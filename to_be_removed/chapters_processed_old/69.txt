69 Klassenhierarchie

Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Kapiteln dieser Kurseinheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht. Sie ist fast immer willkürlich. Im Folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt werden, das ich persönlich eher nicht als Stilfrage einstufen würde, das aber dennoch häufiger in diesem Zusammenhang genannt wird.
Wie bereits in Kurseinheit 6 und teilweise auch schon in Kurseinheit 2, Abschnitt 10.1 bemerkt, ist die Vererbung Aushängeschild und Problemkind der objektorientierten Programmierung zugleich. Es verwundert daher nicht, dass sich eine ganze Menge von Programmierrichtlinien mit genau diesem Thema beschäftigen. Die meines Erachtens gewichtigste aller Regeln zu diesem Thema ist jedoch:
Für JAVA lässt sich diese Regel auch als „deklariere jede Klasse entweder als abstrakt oder als final“ formulieren. Der Grund dafür, dass nur die Blätter der Klassenhierarchie instanziierbar sein sollen, ist einfach: Wenn man mit der Funktionalität einer Klasse bzw. genauer und in diesem Fall wichtig, der Funktionalität der Instanzen einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern. Als Programmiererin möchte man diese Änderung unabhängig von der Frage, ob davon auch andere Klassen betroffen sind, durchführen können. Deswegen wird man die Änderungen auch nur an der Klasse selbst und nicht etwa an einer ihrer Superklassen durchführen. Betrifft der Änderungswunsch eine geerbte Methode, so überschreibt man diese in der betreffenden Klasse nach seinen Vorstellungen. Nur wenn eine eingehende Analyse der Superklasse und all ihrer Subklassen ergibt, dass die gewünschte Änderung für alle sinnvoll ist und den Erwartungen der Klienten entspricht, kann man darüber nachdenken, die Änderung in der Superklasse durchzuführen.
Wenn nun aber die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, dann ist man der Freiheit beraubt, nur für sich zu entscheiden. Von jeder Änderung, die man durchführt, muss man fürchten, dass sie sich auf andere Klassen ausbreitet und den Vertrag dieser Klassen mit ihren Klienten bricht (Siehe auch das Fragile-base-class-Problem in Kapitel 55). Etwas subtiler, aber genau dasselbe Problem, ereilt die Designerin von Klassenbibliotheken, wenn sie beschließt, das Verhalten einer Klasse zu ändern. Selbst wenn sie sich sicher ist, dass dies innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, so kann sie doch nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.
Nun ist aber, wie gerade erst (Kapitel 66) erwähnt, einer der wichtigsten Gedanken der Objektorientierung, existierenden Code, vor allem Bibliotheksklassen, per Vererbung wiederzuverwenden. Wenn die Bibliotheksdesignerin aber alle relevanten Klassen (das sind üblicherweise gerade die konkreten, also die instanziierbaren) final deklariert hat, dann ist das nicht möglich. Eine einfache Konvention erlaubt jedoch, diese Beschränkung zu umgehen: In der Bibliothek wird einfach die Klasse, von der geerbt werden soll, als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die zunächst keine Änderungen (Differenzia) hinzufügt, dafür aber konkret (also instanziierbar) und auch final ist. Sollte die Bibliotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Bibliothek mit den Änderungen beglücken möchte, die Änderungen in der abstrakten Superklasse durchführen. Machen alle Superklassen abstrakt.

Frage: Warum ist die Vererbung ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung?
Antwort: Die Vererbung ist ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung, weil sie einerseits ein mächtiges Konzept zur Wiederverwendung von Code und zur Erstellung von Klassenhierarchien darstellt, andererseits aber auch dazu führen kann, dass Änderungen an einer Klasse sich auf alle davon abgeleiteten Klassen auswirken. Dies kann die Wartbarkeit und Erweiterbarkeit des Codes beeinträchtigen und zu unerwartetem Verhalten führen.

Frage: Was besagt die gewichtigste Regel im Zusammenhang mit Vererbung?
Antwort: Die gewichtigste Regel im Zusammenhang mit Vererbung besagt: "Deklariere jede Klasse entweder als abstrakt oder als final." Das bedeutet, dass Klassen entweder als abstrakt (nicht instanziierbar) oder als final (nicht ableitbar) deklariert werden sollten.

Frage: Warum sollten nur die Blätter der Klassenhierarchie instanziierbar sein?
Antwort: Die Blätter der Klassenhierarchie sollten instanziierbar sein, weil dies sicherstellt, dass Änderungen an einer Klasse nur Auswirkungen auf diese Klasse selbst haben und nicht auf alle davon abgeleiteten Klassen. Wenn eine Klasse in der Hierarchie geändert werden muss, können diese Änderungen in der Klasse selbst oder in ihren Subklassen vorgenommen werden, ohne die anderen Klassen in der Hierarchie zu beeinflussen.

Frage: Warum ist es wichtig, Klassen als abstrakt oder final zu deklarieren, um Änderungen an der Funktionalität der Klasse zu ermöglichen?
Antwort: Das Deklarieren von Klassen als abstrakt oder final ermöglicht es, Änderungen an der Funktionalität der Klasse auf sichere Weise durchzuführen. Wenn eine Klasse als abstrakt deklariert ist, können Änderungen in den abgeleiteten Subklassen vorgenommen werden, ohne die anderen Klassen in der Hierarchie zu beeinflussen. Wenn eine Klasse als final deklariert ist, kann sie nicht abgeleitet werden, was bedeutet, dass ihre Funktionalität nicht geändert werden kann. Dies ermöglicht es, den Vertrag zwischen der Klasse und ihren Klienten zu schützen und unerwartete Verhaltensänderungen zu verhindern.

Frage: Warum ist die Verwendung von abstrakten Klassen in Bibliotheken eine Möglichkeit, die Beschränkungen von finalen Klassen zu umgehen?
Antwort: Die Verwendung von abstrakten Klassen in Bibliotheken ermöglicht es, die Beschränkungen von finalen Klassen zu umgehen, indem sie eine Schicht der Abstraktion hinzufügen. Anstatt eine Klasse als final zu deklarieren, wird sie als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die konkret (instanziierbar) und final ist. Auf diese Weise können Klienten der Bibliothek von der abgeleiteten, finalen Klasse erben und diese verwenden, ohne die ursprüngliche Klasse ändern zu müssen. Wenn Änderungen erforderlich sind, können sie in der finalen Klasse vorgenommen werden, und nur wenn sie für alle Klienten geeignet sind, werden sie in der abstrakten Superklasse durchgeführt. Dies ermöglicht eine gewisse Flexibilität bei der Aktualisierung von Bibliotheken, ohne den Vertrag mit den Klienten zu brechen.