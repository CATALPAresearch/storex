29.3 Parametrischer Polymorphismus und Inklusionspolymorphie

Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).
An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.
Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.
Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumindest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft. Dies verlangt nach Erklärung.
Stellen Sie sich einen Collection-Typ MyCollection vor, dessen Werte solche Collections sein sollen, deren Elemente sortiert und summiert werden können.
Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren lässt, der vom Typ Number oder einem Subtyp davon ist. Man kann daraus schließen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müssen, die einen solchen Wert zurückliefern.
Das aber verlangt, dass der Elementtyp von MyCollection Number oder ein Subtyp davon sein muss, da sonst die Zuweisung an den formalen Blockparameter element nicht zulässig wäre.
Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.
Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicherheit, dass alle Typen, die für E eingesetzt werden können, bestimmte Eigenschaften haben, im gegebenen Beispiel, dass sie sortierbar und addierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, sondern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, nämlich bei der Verwendung (der Instanziierung) der parametrischen Typdefinition in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Polymorphismus, der im nächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.

Frage: Welcher konkrete Typ tritt an die Stelle der Typvariable E bei der Verwendung von Inklusionspolymorphie?
Antwort: Bei der Verwendung von Inklusionspolymorphie tritt der konkrete Typ "Object" an die Stelle der Typvariable E.

Frage: Welche Art von Typfehler kann auftreten, wenn Inklusionspolymorphie verwendet wird?
Antwort: Ein Typfehler kann auftreten, wenn Methoden auf Objekten eines konkreten Subtyps von "Object" aufgerufen werden, da die statische Typprüfung solche Methoden nicht unterstützt.

Frage: Welchen Vorteil bietet der parametrische Polymorphismus gegenüber der Inklusionspolymorphie?
Antwort: Der parametrische Polymorphismus bietet den Vorteil einer erhöhten Typsicherheit, da Typfehler bereits zur Instanziierung des parametrischen Typs erkannt werden können.

Frage: Warum wird in der Praxis trotz Verwendung parametrischer Definitionen von Collections oft auch auf Inklusionspolymorphie zurückgegriffen?
Antwort: In der Praxis wird trotz Verwendung parametrischer Definitionen von Collections oft auf Inklusionspolymorphie zurückgegriffen, da heterogene Collections, die Objekte unterschiedlicher Subtypen enthalten, häufig vorkommen und Inklusionspolymorphie dies ermöglicht.

Frage: Welchen Kompromiss geht man bei der Verwendung parametrischer Typen ein?
Antwort: Bei der Verwendung parametrischer Typen geht man einen Kompromiss ein, bei dem die erhöhte Typsicherheit außerhalb der Typdefinition durch eine geringere Typsicherheit innerhalb der Typdefinition erkauft wird.

Frage: Welche Eigenschaften müssen die Typen haben, die für die Typvariable E eingesetzt werden können, um die Sicherheit zu gewährleisten?
Antwort: Die Typen, die für die Typvariable E eingesetzt werden können, müssen bestimmte Eigenschaften haben, wie z.B. Sortierbarkeit und Addierbarkeit, um die Sicherheit zu gewährleisten.

Frage: Warum ist es wichtig, dass ein Typfehler bereits bei der Verwendung der parametrischen Typdefinition erkannt wird?
Antwort: Es ist wichtig, dass ein Typfehler bereits bei der Verwendung der parametrischen Typdefinition erkannt wird, um sicherzustellen, dass alle eingesetzten Typen die erforderlichen Eigenschaften haben, bevor sie verwendet werden.

Frage: Welche Art von Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen?
Antwort: Der beschränkte parametrische Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen, um Typfehler frühzeitig zu erkennen.