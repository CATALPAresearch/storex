45 Programmieren mit Interfaces

Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem Interface veröffentlichten noch weitere öffentliche (public deklarierte) Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces einer Klasse unterschiedliche Methodenmengen zur Verfügung stellen können. Da auf eine Variable, die mit einem Interfacetyp deklariert wurde, aber immer nur die Methoden aufgerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgreichen Prüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten können), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. So kann beispielsweise ein Ein- und Ausgabestrom als Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben:
Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.
Umgangen werden kann diese Zugriffsbeschränkung über Interfaces in JAVA immer dann, wenn die Klasse, von der das verwendete Objekt eine Instanz ist, ebenfalls als Typ zur Verfügung steht. Man kann in Variablendeklarationen dann genauso gut die Klasse als Typ verwenden. So könnte man sowohl in "WillNurLesen" die Variable "eingabe" als auch in "WillNurSchreiben" die Variable "ausgabe" mit dem Typ "IOStream" deklarieren, hätte damit jedoch keine syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr. C-Sharp geht hier einen Schritt weiter und ermöglicht Klassendefinitionen zumindest, ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen (s. Kurseinheit 5, Abschnitt 50.4.2). Seit JAVA 8 kann man allerdings in Interfaces auch statische Methoden definieren, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff mehr auf die Klassen, die deswegen als package local deklariert und die somit vollständig hinter dem Interface als Schnittstelle verborgen werden können.
Interfaces dienen aber nicht nur der Beschränkung des Zugriffs wie im obigen Beispiel — sie dienen auch der besseren Austauschbarkeit von Klassen. Und das bringt uns zurück zum eingangs in Kapitel 43 benutzten Beispiel (Zeile 1051 ff.): Dadurch, dass die Variable "liste" mit dem Typ "List" (ein Interface) und nicht "ArrayList" (eine Klasse) deklariert wurde, können ihr auch Instanzen anderer Klassen als "ArrayList" zugewiesen werden, solange sie nur dasselbe Interface implementieren. Das Interface als Typ der Variable verlangt lediglich, dass alle in ihm versammelten Methoden von den Objekten, auf die die Variable per Typsystem verweisen darf, auch angeboten werden, und das wird dadurch sichergestellt, dass der Typ der rechten Seite aller Zuweisungen zur Variablen konform zum Typ der linken Seite sein muss. Die Zuweisungskompatibilität ist in JAVA also an die Typkonformität gebunden, und zwar an die nominale.
Eine weitere, vergleichsweise häufig verwendete Möglichkeit des Einsatzes von Interfaces ist die als sog. Tagging oder Marker interfaces. Ein Tagging oder Marker Interface hat in der Regel keine eigenen Methodendeklarationen, sondern dient lediglich der Filterung von Variablenwerten. "Serializable" wäre ein solches Interface. Da in JAVA die vom Compiler statisch geprüfte Zuweisungskompatibilität ja Namenskonformität verlangt, kann die Typisierung einer Variable mit dem Interface "Markiert" erzwingen, dass dieser Variable nur Instanzen solcher Klassen zugewiesen werden, die das Interface "Markiert" zu implementieren deklarieren. Da das Interface aber keine Auflagen macht (keine Methodendeklarationen vorgibt, die von der Klasse mit Definitionen versehen werden müssen), ist die Implementierung des Interfaces für die Klasse zunächst ohne Konsequenzen. Die durch das Interface erfolgte Markierung der Klassen (bzw. deren Instanzen) kann jedoch zur Übersetzungszeit vom Compiler (s. o.) und zur Laufzeit durch einen Typtest (s. Abschnitt 44.2) überprüft werden.
Ein konkretes Beispiel für ein Marker-Interface in JAVA ist das Interface "Serializable", mit dessen Implementierung eine Klasse deklariert, dass ihre Instanzen serialisiert werden können. Die Serialisierung wird aber nicht von der Klasse selbst vorgenommen, sondern von einer anderen; die Klasse muss also zu ihrer Serialisierung nichts weiter beitragen. Seit JAVA 5 würde man allerdings solche Marker-Interfaces eher durch Metadaten (auch Annotationen genannt; s. Abschnitt 47.4) ersetzen, so wie das in C-Sharp schon länger gehandhabt wird (s. Abschnitt 50.4 in Kurseinheit 5). Interfaces erhöhen
JAVAs Interface-als-Typ-Konzept ist ziemlich interessant und vielleicht sogar der größte einzelne Beitrag JAVAs zur objektorientierten Programmierung. In der Programmierpraxis scheint es jedoch, sieht man einmal von großen Frameworks ab, nur langsam anzukommen. Das mag zum einen an der schlechten Verkaufsstrategie liegen („Ersatz für Mehrfachvererbung“ — jede Anfängerin merkt nach fünf Minuten, dass das nicht stimmt), zum anderen aber auch an der Vergrößerung des Programmumfangs, die der parallelen Definition von Klassen und Interfaces geschuldet ist (die auch den Wartungsaufwand erhöhen kann, obwohl ja Interfaces eigentlich die Wartung vereinfachen sollen). Für so manche Programmiererin scheinen die Möglichkeiten, die Schnittstelle einer Klasse mittels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, völlig auszureichen. Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Klienten sowie eine (häufig vorschnelle) Festlegung von Variablen auf Instanzen einer Klasse.

Frage: Welche Vorteile bietet die Verwendung von Interfaces in JAVA?
Antwort: Die Verwendung von Interfaces in JAVA ermöglicht die Bereitstellung verschiedener Sichten auf Objekte, die von Klassen implementiert werden. Dies kann dazu beitragen, den Zugriff auf die Methoden eines Objekts zu beschränken oder die Austauschbarkeit von Klassen zu verbessern.

Frage: Was sind Tagging oder Marker-Interfaces in JAVA und wofür werden sie verwendet?
Antwort: Tagging oder Marker-Interfaces in JAVA sind Schnittstellen, die in der Regel keine eigenen Methoden deklarieren, sondern dazu verwendet werden, Klassen zu markieren oder zu "taggen". Sie dienen der Filterung von Variablenwerten und können beispielsweise dazu verwendet werden, bestimmte Eigenschaften oder Fähigkeiten von Klassen oder Objekten zu kennzeichnen. Ein Beispiel ist das Marker-Interface "Serializable", das angibt, dass Instanzen einer Klasse serialisierbar sind.

Frage: Wie können Interfaces in JAVA dazu beitragen, die Austauschbarkeit von Klassen zu verbessern?
Antwort: Interfaces ermöglichen es, verschiedene Implementierungen eines Interfaces zu verwenden, ohne den zugrunde liegenden Klassentyp zu spezifizieren. Dies verbessert die Austauschbarkeit von Klassen, da verschiedene Klassen, die dasselbe Interface implementieren, in derselben Weise verwendet werden können.

Frage: Welche Rolle spielen Interfaces bei der Einschränkung des Zugriffs auf Methoden in JAVA?
Antwort: Interfaces können dazu verwendet werden, den Zugriff auf Methoden zu beschränken, da nur die im Interface definierten Methoden aufgerufen werden können. Dies ermöglicht es, verschiedene Sichten auf ein Objekt zu gewähren und den Zugriff auf bestimmte Methoden zu kontrollieren.

Frage: Warum werden Marker-Interfaces in JAVA manchmal durch Metadaten (Annotationen) ersetzt?
Antwort: Marker-Interfaces werden in JAVA manchmal durch Metadaten (Annotationen) ersetzt, da Metadaten eine flexiblere Möglichkeit bieten, Informationen über Klassen oder Methoden zu kennzeichnen, ohne zusätzliche Schnittstellen zu definieren. Annotations können zur Laufzeit oder zur Übersetzungszeit gelesen und interpretiert werden, während Marker-Interfaces nur zur Übersetzungszeit überprüft werden können. Dies bietet mehr Flexibilität und ermöglicht es, zusätzliche Informationen zu annotieren, ohne die Klassenhierarchie zu ändern.