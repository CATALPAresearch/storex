paragraph,question,answer
"Übrigens stammt das Prinzip der Generalisierung von Aristoteles' Prinzip von Genus et differentia ab, das gemeinsame Abstammung und Unterschiede betrifft. Das Genus ist die nächst allgemeinere Kategorie, unter die die Objekte der zu generalisierenden Klassen (der Spezies) fallen, und die Differentia sind die Kriterien, anhand derer sich die Objekte aufgrund ihrer Natur unterscheiden, wie sie in den verschiedenen Klassendefinitionen festgelegt sind (und nicht etwa durch spezielle Werte von Instanzvariablen). So haben die Klassen Mensch und Vogel beispielsweise das gemeinsame Genus Zweibeiner als (biologisch nicht ganz korrekte) Generalisierung, in der festgelegt ist, dass alle Exemplare von Zweibeinern (und damit auch von Menschen und Vögeln) ein linkes und ein rechtes Bein sowie einen Aufenthaltsort haben. Die Unterschiede (Differentia) sind dann in den jeweiligen Klassen ausgearbeitet. Beachten Sie, dass Genera keine eigenen Individuen haben, das heißt, es gibt keine Zweibeiner, die nicht entweder Mensch oder Vogel sind.",Was ist das Prinzip der Generalisierung?,"Das Prinzip der Generalisierung ist ein Konzept, das auf Aristoteles' Prinzip von Genus et differentia zurückgeht. Dabei werden gemeinsame Abstammungen und Unterschiede betrachtet. Das Genus ist die nächst allgemeinere Kategorie, unter die die Objekte der zu generalisierenden Klassen (der Spezies) fallen. Die Differentia sind die Kriterien, anhand derer sich die Objekte aufgrund ihrer Natur unterscheiden, wie sie in den verschiedenen Klassendefinitionen festgelegt sind. Genera haben keine eigenen Individuen, das heißt, es gibt keine Zweibeiner, die nicht entweder Mensch oder Vogel sind."
"In SMALLTALK muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. So kann also insbesondere self nicht (wie beispielsweise this in Java) weggelassen werden, wenn ein Objekt eine Nachricht an sich selbst senden möchte. Wie bereits in Abschnitt 4.3.1 erwähnt, bezeichnet die Pseudovariable self immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind. (Die einzige Ausnahme hiervon bilden Blöcke, in denen self sich auf den Empfänger des Home-Kontexts bezieht; siehe Abschnitt 4.4.1 in Kurseinheit 1).",Was ist die Rolle von self in Smalltalk?,"In Smalltalk muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. self bezeichnet immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind."
,Warum muss man bei der Verarbeitung von relationalen Daten durch objektorientierte Programme oft Prinzipien der relationalen Welt anpassen?,"Bei der Verarbeitung von relationalen Daten durch objektorientierte Programme muss man sich an die Prinzipien der relationalen Welt anpassen, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Dies erfordert häufig, einen Teil dessen, was Objektorientierung ausmacht, aufzugeben."
,"Was ist das Problem, das im Zusammenhang mit Subtyping und dynamischem Methodenaufruf auftritt?","Das Problem besteht darin, dass aufgrund des dynamischen Bindens von Methodenaufrufen nicht vorhergesagt werden kann, welchen Effekt ein Aufruf der Methode in einem bestimmten Programmfragment haben wird, selbst wenn der Typ des Empfängerobjekts bekannt ist. Es ist schwer zu bestimmen, welcher Subtyp des Typs des Empfängerobjekts tatsächlich betroffen ist."
"Nun kommen in Protokollen aber selbst Variablen vor, nämlich die formalen Parameter der Methoden, die das Protokoll ausmachen. Außerdem ist eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Objekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle definieren also nicht nur Typen, sie verwenden auch selbst welche, nämlich indem sie die Typen der Ein- und Ausgabeobjekte spezifizieren. Ein einfaches Beispiel für eine Typdefinition, die selbst Typen verwendet, ist die folgende:",Was sind formale Parameter von Methoden in Protokollen?,"Formale Parameter von Methoden sind Variablen, die das Protokoll ausmachen."
"BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.",Wie wirkt sich das Umbenennen von geerbten Features auf das dynamische Binden in Eiffel aus?,"Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei."
"Eine weitere nützliche Collection-Klasse wird durch SortedCollection implementiert. Es handelt sich dabei um eine Subklasse von OrderedCollection, bei der die Reihenfolge der Elemente nicht von außen, also durch die Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt wird, sondern von innen, genauer durch eine Qualität der eingefügten Objekte. Zwischenobjekte der Klasse SortedCollection setzt man ein, wenn man die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge haben möchte, wie z. B. die Kinder einer Person in der Namensfolge, und zwar unabhängig davon, in welcher Reihenfolge sie der Collection hinzugefügt wurden. Voraussetzung dafür, dass die Elemente einer SortedCollection sortiert werden können, ist, dass sie verglichen werden können, dass also die (binäre) Methode <= (für kleiner gleich) darauf definiert ist. So liefert beispielsweise mit #(1 2 3) das gewünschte Ergebnis.",Wozu dient die Klasse SortedCollection?,"Die Klasse SortedCollection wird verwendet, um eine Collection von Objekten in einer bestimmten Reihenfolge zu halten, die durch eine Qualität der Objekte bestimmt wird. Die Objekte müssen vergleichbar sein, d.h. die binäre Methode <= muss auf sie anwendbar sein."
,Was ermöglicht Mehrfachvererbung in C++?,"Mehrfachvererbung in C++ ermöglicht es, eine Klasse von mehreren anderen abzuleiten. Dadurch kann eine Klasse mehrere direkte Supertypen haben, einen pro direkte Superklasse."
,Wie wird in Java zwischen Gleichheit und Identität von Objekten unterschieden?,"In Java wird zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) geprüft, während die Identität mittels == (bzw. !=) überprüft wird."
"In Java gibt es Literale für Zahlen, Zeichen und Strings. Für Arrays gibt es, da sie nicht aus Literalen zusammengesetzt sein müssen, etwas Ähnliches, nämlich die sogenannten Array-Initialisierer; sie werden in Kapitel 41 behandelt. Ob ""true"" und ""false"" bzw. ""null"" in Java Literale oder Schlüsselwörter sind, hängt vom Standpunkt ab: Die meisten Syntaxeditoren behandeln sie wie Schlüsselwörter, gemäß der Sprachdefinition handelt es sich jedoch um Literale, die die beiden booleschen Wahrheitswerte ""wahr"" und ""falsch"" bzw. den Wert des Nulltypen (UndefinedObject in SMALLTALK, in Java umbenannt) repräsentieren.",Was sind Array-Initialisierer in Java und wofür werden sie verwendet?,"Array-Initialisierer in Java sind eine Möglichkeit, Arrays mit Werten zu initialisieren. Sie werden verwendet, um die Elemente eines Arrays bei der Erstellung des Arrays zu initialisieren. Die Elemente werden in geschweiften Klammern ({}) aufgelistet, getrennt durch Kommas. Zum Beispiel: int[] arr = {1, 2, 3}; erstellt ein Array von ganzen Zahlen mit den Werten 1, 2 und 3."
"Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.",Wie werden Informationen in der objektorientierten Programmierung in Smalltalk dargestellt?,"In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt, das navigiert und manipuliert werden kann."
"Es ist wichtig zu beachten, dass es sich bei den entsprechenden Instanzen prinzipiell um eigenständige Objekte handelt, die hier lediglich die Funktion eines Zwischenobjektes haben, um die Beziehungen zu realisieren. Subklassen von Collection müssen also die Methoden add: und remove:ifAbsent: überschreiben. Dabei offenbart sich gleich ein Charakterzug von SMALLTALK: Da seine Klassenhierarchie keine Generalisierungshierarchie ist, kommt es vor, dass Subklassen die Methoden add:, remove: und remove:ifAbsent: löschen. Während beispielsweise in der Klasse OrderedCollection add: und remove:ifAbsent: überschrieben werden, werden sie in der Klasse FixedSizeCollection, die ebenfalls eine Subklasse von Collection ist, gelöscht.","Was ist der Charakterzug von SMALLTALK, der sich in der Klassenhierarchie zeigt?","Der Charakterzug von SMALLTALK ist, dass seine Klassenhierarchie keine Generalisierungshierarchie ist. Das bedeutet, dass Subklassen die Methoden add:, remove: und remove:ifAbsent: löschen können, obwohl sie in der Oberklasse Collection definiert sind."
"Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.","Warum kann es bei der Betrachtung der Aufrufstelle interessant sein, was in der aufgerufenen Methode passiert ist?","Es kann interessant sein, weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann und mehr Informationen über die Abläufe in der aufgerufenen Methode benötigt."
"Sicher ist Ihnen aufgefallen, dass uns bislang keine Schlüsselwörter in SMALLTALK begegnet sind (bis auf die sog. Schlüsselwortnachrichten, die aber frei wählbar sind und deswegen eben gerade keine Schlüsselwörter sind). Der Grund hierfür ist einfach: Es gibt keine Schlüsselwörter, lediglich ein paar Symbole mit spezieller Bedeutung. Es sind dies:Zuweisung, Trennzeichen zwischen zwei Anweisungen sowie Dezimalpunkt für Gleitkommazahlen, Trennzeichen zum Kaskadieren von Nachrichten, Markierung von Parametern in Nachrichten und Blöcken, Klammerung von Ausdrücken zur Festlegung der Reihenfolge der Auswertung, Bildung von Blöcken, Trennzeichen zwischen den Parametern eines Blocks und seinen Anweisungen, Markierung von Kommentaren, Markierung von String-Literalen, Markierung von Zeichenliteralen, Markierung von Symbol- und Array-Literalen, Rückgabe-Operator (Return)Das ist alles! Die reservierten Namen true, false, nil, self und super sind die von Pseudovariablen; alle aus anderen Sprachen bekannten Schlüsselwörter sind als Methoden in SMALLTALK selbst definiert.",Warum gibt es in SMALLTALK keine Schlüsselwörter?,"In SMALLTALK gibt es keine Schlüsselwörter, sondern nur Symbole mit spezieller Bedeutung. Stattdessen sind alle aus anderen Sprachen bekannten Schlüsselwörter in SMALLTALK als Methoden implementiert."
"Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.","Wie kann man sich den Variableninhalt ansehen, wenn man nicht weiß, an welcher Stelle man schauen muss?","In der Praxis bleibt nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen."
"Während ein Programmabbruch wenigstens noch eine erkennbare Reaktion auf einen Programmierfehler darstellt, ist es fast noch schlimmer, wenn ein logischer Fehler ohne solche bleibt. So kann es beispielsweise vorkommen, dass man einer Variable, deren Inhalt eine Strecke darstellen soll, eine andere zuweist, deren Inhalt eine Zeit repräsentiert. Mit beiden ließe sich gleich rechnen (dieselben Rechenoperationen durchführen), aber das Ergebnis wäre vermutlich falsch. Merken muss man das allerdings selbst, denn das Programm läuft einfach weiter.",Was sind die Folgen eines logischen Fehlers in einem Programm?,"Ein logischer Fehler in einem Programm kann dazu führen, dass das Programm weiterläuft, aber das Ergebnis falsch ist. Es ist schwieriger zu erkennen als ein Programmabbruch, da keine erkennbare Reaktion auf einen Programmierfehler stattfindet."
"Man beachte, dass Vererbung tatsächlich eine Kopieren-und-Einfügen-Semantik hat, wie in Abschnitt 11.2 bereits nahegelegt: Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.",Wie funktioniert die Vererbung in SMALLTALK?,"In SMALLTALK hat Vererbung eine Kopieren-und-Einfügen-Semantik, d.h. wenn man die Implementierung einer Methode aus der Superklasse in die Subklasse wiederholt, erhält man das gleiche Ergebnis."
,Warum sind die Methoden in objektorientierten Programmen im Durchschnitt ziemlich kurz?,"Die Methoden in objektorientierten Programmen sind im Durchschnitt ziemlich kurz, weil in der objektorientierten Programmierung die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Wenn eine Funktion verschiedene Arten von Daten manipuliert, wird die Funktionalität wahrscheinlich nicht vollständig in einer Methode implementiert."
"Ein Operator, der speziell für Referenztypen in Java zur Verfügung steht, ist der Typtest ""instanceof"". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist. Dabei wird nicht zwischen direkten und indirekten Instanzen unterschieden. Zum Beispiel ergibt ""x instanceof Object"" immer ""true"", unabhängig davon, für welches Objekt ""x"" steht. Weitere Informationen zur Bedeutung des Typtests finden Sie in Kapitel 44.","Was kann der Typtest ""instanceof"" in Java?","Der Typtest ""instanceof"" in Java ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist, unabhängig davon, ob es sich um eine direkte oder indirekte Instanz handelt. Zum Beispiel ergibt ""x instanceof Object"" immer ""true"", unabhängig davon, für welches Objekt ""x"" steht."
"Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark an die der englischen Sprache angelehnt ist. Sie verlangt ein Subjekt (den Empfänger der Nachricht), ein Prädikat (die Nachricht) sowie eine optionale Liste von Objekten als Prädikatsergänzungen (die Parameter der Nachricht). Dabei wird auf die in anderen Sprachen übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und Klammern zum Umschließen der Parameterliste verzichtet. Stattdessen verwendet man bei Zustandswechsel von zwei oder mehr Parametern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nachrichtenteile, die den Parametern vorangestellt werden. Ein Parameter kann auch eine Variable sein oder ein anderer Ausdruck.In SMALLTALK werden parameterlose Nachrichten auch als ""unär"" (unary messages) bezeichnet, da sie trotz fehlender expliziter Argumente als ""unär"" bezeichnet werden, weil der Empfänger das erste, implizite Argument ist. Nachrichten mit einem Parameter werden als ""binäre Nachrichten"" (binary messages) bezeichnet, da sie nur einen Parameter haben, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.Binäre Nachrichten bestehen aus einem oder mehreren nicht alphanumerischen Zeichen, die keine reservierten Zeichen sind. Alle anderen Nachrichten, die neben dem Empfänger mindestens ein Argument erfordern, werden in SMALLTALK Schlüsselwortnachrichten (keyword messages) genannt. Diese Nachrichten enthalten normalerweise keinen Schlüsselwort im herkömmlichen Sinne, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.",Welche Ausdrucksform ist neben der Zuweisung wichtig?,Neben der Zuweisung ist der Nachrichtenversand eine wichtige Ausdrucksform.
"Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.",Was ist die private Schnittstelle eines Moduls?,"Die private Schnittstelle eines Moduls besteht aus allen Deklarationen, die nicht Teil der öffentlichen Schnittstelle sind."
"Welche Bedingungen sind an die Parametertypen bei der Redefinition zu stellen, damit eine Zuweisung eines Objekts vom Typ B an eine Variable vom Typ A in der Folge zu keiner Verletzung einer (anderen) Typinvariante führt? Die Antwort lässt sich systematisch herleiten. Es ergibt sich, dass sich bei einer Redefinition einer Methode die Eingabeparametertypen einer Funktion nur „nach oben“ (also zu einem Supertypen hin), die Ausgabeparameter hingegen nur „nach unten“ (hin zu einem Subtyp) verändern dürfen, wenn die Typkorrektheit eines Programms nicht verletzt werden soll.",Was passiert bei der Redefinition einer Methode mit den Eingabe- und Ausgabeparametern?,"Bei der Redefinition einer Methode dürfen sich die Eingabeparameter nur zu einem Supertypen ändern, während die Ausgabeparameter nur zu einem Subtyp geändert werden dürfen, um die Typkorrektheit des Programms zu gewährleisten."
"Nun kann man sich vorstellen, dass es für einen Compiler selbst in einfachen Fällen nicht leicht ist, festzustellen, ob eine Wertzuweisung eine Invariante verletzt und somit zu einem typinkorrekten Programm führt. So ist das folgende STRONGTALK-Programmfragment das zunächst eine temporäre Variable i mit dem Typ Integer (in STRONGTALK wird die Typannotation hinter der Variable in spitzen Klammern angeführt) deklariert und ihr dann, in einer Folge von Anweisungen, zunächst 0 und dann 1 (beides Werte vom Typ Integer) zuweist, zwar typkorrekt im Sinne obiger Definition, aber um das zu erschließen, muss man schon wissen, dass die Bedingung in Zeile 835 immer erfüllt ist, der False-Zweig, der zu einer Verletzung der Invariante von i (nämlich dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen) führen würde, also nie ausgeführt wird. Im gegebenen Fall ist das zwar offensichtlich (und bereits von einer recht einfachen Programmanalyse feststellbar), aber es lassen sich auch Fälle konstruieren, in denen eine automatische Programmanalyse streiken muss.",Was ist eine Invariante?,"Eine Invariante ist eine Bedingung, die während der Ausführung eines Programms immer erfüllt sein muss. Im gegebenen Beispiel ist die Invariante von i, dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen."
,"Wie kann ein Objekt verbergen, welche Objekte es kennt?",Es kann dies über lokale Instanzvariablen tun.
,"Was ist ""Call by reference"" in C-Sharp, und wie unterscheidet es sich von ""Call by value""?","In C-Sharp ermöglicht ""Call by reference"" (auch als ""ref"" und ""out"" bekannt) das Übergeben von Argumenten an Methoden, bei denen die Änderungen an den Parametern innerhalb der Methode auf die ursprünglichen Argumente außerhalb der Methode angewendet werden. Im Gegensatz dazu verwendet ""Call by value"" Kopien der Argumente, und Änderungen innerhalb der Methode haben keine Auswirkungen auf die ursprünglichen Argumente."
"Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in Java über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C-Sharp über Funktionszeiger (Delegates in C-Sharp). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JavaSCRIPT seit Jahren einen heimlichen Siegeszug feiert).",Warum können in objektorientierter Programmierung nicht für verschiedene Instanzen einer Klasse verschiedene Implementierungen einer Methode angegeben werden?,"In objektorientierter Programmierung können für verschiedene Instanzen einer Klasse nicht verschiedene Implementierungen einer Methode angegeben werden, weil alle Instanzen einer Klasse dieselben Methoden teilen. Um dieses Problem zu lösen, können Indirektionen eingebaut werden, wie zum Beispiel in Smalltalk über einen Block, in Java über anonyme innere Klassen, in C++ und C-Sharp über Funktionszeiger (Delegates in C-Sharp). Eine bessere Eignung scheint hier die prototypenbasierte Variante der objektorientierten Programmierung zu haben, wie sie in JavaScript seit Jahren erfolgreich eingesetzt wird."
,Welche Unterschiede gibt es zwischen SMALLTALK und den meisten anderen objektorientierten Programmiersprachen in Bezug auf die Typisierung?,"Im Gegensatz zu SMALLTALK sind die meisten anderen objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration Typen zugeordnet werden. In SMALLTALK wird die Typisierung in der Regel erst zur Laufzeit überprüft, während in anderen Sprachen dies bereits zur Übersetzungszeit geschieht."
"Sinn und Zweck des Gesetzes Demeters ist, die Kopplung und damit die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wird das Gesetz Demeters verletzt, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen (sondern eben nur in einer mittelbaren, die nach dem Gesetz vermieden werden soll).",Was ist das Ziel des Gesetzes Demeters?,"Das Ziel des Gesetzes Demeters ist es, die Kopplung und damit die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wenn das Gesetz Demeters verletzt wird, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen."
,"Wie können Typ-Wildcards in Java dazu verwendet werden, eine Liste von Zahlen oder Untertypen von ""Number"" zu verarbeiten?","Typ-Wildcards können verwendet werden, um eine Methode wie ""sum(List<? extends Number> list)"" zu erstellen, die eine Liste von Zahlen oder Untertypen von ""Number"" akzeptiert und die Summe der Zahlen berechnet, unabhängig von ihrem konkreten Typ."
"Beim Entfernen eines Objektes aus einer Collection mittels remove: gibt es zwei Sonderfälle zu berücksichtigen: Das Objekt ist nicht vorhanden oder das Objekt ist mehrfach vorhanden. Im ersten Fall wird ein Fehler gemeldet, während im zweiten Fall nur ein Vorkommen des Objekts aus der Collection entfernt wird (das erste, wie auch immer die Reihenfolge festgelegt ist). Da es immer vorkommen kann, dass ein zu entfernendes Objekt gar nicht vorhanden ist, und ein entsprechender vorheriger Test auf Vorhandensein (siehe unten) wieder eine stereotype Handlung ist, bietet SMALLTALK eine Variante von remove:, die einem genau das erspart: remove: anObject ifAbsent: anExceptionBlock. Sollte das zu entfernende Objekt fehlen, wird stattdessen anExceptionBlock ausgeführt, und dessen Ergebnis wird zurückgeliefert. Will man, dass beim Versuch, ein nicht vorhandenes Objekt zu entfernen, nichts passiert, so gibt man einfach den leeren Block [] für anExceptionBlock an. Sollen mehrere Objekte auf einmal einer Beziehung hinzugefügt bzw. daraus entfernt werden, so stehen hierfür die Methoden addAll: aCollection bzw. removeAll: aCollection zur Verfügung, die jeweils eine Collection als Parameter erwarten.","Was passiert, wenn man versucht, ein nicht vorhandenes Objekt aus einer Collection zu entfernen?","Wenn man versucht, ein nicht vorhandenes Objekt aus einer Collection zu entfernen, wird ein Fehler gemeldet."
"SMALLTALK stammt aus einer Zeit, in der man noch relativ wenig praktische Erfahrung mit objektorientierter Programmierung gesammelt hatte. Damals war man der Ansicht, dass einer der Hauptvorteile der objektorientierten Programmierung die Wiederverwendung von Code durch Vererbung sei. Wie in Abschnitt 10.1 dargelegt, hat die Vererbung etwas mit der auf Generalisierung bzw. Spezialisierung beruhenden Abstraktionshierarchie zu tun: Der allgemeinere Begriff (die Superklasse) überträgt (vererbt) alle seine Eigenschaften auf die spezielleren Begriffe (Subklassen), und der speziellere erbt sie von den allgemeineren. Dies liegt in der Natur der Sache. Problematisch wird es jedoch, sobald man den kausalen Zusammenhang umkehren und von einer möglichen Vererbung auf eine Generalisierung/Spezialisierung schließen will: Nur weil eine Klasse (zufällig) Eigenschaften einer anderen geerbt haben könnte, heißt das noch lange nicht, dass die erbende Klasse auch eine Spezialisierung der vererbenden ist. Ein klassisches Beispiel hierzu hatten wir bereits mit der Ableitung der Klasse Rechteck von der Klasse Quadrat kennengelernt; den unangenehmen Folgen solch vererbungsorientierter Vorgehensweisen werden wir in der nächsten Kurseinheit noch begegnen.",Was ist die Problematik bei der Vererbung in SMALLTALK?,"Die Problematik bei der Vererbung in SMALLTALK ist, dass man davon ausgeht, dass Vererbung etwas mit der auf Generalisierung bzw. Spezialisierung beruhenden Abstraktionshierarchie zu tun hat. Dies ist jedoch nicht immer der Fall, wie das Beispiel der Ableitung der Klasse Rechteck von der Klasse Quadrat zeigt. Diese vererbungsorientierte Vorgehensweise kann zu unangenehmen Folgen führen."
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen eines Programms, da diese erst zur Laufzeit des Programms ausgeführt werden. Wohlgemerkt: Literale repräsentieren Objekte, es sind nicht selbst welche.",Was unterscheidet Literale und objekterzeugende Anweisungen?,"Der Compiler erzeugt bei der Übersetzung eines Literals das entsprechende Objekt im Speicher, während objekterzeugende Anweisungen erst zur Laufzeit des Programms ausgeführt werden."
"So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.",Was sind die Nachteile der objektorientierten Programmierung?,"Die Nachteile der objektorientierten Programmierung sind, dass die Organisation der Funktionen auf der Strecke bleibt und dass die Daten hin- und hergeschickt werden müssen."
"Um auszudrücken, dass eine Sequenz von Ausdrücken ein Block ist, wird die Sequenz mit eckigen Klammern markiert. Die Variablen ""x"" und ""y"" seien außerhalb des Blocks im Kontext des Blocks deklariert. Der Kontext des Blocks ist die Methode, in der er definiert wurde.Bei der Ausführung des obigen Blocks wird ein neues Blockobjekt erzeugt. Die Anweisungen, die den Block ausmachen, werden dabei nicht ausgeführt, selbst dann nicht, wenn der Block isoliert steht und ausgeführt wird (das dabei erzeugte Objekt bleibt namenlos und wird von der Speicherbereinigung wieder entfernt).Um die Anweisungen, die einen Block ausmachen, zur Ausführung zu bringen, muss man ihn auswerten. Dazu schickt man ihm die Nachricht ""value"". Der Ausdruck ""swap value"" bewirkt, dass die Variablen ""x"" und ""y"" aus dem Kontext des Blocks ihren Wert tauschen. Das Objekt, zu dem ""swap value"" ausgewertet wird, ist das Objekt, zu dem die letzte Anweisung auswertet. Der Rückgabewert der Methode ""value"" ist zunächst immer das Objekt, zu dem der letzte Ausdruck eines Blocks auswertet, im obigen Beispiel also das durch ""temp"" benannte Objekt.",Wie werden Blöcke in SMALLTALK ausgeführt?,Bei der Ausführung des Blockausdrucks wird ein neues Blockobjekt erzeugt.
,"Welches Refactoring-Verfahren wird häufig angewendet, um Teile einer Methode in separate Methoden auszulagern?","Das ""Extract-method""-Refactoring-Verfahren wird häufig angewendet, um Teile einer Methode in separate Methoden auszulagern. Dieses Verfahren ermöglicht es, Teile des Codes in neue Methoden auszulagern, selbst wenn diese Teile vorerst nur von ihrer ursprünglichen Position aus aufgerufen werden, um die Lesbarkeit zu verbessern. Es handelt sich um eine gängige Praxis in der objektorientierten Programmierung."
,Gibt es eine Namenskonvention für Interfaces in C-Sharp?,"Ja, im Common Type System von .NET sollten alle Interfacenamen mit einem ""I"" beginnen. Dies dient zur Unterscheidung von Interface- und Klassennamen und folgt der Tradition der ungarischen Notation bei Microsoft."
,Was ist Kovarianz?,"Kovarianz tritt auf, wenn der Rückgabetyp einer Methode in einem Subtyp ein Subtyp des Rückgabetyps in einem Supertyp ist. Dies bedeutet, dass der Subtyp mehr Werte zurückgeben kann als der Supertyp."
"Die Klasse Object definiert die Eigenschaften, die allen Objekten, einschließlich Array-Objekten, gemeinsam sind. Hierbei handelt es sich nicht um Felder (Instanzvariablen), sondern um elf Methoden. Diese sind: Object clone(): Zum Erzeugen von Kopien (vergleichbar mit SMALLTALK's copy). boolean equals(Object): Zum Test auf Gleichheit anstelle von Identität (entsprechend SMALLTALK's =). String toString(): Gibt eine String-Repräsentation des Objekts zurück (entsprechend SMALLTALK's printString). Class<? extends Object> getClass(): Zur Ermittlung des Klassentyps (entsprechend SMALLTALK's class). int hashCode(): Zur Speicherung von Objekten in Hash-Tabellen (entsprechend SMALLTALK's hash). void finalize(): Wird vom Garbage Collector aufgerufen, wenn das Objekt aus dem Speicher entfernt wird (dies ermöglicht das Freigeben von externen Ressourcen, die mit dem Objekt verbunden sind, wie z. B. das Schließen von Dateien). void notify() und void notifyAll(): Zur Benachrichtigung von Threads, die auf den Monitor des Objekts warten. void wait(): In drei Versionen, um den ausführenden Thread zum Warten zu bringen, entweder bis dem Objekt ein Notify gesendet wird oder ein anderes Ereignis eintritt.","Was sind die Methoden, die in der Klasse Object definiert sind?","Die Klasse Object definiert die Methoden clone(), equals(Object), toString(), getClass(), hashCode(), finalize(), notify(), notifyAll() und wait()."
"Genau wie in SMALLTALK werden in Java Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Anders als in SMALLTALK gibt es in Java jedoch eine Vielzahl von Schlüsselwörtern, die Anweisungen einleiten. Dennoch ist es auch in Java möglich, bestimmte Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden Ausdruck durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen (siehe Kapitel 37) direkt zu Anweisungen. Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK, das Semikolon in Java kein Trennzeichen ist, sondern Teil der Anweisung.",Wie werden Ausdrücke in Java zu Anweisungen?,"In Java können bestimmte Ausdrücke zu Anweisungen gemacht werden, indem sie durch ein Semikolon abgeschlossen werden. Dazu gehören Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen."
"Javas Interface-als-Typ-Konzept ist ziemlich interessant und vielleicht sogar der größte einzelne Beitrag Javas zur objektorientierten Programmierung. In der Programmierpraxis scheint es jedoch, sieht man einmal von großen Frameworks ab, nur langsam anzukommen. Das mag zum einen an der schlechten Verkaufsstrategie liegen („Ersatz für Mehrfachvererbung“ — jede Anfängerin merkt nach fünf Minuten, dass das nicht stimmt), zum anderen aber auch an der Vergrößerung des Programmumfangs, die der parallelen Definition von Klassen und Interfaces geschuldet ist (die auch den Wartungsaufwand erhöhen kann, obwohl ja Interfaces eigentlich die Wartung vereinfachen sollen). Für so manche Programmiererin scheinen die Möglichkeiten, die Schnittstelle einer Klasse mittels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, völlig auszureichen. Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Klienten sowie eine (häufig vorschnelle) Festlegung von Variablen auf Instanzen einer Klasse.",Warum wird das Interface-als-Typ-Konzept in Java nur langsam angenommen?,"Javas Interface-als-Typ-Konzept wird nur langsam angenommen, weil die Verkaufsstrategie schlecht ist und es den Programmumfang erhöht, was auch den Wartungsaufwand erhöhen kann. Einige Programmiererinnen scheinen die Möglichkeiten, die Schnittstelle einer Klasse mittels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, auszureichen. Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Klienten sowie eine (häufig vorschnelle) Festlegung von Variablen auf Instanzen einer Klasse."
"Während Java als Programmiersprache anfangs noch recht klein und überschaubar war (zumindest im Vergleich zu C++, einem ihrer Hauptkonkurrenten), so ist die Sprachdefinition heute ein Moloch. Mit dem wachsenden Nutzerkreis sind auch die Anforderungen an die Sprache gewachsen, und mit dem Java Community Process wurde aktiven Entwicklern die Möglichkeit eingeräumt, Vorschläge zur Spracherweiterung zu machen. Dabei ist jedoch - aufgrund der mittlerweile riesigen Menge an Software, die in Java geschrieben ist - stets auf Rückwärtskompatibilität zu achten, so dass revolutionäre Verbesserungen kaum möglich sind; stattdessen wird hinzugefügt. Das unterliegende Programmiermodell ist so immer dasselbe geblieben - und wird es wohl auch immer bleiben.",Was ist der Java Community Process?,"Der Java Community Process ist ein Prozess, bei dem aktiven Entwicklern die Möglichkeit eingeräumt wird, Vorschläge zur Spracherweiterung von Java zu machen. Dabei ist jedoch auf Rückwärtskompatibilität zu achten, um die riesige Menge an Software, die in Java geschrieben ist, nicht zu beeinträchtigen."
"Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls gefeierte Vererbung die Kapselung von Klassen auf unangenehme Weise aufbrach: Wie in Kapitel 55 bemerkt, erzeugt die Vererbung starke Abhängigkeiten (auch zwischen den Implementierungsdetails!) von Klassen und ihren Subklassen. Diese Abhängigkeiten explizit zu machen kann zwar vor Programmierfehlern schützen, sie kann aber die Abhängigkeiten nicht beseitigen, sondern lediglich dokumentieren. Die Abhängigkeiten zu beschränken bedeutet wiederum, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das nun einmal: Alles hat seinen Preis.",Was sind die Nachteile der Vererbung in objektorientierter Programmierung?,"Die Vererbung in objektorientierter Programmierung kann die Kapselung von Klassen auf unangenehme Weise aufbrechen und starke Abhängigkeiten zwischen Klassen und ihren Subklassen erzeugen. Diese Abhängigkeiten explizit zu machen, kann zwar vor Programmierfehlern schützen, aber sie nicht beseitigen. Die Abhängigkeiten zu beschränken, bedeutet, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben."
"Variablen werden in Java genauso wie in SMALLTALK explizit per Zuweisungsoperator ""="" und implizit per Methodenaufruf Werte zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten.",Was ist der Unterschied zwischen Zuweisungen an Variablen primitiver Typen und solchen anderer Typen in Java?,"Bei Zuweisungen an Variablen primitiver Typen wird der Wert selbst kopiert, während bei Zuweisungen an Variablen anderer Typen eine Referenz auf das Objekt kopiert wird."
"In der objektorientierten Programmierung nennt man nicht instanziierbare Klassen abstrakt. Der Grund für die mangelnde Instanziierbarkeit ist nicht immer konzeptuell (wie beispielsweise das Prinzip, dass eine Klasse eine Generalisierung ist und daher nicht instanziierbar sein sollte), sondern oft rein technisch. Abstrakten Klassen fehlen in der Regel Angaben, die das Verhalten ihrer Instanzen vollständig spezifizieren und diese somit brauchbar machen würden. Instanzen dieser Klassen wären unvollständig definiert und würden zu Laufzeitfehlern führen. Diese fehlenden Eigenschaften werden in den Klassen geliefert, die von den abstrakten erben (siehe nächstes Kapitel), wobei die Idee ist, dass sich die Eigenschaften von Klasse zu Klasse unterscheiden. Klassen, die nicht abstrakt sind und eigene Instanzen haben können, nennt man konkret. Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse Collection.",Was ist der Unterschied zwischen abstrakten und konkreten Klassen?,"Abstrakte Klassen sind nicht instanziierbar, da sie in der Regel Angaben fehlen, die das Verhalten ihrer Instanzen vollständig spezifizieren. Konkrete Klassen hingegen haben eigene Instanzen und können instanziiert werden."
,Welche Arten von Vererbung erlaubt EIFFEL?,"EIFFEL erlaubt Mehrfachvererbung, was bedeutet, dass eine Klasse von mehreren anderen Klassen erben kann."
"Nun ist es zwar möglich, Objekte mithilfe der Teil-Ganzes-Beziehung rekursiv aufzubauen (und im oben diskutierten Rahmen auch zu kapseln, also Teile vollständig hinter Ganzen zu verbergen), aber für Klassen gilt das nicht. Zwar ist es hier möglich, über sogenannte innere Klassen (in Java) Klassen zu strukturieren, aber allein schon die Tatsache, wie relativ wenig davon Gebrauch gemacht wird, zeigt, dass es sich dabei um keinen besonders nützlichen Mechanismus handelt.93 Tatsächlich ist es nämlich — wie schon in Kapitel 58 angesprochen — so, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind (und schon gar nicht immer der gleichen Klasse), sondern vielmehr einzelne Exemplare (Instanzen) Teil sein und vielleicht sogar selbst Teile haben können. Man kann also die hierarchische Struktur objektorientierter Systeme genauso wenig auf Klassenebene vorschreiben, wie man den Aufbau einer Maschine anhand lediglich der Typen ihrer Teile (Schrauben etc.) beschreiben könnte (ohne festzulegen, wo jede einzelne Instanz genau hingehört). Was man vielmehr bräuchte, sind Komponenten als zusätzliches, von Klassen und Objekten verschiedenes Programmiersprachenkonstrukt.",Wie können Objekte in objektorientierten Systemen strukturiert werden?,"Objekte können in objektorientierten Systemen mithilfe der Teil-Ganzes-Beziehung rekursiv aufgebaut werden, wobei Teile hinter Ganzen verbergen können. Für Klassen gilt das nicht, da Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind. Stattdessen können Objekte einzelne Exemplare (Instanzen) sein, die Teile haben können. Komponenten als zusätzliches Programmiersprachenkonstrukt können hierbei helfen, die Struktur von objektorientierten Systemen zu beschreiben."
,"Welche Möglichkeiten gibt es, den Mechanismus der Vererbung von Superklassen auf Subklassen umzusetzen?","Es gibt verschiedene Möglichkeiten, den Mechanismus der Vererbung von Superklassen auf Subklassen umzusetzen. Zwei dieser Möglichkeiten wurden im Text angedeutet: Kopieren und Einfügen: Eine Möglichkeit wäre, die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Dies würde die Semantik der Vererbung korrekt wiedergeben, aber bei Änderungen an der Superklasse müssten auch alle Subklassen aktualisiert werden, was technisch problematisch wäre. Automatische Instanzerzeugung: Eine andere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch Instanzen aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Dies würde jedoch das Konzept der Identität von Objekten beeinträchtigen, da Objekte einer Subklasse mehrere Identitäten hätten."
"In einem objektorientierten Programm repräsentieren Objekte nicht nur Literale und Variablen, sondern auch Ausdrücke. Tatsächlich sind Literale und Variablen primitive Ausdrücke, die nicht aus anderen Ausdrücken zusammengesetzt sind. Um mit den Objekten jedoch Aktionen auszuführen und damit ein Programm tatsächlich auszuführen, benötigen wir weitere Arten von Ausdrücken, nämlich Zuweisungsausdrücke und Nachrichtenausdrücke. Auch diese repräsentieren jeweils ein Objekt und können daher an allen Stellen verwendet werden, an denen Objekte erforderlich sind. Es ist sogar möglich, sie geschachtelt anzuordnen.",Was sind primitive Ausdrücke?,"Primitive Ausdrücke sind nicht aus anderen Ausdrücken zusammengesetzt, wie Literale und Variablen."
Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.,Was bedeutet Substituierbarkeit in diesem Kontext?,"In diesem Kontext bedeutet Substituierbarkeit, dass ein Objekt eines Untertyps an jeder Stelle, an der ein Objekt des Obertyps erwartet wird, verwendet werden kann, ohne dass die Korrektheit des Programms beeinträchtigt wird."
"Alle Elemente des Arrays enthalten danach jedoch null (Javas Äquivalent von SMALLTALKs nil). Java-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.",Was passiert mit den Elementen eines Arrays nach der Initialisierung in Java?,Nach der Initialisierung eines Arrays in Java enthalten alle Elemente den Wert null.
"Es ist zu beachten, dass die semantischen Regeln 1.d und 1.e die syntaktischen Regeln 1.a bis 1.c implizieren. In typlosen Sprachen wie Smalltalk würden die entsprechenden Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert, und die Menge der ausgelösten Ausnahmen wäre Teil der Nachbedingungen.",Was sind Vor- und Nachbedingungen in typlosen Sprachen?,"In typlosen Sprachen wie Smalltalk werden die Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert. Vorbedingungen beschreiben die Bedingungen, die vor der Ausführung einer Methode erfüllt sein müssen, während Nachbedingungen die Bedingungen beschreiben, die nach der Ausführung der Methode erfüllt sein müssen. Die Menge der ausgelösten Ausnahmen ist Teil der Nachbedingungen."
,Was ist die Extension?,"Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören."
"Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, die seine Ausführung bestimmen. Anders als in anderen Programmiersprachen gibt es in SMALLTALK nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf; alle anderen, einschließlich der Verzweigung und der Wiederholung (Schleife), müssen durch diese simuliert werden. Dies ist möglich, weil SMALLTALK Blöcke hat und weil in SMALLTALK (wie in allen anderen objektorientierten Programmiersprachen) der Methodenaufruf variabler ist als der gewöhnliche Prozedur- oder Funktionsaufruf, den Sie vielleicht von Sprachen wie PASCAL oder C kennen. Er enthält, wie bereits in Abschnitt 4.3.2 angedeutet, eine versteckte Fallunterscheidung in Form des dynamischen Bindens.",Was sind Verzweigungen und Wiederholungen in SMALLTALK?,"Verzweigungen und Wiederholungen in SMALLTALK werden durch die Verwendung von Blöcken und dynamisch gebundenen Methodenaufrufen simuliert. Da SMALLTALK keine direkten Verzweigungs- und Schleifenkonstrukte wie in einigen anderen Programmiersprachen hat, werden Entscheidungen und Wiederholungen durch den Aufruf entsprechender Methoden und die Auswertung von Blöcken erreicht."
"Logischerweise können Instanzvariablen in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Typische Eigenschaften sind beispielsweise die Farbe von etwas oder der Name; sie unterscheiden sich inhaltlich von Beziehungen dadurch, dass das bezogene Objekt seine Bedeutung verliert, wenn es isoliert betrachtet wird. Ein Objekt wie ""Rot"" ist allein nichts anderes als eine Farbe; es erhält erst Bedeutung, wenn es als Attribut eines Objekts wie ""Apfel"" betrachtet wird. Das Gleiche gilt für ""Schmidtchen"" oder ""1"". Zudem ist zu beachten, dass Attributwerte wie die genannten in der Regel selbst keine Attribute besitzen oder Beziehungen zu anderen Objekten nicht eingehen.Es ist jedoch wichtig zu beachten, dass dieses Unterscheidungskriterium relativ zur jeweils betrachteten Domäne ist. Wenn es beispielsweise um Farben geht, hat ""Rot"" an sich bereits eine Bedeutung und kann vollwertige Beziehungen zu anderen Objekten eingehen, wie zum Beispiel ""Grün"" als sein Komplementärkontrast.",Was sind Kategorien von Instanzvariablen?,"Instanzvariablen können logischerweise in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Eigenschaften sind Attribute wie Farbe oder Name, die ihre Bedeutung verlieren, wenn sie isoliert betrachtet werden. Beziehungen hingegen repräsentieren Verbindungen zwischen Objekten und behalten ihre Bedeutung auch isoliert betrachtet."
,"Warum könnte es in einigen Fällen sinnvoll sein, ein Typ-Wildcard anstelle eines Typparameters in einer generischen Methode zu verwenden?","In einigen Fällen, in denen der Typparameter innerhalb der Methode nicht verwendet wird, kann es sinnvoll sein, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard in der generischen Methode zu verwenden, um den Code einfacher und lesbarer zu gestalten."
,Was repräsentieren die Klassen der Ebene 1 und was repräsentieren die Metaklassen der Ebene 2?,"Die Klassen der Ebene 1 repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. Die Metaklassen der Ebene 2 definieren die Klassen auf Ebene 1, wobei jede Metaklasse genau eine Instanz auf Ebene 1 hat."
"SMALLTALK stammt aus einer Zeit, in der man noch relativ wenig praktische Erfahrung mit objektorientierter Programmierung gesammelt hatte. Damals war man der Ansicht, dass einer der Hauptvorteile der objektorientierten Programmierung die Wiederverwendung von Code durch Vererbung sei. Wie in Abschnitt 10.1 dargelegt, hat die Vererbung etwas mit der auf Generalisierung bzw. Spezialisierung beruhenden Abstraktionshierarchie zu tun: Der allgemeinere Begriff (die Superklasse) überträgt (vererbt) alle seine Eigenschaften auf die spezielleren Begriffe (Subklassen), und der speziellere erbt sie von den allgemeineren. Dies liegt in der Natur der Sache. Problematisch wird es jedoch, sobald man den kausalen Zusammenhang umkehren und von einer möglichen Vererbung auf eine Generalisierung/Spezialisierung schließen will: Nur weil eine Klasse (zufällig) Eigenschaften einer anderen geerbt haben könnte, heißt das noch lange nicht, dass die erbende Klasse auch eine Spezialisierung der vererbenden ist. Ein klassisches Beispiel hierzu hatten wir bereits mit der Ableitung der Klasse Rechteck von der Klasse Quadrat kennengelernt; den unangenehmen Folgen solch vererbungsorientierter Vorgehensweisen werden wir in der nächsten Kurseinheit noch begegnen.",Warum ist die Vererbung in der objektorientierten Programmierung problematisch?,"Die Vererbung in der objektorientierten Programmierung ist problematisch, weil sie oft fälschlicherweise als ein Zeichen für eine Generalisierung/Spezialisierung interpretiert wird. Es ist jedoch möglich, dass eine Klasse Eigenschaften einer anderen Klasse erbt, ohne dass sie eine Spezialisierung der vererbenden Klasse ist. Ein klassisches Beispiel hierfür ist die Ableitung der Klasse Rechteck von der Klasse Quadrat, was zu unangenehmen Folgen führen kann."
"Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.",Was ist Aliasing und wie kann es zu Problemen führen?,"Aliasing bedeutet, dass mehrere Variablen auf das gleiche Objekt verweisen. Dies kann zu Problemen führen, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, da Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger zugreifen können. Dies ist bei sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Am Programmverhalten ist dies jedoch nicht zu erkennen."
"In der Praxis bewegen Sie sich jedoch vor allem auf Ebene 1: Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen Sie also nur eine Abstraktionsstufe für die Programmierung.",Wie viele Abstraktionsstufen werden in der Programmierpraxis hauptsächlich genutzt?,"In der Praxis werden sich Programmierer hauptsächlich auf Ebene 1 bewegen, indem sie Anwendungsklassen definieren, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Das bedeutet, dass nur eine Abstraktionsstufe genutzt wird."
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.",Ist RTTI in C++ immer verfügbar?,"Nein, RTTI ist in C++ nicht immer verfügbar, da es nur für Objekte mit dynamisch gebundenen Methoden zur Verfügung steht."
"Nun kommt dieses Problem so häufig vor, dass sich MICROSOFT dafür entschieden hat, es zumindest teilweise von der Ebene der Programmierung (wo es in Form eines sog. Patterns abgehandelt wird; mehr dazu in Kurs 01853) auf die Ebene der Programmiersprache zu heben (in SMALLTALK, wo diese Unterscheidung nicht so ausgeprägt ist, war das Problem ja mittels einer Implementierung der benötigten Mechanismen in der Klasse Object gelöst worden, von der alle anderen erben).",Wie hat Microsoft das Problem der temporären Variablen gelöst?,"Microsoft hat das Problem der temporären Variablen zumindest teilweise auf die Ebene der Programmiersprache gehoben, indem es eine Möglichkeit geschaffen hat, diese Unterscheidung in der Programmiersprache zu behandeln."
,"Warum ist es wichtig, dass ein Typfehler bereits bei der Verwendung der parametrischen Typdefinition erkannt wird?","Es ist wichtig, dass ein Typfehler bereits bei der Verwendung der parametrischen Typdefinition erkannt wird, um sicherzustellen, dass alle eingesetzten Typen die erforderlichen Eigenschaften haben, bevor sie verwendet werden."
"Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht für eine besondere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung. Die Gegenrolle heißt Supertyp.",Was ist ein Objekt?,Ein Objekt ist eine Instanz einer Klasse.
"Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger um die Return-Anweisung des aufgerufenen Unterprogramms handeln muss. Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterprogramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächliche Parameter übergeben wurden, und wenn zudem das Unterprogramm bekannte Vor- und Nachbedingungen enthält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein großer Nutzen gegenüber: Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anweisungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche Aufrufkontexte gibt (das sog. Inlining, das manche Compiler aus Optimierungsgründen durchführen). Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie getrennt untersuchen und verstehen kann.",Was ist der Unterschied zwischen dem dynamischen Vorgänger einer Anweisung und dem Goto?,"Der dynamische Vorgänger einer Anweisung ist die Anweisung, die unmittelbar davor im Programmablauf ausgeführt wurde. Beim Goto wird die Programmlogik durch Sprunganweisungen unterbrochen, was zu einer unübersichtlichen Programmstruktur führen kann. Im Gegensatz dazu bietet der dynamische Vorgänger eine klare und strukturierte Abfolge der Anweisungen."
,Wie wird EIFFEL als Sprache häufig charakterisiert?,"EIFFEL wird als eine akademische Sprache charakterisiert, was bedeutet, dass sie in erster Linie in der akademischen Welt verwendet wird und möglicherweise weniger in kommerziellen Anwendungen anzutreffen ist."
"Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger-auf-Typ handelt; vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch überladen wurde. Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.",Was bedeutet der Stern vor einer Variable in der Programmierung?,"Vor einer Variable bedeutet der Stern, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird."
"Eine Menge von Objekten aus einer Collection kann in eine andere übertragen werden, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z. B. asSet, das doppelte Elemente entfernt. Diese Konvertierungsmethoden sind in Collection implementiert, analog zu asBag und asOrderedCollection oben. Besonders interessant sind natürlich Konvertierungen in Collections, die strengere Bedingungen stellen, z. B. asSet und asSortedCollection.",Was können Konvertierungsmethoden in Collections tun?,"Konvertierungsmethoden in Collections können eine Menge von Objekten aus einer Collection in eine andere übertragen, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z.B. asSet, das doppelte Elemente entfernt. Besonders interessant sind Konvertierungen in Collections, die strengere Bedingungen stellen, z.B. asSet und asSortedCollection."
"Es definieren also die Interfaces von Java genau wie Klassen Typen und können daher genauso wie Klassen in Variablendeklarationen verwendet werden. Der Type checker garantiert dann, dass auf der Variable mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ. Eine genauere Betrachtung der Bedeutung der Verwendung von Interfaces erfolgt in Kapitel 45.",Was sind Interfaces in Java und wie werden sie verwendet?,"Interfaces in Java definieren Typen und können daher in Variablendeklarationen verwendet werden. Der Type checker garantiert, dass auf der Variablen mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ."
"Die Unterscheidung zwischen lokalen und globalen Variablen dient unter anderem dazu, Geheimnisse zu verbergen, was auch als Geheimnisprinzip oder Information Hiding bezeichnet wird. Genauer gesagt geht es dabei um das Verbergen von Implementationsdetails. Es ist fast immer sinnvoll, die Struktur zusammengesetzter Objekte vor den Objekten zu verbergen, die sie verwenden, damit Änderungen an dieser Struktur vorgenommen werden können, ohne dass die verwendenden (abhängigen) Objekte davon betroffen sind. Solche Änderungsabhängigkeiten werden vermieden, indem die Variablen von außen nicht zugänglich sind, was automatisch für lokale Variablen gilt, da sie von außen unsichtbar sind.",Was ist das Geheimnisprinzip?,"Das Geheimnisprinzip oder Information Hiding bezieht sich auf das Verbergen von Implementationsdetails eines Objekts, insbesondere der Struktur zusammengesetzter Objekte, vor den Objekten, die sie verwenden. Dadurch können Änderungen an der Struktur vorgenommen werden, ohne dass abhängige Objekte davon betroffen sind."
"Vor diesem Hintergrund scheint der in Abschnitt 52.5.2 dargelegte Umgang EIFFELs mit Referenz- und Wertvariablen ziemlich schlau ausgedacht zu sein. Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei. Dumm ist nur, wenn man innerhalb der Kapsel Aliase auf Wertobjekte braucht. Weitergehende Mechanismen zur Aliaskontrolle in objektorientierten Programmiersprachen befinden sich derzeit alle noch in der Vorschlags- und Erprobungsphase und sollen hier deswegen nicht weiter behandelt werden.",Wie geht EIFFEL mit Referenz- und Wertvariablen um?,"EIFFEL erlaubt, auf Wertobjekte Referenzen zu haben, aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Somit sind Wertobjekte in EIFFEL aliasfrei."
,Welche Funktionen haben Klassen in Java?,"Klassen in Java dienen als Vorlagen für die Erzeugung von Objekten, liefern Typen für ein Programm und dienen der Modularisierung."
,Wie kann der parametrische Polymorphismus zur Lösung des Problems der rekursiven Typen beitragen?,"Der parametrische Polymorphismus ermöglicht die Definition eines nicht parametrischen Typs als Subtyp eines parametrisierten Typs, wodurch die gewünschte Rekursion indirekt hergestellt werden kann."
"Einige Sprachkonstrukte verwenden in C-Sharp andere Schlüsselwörter als Java, so ""lock"" anstatt ""synchronized"" sowie ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer Bedeutung leicht von denen Javas ab: So sind auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen (in Java erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anweisung enthält, muss mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen werden. Außerdem hat C-Sharp eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. All dies hat allerdings nichts mit Objektorientierung zu tun.",Wie unterscheidet sich C-Sharp von Java in Bezug auf Schlüsselwörter und Kontrollflussanweisungen?,"In C-Sharp werden einige Sprachkonstrukte mit anderen Schlüsselwörtern als in Java verwendet, wie zum Beispiel ""lock"" anstatt ""synchronized"" und ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen. Zudem sind in C-Sharp auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen und jeder Zweig muss mit einer expliziten Kontrollflussanweisung abgeschlossen werden. Im Gegensatz zu Java verfügt C-Sharp über eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. Diese Unterschiede haben jedoch nichts mit Objektorientierung zu tun."
"Vererbung ist nicht auf die Klassen der Ebene 1 beschränkt — in SMALLTALK können vielmehr auch Metaklassen, die ja ebenfalls Klassen sind (s. Kapitel 8), voneinander erben. Da Metaklassen aber bei der Erzeugung von Klassen automatisch angelegt werden (und auch keine eigenen Namen haben), hat die Programmiererin auch keinen direkten Einfluss auf die Vererbungshierarchie der Metaklassen. Vielmehr wird diese automatisch parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind, angelegt. Dies hat zur Folge, dass in SMALLTALK neben den Instanzvariablen und -methoden auch die Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt werden.",Kann Vererbung in SMALLTALK nur auf der Ebene 1 stattfinden?,"Nein, Vererbung ist in SMALLTALK nicht auf die Klassen der Ebene 1 beschränkt. Auch Metaklassen, die ja ebenfalls Klassen sind, können voneinander erben. Diese Vererbungshierarchie der Metaklassen wird automatisch parallel zur Vererbungshierarchie der Klassen angelegt, die Instanzen der Metaklassen sind."
,"Was ist die Zuweisungskompatibilität, und warum ist sie wichtig?","Die Zuweisungskompatibilität ist wichtig, um festzustellen, ob Zuweisungen zwischen Variablen oder Ausdrücken zulässig sind, ohne die Typinvariante zu verletzen. Sie stellt sicher, dass die Typen der beteiligten Objekte oder Ausdrücke kompatibel sind, um Typfehler zu vermeiden."
,"Was sind Bezeichner in der Programmierung, und wie werden sie verwendet?","Bezeichner sind Namen, die in der Programmierung frei vergeben werden können. Sie werden verwendet, um Programmelemente zu identifizieren und auf sie zu verweisen, beispielsweise Variablen oder Methoden."
"Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken, die die Teile des Nachrichtenselektors sperren. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.Da ein Nachrichtenausdruck für ein Objekt steht, kann er selbst Teil eines anderen Nachrichtenausdrucks sein, entweder als Empfänger der Nachricht oder als eines ihrer Argumente. In diesem Fall ist es möglicherweise notwendig, den geschachtelten Nachrichtenausdruck in Klammern zu setzen, um sicherzustellen, dass er korrekt erkannt wird.Die Kaskadierung ist eine syntaktische Abkürzung, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen.",Was ist die Kaskadierung in SMALLTALK?,"Die Kaskadierung ist eine syntaktische Abkürzung in SMALLTALK, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen. Dies erleichtert das Verketten von Nachrichten an dasselbe Objekt."
"Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit immer dann fraglich ist, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies soll nun etwas genauer beleuchtet werden.",Was ist Substituierbarkeit in Bezug auf Typerweiterung und Typeinschränkung?,"Substituierbarkeit bedeutet, dass ein Objekt eines Typs durch ein Objekt eines anderen Typs ersetzt werden kann, ohne dass die Korrektheit des Programms beeinträchtigt wird. Wenn eine Typerweiterung vorliegt, ist die Substituierbarkeit in der Regel unproblematisch. Wenn jedoch eine Typeinschränkung vorliegt, kann die Substituierbarkeit fraglich sein, da das ersetzende Objekt möglicherweise nicht die gleichen Eigenschaften und Methoden aufweist wie das ursprüngliche Objekt."
"In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: at: i.Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C-Sharp und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen. Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.",Was sind zwei Arten von Instanzvariablen in SMALLTALK?,In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte Instanzvariablen.
"Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die zu liefern ist die Funktion von Streams. Streams werden zunächst immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält. Das Basisprotokoll auf Instanzebene enthält die folgenden Methoden: atEnd: gibt an, ob der Stream bereits am Ende seiner Basis angekommen ist. next: gibt das nächste Element der Basis zurück und rückt den Stream auf dieses Element vor. upToEnd: gibt eine Collection zurück, die alle Elemente der Basis bis zum Ende enthält. upTo: gibt eine Collection zurück, die alle Elemente der Basis bis zu einem bestimmten Element enthält. copyFrom: kopiert einen Teil der Basis in den Stream. reset: setzt den Stream auf den Anfang der Basis zurück.",Wie wird ein Stream erzeugt?,"Ein Stream wird immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält."
"Einhergehend mit kurzen Methoden und aussagekräftigen Bezeichnern ist ein deklarativer Programmierstil für die objektorientierte Programmierung typisch: Die Ausdrucksform bemüht sich mehr um das ""Was"" als um das ""Wie"". Der Effizienzgedanke ist dabei sekundär – mögliche Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben, wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung zu ineffizient ist.",Was ist der Unterschied zwischen einem deklarativen und einem imperativen Programmierstil?,"Ein deklarativer Programmierstil beschäftigt sich mehr mit dem ""Was"" als mit dem ""Wie"" und beschreibt, was das Programm tun soll, während ein imperativer Programmierstil sich mehr auf die Anweisungen und die Reihenfolge der Befehle konzentriert, die das Programm ausführen soll, um ein bestimmtes Ergebnis zu erzielen."
"In EIFFEL gibt es keine Zugriffsmodifikatoren wie in Java/C-Sharp/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.",Wie ist die Zugriffsebene von Features in EIFFEL festgelegt?,"In EIFFEL gibt es keine Zugriffsmodifikatoren wie in Java/C-Sharp/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt. Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis."
,"Warum wird ""SortedList<String>"" als gültige Deklaration betrachtet, aber ""SortedList<Integer>"" nicht?","""SortedList<String>"" wird als gültige Deklaration betrachtet, weil ""String"" ein Subtyp von ""Comparable"" ist und daher die Bedingung ""<E extends Comparable<E>>"" erfüllt. ""SortedList<Integer>"" wird hingegen nicht als gültige Deklaration betrachtet, da ""Integer"" nicht ""Comparable<Integer>"" implementiert, was nicht der Einschränkung entspricht."
"Man beachte hierbei, dass Bag die Klasse Dictionary nutzt, ohne von ihr zu erben. Stattdessen hält sich jede Instanz von Bag eine Instanz von Dictionary als Sklavin, die für sie den Dienst verrichtet. Man spricht hier auch von einer Delegation; da die Delegation in den prototypenbasierten objektorientierten Programmiersprachen tatsächlich die Funktion der Vererbung übernimmt und zudem dynamisch (also nachdem eine Instanz erzeugt wurde) eingerichtet werden kann und da sie zudem von Fragen der Generalisierung/Spezialisierung völlig befreit ist, erfreut sie sich in der objektorientierten Programmierung großer Beliebtheit.",Was ist Delegation in der objektorientierten Programmierung?,"Delegation ist eine Technik in der objektorientierten Programmierung, bei der eine Instanz eine andere Instanz als Sklavin hält, die für sie den Dienst verrichtet. Sie wird oft genutzt, um die Funktion der Vererbung zu übernehmen, da sie dynamisch eingerichtet werden kann und nicht an Fragen der Generalisierung/Spezialisierung gebunden ist."
,Was macht den Zustand eines Objektes aus?,"Der Zustand eines Objektes ist die Summe der Belegungen seiner Instanzvariablen - er wird ausschließlich durch die Verknüpfung mit anderen Objekten definiert. Es folgt, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, der über die Zuweisung von Instanzvariablen ist."
,Gibt es in C-Sharp einen Unterschied zwischen Wert- (primitiven) und Referenztypen wie in Java?,"In C-Sharp wird zunächst nicht zwischen Wert- (primitiven) und Referenztypen wie in Java unterschieden. Alle Typen, einschließlich der primitiven Typen, gelten als von Object (genauer: System.Object) abgeleitet."
,"Welche Herausforderung kann bei flachem Kopieren auftreten, wenn es sich um ein tiefes Kopieren handelt?","Bei flachem Kopieren, das selbst ein tiefes Kopieren enthält, kann der Kopiervorgang leicht in eine Endlosrekursion geraten."
"Modul und Interface sind eigentlich ein Begriffspaar — das eine lässt sich nur mithilfe des anderen definieren. Die Interfaces in Java sind jedoch durchaus eigenständige Konstrukte, die inzwischen weit über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle zu definieren, hinausgehen. Auch wenn Javas Interfaces Vorgänger haben, betrachte ich sie doch als einen von Javas wichtigsten Beiträgen für die Entwicklung objektorientierter Programmiersprachen.",Was ist der Unterschied zwischen Modul und Interface?,"Modul und Interface sind eigentlich ein Begriffspaar, das sich nur mithilfe des anderen definieren lässt. Interfaces in Java sind jedoch eigenständige Konstrukte, die über die eigentliche Bedeutung des Begriffs hinausgehen."
"Nun ändern sich aber bei der Redefinition einer Methode nicht nur die Parametertypen (Ein- und Ausgabe bzw. Rückgabe), sondern auch der Typ des Empfängers. Dieser ändert sich bei der Redefinition aber immer nach unten (da der redefinierende Typ ja als Subtyp vom redefinierten abgeleitet wird). Es folgt also, dass die Eingabeparameter zum Empfängertyp gegenläufig variieren müssen, der Ausgabeparameter hingegen gleichgerichtet. Man spricht im ersten Fall daher von einer Kontravarianz, im zweiten von einer Kovarianz, und sagt: Die Eingabeparameter sind kontravariant und der Ausgabeparameter ist kovariant. Man spricht im Kontext von Subtyping auch von Typkonformität des Subtypen mit dem Supertypen.",Was ist Kontravarianz und Kovarianz?,"Kontravarianz und Kovarianz sind zwei Begriffe, die die Richtung der Variation von Parametern bei der Redefinition von Methoden beschreiben. Kontravarianz bezieht sich auf die Eingabeparameter, die gegenläufig zum Empfängertyp variieren, während Kovarianz sich auf den Ausgabeparameter bezieht, der gleichgerichtet zum Empfängertyp variiert."
,Welche Eigenschaften gelten für die Typäquivalenz?,"Die Typäquivalenz ist reflexiv, was bedeutet, dass jeder Typ zu sich selbst äquivalent ist. Sie ist auch transitiv, was bedeutet, dass wenn A äquivalent zu B ist und B äquivalent zu C ist, dann ist auch A äquivalent zu C."
"In Java wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.",Wie wird in Java ein neuer Thread gestartet?,"In Java wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft."
"Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Methode einer Superklasse des Empfängerobjekts ausgeführt wird, das Objekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilierung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden — handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch Instanz seiner Klasse ist. Die gerade ausgeführte Methode betrachtet es lediglich wie ein Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die Bedeutung der Pseudovariable super, wie wir noch sehen werden.","Was passiert, wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind, aber in einer Superklasse definiert wurden?","Die Methode kann nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar."
,"Warum benötigen viele Applikationen, insbesondere solche mit GUI, eine Kommunikation mit unbekannten Objekten?","Viele Applikationen benötigen eine Kommunikation mit unbekannten Objekten, da sie neben der direkten Kommunikation zwischen Objekten, die sich kennen, auch mit anderen Objekten kommunizieren müssen, die nicht im Voraus bekannt sind. Dies tritt insbesondere in Anwendungen mit grafischer Benutzeroberfläche (GUI) auf, wo verschiedene Elemente miteinander interagieren müssen, ohne im Voraus genau zu wissen, welche Objekte diese Interaktion benötigen."
,Können Indexer in C-Sharp überladen werden und mehrere indizierte Instanzvariablen simulieren?,"Ja, Indexer in C-Sharp können überladen werden, um mehrere indizierte Instanzvariablen zu simulieren. Dies ermöglicht einem Objekt, mehrere indizierte Variablen mit unterschiedlichen Indexen zu haben. Die Einschränkung dabei ist, dass der Rückgabetyp (Elementtyp) beim Überladen gleich bleiben muss. Indexer können auch berechnete Werte zurückgeben, ohne auf interne Instanzvariablen zuzugreifen, ähnlich wie Properties."
"In SMALLTALK gibt es keine frei bezeichenbaren Konstanten, sondern nur Literale. Da verschiedene Vorkommen gleicher Literale jedoch (außer bei Symbolen) verschiedene Objekte erzeugen, sind Literale nicht für alle Zwecke ausreichend. Hierfür gibt es einen Trick, um dasselbe Literal mehrfach verwenden zu können, nämlich durch eine sogenannte konstante Methode.An einer konstanten Methode ist nichts weiter konstant, als dass sie immer dasselbe Objekt zurückgibt. Der Trick besteht darin, dass das zum Literal gehörende Objekt nur einmal, nämlich zur Übersetzungszeit der Methode, erzeugt wird, und die Ausführung der Methode immer auf dieses und damit dasselbe Objekt zurückgreift.",Was sind konstante Methoden?,"Konstante Methoden sind Methoden, die immer dasselbe Objekt zurückgeben. Sie werden häufig verwendet, um Literale auf eine Weise zu repräsentieren, die sicherstellt, dass sie konsistent sind und immer auf dasselbe Objekt verweisen."
,Welchen Zweck dienen Collections in der Programmierung?,"Collections dienen u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen."
"Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C-Sharp. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C-Sharp, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:",Was ist eine Einteilung der verschiedenen Arten von Typen in C-Sharp?,"Die Einteilung der verschiedenen Arten von Typen in C-Sharp ist eine Einteilung, die die verschiedenen Arten von Typen in C-Sharp in ValueType, Delegate und class einteilt."
,Wie wird der Zugriff auf Features in EIFFEL kontrolliert?,"In EIFFEL wird der Zugriff auf Features durch die gezielte Veröffentlichung (Export) von Features gesteuert. Klassen, die auf diese Features zugreifen sollen, werden explizit genannt."
,Wie kennzeichnet man in STRONGTALK den Rückgabetyp einer Methode?,In STRONGTALK wird der Rückgabetyp einer Methode durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter der Methode.
"Häufig findet man in einzelnen Projekten und nicht selten in ganzen Firmen Namenskonventionen vor, an die sich alle halten sollten. Namenskonventionen erleichtern nicht nur die Bezeichnerwahl. Indem die Programmiererin sich an bestimmte Regeln halten kann, wird ihre schöpferische Freiheit eingeschränkt, was man durchaus auch als Entlastung empfinden kann. Sie erleichtern auch das Lesen, weil die Leserin, die die Konventionen kennt, die Bedeutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter entschlüsseln kann und sich somit schneller zurechtfindet. Allerdings ist es dazu notwendig, dass die Namenskonventionen genau festgeschrieben sind und dass sich alle darauf einigen. Wenn nämlich jede ihre individuelle Auslegung der Regel hat, dann kann eine (vermeintliche) Namenskonvention mehr Verwirrung stiften als nutzen. ""It would be a mistake to protest against the rules … on the grounds that they limit developer creativity. A consistent style favors rather than hampers creativity by channeling it to where it matters. A large part of the effort of producing software is spent reading existing software and making others read what is being written. Individual vagaries benefit no one; common conventions help everyone."" - Bertrand Meyer",Wozu dienen Namenskonventionen?,"Namenskonventionen erleichtern die Bezeichnerwahl, indem sie die schöpferische Freiheit der Programmiererin einschränken und das Lesen von Code, indem sie die Bedeutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter entschlüsseln."
,Welche Unterschiede gibt es zwischen der Deklaration eines Interfaces und einer Klasse?,"Die Unterschiede zwischen der Deklaration eines Interfaces und einer Klasse sind: Verwendung des Schlüsselworts ""interface"" anstelle von ""class"". Fehlen von Felddeklarationen in Interfaces. In Interfaces folgt auf die Methodendeklaration lediglich ein abschließendes Semikolon, ohne Implementierung."
"Im Prinzip ist die Definition einer Metaklasse genauso aufgebaut wie die einer normalen Klasse: Sie besteht aus der Angabe einer Menge von benannten Instanzvariablen und einer Menge von Instanzmethodendefinitionen. Lediglich indizierte Instanzvariablen sind nicht vorgesehen, und der Klassenname kann wie gesagt nicht frei angegeben werden.",Was ist der Unterschied zwischen einer Metaklasse und einer normalen Klasse?,"Der Unterschied zwischen einer Metaklasse und einer normalen Klasse besteht darin, dass Metaklassen keine indizierten Instanzvariablen enthalten dürfen und der Klassenname nicht frei angegeben werden kann."
"Die öffentliche Schnittstelle einer Klasse in Java ist die Menge ihrer Instanzvariablen und -methoden (in Java zusammen auch Member genannt), die public deklariert sind. Nun gibt es in Java die Möglichkeit, eine öffentliche Schnittstelle als eigenständiges Konstrukt zu deklarieren, das von dem der Klasse unabhängig ist, das aber genauso wie eine Klasse einen Typ definiert. Es geschieht dies mit Hilfe des Schlüsselwortes ""interface"":",Was ist eine öffentliche Schnittstelle in Java?,"In Java ist eine öffentliche Schnittstelle eine eigenständige Deklaration, die von der Klasse unabhängig ist und einen Typ definiert. Sie wird mit Hilfe des Schlüsselwortes ""interface"" deklariert und enthält eine Menge von Instanzvariablen und -methoden, die public deklariert sind."
"Eine Methode, die die obige Methode aufruft, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft.","Was muss eine Methode tun, wenn sie eine Exception aufruft, die von einer anderen Methode geworfen wird?","Eine Methode, die eine Exception aufruft, die von einer anderen Methode geworfen wird, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft."
,"Warum ist es schwer, C++ zu lehren?","Es ist schwer, C++ zu lehren, weil die Sprache sehr komplex ist und die Kombinatorik ihrer Konstrukte zu einer hohen Zahl von Möglichkeiten führt. Die Vielzahl von Idiomen (Wendungen) in C++ trägt ebenfalls zur Komplexität bei."
"Bei genauerer Betrachtung ergibt sich jedoch das Problem, dass Set durch seine Eigenheit mehrere charakteristische Eigenschaften von Multimengen verletzt. Zum Beispiel gilt für Sets nicht wie für Bags, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden; doppelte Einfügungen werden von Set einfach ignoriert. Ein Programm, das auf die Eigenschaften von Bags setzt und stattdessen mit einem Set arbeiten muss, funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.",Was sind die charakteristischen Eigenschaften von Multimengen (Bags)?,"Die charakteristischen Eigenschaften von Multimengen (Bags) sind, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht und dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden."
"Der Compiler weiß nun aufgrund der Ersetzung des formalen Parameters E mit dem tatsächlichen Parameter Integer in Zeile 1051, dass die Elemente der Variable liste alle vom Typ Integer sind und dass eine Zuweisung der Form get(0) = 42; typkorrekt ist. Um das zu überprüfen, muss er nämlich nur den Wert des Typparameters in der Deklaration von liste, Integer, in die Variable E der Implementierung von get einsetzen. Er kann dann feststellen, dass der Rückgabetyp des Ausdrucks mit der Variable zuweisungskompatibel ist. Man beachte, dass ohne Typparameter in Zeile 1064 eine Typumwandlung von Object auf Integer (Downcast) notwendig wäre, die aber zu einem Laufzeitfehler führen kann. Die Einführung von Generics erhöht hingegen die Typsicherheit statisch, also zur Übersetzungszeit, ein fundamentaler Gewinn.",Was ist der Zweck der Verwendung von Generics in Java?,"Der Zweck der Verwendung von Generics in Java ist es, die Typsicherheit statisch, also zur Übersetzungszeit, zu erhöhen und die Notwendigkeit von Typumwandlungen (Downcast) zu verringern, die zu Laufzeitfehlern führen können."
"EIFFEL ist, wie alle anderen hier behandelten Sprachen (mit Ausnahme von C++), eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist. Klassen können (mit der in Abschnitt 52.5 gemachten Einschränkung) separat übersetzt werden. Die Ausführung von EIFFEL erfolgt nicht auf einer virtuellen Maschine, sondern direkt auf der Zielmaschine. Es gibt jedoch mittlerweile auch eine Version von EIFFEL für .NET, die wie alle .NET-Sprachen zunächst in CIL übersetzt wird und dann in Maschinencode. Die Sprache selbst sieht aufgrund ihrer Einfachheit keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Eventuelle Performance-Verbesserungen werden ganz der Verantwortung eines optimierenden Compilers überlassen. EIFFEL verwendet Garbage Collection zur Speicherfreigabe. Es handelt sich um eine akademische Sprache.",Was ist EIFFEL und welche Eigenschaften hat sie?,"EIFFEL ist eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist. Sie wird direkt auf der Zielmaschine ausgeführt, mit Ausnahme einer Version für .NET, die zunächst in CIL übersetzt wird. EIFFEL verwendet Garbage Collection zur Speicherfreigabe und ist eine akademische Sprache. Sie sieht keine speziellen Konstrukte für leistungsstarke und weniger leistungsstarke Implementierungen vor, diese werden einem optimierenden Compiler überlassen."
"Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.Nach einer Zuweisung x := y bezeichnen die beiden Variablen ""x"" und ""y"" das gleiche Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.",Warum ist die Zuweisung kommutativ?,"Die Zuweisung ist nicht kommutativ, da ""x := y"" und ""y := x"" unterschiedliche Bedeutungen haben, es sei denn, ""x"" und ""y"" hatten bereits denselben Wert vor der jeweiligen Zuweisung."
,Welche Freiheit bietet der Präprozessor in C++?,"Der Präprozessor in C++ bietet die Freiheit, die Syntax der Sprache durch Hinzufügen einer neuen Syntax zu verändern. Dies ermöglicht es, Code in einer für Entwickler verständlicheren Weise zu schreiben, wenn gewünscht."
"Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Dies kann man auch selbst tun: Es gibt dafür in der Klasse Behavior eine Instanzmethode oder so ähnlich (je nach System), die somit allen Klassen (als Klassenmethode) zur Verfügung steht. (Behavior ist ja eine Superklasse von Class, die wiederum Superklasse aller Metaklassen ist, von denen jede Klasse eine Instanz ist, so dass alle Klassen die Methode includesSelector: verstehen.)",Was ist das Methodenwörterbuch in Smalltalk?,"Das Methodenwörterbuch in Smalltalk ist eine Tabelle, die alle Methoden enthält, die zu einer bestimmten Klasse gehören. Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist."
,Was ist die Besonderheit bezüglich der Verwendung des Semikolons in EIFFEL?,"In EIFFEL dient das Semikolon als Trennzeichen und ist kein Bestandteil einer Anweisung. Darüber hinaus kann es am Ende einer Zeile auch weggelassen werden, was dazu führt, dass kleine EIFFEL-Programme optisch aufgeräumt wirken."
"Zum objektorientierten Programmierstil gehört es, eine Lösung eines konkreten Problems möglichst umfassend aus existierenden, idealerweise verbreiteten und bewährten Bibliotheken zusammenzustellen. Jede nicht selbst geschriebene Programmzeile ist ein Gewinn, jede Implementierung einer noch so kleinen Funktion, die es bereits in irgendeiner Bibliothek gibt, ist ein Verlust. Dabei sind die Vorteile der Verwendung von Bibliotheken mannigfaltig: In der Regel können Sie davon ausgehen, dass die Implementierungen korrekt sind (und Probleme sowie Sonderfälle berücksichtigen, an die Sie im Traum nicht gedacht hätten), die Wartung und Anpassung übernehmen andere für Sie, und nicht zuletzt dürfen Sie bei weit verbreiteten Bibliotheken voraussetzen, dass deren Funktionalität auch anderen Programmierern bekannt ist, sodass die Verwendung einer Bibliotheksklasse keiner weiteren Erklärung bedarf. Ihr eigener Beitrag wird dadurch klein und überschaubar, was man Ihnen in keinem Fall als Faulheit oder Arbeitsverweigerung auslegen sollte, sondern als wahre Größe: Sie kennen das Werk anderer, Sie wissen es zu schätzen und zu nutzen.","Warum ist es vorteilhaft, existierende Bibliotheken in der objektorientierten Programmierung zu verwenden?","Es ist vorteilhaft, existierende Bibliotheken in der objektorientierten Programmierung zu verwenden, da die Implementierungen in der Regel korrekt sind, die Wartung und Anpassung übernommen wird, die Funktionalität bekannt ist und die eigene Arbeit klein und überschaubar bleibt."
"Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet (Methoden auf Objekten aufgerufen) werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks (Methodenaufrufs) vorliegen. Dies ist in der Regel bei Kettenaufrufen der Fall (s. u.), kann aber auch über eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen.",Wann wird das Gesetz Demeters typischerweise verletzt?,"Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks vorliegen, wie zum Beispiel bei Kettenaufrufen oder über eine zwischenzeitliche Zuweisung zu einer temporären Variablen."
"Trotzdem stellt sich die Frage, ob sich das in Abschnitt 26.3 angesprochene allgemeine Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischen Polymorphismus nicht irgendwie lösen lässt. Die Antwort ist unbefriedigend: nur zum Teil.",Kann das Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mit parametrischen Polymorphismus gelöst werden?,"Nur zum Teil, da parametrischer Polymorphismus zwar die Verwendung von verschiedenen Typen von Eingabeparametern ermöglicht, aber nicht die kovariante Redefinition von Eingabeparametern in Unterklassenmethoden."
"Eine Methode, die die obige Methode aufruft, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft.",Was ist ein Try-Catch-Block in der Programmierung?,"Ein Try-Catch-Block ist eine Programmstruktur, die eine Ausnahmebehandlung ermöglicht. Der Try-Block enthält den Code, der möglicherweise eine Ausnahme auslöst, während der Catch-Block den Code enthält, der die Ausnahme behandelt."
"ng, bei der eine Instanz eine andere Instanz als Sklavin hält, die für sie einen Dienst verrichtet. Im Gegensatz zur Vererbung kann die Delegation dynamisch eingerichtet werden und ist nicht an Fragen der Generalisierung/Spezialisierung gebunden.",Was ist Delegation und wie wird sie in prototypenbasierten objektorientierten Programmiersprachen genutzt?,"Delegation ist eine Beziehung zwischen zwei Objekten, bei der ein Objekt (Delegierter) die Verantwortung für die Bearbeitung bestimmter Anfragen an ein anderes Objekt (Delegator) überträgt. In prototypenbasierten objektorientierten Programmiersprachen wird Delegation genutzt, um die Funktion der Vererbung zu übernehmen. Sie kann dynamisch eingerichtet werden und ist von Fragen der Generalisierung/Spezialisierung befreit, was sie zu einer beliebten Alternative zur Vererbung macht."
,Wofür steht das Gleichheitszeichen = in Java?,"Das Gleichheitszeichen = in Java steht für die Wertzuweisung, nicht für die Überprüfung der Gleichheit von Objekten."
,"Ist ""SortedList<String>"" ein Subtyp von ""SortedList<Comparable>""?","Nein, ""SortedList<String>"" ist kein Subtyp von ""SortedList<Comparable>"". Die Einschränkung ""<E extends Comparable<E>>"" in ""SortedList"" sorgt dafür, dass der Typparameter ""E"" ein Subtyp von ""Comparable<E>"" sein muss, aber sie schafft keine Subtypenbeziehung zwischen den ""SortedList""-Instanzen selbst."
"Zu 3.: In der Vergangenheit hatten Variablen eher kurze, wenig selbsterklärende Namen (vgl. dazu auch Kapitel 62 in Kurseinheit 7). Es ist dann sinnvoll, wenigstens an der Stelle der ersten Erwähnung der Variablen (in der Regel deren Deklaration) einen Hinweis darauf zu haben, wofür (für welche Menge von Objekten) die Variable steht. Dies kann über einen Kommentar erfolgen, aber auch durch die Assoziation mit einem Typen, die aussagt, welcher Art die Werte der Variable sein müssen. Doch nicht nur Variablen-, auch Methodennamen können für sich genommen wenig aussagekräftig sein und durch die Verknüpfung mit Typen aussagekräftiger gemacht werden: Eine Deklaration der Methode next etwa, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, legt nahe, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren. Dem mag man freilich entgegenhalten, dass man stattdessen ja auch selbsterklärende Namen für Variablen und Methoden vergeben könnte (mehr dazu in Kurseinheit 7, Kapitel 62).","Warum ist es sinnvoll, Variablen und Methoden mit Typen zu assoziieren?","Es ist sinnvoll, Variablen und Methoden mit Typen zu assoziieren, um die Bedeutung der Variablen und Methoden für den Nutzer zu verdeutlichen. Zum Beispiel kann eine Deklaration der Methode next, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, nahelegen, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren."
"Aber solange man sich nicht sicher ist, dass eine (vermeintliche) Abkürzung funktional äquivalent ist (also dasselbe Ergebnis liefert), sollte man von solchen Optimierungen die Finger lassen. (Es könnte beispielsweise sein, dass ""auswerten"" für ""Literale"" einen Seiteneffekt hat; in diesem Fall wären die optimierten Versionen nicht mehr äquivalent!)",Warum sollte man bei Optimierungen vorsichtig sein?,"Man sollte bei Optimierungen vorsichtig sein, weil nicht sichergestellt ist, dass die optimierte Version funktional äquivalent ist und dasselbe Ergebnis liefert. Zum Beispiel könnte ""auswerten"" für ""Literale"" einen Seiteneffekt haben, was die optimierten Versionen ungleich machen würde."
,Wie gibt man in Java den Typ einer Klasse als Wert an?,"In Java gibt man den Typ einer Klasse als Wert mittels eines sogenannten Klassenliterals an. Dieses besteht aus dem Namen der Klasse, gefolgt von "".class"", z. B. ""Klasse.class""."
"Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.",Warum führen Abhängigkeiten zwischen Paketen zu öffentlichen Deklarationen?,"Wenn zwischen Paketen Abhängigkeiten bestehen, sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente für alle gleichermaßen sichtbar machen."
,"Wie funktioniert die Verwendung eines Intervalls in einer ""For""-Schleife?","In einer ""For""-Schleife verwendet man ein Intervall, um durch die darin enthaltenen Werte zu iterieren. Zum Beispiel bewirkt der Ausdruck 5 to: 1 by: -2 do: [:i | ""Code hier""], dass dem Laufparameter ""i"" nacheinander die Werte 5, 3 und 1 zugewiesen werden."
"Da Klassen selbst Objekte sind, sind ""new"" und ""new:"" Instanzmethoden der Klassen. Dabei sind ""basicNew"" und ""basicNew:"" ebenfalls Instanzmethoden der Klasse, deren Implementierung allerdings primitiv ist. Sie geben eine neue Instanz (ein neues Objekt) der Klasse, auf der sie aufgerufen wurden, zurück. Da durch ""basicNew"" und ""basicNew:"" alle Instanzvariablen der erzeugten Objekte den Wert ""nil"" zugewiesen bekommen, wird auf den neuen Objekten vor ihrer Rückgabe die Methode ""initialize"" aufgerufen. ""Initialize"" ist eine Instanzmethode des neuen Objekts, die die Instanzvariablen je nach Klasse, in der die Methode definiert ist, anders belegt.","Was sind ""basicNew"" und ""basicNew:"" in Bezug auf Klassen?","""basicNew"" und ""basicNew:"" sind Instanzmethoden der Klasse, die eine neue Instanz der Klasse zurückgeben, auf der sie aufgerufen wurden. Alle Instanzvariablen der erzeugten Objekte bekommen den Wert ""nil"" zugewiesen."
,Wie unterscheiden sich die Weltansichten von Generalisierung/Spezialisierung und Vererbung?,"Generalisierung/Spezialisierung repräsentieren die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze (Client-Schnittstelle). Vererbung hingegen repräsentiert die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung (Vererbungsschnittstelle). Generalisierung/Spezialisierung versuchen, Komplexität durch Strukturierung zu reduzieren, während Vererbung eine Art genetischen Zusammenhang zwischen Klassen darstellt, der deren Entstehung aus Vorhandenem widerspiegelt. Beide Sichten führen nicht automatisch zum selben Ergebnis, und die Kunst des objektorientierten Entwurfs besteht darin, sie in Einklang zu bringen."
"Damit meinen wir, dass für eine Implementierung von m in der zugehörigen Klasse von T, die auf einem Empfängerobjekt vom Typ T (einer Instanz der entsprechenden Klasse) aufgerufen wird, die Nachbedingung aus der Vorbedingung folgt. Wir müssen diesen Beweis jedoch nicht führen, da unser Interesse hier nicht auf der Korrektheit der Implementierungen an sich liegt, sondern vielmehr daran, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird und es durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Mehr dazu in Abschnitt 54.5.",Was ist der Zweck der Nachbedingung in der objektorientierten Programmierung?,"Der Zweck der Nachbedingung in der objektorientierten Programmierung ist es, die Korrektheit der Implementierung zu gewährleisten. Die Nachbedingung wird aus der Vorbedingung abgeleitet und gilt für die Implementierung einer Methode in der zugehörigen Klasse. Der Beweis für die Nachbedingung muss nicht geführt werden, da es hier um die Austauschbarkeit von Implementierungen abhängig vom Verwendungskontext geht."
,"Warum werden in SMALLTALKs Klassendefinitionen keine Typen verwendet, und wie werden formale Parameter in Bezug auf Typen behandelt?","In SMALLTALK werden keine Typen in Klassendefinitionen verwendet, und formale Parameter verwenden stattdessen Namen wie ""aString"" oder ""anInteger"", die darauf hinweisen, welcher Klasse der Wert sein sollte. Dies wird jedoch nicht überprüft."
"Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.","Was bedeutet es, wenn Members in Java als ""static"" deklariert werden?","Wenn Members in Java als ""static"" deklariert werden, beziehen sie sich nicht auf Objekte, sondern auf die Klasse selbst. Es handelt sich also um Klassenvariablen und -methoden, die nicht dynamisch gebunden werden."
,"Welches Framework wurde für die Implementierung der Methoden forEach, filter, map und reduce in Java 8 geschaffen?","Für die Implementierung der Methoden forEach, filter, map und reduce in Java 8 wurde das Stream-Framework geschaffen."
,Welche Informationen können in einer Metaklasse definiert werden?,"In einer Metaklasse können Informationen wie Instanzvariablen und Methoden für die zugehörige Klasse definiert werden. Dies ermöglicht es, das Verhalten und die Eigenschaften der Klasse individuell anzupassen."
"Dabei ist allerdings zu beachten, dass die Klasse des durch self bezeichneten Objekts nicht unbedingt dieselbe sein muss, in der die gerade ausgeführte Methode (in der auch das self steht) definiert ist, denn das kann ja aufgrund von Vererbung durchaus eine Superklasse sein. Das hat eine fundamentale Auswirkung: Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden, nämlich dann, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde.",Was ist die Bedeutung von self in Smalltalk?,"In Smalltalk bezieht sich self auf das Objekt, auf das die gerade ausgeführte Methode angewendet wird. Die Klasse des durch self bezeichneten Objekts muss nicht unbedingt dieselbe sein, in der die Methode definiert ist, sondern kann durchaus eine Superklasse sein. Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden."
,Wann wird die Frage der Substituierbarkeit interessant?,"Die Frage der Substituierbarkeit wird interessant, wenn Objekte nicht derselben Klasse angehören und eine gewisse Abweichung im Verhalten der zu substituierenden Objekte erlaubt ist."
"Zu den prominentesten Eigenschaften des Typsystems von EIFFEL zählen: Mehrfachvererbung. Generizität (genauer: beschränkter parametrischer Polymorphismus; siehe Abschnitt 29.4 in Kurseinheit 3). Das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden; siehe dazu auch Abschnitt 11.3 in Kurseinheit 1). Kovariante Redefinition, unterstützt durch sog. ""verankerte Typen"" (engl. ""anchored types""; so gut wie ein Alleinstellungsmerkmal von EIFFEL).",Was sind die prominentesten Eigenschaften des Typsystems von EIFFEL?,"Die prominentesten Eigenschaften des Typsystems von EIFFEL sind Mehrfachvererbung, Generizität, das Unterdrücken von Instanzvariablen und Methoden in Subklassen, und kovariante Redefinition, unterstützt durch sog. ""verankerte Typen""."
,Wie erfolgt die Synchronisation von parallelen Prozessen in SMALLTALK?,"Die Synchronisation von parallelen Prozessen in SMALLTALK erfolgt zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen über Methoden wie ""wait"" und ""signal"", um die Ausführung von Prozessen zu steuern. Semaphore-Objekte zählen die Anzahl der Signale und können Prozesse in den Schlaf versetzen oder aufwecken, abhängig von ihrem aktuellen Zustand. Die Synchronisation kann auch über die Klasse SharedQueue erfolgen, die Objekte aufnimmt und Synchronisation über ""next"" und ""nextPut:"" ermöglicht."
"Dass eine Generalisierung bereits über Spezialisierungen verfügt, hindert eine Klasse nicht daran, neue hinzuzufügen. So ist es beispielsweise im obigen Beispiel von ""Zweibeiner"" denkbar, dass man im Nachhinein noch ""Menschenaffe"" als Spezialisierung ergänzt. Als Unterscheidungsmerkmal könnte z. B. eine Methode ""klettern"" dienen, die Mensch und Vogel fehlt. Sie zu ergänzen stellt überhaupt kein Problem dar - ja, es ist sogar eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind. Mehr dazu in Kapitel 26 in Kurseinheit 3.","Kann eine Klasse neue Spezialisierungen hinzufügen, wenn die Generalisierung bereits über Spezialisierungen verfügt?","Ja, eine Klasse kann neue Spezialisierungen hinzufügen, wenn die Generalisierung bereits über Spezialisierungen verfügt. Das ist eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind."
"Wie Ihnen sicher aufgefallen ist, sind einige der Arten von Typen aus der obigen Liste jeweils durch eine spezielle Klasse (Array, Delegate, Attribute) vertreten. Man kann dies als Hinweis darauf verstehen, dass tatsächlich alle Arten von Typen integriert sind und es keine grundsätzlichen Barrieren zwischen ihnen gibt. In C-Sharp haben alle Klassen außer System.Object, genau wie in Java, genau eine Superklasse. Sie können jedoch beliebig viele Interfaces implementieren. Die Tatsache, dass Werttypen als Subtypen eines Referenztypen (nämlich Object) deklariert sind, verrät außerdem, dass C-Sharp über Auto-Boxing und Unboxing verfügt.",Wie sind alle Arten von Typen in C-Sharp integriert?,"Alle Arten von Typen sind in C-Sharp integriert, was daran zu erkennen ist, dass einige Arten von Typen durch spezielle Klassen (Array, Delegate, Attribute) vertreten sind. Klassen, außer System.Object, haben genau eine Superklasse und können beliebig viele Interfaces implementieren. Die Tatsache, dass Werttypen als Subtypen eines Referenztyps (nämlich Object) deklariert sind, verrät außerdem, dass C-Sharp über Auto-Boxing und Unboxing verfügt."
"Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht für eine besondere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung. Die Gegenrolle heißt Supertyp.",Was ist eine Klasse?,"Eine Klasse ist ein Bauplan für Objekte, die beschreibt, welche Attribute und welches Verhalten ein Objekt hat."
"Im Vergleich zu anderen Methoden erlauben Konstruktordefinitionen in Java keine Angabe eines Rückgabetyps. Da die erzeugte Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist, ist der Typ festgelegt. Die Angabe des Rückgabetyps in Konstruktordefinitionen ist daher nicht erforderlich.",Warum wird im Kontext kein Rückgabetyp für den Konstruktor angegeben?,"Im Vergleich zu anderen Methoden erlauben Konstruktordefinitionen in Java keine Angabe eines Rückgabetyps. Da die erzeugte Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist, ist der Typ festgelegt."
"Anders als bei Java waren bei C-Sharp Flexibilität und Performanz von Anfang an kritische Gesichtspunkte des Sprachentwurfs. Für C-Sharp war daher von Anfang an und ausschließlich die sog. Just-in-time-(JIT-)Kompilierung vorgesehen, die den CIL-Code unmittelbar vor der Ausführung (und nur, wenn er überhaupt ausgeführt wird) in Maschinencode der Maschine, auf der er gerade läuft, übersetzt. Die Einheiten der JIT-Kompilierung gehen dabei hinunter bis zu einzelnen Methoden. Eine vollständige Kompilierung von CIL in nativen Maschinencode vor der Ausführung ist ebenfalls möglich.",Was ist Just-in-time-(JIT-)Kompilierung in C-Sharp?,"Bei C-Sharp ist die Just-in-time-(JIT-)Kompilierung eine Technik, bei der der CIL-Code unmittelbar vor der Ausführung (und nur, wenn er überhaupt ausgeführt wird) in Maschinencode der Maschine, auf der er gerade läuft, übersetzt wird. Die Einheiten der JIT-Kompilierung gehen dabei hinunter bis zu einzelnen Methoden."
"Was die Instanzvariablen angeht, so muss Rechteck die Instanzvariable laenge nicht neu definieren, sondern lediglich breite hinzufügen. Allerdings können die Methoden zur Berechnung von Fläche und Umfang nicht mitgeerbt werden, obwohl Quadrate und Rechtecke die Eigenschaft teilen, über solche Merkmale zu verfügen. Die entsprechenden Methoden müssen also in Rechteck neu definiert werden. Man nennt das Überschreiben, weil die neuen Methoden dasselbe tun wie die alten. Die Möglichkeit des Überschreibens ist häufig Voraussetzung dafür, Vererbung überhaupt sinnvoll einzusetzen.",Was ist Überschreiben in der objektorientierten Programmierung?,"Überschreiben bedeutet, dass eine Unterklasse dieselben Methoden wie ihre Superklasse besitzt, aber die Unterklasse die Methoden anders implementiert. Das ist häufig Voraussetzung dafür, Vererbung überhaupt sinnvoll einzusetzen."
"Analog zur Einführung von parametrisierten Typen abstrahieren die generischen Typen von Java von Typen, indem sie die Referenzierung eines oder mehrerer Typen innerhalb einer Typdefinition durch Typvariablen ersetzen. Anders als in STRONGTALK stehen die Typvariablen in Java jedoch nicht in eckigen, sondern in spitzen Klammern.",Was sind generische Typen in Java?,"Generische Typen in Java sind eine Abstraktion von Typen, bei der die Referenzierung eines oder mehrerer Typen innerhalb einer Typdefinition durch Typvariablen ersetzt wird. Diese Typvariablen stehen in Java jedoch nicht in eckigen, sondern in spitzen Klammern."
"Dass Typerweiterung als Basis des Subtyping keine technischen Probleme bereitet, sollte hinreichend klargeworden sein: Typfehler sind damit ausgeschlossen, und es bleibt lediglich das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind (wie im Beispiel von zweidimensionalen und dreidimensionalen Punkten). Es bleibt noch die Frage, ob und falls ja, in welchem Umfang Typeinschränkung im Rahmen des Subtyping erlaubt ist. Diese Frage soll an einem Beispiel beantwortet werden.",Was ist Typerweiterung und warum bereitet sie keine technischen Probleme?,"Typerweiterung ist eine Möglichkeit, eine neue Unterklasse von einer bestehenden Klasse abzuleiten, indem neue Attribute und Methoden hinzugefügt werden. Es bereitet keine technischen Probleme, weil es keine Typfehler verursacht, da die Unterklasse alle Merkmale der Oberklasse erbt und zusätzliche Merkmale hinzufügen kann. Das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind, kann nicht immer vermieden werden, aber es ist kein technisches Problem."
"Auch wenn es in großen Teilen recht ähnlich aussieht, weicht das Typsystem von C-Sharp in mehreren wesentlichen Punkten von dem von Java ab: der Art der Unterscheidung von Wert- und Referenztypen, den angebotenen Typkonstruktoren für Wert- und Referenztypen und dem Umgang mit Interfaces als Typen.",Wie werden Interfaces in C-Sharp verwendet?,"In C-Sharp können Interfaces als Typen verwendet werden, das heißt, dass eine Variable einen Interface-Typ haben kann."
,"Was ist das Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) und warum ist es wichtig?","Das Liskov-Substitutionsprinzip (LSP) ist ein Prinzip im Zusammenhang mit Subtyping, das von Barbara Liskov und Jeannette Wing entwickelt wurde. Es besagt, dass ein Subtyp (z. B. eine abgeleitete Klasse) eines Typs (z. B. eine Basisklasse) sich so verhalten sollte, dass er anstelle des Supertyps (der Basisklasse) in jedem Programm oder Kontext verwendet werden kann, ohne die Korrektheit des Programms zu gefährden. Das LSP ist wichtig, um sicherzustellen, dass Subtypen die Spezifikationen und das Verhalten des Supertyps beibehalten und korrekt verwenden."
"Ein Nachteil der objektorientierten Programmierung (wie auch aller anderen heute bekannten Programmierparadigmen) ist sicherlich, dass die sog. Trennung der Belange, besser bekannt als die Separation of Concerns, nur unzureichend unterstützt wird. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar hoch gehandelt, sind aber dennoch nicht im Mainstream angekommen. Die Gründe dafür mögen vielfältig sein, aber letztlich ist es wohl immer illusorisch zu versprechen, man könne die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen. Insbesondere die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten: Wie so oft muss das Ganze mehr sein als die Summe seiner Teile, um seinen Zweck zu erfüllen. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen.",Was ist die Trennung der Belange (Separation of Concerns) in der objektorientierten Programmierung?,"Die Trennung der Belange, auch Separation of Concerns genannt, ist ein Prinzip in der objektorientierten Programmierung, das die Aufgaben und Verantwortlichkeiten von Objekten und Komponenten klar trennen soll. Es ist jedoch unzureichend unterstützt und kann die Komplexität nur in das Zusammenführen der Sichten verschieben."
"Es stellt sich die Frage, wie der Mechanismus der Vererbung genau umgesetzt wird. Eine Möglichkeit wäre z. B., die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Das wäre zwar möglich und würde auch die Semantik der Vererbung korrekt wiedergeben, würde aber das (technische) Problem mit sich bringen, dass bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müssten.",Was ist der Zweck der Vererbung?,"Der Zweck der Vererbung ist es, die Definition einer Superklasse auf eine Subklasse zu übertragen, um die Code-Reusability zu erhöhen und die Wartbarkeit des Codes zu verbessern."
"EIFFEL nimmt unter den hier behandelten Sprachen eine Sonderstellung ein. Es soll nämlich mehrere Dinge auf einmal sein: eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache.",Was ist die Sonderstellung von EIFFEL unter den hier behandelten Sprachen?,"EIFFEL ist eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache."
"Eine etwas eingeschränktere Sicht auf den Zustand eines Objekts berücksichtigt lediglich seine Attributwerte. Dies setzt jedoch voraus, dass überhaupt eine klare Unterscheidung zwischen Attributen und Beziehungen getroffen werden kann. In Ermangelung spezieller Schlüsselwörter könnte dies, wie bereits oben diskutiert, allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese Unterscheidung ist jedoch nicht immer eindeutig, und in einigen Programmiersprachen ist sie gar nicht zutreffend (z.B., in Java, in dem Strings zwar unveränderlich sind und daher eigentlich als Werte gelten, aber dennoch Referenzsemantik aufweisen). In SMALLTALK hingegen, in dem alle Instanzvariablen Referenzen sein können, ist diese Einschränkung nicht anwendbar.",Was unterscheidet Attribute und Beziehungen?,Die Unterscheidung zwischen Attributen und Beziehungen kann in Ermangelung spezieller Schlüsselwörter allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese ist jedoch in einigen Programmiersprachen nicht immer eindeutig ist und beispielsweise in Java gar nicht zutreffend.
,"Was bedeutet es, dass Java eine stark typisierte Sprache ist?","Java ist eine stark typisierte Sprache, was bedeutet, dass alle Ausdrücke einen Typ haben und Variablen bei ihrer Deklaration einen Typ angeben müssen."
,Wie sieht die Dereferenzierung eines Zeigers auf ein Objekt in C++ aus?,"In C++ erfolgt die Dereferenzierung eines Zeigers auf ein Objekt mit ""->"", z.B., ""a->x"" oder ""a->f(x)"" für ein Feld oder eine Methode der Klasse."
"Bei der Generalisierung können also Eigenschaften, die verschiedene, aber ähnliche Klassen unterscheiden, weggelassen (oder ""abstrahiert"") werden. Das Weglassen ist jedoch nicht die einzige Form der Generalisierung. Es können auch Eigenschaften generalisiert werden, wobei dann der Begriff der Generalisierung rekursiv angewendet wird. Unter der Generalisierung von Attributen (oder allgemeiner von Instanzvariablen; siehe Abschnitt 2.4) versteht man, dass ihr Wertebereich von einem spezielleren (kleineren) zu einem allgemeineren (größeren) erweitert wird. Zum Beispiel würde das Attribut ""Aufenthaltsort,"" das mit (Instanzen der) Klasse Mensch assoziiert ist, bei der Generalisierung zu Zweibeiner von Punkten auf der Erdoberfläche zu Punkten einschließlich des Luftraums darüber generalisiert, um auch den Wertebereich für Vögel abzudecken. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen. Wie Sie später sehen werden, erlauben die meisten Programmiersprachen, die die Möglichkeit der Wertebeschränkung von Variablen bieten, aus guten Gründen nicht, Attributwertebereiche bei der Generalisierung ebenfalls zu generalisieren (die sogenannte kovariante Redefinition; siehe dazu auch die Kapitel 25 und Abschnitt 26.3 in Kurseinheit 3).",Was ist Generalisierung in der objektorientierten Programmierung?,"In der Objektorientierten Programmierung ist Generalisierung ein Prozess, bei dem Eigenschaften, die verschiedene, aber ähnliche Klassen unterscheiden, weggelassen oder abstrahiert werden. Dies kann auch rekursiv angewendet werden, indem der Begriff der Generalisierung auf Attribute oder Instanzvariablen angewendet wird, wodurch ihr Wertebereich von einem spezielleren auf ein allgemeineres erweitert wird. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen."
,Welche Art von Typprüfungen kann Java zur Übersetzungszeit durchführen?,Java kann zur Übersetzungszeit statische Typprüfungen durchführen.
"Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode entworfen und implementiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. Testphase: In dieser Phase wird das Programm getestet, um sicherzustellen, dass es korrekt funktioniert. Die Typisierung kann dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode definiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren, und sie kann auch verwendet werden, um die Konsistenz der Daten während der Ausführung des Programms zu gewährleisten. Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben. Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält. Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert. Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.",Wie hilft die Typisierung während der Implementierungsphase?,"Die Typisierung hilft während der Implementierungsphase sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben."
"Objekte, die keine literale Repräsentation haben, müssen in Java (wie in SMALLTALK) explizit als Instanzen von Klassen erzeugt werden. Dafür gibt es in Java eine spezielle Kategorie von Methoden, die als Konstruktoren bezeichnet werden. Im Unterschied zu SMALLTALK sind Konstruktoren in Java keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne kann man Konstruktoren als Instanzmethoden betrachten, die auf der neu erzeugten Instanz aufgerufen werden.",Was sind Konstruktoren in Java?,"Konstruktoren sind spezielle Methoden in Java, die verwendet werden, um Objekte zu erzeugen, die keine literale Repräsentation haben. Sie sind keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können."
"Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem Interface veröffentlichten noch weitere öffentliche (public deklarierte) Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces einer Klasse unterschiedliche Methodenmengen zur Verfügung stellen können. Da auf eine Variable, die mit einem Interfacetyp deklariert wurde, aber immer nur die Methoden aufgerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgreichen Prüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten können), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. So kann beispielsweise ein Ein- und Ausgabestrom als Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben:",Was sind die Vorteile von Interfaces?,"Interfaces ermöglichen es, unterschiedliche Sichten auf ein Objekt zu gewähren, indem sie unterschiedliche Methodenmengen zur Verfügung stellen. Dadurch können beispielsweise auf eine Variable, die mit einem Interfacetyp deklariert wurde, nur die Methoden aufgerufen werden, die der Interfacetyp veröffentlicht. Dies führt zu einer besseren Kapselung und erhöht die Sicherheit, da Laufzeitfehler vermieden werden können."
"In der objektorientierten Programmierung werden Beziehungen zwischen Objekten über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten ""navigieren"". Es ist wichtig zu beachten, dass diese Verknüpfung immer gerichtet ist. Das bedeutet, dass man von einem Objekt zu einem anderen navigieren kann, aber nicht zwangsläufig wieder zurück. Dafür wäre ein Zeiger in Gegenrichtung erforderlich.Variablen selbst enthalten ebenfalls Verweise. Wer also Zugriff auf die Variable hat, kann auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.",Wie werden Variablen für Beziehungen genutzt?,"Variablen enthalten Verweise. Wenn jemand Zugriff auf die Variable hat, kann er auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden."
"Zu 2.: Wenn man weiß, dass die Werte einer Variable immer vom selben Typ sind, also alle demselben Wertebereich entstammen, dann lassen sich bestimmte Optimierungen durchführen. Wenn man z. B. aufgrund der Deklaration einer Variable x für gegeben annehmen kann, dass x nur ganze Zahlen enthält, dann kann der Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkrement-Anweisung des Prozessors verwenden. Kennt der Compiler den Typ von x hingegen nicht, dann muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist — handelt es sich um eine Fließkommazahl, so muss es zu der entsprechenden Operation verzweigen, handelt es sich womöglich um gar keine Zahl, dann muss es einen Laufzeitfehler signalisieren oder sich etwas anderes einfallen lassen. Dem kann man entgegenhalten, dass im Falle der objektorientierten Programmierung selbst bei einer Typisierung aller Variablen gelegentlich noch Laufzeittests durchgeführt (oder andernfalls schwere Programmfehler in Kauf genommen) werden müssen, und dass sich die zur Optimierung benötigte Information auch anders als über explizite Typisierung von Variablen (z. B. über die sog. Typinferenz, also die Ausnutzung impliziter Typinformation) gewinnen lässt.","Warum ist es vorteilhaft, wenn man den Typ einer Variablen kennt?","Wenn man den Typ einer Variablen kennt, kann der Compiler bestimmte Optimierungen durchführen, wie z.B. die Ganzzahladdition oder die Inkrement-Anweisung des Prozessors verwenden. Wenn der Compiler den Typ nicht kennt, muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist, was zu Laufzeitverzögerungen führen kann."
"Dabei ist allerdings zu beachten, dass die Klasse des durch self bezeichneten Objekts nicht unbedingt dieselbe sein muss, in der die gerade ausgeführte Methode (in der auch das self steht) definiert ist, denn das kann ja aufgrund von Vererbung durchaus eine Superklasse sein. Das hat eine fundamentale Auswirkung: Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden, nämlich dann, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde.","Was passiert, wenn an self eine Nachricht geschickt wird?","Wenn an self eine Nachricht geschickt wird, wird die zu dieser Nachricht passende Methode gesucht. Die Suche beginnt in der Klasse, in der die gerade ausgeführte Methode definiert ist. Wenn die Methode nicht in dieser Klasse gefunden wird, wird die Suche in der Kette der Superklassen fortgesetzt, bis die Methode gefunden wird."
"Wenn Sie If und While schon kennen, kennen Sie sicher auch For. Die klassische Form der For-Schleife verwendet eine Zählvariable, einen Anfangswert, ein Inkrement (das auch negativ, also ein Dekrement sein kann) sowie einen Endwert. Solche For-Schleifen gibt es in SMALLTALK auch.Hier interessiert uns aber vor allem eine Form der Iteration, die nicht einer einfachen Zählschleife entspricht, sondern über eine Menge von beliebigen Objekten geht. Solche Mengen sind uns ja schon begegnet, wenn auch nur in Gestalt von literalen Arrays.Anders als in vielen anderen Sprachen kann man in SMALLTALK über die Elemente eines Arrays direkt, also ohne die Verwendung einer Zählschleife, deren Laufvariable als Index in das Array dient, iterieren. i ist aber diesmal keine Zählvariable, da hier nichts gezählt wird; es ist vielmehr eine Laufvariable, der der Reihe nach die Elemente des literalen Arrays #(5) zugewiesen werden. do: ersetzt also ganz offensichtlich das aus manchen anderen Sprachen bekannte For-each-Konstrukt.Wie wir gleich sehen werden, ist die Iteration, also das Fortschalten der Elemente und die Überprüfung der Abbruchbedingung, in der Collection, über die iteriert wird, implementiert. Deshalb nennt man dieses Verfahren auch interne Iteration (im Gegensatz zur herkömmlichen externen Iteration, bei der die Laufvariable selbst gesetzt und abgefragt werden muss).Die Implementierung der Kontrollstruktur erfolgt wiederum selbst in SMALLTALK und ist ziemlich einfach. Dabei ist to:do: für Ganzahlen analog zu dem bereits erwähnten to:by:do implementiert. Die Zählvariable index des Blocks läuft von 1 bis zur Anzahl der indizierten Instanzvariablen des Empfängers von do: (im obigen Beispiel ein Array). Diese Anzahl wird über den Aufruf von size auf dem Empfänger (repräsentiert durch self) abgefragt. Der Inhalt der indizierten Instanzvariable n des Empfängers wird dann der Reihe nach als Parameter mittels value: an den Block aBlock zur Auswertung geschickt.",Was ist externe Iteration?,Bei der traditionellen externen Iteration muss manuell eine Schleifenvariable als Index verwaltet werden.
"Genau wie in SMALLTALK werden in Java Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Anders als in SMALLTALK gibt es in Java jedoch eine Vielzahl von Schlüsselwörtern, die Anweisungen einleiten. Dennoch ist es auch in Java möglich, bestimmte Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden Ausdruck durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen (siehe Kapitel 37) direkt zu Anweisungen. Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK, das Semikolon in Java kein Trennzeichen ist, sondern Teil der Anweisung.",Was ist der Unterschied zwischen einem Ausdruck und einer Anweisung in Java?,"In Java werden Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Ein Ausdruck wird zu einer Anweisung, indem er mit einem Semikolon abgeschlossen wird. Im Gegensatz zum Semikolon in PASCAL oder dem Punkt in SMALLTALK ist das Semikolon in Java kein Trennzeichen, sondern Teil der Anweisung. Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen sind in Java direkt als Anweisungen möglich."
"Beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimensionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays in Java auch gar nicht um mehrdimensionale Arrays, sondern um Arrays von Arrays).",Was sind Ragged oder Jagged arrays in Java?,"Ragged oder Jagged arrays in Java sind mehrdimensionalen Arrays, bei denen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten müssen."
"Die Klasse Dictionary hat für die Programmierung besondere Bedeutung: Sie realisiert sogenannte Assoziativspeicher, also Speicher, bei dem auf eine Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet. So werden beispielsweise Methoden in Dictionaries hinterlegt (wobei der Nachrichtenselektor die Rolle des Schlüssels spielt und als Wertobjekt die kompilierte Methode gespeichert ist). Aber auch andere Arten von Collections lassen sich mit Hilfe von Dictionaries sehr einfach realisieren.",Was ist die Klasse Dictionary in SMALLTALK?,"Die Klasse Dictionary in SMALLTALK realisiert sogenannte Assoziativspeicher, bei denen auf eine Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet, zum Beispiel für das Hinterlegen von Methoden in Dictionaries."
"BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.",Was ist die Position von Bertrand Meyer zum Überladen von Methoden?,Bertrand Meyer ist ein entschiedener Gegner des Überladens.
,Wie werden in EIFFEL Abfragen und Befehle logisch unterteilt?,"In EIFFEL werden Methoden einer Klasse als ""Abfragen"" (queries) und ""Befehle"" (commands) logisch unterteilt. Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern."
"In Java ist es nicht möglich, Pointervariablen explizit zu deklarieren. Daher gibt es insbesondere beim Methodenaufruf (und den damit verbundenen impliziten Zuweisungen) kein ""Call by reference"" in Java, sondern nur ein ""Call by value"". Dies ändert sich auch nicht, wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben. Weitere Informationen finden Sie auch in den Bemerkungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.",Wie werden Parameter in Java übergeben?,"In Java werden Parameter immer durch Wertübertragung übergeben, auch wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben."
"Nun sind Typumwandlungen entweder überflüssig oder unsicher. Man sollte daher versuchen, auf sie zu verzichten. Wo unverzichtbar, sollten Typumwandlungen mit einem Typtest abgesichert werden. Dabei wird zur Laufzeit geprüft, ob das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat. Ist das nicht der Fall, sollten die Teile des Programms, die den bei der Typumwandlung genannten Typ voraussetzen, nicht ausgeführt werden. Sie werden in späteren Kapiteln zu den einzelnen Programmiersprachen noch Beispiele für diese Praxis zu sehen bekommen.",Was ist der Zweck von Typumwandlungen in der Programmierung?,"Typumwandlungen sind in der Programmierung entweder überflüssig oder unsicher. Wenn sie unverzichtbar sind, sollten sie mit einem Typtest abgesichert werden, um sicherzustellen, dass das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat."
,Welche Funktion haben Streams in Bezug auf Collections?,"Streams ermöglichen einen sequentiellen Zugriff auf einzelne Elemente in Collections zu beliebigen Zeitpunkten. Dies unterscheidet sich von Iteratoren, die die gesamte Collection in einem Schritt durchlaufen. Streams ermöglichen auch den gleichzeitigen oder zeitlich abwechselnden Zugriff auf die Elemente einer Collection durch mehrere andere Objekte. Streams stellen Positionszeiger in eine Collection bereit, um diese Funktionen umzusetzen."
"Nun dienen Collections ja u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen (s. Kurseinheit 2, Kapitel 13). Und so bilden die mit den Collection-Klassen assoziierten Typen auch nur die Typen für die Zwischenobjekte. Was man jedoch eigentlich bei der Deklaration von n-wertigen Attributen angeben (deklarieren) möchte, ist der Typ der in Beziehung stehenden Objekte.",Wie kann man den Typ der in Beziehung stehenden Objekte bei der Deklaration von n-wertigen Attributen angeben?,"Man kann den Typ der in Beziehung stehenden Objekte bei der Deklaration von n-wertigen Attributen angeben, indem man die Collection-Klassen als Typen für die Zwischenobjekte verwendet."
"Wie in SMALLTALK gibt es in Java abstrakte Klassen. Anders als in SMALLTALK verwendet Java jedoch das Schlüsselwort ""abstract,"" mit dem man eine Klasse als abstrakt und damit als nicht instanziierbar deklarieren kann.",Wie werden abstrakte Klassen in Java deklariert?,"In Java werden abstrakte Klassen mit dem Schlüsselwort ""abstract"" deklariert, um sie als abstrakt und damit als nicht instanziierbar zu kennzeichnen."
"Sie kennen vielleicht aus anderen Programmiersprachen, dass Variablen und anderen Programmelementen bei ihrer Deklaration (Kapitel 19) ein Typ zugeordnet wird. Dieser Typ schränkt die möglichen Werte der deklarierten Elemente ein. So lassen sich beispielsweise in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zeichenketten speichern.",Was ist der Zweck der Typisierung in Programmiersprachen?,"Der Zweck der Typisierung in Programmiersprachen ist es, den möglichen Wertebereich von Variablen und anderen Programmelementen einzuschränken. So lassen sich beispielsweise in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zeichenketten speichern."
,Können explizite Interfaceimplementierungen in C-Sharp überschrieben werden?,"Nein, explizite Interfaceimplementierungen können nicht überschrieben werden. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut."
"Für peek ist die freie Positionierbarkeit notwendig, weil man dazu erst das nächste Element anspringen und dann wieder einen Schritt zurückgehen muss. Da ein Stream (wie eine Collection) eine Menge von Objekten repräsentiert, möchte man darüber (genau wie über eine Collection) iterieren können. Die Iteratoren von Streams sind jedoch etwas spezieller als die von Collections. Sie sind sog. ""Single-use""-Iteratoren, d.h. nachdem man einmal next() aufgerufen hat, ist das Iterator-Objekt ungültig. Außerdem wird natürlich zwischen (nur) lesbaren und schreibbaren Streams unterschieden.",Was ist ein Single-use Iterator?,"Ein Single-use Iterator ist ein Iterator, der, nachdem man einmal die next()-Methode aufgerufen hat, ungültig wird. Das bedeutet, dass man ihn nicht mehr verwenden kann, um weitere Elemente des Streams zu iterieren."
"Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in Java oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).",Wie ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen in STRONGTALK?,"In STRONGTALK sind die formalen Parameter der Methoden in den Klassendefinitionen typisiert, was die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer macht."
,Wie startet man einen neuen Thread in Java?,"Einen neuen Thread in Java startet man, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft."
,Was sind die Rollen der beiden Enden der Subklassenbeziehung?,"Die beiden Enden der Subklassenbeziehung haben die Rollen ""Superklasse"" und ""Subklasse"". Diese Rollen legen nahe, dass die Subklassenbeziehung eine Hierarchie von Klassen aufbaut, in der die Superklassen über den Subklassen stehen. Die Superklasse ist die allgemeinere Klasse, von der die Subklasse erbt, während die Subklasse die speziellere Klasse ist, die die Eigenschaften der Superklasse erbt und möglicherweise erweitert oder anpasst."
,Was beschreiben Methodendefinitionen?,"Methodendefinitionen beschreiben, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll."
"Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?","Wie kann man die Zuweisungskompatibilität zwischen ""ArrayList<Integer>"" und ""ArrayList<Comparable<Integer>>"" herstellen?","Die Zuweisungskompatibilität zwischen ""ArrayList<Integer>"" und ""ArrayList<Comparable<Integer>>"" kann durch die Verwendung des Upper-Bounded Wildcards hergestellt werden. Dazu wird der generische Typ mit einem Fragezeichen und dem Upper-Bound (in diesem Fall ""Comparable<Integer>"") angegeben, was bedeutet, dass der generische Typ jede Klasse sein kann, die ein Subtyp von ""Comparable<Integer>"" ist. Somit ist ""Integer"" ein Subtyp von ""Comparable<Integer>"" und die Zuweisungskompatibilität wird hergestellt."
"Nicht zuletzt muss man auch erkennen, dass viele Anwendungsdomänen, für die programmiert wird, aus massenhaft gleichen Objekten bestehen, die durch den klassenbasierten Ansatz besser abgedeckt werden als durch den prototypenbasierten. Und so macht denn auch die Vererbung unter Instanzen das Nachvollziehen (und Debuggen) eines Programms eher noch schwieriger als die Vererbung unter Klassen ohnehin schon (s. Kapitel 56 in Kurseinheit 6).",Was ist der Unterschied zwischen dem klassenbasierten und dem prototypenbasierten Ansatz in der objektorientierten Programmierung?,"Im klassenbasierten Ansatz werden sämtliche Informationen als ein Geflecht von Objekten dargestellt, die auf Klassen basieren. In einem prototypenbasierten Ansatz hingegen werden Objekte als Prototypen verwendet, die als Vorlage für andere Objekte dienen. Der klassenbasierte Ansatz ist besser geeignet, wenn es viele gleiche Objekte gibt, während der prototypenbasierte Ansatz eher für die Erstellung von einzigartigen Objekten geeignet ist."
"Am Anfang dieses Kapitels wurde von dem Mysterium des Nachrichtenversands gesprochen. Tatsächlich ist jedoch zumindest in SMALLTALK seine Realisierung in Form von Methodenaufrufen nur ein Kompromiss zugunsten der Ausführungseffizienz. In SMALLTALK sind Nachrichten (oder genauer gesagt Nachrichtenselektoren) selbst Objekte - schließlich soll in SMALLTALK alles ein Objekt sein. Um tatsächlich als Nachrichtenobjekt an ein anderes Objekt verschickt zu werden, muss man jedoch eine spezielle Methode (genauer gesagt, einen speziellen Methodenaufruf), nämlich ""perform:"", verwenden. Diese Methode ermöglicht es, einem Empfängerobjekt eine Nachricht als Objekt (wenn auch nur als Parameter von ""perform:"") zu senden. Das Empfängerobjekt reagiert darauf, indem es die zur Nachricht passende Methode ausführt, als hätte es direkt einen entsprechenden Methodenaufruf erhalten.Der Nachrichtenselektor ist immer ein Symbol und darf beim ""Versand"" mittels ""perform:"" anders als beim direkten Aufruf auch in einer Variable gespeichert sein. Bei binären und höherwertigen Nachrichten werden zusätzlich Argumente (Parameter) benötigt, die an den Nachrichtenselektor angehängt werden können. Dies erfolgt durch Erweiterung von ""perform:"" zu ""perform:with:"", ""perform:with:with:"", usw.",Wie kann man Nachrichten in SMALLTALK als Objekte verwenden?,"In SMALLTALK kann man Nachrichten (oder Nachrichtenselektoren) selbst als Objekte verwenden, indem man die Methode ""perform:"" verwendet. Diese Methode ermöglicht es, einem Empfängerobjekt eine Nachricht als Objekt zu senden, und das Empfängerobjekt führt die zur Nachricht passende Methode aus, als hätte es einen entsprechenden Methodenaufruf erhalten."
,"Was unterscheidet Call by Value und Call by Reference, und wie wird dies in Java gehandhabt?","In Java wird Call by Value verwendet, was bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Dies ist eine Einschränkung im Vergleich zu Call by Reference, bei dem eine Methode auf den ursprünglichen Wert einer Variablen zugreifen und ihn ändern kann."
"Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der heute üblichen Typsysteme ist übrigens die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt.",Warum hängt das Verhalten eines Objekts von seinem Zustand ab?,"Das Verhalten eines Objekts hängt in der Regel von seinem Zustand ab, weil der Zustand eines Objekts die Informationen enthält, die benötigt werden, um die richtigen Entscheidungen zu treffen und die entsprechenden Aktionen auszuführen. Das Verhalten eines Objekts basiert auf den Daten in seinem Zustand, und diese Daten beeinflussen, wie das Objekt auf Nachrichten reagiert."
"Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark an die der englischen Sprache angelehnt ist. Sie verlangt ein Subjekt (den Empfänger der Nachricht), ein Prädikat (die Nachricht) sowie eine optionale Liste von Objekten als Prädikatsergänzungen (die Parameter der Nachricht). Dabei wird auf die in anderen Sprachen übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und Klammern zum Umschließen der Parameterliste verzichtet. Stattdessen verwendet man bei Zustandswechsel von zwei oder mehr Parametern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nachrichtenteile, die den Parametern vorangestellt werden. Ein Parameter kann auch eine Variable sein oder ein anderer Ausdruck.In SMALLTALK werden parameterlose Nachrichten auch als ""unär"" (unary messages) bezeichnet, da sie trotz fehlender expliziter Argumente als ""unär"" bezeichnet werden, weil der Empfänger das erste, implizite Argument ist. Nachrichten mit einem Parameter werden als ""binäre Nachrichten"" (binary messages) bezeichnet, da sie nur einen Parameter haben, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.Binäre Nachrichten bestehen aus einem oder mehreren nicht alphanumerischen Zeichen, die keine reservierten Zeichen sind. Alle anderen Nachrichten, die neben dem Empfänger mindestens ein Argument erfordern, werden in SMALLTALK Schlüsselwortnachrichten (keyword messages) genannt. Diese Nachrichten enthalten normalerweise keinen Schlüsselwort im herkömmlichen Sinne, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.",Was sind unäre Nachrichten?,"Unäre Nachrichten sind parameterlose Nachrichten, die den Empfänger als implizites erstes Argument haben."
"Wie bereits erwähnt, sind Objekte im Speicher abgelegte Daten. Dabei ist jedes Objekt an genau einer Stelle im Speicher abgelegt: Es wird damit durch seine Speicherstelle eindeutig identifiziert. Aufgrund dieser eindeutigen Identifizierbarkeit spricht man auch von der Identität eines Objekts; sie kann aus technischer Sicht mit der Speicherstelle, an der das Objekt abgelegt ist, gleichgesetzt werden. Da keine zwei Objekte an derselben Stelle abgelegt werden können, haben auch keine zwei Objekte dieselbe Identität.Objekte sind grundsätzlich von Werten zu unterscheiden. Werte werden auch im Speicher abgelegt, haben aber keine Identität. Es folgt, dass derselbe Wert an verschiedenen Stellen im Speicher vorkommen kann. Viele objektorientierte Programmiersprachen (wie etwa Java oder C-Sharp) unterscheiden ganz offen zwischen Werten und Objekten; SMALLTALK tut dies nur hinter den Kulissen und folgt ansonsten seinem Motto ""alles ist ein Objekt"".",Was unterscheidet ein Objekt und ein Wert?,"Objekte haben eine eindeutige Identität und sind an einer bestimmten Stelle im Speicher abgelegt, während Werte an verschiedenen Stellen im Speicher vorkommen können und keine Identität haben."
"Die Methodenrümpfe bestehen aus einer Folge von Anweisungen, die jeweils durch einen Punkt getrennt sind. Wenn die Anweisungen nichts anderes vorsehen, wird die Ausführung einer Methode nach Abarbeitung der letzten Anweisung explizit mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung vorgesehen. Eine Return-Anweisung darf an beliebigen Stellen innerhalb der Methode auftreten, wodurch die Abarbeitung der Methode vor Erreichen der textuell letzten Anweisung beendet werden kann. Die Return-Anweisung beeinflusst somit den Kontrollfluss des Programms. Wichtig ist, dass eine Methode immer ein Objekt zurückgibt. Ein Nachrichtenausdruck (oder Methodenaufruf) steht immer für ein Objekt. Prozeduren im Sinne von PASCAL oder Void-Methoden im Sinne von C, Java usw. gibt es in SMALLTALK nicht.",Wie wird die Ausführung einer Methode beendet?,Die Ausführung einer Methode wird standardmäßig nach Abarbeitung der letzten Anweisung mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung da.
"Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.","Was ist ein Beispiel für funktional äquivalente, aber verschiedene Typen?","Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So können beispielsweise die Objekte für die Elemente eines GUI, wie Fenster, Buttons etc. für jedes Betriebssystem eine eigene Implementierung haben. Diese Objekte sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt."
"Wenn es die Sprache zulässt. Damit schlägt man zwei Fliegen mit einer Klappe: Man kann die Zusicherungen zur Laufzeitverifikation einsetzen und zeigt dem Aufrufer der Methode, wie er selbst prüfen kann, ob die Vorbedingung eingehalten ist.",Was ist die Bedeutung von Zusicherungen (Assertions) in der Programmierung?,"Zusicherungen (Assertions) sind in der Programmierung eine Möglichkeit, die Richtigkeit von Bedingungen zu einem bestimmten Zeitpunkt während der Ausführung eines Programms zu überprüfen. Wenn die Sprache dies zulässt, können sie auch dazu verwendet werden, dem Aufrufer der Methode zu zeigen, wie er selbst prüfen kann, ob die Vorbedingung eingehalten ist."
"Die zweite Möglichkeit wäre, eine Typinferenz für das gesamte Programm durchzuführen, um die möglichen Zuweisungen an Variablen zu sammeln. Dazu sind insbesondere alle Methodenaufrufe anzusehen. Diese können je nach Konfiguration des endgültigen Systems sehr unterschiedlich ausfallen. Eine solche Typinferenz ist jedoch in den meisten Fällen unrealistisch.",Warum ist eine Typinferenz für das gesamte Programm in den meisten Fällen unrealistisch?,"Eine Typinferenz für das gesamte Programm ist unrealistisch, da sie alle Methodenaufrufe im System berücksichtigen muss, die je nach Konfiguration sehr unterschiedlich ausfallen können. Zudem ist sie sehr aufwendig und erfordert eine komplexe Algorithmik."
,Was ist eine weitere Anwendung von become:?,"Eine weitere Anwendung von become: ist die Durchführung eines Rollbacks, um den ursprünglichen Zustand eines Objekts oder Objektgeflechts nach einer Menge von Änderungen wiederherzustellen. Dies geschieht durch Erzeugen einer Kopie des ursprünglichen Objekts und anschließendem Ersetzen des geänderten Objekts durch die Kopie mittels become:."
"EIFFEL nimmt unter den hier behandelten Sprachen eine Sonderstellung ein. Es soll nämlich mehrere Dinge auf einmal sein: eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache.",Was ist die Sprache EIFFEL?,"EIFFEL ist eine Sprache, die für objektorientierte Analyse und Design, kommerzielle Programmierung und akademische Lehre verwendet wird."
,Wie werden Zeichenliterale und String-Literale in Java dargestellt?,"Zeichenliterale werden in Java durch einfache Anführungsstriche eingeschlossen, während String-Literale durch doppelte Anführungsstriche eingeschlossen werden."
"Bei virtuellen Methoden wird hingegen wie in Java zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und Java-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In Java hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C-Sharp hat man diese Entscheidung nicht nachvollzogen.",Wie wird bei einer virtuellen Methode die richtige Implementierung ermittelt?,"Zur Ermittlung der richtigen Implementierung wird eine sog. Virtual function table verwendet, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer und sollte daher nur verwendet werden, wenn unbedingt notwendig."
"C-Sharp unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von Java. Es ist in C-Sharp allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C-Sharp besitzt dafür das Schlüsselwort ""operator"", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:",Was ist Operatorüberladung in C-Sharp?,"In C-Sharp ist es möglich, Operatoren wie +, -, ==, new, ( ), ||, &&, = etc. zu überladen. Dies wird durch das Schlüsselwort ""operator"" in einer Operatordefinition erreicht, die der Definition einer Methode ähnelt."
,Warum muss in SMALLTALK das Empfängerobjekt einer Nachricht immer explizit angegeben werden?,"In SMALLTALK muss das Empfängerobjekt einer Nachricht immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. Dies unterscheidet sich von einigen anderen Programmiersprachen wie Java, in denen das Empfängerobjekt manchmal implizit ist. Die Verwendung von self ist notwendig, um das Objekt zu identifizieren, auf dem die Methode ausgeführt wird, und auf dessen Instanzvariablen zugegriffen werden kann."
,"Warum könnte es sinnvoll sein, das Typsystem einer Programmiersprache von ihrem Rest zu isolieren?","Das Isolieren des Typsystems einer Programmiersprache ermöglicht es, das Typsystem auszutauschen oder zu verbessern, ohne die gesamte Sprachdefinition ändern zu müssen. Dies kann besonders nützlich sein, wenn man eine Sprache an spezifische Anforderungen anpassen möchte."
,Warum ist die Typisierung von Variablen und Ausdrücken in einem Programm wichtig?,"Die Typisierung von Variablen und Ausdrücken in einem Programm ist wichtig, um sicherzustellen, dass jede Variable nur Werte haben kann, für die sie vorgesehen ist. Dies gewährleistet die Einhaltung der Typinvariante und verhindert Typfehler im Programm."
"Die Objekte, die durch Literale repräsentiert werden, sind, da sie vom Compiler erzeugt werden, aus Sicht des Programms „schon da“, wenn es ausgeführt wird. Mittels Instanziierung und Klassen hat man nun die Möglichkeit, neue — und neuartige — Objekte programmatisch, also per Programmausführung, zu erzeugen. Dies geschieht standardmäßig, indem man der Klasse, von der man eine Instanz haben möchte, die Nachricht new (für Klassen ohne indizierte Instanzvariablen) oder new: (für Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert. Der Parameter der Nachricht von Objekten, nämlich solche, die instanziierbar sind, und solche, die es nicht sind. Instanziierbare Objekte sind immer (auch) Klassen; für solche, die es nicht sind, gibt es leider keine spezielle Bezeichnung. Man könnte sie jedoch Ebene-0-Objekte nennen.new: muss immer eine natürliche Zahl sein und legt die Anzahl der indizierten Instanzvariablen fest, über die ein Objekt verfügt. Hat ein Objekt (per Klassendefinition) keine indizierten Instanzvariablen, führt new: zu einem Laufzeitfehler.",Wie passiert in SMALLTALK die Instanziierung?,"In SMALLTALK wird normalerweise die Instanziierung eines Objekts durch Senden der Nachricht ""new"" (für Klassen ohne indizierte Instanzvariablen) oder ""new:"" (für Klassen mit indizierten Instanzvariablen) an die Klasse durchgeführt. Das neue Objekt wird im Speicher angelegt, und seine Instanzvariablen werden alle mit ""nil"" initialisiert."
"BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.","Was ermöglicht die ""Rename""-Klausel in Eiffel?","Die ""Rename""-Klausel in Eiffel ermöglicht es, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen."
,"Gibt es in C++ die Möglichkeit, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren?","Nein, in C++ ist es nicht möglich, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren. Stattdessen erlaubt das Friends-Konzept, dass bestimmte Klassen auf alle privaten Elemente einer anderen Klasse zugreifen können."
"Dies bewirkt, dass der Ausdruck a den Typ T aufgedrückt bekommt. Ist dies nicht möglich, weil der tatsächliche Typ des Objekts, auf das a verweist, kein Subtyp von T ist oder weil keine entsprechende Typumwandlung definiert ist (einschließlich Boxing/Unboxing), wird dies mit einem Laufzeitfehler quittiert. Casts sind also typsicher (in dem Sinne, dass keiner Variable ein Wert zugewiesen wird, den sie nicht haben darf), aber nicht sicher (sie können zu Ausnahmesituationen und, im Falle einer Nichtbehandlung, zu Programmabbrüchen führen).",Was ist der Zweck eines Casts in der Programmierung?,"Der Zweck eines Casts in der Programmierung ist, einem Objekt einen bestimmten Typ aufzudrücken. Ist dies nicht möglich, wird dies mit einem Laufzeitfehler quittiert. Casts sind typsicher, aber nicht sicher, da sie zu Ausnahmesituationen und Programmabbrüchen führen können."
"Hinter dem Nachrichtenversand in SMALLTALK verbirgt sich der Methodenaufruf. Wann immer ein Objekt eine Nachricht an ein Empfängerobjekt verschickt, wechselt der Kontrollfluss damit zum Empfängerobjekt, genauer gesagt zur Methode des Empfängerobjekts, die zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung der Methode kehrt der Kontrollfluss an das sendende Objekt (genauer: zur Methode, aus der die Nachricht versandt wurde) zurück und setzt seine Arbeit dort fort. Bei der Rückkehr wird auch das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird.",Was passiert nach einer Methode in SMALLTALK?,"Bei der Rückkehr nach der Abarbeitung einer Methode in SMALLTALK wird das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Dies ermöglicht die Weiterverarbeitung des Ergebnisses im Kontext des aufrufenden Objekts."
"Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Damit dies erreicht wird, muss die Abhängigkeit der Module möglichst gering ausfallen. Dabei bedeutet Abhängigkeit in der Regel Änderungsabhängigkeit: Wenn sich in einem Teil etwas ändert, muss sich auch im davon abhängigen Teil etwas ändern. Sie ergibt sich regelmäßig aus einer Benutzungsbeziehung. In der objektorientierten Programmierung kommt jedoch noch die Vererbungsabhängigkeit hinzu. Module, die vollkommen unabhängig voneinander sind, sind ein Indikator dafür, dass man nicht ein Programm entwickelt, sondern mehrere. Wo keine Abhängigkeiten bestehen, gibt es auch kein Zusammenspiel.",Wozu dient die Aufteilung eines Programms in Module?,Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Dabei muss die Abhängigkeit der Module möglichst gering ausfallen.
"In SMALLTALK haben wir es also mit einem mehrstufigen Zusammenspiel von Klassen und Instanzen zu tun. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht.",Wie ist das Zusammenspiel von Klassen und Instanzen in SMALLTALK?,"In SMALLTALK gibt es ein mehrstufiges Zusammenspiel von Klassen und Instanzen. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht."
"Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.",Wie wird der Zustand eines Objekts in Smalltalk verändert?,"Der Zustand eines Objekts in Smalltalk wird verändert, indem die Werte seiner Instanzvariablen zugewiesen werden, was gleichbedeutend mit der Änderung seiner Beziehungen ist."
"Den Konstruktoransatz findet man in Sprachen wie EMERALD, den Prototypenansatz in Sprachen wie SELF oder JavaSCRIPT und den Klassenansatz in Sprachen wie SMALLTALK, C++, EIFFEL, Java, C-Sharp, SCALA und vielen anderen mehr. Aus verschiedenen Gründen hat sich die dritte Variante, die klassenbasierte Form der Objektorientierung (wobei die Klassen die erwähnten Vorlagen sind) gegenüber der zweiten, der prototypenbasierten Form der Objektorientierung weitgehend durchgesetzt. Die erste Variante findet im Zuge einer gewissen Ernüchterung bzgl. der objektorientierten Programmierung zunehmend Anhänger, und zwar da, wo Objekte und dynamisches Binden (s. Abschnitt 12) im Kontext traditioneller imperativer Programmierung angeboten werden sollen. Sie liegt damit aber außerhalb des Gegenstands dieses Kurstextes. Die Dominanz der klassenbasierten Form der objektorientierten Programmierung liegt vermutlich zum einen daran, dass Klassen ein klassisches, in anderen Disziplinen wie der Mathematik oder der Biologie fest etabliertes Ordnungskonzept darstellen, mit dessen Hilfe sich auch objektorientierte Programme gut strukturieren lassen, und zum anderen daran, dass Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen (also Sprachen, bei denen alle Variablen und Funktionen bei der Deklaration einen Typ zugeordnet bekommen und der Variableninhalt immer vom deklarierten Typ sein muss) übernehmen kann (der Gegenstand von Kurseinheit 3). Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann, z. B. indem sie eine Methodendefinition nur für ein einziges Objekt abzuändern erlaubt. Letzteres ist z. B. bei der Programmierung von grafischen Bedienoberflächen, bei der das Drücken verschiedener Buttons jeweils verschiedene Ereignisse auslöst (Methoden aufruft), sehr praktisch. Nicht umsonst ist JavaSCRIPT als Programmiersprache für interaktive Webseiten so erfolgreich. Auch wenn es gute Gründe für die prototypenbasierte Form der objektorientierten Programmierung gibt (und sich deswegen jedes Werk zum Thema objektorientierte Programmierung — so wie auch das Ihnen vorliegende — gemüßigt fühlt, darauf hinzuweisen, dass es sie gibt), werde ich mich im Folgenden vornehmlich Klassen als strukturbildenden Konzepten der objektorientierten Programmierung zuwenden und nur hier und da Prototypen kurz die Referenz erweisen.",Was sind die drei Varianten der Objektorientierung?,"Die drei Varianten der Objektorientierung sind der Konstruktoransatz, der Prototypenansatz und der Klassenansatz. Die klassenbasierte Form der Objektorientierung hat sich gegenüber der prototypenbasierten Form weitgehend durchgesetzt, da Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen übernehmen kann. Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann."
"Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.",Was ist ein parametrischer Typ?,"Ein parametrischer Typ ist ein Typ, der einen oder mehrere Typvariablen enthält, die bei der Instanziierung durch konkrete Typen ersetzt werden. Dies ermöglicht die Erstellung von generischen Klassen und Methoden, die für verschiedene Typen verwendet werden können."
,Wie geht (in SMALLTALK) das dynamische Binden von Methodenaufrufen vonstatten?,"Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Wird die Methode gefunden, dann wird sie ausgeführt. Wird sie nicht gefunden, wird zunächst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument."
"Es ist jedoch zu beachten, dass formale Parameter in SMALLTALK Pseudovariablen sind und daher keine explizite Zuweisung an sie erlaubt ist (außer bei der impliziten Zuweisung beim Aufruf).Was passiert, wenn ein Methodenaufruf ins Leere läuft, ist ebenfalls von Interesse. Da in SMALLTALK Ausdrücke beliebige Objekte liefern können, kann der Compiler nicht garantieren, dass das Empfängerobjekt tatsächlich über eine entsprechende Methode verfügt. In solchen Fällen wird der Methodenaufruf in einen Aufruf der Methode ""doesNotUnderstand:"" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung wie ""<Objekt> does not understand: <Nachrichtenselektor>"". Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren.","Was passiert, wenn ein Methodenaufruf in SMALLTALK ins Leere läuft?","Wenn ein Methodenaufruf ins Leere läuft, wird er in einen Aufruf der Methode ""doesNotUnderstand:"" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung, die besagt, dass das Objekt die Nachricht nicht versteht. Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren."
"Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).",Was ist ein Impedanzmismatch zwischen relationalen Datenbanken und objektorientierten Programmen?,"Ein Impedanzmismatch zwischen relationalen Datenbanken und objektorientierten Programmen ist das Problem, dass sich beide Welten in ihrer Art und Weise unterscheiden, wie sie Daten und Beziehungen darstellen. Relationale Datenbanken sind wertbasiert und stellen Beziehungen über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen her, während objektorientierte Programme zeigerbasiert sind und Beziehungen über Referenzen und deren Dereferenzierung (Navigation) herstellen. Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Daher muss man sich, wenn relationale Daten durch objektorientierte Programme verarbeitet werden sollen, an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben."
,Was ist das Besondere an der Moduldefinition von Java in Bezug auf die Einhaltung der Schnittstellenspezifikationen?,"Die Moduldefinition von Java erzwingt die Einhaltung der Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit. Sie kontrolliert auch den reflektiven Zugriff auf Programmelemente, was zu einer erheblichen Verbesserung der Sicherheit von Java-Programmen führt."
"Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die ""rückgängig machen"" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung ""rückgängig Machen leider nicht möglich"" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.",Was ist der Unterschied zwischen Subtypen und austauschbaren Typen?,"Subtypen sind im Allgemeinen nicht gegeneinander austauschbar, während austauschbare Typen es sind. Ein Beispiel für einen Subtyp, der nicht gegen einen anderen Subtyp austauschbar ist, ist eine Aktion, für die ""rückgängig machen"" nicht definiert ist, während eine Aktion, für die ""rückgängig machen"" definiert ist, gegen eine Aktion austauschbar ist, für die ""rückgängig machen"" leer implementiert ist."
,Was ist ein Interface in Java und wie wird es deklariert?,"Ein Interface in Java ist eine eigenständige Schnittstellendeklaration, die von einer Klasse unabhängig ist, aber genauso wie eine Klasse einen Typ definiert. Interfaces werden mit dem Schlüsselwort ""interface"" deklariert."
,Was versteht man unter Inklusionspolymorphie?,"Unter Inklusionspolymorphie versteht man im Wesentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, können Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert). Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus gebräuchlich; sonst redet man eher von Subtyping."
"In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren in Form der Prüfung der Typkonformität immer nur angenähert. Tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen werden, wenn mangelnde Typkonformität vorliegt. Dennoch werden entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet jedoch Typkonformität nicht automatisch auch Substituierbarkeit. Dazu ist auch eine Betrachtung des Verhaltens notwendig.",Was bedeutet Typkonformität nicht automatisch auch Substituierbarkeit?,"Typkonformität bedeutet nicht automatisch auch Substituierbarkeit, weil auch bei Typkonformität das Verhalten der Objekte verglichen werden muss, um sicherzustellen, dass die Substituierbarkeit gegeben ist."
"Die der Fehlerentdeckung mittels Typsystemen zugrundeliegende These ist, dass ein guter Teil logischer Programmierfehler bereits frühzeitig daran erkannt werden kann, dass eine Variable einen Wert hat, den sie eigentlich niemals haben dürfte. So zeugt beispielsweise von einem Fehler, wenn einer Variable, die für Zahlen gedacht war, eine Zeichenkette zugewiesen wird. Wenn dann nämlich einem Ausdruck mit einer arithmetischen Operation, die Zahlen als Operanden verlangt, eine solchermaßen fehlbelegte Variable zugeführt wird, kann dieser nicht ausgewertet werden. Ohne Typprüfung würde dieser Fehler erst zur Laufzeit, also wenn der Ausdruck tatsächlich ausgewertet werden soll, in Erscheinung treten und hätte dann in aller Regel einen Programmabbruch zur Folge. Man nennt einen solchen Programmierfehler einen Typfehler.",Was ist der Zweck von Typsystemen in der Fehlerentdeckung?,"Typsysteme in der Fehlerentdeckung zielen darauf ab, einen Teil logischer Programmierfehler frühzeitig zu erkennen, indem sie Variablen daran hindern, Werte anzunehmen, die sie eigentlich nicht haben dürften. Dies hilft, Fehler zu vermeiden, die erst zur Laufzeit auftreten und in der Regel einen Programmabbruch verursachen. Diese Art von Fehlern werden als Typfehler bezeichnet."
"Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet.",Wie werden in Smalltalk Klassen in einem gemeinsamen Namensraum verwaltet?,"In Smalltalk werden alle Klassen, die in einem SMALLTALK-System zur Verfügung stehen, in einem gemeinsamen Namensraum verwaltet."
"Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.",Was ist weniger geeignet für die objektorientierte Programmierung?,"Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, sind weniger geeignet für die objektorientierte Programmierung."
,Wie ist die Beziehung zwischen Typäquivalenz und Typkonformität auf der einen Seite und den Wertebereichen (Extensionen) von Typen auf der anderen Seite?,"Damit Typkorrektheit erhalten bleibt, müssen die Wertebereiche von Typen in Bezug auf Zuweisungen miteinander in Beziehung stehen. Wenn ein Objekt eines Typs einem Objekt eines anderen Typs zugewiesen werden soll, muss die Extension des zweiten Typs eine Teilmenge der Extension des ersten Typs sein."
"Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet.",Wie werden in Smalltalk Klassen importiert?,"In Smalltalk gibt es keine explizite Möglichkeit, eine Klasse zu importieren. Stattdessen werden alle Klassen, die in einem SMALLTALK-System zur Verfügung stehen, in einem gemeinsamen Namensraum verwaltet."
,Welche Auswirkungen haben die Zugriffsbeschränkungen in Java?,"Die Zugriffsbeschränkungen in Java regeln, welche Teile einer Klasse oder eines Typs von anderen Klassen oder Typen aus zugänglich sind. Sie beeinflussen die Sichtbarkeit von Variablen, Methoden und anderen Elementen innerhalb einer Klasse und zwischen Klassen, insbesondere in verschiedenen Paketen."
,Was sind Factory-Methoden?,"Eine Factory-Methode ist eine Methode, die wie ein Konstruktor eine neue Instanz liefert, die aber die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode gehört, abhängig macht. Zum Beispiel könnte eine Klasse Number eine (Klassen-)Methode fromString: vorsehen, die anhand eines zu analysierenden Strings entweder eine Instanz der Klasse Integer oder eine der Klasse Float zurückgibt. Da in SMALLTALK Konstruktoren ganz normale Klassenmethoden sind, sind sie an keine besonderen Konventionen gebunden. Sie müssen also insbesondere nicht ein neues Objekt genau der Klasse, der sie angehören, zurückgeben. Die Factory-Methoden sind dann solche Klassenmethoden."
"Wie Sie sehen, ist das Problem der kovarianten Redefinition ziemlich hartnäckig. Man muss aber gar nicht so weit gehen, um an die praktischen Grenzen der Typisierung zu gelangen. Nun könnte man einen Typ NotZero definieren und x als von diesem Typ deklarieren, womit der obige Ausdruck kein Problem mehr wäre. Selbst wenn es Typsysteme gibt, die das können, so sind diese kaum praxistauglich.","Warum sind Typsysteme, die kovariante Redefinition erlauben, kaum praxistauglich?","Typsysteme, die kovariante Redefinition erlauben, sind kaum praxistauglich, weil sie zu Problemen führen können, wenn Objekte mit unterschiedlichen Typen miteinander interagieren. Wenn beispielsweise eine Methode, die ein Objekt erwartet, das von Typ A ist, ein Objekt erhält, das von Typ B ist, aber B von A abgeleitet ist, kann dies zu unerwarteten Ergebnissen führen, wenn die Methode versucht, auf die spezifischen Eigenschaften von A zuzugreifen, die in B nicht vorhanden sind. Dies kann zu Laufzeitfehlern führen und die Wartbarkeit und Zuverlässigkeit des Codes beeinträchtigen."
,Warum ist das Friends-Konzept in C++ nützlich?,"Das Friends-Konzept ist nützlich, wenn ein Teilproblem in der Programmierung nicht von einer einzelnen Klasse gelöst werden kann, sondern die Zusammenarbeit mehrerer Klassen erfordert. Es ermöglicht, dass diese Klassen eng zusammenarbeiten können, ohne dass alle Klassen dieselbe Schnittstelle haben müssen."
"Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5 genannten Programmiersprachen ist das jedoch nur in C-Sharp, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.","Wie kann man die Teil-Ganzes-Beziehung zwischen Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, in Programmierung verstehen?","Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können."
"Komplizierter wird die Sache jedoch, wenn die Verkettung länger ist, wenn also der zu vermeidende Ausdruck ""a doX doY doZ"" heißen würde, denn dann müsste auch noch ""doZ"" zur Klasse von ""a"" hinzugefügt und mit entsprechenden Implementierungen versehen werden. Man ahnt schon, wohin das führt: zu einem Wachstum des Protokolls von ""a"".","Was passiert, wenn die Verkettung von Nachrichtenausdrücken länger wird?","Wenn die Verkettung von Nachrichtenausdrücken länger wird, wird das Protokoll der Klasse von ""a"" komplexer und muss mit entsprechenden Implementierungen versehen werden."
,"Was ermöglicht das Interface-als-Typ-Konzept in Java, und warum wird es als bedeutend für die objektorientierte Programmierung angesehen?","Das Interface-als-Typ-Konzept in Java ermöglicht es, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle als Typen der Klasse dienen. Dies erleichtert die interfacebasierte Programmierung und wird als einer der wichtigsten Beiträge von Java zur objektorientierten Programmierung angesehen."
,Können Klassendefinitionen in Java Operatoren definieren?,"Nein, in Java ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren wie es bei den binären Methoden in SMALLTALK der Fall ist."
"Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Kapiteln dieser Kurseinheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht. Sie ist fast immer willkürlich. Im Folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt werden, das ich persönlich eher nicht als Stilfrage einstufen würde, das aber dennoch häufiger in diesem Zusammenhang genannt wird.",Was ist ein Entwurfsprinzip und wie unterscheidet es sich von einem Programmierstil?,"Ein Entwurfsprinzip ist ein allgemeiner Grundsatz oder Richtlinie, die bei der Gestaltung von Softwarearchitektur und Design befolgt wird. Im Gegensatz dazu ist ein Programmierstil eine bestimmte Art und Weise, wie Code geschrieben wird, die von der persönlichen Vorliebe des Programmierers abhängt. Ein Entwurfsprinzip ist also ein allgemeinerer Begriff als Programmierstil und bezieht sich auf die Architektur und das Design von Software, während Programmierstil sich auf die Art und Weise bezieht, wie Code geschrieben wird."
,Warum können nicht alle Typprüfungen in Java zur Übersetzungszeit durchgeführt werden?,"Nicht alle Typprüfungen können in Java zur Übersetzungszeit durchgeführt werden, da einige Typprüfungen erst zur Laufzeit notwendig sind und nicht im Voraus bekannt sind."
"Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger-auf-Typ handelt; vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch überladen wurde. Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.","Was bedeutet der Stern neben Methoden, Klassen, Blöcken und Variablen in der Programmierung?","Neben Methoden, Klassen, Blöcken und Variablen bedeutet der Stern, dass sie unsicher sind. Das heißt, sie können Null-Werte haben und müssen vor der Verwendung auf Null überprüft werden."
,Warum ist die Verwechslung von equals(.) und == ein häufiger Programmierfehler in Java?,"Die Verwechslung von equals(.) und == ist auch in Java ein häufiger Programmierfehler, da sie unterschiedliche Bedeutungen haben. equals(.) prüft die Gleichheit von Objekten, während == die Identität überprüft."
"Vollkommen unvereinbar mit der Spezialisierung ist übrigens das Entfernen von Instanzvariablen oder Methoden. Dies ergibt sich schon daraus, dass die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Die Richtung von Spezialisierung und Generalisierung würde zudem, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte, beliebig werden.",Warum ist das Entfernen von Instanzvariablen oder Methoden unvereinbar mit der Spezialisierung?,"Das Entfernen von Instanzvariablen oder Methoden ist unvereinbar mit der Spezialisierung, weil die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Zudem würde die Richtung von Spezialisierung und Generalisierung beliebig werden, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte."
"Da in SMALLTALK auch eine Klasse ein Objekt ist, kann die Klasse selbst, genau wie alle anderen Objekte, Instanzvariablen und -methoden haben. Aber wo werden diese definiert? Der Analogie der Objekte, die Instanzen der Klasse sind, folgend müsste das in der jeweiligen Klasse der Klasse, also der Klasse, von der die Klasse (als Objekt) eine Instanz ist, erfolgen. Und so ist es tatsächlich auch.",Wo werden Instanzvariablen und -methoden von Klassen definiert?,"Da in SMALLTALK auch eine Klasse ein Objekt ist, kann die Klasse selbst, genau wie alle anderen Objekte, Instanzvariablen und -methoden haben. Diese werden in der jeweiligen Klasse der Klasse, also der Klasse, von der die Klasse (als Objekt) eine Instanz ist, definiert."
"Mit einer so chaotischen Syntax, dass sogar Compiler raten müssen, ist es besser, dass C++-Code wiederverwendbar ist, denn niemand wird jemals daran denken, ihn rückzuentwickeln. Die ""Funktion"" der Programmiersprache - nämlich eine Erweiterung von C zu sein - ist ein grundlegendes Problem. Mit zahlreichen großen Projekten, die bereits in veralteten Dialekten geschrieben wurden, kann man C++ sicherlich als eine ""sofortige Legacy""-Sprache betrachten.",Wie wird C++ oft beschrieben?,"C++ wird oft als eine ""sofortige Legacy""-Sprache beschrieben, die eine Erweiterung von C ist und eine chaotische Syntax hat."
"Die Methode species war uns schon einmal begegnet, und zwar in Kurseinheit 1, Abschnitt 4.6.4, Zeile 244. Sie gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist z. B. bei der Methode collect:, ausgeführt auf einer Instanz von Interval, sinnvoll, da collect: hier kein Intervall zurückgeben kann. So kann beispielsweise die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. Entsprechend ist in der Klasse Interval die Methode species als implementiert.",Was macht die Methode species?,"Die Methode species gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Zum Beispiel bei der Methode collect:, die auf einer Instanz von Interval ausgeführt wird, ist es sinnvoll, die Methode species zu überschreiben, da collect: kein Intervall zurückgeben kann. So kann die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. In der Klasse Interval ist die Methode species als implementiert."
,"Warum wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann?","Es wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann, um zu betonen, dass die Lesbarkeit des Codes in C++ stark von der Programmierpraxis abhängt. C++ bietet die Flexibilität, Code auf unterschiedliche Weisen zu schreiben, von sehr lesbar bis hin zu sehr unlesbar, je nach den Entscheidungen der Entwickler."
"Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.",Wie hängen die Subtyp-Beziehungen von generischen Typen mit Typ-Wildcards zusammen?,"Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant."
"Es ist Ihnen vielleicht aufgefallen, dass im oben beschriebenen Verfahren zum Auffinden der auszuführenden Methode nur das Empfängerobjekt, jedoch nicht die Parameterobjekte berücksichtigt wurden. Das erscheint zunächst natürlich. Manchmal hängt jedoch die Auswahl einer geeigneten Methode auch von den tatsächlichen Parametern ab.",Wann wird das Empfängerobjekt und die Parameterobjekte bei der Auswahl einer Methode berücksichtigt?,"Das Empfängerobjekt und die Parameterobjekte werden bei der Auswahl einer Methode berücksichtigt, wenn die Auswahl der geeigneten Methode von den tatsächlichen Parametern abhängt."
"Wenn man nun eine solche SharedQueue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann hat man tatsächlich „aktive Objekte, die einander Nachrichten schicken“.",Was sind aktive Objekte im Kontext von SharedQueue?,"Aktive Objekte sind Objekte, die einander Nachrichten schicken, indem sie Nachrichten in eine SharedQueue einstellen und diese von einem anderen Objekt ausgelesen werden, das in einer Endlosschleife läuft."
"""5 to: 1 by: -2"" erzeugt ein Intervall, das die Zahlen 5, 3 und 1 enthält. Intervalle dienen vor allem dem Zweck, sog. ""For""-Schleifen zu emulieren. Um der geschätzten Programmiererin auch noch die Klammern zu ersparen, wurde gleich noch die Methode ""to:by:do:"" hinzugefügt. ""to:do:"" ist eine Methode, die eine Schleife über eine Sequenz von Zahlen erzeugt. Die Sequenz beginnt mit dem ersten Wert, der als Argument übergeben wird, und endet mit dem letzten Wert, der ebenfalls als Argument übergeben wird. Die Methode ""to:by:do:"" ist eine Variante von ""to:do:"", die eine Schrittweite als drittes Argument akzeptiert.","Was macht die Methode ""to:do:"" in Smalltalk?","Die Methode ""to:do:"" in Smalltalk erzeugt eine Schleife über eine Sequenz von Zahlen, die mit dem ersten Wert beginnt und mit dem letzten Wert endet, die als Argumente übergeben werden. Die Methode akzeptiert eine Blockvariable, die für jede Zahl in der Sequenz verwendet wird."
"Das Schlüsselwort ""abstract"", das eine Klasse für eine solche Methodendeklaration anführen müsste, wird in Interfaces automatisch angenommen; Interfaces liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begründung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen Deklaration und Implementierung (Definition; s. Kapitel 19 in Kurseinheit 3) unterschieden werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch für eine Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes), wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter und Setter) ersetzt werden kann.",Warum können Interfaces keine Implementierungen oder Objekte liefern?,"Interfaces können keine Implementierungen oder Objekte liefern, weil sie lediglich eine Schnittstelle definieren, die von Klassen implementiert werden kann. Sie legen lediglich fest, welche Methoden eine Klasse implementieren muss, um ein bestimmtes Interface zu implementieren."
"Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden müssen, sondern durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich. Dieser Umstand ist bei der Betrachtung von Zuweisungskompatibilität unter parametrischem Polymorphismus wichtig.",Was ist der Unterschied zwischen einer parametrischen Typdefinition und einer normalen Typdefinition?,"Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit auf Typen beschränkt ist. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt."
,"Welche Art von Subtyping wird bei ""super"" beschränkten Wildcard-Typen verwendet?","""super"" beschränkte Wildcard-Typen verwenden kontravariantes Subtyping."
,Welche beiden Interfaces in Java ermöglichen eine einheitliche Iteration über Collections mittels Iteratoren?,In Java ermöglichen die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer) eine einheitliche Iteration über Collections mittels Iteratoren.
"Das folgende Protokoll setzt diese Form der Kommunikation in SMALLTALK um; es ist vollständig in SMALLTALK implementiert und sollte Ihnen inzwischen kein Problem mehr bereiten. Beachten Sie, dass Object keine Lazy Initialization seiner Klassenvariable Dependents vorsieht; die Methode initDependents muss daher bei Erzeugung einer neuen Klasse jeweils einmal aufgerufen werden.",Was ist die Methode initDependents?,"Die Methode initDependents ist eine Methode, die bei der Erzeugung einer neuen Klasse aufgerufen werden muss, um die Klassenvariable Dependents zu initialisieren."
"In Java werden zunächst sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen. Von Klassen- und Interfacetypen gibt es seit Java 5 auch parametrisierte Varianten, die denen von STRONGTALK stark ähneln (die Java-Generics stammen teilweise von Autoren von STRONGTALK). Die primitiven Typen sind in der Sprachdefinition festgelegt. Es handelt sich um byte, short, int, long, float, double, boolean und char. Sie unterscheiden sich nicht wesentlich von den Typen in gängigen, statisch typgeprüften prozeduralen Sprachen.",Wie viele Arten von Typen werden in Java unterschieden?,"In Java werden sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen."
"Wenn Aliase also schlecht sind, könnte man sie ja auch einfach verbieten. Tatsächlich bieten einige Programmiersprachen wie C-Sharp, C++ und EIFFEL die Möglichkeit, Klassen als Werttypen zu definieren, sodass bei Zuweisungen nicht automatisch Aliase entstehen. Aber durch eine derart einfache Lösung schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein, wie das folgende Beispiel zeigt:","Was sind die Nachteile, wenn Aliase in Programmiersprachen verboten werden?","Wenn Aliase in Programmiersprachen verboten werden, schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein. Ein Beispiel dafür ist die Verwendung von Klassen als Werttypen in Programmiersprachen wie C-Sharp, C++ und EIFFEL, bei der bei Zuweisungen nicht automatisch Aliase entstehen."
"Logischerweise können Instanzvariablen in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Typische Eigenschaften sind beispielsweise die Farbe von etwas oder der Name; sie unterscheiden sich inhaltlich von Beziehungen dadurch, dass das bezogene Objekt seine Bedeutung verliert, wenn es isoliert betrachtet wird. Ein Objekt wie ""Rot"" ist allein nichts anderes als eine Farbe; es erhält erst Bedeutung, wenn es als Attribut eines Objekts wie ""Apfel"" betrachtet wird. Das Gleiche gilt für ""Schmidtchen"" oder ""1"". Zudem ist zu beachten, dass Attributwerte wie die genannten in der Regel selbst keine Attribute besitzen oder Beziehungen zu anderen Objekten nicht eingehen.Es ist jedoch wichtig zu beachten, dass dieses Unterscheidungskriterium relativ zur jeweils betrachteten Domäne ist. Wenn es beispielsweise um Farben geht, hat ""Rot"" an sich bereits eine Bedeutung und kann vollwertige Beziehungen zu anderen Objekten eingehen, wie zum Beispiel ""Grün"" als sein Komplementärkontrast.",Was sind Attribute?,"Attribute sind Instanzvariablen, die die Eigenschaften eines Objekts festhalten."
"Sehr viel dramatischer (und sehr viel weniger in aller Munde) ist jedoch ein ganz anderes Problem, das die gesamten bisherigen Bemühungen der Objektorientierung um Kapselung aushebeln kann: das Aliasing-Problem. Wenn nämlich ein Objekt, das durch ein anderes Objekt gekapselt wird, indem das andere es in einer seiner Instanzvariablen hält, einen (weiteren) Alias besitzt, der nicht selbst dem kapselnden Objekt gehört, dann nützt es nichts, wenn diese Instanzvariable von außen unzugreifbar ist91 — sie wird nämlich gar nicht gebraucht, um auf das gekapselte Objekt zuzugreifen. Man bedient sich einfach des Aliases.",Was ist das Aliasing-Problem in der Objektorientierung?,"Das Aliasing-Problem ist ein Problem in der Objektorientierung, bei dem ein Objekt, das durch ein anderes Objekt gekapselt wird, einen weiteren Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dadurch kann man auf das gekapselte Objekt zugegriffen werden, auch wenn die Instanzvariable von außen unzugreifbar ist."
"Per Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung.",Was sind verschiedene Arten von Beziehungen?,"Beziehungen zwischen Klassen, das ist im Wesentlichen die Subklassen- oder Vererbungsbeziehung. Beziehungen zwischen Klassen und Instanzen, das ist im Wesentlichen die Instanziierungs- oder Klassikationsbeziehung Beziehungen zwischen Instanzen (oder Objekten), das sind im Wesentlichen beliebige Assoziationen (wie Mutter-Tochter) und bestimmte spezielle wie Komposition oder Aggregation."
"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.",Was bedeutet Zuweisungskompatibilität?,"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten."
"Außerdem gibt es in EIFFEL noch einen Typkonstruktor like <ein Ausdruck>, dessen erzeugter Typ typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der Basistyp konform, keiner seiner Subtypen.",Was ist der Typkonstruktor like <ein Ausdruck> in EIFFEL?,"Der Typkonstruktor like <ein Ausdruck> in EIFFEL erzeugt einen Typ, der typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der Basistyp konform, keiner seiner Subtypen."
,Was bedeutet Abhängigkeit zwischen Modulen in der Programmierung?,"In der Programmierung bedeutet Abhängigkeit zwischen Modulen in der Regel Änderungsabhängigkeit. Wenn sich in einem Modul etwas ändert, kann dies Auswirkungen auf andere davon abhängige Module haben. Abhängigkeiten ergeben sich oft aus Benutzungsbeziehungen und können in der objektorientierten Programmierung auch Vererbungsabhängigkeiten einschließen."
"Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode entworfen und implementiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. Testphase: In dieser Phase wird das Programm getestet, um sicherzustellen, dass es korrekt funktioniert. Die Typisierung kann dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode definiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren, und sie kann auch verwendet werden, um die Konsistenz der Daten während der Ausführung des Programms zu gewährleisten. Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben. Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält. Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert. Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.",Wozu dient die Typisierung in den verschiedenen Phasen des Programmentwicklungsprozesses?,"In der Entwurfsphase hilft die Typisierung, die Struktur des Programms zu definieren, indem sie abstrakte Datentypen und Schnittstellen spezifiziert. In der Implementierungsphase wird sie verwendet, um die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. In der Testphase kann die Typisierung dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen."
"Einhergehend mit kurzen Methoden und aussagekräftigen Bezeichnern ist ein deklarativer Programmierstil für die objektorientierte Programmierung typisch: Die Ausdrucksform bemüht sich mehr um das ""Was"" als um das ""Wie"". Der Effizienzgedanke ist dabei sekundär – mögliche Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben, wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung zu ineffizient ist.",Was ist ein deklarativer Programmierstil in der objektorientierten Programmierung?,"Ein deklarativer Programmierstil in der objektorientierten Programmierung bemüht sich mehr um das ""Was"" als um das ""Wie"". Er ist typisch für die objektorientierte Programmierung und geht einher mit kurzen Methoden und aussagekräftigen Bezeichnern. Der Effizienzgedanke ist dabei sekundär – mögliche Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben, wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung zu ineffizient ist."
Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.,Was bedeutet die Wirksamkeit der Bedingungen in diesem Kontext?,"Die Wirksamkeit der Bedingungen bedeutet, dass die Subtypenregeln und die Korrektheit der überschreibenden Methode in S die gewünschte Substituierbarkeit gewährleisten."
"Mit den Nachrichten ""suspend"" und ""terminate"" kann man den Prozess dann temporär anhalten bzw. beenden. Angehaltene Prozesse können später mit ""resume"" wieder gestartet werden, beendete nicht.","Was bewirken die Nachrichten ""suspend"" und ""terminate"" in Bezug auf einen Prozess?","Mit der Nachricht ""suspend"" kann ein Prozess temporär angehalten werden, während er mit ""terminate"" beendet wird. Ein angehaltener Prozess kann später mit ""resume"" wieder gestartet werden, während ein beendeter Prozess nicht wieder gestartet werden kann."
,Warum werden Interfaces in Java als einer der wichtigsten Beiträge zur objektorientierten Programmierung angesehen?,"Interfaces in Java sind einer der wichtigsten Beiträge zur objektorientierten Programmierung, da sie die Möglichkeit bieten, Schnittstellen und Polymorphismus zu implementieren, was die Flexibilität und Erweiterbarkeit von Programmen erheblich verbessert."
"Objekte, die keine literale Repräsentation haben, müssen in Java (wie in SMALLTALK) explizit als Instanzen von Klassen erzeugt werden. Dafür gibt es in Java eine spezielle Kategorie von Methoden, die als Konstruktoren bezeichnet werden. Im Unterschied zu SMALLTALK sind Konstruktoren in Java keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne kann man Konstruktoren als Instanzmethoden betrachten, die auf der neu erzeugten Instanz aufgerufen werden.",Was unterscheidet Konstruktoren in Java im Vergleich zu SMALLTALK?,"Im Gegensatz zu SMALLTALK sind Konstruktoren in Java keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Sie verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne können Konstruktoren als Instanzmethoden betrachtet werden, die auf der neu erzeugten Instanz aufgerufen werden."
"Nahezu alle Anweisungen finden sich in Java-Programmen innerhalb von Methoden. Blöcke sind in Java lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt Java erst seit Version 8, mit der Einführung der Lambda-Ausdrücke.",Was sind Blöcke in Java?,"In Java sind Blöcke lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt Java erst seit Version 8, mit der Einführung der Lambda-Ausdrücke."
"Nicht selten wird der Typparameter (nicht die mit ihm deklarierten Parameter!) innerhalb der Methode nicht mehr verwendet. Eine Variable, die nur einmal vorkommt, kann man aber auch weglassen oder zumindest unbenannt lassen. Und so ist es in diesen Fällen gute Praxis, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard zu verwenden.",Was ist eine Typparameter und wann sollte man eine Typ-Wildcard anstelle des Typparameters verwenden?,"Ein Typparameter ist ein Parameter, der in einer Methode verwendet wird, um einen Typ anzugeben. Es ist gute Praxis, eine Typ-Wildcard anstelle des Typparameters zu verwenden, wenn die Variable nur einmal vorkommt und nicht mehr verwendet wird. Eine Typ-Wildcard ist eine eingeschränkte Version des Typparameters, die anzeigt, dass die Variable mit einem beliebigen Typ initialisiert werden kann."
"In der objektorientierten Programmierung nennt man nicht instanziierbare Klassen abstrakt. Der Grund für die mangelnde Instanziierbarkeit ist nicht immer konzeptuell (wie beispielsweise das Prinzip, dass eine Klasse eine Generalisierung ist und daher nicht instanziierbar sein sollte), sondern oft rein technisch. Abstrakten Klassen fehlen in der Regel Angaben, die das Verhalten ihrer Instanzen vollständig spezifizieren und diese somit brauchbar machen würden. Instanzen dieser Klassen wären unvollständig definiert und würden zu Laufzeitfehlern führen. Diese fehlenden Eigenschaften werden in den Klassen geliefert, die von den abstrakten erben (siehe nächstes Kapitel), wobei die Idee ist, dass sich die Eigenschaften von Klasse zu Klasse unterscheiden. Klassen, die nicht abstrakt sind und eigene Instanzen haben können, nennt man konkret. Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse Collection.",Was ist eine abstrakte Klasse in der objektorientierten Programmierung?,"Abstrakte Klassen in der objektorientierten Programmierung sind nicht instanziierbare Klassen. Der Grund für die mangelnde Instanziierbarkeit kann konzeptuell oder rein technisch sein. Instanzen dieser Klassen wären unvollständig definiert und würden zu Laufzeitfehlern führen. Diese fehlenden Eigenschaften werden in den Klassen geliefert, die von den abstrakten erben. Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse Collection."
"In Abschnitt 7.3 hatten wir bereits die Instanziierung als den hauptsächlichen Weg kennengelernt, wie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Kopierens hingewiesen. Darauf wollen wir nun wieder zurückkommen. Klonen/Kopieren ist eine weitere Möglichkeit, neue Instanzen zu erzeugen. Dabei wird eine bestehende Instanz kopiert, d.h. es wird eine neue Instanz erzeugt, die eine identische Kopie der alten Instanz ist. Klonen/Kopieren ist eine Alternative zur Instanziierung, wenn die Klasse eine komplexe Struktur hat, die sich nicht einfach aus Literalen zusammensetzen lässt. Klonen/Kopieren ist auch dann sinnvoll, wenn die Klasse eine komplexe Struktur hat, die sich zwar einfach aus Literalen zusammensetzen lässt, aber die Initialisierung der Literale aufwändig ist. Klonen/Kopieren ist eine weitere Möglichkeit, neue Instanzen von Klassen zu erzeugen. Dabei wird ein bestehendes Objekt kopiert, d.h. es wird eine exakte Kopie des Objekts erstellt. Die Kopie ist dabei eine eigenständige Instanz, die nicht mit dem Original verbunden ist.Die Kopie eines Objekts kann auf zwei Arten erfolgen: 1. Shallow Copy: Hierbei wird das Objekt inklusive seiner Instanzvariablen kopiert. Wird ein Objekt auf diese Weise kopiert, so wird eine exakte Kopie des Objekts erstellt, die Instanzvariablen verweisen jedoch auf die gleichen Objekte wie im Original. 2. Deep Copy: Hierbei wird das Objekt inklusive seiner Instanzvariablen und deren Instanzvariablen kopiert. Wird ein Objekt auf diese Weise kopiert, so wird eine exakte Kopie des Objekts erstellt, die Instanzvariablen verweisen auf exakte Kopien der Objekte, auf die im Original verwiesen wird.",Was ist Klonen/Kopieren?,"Klonen/Kopieren ist eine Methode, um neue Instanzen von Klassen zu erzeugen, bei der ein bestehendes Objekt kopiert wird, um eine exakte Kopie des Objekts zu erstellen, die eigenständig und nicht mit dem Original verbunden ist. Es gibt zwei Arten von Kopien: Shallow Copy und Deep Copy."
,Warum kann es trotz der Harmonie von Typerweiterung und -einschränkung zu einem Verlust der Zuweisungskompatibilität kommen?,"Der Verlust der Zuweisungskompatibilität kann aus der impliziten Allquantifiziertheit von Typinvarianten resultieren. Typsysteme mit solchen Invarianten sind nicht in der Lage, Aussagen über Wertebereiche zu treffen, die nicht implizit allquantifiziert sind."
,Welche Ebene der Hierarchie nutzen Programmierer in der Praxis am meisten?,"In der Praxis bewegen sich Programmierer hauptsächlich auf Ebene 1. Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen sie also hauptsächlich eine Abstraktionsstufe für die Programmierung."
"Dabei ist ""main"" der Name der Methode; was die anderen Elemente bedeuten, werden Sie im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann einfach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter. Klassen werden in Java wie in SMALLTALK per Konvention immer großgeschrieben.",Was ist die JVM und wie wird sie aufgerufen?,"Die JVM (Java Virtual Machine) ist eine virtuelle Maschine, die Java-Bytecode ausführt. Sie wird auf Betriebssystemebene aufgerufen, indem man ihr den Namen der Klasse als Parameter übergibt."
"Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht parametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.",Wie kann man Rekursion in einem parametrisierten Typ herstellen?,"Man kann die gewünschte Rekursion indirekt herstellen, indem man einen nicht parametrischen Typ als Subtyp des parametrisierten Typs Equatable definiert und gleichzeitig den zu definierenden Typ als tatsächlichen Typparameter einsetzt."
"Dabei ist der parametrische Typ Dictionary ein Subtyp des ebenfalls parametrischen Typs Collection. Man beachte, dass der Typparameter E hier bereits in der Supertypdeklaration verwendet wird. Ein Dictionary, in dem Integer auf beliebige Objekte abgebildet werden, erhält man dann durch die Instanziierung Dictionary[Integer, Object]. Es ist mit einer Variable vom Typ Collection[Object] zuweisungskompatibel. Auf die Einzelheiten des Subtypings bei parametrischen Typen wird in Kapitel 30 eingegangen.",Was ist ein parametrischer Typ in der Programmierung?,"Ein parametrischer Typ ist ein Konstrukt in der Programmierung, bei dem ein oder mehrere Typen als Parameter verwendet werden. Dies ermöglicht die Erstellung von generischen Datentypen und Funktionen, die für verschiedene Datentypen verwendet werden können. Im gegebenen Kontext wird der parametrische Typ Dictionary verwendet, um Integer auf beliebige Objekte abzubilden."
,Was ist eine operationale Semantik in Bezug auf die Bedeutung von Typen?,"Eine operationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf Anweisungen einer (gedachten oder realen) Maschine abgebildet werden. Dies bedeutet, dass die Operationen eines Typs auf die Ausführung von Maschinenbefehlen oder anderen niedrigstufigen Operationen abgebildet werden."
,Wie kann die Klasse Bag in SMALLTALK mit Hilfe von Dictionaries implementiert werden?,"Die Klasse Bag kann in SMALLTALK mithilfe von Dictionaries implementiert werden, indem die Anzahl der Vorkommen eines Elements der Bag in einem Dictionary unter dem Element als Schlüssel gespeichert wird. Dabei nutzt die Klasse Bag die Klasse Dictionary, ohne von ihr zu erben, sondern hält sich eine Instanz von Dictionary als Sklavin, die für sie den Dienst verrichtet. Dies wird als Delegation bezeichnet und ist in prototypenbasierten objektorientierten Programmiersprachen beliebt."
"Sie retourniert (den Inhalt der) Klassenvariable ""Pi"" und ist, da sie eine Klassenmethode ist, allen Instanzen der Klasse ""Float"" zugeordnet. Dazu, wie der Wert in ""Pi"" hineinkommt, s. Abschnitt 8.2.",Was ist eine Klassenvariable?,"Eine Klassenvariable ist eine Variable, die einer Klasse gehört und allen Instanzen dieser Klasse gemeinsam ist. In diesem Fall gehört die Klassenvariable ""Pi"" der Klasse ""Float"" und ist allen Instanzen dieser Klasse zugeordnet."
"Sie retourniert (den Inhalt der) Klassenvariable ""Pi"" und ist, da sie eine Klassenmethode ist, allen Instanzen der Klasse ""Float"" zugeordnet. Dazu, wie der Wert in ""Pi"" hineinkommt, s. Abschnitt 8.2.","Was macht die Klassenmethode ""new""?","Die Klassenmethode ""new"" ist eine Methode, die jedem Objekt zugeordnet ist und aufgerufen wird, wenn ein neues Objekt erzeugt werden soll."
"Wie schon bei einer temporären Variable stehen die Typannotationen von formalen Parametern in STRONGTALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kennzeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Methode ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zurück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo-Typvariable (entsprechend der Pseudovariable self, deren Typ sie darstellt).",Was repräsentiert der Rückgabetyp Self in Smalltalk?,Der Rückgabetyp Self in Smalltalk repräsentiert den Typ des Empfängerobjekts.
,Was bedeutet die Subklassenbeziehung in SMALLTALK?,"In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Das bedeutet, dass eine Subklasse alle Instanzvariablen und Methoden ihrer Superklasse erbt. Es ist jedoch wichtig zu beachten, dass die Subklassenbeziehung allein nicht ausdrückt, dass die Subklasse eine Spezialisierung der Superklasse ist oder umgekehrt. Diese Beziehung muss vom Programmierer explizit definiert und dokumentiert werden."
,Warum stellt die Klassenhierarchie keine Form der hierarchischen Modularisierung dar?,"Die Klassenhierarchie stellt keine Form der hierarchischen Modularisierung dar, da das Herauslösen eines Teilbaums der Vererbungshierarchie praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen trennt. Somit werden Beziehungen zwischen Klassenmitgliedern gestört."
"Eine weitere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch je eine Instanz aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Diese Umsetzung der Vererbung steht jedoch im Konflikt mit dem Konzept der Identität von Objekten: Ein Objekt einer Subklasse hätte auf einmal mehrere Identitäten, und zwar eine für sich selbst und eine pro Superklasse, von der sie erbt. Auch das wäre problematisch.",Was ist das Problem bei der Erzeugung einer Instanz einer Subklasse und gleichzeitig einer Instanz jeder Superklasse?,"Das Problem ist, dass ein Objekt einer Subklasse auf einmal mehrere Identitäten hätte, und zwar eine für sich selbst und eine pro Superklasse, von der es erbt. Das würde dem Konzept der Identität von Objekten widersprechen."
,Wie wird die Strukturäquivalenz bei der Feststellung von Typäquivalenz verwendet?,"Bei der Feststellung von Strukturäquivalenz werden die Definitionen der beteiligten Typen rekursiv expandiert, wobei Namen anderer Typen durch ihre Struktur ersetzt werden. Diese Strukturäquivalenz ermöglicht es, Typen zu vergleichen, indem ihre Strukturen miteinander verglichen werden."
,Welche Anforderung stellt Java an geerbte Variablen (Felder und Parametertypen von Methoden)?,"Java verlangt, dass die Typen geerbter Variablen nicht verändert werden dürfen. Dies wird als Kovarianz bezeichnet."
"Da das Umgekehrte freilich auch nicht geht, bleibt nichts anderes, als die Unveränderlichkeit der Parametertypen, auch als Invarianz oder besser (da das dazu passende Adjektiv „invariant“ in seiner Bedeutung schon belegt ist) als Novarianz bezeichnet, zu verlangen.",Was bedeutet Novarianz?,"Novarianz bedeutet, dass die Parametertypen unveränderlich sein müssen, um die Integrität der Objekte zu gewährleisten. Diese Unveränderlichkeit wird auch als Invarianz bezeichnet."
"Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode. Sie ist in der Klasse, die dem deklarierten Typ des Ausdrucks entspricht, der das Empfängerobjekt liefert (oftmals einfach eine Variable), deklariert oder wird von einer ihrer Superklassen geerbt. Die deklarierten Parametertypen des Aufrufs (die deklarierten tatsächlichen Parametertypen) sind jeweils Subtypen der deklarierten Parametertypen der Methodendeklaration (der deklarierten formalen Parametertypen). Es gibt keine andere Methode, die dieselben Voraussetzungen erfüllt, deren deklarierte formale Parametertypen jedoch näher oder gleich weit vom Typ des Aufrufs entfernt sind (Entfernung gemessen an der Anzahl der Subtypen, die dazwischen liegen).",Wie wird ein dynamischer Methodenaufruf zur Übersetzungszeit gebunden?,"Ein dynamischer Methodenaufruf wird zur Übersetzungszeit lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die den Namen und die Anzahl der Parameter der aufgerufenen Methode teilt, in der Klasse deklariert ist, die dem deklarierten Typ des Empfängerobjekts entspricht, und deren deklarierte Parametertypen Subtypen der deklarierten Parametertypen des Aufrufs sind. Wenn es mehrere solche Methoden gibt, wird diejenige gewählt, deren deklarierte formale Parametertypen am nächsten oder gleich weit vom Typ des Aufrufs entfernt sind."
"C-Sharp soll genau wie Java und anders als C++ eine typsichere Sprache sein, also eine strikte Typprüfung durchführen. Da aber (ebenfalls genau wie in Java) nicht alles zur Übersetzungszeit geschehen kann, hat auch das Typsystem von C-Sharp eine Laufzeitkomponente.",Was ist der Unterschied zwischen C-Sharp und C++ in Bezug auf Typsicherheit?,"Im Gegensatz zu C++ ist C-Sharp eine typsichere Sprache, die eine strikte Typprüfung durchführt. Diese Typprüfung erfolgt sowohl zur Übersetzungszeit als auch zur Laufzeit. In C++ hingegen wird keine Laufzeitprüfung durchgeführt, was zu potenziellen Sicherheitsrisiken führen kann."
,Welcher Typ hat ein Klassenliteral in Java?,"Der Typ eines Klassenliterals in Java ist ""Class<T>"", wobei T der Typ der Klasse ist. Zum Beispiel hat ""Class<Object>"" den Typ ""Class<Object>""."
"Da Ausdrücke andere Ausdrücke enthalten können, stellt sich die Frage nach der Reihenfolge der Auswertung von geschachtelten Ausdrücken. Diese Reihenfolge wird, wie in anderen Programmiersprachen, implizit durch Präzedenzen und explizit durch Klammern festgelegt.Betrachten wir zunächst die doppelte Zuweisung in Zeile 38 oben. Anfangs mag es nicht sofort klar sein, welche der beiden Zuweisungen zuerst ausgewertet (ausgeführt) werden soll: y := x oder x := 1. Wenn man jedoch berücksichtigt, dass y := x := 1 ein geschachtelter Ausdruck ist, und jeder (Teil-)Ausdruck für ein Objekt steht, ergibt sich, dass der zweite Ausdruck zuerst ausgewertet und durch das Ergebnis, nämlich ""1"", ersetzt werden muss. Andernfalls würde die ""1"" dem Ergebnis von y := x zugewiesen, was aber gemäß Abschnitt 4.1.3 ein Objekt und keine Variable ist. Zeile 38 weist also zuerst x und dann y das Objekt ""1"" zu, und die Auswertung erfolgt von rechts nach links.Dies ist jedoch ein Sonderfall. Im Allgemeinen werden in SMALLTALK alle Ausdrücke von links nach rechts ausgewertet. Dabei haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke wiederum haben Vorrang vor Schlüsselwortnachrichten. Bei gleichrangigen Ausdrücken erfolgt die Auswertung von links nach rechts.Um die Präzedenz zu ändern, können Sie einfach Klammern verwenden. SMALLTALK unterstützt keine individuellen Operatorpräzedenzen wie beispielsweise ""Punktrechnung vor Strichrechnung"".Bei mehrstelligen Nachrichten mit Schlüsselwörtern werden alle Schlüsselwörter eines Ausdrucks als zu einer Nachricht gehörig interpretiert, es sei denn, es werden Klammern gesetzt.",Wie ist die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK?,Die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK wird durch Präzedenzen und Klammern festgelegt.
"Der Mut zur Verabschiedung von der expliziten Speicherfreigabe war eine der wichtigsten Entscheidungen beim Entwurf von SMALLTALK. Man hat einfach anerkannt, dass die genaue Buchführung darüber, auf welche Objekte noch zugegriffen wird, zu schwierig ist, um die Verantwortung dafür den Anwendungsprogrammierern zu überlassen. Wer das Problem nicht unmittelbar einsichtig findet, halte sich vor Augen, dass der Ort der Erzeugung eines Objektes und seine erste Zuweisung zu einer Variable im Programm möglicherweise weit entfernt sind von der Stelle, an der dieser Variable ein anderes Objekt zugewiesen wird, es möglicherweise viele solcher Stellen gibt, von denen mal die eine, mal die andere zuerst erreicht wird, und dass in der Zwischenzeit beliebig viele Aliase auf das Objekt angelegt worden sein könnten, die alle mit berücksichtigt werden müssen, um zu entscheiden, ob das Objekt noch in Verwendung ist.Eine vorzeitige Entfernung aus dem Speicher hingegen führt dazu, dass Variablen ins Leere zeigen (eine häufige Quelle von Programmabstürzen) oder dass, bei einer Wiederverwendung des Speichers, die Variable plötzlich auf ein anderes Objekt verweist, das ihr aber nie explizit zugewiesen wurde — ein quasi zufälliges Programmverhalten, das mit hoher Wahrscheinlichkeit zu schweren Programmfehlern führen würde. Ein anderes Beispiel entsteht, wenn in einer Verzweigung eines Programms entweder ein neues oder ein bereits vorhandenes Objekt einer Variable zugewiesen wird. Woher weiß man bei der weiteren Benutzung dieser Variable, ob das Objekt schon vorher existierte und vielleicht schon andere Variablen auf es verweisen, oder ob es gerade erst neu erzeugt wurde und damit noch unbenutzt ist? Wer ist für die Entsorgung des Objekts verantwortlich? All diese Betrachtungen kann man sich in Gegenwart der Garbage Collection ersparen.",Was sind die Vorteile der Garbage Collection in SMALLTALK?,"Die Garbage Collection verhindert vorzeitige Entfernung von Objekten, die noch in Verwendung sind, und stellt sicher, dass Variablen auf gültige Objekte verweisen. Dies trägt zur Stabilität und Sicherheit von Programmen bei."
"Man hätte nun auch umgekehrt vorgehen können und dabei das Prinzip von Generalisierung und Spezialisierung hochhalten können, indem man Quadrat von Rechteck erben lässt (sofern man akzeptiert, dass die Generalisierung Rechteck eigene Instanzen hat). Der Nachteil dieses Ansatzes wäre jedoch, dass Quadrat dann ebenfalls zwei Instanzvariablen für Seitenlängen hätte, obwohl eine ausgereicht hätte. Auf der anderen Seite hätte man die Methoden für Fläche und Umfang nicht überschreiben müssen, denn wenn laenge und breite gleich sind, unterscheiden sich die beiden obigen Implementierungen von flaeche und umfang im Ergebnis nicht. Man muss nur sicherstellen, dass in Instanzen von Quadrat laenge und breite tatsächlich immer gleiche Werte haben.",Was ist Generalisierung und Spezialisierung in Bezug auf objektorientierte Programmierung?,"Generalisierung und Spezialisierung sind Prinzipien in der objektorientierten Programmierung. Dabei wird eine allgemeine Klasse (Generalisation) erstellt, die dann durch eine spezifischere Klasse (Spezialisation) erweitert wird. In diesem Fall wird die Klasse Rechteck als allgemeine Klasse angesehen und Quadrat als spezifischere Klasse, die von Rechteck erbt."
,Warum werden bestimmte Typsysteme als kaum praxistauglich bezeichnet?,"Bestimmte Typsysteme, die in der Lage sind, solche Einschränkungen zu überprüfen, werden als kaum praxistauglich bezeichnet, da sie die Flexibilität und die praktische Anwendbarkeit in realen Programmiersituationen stark einschränken. Sie können zu komplexen und schwer wartbaren Code führen."
"Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.",Was ist der Vorteil von Interfaces in Java?,"Der Vorteil von Interfaces in Java ist, dass sie die Abhängigkeit von der Implementierung verringern, da Klienten auf die Methoden zugreifen können, ohne die tatsächliche Implementierung zu kennen. Dies ermöglicht es, die Klassen zu ändern, ohne die Klienten zu beeinflussen, und erleichtert die Wartung und Erweiterung des Codes."
"Eine weitere, vergleichsweise häufig verwendete Möglichkeit des Einsatzes von Interfaces ist die als sog. Tagging oder Marker interfaces. Ein Tagging oder Marker Interface hat in der Regel keine eigenen Methodendeklarationen, sondern dient lediglich der Filterung von Variablenwerten. ""Serializable"" wäre ein solches Interface. Da in Java die vom Compiler statisch geprüfte Zuweisungskompatibilität ja Namenskonformität verlangt, kann die Typisierung einer Variable mit dem Interface ""Markiert"" erzwingen, dass dieser Variable nur Instanzen solcher Klassen zugewiesen werden, die das Interface ""Markiert"" zu implementieren deklarieren. Da das Interface aber keine Auflagen macht (keine Methodendeklarationen vorgibt, die von der Klasse mit Definitionen versehen werden müssen), ist die Implementierung des Interfaces für die Klasse zunächst ohne Konsequenzen. Die durch das Interface erfolgte Markierung der Klassen (bzw. deren Instanzen) kann jedoch zur Übersetzungszeit vom Compiler (s. o.) und zur Laufzeit durch einen Typtest (s. Abschnitt 44.2) überprüft werden. Ein konkretes Beispiel für ein Marker-Interface in Java ist das Interface ""Serializable"", mit dessen Implementierung eine Klasse deklariert, dass ihre Instanzen serialisiert werden können. Die Serialisierung wird aber nicht von der Klasse selbst vorgenommen, sondern von einer anderen; die Klasse muss also zu ihrer Serialisierung nichts weiter beitragen. Seit Java 5 würde man allerdings solche Marker-Interfaces eher durch Metadaten (auch Annotationen genannt; s. Abschnitt 47.4) ersetzen, so wie das in C-Sharp schon länger gehandhabt wird (s. Abschnitt 50.4 in Kurseinheit 5). Interfaces erhöhen die Komplexität des Codes und können durch Metadaten ersetzt werden, die nur Informationen enthalten, aber keine Methoden deklarieren.",Was sind Tagging oder Marker Interfaces in Java?,"Tagging oder Marker Interfaces in Java haben keine eigenen Methodendeklarationen, sondern dienen lediglich der Filterung von Variablenwerten. Sie können erzwingen, dass einer Variablen nur Instanzen solcher Klassen zugewiesen werden, die das Interface zu implementieren deklarieren. Die Implementierung des Interfaces für die Klasse ist zunächst ohne Konsequenzen, kann aber zur Übersetzungszeit vom Compiler und zur Laufzeit durch einen Typtest überprüft werden."
,Wie wird die Zulässigkeit von Typumwandlungen in C++ überprüft?,"Die Zulässigkeit von Typumwandlungen in C++ wird zur Laufzeit überprüft, und sie kann nicht zur Kompilierzeit überprüft werden. Typumwandlungen sollten vermieden werden, da sie die Typsicherheit untergraben können."
"Das herausragende Merkmal, das EIFFEL zu dieser Multifunktion qualifiziert, ist die Integration von Zusicherungen (die Formulierung von Vorbedingungen, Nachbedingungen und Klasseninvarianten), die als Verträge zwischen dienstanbietenden und dienstnehmenden Klassen interpretiert werden können. Dies erlaubt, das ""Was"" einer Software zumindest teilweise unabhängig vom ""Wie"" zu spezifizieren. Die Typsysteme, die Sie in den vorangegangenen Kapiteln kennengelernt haben und von denen auch EIFFEL eines besitzt, erlauben zwar auch schon, Zusicherungen auszudrücken, aber diese beziehen sich jeweils auf die möglichen Werte einer Variable und bleiben dabei sowohl voneinander als auch von der Zeit unabhängig. EIFFEL erlaubt darüber hinaus, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können.",Was ermöglicht EIFFEL im Vergleich zu anderen Typsystemen?,"EIFFEL ermöglicht es, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können. Im Gegensatz zu anderen Typsystemen, die sich jeweils auf die möglichen Werte einer Variablen beziehen und dabei voneinander und von der Zeit unabhängig bleiben."
"Zur Laufzeit wird dann nur noch der tatsächliche Typ des Empfängerobjekts (die Klasse, von der es eine Instanz ist) bestimmt. Dieser muss aufgrund der Regeln der Zuweisungskompatibilität ein Subtyp des deklarierten Typs des Ausdrucks sein, der das Empfängerobjekt liefert. Mit diesem tatsächlichen (auch dynamisch genannten) Typ wird dann aus der zuvor bestimmten Gruppe von in Frage kommenden überschriebenen Methoden diejenige ausgewählt, die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Superklassenkette am nächsten ist.",Was ist der Unterschied zwischen dem deklarierten Typ und dem tatsächlichen Typ eines Objekts?,"Der deklarierte Typ eines Objekts ist der Typ, der bei der Deklaration des Objekts angegeben wird, während der tatsächliche Typ (auch dynamischer Typ genannt) erst zur Laufzeit bestimmt wird. Der tatsächliche Typ muss ein Subtyp des deklarierten Typs sein."
"Zur Veranschaulichung soll die nachfolgende Abbildung dienen, die einen Programmtext als eine Folge von Anweisungen stilisiert. Anweisungen sind durch Kreise dargestellt, die (textuelle) Folge der Anweisungen im Programmtext durch die kleinen Pfeile. Ohne besondere, den Kontrollfluss beeinflussende Anweisungen entspricht die (dynamische) Reihenfolge der Ausführung der (statischen) Folge der Anweisungen im Programmtext. Bei Betrachtung des stärker umrandeten, mittleren Kreises (der entsprechenden Anweisung), z. B. während einer Debug-Sitzung, ist daher aus dem unmittelbaren Kontext heraus (der Ellipse; Lokalitätsprinzip!) klar, welche Anweisung davor ausgeführt wurde und welche als nächstes drankommt. Alles ist in bester Ordnung.Handelt es sich nun bei einer der Anweisungen um ein Goto, dann ist die Sachlage längst nicht mehr so klar. Man hat vielmehr die folgenden Fälle zu unterscheiden: Die betrachtete Anweisung ist selbst ein Goto: In diesem Fall ist zwar klar, woher der Programmfluss kommt, und auch, wohin er geht, letzteres aber nur mit einer gewissen Einschränkung — das Ziel ist nicht der Nachbar im Programmtext, sondern befindet sich außerhalb des gewählten Kontextes. Nun kann man den Kontext natürlich so wählen, dass er das Ziel enthält, und kurze Sprünge sind vielleicht auch so innerhalb des betrachteten Kontextes möglich; allgemein gilt jedoch, dass jede gewählte Lokalität durch einen Sprung verletzt werden kann. Immerhin lässt sich aber das Ziel des Sprungs aus dem Kontext erkennen und der Kontext entsprechend wechseln. Die betrachtete Anweisung ist Ziel eines Gotos: Hier ist die Sachlage schon schwieriger. Der Programmfluss scheint bei Betrachtung des Kontextes genau wie im ersten Beispiel zu verlaufen. Wenn man den Kontext allerdings vergrößert, lernt man, dass die dynamischen Vorgänger in der betrachteten Anweisung auch andere sein können. Der Kontext selbst gibt jedoch keinen Hinweis darauf; zwar kann das Vorhandensein eines Sprunglabels einen Hinweis darauf geben, dass die so markierte Anweisung Ziel eines Gotos sein kann, sie muss es aber nicht; in Sprachen wie BASIC beispielsweise (damals noch weit verbreitet), in denen Zeilennummern gültige Sprungziele sind, muss jede Anweisung als mit einem Label versehen betrachtet werden und kann somit Sprungziel von irgendwoher sein. Außerdem kann eine Anweisung von verschiedenen Gotos angesprungen werden, so dass unklar bleibt, welches die (zeitliche) Vorgängeranweisung war. Die betrachtete Anweisung ist unmittelbare Nachfolgerin eines Gotos: Hier ist zwar aus dem Kontext ersichtlich, dass die statischen Vorgänger nicht die dynamischen sein können, ansonsten kann man aber nur mutmaßen, dass es sich vielleicht um toten Code handeln könnte (also um Code, der niemals ausgeführt wird). Es kann nämlich die Anweisung Sprungziel von Gotos außerhalb des Kontexts sein (wie in allen anderen Fällen auch).",Was ist die Auswirkung von Goto-Anweisungen auf den Programmfluss?,"Goto-Anweisungen können den Programmfluss beeinflussen, indem sie den Kontext verlassen und zu einer anderen Stelle im Programm springen. Das Ziel des Sprungs ist nicht immer eindeutig aus dem Kontext erkennbar, und es kann unklar sein, welche Anweisungen vorher ausgeführt wurden."
"Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C-Sharp. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C-Sharp, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:",Was ist eine Klassenhierarchie in C-Sharp?,"Eine Klassenhierarchie in C-Sharp ist eine Vererbungshierarchie, die die verschiedenen Arten von Typen in C-Sharp einteilt. Sie ist wesentlich komplexer und vereinheitlicht das Typsystem von C-Sharp, indem alle Typen von System.Object abgeleitet sind."
,Was möchte man bei der Deklaration von n-wertigen Attributen angeben?,Bei der Deklaration von n-wertigen Attributen möchte man den Typ der in Beziehung stehenden Objekte angeben.
"Diese zweite Form der Abstraktion, die Generalisierung, ist also genau wie die Klassifikation Bestandteil der klassenbasierten objektorientierten Programmierung. Anders als bei der Klassifikation ist bei der Generalisierung jedoch die Höhe der Abstraktionshierarchie nicht durch praktische Überlegungen beschränkt, sondern kann von der Programmiererin nach Belieben festgelegt werden. Sprachphilosophisch betrachtet sind Generalisierungen ebenfalls Allgemeinbegriffe, nur noch allgemeiner. Generalisierungen können selbst wiederum Generalisierungen haben, und so weiter. Wie es für eine Abstraktionshierarchie typisch ist, werden die Definitionen, die Intensionen, dabei immer präziser. Gleichzeitig wächst jedoch die Extension (das bereits in Abschnitt 7.1 erwähnte Prinzip vom inversen Zusammenhang der beiden).",Was ist Generalisierung in der objektorientierten Programmierung?,"Generalisierung ist eine Form der Abstraktion in der objektorientierten Programmierung, die Bestandteil der klassenbasierten objektorientierten Programmierung ist. Im Gegensatz zur Klassifikation ist bei der Generalisierung die Höhe der Abstraktionshierarchie nicht beschränkt und kann von der Programmiererin festgelegt werden. Generalisierungen können selbst wiederum Generalisierungen haben, wodurch eine Abstraktionshierarchie entsteht."
,Was ist beschränkter parametrischer Polymorphismus in Java?,"Beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Einschränkung der möglichen Typen, die für einen Typparameter einer generischen Klasse verwendet werden können. Dies geschieht durch das Festlegen von Beschränkungen oder Bedingungen für den Typparameter."
,Was ist Generizität in C-Sharp?,"Generizität in C-Sharp ermöglicht es, parametrischen Polymorphismus sowohl für Klassen als auch für Methoden zu nutzen. Sie erlaubt die Definition von generischen Klassen und Interfaces, die eine Menge von Typen spezifizieren, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen."
"Ein weiterer Kompromiss betrifft die Ausdruckskraft des Typsystems. Je ausdruckskräftiger ein Typsystem ist, desto mehr Informationen kann es in einer Typannotation unterbringen und desto mehr Typfehler lassen sich aufdecken. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass es in einem konkreten Fall notwendig ist, eine aufwändige (und unter Umständen nicht einmal terminierende) Typprüfung durchzuführen. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen (Interfaces, siehe Kapitel 62) deutlich erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können (dies ist in der objektorientierten Programmierung ein schwer wiegendes Manko, da das gemeinsame Arbeiten von Klassen aus verschiedenen Bibliotheken die Regel ist).",Was ist ein Typsystem und wie wirkt sich seine Ausdruckskraft auf die Komplexität aus?,"Ein Typsystem ist ein Mechanismus, der Typen von Variablen und Ausdrücken überprüft. Je ausdruckskräftiger ein Typsystem ist, desto mehr Informationen kann es in einer Typannotation unterbringen und desto mehr Typfehler lassen sich aufdecken. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass es in einem konkreten Fall notwendig ist, eine aufwändige (und unter Umständen nicht einmal terminierende) Typprüfung durchzuführen."
"Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C-Sharp) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.",Was ist Mehrfachvererbung in C++?,"Mehrfachvererbung in C++ bedeutet, dass eine Klasse von mehreren anderen Klassen abgeleitet werden kann. Die Syntax von C++ sieht vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten."
,Wo können Typvariablen (formale Typparameter) in Java verwendet werden?,Typvariablen können sowohl in Typdefinitionen als auch in Methodendefinitionen in Java verwendet werden.
,Wo wird der Rückgabetyp für Blöcke in STRONGTALK angegeben?,"Der Rückgabetyp für Blöcke in STRONGTALK wird im selben Segment wie die formalen Parameter angegeben, und zwar vor dem Trennzeichen."
,Was sind Properties in C-Sharp und wie unterscheiden sie sich von Zugriffsmethoden (Settern und Gettern)?,"Properties in C-Sharp sind eine Möglichkeit, auf die Felder eines Objekts zuzugreifen, indem Methoden aufgerufen werden, die wie Feldzugriffe aussehen. Sie sind die Umkehrung von Zugriffsmethoden (Settern und Gettern) und ermöglichen es, Feldzugriffe mit Nebeneffekten zu versehen. In C-Sharp werden die Schlüsselwörter ""get"" und ""set"" verwendet, wobei ""get"" für den Lesezugriff und ""set"" für den Schreibzugriff verwendet wird. Die Variable ""value"" wird verwendet, um den Eingabewert eines Setters zu halten."
,Was erlaubte Java 9 in Bezug auf Interfaces?,"In Java 9 wurde es erlaubt, in Interfaces auch private Methoden zu definieren. Diese privaten Methoden sind nur innerhalb des Interfaces selbst zugreifbar und dienen dazu, die Lesbarkeit von Default-Methoden zu verbessern, indem gemeinsame Teile in private Methoden ausgelagert werden können."
,Was unterscheidet eine parametrische Typdefinition und eine normale Typdefinition?,"Der Unterschied besteht darin, dass in einer parametrischen Typdefinition andere Typen durch Platzhalter, sogenannte Typparameter, vertreten werden können, die erst bei der Verwendung des parametrisierten Typs belegt werden. Bei einer normalen Typdefinition werden die anderen Typen direkt genannt."
"Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Methode einer Superklasse des Empfängerobjekts ausgeführt wird, das Objekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilierung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden — handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch Instanz seiner Klasse ist. Die gerade ausgeführte Methode betrachtet es lediglich wie ein Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die Bedeutung der Pseudovariable super, wie wir noch sehen werden.","Was passiert, wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind, aber in der Unterklasse hinzugekommen sind?","Die Methode kann nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar."
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in Java (besser gesagt, in Java ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als Java).",Wie werden abstrakte Klassen in EIFFEL deklariert?,"In EIFFEL werden abstrakte Klassen mit dem Schlüsselwort ""deferred"" deklariert."
"Die Klasse Object definiert die Eigenschaften, die allen Objekten, einschließlich Array-Objekten, gemeinsam sind. Hierbei handelt es sich nicht um Felder (Instanzvariablen), sondern um elf Methoden. Diese sind: Object clone(): Zum Erzeugen von Kopien (vergleichbar mit SMALLTALK's copy). boolean equals(Object): Zum Test auf Gleichheit anstelle von Identität (entsprechend SMALLTALK's =). String toString(): Gibt eine String-Repräsentation des Objekts zurück (entsprechend SMALLTALK's printString). Class<? extends Object> getClass(): Zur Ermittlung des Klassentyps (entsprechend SMALLTALK's class). int hashCode(): Zur Speicherung von Objekten in Hash-Tabellen (entsprechend SMALLTALK's hash). void finalize(): Wird vom Garbage Collector aufgerufen, wenn das Objekt aus dem Speicher entfernt wird (dies ermöglicht das Freigeben von externen Ressourcen, die mit dem Objekt verbunden sind, wie z. B. das Schließen von Dateien). void notify() und void notifyAll(): Zur Benachrichtigung von Threads, die auf den Monitor des Objekts warten. void wait(): In drei Versionen, um den ausführenden Thread zum Warten zu bringen, entweder bis dem Objekt ein Notify gesendet wird oder ein anderes Ereignis eintritt.",Was sind die Eigenschaften der Klasse Object in Java?,"Die Klasse Object definiert die Eigenschaften, die allen Objekten, einschließlich Array-Objekten, gemeinsam sind. Hierbei handelt es sich um elf Methoden, darunter clone() zum Erzeugen von Kopien, equals(Object) zum Test auf Gleichheit anstelle von Identität, toString() zur Rückgabe einer String-Repräsentation des Objekts, getClass() zur Ermittlung des Klassentyps, hashCode() zur Speicherung von Objekten in Hash-Tabellen, und finalize() zur Freigabe von externen Ressourcen, die mit dem Objekt verbunden sind."
"Nun sind Klassen relativ feingranulare Gebilde. Zwar hindert einen nichts daran, große Klassen (mit Hunderten von Attributen und Methoden) zu schreiben, aber dies gilt nicht nur als schlechter Stil, es spiegelt auch die Anwendungsdomäne in aller Regel nicht angemessen wider. Dort sind nämlich alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Dasselbe gilt auch für die Artefakte anderer Ingenieursdisziplinen: Baupläne sind in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert. Da wünscht man sich natürlich analoge Möglichkeiten in der objektorientierten Programmierung.",Warum sind Klassen in objektorientierter Programmierung relativ feingranular?,"Klassen sind in objektorientierter Programmierung relativ feingranular, weil große Klassen mit Hunderten von Attributen und Methoden als schlechter Stil gelten und die Anwendungsdomäne nicht angemessen widerspiegeln. Stattdessen sind alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Diese Art der Strukturierung findet man auch in anderen Ingenieursdisziplinen wie dem Bauwesen, wo Baupläne in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert sind."
,Welche Variante der objektorientierten Programmierung scheint besser für die GUI-Programmierung geeignet zu sein?,"Die prototypenbasierte Variante der objektorientierten Programmierung, wie sie in JavaSCRIPT verwendet wird, scheint besser für die GUI-Programmierung geeignet zu sein."
"In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Eine Subklasse erbt demnach alle Instanzvariablen und Methoden ihrer Superklasse. Dass sie darüber hinaus auch noch ihre Klassenvariablen und -methoden erbt, ist nicht selbstverständlich. Wichtig ist hier, festzuhalten, dass durch eine existierende Subklassenbeziehung zwischen zwei Klassen nicht ausgedrückt wird, dass die Subklasse eine Spezialisierung der Superklasse ist oder gar die Superklasse eine Generalisierung der Subklasse. Dies sicherzustellen obliegt der Verantwortung des Programmierers.",Was ist die Subklassenbeziehung in SMALLTALK?,"In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt, d.h. eine Subklasse erbt alle Instanzvariablen und Methoden ihrer Superklasse. Es wird jedoch nicht ausgedrückt, dass die Subklasse eine Spezialisierung der Superklasse ist oder die Superklasse eine Generalisierung der Subklasse. Diese Sicherstellung obliegt der Verantwortung des Programmierers."
C++ ist als objektorientierter Nachfolger von C konzipiert und ermöglicht so einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung. Dies ist besonders nützlich für die Migration von Altsystemen zur Objektorientierung. Infolgedessen zielt C++ auf die gleiche Klasse von Anwendungen wie C ab: maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen. Extreme Speicher- und Recheneffizienz sind dabei oft oberste Kriterien.,Was ist C++ und wofür wird es eingesetzt?,"C++ ist ein objektorientierter Nachfolger von C, der einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung ermöglicht. Es wird hauptsächlich für maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen eingesetzt, bei denen extreme Speicher- und Recheneffizienz oft oberste Kriterien sind."
,"Gibt es vollständig in sich selbst definierte Typsysteme, die von externen Einflüssen unabhängig sind?","Nein, es gibt keine vollständig in sich selbst definierten Typsysteme, die vollständig unabhängig von externen Einflüssen sind. Selbst in Typsystemen wie SMALLTALK oder STRONGTALK sind mindestens einige grundlegende Typen oder Konzepte, wie Wahrheitswerte oder Ganzzahlen, von externen Formalismen oder vorgegebenen Semantiken abhängig."
"Zunächst könnte man annehmen, dass alle Klassen Instanzen einer speziellen Klasse, nennen wir sie ""Class"", sind. Jede Klasse hätte dann (als Instanz dieser Klasse) die Instanzvariablen und Methoden, die in ""Class"" definiert sind. Insbesondere hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden. Dies scheint zunächst auch sinnvoll, denn bei den Klassen handelt es sich ja um Objekte derselben Art, nämlich einheitlich um Klassen.","Warum hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden, wenn sie Instanzen einer speziellen Klasse ""Class"" wären?","Wenn jede Klasse Instanzen einer speziellen Klasse ""Class"" wäre, hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden, weil sie alle Instanzen derselben Klasse sind und somit dieselben Attribute und Methoden haben sollten."
,Welche Vorteile bietet das Stream-Framework von Java im Vergleich zu naiven Implementierungen von Pipelines?,"Das Stream-Framework von Java ermöglicht für viele Pipelines eine besonders effiziente Ausführung. Es minimiert die Anzahl der Iterationen, reduziert die interne Speicherung von Zwischenergebnissen und erlaubt die Auswahl zwischen paralleler und sequenzieller Verarbeitung der Pipeline. Dennoch ist die Performanz von Java-Pipelines nicht leicht vorherzusagen und erfordert Erfahrung und Kenntnisse der Implementierung."
"In Java ist jeder Typ ein Subtyp von Object. Dies gilt auch für Interfaces. Es ist jedoch zu beachten, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können.",Welche Rolle spielen Interfaces in Java?,"Interfaces in Java spielen eine wichtige Rolle bei der Abstraktion und der Schaffung von Schnittstellen, die von mehreren Klassen implementiert werden können. Sie ermöglichen es, die Abhängigkeiten zwischen Klassen zu verringern und die Code-Wiederverwendung zu erhöhen. Interfaces können auch als Verträge zwischen Klassen betrachtet werden, die sicherstellen, dass eine Klasse eine bestimmte Funktionalität bereitstellt."
,Wann liefert eine Stream-Pipeline in Java ein Ergebnis?,"Eine Stream-Pipeline in Java liefert ein Ergebnis immer erst durch einen sogenannten Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert, beispielsweise eine Collection im Falle von collect."
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".",Wozu dient die liberale Zuweisungskompatibilität bei generischen Typen?,"Die liberale Zuweisungskompatibilität bei generischen Typen ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel kann so eine Methode ""sort"" mit Objekten verschiedener Instanzen von ""ArrayList<E>"" aufgerufen werden, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>""."
"Sprachphilosophisch gesehen ist eine Klasse ein Allgemeinbegriff wie etwa ""Person"", ""Haus"" oder ""Dokument"". Diese Allgemeinbegriffe stehen in der Regel für eine ganze Menge von Objekten, also etwa alle Personen, Häuser oder Dokumente. Gleichwohl ist die Klasse selbst immer ein Singular — sie ist nämlich selbst ein Objekt, das unter den Allgemeinbegriff ""Klasse"" fällt. Diese Sprachregelung wird auch in der objektorientierten Programmierung eingehalten (obwohl sie natürlich nicht, da Computer unsere Sprache nicht kennen, überprüft werden kann und deswegen Abweichungen immer wieder vorkommen): Alle Klassennamen sind Singular.",Was sind Klassen sprachphilosophisch?,"Sprachphilosophisch betrachtet ist eine Klasse ein Allgemeinbegriff. Diese Allgemeinbegriffe repräsentieren in der Regel eine Menge von Objekten,. Dennoch ist die Klasse selbst immer im Singular, da sie selbst ein Objekt ist, das unter den Allgemeinbegriff ""Klasse"" fällt."
"Typ ist ein primitiver Begriff, vergleichbar etwa mit dem Begriff der Menge in der Mengentheorie. Ein Typ hat eine Intension und eine Extension, wobei erstere der Definition des Typs entspricht, letztere seinem Wertebereich, also der Menge der Elemente (Objekte), die zu dem Typ gehören (man sagt auch, „die den Typ haben“ oder „die von dem Typ sind“). Häufig hat ein Typ auch einen Namen, den Typbezeichner. Typen sind die Grundlage von Typsystemen.",Was ist der Unterschied zwischen Intension und Extension eines Typs?,"Die Intension eines Typs entspricht seiner Definition, während die Extension dem Wertebereich des Typs entspricht, also der Menge der Elemente (Objekte), die zu dem Typ gehören."
"Einhergehend mit der Trennung zwischen primitiven und Referenztypen gibt es in Java auch eine Trennung zwischen Operationen und Methoden: Auf den primitiven Typen sind bestimmte Operationen, wie mathematische und boolesche Operationen, fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Da primitive Typen jedoch keine Klassen sind, gibt es beispielsweise für mathematische Funktionen eine spezielle Klasse namens Math, in der Funktionen wie sin(.) als Klassenmethoden hinterlegt sind. Umgekehrt ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren, wie es bei den binären Methoden in SMALLTALK der Fall ist (siehe Abschnitt 4.1.2 in Kurseinheit 1). Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von Java als Programmiersprache geprägt hat. Anfangs führte dies zu ihrem Ruf als hybride Programmiersprache, die sowohl objektorientierte als auch imperative Eigenschaften aufweist. Aus meiner Sicht ist die Unterscheidung zwischen Objekten und Werten, wie sie in Java vorgenommen wurde, jedoch sinnvoll: Werte besitzen weder Identität noch Zustand, daher unterscheiden sie sich von Objekten.",Wie ist der Umgang mit primitiven Typen und Referenztypen in Java?,"In Java gibt es eine klare Trennung zwischen primitiven Typen und Referenztypen. Für primitiven Typen sind bestimmte Operationen fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Primitive Typen sind keine Klassen und es ist daher nicht gestattet, Operatoren in Klassendefinitionen zu definieren. Diese Trennung ist konsequent durchgezogen und hat den Charakter von Java als Programmiersprache geprägt."
,Warum ist die gute objektorientierte Programmierung bei Problemen mit einem hohen algorithmischen Anteil und einfachen Datenstrukturen möglicherweise weniger geeignet?,"Die gute objektorientierte Programmierung erfordert, den Code auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Bei Problemen mit einfachen Datenstrukturen und einem hohen algorithmischen Anteil müssen größere Probleme jedoch in der Regel auf durch verschiedene Klassen definierte Daten zugreifen. Dies kann dazu führen, dass der Code durch seine Datenbindung regelrecht zerfleddert wird."
,Warum wird in der Praxis der objektorientierten Programmierung oft die Referenzsemantik verwendet?,"In der Praxis der objektorientierten Programmierung wird oft die Referenzsemantik verwendet, da sie effizienter ist und es ermöglicht, auf dasselbe Objekt von verschiedenen Stellen im Code aus zuzugreifen. Dies erleichtert die Arbeit mit komplexen Datenstrukturen und verhindert unnötige Kopien von Objekten. Die Referenzsemantik ist daher die gebräuchlichere Semantik in vielen objektorientierten Programmiersprachen."
,"Warum wurden Typen und Klassen in diesem Text als separate Konzepte dargestellt, obwohl sie in vielen Sprachen gleich sind?","Die Trennung von Typen und Klassen wird gezeigt, weil sie nicht in allen Programmiersprachen identisch sind, und selbst in den Sprachen, in denen sie ähnlich sind, gibt es Unterschiede und spezifische Verwendungszwecke."
,Wie könnte man die Kovarianzprobleme in EIFFEL verhindern?,"Es gibt verschiedene Ansätze, um die Kovarianzprobleme in EIFFEL zu verhindern, darunter die Beschränkung der Zuweisungskompatibilität, die Durchführung einer Typinferenz für das gesamte Programm und das Verbot dynamisch gebundener Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen ändern. Jede dieser Methoden hat jedoch ihre eigenen Einschränkungen und Herausforderungen."
"Die Beziehung eines Objekts zu einem anderen, also eine Zu-1-Beziehung, wird auf natürliche Weise durch eine benannte Instanzvariable ausgedrückt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung trägt. So zeigt die Instanzvariable arbeitgeber beispielsweise auf das Objekt, das in der Beziehung Anstellung aus Sicht des Arbeitnehmerobjekts die Rolle des Arbeitgebers spielt. Hat auch das Arbeitgeberobjekt einen Verweis auf das Arbeitnehmerobjekt (die Rückrichtung), so wird die entsprechende Variable sinnvollerweise nach der Gegenrolle arbeitnehmer genannt. Steht ein Arbeitnehmerobjekt zurzeit in keinem Anstellungsverhältnis, ist seine Instanzvariable arbeitgeber leer, was in SMALLTALK durch den Verweis auf das Objekt nil ausgedrückt wird.",Wie werden Zu-1-Beziehungen umgesetzt?,Zu-1-Beziehungen können direkt durch benannte Instanzvariablen zwischen Objekten umgesetzt werden.
"Dabei wird einfach die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag, solange diese nicht Null ist, in einem Dictionary unter dem Element als Schlüssel gespeichert.",Was wird in einem Dictionary während der Ausführung einer Methode gespeichert?,"In einem Dictionary wird während der Ausführung einer Methode die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag, solange diese nicht Null ist, in einem Dictionary unter dem Element als Schlüssel gespeichert."
"Man beachte übrigens, wie wenig Aufwand es ist, aus dem klassenbasierten Methoden-Lookup einen objektbasierten zu machen: Man muss dazu lediglich jedem einzelnen Objekt sein eigenes Methodenwörterbuch zur Verfügung stellen. Wenn man zusätzlich noch Objekte von Objekten anstelle von Klassen von Klassen erben lässt, dann hat man schon die prototypenbasierte Form der objektorientierten Programmierung. Der Unterschied ist also technisch nicht besonders groß — konzeptuell hingegen schon, denn mit den Klassen entfielen auch die sonst so nützlichen Begriffe von Generalisierung und Spezialisierung (von der Generalisierung von Objekten zu sprechen erscheint wenig sinnvoll).","Was passiert mit den Begriffen Generalisierung und Spezialisierung, wenn man von Objekten statt von Klassen spricht?","Wenn man von Objekten statt von Klassen spricht, erscheint es wenig sinnvoll, von Generalisierung und Spezialisierung zu sprechen."
,"Was sind einige Beispiele für spezielle, instanziierbare (konkrete) Collection-Klassen in SMALLTALK und wofür werden sie verwendet?","Einige Beispiele für spezielle, instanziierbare (konkrete) Collection-Klassen in SMALLTALK sind: Set: Diese Klasse wird verwendet, um ungeordnete Collections darzustellen, in denen jedes Element höchstens einmal vorkommen darf, was einer Menge entspricht. Bag: Bag wird verwendet, um ungeordnete Collections darzustellen, in denen die Einschränkung aufgehoben ist, dass Elemente nur einmal vorkommen dürfen. In einer Bag können Elemente mehrmals vorhanden sein. SequenceableCollection oder IndexedCollection: Diese Klassen repräsentieren geordnete Collections, bei denen das i-te Element eindeutig bestimmt ist. Sie implementieren die Methoden ""at:"" und ""at:put:"", um auf Elemente zuzugreifen oder Elemente an einer bestimmten Position einzufügen oder zu ändern. Dictionary: Diese Klasse repräsentiert eine ungeordnete Collection, bei der jedes Element unter einem Schlüssel gespeichert wird. Die Methoden ""at:"" und ""at:put:"" werden verwendet, um auf die Elemente zuzugreifen oder sie zu ändern. Dabei können Schlüssel Objekte verschiedener Klassen sein, nicht nur Integer."
"Eine Klasse (das Objekt, das die Klassen repräsentiert, nicht ihr Name) wird in SMALLTALK nach ihrer Erzeugung übrigens durch eine globale Pseudovariable repräsentiert, deren Name der Name der Klasse ist. Da die Variable global ist, muss sie (und damit auch der Name der Klasse) immer mit einem Großbuchstaben beginnen. Die Variable wird automatisch mit der Klassendefinition eingeführt (vereinbart); ihr „Wert“, die Klasse, auf die sie verweist, ist das Objekt, das ihr bei der Anlage der Klasse zugewiesen wird. Da Klassennamen globale Variablen sind, da sie insbesondere absolut global sind und nicht nur in Bezug auf irgendeine Programmeinheit (wie etwa eine Methodendefinition), sind sie von überall her zugreifbar. Außerdem wird jede neue Klasse in eine Art Systemwörterbuch namens „Smalltalk“ (repräsentiert von der globalen Variable Smalltalk) eingetragen, und ihr Name (als Symbol) in die Symboltabelle SymbolTable. Mittels einer solchen Klassendefinition ist man nun in der Lage, das SMALLTALK-System um neue, eigene Klassen zu erweitern.",Was sind globale Pseudovariablen?,"In SMALLTALK wird jede Klasse nach ihrer Erzeugung durch eine globale Pseudovariable repräsentiert, deren Name dem Namen der Klasse entspricht. Diese globale Pseudovariable ist notwendig, um auf die Klasse und ihre Methoden zugreifen zu können. Klassennamen sind global und von überall aus im Code zugreifbar."
,"Was ist ein Nachteil von Zwischenobjekten, wenn man an guten objektorientierten Stil denkt?",Mit Zwischenobjekten wird das Gesetz Demeters verletzt.
,"Warum ist es wichtig, verschiedene objektorientierte Programmiersprachen zu kennen?","Es ist wichtig, verschiedene objektorientierte Programmiersprachen zu kennen, da Praktikerinnen und solche, die es werden wollen, die Programmiersprachen kennen müssen, die auf dem Markt gefragt sind. Dies ermöglicht es ihnen, in verschiedenen beruflichen Situationen flexibel zu sein und die am besten geeignete Sprache für bestimmte Aufgaben auszuwählen."
