paragraph,question,answer
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und Java, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.",Gibt es in C++ Metaklassen?,"Nein, in C++ gibt es keine Metaklassen."
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und Java, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.",Unterstützt C++ Objektorientierung?,"Ja, C++ unterstützt Objektorientierung, indem es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und Java, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden."
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und Java, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.",Was sind die Hauptunterschiede zwischen C++ und Smalltalk in Bezug auf Objektorientierung?,"Die Hauptunterschiede zwischen C++ und Smalltalk in Bezug auf Objektorientierung sind, dass Smalltalk keine Strukturen (structs) kennt, alle Instanzvariablen in Smalltalk Referenzen sein können, Smalltalk Metaklassen anbietet und der Name einer Klasse in Smalltalk als Wert verwendet werden kann."
"Dass man in C++ wie in Java das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne Javas oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.",Was ist der Unterschied zwischen Objekten in SMALLTALK und Objekten in C++?,"In SMALLTALK haben Objekte Identität, während in C++ Objekte Werte sind, die keine Identität haben. Bei Zuweisungen an andere Variablen werden in SMALLTALK Referenzen angefertigt, während in C++ Kopien erstellt werden."
"Dass man in C++ wie in Java das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne Javas oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.",Was ist der Unterschied zwischen Referenz- und Wertsemantik?,"Bei der Referenzsemantik wird auf ein Objekt verwiesen, während bei der Wertsemantik eine Kopie des Objekts erstellt wird. In C++ und Java haben Variablen mit einer Klasse als Typ Wertsemantik, während in SMALLTALK Variablen mit Referenzsemantik arbeiten."
"Dass man in C++ wie in Java das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne Javas oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.",Was ist der Unterschied zwischen Objekten mit Wertsemantik und Objekten mit Referenzsemantik?,"Objekte mit Wertsemantik werden bei Zuweisungen an andere Variablen kopiert, während Objekte mit Referenzsemantik nur einen Verweis auf das Objekt kopieren. Objekte mit Wertsemantik haben keine Identität, während Objekte mit Referenzsemantik eine Identität haben."
"Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Sieht man einmal von der expliziten Festlegung ab, dass es sich bei der Variable a um eine Pointervariable handelt, dann gleicht der parameterlose Konstruktor einer äquivalenten Anweisung in Java oder C-Sharp. Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++ ""->"", z.B., ""a->x"" oder ""a->f(x)"" für ein Feld oder eine Methode der Klasse. Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.",Wie erzeugt man in C++ Objekte mit Identität?,"Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren."
"Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von Java und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.","Was ist der Unterschied zwischen ""Call by value"" und der Übertragung von Pointer-Variablen in C++?","Im ""Call by value"" in C++ wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Bei Pointer-Variablen wie dem obigen a wird jedoch nur der Zeiger auf das Objekt übergeben, was dem Verhalten von Java und SMALLTALK entspricht. In Java und SMALLTALK wird jedoch nirgends explizit angegeben, dass es sich um eine Pointer-variable handelt."
"Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von Java und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.",Was passiert bei Methodenaufrufen mit Pointer-Variablen in C++?,"Bei Methodenaufrufen mit Pointer-Variablen in C++ wird nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben. Dies entspricht dem Verhalten von Java und SMALLTALK, wobei bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-Variable handelt."
"Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von Java und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.","Was bedeutet ""Call by value"" in C++?","Bei ""Call by value"" in C++ wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen."
"Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von Java und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.","Was passiert bei ""Call by value"" in C++, wenn Pointer-Variablen übergeben werden?","Wenn Pointer-Variablen wie dem obigen a übergeben werden, wird nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben."
"Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von Java und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.",Wie verhält sich Java und SMALLTALK in Bezug auf die Übergabe von Parametern?,"In Java und SMALLTALK wird bei Methodenaufrufen immer der Zeiger auf das Objekt übergeben, und es wird nirgends explizit angegeben, dass es sich um eine Pointer-variable handelt."
"Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt. Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können. Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt).","Was ist der Unterschied zwischen ""Call by value"" und ""Call by reference""?","""Call by value"" bedeutet, dass eine Kopie des Inhalts der Variablen an die Funktion übergeben wird, während ""Call by reference"" bedeutet, dass an die Funktion ein Zeiger auf die Speicherstelle der Variablen übergeben wird. In C++ kann man ""Call by reference"" auch mit Zeigern auf Zeiger implementieren, oder aber wie in PASCAL, indem man die formalen Parameter so deklariert, dass sie Zeiger aufnehmen können und an der Aufrufstelle kein Zeigeroperator & verwendet wird."
"Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt. Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können. Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt).","Was ist der Unterschied zwischen ""Call by reference"" und der Übergabe von Zeigern in C++?","""Call by reference"" ist eine Technik, bei der anstelle einer Kopie des Inhalts der Variablen ein Zeiger auf die Speicherstelle der Variablen übergeben wird. In C++ kann dies durch die Verwendung des Zeigeroperators & an der Aufrufstelle erreicht werden, wobei die formalen Parameter so deklariert werden müssen, dass sie Zeiger auf Zeiger aufnehmen können. Alternativ kann in C++ wie in PASCAL verfahren werden, wobei die Aufrufstelle unverändert bleibt (also ohne & auskommt). Der Unterschied besteht darin, dass bei ""Call by reference"" die Aufrufstelle geändert werden muss, während bei der Übergabe von Zeigern in C++ die Aufrufstelle unverändert bleibt."
"Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt. Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können. Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt).","Was ist der Unterschied zwischen ""Call by reference"" und der Möglichkeit in C++ wie in PASCAL zu verfahren?","""Call by reference"" in C++ erfordert die Verwendung des Zeigeroperators & an der Aufrufstelle, um einen Zeiger auf die Speicherstelle der Variablen zu erzeugen und zu übergeben. Dagegen erfordert die Möglichkeit in C++ wie in PASCAL zu verfahren, dass keine Änderungen an der Aufrufstelle vorgenommen werden müssen, da die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können."
"Bei der Parametrisierung steht anstelle eines Typen in der Typdefinition eine Typvariable. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen. Wenn man nun den Typ verwenden möchte, also z. B. eine temporäre Variable von diesem Typ deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable in der Typdefinition haben sollen. Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen. Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.",Was ist eine Typvariable in der Typdefinition?,"In der Typdefinition ist eine Typvariable ein Platzhalter für einen tatsächlichen Typ, der bei der Instantiierung der Klasse eingesetzt wird. Traditionell werden einzelne Großbuchstaben für Typvariablen verwendet, um versehentliches Verdecken eines tatsächlichen Typs zu vermeiden."
"Bei der Parametrisierung steht anstelle eines Typen in der Typdefinition eine Typvariable. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen. Wenn man nun den Typ verwenden möchte, also z. B. eine temporäre Variable von diesem Typ deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable in der Typdefinition haben sollen. Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen. Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.",Was ist der Zweck von Typvariablen in der Typdefinition?,"Der Zweck von Typvariablen in der Typdefinition ist, dass sie anstelle des Parameters und des Rückgabetyps T nennen, wobei T eine Typvariable ist. Typvariablen werden verwendet, um keinen tatsächlichen Typen zu verdecken, wie es sonst versehentlich passieren könnte. Typvariablen können auch zu einer parametrischen Klassendefinition beliebig viele Typen haben."
"Bei der Parametrisierung steht anstelle eines Typen in der Typdefinition eine Typvariable. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen. Wenn man nun den Typ verwenden möchte, also z. B. eine temporäre Variable von diesem Typ deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable in der Typdefinition haben sollen. Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen. Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.",Was ist der Zweck der Typisierung in der Programmierung?,"Der Zweck der Typisierung in der Programmierung ist es, die möglichen Werte einer Variablen oder Funktion einzuschränken und so die Fehleranfälligkeit zu verringern. Durch die Angabe eines Typs wird sichergestellt, dass nur Werte dieses Typs an die Variable oder Funktion übergeben werden können, was die Korrektheit des Programms erhöht."
"Bei der Parametrisierung steht anstelle eines Typen in der Typdefinition eine Typvariable. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen. Wenn man nun den Typ verwenden möchte, also z. B. eine temporäre Variable von diesem Typ deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable in der Typdefinition haben sollen. Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen. Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.",Wie wird der Typ einer parametrischen Typdefinition konkretisiert?,Die Typdefinition wird durch Instanziierung der parametrischen Typdefinition mit einem konkreten Typen konkretisiert. Dieser Vorgang ergibt sich automatisch und muss nicht explizit hingeschrieben werden.
"Bei der Parametrisierung steht anstelle eines Typen in der Typdefinition eine Typvariable. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen. Wenn man nun den Typ verwenden möchte, also z. B. eine temporäre Variable von diesem Typ deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable in der Typdefinition haben sollen. Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen. Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.",Wann ergibt sich die Typdefinition einer parametrischen Typdefinition?,Die Typdefinition einer parametrischen Typdefinition ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen.
"Bei der Parametrisierung steht anstelle eines Typen in der Typdefinition eine Typvariable. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen. Wenn man nun den Typ verwenden möchte, also z. B. eine temporäre Variable von diesem Typ deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable in der Typdefinition haben sollen. Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen. Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.",Was ergibt sich aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen?,Die Typdefinition ergibt sich aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen.
"Bei der Parametrisierung steht anstelle eines Typen in der Typdefinition eine Typvariable. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen. Wenn man nun den Typ verwenden möchte, also z. B. eine temporäre Variable von diesem Typ deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable in der Typdefinition haben sollen. Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen. Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.",Was versteht man unter parametrisierter Typdefinition?,"Eine parametrisierte Typdefinition ist eine Möglichkeit, einen Typ in der Programmierung zu definieren, der einen oder mehrere Typparameter enthält. Diese Typparameter können bei der Instanziierung des Typs durch konkrete Typen ersetzt werden, um einen konkreten Typ zu erzeugen. Durch die Verwendung parametrisierter Typdefinitionen kann Code wiederverwendet werden, und die Typsicherheit wird erhalten."
"Bei der Parametrisierung steht anstelle eines Typen in der Typdefinition eine Typvariable. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen. Wenn man nun den Typ verwenden möchte, also z. B. eine temporäre Variable von diesem Typ deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable in der Typdefinition haben sollen. Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen. Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.",Wie oft kann eine parametrische Typdefinition in einem Programm verwendet werden?,Eine parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.
"Bei der Parametrisierung steht anstelle eines Typen in der Typdefinition eine Typvariable. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen. Wenn man nun den Typ verwenden möchte, also z. B. eine temporäre Variable von diesem Typ deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable in der Typdefinition haben sollen. Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen. Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.",Was ist die Bedeutung von Typparametern in einer parametrisierten Typdefinition?,"Typparameter in einer parametrisierten Typdefinition sind Platzhalter für konkrete Typen, die bei der Instanziierung des Typs eingesetzt werden können. Sie ermöglichen es, den gleichen Code für verschiedene Typen wiederzuverwenden und die Typsicherheit zu erhalten."
"Das obige Beispiel hat gezeigt, dass die einfache Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich ist. Da die Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den Typ implementierenden Klassen) keine Aussagen über den Typ treffen. Außerhalb, bei der Verwendung (Instanziierung) der Typdefinition, ist das hingegen möglich, da hier die Typvariable durch einen Typ ersetzt ist.",Was ist parametrischer Polymorphismus?,"Parametrischer Polymorphismus ist eine Technik in der objektorientierten Programmierung, bei der eine Typvariable innerhalb einer Typdefinition verwendet wird. Diese Typvariable kann später durch einen konkreten Typ ersetzt werden, wenn die Typdefinition instanziiert wird. Dadurch wird die Typsicherheit gewährleistet."
"Das obige Beispiel hat gezeigt, dass die einfache Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich ist. Da die Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den Typ implementierenden Klassen) keine Aussagen über den Typ treffen. Außerhalb, bei der Verwendung (Instanziierung) der Typdefinition, ist das hingegen möglich, da hier die Typvariable durch einen Typ ersetzt ist.",Was ist der Nachteil der einfachen Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung?,"Der Nachteil der einfachen Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung ist, dass die Typvariablen selbst nicht typisiert sind, und man daher innerhalb der Typdefinition keine Aussagen über den Typ treffen kann."
"Was man jedoch gerne hätte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist, und zwar derart, dass man bei den als Werte zulässigen Typen ein bestimmtes, benötigtes Protokoll voraussetzen kann. Die tatsächlichen Typparameter sind dann nicht mehr beliebig wählbar, sondern nur noch aus solchen Typen, die die Einschränkungen erfüllen. Eine Möglichkeit, dies zu erzielen, wäre die Einführung von Metatypen, deren Wertebereiche Typen mit von den Metatypen vorgegebenen Eigenschaften sind. Diese Möglichkeit wird jedoch in der Praxis nicht genutzt.",Was sind Metatypen?,"Metatypen sind eine Möglichkeit, um die Typvariable innerhalb der mit ihr parametrisierten Typdefinition wertbeschränkt zu machen. Dabei sind die Wertebereiche der Metatypen Typen mit von den Metatypen vorgegebenen Eigenschaften. Diese Möglichkeit wird jedoch in der Praxis nicht genutzt."
"Was man jedoch gerne hätte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist, und zwar derart, dass man bei den als Werte zulässigen Typen ein bestimmtes, benötigtes Protokoll voraussetzen kann. Die tatsächlichen Typparameter sind dann nicht mehr beliebig wählbar, sondern nur noch aus solchen Typen, die die Einschränkungen erfüllen. Eine Möglichkeit, dies zu erzielen, wäre die Einführung von Metatypen, deren Wertebereiche Typen mit von den Metatypen vorgegebenen Eigenschaften sind. Diese Möglichkeit wird jedoch in der Praxis nicht genutzt.",Warum werden Metatypen in der Praxis nicht genutzt?,"Metatypen werden in der Praxis nicht genutzt, da sie eine zusätzliche Komplexität in die Sprache einführen und die Sprache unnötig erschweren würden. Zudem gibt es andere Möglichkeiten, um Typbeschränkungen zu erreichen, wie zum Beispiel die Verwendung von generischen Typen oder die Verwendung von Interfaces."
"Stattdessen verwendet man eine Art der Beschränkung des Wertebereichs von Typvariablen, die auf Subtyping beruht. Wenn man nämlich erzwingen kann, dass ein tatsächlicher Typparameter (also der Wert der Typvariable) ein Subtyp eines bestimmten Typs ist, der die benötigten Eigenschaften (Methoden) umfasst, dann ist damit alles erreicht, was man benötigt. Aufgrund der Regeln des Subtyping hat jeder solche Typ die Eigenschaften des Supertyps (siehe Kapitel 26).",Was ist Subtyping?,"Subtyping ist eine Art der Beschränkung des Wertebereichs von Typvariablen, bei der ein tatsächlicher Typparameter (der Wert der Typvariable) ein Subtyp eines bestimmten Typs sein muss, der die benötigten Eigenschaften umfasst. Aufgrund der Regeln des Subtyping hat jeder solche Typ die Eigenschaften des Supertyps."
"Die Beschränkung ist keine Typisierung wie in normalen Variablendeklarationen. Sie drückt vielmehr aus, dass die Typen, die als Werte für E eingesetzt werden dürfen, Subtypen von Number sein müssen. Eine unzulässige Deklaration führt zu einem entsprechenden Typfehler während der statischen Typprüfung.",Was bedeutet die Beschränkung von Typvariablen?,"Die Beschränkung von Typvariablen drückt aus, dass die Typen, die als Werte für die Typvariable eingesetzt werden dürfen, Subtypen des angegebenen Typs sein müssen."
"Die Beschränkung ist keine Typisierung wie in normalen Variablendeklarationen. Sie drückt vielmehr aus, dass die Typen, die als Werte für E eingesetzt werden dürfen, Subtypen von Number sein müssen. Eine unzulässige Deklaration führt zu einem entsprechenden Typfehler während der statischen Typprüfung.","Was passiert, wenn eine unzulässige Deklaration von Typvariablen durchgeführt wird?","Wenn eine unzulässige Deklaration von Typvariablen durchgeführt wird, führt dies zu einem Typfehler während der statischen Typprüfung."
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen eines Programms, da diese erst zur Laufzeit des Programms ausgeführt werden. Wohlgemerkt: Literale repräsentieren Objekte, es sind nicht selbst welche.",Was ist ein Literal?,"Ein Literal ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten."
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen eines Programms, da diese erst zur Laufzeit des Programms ausgeführt werden. Wohlgemerkt: Literale repräsentieren Objekte, es sind nicht selbst welche.",Was unterscheidet Literale und objekterzeugende Anweisungen?,"Der Compiler erzeugt bei der Übersetzung eines Literals das entsprechende Objekt im Speicher, während objekterzeugende Anweisungen erst zur Laufzeit des Programms ausgeführt werden."
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen eines Programms, da diese erst zur Laufzeit des Programms ausgeführt werden. Wohlgemerkt: Literale repräsentieren Objekte, es sind nicht selbst welche.",Warum sind Literale keine Objekte?,"Literale repräsentieren Objekte, sind jedoch selbst keine Objekte, da sie textuelle Spezifikationen von Objekten sind."
"Die einfachsten Literale repräsentieren Zeichen (genauer: Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel Werte.Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.",Was sind die einfachsten Literale in SMALLTALK?,Die einfachsten Literale in SMALLTALK repräsentieren Zeichenobjekte.
"Die einfachsten Literale repräsentieren Zeichen (genauer: Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel Werte.Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.",Was sind atomare Objekte?,"Atomare Objekte sind Zeichenobjekte und Zahlobjekte, die nicht aus anderen Objekten bestehen."
"Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen. Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.",Was sind Pseudo-Variablen in SMALLTALK?,"In SMALLTALK sind die in anderen Programmiersprachen vorhandenen Literale, die ebenfalls atomare Objekte repräsentieren, Pseudo-Variablen."
"Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. String-Literale repräsentieren also zusammengesetzte Objekte.",Was sind Strings?,Strings sind aus Zeichen zusammengesetzte Zeichenketten. String-Literale repräsentieren also zusammengesetzte Objekte.
"Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall. Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.Gleichwohl versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.",Was sind Symbole in SMALLTALK?,"Symbole sind eine weitere Art von Objekten mit literaler Repräsentation in SMALLTALK. Sie dienen dazu, sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen."
"Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall. Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.Gleichwohl versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.",Was unterscheidet Symbole und Strings in SMALLTALK?,Symbole dürfen im Gegensatz zu Strings keine Leerzeichen enthalten. Zudem ist die Erzeugung eines Objekts anhand eines Symbolliterals technisch aufwendiger als die Erzeugung eines Objekts anhand eines String-Literals.
"Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall. Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.Gleichwohl versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.",Was kann bei der Verwendung von identischen Symbolliteralen passieren?,Bei der Verwendung identischer Symbolliterale kann es durch sogenanntes Aliasing zu unerwarteten Ergebnissen führen.
"Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer. Ein Beispiel für ein Array-Literal ist #(1 2 3). Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird.Für Array-Literale gilt ansonsten das Gleiche wie für String-Literale: Dass zwei syntaktisch gleich sind heißt nicht, dass sie dasselbe Objekt erzeugen (oder, richtiger, dass aus ihnen nur ein Objekt erzeugt wird).",Was sind Array-Literale in SMALLTALK ?,"Array-Literale repräsentieren Objekte, die aus einer Folge beliebiger anderer Objekte bestehen."
"Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht für eine besondere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung. Die Gegenrolle heißt Supertyp.",Was ist ein Subtyp?,"Ein Subtyp ist ein Typ, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp ist eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung, und die Gegenrolle heißt Supertyp."
"Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht für eine besondere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung. Die Gegenrolle heißt Supertyp.",Was ist eine Klasse?,"Eine Klasse ist ein Bauplan für Objekte, die beschreibt, welche Attribute und welches Verhalten ein Objekt hat."
"Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht für eine besondere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung. Die Gegenrolle heißt Supertyp.",Was ist ein Objekt?,Ein Objekt ist eine Instanz einer Klasse.
"Man beachte, dass diese Definition von Subtypen Zuweisungskompatibilität impliziert: Wenn die Objekte eines Subtypen überall auftauchen dürfen, wo Objekte seines Supertyps erwartet werden, dann dürfen sie auch Werte von jemandem zugreifen, der bei einer Zeichnung auf ihre Zeilen zugreifen will. Außerdem müsste bei der ersten Annahme des allgemeinsten Typs, von dem alle anderen abgeleitet sind (Object in STRONGTALK), immer alle Attribute deklariert werden, die einem jemals in den Sinn kämen, und das wäre nun wirklich unpraktisch. Die Problemquelle könnten Variablen sein, die mit dem Supertypen annotiert sind (auf Werte des Supertyps beschränkt). Ein Subtyp ist also per Definition mit seinem Supertyp zuweisungskompatibel. In dieser Definition steckt jedoch eine gewisse Zirkularität (Subtyp als Voraussetzung und Ergebnis der Zuweisungskompatibilität), die eine Einfachheit der Zusammenhänge vortäuscht, die es in Wirklichkeit nicht gibt. Die eigentliche Frage, was nämlich erfüllt sein muss, damit ein Objekt eines Typs tatsächlich dort erscheinen darf, wo ein Objekt eines anderen Typs erwartet wird, bleibt unberücksichtigt. Eine Befassung mit dieser Frage erfolgt hier jedoch nur insoweit, wie dies heutige Typsysteme tatsächlich tun; eine genauere Betrachtung erfolgt dann erst in Kurseinheit 6, Kapitel 54.",Was ist Zuweisungskompatibilität?,"Zuweisungskompatibilität bedeutet, dass Objekte eines Subtyps überall auftauchen dürfen, wo Objekte seines Supertyps erwartet werden. Ein Subtyp ist also per Definition mit seinem Supertyp zuweisungskompatibel."
"Man beachte, dass diese Definition von Subtypen Zuweisungskompatibilität impliziert: Wenn die Objekte eines Subtypen überall auftauchen dürfen, wo Objekte seines Supertyps erwartet werden, dann dürfen sie auch Werte von jemandem zugreifen, der bei einer Zeichnung auf ihre Zeilen zugreifen will. Außerdem müsste bei der ersten Annahme des allgemeinsten Typs, von dem alle anderen abgeleitet sind (Object in STRONGTALK), immer alle Attribute deklariert werden, die einem jemals in den Sinn kämen, und das wäre nun wirklich unpraktisch. Die Problemquelle könnten Variablen sein, die mit dem Supertypen annotiert sind (auf Werte des Supertyps beschränkt). Ein Subtyp ist also per Definition mit seinem Supertyp zuweisungskompatibel. In dieser Definition steckt jedoch eine gewisse Zirkularität (Subtyp als Voraussetzung und Ergebnis der Zuweisungskompatibilität), die eine Einfachheit der Zusammenhänge vortäuscht, die es in Wirklichkeit nicht gibt. Die eigentliche Frage, was nämlich erfüllt sein muss, damit ein Objekt eines Typs tatsächlich dort erscheinen darf, wo ein Objekt eines anderen Typs erwartet wird, bleibt unberücksichtigt. Eine Befassung mit dieser Frage erfolgt hier jedoch nur insoweit, wie dies heutige Typsysteme tatsächlich tun; eine genauere Betrachtung erfolgt dann erst in Kurseinheit 6, Kapitel 54.",Was impliziert die Definition von Subtypen in Bezug auf Zuweisungskompatibilität?,"Die Definition von Subtypen impliziert Zuweisungskompatibilität, das heißt, Objekte eines Subtyps dürfen überall auftauchen, wo Objekte seines Supertyps erwartet werden, und sie dürfen auch Werte von jemandem zugreifen, der bei einer Zeichnung auf ihre Zeilen zugreifen will."
"Spätestens mit der Verfügbarkeit sogenannter Hochsprachen und den gleichzeitig immer größer werdenden Programmen kam die Frage auf, was ""gute Programmierung"" ausmacht. Eines der Hauptprobleme schlechter Programmierung war schnell identifiziert: die große Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf. Eine gute Programmiererin hatte ihre Programme so zu schreiben, dass der Programmtext und der Programmablauf einander möglichst ähnlich waren, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zuließ. Man wollte also von den Programmiererinnen Klartext.","Was ist das Ziel von ""guter Programmierung""?","Das Ziel von ""guter Programmierung"" ist es, die Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf zu minimieren. Eine gute Programmiererin schreibt ihre Programme so, dass die statische Struktur des Programms möglichst viele Rückschlüsse auf seinen dynamischen Ablauf zulässt."
"Spätestens mit der Verfügbarkeit sogenannter Hochsprachen und den gleichzeitig immer größer werdenden Programmen kam die Frage auf, was ""gute Programmierung"" ausmacht. Eines der Hauptprobleme schlechter Programmierung war schnell identifiziert: die große Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf. Eine gute Programmiererin hatte ihre Programme so zu schreiben, dass der Programmtext und der Programmablauf einander möglichst ähnlich waren, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zuließ. Man wollte also von den Programmiererinnen Klartext.","Was bedeutet ""gute Programmierung""?","Laut dem Kurstext bedeutet ""gute Programmierung"", dass der Programmtext und der Programmablauf einander möglichst ähnlich sind, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zulässt."
"Spätestens mit der Verfügbarkeit sogenannter Hochsprachen und den gleichzeitig immer größer werdenden Programmen kam die Frage auf, was ""gute Programmierung"" ausmacht. Eines der Hauptprobleme schlechter Programmierung war schnell identifiziert: die große Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf. Eine gute Programmiererin hatte ihre Programme so zu schreiben, dass der Programmtext und der Programmablauf einander möglichst ähnlich waren, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zuließ. Man wollte also von den Programmiererinnen Klartext.",Was war das Hauptproblem schlechter Programmierung?,"Das Hauptproblem schlechter Programmierung war die große Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf."
"Ebenso schnell wie das Problem wurde sein Hauptverursacher ausgemacht: die Goto-Anweisung. Sie erlaubt Sprünge von beliebigen Stellen eines Programms an beliebige andere Stellen des Programms und durchbricht dabei auf brutale Art und Weise das äußerst nützliche Lokalitätsprinzip von Programmen: Dinge, die zusammengehören, stehen im Programmtext beieinander. So, und nur so, ist bei der Inspektion des Programmtextes unmittelbar klar, wie man an eine Stelle im Programm gelangt ist und, mindestens ebenso wichtig, wie eine Variable ihren Wert bekommen hat.",Was ist das Lokalitätsprinzip von Programmen?,"Das Lokalitätsprinzip von Programmen besagt, dass Dinge, die zusammengehören, auch im Programmtext beieinander stehen sollten. Dadurch wird die Lesbarkeit und Nachvollziehbarkeit des Programms verbessert."
"Zur Veranschaulichung soll die nachfolgende Abbildung dienen, die einen Programmtext als eine Folge von Anweisungen stilisiert. Anweisungen sind durch Kreise dargestellt, die (textuelle) Folge der Anweisungen im Programmtext durch die kleinen Pfeile. Ohne besondere, den Kontrollfluss beeinflussende Anweisungen entspricht die (dynamische) Reihenfolge der Ausführung der (statischen) Folge der Anweisungen im Programmtext. Bei Betrachtung des stärker umrandeten, mittleren Kreises (der entsprechenden Anweisung), z. B. während einer Debug-Sitzung, ist daher aus dem unmittelbaren Kontext heraus (der Ellipse; Lokalitätsprinzip!) klar, welche Anweisung davor ausgeführt wurde und welche als nächstes drankommt. Alles ist in bester Ordnung.Handelt es sich nun bei einer der Anweisungen um ein Goto, dann ist die Sachlage längst nicht mehr so klar. Man hat vielmehr die folgenden Fälle zu unterscheiden: Die betrachtete Anweisung ist selbst ein Goto: In diesem Fall ist zwar klar, woher der Programmfluss kommt, und auch, wohin er geht, letzteres aber nur mit einer gewissen Einschränkung — das Ziel ist nicht der Nachbar im Programmtext, sondern befindet sich außerhalb des gewählten Kontextes. Nun kann man den Kontext natürlich so wählen, dass er das Ziel enthält, und kurze Sprünge sind vielleicht auch so innerhalb des betrachteten Kontextes möglich; allgemein gilt jedoch, dass jede gewählte Lokalität durch einen Sprung verletzt werden kann. Immerhin lässt sich aber das Ziel des Sprungs aus dem Kontext erkennen und der Kontext entsprechend wechseln. Die betrachtete Anweisung ist Ziel eines Gotos: Hier ist die Sachlage schon schwieriger. Der Programmfluss scheint bei Betrachtung des Kontextes genau wie im ersten Beispiel zu verlaufen. Wenn man den Kontext allerdings vergrößert, lernt man, dass die dynamischen Vorgänger in der betrachteten Anweisung auch andere sein können. Der Kontext selbst gibt jedoch keinen Hinweis darauf; zwar kann das Vorhandensein eines Sprunglabels einen Hinweis darauf geben, dass die so markierte Anweisung Ziel eines Gotos sein kann, sie muss es aber nicht; in Sprachen wie BASIC beispielsweise (damals noch weit verbreitet), in denen Zeilennummern gültige Sprungziele sind, muss jede Anweisung als mit einem Label versehen betrachtet werden und kann somit Sprungziel von irgendwoher sein. Außerdem kann eine Anweisung von verschiedenen Gotos angesprungen werden, so dass unklar bleibt, welches die (zeitliche) Vorgängeranweisung war. Die betrachtete Anweisung ist unmittelbare Nachfolgerin eines Gotos: Hier ist zwar aus dem Kontext ersichtlich, dass die statischen Vorgänger nicht die dynamischen sein können, ansonsten kann man aber nur mutmaßen, dass es sich vielleicht um toten Code handeln könnte (also um Code, der niemals ausgeführt wird). Es kann nämlich die Anweisung Sprungziel von Gotos außerhalb des Kontexts sein (wie in allen anderen Fällen auch).",Was ist die Auswirkung von Goto-Anweisungen auf den Programmfluss?,"Goto-Anweisungen können den Programmfluss beeinflussen, indem sie den Kontext verlassen und zu einer anderen Stelle im Programm springen. Das Ziel des Sprungs ist nicht immer eindeutig aus dem Kontext erkennbar, und es kann unklar sein, welche Anweisungen vorher ausgeführt wurden."
"Fazit: Die Verwendung von Goto-Anweisungen verursacht ein hohes Maß an Nichtwissen bei der Interpretation von Quelltext. Speziell beim Debugging von Programmen ist der Blick in den Quelltext des Programms so nur sehr bedingt von Nutzen. Von daher, so der allgemeine Konsens, ist die Benutzung von Gotos zu vermeiden.",Warum wird die Verwendung von Goto-Anweisungen im Programmieren nicht empfohlen?,"Die Verwendung von Goto-Anweisungen verursacht ein hohes Maß an Nichtwissen bei der Interpretation von Quelltext, insbesondere beim Debugging von Programmen ist der Blick in den Quelltext des Programms nur bedingt von Nutzen."
"Wenn man also kein Goto benutzen darf, wie steuert man dann den Ablauf von Programmen? Die sogenannte strukturierte Programmierung sieht dafür neben der Sequenz von Anweisungen (ausgedrückt durch die unmittelbare Nachbarschaft im Programmtext) die Verzweigung, die Wiederholung und den Unterprogrammaufruf vor. Von diesen behalten die ersten beiden das Lokalitätsprinzip bei, solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife, die damit ausgedrückt wird, ausdehnt. Für den Unterprogrammaufruf gilt das jedoch nicht mehr: Schon weil ein Unterprogramm in der Regel von mehreren Stellen eines Programms aus aufgerufen werden kann und weil diese Stellen nicht automatisch denselben Kontext haben, wird hier das Lokalitätsprinzip durchbrochen. Dies ist aber unvermeidlich, und man tröstet sich damit, dass ein Unterprogramm, genauer eine Prozedur oder eine Funktion, immer genau an die Stelle zurückkehrt, von der es aufgerufen wurde.",Was ist strukturierte Programmierung?,"Die strukturierte Programmierung ist eine Programmiermethode, die neben der Sequenz von Anweisungen, die Verzweigung, die Wiederholung und den Unterprogrammaufruf vorsieht. Sie behält das Lokalitätsprinzip bei, solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife ausdehnt."
"Wenn man also kein Goto benutzen darf, wie steuert man dann den Ablauf von Programmen? Die sogenannte strukturierte Programmierung sieht dafür neben der Sequenz von Anweisungen (ausgedrückt durch die unmittelbare Nachbarschaft im Programmtext) die Verzweigung, die Wiederholung und den Unterprogrammaufruf vor. Von diesen behalten die ersten beiden das Lokalitätsprinzip bei, solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife, die damit ausgedrückt wird, ausdehnt. Für den Unterprogrammaufruf gilt das jedoch nicht mehr: Schon weil ein Unterprogramm in der Regel von mehreren Stellen eines Programms aus aufgerufen werden kann und weil diese Stellen nicht automatisch denselben Kontext haben, wird hier das Lokalitätsprinzip durchbrochen. Dies ist aber unvermeidlich, und man tröstet sich damit, dass ein Unterprogramm, genauer eine Prozedur oder eine Funktion, immer genau an die Stelle zurückkehrt, von der es aufgerufen wurde.",Was ist das Lokalitätsprinzip in der Programmierung?,"Das Lokalitätsprinzip in der Programmierung besagt, dass die Bedeutung eines Elements in einem Programm durch seinen unmittelbaren Kontext bestimmt wird. Dieses Prinzip wird bei der strukturierten Programmierung durch die Sequenz von Anweisungen, Verzweigungen und Wiederholungen eingehalten, aber durchbrochen, wenn ein Unterprogramm aufgerufen wird, da es von mehreren Stellen eines Programms aus aufgerufen werden kann und diese Stellen nicht automatisch denselben Kontext haben."
"Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger um die Return-Anweisung des aufgerufenen Unterprogramms handeln muss. Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterprogramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächliche Parameter übergeben wurden, und wenn zudem das Unterprogramm bekannte Vor- und Nachbedingungen enthält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein großer Nutzen gegenüber: Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anweisungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche Aufrufkontexte gibt (das sog. Inlining, das manche Compiler aus Optimierungsgründen durchführen). Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie getrennt untersuchen und verstehen kann.",Was ist der Unterschied zwischen dem dynamischen Vorgänger einer Anweisung und dem Unterprogrammaufruf?,"Der dynamische Vorgänger einer Anweisung ist die Anweisung, die unmittelbar davor ausgeführt wurde. Beim Unterprogrammaufruf hingegen wird der Kontrollfluss an eine andere Stelle im Programm übergeben, was zu einer gewissen Unwissenheit führt. Allerdings ist diese Unwissenheit im Vergleich zum Goto geringer und bietet den Vorteil, dass Code dupliziert werden kann und die Programmierung in Abschnitte unterteilt werden kann, die getrennt untersucht und verstanden werden können."
"Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger um die Return-Anweisung des aufgerufenen Unterprogramms handeln muss. Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterprogramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächliche Parameter übergeben wurden, und wenn zudem das Unterprogramm bekannte Vor- und Nachbedingungen enthält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein großer Nutzen gegenüber: Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anweisungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche Aufrufkontexte gibt (das sog. Inlining, das manche Compiler aus Optimierungsgründen durchführen). Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie getrennt untersuchen und verstehen kann.",Was ist der Unterschied zwischen dem dynamischen Vorgänger einer Anweisung und dem Goto?,"Der dynamische Vorgänger einer Anweisung ist die Anweisung, die unmittelbar davor im Programmablauf ausgeführt wurde. Beim Goto wird die Programmlogik durch Sprunganweisungen unterbrochen, was zu einer unübersichtlichen Programmstruktur führen kann. Im Gegensatz dazu bietet der dynamische Vorgänger eine klare und strukturierte Abfolge der Anweisungen."
"Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger um die Return-Anweisung des aufgerufenen Unterprogramms handeln muss. Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterprogramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächliche Parameter übergeben wurden, und wenn zudem das Unterprogramm bekannte Vor- und Nachbedingungen enthält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein großer Nutzen gegenüber: Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anweisungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche Aufrufkontexte gibt (das sog. Inlining, das manche Compiler aus Optimierungsgründen durchführen). Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie getrennt untersuchen und verstehen kann.","Was ist der Unterschied zwischen der Unwissenheit, die durch einen Unterprogrammaufruf und durch eine Goto-Anweisung verursacht wird?","Die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, ist im Vergleich zu der beim Goto gering."
"Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger um die Return-Anweisung des aufgerufenen Unterprogramms handeln muss. Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterprogramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächliche Parameter übergeben wurden, und wenn zudem das Unterprogramm bekannte Vor- und Nachbedingungen enthält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein großer Nutzen gegenüber: Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anweisungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche Aufrufkontexte gibt (das sog. Inlining, das manche Compiler aus Optimierungsgründen durchführen). Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie getrennt untersuchen und verstehen kann.",Welche Vorteile bietet ein Unterprogrammaufruf gegenüber der Duplizierung von Code?,"Durch den Unterprogrammaufruf wird die Duplizierung von Code vermieden, was die Notwendigkeit beseitigt, die Anweisungen des Unterprogramms im Aufrufkontext zu halten, wenn es mehrere solche Aufrufkontexte gibt. Dies erleichtert die Unterteilung von Programmen in Abschnitte, die getrennt untersucht und verstanden werden können."
"Besonders der zweite Punkt ist wichtig: Aus Sicht der Programmiererin sollte es nämlich reichen, zu wissen, was ein Unterprogramm tut, um es korrekt benutzen zu können. Sie muss also insbesondere nicht in das Unterprogramm hineinschauen, also seine Anweisungen inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird — es reicht dann, zu wissen, mit welchen Parametern es versorgt wird, und die sind ihr per formale Parameterdeklaration bekannt. (Voraussetzung dieser Argumentation ist jedoch, dass es keine globalen Variablen gibt, die eine gegenseitige Beeinflussung von Aufrufstelle und Unterprogramm an den tatsächlichen und formalen Parametern vorbei erlauben. Diese globalen Variablen sind jedoch mindestens so sehr verpönt wie das Goto.)",Was ist der Vorteil von lokalen Variablen in Unterprogrammen?,"Der Vorteil von lokalen Variablen in Unterprogrammen ist, dass die Programmiererin das Unterprogramm korrekt benutzen kann, ohne in das Unterprogramm hineinschauen zu müssen. Sie muss also nicht die Anweisungen des Unterprogramms inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt."
"Besonders der zweite Punkt ist wichtig: Aus Sicht der Programmiererin sollte es nämlich reichen, zu wissen, was ein Unterprogramm tut, um es korrekt benutzen zu können. Sie muss also insbesondere nicht in das Unterprogramm hineinschauen, also seine Anweisungen inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird — es reicht dann, zu wissen, mit welchen Parametern es versorgt wird, und die sind ihr per formale Parameterdeklaration bekannt. (Voraussetzung dieser Argumentation ist jedoch, dass es keine globalen Variablen gibt, die eine gegenseitige Beeinflussung von Aufrufstelle und Unterprogramm an den tatsächlichen und formalen Parametern vorbei erlauben. Diese globalen Variablen sind jedoch mindestens so sehr verpönt wie das Goto.)",Was ist der Vorteil von Unterprogrammen?,"Der Vorteil von Unterprogrammen ist, dass die Programmiererin nicht in das Unterprogramm hineinschauen muss, um es korrekt benutzen zu können. Sie muss also nicht die Anweisungen des Unterprogramms inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird."
"Besonders der zweite Punkt ist wichtig: Aus Sicht der Programmiererin sollte es nämlich reichen, zu wissen, was ein Unterprogramm tut, um es korrekt benutzen zu können. Sie muss also insbesondere nicht in das Unterprogramm hineinschauen, also seine Anweisungen inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird — es reicht dann, zu wissen, mit welchen Parametern es versorgt wird, und die sind ihr per formale Parameterdeklaration bekannt. (Voraussetzung dieser Argumentation ist jedoch, dass es keine globalen Variablen gibt, die eine gegenseitige Beeinflussung von Aufrufstelle und Unterprogramm an den tatsächlichen und formalen Parametern vorbei erlauben. Diese globalen Variablen sind jedoch mindestens so sehr verpönt wie das Goto.)","Warum ist es wichtig, dass die Programmiererin nicht in das Unterprogramm hineinschauen muss, um es korrekt benutzen zu können?","Es ist wichtig, dass die Programmiererin nicht in das Unterprogramm hineinschauen muss, um es korrekt benutzen zu können, weil sie sich so auf den Kontext der Aufrufstelle konzentrieren kann und nicht abgelenkt wird durch die Implementierungsdetails des Unterprogramms. Dies erleichtert die Lesbarkeit und Wartbarkeit des Codes."
"Bei der objektorientierten Programmierung hat man es zunächst mit einer leicht veränderten Situation zu tun. Hier sind nämlich nicht allein das Vermeiden von doppeltem Code sowie die stufenweise Verfeinerung Kriterien für die Aufteilung in Unterprogramme, sondern auch die Disziplin, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert. Typische objektorientierte Programme teilen daher die Implementierung größerer Funktionen nicht nur in kleinere auf, sondern verteilen diese auch noch über viele Klassen. Auch wenn es sich dabei stets nur um Unterprogrammaufrufe handelt, die allen obengenannten Anforderungen genügen, so erfolgen die zum Programmverstehen notwendigen Kontextwechsel doch in so kurzer Folge, dass man schnell den Überblick darüber verliert.",Was sind die Kriterien für die Aufteilung in Unterprogramme bei der objektorientierten Programmierung?,"Bei der objektorientierten Programmierung sind die Kriterien für die Aufteilung in Unterprogramme das Vermeiden von doppeltem Code, die stufenweise Verfeinerung, das Zuordnen jeder Teilfunktion der Klasse, deren Daten sie manipuliert, und die Disziplin, die Implementierung größerer Funktionen zu verteilen."
"Bei der objektorientierten Programmierung hat man es zunächst mit einer leicht veränderten Situation zu tun. Hier sind nämlich nicht allein das Vermeiden von doppeltem Code sowie die stufenweise Verfeinerung Kriterien für die Aufteilung in Unterprogramme, sondern auch die Disziplin, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert. Typische objektorientierte Programme teilen daher die Implementierung größerer Funktionen nicht nur in kleinere auf, sondern verteilen diese auch noch über viele Klassen. Auch wenn es sich dabei stets nur um Unterprogrammaufrufe handelt, die allen obengenannten Anforderungen genügen, so erfolgen die zum Programmverstehen notwendigen Kontextwechsel doch in so kurzer Folge, dass man schnell den Überblick darüber verliert.","Warum ist es wichtig, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert?","Es ist wichtig, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert, um das Vermeiden von doppeltem Code sowie die stufenweise Verfeinerung zu gewährleisten und die Implementierung größerer Funktionen in kleinere Unterprogramme aufzuteilen. Diese Disziplin hilft, den Überblick über das Programm zu behalten, auch wenn die Unterprogrammaufrufe in so kurzer Folge erfolgen, dass man schnell den Kontextwechsel verlieren kann."
"Nun ergibt sich aber mit der Einführung von dynamisch gebundenen Unterprogrammaufrufen, wie sie ja für die objektorientierte Programmierung prägend sind, das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht: Wie bereits in Kurseinheit 1, Abschnitt 4.3.2 bemerkt, verbindet das dynamische Binden den Unterprogrammaufruf mit der Verzweigung.",Was ist das Problem mit dynamisch gebundenen Unterprogrammaufrufen in der objektorientierten Programmierung?,"Das Problem mit dynamisch gebundenen Unterprogrammaufrufen in der objektorientierten Programmierung ist, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht. Das dynamische Binden verbindet den Unterprogrammaufruf mit der Verzweigung."
"Nun ergibt sich aber mit der Einführung von dynamisch gebundenen Unterprogrammaufrufen, wie sie ja für die objektorientierte Programmierung prägend sind, das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht: Wie bereits in Kurseinheit 1, Abschnitt 4.3.2 bemerkt, verbindet das dynamische Binden den Unterprogrammaufruf mit der Verzweigung.",Was ist dynamisches Binden und wie verbindet es Unterprogrammaufruf mit Verzweigung?,"Dynamisches Binden ist eine Technik in der objektorientierten Programmierung, bei der der Unterprogrammaufruf mit der Verzweigung verbunden wird, indem die Entscheidung darüber, welches Unterprogramm aufgerufen werden soll, zur Laufzeit getroffen wird, anstatt zur Übersetzungszeit. Das bedeutet, dass der Compiler nicht im Voraus entscheiden kann, welches Unterprogramm aufgerufen wird, sondern dass diese Entscheidung zur Laufzeit getroffen wird, wenn der Unterprogrammaufruf tatsächlich ausgeführt wird. Dies ermöglicht es, dass der Zielcode des Unterprogrammaufrufs zur Laufzeit bestimmt wird, was eine flexiblere und dynamischere Programmstruktur ermöglicht."
"Es ist an der Stelle der betrachteten Anweisung nicht klar, von woher der in der Anweisung zuvor angestoßene Unterprogrammaufruf zurückkehrt — es könnte von jeder Implementierung der im Gosub genannten Methode sein. Um das Sprungziel und damit die Return-Anweisung, die unmittelbarer Vorgänger war, zu identifizieren, muss man die Klasse des Empfängerobjekts kennen, also die Klasse des Werts der Variable, auf der die Methode aufgerufen wurde. Das ist aber in der Regel nur auf Basis einer vollständigen Programmanalyse bestimmbar, die sich nicht lokal durchführen lässt. Das Lokalitätsprinzip wird also durch das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein.",Was ist das Lokalitätsprinzip und wie wird es durch dynamisches Binden aufgeweicht?,"Das Lokalitätsprinzip besagt, dass die Bedeutung eines Namens durch die unmittelbare Umgebung bestimmt wird, in der er deklariert ist. Durch dynamisches Binden wird das Lokalitätsprinzip aufgeweicht, da die Bedeutung eines Namens, der auf eine Methode verweist, nicht nur durch die unmittelbare Umgebung bestimmt wird, sondern auch durch die Klasse des Empfängerobjekts, auf dem die Methode aufgerufen wurde. Diese Information ist in der Regel nicht lokal bestimmbar und erfordert eine vollständige Programmanalyse."
"Es ist an der Stelle der betrachteten Anweisung nicht klar, von woher der in der Anweisung zuvor angestoßene Unterprogrammaufruf zurückkehrt — es könnte von jeder Implementierung der im Gosub genannten Methode sein. Um das Sprungziel und damit die Return-Anweisung, die unmittelbarer Vorgänger war, zu identifizieren, muss man die Klasse des Empfängerobjekts kennen, also die Klasse des Werts der Variable, auf der die Methode aufgerufen wurde. Das ist aber in der Regel nur auf Basis einer vollständigen Programmanalyse bestimmbar, die sich nicht lokal durchführen lässt. Das Lokalitätsprinzip wird also durch das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein.","Was passiert, wenn man die Klasse des Empfängerobjekts nicht kennt?","Wenn man die Klasse des Empfängerobjekts nicht kennt, ist es nicht möglich, an der Stelle der betrachteten Anweisung zu bestimmen, von woher der in der Anweisung zuvor angestoßene Unterprogrammaufruf zurückkehrt. Das Lokalitätsprinzip wird also durch das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein."
"Dieser Umstand hat dazu geführt, dass das dynamische Binden von Skeptikerinnen und Gegnerinnen der objektorientierten Programmierung schon als eine Art Goto der 90er Jahre betrachtet wurde. Dieser Vergleich ist jedoch nicht ganz fair, weil, genau wie beim statisch gebundenen Unterprogrammaufruf, die Aufruferin ja gar nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen — es reicht zu wissen, welchen Vertrag die aufgerufene Methode (das aufgerufene Unterprogramm) erfüllt. Dies sollte nach den Regeln des Subtyping (Abschnitt 54.2) stets unabhängig vom vertragserfüllenden Objekt sein.",Warum wird dynamisches Binden in der objektorientierten Programmierung kritisiert?,"Kritikerinnen der objektorientierten Programmierung haben das dynamische Binden als eine Art Goto der 90er Jahre betrachtet. Dieser Vergleich ist jedoch nicht ganz fair, weil die Aufruferin nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen. Es reicht zu wissen, welchen Vertrag die aufgerufene Methode erfüllt."
"Dieser Umstand hat dazu geführt, dass das dynamische Binden von Skeptikerinnen und Gegnerinnen der objektorientierten Programmierung schon als eine Art Goto der 90er Jahre betrachtet wurde. Dieser Vergleich ist jedoch nicht ganz fair, weil, genau wie beim statisch gebundenen Unterprogrammaufruf, die Aufruferin ja gar nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen — es reicht zu wissen, welchen Vertrag die aufgerufene Methode (das aufgerufene Unterprogramm) erfüllt. Dies sollte nach den Regeln des Subtyping (Abschnitt 54.2) stets unabhängig vom vertragserfüllenden Objekt sein.",Warum ist der Vergleich des dynamischen Bindens mit Goto der 90er Jahre nicht ganz fair?,"Der Vergleich ist nicht ganz fair, weil im Gegensatz zum Goto die Aufruferin nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen, sondern es reicht zu wissen, welchen Vertrag die aufgerufene Methode erfüllt. Diese Unabhängigkeit vom vertragserfüllenden Objekt ist ein wichtiger Unterschied zum Goto."
"Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.","Warum kann es bei der Betrachtung der Aufrufstelle interessant sein, was in der aufgerufenen Methode passiert ist?","Es kann interessant sein, weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann und mehr Informationen über die Abläufe in der aufgerufenen Methode benötigt."
"Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.","Warum ist es in der Praxis nicht immer möglich, den aufgerufenen Code anzuschauen?","In der Praxis ist es nicht immer möglich, den aufgerufenen Code anzuschauen, weil man nicht weiß, an welcher Stelle man schauen muss. Man muss das Programm erneut ausführen, vor dem dynamisch gebundenen Aufruf stoppen und sich den Variableninhalt ansehen oder den Programmablauf Schritt für Schritt verfolgen."
"Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.","Was ist das Problem, wenn man sich den aufgerufenen Code anschauen will?","Das Problem ist, dass man gar nicht weiß, an welcher Stelle man schauen muss."
"Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.","Wie kann man sich den Variableninhalt ansehen, wenn man nicht weiß, an welcher Stelle man schauen muss?","In der Praxis bleibt nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen."
"Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.","Warum ist es wichtig, den aufgerufenen Code anzuschauen, wenn man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann?","Es ist wichtig, den aufgerufenen Code anzuschauen, um zu verstehen, was in der aufgerufenen Methode passiert ist und wie sich dies auf die Variablenbelegung ausgewirkt hat. Dies kann hilfreich sein, um Fehler zu debuggen und das Verhalten des Programms zu verstehen."
"Es ist wohl unbestritten, dass objektorientierte Programme schwerer zu tracen und zu debuggen sind als prozedurale. Wie schon bei den statisch gebundenen Unterprogrammaufrufen (die ja ebenfalls ein Problem darstellen können) ist die Frage jedoch, ob das, was man durch das dynamische Binden hinzugewinnt, den Preis aufwiegt. Während diese Frage jede für sich selbst entscheiden muss, so scheint die Antwort für viele Programmiererinnen — weit mehr als eine Generation nach dem Aufkommen der Objektorientierung und damit vor dem Hintergrund genügend praktischer Erfahrung — überwiegend positiv zu sein. Man darf aber auch die Neinsagerinnen nicht als Ewiggestrige abstempeln — sie mögen gute Gründe haben.",Sind objektorientierte Programme schwerer zu tracen und zu debuggen als prozedurale?,"Es ist wohl unbestritten, dass objektorientierte Programme schwerer zu tracen und zu debuggen sind als prozedurale. Jedoch scheint die Antwort für viele Programmiererinnen positiv zu sein, dass der Gewinn durch das dynamische Binden den Preis aufwiegt."
"Es ist wohl unbestritten, dass objektorientierte Programme schwerer zu tracen und zu debuggen sind als prozedurale. Wie schon bei den statisch gebundenen Unterprogrammaufrufen (die ja ebenfalls ein Problem darstellen können) ist die Frage jedoch, ob das, was man durch das dynamische Binden hinzugewinnt, den Preis aufwiegt. Während diese Frage jede für sich selbst entscheiden muss, so scheint die Antwort für viele Programmiererinnen — weit mehr als eine Generation nach dem Aufkommen der Objektorientierung und damit vor dem Hintergrund genügend praktischer Erfahrung — überwiegend positiv zu sein. Man darf aber auch die Neinsagerinnen nicht als Ewiggestrige abstempeln — sie mögen gute Gründe haben.",Warum werden objektorientierte Programme als schwerer zu tracen und zu debuggen angesehen als prozedurale?,"Objektorientierte Programme werden als schwerer zu tracen und zu debuggen angesehen als prozedurale, weil sie dynamisch gebundene Unterprogrammaufrufe verwenden, was die Nachverfolgung von Programmabläufen erschweren kann."
"Genau wie in Java entspricht in C-Sharp zunächst jeder Klasse und jedem Interface ein Typ. Mit der Version 2.0 ist C-Sharp jedoch ebenfalls generisch geworden. Genauer gesagt erlaubt C-Sharp sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus, wobei die Syntax für unbeschränkte sich nicht von der von Java unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C-Sharp erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).",Unterstützt C-Sharp generische Programmierung?,"Ja, C-Sharp unterstützt ab Version 2.0 generische Programmierung sowohl bei Klassen als auch bei Methoden. Es erlaubt sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus. C-Sharp erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz)."
"Genau wie in Java entspricht in C-Sharp zunächst jeder Klasse und jedem Interface ein Typ. Mit der Version 2.0 ist C-Sharp jedoch ebenfalls generisch geworden. Genauer gesagt erlaubt C-Sharp sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus, wobei die Syntax für unbeschränkte sich nicht von der von Java unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C-Sharp erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).",Unterstützt C-Sharp generischen Polymorphismus?,"Ja, C-Sharp unterstützt sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht anders aus als die von Java, während die Syntax für unbeschränkte sich nicht unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C-Sharp erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz)."
"Genau wie in Java entspricht in C-Sharp zunächst jeder Klasse und jedem Interface ein Typ. Mit der Version 2.0 ist C-Sharp jedoch ebenfalls generisch geworden. Genauer gesagt erlaubt C-Sharp sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus, wobei die Syntax für unbeschränkte sich nicht von der von Java unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C-Sharp erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).",Was ist der Unterschied zwischen beschränktem und unbeschränktem parametrischen Polymorphismus in C-Sharp?,"Beschränkter parametrischer Polymorphismus in C-Sharp erlaubt die Einschränkung der zulässigen Typen für die Typvariablen, während unbeschränkter parametrischer Polymorphismus keine Einschränkungen vorsieht. Die Syntax für beschränkte Typparameter in C-Sharp sieht anders aus als die für unbeschränkte, die Syntax für unbeschränkte Typparameter ist in C-Sharp identisch mit der von Java."
"Auch wenn sich die Generics von C-Sharp auf den ersten Blick nicht groß von denen von Java zu unterscheiden scheinen, verbirgt sich hinter der Oberfläche doch ein anderer Mechanismus. Während Java die Typparameter grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type erasure), instanziiert C-Sharp im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Dies hat den Vorteil, dass diese Implementierungen ohne Boxing/Unboxing auskommen und vom JIT-Compiler durch Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird der Code jedoch (wie in Java) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.",Wie werden Generics in C-Sharp und Java behandelt?,"In Java werden die Typparameter grundsätzlich immer wegkompiliert, um Abwärtskompatibilität zu erreichen. Im Gegensatz dazu instanziiert C-Sharp im Fall von Werttyp-Parametern jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen. Für Referenztypen wird der Code jedoch nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten und kann per Reflection abgefragt werden."
"Auch wenn sich die Generics von C-Sharp auf den ersten Blick nicht groß von denen von Java zu unterscheiden scheinen, verbirgt sich hinter der Oberfläche doch ein anderer Mechanismus. Während Java die Typparameter grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type erasure), instanziiert C-Sharp im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Dies hat den Vorteil, dass diese Implementierungen ohne Boxing/Unboxing auskommen und vom JIT-Compiler durch Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird der Code jedoch (wie in Java) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.",Wie werden Typen in C-Sharp und Java behandelt?,"In Java werden die Typparameter grundsätzlich immer wegkompiliert, um Abwärtskompatibilität zu erreichen (Type erasure). Im Gegensatz dazu instanziiert C-Sharp im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Für Referenztypen wird der Code jedoch (wie in Java) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten und kann per Reflection abgefragt werden."
"Auch wenn sich die Generics von C-Sharp auf den ersten Blick nicht groß von denen von Java zu unterscheiden scheinen, verbirgt sich hinter der Oberfläche doch ein anderer Mechanismus. Während Java die Typparameter grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type erasure), instanziiert C-Sharp im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Dies hat den Vorteil, dass diese Implementierungen ohne Boxing/Unboxing auskommen und vom JIT-Compiler durch Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird der Code jedoch (wie in Java) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.",Was ist der Unterschied zwischen Generics in C-Sharp und Java?,"Der Hauptunterschied besteht darin, dass Java die Typparameter grundsätzlich immer wegkompiliert, während C-Sharp im Fall von Werttyp-Parametern jede generische Klasse für jeden verwendeten Typ einmal instanziiert und alternative Implementierungen erzeugt, was zu optimierten Implementierungen führt. Für Referenztypen verhält sich C-Sharp jedoch wie Java. Zudem bleibt die generische Typinformation in C-Sharp zur Laufzeit erhalten und kann per Reflection abgefragt werden."
"Genau wie in Java gibt es in C-Sharp beim Subtyping von Containern (wie z. B. Collections) ein Varianzproblem: Collection<A> und Collection<B> sind auch dann nicht zuweisungskompatibel, wenn A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch Zuweisungskompatibilität herzustellen, sieht C-Sharp keine spezielle Annotation der Benutzung eines Typs wie in Java vor, sondern eine Annotation der Definition des Typs: Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen. Übrigens: Für Arrays in C-Sharp gilt dasselbe wie in Java: Sie sind kovariant, das Schreiben in ein Array kann jedoch zu einem Laufzeittypfehler führen, der in C-Sharp ""Array Type-Mismatch Exception"" heißt.",Wie wird in C-Sharp Zuweisungskompatibilität bei Containern hergestellt?,"In C-Sharp wird Zuweisungskompatibilität bei Containern hergestellt, indem dem kovarianten bzw. kontravarianten Typparameter das Schlüsselwort out bzw. in vorangestellt wird. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen."
"Genau wie in Java gibt es in C-Sharp beim Subtyping von Containern (wie z. B. Collections) ein Varianzproblem: Collection<A> und Collection<B> sind auch dann nicht zuweisungskompatibel, wenn A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch Zuweisungskompatibilität herzustellen, sieht C-Sharp keine spezielle Annotation der Benutzung eines Typs wie in Java vor, sondern eine Annotation der Definition des Typs: Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen. Übrigens: Für Arrays in C-Sharp gilt dasselbe wie in Java: Sie sind kovariant, das Schreiben in ein Array kann jedoch zu einem Laufzeittypfehler führen, der in C-Sharp ""Array Type-Mismatch Exception"" heißt.",Wie wird in C-Sharp das Varianzproblem bei der Zuweisung von Containern gelöst?,In C-Sharp wird das Varianzproblem bei der Zuweisung von Containern durch eine Annotation der Definition des Typs gelöst. Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen.
"Genau wie in Java gibt es in C-Sharp beim Subtyping von Containern (wie z. B. Collections) ein Varianzproblem: Collection<A> und Collection<B> sind auch dann nicht zuweisungskompatibel, wenn A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch Zuweisungskompatibilität herzustellen, sieht C-Sharp keine spezielle Annotation der Benutzung eines Typs wie in Java vor, sondern eine Annotation der Definition des Typs: Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen. Übrigens: Für Arrays in C-Sharp gilt dasselbe wie in Java: Sie sind kovariant, das Schreiben in ein Array kann jedoch zu einem Laufzeittypfehler führen, der in C-Sharp ""Array Type-Mismatch Exception"" heißt.",Was ist der Unterschied zwischen der Annotation der Benutzung eines Typs in Java und der Annotation der Definition des Typs in C-Sharp?,"In Java wird ein Typparameter durch eine Annotation der Benutzung eines Typs als kovariant, kontravariant oder invariant markiert, während in C-Sharp die Annotation der Definition des Typs erfolgt. Das bedeutet, dass in Java die Varianz eines Typs bei seiner Verwendung festgelegt wird, während in C-Sharp die Varianz eines Typs bei seiner Definition festgelegt wird. In C-Sharp wird dem kovarianten oder kontravarianten Typparameter das Schlüsselwort out oder in vorangestellt, um die Beschränkungen (nur lesen oder nur schreiben) bei allen Verwendungen des Typs festzulegen."
"Methoden oder Operationen, die auf unveränderlichen Objekten ausgeführt werden, können deren Zustand naturgemäß nicht ändern. Beispielsweise ändert die Addition von Zahlen nichts an ihren Operanden, sondern liefert als Ergebnis ein anderes Objekt. Derartige Methoden (oder Operationen) sind also klassische Funktionen: Sie berechnen ein Ergebnis anhand eines oder mehrerer Argumente (wovon eines das Empfängerobjekt ist) ohne Nebenwirkungen wie Zustandsänderungen der Argumente.Für andere Objekte wie zum Beispiel die Punktobjekte ist jedoch fraglich, ob Operationen wie die Addition den Zustand des Empfängers verändern sollten oder ein neues Objekt zurückgeben sollten. Wenn eine Veränderung des Empfängers eher einer Translation entspricht, sollte die entsprechende Methode entsprechend benannt werden. Um jedoch zu zeigen, wie man neue Objekte erzeugen und zurückgeben kann, fehlt uns hier noch einiges.",Was sind unveränderliche Objekte?,"Unveränderliche oder zustandslose Objekte in SMALLTALK sind Objekte, deren Zustand nicht geändert werden kann. Operationen oder Methoden, die auf solchen Objekten ausgeführt werden, ändern nicht den Zustand des Objekts selbst, sondern erzeugen in der Regel ein neues Objekt als Ergebnis."
"In Beziehungen mit Zu-n-Verbindungen müssen häufig mehrere Elemente der gleichen Behandlung unterzogen werden oder es müssen Elemente aus der Menge gesucht werden. Wenn jedoch Collections verwendet werden, die nicht indiziert sind (Java bietet auch Collections wie Bäume oder verkettete Listen), ist die oben gezeigte Form der Iteration nicht anwendbar. Stattdessen gibt es in Java die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer), die eine einheitliche Iteration über Collections mittels sogenannter Iteratoren erlauben. Jede Collection-Klasse, die Iterator implementiert, bietet dazu eine Methode iterator() an, die ein solches Iteratorobjekt (vom Typ Iterator) zurückliefert.",Was sind Iteratoren in Java?,"Iteratoren in Java sind Objekte, die eine einheitliche Iteration über verschiedene Collection-Klassen ermöglichen. Jede Collection-Klasse, die Iterator implementiert, bietet eine Methode iterator() an, die ein Iteratorobjekt zurückliefert."
"In Beziehungen mit Zu-n-Verbindungen müssen häufig mehrere Elemente der gleichen Behandlung unterzogen werden oder es müssen Elemente aus der Menge gesucht werden. Wenn jedoch Collections verwendet werden, die nicht indiziert sind (Java bietet auch Collections wie Bäume oder verkettete Listen), ist die oben gezeigte Form der Iteration nicht anwendbar. Stattdessen gibt es in Java die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer), die eine einheitliche Iteration über Collections mittels sogenannter Iteratoren erlauben. Jede Collection-Klasse, die Iterator implementiert, bietet dazu eine Methode iterator() an, die ein solches Iteratorobjekt (vom Typ Iterator) zurückliefert.",Wozu dienen Iteratoren in Java?,"Iteratoren in Java dienen dazu, eine einheitliche Iteration über verschiedene Arten von Collections zu ermöglichen, unabhängig davon, ob sie indiziert sind oder nicht. Sie bieten eine standardisierte Möglichkeit, durch die Elemente einer Collection zu iterieren, ohne sich um die interne Implementierung der Collection kümmern zu müssen."
"In Beziehungen mit Zu-n-Verbindungen müssen häufig mehrere Elemente der gleichen Behandlung unterzogen werden oder es müssen Elemente aus der Menge gesucht werden. Wenn jedoch Collections verwendet werden, die nicht indiziert sind (Java bietet auch Collections wie Bäume oder verkettete Listen), ist die oben gezeigte Form der Iteration nicht anwendbar. Stattdessen gibt es in Java die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer), die eine einheitliche Iteration über Collections mittels sogenannter Iteratoren erlauben. Jede Collection-Klasse, die Iterator implementiert, bietet dazu eine Methode iterator() an, die ein solches Iteratorobjekt (vom Typ Iterator) zurückliefert.",Wie erhält man einen Iterator für eine Collection in Java?,"In Java kann man einen Iterator für eine Collection erhalten, indem man die Methode iterator() auf der Collection aufruft. Diese Methode gibt ein Iterator-Objekt zurück, das für die Iteration über die Elemente der Collection verwendet werden kann."
"Mit der Methode next() erhält man von diesem Iterator-Objekt zunächst das erste und anschließend alle weiteren Objekte der Collection. Mit der Methode hasNext() fragt man ab, ob die Collection noch weitere Objekte enthält.",Was tut die Methode next() in einem Iterator-Objekt?,Die Methode next() in einem Iterator-Objekt gibt das erste und anschließend alle weiteren Objekte der Collection zurück.
"Mit der Methode next() erhält man von diesem Iterator-Objekt zunächst das erste und anschließend alle weiteren Objekte der Collection. Mit der Methode hasNext() fragt man ab, ob die Collection noch weitere Objekte enthält.",Was macht die Methode hasNext() in einem Iterator-Objekt?,"Die Methode hasNext() in einem Iterator-Objekt fragt ab, ob die Collection noch weitere Objekte enthält."
"Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Kapiteln dieser Kurseinheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht. Sie ist fast immer willkürlich. Im Folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt werden, das ich persönlich eher nicht als Stilfrage einstufen würde, das aber dennoch häufiger in diesem Zusammenhang genannt wird.",Was ist ein Entwurfsprinzip in der Programmierung?,"Ein Entwurfsprinzip in der Programmierung ist ein Grundsatz, der bei der Gestaltung von Software berücksichtigt wird. Im Gegensatz zu einem Programmierstil ist ein Entwurfsprinzip eher allgemein und weniger willkürlich. Es kann die Gestaltung von Software in Hinsicht auf Funktionalität, Wartbarkeit, Lesbarkeit und Effizienz beeinflussen."
"Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Kapiteln dieser Kurseinheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht. Sie ist fast immer willkürlich. Im Folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt werden, das ich persönlich eher nicht als Stilfrage einstufen würde, das aber dennoch häufiger in diesem Zusammenhang genannt wird.",Was ist ein Entwurfsprinzip und wie unterscheidet es sich von einem Programmierstil?,"Ein Entwurfsprinzip ist ein allgemeiner Grundsatz oder Richtlinie, die bei der Gestaltung von Softwarearchitektur und Design befolgt wird. Im Gegensatz dazu ist ein Programmierstil eine bestimmte Art und Weise, wie Code geschrieben wird, die von der persönlichen Vorliebe des Programmierers abhängt. Ein Entwurfsprinzip ist also ein allgemeinerer Begriff als Programmierstil und bezieht sich auf die Architektur und das Design von Software, während Programmierstil sich auf die Art und Weise bezieht, wie Code geschrieben wird."
"Wie bereits in Kurseinheit 6 und teilweise auch schon in Kurseinheit 2, Abschnitt 10.1 bemerkt, ist die Vererbung Aushängeschild und Problemkind der objektorientierten Programmierung zugleich. Es verwundert daher nicht, dass sich eine ganze Menge von Programmierrichtlinien mit genau diesem Thema beschäftigen. Die meines Erachtens gewichtigste aller Regeln zu diesem Thema ist jedoch: Mache alle Superklassen abstrakt.",Was ist die wichtigste Programmierrichtlinie zur Vererbung?,Die wichtigste Programmierrichtlinie zur Vererbung ist: Mache alle Superklassen abstrakt.
"Für Java lässt sich diese Regel auch als „deklariere jede Klasse entweder als abstrakt oder als final“ formulieren. Der Grund dafür, dass nur die Blätter der Klassenhierarchie instanziierbar sein sollen, ist einfach: Wenn man mit der Funktionalität einer Klasse bzw. genauer und in diesem Fall wichtig, der Funktionalität der Instanzen einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern. Als Programmiererin möchte man diese Änderung unabhängig von der Frage, ob davon auch andere Klassen betroffen sind, durchführen können. Deswegen wird man die Änderungen auch nur an der Klasse selbst und nicht etwa an einer ihrer Superklassen durchführen. Betrifft der Änderungswunsch eine geerbte Methode, so überschreibt man diese in der betreffenden Klasse nach seinen Vorstellungen. Nur wenn eine eingehende Analyse der Superklasse und all ihrer Subklassen ergibt, dass die gewünschte Änderung für alle sinnvoll ist und den Erwartungen der Klienten entspricht, kann man darüber nachdenken, die Änderung in der Superklasse durchzuführen.",Warum sollten nur die Blätter der Klassenhierarchie instanziierbar sein?,"Die Blätter der Klassenhierarchie sollten instanziierbar sein, weil man die Implementierung einer Klasse ändern will, ohne die Implementierung der Superklasse ändern zu müssen. Wenn man mit der Funktionalität einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern, ohne die Implementierung der Superklasse ändern zu müssen."
"Wenn nun aber die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, dann ist man der Freiheit beraubt, nur für sich zu entscheiden. Von jeder Änderung, die man durchführt, muss man fürchten, dass sie sich auf andere Klassen ausbreitet und den Vertrag dieser Klassen mit ihren Klienten bricht (Siehe auch das Fragile-base-class-Problem in Kapitel 55). Etwas subtiler, aber genau dasselbe Problem, ereilt die Designerin von Klassenbibliotheken, wenn sie beschließt, das Verhalten einer Klasse zu ändern. Selbst wenn sie sich sicher ist, dass dies innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, so kann sie doch nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.",Was ist das Fragile-base-class-Problem?,"Das Fragile-base-class-Problem ist ein Problem, bei dem eine Änderung an der Basisklasse sich auf andere Klassen ausbreiten und den Vertrag dieser Klassen mit ihren Klienten brechen kann. Das Problem tritt auf, wenn die Klasse, deren Verhalten man ändern möchte, Subklassen hat oder wenn die Designerin von Klassenbibliotheken beschließt, das Verhalten einer Klasse zu ändern."
"Wenn nun aber die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, dann ist man der Freiheit beraubt, nur für sich zu entscheiden. Von jeder Änderung, die man durchführt, muss man fürchten, dass sie sich auf andere Klassen ausbreitet und den Vertrag dieser Klassen mit ihren Klienten bricht (Siehe auch das Fragile-base-class-Problem in Kapitel 55). Etwas subtiler, aber genau dasselbe Problem, ereilt die Designerin von Klassenbibliotheken, wenn sie beschließt, das Verhalten einer Klasse zu ändern. Selbst wenn sie sich sicher ist, dass dies innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, so kann sie doch nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.",Warum kann eine Änderung am Verhalten einer Klasse Auswirkungen auf andere Klassen haben?,"Eine Änderung am Verhalten einer Klasse kann Auswirkungen auf andere Klassen haben, weil wenn die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, jede Änderung sich auf diese Subklassen ausbreiten und den Vertrag dieser Klassen mit ihren Klienten brechen kann. Auch wenn die Designerin sicher ist, dass die Änderung innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, kann sie nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann."
"Nun ist aber, wie gerade erst (Kapitel 66) erwähnt, einer der wichtigsten Gedanken der Objektorientierung, existierenden Code, vor allem Bibliotheksklassen, per Vererbung wiederzuverwenden. Wenn die Bibliotheksdesignerin aber alle relevanten Klassen (das sind üblicherweise gerade die konkreten, also die instanziierbaren) final deklariert hat, dann ist das nicht möglich. Eine einfache Konvention erlaubt jedoch, diese Beschränkung zu umgehen: In der Bibliothek wird einfach die Klasse, von der geerbt werden soll, als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die zunächst keine Änderungen (Differenzia) hinzufügt, dafür aber konkret (also instanziierbar) und auch final ist. Sollte die Bibliotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Bibliothek mit den Änderungen beglücken möchte, die Änderungen in der abstrakten Superklasse durchführen. Machen alle Superklassen abstrakt.","Wie kann man die Beschränkung umgehen, wenn die Bibliotheksdesignerin alle relevanten Klassen final deklariert hat?","Eine Möglichkeit, diese Beschränkung zu umgehen, ist die Konvention, die Klasse, von der geerbt werden soll, als abstrakt zu deklarieren und eine Subklasse davon abzuleiten, die zunächst keine Änderungen hinzufügt, dafür aber konkret und final ist. Sollte die Bibliotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Bibliothek mit den Änderungen beglücken möchte, die Änderungen in der abstrakten Superklasse durchführen."
"Nun hat die Subklasse die Möglichkeit, neue Member hinzuzufügen und bereits vorhandene zu redefinieren. In Java ist die Redefinition auf das Überschreiben beschränkt, was bedeutet, dass eine Methode mit derselben Signatur (bestehend aus Methodennamen und formalen Parametertypen) erneut definiert werden kann, jedoch mit einer geänderten Implementierung. Die Methode kann auch den Rückgabetyp kovariant ändern, d.h., in Richtung Subtyp (vgl. dazu die Diskussion in Kurseinheit 3, Abschnitt 26.3). Die Einhaltung der Typinvarianten, die mit ihren (geerbten) Parametern verbunden sind, über die hinaus die überschreibende Methode nichts tut, was mit der überschriebenen Methode inkompatibel ist, kann durch die Sprachdefinition von Java nicht erzwungen werden. In diesem Punkt liegt die Verantwortung beim Programmierer (vgl. dazu auch Abschnitt 52.6 in Kurseinheit 5 und 54.1 in Kurseinheit 6).","Was bedeutet es, eine Methode in Java zu redefinieren?","In Java kann eine Subklasse eine Methode mit derselben Signatur (bestehend aus Methodennamen und formalen Parametertypen) wie eine Methode der Superklasse neu definieren, jedoch mit einer geänderten Implementierung. Die Methode kann auch den Rückgabetyp kovariant ändern, d.h., in Richtung Subtyp. Die Einhaltung der Typinvarianten, die mit ihren (geerbten) Parametern verbunden sind, über die hinaus die überschreibende Methode nichts tut, was mit der überschriebenen Methode inkompatibel ist, kann durch die Sprachdefinition von Java nicht erzwungen werden. In diesem Punkt liegt die Verantwortung beim Programmierer."
"Nun hat die Subklasse die Möglichkeit, neue Member hinzuzufügen und bereits vorhandene zu redefinieren. In Java ist die Redefinition auf das Überschreiben beschränkt, was bedeutet, dass eine Methode mit derselben Signatur (bestehend aus Methodennamen und formalen Parametertypen) erneut definiert werden kann, jedoch mit einer geänderten Implementierung. Die Methode kann auch den Rückgabetyp kovariant ändern, d.h., in Richtung Subtyp (vgl. dazu die Diskussion in Kurseinheit 3, Abschnitt 26.3). Die Einhaltung der Typinvarianten, die mit ihren (geerbten) Parametern verbunden sind, über die hinaus die überschreibende Methode nichts tut, was mit der überschriebenen Methode inkompatibel ist, kann durch die Sprachdefinition von Java nicht erzwungen werden. In diesem Punkt liegt die Verantwortung beim Programmierer (vgl. dazu auch Abschnitt 52.6 in Kurseinheit 5 und 54.1 in Kurseinheit 6).","Was bedeutet es, wenn eine Methode in Java kovariant geändert wird?","Wenn eine Methode in Java kovariant geändert wird, bedeutet das, dass sie den Rückgabetyp in Richtung Subtyp ändern kann. Das heißt, der Rückgabetyp der überschriebenen Methode kann eine Unterklasse des Rückgabetyp der ursprünglichen Methode sein."
"In Java können auch Methoden mit demselben Namen, aber verschiedenen Parametertypen in derselben Klasse oder einer Subklasse vorhanden sein. Diese Methoden nennt man dann überladen. Es ist wichtig zu verstehen, dass in Java Überladen und Überschreiben zwei grundverschiedene Dinge sind, obwohl in beiden Fällen eine Methode mit dem gleichen Namen erneut definiert wird: Beim Überladen wird eine neue Methode eingeführt, beim Überschreiben wird eine bereits existierende Methode neu definiert. Diese Unterscheidung spielt beim dynamischen Binden eine entscheidende Rolle.",Was ist der Unterschied zwischen Überladen und Überschreiben in Java?,"Beim Überladen wird eine neue Methode mit demselben Namen, aber verschiedenen Parametertypen eingeführt, während beim Überschreiben eine bereits existierende Methode neu definiert wird. Diese Unterscheidung ist wichtig für das dynamische Binden."
"Um das dynamische Binden in Java genau zu verstehen (und damit das Verhalten eines Programms vorherzusagen), muss man sich den Bindealgorithmus vor Augen halten. Dieser funktioniert wie folgt: 1. Die Methode wird aufgerufen. 2. Der Compiler prüft, ob die Methode in der Klasse, in der sie aufgerufen wurde, definiert ist. Wenn ja, wird die Methode dort ausgeführt. 3. Wenn die Methode nicht in der Klasse definiert ist, wird der Compiler die Superklasse überprüfen. Dies wird so lange wiederholt, bis die Methode gefunden wurde oder die Klassenhierarchie durchsucht ist. 4. Wenn die Methode nicht in der Klassenhierarchie gefunden wurde, wird eine Methode mit dem gleichen Namen in einer Schnittstelle gesucht, die von der Klasse implementiert wird. 5. Wenn die Methode immer noch nicht gefunden wurde, wird eine Fehlermeldung ausgegeben.",Wie funktioniert der Bindealgorithmus in Java?,"Der Bindealgorithmus in Java funktioniert, indem er zunächst die Methode in der Klasse sucht, in der sie aufgerufen wurde. Wenn sie nicht gefunden wird, wird die Superklasse überprüft, bis die Methode gefunden wird oder die Klassenhierarchie durchsucht ist. Wenn die Methode nicht in der Klassenhierarchie gefunden wurde, wird eine Methode mit dem gleichen Namen in einer Schnittstelle gesucht, die von der Klasse implementiert wird. Wenn die Methode immer noch nicht gefunden wurde, wird eine Fehlermeldung ausgegeben."
"Um das dynamische Binden in Java genau zu verstehen (und damit das Verhalten eines Programms vorherzusagen), muss man sich den Bindealgorithmus vor Augen halten. Dieser funktioniert wie folgt: 1. Die Methode wird aufgerufen. 2. Der Compiler prüft, ob die Methode in der Klasse, in der sie aufgerufen wurde, definiert ist. Wenn ja, wird die Methode dort ausgeführt. 3. Wenn die Methode nicht in der Klasse definiert ist, wird der Compiler die Superklasse überprüfen. Dies wird so lange wiederholt, bis die Methode gefunden wurde oder die Klassenhierarchie durchsucht ist. 4. Wenn die Methode nicht in der Klassenhierarchie gefunden wurde, wird eine Methode mit dem gleichen Namen in einer Schnittstelle gesucht, die von der Klasse implementiert wird. 5. Wenn die Methode immer noch nicht gefunden wurde, wird eine Fehlermeldung ausgegeben.",Wie funktioniert das dynamische Binden in Java?,"Das dynamische Binden in Java funktioniert durch einen Bindealgorithmus, der im Klassenbereich der Klasse des Objekts beginnt und sich durch die Klassenhierarchie nach oben arbeitet, bis eine passende Methode gefunden wird oder die Suche bei Object endet."
"Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode. Sie ist in der Klasse, die dem deklarierten Typ des Ausdrucks entspricht, der das Empfängerobjekt liefert (oftmals einfach eine Variable), deklariert oder wird von einer ihrer Superklassen geerbt. Die deklarierten Parametertypen des Aufrufs (die deklarierten tatsächlichen Parametertypen) sind jeweils Subtypen der deklarierten Parametertypen der Methodendeklaration (der deklarierten formalen Parametertypen). Es gibt keine andere Methode, die dieselben Voraussetzungen erfüllt, deren deklarierte formale Parametertypen jedoch näher oder gleich weit vom Typ des Aufrufs entfernt sind (Entfernung gemessen an der Anzahl der Subtypen, die dazwischen liegen).",Wie wird ein dynamischer Methodenaufruf zur Übersetzungszeit gebunden?,"Ein dynamischer Methodenaufruf wird zur Übersetzungszeit lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die den Namen und die Anzahl der Parameter der aufgerufenen Methode teilt, in der Klasse deklariert ist, die dem deklarierten Typ des Empfängerobjekts entspricht, und deren deklarierte Parametertypen Subtypen der deklarierten Parametertypen des Aufrufs sind. Wenn es mehrere solche Methoden gibt, wird diejenige gewählt, deren deklarierte formale Parametertypen am nächsten oder gleich weit vom Typ des Aufrufs entfernt sind."
"Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode. Sie ist in der Klasse, die dem deklarierten Typ des Ausdrucks entspricht, der das Empfängerobjekt liefert (oftmals einfach eine Variable), deklariert oder wird von einer ihrer Superklassen geerbt. Die deklarierten Parametertypen des Aufrufs (die deklarierten tatsächlichen Parametertypen) sind jeweils Subtypen der deklarierten Parametertypen der Methodendeklaration (der deklarierten formalen Parametertypen). Es gibt keine andere Methode, die dieselben Voraussetzungen erfüllt, deren deklarierte formale Parametertypen jedoch näher oder gleich weit vom Typ des Aufrufs entfernt sind (Entfernung gemessen an der Anzahl der Subtypen, die dazwischen liegen).",Wann wird eine dynamische Methode an eine Methodendeklaration gebunden?,"Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die den Namen und die Anzahl der Parameter der aufgerufenen Methode teilt, in der Klasse deklariert ist, die dem deklarierten Typ des Empfängerobjekts entspricht oder von einer ihrer Superklassen geerbt wird, und deren deklarierte Parametertypen Subtypen der deklarierten Parametertypen der Methodendeklaration sind."
"Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode. Sie ist in der Klasse, die dem deklarierten Typ des Ausdrucks entspricht, der das Empfängerobjekt liefert (oftmals einfach eine Variable), deklariert oder wird von einer ihrer Superklassen geerbt. Die deklarierten Parametertypen des Aufrufs (die deklarierten tatsächlichen Parametertypen) sind jeweils Subtypen der deklarierten Parametertypen der Methodendeklaration (der deklarierten formalen Parametertypen). Es gibt keine andere Methode, die dieselben Voraussetzungen erfüllt, deren deklarierte formale Parametertypen jedoch näher oder gleich weit vom Typ des Aufrufs entfernt sind (Entfernung gemessen an der Anzahl der Subtypen, die dazwischen liegen).",Wie wird ein dynamischer Methodenaufruf in der objektorientierten Programmierung gebunden?,"Ein dynamischer Methodenaufruf wird in der objektorientierten Programmierung an eine Methodendeklaration gebunden, die den gleichen Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode hat, in der Klasse deklariert ist, die dem deklarierten Typ des Empfängerobjekts entspricht, und deren deklarierte Parametertypen Subtypen der deklarierten Parametertypen des Aufrufs sind. Wenn keine solche Methode gefunden wird, wird die Suche nach einer Methode mit den gleichen Eigenschaften in den Superklassen wiederholt."
"Dadurch wird die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden ausgewählt, die für die Bindung infrage kommt. Beachten Sie, dass die überschreibenden Methoden dieselbe Signatur haben müssen wie die überschriebene Methode; diese Methoden bilden eine Art Familie, aus der eine Methode zur Bindung ausgewählt wird.",Was ist die Funktion der obersten Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden?,"Die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden wird ausgewählt, um für die Bindung infrage zu kommen. Diese Methode muss dieselbe Signatur haben wie die überschreibenden Methoden, die eine Art Familie bilden."
"Dadurch wird die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden ausgewählt, die für die Bindung infrage kommt. Beachten Sie, dass die überschreibenden Methoden dieselbe Signatur haben müssen wie die überschriebene Methode; diese Methoden bilden eine Art Familie, aus der eine Methode zur Bindung ausgewählt wird.",Was ist die Funktion der obersten Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden?,"Die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden wird ausgewählt, um für die Bindung infrage zu kommen. Diese Methode wird ausgewählt, wenn die überschreibenden Methoden dieselbe Signatur haben wie die überschriebene Methode."
"Dadurch wird die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden ausgewählt, die für die Bindung infrage kommt. Beachten Sie, dass die überschreibenden Methoden dieselbe Signatur haben müssen wie die überschriebene Methode; diese Methoden bilden eine Art Familie, aus der eine Methode zur Bindung ausgewählt wird.",Was ist die Bedeutung der Signatur in der objektorientierten Programmierung?,"In der objektorientierten Programmierung ist die Signatur eine Möglichkeit, Methoden zu identifizieren und zu unterscheiden. Die Signatur einer Methode besteht aus ihrem Namen und der Anzahl, Art und Reihenfolge ihrer Parameter. Methoden mit derselben Signatur bilden eine Familie, aus der eine Methode zur Bindung ausgewählt wird, wenn eine Nachricht gesendet wird."
"Dadurch wird die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden ausgewählt, die für die Bindung infrage kommt. Beachten Sie, dass die überschreibenden Methoden dieselbe Signatur haben müssen wie die überschriebene Methode; diese Methoden bilden eine Art Familie, aus der eine Methode zur Bindung ausgewählt wird.",Was ist die Bindung in der objektorientierten Programmierung?,"In der objektorientierten Programmierung ist die Bindung der Prozess, bei dem eine Methode ausgewählt wird, die auf eine Nachricht reagieren soll. Die Bindung erfolgt dynamisch zur Laufzeit, wenn eine Nachricht gesendet wird. Die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden wird ausgewählt, die für die Bindung infrage kommt."
"Zur Laufzeit wird dann nur noch der tatsächliche Typ des Empfängerobjekts (die Klasse, von der es eine Instanz ist) bestimmt. Dieser muss aufgrund der Regeln der Zuweisungskompatibilität ein Subtyp des deklarierten Typs des Ausdrucks sein, der das Empfängerobjekt liefert. Mit diesem tatsächlichen (auch dynamisch genannten) Typ wird dann aus der zuvor bestimmten Gruppe von in Frage kommenden überschriebenen Methoden diejenige ausgewählt, die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Superklassenkette am nächsten ist.",Was ist der Unterschied zwischen dem deklarierten Typ und dem tatsächlichen Typ eines Objekts?,"Der deklarierte Typ eines Objekts ist der Typ, der bei der Deklaration des Objekts angegeben wird, während der tatsächliche Typ (auch dynamischer Typ genannt) erst zur Laufzeit bestimmt wird. Der tatsächliche Typ muss ein Subtyp des deklarierten Typs sein."
"Zur Laufzeit wird dann nur noch der tatsächliche Typ des Empfängerobjekts (die Klasse, von der es eine Instanz ist) bestimmt. Dieser muss aufgrund der Regeln der Zuweisungskompatibilität ein Subtyp des deklarierten Typs des Ausdrucks sein, der das Empfängerobjekt liefert. Mit diesem tatsächlichen (auch dynamisch genannten) Typ wird dann aus der zuvor bestimmten Gruppe von in Frage kommenden überschriebenen Methoden diejenige ausgewählt, die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Superklassenkette am nächsten ist.",Wie wird die tatsächliche Methode bei der Laufzeit bestimmt?,"Zur Laufzeit wird der tatsächliche Typ des Empfängerobjekts bestimmt. Mit diesem tatsächlichen (auch dynamisch genannten) Typ wird dann aus der Gruppe der in Frage kommenden überschriebenen Methoden diejenige ausgewählt, die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Superklassenkette am nächsten ist."
"Zur Laufzeit wird dann nur noch der tatsächliche Typ des Empfängerobjekts (die Klasse, von der es eine Instanz ist) bestimmt. Dieser muss aufgrund der Regeln der Zuweisungskompatibilität ein Subtyp des deklarierten Typs des Ausdrucks sein, der das Empfängerobjekt liefert. Mit diesem tatsächlichen (auch dynamisch genannten) Typ wird dann aus der zuvor bestimmten Gruppe von in Frage kommenden überschriebenen Methoden diejenige ausgewählt, die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Superklassenkette am nächsten ist.",Was ist der Unterschied zwischen dem deklarierten Typ und dem tatsächlichen Typ eines Objekts?,"Der deklarierte Typ eines Objekts ist der Typ, der bei der Deklaration der Variablen angegeben wird, während der tatsächliche Typ eines Objekts der Typ ist, der zur Laufzeit bestimmt wird und der Klasse angehört, von der das Objekt eine Instanz ist. Die Zuweisungskompatibilität stellt sicher, dass der tatsächliche Typ des Objekts ein Subtyp des deklarierten Typs ist."
"Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind, meldet der Compiler einen sogenannten Methodenambiguitätsfehler. Dieser bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist. Beachten Sie, dass dieser Fehler durch Methodenaufrufe, nicht durch Methodendeklarationen verursacht wird. Wenn Sie den problematischen Aufruf entfernen, tritt auch kein Fehler mehr auf.",Was ist ein Methodenambiguitätsfehler?,"Ein Methodenambiguitätsfehler tritt auf, wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind. Dies bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist."
"Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind, meldet der Compiler einen sogenannten Methodenambiguitätsfehler. Dieser bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist. Beachten Sie, dass dieser Fehler durch Methodenaufrufe, nicht durch Methodendeklarationen verursacht wird. Wenn Sie den problematischen Aufruf entfernen, tritt auch kein Fehler mehr auf.",Was verursacht einen Methodenambiguitätsfehler?,"Ein Methodenambiguitätsfehler wird verursacht, wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind und der Compiler dadurch nicht eindeutig bestimmen kann, welche Methode aufgerufen werden soll."
"Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind, meldet der Compiler einen sogenannten Methodenambiguitätsfehler. Dieser bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist. Beachten Sie, dass dieser Fehler durch Methodenaufrufe, nicht durch Methodendeklarationen verursacht wird. Wenn Sie den problematischen Aufruf entfernen, tritt auch kein Fehler mehr auf.",Wann tritt ein Methodenambiguitätsfehler nicht mehr auf?,"Ein Methodenambiguitätsfehler tritt nicht mehr auf, wenn der problematische Aufruf entfernt wird."
"Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind, meldet der Compiler einen sogenannten Methodenambiguitätsfehler. Dieser bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist. Beachten Sie, dass dieser Fehler durch Methodenaufrufe, nicht durch Methodendeklarationen verursacht wird. Wenn Sie den problematischen Aufruf entfernen, tritt auch kein Fehler mehr auf.",Wer meldet einen Methodenambiguitätsfehler?,Der Compiler meldet einen Methodenambiguitätsfehler.
"Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind, meldet der Compiler einen sogenannten Methodenambiguitätsfehler. Dieser bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist. Beachten Sie, dass dieser Fehler durch Methodenaufrufe, nicht durch Methodendeklarationen verursacht wird. Wenn Sie den problematischen Aufruf entfernen, tritt auch kein Fehler mehr auf.",Was bedeutet ein Methodenambiguitätsfehler?,"Ein Methodenambiguitätsfehler bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist."
"Typerweiterung ist nicht die einzige Möglichkeit, auf der Basis eines bereits bestehenden einen neuen, verwandten Typen zu erzeugen; Typeinschränkung ist eine andere. Eine erste, offensichtliche Form der Typeinschränkung liegt dann vor, wenn ein Typ auf Basis eines anderen unter Entfernen von Eigenschaften (Methoden) definiert wird (das Beispiel vom Pinguin als einem Vogel, der nicht fliegen kann, kennen Sie ja bereits aus Kurseinheit 1, Abschnitt 9.2; das Beispiel vom Quadrat als einem Rechteck, das nur eine Kantenlänge braucht, ist ein anderes). Diese Form der Typeinschränkung stellt zumindest auf Ebene der Typdefinition (der Intensionen) die Umkehrung der Typerweiterung dar. Es liegt auf der Hand, dass diese Form der Typeinschränkung nicht zur Zuweisungskompatibilität führt; dies folgt schon aus der fehlenden Symmetrie der Typkonformität. Sie soll hier deswegen keine weitere Berücksichtigung finden, auch wenn es Sprachen gibt, die sie erlauben (z. B. EIFFEL).",Was ist Typeinschränkung?,"Typeinschränkung ist eine Möglichkeit, auf der Basis eines bereits bestehenden Typs einen neuen, verwandten Typen zu erzeugen, indem man ihn auf Basis des bestehenden Typs definiert, aber mit dem Entfernen von Eigenschaften (Methoden). Diese Form der Typeinschränkung stellt die Umkehrung der Typerweiterung dar, führt aber nicht zur Zuweisungskompatibilität."
"Typerweiterung ist nicht die einzige Möglichkeit, auf der Basis eines bereits bestehenden einen neuen, verwandten Typen zu erzeugen; Typeinschränkung ist eine andere. Eine erste, offensichtliche Form der Typeinschränkung liegt dann vor, wenn ein Typ auf Basis eines anderen unter Entfernen von Eigenschaften (Methoden) definiert wird (das Beispiel vom Pinguin als einem Vogel, der nicht fliegen kann, kennen Sie ja bereits aus Kurseinheit 1, Abschnitt 9.2; das Beispiel vom Quadrat als einem Rechteck, das nur eine Kantenlänge braucht, ist ein anderes). Diese Form der Typeinschränkung stellt zumindest auf Ebene der Typdefinition (der Intensionen) die Umkehrung der Typerweiterung dar. Es liegt auf der Hand, dass diese Form der Typeinschränkung nicht zur Zuweisungskompatibilität führt; dies folgt schon aus der fehlenden Symmetrie der Typkonformität. Sie soll hier deswegen keine weitere Berücksichtigung finden, auch wenn es Sprachen gibt, die sie erlauben (z. B. EIFFEL).",Was ist der Unterschied zwischen Typerweiterung und Typeinschränkung?,"Typerweiterung erfolgt durch Hinzufügen von Eigenschaften (Methoden) zu einem bestehenden Typen, während Typeinschränkung durch Entfernen von Eigenschaften (Methoden) von einem bestehenden Typen erfolgt. Typerweiterung führt zur Zuweisungskompatibilität, während Typeinschränkung nicht dazu führt."
"Eine unter dem Gesichtspunkt der Zuweisungskompatibilität interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere zu ersetzen (ohne hier schon zu sagen, was „spezieller“ im Zusammenhang mit Typen bedeutet). Diese Form der Typeinschränkung ergibt sich auf natürliche Weise, wenn man sich den Zusammenhang von Extensionen von definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht.",Was ist eine Form der Typeinschränkung?,"Eine Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere Typen zu ersetzen. Diese Form der Typeinschränkung ergibt sich auf natürliche Weise, wenn man sich den Zusammenhang von Extensionen von definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht."
"Eine unter dem Gesichtspunkt der Zuweisungskompatibilität interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere zu ersetzen (ohne hier schon zu sagen, was „spezieller“ im Zusammenhang mit Typen bedeutet). Diese Form der Typeinschränkung ergibt sich auf natürliche Weise, wenn man sich den Zusammenhang von Extensionen von definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht.",Was ist die unter dem Gesichtspunkt der Zuweisungskompatibilität interessante Form der Typeinschränkung?,"Die unter dem Gesichtspunkt der Zuweisungskompatibilität interessante Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere zu ersetzen. Diese Form der Typeinschränkung ergibt sich auf natürliche Weise, wenn man sich den Zusammenhang von Extensionen von definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht."
"Man mag sich fragen, warum bei der Typerweiterung keine zwei Formen analog zur Typeinschränkung eingeführt wurden. Die Typerweiterung würde damit zur vollständigen Umkehrung der Typeinschränkung wie hier beschrieben. Wie Sie noch sehen werden, ist das Ziel nicht die Schaffung zweier Komplementäre, sondern die Vereinigung beider zu einer Beziehung zwischen Typen – dazu müssen sie aber in dieselbe und nicht in gegensätzliche Richtungen gehen. Außerdem ist eine Erweiterung des Wertebereichs bei Einschränkung des Definitionsbereichs nicht durch den Begriff der Relation wie oben erklärt; eine wichtige Analogie zur Realität, die durch Typen zwecks semantischer Prüfung nachgebildet werden soll, ginge damit verloren.",Was ist das Ziel der Typerweiterung ?,"Das Ziel der Typerweiterung ist die Vereinigung von Typerweiterung und Typeinschränkung zu einer Beziehung zwischen Typen, nicht die Schaffung zweier Komplementäre."
"Man mag sich fragen, warum bei der Typerweiterung keine zwei Formen analog zur Typeinschränkung eingeführt wurden. Die Typerweiterung würde damit zur vollständigen Umkehrung der Typeinschränkung wie hier beschrieben. Wie Sie noch sehen werden, ist das Ziel nicht die Schaffung zweier Komplementäre, sondern die Vereinigung beider zu einer Beziehung zwischen Typen – dazu müssen sie aber in dieselbe und nicht in gegensätzliche Richtungen gehen. Außerdem ist eine Erweiterung des Wertebereichs bei Einschränkung des Definitionsbereichs nicht durch den Begriff der Relation wie oben erklärt; eine wichtige Analogie zur Realität, die durch Typen zwecks semantischer Prüfung nachgebildet werden soll, ginge damit verloren.",Warum wurden bei der Typerweiterung keine zwei Formen eingeführt?,"Es wurden keine zwei Formen der Typerweiterung eingeführt, weil das Ziel nicht die Schaffung zweier Komplementäre, sondern die Vereinigung beider zu einer Beziehung zwischen Typen ist. Eine wichtige Analogie zur Realität, die durch Typen zwecks semantischer Prüfung nachgebildet werden soll, ginge damit nicht verloren."
"Nun ergibt sich aber bei der Typeinschränkung auch ohne Löschen das Problem, dass sie die Zuweisungskompatibilität, die ja für die Typerweiterung noch per Typkonformität geregelt werden konnte, aushebelt.",Was ist die Zuweisungskompatibilität?,"Die Zuweisungskompatibilität ist eine Regel, die bestimmt, ob ein Wert einer Variablen zugewiesen werden kann. Wenn der Typ des Werts mit dem Typ der Variablen kompatibel ist, ist die Zuweisungskompatibilität gegeben."
"Nun ergibt sich aber bei der Typeinschränkung auch ohne Löschen das Problem, dass sie die Zuweisungskompatibilität, die ja für die Typerweiterung noch per Typkonformität geregelt werden konnte, aushebelt.",Was ist die Typkonformität?,"Die Typkonformität ist eine Regel, die bestimmt, ob ein Typ in eine Typerweiterung übergehen kann. Wenn der Typ des Werts mit dem Typ der Variablen kompatibel ist, ist die Typkonformität gegeben."
"Nun ergibt sich aber bei der Typeinschränkung auch ohne Löschen das Problem, dass sie die Zuweisungskompatibilität, die ja für die Typerweiterung noch per Typkonformität geregelt werden konnte, aushebelt.","Was passiert, wenn die Zuweisungskompatibilität durch die Typeinschränkung ausgehebelt wird?","Wenn die Zuweisungskompatibilität durch die Typeinschränkung ausgehebelt wird, kann kein Wert mehr zugewiesen werden, was zu einem Fehler führt."
"Nun ergibt sich aber bei der Typeinschränkung auch ohne Löschen das Problem, dass sie die Zuweisungskompatibilität, die ja für die Typerweiterung noch per Typkonformität geregelt werden konnte, aushebelt.",Was ist die Auswirkung der Typeinschränkung auf die Zuweisungskompatibilität?,"Die Typeinschränkung hebelt die Zuweisungskompatibilität aus, was bedeutet, dass die Zuweisung von Werten mit unverträglichen Typen nicht mehr möglich ist."
"Nun ergibt sich aber bei der Typeinschränkung auch ohne Löschen das Problem, dass sie die Zuweisungskompatibilität, die ja für die Typerweiterung noch per Typkonformität geregelt werden konnte, aushebelt.",Was ist das Problem bei der Typeinschränkung und der Zuweisungskompatibilität?,"Das Problem ist, dass die Typeinschränkung die Zuweisungskompatibilität aushebelt, die für die Typerweiterung noch per Typkonformität geregelt werden konnte. Das bedeutet, dass die Zuweisung von Werten unterschiedlicher Typen nicht mehr möglich ist, auch wenn sie in einem übergeordneten Typ enthalten sind."
"Wesentlich für diese Betrachtungsweise, und damit das geschilderte Problem, ist übrigens, dass nach der Zuweisung von Zeile 901 d und z auf dasselbe Objekt, nämlich eine Zeichnung, verweisen. d ist also ein Alias für z. Unter Wertsemantik, bei der bei der Zuweisung eine Kopie erstellt wird, hätte man hingegen überlegen müssen, wie man ein Objekt vom Typ Zeichnung in einer Variable vom Typ Dokument speichern kann; je nach interner Repräsentation der Objekte (die ja durch den Typ nicht festgelegt ist), ist dafür nämlich gar nicht genug Platz. Gleichzeitig mit der Kopie könnte dann eine Typkonvertierung erfolgen, bei der aus der Zeichnung ein Dokument gemacht würde (was auch immer das heißen mag). Dieses Dokument müsste dann, per obiger Typdefinition, auch auf einem Zeilendrucker druckbar sein. Es ist allerdings schwer vorstellbar, wie dies umzusetzen ist, wenn das entsprechende Objekt nicht einmal mehr weiß, dass es eine Zeichnung ist, geschweige denn, wie seine interne Repräsentation aussieht. In der Praxis der objektorientierten Programmierung ist daher auch nur die Referenzsemantik in Fragen der Zuweisungskompatibilität interessant.",Was ist der Unterschied zwischen Wertsemantik und Referenzsemantik?,"Unter Wertsemantik, bei der Zuweisung eine Kopie erstellt wird, hätte man überlegen müssen, wie man ein Objekt vom Typ Zeichnung in einer Variablen vom Typ Dokument speichern kann. In der Praxis der objektorientierten Programmierung ist jedoch nur die Referenzsemantik in Fragen der Zuweisungskompatibilität interessant. Bei Referenzsemantik verweisen zwei Variablen auf dasselbe Objekt, während bei Wertsemantik eine Kopie erstellt wird."
"Wesentlich für diese Betrachtungsweise, und damit das geschilderte Problem, ist übrigens, dass nach der Zuweisung von Zeile 901 d und z auf dasselbe Objekt, nämlich eine Zeichnung, verweisen. d ist also ein Alias für z. Unter Wertsemantik, bei der bei der Zuweisung eine Kopie erstellt wird, hätte man hingegen überlegen müssen, wie man ein Objekt vom Typ Zeichnung in einer Variable vom Typ Dokument speichern kann; je nach interner Repräsentation der Objekte (die ja durch den Typ nicht festgelegt ist), ist dafür nämlich gar nicht genug Platz. Gleichzeitig mit der Kopie könnte dann eine Typkonvertierung erfolgen, bei der aus der Zeichnung ein Dokument gemacht würde (was auch immer das heißen mag). Dieses Dokument müsste dann, per obiger Typdefinition, auch auf einem Zeilendrucker druckbar sein. Es ist allerdings schwer vorstellbar, wie dies umzusetzen ist, wenn das entsprechende Objekt nicht einmal mehr weiß, dass es eine Zeichnung ist, geschweige denn, wie seine interne Repräsentation aussieht. In der Praxis der objektorientierten Programmierung ist daher auch nur die Referenzsemantik in Fragen der Zuweisungskompatibilität interessant.",Was ist der Unterschied zwischen Wertsemantik und Referenzsemantik in Bezug auf Zuweisungskompatibilität in der objektorientierten Programmierung?,"In der objektorientierten Programmierung ist bei der Zuweisungskompatibilität nur die Referenzsemantik relevant. Bei der Referenzsemantik wird nur der Verweis auf das Objekt kopiert und in der Variablen gespeichert, während bei der Wertsemantik eine Kopie des Objekts angefertigt wird. Dies führt dazu, dass bei der Referenzsemantik Änderungen am Objekt in einer Variablen auch das Objekt in einer anderen Variablen betrifft, wenn sie auf dasselbe Objekt verweisen. Bei der Wertsemantik hingegen betrifft eine Änderung am Objekt in einer Variablen nicht das Objekt in einer anderen Variablen, da es sich um eine Kopie handelt."
"Was die Freiheit von Typfehlern angeht, kann man das Löschen von Eigenschaften (Methoden) übrigens auch als einen Spezialfall der Typeinschränkung der obigen, zweiten Form auffassen, nämlich einer, in der der Wertebereich auf die leere Menge eingeschränkt wird. So wäre beispielsweise druckenAuf: mit einem Parametertyp ohne Elemente gar nicht mehr aufrufbar (da es kein typkorrektes Parameterobjekt gäbe), was einer Löschung gleichkäme.",Wie kann man das Löschen von Eigenschaften (Methoden) als Spezialfall der Typeinschränkung auffassen?,"Man kann das Löschen von Eigenschaften (Methoden) als Spezialfall der Typeinschränkung auffassen, indem man den Wertebereich auf die leere Menge einschränkt. In diesem Fall wäre die Methode nicht mehr aufrufbar, da es kein typkorrektes Parameterobjekt gäbe, was einer Löschung gleichkäme."
"Was die Freiheit von Typfehlern angeht, kann man das Löschen von Eigenschaften (Methoden) übrigens auch als einen Spezialfall der Typeinschränkung der obigen, zweiten Form auffassen, nämlich einer, in der der Wertebereich auf die leere Menge eingeschränkt wird. So wäre beispielsweise druckenAuf: mit einem Parametertyp ohne Elemente gar nicht mehr aufrufbar (da es kein typkorrektes Parameterobjekt gäbe), was einer Löschung gleichkäme.",Wie kann man das Löschen von Eigenschaften (Methoden) in Bezug auf Typfehler verstehen?,"Das Löschen von Eigenschaften (Methoden) kann als ein Spezialfall der Typeinschränkung verstanden werden, bei der der Wertebereich auf die leere Menge eingeschränkt wird. In diesem Fall wäre die Methode nicht mehr aufrufbar, da es kein typkorrektes Parameterobjekt gäbe, was einer Löschung gleichkäme."
"Mit einer so chaotischen Syntax, dass sogar Compiler raten müssen, ist es besser, dass C++-Code wiederverwendbar ist, denn niemand wird jemals daran denken, ihn rückzuentwickeln. Die ""Funktion"" der Programmiersprache - nämlich eine Erweiterung von C zu sein - ist ein grundlegendes Problem. Mit zahlreichen großen Projekten, die bereits in veralteten Dialekten geschrieben wurden, kann man C++ sicherlich als eine ""sofortige Legacy""-Sprache betrachten.",Wie wird C++ oft beschrieben?,"C++ wird oft als eine ""sofortige Legacy""-Sprache beschrieben, die eine Erweiterung von C ist und eine chaotische Syntax hat."
"Mit einer so chaotischen Syntax, dass sogar Compiler raten müssen, ist es besser, dass C++-Code wiederverwendbar ist, denn niemand wird jemals daran denken, ihn rückzuentwickeln. Die ""Funktion"" der Programmiersprache - nämlich eine Erweiterung von C zu sein - ist ein grundlegendes Problem. Mit zahlreichen großen Projekten, die bereits in veralteten Dialekten geschrieben wurden, kann man C++ sicherlich als eine ""sofortige Legacy""-Sprache betrachten.",Was ist das grundlegende Problem von C++?,"Das grundlegende Problem von C++ ist, dass es eine Erweiterung von C ist."
"Mit einer so chaotischen Syntax, dass sogar Compiler raten müssen, ist es besser, dass C++-Code wiederverwendbar ist, denn niemand wird jemals daran denken, ihn rückzuentwickeln. Die ""Funktion"" der Programmiersprache - nämlich eine Erweiterung von C zu sein - ist ein grundlegendes Problem. Mit zahlreichen großen Projekten, die bereits in veralteten Dialekten geschrieben wurden, kann man C++ sicherlich als eine ""sofortige Legacy""-Sprache betrachten.","Warum ist es besser, dass C++-Code wiederverwendbar ist?","Es ist besser, dass C++-Code wiederverwendbar ist, weil niemand jemals daran denken wird, ihn rückzuentwickeln, aufgrund der chaotischen Syntax."
"Mit einer so chaotischen Syntax, dass sogar Compiler raten müssen, ist es besser, dass C++-Code wiederverwendbar ist, denn niemand wird jemals daran denken, ihn rückzuentwickeln. Die ""Funktion"" der Programmiersprache - nämlich eine Erweiterung von C zu sein - ist ein grundlegendes Problem. Mit zahlreichen großen Projekten, die bereits in veralteten Dialekten geschrieben wurden, kann man C++ sicherlich als eine ""sofortige Legacy""-Sprache betrachten.","Warum wird C++ als ""sofortige Legacy""-Sprache bezeichnet?","C++ wird als ""sofortige Legacy""-Sprache bezeichnet, weil es zahlreiche große Projekte gibt, die bereits in veralteten Dialekten geschrieben wurden und weil die chaotische Syntax von C++ dazu führt, dass sogar Compiler raten müssen, was der Programmierer beabsichtigt hat. Diese Faktoren machen es unwahrscheinlich, dass C++-Code rückentwickelt wird, und somit ist die Wiederverwendbarkeit von C++-Code wichtiger als seine Rückentwicklung."
"Über C++ wurde viel geschrieben, und nicht alles davon war positiv. Dabei wird jedoch häufig vergessen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss. Natürlich kann man in C++ völlig unlesbaren Code schreiben, aber das gilt auch für C, weil man in C völlig unlesbaren Code schreiben kann. Aber man kann auch C++ mit einer neuen Syntax versehen (mithilfe seines Präprozessors, der übrigens Turing-äquivalent ist und daher die Ausdrucksstärke einer vollwertigen Programmiersprache besitzt) und dann völlig lesbaren Code schreiben.","Warum wird oft vergessen, dass C++ vollständig rückwärtskompatibel zu C sein muss?","Bei der Entwicklung von C++ war eine der harten Anforderungen die vollständige Rückwärtskompatibilität zu C. Diese Anforderung wird oft vergessen, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss."
"Über C++ wurde viel geschrieben, und nicht alles davon war positiv. Dabei wird jedoch häufig vergessen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss. Natürlich kann man in C++ völlig unlesbaren Code schreiben, aber das gilt auch für C, weil man in C völlig unlesbaren Code schreiben kann. Aber man kann auch C++ mit einer neuen Syntax versehen (mithilfe seines Präprozessors, der übrigens Turing-äquivalent ist und daher die Ausdrucksstärke einer vollwertigen Programmiersprache besitzt) und dann völlig lesbaren Code schreiben.",Kann man in C++ völlig unlesbaren Code schreiben?,"Ja, man kann in C++ völlig unlesbaren Code schreiben, aber das gilt auch für C, weil man in C völlig unlesbaren Code schreiben kann."
"Über C++ wurde viel geschrieben, und nicht alles davon war positiv. Dabei wird jedoch häufig vergessen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss. Natürlich kann man in C++ völlig unlesbaren Code schreiben, aber das gilt auch für C, weil man in C völlig unlesbaren Code schreiben kann. Aber man kann auch C++ mit einer neuen Syntax versehen (mithilfe seines Präprozessors, der übrigens Turing-äquivalent ist und daher die Ausdrucksstärke einer vollwertigen Programmiersprache besitzt) und dann völlig lesbaren Code schreiben.",Kann man auch C++ mit einer neuen Syntax versehen und dann völlig lesbaren Code schreiben?,"Ja, man kann C++ mit einer neuen Syntax versehen, indem man den Präprozessor verwendet, der die Ausdrucksstärke einer vollwertigen Programmiersprache besitzt, und dann völlig lesbaren Code schreiben."
"Über C++ wurde viel geschrieben, und nicht alles davon war positiv. Dabei wird jedoch häufig vergessen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss. Natürlich kann man in C++ völlig unlesbaren Code schreiben, aber das gilt auch für C, weil man in C völlig unlesbaren Code schreiben kann. Aber man kann auch C++ mit einer neuen Syntax versehen (mithilfe seines Präprozessors, der übrigens Turing-äquivalent ist und daher die Ausdrucksstärke einer vollwertigen Programmiersprache besitzt) und dann völlig lesbaren Code schreiben.",Warum ist die Kritik an C++ als unfair anzusehen?,"Die Kritik an C++ ist als unfair anzusehen, weil bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C gefordert wurde, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss."
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. Obwohl zwei gleiche Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden.",Was ist die Gleichheit von Objekten?,Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten und wird in SMALLTALK durch den Gleichheitsoperator getestet.
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. Obwohl zwei gleiche Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden.",Was ist die Identität von Objekten?,"Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren."
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. Obwohl zwei gleiche Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden.",Was unterscheidet Gleichheit und Identität von Objekten?,"Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten. Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren."
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. Obwohl zwei gleiche Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden.",Warum können syntaktisch gleiche String-Literale in SMALLTALK unterschiedliche Identitäten haben?,"Syntaktisch gleiche String-Literale können in SMALLTALK unterschiedliche Identitäten haben, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen."
"Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!",Warum sind gleiche Zahlen nur manchmal identisch in SMALLTALK?,"In SMALLTALK werden gleiche Zahlen manchmal als identisch behandelt und manchmal nicht, abhängig von ihrer Größe und technischen Gründen."
"Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!","Was unterscheidet die Bezeichnungen ""das gleiche"" und ""dasselbe""?","In der objektorientierten Programmierung sind ""das gleiche"" und ""dasselbe"" nicht dasselbe. Zwei Objekte können gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins."
"Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!",Warum ist die Identität von Objekten wichtig?,"Die Identität von Objekten ist wichtig, um festzustellen, ob zwei Namen oder Variablen dasselbe Objekt repräsentieren oder nicht."
"Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!",Warum haben veränderliche Objekte eine Identität?,"Veränderliche Objekte haben eine Identität um sie auch bei vorübergehender Gleichheit voneinander unterscheiden zu können, da sie sich hinterher wieder auseinanderentwickeln können."
"Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!",Warum haben unveränderliche Objekte eine Identität?,"Unveränderliche Objekte haben aus technischen Gründen eine Identität. Wenn sich ein unveränderliches Objekt aus einer Operation ergibt, dann müsste für eine Zusammenlegung gleicher Objekte zu einem immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Ganze Zahlen bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind."
"Neben den reinen Namenskonventionen einigt man sich häufig auch auf Formatierungskonventionen (zusammen mit Namenskonventionen und anderen Richtlinien, auf Englisch oft als ""coding conventions"" bezeichnet, auf Deutsch oft auch, und etwas zu allgemein, als ""Programmierstil""). Diese regeln Dinge wie Einrückungen und an welchen Stellen Zeilenumbrüche, Leerzeilen und Leerzeichen einzufügen sind. Sie dienen ebenfalls der besseren Lesbarkeit.",Was sind Formatierungskonventionen?,"Formatierungskonventionen sind Vereinbarungen über die Formatierung von Quellcode, die neben Namenskonventionen dazu dienen, den Code lesbarer zu gestalten. Sie regeln Dinge wie Einrückungen und an welchen Stellen Zeilenumbrüche, Leerzeilen und Leerzeichen einzufügen sind."
"Neben den reinen Namenskonventionen einigt man sich häufig auch auf Formatierungskonventionen (zusammen mit Namenskonventionen und anderen Richtlinien, auf Englisch oft als ""coding conventions"" bezeichnet, auf Deutsch oft auch, und etwas zu allgemein, als ""Programmierstil""). Diese regeln Dinge wie Einrückungen und an welchen Stellen Zeilenumbrüche, Leerzeilen und Leerzeichen einzufügen sind. Sie dienen ebenfalls der besseren Lesbarkeit.",Was sind Coding Conventions?,"Coding Conventions sind Vereinbarungen über die Formatierung von Quellcode, die neben Namenskonventionen und anderen Richtlinien dazu dienen, den Code lesbarer zu gestalten. Sie regeln Dinge wie Einrückungen, Zeilenumbrüche, Leerzeilen und Leerzeichen."
"Formatierungskonventionen sind jedoch nicht nur eine Richtschnur für Einzelne, die sich vielleicht unsicher sind, ob bzw. wo sie ein Leerzeichen einfügen sollen. Sie vermeiden auch den Effekt, dass jede Programmiererin im Team ihre eigenen Vorlieben pflegt. Dies kann dazu führen, dass wenn eine Programmiererin den Code einer anderen bearbeitet, sie zunächst einmal damit beginnt, diesen so zu formatieren, dass er ihren Lesegewohnheiten entspricht. Die ursprüngliche Autorin reagiert natürlich empört und wird nichts anderes tun, als dies bei nächster Gelegenheit wieder rückgängig zu machen, sprich zu ihren eigenen Vorlieben zurückzukehren. Dies ist alles andere als produktiv.",Warum sind Formatierungskonventionen wichtig in der Teamarbeit?,"Formatierungskonventionen sind wichtig in der Teamarbeit, um eine einheitliche Formatierung des Codes zu gewährleisten und somit die Lesbarkeit und Verständlichkeit zu erhöhen. Sie vermeiden den Effekt, dass jede Programmiererin im Team ihre eigenen Vorlieben pflegt, was zu unnötigen Änderungen und Konflikten führen kann."
"Ein wirksames Gegenmittel gegen solche Energieverschwendung sind automatische Codeformatierer, die auf Knopfdruck bestimmte Codierungs-konventionen umsetzen. Wo immer verfügbar, sollte man sich zur Angewohnheit machen, diese auch einzusetzen, selbst wenn man allein arbeitet, schon um sich mit der Entwicklung des persönlichen Programmierstils nicht zu weit von dem, was allgemein üblich ist, zu entfernen. Die Programmierung ist nicht geeignet, Individualität zum Ausdruck zu bringen, geschweige denn, sie voll auszuleben.",Was sind automatische Codeformatierer?,"Automatische Codeformatierer sind Werkzeuge, die auf Knopfdruck bestimmte Codierungs-konventionen umsetzen. Sie sind ein wirksames Gegenmittel gegen Energieverschwendung und sollten, wo immer verfügbar, eingesetzt werden."
"Ein wirksames Gegenmittel gegen solche Energieverschwendung sind automatische Codeformatierer, die auf Knopfdruck bestimmte Codierungs-konventionen umsetzen. Wo immer verfügbar, sollte man sich zur Angewohnheit machen, diese auch einzusetzen, selbst wenn man allein arbeitet, schon um sich mit der Entwicklung des persönlichen Programmierstils nicht zu weit von dem, was allgemein üblich ist, zu entfernen. Die Programmierung ist nicht geeignet, Individualität zum Ausdruck zu bringen, geschweige denn, sie voll auszuleben.","Warum sollte man sich zur Angewohnheit machen, automatische Codeformatierer einzusetzen?","Man sollte sich zur Angewohnheit machen, automatische Codeformatierer einzusetzen, um Energieverschwendung zu vermeiden, Codierungs-konventionen umzusetzen, sich nicht zu weit von dem, was allgemein üblich ist, zu entfernen und sich auf die Entwicklung des persönlichen Programmierstils zu konzentrieren."
"Genau wie in der SMALLTALK-Programmierung kommt man in der Java-Programmierung häufig in die Verlegenheit, Zu-n-Beziehungen umsetzen zu müssen. Wie in SMALLTALK geschieht dies auch in Java mit Hilfe von Zwischenobjekten. Anders als in SMALLTALK wird hier aber grundsätzlich zwischen zwei Arten von Zwischenobjekten unterschieden: den Arrays und den Collections. Da Java-Arrays in ihrer Funktionalität beschränkt sind (siehe Kapitel 41: keine eigenen Methoden zur Unterstützung des Zugriffs, kein dynamisches Wachstum, dazu die etwas verkorkste Situation beim Subtyping), werden Arrays vornehmlich dort eingesetzt.",Wie werden Zu-n-Beziehungen in Java umgesetzt?,"In Java werden Zu-n-Beziehungen mithilfe von Zwischenobjekten umgesetzt, wobei zwischen zwei Arten von Zwischenobjekten unterschieden wird: Arrays und Collections. Arrays sind in Java beschränkt, da sie keine eigenen Methoden zur Unterstützung des Zugriffs haben, kein dynamisches Wachstum ermöglichen und eine etwas verkorkste Situation beim Subtyping aufweisen."
"Genau wie in der SMALLTALK-Programmierung kommt man in der Java-Programmierung häufig in die Verlegenheit, Zu-n-Beziehungen umsetzen zu müssen. Wie in SMALLTALK geschieht dies auch in Java mit Hilfe von Zwischenobjekten. Anders als in SMALLTALK wird hier aber grundsätzlich zwischen zwei Arten von Zwischenobjekten unterschieden: den Arrays und den Collections. Da Java-Arrays in ihrer Funktionalität beschränkt sind (siehe Kapitel 41: keine eigenen Methoden zur Unterstützung des Zugriffs, kein dynamisches Wachstum, dazu die etwas verkorkste Situation beim Subtyping), werden Arrays vornehmlich dort eingesetzt.",Was ist der Unterschied zwischen Arrays und Collections in Java?,"In Java werden Arrays und Collections als Zwischenobjekte verwendet, um Zu-n-Beziehungen umzusetzen. Der Hauptunterschied besteht darin, dass Arrays beschränkt sind und keine eigenen Methoden zur Unterstützung des Zugriffs haben, kein dynamisches Wachstum ermöglichen und eine etwas verkorkste Situation beim Subtyping aufweisen. Collections hingegen sind dynamisch und verfügen über eine Vielzahl von Methoden, die das Manipulieren von Objekten erleichtern."
"In SMALLTALK sind Klassen Instanzen von Metaklassen, die selbst Instanzen einer weiteren Klasse sind, und alle diese zusammen sind Objekte. Daher ist jedes SMALLTALK-Programm, ja das ganze SMALLTALK-System, nichts weiter als ein Geflecht von Objekten (abgesehen von den primitiven Methoden). SMALLTALK ist somit nicht nur ein Programmiersystem, sondern auch ein Metaprogrammiersystem in der Tradition funktionaler und logischer Programmiersprachen wie LISP und PROLOG. In der Welt der imperativen und objektorientierten Programmiersprachen sucht diese Mächtigkeit bis heute ihresgleichen.",Was ist SMALLTALK?,"SMALLTALK ist ein objektorientiertes Programmiersystem, in dem Klassen Instanzen von Metaklassen sind, die selbst Instanzen einer weiteren Klasse sind, und alle diese zusammen sind Objekte. SMALLTALK ist somit ein Geflecht von Objekten und bietet die Möglichkeiten von Metaprogrammierung."
"Als Programmiererin, die nicht gleich eine neue Sprache entwickeln möchte, werden Sie wahrscheinlich nicht in die Ebene der Metaklassen hinabsteigen oder diese gar selbst ändern. Wenn Sie beispielsweise möchten, dass beim Erstellen einer neuen Klasse automatisch Zugriffsmethoden für alle benannten Instanzvariablen dieser Klasse generiert werden, ist dies leicht möglich, indem Sie an der entsprechenden Stelle (z. B. in der Klasse ""Class"" oder ""Behavior"", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert.",Was ist eine Metaklasse in der Programmierung?,"Eine Metaklasse ist eine Klasse, die für die Erstellung von Klassen verantwortlich ist. Sie ist eine Klasse der Klassen und ermöglicht es, die Verhaltensweisen von Klassen zu ändern oder zu erweitern."
"Als Programmiererin, die nicht gleich eine neue Sprache entwickeln möchte, werden Sie wahrscheinlich nicht in die Ebene der Metaklassen hinabsteigen oder diese gar selbst ändern. Wenn Sie beispielsweise möchten, dass beim Erstellen einer neuen Klasse automatisch Zugriffsmethoden für alle benannten Instanzvariablen dieser Klasse generiert werden, ist dies leicht möglich, indem Sie an der entsprechenden Stelle (z. B. in der Klasse ""Class"" oder ""Behavior"", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert.",Was ist die Aufgabe von Metaklassen in der Programmierung?,"Metaklassen sind eine Ebene oberhalb von Klassen und werden verwendet, um die Verhaltensweisen von Klassen zu definieren. Sie können auch geändert werden, um die Erstellung von Klassen zu ändern, wie zum Beispiel das automatische Generieren von Zugriffsmethoden für alle benannten Instanzvariablen einer Klasse."
"Als Programmiererin, die nicht gleich eine neue Sprache entwickeln möchte, werden Sie wahrscheinlich nicht in die Ebene der Metaklassen hinabsteigen oder diese gar selbst ändern. Wenn Sie beispielsweise möchten, dass beim Erstellen einer neuen Klasse automatisch Zugriffsmethoden für alle benannten Instanzvariablen dieser Klasse generiert werden, ist dies leicht möglich, indem Sie an der entsprechenden Stelle (z. B. in der Klasse ""Class"" oder ""Behavior"", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert.","Was ist die Klasse ""Class"" oder ""Behavior"" in Smalltalk?","Die Klasse ""Class"" oder ""Behavior"" in Smalltalk ist eine Metaklasse, die für das Erstellen neuer Klassen verantwortlich ist."
"Als Programmiererin, die nicht gleich eine neue Sprache entwickeln möchte, werden Sie wahrscheinlich nicht in die Ebene der Metaklassen hinabsteigen oder diese gar selbst ändern. Wenn Sie beispielsweise möchten, dass beim Erstellen einer neuen Klasse automatisch Zugriffsmethoden für alle benannten Instanzvariablen dieser Klasse generiert werden, ist dies leicht möglich, indem Sie an der entsprechenden Stelle (z. B. in der Klasse ""Class"" oder ""Behavior"", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert.",Was ist eine Metaklasse in Smalltalk?,"In Smalltalk ist eine Metaklasse eine Klasse, die dazu dient, andere Klassen zu definieren und zu erstellen."
"Als Programmiererin, die nicht gleich eine neue Sprache entwickeln möchte, werden Sie wahrscheinlich nicht in die Ebene der Metaklassen hinabsteigen oder diese gar selbst ändern. Wenn Sie beispielsweise möchten, dass beim Erstellen einer neuen Klasse automatisch Zugriffsmethoden für alle benannten Instanzvariablen dieser Klasse generiert werden, ist dies leicht möglich, indem Sie an der entsprechenden Stelle (z. B. in der Klasse ""Class"" oder ""Behavior"", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert.",Wie kann man in Smalltalk automatische Zugriffsmethoden für alle benannten Instanzvariablen einer Klasse generieren?,"Dies ist möglich, indem man eine neue Methode zur Klassendefinition in der Klasse ""Class"" oder ""Behavior"" hinzufügt, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert."
"Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.",Was sind Metaklassen in SMALLTALK?,"Metaklassen sind Klassen, die Klassen erstellen. In SMALLTALK erstellt die Programmiersprache automatisch Metaklassen, die für den Programmierer nicht sichtbar sind, außer durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden im Klassenbrowser."
"Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.",Wer erstellt Metaklassen in Smalltalk?,Smalltalk erstellt Metaklassen automatisch selbst.
"Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.",Wann werden Metaklassen im Klassenbrowser sichtbar?,Metaklassen werden im Klassenbrowser nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.
"Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.",Wozu werden temporäre Variablen in Smalltalk verwendet?,"Temporäre Variablen werden in Smalltalk verwendet, um Zwischenergebnissen Namen zu geben und die Lesbarkeit zu verbessern."
"Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.",Wie wird der Zustand eines Objekts in Smalltalk verändert?,"Der Zustand eines Objekts in Smalltalk wird verändert, indem die Werte seiner Instanzvariablen zugewiesen werden, was gleichbedeutend mit der Änderung seiner Beziehungen ist."
"Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.",Wann entstehen Aliase in Smalltalk?,"Aliase entstehen in Smalltalk immer bei der Zuweisung, wenn die Variable auf der linken Seite Verweissemantik hat."
"Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.",Wie werden Informationen in der objektorientierten Programmierung in Smalltalk dargestellt?,"In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt, das navigiert und manipuliert werden kann."
"Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.",Was erstellt SMALLTALK automatisch für Klassen?,"SMALLTALK erstellt automatisch Metaklassen für Klassen, deren Instanzen selbst keine Klassen sind."
"Eine weitere nützliche Collection-Klasse wird durch SortedCollection implementiert. Es handelt sich dabei um eine Subklasse von OrderedCollection, bei der die Reihenfolge der Elemente nicht von außen, also durch die Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt wird, sondern von innen, genauer durch eine Qualität der eingefügten Objekte. Zwischenobjekte der Klasse SortedCollection setzt man ein, wenn man die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge haben möchte, wie z. B. die Kinder einer Person in der Namensfolge, und zwar unabhängig davon, in welcher Reihenfolge sie der Collection hinzugefügt wurden. Voraussetzung dafür, dass die Elemente einer SortedCollection sortiert werden können, ist, dass sie verglichen werden können, dass also die (binäre) Methode <= (für kleiner gleich) darauf definiert ist. So liefert beispielsweise mit #(1 2 3) das gewünschte Ergebnis.",Was ist die Klasse SortedCollection in Smalltalk?,"SortedCollection ist eine Subklasse von OrderedCollection, die die Elemente in einer bestimmten Reihenfolge hält, die durch eine Qualität der eingefügten Objekte bestimmt wird. Die Elemente müssen vergleichbar sein, d.h. die (binäre) Methode <= muss darauf definiert sein."
"Eine weitere nützliche Collection-Klasse wird durch SortedCollection implementiert. Es handelt sich dabei um eine Subklasse von OrderedCollection, bei der die Reihenfolge der Elemente nicht von außen, also durch die Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt wird, sondern von innen, genauer durch eine Qualität der eingefügten Objekte. Zwischenobjekte der Klasse SortedCollection setzt man ein, wenn man die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge haben möchte, wie z. B. die Kinder einer Person in der Namensfolge, und zwar unabhängig davon, in welcher Reihenfolge sie der Collection hinzugefügt wurden. Voraussetzung dafür, dass die Elemente einer SortedCollection sortiert werden können, ist, dass sie verglichen werden können, dass also die (binäre) Methode <= (für kleiner gleich) darauf definiert ist. So liefert beispielsweise mit #(1 2 3) das gewünschte Ergebnis.",Wozu dient die Klasse SortedCollection?,"Die Klasse SortedCollection wird verwendet, um eine Collection von Objekten in einer bestimmten Reihenfolge zu halten, die durch eine Qualität der Objekte bestimmt wird. Die Objekte müssen vergleichbar sein, d.h. die binäre Methode <= muss auf sie anwendbar sein."
"Wenn die Elemente, die in eine sortierte Collection eingefügt werden sollen, keine Größen sind und insbesondere den Vergleich <= nicht implementieren, dann ist es immer noch möglich, für eine neue Instanz einer SortedCollection einen sogenannten Sortierblock zu spezifizieren, der zwei formale Parameter hat und dessen Auswertung zurückliefert, ob der erste tatsächlich e Parameter kleiner oder gleich dem zweiten ist.",Was ist ein Sortierblock in SortedCollection in SMALLTALK?,"Wenn die Elemente, die in eine sortierte Collection eingefügt werden sollen, keine Größen sind und insbesondere den Vergleich <= nicht implementieren, kann für eine neue Instanz einer SortedCollection ein Sortierblock spezifiziert werden. Dieser Sortierblock ist ein Block mit zwei formalen Parametern, der eine Auswertung zurückliefert, die angibt, ob der erste Parameter kleiner oder gleich dem zweiten ist."
"Eine Menge von Objekten aus einer Collection kann in eine andere übertragen werden, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z. B. asSet, das doppelte Elemente entfernt. Diese Konvertierungsmethoden sind in Collection implementiert, analog zu asBag und asOrderedCollection oben. Besonders interessant sind natürlich Konvertierungen in Collections, die strengere Bedingungen stellen, z. B. asSet und asSortedCollection.",Was können Konvertierungsmethoden in Collections tun?,"Konvertierungsmethoden in Collections können eine Menge von Objekten aus einer Collection in eine andere übertragen, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z.B. asSet, das doppelte Elemente entfernt. Besonders interessant sind Konvertierungen in Collections, die strengere Bedingungen stellen, z.B. asSet und asSortedCollection."
"Eine Menge von Objekten aus einer Collection kann in eine andere übertragen werden, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z. B. asSet, das doppelte Elemente entfernt. Diese Konvertierungsmethoden sind in Collection implementiert, analog zu asBag und asOrderedCollection oben. Besonders interessant sind natürlich Konvertierungen in Collections, die strengere Bedingungen stellen, z. B. asSet und asSortedCollection.",Was ist der Zweck von Konvertierungsmethoden in Collection?,"Der Zweck von Konvertierungsmethoden in Collection ist es, eine Menge von Objekten aus einer Collection in eine andere zu übertragen, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, wie z.B. das Entfernen doppelter Elemente bei der Konvertierung in eine Menge (asSet) oder das Sortieren der Elemente bei der Konvertierung in eine sortierte Collection (asSortedCollection)."
"Bitte beachten Sie jedoch, dass eine nachträgliche Änderung der Attributwerte, die zum Vergleich der Objekte für die Sortierung herangezogen wurden, keine automatische Änderung der Reihenfolge bewirkt, selbst wenn dies eigentlich notwendig wäre.","Was passiert, wenn man die Attributwerte eines Objekts nachträglich ändert, die für die Sortierung herangezogen wurden?","Eine nachträgliche Änderung der Attributwerte, die zum Vergleich der Objekte für die Sortierung herangezogen wurden, bewirkt keine automatische Änderung der Reihenfolge."
"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.",Was bedeutet Zuweisungskompatibilität?,"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten."
"Nun ist die Frage, ob eine Zuweisung gutgeht, eine, die man gerne automatisch, am besten durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der Programmierung zu einem eigenständigen Begriff geworden, der zunächst unabhängig von der (an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der Begriff der Substituierbarkeit soll daher zunächst genauer untersucht werden.",Was ist Substituierbarkeit in der Programmierung?,"Substituierbarkeit in der Programmierung ist ein Begriff, der unabhängig von der Typkonformität betrachtet wird. Er bezieht sich darauf, ob eine Zuweisung automatisch und ohne Probleme durch den Compiler beantwortet werden kann."
"In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack gerade leer ist, ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar: Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus Wartungsgründen substituiert werden müssten), gibt es wohl kaum einen Grund für eine Substituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend eng gefassten Substituierbarkeitsbegriff.",Was ist Substituierbarkeit in der objektorientierten Programmierung?,"Substituierbarkeit in der objektorientierten Programmierung bedeutet, dass ein Objekt ein anderes Objekt ersetzen kann, ohne dass sich der Programmablauf ändert. In der strengsten Auslegung müsste das ersetzende Objekt nicht nur gleich implementiert sein wie das ersetzte, sondern sich auch noch im selben Zustand befinden."
"In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack gerade leer ist, ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar: Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus Wartungsgründen substituiert werden müssten), gibt es wohl kaum einen Grund für eine Substituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend eng gefassten Substituierbarkeitsbegriff.",Was ist die strengste Auslegung des Begriffs der Substituierbarkeit?,"In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden."
"Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.",Was ist der Substituierbarkeitsbegriff und wie hängt er mit der Übersetzungszeit zusammen?,"Der Substituierbarkeitsbegriff ist ein Begriff, der unabhängig vom konkreten Zustand der Objekte sein muss. Wenn man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungszeit verlagert, ist das Verhalten aller Objekte einer Klasse gleich spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist."
"Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.",Was ist der Substituierbarkeitsbegriff und wovon sollte er unabhängig sein?,"Der Substituierbarkeitsbegriff bezieht sich darauf, ob ein Objekt eines Typs durch ein Objekt eines anderen Typs ersetzt werden kann, ohne dass sich das Verhalten des Systems ändert. Er sollte unabhängig vom konkreten Zustand der Objekte sein."
"Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.","Was ist der Vorteil, wenn man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann?","Der Vorteil ist, dass auf dieser Ebene das Verhalten aller Objekte einer Klasse gleich ist und somit eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist."
"Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. So könnte man sich beispielsweise vorstellen, dass ein substituierendes Objekt funktional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen. Diese sogenannten nichtfunktionalen Anforderungen, die normalerweise von den funktionalen getrennt dargestellt werden, sind jedoch in Wirklichkeit gar nicht immer hundertprozentig voneinander zu trennen. Es ist durchaus vorstellbar, dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, nicht funktioniert (beispielsweise weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu Abbrüchen durch Timeouts o. ä. führt).",Was ist die Frage der Substituierbarkeit?,"Die Frage der Substituierbarkeit bezieht sich darauf, ob ein Objekt durch ein anderes Objekt ersetzt werden kann, ohne dass sich das Verhalten des Gesamtsystems ändert. Diese Frage wird interessant, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. Diese Abweichungen können sowohl funktional als auch nichtfunktional sein."
"Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. So könnte man sich beispielsweise vorstellen, dass ein substituierendes Objekt funktional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen. Diese sogenannten nichtfunktionalen Anforderungen, die normalerweise von den funktionalen getrennt dargestellt werden, sind jedoch in Wirklichkeit gar nicht immer hundertprozentig voneinander zu trennen. Es ist durchaus vorstellbar, dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, nicht funktioniert (beispielsweise weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu Abbrüchen durch Timeouts o. ä. führt).",Was ist Substituierbarkeit und wann wird sie interessant?,"Substituierbarkeit bedeutet, dass ein Objekt durch ein anderes Objekt ersetzt werden kann, ohne dass sich das Verhalten des Systems ändert. Sie wird interessant, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt, wie beispielsweise in nichtfunktionalen Eigenschaften wie Geschwindigkeit oder Speicheranforderungen. Es ist jedoch zu beachten, dass funktionale und nichtfunktionale Anforderungen nicht immer hundertprozentig voneinander zu trennen sind und dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, möglicherweise nicht funktioniert."
"Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.",Was ist funktionale Äquivalenz?,"Funktionale Äquivalenz bedeutet, dass zwei Objekte, die zu verschiedenen Typen gehören, aber innerhalb derselben Gruppe sind, die gleichen Funktionen erfüllen und die gleichen Methoden aufrufen können. Sie können sich jedoch im Aussehen und Verhalten unterscheiden."
"Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.","Was ist ein Beispiel für funktional äquivalente, aber verschiedene Typen?","Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So können beispielsweise die Objekte für die Elemente eines GUI, wie Fenster, Buttons etc. für jedes Betriebssystem eine eigene Implementierung haben. Diese Objekte sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt."
"Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.",Was ist funktionale Äquivalenz?,"Funktionale Äquivalenz bedeutet, dass Objekte verschiedener Typen, aber innerhalb derselben Gruppe, die gleichen Funktionen erfüllen und die gleichen Ergebnisse liefern, auch wenn sie sich im Aussehen und ggf. im Detailverhalten unterscheiden. Diese Unterschiede sind jedoch gewollt und die Substituierbarkeit bleibt davon unberührt."
"Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion ""rückgängig machen"" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion ""ausführen"" auch noch eine ""Rückgängigmachen""-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit ""ausführen"" und ""rückgängig machen"" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.","Was ist der Zweck von Objekten, die eine ""Rückgängigmachen""-Funktion haben?","Der Zweck von Objekten, die eine ""Rückgängigmachen""-Funktion haben, ist es, Aktionen als Objekte zu repräsentieren, die neben einer Funktion ""ausführen"" auch noch eine ""Rückgängigmachen""-Funktion haben, die für jeden Typ von Aktion unterschiedlich ist. Diese Objekte sind dann gegeneinander austauschbar, und die Aktionstypen sind alle Subtypen eines allgemeinen (abstrakten) Typs Aktion. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering."
"Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion ""rückgängig machen"" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion ""ausführen"" auch noch eine ""Rückgängigmachen""-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit ""ausführen"" und ""rückgängig machen"" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.",Was ist der Zweck von abstrakten Typen?,"Abstrakte Typen werden verwendet, um Objekte verschiedener konkreter Typen zu repräsentieren, die eine gemeinsame Schnittstelle haben, aber ein unterschiedliches Verhalten aufweisen. Die Objekte sind austauschbar, da sie die gleichen Methoden besitzen, aber das konkrete Verhalten dieser Methoden kann unterschiedlich sein. Abstrakte Typen werden verwendet, um eine allgemeine Klasse von Objekten zu definieren, ohne sich auf eine bestimmte Implementierung festzulegen."
"Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion ""rückgängig machen"" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion ""ausführen"" auch noch eine ""Rückgängigmachen""-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit ""ausführen"" und ""rückgängig machen"" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.",Was ist die Idee hinter dem Begriff der Substituierbarkeit?,"Die Idee hinter dem Begriff der Substituierbarkeit ist, dass Objekte unterschiedlicher Typen austauschbar sind, wenn sie die gleichen Methoden besitzen und diese auf die gleiche Weise implementieren. Dies ermöglicht es, Objekte verschiedener Typen in einem Programm zu verwenden, ohne dass das Programmverhalten davon beeinflusst wird. Die Substituierbarkeit ist ein wichtiges Prinzip in der objektorientierten Programmierung, da es die Wiederverwendung von Code und die Entwicklung von abstrakten Klassen und Schnittstellen ermöglicht."
"Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die ""rückgängig machen"" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung ""rückgängig Machen leider nicht möglich"" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.","Was ist der Unterschied zwischen einer Aktion, die in dem auszutauschenden Typen definiert ist, und einer Aktion, die in dem austauschenden Typ schlicht fehlt?","Wenn eine Aktion in dem auszutauschenden Typen definiert ist, aber in dem austauschenden Typ fehlt, dann ist diese Aktion nicht austauschbar. Ein Beispiel wäre eine Aktion, für die ""rückgängig machen"" nicht definiert ist, wie zum Beispiel das Speichern. Ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, ist diskutierbar. Die formale Spezifikation, nämlich die Aktion rückgängig zu machen, würde nicht erfüllt, und Objekte vom Typ Speichern sind damit nicht gegen andere Objekte vom Typ Aktion austauschbar."
"Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die ""rückgängig machen"" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung ""rückgängig Machen leider nicht möglich"" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.",Was ist der Unterschied zwischen Subtypen und austauschbaren Typen?,"Subtypen sind im Allgemeinen nicht gegeneinander austauschbar, während austauschbare Typen es sind. Ein Beispiel für einen Subtyp, der nicht gegen einen anderen Subtyp austauschbar ist, ist eine Aktion, für die ""rückgängig machen"" nicht definiert ist, während eine Aktion, für die ""rückgängig machen"" definiert ist, gegen eine Aktion austauschbar ist, für die ""rückgängig machen"" leer implementiert ist."
"Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die ""rückgängig machen"" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung ""rückgängig Machen leider nicht möglich"" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.",Was ist der Unterschied zwischen austauschbaren und nicht austauschbaren Typen?,"Austauschbare Typen sind solche, bei denen eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ vorhanden ist und die gleiche Funktionalität aufweist. Nicht austauschbare Typen hingegen sind solche, bei denen eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ fehlt oder eine andere Funktionalität aufweist. Ein Beispiel für nicht austauschbare Typen ist eine Aktion, für die ""rückgängig machen"" nicht definiert ist, wie beispielsweise Speichern. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar."
"Häufig findet man in einzelnen Projekten und nicht selten in ganzen Firmen Namenskonventionen vor, an die sich alle halten sollten. Namenskonventionen erleichtern nicht nur die Bezeichnerwahl. Indem die Programmiererin sich an bestimmte Regeln halten kann, wird ihre schöpferische Freiheit eingeschränkt, was man durchaus auch als Entlastung empfinden kann. Sie erleichtern auch das Lesen, weil die Leserin, die die Konventionen kennt, die Bedeutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter entschlüsseln kann und sich somit schneller zurechtfindet. Allerdings ist es dazu notwendig, dass die Namenskonventionen genau festgeschrieben sind und dass sich alle darauf einigen. Wenn nämlich jede ihre individuelle Auslegung der Regel hat, dann kann eine (vermeintliche) Namenskonvention mehr Verwirrung stiften als nutzen. ""It would be a mistake to protest against the rules … on the grounds that they limit developer creativity. A consistent style favors rather than hampers creativity by channeling it to where it matters. A large part of the effort of producing software is spent reading existing software and making others read what is being written. Individual vagaries benefit no one; common conventions help everyone."" - Bertrand Meyer",Wozu dienen Namenskonventionen?,"Namenskonventionen erleichtern die Bezeichnerwahl, indem sie die schöpferische Freiheit der Programmiererin einschränken und das Lesen von Code, indem sie die Bedeutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter entschlüsseln."
"Häufig findet man in einzelnen Projekten und nicht selten in ganzen Firmen Namenskonventionen vor, an die sich alle halten sollten. Namenskonventionen erleichtern nicht nur die Bezeichnerwahl. Indem die Programmiererin sich an bestimmte Regeln halten kann, wird ihre schöpferische Freiheit eingeschränkt, was man durchaus auch als Entlastung empfinden kann. Sie erleichtern auch das Lesen, weil die Leserin, die die Konventionen kennt, die Bedeutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter entschlüsseln kann und sich somit schneller zurechtfindet. Allerdings ist es dazu notwendig, dass die Namenskonventionen genau festgeschrieben sind und dass sich alle darauf einigen. Wenn nämlich jede ihre individuelle Auslegung der Regel hat, dann kann eine (vermeintliche) Namenskonvention mehr Verwirrung stiften als nutzen. ""It would be a mistake to protest against the rules … on the grounds that they limit developer creativity. A consistent style favors rather than hampers creativity by channeling it to where it matters. A large part of the effort of producing software is spent reading existing software and making others read what is being written. Individual vagaries benefit no one; common conventions help everyone."" - Bertrand Meyer",Was ist die Bedeutung von einheitlichen Stilrichtlinien in der Softwareentwicklung?,"Einheitliche Stilrichtlinien in der Softwareentwicklung fördern die Kreativität, indem sie die Kreativität auf das Wesentliche konzentrieren. Ein großer Teil der Softwareentwicklung besteht darin, bestehenden Code zu lesen und sicherzustellen, dass der geschriebene Code für andere leicht lesbar ist. Individuelle Eigenheiten sind niemandem von Nutzen, während gemeinsame Konventionen allen helfen."
"Häufig findet man in einzelnen Projekten und nicht selten in ganzen Firmen Namenskonventionen vor, an die sich alle halten sollten. Namenskonventionen erleichtern nicht nur die Bezeichnerwahl. Indem die Programmiererin sich an bestimmte Regeln halten kann, wird ihre schöpferische Freiheit eingeschränkt, was man durchaus auch als Entlastung empfinden kann. Sie erleichtern auch das Lesen, weil die Leserin, die die Konventionen kennt, die Bedeutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter entschlüsseln kann und sich somit schneller zurechtfindet. Allerdings ist es dazu notwendig, dass die Namenskonventionen genau festgeschrieben sind und dass sich alle darauf einigen. Wenn nämlich jede ihre individuelle Auslegung der Regel hat, dann kann eine (vermeintliche) Namenskonvention mehr Verwirrung stiften als nutzen. ""It would be a mistake to protest against the rules … on the grounds that they limit developer creativity. A consistent style favors rather than hampers creativity by channeling it to where it matters. A large part of the effort of producing software is spent reading existing software and making others read what is being written. Individual vagaries benefit no one; common conventions help everyone."" - Bertrand Meyer",Warum sind gemeinsame Konventionen in der Softwareentwicklung wichtig?,"Gemeinsame Konventionen in der Softwareentwicklung sind wichtig, weil ein großer Teil des Aufwands bei der Softwareentwicklung darin besteht, bestehende Software zu lesen und sicherzustellen, dass andere das Geschriebene leicht verstehen können. Individuelle Eigenheiten sind nicht hilfreich, während gemeinsame Konventionen allen Entwicklern helfen."
"In Abschnitt 7.3 hatten wir bereits die Instanziierung als den hauptsächlichen Weg kennengelernt, wie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Kopierens hingewiesen. Darauf wollen wir nun wieder zurückkommen. Klonen/Kopieren ist eine weitere Möglichkeit, neue Instanzen zu erzeugen. Dabei wird eine bestehende Instanz kopiert, d.h. es wird eine neue Instanz erzeugt, die eine identische Kopie der alten Instanz ist. Klonen/Kopieren ist eine Alternative zur Instanziierung, wenn die Klasse eine komplexe Struktur hat, die sich nicht einfach aus Literalen zusammensetzen lässt. Klonen/Kopieren ist auch dann sinnvoll, wenn die Klasse eine komplexe Struktur hat, die sich zwar einfach aus Literalen zusammensetzen lässt, aber die Initialisierung der Literale aufwändig ist. Klonen/Kopieren ist eine weitere Möglichkeit, neue Instanzen von Klassen zu erzeugen. Dabei wird ein bestehendes Objekt kopiert, d.h. es wird eine exakte Kopie des Objekts erstellt. Die Kopie ist dabei eine eigenständige Instanz, die nicht mit dem Original verbunden ist.Die Kopie eines Objekts kann auf zwei Arten erfolgen: 1. Shallow Copy: Hierbei wird das Objekt inklusive seiner Instanzvariablen kopiert. Wird ein Objekt auf diese Weise kopiert, so wird eine exakte Kopie des Objekts erstellt, die Instanzvariablen verweisen jedoch auf die gleichen Objekte wie im Original. 2. Deep Copy: Hierbei wird das Objekt inklusive seiner Instanzvariablen und deren Instanzvariablen kopiert. Wird ein Objekt auf diese Weise kopiert, so wird eine exakte Kopie des Objekts erstellt, die Instanzvariablen verweisen auf exakte Kopien der Objekte, auf die im Original verwiesen wird.",Was ist Klonen/Kopieren?,"Klonen/Kopieren ist eine Methode, um neue Instanzen von Klassen zu erzeugen, bei der ein bestehendes Objekt kopiert wird, um eine exakte Kopie des Objekts zu erstellen, die eigenständig und nicht mit dem Original verbunden ist. Es gibt zwei Arten von Kopien: Shallow Copy und Deep Copy."
"In Abschnitt 7.3 hatten wir bereits die Instanziierung als den hauptsächlichen Weg kennengelernt, wie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Kopierens hingewiesen. Darauf wollen wir nun wieder zurückkommen. Klonen/Kopieren ist eine weitere Möglichkeit, neue Instanzen zu erzeugen. Dabei wird eine bestehende Instanz kopiert, d.h. es wird eine neue Instanz erzeugt, die eine identische Kopie der alten Instanz ist. Klonen/Kopieren ist eine Alternative zur Instanziierung, wenn die Klasse eine komplexe Struktur hat, die sich nicht einfach aus Literalen zusammensetzen lässt. Klonen/Kopieren ist auch dann sinnvoll, wenn die Klasse eine komplexe Struktur hat, die sich zwar einfach aus Literalen zusammensetzen lässt, aber die Initialisierung der Literale aufwändig ist. Klonen/Kopieren ist eine weitere Möglichkeit, neue Instanzen von Klassen zu erzeugen. Dabei wird ein bestehendes Objekt kopiert, d.h. es wird eine exakte Kopie des Objekts erstellt. Die Kopie ist dabei eine eigenständige Instanz, die nicht mit dem Original verbunden ist.Die Kopie eines Objekts kann auf zwei Arten erfolgen: 1. Shallow Copy: Hierbei wird das Objekt inklusive seiner Instanzvariablen kopiert. Wird ein Objekt auf diese Weise kopiert, so wird eine exakte Kopie des Objekts erstellt, die Instanzvariablen verweisen jedoch auf die gleichen Objekte wie im Original. 2. Deep Copy: Hierbei wird das Objekt inklusive seiner Instanzvariablen und deren Instanzvariablen kopiert. Wird ein Objekt auf diese Weise kopiert, so wird eine exakte Kopie des Objekts erstellt, die Instanzvariablen verweisen auf exakte Kopien der Objekte, auf die im Original verwiesen wird.",Wozu dient das Klonen/Kopieren?,"Das Klonen/Kopieren wird verwendet, um eine unabhängige Kopie eines Objekts zu erstellen, das unabhängig von der Originalinstanz geändert werden kann, ohne die Originalinstanz zu beeinflussen. Es wird auch verwendet, um Objekte zu erstellen, die mit den gleichen Daten initialisiert werden sollen, oder um Objekte zu speichern, die später wiederhergestellt werden sollen."
"In Abschnitt 7.3 hatten wir bereits die Instanziierung als den hauptsächlichen Weg kennengelernt, wie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Kopierens hingewiesen. Darauf wollen wir nun wieder zurückkommen. Klonen/Kopieren ist eine weitere Möglichkeit, neue Instanzen zu erzeugen. Dabei wird eine bestehende Instanz kopiert, d.h. es wird eine neue Instanz erzeugt, die eine identische Kopie der alten Instanz ist. Klonen/Kopieren ist eine Alternative zur Instanziierung, wenn die Klasse eine komplexe Struktur hat, die sich nicht einfach aus Literalen zusammensetzen lässt. Klonen/Kopieren ist auch dann sinnvoll, wenn die Klasse eine komplexe Struktur hat, die sich zwar einfach aus Literalen zusammensetzen lässt, aber die Initialisierung der Literale aufwändig ist. Klonen/Kopieren ist eine weitere Möglichkeit, neue Instanzen von Klassen zu erzeugen. Dabei wird ein bestehendes Objekt kopiert, d.h. es wird eine exakte Kopie des Objekts erstellt. Die Kopie ist dabei eine eigenständige Instanz, die nicht mit dem Original verbunden ist.Die Kopie eines Objekts kann auf zwei Arten erfolgen: 1. Shallow Copy: Hierbei wird das Objekt inklusive seiner Instanzvariablen kopiert. Wird ein Objekt auf diese Weise kopiert, so wird eine exakte Kopie des Objekts erstellt, die Instanzvariablen verweisen jedoch auf die gleichen Objekte wie im Original. 2. Deep Copy: Hierbei wird das Objekt inklusive seiner Instanzvariablen und deren Instanzvariablen kopiert. Wird ein Objekt auf diese Weise kopiert, so wird eine exakte Kopie des Objekts erstellt, die Instanzvariablen verweisen auf exakte Kopien der Objekte, auf die im Original verwiesen wird.",Was ist der Unterschied zwischen einer Shallow Copy und einer Deep Copy?,"Bei einer Shallow Copy wird nur die oberste Ebene der Objektstruktur kopiert, während bei einer Deep Copy auch alle Unterobjekte rekursiv kopiert werden. Das heißt, beim flachen Klonen wird nur eine Referenz auf das Unterobjekt kopiert, während beim tiefen Klonen eine neue Kopie des Unterobjekts erstellt wird."
"Die einfachste Form des Kopierens eines Objekts erzeugt ein Objekt gleicher Klasse mit gleichen Variablenbelegungen. Dazu gibt es in SMALLTALK die Methode shallowCopy. Diese Methode liefert eine neue Instanz der Klasse des Empfängers, die in denselben Beziehungen zu denselben anderen Objekten steht wie das Original. Insbesondere werden die Objekte, die die Instanzvariablen des Originals benennen, nicht selbst kopiert. Deswegen nennt man die Kopie flach. Sie erfolgt einfach durch Zuweisung aller Instanzvariablen des Originals an die Instanzvariablen des neuen Objekts, das damit zur Kopie wird. Die Implementierung in SMALLTALK EXPRESS ist die folgende:","Was macht die Methode ""copy"" in SMALLTALK?","Die Methode ""copy"" in SMALLTALK erzeugt eine flache Kopie des Empfängers, indem sie eine neue Instanz der Klasse des Empfängers erstellt und die Instanzvariablen des Originals an die Instanzvariablen des neuen Objekts zuweist."
isVariable unterscheidet dabei zwischen Klassen mit indizierten Instanzvariablen und solchen ohne; isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.,Was macht die Methode isVariable?,Die Methode isVariable unterscheidet zwischen Klassen mit indizierten Instanzvariablen und solchen ohne.
isVariable unterscheidet dabei zwischen Klassen mit indizierten Instanzvariablen und solchen ohne; isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.,Was untersucht die Methode isPointers?,Die Methode isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.
isVariable unterscheidet dabei zwischen Klassen mit indizierten Instanzvariablen und solchen ohne; isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.,Was ist der Unterschied zwischen isVariable und isPointers?,"isVariable ist eine Methode, die zwischen Klassen mit indizierten Instanzvariablen und solchen ohne unterscheidet, während isPointers eine Methode ist, die zwischen Klassen mit zusammengesetzten Objekten und atomaren unterscheidet."
"Nun ist eine flache Kopie aber häufig nicht genug. Es gibt daher noch eine zweite Methode deepCopy, die ein Objekt und alle seine Unterobjekte tief kopiert. Wie der Name nahelegt, unterscheidet sich die Methode deepCopy von shallowCopy darin, dass auch die in Beziehung stehenden (durch die Instanzvariablen benannten) Objekte kopiert werden. Statt einzelner Objekte wird also ein Objektgeflecht kopiert — die Kopie ist tief. Es muss dazu an die beiden tatsächlichen Parameter von put: (Zeilen 566 und 570) lediglich eine Nachricht zum Kopieren der Parameter angehängt werden. Dabei ist jedoch flaches Kopieren Vorsicht geboten: Wenn es sich dabei ebenfalls um ein tiefes Kopieren handelt, dann kann der Kopiervorgang leicht in eine Endlosrekursion geraten.",Was ist der Unterschied zwischen deepCopy und shallowCopy?,"deepCopy kopiert auch die in Beziehung stehenden Objekte, während shallowCopy nur einzelne Objekte kopiert. deepCopy erstellt also eine Kopie des Objektgeflechts, während shallowCopy nur eine flache Kopie erstellt."
"Nun ist die Festlegung, ob die Kopien ihrer Instanzen tiefe oder flache sein sollen, gelegentlich ein Charakteristikum der Klasse selbst. Jede Klasse erbt deswegen von Object eine Methode copy, die standardmäßig (also in Object) einfach shallowCopy aufruft (warum es nicht deepCopy aufruft, sollte klar sein) und die die erbende Klasse entsprechend ihren eigenen Konditionen überschreiben kann. Es ist so möglich, die Kopiertiefe von Objektstrukturen selbst zu bestimmen, indem man copy für manche Klassen deepCopy aufrufen lässt und das tiefe Kopieren durch Instanzen terminiert, deren Klassen shallowCopy aufrufen lassen.",Wie kann die Kopiertiefe von Objektstrukturen bestimmt werden?,"Die Kopiertiefe von Objektstrukturen kann bestimmt werden, indem man für manche Klassen deepCopy aufruft und das tiefe Kopieren durch Instanzen terminiert, deren Klassen shallowCopy aufrufen lassen."
Manchmal darf bei Kopier- oder Konvertieroperationen kein Objekt des gleichen Typs zurückgegeben werden. In diesen Fällen sollte statt self class (Zeile 554) self species aufgerufen werden:,Was ist der Unterschied zwischen self class und self species in Smalltalk?,"In Smalltalk, self class gibt den Klassentyp des empfangenden Objekts zurück, während self species den Metaklassentyp des empfangenden Objekts zurückgibt."
Manchmal darf bei Kopier- oder Konvertieroperationen kein Objekt des gleichen Typs zurückgegeben werden. In diesen Fällen sollte statt self class (Zeile 554) self species aufgerufen werden:,Wann sollte self class und wann self species in Smalltalk verwendet werden?,"Wenn man eine Kopie oder Konvertierung durchführen möchte und kein Objekt des gleichen Typs zurückgegeben werden darf, sollte man self species anstelle von self class verwenden."
"Die Methode species war uns schon einmal begegnet, und zwar in Kurseinheit 1, Abschnitt 4.6.4, Zeile 244. Sie gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist z. B. bei der Methode collect:, ausgeführt auf einer Instanz von Interval, sinnvoll, da collect: hier kein Intervall zurückgeben kann. So kann beispielsweise die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. Entsprechend ist in der Klasse Interval die Methode species als implementiert.",Was macht die Methode species?,"Die Methode species gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Zum Beispiel bei der Methode collect:, die auf einer Instanz von Interval ausgeführt wird, ist es sinnvoll, die Methode species zu überschreiben, da collect: kein Intervall zurückgeben kann. So kann die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. In der Klasse Interval ist die Methode species als implementiert."
"Die Klasse Object definiert die Eigenschaften, die allen Objekten, einschließlich Array-Objekten, gemeinsam sind. Hierbei handelt es sich nicht um Felder (Instanzvariablen), sondern um elf Methoden. Diese sind: Object clone(): Zum Erzeugen von Kopien (vergleichbar mit SMALLTALK's copy). boolean equals(Object): Zum Test auf Gleichheit anstelle von Identität (entsprechend SMALLTALK's =). String toString(): Gibt eine String-Repräsentation des Objekts zurück (entsprechend SMALLTALK's printString). Class<? extends Object> getClass(): Zur Ermittlung des Klassentyps (entsprechend SMALLTALK's class). int hashCode(): Zur Speicherung von Objekten in Hash-Tabellen (entsprechend SMALLTALK's hash). void finalize(): Wird vom Garbage Collector aufgerufen, wenn das Objekt aus dem Speicher entfernt wird (dies ermöglicht das Freigeben von externen Ressourcen, die mit dem Objekt verbunden sind, wie z. B. das Schließen von Dateien). void notify() und void notifyAll(): Zur Benachrichtigung von Threads, die auf den Monitor des Objekts warten. void wait(): In drei Versionen, um den ausführenden Thread zum Warten zu bringen, entweder bis dem Objekt ein Notify gesendet wird oder ein anderes Ereignis eintritt.","Was sind die Methoden, die in der Klasse Object definiert sind?","Die Klasse Object definiert die Methoden clone(), equals(Object), toString(), getClass(), hashCode(), finalize(), notify(), notifyAll() und wait()."
"Die Klasse Object definiert die Eigenschaften, die allen Objekten, einschließlich Array-Objekten, gemeinsam sind. Hierbei handelt es sich nicht um Felder (Instanzvariablen), sondern um elf Methoden. Diese sind: Object clone(): Zum Erzeugen von Kopien (vergleichbar mit SMALLTALK's copy). boolean equals(Object): Zum Test auf Gleichheit anstelle von Identität (entsprechend SMALLTALK's =). String toString(): Gibt eine String-Repräsentation des Objekts zurück (entsprechend SMALLTALK's printString). Class<? extends Object> getClass(): Zur Ermittlung des Klassentyps (entsprechend SMALLTALK's class). int hashCode(): Zur Speicherung von Objekten in Hash-Tabellen (entsprechend SMALLTALK's hash). void finalize(): Wird vom Garbage Collector aufgerufen, wenn das Objekt aus dem Speicher entfernt wird (dies ermöglicht das Freigeben von externen Ressourcen, die mit dem Objekt verbunden sind, wie z. B. das Schließen von Dateien). void notify() und void notifyAll(): Zur Benachrichtigung von Threads, die auf den Monitor des Objekts warten. void wait(): In drei Versionen, um den ausführenden Thread zum Warten zu bringen, entweder bis dem Objekt ein Notify gesendet wird oder ein anderes Ereignis eintritt.",Was sind die Eigenschaften der Klasse Object in Java?,"Die Klasse Object definiert die Eigenschaften, die allen Objekten, einschließlich Array-Objekten, gemeinsam sind. Hierbei handelt es sich um elf Methoden, darunter clone() zum Erzeugen von Kopien, equals(Object) zum Test auf Gleichheit anstelle von Identität, toString() zur Rückgabe einer String-Repräsentation des Objekts, getClass() zur Ermittlung des Klassentyps, hashCode() zur Speicherung von Objekten in Hash-Tabellen, und finalize() zur Freigabe von externen Ressourcen, die mit dem Objekt verbunden sind."
"In Java ist jeder Typ ein Subtyp von Object. Dies gilt auch für Interfaces. Es ist jedoch zu beachten, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können.","Was bedeutet es, dass jeder Typ in Java ein Subtyp von Object ist?","Das bedeutet, dass jeder Typ in Java eine Unterklasse von Object ist und somit die Methoden von Object erbt."
"In Java ist jeder Typ ein Subtyp von Object. Dies gilt auch für Interfaces. Es ist jedoch zu beachten, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können.","Was sind die Auswirkungen der Tatsache, dass Interfaces in Java auch Subtypen von Object sind?","Interfaces können nicht wie Klassen instanziiert werden, aber sie können als Typen für Variablen, Parameter und Rückgabewerte verwendet werden. Da Interfaces auch Subtypen von Object sind, können sie daher überall dort verwendet werden, wo ein Object erwartet wird."
"In Java ist jeder Typ ein Subtyp von Object. Dies gilt auch für Interfaces. Es ist jedoch zu beachten, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können.",Was ist der Subtyp von jedem Typ in Java?,"In Java ist jeder Typ ein Subtyp von Object, was auch für Interfaces gilt."
"In Java ist jeder Typ ein Subtyp von Object. Dies gilt auch für Interfaces. Es ist jedoch zu beachten, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können.",Was ist in Java der Unterschied zwischen Klassen und Interfaces?,"In Java sind Klassen die Blaupausen für Objekte, die definieren, welche Attribute und Methoden ein Objekt besitzt. Interfaces hingegen definieren nur eine Schnittstelle, die von Klassen implementiert werden kann. Sie spezifizieren eine Menge von Methodensignaturen, die eine Klasse implementieren muss, wenn sie das Interface implementiert. Im Gegensatz zu Klassen können Interfaces keine Attribute haben und die Methoden in Interfaces sind immer abstrakt."
"In Java ist jeder Typ ein Subtyp von Object. Dies gilt auch für Interfaces. Es ist jedoch zu beachten, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können.",Warum können Interfaces in Java nicht von Klassen abgeleitet werden?,"Interfaces in Java können nicht von Klassen abgeleitet werden, weil sie nur eine Schnittstelle definieren und keine Implementierung enthalten. Sie spezifizieren lediglich eine Menge von Methodensignaturen, die eine Klasse implementieren muss, wenn sie das Interface implementiert. Daher können Interfaces nicht von Klassen abgeleitet werden, sondern nur von anderen Interfaces."
"In Java ist jeder Typ ein Subtyp von Object. Dies gilt auch für Interfaces. Es ist jedoch zu beachten, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können.",Welche Rolle spielen Interfaces in Java?,"Interfaces in Java spielen eine wichtige Rolle bei der Abstraktion und der Schaffung von Schnittstellen, die von mehreren Klassen implementiert werden können. Sie ermöglichen es, die Abhängigkeiten zwischen Klassen zu verringern und die Code-Wiederverwendung zu erhöhen. Interfaces können auch als Verträge zwischen Klassen betrachtet werden, die sicherstellen, dass eine Klasse eine bestimmte Funktionalität bereitstellt."
"Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem Interface veröffentlichten noch weitere öffentliche (public deklarierte) Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces einer Klasse unterschiedliche Methodenmengen zur Verfügung stellen können. Da auf eine Variable, die mit einem Interfacetyp deklariert wurde, aber immer nur die Methoden aufgerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgreichen Prüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten können), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. So kann beispielsweise ein Ein- und Ausgabestrom als Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben:",Wozu können verschiedene Interfaces einer Klasse dienen?,"Unterschiedliche Interfaces einer Klasse können unterschiedliche Methodenmengen zur Verfügung stellen. Dadurch können mithilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. Zum Beispiel kann eine Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben."
"Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem Interface veröffentlichten noch weitere öffentliche (public deklarierte) Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces einer Klasse unterschiedliche Methodenmengen zur Verfügung stellen können. Da auf eine Variable, die mit einem Interfacetyp deklariert wurde, aber immer nur die Methoden aufgerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgreichen Prüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten können), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. So kann beispielsweise ein Ein- und Ausgabestrom als Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben:",Was ist der Zweck von Interfaces in der objektorientierten Programmierung?,"Interfaces in der objektorientierten Programmierung dienen dazu, unterschiedliche Sichten auf ein Objekt zu gewährleisten. Sie definieren eine Menge von Methoden, die ein Objekt zur Verfügung stellen muss. Durch die Verwendung von Interfaces können unterschiedliche Methodenmengen für eine Klasse definiert werden, was die Flexibilität und Wiederverwendbarkeit von Klassen erhöht."
"Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem Interface veröffentlichten noch weitere öffentliche (public deklarierte) Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces einer Klasse unterschiedliche Methodenmengen zur Verfügung stellen können. Da auf eine Variable, die mit einem Interfacetyp deklariert wurde, aber immer nur die Methoden aufgerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgreichen Prüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten können), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. So kann beispielsweise ein Ein- und Ausgabestrom als Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben:",Was sind die Vorteile von Interfaces?,"Interfaces ermöglichen es, unterschiedliche Sichten auf ein Objekt zu gewähren, indem sie unterschiedliche Methodenmengen zur Verfügung stellen. Dadurch können beispielsweise auf eine Variable, die mit einem Interfacetyp deklariert wurde, nur die Methoden aufgerufen werden, die der Interfacetyp veröffentlicht. Dies führt zu einer besseren Kapselung und erhöht die Sicherheit, da Laufzeitfehler vermieden werden können."
"Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.",Was ist ein Klient einer Instanz?,Ein Klient von Instanz einer Klasse kann auf die Methoden und Variablen der Klasse zugreifen.
"Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.",Was ist der Zweck von Interfaces in der Programmierung?,"Interfaces definieren eine Schnittstelle für Klassen, die eine bestimmte Funktionalität bereitstellen. Sie legen fest, welche Methoden eine Klasse implementieren muss, um ein bestimmtes Interface zu unterstützen. Durch Interfaces können Klienten auf die Funktionalität einer Klasse zugreifen, ohne von der konkreten Implementierung abhängig zu sein. In dem oben genannten Kontext können verschiedene Klienten entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat."
"Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.",Was ist der Zweck von Interfaces in Java?,"Interfaces in Java definieren einen Vertrag, der festlegt, welche Methoden eine Klasse implementieren muss, um ein bestimmtes Verhalten zu bieten. Sie werden verwendet, um die Schnittstelle zwischen Klienten und Diensten zu definieren, und ermöglichen es, die Abhängigkeit von der Implementierung zu verringern. Durch die Verwendung von Interfaces können Klienten auf die Methoden zugreifen, ohne die tatsächliche Implementierung zu kennen."
"Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.","Wie können Klienten auf die Methoden zugreifen, ohne die tatsächliche Implementierung zu kennen?","Klienten können auf die Methoden zugreifen, ohne die tatsächliche Implementierung zu kennen, indem sie die Interfaces verwenden, die die Schnittstelle zwischen Klienten und Diensten definieren. Die Interfaces definieren den Vertrag, welche Methoden eine Klasse implementieren muss, um ein bestimmtes Verhalten zu bieten, und die Klienten können auf die Methoden zugreifen, indem sie die Interfaces als Typen verwenden."
"Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.",Was ist der Vorteil von Interfaces in Java?,"Der Vorteil von Interfaces in Java ist, dass sie die Abhängigkeit von der Implementierung verringern, da Klienten auf die Methoden zugreifen können, ohne die tatsächliche Implementierung zu kennen. Dies ermöglicht es, die Klassen zu ändern, ohne die Klienten zu beeinflussen, und erleichtert die Wartung und Erweiterung des Codes."
"Umgangen werden kann diese Zugriffsbeschränkung über Interfaces in Java immer dann, wenn die Klasse, von der das verwendete Objekt eine Instanz ist, ebenfalls als Typ zur Verfügung steht. Man kann in Variablendeklarationen dann genauso gut die Klasse als Typ verwenden. So könnte man sowohl in ""WillNurLesen"" die Variable ""eingabe"" als auch in ""WillNurSchreiben"" die Variable ""ausgabe"" mit dem Typ ""IOStream"" deklarieren, hätte damit jedoch keine syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr. C-Sharp geht hier einen Schritt weiter und ermöglicht Klassendefinitionen zumindest, ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen (s. Kurseinheit 5, Abschnitt 50.4.2). Seit Java 8 kann man allerdings in Interfaces auch statische Methoden definieren, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff mehr auf die Klassen, die deswegen als package local deklariert und die somit vollständig hinter dem Interface als Schnittstelle verborgen werden können.",Was ist der Unterschied zwischen der Verwendung von Interfaces und Klassen als Variablentypen in Java?,"Wenn die Klasse, von der das verwendete Objekt eine Instanz ist, als Typ zur Verfügung steht, kann man in Java in Variablendeklarationen genauso gut die Klasse als Typ verwenden. Dann hat man jedoch keine syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr. Seit Java 8 können in Interfaces auch statische Methoden definiert werden, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff mehr auf die Klassen, die somit vollständig hinter dem Interface als Schnittstelle verborgen werden können."
"Umgangen werden kann diese Zugriffsbeschränkung über Interfaces in Java immer dann, wenn die Klasse, von der das verwendete Objekt eine Instanz ist, ebenfalls als Typ zur Verfügung steht. Man kann in Variablendeklarationen dann genauso gut die Klasse als Typ verwenden. So könnte man sowohl in ""WillNurLesen"" die Variable ""eingabe"" als auch in ""WillNurSchreiben"" die Variable ""ausgabe"" mit dem Typ ""IOStream"" deklarieren, hätte damit jedoch keine syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr. C-Sharp geht hier einen Schritt weiter und ermöglicht Klassendefinitionen zumindest, ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen (s. Kurseinheit 5, Abschnitt 50.4.2). Seit Java 8 kann man allerdings in Interfaces auch statische Methoden definieren, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff mehr auf die Klassen, die deswegen als package local deklariert und die somit vollständig hinter dem Interface als Schnittstelle verborgen werden können.",Was ist der Unterschied zwischen der Verwendung von Interfaces und Klassen als Typ in Java?,"In Java können Variablendeklarationen entweder mit der Klasse oder mit dem Interface als Typ erfolgen. Wenn man die Klasse als Typ verwendet, hat man syntaktische Unterstützung bei der Benutzung der Variable, aber keine Zugriffsbeschränkung. Wenn man das Interface als Typ verwendet, hat man eine Zugriffsbeschränkung, aber keine syntaktische Unterstützung. Seit Java 8 können in Interfaces auch statische Methoden definiert werden, die neue Instanzen von Klassen, die das Interface implementieren, zurückliefern. Dadurch können die Konstruktoren der Klassen ersetzt und die Klassen hinter dem Interface als Schnittstelle verborgen werden."
"Umgangen werden kann diese Zugriffsbeschränkung über Interfaces in Java immer dann, wenn die Klasse, von der das verwendete Objekt eine Instanz ist, ebenfalls als Typ zur Verfügung steht. Man kann in Variablendeklarationen dann genauso gut die Klasse als Typ verwenden. So könnte man sowohl in ""WillNurLesen"" die Variable ""eingabe"" als auch in ""WillNurSchreiben"" die Variable ""ausgabe"" mit dem Typ ""IOStream"" deklarieren, hätte damit jedoch keine syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr. C-Sharp geht hier einen Schritt weiter und ermöglicht Klassendefinitionen zumindest, ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen (s. Kurseinheit 5, Abschnitt 50.4.2). Seit Java 8 kann man allerdings in Interfaces auch statische Methoden definieren, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff mehr auf die Klassen, die deswegen als package local deklariert und die somit vollständig hinter dem Interface als Schnittstelle verborgen werden können.",Was ermöglichen Interfaces in Java und C-Sharp?,"Interfaces in Java ermöglichen es, die Variablen mit dem Typ der Klasse zu deklarieren, die die Instanz des Objekts bereitstellt, und somit die syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variablen zu behalten. C-Sharp geht noch weiter und ermöglicht es, Klassendefinitionen ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen und somit die Konstruktoren der Klassen zu ersetzen. Seit Java 8 können in Interfaces auch statische Methoden definiert werden, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen."
"Interfaces dienen aber nicht nur der Beschränkung des Zugriffs wie im obigen Beispiel — sie dienen auch der besseren Austauschbarkeit von Klassen. Und das bringt uns zurück zum eingangs in Kapitel 43 benutzten Beispiel (Zeile 1051 ff.): Dadurch, dass die Variable ""liste"" mit dem Typ ""List"" (ein Interface) und nicht ""ArrayList"" (eine Klasse) deklariert wurde, können ihr auch Instanzen anderer Klassen als ""ArrayList"" zugewiesen werden, solange sie nur dasselbe Interface implementieren. Das Interface als Typ der Variable verlangt lediglich, dass alle in ihm versammelten Methoden von den Objekten, auf die die Variable per Typsystem verweisen darf, auch angeboten werden, und das wird dadurch sichergestellt, dass der Typ der rechten Seite aller Zuweisungen zur Variablen konform zum Typ der linken Seite sein muss. Die Zuweisungskompatibilität ist in Java also an die Typkonformität gebunden, und zwar an die nominale.",Wozu dienen Interfaces in Java?,"Interfaces in Java dienen der Beschränkung des Zugriffs und der besseren Austauschbarkeit von Klassen. Durch die Verwendung von Interfaces als Typen von Variablen können Objekte verschiedener Klassen zugewiesen werden, solange sie dasselbe Interface implementieren."
"Eine weitere, vergleichsweise häufig verwendete Möglichkeit des Einsatzes von Interfaces ist die als sog. Tagging oder Marker interfaces. Ein Tagging oder Marker Interface hat in der Regel keine eigenen Methodendeklarationen, sondern dient lediglich der Filterung von Variablenwerten. ""Serializable"" wäre ein solches Interface. Da in Java die vom Compiler statisch geprüfte Zuweisungskompatibilität ja Namenskonformität verlangt, kann die Typisierung einer Variable mit dem Interface ""Markiert"" erzwingen, dass dieser Variable nur Instanzen solcher Klassen zugewiesen werden, die das Interface ""Markiert"" zu implementieren deklarieren. Da das Interface aber keine Auflagen macht (keine Methodendeklarationen vorgibt, die von der Klasse mit Definitionen versehen werden müssen), ist die Implementierung des Interfaces für die Klasse zunächst ohne Konsequenzen. Die durch das Interface erfolgte Markierung der Klassen (bzw. deren Instanzen) kann jedoch zur Übersetzungszeit vom Compiler (s. o.) und zur Laufzeit durch einen Typtest (s. Abschnitt 44.2) überprüft werden. Ein konkretes Beispiel für ein Marker-Interface in Java ist das Interface ""Serializable"", mit dessen Implementierung eine Klasse deklariert, dass ihre Instanzen serialisiert werden können. Die Serialisierung wird aber nicht von der Klasse selbst vorgenommen, sondern von einer anderen; die Klasse muss also zu ihrer Serialisierung nichts weiter beitragen. Seit Java 5 würde man allerdings solche Marker-Interfaces eher durch Metadaten (auch Annotationen genannt; s. Abschnitt 47.4) ersetzen, so wie das in C-Sharp schon länger gehandhabt wird (s. Abschnitt 50.4 in Kurseinheit 5). Interfaces erhöhen die Komplexität des Codes und können durch Metadaten ersetzt werden, die nur Informationen enthalten, aber keine Methoden deklarieren.",Was sind Tagging oder Marker Interfaces in Java?,"Tagging oder Marker Interfaces in Java haben keine eigenen Methodendeklarationen, sondern dienen lediglich der Filterung von Variablenwerten. Sie können erzwingen, dass einer Variablen nur Instanzen solcher Klassen zugewiesen werden, die das Interface zu implementieren deklarieren. Die Implementierung des Interfaces für die Klasse ist zunächst ohne Konsequenzen, kann aber zur Übersetzungszeit vom Compiler und zur Laufzeit durch einen Typtest überprüft werden."
"Javas Interface-als-Typ-Konzept ist ziemlich interessant und vielleicht sogar der größte einzelne Beitrag Javas zur objektorientierten Programmierung. In der Programmierpraxis scheint es jedoch, sieht man einmal von großen Frameworks ab, nur langsam anzukommen. Das mag zum einen an der schlechten Verkaufsstrategie liegen („Ersatz für Mehrfachvererbung“ — jede Anfängerin merkt nach fünf Minuten, dass das nicht stimmt), zum anderen aber auch an der Vergrößerung des Programmumfangs, die der parallelen Definition von Klassen und Interfaces geschuldet ist (die auch den Wartungsaufwand erhöhen kann, obwohl ja Interfaces eigentlich die Wartung vereinfachen sollen). Für so manche Programmiererin scheinen die Möglichkeiten, die Schnittstelle einer Klasse mittels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, völlig auszureichen. Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Klienten sowie eine (häufig vorschnelle) Festlegung von Variablen auf Instanzen einer Klasse.",Was ist das Interface-als-Typ-Konzept in Java?,"Javas Interface-als-Typ-Konzept ist ein Mechanismus, bei dem Interfaces als Typen verwendet werden können. Dies ermöglicht es, eine Schnittstelle einer Klasse unabhängig von ihrer Implementierung zu definieren und verschiedene Klassen können diese Schnittstelle implementieren. Das Interface-als-Typ-Konzept ist ein wichtiger Beitrag von Java zur objektorientierten Programmierung, wird aber in der Praxis nur langsam angenommen."
"Javas Interface-als-Typ-Konzept ist ziemlich interessant und vielleicht sogar der größte einzelne Beitrag Javas zur objektorientierten Programmierung. In der Programmierpraxis scheint es jedoch, sieht man einmal von großen Frameworks ab, nur langsam anzukommen. Das mag zum einen an der schlechten Verkaufsstrategie liegen („Ersatz für Mehrfachvererbung“ — jede Anfängerin merkt nach fünf Minuten, dass das nicht stimmt), zum anderen aber auch an der Vergrößerung des Programmumfangs, die der parallelen Definition von Klassen und Interfaces geschuldet ist (die auch den Wartungsaufwand erhöhen kann, obwohl ja Interfaces eigentlich die Wartung vereinfachen sollen). Für so manche Programmiererin scheinen die Möglichkeiten, die Schnittstelle einer Klasse mittels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, völlig auszureichen. Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Klienten sowie eine (häufig vorschnelle) Festlegung von Variablen auf Instanzen einer Klasse.",Warum wird das Interface-als-Typ-Konzept in Java nur langsam angenommen?,"Javas Interface-als-Typ-Konzept wird nur langsam angenommen, weil die Verkaufsstrategie schlecht ist und es den Programmumfang erhöht, was auch den Wartungsaufwand erhöhen kann. Einige Programmiererinnen scheinen die Möglichkeiten, die Schnittstelle einer Klasse mittels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, auszureichen. Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Klienten sowie eine (häufig vorschnelle) Festlegung von Variablen auf Instanzen einer Klasse."
"In Zu-1-Beziehungen sendet man häufig Nachrichten an das Objekt, auf das die betreffende Variable verweist.",Wie sendet man Nachrichten in Zu-1-Beziehungen?,"In Zu-1-Beziehungen in SMALLTALK sendet man oft Nachrichten direkt an das Objekt, auf das die betreffende Variable verweist."
"Wenn Sie dasselbe mit Zu-n-Beziehungen tun möchten, erreicht die Nachricht – bei gleicher Vorgehensweise – nicht mehr die logisch in Beziehung stehenden Objekte, sondern das Zwischenobjekt, das die Beziehung selbst repräsentiert (das ja der Wert der Variable ist). Dieses Zwischenobjekt kann jedoch mit dieser Nachricht nichts anfangen. Um die Nachricht stattdessen an alle von diesem Zwischenobjekt referenzierten Objekte zu senden, verwendet man die Nachricht do: aBlock, wobei aBlock ein Block ist, der mit einem Parameter parametrisiert ist und der für jedes Element des Arrays genau einmal (mit dem Element als tatsächlichem Parameter) aufgerufen wird.",Wie sendet man Nachrichten in Zu-n-Beziehungen?,"Bei Zu-n-Beziehungen erreicht die Nachricht nicht mehr die logisch in Beziehung stehenden Objekte, sondern das Zwischenobjekt, das die Beziehung selbst repräsentiert (der Wert der Variable). Um die Nachricht stattdessen an alle von diesem Zwischenobjekt referenzierten Objekte zu senden, verwendet man die Nachricht do: aBlock, wobei aBlock ein Block ist, der mit einem Parameter parametrisiert ist und der für jedes Element des Arrays genau einmal (mit dem Element als tatsächlichem Parameter) aufgerufen wird."
"Java ist in vielerlei Hinsicht (und vor allem im Vergleich zu SMALLTALK) eine konventionelle Programmiersprache. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die - jede für sich - immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist jedoch kein direkt ausführbarer Maschinencode, sondern ein sogenannter Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Das sonst übliche Linken der einzelnen Klassen (genauer: des zu den Klassen gehörenden Bytecodes, die sogenannten Class Files) wird dabei durch das Class Loading der JVM ersetzt. Vorteile des Ganzen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit: Java-Programme können, soweit sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen (man denke z. B. an die unterschiedliche Handhabung von Groß-/Kleinschreibung - Java ist case sensitive, Windows nicht!), auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt.",Was ist Java?,"Java ist eine konventionelle Programmiersprache, die in vielerlei Hinsicht SMALLTALK ähnelt, aber auch Unterschiede aufweist. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss."
"Java ist in vielerlei Hinsicht (und vor allem im Vergleich zu SMALLTALK) eine konventionelle Programmiersprache. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die - jede für sich - immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist jedoch kein direkt ausführbarer Maschinencode, sondern ein sogenannter Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Das sonst übliche Linken der einzelnen Klassen (genauer: des zu den Klassen gehörenden Bytecodes, die sogenannten Class Files) wird dabei durch das Class Loading der JVM ersetzt. Vorteile des Ganzen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit: Java-Programme können, soweit sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen (man denke z. B. an die unterschiedliche Handhabung von Groß-/Kleinschreibung - Java ist case sensitive, Windows nicht!), auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt.",Wie werden Java-Programme gespeichert und ausgeführt?,"Java-Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Die JVM ermöglicht eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit."
"Java ist in vielerlei Hinsicht (und vor allem im Vergleich zu SMALLTALK) eine konventionelle Programmiersprache. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die - jede für sich - immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist jedoch kein direkt ausführbarer Maschinencode, sondern ein sogenannter Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Das sonst übliche Linken der einzelnen Klassen (genauer: des zu den Klassen gehörenden Bytecodes, die sogenannten Class Files) wird dabei durch das Class Loading der JVM ersetzt. Vorteile des Ganzen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit: Java-Programme können, soweit sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen (man denke z. B. an die unterschiedliche Handhabung von Groß-/Kleinschreibung - Java ist case sensitive, Windows nicht!), auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt.",Was sind die Vorteile von Java gegenüber anderen Programmiersprachen?,"Die Vorteile von Java gegenüber anderen Programmiersprachen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit. Java-Programme können auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt, sofern sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen."
"Während Java als Programmiersprache anfangs noch recht klein und überschaubar war (zumindest im Vergleich zu C++, einem ihrer Hauptkonkurrenten), so ist die Sprachdefinition heute ein Moloch. Mit dem wachsenden Nutzerkreis sind auch die Anforderungen an die Sprache gewachsen, und mit dem Java Community Process wurde aktiven Entwicklern die Möglichkeit eingeräumt, Vorschläge zur Spracherweiterung zu machen. Dabei ist jedoch - aufgrund der mittlerweile riesigen Menge an Software, die in Java geschrieben ist - stets auf Rückwärtskompatibilität zu achten, so dass revolutionäre Verbesserungen kaum möglich sind; stattdessen wird hinzugefügt. Das unterliegende Programmiermodell ist so immer dasselbe geblieben - und wird es wohl auch immer bleiben.",Was ist der Java Community Process?,"Der Java Community Process ist ein Prozess, bei dem aktiven Entwicklern die Möglichkeit eingeräumt wird, Vorschläge zur Spracherweiterung von Java zu machen. Dabei ist jedoch auf Rückwärtskompatibilität zu achten, um die riesige Menge an Software, die in Java geschrieben ist, nicht zu beeinträchtigen."
"Während Java als Programmiersprache anfangs noch recht klein und überschaubar war (zumindest im Vergleich zu C++, einem ihrer Hauptkonkurrenten), so ist die Sprachdefinition heute ein Moloch. Mit dem wachsenden Nutzerkreis sind auch die Anforderungen an die Sprache gewachsen, und mit dem Java Community Process wurde aktiven Entwicklern die Möglichkeit eingeräumt, Vorschläge zur Spracherweiterung zu machen. Dabei ist jedoch - aufgrund der mittlerweile riesigen Menge an Software, die in Java geschrieben ist - stets auf Rückwärtskompatibilität zu achten, so dass revolutionäre Verbesserungen kaum möglich sind; stattdessen wird hinzugefügt. Das unterliegende Programmiermodell ist so immer dasselbe geblieben - und wird es wohl auch immer bleiben.","Warum ist es schwierig, die Sprache Java zu revolutionieren?","Es ist schwierig, die Sprache Java zu revolutionieren, weil aufgrund der riesigen Menge an Software, die in Java geschrieben ist, stets auf Rückwärtskompatibilität geachtet werden muss. Zudem ist das Programmiermodell von Java seit Beginn an dasselbe geblieben und wird wohl auch immer gleich bleiben."
"Die grundlegenden Werkzeuge der Java-Programmierung sind neben dem Editor der Java-Compiler Javac, die JVM, die Java-Klassenbibliothek (das sogenannte Application Programming Interface, API) und natürlich die Dokumentation (API-Dokumentation und Sprachdefinition). Gerade für die Java-Programmierung gibt es jedoch zahlreiche integrierte Entwicklungsumgebungen (IDEs), und es ist niemandem zu raten, diese Werkzeuge links liegen zu lassen. Diejenigen, die einmal einen Teil ihrer wertvollen Lebenszeit mit dem richtigen Setzen des sogenannten Class Path verbracht haben, wissen, wovon ich rede. Auf der anderen Seite sind diese IDEs sehr komplex und erschlagen gerade Anfänger mit ihrem Funktionsumfang. Das ist auch der Grund, warum in diesem Kurs keine Java-Installation von Ihnen verlangt wird. Wer es aber wissen möchte und mit Java experimentieren möchte, den will ich keinesfalls davon abhalten.",Was sind die grundlegenden Werkzeuge der Java-Programmierung?,"Die grundlegenden Werkzeuge der Java-Programmierung sind der Editor, der Java-Compiler Javac, die JVM, die Java-Klassenbibliothek (das sogenannte Application Programming Interface, API) und die Dokumentation (API-Dokumentation und Sprachdefinition)."
"Um ein Java-Programm, bestehend aus einer Menge von Class Files, auszuführen, muss man eine Klasse angeben, die eine Startmethode besitzt. Diese Startmethode heißt immer gleich; ihre Signatur hat die leicht zu merkende und immer wieder gerne eingetippte Form: public static void main(String[] args) Die main-Methode ist eine normale Instanzmethode, die zu einem beliebigen Objekt gehören könnte. Sie ist aber als statische Methode deklariert, d.h. sie gehört keinem Objekt an, sondern der Klasse selbst. Sie wird daher auch nicht über ein Objekt, sondern über den Klassennamen aufgerufen.",Wie wird ein Java-Programm ausgeführt?,"Um ein Java-Programm auszuführen, muss man eine Klasse angeben, die eine Startmethode mit der Signatur public static void main(String[] args) besitzt. Diese Startmethode ist eine statische Methode, die nicht zu einem Objekt gehört, sondern der Klasse selbst. Sie wird über den Klassennamen aufgerufen. Die main-Methode ist eine normale Instanzmethode, die zu einem beliebigen Objekt gehören kann, das die main-Methode implementiert."
"Um ein Java-Programm, bestehend aus einer Menge von Class Files, auszuführen, muss man eine Klasse angeben, die eine Startmethode besitzt. Diese Startmethode heißt immer gleich; ihre Signatur hat die leicht zu merkende und immer wieder gerne eingetippte Form: public static void main(String[] args) Die main-Methode ist eine normale Instanzmethode, die zu einem beliebigen Objekt gehören könnte. Sie ist aber als statische Methode deklariert, d.h. sie gehört keinem Objekt an, sondern der Klasse selbst. Sie wird daher auch nicht über ein Objekt, sondern über den Klassennamen aufgerufen.",Wie startet man ein Java-Programm?,"Um ein Java-Programm auszuführen, muss man eine Klasse angeben, die eine main-Methode besitzt. Die Signatur der main-Methode hat die Form public static void main(String[] args). Die main-Methode ist eine normale Instanzmethode, die zu einem beliebigen Objekt gehören kann, das die main-Methode implementiert."
"Um ein Java-Programm, bestehend aus einer Menge von Class Files, auszuführen, muss man eine Klasse angeben, die eine Startmethode besitzt. Diese Startmethode heißt immer gleich; ihre Signatur hat die leicht zu merkende und immer wieder gerne eingetippte Form: public static void main(String[] args) Die main-Methode ist eine normale Instanzmethode, die zu einem beliebigen Objekt gehören könnte. Sie ist aber als statische Methode deklariert, d.h. sie gehört keinem Objekt an, sondern der Klasse selbst. Sie wird daher auch nicht über ein Objekt, sondern über den Klassennamen aufgerufen.",Wie heißt die Startmethode in Java?,"Die Startmethode in Java heißt ""public static void main(String[] args)""."
"Dabei ist ""main"" der Name der Methode; was die anderen Elemente bedeuten, werden Sie im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann einfach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter. Klassen werden in Java wie in SMALLTALK per Konvention immer großgeschrieben.",Was ist der Zweck der main-Methode in Java?,"Die main-Methode ist der Einstiegspunkt für die Ausführung eines Java-Programms. Das Betriebssystem übergibt der JVM den Namen der Klasse, die die main-Methode enthält, als Parameter, um das Programm auszuführen."
"Dabei ist ""main"" der Name der Methode; was die anderen Elemente bedeuten, werden Sie im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann einfach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter. Klassen werden in Java wie in SMALLTALK per Konvention immer großgeschrieben.",Was ist die JVM und wie wird sie aufgerufen?,"Die JVM (Java Virtual Machine) ist eine virtuelle Maschine, die Java-Bytecode ausführt. Sie wird auf Betriebssystemebene aufgerufen, indem man ihr den Namen der Klasse als Parameter übergibt."
"Dabei ist ""main"" der Name der Methode; was die anderen Elemente bedeuten, werden Sie im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann einfach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter. Klassen werden in Java wie in SMALLTALK per Konvention immer großgeschrieben.",Wie werden Klassen in Java und SMALLTALK benannt?,In Java werden Klassen wie in SMALLTALK per Konvention immer großgeschrieben.
"Ein letztes, wichtiges Merkmal des Programmiermodells von Java ist die Art des Deployment, also wie in Java programmierte Anwendungen in die Anwendung gehen. Während früher alle namhaften Web-Browser (per Plug-in) den Start von in Webseiten eingebetteten Java-Anwendungen erlaubten, bleibt heute praktisch nur noch die Verteilung per sogenanntem Java Archive (einer .jar-Datei). Zu deren Ausführung ist jedoch eine Installation der JVM nötig.",Wie werden Java-Anwendungen in der Regel verteilt?,Java-Anwendungen werden heute praktisch nur noch per Java Archive (einer .jar-Datei) verteilt. Zur Ausführung ist jedoch eine Installation der JVM nötig.
"Ein letztes, wichtiges Merkmal des Programmiermodells von Java ist die Art des Deployment, also wie in Java programmierte Anwendungen in die Anwendung gehen. Während früher alle namhaften Web-Browser (per Plug-in) den Start von in Webseiten eingebetteten Java-Anwendungen erlaubten, bleibt heute praktisch nur noch die Verteilung per sogenanntem Java Archive (einer .jar-Datei). Zu deren Ausführung ist jedoch eine Installation der JVM nötig.",Was ist die Funktion der Java Virtual Machine (JVM)?,"Die JVM ist eine virtuelle Maschine, die Bytecode-Anweisungen ausführt, die von einem Java-Compiler erzeugt wurden. Sie ermöglicht es, Java-Programme auf verschiedenen Geräten und Betriebssystemen auszuführen."
"Wenn ich im vorangegangenen Absatz das Präteritum bemüht habe, dann liegt das daran, dass Interfaces in Java seit Version 8 einen Bedeutungswandel erfahren haben. Der ursprüngliche Anlass hierfür ergibt sich aus der Evolution von Software, genauer aus der Erweiterung von Interfaces im Laufe der Zeit um zusätzliche Methoden und der Tatsache, dass solche Erweiterungen ein Nachführen der Klassen, die die Interfaces implementieren, zwingend erfordern. Insbesondere bei sog. Black-box-Frameworks, deren Interfaces dazu gedacht sind, von Anwendungsklassen implementiert zu werden, deren Entwicklung in den Händen Dritter liegt, ist dies ein erhebliches Problem. Dasselbe Problem hätte man nicht, wenn man stattdessen abstrakte Klassen verwenden würde — dann könnte man nämlich die zusätzlichen Methoden mit einer Default-Implementierung versehen, die von den „implementierenden“ Klassen geerbt würde, sofern diese Klassen keine eigenen Implementierungen angeben. Interfaces in Varia -",Was ist der Bedeutungswandel von Interfaces in Java seit Version 8?,"Seit Java 8 können Interfaces Methoden mit einer Default-Implementierung enthalten. Dadurch wurde der ursprüngliche Zweck von Interfaces, die nur als Typdeklarationen fungieren, erweitert. Diese Erweiterung war notwendig, um die Erweiterung von Interfaces um zusätzliche Methoden zu ermöglichen, ohne dass die Klassen, die diese Interfaces implementieren, nachgeführt werden müssen."
"Genau das wurde in Java 8 auch für Interfaces eingeführt: Ein Interface kann die Implementierung einer Methode vorgeben, die dann an implementierende Klassen (oder per ""extends"" abgeleitete Interfaces) vererbt wird. Dafür hat Java ein neues Schlüsselwort spendiert bekommen: ""default"". Allerdings haben Interfaces immer noch keine Instanzvariablen, und entsprechend können Default-Methoden allenfalls auf abstrakte Getter und Setter zugreifen.","Was ist die Bedeutung des Schlüsselworts ""default"" in Java 8?","Mit dem Schlüsselwort ""default"" kann eine Methode in einem Interface vorgegeben werden, die dann an implementierende Klassen (oder per ""extends"" abgeleitete Interfaces) vererbt wird."
"Genau das wurde in Java 8 auch für Interfaces eingeführt: Ein Interface kann die Implementierung einer Methode vorgeben, die dann an implementierende Klassen (oder per ""extends"" abgeleitete Interfaces) vererbt wird. Dafür hat Java ein neues Schlüsselwort spendiert bekommen: ""default"". Allerdings haben Interfaces immer noch keine Instanzvariablen, und entsprechend können Default-Methoden allenfalls auf abstrakte Getter und Setter zugreifen.",Was ist die Funktion von Default-Methoden in Java 8?,"In Java 8 können Interfaces die Implementierung einer Methode vorgeben, die dann an implementierende Klassen (oder per ""extends"" abgeleitete Interfaces) vererbt wird. Dafür wurde das Schlüsselwort ""default"" eingeführt. Default-Methoden können allenfalls auf abstrakte Getter und Setter zugreifen, da Interfaces keine Instanzvariablen haben."
"Mit Java 9 schließlich wurde — letztlich nur konsequent — erlaubt, in Interfaces auch private Methoden zu definieren. Da diese ausschließlich aus dem Interface selbst heraus zugreifbar sind, dienen sie ausschließlich der Verbesserung der Lesbarkeit von Default-Methoden, indem man zusammenhängende Teile aus ihnen herauslöst und in private Methoden verlegt.",Was ist der Zweck von privaten Methoden in Interfaces in Java 9?,"Der Zweck von privaten Methoden in Interfaces in Java 9 ist die Verbesserung der Lesbarkeit von Default-Methoden, indem man zusammenhängende Teile aus ihnen herauslöst und in private Methoden verlegt. Diese privaten Methoden sind ausschließlich aus dem Interface selbst heraus zugreifbar."
"Sicher ist Ihnen aufgefallen, dass uns bislang keine Schlüsselwörter in SMALLTALK begegnet sind (bis auf die sog. Schlüsselwortnachrichten, die aber frei wählbar sind und deswegen eben gerade keine Schlüsselwörter sind). Der Grund hierfür ist einfach: Es gibt keine Schlüsselwörter, lediglich ein paar Symbole mit spezieller Bedeutung. Es sind dies:Zuweisung, Trennzeichen zwischen zwei Anweisungen sowie Dezimalpunkt für Gleitkommazahlen, Trennzeichen zum Kaskadieren von Nachrichten, Markierung von Parametern in Nachrichten und Blöcken, Klammerung von Ausdrücken zur Festlegung der Reihenfolge der Auswertung, Bildung von Blöcken, Trennzeichen zwischen den Parametern eines Blocks und seinen Anweisungen, Markierung von Kommentaren, Markierung von String-Literalen, Markierung von Zeichenliteralen, Markierung von Symbol- und Array-Literalen, Rückgabe-Operator (Return)Das ist alles! Die reservierten Namen true, false, nil, self und super sind die von Pseudovariablen; alle aus anderen Sprachen bekannten Schlüsselwörter sind als Methoden in SMALLTALK selbst definiert.",Warum gibt es in SMALLTALK keine Schlüsselwörter?,"In SMALLTALK gibt es keine Schlüsselwörter, sondern nur Symbole mit spezieller Bedeutung. Stattdessen sind alle aus anderen Sprachen bekannten Schlüsselwörter in SMALLTALK als Methoden implementiert."
"Sicher ist Ihnen aufgefallen, dass uns bislang keine Schlüsselwörter in SMALLTALK begegnet sind (bis auf die sog. Schlüsselwortnachrichten, die aber frei wählbar sind und deswegen eben gerade keine Schlüsselwörter sind). Der Grund hierfür ist einfach: Es gibt keine Schlüsselwörter, lediglich ein paar Symbole mit spezieller Bedeutung. Es sind dies:Zuweisung, Trennzeichen zwischen zwei Anweisungen sowie Dezimalpunkt für Gleitkommazahlen, Trennzeichen zum Kaskadieren von Nachrichten, Markierung von Parametern in Nachrichten und Blöcken, Klammerung von Ausdrücken zur Festlegung der Reihenfolge der Auswertung, Bildung von Blöcken, Trennzeichen zwischen den Parametern eines Blocks und seinen Anweisungen, Markierung von Kommentaren, Markierung von String-Literalen, Markierung von Zeichenliteralen, Markierung von Symbol- und Array-Literalen, Rückgabe-Operator (Return)Das ist alles! Die reservierten Namen true, false, nil, self und super sind die von Pseudovariablen; alle aus anderen Sprachen bekannten Schlüsselwörter sind als Methoden in SMALLTALK selbst definiert.",Was sind reservierte Namen in SMALLTALK?,"In SMALLTALK gibt es einige reservierte Namen, die als Pseudovariablen dienen. Diese reservierten Namen sind: true, false, nil, self and super. Alle anderen Schlüsselwörter, die in anderen Programmiersprachen üblich sind, werden in SMALLTALK als Methoden definiert."
"Java ist (wie SMALLTALK und alle in der nächsten Kurseinheit behandelten Sprachen) klassenbasiert und nicht prototypenbasiert. Das bedeutet, dass man programmieren kann, indem man Klassendefinitionen angibt. Wie bereits in Kapitel 34 erwähnt, gibt es in Java keine Anweisungen außerhalb von Klassen (abgesehen von Import-Anweisungen).","Was bedeutet es, dass Java klassenbasiert und nicht prototypenbasiert ist?","In Java werden Programme durch Angabe von Klassendefinitionen erstellt, im Gegensatz zu prototypenbasierten Sprachen, bei denen Objekte direkt erstellt und angepasst werden können."
"Java ist (wie SMALLTALK und alle in der nächsten Kurseinheit behandelten Sprachen) klassenbasiert und nicht prototypenbasiert. Das bedeutet, dass man programmieren kann, indem man Klassendefinitionen angibt. Wie bereits in Kapitel 34 erwähnt, gibt es in Java keine Anweisungen außerhalb von Klassen (abgesehen von Import-Anweisungen).",Was ist der Unterschied zwischen klassenbasierten und prototypenbasierten Programmiersprachen?,"Klassenbasierte Programmiersprachen wie Java, SMALLTALK und andere Sprachen, die in der nächsten Kurseinheit behandelt werden, verwenden Klassendefinitionen, um das Programmieren zu ermöglichen. Prototypenbasierte Sprachen hingegen verwenden Prototypen, um Objekte zu erstellen und zu definieren. In prototypenbasierten Sprachen gibt es keine Klassendefinitionen, sondern Objekte werden direkt erstellt und können dann als Vorlage für andere Objekte dienen."
"Wie ebenfalls bereits erwähnt wurde, besteht in Java ein relativ enger Zusammenhang zwischen Klassen und Dateien. Jede Datei enthält die Definition einer Klasse, die den Dateinamen (ohne Erweiterung) als Namen trägt. Eine Datei (oder Compilation Unit) kann auch mehrere Klassen enthalten, die dann natürlich verschiedene Namen haben müssen. Es darf jedoch keine dieser Klassen als ""public"" deklariert werden. Dies liegt zum Teil daran, dass die meisten integrierten Entwicklungsumgebungen für Java heute auf Dateibasis arbeiten und Dateien die Grundlage vieler Versionsverwaltungssysteme bilden. Daher ist es wenig üblich, mehrere Klassen in einer Datei zu definieren, es sei denn, es handelt sich um innere Klassen (siehe unten).",Wie ist der Zusammenhang zwischen Klassen und Dateien in Java?,"In Java besteht ein enger Zusammenhang zwischen Klassen und Dateien. Jede Datei enthält die Definition einer Klasse, die den Dateinamen (ohne Erweiterung) als Namen trägt. Eine Datei kann auch mehrere Klassen enthalten, die dann verschiedene Namen haben müssen. Es darf jedoch nur eine dieser Klassen als ""public"" deklariert werden."
"Klassen und Typen sind zunächst zwei verschiedene Konzepte, aber eine Typdefinition aus einer Klassendefinition abgeleitet werden kann. Genau das trifft auf Java zu: Jede Klasse definiert ihren eigenen Typ. Genauer gesagt, spezifiziert jede Klasse einen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält.",Wie hängen Klassen und Typen in Java zusammen?,"In Java definiert jede Klasse ihren eigenen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält."
"Klassen und Typen sind zunächst zwei verschiedene Konzepte, aber eine Typdefinition aus einer Klassendefinition abgeleitet werden kann. Genau das trifft auf Java zu: Jede Klasse definiert ihren eigenen Typ. Genauer gesagt, spezifiziert jede Klasse einen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält.",Was definiert eine Klasse in Java?,"In Java definiert jede Klasse ihren eigenen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält."
"Klassen und Typen sind zunächst zwei verschiedene Konzepte, aber eine Typdefinition aus einer Klassendefinition abgeleitet werden kann. Genau das trifft auf Java zu: Jede Klasse definiert ihren eigenen Typ. Genauer gesagt, spezifiziert jede Klasse einen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält.",Wie wird in Java ein Typ definiert?,"In Java wird ein Typ durch eine Klassendefinition definiert, die Felddefinitionen und Methodendeklarationen enthält. Jede Klasse definiert somit ihren eigenen Typ, der denselben Namen wie die Klasse trägt."
"Beachten Sie, dass im Gegensatz zu STRONGTALK in Java der Typ bei Deklarationen ohne spitze Klammern vorangestellt wird, in Anlehnung an die Tradition von C und C++. Die spitzen Klammern in Zeile 985 kennzeichnen lediglich metasyntaktische Variablen.",Was ist der Unterschied zwischen STRONGTALK und Java in Bezug auf Deklarationen?,"In STRONGTALK werden die Typen bei Deklarationen ohne spitze Klammern nachgestellt, während in Java der Typ bei Deklarationen ohne spitze Klammern vorangestellt wird, in Anlehnung an die Tradition von C und C++. Die spitzen Klammern in Zeile 985 kennzeichnen in diesem Zusammenhang lediglich metasyntaktische Variablen."
"Beachten Sie, dass im Gegensatz zu STRONGTALK in Java der Typ bei Deklarationen ohne spitze Klammern vorangestellt wird, in Anlehnung an die Tradition von C und C++. Die spitzen Klammern in Zeile 985 kennzeichnen lediglich metasyntaktische Variablen.",Wie werden Variablen in Java deklariert?,"In Java wird der Typ einer Variablen bei der Deklaration vorangestellt, z.B. int x; oder String s;"
"Die Blöcke in SMALLTALK können auch als anonyme Funktionen aufgefasst werden. Bisher waren alle Blöcke parameterlos, und ihre Beziehung zur Umgebung wurde ausschließlich über den Home Context hergestellt. Es ist jedoch auch möglich, Blöcke mit Parametern zu versehen, die bei ihrer Auswertung an Objekte aus dem Auswertungskontext gebunden werden können.",Was sind anonyme Funktionen?,Blöcke in SMALLTALK können auch als anonyme Funktionen aufgefasst werden.
"Die Blöcke in SMALLTALK können auch als anonyme Funktionen aufgefasst werden. Bisher waren alle Blöcke parameterlos, und ihre Beziehung zur Umgebung wurde ausschließlich über den Home Context hergestellt. Es ist jedoch auch möglich, Blöcke mit Parametern zu versehen, die bei ihrer Auswertung an Objekte aus dem Auswertungskontext gebunden werden können.",Was sind parametrisierten Blöcke?,"Parametrisierte Blöcke können mit Parametern versehen werden, die bei ihrer Auswertung an Objekte aus dem Auswertungskontext gebunden werden können."
"Da Blöcke Objekte sind, denen Variablen zugewiesen werden können, können sie auch an andere Methoden übergeben werden. Werden sie dort (mittels value) ausgewertet, findet die Ausführung in einem anderen Kontext statt. In diesem Kontext sind die ""freien"" Variablen des Blocks nicht zugreifbar. Der Block nimmt deshalb seinen Kontext mit (oder, genauer gesagt, der Kontext ist im Block enthalten). Den Kontext, in dem ein Block definiert wurde (in dem das ihn repräsentierende Objekt erzeugt wurde), nennt man seinen Home Context. Die Auswertung eines Blocks erfolgt stets in seinem Home Context, auch dann, wenn ihm value in einem anderen Kontext gesendet wurde.",Was ist der Home Context eines Blocks in SMALLTALK?,"Der Home Context eines Blocks in SMALLTALK ist der Kontext, in dem der Block definiert wurde oder genauer gesagt, in dem das ihn repräsentierende Objekt erzeugt wurde. Dieser Kontext enthält Informationen über die lokalen Variablen und formalen Parameter, die der Block ""einfängt"". Die Ausführung eines Blocks erfolgt immer in seinem Home Context, selbst wenn der Block in einem anderen Kontext ausgewertet wird."
"Dass ein Block aus seinem Home Context herausgelöst und in einem anderen gespeichert werden kann, beinhaltet das Problem, dass die lokalen Variablen des Home Contexts schon verschwunden sein können, wenn der Block ausgewertet wird. Die durch den Block ""eingefangenen"" lokalen Variablen (einschließlich der formalen Parameter) müssen daher unabhängig von der Ausführung der Methoden, die sie definieren, weiterleben. Die Umsetzung von Blöcken durch den SMALLTALK-Compiler ist alles andere als trivial, und verschiedene SMALLTALK-Systeme unterscheiden sich darin teilweise erheblich voneinander, was sich (leider) auch in unterschiedlichem Verhalten äußert.Die Blöcke in SMALLTALK werden in anderen Sprachen übrigens als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können. Dabei unterscheiden sich die Sprachen erheblich darin, was alles in eine Closure einbezogen werden kann. Zum Beispiel können die lokalen Namen (Variablen) auf Konstanten eingeschränkt werden, um zu verhindern, dass temporäre Variablen weiterleben müssen, nur weil sie in einer Closure enthalten sind.",Was sind Closures?,"Closures sind in SMALLTALK Blöcke für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können."
"Dass ein Block aus seinem Home Context herausgelöst und in einem anderen gespeichert werden kann, beinhaltet das Problem, dass die lokalen Variablen des Home Contexts schon verschwunden sein können, wenn der Block ausgewertet wird. Die durch den Block ""eingefangenen"" lokalen Variablen (einschließlich der formalen Parameter) müssen daher unabhängig von der Ausführung der Methoden, die sie definieren, weiterleben. Die Umsetzung von Blöcken durch den SMALLTALK-Compiler ist alles andere als trivial, und verschiedene SMALLTALK-Systeme unterscheiden sich darin teilweise erheblich voneinander, was sich (leider) auch in unterschiedlichem Verhalten äußert.Die Blöcke in SMALLTALK werden in anderen Sprachen übrigens als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können. Dabei unterscheiden sich die Sprachen erheblich darin, was alles in eine Closure einbezogen werden kann. Zum Beispiel können die lokalen Namen (Variablen) auf Konstanten eingeschränkt werden, um zu verhindern, dass temporäre Variablen weiterleben müssen, nur weil sie in einer Closure enthalten sind.",Was sind Blöcke?,"Blöcke in SMALLTALK werden in anderen Programmiersprachen oft als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, die anonyme Funktionen repräsentieren und als Objekte oder Werte behandelt werden können. Closures erlauben es, Funktionen aus ihrem Kontext herauszulösen und in andere Kontexte zu übertragen. Die Verwendung und das Verhalten von Closures können sich jedoch zwischen verschiedenen Programmiersprachen erheblich unterscheiden."
"Vererbung ist nicht auf die Klassen der Ebene 1 beschränkt — in SMALLTALK können vielmehr auch Metaklassen, die ja ebenfalls Klassen sind (s. Kapitel 8), voneinander erben. Da Metaklassen aber bei der Erzeugung von Klassen automatisch angelegt werden (und auch keine eigenen Namen haben), hat die Programmiererin auch keinen direkten Einfluss auf die Vererbungshierarchie der Metaklassen. Vielmehr wird diese automatisch parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind, angelegt. Dies hat zur Folge, dass in SMALLTALK neben den Instanzvariablen und -methoden auch die Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt werden.",Kann Vererbung in SMALLTALK auch auf Metaklassen angewendet werden?,"Ja, Vererbung kann in SMALLTALK auch auf Metaklassen angewendet werden, da Metaklassen ebenfalls Klassen sind. Die Vererbungshierarchie der Metaklassen wird automatisch parallel zur Vererbungshierarchie der Klassen angelegt, die Instanzen der Metaklassen sind."
"Vererbung ist nicht auf die Klassen der Ebene 1 beschränkt — in SMALLTALK können vielmehr auch Metaklassen, die ja ebenfalls Klassen sind (s. Kapitel 8), voneinander erben. Da Metaklassen aber bei der Erzeugung von Klassen automatisch angelegt werden (und auch keine eigenen Namen haben), hat die Programmiererin auch keinen direkten Einfluss auf die Vererbungshierarchie der Metaklassen. Vielmehr wird diese automatisch parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind, angelegt. Dies hat zur Folge, dass in SMALLTALK neben den Instanzvariablen und -methoden auch die Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt werden.",Kann Vererbung in SMALLTALK nur auf der Ebene 1 stattfinden?,"Nein, Vererbung ist in SMALLTALK nicht auf die Klassen der Ebene 1 beschränkt. Auch Metaklassen, die ja ebenfalls Klassen sind, können voneinander erben. Diese Vererbungshierarchie der Metaklassen wird automatisch parallel zur Vererbungshierarchie der Klassen angelegt, die Instanzen der Metaklassen sind."
"Vererbung ist nicht auf die Klassen der Ebene 1 beschränkt — in SMALLTALK können vielmehr auch Metaklassen, die ja ebenfalls Klassen sind (s. Kapitel 8), voneinander erben. Da Metaklassen aber bei der Erzeugung von Klassen automatisch angelegt werden (und auch keine eigenen Namen haben), hat die Programmiererin auch keinen direkten Einfluss auf die Vererbungshierarchie der Metaklassen. Vielmehr wird diese automatisch parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind, angelegt. Dies hat zur Folge, dass in SMALLTALK neben den Instanzvariablen und -methoden auch die Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt werden.",Wie vererben sich Klassenvariablen und -methoden in SMALLTALK?,"In SMALLTALK werden Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt. Dies geschieht automatisch parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind."
"Da in SMALLTALK jede Klasse direkte oder indirekte Subklasse von Object ist und die Subklassenhierarchie der Metaklassen parallel zu der ihrer Klassen angelegt ist, erbt jede Metaklasse in SMALLTALK automatisch von Object class, der Metaklasse von Object. Was läge also näher, als die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen — darunter auch die beiden Standardkonstruktoren new und new: — in Object (genauer: als Instanzmethoden von Object class) zu definieren?","Wo werden die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, definiert?","Die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, werden in Object class definiert, der Metaklasse von Object."
"Da in SMALLTALK jede Klasse direkte oder indirekte Subklasse von Object ist und die Subklassenhierarchie der Metaklassen parallel zu der ihrer Klassen angelegt ist, erbt jede Metaklasse in SMALLTALK automatisch von Object class, der Metaklasse von Object. Was läge also näher, als die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen — darunter auch die beiden Standardkonstruktoren new und new: — in Object (genauer: als Instanzmethoden von Object class) zu definieren?",Wo werden die Klassenmethoden in Smalltalk definiert?,"In Smalltalk werden die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, als Instanzmethoden von Object class definiert."
"Da in SMALLTALK jede Klasse direkte oder indirekte Subklasse von Object ist und die Subklassenhierarchie der Metaklassen parallel zu der ihrer Klassen angelegt ist, erbt jede Metaklasse in SMALLTALK automatisch von Object class, der Metaklasse von Object. Was läge also näher, als die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen — darunter auch die beiden Standardkonstruktoren new und new: — in Object (genauer: als Instanzmethoden von Object class) zu definieren?","Warum werden die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, in Object class definiert?","Die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, werden in Object class definiert, da jede Klasse in SMALLTALK direkte oder indirekte Subklasse von Object ist und die Subklassenhierarchie der Metaklassen parallel zu der ihrer Klassen angelegt ist. Somit erbt jede Metaklasse in SMALLTALK automatisch von Object class, der Metaklasse von Object."
"Nun gibt es ja schon, wie bereits in Fußnote 29 oben erwähnt, in SMALLTALK zwei Arten von Objekten, nämlich solche, die instanziierbar sind (also Klassen) und solche, die es nicht sind. Darüber hinaus gibt es auch noch eine Unterscheidung zwischen Klassen, die Metaklassen sind, und solchen, die es nicht sind — bei allen Gemeinsamkeiten von Klassen und Metaklassen muss man z. B. von Klassen neue Subklassen bilden können, von Metaklassen jedoch nicht. Diese Unterscheidungen müssen schließlich irgendwo getroffen werden. Und so kommt es, dass Object class nicht die Wurzel der Vererbungshierarchie der Metaklassen ist (kann sie sowieso nicht, denn auch sie muss eine Subklasse von Object sein!), sondern selbst von einer für diesen Zweck vorgesehenen Klasse erbt. Aus demselben Grund, aus dem die Klasse Object „Object“ und die Klasse Metaclass „Metaclass“ heißt, heißt diese Klasse „Class“: Es gilt nämlich für jede Instanz dieser Klasse, dass sie eine Klasse ist. Man beachte übrigens, dass Class, auch wenn sie die Superklasse aller Metaklassen ist, selbst keine Metaklasse ist, denn sonst müsste Class ja als Superklasse von Object class und wegen der parallelen Vererbungshierarchie von Metaklassen und Klassen die (Meta-)Klasse einer Klasse sein, die Superklasse von Object ist. Ist sie aber nicht. Außerdem ist, wie man sich leicht überzeugen kann, die Klasse von Class die Klasse Class class und erst Class class eine Metaklasse. Zugegebenermaßen etwas kompliziert.",Wie werden Klassen und Metaklassen in SMALLTALK unterschieden?,"In SMALLTALK gibt es zwei Arten von Objekten: solche, die instanziierbar sind (Klassen) und solche, die es nicht sind. Darüber hinaus gibt es eine Unterscheidung zwischen Klassen, die Metaklassen sind, und solchen, die es nicht sind. Diese Unterscheidungen müssen irgendwo getroffen werden. Die Klasse Object ist nicht die Wurzel der Vererbungshierarchie der Metaklassen, sondern erbt von einer für diesen Zweck vorgesehenen Klasse. Die Klasse Class ist die Superklasse aller Metaklassen, ist aber selbst keine Metaklasse. Die Klasse von Class ist Class class und erst Class class eine Metaklasse."
"Nun gibt es ja schon, wie bereits in Fußnote 29 oben erwähnt, in SMALLTALK zwei Arten von Objekten, nämlich solche, die instanziierbar sind (also Klassen) und solche, die es nicht sind. Darüber hinaus gibt es auch noch eine Unterscheidung zwischen Klassen, die Metaklassen sind, und solchen, die es nicht sind — bei allen Gemeinsamkeiten von Klassen und Metaklassen muss man z. B. von Klassen neue Subklassen bilden können, von Metaklassen jedoch nicht. Diese Unterscheidungen müssen schließlich irgendwo getroffen werden. Und so kommt es, dass Object class nicht die Wurzel der Vererbungshierarchie der Metaklassen ist (kann sie sowieso nicht, denn auch sie muss eine Subklasse von Object sein!), sondern selbst von einer für diesen Zweck vorgesehenen Klasse erbt. Aus demselben Grund, aus dem die Klasse Object „Object“ und die Klasse Metaclass „Metaclass“ heißt, heißt diese Klasse „Class“: Es gilt nämlich für jede Instanz dieser Klasse, dass sie eine Klasse ist. Man beachte übrigens, dass Class, auch wenn sie die Superklasse aller Metaklassen ist, selbst keine Metaklasse ist, denn sonst müsste Class ja als Superklasse von Object class und wegen der parallelen Vererbungshierarchie von Metaklassen und Klassen die (Meta-)Klasse einer Klasse sein, die Superklasse von Object ist. Ist sie aber nicht. Außerdem ist, wie man sich leicht überzeugen kann, die Klasse von Class die Klasse Class class und erst Class class eine Metaklasse. Zugegebenermaßen etwas kompliziert.",Was ist der Unterschied zwischen Klassen und Metaklassen in Smalltalk?,"In Smalltalk gibt es zwei Arten von Objekten: solche, die instanziierbar sind (Klassen) und solche, die es nicht sind. Darüber hinaus gibt es eine Unterscheidung zwischen Klassen, die Metaklassen sind, und solchen, die es nicht sind. Diese Unterscheidungen müssen irgendwo getroffen werden. Die Klasse Object ist nicht die Wurzel der Vererbungshierarchie der Metaklassen, sondern erbt von einer für diesen Zweck vorgesehenen Klasse. Die Klasse Class ist die Superklasse aller Metaklassen, ist aber selbst keine Metaklasse. Die Klasse von Class ist Class class und erst Class class eine Metaklasse."
"Nun gibt es ja schon, wie bereits in Fußnote 29 oben erwähnt, in SMALLTALK zwei Arten von Objekten, nämlich solche, die instanziierbar sind (also Klassen) und solche, die es nicht sind. Darüber hinaus gibt es auch noch eine Unterscheidung zwischen Klassen, die Metaklassen sind, und solchen, die es nicht sind — bei allen Gemeinsamkeiten von Klassen und Metaklassen muss man z. B. von Klassen neue Subklassen bilden können, von Metaklassen jedoch nicht. Diese Unterscheidungen müssen schließlich irgendwo getroffen werden. Und so kommt es, dass Object class nicht die Wurzel der Vererbungshierarchie der Metaklassen ist (kann sie sowieso nicht, denn auch sie muss eine Subklasse von Object sein!), sondern selbst von einer für diesen Zweck vorgesehenen Klasse erbt. Aus demselben Grund, aus dem die Klasse Object „Object“ und die Klasse Metaclass „Metaclass“ heißt, heißt diese Klasse „Class“: Es gilt nämlich für jede Instanz dieser Klasse, dass sie eine Klasse ist. Man beachte übrigens, dass Class, auch wenn sie die Superklasse aller Metaklassen ist, selbst keine Metaklasse ist, denn sonst müsste Class ja als Superklasse von Object class und wegen der parallelen Vererbungshierarchie von Metaklassen und Klassen die (Meta-)Klasse einer Klasse sein, die Superklasse von Object ist. Ist sie aber nicht. Außerdem ist, wie man sich leicht überzeugen kann, die Klasse von Class die Klasse Class class und erst Class class eine Metaklasse. Zugegebenermaßen etwas kompliziert.","Was ist die Rolle der Klasse ""Class"" in Smalltalk?","Die Klasse ""Class"" ist in Smalltalk die Superklasse aller Metaklassen. Jede Instanz dieser Klasse ist eine Klasse. Die Klasse von Class ist Class class und erst Class class eine Metaklasse."
"Die Klasse Class steht in der Vererbungshierarchie SMALLTALKs neben der Klasse Metaclass. Gemeinsam erben sie von der Klasse Behavior (in SMALLTALK-80 und direkten Derivaten indirekt, über die Klasse ClassDescription), in der schließlich, neben vielen anderen Methoden, new und new: definiert sind. Man beachte, dass diese Methoden als Instanzmethoden deklariert sind; da sie aber in der Vererbungshierarchie SMALLTALKs von den Metaklassen der Klassen geerbt werden (z. B. Object class), stehen sie in den Klassen als Klassenmethoden zur Verfügung. new und new: werden also in der Praxis immer an Klassen geschickt.",Was ist die Klasse Class in SMALLTALK?,"Die Klasse Class ist in SMALLTALK eine Klasse, die neben der Klasse Metaclass in der Vererbungshierarchie steht und gemeinsam mit ihr von der Klasse Behavior erbt. Die Klasse Class stellt Methoden zur Verfügung, die als Klassenmethoden in den Klassen zur Verfügung stehen, wie zum Beispiel new und new:."
"Die Klasse Class steht in der Vererbungshierarchie SMALLTALKs neben der Klasse Metaclass. Gemeinsam erben sie von der Klasse Behavior (in SMALLTALK-80 und direkten Derivaten indirekt, über die Klasse ClassDescription), in der schließlich, neben vielen anderen Methoden, new und new: definiert sind. Man beachte, dass diese Methoden als Instanzmethoden deklariert sind; da sie aber in der Vererbungshierarchie SMALLTALKs von den Metaklassen der Klassen geerbt werden (z. B. Object class), stehen sie in den Klassen als Klassenmethoden zur Verfügung. new und new: werden also in der Praxis immer an Klassen geschickt.",Was ist der Unterschied zwischen new und new: in Smalltalk?,"new erstellt eine neue Instanz eines Klassentyps, während new: eine neue Instanz mit angegebenen Parametern erstellt."
"Eine wichtige Gruppe von Klassen, die Sie in den letzten beiden Kurseinheiten kennengelernt haben, sind die sog. Collection-Klassen. Auch diese bilden jeweils einen Typ, so dass Variablen, die auf eine Collection verweisen, mit diesem Typ deklariert werden können.",Was sind Collection-Klassen?,"Collection-Klassen sind eine wichtige Gruppe von Klassen, die Sie in den letzten beiden Kurseinheiten kennengelernt haben. Sie bilden jeweils einen Typ, so dass Variablen, die auf eine Collection verweisen, mit diesem Typ deklariert werden können."
"Eine wichtige Gruppe von Klassen, die Sie in den letzten beiden Kurseinheiten kennengelernt haben, sind die sog. Collection-Klassen. Auch diese bilden jeweils einen Typ, so dass Variablen, die auf eine Collection verweisen, mit diesem Typ deklariert werden können.",Was ist die Zuweisung in der objektorientierten Programmierung?,"Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung, das eine Variable mit einem Wert oder einem Verweis auf ein Objekt verbindet. Sie kann explizit durch den Zuweisungsoperator oder implizit bei Methodenaufrufen erfolgen."
"Nun dienen Collections ja u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen (s. Kurseinheit 2, Kapitel 13). Und so bilden die mit den Collection-Klassen assoziierten Typen auch nur die Typen für die Zwischenobjekte. Was man jedoch eigentlich bei der Deklaration von n-wertigen Attributen angeben (deklarieren) möchte, ist der Typ der in Beziehung stehenden Objekte.",Wie kann man den Typ der in Beziehung stehenden Objekte bei der Deklaration von n-wertigen Attributen angeben?,"Man kann den Typ der in Beziehung stehenden Objekte bei der Deklaration von n-wertigen Attributen angeben, indem man die Collection-Klassen als Typen für die Zwischenobjekte verwendet."
"Nun dienen Collections ja u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen (s. Kurseinheit 2, Kapitel 13). Und so bilden die mit den Collection-Klassen assoziierten Typen auch nur die Typen für die Zwischenobjekte. Was man jedoch eigentlich bei der Deklaration von n-wertigen Attributen angeben (deklarieren) möchte, ist der Typ der in Beziehung stehenden Objekte.",Wozu dienen Collections in der objektorientierten Programmierung?,"Collections dienen dazu, n-Beziehungen zwischen einem Objekt und mehreren anderen Objekten zu ermöglichen, indem sie dafür Zwischenobjekte bereitstellen. Die mit den Collection-Klassen assoziierten Typen sind die Typen für die Zwischenobjekte."
"Nun dienen Collections ja u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen (s. Kurseinheit 2, Kapitel 13). Und so bilden die mit den Collection-Klassen assoziierten Typen auch nur die Typen für die Zwischenobjekte. Was man jedoch eigentlich bei der Deklaration von n-wertigen Attributen angeben (deklarieren) möchte, ist der Typ der in Beziehung stehenden Objekte.",Was sind die Zwischenobjekte in Bezug auf n-Beziehungen zwischen Objekten?,"Die Zwischenobjekte in Bezug auf n-Beziehungen zwischen Objekten sind die Objekte, die mit den Collection-Klassen assoziiert sind und die Beziehung zwischen einem Objekt und mehreren anderen Objekten ermöglichen."
"Wenn das Attribut beispielsweise Kinder heißt und man damit eine Person mit einer Menge anderer Objekte vom Typ Person, den Kindern, in Beziehung setzen möchte, dann nutzt es nichts, wenn man Kinder vom Typ Person deklariert — es könnte dann höchstens eine Person enthalten und nicht mehrere. Was man vielmehr gern hätte, wäre etwas, das dem Array-Typkonstruktor array [<Bereich>] of <Elementtyp> (spitze Klammern hier wieder als Begrenzer von metasyntaktischen Variablen) von PASCAL gleicht: Im gegebenen Beispiel würde man gern deklarieren, dass Kinder den Typ Collection of Person haben soll.",Wie kann man in Smalltalk eine Menge von Objekten vom Typ Person deklarieren?,"Man kann eine Menge von Objekten vom Typ Person in Smalltalk mit dem Typ Collection of Person deklarieren, der dem Array-Typkonstruktor array [<Bereich>] of <Elementtyp> von PASCAL ähnelt."
"Wenn das Attribut beispielsweise Kinder heißt und man damit eine Person mit einer Menge anderer Objekte vom Typ Person, den Kindern, in Beziehung setzen möchte, dann nutzt es nichts, wenn man Kinder vom Typ Person deklariert — es könnte dann höchstens eine Person enthalten und nicht mehrere. Was man vielmehr gern hätte, wäre etwas, das dem Array-Typkonstruktor array [<Bereich>] of <Elementtyp> (spitze Klammern hier wieder als Begrenzer von metasyntaktischen Variablen) von PASCAL gleicht: Im gegebenen Beispiel würde man gern deklarieren, dass Kinder den Typ Collection of Person haben soll.",Was ist der Unterschied zwischen dem Attribut Kinder als Typ Person und Collection of Person?,"Wenn das Attribut Kinder als Typ Person deklariert wird, kann es nur ein Objekt vom Typ Person enthalten, während es als Collection of Person deklariert, eine Menge von Objekten vom Typ Person enthalten kann."
"Ein anderes Beispiel für eine parametrische Definition einer Collection ist Dictionary: Hier sollte nicht nur der Element-, sondern auch der Schlüsseltyp variabel gehalten werden.",Was ist eine parametrische Definition einer Collection?,"Eine parametrische Definition einer Collection ist eine Definition, bei der sowohl der Element- als auch der Schlüsseltyp variabel gehalten wird, wie zum Beispiel bei Dictionary."
"Ein anderes Beispiel für eine parametrische Definition einer Collection ist Dictionary: Hier sollte nicht nur der Element-, sondern auch der Schlüsseltyp variabel gehalten werden.",Was ist ein Dictionary in der Programmierung?,"Ein Dictionary ist eine parametrische Definition einer Collection, bei der sowohl der Element- als auch der Schlüsseltyp variabel gehalten wird. Es ist eine Datenstruktur, die Werte mit Schlüsseln verbindet, um eine schnelle Suche und Zugriff auf die Werte zu ermöglichen. In einigen Programmiersprachen wird Dictionary auch als Map oder Hashtable bezeichnet."
"Dabei ist der parametrische Typ Dictionary ein Subtyp des ebenfalls parametrischen Typs Collection. Man beachte, dass der Typparameter E hier bereits in der Supertypdeklaration verwendet wird. Ein Dictionary, in dem Integer auf beliebige Objekte abgebildet werden, erhält man dann durch die Instanziierung Dictionary[Integer, Object]. Es ist mit einer Variable vom Typ Collection[Object] zuweisungskompatibel. Auf die Einzelheiten des Subtypings bei parametrischen Typen wird in Kapitel 30 eingegangen.",Was ist ein parametrischer Typ in der Programmierung?,"Ein parametrischer Typ ist ein Konstrukt in der Programmierung, bei dem ein oder mehrere Typen als Parameter verwendet werden. Dies ermöglicht die Erstellung von generischen Datentypen und Funktionen, die für verschiedene Datentypen verwendet werden können. Im gegebenen Kontext wird der parametrische Typ Dictionary verwendet, um Integer auf beliebige Objekte abzubilden."
"Dabei ist der parametrische Typ Dictionary ein Subtyp des ebenfalls parametrischen Typs Collection. Man beachte, dass der Typparameter E hier bereits in der Supertypdeklaration verwendet wird. Ein Dictionary, in dem Integer auf beliebige Objekte abgebildet werden, erhält man dann durch die Instanziierung Dictionary[Integer, Object]. Es ist mit einer Variable vom Typ Collection[Object] zuweisungskompatibel. Auf die Einzelheiten des Subtypings bei parametrischen Typen wird in Kapitel 30 eingegangen.",Was ist der parametrische Typ Dictionary?,"Der parametrische Typ Dictionary ist ein Subtyp des ebenfalls parametrischen Typs Collection, bei dem der Typparameter E bereits in der Supertypdeklaration verwendet wird. Ein Dictionary, in dem Integer auf beliebige Objekte abgebildet werden, erhält man durch die Instanziierung Dictionary[Integer, Object]. Es ist mit einer Variablen vom Typ Collection[Object] zuweisungskompatibel."
"In der vorangegangenen Kurseinheit haben Sie die Grundkonzepte der objektorientierten Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten. Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden. Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Programmierung nicht grundsätzlich festgelegt. Eine gewisse Anerkennung und Verbreitung erfahren haben aber drei verschiedene Ansätze: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschieden aufgebaute Objekte; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden.","Wie können Objekte, für die es keine literale Repräsentation gibt, entstehen?","Es gibt drei verschiedene Ansätze, wie Objekte entstehen können: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen erzeugt werden."
"In der vorangegangenen Kurseinheit haben Sie die Grundkonzepte der objektorientierten Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten. Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden. Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Programmierung nicht grundsätzlich festgelegt. Eine gewisse Anerkennung und Verbreitung erfahren haben aber drei verschiedene Ansätze: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschieden aufgebaute Objekte; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden.",Was ist der Klassenansatz in der objektorientierten Programmierung?,"Der Klassenansatz ist ein Ansatz in der objektorientierten Programmierung, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden. Diese Vorlagen werden als Klassen bezeichnet."
"In der vorangegangenen Kurseinheit haben Sie die Grundkonzepte der objektorientierten Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten. Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden. Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Programmierung nicht grundsätzlich festgelegt. Eine gewisse Anerkennung und Verbreitung erfahren haben aber drei verschiedene Ansätze: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschieden aufgebaute Objekte; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden.",Was ist der Unterschied zwischen dem Konstruktoransatz und dem Klassenansatz in der objektorientierten Programmierung?,"Beim Konstruktoransatz wird der Aufbau eines Objekts in einer Methode beschrieben, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden. Bei jedem Aufruf dieser Methode entsteht ein neues Objekt. Im Gegensatz dazu, erzeugt der Klassenansatz Objekte als Instanzen von bestimmten Vorlagen, die als Klassen bezeichnet werden. Alle Objekte, die von einer Klasse erzeugt werden, haben dieselben Instanzvariablen und Methoden."
"In der vorangegangenen Kurseinheit haben Sie die Grundkonzepte der objektorientierten Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten. Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden. Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Programmierung nicht grundsätzlich festgelegt. Eine gewisse Anerkennung und Verbreitung erfahren haben aber drei verschiedene Ansätze: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschieden aufgebaute Objekte; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden.",Was ist der Prototypenansatz in der objektorientierten Programmierung?,"Der Prototypenansatz ist ein Ansatz in der objektorientierten Programmierung, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird. Ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden."
"In der vorangegangenen Kurseinheit haben Sie die Grundkonzepte der objektorientierten Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten. Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden. Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Programmierung nicht grundsätzlich festgelegt. Eine gewisse Anerkennung und Verbreitung erfahren haben aber drei verschiedene Ansätze: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschieden aufgebaute Objekte; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden.",Was ist der Unterschied zwischen dem Prototypenansatz und dem Klassenansatz in der objektorientierten Programmierung?,"Beim Prototypenansatz wird ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont und bei Bedarf um weitere Instanzvariablen und Methoden ergänzt. Im Gegensatz dazu, erzeugt der Klassenansatz Objekte als Instanzen von bestimmten Vorlagen, die als Klassen bezeichnet"
"Den Konstruktoransatz findet man in Sprachen wie EMERALD, den Prototypenansatz in Sprachen wie SELF oder JavaSCRIPT und den Klassenansatz in Sprachen wie SMALLTALK, C++, EIFFEL, Java, C-Sharp, SCALA und vielen anderen mehr. Aus verschiedenen Gründen hat sich die dritte Variante, die klassenbasierte Form der Objektorientierung (wobei die Klassen die erwähnten Vorlagen sind) gegenüber der zweiten, der prototypenbasierten Form der Objektorientierung weitgehend durchgesetzt. Die erste Variante findet im Zuge einer gewissen Ernüchterung bzgl. der objektorientierten Programmierung zunehmend Anhänger, und zwar da, wo Objekte und dynamisches Binden (s. Abschnitt 12) im Kontext traditioneller imperativer Programmierung angeboten werden sollen. Sie liegt damit aber außerhalb des Gegenstands dieses Kurstextes. Die Dominanz der klassenbasierten Form der objektorientierten Programmierung liegt vermutlich zum einen daran, dass Klassen ein klassisches, in anderen Disziplinen wie der Mathematik oder der Biologie fest etabliertes Ordnungskonzept darstellen, mit dessen Hilfe sich auch objektorientierte Programme gut strukturieren lassen, und zum anderen daran, dass Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen (also Sprachen, bei denen alle Variablen und Funktionen bei der Deklaration einen Typ zugeordnet bekommen und der Variableninhalt immer vom deklarierten Typ sein muss) übernehmen kann (der Gegenstand von Kurseinheit 3). Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann, z. B. indem sie eine Methodendefinition nur für ein einziges Objekt abzuändern erlaubt. Letzteres ist z. B. bei der Programmierung von grafischen Bedienoberflächen, bei der das Drücken verschiedener Buttons jeweils verschiedene Ereignisse auslöst (Methoden aufruft), sehr praktisch. Nicht umsonst ist JavaSCRIPT als Programmiersprache für interaktive Webseiten so erfolgreich. Auch wenn es gute Gründe für die prototypenbasierte Form der objektorientierten Programmierung gibt (und sich deswegen jedes Werk zum Thema objektorientierte Programmierung — so wie auch das Ihnen vorliegende — gemüßigt fühlt, darauf hinzuweisen, dass es sie gibt), werde ich mich im Folgenden vornehmlich Klassen als strukturbildenden Konzepten der objektorientierten Programmierung zuwenden und nur hier und da Prototypen kurz die Referenz erweisen.",Was sind die drei Varianten der Objektorientierung?,"Die drei Varianten der Objektorientierung sind der Konstruktoransatz, der Prototypenansatz und der Klassenansatz. Die klassenbasierte Form der Objektorientierung hat sich gegenüber der prototypenbasierten Form weitgehend durchgesetzt, da Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen übernehmen kann. Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann."
"Viele Applikationen, insbesondere solche mit GUI, benötigen neben der direkten Kommunikation zwischen Objekten, die sich kennen (die ja durch Nachrichtenaustausch bzw., je nach Diktion, durch Methodenaufrufe bewerkstelligt wird), auch eine Kommunikation mit unbekannten. Die Problematik hatten wir im Kontext von SMALLTALK bereits besprochen.",Was ist die Problematik bei der Kommunikation mit unbekannten Objekten?,"Die Problematik bei der Kommunikation mit unbekannten Objekten ist, dass diese Objekte nicht direkt bekannt sind und somit kein Nachrichtenaustausch stattfinden kann. Um dieses Problem zu lösen, werden sogenannte Broker-Objekte eingesetzt, die als Vermittler zwischen den Objekten fungieren. Diese Broker-Objekte stellen sicher, dass Nachrichten an die richtigen Objekte weitergeleitet werden, auch wenn diese unbekannt sind. In SMALLTALK wird dieses Problem durch den Objekt-Manager gelöst, der eine Art Broker-Objekt darstellt."
"Nun kommt dieses Problem so häufig vor, dass sich MICROSOFT dafür entschieden hat, es zumindest teilweise von der Ebene der Programmierung (wo es in Form eines sog. Patterns abgehandelt wird; mehr dazu in Kurs 01853) auf die Ebene der Programmiersprache zu heben (in SMALLTALK, wo diese Unterscheidung nicht so ausgeprägt ist, war das Problem ja mittels einer Implementierung der benötigten Mechanismen in der Klasse Object gelöst worden, von der alle anderen erben).",Wie hat Microsoft das Problem der temporären Variablen gelöst?,"Microsoft hat das Problem der temporären Variablen zumindest teilweise auf die Ebene der Programmiersprache gehoben, indem es eine Möglichkeit geschaffen hat, diese Unterscheidung in der Programmiersprache zu behandeln."
"Nun kommt dieses Problem so häufig vor, dass sich MICROSOFT dafür entschieden hat, es zumindest teilweise von der Ebene der Programmierung (wo es in Form eines sog. Patterns abgehandelt wird; mehr dazu in Kurs 01853) auf die Ebene der Programmiersprache zu heben (in SMALLTALK, wo diese Unterscheidung nicht so ausgeprägt ist, war das Problem ja mittels einer Implementierung der benötigten Mechanismen in der Klasse Object gelöst worden, von der alle anderen erben).","Warum hat Microsoft sich entschieden, das Problem der Unterscheidung zwischen Verweis- und Wertsemantik auf die Ebene der Programmiersprache zu heben?","Das Problem der Unterscheidung zwischen Verweis- und Wertsemantik tritt sehr häufig auf. Microsoft hat sich dafür entschieden, es zumindest teilweise auf die Ebene der Programmiersprache zu heben, um es mittels einer Implementierung der benötigten Mechanismen in der Sprache zu lösen. In Smalltalk, wo diese Unterscheidung nicht so ausgeprägt ist, war das Problem mittels einer Implementierung in der Klasse Object gelöst worden, von der alle anderen Klassen erben."
"Zu diesem Zweck wurde das Konstrukt des Events (Ereignisses) eingeführt, über das sog. Event handler aktiviert werden können. Dabei handelt es sich um die in Abschnitt 50.4.1 skizzierten sog. Delegates. Leider ist die Syntax von C-Sharp, die mit Deklaration und Registrierung von Eventhandlern sowie der Verbreitung von Ereignissen verbunden ist, nach Ansicht des Autors dieses Textes komplett unleserlich geraten, so dass hier auf eine weitergehende Befassung mit dem Thema verzichtet wird.",Was ist ein Event (Ereignis) in C-Sharp und wie wird es gehandhabt?,"Ein Event (Ereignis) in C-Sharp ist ein Konstrukt, über das sog. Event handler aktiviert werden können. Die Handhabung von Ereignissen erfolgt über die in Abschnitt 50.4.1 skizzierten sog. Delegates. Leider ist die Syntax von C-Sharp, die mit Deklaration und Registrierung von Eventhandlern sowie der Verbreitung von Ereignissen verbunden ist, nach Ansicht des Autors dieses Textes komplett unleserlich geraten, so dass hier auf eine weitergehende Befassung mit dem Thema verzichtet wird."
"Zu diesem Zweck wurde das Konstrukt des Events (Ereignisses) eingeführt, über das sog. Event handler aktiviert werden können. Dabei handelt es sich um die in Abschnitt 50.4.1 skizzierten sog. Delegates. Leider ist die Syntax von C-Sharp, die mit Deklaration und Registrierung von Eventhandlern sowie der Verbreitung von Ereignissen verbunden ist, nach Ansicht des Autors dieses Textes komplett unleserlich geraten, so dass hier auf eine weitergehende Befassung mit dem Thema verzichtet wird.",Was ist ein Event (Ereignis) in C-Sharp und wozu dient es?,"In C-Sharp wurde das Konstrukt des Events (Ereignisses) eingeführt, um sog. Event handler aktivieren zu können. Ein Event handler ist ein Delegat, der auf ein Ereignis reagiert. Das Ereignis dient dazu, auf etwas zu reagieren, wie z.B. auf eine Benutzerinteraktion. Leider ist die Syntax von C-Sharp, die mit Deklaration und Registrierung von Eventhandlern sowie der Verbreitung von Ereignissen verbunden ist, nach Ansicht des Autors dieses Textes komplett unleserlich geraten."
"Zu diesem Zweck wurde das Konstrukt des Events (Ereignisses) eingeführt, über das sog. Event handler aktiviert werden können. Dabei handelt es sich um die in Abschnitt 50.4.1 skizzierten sog. Delegates. Leider ist die Syntax von C-Sharp, die mit Deklaration und Registrierung von Eventhandlern sowie der Verbreitung von Ereignissen verbunden ist, nach Ansicht des Autors dieses Textes komplett unleserlich geraten, so dass hier auf eine weitergehende Befassung mit dem Thema verzichtet wird.",Was ist ein Event (Ereignis) in der Programmierung?,"Ein Event (Ereignis) ist ein Konstrukt in der Programmierung, das dazu dient, eine bestimmte Aktion auszulösen, wenn ein bestimmter Zustand erreicht ist oder eine bestimmte Benutzerinteraktion erfolgt. Über sog. Eventhandler können dann auf diese Ereignisse reagiert werden."
"Programme bestehen aus Schlüsselwörtern und -zeichen sowie aus Programmelementen, deren Namen, die sogenannten Bezeichner, frei vergeben werden können. Viele Programmiersprachen verlangen, dass man diese Programmelemente vor der ersten Verwendung vereinbart oder deklariert. Durch eine solche Deklaration gibt man dem Compiler den Bezeichner bekannt; er kann ihn in der Folge wiedererkennen und mit der Deklaration in Verbindung bringen.",Was ist eine Deklaration in Programmierung?,"Eine Deklaration in Programmierung ist ein Vorgang, bei dem man Programmelemente, wie Variablen oder Funktionen, vor der ersten Verwendung bekannt gibt. Dabei wird der Bezeichner dem Compiler bekannt gegeben, damit er ihn in der Folge wiedererkennen und mit der Deklaration in Verbindung bringen kann."
"Programme bestehen aus Schlüsselwörtern und -zeichen sowie aus Programmelementen, deren Namen, die sogenannten Bezeichner, frei vergeben werden können. Viele Programmiersprachen verlangen, dass man diese Programmelemente vor der ersten Verwendung vereinbart oder deklariert. Durch eine solche Deklaration gibt man dem Compiler den Bezeichner bekannt; er kann ihn in der Folge wiedererkennen und mit der Deklaration in Verbindung bringen.",Was ist die Bedeutung einer Deklaration in Programmierung?,"Eine Deklaration in Programmierung ist ein Prozess, bei dem man einem Compiler einen Bezeichner bekannt gibt, bevor er zum ersten Mal verwendet wird. Dies ermöglicht es dem Compiler, den Bezeichner in der Folge wiederzuerkennen und mit der Deklaration in Verbindung zu bringen."
"Bei der Definition wird dem Bezeichner das zugeordnet, wofür er steht. Im Falle einer Variable ist das eine bestimmte Stelle im Speicher, die genügend Platz bietet, um den Wert der Variable aufzunehmen. Im Falle einer Methode sind es die Anweisungen, die durch die Methode zusammengefasst werden. Nicht selten (aber immer abhängig von der Programmiersprache) erfolgen Deklaration und Definition in einem Ausdruck. In solchen Fällen spricht man von Deklaration beziehungsweise Definition des Programmelementes, abhängig davon, was man gerade meint. Bei Variablen ist die Definition in der Regel implizit und aus der Deklaration ableitbar (der Speicherplatz wird vom Compiler automatisch zugewiesen), so dass man hier häufig Deklaration meint, selbst wenn man Definition sagt. Bei Methoden hingegen ist die Unterscheidung essentiell: In ihrer Deklaration wird ihre Signatur, das ist ihr Name (in SMALLTALK der Nachrichtenselektor), und die Liste der formalen Parameter bekanntgegeben. In ihrer Definition wird der Signatur der Methodenrumpf, also die Folge der mit der Methode verbundenen und bei einem Aufruf auszuführenden Anweisungen, zugeordnet. Von der Definition einer Variable zu unterscheiden ist übrigens ihre Initialisierung, bei der ihr (der dafür vorgesehenen Speicherstelle) ein Anfangswert zugewiesen wird; in manchen Kontexten (insbesondere im Kontext der Programmanalyse) ist mit Variablendefinition aber auch die Zuweisung eines Werts an eine Variable ganz allgemein gemeint.",Was ist der Unterschied zwischen Deklaration und Definition einer Variablen?,"Bei der Deklaration wird dem Bezeichner das zugeordnet, wofür er steht, während bei der Definition der Speicherplatz für die Variable zugewiesen wird. In manchen Kontexten wird der Begriff Definition aber auch für die Zuweisung eines Anfangswerts an eine Variable verwendet."
"Bei der Definition wird dem Bezeichner das zugeordnet, wofür er steht. Im Falle einer Variable ist das eine bestimmte Stelle im Speicher, die genügend Platz bietet, um den Wert der Variable aufzunehmen. Im Falle einer Methode sind es die Anweisungen, die durch die Methode zusammengefasst werden. Nicht selten (aber immer abhängig von der Programmiersprache) erfolgen Deklaration und Definition in einem Ausdruck. In solchen Fällen spricht man von Deklaration beziehungsweise Definition des Programmelementes, abhängig davon, was man gerade meint. Bei Variablen ist die Definition in der Regel implizit und aus der Deklaration ableitbar (der Speicherplatz wird vom Compiler automatisch zugewiesen), so dass man hier häufig Deklaration meint, selbst wenn man Definition sagt. Bei Methoden hingegen ist die Unterscheidung essentiell: In ihrer Deklaration wird ihre Signatur, das ist ihr Name (in SMALLTALK der Nachrichtenselektor), und die Liste der formalen Parameter bekanntgegeben. In ihrer Definition wird der Signatur der Methodenrumpf, also die Folge der mit der Methode verbundenen und bei einem Aufruf auszuführenden Anweisungen, zugeordnet. Von der Definition einer Variable zu unterscheiden ist übrigens ihre Initialisierung, bei der ihr (der dafür vorgesehenen Speicherstelle) ein Anfangswert zugewiesen wird; in manchen Kontexten (insbesondere im Kontext der Programmanalyse) ist mit Variablendefinition aber auch die Zuweisung eines Werts an eine Variable ganz allgemein gemeint.",Was ist die Signatur einer Methode?,Die Signatur einer Methode ist ihr Name und die Liste der formalen Parameter.
"Bei der Definition wird dem Bezeichner das zugeordnet, wofür er steht. Im Falle einer Variable ist das eine bestimmte Stelle im Speicher, die genügend Platz bietet, um den Wert der Variable aufzunehmen. Im Falle einer Methode sind es die Anweisungen, die durch die Methode zusammengefasst werden. Nicht selten (aber immer abhängig von der Programmiersprache) erfolgen Deklaration und Definition in einem Ausdruck. In solchen Fällen spricht man von Deklaration beziehungsweise Definition des Programmelementes, abhängig davon, was man gerade meint. Bei Variablen ist die Definition in der Regel implizit und aus der Deklaration ableitbar (der Speicherplatz wird vom Compiler automatisch zugewiesen), so dass man hier häufig Deklaration meint, selbst wenn man Definition sagt. Bei Methoden hingegen ist die Unterscheidung essentiell: In ihrer Deklaration wird ihre Signatur, das ist ihr Name (in SMALLTALK der Nachrichtenselektor), und die Liste der formalen Parameter bekanntgegeben. In ihrer Definition wird der Signatur der Methodenrumpf, also die Folge der mit der Methode verbundenen und bei einem Aufruf auszuführenden Anweisungen, zugeordnet. Von der Definition einer Variable zu unterscheiden ist übrigens ihre Initialisierung, bei der ihr (der dafür vorgesehenen Speicherstelle) ein Anfangswert zugewiesen wird; in manchen Kontexten (insbesondere im Kontext der Programmanalyse) ist mit Variablendefinition aber auch die Zuweisung eines Werts an eine Variable ganz allgemein gemeint.",Was ist der Unterschied zwischen Deklaration und Definition einer Methode?,"Bei der Deklaration wird die Signatur einer Methode bekannt gegeben, bei der Definition wird der Signatur der Methodenrumpf zugeordnet."
"Bei der Definition wird dem Bezeichner das zugeordnet, wofür er steht. Im Falle einer Variable ist das eine bestimmte Stelle im Speicher, die genügend Platz bietet, um den Wert der Variable aufzunehmen. Im Falle einer Methode sind es die Anweisungen, die durch die Methode zusammengefasst werden. Nicht selten (aber immer abhängig von der Programmiersprache) erfolgen Deklaration und Definition in einem Ausdruck. In solchen Fällen spricht man von Deklaration beziehungsweise Definition des Programmelementes, abhängig davon, was man gerade meint. Bei Variablen ist die Definition in der Regel implizit und aus der Deklaration ableitbar (der Speicherplatz wird vom Compiler automatisch zugewiesen), so dass man hier häufig Deklaration meint, selbst wenn man Definition sagt. Bei Methoden hingegen ist die Unterscheidung essentiell: In ihrer Deklaration wird ihre Signatur, das ist ihr Name (in SMALLTALK der Nachrichtenselektor), und die Liste der formalen Parameter bekanntgegeben. In ihrer Definition wird der Signatur der Methodenrumpf, also die Folge der mit der Methode verbundenen und bei einem Aufruf auszuführenden Anweisungen, zugeordnet. Von der Definition einer Variable zu unterscheiden ist übrigens ihre Initialisierung, bei der ihr (der dafür vorgesehenen Speicherstelle) ein Anfangswert zugewiesen wird; in manchen Kontexten (insbesondere im Kontext der Programmanalyse) ist mit Variablendefinition aber auch die Zuweisung eines Werts an eine Variable ganz allgemein gemeint.",Was ist die Initialisierung einer Variablen?,Die Initialisierung einer Variablen ist die Zuweisung eines Anfangswerts an eine Variable.
"Deklaration und Definition dienen letztlich nur einem Zweck: der Verwendung. Die Verwendung eines Programmelements äußert sich darin, dass sein Name, der Bezeichner, im Programmtext angeführt oder referenziert wird. An der Stelle der Verwendung steht eine Variable für den Wert, den sie hat (bzw., wenn sie auf der linken Seite einer Zuweisung auftaucht, haben soll). Der Bezeichner einer Methode steht hingegen meistens für ihren Aufruf (in manchen Sprachen durch ein Schlüsselwort eingeleitet), seltener auch für einen Zeiger auf die Implementierung.",Was ist der Zweck der Deklaration und Definition von Programmelementen?,"Der Zweck der Deklaration und Definition von Programmelementen ist die Verwendung. Die Verwendung eines Programmelements äußert sich darin, dass sein Name, der Bezeichner, im Programmtext angeführt oder referenziert wird."
"Variablendeklarationen haben Sie in SMALLTALK bislang an zwei Stellen gesehen: als formale Parameter in Methodendeklarationen und als temporäre, lokale Variablen in Methodenrümpfen. Im Beispiel stecken die Deklarationen von a und b als formaler Parameter und von c als temporäre Variable. Weitere Formen der Deklaration werden Sie im Verlauf dieses Kurstextes noch kennenlernen.",Wo können Variablen in SMALLTALK deklariert werden?,"Variablen können in SMALLTALK als formale Parameter in Methodendeklarationen und als temporäre, lokale Variablen in Methodenrümpfen deklariert werden."
"Variablendeklarationen haben Sie in SMALLTALK bislang an zwei Stellen gesehen: als formale Parameter in Methodendeklarationen und als temporäre, lokale Variablen in Methodenrümpfen. Im Beispiel stecken die Deklarationen von a und b als formaler Parameter und von c als temporäre Variable. Weitere Formen der Deklaration werden Sie im Verlauf dieses Kurstextes noch kennenlernen.",Was sind formale Parameter in SMALLTALK?,"Formale Parameter sind Variablen, die in der Deklaration einer Methode angegeben werden und Werte entgegennehmen, die bei einem Methodenaufruf übergeben werden."
"Variablendeklarationen haben Sie in SMALLTALK bislang an zwei Stellen gesehen: als formale Parameter in Methodendeklarationen und als temporäre, lokale Variablen in Methodenrümpfen. Im Beispiel stecken die Deklarationen von a und b als formaler Parameter und von c als temporäre Variable. Weitere Formen der Deklaration werden Sie im Verlauf dieses Kurstextes noch kennenlernen.",Was sind temporäre Variablen in SMALLTALK?,"Temporäre Variablen sind lokale Variablen, die in der Methode deklariert und verwendet werden, um temporäre Werte zu speichern oder Berechnungen durchzuführen. Sie sind nur innerhalb der Methode verfügbar und verlieren ihren Wert, sobald die Methode beendet ist."
"In untypisierten Sprachen werden Variablen ohne Angabe eines Typs (wie z. B. in SMALLTALK) oder gar nicht (etliche Skriptsprachen und z. B. BASIC) deklariert. Letzteres hat den erheblichen Nachteil, dass Variablen durch ihre erste Verwendung quasi implizit deklariert (und damit angelegt) werden, was bei Schreibfehlern dazu führt, dass man plötzlich zwei Variablen anstatt einer hat, wobei die eine mit der anderen nichts zu tun hat. Eine solche Einladung zu Programmierfehlern sollten Sie als diejenige, die die Entscheidung für die Auswahl einer Sprache zu treffen hat, stets ablehnen.","Was sind die Nachteile von Sprachen, die Variablen nicht deklarieren?","Wenn Variablen nicht deklariert werden, können Schreibfehler dazu führen, dass plötzlich zwei Variablen anstatt einer existieren, was zu Programmierfehlern führen kann. Diese Art von Fehlern ist schwer zu erkennen und zu beheben."
"In untypisierten Sprachen werden Variablen ohne Angabe eines Typs (wie z. B. in SMALLTALK) oder gar nicht (etliche Skriptsprachen und z. B. BASIC) deklariert. Letzteres hat den erheblichen Nachteil, dass Variablen durch ihre erste Verwendung quasi implizit deklariert (und damit angelegt) werden, was bei Schreibfehlern dazu führt, dass man plötzlich zwei Variablen anstatt einer hat, wobei die eine mit der anderen nichts zu tun hat. Eine solche Einladung zu Programmierfehlern sollten Sie als diejenige, die die Entscheidung für die Auswahl einer Sprache zu treffen hat, stets ablehnen.","Warum sollte man die Verwendung von Sprachen, die Variablen nicht deklarieren, vermeiden?","Man sollte die Verwendung von Sprachen, die Variablen nicht deklarieren, vermeiden, weil dies zu Programmierfehlern führen kann, wenn Variablen durch ihre erste Verwendung implizit deklariert werden und Schreibfehler dazu führen, dass man plötzlich zwei Variablen anstatt einer hat, die nichts miteinander zu tun haben."
"Logischerweise können Instanzvariablen in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Typische Eigenschaften sind beispielsweise die Farbe von etwas oder der Name; sie unterscheiden sich inhaltlich von Beziehungen dadurch, dass das bezogene Objekt seine Bedeutung verliert, wenn es isoliert betrachtet wird. Ein Objekt wie ""Rot"" ist allein nichts anderes als eine Farbe; es erhält erst Bedeutung, wenn es als Attribut eines Objekts wie ""Apfel"" betrachtet wird. Das Gleiche gilt für ""Schmidtchen"" oder ""1"". Zudem ist zu beachten, dass Attributwerte wie die genannten in der Regel selbst keine Attribute besitzen oder Beziehungen zu anderen Objekten nicht eingehen.Es ist jedoch wichtig zu beachten, dass dieses Unterscheidungskriterium relativ zur jeweils betrachteten Domäne ist. Wenn es beispielsweise um Farben geht, hat ""Rot"" an sich bereits eine Bedeutung und kann vollwertige Beziehungen zu anderen Objekten eingehen, wie zum Beispiel ""Grün"" als sein Komplementärkontrast.",Was sind Attribute?,"Attribute sind Instanzvariablen, die die Eigenschaften eines Objekts festhalten."
"Logischerweise können Instanzvariablen in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Typische Eigenschaften sind beispielsweise die Farbe von etwas oder der Name; sie unterscheiden sich inhaltlich von Beziehungen dadurch, dass das bezogene Objekt seine Bedeutung verliert, wenn es isoliert betrachtet wird. Ein Objekt wie ""Rot"" ist allein nichts anderes als eine Farbe; es erhält erst Bedeutung, wenn es als Attribut eines Objekts wie ""Apfel"" betrachtet wird. Das Gleiche gilt für ""Schmidtchen"" oder ""1"". Zudem ist zu beachten, dass Attributwerte wie die genannten in der Regel selbst keine Attribute besitzen oder Beziehungen zu anderen Objekten nicht eingehen.Es ist jedoch wichtig zu beachten, dass dieses Unterscheidungskriterium relativ zur jeweils betrachteten Domäne ist. Wenn es beispielsweise um Farben geht, hat ""Rot"" an sich bereits eine Bedeutung und kann vollwertige Beziehungen zu anderen Objekten eingehen, wie zum Beispiel ""Grün"" als sein Komplementärkontrast.",Was sind Kategorien von Instanzvariablen?,"Instanzvariablen können logischerweise in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Eigenschaften sind Attribute wie Farbe oder Name, die ihre Bedeutung verlieren, wenn sie isoliert betrachtet werden. Beziehungen hingegen repräsentieren Verbindungen zwischen Objekten und behalten ihre Bedeutung auch isoliert betrachtet."
"Wenn wir von Attributwerten sprechen, ist das nicht zufällig. Häufig haben Variablen, die Attribute repräsentieren, zumindest logisch eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Es ist sinnvoll, dass die Änderung des Namens (genauer gesagt, des Namensobjekts) bei einer Person nicht gleichzeitig andere Personen betrifft, die denselben (nicht denselben!) Namen haben. Eine ähnliche Überlegung spielt auch im Zusammenhang mit der Betrachtung des Zustands eines Objekts eine Rolle.","Welche Semantik haben Variablen, die Attribute repräsentieren?","Variablen, die Attribute repräsentieren, haben in der Regel eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Dies ermöglicht es, dass Änderungen an einem Attributwert nicht automatisch andere Objekte mit dem gleichen Attributwert beeinflussen."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können, was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.",Welche Objekte sind in SMALLTALK veränderbar?,"Atomare Objekte und Objekte, die aus Symbolliteralen hervorgegangen sind, sind grundsätzlich nicht veränderbar. Zusammengesetzte Objekte in SMALLTALK sind jedoch veränderbar."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können, was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.",Warum sind atomare Objekte grundsätzlich nicht veränderbar?,"Atomare Objekte sind grundsätzlich nicht veränderbar, da es keinen Sinn ergibt, sie zu verändern. Zum Beispiel macht es keinen Sinn, aus einer ""1"" eine ""2"" zu machen."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können, was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.",Warum könnten zusammengesetzte Objekte veränderbar sein?,"Zusammengesetzte Objekte könnten veränderbar sein, da es sinnvoll sein kann, eine Komponente durch eine andere zu ersetzen."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können, was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.",Sind Array-Objekten in SMALLTALK veränderbar?,"Zusammengesetzte Array-Objekte sind in der Regel veränderbar. Ob Array-Objekte, die aus Literalen erzeugt wurden, veränderbar sein sollen, ist ansichtssache und wird von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können, was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.",Warum sind zusammengesetzte Objekte in SMALLTALK grundsätzlich veränderbar?,"Zusammengesetzte Objekte sind in SMALLTALK grundsätzlich veränderbar, da dies eine Voraussetzung dafür ist, dass Objekte einen Zustand haben können."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können, was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.",Warum bieten immer mehr Sprachen unveränderliche Objekte an?,Immer mehr Sprachen bieten unveränderliche Objekte an aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung.
"Die Sequenz als Kontrollstruktur besagt lediglich, dass textuell aufeinanderfolgende Anweisungen eines Programms (einer Methode) auch zeitlich nacheinander ausgeführt werden. Die zeitliche Sequenz aufeinanderfolgender Anweisungen kann lediglich durch andere Kontrollstrukturen (in SMALLTALK nur durch den Methodenaufruf) unterbrochen werden. Dies gilt auch für parallele Ausführung, die man sich wie die gleichzeitige Abarbeitung zweier sequentieller Programme auf denselben Objekten vorstellen kann.",Was ist die Sequenz als Kontrollstruktur in SMALLTALK?,"Die Sequenz als Kontrollstruktur besagt lediglich, dass textuell aufeinanderfolgende Anweisungen eines Programms (einer Methode) auch zeitlich nacheinander ausgeführt werden. Die zeitliche Sequenz aufeinanderfolgender Anweisungen kann lediglich durch andere Kontrollstrukturen unterbrochen werden."
"Die Sequenz als Kontrollstruktur besagt lediglich, dass textuell aufeinanderfolgende Anweisungen eines Programms (einer Methode) auch zeitlich nacheinander ausgeführt werden. Die zeitliche Sequenz aufeinanderfolgender Anweisungen kann lediglich durch andere Kontrollstrukturen (in SMALLTALK nur durch den Methodenaufruf) unterbrochen werden. Dies gilt auch für parallele Ausführung, die man sich wie die gleichzeitige Abarbeitung zweier sequentieller Programme auf denselben Objekten vorstellen kann.",Wie kann eine Sequenz unterbrochen werden?,In SMALLTALK kann die zeitliche Sequenz von aufeinanderfolgenden Anweisungen nur durch den Methodenaufruf unterbrochen werden.
"Obwohl C-Sharp das Konzept der Interface-Implementierung aus Java übernommen hat, wurde seine Rolle hier deutlich gestärkt. In C-Sharp ist es möglich, dass eine Klasse dieselbe Methodendeklaration, die von verschiedenen Interfaces ""geerbt"" wurde, getrennt voneinander implementiert. Dies wird mithilfe von sogenannten expliziten Interfaceimplementierungen erreicht, wie im folgenden Beispiel dargestellt (beachten Sie, dass in C-Sharp der Doppelpunkt die Schlüsselwörter ""extends"" und ""implements"" aus Java ersetzt).",Was sind explizite Interfaceimplementierungen in C-Sharp?,"Explizite Interfaceimplementierungen in C-Sharp ermöglichen es einer Klasse, dieselbe Methodendeklaration, die von verschiedenen Interfaces ""geerbt"" wurde, getrennt voneinander zu implementieren. Dies wird erreicht, indem die Methodendeklaration mit dem Namen des Interfaces und dem Doppelpunkt versehen wird."
"Der Nutzen der expliziten Interfaceimplementierung liegt darin, dass die Methode gibTelefonnummer() je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Der Typ der Variable (oder des Ausdrucks), die als Empfänger fungiert, gibt gewissermaßen die Rolle vor, in der das Objekt angesprochen wird (hier: Angestellte oder Privatperson). Es ist weder vorgesehen noch möglich, etwas wie x.Angestellte.gibTelefonnummer() an der Aufrufstelle zu schreiben (wobei x das Objekt bezeichnet); stattdessen steht einfach x.gibTelefonnummer(). Falls die Methodendeklaration Telefonnummer gibTelefonnummer() von einem gemeinsamen Superinterface von Angestellte und Privatperson, z. B. Erreichbar, geerbt würde, wäre das Programm ungültig. Es muss immer der tatsächlich deklarierende Typ als Qualifizierer angegeben werden.",Was ist der Nutzen der expliziten Interfaceimplementierung?,"Der Nutzen der expliziten Interfaceimplementierung liegt darin, dass die Methode gibTelefonnummer() je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Der Typ der Variablen (oder des Ausdrucks), die als Empfänger fungiert, gibt gewissermaßen die Rolle vor, in der das Objekt angesprochen wird."
"Falls im obigen Beispiel für die beiden expliziten Interfaceimplementierungen von gibTelefonnummer() nicht wie in Java der Zugriffsmodifikator ""public"" angegeben wurde, geschah dies nicht ohne Grund. In C-Sharp ist es nämlich möglich, Methoden nicht als ""public"" zu deklarieren und dennoch per Interfaceimplementierung von außen darauf zuzugreifen. Allerdings ist dies an die explizite Interfaceimplementierung gebunden. Die sogenannte implizite Interfaceimplementierung, bei der manchmal nicht klar ist, welcher der aufgelisteten Supertypen ein Interface und welcher eine Superklasse ist, wird durch eine Namenskonvention aufgelöst: Im Common Type System von .NET sollten alle Interfacenamen mit einem ""I"" beginnen. Dies steht in der Tradition der bei MICROSOFT weit verbreiteten und nach dem früheren Mitarbeiter CHARLES SIMONYI benannten ungarischen Notation.","Was ist die Bedeutung des Buchstabens ""I"" am Anfang von Interfacenamen in C-Sharp?","Der Buchstabe ""I"" am Anfang von Interfacenamen in C-Sharp ist eine Namenskonvention, die aufzeigen soll, dass es sich bei dem Namen um ein Interface und nicht um eine Superklasse handelt. Diese Namenskonvention ist Teil des Common Type Systems von .NET."
"Falls im obigen Beispiel für die beiden expliziten Interfaceimplementierungen von gibTelefonnummer() nicht wie in Java der Zugriffsmodifikator ""public"" angegeben wurde, geschah dies nicht ohne Grund. In C-Sharp ist es nämlich möglich, Methoden nicht als ""public"" zu deklarieren und dennoch per Interfaceimplementierung von außen darauf zuzugreifen. Allerdings ist dies an die explizite Interfaceimplementierung gebunden. Die sogenannte implizite Interfaceimplementierung, bei der manchmal nicht klar ist, welcher der aufgelisteten Supertypen ein Interface und welcher eine Superklasse ist, wird durch eine Namenskonvention aufgelöst: Im Common Type System von .NET sollten alle Interfacenamen mit einem ""I"" beginnen. Dies steht in der Tradition der bei MICROSOFT weit verbreiteten und nach dem früheren Mitarbeiter CHARLES SIMONYI benannten ungarischen Notation.",Was ist die Funktion der ungarischen Notation in C-Sharp?,"Die ungarische Notation in C-Sharp wird verwendet, um die Typen von Variablen und Methoden zu identifizieren, indem man den Variablen- oder Methodennamen mit einem Präfix versehen, das den Typ angibt. In diesem Fall wird die ungarische Notation verwendet, um die implizite Interfaceimplementierung in C-Sharp aufzulösen, indem alle Interfacenamen mit einem ""I"" beginnen."
"Explizite Interfaceimplementierungen können nicht überschrieben werden und dürfen nicht als ""virtual"" deklariert sein. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut. Es ist jedoch wichtig zu beachten, dass diese erneute explizite Implementierung keine Überschreibung darstellt. Insbesondere findet bei Aufruf der explizit implementierten Methode kein dynamisches Binden statt.","Was bedeutet es, wenn eine Klasse explizite Interfaceimplementierungen erbt?","Wenn eine Klasse von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt sie diese Implementierungen ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut. Es ist jedoch wichtig zu beachten, dass diese erneute explizite Implementierung keine Überschreibung darstellt und bei Aufruf der explizit implementierten Methode kein dynamisches Binden stattfindet."
"Explizite Interfaceimplementierungen können nicht überschrieben werden und dürfen nicht als ""virtual"" deklariert sein. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut. Es ist jedoch wichtig zu beachten, dass diese erneute explizite Implementierung keine Überschreibung darstellt. Insbesondere findet bei Aufruf der explizit implementierten Methode kein dynamisches Binden statt.","Was passiert, wenn eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, diese Methode erneut implementiert?","Wenn eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, diese Methode erneut implementiert, dann stellt dies keine Überschreibung dar und findet bei Aufruf der explizit implementierten Methode kein dynamisches Binden statt."
"Die Einführung von Typäquivalenz und Typkonformität bezog sich bislang lediglich auf das Verhältnis der Typdefinitionen, also der Intensionen der Typen. Die Frage des Zusammenhangs der Wertebereiche der Typen, also der Extensionen, ist dabei unberücksichtigt geblieben. Wenn aber die obige Definition von Typkorrektheit weiter Bestand haben soll, dann müssen die Werte zuweisungskompatibler Typen zum Wertebereich des Typen, an den zugewiesen werden soll, gehören. Zur Erinnerung: Typannotationen stellen Invarianten dar, die die möglichen Werte einer Variable beschränken. Diese Invarianten dürfen durch Zuweisungen nicht verletzt werden. Wenn man aber nun Zuweisungen von einem anderen Typen zulässt, dann wird die Typkorrektheit nur dann nicht verletzt, wenn der Wertebereich des anderen Typen (seine Extension) in dem desjenigen, dem zugewiesen wird, enthalten (inkludiert) ist. Mit anderen Worten: Damit eine Zuweisung a := b, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein. Im Fall der Typerweiterung ist dies nicht automatisch der Fall.",Was ist die Beziehung zwischen den Wertebereichen von Typen bei Typäquivalenz und Typkonformität?,"Bei Typäquivalenz und Typkonformität müssen die Werte zuweisungskompatibler Typen zum Wertebereich des Typs, an den zugewiesen wird, gehören. Die Wertebereiche der Typen müssen also inkludiert sein, damit die Typkorrektheit nicht verletzt wird."
"Die Einführung von Typäquivalenz und Typkonformität bezog sich bislang lediglich auf das Verhältnis der Typdefinitionen, also der Intensionen der Typen. Die Frage des Zusammenhangs der Wertebereiche der Typen, also der Extensionen, ist dabei unberücksichtigt geblieben. Wenn aber die obige Definition von Typkorrektheit weiter Bestand haben soll, dann müssen die Werte zuweisungskompatibler Typen zum Wertebereich des Typen, an den zugewiesen werden soll, gehören. Zur Erinnerung: Typannotationen stellen Invarianten dar, die die möglichen Werte einer Variable beschränken. Diese Invarianten dürfen durch Zuweisungen nicht verletzt werden. Wenn man aber nun Zuweisungen von einem anderen Typen zulässt, dann wird die Typkorrektheit nur dann nicht verletzt, wenn der Wertebereich des anderen Typen (seine Extension) in dem desjenigen, dem zugewiesen wird, enthalten (inkludiert) ist. Mit anderen Worten: Damit eine Zuweisung a := b, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein. Im Fall der Typerweiterung ist dies nicht automatisch der Fall.",Was bedeutet Typäquivalenz und Typkonformität in Bezug auf Wertebereiche?,"Typäquivalenz und Typkonformität beziehen sich nicht nur auf das Verhältnis der Typdefinitionen, sondern auch auf den Zusammenhang der Wertebereiche der Typen. Wenn eine Zuweisung von einem anderen Typen zulässig ist, muss der Wertebereich des anderen Typs in dem desjenigen, dem zugewiesen wird, enthalten sein. Im Fall der Typerweiterung ist dies nicht automatisch der Fall."
"Die Einführung von Typäquivalenz und Typkonformität bezog sich bislang lediglich auf das Verhältnis der Typdefinitionen, also der Intensionen der Typen. Die Frage des Zusammenhangs der Wertebereiche der Typen, also der Extensionen, ist dabei unberücksichtigt geblieben. Wenn aber die obige Definition von Typkorrektheit weiter Bestand haben soll, dann müssen die Werte zuweisungskompatibler Typen zum Wertebereich des Typen, an den zugewiesen werden soll, gehören. Zur Erinnerung: Typannotationen stellen Invarianten dar, die die möglichen Werte einer Variable beschränken. Diese Invarianten dürfen durch Zuweisungen nicht verletzt werden. Wenn man aber nun Zuweisungen von einem anderen Typen zulässt, dann wird die Typkorrektheit nur dann nicht verletzt, wenn der Wertebereich des anderen Typen (seine Extension) in dem desjenigen, dem zugewiesen wird, enthalten (inkludiert) ist. Mit anderen Worten: Damit eine Zuweisung a := b, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein. Im Fall der Typerweiterung ist dies nicht automatisch der Fall.",Was ist die Bedingung für eine zulässige Zuweisung bei unterschiedlichen Typen?,"Damit eine Zuweisung a := b, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein."
"Auch nicht selbstverständlich ist die Teilmengenbeziehung bei der Typeinschränkung: Durch das Weglassen von Eigenschaften (Methoden) wird die Extension, also die Menge der Werte (Objekte), die darunter fallen, eher größer denn kleiner — je weniger spezifisch die Menge der geforderten Eigenschaften ist, desto mehr Objekte fallen darunter. Die sich daraus ergebende Teilmengebeziehung wäre also eher umgekehrt (die Extension des einschränkenden Typs enthält die des eingeschränkten). Etwas anders sieht es aus, wenn durch Typeinschränkung (Redefinition) die Ein- oder Rückgabetypen von Methoden beschränkt werden: Die Menge der Zeichnungen ist eine Teilmenge der Menge der Dokumente, auch weil sich Zeichnungen eben nur auf Plottern ausgeben lassen. Die Zuweisungskompatibilität von Zeichnung mit Dokument wäre also, was die Inklusion der Extensionen angeht, kein Problem. Man könnte nun die Typerweiterung unter oben gemachter Einschränkung und die zweite Form der Typeinschränkung als in dieselbe Richtung zielende Maßnahmen ansehen: Beide schränken Extensionen ein. Das lässt sich wie folgt erklären: Wenn man einer Menge von Objekten, die durch eine Anzahl Attribute alle gleichermaßen charakterisiert werden, weitere Attribute beimisst, dann schränkt man diese Menge ein, wenn die hinzugefügten Attribute nicht alle Objekte der Menge charakterisieren. Wenn man beispielsweise wie oben geschehen die Attributmenge des Typs Dokument um die Methode zeilen ^ <Collection> erweitert, dann fallen die Zeichnungen aus der durch Dokument beschriebenen Menge von Objekten heraus, weil sie keine Zeilen haben. Alternativ könnte man auch sagen, dass Dokumente grundsätzlich über Zeilen verfügen können, diese aber bei Zeichnungen immer in der Anzahl erscheint das weniger natürlich. 51 Man beachte die Parallelität zum Begriff der Spezialisierung (Abschnitt 9.2 in Kurseinheit 2): Der durch Typerweiterung oder -einschränkung aus Dokument hervorgegangene Typ Zeichnung ist spezieller als seine Vorlage. Nun ergibt sich aber gemäß obigem Beispiel (Zeilen 900–902) ein Sachverhalt, der trotz aller Harmonie von Typerweiterung und -einschränkung nicht weniger als den Verlust der Zuweisungskompatibilität bedeutet. Dieser resultiert jedoch bei genauerer Betrachtung nicht daraus, dass Zeichnungen keine Dokumente wären, sondern aus der mit der Typkorrektheit verbundenen, impliziten Allquantifiziertheit von Typinvarianten: Eine Methodendeklaration im Protokoll eines Typs Dokument wird nämlich interpretiert als „druckenAuf: ist definiert für alle Empfängerobjekte vom Typ Dokument und Parameterobjekte vom Typ Drucker“, was aber in dieser Allgemeinheit sachlich falsch ist. Typsysteme mit Typinvarianten der hier vorgestellten Art sind nicht in der Lage, andere als implizit allquantifizierte Aussagen über Wertebereiche zu treffen. Dies ist gewissermaßen der Preis der Einfachheit. Abhilfe schaffen neuere Typsysteme wie die Idee von den Dependent types, wie sie beispielsweise in SCALA zum Einsatz kommen: Hier kann man sich die Parametertypen von Methoden als Funktionen des Typs, zu dem die Methode gehört, vorstellen. Der Parametertyp von druckenAuf: aus obigem Beispiel wäre dann, in Abhängigkeit davon, ob die Methode auf einem Objekt vom Typ Dokument oder Zeichnung aufgerufen wird, Drucker oder Plotter. Wie man sich leicht vorstellen kann, ist die statische Prüfung solcher Bedingungen (Invarianz) aber nicht so einfach. Die Vereinigung von Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität und der daraus folgenden Typkorrektheit bietet der Begriff des Subtyps.",Was ist die Teilmengenbeziehung bei der Typeinschränkung?,"Durch das Weglassen von Eigenschaften (Methoden) wird die Extension, also die Menge der Werte (Objekte), die darunter fallen, eher größer denn kleiner. Die sich daraus ergebende Teilmengebeziehung wäre also eher umgekehrt (die Extension des einschränkenden Typs enthält die des eingeschränkten)."
"Auch nicht selbstverständlich ist die Teilmengenbeziehung bei der Typeinschränkung: Durch das Weglassen von Eigenschaften (Methoden) wird die Extension, also die Menge der Werte (Objekte), die darunter fallen, eher größer denn kleiner — je weniger spezifisch die Menge der geforderten Eigenschaften ist, desto mehr Objekte fallen darunter. Die sich daraus ergebende Teilmengebeziehung wäre also eher umgekehrt (die Extension des einschränkenden Typs enthält die des eingeschränkten). Etwas anders sieht es aus, wenn durch Typeinschränkung (Redefinition) die Ein- oder Rückgabetypen von Methoden beschränkt werden: Die Menge der Zeichnungen ist eine Teilmenge der Menge der Dokumente, auch weil sich Zeichnungen eben nur auf Plottern ausgeben lassen. Die Zuweisungskompatibilität von Zeichnung mit Dokument wäre also, was die Inklusion der Extensionen angeht, kein Problem. Man könnte nun die Typerweiterung unter oben gemachter Einschränkung und die zweite Form der Typeinschränkung als in dieselbe Richtung zielende Maßnahmen ansehen: Beide schränken Extensionen ein. Das lässt sich wie folgt erklären: Wenn man einer Menge von Objekten, die durch eine Anzahl Attribute alle gleichermaßen charakterisiert werden, weitere Attribute beimisst, dann schränkt man diese Menge ein, wenn die hinzugefügten Attribute nicht alle Objekte der Menge charakterisieren. Wenn man beispielsweise wie oben geschehen die Attributmenge des Typs Dokument um die Methode zeilen ^ <Collection> erweitert, dann fallen die Zeichnungen aus der durch Dokument beschriebenen Menge von Objekten heraus, weil sie keine Zeilen haben. Alternativ könnte man auch sagen, dass Dokumente grundsätzlich über Zeilen verfügen können, diese aber bei Zeichnungen immer in der Anzahl erscheint das weniger natürlich. 51 Man beachte die Parallelität zum Begriff der Spezialisierung (Abschnitt 9.2 in Kurseinheit 2): Der durch Typerweiterung oder -einschränkung aus Dokument hervorgegangene Typ Zeichnung ist spezieller als seine Vorlage. Nun ergibt sich aber gemäß obigem Beispiel (Zeilen 900–902) ein Sachverhalt, der trotz aller Harmonie von Typerweiterung und -einschränkung nicht weniger als den Verlust der Zuweisungskompatibilität bedeutet. Dieser resultiert jedoch bei genauerer Betrachtung nicht daraus, dass Zeichnungen keine Dokumente wären, sondern aus der mit der Typkorrektheit verbundenen, impliziten Allquantifiziertheit von Typinvarianten: Eine Methodendeklaration im Protokoll eines Typs Dokument wird nämlich interpretiert als „druckenAuf: ist definiert für alle Empfängerobjekte vom Typ Dokument und Parameterobjekte vom Typ Drucker“, was aber in dieser Allgemeinheit sachlich falsch ist. Typsysteme mit Typinvarianten der hier vorgestellten Art sind nicht in der Lage, andere als implizit allquantifizierte Aussagen über Wertebereiche zu treffen. Dies ist gewissermaßen der Preis der Einfachheit. Abhilfe schaffen neuere Typsysteme wie die Idee von den Dependent types, wie sie beispielsweise in SCALA zum Einsatz kommen: Hier kann man sich die Parametertypen von Methoden als Funktionen des Typs, zu dem die Methode gehört, vorstellen. Der Parametertyp von druckenAuf: aus obigem Beispiel wäre dann, in Abhängigkeit davon, ob die Methode auf einem Objekt vom Typ Dokument oder Zeichnung aufgerufen wird, Drucker oder Plotter. Wie man sich leicht vorstellen kann, ist die statische Prüfung solcher Bedingungen (Invarianz) aber nicht so einfach. Die Vereinigung von Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität und der daraus folgenden Typkorrektheit bietet der Begriff des Subtyps.",Was ist der Unterschied zwischen Typerweiterung und Typeinschränkung?,"Typerweiterung und Typeinschränkung sind zwei Möglichkeiten, den Typ eines Objekts zu ändern. Typerweiterung bedeutet, dass dem Objekt weitere Attribute hinzugefügt werden, wodurch die Menge der Objekte, die darunter fallen, eingeschränkt wird. Typeinschränkung hingegen beschränkt die Ein- oder Rückgabetypen von Methoden, wodurch die Menge der Objekte, die darunter fallen, ebenfalls eingeschränkt wird. Typerweiterung und Typeinschränkung können als in dieselbe Richtung zielende Maßnahmen angesehen werden, da beide die Extension einschränken."
"Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, die seine Ausführung bestimmen. Anders als in anderen Programmiersprachen gibt es in SMALLTALK nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf; alle anderen, einschließlich der Verzweigung und der Wiederholung (Schleife), müssen durch diese simuliert werden. Dies ist möglich, weil SMALLTALK Blöcke hat und weil in SMALLTALK (wie in allen anderen objektorientierten Programmiersprachen) der Methodenaufruf variabler ist als der gewöhnliche Prozedur- oder Funktionsaufruf, den Sie vielleicht von Sprachen wie PASCAL oder C kennen. Er enthält, wie bereits in Abschnitt 4.3.2 angedeutet, eine versteckte Fallunterscheidung in Form des dynamischen Bindens.",Was sind Kontrollstrukturen?,"Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, die seine Ausführung bestimmen. In SMALLTALK gibt es ie Sequenz und den dynamisch gebundenen Methodenaufruf."
"Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, die seine Ausführung bestimmen. Anders als in anderen Programmiersprachen gibt es in SMALLTALK nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf; alle anderen, einschließlich der Verzweigung und der Wiederholung (Schleife), müssen durch diese simuliert werden. Dies ist möglich, weil SMALLTALK Blöcke hat und weil in SMALLTALK (wie in allen anderen objektorientierten Programmiersprachen) der Methodenaufruf variabler ist als der gewöhnliche Prozedur- oder Funktionsaufruf, den Sie vielleicht von Sprachen wie PASCAL oder C kennen. Er enthält, wie bereits in Abschnitt 4.3.2 angedeutet, eine versteckte Fallunterscheidung in Form des dynamischen Bindens.",Welche Kontrollstrukturen gibt es in SMALLTALK?,"In SMALLTALK gibt es nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf."
"Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, die seine Ausführung bestimmen. Anders als in anderen Programmiersprachen gibt es in SMALLTALK nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf; alle anderen, einschließlich der Verzweigung und der Wiederholung (Schleife), müssen durch diese simuliert werden. Dies ist möglich, weil SMALLTALK Blöcke hat und weil in SMALLTALK (wie in allen anderen objektorientierten Programmiersprachen) der Methodenaufruf variabler ist als der gewöhnliche Prozedur- oder Funktionsaufruf, den Sie vielleicht von Sprachen wie PASCAL oder C kennen. Er enthält, wie bereits in Abschnitt 4.3.2 angedeutet, eine versteckte Fallunterscheidung in Form des dynamischen Bindens.",Was sind Verzweigungen und Wiederholungen in SMALLTALK?,"Verzweigungen und Wiederholungen in SMALLTALK werden durch die Verwendung von Blöcken und dynamisch gebundenen Methodenaufrufen simuliert. Da SMALLTALK keine direkten Verzweigungs- und Schleifenkonstrukte wie in einigen anderen Programmiersprachen hat, werden Entscheidungen und Wiederholungen durch den Aufruf entsprechender Methoden und die Auswertung von Blöcken erreicht."
"Damit eine Variable ein Objekt bezeichnet, muss dieses ihr durch eine sogenannte Zuweisung, in anderen Kontexten auch als Wertzuweisung bezeichnet, zugeordnet werden. In den meisten SMALLTALK-Implementierungen ist der Zuweisungsoperator :=, was durch ALGOL und PASCAL bekannt ist.",Was ist eine Zuweisung?,"Eine Zuweisung ist der Vorgang, bei dem einer Variable ein Objekt zugewiesen wird, damit sie dieses Objekt bezeichnet."
"Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.Nach einer Zuweisung x := y bezeichnen die beiden Variablen ""x"" und ""y"" das gleiche Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.",Warum ist die Zuweisung kommutativ?,"Die Zuweisung ist nicht kommutativ, da ""x := y"" und ""y := x"" unterschiedliche Bedeutungen haben, es sei denn, ""x"" und ""y"" hatten bereits denselben Wert vor der jeweiligen Zuweisung."
"Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben der expliziten Zuweisung durch den Zuweisungsoperator kommt auch eine implizite Zuweisung (bei Methodenaufrufen) vor.Der oben geschilderte Unterschied zwischen Wert- und Verweissemantik von Variablen hat erhebliche Konsequenzen für die Zuweisung: Bei einer Zuweisung unter Wertsemantik muss eine Kopie angefertigt werden, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist), und ein Objekt nicht in zwei Variablen gespeichert sein kann. Das hat zur Folge, dass die beiden Variablen ""x"" und ""y"" nach der Zuweisung aus Zeile 21 nicht dasselbe (identische) Objekt bezeichnen (was unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), sodass z. B. Änderungen am in ""x"" gespeicherten Objekt das in ""y"" gespeicherte Objekt nicht betreffen. Bei einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite kopiert und in der Variablen auf der linken Seite gespeichert. Wenn die Variablen auf der linken und der rechten Seite unterschiedliche Semantiken haben, dann liegt entweder eine unzulässige Zuweisung (siehe Kapitel 18) vor, oder es muss, je nach Art der Variable auf der linken Seite, eine Kopie eines Objekts oder ein Verweis auf ein Objekt angefertigt werden.",Was unterscheidet Zuweisungen unter Wertsemantik und unter Verweissemantik?,"Bei Zuweisungen unter Wertsemantik muss eine Kopie des Objekts angefertigt werden, da die Variable das Objekt selbst speichert. Bei Zuweisungen unter Verweissemantik wird nur der Verweis auf das Objekt kopiert und in der Variable gespeichert. Dies hat Auswirkungen darauf, ob Änderungen an einem Objekt in einer Variable sich auf dasselbe Objekt in einer anderen Variable auswirken."
"Überaus angemessen, wenn auch nicht immer in letzter Konsequenz einzuhalten, ist, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. So legt beispielsweise der in Kurseinheit 1, Kapitel für Klassennamen Substantive verwendet. Tatsächlich ist es eine vielzitierte objektorientierte Technik, in der Analysephase eines Projekts alle Substantive der Spezifikation zu extrahieren, um auf der Basis der so gewonnenen Liste die Menge der Klassen eines Systems zu identifizieren.",Wie können Substantive in der Programmierung verwendet werden?,"In der Programmierung können Substantive für Klassennamen verwendet werden. Diese Technik wird oft in der Analysephase eines Projekts angewendet, um die Menge der Klassen eines Systems zu identifizieren."
"Überaus angemessen, wenn auch nicht immer in letzter Konsequenz einzuhalten, ist, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. So legt beispielsweise der in Kurseinheit 1, Kapitel für Klassennamen Substantive verwendet. Tatsächlich ist es eine vielzitierte objektorientierte Technik, in der Analysephase eines Projekts alle Substantive der Spezifikation zu extrahieren, um auf der Basis der so gewonnenen Liste die Menge der Klassen eines Systems zu identifizieren.",Warum werden Substantive für Klassennamen verwendet?,"Substantive werden für Klassennamen verwendet, weil sie die Namen von Dingen oder Konzepten bezeichnen, die in der Objektorientierung als Klassen repräsentiert werden. Diese Technik erleichtert die Identifizierung der Klassen eines Systems in der Analysephase."
"Methoden, die eine Aktion implementieren (Befehle in EIFFEL, s. Kurseinheit 5, Abschnitt 52.2), wird man aufgrund ihres prädikativen Charakters mit Verben benennen, wobei es eine Stilfrage ist, ob man die Infinitiv- oder die Imperativform (im Englischen übrigens kein Unterschied in der Erscheinungsform) bevorzugt. Persönlich fühle ich mich hier an keine Regel gebunden außer an die, dass Ausdrücke durch meine Namenwahl möglichst lesbar werden. So klingt ""hinzufügen"" (Infinitivform) in meinen Ohren besser als ""add"" (Imperativform), ""entfernen"" (Imperativform) klingt dagegen besser als ""remove"" (Infinitivform). Man könnte natürlich der imperativen Form ein Reflexivpronomen hinzufügen wie etwa in ""sich entfernen,"" aber das ist eher unüblich (obwohl nicht ohne Charme!). Verbergänzungen wie Präpositionen verwendet man in SMALLTALK dauernd (schon um mehrere Parameter voneinander abzusetzen); in Sprachen wie Java fügt man einem allgemeinen (und häufig überladenen) Verb dann gelegentlich noch ein Substantiv als Objekt des Prädikats hinzu, wie in ""addElement."" Gerade dieses Beispiel ist jedoch nicht unumstritten, da „Element“ hier gewissermaßen redundant ist — wenn es mehrere Methoden namens „add“ gibt, kann man sie auch mittels ihrer Parametertypen unterscheiden (also überladen). So heißt die entsprechende Methode im JDK heute auch nur noch ""add(.)"".","Wie sollten Methoden, die eine Aktion implementieren, benannt werden?","Methoden, die eine Aktion implementieren, sollten mit Verben benannt werden, wobei es eine Stilfrage ist, ob man die Infinitiv- oder die Imperativform bevorzugt. Die Namen sollten so gewählt werden, dass sie möglichst lesbar sind."
"Keine Verben, sondern Adjektive (oder Kopula plus Prädikatsnomen) verwendet man hingegen für Methoden, die eine Abfrage darstellen (Queries; s. Abschnitt 52.2), wie etwa ""istLeer"" oder ""hatInhalt.""","Wie werden Methoden bezeichnet, die eine Abfrage darstellen?","Methoden, die eine Abfrage darstellen, werden als Queries bezeichnet und werden mit Adjektiven oder Kopula plus Prädikatsnomen benannt."
"Für Instanzvariablen verwendet man unterschiedliche Wortarten, und zwar abhängig davon, ob eine Instanzvariable ein Attribut oder eine Beziehung repräsentiert. Wenn es sich um ein Attribut handelt, das eine mehrwertige Qualität ausdrückt (wie Größe, Farbe etc.), dann wird man den Namen der Qualität verwenden und damit ein Substantiv (ggf. in Kleinschreibung). Wenn es sich um ein zweiwertiges (Boolesches) Attribut handelt, dann nimmt man das entsprechende Adjektiv (wie etwa ""leer""), ein Gerundivum (z. B. ""laufend"") oder ein Partizip (wie etwa ""gelöst""). Für Instanzvariablen, die Beziehungen ausdrücken, nimmt man gerne den Namen der Gegenrolle, also beispielsweise ""mutter"" in einer Kind-Mutter-Beziehung. Bei n-Beziehungen nehme ich persönlich gerne den Plural, also z. B. ""kinder"" (statt ""kind"") für die umgekehrte Richtung.","Wie werden Instanzvariablen benannt, die ein Attribut repräsentieren?","Für Instanzvariablen, die ein Attribut repräsentieren, wird der Name der Qualität verwendet, die das Attribut ausdrückt. Dabei wird ein Substantiv (ggf. in Kleinschreibung) verwendet."
"Für Instanzvariablen verwendet man unterschiedliche Wortarten, und zwar abhängig davon, ob eine Instanzvariable ein Attribut oder eine Beziehung repräsentiert. Wenn es sich um ein Attribut handelt, das eine mehrwertige Qualität ausdrückt (wie Größe, Farbe etc.), dann wird man den Namen der Qualität verwenden und damit ein Substantiv (ggf. in Kleinschreibung). Wenn es sich um ein zweiwertiges (Boolesches) Attribut handelt, dann nimmt man das entsprechende Adjektiv (wie etwa ""leer""), ein Gerundivum (z. B. ""laufend"") oder ein Partizip (wie etwa ""gelöst""). Für Instanzvariablen, die Beziehungen ausdrücken, nimmt man gerne den Namen der Gegenrolle, also beispielsweise ""mutter"" in einer Kind-Mutter-Beziehung. Bei n-Beziehungen nehme ich persönlich gerne den Plural, also z. B. ""kinder"" (statt ""kind"") für die umgekehrte Richtung.","Wie werden Instanzvariablen benannt, die eine Beziehung repräsentieren?","Für Instanzvariablen, die Beziehungen ausdrücken, nimmt man gerne den Namen der Gegenrolle, also beispielsweise ""mutter"" in einer Kind-Mutter-Beziehung. Bei n-Beziehungen nehme ich persönlich gerne den Plural, also z. B. ""kinder"" (statt ""kind"") für die umgekehrte Richtung."
"Interfaces sind zwar wie Klassen Typen, aber bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte, die konkrete Ausprägungen der Allgemeinbegriffe sind, spielen können. Rollen werden aber, genau wie Allgemeinbegriffe, häufig durch Substantive bezeichnet: „Mutter“ ist ein Beispiel hierfür. Andere Rollen, insbesondere die, die mit Parametern von Methoden verbunden sind, werden häufig durch Adjektive bezeichnet: ""Druckbar"" beispielsweise könnte der Parametertyp einer Methode ""drucken"" sein, den das zu druckende Objekt haben muss. Tatsächlich enden viele der gebräuchlichen Interfacenamen im Englischen auf „able“ oder „ible“, so z. B. bei ""Serializable.""",Was sind Interfaces in der objektorientierten Programmierung?,"Interfaces sind in der objektorientierten Programmierung Typen, die eher Rollen bezeichnen, die Objekte spielen können, als Allgemeinbegriffe. Sie werden häufig durch Substantive oder Adjektive bezeichnet."
"Eine ganz interessante Option ergibt sich übrigens für Programmiererinnen, deren Muttersprache nicht Englisch ist: Man hat hier die Möglichkeit, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Ich persönlich verwende dann gerne für Begrifflichkeiten aus der Anwendungsdomäne (also dem Gegenstandsbereich, mit dem sich das Programm befasst) deutsche Bezeichner und für solche aus der technischen Umsetzung (Hilfsklassen etc.) englische. Alternativ kann man natürlich auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden.","Was ist eine Möglichkeit für Programmiererinnen, deren Muttersprache nicht Englisch ist?","Eine Möglichkeit für Programmiererinnen, deren Muttersprache nicht Englisch ist, ist die Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Zum Beispiel können sie für Begrifflichkeiten aus der Anwendungsdomäne deutsche Bezeichner und für solche aus der technischen Umsetzung englische Bezeichner verwenden. Alternativ können sie auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden."
"Eine ganz interessante Option ergibt sich übrigens für Programmiererinnen, deren Muttersprache nicht Englisch ist: Man hat hier die Möglichkeit, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Ich persönlich verwende dann gerne für Begrifflichkeiten aus der Anwendungsdomäne (also dem Gegenstandsbereich, mit dem sich das Programm befasst) deutsche Bezeichner und für solche aus der technischen Umsetzung (Hilfsklassen etc.) englische. Alternativ kann man natürlich auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden.","Warum kann es sinnvoll sein, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen?","Das kann sinnvoll sein, um eine zusätzliche Form der Differenzierung einzusetzen. Zum Beispiel kann man für Begrifflichkeiten aus der Anwendungsdomäne deutsche Bezeichner verwenden und für solche aus der technischen Umsetzung englische. Alternativ kann man auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden."
"Wir kommen nun zu einer der wichtigsten Ausprägungen des ""Alles-ist-ein-Objekt""-Mottos von SMALLTALK: den Blöcken. Genau wie eine Methode ist ein Block eine abgegrenzte Sequenz oder Folge von Anweisungen. Anders als eine Methode ist ein Block jedoch nicht benannt, kann aber benannt werden, indem er einer Variable zugewiesen wird.",Was ist ein Block in SMALLTALK?,"Ein Block in SMALLTALK ist eine abgegrenzte Sequenz oder Folge von Anweisungen. Anders als eine Methode ist ein Block nicht benannt, kann aber einer Variable zugewiesen werden."
"Um auszudrücken, dass eine Sequenz von Ausdrücken ein Block ist, wird die Sequenz mit eckigen Klammern markiert. Die Variablen ""x"" und ""y"" seien außerhalb des Blocks im Kontext des Blocks deklariert. Der Kontext des Blocks ist die Methode, in der er definiert wurde.Bei der Ausführung des obigen Blocks wird ein neues Blockobjekt erzeugt. Die Anweisungen, die den Block ausmachen, werden dabei nicht ausgeführt, selbst dann nicht, wenn der Block isoliert steht und ausgeführt wird (das dabei erzeugte Objekt bleibt namenlos und wird von der Speicherbereinigung wieder entfernt).Um die Anweisungen, die einen Block ausmachen, zur Ausführung zu bringen, muss man ihn auswerten. Dazu schickt man ihm die Nachricht ""value"". Der Ausdruck ""swap value"" bewirkt, dass die Variablen ""x"" und ""y"" aus dem Kontext des Blocks ihren Wert tauschen. Das Objekt, zu dem ""swap value"" ausgewertet wird, ist das Objekt, zu dem die letzte Anweisung auswertet. Der Rückgabewert der Methode ""value"" ist zunächst immer das Objekt, zu dem der letzte Ausdruck eines Blocks auswertet, im obigen Beispiel also das durch ""temp"" benannte Objekt.",Wie werden Blöcke in SMALLTALK ausgeführt?,Bei der Ausführung des Blockausdrucks wird ein neues Blockobjekt erzeugt.
"Nun können Typen neben ihrer formalen Funktion, Fehler zu vermeiden, noch eine inhaltliche Funktion erfüllen, nämlich eine Filterfunktion. Diese setzt jedoch voraus, dass dem Typ auch eine Bedeutung, die über seine bloße Struktur (seine Syntax) hinausgeht, beigemessen werden kann. Dies geschieht heute vor allem durch die Benennung des Typs, die dann, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität, verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Eine Zuweisung einer Wohnung an ein Büro oder umgekehrt ist dann, trotz im obigen Beispiel strukturell gleich definierter Typen und deswegen ausbleibenden Typfehlern, aufgrund fehlender Namensgleichheit ausgeschlossen. Dies ist auch sinnvoll, da es sich dabei mit hoher Wahrscheinlichkeit um einen logischen Programmierfehler handelt, der auf mechanische Art sonst kaum zu entdecken wäre. Die Filterfunktion, die die geforderte Namensäquivalenz verlangt, drückt also eher eine Absicht der Programmiererin aus als eine technische Notwendigkeit. Die Bedeutung gerade dieser Funktion sollte man jedoch nicht unterschätzen, da nur wenige Möglichkeiten, Fehler in einem Programm aufzudecken bzw. zu vermeiden, so einfach zu handhaben sind.",Was ist eine Filterfunktion von Typen?,"Eine Filterfunktion von Typen ist eine Funktion, die neben der formalen Funktion, Fehler zu vermeiden, auch eine inhaltliche Funktion erfüllt. Sie setzt voraus, dass dem Typ eine Bedeutung beigemessen wird, die über seine bloße Struktur hinausgeht. Diese Bedeutung wird heute hauptsächlich durch die Benennung des Typs vermittelt. Die Namensäquivalenz als Bedingung der Zuweisungskompatibilität verlangt, dass einer Variablen nur Werte gleicher Bedeutung zugewiesen werden können. Die Filterfunktion drückt also eher eine Absicht der Programmiererin aus als eine technische Notwendigkeit."
"Ein Prinzip, das der Typprüfung per Namensäquivalenz ähnelt, findet übrigens auch in der Physik Anwendung: Bei ihren Berechnungen führen Physikerinnen stets eine Art Typprüfung durch, indem sie nicht nur mit den Beträgen der physikalischen Größen, sondern auch mit deren Einheiten rechnen. Wenn Physikerinnen also beispielsweise eine Geschwindigkeit berechnen und bei der Behandlung der Einheiten etwas anderes als m/s herauskommt, dann steckt im Rechenvorgang ein Fehler — das Ergebnis hat nicht den richtigen Typ (die richtige Einheit) und ist deswegen mit hoher Wahrscheinlichkeit falsch.",Wie wird in der Physik eine Art Typprüfung durchgeführt?,"In der Physik wird eine Art Typprüfung durchgeführt, indem nicht nur mit den Beträgen der physikalischen Größen, sondern auch mit deren Einheiten gerechnet wird. Wenn bei der Behandlung der Einheiten etwas anderes als die erwartete Einheit herauskommt, ist das Ergebnis mit hoher Wahrscheinlichkeit falsch."
"Namensäquivalenz hat jedoch auch einen entscheidenden Nachteil: Sie setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen (also da, wo Objekte ausgetauscht werden) dieselben Typen verwenden. Dies kann für die Interoperabilität von getrennt voneinander entwickelten Programmen (wie z. B. Web Services) ein echtes Hindernis sein.",Was ist der Nachteil von Namensäquivalenz?,"Der Nachteil von Namensäquivalenz ist, dass sie voraussetzt, dass getrennt voneinander entwickelte Programme dieselben Typen verwenden. Für die Interoperabilität von getrennt voneinander entwickelten Programmen kann dies ein echtes Hindernis sein."
"Strukturelle Typäquivalenz bietet mehr Flexibilität als nominale: Sie erlaubt Äquivalenz von Typen, bei deren Definition man vom jeweils anderen nichts wusste. Die erhöhte Flexibilität hat jedoch ihren Preis: Zufällige strukturelle Übereinstimmungen können zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Type branding führt in solchen Fällen optional eine Namensäquivalenz durch die Hintertür ein, mit dem Vorteil, dass diese optional ist.",Was ist der Unterschied zwischen nominaler und struktureller Typäquivalenz?,"Nominale Typäquivalenz erlaubt Äquivalenz von Typen, bei deren Definition man vom jeweils anderen nichts wusste. Strukturelle Typäquivalenz bietet mehr Flexibilität, hat jedoch den Nachteil, dass zufällige strukturelle Übereinstimmungen zu einer Äquivalenz führen können, die nicht der intendierten Semantik entspricht. Type branding führt in solchen Fällen optional eine Namensäquivalenz durch die Hintertür ein, mit dem Vorteil, dass diese optional ist."
"Jedem Objekt können eine Menge von lokalen Variablen zugeordnet werden. Aus Gründen, auf die wir noch zu sprechen kommen, heißen diese Variablen Instanzvariablen; sie werden aber manchmal auch als Felder oder Attribute bezeichnet. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: Sie sind für andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschränkt. Außerdem ist die Existenz dieser Variablen an die Existenz des besitzenden Objekts gebunden.Instanzvariablen bestimmen die Struktur zusammengesetzter Objekte (die manchmal deswegen auch strukturierte Objekte genannt werden) — atomare Objekte haben keine Instanzvariablen. Jede Instanzvariable eines Objekts belegt dabei einen Teil des Speichers aus seiner Repräsentation, indem sie öffentlich zugängliche Instanzvariablen erlauben und selbst nicht verhindern, dass ein anderes Objekt der gleichen Klasse darauf zugreift. Etwas anderes ist es jedoch auch in SMALLTALK mit den Objekten, auf die die Variablen verweisen: Aufgrund möglicher Aliase kann der Zugriff nicht so leicht einem einzigen Objekt vorbehalten werden.",Was sind Instanzvariablen?,"Instanzvariablen sind lokale Variablen, die einem Objekt zugeordnet sind und dazu verwendet werden, Informationen zu speichern, die spezifisch für dieses Objekt sind. Sie bestimmen die Struktur zusammengesetzter Objekte."
"Jedem Objekt können eine Menge von lokalen Variablen zugeordnet werden. Aus Gründen, auf die wir noch zu sprechen kommen, heißen diese Variablen Instanzvariablen; sie werden aber manchmal auch als Felder oder Attribute bezeichnet. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: Sie sind für andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschränkt. Außerdem ist die Existenz dieser Variablen an die Existenz des besitzenden Objekts gebunden.Instanzvariablen bestimmen die Struktur zusammengesetzter Objekte (die manchmal deswegen auch strukturierte Objekte genannt werden) — atomare Objekte haben keine Instanzvariablen. Jede Instanzvariable eines Objekts belegt dabei einen Teil des Speichers aus seiner Repräsentation, indem sie öffentlich zugängliche Instanzvariablen erlauben und selbst nicht verhindern, dass ein anderes Objekt der gleichen Klasse darauf zugreift. Etwas anderes ist es jedoch auch in SMALLTALK mit den Objekten, auf die die Variablen verweisen: Aufgrund möglicher Aliase kann der Zugriff nicht so leicht einem einzigen Objekt vorbehalten werden.",Was ist die Sichtbarkeit von Instanzvariablen in SMALLTALK?,Die Sichtbarkeit von Instanzvariablen in SMALLTALK ist auf das besitzende Objekt beschränkt. Instanzvariablen können von anderen Objekten nicht direkt zugegriffen werden.
"In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: at: i.Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C-Sharp und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen. Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.",Was sind zwei Arten von Instanzvariablen in SMALLTALK?,In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte Instanzvariablen.
"In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: at: i.Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C-Sharp und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen. Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.",Was sind benannte Instanzvariablen in SMALLTALK?,"Benannte Instanzvariablen sind Instanzvariablen, die jeweils auf ein bestimmtes Objekt verweisen oder es benennen. Der Name der Variablen wird zum Namen des Objekts, auf das sie verweisen."
"In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: at: i.Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C-Sharp und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen. Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.",Was sind indizierte Instanzvariablen in SMALLTALK?,"Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zum Objekt angesprochen, dem sie gehören. Der Index fungiert gewissermaßen als Name für die Instanzvariable."
"In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: at: i.Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C-Sharp und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen. Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.",Was sind Indexer?,Indexer sind ähnlich zu indizierten Instanzvariablen und werden beispielsweise von C-Sharp und VISUAL BASIC verwendet.
Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix. Damit ist auch die Größe eines Objekts mit indizierten Instanzvariablen fest; insbesondere können Array-Objekte nicht wachsen. Es müssen aber nicht alle indizierten Instanzvariablen belegt sein; die „leeren“ enthalten dann nil.,Wie ist die Anzahl indizierten Instanzvariablen eines Objekts?,"Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix, und die Größe eines Objekts mit indizierten Instanzvariablen ist ebenfalls fest und kann nicht verändert werden."
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in Java (besser gesagt, in Java ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als Java).",Unterstützt EIFFEL Mehrfachvererbung?,"Ja, EIFFEL erlaubt Mehrfachvererbung."
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in Java (besser gesagt, in Java ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als Java).",Wie werden Methoden in EIFFEL überschrieben?,"In EIFFEL wird das Überschreiben von Methoden als ""Redefinition"" bezeichnet."
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in Java (besser gesagt, in Java ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als Java).",Kann man in EIFFEL Methoden löschen?,"Ja, EIFFEL gestattet das Löschen von Methoden."
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in Java (besser gesagt, in Java ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als Java).",Wie werden abstrakte Klassen in EIFFEL deklariert?,"In EIFFEL werden abstrakte Klassen mit dem Schlüsselwort ""deferred"" deklariert."
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in Java (besser gesagt, in Java ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als Java).",Unterstützt EIFFEL Mehrfachvererbung?,"Ja, EIFFEL unterstützt Mehrfachvererbung."
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in Java (besser gesagt, in Java ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als Java).","Was bedeutet ""Redefinition"" in EIFFEL?","In EIFFEL wird das Überschreiben von Methoden als ""Redefinition"" bezeichnet."
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in Java (besser gesagt, in Java ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als Java).","Was bedeutet ""deferred"" in EIFFEL?","In EIFFEL bezeichnet das Schlüsselwort ""deferred"" abstrakte Klassen."
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in Java (besser gesagt, in Java ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als Java).",Wie ist die Reihenfolge der Klassendeklaration in EIFFEL?,"In EIFFEL muss zu Beginn einer Klassendefinition deklariert werden, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden"")."
"BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.",Was ist die Position von Bertrand Meyer zum Überladen von Methoden?,Bertrand Meyer ist ein entschiedener Gegner des Überladens.
"BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.","Was ist in Eiffel erlaubt, wenn zwei Methoden den gleichen Namen haben?","In Eiffel ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben, solange diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen oder die Methoden gleiche oder kovariant redefinierte Parameter haben."
"BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.","Was bedeutet ""Redefine"" in Eiffel?","""Redefine"" ist eine Deklaration in Eiffel, die angibt, dass eine Methode eine andere Methode mit demselben Namen und denselben oder kovariant redefinierten Parametern überschreibt."
"BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.","Was ermöglicht Eiffel, wenn zwei Klassen, von denen Sie erben möchten, Methoden mit demselben Namen verwenden?","Eiffel ermöglicht es, geerbte Features umzubenennen, indem es eine ""Rename""-Klausel gibt, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen."
"BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.",Wie wirkt sich das Umbenennen von geerbten Features auf das dynamische Binden in Eiffel aus?,"Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei."
"BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.",Was passiert mit dem ursprünglichen Namen einer umbenannten Methode in Eiffel?,"Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei."
"BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.","Was ermöglicht die ""Rename""-Klausel in Eiffel?","Die ""Rename""-Klausel in Eiffel ermöglicht es, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen."
"BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.",Wie wirkt sich das Umbenennen von geerbten Features auf das dynamische Binden in Eiffel aus?,"Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei."
"Obwohl in Java längst nicht alles ein Objekt ist, gibt es dennoch die Möglichkeit, auf die Elemente eines Programms zuzugreifen. Dafür ist das sog. Reflection API zuständig, in dem für jede Art von Programmelement eine Klasse existiert, deren Instanzen entsprechende Programmelemente repräsentieren. (So gibt es dort eine Klasse Method, eine Klasse Field etc.) Eine detaillierte Untersuchung dieses APIs würde an dieser Stelle jedoch zu weit führen; sie wird im Kurs 01853 („Moderne Programmiertechniken und -methoden“) ausführlicher behandelt.",Was ist das Reflection API in Java?,"Das Reflection API in Java ist eine Programmierschnittstelle, die es ermöglicht, auf die Elemente eines Programms zuzugreifen und diese zu untersuchen. Es enthält Klassen, die Instanzen entsprechender Programmelemente repräsentieren, wie zum Beispiel Methoden und Felder."
"Eine andere Form der Metaprogrammierung, die sog. Annotationen, hat zunächst nichts mit Objektorientierung zu tun — sie ordnen lediglich Programmmetadaten den Programmelementen im Quelltext zu. Diese können dann während der Übersetzung und/oder während der Ausführung des Programms abgefragt werden und so den jeweiligen Prozess beeinflussen oder sogar steuern. In Java 5 wurden Annotationen als eine spezielle Art von Interfaces eingeführt, die jedoch keine Methoden, sondern nur Felder (!) deklarieren.",Was sind Annotationen in Java 5?,"Annotationen in Java 5 sind eine spezielle Art von Interfaces, die nur Felder deklarieren und zur Zuordnung von Programmmetadaten zu Programmelementen im Quelltext dienen. Diese können während der Übersetzung und/oder Ausführung des Programms abgefragt und den jeweiligen Prozess beeinflussen oder sogar steuern."
"In einem objektorientierten Programm repräsentieren Objekte nicht nur Literale und Variablen, sondern auch Ausdrücke. Tatsächlich sind Literale und Variablen primitive Ausdrücke, die nicht aus anderen Ausdrücken zusammengesetzt sind. Um mit den Objekten jedoch Aktionen auszuführen und damit ein Programm tatsächlich auszuführen, benötigen wir weitere Arten von Ausdrücken, nämlich Zuweisungsausdrücke und Nachrichtenausdrücke. Auch diese repräsentieren jeweils ein Objekt und können daher an allen Stellen verwendet werden, an denen Objekte erforderlich sind. Es ist sogar möglich, sie geschachtelt anzuordnen.",Welche Arten von Ausdrücken gibt es?,"Es gibt Literale, Variablen, Zuweisungsausdrücke und Nachrichtenausdrücke."
"In einem objektorientierten Programm repräsentieren Objekte nicht nur Literale und Variablen, sondern auch Ausdrücke. Tatsächlich sind Literale und Variablen primitive Ausdrücke, die nicht aus anderen Ausdrücken zusammengesetzt sind. Um mit den Objekten jedoch Aktionen auszuführen und damit ein Programm tatsächlich auszuführen, benötigen wir weitere Arten von Ausdrücken, nämlich Zuweisungsausdrücke und Nachrichtenausdrücke. Auch diese repräsentieren jeweils ein Objekt und können daher an allen Stellen verwendet werden, an denen Objekte erforderlich sind. Es ist sogar möglich, sie geschachtelt anzuordnen.",Was sind primitive Ausdrücke?,"Primitive Ausdrücke sind nicht aus anderen Ausdrücken zusammengesetzt, wie Literale und Variablen."
"In einem objektorientierten Programm repräsentieren Objekte nicht nur Literale und Variablen, sondern auch Ausdrücke. Tatsächlich sind Literale und Variablen primitive Ausdrücke, die nicht aus anderen Ausdrücken zusammengesetzt sind. Um mit den Objekten jedoch Aktionen auszuführen und damit ein Programm tatsächlich auszuführen, benötigen wir weitere Arten von Ausdrücken, nämlich Zuweisungsausdrücke und Nachrichtenausdrücke. Auch diese repräsentieren jeweils ein Objekt und können daher an allen Stellen verwendet werden, an denen Objekte erforderlich sind. Es ist sogar möglich, sie geschachtelt anzuordnen.",Welche zwei Ausdrücke sind wichtig?,"Zuweisungsausdrücke und Nachrichtenausdrücke sind wichtig. Sie ermöglichen es, Aktionen mit den repräsentierten Objekten auszuführen und damit ein Programm tatsächlich auszuführen."
"Ein Modul ist eine Einheit von Programmelementen, die (bzw. deren Funktion) von außen (also z. B. von anderen Modulen) nur über die Schnittstelle des Moduls zugänglich sind. Damit behält ein Modul einen Teil seiner Implementierung für sich — es hütet quasi ein Implementationsgeheimnis. Der Teil, den es (über seine Schnittstelle) nach außen trägt, gilt gemeinhin als öffentlich. Die „Öffentlichkeit“ kann dabei durchaus beschränkt sein (siehe dazu auch Abschnitt 52.2 in Kurseinheit 5).",Was ist ein Modul in der Programmierung?,"Ein Modul ist eine Einheit von Programmelementen, die nur über die Schnittstelle des Moduls von außen zugänglich sind. Damit behält ein Modul einen Teil seiner Implementierung für sich und hütet ein Implementationsgeheimnis. Der Teil, den es nach außen trägt, gilt als öffentlich."
"Ein wesentlicher Grund, zwischen öffentlichen und nicht öffentlichen — privaten — Teilen eines Moduls zu unterscheiden, ist, dass die Programmierer eines Moduls die Hoheit darüber behalten wollen, wie sie das Modul programmieren. Indem sie sich auf eine Schnittstelle festlegen und alles andere hinter der Schnittstelle verbergen, ist es ihnen möglich, jederzeit die verborgenen Teile zu ändern, ohne dass irgendjemand davon in Kenntnis gesetzt werden muss — weil die privaten Teile von außen unsichtbar sind, hängt auch niemand davon ab, und insofern ist auch niemand davon betroffen, wenn an einem Modul eine Änderung durchgeführt wird, die die Schnittstellen unberührt lässt.","Warum ist es wichtig, zwischen öffentlichen und privaten Teilen eines Moduls zu unterscheiden?","Die Unterscheidung zwischen öffentlichen und privaten Teilen eines Moduls ermöglicht es den Programmierern, die Hoheit über die Implementierung des Moduls zu behalten. Durch die Verwendung einer Schnittstelle und das Verbergen der internen Details können sie jederzeit die internen Teile ändern, ohne dass dies Auswirkungen auf andere Teile des Programms hat, solange die Schnittstelle unverändert bleibt."
"In Java wurden bis Version 8 Module durch Klassen und Pakete (engl. packages) mehr oder weniger gut simuliert. Mit Java 9 wurde schließlich — nach langer Vorbereitungszeit — ein Modulbegriff eingeführt, der diesen Namen auch verdient.",Was simulierten Klassen und Pakete in Java bis Version 8?,In Java wurden bis Version 8 Module durch Klassen und Pakete simuliert.
"Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird. In SMALLTALK gelten alle Ausdrücke, die nicht Teil anderer Ausdrücke sind, als Anweisungen. Im Gegensatz zu Java und C-Sharp ist in SMALLTALK kein Semikolon erforderlich.In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt. Dieser Punkt ist ein Trennzeichen (ähnlich wie in PASCAL oder EIFFEL) und gehört nicht zur Anweisung selbst, im Gegensatz zu den von C abgeleiteten Sprachen wie Java oder C-Sharp. Der Punkt am Ende einer Anweisung kann also weggelassen werden, wenn keine weitere Anweisung folgt. Die Verwendung des Punktes entspricht dem Ziel von SMALLTALK, sich natürlicher Sprache anzunähern. Ähnlich ist die Wahl des Semikolons zur Kaskadierung von Nachrichtenausdrücken zu betrachten.Die einzige andere Form der Anweisung in SMALLTALK ist die Return-Anweisung, auf die wir im nächsten Kapitel im Zusammenhang mit Methoden näher eingehen werden. In SMALLTALK besteht sie aus dem Sonderzeichen ^, gefolgt von einem Ausdruck. Die Return-Anweisung gibt das Objekt zurück, zu dem dieser Ausdruck ausgewertet wird. Da alle anderen Anweisungen in SMALLTALK Ausdrücke sind, die zu einem Objekt ausgewertet werden, benötigen Methoden und Blöcke in SMALLTALK keine Return-Anweisungen, um ein Objekt zurückzugeben. Sie geben automatisch das Objekt zurück, zu dem die letzte Anweisung ausgewertet wird.",Was sind Anweisungen?,"Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird."
"Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird. In SMALLTALK gelten alle Ausdrücke, die nicht Teil anderer Ausdrücke sind, als Anweisungen. Im Gegensatz zu Java und C-Sharp ist in SMALLTALK kein Semikolon erforderlich.In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt. Dieser Punkt ist ein Trennzeichen (ähnlich wie in PASCAL oder EIFFEL) und gehört nicht zur Anweisung selbst, im Gegensatz zu den von C abgeleiteten Sprachen wie Java oder C-Sharp. Der Punkt am Ende einer Anweisung kann also weggelassen werden, wenn keine weitere Anweisung folgt. Die Verwendung des Punktes entspricht dem Ziel von SMALLTALK, sich natürlicher Sprache anzunähern. Ähnlich ist die Wahl des Semikolons zur Kaskadierung von Nachrichtenausdrücken zu betrachten.Die einzige andere Form der Anweisung in SMALLTALK ist die Return-Anweisung, auf die wir im nächsten Kapitel im Zusammenhang mit Methoden näher eingehen werden. In SMALLTALK besteht sie aus dem Sonderzeichen ^, gefolgt von einem Ausdruck. Die Return-Anweisung gibt das Objekt zurück, zu dem dieser Ausdruck ausgewertet wird. Da alle anderen Anweisungen in SMALLTALK Ausdrücke sind, die zu einem Objekt ausgewertet werden, benötigen Methoden und Blöcke in SMALLTALK keine Return-Anweisungen, um ein Objekt zurückzugeben. Sie geben automatisch das Objekt zurück, zu dem die letzte Anweisung ausgewertet wird.",Wie werden Anweisungen in SMALLTALK getrennt?,In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt.
"Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird. In SMALLTALK gelten alle Ausdrücke, die nicht Teil anderer Ausdrücke sind, als Anweisungen. Im Gegensatz zu Java und C-Sharp ist in SMALLTALK kein Semikolon erforderlich.In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt. Dieser Punkt ist ein Trennzeichen (ähnlich wie in PASCAL oder EIFFEL) und gehört nicht zur Anweisung selbst, im Gegensatz zu den von C abgeleiteten Sprachen wie Java oder C-Sharp. Der Punkt am Ende einer Anweisung kann also weggelassen werden, wenn keine weitere Anweisung folgt. Die Verwendung des Punktes entspricht dem Ziel von SMALLTALK, sich natürlicher Sprache anzunähern. Ähnlich ist die Wahl des Semikolons zur Kaskadierung von Nachrichtenausdrücken zu betrachten.Die einzige andere Form der Anweisung in SMALLTALK ist die Return-Anweisung, auf die wir im nächsten Kapitel im Zusammenhang mit Methoden näher eingehen werden. In SMALLTALK besteht sie aus dem Sonderzeichen ^, gefolgt von einem Ausdruck. Die Return-Anweisung gibt das Objekt zurück, zu dem dieser Ausdruck ausgewertet wird. Da alle anderen Anweisungen in SMALLTALK Ausdrücke sind, die zu einem Objekt ausgewertet werden, benötigen Methoden und Blöcke in SMALLTALK keine Return-Anweisungen, um ein Objekt zurückzugeben. Sie geben automatisch das Objekt zurück, zu dem die letzte Anweisung ausgewertet wird.",Welche Funktion hat die Return-Anweisung in SMALLTALK?,"Die Return-Anweisung gibt das Objekt zurück, zu dem der nachfolgende Ausdruck ausgewertet wird. Sie wird in Methoden und Blöcken verwendet, um das Ergebnis der Ausführung zurückzugeben."
"Zwar ist SMALLTALK über weite Teile in sich selbst definiert, was sich darin äußert, dass praktisch die gesamte Sprachdefinition in Form von Methoden hinterlegt ist und somit für die Programmiererin nicht nur sichtbar, sondern auch änderbar ist. Dennoch greift SMALLTALK für einige primitive Operationen auf native Implementierungen zurück. Dazu zählt beispielsweise die Addition (+) für kleine Integer oder der Zugriff auf indizierte Variablen mittels at: und at:put:.Dabei stehen die in spitzen Klammern stehenden Ausdrücke jeweils für Aufrufe von primitiven Methoden, die, da sie von Programmierern nicht selbst verwendet werden sollen, nur durch Nummern identifiziert wurden. Die Anweisungen nach den Aufrufen der primitiven Methoden werden nur ausgeführt, wenn die primitive Methode nicht erfolgreich war. Dieses Verhalten ermöglicht es, aus einer primitiven Methode mittels Return direkt zurückzuspringen, und zwar zu dem Ort, an dem die Methode +, at: oder at:put: aufgerufen wurde. Dieses Verhalten, das auf den ersten Blick ungewöhnlich erscheinen mag, wird uns im Zusammenhang mit Blöcken wieder begegnen.",Was sind primitive Methoden?,"Primitive Methoden sind primitive Operationen, die auf native Implementierungen zurückgreifen. Diese Methoden sind durch Nummern identifiziert und sollen nicht direkt von Programmierern verwendet werden."
"Das Programmiermodell von C-Sharp unterscheidet sich zunächst nicht wesentlich von dem von Java: Auch in C-Sharp ist der Code auf Klassen verteilt, die einzeln übersetzt werden können. Klassen werden in Dateien gespeichert, jedoch ist das Verhältnis von Klasse zu Datei lockerer als in Java (u. a. können Klassen anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden). Allerdings sind der Bytecode und die dazu passende virtuelle Maschine nicht speziell für C-Sharp entworfen, sondern für alle sog. .NET-Sprachen. So heißt denn auch die Sprache des Bytecode Common Intermediate Language (CIL); sie gilt als (gerade noch) menschenlesbar.",Wie ist das Verhältnis von Klasse zu Datei in C-Sharp?,Das Verhältnis von Klasse zu Datei in C-Sharp ist lockerer als in Java. Klassen können anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden.
"Das Programmiermodell von C-Sharp unterscheidet sich zunächst nicht wesentlich von dem von Java: Auch in C-Sharp ist der Code auf Klassen verteilt, die einzeln übersetzt werden können. Klassen werden in Dateien gespeichert, jedoch ist das Verhältnis von Klasse zu Datei lockerer als in Java (u. a. können Klassen anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden). Allerdings sind der Bytecode und die dazu passende virtuelle Maschine nicht speziell für C-Sharp entworfen, sondern für alle sog. .NET-Sprachen. So heißt denn auch die Sprache des Bytecode Common Intermediate Language (CIL); sie gilt als (gerade noch) menschenlesbar.",Was ist der Unterschied zwischen der Verwendung von Klassen in C-Sharp und Java?,"Der Unterschied liegt darin, dass in C-Sharp das Verhältnis von Klasse zu Datei lockerer ist als in Java. In C-Sharp können Klassen anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden. Im Gegensatz dazu ist in Java das Verhältnis von Klasse zu Datei strenger, da die Klasse denselben Namen wie ihre Datei haben muss."
"Anders als bei Java waren bei C-Sharp Flexibilität und Performanz von Anfang an kritische Gesichtspunkte des Sprachentwurfs. Für C-Sharp war daher von Anfang an und ausschließlich die sog. Just-in-time-(JIT-)Kompilierung vorgesehen, die den CIL-Code unmittelbar vor der Ausführung (und nur, wenn er überhaupt ausgeführt wird) in Maschinencode der Maschine, auf der er gerade läuft, übersetzt. Die Einheiten der JIT-Kompilierung gehen dabei hinunter bis zu einzelnen Methoden. Eine vollständige Kompilierung von CIL in nativen Maschinencode vor der Ausführung ist ebenfalls möglich.",Was ist Just-in-time-(JIT-)Kompilierung in C-Sharp?,"Bei C-Sharp ist die Just-in-time-(JIT-)Kompilierung eine Technik, bei der der CIL-Code unmittelbar vor der Ausführung (und nur, wenn er überhaupt ausgeführt wird) in Maschinencode der Maschine, auf der er gerade läuft, übersetzt wird. Die Einheiten der JIT-Kompilierung gehen dabei hinunter bis zu einzelnen Methoden."
"Eine andere Eigenschaft von Java, mit der die Programmiererinnen von MICROSOFT offenbar nicht unter allen Umständen leben konnten, ist die Garbage Collection. In C-Sharp hat man daher die Möglichkeit, den Speicherplatz für Objekte, die mit ""new"" erzeugt wurden, selbst wieder freizugeben. Doch wehe derjenige, der das vergisst: Speicherlecks sind die unmittelbare Folge. Noch schlimmer sind aber Speicherfreigaben von Objekten, auf die noch Referenzen existieren: Diese zeigen dann ins Leere oder, wenn der Speicher wieder belegt wird, auf oder mitten hinein in ein anderes Objekt. Eine Katastrophe. Aber damit nicht genug: Das mit SMALLTALK und Java abgeschaffte Hantieren mit Pointern wurde in C-Sharp auch wiedereingeführt, wohl weil man in der systemnahen Programmierung (und bei Aufrufen in das hauseigene Betriebssystem) nicht darauf verzichten konnte. Allerdings sind beide Rückschritte — explizite Speicherverwaltung und das Hantieren mit Pointern — in sog. unsichere Bereiche verbannt. Dazu gibt es in C-Sharp einen Modifikator ""unsafe"", der solche Bereiche einleitet:","Was ist die Funktion des ""unsafe""-Modifikators in C-Sharp?","Der ""unsafe""-Modifikator in C-Sharp dient dazu, Bereiche im Programm zu markieren, in denen explizite Speicherverwaltung und das Hantieren mit Pointern erlaubt sind. Diese Bereiche werden als ""unsicher"" bezeichnet."
"Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger-auf-Typ handelt; vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch überladen wurde. Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.",Was bedeutet der Stern hinter einem Typ in Objective-C?,"Der Stern hinter einem Typ in Objective-C bedeutet, dass es sich um einen Zeiger-auf-Typ handelt."
"Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger-auf-Typ handelt; vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch überladen wurde. Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.",Was bedeutet der Stern vor einer Variable in der Programmierung?,"Vor einer Variable bedeutet der Stern, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird."
"Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger-auf-Typ handelt; vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch überladen wurde. Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.","Was bedeutet der Stern neben Methoden, Klassen, Blöcken und Variablen in der Programmierung?","Neben Methoden, Klassen, Blöcken und Variablen bedeutet der Stern, dass sie unsicher sind. Das heißt, sie können Null-Werte haben und müssen vor der Verwendung auf Null überprüft werden."
"C++ ist eine sehr komplexe Sprache. Ihre Beherrschung dauert Jahre, selbst bei täglichem Umgang mit ihr; sie zu lehren erscheint fast aussichtslos. Selbst wenn man die zahlreichen Konstrukte der Sprache der Reihe nach durchginge, ergibt sich die eigentliche Komplexität erst aus deren kombinierter Verwendung, und die Zahl der Möglichkeiten ist den Gesetzen der Kombinatorik folgend hoch. Entsprechend groß ist auch die Zahl der Idiome (Wendungen), die es für C++ gibt. Auch wenn längst nicht alle Beiträge zur Komplexität von C++ in Zusammenhang mit der Objektorientierung stehen, so ist es doch schwierig, sie davon zu trennen. Deshalb soll es an dieser Stelle auch genug damit sein.",Warum ist C++ eine sehr komplexe Programmiersprache?,"C++ ist eine sehr komplexe Programmiersprache, weil sie eine große Anzahl an Konstrukten hat und die eigentliche Komplexität aus deren kombinierter Verwendung entsteht. Die Zahl der Möglichkeiten ist hoch und es gibt entsprechend viele Idiome (Wendungen) für C++."
"Einhergehend mit der Trennung zwischen primitiven und Referenztypen gibt es in Java auch eine Trennung zwischen Operationen und Methoden: Auf den primitiven Typen sind bestimmte Operationen, wie mathematische und boolesche Operationen, fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Da primitive Typen jedoch keine Klassen sind, gibt es beispielsweise für mathematische Funktionen eine spezielle Klasse namens Math, in der Funktionen wie sin(.) als Klassenmethoden hinterlegt sind. Umgekehrt ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren, wie es bei den binären Methoden in SMALLTALK der Fall ist (siehe Abschnitt 4.1.2 in Kurseinheit 1). Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von Java als Programmiersprache geprägt hat. Anfangs führte dies zu ihrem Ruf als hybride Programmiersprache, die sowohl objektorientierte als auch imperative Eigenschaften aufweist. Aus meiner Sicht ist die Unterscheidung zwischen Objekten und Werten, wie sie in Java vorgenommen wurde, jedoch sinnvoll: Werte besitzen weder Identität noch Zustand, daher unterscheiden sie sich von Objekten.",Wie ist der Umgang mit primitiven Typen und Referenztypen in Java?,"In Java gibt es eine klare Trennung zwischen primitiven Typen und Referenztypen. Für primitiven Typen sind bestimmte Operationen fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Primitive Typen sind keine Klassen und es ist daher nicht gestattet, Operatoren in Klassendefinitionen zu definieren. Diese Trennung ist konsequent durchgezogen und hat den Charakter von Java als Programmiersprache geprägt."
"Einhergehend mit der Trennung zwischen primitiven und Referenztypen gibt es in Java auch eine Trennung zwischen Operationen und Methoden: Auf den primitiven Typen sind bestimmte Operationen, wie mathematische und boolesche Operationen, fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Da primitive Typen jedoch keine Klassen sind, gibt es beispielsweise für mathematische Funktionen eine spezielle Klasse namens Math, in der Funktionen wie sin(.) als Klassenmethoden hinterlegt sind. Umgekehrt ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren, wie es bei den binären Methoden in SMALLTALK der Fall ist (siehe Abschnitt 4.1.2 in Kurseinheit 1). Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von Java als Programmiersprache geprägt hat. Anfangs führte dies zu ihrem Ruf als hybride Programmiersprache, die sowohl objektorientierte als auch imperative Eigenschaften aufweist. Aus meiner Sicht ist die Unterscheidung zwischen Objekten und Werten, wie sie in Java vorgenommen wurde, jedoch sinnvoll: Werte besitzen weder Identität noch Zustand, daher unterscheiden sie sich von Objekten.",Was ist der Unterschied zwischen primitiven und Referenztypen in Java?,"In Java gibt es eine Trennung zwischen primitiven und Referenztypen. Primitiven Typen sind vordefinierte Datentypen, wie zum Beispiel int, float oder boolean. Referenztypen hingegen sind Objekte, die in der Sprache definiert werden. Die Operationen auf primitiven Typen sind fest vorgegeben, während alle anderen Operationen als Methoden in Klassen definiert werden müssen. Primitiven Typen besitzen weder Identität noch Zustand, im Gegensatz zu Referenztypen."
"Einhergehend mit der Trennung zwischen primitiven und Referenztypen gibt es in Java auch eine Trennung zwischen Operationen und Methoden: Auf den primitiven Typen sind bestimmte Operationen, wie mathematische und boolesche Operationen, fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Da primitive Typen jedoch keine Klassen sind, gibt es beispielsweise für mathematische Funktionen eine spezielle Klasse namens Math, in der Funktionen wie sin(.) als Klassenmethoden hinterlegt sind. Umgekehrt ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren, wie es bei den binären Methoden in SMALLTALK der Fall ist (siehe Abschnitt 4.1.2 in Kurseinheit 1). Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von Java als Programmiersprache geprägt hat. Anfangs führte dies zu ihrem Ruf als hybride Programmiersprache, die sowohl objektorientierte als auch imperative Eigenschaften aufweist. Aus meiner Sicht ist die Unterscheidung zwischen Objekten und Werten, wie sie in Java vorgenommen wurde, jedoch sinnvoll: Werte besitzen weder Identität noch Zustand, daher unterscheiden sie sich von Objekten.",Warum gibt es in Java eine klare Trennung zwischen primitiven und Referenztypen?,"Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von Java als Programmiersprache geprägt hat. Sie ist sinnvoll, weil Werte, im Gegensatz zu Objekten, weder Identität noch Zustand besitzen und somit unterschieden werden müssen."
"Die Methoden in Java können in Prozeduren und Funktionen unterteilt werden, wobei der einzige Unterschied darin besteht, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp ""void"" deklarieren. Dies ist eine der vielen Erbschaften aus der Programmiersprache C.",Was ist der Unterschied zwischen Prozeduren und Funktionen in Java?,"Der Unterschied zwischen Prozeduren und Funktionen in Java besteht darin, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp ""void"" deklarieren, während Funktionen einen Rückgabewert haben."
"Ein Operator, der speziell für Referenztypen in Java zur Verfügung steht, ist der Typtest ""instanceof"". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist. Dabei wird nicht zwischen direkten und indirekten Instanzen unterschieden. Zum Beispiel ergibt ""x instanceof Object"" immer ""true"", unabhängig davon, für welches Objekt ""x"" steht. Weitere Informationen zur Bedeutung des Typtests finden Sie in Kapitel 44.","Was macht der Operator ""instanceof"" in Java?","Der Operator ""instanceof"" in Java ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist. Dabei wird nicht zwischen direkten und indirekten Instanzen unterschieden."
"Ein Operator, der speziell für Referenztypen in Java zur Verfügung steht, ist der Typtest ""instanceof"". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist. Dabei wird nicht zwischen direkten und indirekten Instanzen unterschieden. Zum Beispiel ergibt ""x instanceof Object"" immer ""true"", unabhängig davon, für welches Objekt ""x"" steht. Weitere Informationen zur Bedeutung des Typtests finden Sie in Kapitel 44.","Was kann der Typtest ""instanceof"" in Java?","Der Typtest ""instanceof"" in Java ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist, unabhängig davon, ob es sich um eine direkte oder indirekte Instanz handelt. Zum Beispiel ergibt ""x instanceof Object"" immer ""true"", unabhängig davon, für welches Objekt ""x"" steht."
"Eine Klasse liefert eine Implementierung. Nach gängigen Prinzipien der objektorientierten Programmierung sind Implementierungen jedoch hinter Schnittstellen (oder Interfaces) zu verbergen: Nur die Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind, sollen durch die Schnittstelle nach außen getragen werden – der Rest soll verborgen bleiben (das sog. Geheimnisprinzip).",Was ist eine Schnittstelle in Bezug auf eine Klasse?,"Eine Schnittstelle in Bezug auf eine Klasse ist das Verbergen der Implementierung und das Nach-außen-Treten der Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind. Dieses Prinzip wird auch als Geheimnisprinzip bezeichnet."
"Eine Klasse liefert eine Implementierung. Nach gängigen Prinzipien der objektorientierten Programmierung sind Implementierungen jedoch hinter Schnittstellen (oder Interfaces) zu verbergen: Nur die Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind, sollen durch die Schnittstelle nach außen getragen werden – der Rest soll verborgen bleiben (das sog. Geheimnisprinzip).",Was ist das Geheimnisprinzip in der objektorientierten Programmierung?,"Das Geheimnisprinzip in der objektorientierten Programmierung besagt, dass nur die Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind, durch die Schnittstelle nach außen getragen werden sollen – der Rest soll verborgen bleiben."
"In Programmiersprachen wie Java, C++, usw. gibt es spezielle Schlüsselwörter, die einem Element einer Klassendefinition (beispielsweise einer Methode) vorangestellt seine Zugreifbarkeit festlegen. Diese sogenannten Zugriffsmodifikatoren (engl. access modifier) legen gemeinsam mit der Klassendefinition, die ihre vollständige Implementierung beinhaltet, auch die Schnittstelle der Klasse fest. Je nach Sprache ist diese Schnittstelle für alle Benutzer der Klasse gleich oder unterscheidet sich nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse. Im ersten Fall könnte man von einer absoluten Schnittstelle sprechen; um sie zu spezifizieren, reicht es, zwischen sichtbar und unsichtbar zu unterscheiden. Im zweiten Fall ist die Schnittstelle relativ.",Was sind Zugriffsmodifikatoren in Programmiersprachen?,"Zugriffsmodifikatoren sind spezielle Schlüsselwörter in Programmiersprachen wie Java und C++, die einem Element einer Klassendefinition vorangestellt werden, um dessen Zugreifbarkeit festzulegen. Sie legen gemeinsam mit der Klassendefinition, die die vollständige Implementierung beinhaltet, auch die Schnittstelle der Klasse fest."
"Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nämlich nur aus Deklarationen von Methoden. Die gemachte Einschränkung ist notwendig, weil manche Sprachen, so z. B. Java und C++, die Instanzvariablen ihrer Objekte in die Schnittstelle der Klassen aufzunehmen erlauben. Mit den Instanzvariablen wird jedoch die Repräsentation der Objekte nach außen sichtbar, was dem Gedanken des Geheimnisprinzips widerspricht.",Was ist eine absolut spezifizierte Schnittstelle einer Klasse?,"Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nur aus Deklarationen von Methoden und enthält keine Instanzvariablen."
"Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nämlich nur aus Deklarationen von Methoden. Die gemachte Einschränkung ist notwendig, weil manche Sprachen, so z. B. Java und C++, die Instanzvariablen ihrer Objekte in die Schnittstelle der Klassen aufzunehmen erlauben. Mit den Instanzvariablen wird jedoch die Repräsentation der Objekte nach außen sichtbar, was dem Gedanken des Geheimnisprinzips widerspricht.",Was ist der Unterschied zwischen einer Schnittstelle und einem Typ in Bezug auf Objekte?,"Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nämlich nur aus Deklarationen von Methoden. Im Gegensatz dazu, werden bei einem Typ die Instanzvariablen der Objekte in die Schnittstelle der Klassen aufgenommen, was dem Gedanken des Geheimnisprinzips widerspricht."
"Wenn man nun eine Variable mit einem solchen die Schnittstelle repräsentierenden Typ deklariert und eine Typprüfung erfolgreich durchgeführt hat, dann ist sichergestellt, dass über diese Variable nur auf die Elemente einer Klasse zugegriffen wird, die auch Bestandteil des Interfaces der Klasse sind. Wenn jede Instanz dieser Klasse ausschließlich über typisierte Variablen ansprechbar ist, ist damit die Wahrung des Geheimnisprinzips garantiert. Typen dienen damit einem weiteren Zweck, den man zunächst einmal nicht mit ihnen assoziieren würde, nämlich der Wahrung des Implementationsgeheimnisses und Einhaltung der Schnittstellen durch den Compiler. Dieser überaus nützliche Zusammenhang zwischen Klassen, ihren Schnittstellen und Typen wurde erst relativ spät, nämlich mit der Programmiersprache Java und ihrem Interface-als-Typ-Konzept, so weiterentwickelt, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle zugleich Typen der Klasse (außer: Supertypen des der Klasse entsprechenden Typs) sind. Die damit ermöglichte interfacebasierte Programmierung, die in Kurs 01853 ausführlich behandelt wird, betrachte ich persönlich als den wichtigsten Beitrag Javas zur Disziplin der objektorientierten Programmierung (s. a. Kurseinheit 4, Kapitel 45).",Was ist die Funktion von Typen in der objektorientierten Programmierung?,"Typen dienen in der objektorientierten Programmierung nicht nur dazu, Objekte zu klassifizieren, sondern auch dazu, das Implementationsgeheimnis der Klassen zu wahren und die Einhaltung der Schnittstellen durch den Compiler zu gewährleisten. Diese Funktion von Typen wurde mit der Programmiersprache Java und ihrem Interface-als-Typ-Konzept weiterentwickelt, was zur interfacebasierten Programmierung führte. Diese betrachte ich als den wichtigsten Beitrag Javas zur Disziplin der objektorientierten Programmierung."
"Wenn man nun eine Variable mit einem solchen die Schnittstelle repräsentierenden Typ deklariert und eine Typprüfung erfolgreich durchgeführt hat, dann ist sichergestellt, dass über diese Variable nur auf die Elemente einer Klasse zugegriffen wird, die auch Bestandteil des Interfaces der Klasse sind. Wenn jede Instanz dieser Klasse ausschließlich über typisierte Variablen ansprechbar ist, ist damit die Wahrung des Geheimnisprinzips garantiert. Typen dienen damit einem weiteren Zweck, den man zunächst einmal nicht mit ihnen assoziieren würde, nämlich der Wahrung des Implementationsgeheimnisses und Einhaltung der Schnittstellen durch den Compiler. Dieser überaus nützliche Zusammenhang zwischen Klassen, ihren Schnittstellen und Typen wurde erst relativ spät, nämlich mit der Programmiersprache Java und ihrem Interface-als-Typ-Konzept, so weiterentwickelt, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle zugleich Typen der Klasse (außer: Supertypen des der Klasse entsprechenden Typs) sind. Die damit ermöglichte interfacebasierte Programmierung, die in Kurs 01853 ausführlich behandelt wird, betrachte ich persönlich als den wichtigsten Beitrag Javas zur Disziplin der objektorientierten Programmierung (s. a. Kurseinheit 4, Kapitel 45).",Was ermöglichen Typen in der objektorientierten Programmierung?,"Typen dienen in der objektorientierten Programmierung nicht nur der Wahrung des Geheimnisprinzips und Einhaltung der Schnittstellen durch den Compiler, sondern ermöglichen auch die interfacebasierte Programmierung, die als wichtigster Beitrag Javas zur Disziplin der objektorientierten Programmierung gilt."
"Gegen die Verwendung langer, sprechender Bezeichner kann man einwenden, dass der Programmtext dadurch übermäßig lang wird. Anweisungen, die sonst in eine Zeile gepasst hätten, müssen u. U. mehrfach umgebrochen werden, was die Lesbarkeit nicht gerade erhöht. Auch hört man hier und da, dass lange Namen für die Programmiererin zusätzliche Schreibarbeit bedeuten. Letzteres Argument kann man jedoch kaum gelten lassen, da die meisten Entwicklungsumgebungen über eine automatische Vervollständigungsfunktion verfügen, die einem das Tippen abnimmt (und damit auch Tippfehler aufdeckt oder vermeidet).","Warum sollte man lange, sprechende Bezeichner verwenden?","Gegen die Verwendung langer, sprechender Bezeichner kann man einwenden, dass der Programmtext dadurch übermäßig lang wird. Allerdings erhöht dies die Lesbarkeit und verringert das Risiko von Tippfehlern, da die meisten Entwicklungsumgebungen über eine automatische Vervollständigungsfunktion verfügen, die einem das Tippen abnimmt."
"Das erste Argument ist schon schwieriger zu entkräften: Natürlich sind prägnante Namen geschwätzigen vorzuziehen, und auch in der Programmierung liegt die Würze in der Kürze. Insbesondere sind lange Namen, die sich nur geringfügig unterscheiden (und das auch noch wenig offensichtlich), zu vermeiden. Als Faustregel ist ein Name dann gut gewählt, wenn man alle Ausdrücke, in denen er vorkommt, schnell verstehen kann (und nicht nur, aufgrund falscher Assoziationen und Vermutungen, zu verstehen glaubt). Eine sorgfältige Programmiererin wird sich also häufiger dabei beobachten, wie sie über einen passenden Namen für ein Programmelement länger nachsinnt. Diese Zeit ist jedoch gut investiert.",Warum ist die Wahl eines guten Namens für ein Programmelement wichtig?,"Eine sorgfältige Programmiererin wird sich häufiger dabei beobachten, wie sie über einen passenden Namen für ein Programmelement länger nachsinnt. Diese Zeit ist jedoch gut investiert, da prägnante Namen vorzuziehen sind und lange Namen, die sich nur geringfügig unterscheiden, zu vermeiden sind. Ein Name ist dann gut gewählt, wenn man alle Ausdrücke, in denen er vorkommt, schnell verstehen kann."
"In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung, die sogenannte ""Garbage Collection"". Garbage Collection ist ein Mechanismus, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr zugreifbar sind. Da in SMALLTALK auf Objekte nach ihrer Erzeugung ausschließlich über Variablen (Namen) zugegriffen werden kann, kann ein solches Objekt genau dann entfernt werden, wenn keine Variable mehr auf es verweist. Es kann entfernt werden, muss aber nicht; aus Sicht der Programmiererin ist es ausreichend, dass das Objekt nicht mehr bekannt oder benannt ist — es kann somit nicht mehr aufgefunden und durch eine Zuweisung einer Variable zugewiesen werden. Bei der Implementierung von Garbage-Collection-Algorithmen besteht daher erhebliche Freiheit.",Was ist der Lebenslauf von Objekten in SMALLTALK?,In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung.
"In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung, die sogenannte ""Garbage Collection"". Garbage Collection ist ein Mechanismus, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr zugreifbar sind. Da in SMALLTALK auf Objekte nach ihrer Erzeugung ausschließlich über Variablen (Namen) zugegriffen werden kann, kann ein solches Objekt genau dann entfernt werden, wenn keine Variable mehr auf es verweist. Es kann entfernt werden, muss aber nicht; aus Sicht der Programmiererin ist es ausreichend, dass das Objekt nicht mehr bekannt oder benannt ist — es kann somit nicht mehr aufgefunden und durch eine Zuweisung einer Variable zugewiesen werden. Bei der Implementierung von Garbage-Collection-Algorithmen besteht daher erhebliche Freiheit.","Was ist die ""Garbage Collection"" in SMALLTALK?","Die ""Garbage Collection"" ist ein Mechanismus in SMALLTALK, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr über Variablen zugreifbar sind."
"In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung, die sogenannte ""Garbage Collection"". Garbage Collection ist ein Mechanismus, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr zugreifbar sind. Da in SMALLTALK auf Objekte nach ihrer Erzeugung ausschließlich über Variablen (Namen) zugegriffen werden kann, kann ein solches Objekt genau dann entfernt werden, wenn keine Variable mehr auf es verweist. Es kann entfernt werden, muss aber nicht; aus Sicht der Programmiererin ist es ausreichend, dass das Objekt nicht mehr bekannt oder benannt ist — es kann somit nicht mehr aufgefunden und durch eine Zuweisung einer Variable zugewiesen werden. Bei der Implementierung von Garbage-Collection-Algorithmen besteht daher erhebliche Freiheit.",Wann kann ein Objekt in SMALLTALK aus dem Speicher entfernt werden?,"Ein Objekt in SMALLTALK kann aus dem Speicher entfernt werden, wenn keine Variable mehr auf dieses Objekt verweist und es somit nicht mehr erreichbar ist."
"Von der automatischen Speicherbereinigung ausgenommen sind bestimmte Objekte mit eindeutiger literaler Repräsentation (wie z. B. kleine Zahlen, Zeichen und Symbole). Im Falle von Zahlen und Zeichen liegt das jedoch weniger an der Natur dieser Objekte selbst als vielmehr an der Tatsache, dass diese in der Regel nicht als Objekte im Speicher angelegt werden (sodass Variablen darauf verweisen könnten), sondern dass sie selbst, als Werte (und anstelle von Zeigern), in Variablen gespeichert werden. Sie werden ""entfernt"", indem einer Variable ein neuer Wert zugewiesen wird. Symbole werden schon deswegen nicht aus dem Speicher entfernt, weil sie in einer Symboltabelle abgelegt sind (und somit immer mindestens einmal referenziert werden).",Welche Objekte sind von der automatischen Speicherbereinigung ausgenommen?,"Von der automatischen Speicherbereinigung ausgenommen sind Objekte mit eindeutiger literaler Repräsentation, wie kleine Zahlen, Zeichen und Symbole. Zahlen und Zeichen werden durch Werte in Variablen repräsentiert und Symbole sind in einer Symboltabelle abgelegt."
"Der Mut zur Verabschiedung von der expliziten Speicherfreigabe war eine der wichtigsten Entscheidungen beim Entwurf von SMALLTALK. Man hat einfach anerkannt, dass die genaue Buchführung darüber, auf welche Objekte noch zugegriffen wird, zu schwierig ist, um die Verantwortung dafür den Anwendungsprogrammierern zu überlassen. Wer das Problem nicht unmittelbar einsichtig findet, halte sich vor Augen, dass der Ort der Erzeugung eines Objektes und seine erste Zuweisung zu einer Variable im Programm möglicherweise weit entfernt sind von der Stelle, an der dieser Variable ein anderes Objekt zugewiesen wird, es möglicherweise viele solcher Stellen gibt, von denen mal die eine, mal die andere zuerst erreicht wird, und dass in der Zwischenzeit beliebig viele Aliase auf das Objekt angelegt worden sein könnten, die alle mit berücksichtigt werden müssen, um zu entscheiden, ob das Objekt noch in Verwendung ist.Eine vorzeitige Entfernung aus dem Speicher hingegen führt dazu, dass Variablen ins Leere zeigen (eine häufige Quelle von Programmabstürzen) oder dass, bei einer Wiederverwendung des Speichers, die Variable plötzlich auf ein anderes Objekt verweist, das ihr aber nie explizit zugewiesen wurde — ein quasi zufälliges Programmverhalten, das mit hoher Wahrscheinlichkeit zu schweren Programmfehlern führen würde. Ein anderes Beispiel entsteht, wenn in einer Verzweigung eines Programms entweder ein neues oder ein bereits vorhandenes Objekt einer Variable zugewiesen wird. Woher weiß man bei der weiteren Benutzung dieser Variable, ob das Objekt schon vorher existierte und vielleicht schon andere Variablen auf es verweisen, oder ob es gerade erst neu erzeugt wurde und damit noch unbenutzt ist? Wer ist für die Entsorgung des Objekts verantwortlich? All diese Betrachtungen kann man sich in Gegenwart der Garbage Collection ersparen.",Warum wurde in SMALLTALK die explizite Speicherfreigabe aufgegeben?,"Die explizite Speicherfreigabe wurde in SMALLTALK aufgegeben, da es schwierig ist, genau zu verfolgen, welche Objekte noch referenziert werden, insbesondere in großen und komplexen Programmen. Die Verantwortung dafür den Anwendungsprogrammierern zu überlassen, würde zu vielen potenziellen Programmierfehlern führen."
"Der Mut zur Verabschiedung von der expliziten Speicherfreigabe war eine der wichtigsten Entscheidungen beim Entwurf von SMALLTALK. Man hat einfach anerkannt, dass die genaue Buchführung darüber, auf welche Objekte noch zugegriffen wird, zu schwierig ist, um die Verantwortung dafür den Anwendungsprogrammierern zu überlassen. Wer das Problem nicht unmittelbar einsichtig findet, halte sich vor Augen, dass der Ort der Erzeugung eines Objektes und seine erste Zuweisung zu einer Variable im Programm möglicherweise weit entfernt sind von der Stelle, an der dieser Variable ein anderes Objekt zugewiesen wird, es möglicherweise viele solcher Stellen gibt, von denen mal die eine, mal die andere zuerst erreicht wird, und dass in der Zwischenzeit beliebig viele Aliase auf das Objekt angelegt worden sein könnten, die alle mit berücksichtigt werden müssen, um zu entscheiden, ob das Objekt noch in Verwendung ist.Eine vorzeitige Entfernung aus dem Speicher hingegen führt dazu, dass Variablen ins Leere zeigen (eine häufige Quelle von Programmabstürzen) oder dass, bei einer Wiederverwendung des Speichers, die Variable plötzlich auf ein anderes Objekt verweist, das ihr aber nie explizit zugewiesen wurde — ein quasi zufälliges Programmverhalten, das mit hoher Wahrscheinlichkeit zu schweren Programmfehlern führen würde. Ein anderes Beispiel entsteht, wenn in einer Verzweigung eines Programms entweder ein neues oder ein bereits vorhandenes Objekt einer Variable zugewiesen wird. Woher weiß man bei der weiteren Benutzung dieser Variable, ob das Objekt schon vorher existierte und vielleicht schon andere Variablen auf es verweisen, oder ob es gerade erst neu erzeugt wurde und damit noch unbenutzt ist? Wer ist für die Entsorgung des Objekts verantwortlich? All diese Betrachtungen kann man sich in Gegenwart der Garbage Collection ersparen.",Was sind die Vorteile der Garbage Collection in SMALLTALK?,"Die Garbage Collection verhindert vorzeitige Entfernung von Objekten, die noch in Verwendung sind, und stellt sicher, dass Variablen auf gültige Objekte verweisen. Dies trägt zur Stabilität und Sicherheit von Programmen bei."
"Im objektorientierten Jargon spricht man übrigens häufig auch vom ""Lebenszyklus"" (""Life Cycle"") eines Objekts. Genaugenommen ist dies jedoch irreführend, denn das Wort ""Zyklus"" verspricht, dass das Leben nach seinem Ende wieder neu beginnt. Gerade dies ist aber, wie eben erläutert, nicht der Fall: Objekte werden nicht recycelt, sondern höchstens der Speicherplatz, den sie belegen.","Warum ist ""Lebenszyklus"" eines Objekts irreführend?","Der Begriff ""Lebenszyklus"" würde implizieren, dass das Objekt nach seinem Ende wiederverwendet wird, was nicht der Fall ist. Objekte werden nicht recycelt, sondern nur der von ihnen belegte Speicherplatz wird möglicherweise wiederverwendet."
,Welche praktische Bedeutung haben Metaklassen für die Programmierung in SMALLTALK?,"Metaklassen haben in SMALLTALK die praktische Bedeutung, dass sie die Definition von Klassen steuern und die Struktur des Programms beeinflussen. Sie ermöglichen es, Klassen dynamisch zu erzeugen und zu verändern. Zum Beispiel können Sie an der Ebene der Metaklassen Methoden hinzufügen, um das Verhalten von Klassen zu ändern, ohne die Klassen selbst zu ändern."
,"Was ist eine SortedCollection in SMALLTALK, und wie unterscheidet sie sich von anderen Collection-Klassen?","Eine SortedCollection ist eine Collection-Klasse in SMALLTALK, die eine Subklasse von OrderedCollection ist. Im Gegensatz zu anderen Collection-Klassen wird die Reihenfolge der Elemente in einer SortedCollection nicht von außen, durch Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt. Stattdessen wird die Reihenfolge von innen durch eine Qualität der eingefügten Objekte bestimmt. Dies ermöglicht es, die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge zu halten, unabhängig von der Reihenfolge, in der sie der Collection hinzugefügt wurden."
,"Welche Voraussetzungen müssen erfüllt sein, damit die Elemente einer SortedCollection sortiert werden können?","Damit die Elemente einer SortedCollection sortiert werden können, müssen sie vergleichbar sein, dh die Methode <= (für kleiner gleich) muss für die Elemente definiert sein. Dies ermöglicht es, die Elemente aufsteigend zu sortieren."
,"Was ist ein Sortierblock in einer SortedCollection, und wie wird er verwendet?","Ein Sortierblock ist eine Funktion, die zwei formale Parameter hat und zurückliefert, ob der erste Parameter kleiner oder gleich dem zweiten ist. In einer SortedCollection kann ein Sortierblock angegeben werden, wenn die Elemente keine Größen sind oder keinen natürlichen Vergleich unterstützen. Der Sortierblock wird verwendet, um die Elemente zu vergleichen und die Reihenfolge in der SortedCollection festzulegen. Wenn kein Sortierblock angegeben wird, wird ein Standardsortierblock verwendet."
,Was ist die einfachste Form des Kopierens eines Objekts in SMALLTALK?,"Die einfachste Form des Kopierens eines Objekts in SMALLTALK ist das Erzeugen eines Objekts derselben Klasse mit denselben Variablenbelegungen. Dies wird durch die Methode ""shallowCopy"" ermöglicht."
,"Welche Herausforderung kann bei flachem Kopieren auftreten, wenn es sich um ein tiefes Kopieren handelt?","Bei flachem Kopieren, das selbst ein tiefes Kopieren enthält, kann der Kopiervorgang leicht in eine Endlosrekursion geraten."
,"Welche Ansätze gibt es, um Objekte in der objektorientierten Programmierung zu erzeugen und ihnen Instanzvariablen und Methoden zuzuordnen?","Es gibt drei verschiedene Ansätze, um Objekte in der objektorientierten Programmierung zu erzeugen und ihnen Instanzvariablen und Methoden zuzuordnen: Konstruktoransatz: Bei diesem Ansatz wird der Aufbau eines Objekts in einer Methode beschrieben, die dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zuweist. Verschiedene Konstruktoren können verschiedene Varianten von Objekten erzeugen. Prototypenansatz: Hier wird ein bereits existierendes Objekt samt seiner Instanzvariablen und Methoden geklont. Ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt oder abgeändert werden. Klassenansatz: Alle Objekte werden als Instanzen von bestimmten Vorlagen (Klassen) erzeugt. Diese Klassen definieren die Struktur und das Verhalten der Objekte."
,Welche Programmiersprachen nutzen den Konstruktoransatz?,Der Konstruktoransatz findet sich in Sprachen wie EMERALD.
,Welche Programmiersprachen nutzen den Prototypenansatz?,Der Prototypenansatz wird in Sprachen wie SELF oder JavaSCRIPT angewendet.
,Welche Programmiersprachen nutzen den Klassenansatz?,"Der Klassenansatz wird in Sprachen wie SMALLTALK, C++, EIFFEL, Java, C-Sharp, SCALA und vielen anderen mehr angewendet."
,Was sind Konstruktoren in SMALLTALK?,"In SMALLTALK sind Konstruktoren Methoden, die, wenn sie auf einer Klasse aufgerufen werden, eine neue Instanz dieser Klasse erstellen und zurückgeben. Sie sind Klassenmethoden, die dazu dienen, neue Objekte zu erzeugen."
,Welche Rolle spielen Ein- und Ausgabeströme in der objektorientierten Programmierung?,"Ein- und Ausgabeströme spielen in der objektorientierten Programmierung eine wichtige Rolle, da sie den Zugriff auf Eingabe- und Ausgabedaten im System ermöglichen. Sie dienen dazu, Daten sowohl von/zu Benutzern als auch von/zu Dateisystemen zu lesen und zu schreiben."
,Welche Funktion haben Streams in Bezug auf Collections?,"Streams ermöglichen einen sequentiellen Zugriff auf einzelne Elemente in Collections zu beliebigen Zeitpunkten. Dies unterscheidet sich von Iteratoren, die die gesamte Collection in einem Schritt durchlaufen. Streams ermöglichen auch den gleichzeitigen oder zeitlich abwechselnden Zugriff auf die Elemente einer Collection durch mehrere andere Objekte. Streams stellen Positionszeiger in eine Collection bereit, um diese Funktionen umzusetzen."
,Was sind die Unterschiede zwischen lesbarbaren und schreibbaren Streams?,"Lesbare Streams ermöglichen das Lesen von Daten aus einer Quelle, während schreibbare Streams das Schreiben von Daten in eine Zielquelle ermöglichen. Lesbare Streams bieten Methoden zum Lesen von Daten, während schreibbare Streams Methoden zum Schreiben von Daten bereitstellen."
,Welche Informationen können in einer Metaklasse definiert werden?,"In einer Metaklasse können Informationen wie Instanzvariablen und Methoden für die zugehörige Klasse definiert werden. Dies ermöglicht es, das Verhalten und die Eigenschaften der Klasse individuell anzupassen."
,Was sind Klassen sprachphilosophisch?,"Sprachphilosophisch betrachtet ist eine Klasse ein Allgemeinbegriff. Diese Allgemeinbegriffe repräsentieren in der Regel eine Menge von Objekten,. Dennoch ist die Klasse selbst immer im Singular, da sie selbst ein Objekt ist, das unter den Allgemeinbegriff ""Klasse"" fällt."
,Was sind die Eigenschaften einer Klasse?,"Die Eigenschaften einer Klasse ordnen wir den Objekten zu, die dieser Klasse angehören. Zum Beispiel sind mit dem Allgemeinbegriff ""Person"" Eigenschaften wie Name, Geburtstag und möglicherweise weitere Attribute verknüpft, aber auch bestimmtes Verhalten, das für Personen charakteristisch ist. Diese Eigenschaften gehören den individuellen Objekten an, die Teil der Klasse ""Person"" sind."
,Was ist die Methode become: in SMALLTALK?,"Die Methode become: in SMALLTALK bewirkt, dass das Empfängerobjekt die Identität des Parameterobjekts annimmt oder mit ihm tauscht."
,Welche Auswirkungen hat die Methode become: auf Variablen?,"Die Methode become: bewirkt, dass Variablen, die vor der Ausführung der Methode auf das Empfängerobjekt verwiesen haben, danach auf das Parameterobjekt verweisen."
,Was ist eine weitere Anwendung von become:?,"Eine weitere Anwendung von become: ist die Durchführung eines Rollbacks, um den ursprünglichen Zustand eines Objekts oder Objektgeflechts nach einer Menge von Änderungen wiederherzustellen. Dies geschieht durch Erzeugen einer Kopie des ursprünglichen Objekts und anschließendem Ersetzen des geänderten Objekts durch die Kopie mittels become:."
,Welche Bedeutung hat die Generalisierung in der objektorientierten Programmierung?,"Die Generalisierung ermöglicht es, mehrere Klassen, deren Definitionen inhaltlich verwandt sind, zu abstrahieren und zusammenzufassen. Dies führt zur Bildung einer Generalisierungsklasse, die die gemeinsamen Eigenschaften (Instanzvariablen und Methoden) der generalisierten Klassen enthält. Die Generalisierung erlaubt es, Gemeinsamkeiten zwischen Klassen auf höherer Abstraktionsebene darzustellen und die Wiederverwendung von Code zu fördern."
,Was ist die mengentheoretische Interpretation der Generalisierung?,"In der mengentheoretischen Interpretation der Generalisierung ist die Menge der Instanzen einer Generalisierung eine Obermenge der Vereinigung der Mengen der Instanzen von generalisierten Klassen. Dies bedeutet, dass Instanzen von generalisierten Klassen auch Instanzen der Generalisierung sind."
,Was sind Konstruktoren in SMALLTALK und was ist ihre Aufgabe?,"In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse erstellen und zurückliefern. Ihre Aufgabe ist es, neue Objekte zu erzeugen."
,"Was ist ""Lazy initialization"" und wann kann es sinnvoll sein?","""Lazy initialization"" ist eine Technik, bei der die Initialisierung von Instanzvariablen zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt wird. Dies kann sinnvoll sein, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Die Initialisierung wird verschoben, um den Preis der Initialisierung im Programmablauf zu sparen, wenn sie nie notwendig wird."
,Welches Entwurfsmuster wird SMALLTALK zugeschrieben und warum ist es wichtig?,"SMALLTALK wird das Model-View-Controller-Entwurfsmuster (MVC-Pattern) zugeschrieben. Es ist wichtig, da es sich auch heute noch großer Beliebtheit erfreut und in vielen Anwendungen, einschließlich Web-Anwendungen, verwendet wird. Das MVC-Pattern ermöglicht verschiedene Ansichten auf ein logisches Modell, und Änderungen im Modell müssen alle Ansichten darüber informieren. Daher erfordert es eine Eins-zu-viele-Kommunikation, die nicht durch den normalen Nachrichtenversand abgedeckt wird."
,Was ist eine Klassendefinition?,"Eine Klassendefinition liefert die Intension oder Beschreibung einer Klasse. Sie besteht aus dem Namen der Klasse, der Liste der benannten Instanzvariablen, Angaben zu indizierten Instanzvariablen, Informationen zur Atomarität, und einer Liste von Instanzmethoden."
,Was sind Instanzen einer Klasse?,"Eine Instanz der Klasse ist das Objekt, das zur Extension der Klasse gehört. Jede Instanz belegt den Satz an Instanzvariablen individuell. Alle Instanzen einer Klasse verstehen dieselben Nachrichten und verwenden dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren."
,Was sind indizierte Instanzvariablen?,Indizierten Instanzvariablen enthalten binäre Repräsentationen.
,Was sind globale Pseudovariablen?,"In SMALLTALK wird jede Klasse nach ihrer Erzeugung durch eine globale Pseudovariable repräsentiert, deren Name dem Namen der Klasse entspricht. Diese globale Pseudovariable ist notwendig, um auf die Klasse und ihre Methoden zugreifen zu können. Klassennamen sind global und von überall aus im Code zugreifbar."
,Was sind die Rollen der beiden Enden der Subklassenbeziehung?,"Die beiden Enden der Subklassenbeziehung haben die Rollen ""Superklasse"" und ""Subklasse"". Diese Rollen legen nahe, dass die Subklassenbeziehung eine Hierarchie von Klassen aufbaut, in der die Superklassen über den Subklassen stehen. Die Superklasse ist die allgemeinere Klasse, von der die Subklasse erbt, während die Subklasse die speziellere Klasse ist, die die Eigenschaften der Superklasse erbt und möglicherweise erweitert oder anpasst."
,Welche Konzepte haben die Entwicklung objektorientierter Programmiersprachen im Gegensatz zu Generalisierung und Spezialisierung geprägt?,Die Entwicklung objektorientierter Programmiersprachen wurde eher von abstrakten Klassen und Vererbung als von den theoretischen Konzepten der Generalisierung und Spezialisierung geprägt.
,Was ist das Konzept der offenen Rekursion in SMALLTALK?,"Das Konzept der offenen Rekursion in SMALLTALK bedeutet, dass die Methode, die durch eine Nachricht an self aufgerufen wird, nicht zwangsläufig die in derselben Klasse definierte Methode ist. Stattdessen kann die passende Methode in einer Subklasse gefunden werden, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde. Dies kann zu überraschenden Ergebnissen führen, wenn nicht erwartet wird, dass die Methode in einer Subklasse überschrieben wurde."
,Was ist der grundlegende Unterschied zwischen aktiven und passiven Objekten in der objektorientierten Programmierung?,"Aktive Objekte sind Objekte, die über einen eigenen Rechenprozess verfügen und Nachrichten asynchron empfangen und verarbeiten können. Passive Objekte hingegen sind Objekte, die nur aktiv sind, solange sie gerade eine Methode ausführen. In der Praxis werden jedoch passive Objekte verwendet, da aktive Objekte sehr aufwendig wären."
,"Welche Methode wird verwendet, um einen parametrisierten Block als Prozess zu starten?","Um einen parametrisierten Block als Prozess zu starten, verwendet man die Methode ""newProcessWith:"" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält."
,"Was ist die Beziehung zwischen der Klasse ""Metaclass"" und ihrer eigenen Meta-Metaklasse?","Die Klasse ""Metaclass"" von ""Metaclass"" wird selbst als einfache Metaklasse betrachtet, obwohl sie eigentlich eine Meta-Meta-Metaklasse ist. Genau wie alle anderen Metaklassen ist sie eine Instanz von ""Metaclass"". Daher gilt für ""Metaclass"": Metaclass ist eine Instanz von Metaclass."
,Welche Ebenen gibt es in SMALLTALK im Zusammenhang mit Klassen und Instanzen?,"In SMALLTALK gibt es mehrere Ebenen im Zusammenhang mit Klassen und Instanzen: Ebene 0: Konkrete Objekte, die nicht instanziierbar sind und Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Ebene 1: Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Ebene 2: Metaklassen, die die Klassen auf Ebene 1 definieren. Jede Metaklasse hat genau eine Instanz. Ebene 3: Die Klasse ""Metaclass"", von der alle Metaklassen Instanzen sind."
,Was ist der wesentliche Nachteil von Arrays in SMALLTALK?,"Der wesentliche Nachteil von Arrays in SMALLTALK ist, dass ihre Größe beschränkt ist. Das bedeutet, dass die Anzahl der Elemente in einem Array begrenzt ist, und es schwierig oder teuer sein kann, die Größe eines Arrays dynamisch zu ändern, um mehr Elemente aufzunehmen."
,"Welche SMALLTALK-Klasse eignet sich besser für geordnete Collections, die beliebig wachsen können, und warum?","Für geordnete Collections, die beliebig wachsen können und bei denen am Anfang, am Ende oder an einer beliebigen Position dazwischen Elemente hinzugefügt werden können, eignet sich die Klasse ""OrderedCollection"" besser als Arrays. OrderedCollections bieten einen geeigneten Methodensatz und ein Protokoll für die Implementierung von Stapeln (Stacks) und Puffern (Queues). Sie sind flexibler und können dynamisch wachsen, was Arrays nicht können."
,Welche Besonderheiten gibt es beim Entfernen eines Objekts aus einer Collection in SMALLTALK?,"Beim Entfernen eines Objekts aus einer Collection gibt es zwei Sonderfälle zu berücksichtigen: Das Objekt ist nicht vorhanden oder das Objekt ist mehrfach vorhanden. Im ersten Fall wird ein Fehler gemeldet, während im zweiten Fall nur ein Vorkommen des Objekts aus der Collection entfernt wird. SMALLTALK bietet eine Variante von remove: namens remove: anObject ifAbsent: anExceptionBlock, die es ermöglicht, das Verhalten beim Fehlen des zu entfernenden Objekts zu steuern. Wenn das Objekt fehlt, wird anExceptionBlock ausgeführt, und dessen Ergebnis wird zurückgeliefert."
,"Was ist die Hierarchie in SMALLTALK, die auf dem Konzept der Klassifikation basiert?","In SMALLTALK gibt es eine Hierarchie, die auf dem Konzept der Klassifikation basiert. Diese Hierarchie stellt eine Abstraktionshierarchie dar, bei der von konkreten Objekten der Ebene 0 über Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Konzepte auf Ebene 2 und schließlich zur Fassung von Definitionen auf Ebene 3 fortgeschritten wird."
,Welche Ebene der Hierarchie nutzen Programmierer in der Praxis am meisten?,"In der Praxis bewegen sich Programmierer hauptsächlich auf Ebene 1. Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen sie also hauptsächlich eine Abstraktionsstufe für die Programmierung."
,"Was sind einige Beispiele für spezielle, instanziierbare (konkrete) Collection-Klassen in SMALLTALK und wofür werden sie verwendet?","Einige Beispiele für spezielle, instanziierbare (konkrete) Collection-Klassen in SMALLTALK sind: Set: Diese Klasse wird verwendet, um ungeordnete Collections darzustellen, in denen jedes Element höchstens einmal vorkommen darf, was einer Menge entspricht. Bag: Bag wird verwendet, um ungeordnete Collections darzustellen, in denen die Einschränkung aufgehoben ist, dass Elemente nur einmal vorkommen dürfen. In einer Bag können Elemente mehrmals vorhanden sein. SequenceableCollection oder IndexedCollection: Diese Klassen repräsentieren geordnete Collections, bei denen das i-te Element eindeutig bestimmt ist. Sie implementieren die Methoden ""at:"" und ""at:put:"", um auf Elemente zuzugreifen oder Elemente an einer bestimmten Position einzufügen oder zu ändern. Dictionary: Diese Klasse repräsentiert eine ungeordnete Collection, bei der jedes Element unter einem Schlüssel gespeichert wird. Die Methoden ""at:"" und ""at:put:"" werden verwendet, um auf die Elemente zuzugreifen oder sie zu ändern. Dabei können Schlüssel Objekte verschiedener Klassen sein, nicht nur Integer."
,"Welche Gemeinsamkeiten haben die Klassen ""Set"" und ""Bag"" in SMALLTALK?","Die Gemeinsamkeit zwischen den Klassen ""Set"" und ""Bag"" besteht darin, dass beide ungeordnete Collections repräsentieren. In diesen Collections darf jedes Element höchstens einmal vorkommen. Sie unterscheiden sich jedoch darin, dass in einem Set die Elemente eindeutig sind und keine Duplikate enthalten, während in einer Bag Elemente mehrmals vorhanden sein können."
,"Welche Möglichkeiten gibt es, den Mechanismus der Vererbung von Superklassen auf Subklassen umzusetzen?","Es gibt verschiedene Möglichkeiten, den Mechanismus der Vererbung von Superklassen auf Subklassen umzusetzen. Zwei dieser Möglichkeiten wurden im Text angedeutet: Kopieren und Einfügen: Eine Möglichkeit wäre, die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Dies würde die Semantik der Vererbung korrekt wiedergeben, aber bei Änderungen an der Superklasse müssten auch alle Subklassen aktualisiert werden, was technisch problematisch wäre. Automatische Instanzerzeugung: Eine andere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch Instanzen aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Dies würde jedoch das Konzept der Identität von Objekten beeinträchtigen, da Objekte einer Subklasse mehrere Identitäten hätten."
,Was ist Spezialisierung in Bezug auf die objektorientierte Programmierung?,"Spezialisierung ist das Gegenteil von Generalisierung in der objektorientierten Programmierung. Während bei der Generalisierung Eigenschaften weggelassen oder verallgemeinert werden, fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene Eigenschaften von Klassen. Es bedeutet, dass eine Klasse eine Spezialisierung ihrer Generalisierungen sein kann, wenn sie zusätzliche Merkmale oder Verhaltensweisen hinzufügt."
,Was ist die Funktion der Methode printString in SMALLTALK?,"Die Methode printString gibt eine String-Repräsentation eines Objekts zurück. Diese Repräsentation kann für Ausgaben auf dem Transcript, zur Inspektion von Objekten und für das Debugging verwendet werden."
,Was ist die Funktion der Methode storeOn: in SMALLTALK?,"Die Methode storeOn: ermöglicht das Schreiben eines Objekts auf einen Ausgabestrom in einer textuellen Repräsentation, die später zur Rekonstruktion des Objekts verwendet werden kann. Es wird keine binäre Repräsentation verwendet. Dies ist nützlich, um Objekte in einer menschenlesbaren Form zu speichern und später wiederherzustellen."
,Was ist Instanziierung?,"Instanziierung ist der Prozess, bei dem ein neues Objekt einer bestimmten Klasse erstellt wird. Das neue Objekt wird eine Instanz dieser Klasse genannt und hat die Eigenschaften (Instanzvariablen und Methoden), die durch die Definition (Intension) der Klasse festgelegt sind."
,Was ist eine Instanz?,"In SMALLTALK ist jedes Objekt Instanz genau einer Klasse. Genaugenommen ist es direkte Instanz genau einer Klasse. Dabei weiß jedes Objekt, von welcher Klasse es eine Instanz ist."
,Welche Alternative gibt es zur Instanziierung?,Eine Alternative zur Instanziierung ist das Klonen.
,Was ist das Klonen?,"Das Klone ist ein Prozess, bei dem ein neues Objekt auf der Basis eines bereits existierenden Objekts erstellt wird. Der Klon ist eine Kopie des Originalobjekts. Beim Klonen muss festgelegt werden, wie tief die Kopie gehen soll, dh ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht, kopiert werden sollen. Während das Klonen in klassenbasierten objektorientierten Programmiersprachen in der Regel durch Instanziierung und Übertragung von Inhaltsdaten der Instanzvariablen erzeugt wird, erfolgt das Klonen in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse nicht kennen, durch einfaches Kopieren. In SMALLTALK wird die Instanziierung normalerweise bevorzugt, da es sich um eine klassenbasierte Sprache handelt."
,Welche Bezeichnungen werden alternativ zur Subklassenbeziehung und den Begriffen Subklasse und Superklasse in der objektorientierten Programmierung verwendet?,"In der objektorientierten Programmierung werden neben der Subklassenbeziehung und den Begriffen Subklasse und Superklasse auch Begriffe wie ""abgeleitete Klassen"" und ""Basisklassen"" verwendet. Im Englischen sind auch die Begriffe ""Derived class"" und ""Base class"" gebräuchlich. Es kann je nach Programmiersprache und Konvention unterschiedliche Bezeichnungen geben."
,"Welche Bedingungen müssen erfüllt sein, damit eine Subklassenbeziehung zwischen zwei Klassen in SMALLTALK zulässig ist?","Damit eine Subklassenbeziehung zwischen zwei Klassen in SMALLTALK zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen: Benannte Instanz- und Klassenvariablen dürfen nicht dieselben Namen haben wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Wenn die Superklasse indizierte Instanzvariablen hat, müssen diese auch in der Subklasse vorhanden sein. Methodendefinitionen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden."
,Welche Ansicht über die objektorientierte Programmierung herrschte in den Anfängen von SMALLTALK?,"In den Anfängen von SMALLTALK herrschte die Ansicht vor, dass einer der Hauptvorteile der objektorientierten Programmierung die Wiederverwendung von Code durch Vererbung sei. Man glaubte, dass die Vererbung dazu diene, Code und Eigenschaften von einer allgemeineren Klasse (Superklasse) auf speziellere Klassen (Subklassen) zu übertragen, was die Wiederverwendung von Code fördert."
,Was sind Factory-Methoden in SMALLTALK?,"Factory-Methoden in SMALLTALK sind spezielle Klassenmethoden, die ähnlich wie Konstruktoren neue Instanzen erstellen. Allerdings können sie die Klasse der Instanz basierend auf anderen Faktoren als nur der Klasse, zu der die Methode gehört, festlegen."
,Welches Prinzip geht der Vererbung voraus und wie stehen sie in Beziehung zueinander?,"Die Prinzipien von Generalisierung und Spezialisierung gehen der Vererbung voraus. Generalisierung und Spezialisierung sind eng mit der Vererbung verbunden, da Vererbung oft verwendet wird, um diese Prinzipien umzusetzen. Generalisierung ist die Bildung von allgemeineren Klassen aus spezifischeren Klassen, während Spezialisierung die Bildung spezifischerer Klassen aus allgemeineren Klassen ist."
,"Welches Problem kann bei der Vererbung auftreten, wenn sie nicht in Einklang mit den Prinzipien von Generalisierung und Spezialisierung angewendet wird?","Ein Problem bei der Vererbung tritt auf, wenn sie oberflächlich zur Wiederverwendung von Elementen einer Klassendefinition verwendet wird, ohne die Prinzipien von Generalisierung und Spezialisierung zu berücksichtigen. Dies kann dazu führen, dass die Beziehung zwischen den Extensionen der beteiligten Klassen nicht angemessen berücksichtigt wird und zu unerwarteten Konsequenzen führt."
,"Was sind Dictionaries in SMALLTALK, und wofür werden sie verwendet?","In SMALLTALK repräsentieren Dictionaries qualifizierte Beziehungen, bei denen jedes Element der Beziehung durch einen Schlüssel (auch als Qualifizierer oder Key bezeichnet) eindeutig bestimmt wird. Ein Element einer qualifizierten Beziehung besteht aus einer Assoziation eines Schlüssels mit einem Wert (Value). Dictionaries ermöglichen es, Werte unter ihren Schlüsseln extrem schnell, idealerweise ohne Suche, zu finden. Dies wird in der Regel durch Hashing erreicht."
,Welche besondere Bedeutung hat die Klasse Dictionary in SMALLTALK?,"Die Klasse Dictionary in SMALLTALK realisiert Assoziativspeicher, bei denen auf Speicherzellen nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet, beispielsweise um Methoden in Dictionaries zu hinterlegen, wobei der Nachrichtenselektor die Rolle des Schlüssels spielt und als Wertobjekt die kompilierte Methode gespeichert ist. Dictionaries können auch verwendet werden, um andere Arten von Collections, wie z.B. die Klasse Bag, zu implementieren."
,Welche Einschränkung gibt es bei der Verwendung eines Attributs als Schlüssel in einem Dictionary?,"Wenn ein Attribut eines in einem Dictionary gespeicherten Objekts als Schlüssel verwendet wird, sollte dieses Attribut unveränderlich sein. Dies liegt daran, dass das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel im Dictionary gespeichert ist und nur unter diesem Wert wiedergefunden wird."
,Was ist die Klassifikation?,"Eine Klassifikation ist eine Zuordnung von Individuen oder Objekten zu bestimmten Allgemeinbegriffen oder Klassen. Diese Klassifikation ermöglicht eine Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen und Eigenschaften nur noch für die Klassen im Allgemeinen getroffen werden müssen, anstatt für jedes einzelne Objekt. Statt also Eigenschaften und Methoden direkt Objekten zuzuweisen, verbindet man sie mit Klassen und legt fest, dass sie die einzelnen Objekte, die zu dieser Klasse gehören, beschreiben."
,Was ist die Extension?,"Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören."
,Was ist die Intension?,"Die Intension ist die Summe der Merkmale oder Eigenschaften, die den Begriff ausmachen und die Objekte charakterisieren, die zu dieser Klasse gehören. Die Intension ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die entscheidet, ob ein beliebiges Element unter den Begriff fällt."
,Was sind Allgemeinbegriffe ?,"Allgemeinbegriffe sind die Vorbilder für Klassen in der objektorientierten Programmierung. In SMALLTALK werden Allgemeinbegriffe in Form von Klassen repräsentiert. Klassen sind die Vorbilder für Objekte in der objektorientierten Programmierung. Jede Klasse kann Instanzvariablen und Methoden haben, die das Verhalten und die Eigenschaften der Objekte beschreiben, die zu dieser Klasse gehören."
,Was sind abstrakte Klassen in der objektorientierten Programmierung?,"Abstrakte Klassen in der objektorientierten Programmierung sind Klassen, die selbst keine Instanzen haben und daher nicht instanziierbar sind. Sie werden oft verwendet, um gemeinsame Eigenschaften und Methoden für ihre Subklassen bereitzustellen, aber sie sind in der Regel unvollständig definiert und können zu Laufzeitfehlern führen, wenn sie direkt instanziiert werden."
,Was ist ein Beispiel für eine abstrakte Klasse in SMALLTALK und wie zeigt sich ihre Abstraktheit?,"Ein Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse ""Collection"". Ihre Abstraktheit zeigt sich darin, dass sie keine benannten Instanzvariablen hat und einige ihrer Methoden, wie ""add:"", nicht implementiert sind. Wenn jemand versuchen würde, die Methode ""add:"" auf einer Instanz von ""Collection"" oder einer ihrer Subklassen aufzurufen, würde dies zu einer Fehlermeldung führen."
,"Was ist die Klasse ""Interval"" und wofür werden ihre Instanzen verwendet?","Die Klasse ""Interval"" repräsentiert endliche arithmetische Folgen von Zahlen, bei denen alle Zahlen denselben Abstand voneinander haben. Instanzen dieser Klasse werden verwendet, um solche Intervalle zu definieren, wobei die Spezifikation eines Intervalls den Anfangs- und Endwert sowie die Schrittweite umfasst, die sogar negativ sein kann."
,"Was ist das Besondere an der Methode ""to:by:do:""?","Die Methode ""to:by:do:"" erlaubt die kompakte Darstellung einer ""For""-Schleife und erspart die Verwendung von Klammern. Sie ermöglicht es, den Schleifenkörper in einem übersichtlichen Format anzugeben."
,"Welche Art von Methoden bietet die Klasse ""Object"" den Objekten an?","Die Klasse ""Object"" bietet eine Vielzahl von Methoden an, die grundlegende Typtests und andere gemeinsame Operationen für Objekte ermöglichen. Dazu gehören Methoden wie isNil, notNil, isInteger, isFloat und viele andere. Diese Methoden erlauben es, Eigenschaften von Objekten abzufragen und deren Typ zu überprüfen."
,Was sind Zu-n-Beziehungen und wie stehen sie zu Zu-1-Beziehungen?,"Zu-n-Beziehungen sind Beziehungen, bei denen ein Objekt mit mehreren anderen Objekten in Beziehung stehen kann. Sie stehen logisch gleichberechtigt neben Zu-1-Beziehungen, bei denen ein Objekt nur mit einem anderen Objekt in Beziehung steht. Die Umsetzung von Zu-n-Beziehungen erfordert jedoch besondere Mechanismen."
,Welche Rolle spielen Zwischenobjekte in der Umsetzung von Zu-n-Beziehungen?,"Zwischenobjekte spielen eine Rolle in der Umsetzung von Zu-n-Beziehungen. Sie ermöglichen es, solche Beziehungen indirekt über ihre indizierten Instanzvariablen herzustellen."
,Welcher Vorteil ergibt sich aus der Verwendung von Zwischenobjekten in Bezug auf Zu-n-Beziehungen?,"Ein entscheidender Vorteil der Verwendung von Zwischenobjekten in Bezug auf Zu-n-Beziehungen ist die Möglichkeit, verschiedene Arten von solchen Beziehungen zu definieren und diesen jeweils spezifisches Verhalten zuzuweisen, das auf die Art der Beziehung abgestimmt ist. Dies ermöglicht es, mengenwertige Beziehungen oder sortierte Beziehungen zu erstellen und Operationen wie das Hinzufügen oder Entfernen von Objekten individuell anzupassen."
,Was sind einige Beispiele für spezielle Arten von Zu-n-Beziehungen?,"Ein Beispiel für eine spezielle Art von ""n-Beziehung"" ist eine mengenwertige Beziehung, bei der die Elemente jeweils nur einmal darin vorkommen dürfen. Eine weitere Art ist eine sortierte Beziehung, bei der die Elemente nach einem bestimmten Kriterium sortiert sind."
,Welche Rolle spielen Standarditeratoren in Bezug auf Zu-n-Beziehungen?,"Standarditeratoren spielen eine Rolle in Bezug auf Zu-n-Beziehungen, und je nach Art der Beziehung haben sie unterschiedliche Eigenschaften. Diese Standarditeratoren wurden bereits in Abschnitt 4.6.4 vorgestellt."
,"Wie wird in SMALLTALK die Mächtigkeit eines Programms hervorgehoben, insbesondere im Vergleich zu imperativen und objektorientierten Programmiersprachen?","In SMALLTALK wird die Mächtigkeit eines Programms hervorgehoben, indem betont wird, dass Klassen Instanzen von Metaklassen sind, die selbst Instanzen einer weiteren Klasse sind. Dieses Zusammenspiel von Klassen und Metaklassen ermöglicht eine hohe Programmiermächtigkeit. Im Vergleich zu imperativen und objektorientierten Programmiersprachen sucht diese Mächtigkeit bis heute ihresgleichen."
,"Wie können Objekte von einer Collection in eine andere übertragen werden, und warum kann dies nützlich sein?","Eine Menge von Objekten aus einer Collection kann in eine andere übertragen werden, indem Konvertierungsmethoden wie asSet oder asSortedCollection verwendet werden. Dies ist nützlich, um die Eigenschaften der Ziel-Collection zu berücksichtigen, z. B. doppelte Elemente zu entfernen oder die Elemente zu sortieren. Es ermöglicht auch die Umwandlung von Collections in Collections mit strengeren Bedingungen, was je nach Anwendungsfall nützlich sein kann."
,Wie können Sie technisch eine rekursive tiefe Kopie in den Griff bekommen?,"Um eine rekursive tiefe Kopie in den Griff zu bekommen, können Sie eine Methode implementieren, die überprüft, ob ein Objekt bereits kopiert wurde, und es nur dann kopiert, wenn es noch nicht kopiert wurde. Dadurch wird die Endlosrekursion vermieden."
,Wie ist die Vererbungshierarchie der Metaklassen in SMALLTALK organisiert?,"In SMALLTALK können Metaklassen, die ebenfalls Klassen sind, voneinander erben. Die Vererbungshierarchie der Metaklassen wird parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind, erstellt. Dies bedeutet, dass in SMALLTALK sowohl Instanzvariablen und -methoden als auch Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt werden. Jede Metaklasse in SMALLTALK erbt automatisch von ""Object class"", der Metaklasse von ""Object"". Die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, einschließlich der Standardkonstruktoren ""new"" und ""new:"", werden in ""Object class"" (genauer gesagt als Instanzmethoden von ""Object class"") definiert. Um die Unterscheidung zwischen instanziierbaren Klassen (Klassen) und nicht instanziierbaren Klassen (Metaklassen) sowie zwischen Klassen und Metaklassen zu treffen, wird die Klasse ""Class"" verwendet. ""Class"" ist die Superklasse aller Metaklassen und stellt sicher, dass jede Instanz dieser Klasse eine Klasse ist. Obwohl ""Class"" die Superklasse aller Metaklassen ist, ist sie selbst keine Metaklasse. Die Klasse von ""Class"" ist ""Class class"", und erst ""Class class"" ist eine Metaklasse."
,Wie werden Streams in SMALLTALK normalerweise erzeugt?,"Streams werden normalerweise durch die Klassenmethode on: auf einer Collection erzeugt. Diese Methode erhält eine Collection als Parameter und erstellt einen Stream, der auf dem Inhalt der Collection basiert."
,Wie werden Metaklassen in SMALLTALK erstellt?,"In SMALLTALK werden Metaklassen automatisch erstellt, wenn eine neue Klasse definiert wird. Jede Klasse hat automatisch ihre eigene Metaklasse, die die Definitionen von Instanzvariablen und Methoden für diese Klasse enthält."
,Wie können Programmierer in SMALLTALK geerbte Methoden löschen?,"In SMALLTALK können Programmierer geerbte Methoden löschen, indem sie die Methode ""shouldNotImplement"" in der Subklasse implementieren und die geerbte Methode überschreiben. Wenn eine Klasse also eine geerbte Methode löschen möchte, überschreibt sie diese Methode einfach mit ""shouldNotImplement"". Diese Konvention ermöglicht es Programmierern, geerbte Methoden elegant auszulöschen, sollte dies erforderlich sein. Es ist jedoch wichtig zu beachten, dass der Wunsch, geerbte Methoden zu löschen, eine direkte Folge der Orientierung an Vererbung ist, die in dieser Textpassage kritisiert wird. Wenn die Superklasse auf Grundlage des Prinzips der Generalisierung ausgewählt wurde, besteht normalerweise keine Notwendigkeit, geerbte Methoden zu löschen, da alles, was für die Generalisierung sinnvoll ist, auch für ihre Spezialisierungen sinnvoll ist. Dieses Prinzip wird in späteren Kurseinheiten weiter erläutert."
,Wie kann die Methode grow in der Klasse ArrayedCollection verwendet werden?,"Die Methode grow in der Klasse ArrayedCollection kann verwendet werden, um ein Objekt zu vergrößern, indem man eine neue Stelle als entsprechend groß dimensioniertes Objekt anlegt und dann das alte Objekt durch die neue Stelle mittels become: ersetzt."
,"Wie werden Instanzvariablen in SMALLTALK standardmäßig initialisiert, nachdem eine Instanz erzeugt wurde?","Nach der Erzeugung einer Instanz in SMALLTALK haben alle Instanzvariablen standardmäßig den Wert ""nil"". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden, normalerweise durch Aufrufen der Methode ""initialize""."
,Wie wird die Eins-zu-viele-Kommunikation in SMALLTALK umgesetzt?,"Die Eins-zu-viele-Kommunikation in SMALLTALK wird durch das in SMALLTALK implementierte Protokoll umgesetzt. Dieses Protokoll ermöglicht die Kommunikation zwischen verschiedenen Teilen einer Anwendung, insbesondere im Kontext des MVC-Patterns."
,Wie werden Klassendefinitionen in SMALLTALK umgesetzt?,"In SMALLTALK erfolgt die Klassendefinition nicht in einer separaten Datei wie in vielen anderen objektorientierten Programmiersprachen. Stattdessen werden Klassendefinitionen durch Eintragungen in eine Datenstruktur oder das Erzeugen eines Objekts repräsentiert. Es gibt keine spezielle Syntax für Klassendefinitionen, nur ein Schema."
,Wie funktioniert die Verwendung von super in SMALLTALK?,"Wenn super als Nachrichtenempfänger in einer Methodendefinition verwendet wird, beginnt die Suche nach der zur Nachricht passenden Methodendefinition in der (direkten) Superklasse der Klasse, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet. Anders als bei self ist die Suche unabhängig von der Klasse des Objekts, für das super steht. Das bedeutet, dass super immer eine von der Klasse des konkreten Empfängerobjekts losgelöste Suche auslöst, die in der Superklasse der Klasse beginnt, in der super verwendet wird, und nicht in der Superklasse der Klasse, von der das (durch super bezeichnete) Empfängerobjekt eine direkte Instanz ist."
,"Wie wird Parallelverarbeitung in SMALLTALK implementiert, und warum werden keine aktiven Objekte verwendet?","In SMALLTALK wird Parallelverarbeitung nicht in Form von aktiven Objekten, sondern in Form von parallelen Prozessen implementiert. Jeder dieser Prozesse führt zu einem Zeitpunkt eine Methode aus, wobei die Empfängerobjekte selbst passiv bleiben. Dies liegt daran, dass aktive Objekte, die asynchron Nachrichten verarbeiten, in der Praxis sehr aufwendig wären."
,Wie startet man in SMALLTALK einen neuen Prozess?,"In SMALLTALK kann man einen neuen Prozess starten, indem man einem Block die Nachricht ""fork"" sendet. Dies führt dazu, dass der Block in einem eigenen, unabhängigen Prozess ausgeführt wird."
,Wie erfolgt die Synchronisation von parallelen Prozessen in SMALLTALK?,"Die Synchronisation von parallelen Prozessen in SMALLTALK erfolgt zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen über Methoden wie ""wait"" und ""signal"", um die Ausführung von Prozessen zu steuern. Semaphore-Objekte zählen die Anzahl der Signale und können Prozesse in den Schlaf versetzen oder aufwecken, abhängig von ihrem aktuellen Zustand. Die Synchronisation kann auch über die Klasse SharedQueue erfolgen, die Objekte aufnimmt und Synchronisation über ""next"" und ""nextPut:"" ermöglicht."
,Wie funktioniert die Suche nach einer Methode in SMALLTALK?,"Bei der Suche nach einer Methode wird zunächst im Methodenwörterbuch der Klasse des Empfängers nachgeschlagen. Wenn die Methode dort nicht gefunden wird, wird in der direkten Superklasse der Klasse des Objekts gesucht, und dieser Prozess setzt sich fort, bis die Methode gefunden wird oder bis zur Klasse ""Object"". Sobald die Methode gefunden wird, wird sie ausgeführt. Falls die Methode auch in ""Object"" nicht gefunden wird, wird die Nachricht ""doesNotUnderstand:"" an den ursprünglichen Empfänger mit der ursprünglichen Nachricht als Argument gesendet."
,"Wie wird die Klasse ""Metaclass"" in SMALLTALK bezeichnet und warum?","Die Klasse ""Metaclass"" wird in SMALLTALK als ""Metaclass"" bezeichnet, weil alle ihre Instanzen Metaklassen sind. Dies folgt der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz ""<eine Instanz> ist ein <Klassenname>"" korrekt ergänzen."
,"Wie können Zu-n-Beziehungen in SMALLTALK gepflegt werden, und welche Methoden werden standardmäßig verwendet?","In SMALLTALK werden Zu-n-Beziehungen standardmäßig mit den Methoden add: und remove: gepflegt. Diese Methoden sind in der abstrakten Klasse Collection definiert, und alle Klassen, die : n-Beziehungen repräsentieren, sind indirekte Instanzen von Collection. Diese Methoden bleiben zunächst abstrakt und müssen in den entsprechenden Subklassen implementiert werden."
,Wie können mehrere Objekte auf einmal einer Beziehung in SMALLTALK hinzugefügt oder daraus entfernt werden?,"Um mehrere Objekte auf einmal einer Beziehung hinzuzufügen oder daraus zu entfernen, stehen die Methoden addAll: aCollection und removeAll: aCollection zur Verfügung. Beide Methoden akzeptieren eine Collection als Parameter und führen die entsprechenden Aktionen für jedes Objekt in der übergebenen Collection aus."
,Wie wird die Vererbung in SMALLTALK und vielen anderen objektorientierten Programmiersprachen tatsächlich umgesetzt?,"In SMALLTALK und vielen anderen objektorientierten Programmiersprachen wird die Vererbung als ein Teilen der Klassendefinitionen realisiert. Das bedeutet, dass Vereinbarungen, die in einer Klasse getroffen wurden, automatisch auch für alle Subklassen gelten, es sei denn, diese spezifizieren etwas anderes. Die Vereinbarungen werden nicht übertragen oder kopiert, sondern einfach gemeinsam genutzt. Dies ermöglicht eine effiziente Vererbung von Eigenschaften und Verhalten, ohne die Probleme mit der Identität von Objekten oder der Notwendigkeit der Aktualisierung von Subklassen bei Änderungen in der Superklasse."
,Wie kann man das Problem der Spezialisierung von Klassen elegant lösen?,"Das Problem der Spezialisierung von Klassen kann elegant gelöst werden, indem parallel zur spezialisierten Klasse eine Klasse ""NichtSpezialisierteKlasse"" eingeführt wird. Alle Eigenschaften, die andere Instanzen von derselben Generalisierung unterscheiden, können in der ""NichtSpezialisierteKlasse"" platziert werden. Dadurch bleibt die Hierarchie sauber und ermöglicht eine klare Unterscheidung zwischen spezialisierten und nicht spezialisierten Klassen."
,Wie kann die Methode inspect in SMALLTALK genutzt werden und wofür ist sie nützlich?,"Die Methode inspect startet einen Inspektor auf dem Empfängerobjekt und gibt das Empfängerobjekt zurück. Sie ist nützlich, wenn Sie ein Zwischenergebnis eines Ausdrucks inspizieren möchten, ohne den Ausdruck in zwei Teile aufteilen zu müssen. Sie fügen einfach inspect an der Stelle des Ausdrucks ein, an der das zu inspizierende Objekt gewonnen wurde."
,Wie passiert in SMALLTALK die Instanziierung?,"In SMALLTALK wird normalerweise die Instanziierung eines Objekts durch Senden der Nachricht ""new"" (für Klassen ohne indizierte Instanzvariablen) oder ""new:"" (für Klassen mit indizierten Instanzvariablen) an die Klasse durchgeführt. Das neue Objekt wird im Speicher angelegt, und seine Instanzvariablen werden alle mit ""nil"" initialisiert."
,Wie wird in SMALLTALK eine neue Klasse erstellt und eine Superklasse angegeben?,"In SMALLTALK wird eine neue Klasse erstellt, indem man einer Superklasse eine entsprechende Nachricht sendet. Es gibt kein spezielles Schlüsselwort wie ""extends"" in anderen Programmiersprachen. Stattdessen erfolgt die Klassenerstellung in einem speziellen Browser durch Senden einer Nachricht an die Superklasse."
,Wie unterscheiden sich Factory-Methoden formal von Konstruktoren in SMALLTALK?,"Formal unterscheiden sich Factory-Methoden in SMALLTALK nicht von Konstruktoren; sie sind ebenfalls Klassenmethoden. Der Unterschied besteht darin, dass Factory-Methoden die Klasse der Instanz basierend auf anderen Faktoren festlegen können, während Konstruktoren normalerweise Instanzen derselben Klasse erstellen."
,Wie werden Klassen in SMALLTALK erzeugt?,"In SMALLTALK werden Klassen erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Dies ist notwendig, da Instanzen in SMALLTALK grundsätzlich über Konstruktoren erstellt werden, und jede Klasse ist eine Instanz ihrer Metaklasse."
,"Wie wird das Dilemma, welche Klasse zuerst erstellt werden muss, in SMALLTALK gelöst?","In SMALLTALK wird das Dilemma gelöst, indem eine Klasse in SMALLTALK erzeugt wird, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Diese Nachricht führt zur Erzeugung einer neuen Klasse und gleichzeitig ihrer Metaklasse."
,Wie unterscheiden sich die Weltansichten von Generalisierung/Spezialisierung und Vererbung?,"Generalisierung/Spezialisierung repräsentieren die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze (Client-Schnittstelle). Vererbung hingegen repräsentiert die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung (Vererbungsschnittstelle). Generalisierung/Spezialisierung versuchen, Komplexität durch Strukturierung zu reduzieren, während Vererbung eine Art genetischen Zusammenhang zwischen Klassen darstellt, der deren Entstehung aus Vorhandenem widerspiegelt. Beide Sichten führen nicht automatisch zum selben Ergebnis, und die Kunst des objektorientierten Entwurfs besteht darin, sie in Einklang zu bringen."
,Wie kann die Klasse Bag in SMALLTALK mit Hilfe von Dictionaries implementiert werden?,"Die Klasse Bag kann in SMALLTALK mithilfe von Dictionaries implementiert werden, indem die Anzahl der Vorkommen eines Elements der Bag in einem Dictionary unter dem Element als Schlüssel gespeichert wird. Dabei nutzt die Klasse Bag die Klasse Dictionary, ohne von ihr zu erben, sondern hält sich eine Instanz von Dictionary als Sklavin, die für sie den Dienst verrichtet. Dies wird als Delegation bezeichnet und ist in prototypenbasierten objektorientierten Programmiersprachen beliebt."
,Wie unterscheidet sich Vererbung in prototypenbasierten objektorientierten Programmiersprachen von der Vererbung in klassenbasierten Systemen?,"In klassenbasierten objektorientierten Programmiersprachen ist die Vererbung an Klassen gebunden, während in prototypenbasierten Sprachen die Vererbung vollständig zwischen Objekten definiert ist. In prototypenbasierten Systemen gibt jedes Objekt eines oder mehrere andere an, von denen es Eigenschaften und Verhalten erbt. Es hat die Möglichkeit, geerbte Teile der Definition zu überschreiben und zu löschen."
,"Wie kann in SMALLTALK verhindert werden, dass Instanzen einer abstrakten Klasse erzeugt werden?","In SMALLTALK erfolgt die Erkennung, dass eine abstrakte Klasse instanziiert wurde, zur Laufzeit, wenn versucht wird, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere ""new"" und ""new:"", entsprechend überschreiben. Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von der abstrakten Klasse erben, was oft nicht akzeptabel ist."
,"Wie kann man ein Intervall in Smalltalk definieren, und welche Methode wird verwendet?","Ein Intervall in Smalltalk kann mithilfe der Methode to:by: definiert werden. Zum Beispiel erzeugt 5 to: 1 by: -2 ein Intervall, das die Zahlen 5, 3 und 1 enthält."
,"Wie funktioniert die Verwendung eines Intervalls in einer ""For""-Schleife?","In einer ""For""-Schleife verwendet man ein Intervall, um durch die darin enthaltenen Werte zu iterieren. Zum Beispiel bewirkt der Ausdruck 5 to: 1 by: -2 do: [:i | ""Code hier""], dass dem Laufparameter ""i"" nacheinander die Werte 5, 3 und 1 zugewiesen werden."
,Wie wird die Unterscheidung nach den Parameterobjekten in SMALLTALK durchgeführt?,"In SMALLTALK kann die Unterscheidung nach den Parameterobjekten mithilfe einer Technik namens ""Double Dispatch"" durchgeführt werden. Bei dieser Technik wird im Rumpf einer Methode dieselbe Methode noch einmal aufgerufen, wobei Empfänger (self) und Parameter vertauscht werden. Die Klasse des Empfängers wird im Nachrichtenselektor der neu aufgerufenen Methode kodiert. Dadurch erfolgt die dynamische Bindung zweimal hintereinander, einmal für den Empfänger und einmal für den Parameter, um die richtige Methode basierend auf beiden Objekten auszuwählen."
,"Was können Programmierer tun, um automatisch Zugriffsmethoden für Instanzvariablen in SMALLTALK zu generieren?","Programmierer können in SMALLTALK an der entsprechenden Stelle (z. B. in der Klasse ""Class"" oder ""Behavior"", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden (Accessoren) für ausgewählte Instanzvariablen erweitert. Dies ermöglicht es, Zugriffsmethoden für Instanzvariablen automatisch zu generieren."
,"Was sollten Sie beachten, wenn Sie die Attributwerte von Objekten in einer SortedCollection ändern?","Wenn Sie die Attributwerte von Objekten in einer SortedCollection nachträglich ändern, führt dies nicht automatisch zu einer Änderung der Reihenfolge der Elemente in der SortedCollection. Dies gilt selbst dann, wenn eine Änderung der Reihenfolge erforderlich wäre. Sie müssen sicherstellen, dass die Sortierung erneut durchgeführt wird, um die korrekte Reihenfolge beizubehalten."
,"Was unterscheidet ""shallowCopy"" und ""deepCopy""?","""shallowCopy"" erstellt eine flache Kopie eines Objekts, bei der die in Beziehung stehenden Objekte nicht kopiert werden, während ""deepCopy"" eine tiefe Kopie erstellt, bei der auch die in Beziehung stehenden Objekte kopiert werden."
,"Warum ist die Festlegung, ob Kopien tiefe oder flache Kopien sein sollen, gelegentlich ein Charakteristikum der Klasse selbst?","Die Festlegung, ob Kopien tiefe oder flache Kopien sein sollen, ist gelegentlich ein Charakteristikum der Klasse selbst, da jede Klasse die Methode ""copy"" von ""Object"" erbt und diese Methode standardmäßig ""shallowCopy"" aufruft. Die erbende Klasse kann ""copy"" entsprechend ihren eigenen Konditionen überschreiben und somit die Kopiertiefe von Objektstrukturen selbst bestimmen."
,"Was gibt die Methode ""species"" standardmäßig zurück, und wie kann sie überschrieben werden?","Die Methode ""species"" gibt standardmäßig die Klasse des Empfängerobjekts zurück. Sie kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist nützlich, wenn bei Kopier- oder Konvertieroperationen ein Objekt eines anderen Typs als das ursprüngliche zurückgegeben werden soll."
,"Warum heißt die Klasse ""Class"" und die Klasse ""Metaclass"" in SMALLTALK so?","Die Klasse ""Class"" heißt so, weil jede Instanz dieser Klasse eine Klasse ist. Die Klasse ""Metaclass"" heißt so, weil sie die Metaklassen repräsentiert, die Klassen sind, die die Klassen selbst definieren. Diese Namensgebung spiegelt die Art der Objekte wider, die von diesen Klassen repräsentiert werden."
,Warum hat sich die klassenbasierte Form der objektorientierten Programmierung gegenüber der prototypenbasierten Form durchgesetzt?,"Die klassenbasierte Form der objektorientierten Programmierung hat sich vermutlich aus verschiedenen Gründen durchgesetzt. Zum einen bieten Klassen ein etabliertes Ordnungskonzept, das in anderen Disziplinen wie Mathematik und Biologie verwendet wird, und das sich gut zur Strukturierung von objektorientierten Programmen eignet. Zum anderen eignen sich Klassen als Vorlagen für Typen, was die Integration von objektorientierter Programmierung in typisierte Sprachen ermöglicht. Die prototypenbasierte Form der Objektorientierung bietet hingegen Flexibilität bei der Anpassung von einzelnen Objekten an ihren Zweck und ist besonders nützlich in interaktiven Anwendungen."
,"Gibt es gute Gründe, die prototypenbasierte Form der objektorientierten Programmierung zu nutzen?","Ja, es gibt gute Gründe, die prototypenbasierte Form der objektorientierten Programmierung zu nutzen. Sie erlaubt eine hohe Flexibilität bei der Anpassung von Objekten an ihren jeweiligen Zweck, insbesondere in interaktiven Anwendungen. Ein Beispiel dafür ist die Programmierung von grafischen Benutzeroberflächen, bei der verschiedene Buttons verschiedene Ereignisse auslösen können. JavaScript ist eine erfolgreiche Programmiersprache für interaktive Webseiten und basiert auf dem Prototypenansatz."
,"Was bewirken die Methoden ""basicNew"" und ""basicNew:"" in den Konstruktoren?","Die Methoden ""basicNew"" und ""basicNew:"" sind Instanzmethoden der Klasse, die eine neue Instanz (ein neues Objekt) der Klasse erstellen und zurückgeben. Sie weisen allen Instanzvariablen der erzeugten Objekte den Wert ""nil"" zu. Bevor die Objekte zurückgegeben werden, wird die Methode ""initialize"" auf ihnen aufgerufen, um die Instanzvariablen je nach Klasse anders zu belegen."
,Warum hat die Ein- und Ausgabe über Streams in SMALLTALK eine besondere Bedeutung?,"In SMALLTALK wurde die Ein- und Ausgabe über Streams anders konzipiert als in konventionellen textbasierten Programmen. SMALLTALK ist ein fensterbasiertes, grafisches System, das eine Alternative zur zeilenorientierten Ein- und Ausgabe bieten wollte. Zudem sind in SMALLTALK permanente Datenspeicherung in Dateien nicht notwendig, da alle Objekte im Image dauerhaft gespeichert werden. Daher haben Streams in SMALLTALK eine andere Aufgabe, nämlich den sequentiellen Zugriff auf einzelne Elemente in Collections und den gleichzeitigen Zugriff durch mehrere Objekte auf Collections zu ermöglichen."
,Warum benötigen Klassen in SMALLTALK ihre eigenen Metaklassen?,"Klassen in SMALLTALK benötigen ihre eigenen Metaklassen, damit sie ihre eigenen Instanzvariablen und Methoden definieren können, ohne die Definitionen anderer Klassen zu beeinflussen. Dies ermöglicht eine hohe Flexibilität und erlaubt es den Programmierern, das Verhalten von Klassen individuell anzupassen."
,Warum gibt es eine 1-zu-1-Beziehung zwischen Klassen und ihren Metaklassen in SMALLTALK?,"Die 1-zu-1-Beziehung zwischen Klassen und ihren Metaklassen in SMALLTALK gewährleistet, dass jede Klasse ihre eigenen Instanzvariablen und Methoden definieren kann, ohne andere Klassen zu beeinflussen. Dadurch wird die Flexibilität und Unabhängigkeit der Klassen in SMALLTALK gewährleistet."
,"Warum erhalten Programmierer in SMALLTALK erst zur Laufzeit des Programms eine Fehlermeldung, wenn sie eine Nachricht an eine Instanz einer abstrakten Klasse senden?","In SMALLTALK und ähnlichen objektorientierten Programmiersprachen erhalten Programmierer zur Laufzeit des Programms eine Fehlermeldung, wenn sie eine Nachricht an eine Instanz einer abstrakten Klasse senden, da diese abstrakten Klassen unvollständig sind und daher nicht implementierte Methoden enthalten können. Die Fehlermeldung, die durch die Methode ""doesNotUnderstand:"" (in der Klasse ""Object"") ausgelöst wird, informiert die Programmierer darüber, dass die Methode in einer Subklasse implementiert werden sollte. Dieser Ansatz entspricht dem interaktiven Geist des SMALLTALK-Systems, bei dem das Programmieren als iteratives Zurechtbiegen und Erweitern eines bereits funktionierenden Systems betrachtet wird."
,Was ermöglicht die Sprachregelung in der objektorientierten Programmierung bezüglich der Klassennamen?,"Die Sprachregelung in der objektorientierten Programmierung besagt, dass alle Klassennamen im Singular sind. Dies bedeutet, dass jeder Klassenname einen Singularausdruck verwendet, um die Klasse zu benennen, selbst wenn die Klasse eine Menge von Objekten repräsentiert."
,Was unterscheidet Klassifikation und Generalisierung?,"In der objektorientierten Programmierung entspricht die Klassifikation der ""Ist-ein-Abstraktionsbeziehung"" zwischen Individuen und ihren Klassen, während die Generalisierung eine Form der Abstraktion ist, bei der Allgemeinbegriffe miteinander in Beziehung gesetzt werden. Klassifikation bezieht sich auf die Zuordnung eines Individuums zu einer Klasse, während Generalisierung die Beziehung zwischen verschiedenen Klassen beschreibt, bei der eine Klasse eine Verallgemeinerung (Generalisierung) einer anderen ist."
,Ist die Generalisierung in der objektorientierten Programmierung transitiv?,"Ja, die Generalisierung ist in der objektorientierten Programmierung transitiv. Wenn eine Klasse A eine Generalisierung einer Klasse B ist und Klasse B wiederum eine Generalisierung einer Klasse C ist, ergibt sich logischerweise, dass Klasse A eine Generalisierung von Klasse C ist."
,"Warum ist es möglich, in SMALLTALK mehrere alternative Konstruktoren (Klassenmethoden) für eine Klasse zu definieren?","Es ist möglich, mehrere alternative Konstruktoren für eine Klasse in SMALLTALK zu definieren, da nicht immer alle Instanzen einer Klasse auf die gleiche Weise initialisiert werden müssen. Dies ermöglicht es, verschiedene Initialisierungsmethoden für verschiedene Anwendungsfälle anzubieten."
,"Warum wird in SMALLTALK die Methode ""initialize"" standardmäßig von den Konstruktoren ""new"" und ""new:"" aufgerufen?","In SMALLTALK wird die Methode ""initialize"" standardmäßig von den Konstruktoren ""new"" und ""new:"" aufgerufen, um die Initialisierung der Instanzvariablen vorzunehmen. Dies erlaubt es, alle Initialisierungen in einer zentralen Methode durchzuführen, ohne dass etwas über den Aufbau der Instanzen nach außen verraten wird."
,Warum ist eine Eins-zu-viele-Kommunikation im MVC-Pattern erforderlich?,"Im MVC-Pattern gibt es verschiedene Ansichten auf ein logisches Modell. Wenn Änderungen im Modell potenziell alle Ansichten betreffen, müssen diese Änderungen alle Ansichten darüber informieren. Daher ist eine Eins-zu-viele-Kommunikation erforderlich, um sicherzustellen, dass alle betroffenen Ansichten aktualisiert werden."
,"Warum wurden die Begriffe ""Superklasse"" und ""Subklasse"" in früheren Abschnitten nicht erwähnt?","Die Begriffe ""Superklasse"" und ""Subklasse"" wurden in früheren Abschnitten nicht erwähnt, da sie in verschiedenen Programmiersprachen unterschiedliche Bedeutungen haben können, während die Begriffe ""Generalisierung"", ""Spezialisierung"", ""Vererbung"" und ""abstrakte Klassen"" eher einheitlich interpretiert werden. Diese Begriffe können je nach Programmiersprache und Kontext unterschiedliche Konzepte darstellen, daher wurden sie in diesem Kurs erst später spezifiziert."
,"Was bedeutet es, dass die Subklassenbeziehung transitiv ist?","Die Transitivität der Subklassenbeziehung bedeutet, dass, wenn Klasse A eine Subklasse von Klasse B ist und Klasse B eine Subklasse von Klasse C ist, dann ist Klasse A auch eine Subklasse von Klasse C. Dies bedeutet, dass die Vererbung von Eigenschaften und Verhalten in der Klassenhierarchie entlang der Subklassenbeziehung in einer kaskadierenden Weise erfolgt."
,Was unterscheidet ein direkte Subklasse und ein indirekte Subklasse?,"Eine direkte Subklasse ist eine Klasse, die direkt von einer anderen Klasse erbt, ohne dass eine weitere Klasse dazwischen liegt. Eine indirekte Subklasse ist eine Klasse, die von einer Superklasse erbt, die selbst von einer anderen Klasse erbt. Mit anderen Worten, eine indirekte Subklasse ist eine Subklasse, die von einer Superklasse erbt, die ebenfalls eine Subklasse ist."
,Warum haben abstrakte Klassen und Vererbung die Entwicklung objektorientierter Programmiersprachen geprägt?,"Abstrakte Klassen und Vererbung haben die Entwicklung objektorientierter Programmiersprachen geprägt, weil sie pragmatische Werkzeuge sind, die die Wiederverwendung von Code und die Strukturierung von Software erleichtern. Sie ermöglichen es, gemeinsame Eigenschaften und Methoden in einer Oberklasse zu definieren und von dieser Oberklasse abgeleitete Unterklassen zu erstellen, die diese Eigenschaften und Methoden erben und bei Bedarf überschreiben können."
,Warum sind Generalisierung und Spezialisierung in der objektorientierten Programmierung dennoch relevant?,"Obwohl Generalisierung und Spezialisierung eher theoretisch motivierte Konzepte sind, sind sie dennoch relevant, da sie dazu beitragen, die Struktur und Hierarchie von Klassen in objektorientierten Programmen zu definieren. Sie ermöglichen es, Klassen in Beziehung zueinander zu setzen und abstrakte Modelle für die Softwareentwicklung zu entwickeln. Diese Konzepte können in komplexen Softwareprojekten zur Verbesserung der Wartbarkeit und Erweiterbarkeit beitragen."
,"In welcher Situation ist es sinnvoll, die Methode super in SMALLTALK zu verwenden?","Die Methode super in SMALLTALK wird verwendet, wenn eine überschreibende Methode die überschriebene Methode nicht vollständig ersetzen, sondern nur modifizieren möchte. Dies kann beispielsweise bei Konstruktoren, wie den Klassenmethoden new und new:, der Fall sein, bei denen das grundlegende Verhalten beibehalten werden muss. super ermöglicht es, die überschriebene Methode aufzurufen und sie um zusätzliche Ausdrücke zu ergänzen."
,Warum muss in SMALLTALK das Empfängerobjekt einer Nachricht immer explizit angegeben werden?,"In SMALLTALK muss das Empfängerobjekt einer Nachricht immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. Dies unterscheidet sich von einigen anderen Programmiersprachen wie Java, in denen das Empfängerobjekt manchmal implizit ist. Die Verwendung von self ist notwendig, um das Objekt zu identifizieren, auf dem die Methode ausgeführt wird, und auf dessen Instanzvariablen zugegriffen werden kann."
,Was bezeichnet die Pseudovariable self in SMALLTALK?,"Die Pseudovariable self bezeichnet immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird. Sie ermöglicht den Zugriff auf die Instanzvariablen dieses Objekts."
,Was versteht man unter dynamischem Binden von Methodenaufrufen in SMALLTALK?,"Beim dynamischen Binden von Methodenaufrufen in SMALLTALK hängt die Auswahl der auszuführenden Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt ab. Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zuerst überprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Wenn die Methode gefunden wird, wird sie ausgeführt. Andernfalls wird in der direkten Superklasse der Klasse des Objekts gesucht, und so weiter, bis die Methode gefunden wird oder ein Laufzeitfehler auftritt."
,Warum bleibt das Empfängerobjekt bei der Ausführung einer Methode aus einer Superklasse dasselbe?,"Obwohl bei der Ausführung einer Methode aus einer Superklasse die Methode in einer Superklasse kompiliert wurde, bleibt das Objekt, auf dem sie ausgeführt wird, dasselbe Empfängerobjekt. Dies bedeutet, dass das Objekt immer noch Instanz seiner ursprünglichen Klasse ist. Die Methode betrachtet es jedoch wie ein Objekt der Klasse, in der sie selbst definiert ist. Dies ermöglicht den Zugriff auf die Instanzvariablen, die für die Objekte dieser Klasse zugreifbar sind."
,Was unterscheidet dynamische und statische Typisierung in Bezug auf das dynamische Binden?,"In der dynamischen Bindung, wie sie in SMALLTALK verwendet wird, erfolgt die Auswahl der Methode zur Laufzeit und hängt von der Art des Empfängerobjekts ab. In der statischen Typisierung, wie sie in statisch typgeprüften Sprachen wie Java, C-Sharp und C++ verwendet wird, erfolgt die Typüberprüfung zur Übersetzungszeit und nicht zur Laufzeit. Statisch typisierte Sprachen erfordern in der Regel, dass der Programmierer den Datentyp der Objekte und deren Methoden im Voraus festlegt, während dynamisch typisierte Sprachen mehr Flexibilität bieten, da die Typüberprüfung erst zur Laufzeit erfolgt. Allerdings erhöht die dynamische Bindung das Risiko von Laufzeitfehlern, die in statisch typisierten Sprachen vermieden werden können, indem explizite Typüberprüfungen durchgeführt werden."
,"Warum ist es nicht notwendig, dass jede Metaklasse in SMALLTALK ihre eigene Meta-Metaklasse hat?","Es ist nicht notwendig, dass jede Metaklasse in SMALLTALK ihre eigene Meta-Metaklasse hat, da es in der Praxis ausreicht, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind."
,Was repräsentieren die Klassen der Ebene 1 und was repräsentieren die Metaklassen der Ebene 2?,"Die Klassen der Ebene 1 repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. Die Metaklassen der Ebene 2 definieren die Klassen auf Ebene 1, wobei jede Metaklasse genau eine Instanz auf Ebene 1 hat."
,Warum werden Arrays in SMALLTALK häufig verwendet?,"Arrays werden in SMALLTALK häufig verwendet, insbesondere aufgrund ihrer einfachen literalen Definitionsmöglichkeiten. Sie ermöglichen es, über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung zu iterieren, ohne viel Aufwand betreiben zu müssen."
,Warum ist die Hierarchie in SMALLTALK beschränkt?,"Die Hierarchie in SMALLTALK ist aus praktischen Überlegungen beschränkt und ist in der Sprachdefinition festgelegt. Dies bedeutet, dass die Hierarchie nicht unbegrenzt erweitert oder verändert werden kann, sondern einen festen Rahmen hat."
,Warum ist die Spezialisierung in der objektorientierten Programmierung wichtig?,"Spezialisierung ermöglicht es, bestehende Klassen um spezifische Eigenschaften oder Verhaltensweisen zu erweitern, ohne andere Teile des Programms zu beeinflussen. Dies fördert die Modularität und die Möglichkeit zur Erweiterung von Klassen, was eine der Stärken der objektorientierten Programmierung ist."
,Gibt es Einschränkungen bei der Spezialisierung von Klassen?,"Ja, es gibt Einschränkungen bei der Spezialisierung von Klassen. Das Entfernen von Instanzvariablen oder Methoden ist vollkommen unvereinbar mit der Spezialisierung, da dies die Umkehrung der Spezialisierung, die Generalisierung, verhindern würde. Es ist jedoch möglich, Eigenschaften durch Beschränkungen zu ändern oder hinzuzufügen, aber das Entfernen ist nicht erlaubt."
,Was bedeutet die Subklassenbeziehung in SMALLTALK?,"In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Das bedeutet, dass eine Subklasse alle Instanzvariablen und Methoden ihrer Superklasse erbt. Es ist jedoch wichtig zu beachten, dass die Subklassenbeziehung allein nicht ausdrückt, dass die Subklasse eine Spezialisierung der Superklasse ist oder umgekehrt. Diese Beziehung muss vom Programmierer explizit definiert und dokumentiert werden."
,"Warum gibt es in SMALLTALK mindestens eine Klasse, die keine Subklasse ist?","In SMALLTALK ist die Subklassenbeziehung nicht reflexiv, was bedeutet, dass jede Klasse mindestens eine Superklasse haben muss. Diese oberste Superklasse ist die Klasse ""Object"". In ""Object"" sind Definitionen enthalten, die den Instanzen aller Klassen zugutekommen sollen, und diese Methoden werden per Vererbung auf alle anderen Klassen übertragen."
,Warum kann die Vererbung allein nicht als Indikator für Generalisierung und Spezialisierung dienen?,"Die Vererbung allein kann nicht als Indikator für Generalisierung und Spezialisierung dienen, da sie keinen kausalen Zusammenhang zwischen Klassen herstellt. Nur weil eine Klasse Eigenschaften von einer anderen geerbt hat, bedeutet das nicht zwangsläufig, dass die erbende Klasse eine Spezialisierung der vererbenden ist. Ein klassisches Beispiel dafür wurde bereits mit der Ableitung der Klasse ""Rechteck"" von der Klasse ""Quadrat"" gegeben. Es ist wichtig zu erkennen, dass die Vererbung nicht immer eindeutig auf eine Generalisierung/Spezialisierung hinweist und vorsichtige Analyse und Planung erfordert. In einigen Fällen kann eine zu starke Vererbung sogar zu unerwünschten Ergebnissen führen."
,"Warum kann man nicht einfach ""new"" an die Metaklasse einer Klasse senden, um eine neue Klasse zu erstellen?","Man kann nicht einfach ""new"" oder ähnliches an die Metaklasse einer Klasse senden, da die Metaklasse zu diesem Zeitpunkt noch nicht existiert. Dies führt zu einem Dilemma, da die Frage aufkommt, ob die Klasse zuerst oder die Metaklasse zuerst erstellt werden muss."
,"Was versteht man in der objektorientierten Programmierung unter Vererbung, und welchen Zweck erfüllt sie?","In der objektorientierten Programmierung bezieht sich Vererbung auf die Übertragung der Definition von Eigenschaften und Verhalten von einer Klasse auf eine andere. Der Zweck der Vererbung besteht vor allem darin, Code wiederzuverwenden und die Ökonomie in der Softwareentwicklung zu verbessern."
,"Warum sind Dictionaries in SMALLTALK nützlich, und wann sollte man sie verwenden?","Dictionaries sind in SMALLTALK nützlich, da sie das schnelle Auffinden von Werten unter Schlüsseln ermöglichen. Sie sollten verwendet werden, wenn Sie auf die Elemente einer Menge von Objekten über Schlüssel zugreifen möchten. Dictionaries erlauben es, Assoziationsketten direkt in einem Programm nachzubilden und sind besonders geeignet, wenn die Zuordnung von Schlüsseln zu Werten benötigt wird."
,Warum könnte die prototypenbasierte Vererbung auf den ersten Blick als natürlicher angesehen werden?,"Auf den ersten Blick könnte die prototypenbasierte Vererbung als natürlicher angesehen werden, da sie dem Prinzip der biologischen Vererbung ähnelt, bei dem Merkmale von Individuum zu Individuum weitergegeben werden. In der Natur gibt es keine festen biologischen Klassen wie in klassenbasierten Systemen, und Arten können sich ständig verändern und anpassen."
,"Warum wird die Vererbung oft auf Klassen in der objektorientierten Programmierung übertragen, obwohl sie in prototypenbasierten Sprachen zwischen Objekten definiert ist?","Programmierer entwerfen normalerweise Klassen, nicht einzelne Objekte. Klassen sind die grundlegende Entität in der klassenbasierten objektorientierten Programmierung, und Klassendefinitionen ändern sich im Laufe der Zeit. Klassen bieten auch eine bessere Abdeckung für Anwendungsdomänen, die aus vielen gleichen Objekten bestehen. Daher wird die Vererbung oft auf Klassen übertragen, da sie besser zur strukturierten Programmierung passt und das Verfolgen und Debuggen von Programmen erleichtert."
,Warum könnte die Vererbung zwischen Instanzen in der objektorientierten Programmierung das Verfolgen und Debuggen von Programmen erschweren?,"Die Vererbung zwischen Instanzen kann das Verfolgen und Debuggen von Programmen erschweren, da sie die Beziehungen zwischen Objekten komplexer gestaltet. Wenn Objekte Eigenschaften und Verhalten von anderen Objekten erben können und diese Eigenschaften überschreiben oder löschen können, kann dies zu unvorhersehbarem Verhalten führen und die Fehlersuche erschweren."
,Was unterscheidet Extension und Intension?,"Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören. Die Intension ist die Summe der Merkmale oder Eigenschaften, die den Begriff ausmachen und die Objekte charakterisieren, die zu dieser Klasse gehören. Mit steigender Intension wird die Extension kleiner, und umgekehrt."
,Was machen Allgemeinbegriffe und Klassen in der objektorientierten Programmierung?,Allgemeinbegriffe oder Klassen vereinfachen die Strukturierung von Objekten und die Beschreibung von Eigenschaften und Verhalten in der objektorientierten Programmierung.
,Warum sind abstrakte Klassen in der objektorientierten Programmierung nicht instanziierbar?,"Abstrakte Klassen sind in der Regel nicht instanziierbar, weil ihnen oft die notwendigen Informationen fehlen, um Instanzen vollständig zu initialisieren. Sie dienen als Vorlagen für Subklassen, die die fehlenden Details ergänzen."
,"Warum könnte das Weglassen einer Methode wie ""add:"" in einer abstrakten Klasse in SMALLTALK weniger aufschlussreich für Programmierer sein?","Das Weglassen einer Methode wie ""add:"" in einer abstrakten Klasse in SMALLTALK könnte weniger aufschlussreich sein, da die Fehlermeldung, die bei einem Aufruf dieser Methode auftritt, nicht zwischen einem falschen Methodennamen und dem Vergessen der Implementierung in einer Subklasse unterscheiden könnte. Das Bereitstellen einer Methode wie ""add:"" in der abstrakten Klasse, die auf ein Versäumnis hinweist, ist sinnvoll, um Programmierer auf das Problem aufmerksam zu machen."
,Wozu dienen Intervalle hauptsächlich in Smalltalk?,"Intervalle in Smalltalk dienen hauptsächlich dem Zweck, sogenannte ""For""-Schleifen zu emulieren, wie sie im Abschnitt 4.6.3 in Kurseinheit 1 beschrieben sind."
,"Gibt es eine Methode in der Klasse ""Number,"" die die Verwendung von Intervallen noch komfortabler macht?","Ja, in der Klasse ""Number"" gibt es die Methode ""to:by:"", die ein entsprechendes Intervall zurückliefert. Dadurch kann man eine ""For""-Schleife in einer kompakteren Form schreiben, z. B. 5 to: 1 by: -2."
,Wo ist der Iterator für Intervalle definiert?,"Der Iterator für Intervalle ist in der Klasse ""Number"" definiert und nicht in einer Collection-Klasse wie ""Interval."""
,"In welcher Klasse ist das Protokoll definiert, das allen Objekten gemeinsam ist, und warum ist es wichtig?","Das Protokoll, das allen Objekten gemeinsam ist, ist in der Klasse ""Object"" definiert. Es ist wichtig, weil es Methodendefinitionen enthält, die von allen Klassen entweder geerbt oder in den meisten Fällen direkt übernommen werden können. Diese Methoden sind grundlegende Funktionen, die für alle Objekte verfügbar sind und von den meisten Objekten nicht überschrieben werden müssen."
,"Warum ist es manchmal notwendig, auch die tatsächlichen Parameter bei der Methodenauswahl zu berücksichtigen?","In bestimmten Situationen hängt die Auswahl einer geeigneten Methode nicht nur vom Empfängerobjekt ab, sondern auch von den tatsächlichen Parametern, die an die Methode übergeben werden. Dies ist beispielsweise bei arithmetischen Operationen wie Addition, Subtraktion, Multiplikation und Division der Fall, bei denen die Implementierung der Operation von der Art der Operanden abhängt (z. B. Ganzzahlen oder Gleitkommazahlen). Es ist notwendig, die Unterscheidung nach den Parameterobjekten vorzunehmen, um die richtige Methode auszuwählen."
,"Wer hat die Technik des ""Double Dispatch"" erstmals beschrieben und in welchen Programmiersprachen wird sie verwendet?","Die Technik des ""Double Dispatch"" wurde von Dan Ingalls am Beispiel von SMALLTALK erstmals beschrieben. Diese Technik wird auch in anderen Programmiersprachen mit ""Single Dispatch"" (wie Java und C-Sharp) verbreitet angewendet. Es ist jedoch zu beachten, dass in Sprachen, in denen die Parametertypen von Haus aus bei der (dynamischen) Methodenauswahl berücksichtigt werden (sog. ""Multi Dispatch""-Sprachen), Double Dispatch nicht benötigt wird."
,"Warum könnte die Einführung von indizierten Instanzvariablen den Anschein erwecken, dass sie speziell für Zu-n-Beziehungen eingeführt wurden?","Indizierten Instanzvariablen könnten den Anschein erwecken, speziell für Zu-n-Beziehungen eingeführt worden zu sein, da sie es ermöglichen, Elemente in Beziehung zu setzen, selbst wenn sie nur indirekt über Zwischenobjekte erreicht werden. Dies erleichtert die Arbeit mit Zu-n-Beziehungen."
,"Warum ist es besonders attraktiv, eigene Kontrollstrukturen für Zu-n-Beziehungen in SMALLTALK zu spezifizieren?","Es ist besonders attraktiv, eigene Kontrollstrukturen für Zu-n-Beziehungen in SMALLTALK zu spezifizieren, weil es die Möglichkeit bietet, maßgeschneiderte und auf die spezifische Art der Beziehung zugeschnittene Kontrollstrukturen zu erstellen. Dies ermöglicht eine flexible und effiziente Programmierung für unterschiedliche Arten von Beziehungen."
,Was ermöglicht die Verwendung eigener Arten von Beziehungen in SMALLTALK?,"Die Verwendung eigener Arten von Beziehungen in SMALLTALK ermöglicht es, spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren, um die Programmierung für diese Beziehungen effizienter zu gestalten."
,Welches Problem möchte man mit dem beschränkten parametrischen Polymorphismus lösen?,"Mit dem beschränkten parametrischen Polymorphismus möchte man sicherstellen, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist und nur bestimmte, benötigte Protokolle für die als Werte zulässigen Typen erlaubt."
,Welche Möglichkeit zur Beschränkung des Wertebereichs von Typvariablen wird in der Praxis nicht genutzt?,"Die Einführung von Metatypen, deren Wertebereiche Typen mit von den Metatypen vorgegebenen Eigenschaften sind, wird in der Praxis nicht genutzt."
,Welche Implikation hat die Definition von Subtypen in Bezug auf die Zuweisungskompatibilität?,"Die Definition von Subtypen impliziert Zuweisungskompatibilität. Wenn die Objekte eines Subtyps überall dort verwendet werden können, wo Objekte seines Supertyps erwartet werden, dann können sie auch Werte für Variablen des Supertyps sein. Dies bedeutet, dass ein Subtyp per Definition zuweisungskompatibel mit seinem Supertyp ist."
,"Was ist Typeinschränkung, und wie unterscheidet sie sich von Typerweiterung?","Typeinschränkung ist eine Möglichkeit, auf der Basis eines bereits bestehenden Typs einen neuen, verwandten Typen zu erzeugen. Sie besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere Typen zu ersetzen. Im Gegensatz dazu erweitert Typerweiterung den vorhandenen Typ um zusätzliche Eigenschaften oder Methoden. Typeinschränkung ist also die Umkehrung der Typerweiterung in Bezug auf die Typdefinition."
,Welche Formen der Typeinschränkung gibt es?,"Eine Form der Typeinschränkung besteht darin, einen Typ auf Basis eines anderen Typs zu definieren, indem man Eigenschaften (Methoden) entfernt. Diese Form führt jedoch nicht zur Zuweisungskompatibilität und wird in vielen Sprachen nicht unterstützt. Eine interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere Typen zu ersetzen, ohne Eigenschaften zu löschen."
,Welchen Zweck dienen Collections in der Programmierung?,"Collections dienen u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen."
,Welchen Typ repräsentieren die mit Collection-Klassen assoziierten Typen?,Die mit Collection-Klassen assoziierten Typen repräsentieren die Typen für die Zwischenobjekte in den Collections.
,Was ist ein Beispiel für eine parametrische Definition einer Collection?,"Ein Beispiel für eine parametrische Definition einer Collection ist Dictionary, bei dem nicht nur der Elementtyp, sondern auch der Schlüsseltyp variabel gehalten werden sollte."
,"Was ist die inhaltliche Funktion, die Typen neben ihrer formalen Rolle erfüllen können, und wie wird sie in der Programmierung hergestellt?","Typen können in der Programmierung neben ihrer formalen Rolle, Fehler zu vermeiden, auch eine inhaltliche Funktion erfüllen. Diese inhaltliche Funktion wird vor allem durch die Benennung des Typs hergestellt, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität. Sie verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können."
,"Welche Bedeutung hat die Filterfunktion, die durch die Namensäquivalenz verlangt wird?","Die Filterfunktion, die durch die Namensäquivalenz verlangt wird, drückt die Absicht der Programmiererin aus, Werte nur gleicher Bedeutung zuzuweisen. Sie ermöglicht es, Fehler in einem Programm auf einfache Weise zu erkennen und zu vermeiden."
,"Welches Prinzip in der Physik ähnelt der Typprüfung per Namensäquivalenz, und wie wird es angewendet?","Ein ähnliches Prinzip wie die Typprüfung per Namensäquivalenz wird in der Physik angewendet. Bei physikalischen Berechnungen prüfen Physikerinnen nicht nur die Beträge der physikalischen Größen, sondern auch deren Einheiten. Wenn die Einheiten nicht korrekt behandelt werden und das Ergebnis etwas anderes als erwartet ergibt, liegt ein Fehler im Rechenvorgang vor."
,Welchen Nachteil hat die Namensäquivalenz in Bezug auf die Interoperabilität von getrennt voneinander entwickelten Programmen?,"Die Namensäquivalenz setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen dieselben Typen verwenden. Dies kann ein Hindernis für die Interoperabilität von solchen Programmen, wie zum Beispiel Web Services, darstellen."
,Was sind die Unterschiede zwischen struktureller Typäquivalenz und Namensäquivalenz in Bezug auf Flexibilität und Semantik?,"Strukturelle Typäquivalenz bietet mehr Flexibilität als Namensäquivalenz, da sie die Äquivalenz von Typen erlaubt, deren Definition voneinander unabhängig ist. Allerdings können zufällige strukturelle Übereinstimmungen zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Um diesen Nachteil zu vermeiden, kann optional eine Namensäquivalenz durch Type branding eingeführt werden."
,Welche Rolle spielen Zugriffsmodifikatoren in Programmiersprachen wie Java und C++ bei der Festlegung der Schnittstelle einer Klasse?,"Zugriffsmodifikatoren legen fest, welche Elemente einer Klassendefinition für Benutzer sichtbar sind und somit die Schnittstelle der Klasse beeinflussen. Sie regeln die Zugriffsberechtigungen auf Methoden und Instanzvariablen."
,Welche Konsequenz ergibt sich daraus für die Beziehung von Subklassen und Subtypen?,"Die Konsequenz daraus ist, dass die Beziehung von Subklassen und Subtypen in den meisten objektorientierten Programmiersprachen auf eine parallele Subtypenbeziehung übertragen werden kann. Das bedeutet, dass eine Instanz einer Subklasse auch als Instanz des zur Superklasse gehörenden Typs betrachtet werden kann, sofern die Subklassenbeziehung die Typkonformität nicht aufhebt."
,"Welches Problem wird in diesem Abschnitt ""Grenzen der Typisierung"" angesprochen?","In diesem Abschnitt wird das Problem der praktischen Grenzen der Typisierung diskutiert, insbesondere im Kontext von Typfehlern und der Einschränkung bei der Überprüfung von Zuweisungen."
,Was ist nominales Subtyping?,"Nominales Subtyping bedeutet, dass ein Subtyp explizit aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. In diesem Fall ist die Namensähnlichkeit entscheidend."
,Was ist strukturelles Subtyping?,"Strukturelles Subtyping liegt vor, wenn ein Typ die allgemeine Definition eines Subtyps erfüllt, unabhängig von seiner expliziten Nennung als Supertyp. Hier ist die Struktur und das Verhalten des Typs entscheidend, nicht seine explizite Nennung als Supertyp."
,Welches der beiden Subtyping-Modelle impliziert das andere?,"Nominales Subtyping impliziert strukturelles Subtyping. Das bedeutet, wenn ein Subtyp nominal als Supertyp erwähnt wird, erfüllt er automatisch auch die strukturellen Kriterien eines Subtyps."
,Was sind die Auswirkungen von nominalem und strukturellem Subtyping auf die Subtypenbeziehung?,"Nominales Subtyping macht die Subtypenbeziehung antisymmetrisch, während strukturelles Subtyping dies nicht tut. Das bedeutet, dass im Fall des nominalen Subtypings ein Subtyp nicht gleichzeitig Subtyp seines Supertyps sein kann, während dies im strukturellen Subtyping möglich ist."
,Welche Bedeutung hat die Typkonformität in Bezug auf die Zuweisungskompatibilität?,"Typkonformität ist in vielen Sprachen eine notwendige Voraussetzung für die Zuweisungskompatibilität. Das bedeutet, dass ein Objekt eines typkonformen Typs einer Variable eines anderen, typgleichen Typs zugewiesen werden darf."
,"Welche beiden Varianten der Typkonformität gibt es, und wie unterscheiden sie sich?",Es gibt strukturelle Typkonformität und nominale Typkonformität. Bei struktureller Typkonformität müssen alle Elemente des konformen Typs im konformen Typ enthalten sein. Bei nominaler Typkonformität muss zusätzlich die Erweiterung eines anderen Typs explizit angegeben werden.
,Welche Vorteile bietet nominale Typkonformität gegenüber struktureller Typkonformität?,"Nominale Typkonformität bietet die Vorteile der Zuweisungskompatibilität und Abwesenheit von Typfehlern. Sie dient auch als Filterfunktion, da nur Objekte von solchen Typen Variablen zugewiesen werden können, für die die Programmiererin dies aus semantischen Überlegungen heraus ausdrücklich vorgesehen hat."
,"Was ist Typäquivalenz, und wie wird sie in Bezug auf die Zuweisungskompatibilität von Typen verwendet?","Typäquivalenz ist eine Eigenschaft, die die Zuweisungskompatibilität von Typen beschreibt. Sie bezieht sich darauf, ob Typen in bestimmten Aspekten gleich oder äquivalent sind, ohne unbedingt identisch zu sein."
,"Welche Arten von Typäquivalenz gibt es, und wie unterscheiden sie sich?","Es gibt zwei Arten von Typäquivalenz: die nominale (Namensäquivalenz) und die strukturelle (Strukturäquivalenz) Typäquivalenz. Die nominale Typäquivalenz erfordert, dass zwei Deklarationen denselben Typnamen angeben, um Zuweisungskompatibilität zu haben. Die strukturelle Typäquivalenz hingegen erfordert nur, dass die Typen paarweise gleich definiert sind, unabhängig von ihren Namen."
,Welche weiteren Eigenschaften gelten für die Typäquivalenz?,"Die Typäquivalenz ist reflexiv, was bedeutet, dass jeder Typ zu sich selbst äquivalent ist. Sie ist auch transitiv, was bedeutet, dass wenn A äquivalent zu B ist und B äquivalent zu C ist, dann ist auch A äquivalent zu C."
,Was sind mögliche Nachteile der Strukturäquivalenz?,"Bei Verwendung der Strukturäquivalenz können Typen, die inhaltlich nichts miteinander zu tun haben, fälschlicherweise als äquivalent betrachtet werden. Dies kann dazu führen, dass Objekte, die eigentlich unterschiedlichen Typen angehören, fälschlicherweise zugewiesen werden können, was zu semantischen Fehlern führen kann. Dieses Problem kann durch die Technik des ""Type Branding"" gelöst werden, bei der jedem Typ eine charakteristische Methode exklusiv zugeordnet wird, um die Strukturäquivalenz einzuschränken."
,"Welche Anforderungen müssen erfüllt sein, um Typfehler bei Zuweisungen zu vermeiden?","Um Typfehler bei Zuweisungen zu vermeiden, ist es ausreichend, dass der Typ auf der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs auf der linken Seite enthält."
,"Was ist Typerweiterung, und in welchen Programmiersprachen wird sie verwendet?","Typerweiterung (englisch: type extension) erlaubt, dass der Typ auf der rechten Seite einer Zuweisung eine Erweiterung des Typs auf der linken Seite um zusätzliche Methoden ist. Sie wird in Programmiersprachen wie MODULA-3 und OBERON verwendet."
,"Was sind Bezeichner in der Programmierung, und wie werden sie verwendet?","Bezeichner sind Namen, die in der Programmierung frei vergeben werden können. Sie werden verwendet, um Programmelemente zu identifizieren und auf sie zu verweisen, beispielsweise Variablen oder Methoden."
,Was ist der Zweck der Deklaration von Programmelementen?,"Die Deklaration von Programmelementen dient dazu, dem Compiler den Bezeichner bekanntzugeben, damit er ihn in der Folge wiedererkennen und mit der entsprechenden Definition in Verbindung bringen kann."
,"Welche Probleme können in untypisierten Sprachen auftreten, wenn Variablen ohne Angabe eines Typs deklariert werden?","In untypisierten Sprachen, in denen Variablen ohne Angabe eines Typs deklariert werden, kann es zu Problemen führen, da Variablen quasi implizit deklariert werden, wenn sie zum ersten Mal verwendet werden. Dies kann zu Schreibfehlern führen, bei denen versehentlich zwei Variablen mit dem gleichen Namen erstellt werden, die jedoch nichts miteinander zu tun haben. Dies erhöht das Risiko von Programmierfehlern."
,"Welche Rolle spielen Klassen in der Programmierung, und wie unterscheiden sie sich von Typen?","Klassen dienen der Angabe von Implementierungen und fungieren als Container für ausführbaren Code. Sie sind strukturell ähnlich wie Typen, haben jedoch unterschiedliche Verwendungszwecke."
,"Welche Funktion erfüllen Typen in der Programmierung, und wie unterscheiden sie sich von Klassen?","Typen dienen der Formulierung von Invarianten, die für Variablenzuweisungen gelten müssen und bei deren Verletzung auf Programmfehler hinweisen. Sie sind strukturell ähnlich wie Klassen, haben jedoch eine andere Rolle zur Laufzeit des Programms."
,"Welche Rolle spielt Typinformation zur Laufzeit eines Programms, und wie unterscheidet sie sich von Klasseninformation?","Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante durch einen dynamischen Typtest abbricht. Klasseninformation hingegen bildet die Grundlage des dynamischen Bindens und kann in einem Programm als Eigenschaft von Objekten abgefragt werden."
,Was ist Inklusionspolymorphie?,"Inklusionspolymorphie, auch als Subtyp-Polymorphie bezeichnet, bedeutet, dass Objekte eines bestimmten Typs an Stellen erwartet werden können, an denen Objekte anderer Typen verwendet werden können, wenn der erste Typ die anderen Typen einschließt oder subsumiert."
,Welche Probleme gibt es in Bezug auf die Definition von Subtyping und Inklusionspolymorphie in der objektorientierten Programmierung?,"Die Definition von Subtyping und Inklusionspolymorphie in der objektorientierten Programmierung ist unklar, insbesondere in Bezug darauf, was erforderlich ist, damit ein Objekt eines Typs tatsächlich an Stellen verwendet werden kann, an denen ein Objekt eines anderen Typs erwartet wird. Die Regeln von Ko- und Kontravarianz geben zwar klare Bedingungen vor, sind aber in der Praxis umstritten und reichen nicht immer aus, um Ersetzbarkeit sicherzustellen. Dies führt zu Unsicherheiten in der Definition des Subtypenbegriffs."
,"Was ist die Zuweisungskompatibilität, und warum ist sie wichtig?","Die Zuweisungskompatibilität ist wichtig, um festzustellen, ob Zuweisungen zwischen Variablen oder Ausdrücken zulässig sind, ohne die Typinvariante zu verletzen. Sie stellt sicher, dass die Typen der beteiligten Objekte oder Ausdrücke kompatibel sind, um Typfehler zu vermeiden."
,Was ist eine Typumwandlung?,"Eine Typumwandlung (type cast) ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen Typ konvertiert wird. Dies geschieht, um dem Compiler oder Type Checker mitzuteilen, dass der Ausdruck den angegebenen Typ hat, auch wenn dies nicht automatisch sichergestellt ist."
,Welche Richtungen von Typumwandlungen gibt es?,"Typumwandlungen können in verschiedene Richtungen erfolgen: zu Supertypen (Upcast), zu Subtypen (Downcast) oder zu Typen, die weder Supertyp noch Subtyp des Ausgangstyps sind (Crosscast)."
,"Was ist der Zweck abstrakter Klassen, und warum enthalten sie normalerweise zumindest eine partielle Implementierung?","Abstrakte Klassen können ausschließlich aus Methodendeklarationen bestehen und dienen dazu, eine gemeinsame partielle Implementierung für andere Klassen, einschließlich ihrer Subklassen, vorzugeben."
,Was ist das Kovarianzproblem im Zusammenhang mit parametrischem Polymorphismus?,"Das Kovarianzproblem im Zusammenhang mit parametrischem Polymorphismus bezieht sich darauf, wie Eingabeparameter in Methoden kovariant, also flexibel, in Bezug auf ihren Typ angepasst werden können."
,Was sind Typvariablen in parametrischen Typdefinitionen?,"Typvariablen sind Platzhalter in parametrischen Typdefinitionen, die implizit auf Typen beschränkt sind und erst bei der Verwendung eines parametrisierten Typs mit einem konkreten Typ belegt werden."
,Was ist die Idee des parametrischen Polymorphismus?,"Die Idee des parametrischen Polymorphismus besteht darin, aus einer Typdefinition durch Parametrisierung viele verschiedene Typen zu generieren, je nachdem, welche konkreten Typen als Typparameter verwendet werden."
,"Was sind Typen, die sich ausschließlich auf sich selbst beziehen, und wie erhalten sie Bedeutung?","Typen, die sich ausschließlich auf sich selbst beziehen, sind solche, deren Bedeutung nicht von anderen Typen abhängt. Ein Beispiel dafür ist der Typ ""Boolean"". Sie können Bedeutung erhalten, indem sie auf bekannte externe Formalismen abgebildet werden, wie die boolesche Algebra."
,Was ist eine denotationale Semantik in Bezug auf die Bedeutung von Typen?,"Eine denotationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf bekannte externe Formalismen abgebildet werden. Dies kann beispielsweise bedeuten, dass die Operationen eines Typs auf mathematische oder logische Konzepte abgebildet werden, die in der Programmierung verwendet werden."
,Was ist eine operationale Semantik in Bezug auf die Bedeutung von Typen?,"Eine operationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf Anweisungen einer (gedachten oder realen) Maschine abgebildet werden. Dies bedeutet, dass die Operationen eines Typs auf die Ausführung von Maschinenbefehlen oder anderen niedrigstufigen Operationen abgebildet werden."
,Was sind die Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs?,"Es gibt mindestens zwei wichtige Unterschiede: Abstrakte Datentypen sind nicht objektorientiert, während STRONGTALK-Typen objektorientiert sind und Objekte Zustand haben können. Abstrakte Datentypen haben Funktionen mit einem Argument mehr, das dem Typ des Datentyps selbst entspricht. In objektorientierten Sprachen entspricht dies dem Nachrichtenempfänger, dem impliziten Parameter ""self""."
,Was ist der Zweck eines Typsystems in der objektorientierten Programmierung?,"Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Es sorgt dafür, dass Programmelemente bei ihrer Deklaration Typen zugewiesen bekommen, die die Menge der zulässigen Objekte und die erlaubten Operationen auf diesen Objekten einschränken."
,Welche Unterschiede gibt es zwischen SMALLTALK und den meisten anderen objektorientierten Programmiersprachen in Bezug auf die Typisierung?,"Im Gegensatz zu SMALLTALK sind die meisten anderen objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration Typen zugeordnet werden. In SMALLTALK wird die Typisierung in der Regel erst zur Laufzeit überprüft, während in anderen Sprachen dies bereits zur Übersetzungszeit geschieht."
,"Was sind rekursive Typen, und warum sind sie wichtig?","Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren, und sie sind wichtig, um dynamische Strukturen wie verschachtelte Listen oder Bäume in der Programmierung zu ermöglichen."
,Welches Problem ergibt sich bei der strukturellen Äquivalenz von rekursiven Typen?,"Das Problem bei der strukturellen Äquivalenz von rekursiven Typen besteht darin, dass die Expansion rekursiver Typen unendlich große Definitionen ergeben kann, was die Feststellung der strukturellen Äquivalenz erschwert."
,Was ist Kovarianz und Kontravarianz bei Methodenaufrufen im Zusammenhang mit Subtyping?,"Bei Methodenaufrufen und Subtyping unterscheidet man zwischen Kovarianz und Kontravarianz. Kovarianz bezieht sich auf die Veränderung von Rückgabetypen, während Kontravarianz die Veränderung von Parametertypen beschreibt."
,Was ist Kovarianz?,"Kovarianz tritt auf, wenn der Rückgabetyp einer Methode in einem Subtyp ein Subtyp des Rückgabetyps in einem Supertyp ist. Dies bedeutet, dass der Subtyp mehr Werte zurückgeben kann als der Supertyp."
,Was ist Kontravarianz?,"Kontravarianz tritt auf, wenn die Parametertypen einer Methode in einem Subtyp Supertypen der Parametertypen in einem Supertyp sind. Dies bedeutet, dass der Subtyp Eingabeparameter akzeptiert, die allgemeiner sind als die des Supertyps."
,Welcher konkrete Typ tritt an die Stelle der Typvariable E bei der Verwendung von Inklusionspolymorphie?,"Bei der Verwendung von Inklusionspolymorphie tritt der konkrete Typ ""Object"" an die Stelle der Typvariable E."
,"Welche Art von Typfehler kann auftreten, wenn Inklusionspolymorphie verwendet wird?","Ein Typfehler kann auftreten, wenn Methoden auf Objekten eines konkreten Subtyps von ""Object"" aufgerufen werden, da die statische Typprüfung solche Methoden nicht unterstützt."
,Welchen Vorteil bietet der parametrische Polymorphismus gegenüber der Inklusionspolymorphie?,"Der parametrische Polymorphismus bietet den Vorteil einer erhöhten Typsicherheit, da Typfehler bereits zur Instanziierung des parametrischen Typs erkannt werden können."
,Welchen Kompromiss geht man bei der Verwendung parametrischer Typen ein?,"Bei der Verwendung parametrischer Typen geht man einen Kompromiss ein, bei dem die erhöhte Typsicherheit außerhalb der Typdefinition durch eine geringere Typsicherheit innerhalb der Typdefinition erkauft wird."
,"Welche Eigenschaften müssen die Typen haben, die für die Typvariable E eingesetzt werden können, um die Sicherheit zu gewährleisten?","Die Typen, die für die Typvariable E eingesetzt werden können, müssen bestimmte Eigenschaften haben, wie z.B. Sortierbarkeit und Addierbarkeit, um die Sicherheit zu gewährleisten."
,Welche Art von Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen?,"Der beschränkte parametrische Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen, um Typfehler frühzeitig zu erkennen."
,"Was ist ein Typ in der Programmierung, und wie ist er definiert?","Ein Typ in der Programmierung schränkt die möglichen Werte eines deklarierten Elements (z. B. einer Variable) ein. Ein Typ hat eine Intension (Definition) und eine Extension (Wertebereich), wobei er eine Menge von Elementen (Objekten) umfasst, die zu diesem Typ gehören. Typen sind die Grundlage von Typsystemen."
,"Welche Gründe gibt es, Variablen und andere Programmelemente zu typisieren?",Es gibt mindestens vier gute Gründe für die Typisierung von Variablen und anderen Programmelementen: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm.
,Welche Phase des Entwicklungszyklus verwendet die Typisierung in der Softwareentwicklung?,"Die Typisierung wird in verschiedenen Phasen des Entwicklungszyklus verwendet: In der Entwurfsphase hilft sie bei der Strukturspezifikation. In der Implementierungsphase stellt sie sicher, dass Variablen und Funktionen korrekt verwendet werden. In der Testphase ermöglicht sie gezielte Tests, um die Einhaltung von Datentypen und Schnittstellen zu prüfen. In der Wartungsphase trägt sie zur sicheren Durchführung von Änderungen bei. Bei der Dokumentation hilft sie anderen Entwicklern, den Code zu verstehen und zu verwenden."
,Wie instanziiert man den Typ A mit einem konkreten Typparameter?,"Um den Typ A zu instanziiert, verwendet man eckige Klammern, um den tatsächlichen Typparameter anzugeben. Zum Beispiel: a := A[Integer] new."
,Wie ist die Beziehung zwischen Typäquivalenz und Typkonformität auf der einen Seite und den Wertebereichen (Extensionen) von Typen auf der anderen Seite?,"Damit Typkorrektheit erhalten bleibt, müssen die Wertebereiche von Typen in Bezug auf Zuweisungen miteinander in Beziehung stehen. Wenn ein Objekt eines Typs einem Objekt eines anderen Typs zugewiesen werden soll, muss die Extension des zweiten Typs eine Teilmenge der Extension des ersten Typs sein."
,Wie kann die Einschränkung von Ein- oder Rückgabetypen von Methoden die Zuweisungskompatibilität beeinflussen?,"Die Einschränkung von Ein- oder Rückgabetypen von Methoden kann die Zuweisungskompatibilität beeinflussen, indem sie sicherstellt, dass die Extension des eingeschränkten Typs eine Teilmenge der Extension des einschränkenden Typs ist. Dies kann dazu beitragen, die Typkorrektheit von Zuweisungen zu gewährleisten."
,Wie gewährleistet die Verwendung von Typen die Wahrung des Geheimnisprinzips und die Einhaltung von Schnittstellen in der objektorientierten Programmierung?,"Die Verwendung von Typen stellt sicher, dass über Variablen nur auf die Elemente einer Klasse zugegriffen wird, die Teil der Schnittstelle sind. Dadurch wird das Geheimnisprinzip gewahrt, und die Einhaltung von Schnittstellen wird durch den Compiler sichergestellt."
,"Wie verhält sich die Typkonformität in Bezug auf Reflexivität, Transitivität und Symmetrie?","Typkonformität ist reflexiv, da jeder Typ konform zu sich selbst ist. Sie ist transitiv, sodass wenn Typ A konform zu Typ B ist und Typ B konform zu Typ C ist, dann ist auch Typ A konform zu Typ C. Im Gegensatz zur Typäquivalenz ist Typkonformität nicht symmetrisch. Es gilt jedoch meistens die Antisymmetrie, was bedeutet, dass wenn Typ B zu Typ A und Typ A zu Typ B konform ist, dann müssen A und B identisch sein."
,Wann sind zwei Typen zuweisungskompatibel?,"Zwei Typen sind zuweisungskompatibel, wenn sie identisch sind oder eine bestimmte Form der Typäquivalenz aufweisen."
,Wie verhält sich die Typäquivalenz in Bezug auf Symmetrie?,"Typäquivalenz ist eine symmetrische Eigenschaft, was bedeutet, dass wenn Typ A äquivalent zu Typ B ist, dann ist auch Typ B äquivalent zu Typ A."
,Wie wird die Strukturäquivalenz bei der Feststellung von Typäquivalenz verwendet?,"Bei der Feststellung von Strukturäquivalenz werden die Definitionen der beteiligten Typen rekursiv expandiert, wobei Namen anderer Typen durch ihre Struktur ersetzt werden. Diese Strukturäquivalenz ermöglicht es, Typen zu vergleichen, indem ihre Strukturen miteinander verglichen werden."
,Wie wird Typerweiterung in Bezug auf bereits existierende Typen definiert?,"Typerweiterung definiert einen neuen Typ relativ zu einem bereits bestehenden, dem erweiterten Typ. Die Methodendeklarationen des erweiterten Typs werden an den erweiternden Typ vererbt, sodass sie nicht erneut deklariert werden müssen."
,Wie äußert sich die Verwendung eines Programmelements in einem Programmtext?,"Die Verwendung eines Programmelements zeigt sich darin, dass sein Name (Bezeichner) im Programmtext angeführt oder referenziert wird. An dieser Stelle kann eine Variable für ihren aktuellen Wert oder eine Methode für ihren Aufruf stehen."
,"Wie können Typen und Klassen in einem Sprachkonstrukt zusammengefasst werden, obwohl sie unterschiedliche Zwecke haben?","Obwohl Typen und Klassen unterschiedliche Zwecke haben, teilen sie sich strukturelle Ähnlichkeiten, die es ermöglichen, ihre Definition in einem Sprachkonstrukt zu kombinieren. Dies erleichtert die Verwendung beider Konzepte in einer Programmiersprache."
,Wie steht Inklusionspolymorphie in Beziehung zum Subtyping?,"Inklusionspolymorphie und Subtyping sind im Wesentlichen dasselbe Konzept. Beide Begriffe beschreiben, wie Objekte eines Subtyps anstelle ihres Supertyps verwendet werden können."
,Wie werden Typfehler in STRONGTALK vermieden?,"In STRONGTALK werden Typfehler vermieden, indem Variablen mit einem Protokoll als Typ typisiert werden. Wenn das Programm typkorrekt ist, bedeutet dies, dass jede Methode im Protokoll, die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist."
,Wie werden formale Parameter in STRONGTALK typisiert?,Formale Parameter in STRONGTALK werden durch Typannotationen in spitzen Klammern hinter den Parametern typisiert.
,Wie kennzeichnet man in STRONGTALK den Rückgabetyp einer Methode?,In STRONGTALK wird der Rückgabetyp einer Methode durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter der Methode.
,Wie werden Typen in Variablendeklarationen zugeordnet?,"Typen werden in Variablendeklarationen explizit angegeben, um jedem Objekt und Ausdruck im Programm einen Typ zuzuordnen."
,Wie wird die Richtung der erlaubten Zuweisung bei der Zuweisungskompatibilität interpretiert?,"Bei der Zuweisungskompatibilität wird die Richtung der erlaubten Zuweisung so interpretiert, dass beim Satz ""a ist zuweisungskompatibel mit b"" die Zuweisung ""b := a"" zulässig ist. Die umgekehrte Richtung, ""a := b,"" wird durch den Satz nicht ausgesagt."
,Wie ist der Zusammenhang zwischen Typen und Klassen in Bezug auf schematische Klassendefinitionen in SMALLTALK?,"In SMALLTALK enthalten Klassendefinitionen bestimmte Elemente, die auch in Typdefinitionen auftauchen, wie Namen, von denen Definitionen abgeleitet werden, und Methodennamen mit formalen Parametern."
,Wie unterscheidet sich die Verwendung von Klassendefinitionen in STRONGTALK von anderen Sprachen wie Java oder C++?,"In STRONGTALK sind formale Parameter in Klassendefinitionen typisiert, während in Java oder C++ Instanzvariablen nicht Teil einer Typdefinition sein können."
,Wie erfolgt die Zuweisung eines Typs zu einer Typvariable bei der Verwendung eines parametrisch definierten Typs?,"Die Zuweisung eines Typs zu einer Typvariable erfolgt bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, z. B. der Deklaration einer Variable oder des Rückgabewerts einer Methode. Diese Verwendung entspricht oberflächlich betrachtet dem Aufruf einer Methode oder eines Konstruktors, führt aber bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen."
,Wie kann der parametrische Polymorphismus zur Lösung des Problems der rekursiven Typen beitragen?,"Der parametrische Polymorphismus ermöglicht die Definition eines nicht parametrischen Typs als Subtyp eines parametrisierten Typs, wodurch die gewünschte Rekursion indirekt hergestellt werden kann."
,Wie wird die Beschränkung des tatsächlichen Typparameters in der Typdefinition erreicht?,"Die Beschränkung des tatsächlichen Typparameters wird erreicht, indem der formale Typparameter auf einen Subtyp beschränkt wird."
,Wie wird Kovarianz und Kontravarianz bei der Redefinition von Methodenaufrufen im Subtyping angewendet?,"Bei der Redefinition von Methodenaufrufen im Subtyping müssen die Parametertypen kontravariant und die Rückgabetypen kovariant sein. Dies bedeutet, dass die Eingabeparameter des Subtyps genereller sein dürfen als die des Supertyps, während der Subtyp mehr Werte zurückgeben kann als der Supertyp."
,Wie können definierte Typen in STRONGTALK-Programmen verwendet werden?,"Definierte Typen können in STRONGTALK-Programmen bei der Deklaration von (anderen) Typen, von Variablen, von Blöcken und von Methoden verwendet werden. Dies führt zu einer Typisierung der deklarierten Programmelemente."
,Wie erfolgt die Verwendung definierter Typen in Typdefinitionen und Methoden in STRONGTALK?,"Die Verwendung von definierten Typen in Typdefinitionen und Methoden erfolgt analog. In Methoden werden Variablen (einschließlich formaler Parameter) durch die Anfügung eines Typnamens in spitzen Klammern typisiert. Der Rückgabetyp eines Blocks wird im selben Segment wie die formalen Parameter angegeben, also vor dem Trennzeichen."
,Wie werden Variablen in STRONGTALK typisiert?,"Variablen (einschließlich Instanzvariablen und temporäre Variablen) werden in STRONGTALK typisiert, indem ein Typname in spitzen Klammern an die Variable angehängt wird."
,"Wo wird die Typvariable T deklariert, und wo wird sie verwendet?","T wird im Abschnitt ""Typvariablen"" deklariert und im Abschnitt ""Protokoll"" verwendet."
,Warum verwendet man traditionell einzelne Großbuchstaben für Typvariablen?,"Typvariablen werden traditionell mit einzelnen Großbuchstaben bezeichnet, um zu vermeiden, dass sie tatsächliche Typen verdecken. Dies ermöglicht die Verwendung beliebig vieler Typen in einer parametrischen Klassendefinition."
,Was passiert bei der Instanziierung eines parametrischen Typs mit einem konkreten Typen?,"Der konkrete Typ wird in die formale Typvariable eingesetzt, und der resultierende Typ wird zur Verwendung im Programm definiert."
,Warum ist die einfache Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich?,"Die einfache Form des parametrischen Polymorphismus ist nur teilweise nützlich, da die Typvariablen selbst nicht typisiert sind, und somit innerhalb der Typdefinition keine Aussagen über den Typ getroffen werden können."
,Was versteht man unter einem Subtyp und wie steht er in Beziehung zu einem Supertyp?,"Ein Subtyp ist ein Typ, dessen Werte oder Objekte überall dort verwendet werden können, wo die Werte des Supertyps, von dem er ein Subtyp ist, erwartet werden. Der Begriff ""Subtyp"" bezieht sich auf die Rolle eines Typs in der Beziehung zu einem anderen Typ, nämlich der Subtypenbeziehung. Die Gegenrolle in dieser Beziehung wird als Supertyp bezeichnet."
,Gibt es eine gewisse Zirkularität in der Definition von Subtypen?,"Ja, es gibt eine gewisse Zirkularität in der Definition von Subtypen. Die Definition selbst basiert auf der Zuweisungskompatibilität zwischen Subtypen und Supertypen. Dies kann den Eindruck erwecken, dass die Beziehung zwischen Subtypen und Supertypen einfacher ist, als sie in der Realität ist. Die eigentliche Frage, welche Bedingungen erfüllt sein müssen, damit ein Objekt eines Subtyps tatsächlich an Stellen verwendet werden darf, an denen ein Objekt eines Supertyps erwartet wird, wird jedoch in dieser Definition nicht näher erläutert."
,Warum könnte die Annotation von Variablen mit dem Supertypen ein Problem darstellen?,"Die Annotation von Variablen mit dem Supertypen könnte ein Problem darstellen, da dies die Verwendung von Subtypen einschränken würde. Wenn Variablen mit dem Supertypen annotiert sind und nur Werte des Supertyps akzeptieren, könnten keine Objekte des Subtyps in diesen Variablen gespeichert werden, selbst wenn sie die gleiche Struktur oder das gleiche Verhalten aufweisen. Dies würde die Flexibilität des Typsystems einschränken und die Verwendung von Subtypen weniger nützlich machen."
,Warum führt die Typeinschränkung zur Problematik der Zuweisungskompatibilität?,"Die Typeinschränkung kann die Zuweisungskompatibilität beeinträchtigen, da sie die Parameter-Typen in Methoden neu definiert und dadurch potenziell Konflikte bei der Zuweisung von Objekten unterschiedlicher Typen verursachen kann. Dies führt dazu, dass nicht alle Zuweisungen, die bei Typerweiterung basierend auf Typkonformität zulässig wären, bei Typeinschränkung ebenfalls zulässig sind."
,"Warum ist die Unterscheidung zwischen Wertsemantik und Referenzsemantik relevant, wenn es um Typeinschränkung geht?","Die Unterscheidung zwischen Wertsemantik und Referenzsemantik ist relevant, da sie Auswirkungen auf die Zuweisungskompatibilität hat. Unter Wertsemantik wird bei der Zuweisung eine Kopie des Objekts erstellt, während unter Referenzsemantik mehrere Variablen auf dasselbe Objekt verweisen können. In diesem Zusammenhang ist die Referenzsemantik interessanter, da Typeinschränkungen bei der Zuweisung von Aliasen (Variablen, die auf dasselbe Objekt verweisen) Probleme verursachen können, die bei Wertsemantik nicht auftreten."
,Warum wird in der Praxis der objektorientierten Programmierung oft die Referenzsemantik verwendet?,"In der Praxis der objektorientierten Programmierung wird oft die Referenzsemantik verwendet, da sie effizienter ist und es ermöglicht, auf dasselbe Objekt von verschiedenen Stellen im Code aus zuzugreifen. Dies erleichtert die Arbeit mit komplexen Datenstrukturen und verhindert unnötige Kopien von Objekten. Die Referenzsemantik ist daher die gebräuchlichere Semantik in vielen objektorientierten Programmiersprachen."
,Was möchte man bei der Deklaration von n-wertigen Attributen angeben?,Bei der Deklaration von n-wertigen Attributen möchte man den Typ der in Beziehung stehenden Objekte angeben.
,"Was bedeutet es, wenn die Extension eines Typs in der Extension eines anderen Typs enthalten ist?","Wenn die Extension eines Typs in der Extension eines anderen Typs enthalten ist, bedeutet dies, dass Objekte des ersten Typs an Stellen verwendet werden können, an denen Objekte des zweiten Typs erwartet werden, ohne die Typkorrektheit zu verletzen."
,Warum ist die Teilmengenbeziehung bei der Typeinschränkung nicht immer offensichtlich?,"Bei der Typeinschränkung, bei der Eigenschaften (Methoden) entfernt werden, kann die Extension des eingeschränkten Typs tatsächlich größer werden, da weniger spezifische Anforderungen gestellt werden. Dies kann zu einer scheinbaren Umkehrung der Teilmengenbeziehung führen."
,Warum kann es trotz der Harmonie von Typerweiterung und -einschränkung zu einem Verlust der Zuweisungskompatibilität kommen?,"Der Verlust der Zuweisungskompatibilität kann aus der impliziten Allquantifiziertheit von Typinvarianten resultieren. Typsysteme mit solchen Invarianten sind nicht in der Lage, Aussagen über Wertebereiche zu treffen, die nicht implizit allquantifiziert sind."
,Was bietet der Begriff des Subtyps als Lösung für diese Probleme?,"Der Begriff des Subtyps bietet eine Möglichkeit, Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität und Typkorrektheit zu vereinen. Ein Subtyp ist ein Typ, dessen Extension eine Teilmenge der Extension seines Supertyps ist, was sicherstellt, dass Objekte des Subtyps an Stellen verwendet werden können, an denen Objekte des Supertyps erwartet werden."
,Warum ist die Namensäquivalenz als Bedingung der Zuweisungskompatibilität wichtig?,"Die Namensäquivalenz ist wichtig, da sie sicherstellt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Sie verhindert Zuweisungen zwischen Typen, die zwar strukturell gleich sind, aber unterschiedliche Bedeutungen haben. Dies ist entscheidend, um logische Programmierfehler zu vermeiden, die sonst schwer zu entdecken wären."
,"Warum ist es nach den Prinzipien der objektorientierten Programmierung wichtig, Implementierungen von Klassen hinter Schnittstellen zu verbergen?","Das Verbergen von Implementierungen hinter Schnittstellen ist wichtig, um das Geheimnisprinzip zu wahren und sicherzustellen, dass nur die für Benutzer einer Klasse vorgesehenen Elemente sichtbar sind."
,Was unterscheidet eine absolute und eine relativ spezifizierte Schnittstelle einer Klasse?,Eine absolute Schnittstelle verrät keinerlei Implementierungsdetails und besteht nur aus Methodendeklarationen. Eine relative Schnittstelle kann sich je nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse unterscheiden und gibt mehr Einblicke in die Implementierung.
,"Warum beschränken einige Sprachen, wie Java und C++, die Instanzvariablen ihrer Klassen in der Schnittstelle?","Das Beschränken von Instanzvariablen in der Schnittstelle dient dazu, die Repräsentation der Objekte nach außen nicht sichtbar zu machen, um das Geheimnisprinzip zu wahren und Implementierungsdetails zu verbergen."
,"Was ermöglicht das Interface-als-Typ-Konzept in Java, und warum wird es als bedeutend für die objektorientierte Programmierung angesehen?","Das Interface-als-Typ-Konzept in Java ermöglicht es, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle als Typen der Klasse dienen. Dies erleichtert die interfacebasierte Programmierung und wird als einer der wichtigsten Beiträge von Java zur objektorientierten Programmierung angesehen."
,Warum gehört eine Instanz einer Subklasse nicht zwangsläufig zum Wertebereich des zur Superklasse gehörenden Typs?,"Eine Instanz einer Subklasse gehört nicht zwangsläufig zum Wertebereich des zur Superklasse gehörenden Typs, da in der Subklasse Änderungen vorgenommen werden können, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben können. Zum Beispiel können Methoden gelöscht oder inkompatibel redefiniert werden."
,Warum werden bestimmte Typsysteme als kaum praxistauglich bezeichnet?,"Bestimmte Typsysteme, die in der Lage sind, solche Einschränkungen zu überprüfen, werden als kaum praxistauglich bezeichnet, da sie die Flexibilität und die praktische Anwendbarkeit in realen Programmiersituationen stark einschränken. Sie können zu komplexen und schwer wartbaren Code führen."
,Was unterscheidet nominales und strukturelles Subtyping?,Beim Subtyping gibt es zwei Unterscheidungen: nominales und strukturelles Subtyping.
,"Was bedeutet es, wenn ein Typ als ""typkonform"" bezeichnet wird?","Ein Typ wird als ""typkonform"" bezeichnet, wenn seine Definition alle deklarierten Elemente der Definition eines anderen Typen enthält."
,"Warum setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität?","Die meisten Programmiersprachen setzen auf nominale Typkonformität, da sie automatisch gegeben ist, wenn der Typ, von dem ein neuer per Erweiterung abgeleitet wird, genannt wird. Dies vermeidet aufwendige, fallweise Konformitätstests. Strukturelle Typsysteme, insbesondere solche ohne explizite Benennung von Typen, erschweren die Ausdrücklichkeit der Programmiererin bei der Definition ihrer Absicht (intendierte Semantik) und können Programme schwerer lesbar und debugbar machen. Fehlermeldungen aus strukturellen Typprüfungen sind oft schwer zu verstehen und beziehen sich nicht immer auf die eigentliche Fehlerquelle."
,Was unterscheidet Namensäquivalenz und Strukturäquivalenz?,"Bei der Namensäquivalenz spielen die Namen der Typen eine eigenständige Rolle und haben unabhängig von ihrer Struktur Bedeutung. Bei der Strukturäquivalenz dienen Namen lediglich als abkürzende Schreibweise für die Typstrukturen. Namensäquivalenz impliziert Strukturäquivalenz, aber nicht umgekehrt."
,Warum reicht Strukturäquivalenz als Bedingung für Zuweisungskompatibilität aus?,"Strukturäquivalenz reicht als Bedingung für Zuweisungskompatibilität aus, um Typfehler zu verhindern, die auf der Annahme einer nicht vorhandenen Methode bei einem Wert einer Variable basieren. Sie gewährleistet, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können."
,Was bedeutet Typkonformität in Bezug auf Typerweiterung?,"Typkonformität regelt die Zuweisungskompatibilität unter Typerweiterung. Es bedeutet, dass Variablen, deren deklarierter Typ ein erweiterter Typ ist, auch Objekte des ursprünglichen Typs enthalten können, ohne zu Typfehlern zu führen. Die umgekehrte Zuweisung, bei der ein Objekt des ursprünglichen Typs einer Variable mit dem erweiterten Typ zugewiesen wird, kann jedoch Probleme verursachen, wenn auf Methoden des erweiterten Typs zugegriffen wird, die für das Objekt nicht definiert sind."
,Was unterscheidet eine Deklaration und eine Definition?,"Deklaration gibt dem Bezeichner bekannt, während Definition ihm sagt, wofür er steht. Bei Variablen kann die Definition implizit sein und aus der Deklaration abgeleitet werden, während bei Methoden die Unterscheidung zwischen Deklaration (Signatur) und Definition (Methodenrumpf) essentiell ist."
,"Warum wurden Typen und Klassen in diesem Text als separate Konzepte dargestellt, obwohl sie in vielen Sprachen gleich sind?","Die Trennung von Typen und Klassen wird gezeigt, weil sie nicht in allen Programmiersprachen identisch sind, und selbst in den Sprachen, in denen sie ähnlich sind, gibt es Unterschiede und spezifische Verwendungszwecke."
,"Warum wird die Unterscheidung zwischen Klassen und Typen in Sprachen, in denen jede Klasse einen Typ definiert, manchmal nicht klar getroffen?","In Sprachen, in denen Klassen auch Typen definieren, kann die Unterscheidung zwischen den beiden Konzepten verschwommen sein, da Programmierer möglicherweise nicht immer klar wahrnehmen, wie sie zur Laufzeit eines Programms wirken."
,Warum ist Inklusionspolymorphie interessant?,"Inklusionspolymorphie ermöglicht die Erweiterung des Wertebereichs von Typen, indem neue Typen hinzugefügt werden können, die anstelle bereits existierender Typen verwendet werden können, ohne dass am Programm sonst etwas geändert werden muss. Dies ist besonders nützlich für die Weiterentwicklung und Wiederverwendung von Programmen."
,"Warum ist es wichtig, die Eigenschaften eines Typs und seiner Elemente in einem Typsystem zu kennen?","Es ist wichtig, die Eigenschaften eines Typs und seiner Elemente in einem Typsystem zu kennen, um Fehler im Programm zu vermeiden, die auf der Annahme von Eigenschaften beruhen, die Objekte möglicherweise nicht haben. Ein Typsystem definiert, welche Methoden auf einem Objekt aufgerufen werden können, und stellt sicher, dass diese Methoden auch für das Objekt definiert sind."
,Warum müssen Protokolle in STRONGTALK selbst Typen verwenden?,"Protokolle in STRONGTALK verwenden selbst Typen, da sie die Typen der Eingabe- und Ausgabeobjekte in den Methoden spezifizieren. Dies gewährleistet, dass die Typen der Objekte, die mit den Methoden interagieren, kompatibel sind."
,Warum gibt es in STRONGTALK keine primitiven Typen?,"In STRONGTALK gibt es keine primitiven Typen, da alle Typen in STRONGTALK auf andere Typen zurückgeführt werden können. Selbst wenn eine Typannotation weggelassen wird, hat die entsprechende Variable bzw. der Rückgabewert der Methode immer einen impliziten Typ. Dies ermöglicht es, Typen mit zwangsläufiger Selbstbezüglichkeit eine Bedeutung zuzuweisen."
,Warum ist die Typisierung von Variablen und Ausdrücken in einem Programm wichtig?,"Die Typisierung von Variablen und Ausdrücken in einem Programm ist wichtig, um sicherzustellen, dass jede Variable nur Werte haben kann, für die sie vorgesehen ist. Dies gewährleistet die Einhaltung der Typinvariante und verhindert Typfehler im Programm."
,Ist Zuweisungskompatibilität eine transitive Eigenschaft?,"Ja, in der Regel ist Zuweisungskompatibilität eine transitive Eigenschaft. Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c ist, dann ist auch a zuweisungskompatibel mit c."
,Warum ist Zuweisungskompatibilität auch bei impliziten Zuweisungen wichtig?,"Zuweisungskompatibilität ist auch bei impliziten Zuweisungen wichtig, da sie Typkorrektheit impliziert. Bei der Parameterübergabe von Methodenaufrufen oder impliziten Zuweisungen müssen die beteiligten Typen kompatibel sein, um Typfehler zu vermeiden."
,Was erlaubt die Zuweisungskompatibilität unter Subtyping?,Die Zuweisungskompatibilität unter Subtyping erlaubt die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps.
,"Warum kann es für die Programmiererin problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden?","Es kann problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden, da der Supertyp möglicherweise nicht alle Methoden und Eigenschaften des tatsächlichen Typs enthält, die die Programmiererin verwenden möchte."
,"Warum sind Upcasts immer typsicher, während Downcasts und Crosscasts unsicher sein können?","Upcasts sind immer typsicher, da sie von einem spezielleren Typ zu einem allgemeineren Typ erfolgen. Downcasts und Crosscasts können unsicher sein, da sie von einem allgemeineren Typ zu einem spezielleren oder nicht verwandten Typ erfolgen, was dazu führen kann, dass der Ausdruck zur Laufzeit nicht den erwarteten Typ hat."
,"Warum sollte man versuchen, Typumwandlungen zu vermeiden?","Typumwandlungen sollten vermieden werden, da sie potenziell unsicher sind und die Programmlogik komplexer machen können. Wenn Typumwandlungen unvermeidbar sind, sollten sie mit einem Typtest abgesichert werden, um sicherzustellen, dass das Objekt zur Laufzeit den gewünschten Typ hat."
,Warum wurde in dieser Kurseinheit bisher nur über Typen gesprochen und Klassen ignoriert?,"Typen und Klassen werden getrennt behandelt, da Klassen die Implementierung von Objekten festlegen, während Typdefinitionen frei von Implementierungsaspekten sind."
,"Was unterscheidet Typen und Klassen, wenn es um die Einschränkung des Wertebereichs von Variablen und die Angabe des Protokolls von Objekten geht?","Typen sind abstrakte Spezifikationen, die den Wertebereich von Variablen und das Protokoll von Objekten festlegen. Klassen hingegen sind Konstrukte, die Objekte bilden und mit Implementierung versehen."
,"Warum werden in SMALLTALKs Klassendefinitionen keine Typen verwendet, und wie werden formale Parameter in Bezug auf Typen behandelt?","In SMALLTALK werden keine Typen in Klassendefinitionen verwendet, und formale Parameter verwenden stattdessen Namen wie ""aString"" oder ""anInteger"", die darauf hinweisen, welcher Klasse der Wert sein sollte. Dies wird jedoch nicht überprüft."
,Warum ergibt sich beim rekursiv beschränkten parametrischen Polymorphismus kein Widerspruch zur Kontravarianzregel des Subtyping?,"Beim rekursiv beschränkten parametrischen Polymorphismus ändert sich der Parametertyp der Methode = mit dem Empfängertyp, was kovariant wirkt. Es ergibt sich jedoch kein Widerspruch zur Kontravarianzregel des Subtyping, da der Empfängertyp (z. B. Integer) lediglich zu einem Subtyp von Equatable[Integer] wird und nicht von Equatable[Object]."
,Gibt es eine Lösung für das Problem der kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischem Polymorphismus?,"Es gibt keine zufriedenstellende Lösung für das Problem der kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischem Polymorphismus. Die Kovarianz kann zwar in bestimmten Fällen erreicht werden, aber sie ist nicht in allen Typdefinitionen festgehalten und bietet keine vollständige Kontrolle über die Typkorrektheit."
,Warum ist die Assoziation von Zeichnung mit Plotter in keiner Typdefinition festgehalten?,"Die Assoziation von Zeichnung mit Plotter, die Kovarianz, ist in keiner Typdefinition festgehalten, da es keine Möglichkeit gibt, einen bestimmten Wert für einen Typparameter vorzuschreiben. Die Kovarianz ist nicht in allen Fällen durch parametrische Typen abbildbar."
,Kann das Kovarianzproblem durch parametrische Typen gelöst werden?,"Das Kovarianzproblem kann in bestimmten Fällen durch parametrische Typen gelöst werden, aber es gibt keine allgemeine Lösung, die in allen Fällen die kovariante Redefinition von Eingabeparametern in Methoden ermöglicht. Die Flexibilität ist begrenzt, und es kann zu Einschränkungen bei der Verwendung von parametrischen Typen führen."
,Was unterscheidet eine parametrische Typdefinition und eine normale Typdefinition?,"Der Unterschied besteht darin, dass in einer parametrischen Typdefinition andere Typen durch Platzhalter, sogenannte Typparameter, vertreten werden können, die erst bei der Verwendung des parametrisierten Typs belegt werden. Bei einer normalen Typdefinition werden die anderen Typen direkt genannt."
,Warum nennt man parametrische Typen auch generische Typen oder Generics?,"Parametrische Typen werden auch als generische Typen oder Generics bezeichnet, weil sie die Idee verfolgen, aus einer Typdefinition generisch (theoretisch für beliebig viele Typen) viele Typen zu erzeugen, je nach Bedarf. Sie ermöglichen eine gewisse Generizität in der Typsicherung."
,"Müssen die zugewiesenen Typen Objekte sein, um Typvariablen in parametrischen Typen zu belegen?","Nein, die zugewiesenen Typen müssen keine Objekte sein, um Typvariablen in parametrischen Typen zu belegen. Es können auch andere Typen sein, solange sie die erforderlichen Bedingungen erfüllen."
,"Gibt es vollständig in sich selbst definierte Typsysteme, die von externen Einflüssen unabhängig sind?","Nein, es gibt keine vollständig in sich selbst definierten Typsysteme, die vollständig unabhängig von externen Einflüssen sind. Selbst in Typsystemen wie SMALLTALK oder STRONGTALK sind mindestens einige grundlegende Typen oder Konzepte, wie Wahrheitswerte oder Ganzzahlen, von externen Formalismen oder vorgegebenen Semantiken abhängig."
,Was bedeutet Typisierung in objektorientierten Programmiersprachen?,"Typisierung in objektorientierten Programmiersprachen bedeutet, dass bei der Deklaration von Programmelementen, wie Variablen oder Funktionen, Typen zugeordnet werden. Diese Typen bestimmen, welche Arten von Objekten in diesen Programmelementen gespeichert oder verarbeitet werden können und welche Operationen auf diese Objekte angewendet werden können."
,"Warum könnte es sinnvoll sein, das Typsystem einer Programmiersprache von ihrem Rest zu isolieren?","Das Isolieren des Typsystems einer Programmiersprache ermöglicht es, das Typsystem auszutauschen oder zu verbessern, ohne die gesamte Sprachdefinition ändern zu müssen. Dies kann besonders nützlich sein, wenn man eine Sprache an spezifische Anforderungen anpassen möchte."
,Warum wird in dieser Kurseinheit das Typsystem am Beispiel von STRONGTALK behandelt?,"Diese Kurseinheit behandelt das Typsystem am Beispiel von STRONGTALK, einer SMALLTALK-Erweiterung um ein optionales Typsystem. Dies geschieht, um die Konzepte schrittweise und verständlich einzuführen. Das Ziel ist, dass die Leserinnen und Leser Typsysteme als Möglichkeiten zur Spezifikation redundanter Informationen verstehen, die die Qualität von Programmen erhöhen sollen."
,Warum ist die direkte Deklaration des Gleichheitstests in Object problematisch?,"Die direkte Deklaration des Gleichheitstests in Object wäre problematisch, da sie zu einer kovarianten Redefinition führen würde, was zu bekannten Problemen führt."
,Warum sind solche Konstrukte wichtig in der objektorientierten Programmierung?,"Solche Konstrukte sind wichtig in der objektorientierten Programmierung, da sie die Typsicherheit erhöhen und es ermöglichen, flexible Frameworks und komplexe Datenstrukturen zu erstellen. Sie sind in vielen modernen Programmiersprachen und Frameworks weit verbreitet."
,Warum ist die Kovarianz für Parametertypen in der Praxis nicht notwendig und kann sogar zu typinkorrekten Programmen führen?,"Obwohl Kovarianz für Parametertypen auf den ersten Blick sinnvoll erscheint, kann sie in der Praxis zu typinkorrekten Programmen führen. Dies liegt daran, dass die Anzahl der möglichen Eingabewerte in einem Subtyp reduziert wird, wenn die Menge der Empfängerobjekte eingeschränkt wird. Dies führt dazu, dass die Parametertypen tatsächlich kontravariant sind. Kovarianz für Parametertypen würde typinkorrekte Programme ermöglichen."
,Warum wird in der Praxis trotz Verwendung parametrischer Definitionen von Collections oft auch auf Inklusionspolymorphie zurückgegriffen?,"In der Praxis wird trotz Verwendung parametrischer Definitionen von Collections oft auf Inklusionspolymorphie zurückgegriffen, da heterogene Collections, die Objekte unterschiedlicher Subtypen enthalten, häufig vorkommen und Inklusionspolymorphie dies ermöglicht."
,"Warum ist es wichtig, dass ein Typfehler bereits bei der Verwendung der parametrischen Typdefinition erkannt wird?","Es ist wichtig, dass ein Typfehler bereits bei der Verwendung der parametrischen Typdefinition erkannt wird, um sicherzustellen, dass alle eingesetzten Typen die erforderlichen Eigenschaften haben, bevor sie verwendet werden."
,Wo wird der Rückgabetyp für Blöcke in STRONGTALK angegeben?,"Der Rückgabetyp für Blöcke in STRONGTALK wird im selben Segment wie die formalen Parameter angegeben, und zwar vor dem Trennzeichen."
,Gibt es eine Verbindung zwischen Typen und Klassen in der objektorientierten Programmierung?,"Ja, es gibt eine Verbindung zwischen Typen und Klassen in der objektorientierten Programmierung. Der Zusammenhang wird jedoch vorerst zurückgestellt und wird in Kapitel 28 erklärt."
,Was unterscheidet statische und dynamische Typprüfung?,"Statische Typprüfung erfolgt zur Übersetzungszeit und gewährleistet, dass die Typkorrektheit eines Programms vor der Ausführung sichergestellt wird. Dynamische Typprüfung erfolgt zur Laufzeit und prüft, ob der zuzuweisende Wert den geforderten Typ hat. Statische Typprüfung erfordert Typenannotationen bei der Variablendeklaration, während dynamische Typprüfung dies zur Laufzeit überprüft."
,Welche beiden Interfaces in Java ermöglichen eine einheitliche Iteration über Collections mittels Iteratoren?,In Java ermöglichen die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer) eine einheitliche Iteration über Collections mittels Iteratoren.
,"Welches Interface muss eine Klasse implementieren, um die ""syntaktische Zucker""-Version der ""for""-Schleife in Java verwenden zu können?","Eine Klasse muss das Interface ""Iterable"" implementieren, um die ""syntaktische Zucker""-Version der ""for""-Schleife in Java verwenden zu können. Diese Version ermöglicht die externe Iteration über Collections."
,"Was ist das Überschreiben von Methoden in Java, und welche Bedingungen gelten dafür?","Das Überschreiben von Methoden in Java bedeutet, dass eine bereits vorhandene Methode in einer Subklasse mit derselben Signatur (Methodenname und formale Parametertypen) neu definiert wird. Die Bedingungen dafür sind, dass die Methode denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode hat und dass die deklarierten Parametertypen der Methode Subtypen der deklarierten Parametertypen der Methode in der Superklasse sind."
,"Was ist das Überladen von Methoden in Java, und wie unterscheidet es sich vom Überschreiben?","Das Überladen von Methoden in Java bedeutet, dass Methoden denselben Namen haben, aber verschiedene Parametertypen in derselben Klasse oder einer Subklasse haben. Der Unterschied zum Überschreiben besteht darin, dass beim Überladen neue Methoden hinzugefügt werden, während beim Überschreiben bereits vorhandene Methoden neu definiert werden."
,"Was ist dynamisches Binden in Java, und wie funktioniert der Bindungsalgorithmus?","Das dynamische Binden in Java bezieht sich auf die Auswahl der Methode zur Laufzeit, basierend auf dem tatsächlichen Typ des Empfängerobjekts. Der Bindungsalgorithmus in Java wählt die Methode aus, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode, ist in der Klasse des deklarierten Typs des Ausdrucks deklariert und deren deklarierte Parametertypen sind Subtypen der deklarierten Parametertypen der aufgerufenen Methode. Wenn mehrere Methoden die Bedingungen erfüllen, wird diejenige ausgewählt, deren Klasse am nächsten zur Klasse des Empfängerobjekts in der Superklassenkette ist."
,Was sind die Einschränkungen von Java-Arrays im Vergleich zu Collections?,"Java-Arrays haben im Vergleich zu Collections Einschränkungen in ihrer Funktionalität. Sie bieten keine eigenen Methoden zur Unterstützung des Zugriffs, kein dynamisches Wachstum und es gibt einige Probleme mit dem Subtyping von Arrays."
,Welche Vorteile bietet die Verwendung von Interfaces in Java?,"Die Verwendung von Interfaces in Java ermöglicht die Bereitstellung verschiedener Sichten auf Objekte, die von Klassen implementiert werden. Dies kann dazu beitragen, den Zugriff auf die Methoden eines Objekts zu beschränken oder die Austauschbarkeit von Klassen zu verbessern."
,Was sind Tagging oder Marker-Interfaces in Java und wofür werden sie verwendet?,"Tagging oder Marker-Interfaces in Java sind Schnittstellen, die in der Regel keine eigenen Methoden deklarieren, sondern dazu verwendet werden, Klassen zu markieren oder zu ""taggen"". Sie dienen der Filterung von Variablenwerten und können beispielsweise dazu verwendet werden, bestimmte Eigenschaften oder Fähigkeiten von Klassen oder Objekten zu kennzeichnen. Ein Beispiel ist das Marker-Interface ""Serializable"", das angibt, dass Instanzen einer Klasse serialisierbar sind."
,Welche Rolle spielen Interfaces bei der Einschränkung des Zugriffs auf Methoden in Java?,"Interfaces können dazu verwendet werden, den Zugriff auf Methoden zu beschränken, da nur die im Interface definierten Methoden aufgerufen werden können. Dies ermöglicht es, verschiedene Sichten auf ein Objekt zu gewähren und den Zugriff auf bestimmte Methoden zu kontrollieren."
,Welche Rolle spielt die Java Virtual Machine (JVM) in Java-Programmen?,"Die Java Virtual Machine (JVM) interpretiert den Bytecode, der das Ergebnis der Übersetzung von Java-Programmen ist. Sie spielt eine entscheidende Rolle bei der Ausführung von Java-Programmen."
,"Was ist die typische Methode, um ein Java-Programm auszuführen, und wie lautet ihre Signatur?","Die typische Methode, um ein Java-Programm auszuführen, ist die ""main""-Methode mit der Signatur ""public static void main(String[] args)"". Dies ist die Startmethode für Java-Anwendungen."
,Was ist ein wichtiges Merkmal des Programmiermodells von Java in Bezug auf die Namenskonvention von Klassen?,"Ein wichtiges Merkmal des Programmiermodells von Java ist, dass Klassennamen immer großgeschrieben werden sollen."
,"Welches Problem ergibt sich bei der Erweiterung von Interfaces, wenn man keine abstrakten Klassen verwendet?","Bei der Erweiterung von Interfaces, insbesondere wenn diese von Anwendungsklassen implementiert werden, entsteht das Problem, dass die Klassen, die diese Interfaces implementieren, aktualisiert werden müssen. Dies kann zu Schwierigkeiten führen, insbesondere wenn die Entwicklung dieser Klassen in den Händen Dritter liegt."
,"Welchen Zusammenhang gibt es zwischen Klassen und Dateien in Java, und warum dürfen mehrere Klassen nicht als ""public"" deklariert werden?","In Java entspricht normalerweise jede Datei der Definition einer Klasse mit dem gleichen Namen wie der Dateiname (ohne Erweiterung). Es ist möglich, mehrere Klassen in einer Datei zu definieren, aber keine dieser Klassen darf als ""public"" deklariert werden. Dies liegt an Konventionen, die die meisten integrierten Entwicklungsumgebungen und Versionsverwaltungssysteme unterstützen. In der Regel sollte jede Datei eine öffentliche Klasse mit demselben Namen enthalten."
,"Welche Konvention wird in Java verwendet, um den Typ bei Deklarationen anzugeben, und wie unterscheidet sich dies von STRONGTALK?","In Java wird der Typ bei Deklarationen ohne spitze Klammern vorangestellt. Dies unterscheidet sich von STRONGTALK, bei dem die spitzen Klammern in Deklarationen verwendet werden. In Java folgt die Typangabe der Tradition von C und C++."
,Was ist das Reflection API in Java und wofür wird es verwendet?,"Das Reflection API in Java ermöglicht den Zugriff auf die Elemente eines Programms, obwohl nicht alles in Java ein Objekt ist. Es stellt Klassen zur Verfügung, die verschiedene Programmelemente repräsentieren, wie Methoden (Klasse Method) oder Felder (Klasse Field). Dies ermöglicht es, Programmierung auf einer höheren Ebene durchzuführen, indem man dynamisch auf Programmstrukturen zugreift. Eine ausführliche Untersuchung dieses APIs wird im Kurs 01853 (""Moderne Programmiertechniken und -methoden"") behandelt."
,Was sind Annotationen in Java und welche Rolle spielen sie in der Metaprogrammierung?,"Annotationen in Java sind eine Form der Metaprogrammierung, bei der Programmmetadaten den Programmelementen im Quelltext zugeordnet werden. Diese Metadaten können während der Übersetzung und/oder während der Ausführung des Programms abgefragt werden und den jeweiligen Prozess beeinflussen oder steuern. In Java 5 wurden Annotationen als eine spezielle Art von Interfaces eingeführt, die jedoch keine Methoden, sondern nur Felder deklarieren. Annotationen werden häufig verwendet, um zusätzliche Informationen oder Konfigurationen zu einem Programm hinzuzufügen."
,Was ist ein Modul in der Programmierung und wie ist seine Schnittstelle definiert?,"Ein Modul ist eine Einheit von Programmelementen, deren Funktion von außen, z. B. von anderen Modulen, nur über die Schnittstelle des Moduls zugänglich ist. Die Schnittstelle definiert, welche Teile des Moduls öffentlich sichtbar sind."
,Welche Trennung gibt es in Java zwischen Operationen und Methoden?,"In Java gibt es eine Trennung zwischen Operationen, die auf primitiven Typen fest vorgegeben sind, und Methoden, die in Klassen definiert werden müssen."
,Welcher Operator steht speziell für Referenztypen in Java zur Verfügung?,"Ein Operator, der speziell für Referenztypen in Java zur Verfügung steht, ist der Typtest ""instanceof"". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist."
,Welche Funktionen haben Klassen in Java?,"Klassen in Java dienen als Vorlagen für die Erzeugung von Objekten, liefern Typen für ein Programm und dienen der Modularisierung."
,Was sind Zugriffsmodifikatoren in Java?,"Zugriffsmodifikatoren (access modifiers) sind in Java Schlüsselwörter wie private, protected, public und ""Package local,"" die die Zugriffsbeschränkungen für Klassen, Typen und deren Elemente festlegen. Sie regeln, welche Teile einer Klasse von anderen Klassen aus zugänglich sind."
,Welche Auswirkungen haben die Zugriffsbeschränkungen in Java?,"Die Zugriffsbeschränkungen in Java regeln, welche Teile einer Klasse oder eines Typs von anderen Klassen oder Typen aus zugänglich sind. Sie beeinflussen die Sichtbarkeit von Variablen, Methoden und anderen Elementen innerhalb einer Klasse und zwischen Klassen, insbesondere in verschiedenen Paketen."
,Was sind die konkreten Auswirkungen der Zugriffsbeschränkungen in Java?,"Die Zugriffsbeschränkungen in Java wirken sich auf die Sichtbarkeit von Elementen innerhalb von Klassen und zwischen Klassen aus. Sie regeln, welche Teile eines Moduls von anderen Modulen aus sichtbar sind und können durch Hiding, Shadowing und Obscuring weiter eingeschränkt werden. Die Verknüpfung von Typ und Zugriffsbeschränkung ist in Java etabliert und ermöglicht die Deklaration von Typen und Schnittstellen in einem."
,Welche Arten von Literale gibt es in Java?,"In Java gibt es Literale für Zahlen, Zeichen und Strings."
,"Welche drei besonderen Werte im Fließkommabereich haben keine Literale, sondern nur Konstanten in Java?","Die drei besonderen Werte im Fließkommabereich, die keine Literale, sondern nur Konstanten in Java haben, sind ""NaN"" (Not a Number), ""POSITIVE_INFINITY"" und ""NEGATIVE_INFINITY""."
,Welcher Typ hat ein Klassenliteral in Java?,"Der Typ eines Klassenliterals in Java ist ""Class<T>"", wobei T der Typ der Klasse ist. Zum Beispiel hat ""Class<Object>"" den Typ ""Class<Object>""."
,Welche Art von Typprüfungen kann Java zur Übersetzungszeit durchführen?,Java kann zur Übersetzungszeit statische Typprüfungen durchführen.
,Welche gelegentlichen Typprüfungen erfordern dynamische Typprüfungen in Java?,"Gelegentliche Typprüfungen, die dynamische Typprüfungen in Java erfordern, sind insbesondere Typumwandlungen (Type casts)."
,"Welches Schlüsselwort verwendet Java, um die Bestehen einer Subklassenbeziehung zwischen zwei Klassen zu deklarieren?","Java verwendet das Schlüsselwort ""extends,"" um die Bestehen einer Subklassenbeziehung zwischen zwei Klassen zu deklarieren."
,Was ist ein Interface in Java und wie wird es deklariert?,"Ein Interface in Java ist eine eigenständige Schnittstellendeklaration, die von einer Klasse unabhängig ist, aber genauso wie eine Klasse einen Typ definiert. Interfaces werden mit dem Schlüsselwort ""interface"" deklariert."
,Welche Unterschiede gibt es zwischen der Deklaration eines Interfaces und einer Klasse?,"Die Unterschiede zwischen der Deklaration eines Interfaces und einer Klasse sind: Verwendung des Schlüsselworts ""interface"" anstelle von ""class"". Fehlen von Felddeklarationen in Interfaces. In Interfaces folgt auf die Methodendeklaration lediglich ein abschließendes Semikolon, ohne Implementierung."
,Welchen Vorteil bietet die Verwendung von Interfaces bei der Verwendung von Variablen?,"Die Verwendung von Interfaces ermöglicht es, Methoden und Felder einer Instanz vor anderen Instanzen zu verbergen. Durch die Deklaration von Variablen mit dem Interface als Typ kann der Zugriff auf bestimmte Methoden und Felder beschränkt werden."
,"Welche Beziehung müssen die Typen in Java haben, damit Ausdrücke von einem Typ Variablen eines anderen Typs zugewiesen werden können?","Damit Ausdrücke von einem Typ Variablen eines anderen Typs zugewiesen werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen ihnen bestehen."
,"Was ist nominale Typkonformität, und welche Vor- und Nachteile hat sie?","Nominale Typkonformität bedeutet, dass die Subtypbeziehung explizit deklariert werden muss. Dies hat den Vorteil der Filterfunktion, aber den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen, was bei verteilten Anwendungen problematisch sein kann."
,Welche Anforderung stellt Java an geerbte Variablen (Felder und Parametertypen von Methoden)?,"Java verlangt, dass die Typen geerbter Variablen nicht verändert werden dürfen. Dies wird als Kovarianz bezeichnet."
,"Was sind Konstruktoren in Java, und wie verhalten sie sich im Vergleich zu SMALLTALK?","Konstruktoren in Java sind spezielle Methoden, die zur Erzeugung von Objekten verwendet werden. Im Gegensatz zu SMALLTALK sind Konstruktoren in Java keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Sie verhalten sich wie Instanzmethoden und können auf alle Felder und Methoden der neu erzeugten Instanz zugreifen."
,"Was sind Factory-Methoden in Java, und wie werden sie verwendet?","Factory-Methoden sind Klassenmethoden in Java, die zur Erzeugung von Objekten verwendet werden können. Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben. Factory-Methoden ermöglichen eine flexible Objekterzeugung und werden oft in Bibliotheken und Frameworks eingesetzt."
,Was ist Exception Handling in Java?,"Exception Handling ist eine Möglichkeit in Java, mögliche Ausnahmesituationen und deren Behandlung bei der Spezifikation des Kontrollflusses eines Programms vorübergehend zu vernachlässigen und so zu tun, als würde immer alles gutgehen. Ausnahmesituationen werden in Java in Form von Exception-Klassen dargestellt."
,Was sind Checked Exceptions in Java?,"Checked Exceptions sind Ausnahmesituationen, bei denen die Programmierer sich der möglichen Ausnahmesituationen bewusst sein müssen. Sie erfordern eine Deklaration im Methodenkopf oder müssen innerhalb der Methode behandelt werden. Diese Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind."
,Was sind Unchecked Exceptions in Java?,"Unchecked Exceptions sind Ausnahmesituationen, die in der Praxis überall auftreten können. Sie erfordern keine explizite Deklaration im Methodenkopf und können überall auftreten. Unchecked Exceptions werden von Exception-Klassen abgeleitet, die von RuntimeException abgeleitet sind."
,"Welche Initiative wurde von der Java-Community aufgegriffen, um die Situation mit aufgeteilten Paketen zu verbessern?","Die Java-Community griff die Open Services Gateway Initiative (OSGi) auf, um die Situation mit aufgeteilten Paketen zu verbessern. OSGi ermöglichte die Zusammenfassung von Java-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation."
,Was ist der qualifizierte Export in der Moduldefinition von Java?,"Der qualifizierte Export in der Moduldefinition von Java ist ähnlich wie in EIFFEL. Er nennt die Module, an die exportiert wird, namentlich und erlaubt einen ""privaten"" Austausch zwischen bestimmten Modulen, die somit ihre eigenen, privaten Schnittstellen haben."
,Was ist das Besondere an der Moduldefinition von Java in Bezug auf die Einhaltung der Schnittstellenspezifikationen?,"Die Moduldefinition von Java erzwingt die Einhaltung der Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit. Sie kontrolliert auch den reflektiven Zugriff auf Programmelemente, was zu einer erheblichen Verbesserung der Sicherheit von Java-Programmen führt."
,Welche Möglichkeit zur Iteration von Collection-Klassen kennen Sie aus SMALLTALK?,"In SMALLTALK gibt es die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren, was als interne Iteration bezeichnet wird."
,"Welche neuen Funktionen wurden in Java 8 eingeführt, um interne Iterationen zu ermöglichen?","In Java 8 wurden (anonyme) Funktionen, auch bekannt als Lambda-Ausdrücke, eingeführt, um interne Iterationen à la SMALLTALK zu ermöglichen."
,"Welches Framework wurde für die Implementierung der Methoden forEach, filter, map und reduce in Java 8 geschaffen?","Für die Implementierung der Methoden forEach, filter, map und reduce in Java 8 wurde das Stream-Framework geschaffen."
,Welche Vorteile bietet das Stream-Framework von Java im Vergleich zu naiven Implementierungen von Pipelines?,"Das Stream-Framework von Java ermöglicht für viele Pipelines eine besonders effiziente Ausführung. Es minimiert die Anzahl der Iterationen, reduziert die interne Speicherung von Zwischenergebnissen und erlaubt die Auswahl zwischen paralleler und sequenzieller Verarbeitung der Pipeline. Dennoch ist die Performanz von Java-Pipelines nicht leicht vorherzusagen und erfordert Erfahrung und Kenntnisse der Implementierung."
,Was ist die Hauptanwendung generischer Typen in Java?,"Eine Hauptanwendung generischer Typen in Java ist die Arbeit mit Collections, um den Typ der Elemente in der Collection anzugeben und so die Typsicherheit zu erhöhen."
,"Welche Konvention wird häufig verwendet, um Typparameter von Klassen- und Variablennamen zu unterscheiden?","Eine häufig verwendete Konvention ist es, einzelne Großbuchstaben für Typparameter zu wählen. Zum Beispiel steht ""E"" üblicherweise für den Elementtyp von Containern wie Collections."
,Was ist rekursiv beschränkter parametrischer Polymorphismus in Java?,"Rekursiv beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Möglichkeit, Beschränkungen für Typparameter auf eine Weise zu definieren, die auf sich selbst oder andere Typparameter verweist."
,Welche Typkonstruktoren gab es in Java bis zur Version 1.4?,"Bis Java 1.4 gab es die Typkonstruktoren class, interface und [] (Array)."
,Welcher Typkonstruktor wurde in Java 1.5 für Aufzählungstypen hinzugefügt?,In Java 1.5 wurde der Typkonstruktor enum für Aufzählungstypen hinzugefügt.
,Welche Art von Typen sind Aufzählungstypen in Java?,Aufzählungstypen in Java sind Klassentypen. Sie können neben den Aufzählungselementen auch Felder und Methoden enthalten.
,Was ist das Symbol für eine Typ-Wildcard in Java?,Das Symbol für eine Typ-Wildcard in Java ist das Fragezeichen (?).
,"Was ist die Verwendung von ""extends"" und ""super"" in Verbindung mit Typ-Wildcards?","""extends"" wird verwendet, um eine obere Schranke für Typ-Wildcards anzugeben, während ""super"" verwendet wird, um eine untere Schranke anzugeben. Mit ""extends"" beschränkte Wildcard-Typen sind kovariant, und mit ""super"" beschränkte Wildcard-Typen sind kontravariant."
,"Welche Einschränkung gibt es bei der Verwendung von ""super"" beschränkten Typ-Wildcards?","Bei ""super"" beschränkten Typ-Wildcards ist der Zugriff auf Elemente in der Regel auf schreibende Zugriffe beschränkt, und lesende Zugriffe haben immer den Typ ""Object""."
,"Welche Art von Subtyping wird bei ""extends"" beschränkten Wildcard-Typen verwendet?","""extends"" beschränkte Wildcard-Typen verwenden kovariantes Subtyping."
,"Welche Art von Subtyping wird bei ""super"" beschränkten Wildcard-Typen verwendet?","""super"" beschränkte Wildcard-Typen verwenden kontravariantes Subtyping."
,Was sind generische Typen in Java?,"Generische Typen in Java sind Typdefinitionen, die Typvariablen verwenden, um die Referenzierung eines oder mehrerer Typen innerhalb der Definition zu abstrahieren."
,Welche Merkmale von C++ und SMALLTALK wurden in Java übernommen?,"In Java wurden weite Teile der Syntax und der statischen Typüberprüfung von C++ übernommen. Außerdem wurde der eher klassisch prozedurale Charakter von C++ beibehalten, wobei Methodenaufrufe anstelle von Nachrichtenversand verwendet werden. Von SMALLTALK wurden die umfassende Objektorientierung (es gibt keinen Code außerhalb von Klassen), die Einfachvererbung sowie die Garbage Collection übernommen."
,Was sind Instanzvariablen in Java?,"Instanzvariablen in Java sind Felder, die zur Speicherung von Daten in einer Klasse verwendet werden. Jede Instanz der Klasse hat ihre eigenen Kopien dieser Variablen."
,Was sind Instanzmethoden in Java?,"Instanzmethoden in Java sind Methoden, die auf Instanzen (Objekten) einer Klasse angewendet werden können. Sie definieren das Verhalten der Klasse."
,"Was sind ""Member"" in Bezug auf Klassendefinitionen in Java?","""Member"" ist ein zusammenfassender Begriff für Felder und Methoden innerhalb einer Klassendefinition in Java."
,Welche weiteren Arten von Klassendefinitionen sind in Java möglich?,"In Java können Sie auch geschachtelte Klassendefinitionen und innere Klassendefinitionen erstellen, die ebenfalls als Members der umschließenden Klasse gelten."
,Welche Arten von Ausdrücken gibt es in Java?,"In Java gibt es verschiedene Arten von Ausdrücken, darunter Literale, Variablen, Methodenaufrufe, Operatoranwendungen, Feldzugriffe, Klasseninstanziierungen, Array-Instanziierungen, Konditionalausdrücke, Cast-Ausdrücke und Lambda-Ausdrücke."
,Welche Typisierungsanforderungen gelten für Ausdrücke in Java?,"In Java müssen alle Ausdrücke korrekt typisiert sein. Das bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks übereinstimmen muss, an der Stelle, an der er eingesetzt wird."
,"Welche Rolle spielen Lambda-Ausdrücke in Java, und wie unterscheiden sie sich von anonymen inneren Klassen?","Lambda-Ausdrücke in Java, die in Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Sie ermöglichen die Darstellung von Funktionen als Werte und werden häufig für die Implementierung von Schnittstellen mit nur einer Methode (Funktionale Interfaces) verwendet. Im Gegensatz dazu verwenden anonyme innere Klassen explizite Klassendefinitionen, um Schnittstellen zu implementieren."
,Welche Arten von Typumwandlungen gibt es in Java?,"In Java gibt es drei Arten von Typumwandlungen: Up casts, Down casts und Cross casts."
,Was ist ein Up cast?,"Ein Up cast tritt auf, wenn der Zieltyp ein Supertyp des Ausgangstyps ist."
,Was ist ein Down cast?,"Ein Down cast tritt auf, wenn der Zieltyp ein Subtyp des Ausgangstyps ist."
,Was ist ein Cross cast?,"Ein Cross cast tritt auf, wenn Zieltyp und Ausgangstyp keine Subtypenbeziehung zueinander haben und nebeneinander stehen."
,Welche Art von Typumwandlung ist immer sicher?,"Ein Up cast ist immer sicher, da jedes Objekt neben seinem Typ auch den Typ all seiner Supertypen hat."
,Welche Art von Typumwandlung kann zu Laufzeittypfehlern führen?,"Down und Cross casts können zu Laufzeittypfehlern führen, wenn das Objekt, zu dem der typumgewandelte Ausdruck ausgewertet wird, nicht den Zieltyp oder einen Subtyp davon hat. Dies kann zur Laufzeit zu ClassCastException-Fehlern führen."
,Welche Bedeutung haben Interfaces und Module in Java?,"Interfaces und Module sind in Java eng miteinander verknüpft und dienen dazu, die Schnittstellen und die Modularisierung von Klassen und Programmen zu definieren."
,Welche Rolle spielen Interfaces in der objektorientierten Programmierung?,"Interfaces spielen in der objektorientierten Programmierung eine wichtige Rolle, da sie dazu dienen, Schnittstellen zu definieren, über die Klassen miteinander kommunizieren können. Sie ermöglichen die Implementierung von Methoden in verschiedenen Klassen und erlauben die Implementierung von Polymorphismus."
,Was ist die Besonderheit von Javas Interfaces?,"Javas Interfaces sind eigenständige Konstrukte, die über die ursprüngliche Bedeutung hinausgehen und weitreichende Möglichkeiten zur Definition von Schnittstellen und zur Entwicklung objektorientierter Programmiersprachen bieten."
,Welche Formen von Abhängigkeiten gibt es in den Klassen als Modulen der Java-Programmierung?,"In den Klassen als Modulen der Java-Programmierung gibt es zwei Formen von Abhängigkeiten: Eine Klasse hängt von einer anderen ab, wenn auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich durch die Deklaration von Variablen des entsprechenden Typs und gegebenenfalls durch das Importieren der Klasse oder des Pakets, in dem sich die andere Klasse befindet. Eine Klasse bietet einige ihrer Member zur Benutzung durch andere Klassen an und diese werden dadurch von ihr abhängig. Dies erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht privat sind, sowie an der Implementierung von Interfaces."
,Welche Arten von Abhängigkeiten können zwischen Klassen und Paketen in Java entstehen?,"In Java können Vererbungsabhängigkeiten zwischen Klassen auftreten, die nicht zirkulär sind. Bei der Ausdehnung der Abhängigkeiten auf Pakete können jedoch auch zirkuläre Abhängigkeiten zwischen Paketen entstehen."
,Welches Schlüsselwort wird in Java für Typtests verwendet?,"Das Schlüsselwort für Typtests in Java lautet ""instanceof""."
,Welche Vorteile bieten Typtests in Kombination mit bedingten Umwandlungen?,"Typtests in Kombination mit bedingten Umwandlungen bilden die typsichere Variante der Typumwandlung und helfen, Laufzeitfehler zu vermeiden."
,Was ist die Sichtbarkeit von Typparametern in Methodendefinitionen?,Die Sichtbarkeit von Typparametern in Methodendefinitionen ist auf die jeweilige Methode beschränkt.
,Was ist Typinferenz in Bezug auf generische Methoden?,"Typinferenz in Bezug auf generische Methoden bezieht sich auf die Fähigkeit des Java-Compilers, den tatsächlichen Typparameter wegzulassen, wenn er sich aus dem Kontext des Methodenaufrufs ableiten kann."
,Welche Vorteile bietet die Verwendung von Typinferenz bei generischen Methoden?,"Die Verwendung von Typinferenz bei generischen Methoden erleichtert die Verwendung, da der tatsächliche Typparameter nicht immer explizit angegeben werden muss, was den Code lesbarer macht."
,Welche Arten von Anweisungen gibt es in Java?,"In Java gibt es verschiedene Arten von Anweisungen, darunter Variablendeklarationen, Wertzuweisungen, Methodenaufrufe, Klasseninstanziierungen und Kontrollstrukturen wie If-Anweisungen, Schleifen, Switch-Anweisungen, Try-Anweisungen und mehr."
,Welche Arten von Schleifen werden in Java unterstützt?,"Java unterstützt While-Schleifen, Do-Schleifen, For-Schleifen und die erweiterte For-Schleife. Dabei wird While-Schleife verwendet, um Anweisungen solange auszuführen, wie eine Bedingung wahr ist. Do-Schleife ist ähnlich, aber die Bedingung wird erst nach der Ausführung überprüft. For-Schleifen ermöglichen die explizite Initialisierung, Bedingung und Veränderung der Schleifenvariable. Die erweiterte For-Schleife iteriert über die Elemente eines Arrays oder Objekts, das Iterable implementiert."
,Was ist der Zweck der Assert-Anweisung in Java?,"Die Assert-Anweisung in Java dient dazu, bestimmte Bedingungen im Programm zu überprüfen. Wenn die Bedingung zu false ausgewertet wird, wird das Programm mit einer entsprechenden Fehlermeldung abgebrochen. Die Assert-Anweisung kann auch ein optionales Ergebnis liefern, das in der Fehlermeldung angezeigt wird. Sie eignet sich zur Überprüfung von Invarianten zur Laufzeit."
,"Welche Semantik haben Variablen in Java, und wie wird dies bestimmt?","Variablen in Java haben entweder Referenzsemantik oder Wertsemantik, je nach ihrem Typ. Primitive Typen wie byte, short, int, usw., haben Wertsemantik. Andere Typen haben Referenzsemantik."
,"Was ist ""Auto boxing"" und ""Auto unboxing"" in Java?","Seit Java 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" für das Verpacken in Wrapper-Typen und ""Auto unboxing"" für das Entpacken."
,"Welche Vorsichtsmaßnahmen müssen bei ""Auto boxing"" und ""Auto unboxing"" in Java getroffen werden?","Bei ""Auto boxing"" und ""Auto unboxing"" in Java ist Vorsicht geboten, da unerwartete Ergebnisse auftreten können. Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte, um Programmierfehler zu vermeiden."
,"Was sind die sechs Arten von Typen, die in Java unterschieden werden?","In Java werden die folgenden sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen."
,Welche primitiven Typen sind in Java definiert?,"In Java sind die folgenden primitiven Typen definiert: byte, short, int, long, float, double, boolean und char."
,Was sind Wrapper-Typen in Java und wofür werden sie verwendet?,"Wrapper-Typen in Java sind Referenztypen, die jeweils einen Wert eines entsprechenden primitiven Typs aufnehmen können. Sie werden verwendet, um primitiven Typen eine Objekthülle zu geben und sie in Situationen zu verwenden, die Referenztypen erfordern."
,Welche vordefinierten Typen sind in der Java-Sprachdefinition bereits festgelegt?,"In der Java-Sprachdefinition sind folgende vordefinierte Typen festgelegt: Object, String, Throwable, Error, Exception, RuntimeException und Thread."
,"Was sind Literale in Java, und wie werden sie verwendet?","Literale in Java sind Werte wie Zahlen, Zeichen und Wahrheitswerte, die direkt in den Code geschrieben werden können, ohne sie durch Instanziierung von Klassen zu erzeugen. Literale sind eine Möglichkeit, Objekte in Java zu erstellen."
,Was ist beschränkter parametrischer Polymorphismus in Java?,"Beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Einschränkung der möglichen Typen, die für einen Typparameter einer generischen Klasse verwendet werden können. Dies geschieht durch das Festlegen von Beschränkungen oder Bedingungen für den Typparameter."
,Welche Art von Typvariablen können in generischen Variablen verwendet werden?,"In generischen Variablen können anonyme Typvariablen, also Wildcards, verwendet werden."
,Welche Einschränkungen gelten für generische Variablen mit Typ-Wildcards?,"Generische Variablen mit Typ-Wildcards unterliegen den im Abschnitt 43.2 genannten Einschränkungen, insbesondere in Bezug auf die Verwendung von Wildcards mit oberen und unteren Schranken."
,"Welche Methode wird in Java verwendet, um die Gleichheit von Objekten zu prüfen?","In Java wird die Methode equals(.) verwendet, um die Gleichheit von Objekten zu prüfen."
,Welche Klasse erbt die Methode equals(.) in Java?,"Die Methode equals(.) wird von der Klasse Object geerbt, die in Java die Superklasse aller Klassen ist."
,Was sind Threads in Java und wie unterscheiden sie sich von Prozessen?,"Threads in Java sind parallele Ausführungsstränge, während Prozesse in der Regel eigenständige Programme mit separater Ressourcenallokation sind. Threads sind leichtgewichtiger und teilen sich Ressourcen innerhalb eines Prozesses. Bei Threads müssen die Synchronisationsmechanismen selbst implementiert werden, während Prozesse in Betriebssystemen über die Inter-Prozess-Kommunikation reguliert werden."
,Was ist ein Monitor in Bezug auf Threads in Java?,"Ein Monitor in Bezug auf Threads in Java ist ein Mechanismus, der dazu dient, die Synchronisation von Threads zu ermöglichen. Jedes Objekt in Java ist mit einem Monitor verknüpft. Wenn ein Thread einen Monitor eines Objekts sperrt (""lockt""), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird."
,Welche Besonderheiten gibt es bei mehrdimensionalen Arrays in Java?,"In Java können mehrdimensionale Arrays geschachtelt werden, wobei die Größen der Dimensionen nicht für jedes Element der ersten Dimension gleich sein müssen."
,Wie wurde der Fehler bezüglich unnötig langer Bezeichner in Iterationen mit Java 5 korrigiert?,"Der Fehler bezüglich unnötig langer Bezeichner in Iterationen wurde mit Java 5 korrigiert, indem die ""for""-Schleife um eine vereinfachte Schreibweise für die externe Iteration über Collections ergänzt wurde."
,"Wie wird das dynamische Binden in Java durchgeführt, und warum ist es wichtig zu verstehen?","Das dynamische Binden in Java erfolgt zur Laufzeit, wenn der tatsächliche Typ des Empfängerobjekts bestimmt wird, um die entsprechende Methode auszuwählen. Es ist wichtig zu verstehen, da es das Verhalten eines Programms beeinflusst und zur Vorhersage des Programmverhaltens beiträgt."
,"Wie können Interfaces in Java dazu beitragen, die Austauschbarkeit von Klassen zu verbessern?","Interfaces ermöglichen es, verschiedene Implementierungen eines Interfaces zu verwenden, ohne den zugrunde liegenden Klassentyp zu spezifizieren. Dies verbessert die Austauschbarkeit von Klassen, da verschiedene Klassen, die dasselbe Interface implementieren, in derselben Weise verwendet werden können."
,Wie erfolgt die Ausführung eines Java-Programms auf Betriebssystemebene?,"Die Ausführung eines Java-Programms auf Betriebssystemebene erfolgt, indem man der JVM den Namen der Klasse als Parameter übergibt. Zum Beispiel: ""Java MeineKlasse""."
,Wie erfolgt in Java das Deployment von Anwendungen?,In Java erfolgt das Deployment von Anwendungen oft durch die Verteilung von sogenannten Java Archiven (.jar-Dateien). Zur Ausführung ist jedoch eine Installation der JVM erforderlich.
,Wie wurde das Problem der Erweiterung von Interfaces in Java 8 gelöst?,"In Java 8 wurde das Problem der Erweiterung von Interfaces gelöst, indem Interfaces die Implementierung von Methoden durch das Schlüsselwort ""default"" vorgeben konnten. Dadurch konnten zusätzliche Methoden in Interfaces hinzugefügt werden, ohne die implementierenden Klassen zu zwingen, sie zu implementieren."
,Wie wird ein Typ in Java aus einer Klassendefinition abgeleitet?,In Java spezifiziert jede Klasse ihren eigenen Typ. Der Typ trägt denselben Namen wie die Klasse und enthält Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften.
,Wie wurden Module in Java bis zur Version 8 simuliert?,In Java wurden Module bis zur Version 8 mehr oder weniger gut durch Klassen und Pakete simuliert.
,Wie kann auf Klassen und Typen in unterschiedlichen Paketen in Java zugegriffen werden?,"Um auf Klassen und Typen in verschiedenen Paketen zuzugreifen, müssen in Java explizite Import-Deklarationen verwendet werden, die die jeweiligen Paketnamen nennen. Pakete ermöglichen keinen privilegierten Zugriff auf Klassen ihrer Subpakete."
,Wie werden Zeichenliterale und String-Literale in Java dargestellt?,"Zeichenliterale werden in Java durch einfache Anführungsstriche (\' \') eingeschlossen, während String-Literale durch doppelte Anführungsstriche ("" "") eingeschlossen werden."
,Wie gibt man in Java den Typ einer Klasse als Wert an?,"In Java gibt man den Typ einer Klasse als Wert mittels eines sogenannten Klassenliterals an. Dieses besteht aus dem Namen der Klasse, gefolgt von "".class"", z. B. ""Klasse.class""."
,"Wie werden abstrakte Methoden in Java deklariert, und wie werden sie in Subklassen implementiert?","Abstrakte Methoden in Java werden deklariert, indem man hinter der Methodensignatur ein abschließendes Semikolon setzt, anstatt eine Implementierung anzugeben. In Subklassen müssen abstrakte Methoden mit Implementierungen versehen werden, andernfalls gibt der Compiler eine Fehlermeldung aus."
,"Wie kann in Java verhindert werden, dass von einer Klasse abgeleitet wird?","In Java kann verhindert werden, dass von einer Klasse abgeleitet wird, indem man das Schlüsselwort ""final"" vor der Klassendefinition verwendet."
,"Wie gibt eine Klasse an, dass sie ein Interface implementiert, und welche Verpflichtung ergibt sich daraus?","Eine Klasse gibt an, dass sie ein Interface implementiert, indem sie das Schlüsselwort ""implements"" verwendet, gefolgt vom Namen des Interfaces. Die Klasse verpflichtet sich, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten."
,Wie können Interfaces in Variablendeklarationen verwendet werden?,"Interfaces können in Variablendeklarationen als Typen verwendet werden. Der Type Checker garantiert dann, dass auf der Variable nur die Methoden aufgerufen werden können, die im Interface deklariert sind, selbst wenn das Objekt, das die Variable referenziert, mehr Methoden anbietet."
,Wie werden Konstruktoren in Java aufgerufen?,"In Java werden Konstruktoren aufgerufen, indem der Klassenname gefolgt von den Konstruktorargumenten verwendet wird, z.B., ""new MeineKlasse(argumente)""."
,Wie unterscheiden sich Streams von Collections in Java?,"Streams unterscheiden sich von Collections in Java dadurch, dass sie keine Datenspeicher sind, sondern interne Iteratoren. Jeder Stream hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen."
,Wann liefert eine Stream-Pipeline in Java ein Ergebnis?,"Eine Stream-Pipeline in Java liefert ein Ergebnis immer erst durch einen sogenannten Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert, beispielsweise eine Collection im Falle von collect."
,Wie werden parametrische (generische) Typen in Java definiert?,"Parametrische (generische) Typen in Java werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Die formalen Typparameter in der Klassendefinition können durch verschiedene Typen ersetzt werden."
,Wie können Typ-Wildcards in Java zur Verbesserung der Typsicherheit verwendet werden?,"Typ-Wildcards können verwendet werden, um sicherzustellen, dass Zuweisungen und Zugriffe auf generische Typen zur Übersetzungszeit statisch typsicher sind, ohne dass es zu Laufzeitfehlern kommt. Dies erhöht die Typsicherheit von Java-Programmen."
,"Wie können Typ-Wildcards in Java dazu verwendet werden, eine Liste von Zahlen oder Untertypen von ""Number"" zu verarbeiten?","Typ-Wildcards können verwendet werden, um eine Methode wie ""sum(List<? extends Number> list)"" zu erstellen, die eine Liste von Zahlen oder Untertypen von ""Number"" akzeptiert und die Summe der Zahlen berechnet, unabhängig von ihrem konkreten Typ."
,Wie werden Typvariablen in Java generischen Typen dargestellt?,In Java werden Typvariablen in generischen Typen in spitzen Klammern dargestellt.
,Wie sieht eine einfache Klassendefinition in Java aus?,"Eine einfache Klassendefinition in Java besteht aus dem Klassennamen, der Angabe von Instanzvariablen (Felder) und Instanzmethoden."
,"Wann werden ""final""-Variablen in Java verwendet?","""final""-Variablen werden in Java verwendet, um Konstanten zu deklarieren. Sie dürfen nur einmal einen Wert zugewiesen bekommen und sind dann nicht mehr änderbar."
,"Wie werden Ausdrücke in Java aufgebaut, und welche rekursiven Elemente sind dabei beteiligt?",Ausdrücke in Java können rekursiv aus anderen Ausdrücken aufgebaut werden. Zum Beispiel enthalten Methodenausdrücke Ausdrücke für den Empfänger und die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung von Indexen oder Größen.
,Wann werden Type casts in Java verwendet?,"Type casts werden in Java verwendet, wenn man einem Programmelement, das einen bestimmten Typ hat, einen anderen Typ zuweisen möchte oder wenn man auf Methoden oder Felder zugreifen möchte, die nicht im deklarierten Typ verfügbar sind."
,Wie vermeidet man Laufzeitfehler bei Typumwandlungen in Java?,"Man vermeidet Laufzeitfehler bei Typumwandlungen in Java mithilfe von Typtests, die vor der Typumwandlung durchgeführt werden."
,Wie können Ausdrücke zu Anweisungen in Java gemacht werden?,"In Java können Ausdrücke zu Anweisungen gemacht werden, indem sie einfach durch ein Semikolon abgeschlossen werden. Dies gilt insbesondere für Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen."
,Wie werden Werte Variablen in Java zugewiesen?,"In Java werden Werte Variablen sowohl explizit per Zuweisungsoperator ""="" als auch implizit per Methodenaufruf zugewiesen."
,Wie wird beschränkter parametrischer Polymorphismus in Java implementiert?,"In Java wird beschränkter parametrischer Polymorphismus durch das Hinzufügen von Beschränkungen für den Typparameter einer generischen Klasse oder Methode erreicht. Dies geschieht durch die Verwendung des ""extends"" oder ""super"" Schlüsselworts gefolgt von einem bestimmten Typ oder einer bestimmten Schnittstelle."
,Wie wird in Java zwischen Gleichheit und Identität von Objekten unterschieden?,"In Java wird zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) geprüft, während die Identität mittels == (bzw. !=) überprüft wird."
,Wie startet man einen neuen Thread in Java?,"Einen neuen Thread in Java startet man, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft."
,"Wie stellt man sicher, dass ein neuer Thread in Java sinnvolle Aufgaben ausführt?","Es gibt zwei Möglichkeiten, sicherzustellen, dass ein neuer Thread in Java sinnvolle Aufgaben ausführt. Entweder man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen, oder man lässt eine Klasse das Interface Runnable implementieren und implementiert die Methode run() in dieser Klasse. Dann erzeugt man eine Instanz dieser Klasse und startet deren Methode run()."
,Wie kann die Synchronisation von Threads in Java erzwungen werden?,"Die Synchronisation von Threads in Java kann auf zwei Arten erzwungen werden. Die erste Möglichkeit ist die Verwendung der synchronized-Anweisung, um einen synchronisierten Block zu erstellen. Die Anweisungen innerhalb dieses Blocks können nur von einem Thread gleichzeitig ausgeführt werden. Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren, wodurch die Sperre auf das zugehörige Objekt angewendet wird. Es ist wichtig zu beachten, dass Felder nicht als synchronized deklariert werden können."
,Wie erfolgt die Deklaration von Arrays in Java?,"Die Deklaration von Arrays in Java erfolgt implizit in Variablendeklarationen, wobei die Größe des Arrays nicht in der Deklaration festgelegt wird."
,Wie können Arrays in Java initialisiert werden?,Arrays können in Java bei ihrer Deklaration initialisiert werden. Dabei wird die Größe des Arrays automatisch festgelegt.
,Wie funktioniert die Zuweisung von Array-Variablen in Java?,"In Java haben Array-Variablen Referenzsemantik, und bei der Zuweisung wird lediglich ein Verweis auf das Array übergeben. Die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[] ist zulässig."
,"Warum ist die oben gezeigte Form der Iteration in Java nicht anwendbar, wenn Collections verwendet werden, die nicht indiziert sind?","Die oben gezeigte Form der Iteration mittels Indizes ist nicht anwendbar, wenn Collections verwendet werden, die nicht indiziert sind, da diese Collections keine numerischen Indizes für den Zugriff auf ihre Elemente bereitstellen."
,Was tut die Methode next() eines Iterator-Objekts?,"Die Methode next() eines Iterator-Objekts gibt das nächste Element der Collection zurück, über die iteriert wird."
,Wofür wird die Methode hasNext() bei der Verwendung von Iteratoren in Java eingesetzt?,"Die Methode hasNext() wird bei der Verwendung von Iteratoren in Java eingesetzt, um abzufragen, ob die Collection noch weitere Elemente enthält, die iteriert werden können."
,"Was passiert, wenn der Bindungsalgorithmus in Java zu mehreren Methoden führt, die die Bedingungen erfüllen?","Wenn der Bindungsalgorithmus zu mehreren Methoden führt, die die Bedingungen erfüllen, meldet der Compiler einen Methodenambiguitätsfehler, da die aufgerufene Methode nicht eindeutig bestimmt werden kann. Dieser Fehler wird durch Methodenaufrufe, nicht durch Methodendeklarationen, verursacht."
,In der Java-Programmierung gibt es zwei Arten von Zwischenobjekten für die Umsetzung von Zu-n-Beziehungen. Welche sind das?,In der Java-Programmierung gibt es zwei Arten von Zwischenobjekten für die Umsetzung von Zu-n-Beziehungen: Arrays und Collections.
,"Was bedeutet es, dass in Java jeder Typ ein Subtyp von Object ist?","In Java ist jeder Typ, einschließlich Klassen und Interfaces, ein Subtyp von Object. Das bedeutet, dass alle Typen in Java die Methoden und Eigenschaften erben, die in der Object-Klasse definiert sind. Dies ermöglicht eine gewisse Einheitlichkeit und Polymorphie in der Java-Programmierung. Beachten Sie jedoch, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können, obwohl sie Object erweitern."
,Warum werden Marker-Interfaces in Java manchmal durch Metadaten (Annotationen) ersetzt?,"Marker-Interfaces werden in Java manchmal durch Metadaten (Annotationen) ersetzt, da Metadaten eine flexiblere Möglichkeit bieten, Informationen über Klassen oder Methoden zu kennzeichnen, ohne zusätzliche Schnittstellen zu definieren. Annotations können zur Laufzeit oder zur Übersetzungszeit gelesen und interpretiert werden, während Marker-Interfaces nur zur Übersetzungszeit überprüft werden können. Dies bietet mehr Flexibilität und ermöglicht es, zusätzliche Informationen zu annotieren, ohne die Klassenhierarchie zu ändern."
,Warum sind Java-Programme weitgehend plattformunabhängig?,"Java-Programme sind weitgehend plattformunabhängig, da sie in Form von Bytecode vorliegen und von der JVM interpretiert werden. Solange eine JVM für ein bestimmtes Betriebssystem verfügbar ist, können Java-Programme auf jedem Rechner und Betriebssystem ausgeführt werden, für das es eine JVM gibt."
,"Warum wird darauf hingewiesen, dass Java-Programmierung oft in integrierten Entwicklungsumgebungen (IDEs) stattfindet?","Es wird darauf hingewiesen, dass Java-Programmierung oft in integrierten Entwicklungsumgebungen (IDEs) stattfindet, da diese Werkzeuge die Entwicklung erleichtern. Allerdings können IDEs aufgrund ihrer Komplexität Anfänger überwältigen."
,Warum haben Interfaces in Java seit Version 8 einen Bedeutungswandel erfahren?,"Interfaces in Java haben einen Bedeutungswandel erfahren, weil sie im Laufe der Zeit um zusätzliche Methoden erweitert wurden, was dazu führte, dass Klassen, die diese Interfaces implementieren, aktualisiert werden mussten. Insbesondere bei Black-Box-Frameworks, bei denen die Entwicklung von Anwendungsklassen in den Händen Dritter liegt, führte dies zu erheblichen Problemen."
,Was erlaubte Java 9 in Bezug auf Interfaces?,"In Java 9 wurde es erlaubt, in Interfaces auch private Methoden zu definieren. Diese privaten Methoden sind nur innerhalb des Interfaces selbst zugreifbar und dienen dazu, die Lesbarkeit von Default-Methoden zu verbessern, indem gemeinsame Teile in private Methoden ausgelagert werden können."
,"Was bedeutet es, dass Java eine klassenbasierte Programmiersprache ist, und wie unterscheidet sich dies von prototypenbasierten Sprachen?","Java ist klassenbasiert, was bedeutet, dass Programmierung durch die Definition von Klassen erfolgt. Im Gegensatz dazu sind prototypenbasierte Sprachen wie SMALLTALK auf Prototypenobjekten aufgebaut, und es gibt keine strikten Klassendefinitionen."
,"Warum ist es wichtig, zwischen öffentlichen und nicht öffentlichen (privaten) Teilen eines Moduls zu unterscheiden?","Es ist wichtig, zwischen öffentlichen und privaten Teilen eines Moduls zu unterscheiden, damit die Programmierer die Kontrolle über die Implementierung des Moduls behalten können. Indem sie sich auf eine Schnittstelle festlegen und private Teile hinter der Schnittstelle verbergen, können sie Änderungen an den verborgenen Teilen vornehmen, ohne andere Benutzer des Moduls zu beeinträchtigen."
,"Ab welcher Version von Java wurde ein Modulbegriff eingeführt, der diesen Namen verdient?","Ein Modulbegriff, der den Namen verdient, wurde mit Java 9 eingeführt, nach langer Vorbereitungszeit."
,Warum gibt es für mathematische Funktionen in Java die spezielle Klasse Math?,"Die primitiven Typen in Java sind keine Klassen, daher werden mathematische Funktionen wie sin(.) in der speziellen Klasse Math als Klassenmethoden definiert."
,Können Klassendefinitionen in Java Operatoren definieren?,"Nein, in Java ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren wie es bei den binären Methoden in SMALLTALK der Fall ist."
,Was unterscheidet Prozeduren und Funktionen in Java?,"In Java können Methoden in Prozeduren und Funktionen unterteilt werden. Der einzige Unterschied besteht darin, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp ""void"" deklarieren."
,Wozu dienen Pakete in Java?,Pakete in Java dienen der Sammlung von Klassen und dienen gleichzeitig als Namensräume für diese. Sie ermöglichen die Organisation von Klassen und bieten zugleich laxere Zugriffsbeschränkungen für Klassen innerhalb desselben Pakets.
,Warum sind Klassenliterale in Java eher selten anzutreffen?,"Klassenliterale sind in Java eher selten anzutreffen, da Klassennamen auch direkt in Java-Programmen verwendet werden können, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof""."
,Warum können nicht alle Typprüfungen in Java zur Übersetzungszeit durchgeführt werden?,"Nicht alle Typprüfungen können in Java zur Übersetzungszeit durchgeführt werden, da einige Typprüfungen erst zur Laufzeit notwendig sind und nicht im Voraus bekannt sind."
,"Was bedeutet es, wenn eine Klasse in Java als abstrakt deklariert wird?","Wenn eine Klasse in Java als abstrakt deklariert wird, bedeutet dies, dass sie nicht instanziierbar ist. Es können keine Objekte dieser Klasse erstellt werden."
,"Warum ist es eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren?","Es ist eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren, um das Prinzip der abstrakten Generalisierung zu fördern und Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien zu vermeiden."
,"Warum wird das Schlüsselwort ""abstract"" in Interfaces automatisch angenommen?","Das Schlüsselwort ""abstract"" wird in Interfaces automatisch angenommen, da Interfaces zunächst weder Implementierungen noch Objekte liefern. Sie dienen der Definition von Schnittstellen und Typen."
,Kann eine Klasse mehrere Interfaces gleichzeitig implementieren?,"Ja, eine Klasse kann mehrere Interfaces gleichzeitig implementieren, indem die entsprechenden Interface-Namen durch Kommata getrennt angegeben werden. In diesem Fall müssen die Methoden in der Klasse zumindest als abstrakt deklariert werden."
,An welches Konzept in Java ist die Typkonformität und die Zuweisungskompatibilität unter Referenztypen gebunden?,Die Typkonformität und die Zuweisungskompatibilität unter Referenztypen in Java sind an das Konzept des Subtypings gebunden.
,"Ist Java eine Sprache mit einem strengen Typsystem, und was bedeutet das?","Ja, Java ist eine Sprache mit einem strengen Typsystem, was bedeutet, dass alle Typfehler entweder während der Übersetzung durch den Compiler oder während der Laufzeit erkannt werden, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung, bei der eine Typinvariante verletzt wird."
,"Was passiert, wenn kein Konstruktor in Java definiert wird?","Wenn kein Konstruktor in Java definiert wird, verwendet Java standardmäßig den impliziten Standardkonstruktor, der parameterlos ist und eine neue Instanz der Klasse erzeugt."
,Werden Konstruktoren in Java vererbt?,"Nein, Konstruktoren werden in Java nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse automatisch aufgerufen, wenn eine Instanz einer ihrer Subklassen erzeugt wird."
,"Was passiert, wenn der Typ der geworfenen Exception nicht in einer Catch-Klausel aufgeführt ist?","Wenn der Typ der geworfenen Exception nicht in einer Catch-Klausel aufgeführt ist, wird die Exception als unbehandelt betrachtet. Die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung (""Exception in thread ..."")."
,Was unterscheidet Checked Exceptions und Unchecked Exceptions in Java?,"Der Hauptunterschied besteht darin, dass Checked Exceptions eine explizite Deklaration im Methodenkopf oder eine Behandlung innerhalb der Methode erfordern, während Unchecked Exceptions dies nicht tun. Checked Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind, während Unchecked Exceptions von Exception-Klassen abgeleitet werden, die von RuntimeException abgeleitet sind. Checked Exceptions sollen den Programmierer auf mögliche Ausnahmesituationen hinweisen, während Unchecked Exceptions oft schwer vorhersehbar sind und überall auftreten können."
,"Warum funktioniert der ursprüngliche Ansatz von Java, bei dem alle Klassen eines Programms zu einem Paket zusammengefasst werden können, nicht mehr, wenn Programme in mehrere Pakete aufgeteilt werden?","Der ursprüngliche Ansatz von Java, bei dem alle Klassen eines Programms zu einem Paket zusammengefasst werden können, funktioniert nicht mehr, wenn Programme in mehrere Pakete aufgeteilt werden, weil Abhängigkeiten zwischen den Paketen öffentliche Deklarationen erfordern, die dann jedoch alle Programmelemente für jeden sichtbar machen, was die Modularität einschränkt."
,"Was wurde mit Java 9 eingeführt, um das Problem der Modularität in Java zu lösen?","Mit Java 9 wurde ein eigenes Modulkonzept eingeführt, das über Klassen und Paketen steht. Ein Modul in Java 9 ist eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Die Moduldeklaration umfasst den Namen des Moduls, die angebotene Schnittstelle und die benötigte Schnittstelle."
,Warum führt die Zuweisung von List<Integer> zu List<Object> zu einem statischen Typfehler in Java?,"Die Zuweisung von List<Integer> zu List<Object> führt zu einem statischen Typfehler in Java, weil bei generischen Typen nicht automatisch eine Zuweisungskompatibilität zwischen unterschiedlichen generischen Typen besteht, selbst wenn die Typen, die sie parametrisieren, zueinander in Beziehung stehen. Dies erhöht die Typsicherheit zur Übersetzungszeit."
,"Warum könnte eine Parametrisierung von ""Comparable"" vorteilhaft sein?","Eine Parametrisierung von ""Comparable"" könnte vorteilhaft sein, um die Flexibilität bei der Verwendung von Vergleichen zu erhöhen. Es ermöglicht, dass Objekte mit verschiedenen, aber kompatiblen Typen miteinander verglichen werden können."
,"Was würde die Deklaration ""interface Comparable<T extends T>"" bedeuten?","Die Deklaration ""interface Comparable<T extends T>"" würde bedeuten, dass der Typparameter ""T"" vom gleichen Typ sein muss wie der Typparameter ""T"" selbst, was in der Praxis keine sinnvolle Einschränkung ist."
,"Warum ist die Bedingung, dass zu vergleichende Elemente vom gleichen Typ sein müssen, zu restriktiv?","Die Bedingung, dass zu vergleichende Elemente vom gleichen Typ sein müssen, ist zu restriktiv, weil es Fälle gibt, in denen Objekte unterschiedlicher, aber verwandter Typen miteinander verglichen werden sollen. Eine flexiblere Einschränkung ist erforderlich."
,"Was bedeutet ""Comparable<? super E>""?","""Comparable<? super E>"" bedeutet, dass der Parametertyp von ""Comparable"" mindestens ""E"" umfassen muss, kann jedoch auch allgemeiner sein, z. B. ""Object"". Das ""?"" in der Typ-Wildcard steht für einen beliebigen Typen, der die Bedingung erfüllt, in diesem Fall ein Supertyp von ""E""."
,"Warum ist ""Comparable<? super E>"" flexibler als ""Comparable<T extends T>""?","""Comparable<? super E>"" ist flexibler, weil es eine größere Bandbreite von Typen zulässt, die miteinander verglichen werden können. Es erlaubt, dass Objekte vom Typ ""E"" mit Objekten anderer, aber verwandter Typen verglichen werden, was die Verwendung von ""Comparable"" vielseitiger macht."
,Warum wurden Typ-Wildcards (Wildcard-Typen) in Java eingeführt?,"Typ-Wildcards wurden eingeführt, um eine flexiblere Form der Zuweisungskompatibilität für generische Typen zu ermöglichen, insbesondere bei der Verwendung von Collections mit unterschiedlichen Typparametern."
,"Was bedeutet es, wenn ein Typ mit einer Typ-Wildcard (z. B. List<?>) deklariert wird?","Wenn ein Typ mit einer Typ-Wildcard deklariert wird, bedeutet dies, dass die Variable dieses Typs Objekte beliebigen, aber unbekannten Typparameters akzeptieren kann. Es ist eine abstrakte Deklaration."
,"Warum sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz ""Integer"" und ""String"" als Subtypen von ""Comparable"" nicht zuweisungskompatibel mit ""ArrayList<Comparable>""?","""ArrayList<Integer>"" und ""ArrayList<String>"" sind nicht zuweisungskompatibel mit ""ArrayList<Comparable>"", weil generische Typen in Java keine kovariante Zuweisung von Subtypen erlauben. Dies wurde durch die Einführung von Typ-Wildcards gelöst."
,Warum sollten Klassenbibliotheken unabhängig von der Sprachdefinition sein und austauschbar sein?,"Klassenbibliotheken sollten unabhängig von der Sprachdefinition sein und austauschbar sein, um die Flexibilität und Portabilität von Software zu gewährleisten. Wenn Klassenbibliotheken eng an die Sprachdefinition gebunden sind, könnte dies dazu führen, dass eine Software nur auf einer bestimmten Plattform oder mit einer bestimmten Sprachversion funktioniert. Durch die Unabhängigkeit von der Sprachdefinition können Klassenbibliotheken in verschiedenen Umgebungen verwendet werden und die Softwareentwicklung erleichtern."
,Warum sind einige Klassen in Java von der Sprache fest vorgegeben und können nicht beliebig ersetzt werden?,"In Java sind einige Klassen von der Sprache fest vorgegeben, um die grundlegende Funktionalität der Sprache sicherzustellen und um sicherzustellen, dass bestimmte wichtige Aufgaben immer erfüllt werden können. Zum Beispiel sind Klassen wie Object und String integraler Bestandteil der Java-Sprache und können nicht ersetzt werden, da sie grundlegende Funktionen wie die Objekterstellung und Zeichenkettenmanipulation ermöglichen. Diese Klassen stellen die Grundlage für die Entwicklung von Java-Programmen dar und sind daher unverzichtbar."
,Warum werden in diesem Kapitel keine metasyntaktischen Variablen verwendet?,Metasyntaktische Variablen könnten aufgrund der Verwendung von spitzen Klammern für Typvariablen in Java zu Verwechselungen führen. Daher werden in diesem Kapitel keine metasyntaktischen Variablen verwendet.
,Warum wird in den kommenden Kurseinheiten Java behandelt?,"In den kommenden Kurseinheiten wird Java behandelt, da es immer noch die am weitesten verbreitete objektorientierte Programmiersprache ist und viele Parallelen zu SMALLTALK aufweist, was den Übergang zu anderen Programmiersprachen erleichtert. Es ist jedoch wichtig zu beachten, dass Java aus theoretischer Sicht keine besondere Position einnimmt, und sein Erfolg war wahrscheinlich eher auf das Internet zurückzuführen."
,"Was bedeutet es, wenn ein Member in Java als ""static"" deklariert wird?","Wenn ein Member als ""static"" deklariert wird, bedeutet dies, dass er sich nicht auf Instanzen der Klasse bezieht, sondern auf die Klasse selbst. Es handelt sich um Klassenvariablen und -methoden."
,"Warum sind ""static""-Felder in Java keine Konstanten?","""static""-Felder in Java sind nicht automatisch Konstanten, da sie mehrfach geändert werden können. Konstanten werden in Java stattdessen durch das Schlüsselwort ""final"" gekennzeichnet."
,"Was unterscheidet Call by Value und Call by Reference, und wie wird dies in Java gehandhabt?","In Java wird Call by Value verwendet, was bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Dies ist eine Einschränkung im Vergleich zu Call by Reference, bei dem eine Methode auf den ursprünglichen Wert einer Variablen zugreifen und ihn ändern kann."
,Was versteht man unter einem Type cast (Typumwandlung)?,"Ein Type cast ist der Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde."
,Warum werden Interfaces in Java als einer der wichtigsten Beiträge zur objektorientierten Programmierung angesehen?,"Interfaces in Java sind einer der wichtigsten Beiträge zur objektorientierten Programmierung, da sie die Möglichkeit bieten, Schnittstellen und Polymorphismus zu implementieren, was die Flexibilität und Erweiterbarkeit von Programmen erheblich verbessert."
,Warum ist die Aufteilung eines Programms in Module wichtig?,"Die Aufteilung eines Programms in Module ist wichtig, um die unabhängige Entwicklung von Programmteilen zu ermöglichen. Dadurch sollen Abhängigkeiten zwischen den Modulen minimiert werden, insbesondere in Bezug auf Änderungen."
,Was bedeutet Abhängigkeit zwischen Modulen in der Programmierung?,"In der Programmierung bedeutet Abhängigkeit zwischen Modulen in der Regel Änderungsabhängigkeit. Wenn sich in einem Modul etwas ändert, kann dies Auswirkungen auf andere davon abhängige Module haben. Abhängigkeiten ergeben sich oft aus Benutzungsbeziehungen und können in der objektorientierten Programmierung auch Vererbungsabhängigkeiten einschließen."
,Sind zirkuläre Abhängigkeiten zwischen Klassen in Java erlaubt?,"Ja, zirkuläre Abhängigkeiten zwischen Klassen sind in Java zunächst erlaubt. Dies bedeutet, dass sich zwei Klassen wechselseitig importieren können. Jedoch wird dies in der Softwareentwicklung vermieden, da wechselseitige Abhängigkeiten eine enge Kopplung zwischen Modulen anzeigen, die vermieden werden sollte. Für Java-Module sind zirkuläre Abhängigkeiten jedoch verboten."
,Warum sind zirkuläre Abhängigkeiten in Java-Modulen verpönt?,"Zirkuläre Abhängigkeiten in Java-Modulen sind verpönt, da sie eine enge Kopplung zwischen Modulen dokumentieren und dies vermieden werden sollte. Das Verbot zirkulärer Abhängigkeiten erfordert eine sorgfältige Planung der Modularisierung, was generell von großem Wert ist."
,"Wem obliegt es, zu definieren, was passieren soll, wenn der Typtest fehlschlägt?","Es obliegt der Programmiererin, zu definieren, was passieren soll, wenn der Typtest fehlschlägt, d.h., wenn das Objekt nicht den geforderten Typ hat."
,Wo können Typvariablen (formale Typparameter) in Java verwendet werden?,Typvariablen können sowohl in Typdefinitionen als auch in Methodendefinitionen in Java verwendet werden.
,"Warum könnte es sinnvoll sein, den Typparameter einer generischen Methode mit ""extends"" zu beschränken?","Das Beschränken des Typparameters einer generischen Methode mit ""extends"" kann sinnvoll sein, um die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte zu erhöhen, da deren Typ innerhalb der Methode bekannter ist."
,"Warum könnte es in einigen Fällen sinnvoll sein, ein Typ-Wildcard anstelle eines Typparameters in einer generischen Methode zu verwenden?","In einigen Fällen, in denen der Typparameter innerhalb der Methode nicht verwendet wird, kann es sinnvoll sein, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard in der generischen Methode zu verwenden, um den Code einfacher und lesbarer zu gestalten."
,Was bewirkt die Break-Anweisung in Java?,"Die Break-Anweisung in Java bewirkt, dass eine Schleife oder ein Switch-Statement sofort verlassen wird. Sie kann optional mit einem Label versehen werden, um eine äußere Schleife oder ein äußeres Switch-Statement zu verlassen."
,"Was bedeutet es, dass Java eine stark typisierte Sprache ist?","Java ist eine stark typisierte Sprache, was bedeutet, dass alle Ausdrücke einen Typ haben und Variablen bei ihrer Deklaration einen Typ angeben müssen."
,Was unterscheidet eine Wertzuweisung und eine Zuweisung von Referenzen in Java?,"Bei der Wertzuweisung wird der tatsächliche Wert einer Variable kopiert, während bei der Zuweisung von Referenzen nur die Referenz auf das Objekt kopiert wird."
,"Gibt es in Java ""Call by reference""?","Nein, in Java gibt es kein ""Call by reference"", sondern nur ""Call by value"". Auch wenn Variablen Referenztypen haben, wird bei Methodenaufrufen immer eine Kopie des Zeigers an die formalen Parameter übergeben."
,Warum ist beschränkter parametrischer Polymorphismus wichtig?,"Beschränkter parametrischer Polymorphismus ist wichtig, um sicherzustellen, dass die Objekte, die von einem generischen Typ erzeugt werden, bestimmte Eigenschaften oder Methoden haben. Dadurch wird die Typsicherheit erhöht und es können bestimmte Annahmen über die Objekte gemacht werden."
,"Was bedeutet die Einschränkung ""<E extends Comparable<E>>"" in der Klasse ""SortedList""?","Die Einschränkung ""<E extends Comparable<E>>"" bedeutet, dass der Typparameter ""E"" auf Typen beschränkt ist, die das Interface ""Comparable"" implementieren oder davon erben. Dies stellt sicher, dass Objekte vom Typ ""E"" die Methode ""compareTo(.)"" implementieren können, die vom Interface ""Comparable"" vorgeschrieben wird."
,"Warum wird ""SortedList<String>"" als gültige Deklaration betrachtet, aber ""SortedList<Integer>"" nicht?","""SortedList<String>"" wird als gültige Deklaration betrachtet, weil ""String"" ein Subtyp von ""Comparable"" ist und daher die Bedingung ""<E extends Comparable<E>>"" erfüllt. ""SortedList<Integer>"" wird hingegen nicht als gültige Deklaration betrachtet, da ""Integer"" nicht ""Comparable<Integer>"" implementiert, was nicht der Einschränkung entspricht."
,"Ist ""SortedList<String>"" ein Subtyp von ""SortedList<Comparable>""?","Nein, ""SortedList<String>"" ist kein Subtyp von ""SortedList<Comparable>"". Die Einschränkung ""<E extends Comparable<E>>"" in ""SortedList"" sorgt dafür, dass der Typparameter ""E"" ein Subtyp von ""Comparable<E>"" sein muss, aber sie schafft keine Subtypenbeziehung zwischen den ""SortedList""-Instanzen selbst."
,"Ist es in Java möglich, generische Variablen zu deklarieren?","Ja, es ist in Java möglich, generische Variablen zu deklarieren."
,"Was passiert, wenn eine Variable mit einem Typ-Wildcard deklariert wird?","Wenn eine Variable mit einem Typ-Wildcard deklariert wird, kann ihr eine Instanz eines beliebigen konkreten Typs zugewiesen werden, der den Anforderungen der Wildcard entspricht."
,Führen generische Variablendeklarationen einen neuen Typ ein?,"Nein, generische Variablendeklarationen führen keinen neuen Typ ein. Der durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzte Typ ist ein konkreter Typ."
,Warum ist die Verwechslung von equals(.) und == ein häufiger Programmierfehler in Java?,"Die Verwechslung von equals(.) und == ist auch in Java ein häufiger Programmierfehler, da sie unterschiedliche Bedeutungen haben. equals(.) prüft die Gleichheit von Objekten, während == die Identität überprüft."
,Wofür steht das Gleichheitszeichen = in Java?,"Das Gleichheitszeichen = in Java steht für die Wertzuweisung, nicht für die Überprüfung der Gleichheit von Objekten."
,"Was passiert standardmäßig, wenn man einen neuen Thread in Java startet?","Standardmäßig führt ein Thread in Java keine spezifischen Aufgaben aus und endet sofort. Dies geschieht, weil die Methode run() in der Klasse Thread standardmäßig leer ist."
,Was ermöglicht Java in Bezug auf Arrays in Bezug auf Wert- und Referenztypen?,"In Java ist es möglich, sowohl Arrays von primitiven (Wert-)Typen als auch von Referenztypen zu erstellen."
,Warum gestattet Java die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[]?,"Diese Zuweisungskompatibilität ermöglicht eine flexiblere Programmierung, insbesondere in Situationen, in denen der statische Typ der Array-Elemente nicht genau festgelegt ist, aber nach oben beschränkt werden soll, wie im Beispiel mit dem Interface Comparable und der Methode sort. Dieser Kompromiss zwischen statischer und dynamischer Typprüfung bietet Flexibilität beim Programmieren."
,Welche Strukturen bietet C++ im Bereich der objektorientierten Programmierung?,C++ bietet sowohl Strukturen (structs) als auch Klassen (classes) im Bereich der objektorientierten Programmierung.
,Welche Besonderheiten gibt es bei Zuweisungen von Pointervariablen in C++?,"Bei Zuweisungen von Pointervariablen muss man sich in C++ genau überlegen, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen möchte. C++ verwendet standardmäßig ""Call by value"" für Methodenaufrufe, was bedeutet, dass Kopien von Parametern übergeben werden."
,Was ist die Grundlage für die Übertragung von Parametern in C++-Methodenaufrufen?,"In C++-Methodenaufrufen erfolgt die Übertragung von Parametern standardmäßig durch ""Call by value"", was bedeutet, dass Kopien der Parameter übergeben werden."
,Was ist Generizität in C-Sharp?,"Generizität in C-Sharp ermöglicht es, parametrischen Polymorphismus sowohl für Klassen als auch für Methoden zu nutzen. Sie erlaubt die Definition von generischen Klassen und Interfaces, die eine Menge von Typen spezifizieren, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen."
,Welche Arten von Generizität werden in C-Sharp unterstützt?,"C-Sharp unterstützt sowohl beschränkte als auch unbeschränkte parametrische Polymorphismus für Klassen und Methoden. Dies bedeutet, dass Typparameter sowohl eingeschränkte (mit bestimmten Anforderungen) als auch unbeschränkte (ohne Anforderungen) Typen sein können."
,Welche Vorteile bietet die Typexpansion in C-Sharp für Werttypen?,"Die Typexpansion in C-Sharp ermöglicht es, generische Klassen für Werttypen ohne Boxing/Unboxing zu optimieren. Dies führt zu besserer Leistung und geringerem Overhead, da der JIT-Compiler den Code für verschiedene Typen optimieren kann."
,Welche Freiheit bietet der Präprozessor in C++?,"Der Präprozessor in C++ bietet die Freiheit, die Syntax der Sprache durch Hinzufügen einer neuen Syntax zu verändern. Dies ermöglicht es, Code in einer für Entwickler verständlicheren Weise zu schreiben, wenn gewünscht."
,Was sind explizite Interfaceimplementierungen in C-Sharp?,"Explizite Interfaceimplementierungen in C-Sharp ermöglichen es einer Klasse, die gleiche Methodendeklaration von verschiedenen Interfaces getrennt voneinander zu implementieren. Dies wird durch die Angabe des Interfacequalifikators vor der Methode erreicht."
,Welchen Nutzen haben explizite Interfaceimplementierungen in C-Sharp?,"Der Nutzen von expliziten Interfaceimplementierungen liegt darin, dass die Methode je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Dies ermöglicht es, verschiedene Verhaltensweisen für denselben Methodennamen in verschiedenen Kontexten zu definieren."
,Welche Arten von Vererbung erlaubt EIFFEL?,"EIFFEL erlaubt Mehrfachvererbung, was bedeutet, dass eine Klasse von mehreren anderen Klassen erben kann."
,Welches Schlüsselwort wird in EIFFEL für abstrakte Klassen verwendet?,"In EIFFEL wird das Schlüsselwort ""deferred"" anstelle von ""abstract"" für abstrakte Klassen verwendet."
,"Was ist in EIFFEL nicht erlaubt, was das Überladen von Methoden betrifft?","In EIFFEL ist es nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt."
,Was ist die Just-in-time-(JIT-)Kompilierung in C-Sharp und wie unterscheidet sie sich von Java?,"In C-Sharp ist die Just-in-time-(JIT-)Kompilierung die Standardmethode zur Übersetzung des CIL-Codes in Maschinencode. Dieser Vorgang erfolgt unmittelbar vor der Ausführung und nur dann, wenn der Code tatsächlich ausgeführt wird. Im Gegensatz dazu verwendet Java normalerweise den Ahead-of-time-(AOT-)Kompilierungsansatz, bei dem der Bytecode vor der Ausführung in nativen Maschinencode übersetzt wird. Die JIT-Kompilierung in C-Sharp ermöglicht eine feinere Granularität, da sie bis auf die Ebene einzelner Methoden herabgeht."
,Welche Unterschiede gibt es in Bezug auf die Garbage Collection zwischen C-Sharp und Java?,"In C-Sharp haben Entwickler die Möglichkeit, den Speicherplatz für Objekte, die mit ""new"" erstellt wurden, manuell freizugeben. Dies kann jedoch zu Speicherlecks führen, wenn Entwickler vergessen, den Speicher freizugeben, oder zu Problemen, wenn auf freigegebene Objekte weiterhin Referenzen vorhanden sind. Im Gegensatz dazu verwendet Java normalerweise eine automatische Garbage Collection, bei der nicht mehr benötigte Objekte automatisch erkannt und freigegeben werden."
,"Welche Spracherweiterungen, die später in Java eingeführt wurden, gab es bereits in C-Sharp?","In C-Sharp gab es von Anfang an sogenannte ""Attributes"" (Attribute), die in Java in der Version 5 als ""Annotationen"" Einzug hielten. C-Sharp führte auch bereits ab Version 3.0 Lambda-Ausdrücke ein, während Java erst mit Version 8 nachzog."
,Was ist ein herausragendes Merkmal von EIFFEL in Bezug auf Zusicherungen (Assertions)?,"Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Anders als in Java, wo Zusicherungen flexibel platziert werden können, gibt es in EIFFEL spezielle vorgesehene Stellen für diese Zusicherungen."
,"Welche Schlüsselwörter werden in EIFFEL verwendet, um Vor- und Nachbedingungen für Methoden zu definieren?","In EIFFEL werden die Schlüsselwörter ""require"" (vor der Implementierung der Methode) und ""ensure"" (nach der Implementierung der Methode) verwendet, um Vor- und Nachbedingungen für Methoden zu definieren."
,Was sind Klasseninvarianten in EIFFEL?,"Klasseninvarianten in EIFFEL sind Bedingungen, die zwischen zwei Methodenaufrufen in einer Klasse immer gelten müssen. Sie werden mit dem Schlüsselwort ""invariant"" deklariert und sind sozusagen eine Zusammenfassung von Vor- und Nachbedingungen, die für die Klasse als Ganzes gelten."
,Welche Rolle nimmt EIFFEL unter den behandelten Sprachen ein?,"EIFFEL nimmt eine besondere Position unter den behandelten Sprachen ein, da es mehrere Funktionen erfüllt: Es dient als Sprache für objektorientierte Analyse und Design, für kommerzielle Programmierung und als akademische Lehrsprache."
,Was ist das herausragende Merkmal von EIFFEL und wie trägt es zu seiner Multifunktion bei?,"Das herausragende Merkmal von EIFFEL ist die Integration von Zusicherungen (Vorbedingungen, Nachbedingungen und Klasseninvarianten), die als Verträge zwischen Klassen dienen können. Dies ermöglicht eine Spezifikation des ""Was"" einer Software unabhängig vom ""Wie"". Es erlaubt, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sich auf andere Werte und den zeitlichen Verlauf beziehen können. Diese Funktion trägt zu seiner Multifunktion bei, da sie verschiedene Anwendungsbereiche unterstützt."
,"Welche Abweichungen gibt es in EIFFEL im Vergleich zu anderen Sprachen, und warum sind sie vorhanden?","Obwohl EIFFEL syntaktisch Ähnlichkeiten zu anderen Sprachen wie PASCAL aufweist, gibt es einige Abweichungen. Diese Abweichungen sind jedoch gut begründet und bieten eine alternative Perspektive auf vertraute Konzepte. Sie tragen dazu bei, klarere und orthogonalere Konzepte zu schaffen."
,Was ist das Common Type System (CTS) in C-Sharp und warum ist es wichtig?,"Das Common Type System (CTS) ist ein Teil des .NET-Frameworks und sorgt dafür, dass Typen, die in verschiedenen .NET-Sprachen definiert wurden, gemeinsam genutzt werden können. Es stellt sicher, dass Typen in einer einheitlichen Hierarchie organisiert sind und in verschiedenen .NET-Sprachen verwendet werden können, als wären sie in der jeweiligen Sprache selbst definiert worden. Dies erleichtert die Interoperabilität zwischen verschiedenen .NET-Sprachen und ermöglicht es, Bibliotheken und Komponenten in verschiedenen Sprachen zu verwenden."
,Welche Arten von Werttypen gibt es in C-Sharp?,"In C-Sharp gibt es verschiedene Arten von Werttypen, darunter die primitiven Typen (z. B. int, bool, double), Aufzählungstypen (enum) und vom Entwickler definierte Werttypen. Werttypen werden in C-Sharp mit dem Typkonstruktor ""struct"" erstellt und können Methoden und Konstruktoren haben, jedoch erlauben sie keine Typerweiterung oder Vererbung."
,Welche Arten von Referenztypen gibt es in C-Sharp?,"In C-Sharp gibt es verschiedene Arten von Referenztypen, darunter Klassen, Interfaces, Arrays, Delegates und Attribut-Typen. Diese Referenztypen ermöglichen eine größere Vielfalt an Programmierkonzepten und -strukturen in C-Sharp."
,Was sind Delegates in C-Sharp und wozu dienen sie?,"Delegates in C-Sharp sind Zeiger auf an ein Objekt gebundene einzelne Methoden. Sie ermöglichen es, Funktionen und Methoden als Parameter an andere Funktionen oder Methoden zu übergeben, was besonders nützlich für Problemstellungen wie Listener-Mechanismen ist. Delegates ersetzen die aus anderen Sprachen bekannten Funktionszeiger oder Funktionspointer."
,Was ist Runtime Type Information (RTTI) in C++?,"Runtime Type Information (RTTI) ist eine Funktion in C++, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. RTTI ermöglicht die Ermittlung des Typs eines Objekts zur Laufzeit."
,Was ist die Funktion dynamic_cast in C++?,"Die Funktion dynamic_cast<T>(x) in C++ nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt. Andernfalls gibt sie 0 zurück."
,Was sind Zugriffsmethoden in EIFFEL und wofür werden sie verwendet?,"Zugriffsmethoden in EIFFEL sind Methoden, die verwendet werden, um auf private Instanzvariablen (Attribute) zuzugreifen. Sie dienen dazu, den Zugriff auf diese Variablen zu kontrollieren und bieten die Möglichkeit, Vor- und Nachbedingungen festzulegen."
,Welche Aufgaben können Zugriffsmethoden in EIFFEL erfüllen?,"Neben dem Lesen und Setzen von Instanzvariablen können Zugriffsmethoden in EIFFEL auch andere Aufgaben erfüllen, wie das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen."
,Was sind Features in EIFFEL und wie werden sie zusammengefasst?,"In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als ""Features"" bezeichnet. Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL."
,Was ist das Besondere an der Definition einer Schnittstelle in EIFFEL?,"Die Definition einer Schnittstelle in EIFFEL ist recht unspezifisch. Alle Klienten einer Klasse haben standardmäßig das gleiche Bild von ihr. Statt den Zugriff an Pakete oder Freunde zu binden, bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (exportieren)."
,Was ist das Programmiermodell von EIFFEL?,"Das Programmiermodell von EIFFEL ist rein objektorientiert, bei dem der gesamte Code in Klassen organisiert ist. Diese Klassen können separat übersetzt werden, und die Ausführung erfolgt direkt auf der Zielmaschine."
,Welche Methode verwendet EIFFEL zur Speicherfreigabe?,EIFFEL verwendet Garbage Collection zur Speicherfreigabe.
,Welche Art der Vererbung bietet C++ in Bezug auf Mehrfachvererbung?,"C++ bietet uneingeschränkte Mehrfachvererbung, was bedeutet, dass eine Klasse von mehreren anderen Klassen erben kann."
,Was ist ein Nachteil der Mehrfachvererbung in C++?,"Ein Nachteil der Mehrfachvererbung in C++ ist, dass das Erben nicht selektiv erfolgt, und das Löschen von geerbten Membern nicht möglich ist. Dies führt oft dazu, dass Klassen in viele kleine Teile aufgespalten werden, um unnötigen Ballast zu vermeiden."
,"Welches Problem kann auftreten, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements erbt?","Wenn eine Klasse in C++ von mehreren anderen Klassen verschiedene Definitionen desselben Elements (z. B. eines Feldes oder einer Methode) erbt, muss die Klasse sich für eine der beiden Definitionen entscheiden, und die andere geht verloren. Dies kann zu unerwartetem Verhalten führen, insbesondere im Zusammenhang mit dynamischem Binden und offener Rekursion."
,Welche praktischen Probleme können sich aus der Mehrfachvererbung in C++ ergeben?,"Die Mehrfachvererbung in C++ kann zu zahlreichen praktischen Problemen führen, darunter die Auswahl von geerbten Definitionen, Konflikte bei gleichen Elementen in verschiedenen Elternklassen und unerwartetes Verhalten im Zusammenhang mit dynamischem Binden. Weitere Probleme können auftreten, sind jedoch in diesem Abschnitt nicht näher erläutert."
,"Welche Gemeinsamkeiten gibt es zwischen C-Sharp und Java in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen?","C-Sharp und Java weisen in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen viele Gemeinsamkeiten auf. Die grundlegende Syntax und Struktur der beiden Sprachen sind ähnlich. In beiden Sprachen werden Klassen verwendet, um Objekte zu erstellen, Variablen und Ausdrücke zu definieren, Anweisungen auszuführen und Kontrollstrukturen zu steuern."
,"Welche Besonderheit gibt es in C-Sharp in Bezug auf die Überladung von Operatoren, und wie wird sie umgesetzt?","In C-Sharp ist es möglich, Operatoren wie +, -, == usw. zu überladen. Dies wird durch das Schlüsselwort ""operator"" ermöglicht, das in einer Operatordefinition vorangestellt wird. Die Überladung von Operatoren erfolgt ähnlich wie die Definition von Methoden, aber anstelle von Methodennamen werden die Operatorzeichen verwendet."
,"Was ist ""Call by reference"" in C-Sharp, und wie unterscheidet es sich von ""Call by value""?","In C-Sharp ermöglicht ""Call by reference"" (auch als ""ref"" und ""out"" bekannt) das Übergeben von Argumenten an Methoden, bei denen die Änderungen an den Parametern innerhalb der Methode auf die ursprünglichen Argumente außerhalb der Methode angewendet werden. Im Gegensatz dazu verwendet ""Call by value"" Kopien der Argumente, und Änderungen innerhalb der Methode haben keine Auswirkungen auf die ursprünglichen Argumente."
,"Was sind die Unterschiede zwischen ""ref"" und ""out"" in Bezug auf Methodenparameter in C-Sharp?","In C-Sharp werden ""ref"" und ""out"" verwendet, um formale Parameter zu kennzeichnen, die durch den Methodenaufruf modifiziert werden können. Der Hauptunterschied besteht darin, dass bei ""ref"" die übergebene Variable vor dem Aufruf initialisiert sein muss, während bei ""out"" dies nicht erforderlich ist. Bei ""out"" muss jedoch die formale Parameter in der Methode selbst einen Wert zugewiesen bekommen. Beide ermöglichen mehrere Rückgabewerte für Methoden."
,Welche Unterschiede gibt es zwischen der Überschreibung von Methoden in C-Sharp im Vergleich zu Java?,"In C-Sharp müssen dynamisch zu bindende Methoden als ""virtual"" deklariert werden, und überschreibende Methoden müssen mit ""override"" gekennzeichnet sein. Wenn eine Methode in einer Subklasse neu eingeführt werden soll, wird ""new"" verwendet. Dies unterscheidet sich von Java, wo Methoden standardmäßig überschrieben werden können, es sei denn, sie sind als ""final"" deklariert. Diese Unterschiede sollen das sogenannte ""Fragile-base-class-Problem"" verhindern und die Programmiererin darüber informieren, welche Methoden dynamisch gebunden werden und welche nicht."
,Welche anderen Unterschiede und Konventionen gibt es zwischen C-Sharp und Java in Bezug auf Sprachkonstrukte?,"Einige Unterschiede und Konventionen zwischen C-Sharp und Java umfassen die Verwendung von ""lock"" anstelle von ""synchronized"" für die Synchronisation, die Verwendung von ""foreach"" anstelle von ""for"" für bestimmte Schleifen, die Möglichkeit, ""Strings"" als Basis einer ""Switch""-Anweisung zu verwenden, und die Anforderung, dass jeder Zweig (case) einer ""Switch""-Anweisung mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen sein muss. C-Sharp verfügt auch über eine ""Goto""-Anweisung, die jedoch nicht in Blöcke springen kann."
,Was sind Indexer in C-Sharp und wie ähneln sie Properties?,"Indexer in C-Sharp sind eine Möglichkeit, auf indizierte Instanzvariablen zuzugreifen, ähnlich dem Konzept der indizierten Instanzvariablen in SMALLTALK. Jede Instanz einer Klasse mit einem Indexer hat eine Menge von indizierten Instanzvariablen, auf die über einen Index zugegriffen werden kann. Indexer verwenden Get- und Set-Methoden, um den Zugriff auf diese indizierten Variablen zu ermöglichen. Sie ähneln Properties insofern, als der Zugriff über einen Index mithilfe von Get- und Set-Abbildungen auf eine benannte Instanzvariable übertragen wird."
,Welche Schwierigkeit ergibt sich aus der kovarianten Redefinition?,"Durch die kovariante Redefinition wird bei einem Funktionsaufruf von ""share"" dynamische Bindung verwendet, was dazu führt, dass ein Objekt vom Typ ""GIRL"" einem ""BOY"" zugewiesen wird. Dies führt zu einem Programmfehler, da das Programm nicht mehr typkorrekt ist."
,Welche Unterschiede gibt es im Typsystem von EIFFEL im Vergleich zu anderen Sprachen wie Java?,"Im Gegensatz zu Java besitzt EIFFEL ein einheitliches Typsystem, bei dem keine separaten Referenz- und Werttypen unterschieden werden. EIFFEL unterscheidet auch nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden. Alle Operationen, einschließlich derer auf eingebauten Typen wie Integern, werden als Methoden behandelt."
,Was ist ein herausragendes Merkmal des Typsystems von EIFFEL?,"Ein herausragendes Merkmal des Typsystems von EIFFEL ist die Unterstützung von Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden), sowie kovariante Redefinitionen, die durch ""verankerte Typen"" ermöglicht werden."
,"Welche Bedeutung haben ""verankerte Typen"" im Kontext von kovarianten Redefinitionen in EIFFEL?","""Verankerte Typen"" (engl. ""anchored types"") spielen im Kontext von kovarianten Redefinitionen in EIFFEL eine wichtige Rolle. Sie ermöglichen es, die Kovarianz bei der Redefinition von Methoden zu unterstützen und sind eine besondere Eigenschaft von EIFFEL."
,Was sind einige der Eigenschaften des Typsystems von EIFFEL?,"Einige der prominenten Eigenschaften des Typsystems von EIFFEL sind Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen sowie die Unterstützung kovarianter Redefinitionen durch ""verankerte Typen""."
,Welche Arten von Anweisungen gibt es in EIFFEL?,"In EIFFEL gibt es Anweisungen, die aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung bestehen."
,Welche Prinzipien der Programmierung werden von EIFFEL strikt eingehalten?,"EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat."
,Welche Besonderheit bietet das Exception Handling in EIFFEL?,"EIFFEL bietet ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet, insbesondere erlaubt es ein ""Retry"", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss."
,Was ist die Besonderheit bezüglich der Verwendung des Semikolons in EIFFEL?,"In EIFFEL dient das Semikolon als Trennzeichen und ist kein Bestandteil einer Anweisung. Darüber hinaus kann es am Ende einer Zeile auch weggelassen werden, was dazu führt, dass kleine EIFFEL-Programme optisch aufgeräumt wirken."
,Was sind Properties in C-Sharp und wie unterscheiden sie sich von Zugriffsmethoden (Settern und Gettern)?,"Properties in C-Sharp sind eine Möglichkeit, auf die Felder eines Objekts zuzugreifen, indem Methoden aufgerufen werden, die wie Feldzugriffe aussehen. Sie sind die Umkehrung von Zugriffsmethoden (Settern und Gettern) und ermöglichen es, Feldzugriffe mit Nebeneffekten zu versehen. In C-Sharp werden die Schlüsselwörter ""get"" und ""set"" verwendet, wobei ""get"" für den Lesezugriff und ""set"" für den Schreibzugriff verwendet wird. Die Variable ""value"" wird verwendet, um den Eingabewert eines Setters zu halten."
,Welche Vorteile bieten Properties in C-Sharp im Vergleich zu direktem Feldzugriff?,"Properties in C-Sharp bieten den Vorteil, dass sie Feldzugriffe mit zusätzlicher Logik und Validierung versehen können. Sie machen den Code auf der Aufruferinnenseite knapper und besser lesbar, da sie wie Feldzugriffe aussehen und die Details der Implementierung verbergen. Außerdem ermöglichen sie die Simulation von Feldern mit Nur-Lese- oder Nur-Schreib-Zugriff, indem entweder der Getter oder der Setter weggelassen wird."
,"Was ist die spezielle Variable ""value"" in einem Property-Setter?","Die spezielle Variable ""value"" in einem Property-Setter enthält den Eingabewert, der beim Setzen des Property-Werts übergeben wurde. Sie ermöglicht es, den neuen Wert zu verarbeiten und in das entsprechende Feld oder die entsprechende Variable zu schreiben. Dies ist besonders nützlich, um Validierungen oder Transformationen beim Schreibzugriff durchzuführen."
,Welche Rolle spielt der Zuweisungsversuch bei kovarianten Redefinitionen in EIFFEL?,"Der Zuweisungsversuch spielt eine Rolle bei kovarianten Redefinitionen in EIFFEL, da er verwendet wird, um dynamische Bindungen programmatisch zu emulieren. Da EIFFEL polymorphe CAT-Calls verbietet, werden Zuweisungsversuche genutzt, um das dynamische Binden zu ermöglichen."
,Welche Unterschiede gibt es zwischen Zuweisungsversuchen in EIFFEL und Downcasts in Java?,"Ein Unterschied besteht darin, dass Zuweisungsversuche in EIFFEL keinen Laufzeitfehler verursachen können, im Gegensatz zu Downcasts in Java. Allerdings kann ""void"" in einer Variable in EIFFEL zur Laufzeit eine Nullzeiger-Ausnahme auslösen."
,Welche Rolle spielt die kovariante Redefinition in EIFFEL?,"In EIFFEL kann die kovariante Redefinition verwendet werden, um den Typ von Variablen automatisch mit dem Typ eines anderen, bereits typisierten Programms zu verknüpfen. Dies ermöglicht die automatische Anpassung von Typen bei Vererbung."
,Welche Probleme ergeben sich aus der Verwendung von kovarianten Redefinitionen in EIFFEL?,"Die Verwendung von kovarianten Redefinitionen in EIFFEL kann zu Problemen führen, insbesondere wenn dynamische Bindungen auftreten. Dies kann dazu führen, dass Typen inkonsistent werden und unerwartetes Verhalten auftritt."
,Welche Rolle spielen verankerte Typdeklarationen in EIFFEL?,"Verankerte Typdeklarationen in EIFFEL ermöglichen es, den Typ von Variablen automatisch an den Typ eines bereits typisierten Programms zu binden. Dies erleichtert die Verwendung von kovarianten Redefinitionen."
,Was sind Tupel in EIFFEL und wofür werden sie verwendet?,"Tupel sind in EIFFEL eine relativ neue Funktion, die es ermöglicht, mehrere Objekte ohne die Notwendigkeit der Definition einer eigenen Klasse zu gruppieren. Sie sind besonders nützlich, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugewiesen wird. Tupel werden oft verwendet, wenn Methoden mehrere Werte zurückgeben sollen."
,Welche Rolle spielen die Positionen und Positionsnamen in Tupeln?,"In Tupeln spielen die Positionen und gegebenenfalls die Positionsnamen eine wichtige Rolle. Sie dienen dazu, die Struktur des Tupels festzulegen und die Werte den richtigen Positionen zuzuordnen. Die Zuordnung eines Tupels zu einem Tupeltyp erfolgt durch den Abgleich der vorhandenen Positionen mit den deklarierten Positionstypen sowie gegebenenfalls den Positionsnamen."
,Was ist das Friends-Konzept in C++?,"Das Friends-Konzept in C++ ermöglicht es, dass bestimmte Klassen auf private Elemente einer anderen Klasse zugreifen können, ohne direkte Mitglieder dieser Klasse zu sein."
,Welchen Nachteil hat die Verwendung von Paketen in Java für die Zusammenarbeit von Klassen?,"In Java hatte man bis zur Version 8 die Möglichkeit, Klassen in ein Paket zu verfrachten, um die Zusammenarbeit von Klassen zu ermöglichen. Der Nachteil dabei ist, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben, was die Aufteilung der Klassen auf Pakete einschränken kann."
,Welche Antwort auf Java stellt C-Sharp dar?,C-Sharp ist Microsofts Antwort auf Java.
,"Was sind einige der zusätzlichen Merkmale von C-Sharp, die es im Vergleich zu Java enthält?","C-Sharp enthält einige zusätzliche Merkmale von C++ sowie von Microsofts hauseigener Sprache, Visual Basic."
,"Was sind einige der Unterschiede im Typsystem von C-Sharp, die im Text erwähnt werden?",Im Text werden die folgenden Unterschiede im Typsystem von C-Sharp im Vergleich zu Java erwähnt: Die Unterscheidung von Wert- und Referenztypen. Die verschiedenen Typkonstruktoren für Wert- und Referenztypen. Der Umgang mit Interfaces als Typen.
,Welche weiteren Verbesserungen im Zusammenhang mit dem Typsystem von C-Sharp werden im Text erwähnt?,"Im Text wird erwähnt, dass C-Sharp noch eine ganze Reihe weiterer Verbesserungen im Zusammenhang mit dem Typsystem aufweist, jedoch wird auf diese Verbesserungen hier nur am Rande eingegangen, ohne sie im Detail zu erläutern."
,Welches Programmiermodell wird in C++ verwendet?,"Das Programmiermodell von C++ ist ein klassisches Modell, bei dem Programme als eine Menge von Quellcode-Dateien geschrieben werden, die auf einer Zielmaschine direkt in ausführbaren Maschinencode übersetzt werden."
,"Was ist das Ziel von C++ in Bezug auf die Art von Anwendungen, die es unterstützt?","C++ zielt auf die gleiche Klasse von Anwendungen wie C ab, insbesondere maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen, wobei extreme Speicher- und Recheneffizienz oft oberste Kriterien sind."
,Was ist das Ziel des Typsystems von C++?,"Das Ziel des Typsystems von C++ ist, objektorientierte Programmierung mit starker Typsicherheit zu ermöglichen, während gleichzeitig die volle Freiheit der Programmiererin erhalten bleibt und der Laufzeit-Overhead minimiert wird."
,Welche primitive Datentypen gibt es in C++?,"In C++ gibt es primitive Datentypen wie int, bool, etc. Diese Datentypen sind genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik."
,Was ist ein Typumwandlung (Type cast) in C++?,"Eine Typumwandlung (Type cast) in C++ ist ein Ausdruck der Form <Typ> <Ausdruck>, der den Compiler davon überzeugt, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Diese Umwandlung wird vom Compiler überwacht, und die Zulässigkeit wird zur Laufzeit überprüft."
,Welche Eigenschaften sollte eine typsichere Sprache haben?,"Eine typsichere Sprache wie C-Sharp soll strikte Typprüfungen durchführen, um sicherzustellen, dass Variablen nur Werte akzeptieren, die ihrem deklarierten Typ entsprechen."
,Welcher Operator in C-Sharp entspricht dem instanceof-Operator in Java?,"In C-Sharp entspricht der Operator is dem instanceof-Operator in Java. Er prüft, ob das Ergebnis der Auswertung eines Ausdrucks mit einem gegebenen Typ T zuweisungskompatibel ist."
,Wie werden Klassenfelder und -methoden in C++ deklariert?,"Klassenfelder und -methoden werden in C++ mit dem Schlüsselwort ""static"" in einer Klasse eingeführt, ähnlich wie in Java."
,Wie erfolgt die Erzeugung von Objekten in C++ im Vergleich zu Java?,"In C++ erfolgt die Erzeugung von Objekten oft ohne ""new"". Der benötigte Speicherplatz wird bei der Deklaration reserviert, und es entstehen Werte (Objekte) mit Wertsemantik, im Gegensatz zu Java, wo ""new"" verwendet wird."
,Wie erzeugt man in C++ Objekte mit Identität?,"Um in C++ Objekte mit Identität zu erzeugen, muss man Zeigervariablen (Pointer) verwenden und eine Klasse mit dem ""new""-Operator instanziieren."
,Wie sieht die Dereferenzierung eines Zeigers auf ein Objekt in C++ aus?,"In C++ erfolgt die Dereferenzierung eines Zeigers auf ein Objekt mit ""->"", z.B., ""a->x"" oder ""a->f(x)"" für ein Feld oder eine Methode der Klasse."
,"Wie kann in C++ ""Call by reference"" erreicht werden?","In C++ kann ""Call by reference"" erreicht werden, indem man den Zeigeroperator ""&"" verwendet und die formalen Parameter so deklariert, dass sie Zeiger auf Zeiger aufnehmen können."
,Wie wird das Varianzproblem bei der Subtypisierung von Containern in C-Sharp gelöst?,"In C-Sharp wird das Varianzproblem bei der Subtypisierung von Containern durch das Hinzufügen des Schlüsselworts ""out"" für kovariante Typparameter und ""in"" für kontravariante Typparameter bei der Definition des Typs gelöst. Dies stellt sicher, dass Zuweisungskompatibilität auch dann gegeben ist, wenn die generischen Typen verschiedene Typparameter haben."
,"Wie hat Microsoft versucht, das Problem der Kommunikation mit unbekannten Objekten auf der Ebene der Programmiersprache zu lösen?","Microsoft hat versucht, das Problem der Kommunikation mit unbekannten Objekten teilweise von der Ebene der Programmierung auf die Ebene der Programmiersprache zu heben, indem sie das Konstrukt des Events (Ereignisses) eingeführt haben. Über Ereignisse können sogenannte Eventhandler aktiviert werden, die auf unerwartete Ereignisse reagieren können. Dies wurde mithilfe von Delegates realisiert, wie im Abschnitt 50.4.1 skizziert."
,"Wie wird in C-Sharp sichergestellt, dass explizite Interfaceimplementierungen von außen aufgerufen werden?","In C-Sharp muss der tatsächliche deklarierende Typ des Objekts als Qualifikator für den Methodenaufruf angegeben werden, um sicherzustellen, dass die richtige explizite Interfaceimplementierung aufgerufen wird."
,Wie werden in EIFFEL überschriebene Methoden bezeichnet?,"In EIFFEL werden überschriebene Methoden als ""Redefinition"" bezeichnet."
,Wie können in EIFFEL Methoden mit demselben Namen in verschiedenen Klassen behandelt werden?,"In EIFFEL ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben, solange diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen. Wenn die Methoden gleiche oder kovariant redefinierte Parameter haben, handelt es sich nicht um Überladung, sondern um Überschreibung."
,"Wie kann in EIFFEL sichergestellt werden, dass geerbte Features mit demselben Namen unterschiedlich benannt werden?","EIFFEL ermöglicht es, geerbte Features umzubenennen, indem eine ""Rename""-Klausel verwendet wird. Diese Klausel erlaubt es, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen, ohne das dynamische Binden zu beeinflussen."
,Wie unterscheidet sich das Programmiermodell von C-Sharp von dem von Java?,"Das Programmiermodell von C-Sharp weist zunächst einige Ähnlichkeiten mit dem von Java auf, da es ebenfalls auf Klassen basiert und der Code in einzelnen Klassen organisiert ist. Die Klassen in C-Sharp können jedoch in lockererem Verhältnis zu Dateien stehen, und Klassen können anders benannt werden als ihre Dateien. Ein wesentlicher Unterschied besteht darin, dass der Bytecode von C-Sharp und die zugehörige virtuelle Maschine, Common Intermediate Language (CIL) genannt, für alle .NET-Sprachen entwickelt wurden und nicht exklusiv für C-Sharp. Die CIL gilt als menschenlesbar."
,Wie werden Vor- und Nachbedingungen in EIFFEL formuliert?,"Vor- und Nachbedingungen in EIFFEL werden als Boolesche Ausdrücke formuliert, die immer als ""wahr"" ausgewertet werden müssen. Die ""require""-Klausel stellt Bedingungen dar, die vor dem Aufruf der Methode erfüllt sein müssen, während die ""ensure""-Klausel Bedingungen darstellt, die nach dem Aufruf der Methode garantiert erfüllt sind."
,"Wie werden Zusicherungen in EIFFEL vererbt, insbesondere wenn eine Methode redefiniert wird?","Zusicherungen, einschließlich Vor- und Nachbedingungen, werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen die Zusicherungen angepasst werden, jedoch mit bestimmten Einschränkungen. Die Vorbedingung darf nur abgeschwächt und die Nachbedingung nur verschärft werden, und die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingungen eingehalten werden."
,"Wie kann RTTI in C++ verwendet werden, um den Typ eines Objekts zu ermitteln?","RTTI kann verwendet werden, indem die Funktion typeid auf eine Referenz aufgerufen wird. Diese Funktion ist auf Klassennamen überladen und gibt eine Struktur zurück, auf der == als Gleichheitstest definiert ist. Der Typ eines Objekts kann überprüft werden, indem typeid(x) == typeid(T) verwendet wird."
,"Wie kann in C++ ohne Verwendung von typeid herausgefunden werden, welcher Klasse Instanzen aller Klassen angehören?","Eine Möglichkeit, den Typ einer Klasse in C++ ohne Verwendung von typeid herauszufinden, ist die Verwendung von dynamic_cast. Man kann versuchen, das Objekt auf verschiedene Klassen zu überprüfen, und wenn das Casting erfolgreich ist, gehört das Objekt zu dieser Klasse."
,Wie werden Zugriffsmethoden in EIFFEL syntaktisch dargestellt?,"Zugriffsmethoden in EIFFEL sehen syntaktisch aus wie Variablen, können jedoch Funktionen (Setter) oder Funktionen (Getter) sein. Sie können verwendet werden, um Werte zu setzen oder zu lesen."
,Wie werden in EIFFEL Abfragen und Befehle logisch unterteilt?,"In EIFFEL werden Methoden einer Klasse als ""Abfragen"" (queries) und ""Befehle"" (commands) logisch unterteilt. Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern."
,Wie wird der Zugriff auf Features in EIFFEL kontrolliert?,"In EIFFEL wird der Zugriff auf Features durch die gezielte Veröffentlichung (Export) von Features gesteuert. Klassen, die auf diese Features zugreifen sollen, werden explizit genannt."
,Wie unterscheidet sich EIFFEL von C++ in Bezug auf die Ausführungsumgebung?,"Im Gegensatz zu C++ führt EIFFEL den Code nicht auf einer virtuellen Maschine aus, sondern direkt auf der Zielmaschine. Es gibt jedoch auch eine Version von EIFFEL für .NET, die in CIL übersetzt und dann in Maschinencode ausgeführt wird."
,Wie wird EIFFEL als Sprache häufig charakterisiert?,"EIFFEL wird als eine akademische Sprache charakterisiert, was bedeutet, dass sie in erster Linie in der akademischen Welt verwendet wird und möglicherweise weniger in kommerziellen Anwendungen anzutreffen ist."
,Wie wird in EIFFEL ein Typtest durchgeführt?,"In EIFFEL wird ein Typtest mithilfe eines ""Zuweisungsversuchs"" (engl. ""assignment attempt"") durchgeführt. Wenn es keine Zuweisungskompatibilität zwischen den Typen gibt, wird ""void"" (entsprechend ""nil"" in SMALLTALK oder ""null"" in Java) zugewiesen. Die Programmiererin muss dann den Typ von ""a"" nach der Zuweisung überprüfen."
,Wie definiert EIFFEL unparametrisierte und parametrisierte Klassen?,"In EIFFEL definiert jede unparametrisierte Klasse einen Typ, während jede parametrisierte Klasse eine (generische) Menge von Typen definiert."
,Wie wird in EIFFEL zwischen Wert- und Referenztypen unterschieden?,"In EIFFEL kann bei der Deklaration angegeben werden, ob Variablen eines Typs Wertsemantik oder Referenzsemantik haben sollen. Dies kann für alle Variablen eines Typs oder nur für bestimmte Variablen festgelegt werden."
,Wie könnte man die Kovarianzprobleme in EIFFEL verhindern?,"Es gibt verschiedene Ansätze, um die Kovarianzprobleme in EIFFEL zu verhindern, darunter die Beschränkung der Zuweisungskompatibilität, die Durchführung einer Typinferenz für das gesamte Programm und das Verbot dynamisch gebundener Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen ändern. Jede dieser Methoden hat jedoch ihre eigenen Einschränkungen und Herausforderungen."
,Wie werden Tupeltypen in EIFFEL deklariert?,"Tupeltypen in EIFFEL werden deklariert, indem für jede Position im Tupel ein Typ angegeben wird. Konkrete Werte eines Tupels werden in eckigen Klammern notiert, wobei die Positionen optional auch Namen erhalten können."
,"Wie wird in C++ festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen?","In C++ wird festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen, indem man die betreffenden Klassen mit dem Schlüsselwort ""friend"" in der Zielsklasse deklariert. Zum Beispiel: friend class B; und friend class C;"
,Wie wird das Friends-Konzept in Java angenähert?,Das Friends-Konzept wird in Java durch die Verwendung von Modulen und den dedizierten (qualifizierten) Export auf Ebene der Pakete angenähert. Dies ermöglicht eine kontrollierte Freigabe von Elementen an bestimmte Pakete.
,Wie ermöglicht C++ die getrennte Übersetzung von Programmteilen?,"C++ ermöglicht die getrennte Übersetzung von Programmteilen mithilfe von Header-Dateien, die die Schnittstellen der Teile enthalten."
,Wie erfolgt die Methodenbindung in C++ standardmäßig?,"Standardmäßig erfolgt die Methodenbindung (Methodenaufruf) in C++ statisch. Das bedeutet, dass die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable hat."
,Wann werden Methoden in C++ zur Laufzeit dynamisch gebunden?,"In C++ werden Methoden zur Laufzeit dynamisch gebunden, wenn sie mit dem Schlüsselwort virtual deklariert sind. Bei virtuellen Methoden wird zur Laufzeit überprüft, welchen Typs das Objekt ist, und zur entsprechenden Methodenimplementierung verzweigt."
,Wie wird Generizität in C++ implementiert?,"Generizität in C++ wird mit Hilfe von Templates erreicht. Ein Template ist ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Tatsächlich werden aus Templates neue Typen erzeugt, und für jede Instanz eines generischen Typs wird ein neuer Typ erzeugt und kompiliert."
,Wie wird die Zulässigkeit von Typumwandlungen in C++ überprüft?,"Die Zulässigkeit von Typumwandlungen in C++ wird zur Laufzeit überprüft, und sie kann nicht zur Kompilierzeit überprüft werden. Typumwandlungen sollten vermieden werden, da sie die Typsicherheit untergraben können."
,Wie kann in C-Sharp eine Typumwandlung (Casting) durchgeführt werden?,"In C-Sharp kann eine Typumwandlung mithilfe von Casts durchgeführt werden. Die Syntax dafür ist (T)a;, wobei T der Zieltyp ist und a der Ausdruck, der umgewandelt werden soll."
,"Wie wird in C-Sharp sichergestellt, dass ein Cast sicher ist?","In C-Sharp wird ein Cast sicher gemacht, indem der is-Operator verwendet wird, um zu prüfen, ob die Zuweisung kompatibel ist. Zusätzlich kann der as-Operator verwendet werden, der bei fehlschlagender Zuweisung null zurückgibt."
,Was enthält eine C++ Klasse neben Feldern (Instanzvariablen)?,Eine C++ Klasse enthält neben Feldern (Instanzvariablen) auch Methoden.
,"Gibt es in C++ die Möglichkeit, ""Call by reference"" ohne Verwendung des Zeigeroperators ""&"" zu erreichen?","Ja, in C++ gibt es die Möglichkeit, ""Call by reference"" ohne Verwendung des Zeigeroperators ""&"" zu erreichen, ähnlich wie in Pascal. Hierbei bleiben die Aufrufstellen unverändert."
,Was unterscheidet Generics in C-Sharp und Generics in Java?,"Obwohl die Oberfläche von C-Sharp Generics der von Java ähnelt, unterscheidet sich der Mechanismus dahinter. C-Sharp instanziiert generische Klassen für Werttypen (wie int oder selbst definierte structs) für jeden verwendeten Typ, während Java Typparameter grundsätzlich immer entfernt (Type Erasure) und nur eine Implementierung erzeugt."
,Bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten?,"Ja, in C-Sharp bleibt die generische Typinformation auch zur Laufzeit erhalten und kann per Reflection abgefragt werden."
,Gibt es in C-Sharp eine Möglichkeit zur Typparameter-Inferenz bei generischen Methodenaufrufen?,"Ja, C-Sharp unterstützt Typparameter-Inferenz, was bedeutet, dass der Compiler den tatsächlichen Typparameter bei generischen Methodenaufrufen automatisch aus den Argumenten ableiten kann. Dies führt zu weniger Code und erhöht die Lesbarkeit."
,"Warum wird C++ als ""sofortige Legacy""-Sprache bezeichnet?","C++ wird als ""sofortige Legacy""-Sprache bezeichnet, weil sie eine Erweiterung von C ist und eine chaotische Syntax hat, die es schwer macht, den Code zu verstehen oder zurückzuentwickeln. Außerdem gibt es viele große Projekte, die bereits in veralteten C++-Dialekten geschrieben wurden."
,"Warum wird darauf hingewiesen, dass C++ eine Erweiterung von C ist?","Es wird darauf hingewiesen, dass C++ eine Erweiterung von C ist, um zu betonen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist. Dies bedeutet, dass C++-Code mit C-Code kombiniert werden kann und C++-Programmierer auf bestehende C-Bibliotheken zugreifen können."
,"Warum wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann?","Es wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann, um zu betonen, dass die Lesbarkeit des Codes in C++ stark von der Programmierpraxis abhängt. C++ bietet die Flexibilität, Code auf unterschiedliche Weisen zu schreiben, von sehr lesbar bis hin zu sehr unlesbar, je nach den Entscheidungen der Entwickler."
,"Warum benötigen viele Applikationen, insbesondere solche mit GUI, eine Kommunikation mit unbekannten Objekten?","Viele Applikationen benötigen eine Kommunikation mit unbekannten Objekten, da sie neben der direkten Kommunikation zwischen Objekten, die sich kennen, auch mit anderen Objekten kommunizieren müssen, die nicht im Voraus bekannt sind. Dies tritt insbesondere in Anwendungen mit grafischer Benutzeroberfläche (GUI) auf, wo verschiedene Elemente miteinander interagieren müssen, ohne im Voraus genau zu wissen, welche Objekte diese Interaktion benötigen."
,"Warum bezeichnet der Autor die Syntax von C-Sharp im Zusammenhang mit Events als ""komplett unleserlich""?","Der Autor bezeichnet die Syntax von C-Sharp im Zusammenhang mit Events als ""komplett unleserlich"", weil er sie als schwer verständlich oder verwirrend empfindet. Dies kann auf die Art und Weise zurückzuführen sein, wie Events deklariert, Eventhandler registriert und Ereignisse behandelt werden, was möglicherweise die Lesbarkeit des Codes beeinträchtigt."
,"Was passiert, wenn man versucht, eine explizite Interfaceimplementierung mit einem anderen Zugriffsmodifikator als ""public"" zu deklarieren?","In C-Sharp ist es möglich, Methoden von expliziten Interfaceimplementierungen mit Zugriffsmodifikatoren, die nicht ""public"" sind, von außen aufzurufen. Dies ist jedoch an die explizite Implementierung gebunden und erfordert die Verwendung des richtigen Interfacequalifikators."
,Können explizite Interfaceimplementierungen in C-Sharp überschrieben werden?,"Nein, explizite Interfaceimplementierungen können nicht überschrieben werden. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut."
,Gibt es eine Namenskonvention für Interfaces in C-Sharp?,"Ja, im Common Type System von .NET sollten alle Interfacenamen mit einem ""I"" beginnen. Dies dient zur Unterscheidung von Interface- und Klassennamen und folgt der Tradition der ungarischen Notation bei Microsoft."
,"Warum wurde in C-Sharp das Hantieren mit Pointern wieder eingeführt, und wie werden unsichere Bereiche behandelt?","In C-Sharp wurde das Hantieren mit Pointern in unsichere Bereiche verbannt, weil es in systemnahen Programmierungen und beim Zugriff auf das Betriebssystem notwendig ist. Der Modifikator ""unsafe"" kennzeichnet solche unsicheren Bereiche und wird verwendet, um den Einsatz von Pointern zu ermöglichen. In unsicheren Bereichen können Zeiger auf Typen deklariert werden, und die Dereferenzierung eines Zeigers erfolgt mit einem Stern (*). Dies ermöglicht das Hantieren mit Pointern in einem begrenzten und kontrollierten Umfeld."
,Warum wird C++ als eine sehr komplexe Sprache beschrieben?,"C++ wird als eine sehr komplexe Sprache beschrieben, weil ihre Beherrschung Jahre dauern kann, selbst bei täglichem Umgang mit ihr. Die eigentliche Komplexität ergibt sich aus der kombinierten Verwendung ihrer zahlreichen Konstrukte, und die Möglichkeiten sind vielfältig."
,"Warum ist es schwer, C++ zu lehren?","Es ist schwer, C++ zu lehren, weil die Sprache sehr komplex ist und die Kombinatorik ihrer Konstrukte zu einer hohen Zahl von Möglichkeiten führt. Die Vielzahl von Idiomen (Wendungen) in C++ trägt ebenfalls zur Komplexität bei."
,"Warum ist es schwierig, die Komplexität von C++ von der Objektorientierung zu trennen?","Es ist schwierig, die Komplexität von C++ von der Objektorientierung zu trennen, weil viele Beiträge zur Komplexität von C++ in Zusammenhang mit der Objektorientierung stehen. Die Kombination von objektorientierten Konzepten und anderen Sprachmerkmalen macht C++ zu einer komplexen Sprache."
,Was wird als mögliche Gefahr hinsichtlich der Entwicklung von C-Sharp und Java erwähnt?,"Als mögliche Gefahr wird erwähnt, dass die beiden Sprachen sich gegenseitig übertrumpfen könnten. Es besteht die Möglichkeit, dass jemand auf die Idee kommt, die besten Eigenschaften beider Sprachen zu kombinieren und eine neue Sprache zu entwickeln. Dies könnte auch eine Gelegenheit sein, sich von den Syntax-Erben aus der C-Welt zu verabschieden."
,Warum könnte EIFFEL trotz seiner Funktionen kein größerer Erfolg geworden sein?,"Es gibt mehrere mögliche Gründe für den begrenzten Erfolg von EIFFEL. Dies könnte auf unzureichende Implementierungen der Werkzeuge, die Kompromisslosigkeit des Schöpfers BERTRAND MEYER und den Spagat zwischen kommerzieller Anwendbarkeit und akademischer Eignung zurückzuführen sein. Auch das Typsystem von EIFFEL und akademische Vorbehalte gegenüber bestimmten Programmierweisen könnten eine Rolle spielen. Trotzdem hat EIFFEL Einfluss auf die Art und Weise, wie über das Programmieren nachgedacht wird."
,Gibt es in C-Sharp einen Unterschied zwischen Wert- (primitiven) und Referenztypen wie in Java?,"In C-Sharp wird zunächst nicht zwischen Wert- (primitiven) und Referenztypen wie in Java unterschieden. Alle Typen, einschließlich der primitiven Typen, gelten als von Object (genauer: System.Object) abgeleitet."
,Bietet C++ eine dynamische Typprüfung wie andere Sprachen?,"Nein, C++ bietet keine eingebaute dynamische Typprüfung."
,"Warum wissen einige Objekte in C++, von welcher Klasse sie eine Instanz sind?","Einige Objekte in C++ wissen zumindest im Prinzip, von welcher Klasse sie eine Instanz sind, weil sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Diese virtuelle Funktionstabelle dient als eine Art Repräsentation der Klasse."
,Gibt es in EIFFEL Zugriffsmodifikatoren wie in Java oder C++?,"Nein, es gibt in EIFFEL keine Zugriffsmodifikatoren wie in Java oder C++. Alle Features sind standardmäßig öffentlich zugänglich."
,Bietet EIFFEL spezielle Konstrukte zur Leistungsoptimierung?,"Nein, EIFFEL sieht keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Die Performance-Verbesserungen werden vollständig einem optimierenden Compiler überlassen."
,Warum kann Mehrfachvererbung in C++ sinnvoll sein?,"Mehrfachvererbung kann aus verschiedenen Gründen sinnvoll sein: Eine Klasse kann von mehreren vollständig abstrakten Klassen erben und damit mehrere Interfaces implementieren. In Aufgabenstellungen, in denen eine Klasse Eigenschaften von mehreren anderen Klassen benötigt, erlaubt Mehrfachvererbung, alle benötigten Eigenschaften zu erben, anstatt sich für eine einzige Superklasse entscheiden zu müssen."
,"Warum gibt es in C-Sharp keine ""Throws""-Klauseln in Methodendeklarationen, wie sie in Java existieren?","C-Sharp verzichtet auf ""Throws""-Klauseln in Methodendeklarationen, die in Java zur Unterscheidung von Checked Exceptions und Unchecked Exceptions verwendet werden. Stattdessen gibt es in C-Sharp nur Unchecked Exceptions. Diese Entscheidung wurde getroffen, um die Programmierer nicht dazu zu zwingen, im Voraus zu wissen, was in jeder Methode schief gehen kann. Es gibt jedoch Möglichkeiten, Exception-Handling in C-Sharp durch ""Exception chaining"" und ""Exception tunneling"" zu implementieren."
,Können Indexer in C-Sharp überladen werden und mehrere indizierte Instanzvariablen simulieren?,"Ja, Indexer in C-Sharp können überladen werden, um mehrere indizierte Instanzvariablen zu simulieren. Dies ermöglicht einem Objekt, mehrere indizierte Variablen mit unterschiedlichen Indexen zu haben. Die Einschränkung dabei ist, dass der Rückgabetyp (Elementtyp) beim Überladen gleich bleiben muss. Indexer können auch berechnete Werte zurückgeben, ohne auf interne Instanzvariablen zuzugreifen, ähnlich wie Properties."
,Warum wird in EIFFEL eine kovariante Redefinition benötigt?,"In EIFFEL wird eine kovariante Redefinition benötigt, um die Unterkunft der jungen Skifahrerinnen nach Geschlechtern getrennt zu organisieren. Dies ermöglicht es, Mädchen und Jungen unterschiedliche Typen für ""roommate"" zuzuweisen."
,Warum führt die implizite Allquantifizierung einer Deklaration zu einem Fehler?,"Die implizite Allquantifizierung einer Deklaration wie ""SKIER.share(SKIER)"" bedeutet nicht, dass alle Skifahrerinnen (beider Geschlechter) ihr Zimmer mit allen Skifahrerinnen teilen können. Dies ist aufgrund von Faktoren wie Krankheit nicht immer möglich. Die statische Typisierung kann solche situativen Unterschiede nicht abbilden."
,Warum sind Typtests in EIFFEL manchmal notwendig?,"Typtests in EIFFEL sind manchmal notwendig, um festzustellen, welchen genauen Typ ein Element hat, das in einen Container (eine Variable oder eine Collection) ungleichen Typs gelegt wurde. Dadurch kann das Element entsprechend seines Typs verwendet werden."
,Gibt es in EIFFEL explizite Typumwandlungen wie in anderen Sprachen?,In EIFFEL gibt es keine expliziten Typumwandlungen wie in einigen anderen Sprachen. Die Typumwandlung erfolgt immer in Verbindung mit einer Zuweisung.
,Was unterscheidet Werttypen und Referenztypen in EIFFEL?,Anders als in C-Sharp unterscheidet EIFFEL nicht zwischen Wert- und Referenztypen auf der Ebene von Typkonstruktoren. Stattdessen kann es für jeden Typ sowohl Wertsemantik als auch Referenzsemantik geben.
,Warum ist das Friends-Konzept in C++ nützlich?,"Das Friends-Konzept ist nützlich, wenn ein Teilproblem in der Programmierung nicht von einer einzelnen Klasse gelöst werden kann, sondern die Zusammenarbeit mehrerer Klassen erfordert. Es ermöglicht, dass diese Klassen eng zusammenarbeiten können, ohne dass alle Klassen dieselbe Schnittstelle haben müssen."
,"Gibt es in C++ die Möglichkeit, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren?","Nein, in C++ ist es nicht möglich, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren. Stattdessen erlaubt das Friends-Konzept, dass bestimmte Klassen auf alle privaten Elemente einer anderen Klasse zugreifen können."
,Warum wurde C-Sharp entwickelt?,"Die Entwicklung von C-Sharp wurde weniger als Versuch betrachtet, mit Microsofts Marktmacht einen proprietären Standard durchzusetzen, sondern war vielmehr dem Umstand geschuldet, dass Java keine volle Kontrolle über Hardware und Betriebssystem bietet und somit nicht für jede kommerzielle Softwareentwicklung geeignet ist."
,In welchen wesentlichen Punkten unterscheidet sich das Typsystem von C-Sharp von dem von Java?,"Das Typsystem von C-Sharp unterscheidet sich von Java in mehreren wesentlichen Punkten, darunter die Art der Unterscheidung von Wert- und Referenztypen, die angebotenen Typkonstruktoren für Wert- und Referenztypen und den Umgang mit Interfaces als Typen."
,"Warum ist es wichtig, andere objektorientierte Programmiersprachen zu kennen?","Es ist wichtig, andere objektorientierte Programmiersprachen zu kennen, da Praktikerinnen und solche, die es werden wollen, die Programmiersprachen kennen müssen, die auf dem Markt gefragt sind. Dies ermöglicht es ihnen, in verschiedenen beruflichen Situationen flexibel zu sein und die am besten geeignete Sprache für bestimmte Aufgaben auszuwählen."
,Was ermöglicht Mehrfachvererbung in C++?,"Mehrfachvererbung in C++ ermöglicht es, eine Klasse von mehreren anderen abzuleiten. Dadurch kann eine Klasse mehrere direkte Supertypen haben, einen pro direkte Superklasse."
,"Was passiert, wenn eine Typumwandlung in C-Sharp nicht möglich ist?","Wenn eine Typumwandlung in C-Sharp nicht möglich ist, weil der tatsächliche Typ des Ausdrucks a kein Subtyp von T ist oder keine entsprechende Typumwandlung definiert ist, führt dies zu einem Laufzeitfehler."
,Was ist das Problem der schlechten Tracebarkeit?,"Das Problem der schlechten Tracebarkeit entsteht durch den dynamischen Programmablauf. Die Goto-Anweisung erlaubt Sprünge von beliebigen Stellen eines Programms zu anderen Stellen und bricht dabei das Lokalitätsprinzip von Programmen, bei dem zusammengehörende Anweisungen im Programmtext nahe beieinander stehen. Dies führte zu einer Unübersichtlichkeit im Programmtext und erschwerte das Verstehen und Debuggen von Programmen."
,Welche Probleme ergeben sich bei der Verwendung dynamisch gebundener Unterprogrammaufrufe in der objektorientierten Programmierung?,"Bei der Verwendung dynamisch gebundener Unterprogrammaufrufe in der objektorientierten Programmierung ergibt sich das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht. Dies führt zu einer Unsicherheit darüber, welcher Code tatsächlich ausgeführt wird, insbesondere beim Tracen oder Debuggen von Programmen."
,"Welche Idee aus der formalen Programmverifikation wird verwendet, um das Verhalten von Objekten in der Subtypenbeziehung zu berücksichtigen?","Die Idee aus der formalen Programmverifikation besteht darin, Vorbedingungen in Nachbedingungen zu überführen, um das Verhalten von Objekten eines Typs zu berücksichtigen. Dies wird verwendet, um sicherzustellen, dass die Implementierung eines Typs korrekt ist und dass aus Vorbedingungen die entsprechenden Nachbedingungen folgen."
,"Welches Konzept bieten Programmiersprachen wie Java und C-Sharp, um die doppelte Sichtweise auf Typen zu unterstützen?","Programmiersprachen wie Java und C-Sharp bieten das Konzept von ""Interfaces als Typen"" an, mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. Dies ermöglicht es den Nutzerinnen, ihre eigenen Anforderungen als Typen zu definieren. Allerdings wird diese Möglichkeit in der Praxis oft nicht genutzt, um Anwenderinnen ihre eigenen Typen definieren zu lassen. Es wird jedoch darauf hingewiesen, dass dies in Zukunft anders gehandhabt werden könnte."
,Was ist das Fragile-Base-Class-Problem?,"Das Fragile-Base-Class-Problem bezieht sich auf eine Gruppe von Problemen in der Vererbung von Klassen. Wenn zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, können Änderungen an der Basisklasse zu unerwarteten und unerwünschten Auswirkungen in der abgeleiteten Klasse führen."
,Welche Herausforderungen ergeben sich aus dem Fragile-Base-Class-Problem in verteilten Objektsystemen?,"In verteilten Objektsystemen wird das Problem komplexer, da Änderungen an einer Komponente unerwartete Auswirkungen auf verwandte Komponenten haben können. Die Schnittstellen und Beziehungen zwischen Komponenten müssen klar und stabil sein, um unerwartetes Verhalten zu verhindern. Das Problem wird noch schwerwiegender, wenn verschiedene Anbieter Komponenten entwickeln, da Änderungen an einer Komponente die Funktionalität anderer Komponenten beeinträchtigen könnten."
,Welche Ansätze werden zur Bewältigung des Fragile-Base-Class-Problems vorgeschlagen?,"Ein Ansatz besteht darin, explizite Vererbungsinterfaces einzuführen, um die Beziehungen zwischen Klassen in einer Vererbungshierarchie klarer zu definieren. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie ""protected,"" ""virtual"" und ""override,"" um die Überschreibbarkeit von Methoden zu steuern und das Verhalten in Subklassen zu dokumentieren. Jedoch gibt es keine universelle Lösung für das Problem."
,Welche Faktoren beeinflussen den Programmierstil in der Softwareentwicklung?,"Programmiersprachen ermöglichen es einer Autorin, sich auf eine persönliche Art und Weise auszudrücken. Die Qualität eines Programms wird nicht durch die Ausdrucksweise bestimmt, sondern durch Faktoren wie Effizienz und Verständlichkeit. Der Programmierstil, der sich ausdrückt, spielt eine entscheidende Rolle für die Verständlichkeit und Qualität eines Programms. Weitere Faktoren wie Mode und Ästhetik (Eleganz) können ebenfalls den Programmierstil beeinflussen."
,Welche strukturbildende Einheit wird in der objektorientierten Programmierung auf Programmebene hauptsächlich verwendet?,Auf Programmebene besteht die strukturbildende Einheit in der objektorientierten Programmierung hauptsächlich aus Klassen.
,Welche Herausforderung besteht hinsichtlich der Strukturierung von Klassen in der objektorientierten Programmierung?,"Eine Herausforderung besteht darin, dass die hierarchische Struktur objektorientierter Systeme auf Klassenebene nicht immer vorschreibbar ist. Objekte einer Klasse sind nicht immer Teile von Objekten anderer Klassen, sondern können auch einzelne Exemplare (Instanzen) sein und selbst Teile haben können. Es fehlen Konstrukte zur Definition von Komponenten als separate strukturbildende Einheiten neben Klassen und Objekten."
,"Welches Beispiel wird gegeben, um das Problem der Substituierbarkeit zwischen den Typen Set (Menge) und Bag (Multimenge) zu erklären?","Das Beispiel betrifft die Substituierbarkeit zwischen den Typen Set (Menge) und Bag (Multimenge). Wenn Set als Subtyp von Bag angesehen wird, gibt es Probleme, da Sets einige charakteristische Eigenschaften von Multimengen verletzen, wie die Größenänderung nach dem Hinzufügen eines Elements. Wenn Bag als Subtyp von Set angesehen wird, wird die charakteristische Eigenschaft verletzt, dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist."
,"Was ist das Problem, das im Zusammenhang mit Subtyping und dynamischem Methodenaufruf auftritt?","Das Problem besteht darin, dass aufgrund des dynamischen Bindens von Methodenaufrufen nicht vorhergesagt werden kann, welchen Effekt ein Aufruf der Methode in einem bestimmten Programmfragment haben wird, selbst wenn der Typ des Empfängerobjekts bekannt ist. Es ist schwer zu bestimmen, welcher Subtyp des Typs des Empfängerobjekts tatsächlich betroffen ist."
,Welche Variante der objektorientierten Programmierung scheint besser für die GUI-Programmierung geeignet zu sein?,"Die prototypenbasierte Variante der objektorientierten Programmierung, wie sie in JavaSCRIPT verwendet wird, scheint besser für die GUI-Programmierung geeignet zu sein."
,"Was ist das Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) und warum ist es wichtig?","Das Liskov-Substitutionsprinzip (LSP) ist ein Prinzip im Zusammenhang mit Subtyping, das von Barbara Liskov und Jeannette Wing entwickelt wurde. Es besagt, dass ein Subtyp (z. B. eine abgeleitete Klasse) eines Typs (z. B. eine Basisklasse) sich so verhalten sollte, dass er anstelle des Supertyps (der Basisklasse) in jedem Programm oder Kontext verwendet werden kann, ohne die Korrektheit des Programms zu gefährden. Das LSP ist wichtig, um sicherzustellen, dass Subtypen die Spezifikationen und das Verhalten des Supertyps beibehalten und korrekt verwenden."
,"Welche beiden Lösungen werden vorgeschlagen, um das Problem der Aliasbildung und zusätzlicher Methodenaufrufe zu lösen?","Es werden zwei Lösungen vorgeschlagen, um das Problem der Aliasbildung und zusätzlicher Methodenaufrufe zu lösen: Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existieren muss, die denselben Effekt wie die zusätzliche Methode hat. Die zweite Lösung erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet und erfordern eine Art Spezifikation endlicher Automaten, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt."
,Was ist das Problem der eindimensionalen Strukturierung?,"Bei größeren Programmen kann das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren, da verschiedene Vererbungshierarchien oder andere Strukturierungskriterien gleichzeitig relevant sein können. Die Trennung der Belange, auch als Separation of Concerns bekannt, wird in der objektorientierten Programmierung als unzureichend unterstützt angesehen, da es schwer ist, verschiedene Aspekte eines Systems sauber voneinander zu trennen."
,"Welche Rolle spielen Klassen in der objektorientierten Programmierung, und wie werden Programme weiter strukturiert?","Klassen sind die Module der objektorientierten Programmierung. Programme werden durch die Vererbungshierarchie weiter strukturiert, was bedeutet, dass Klassen in einer hierarchischen Beziehung zueinander stehen."
,"Welche Art von Struktur gibt es parallel zur Vererbungshierarchie, die jedoch nicht hierarchisch ist und sich nicht zur systematischen Programmorganisation eignet?","Parallel zur Vererbungshierarchie gibt es eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen bzw. Objekten geprägt ist. Diese Struktur ist nicht hierarchisch und eher unorganisiert, weshalb sie sich nicht zur systematischen Programmorganisation eignet."
,Was ist das Problem der mangelnden Kapselung?,"Die Vererbung in der objektorientierten Programmierung beeinträchtigt die Kapselung von Klassen auf unangenehme Weise. Vererbung führte zu starken Abhängigkeiten zwischen Klassen und ihren Subklassen, einschließlich der Implementierungsdetails. Diese Abhängigkeiten führten dazu, dass Teile der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufgegeben werden mussten. Das Aliasing-Problem tritt auf, wenn ein Objekt, das von einem anderen Objekt gekapselt wird, auch einen Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dies bedeutet, dass von außen auf das gekapselte Objekt zugegriffen werden kann, indem man den Alias verwendet. Dies stellt eine Herausforderung für die Kapselung dar, da es die Geheimhaltung der Implementierung durchbrechen kann."
,"Welche Enttäuschung trat auf, die die Kapselung von Klassen beeinflusste?","Die Enttäuschung trat auf, als man feststellte, dass die Vererbung in der objektorientierten Programmierung die Kapselung von Klassen auf unangenehme Weise beeinträchtigte. Vererbung führte zu starken Abhängigkeiten zwischen Klassen und ihren Subklassen, einschließlich der Implementierungsdetails. Diese Abhängigkeiten konnten dokumentiert, aber nicht beseitigt werden, und sie führten dazu, dass Teile der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufgegeben werden mussten."
,"Was ist das Aliasing-Problem, und warum stellt es eine Herausforderung für die Kapselung dar?","Das Aliasing-Problem tritt auf, wenn ein Objekt, das von einem anderen Objekt gekapselt wird, auch einen Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dies bedeutet, dass von außen auf das gekapselte Objekt zugegriffen werden kann, indem man den Alias verwendet. Dies stellt eine Herausforderung für die Kapselung dar, da es die Geheimhaltung der Implementierung durchbrechen kann."
,Welche Möglichkeiten zur Kontrolle von Aliasing werden in objektorientierten Programmiersprachen diskutiert?,"Es gibt verschiedene Ansätze zur Kontrolle von Aliasing in objektorientierten Programmiersprachen. Ein Ansatz besteht darin, die Teil-Ganzes-Beziehung zwischen Repräsentationsobjekten und dem Objekt zu definieren, sodass die Teile dem Ganzen gehören und nicht gleichzeitig Teile anderer Objekte sein können. Ein anderer Ansatz ist die Verwendung von Wertobjekten, die keine Referenzen auf andere Objekte zulassen. Ein dritter Ansatz besteht darin, Mechanismen zur Aliaskontrolle in die Programmiersprache zu integrieren, wobei viele dieser Mechanismen noch in der Entwicklung sind."
,Wie versuchte man das Problem der schlechten Tracebarkeit durch Goto-Anweisungen zu lösen?,"Man versuchte, das Problem der schlechten Tracebarkeit durch das Vermeiden von Goto-Anweisungen zu lösen. Stattdessen setzte man auf strukturierte Programmierung, die Verzweigung, Wiederholung und Unterprogrammaufrufe verwendete, um den Programmfluss zu steuern."
,Wie wird der Begriff der Substituierbarkeit in der Programmierung betrachtet?,"Der Begriff der Substituierbarkeit bezieht sich darauf, ob eine Zuweisung zwischen verschiedenen Typen gutgeht, ohne Fehler zu verursachen. Dieser Begriff wird unabhängig von der Zuweisungskompatibilität betrachtet und kann als eigenständiger Begriff betrachtet werden."
,Wann wird die Frage der Substituierbarkeit interessant?,"Die Frage der Substituierbarkeit wird interessant, wenn Objekte nicht derselben Klasse angehören und eine gewisse Abweichung im Verhalten der zu substituierenden Objekte erlaubt ist."
,Wann werden Objekte als nicht gegeneinander austauschbar angesehen?,"Objekte werden als nicht gegeneinander austauschbar angesehen, wenn eine Funktion, die in einem Typ definiert ist, in einem anderen Typ schlicht fehlt. Dies ist der Fall, wenn das Verhalten eines Typs nicht das erwartete Verhalten eines anderen Typs bietet, was zu Inkompatibilitäten führt."
,Wie kann man dem Umstand der relativen Substituierbarkeit begegnen?,"Man kann dem Umstand der relativen Substituierbarkeit begegnen, indem man nicht nur die Sichtweise der Person berücksichtigt, die die Typen erstellt (die Anbieterin), sondern auch die Sichtweise der Person, die die Typen für einen bestimmten Zweck verwendet (die Nutzerin). Die Nutzerin kann ihre Erwartungen an einen Typen definieren, indem sie einen eigenen Typen erstellt, der nur die benötigten Eigenschaften umfasst. Dieser Typ spezifiziert die Rolle, die die Objekte im Kontext der Verwendung spielen sollen. Die Auswahl der Typen, deren Objekte für spezielle Zwecke in Frage kommen, erweitert sich dadurch, ohne die Substituierbarkeit zu beeinträchtigen."
,Wie kann die Programmiererin ihre Erwartungen an Typen ausdrücken?,"Die Programmiererin kann ihre Erwartungen an Typen ausdrücken, indem sie einen eigenen Typen definiert, der nur die benötigten Eigenschaften umfasst. Dieser Typ stellt gewissermaßen die Rolle dar, die die Objekte im Kontext der Verwendung spielen sollen. Durch die Definition solcher Typen kann die Programmiererin ihre Anforderungen klar ausdrücken und sicherstellen, dass die Typen ihren speziellen Zwecken entsprechen."
,Wie kann man das Fragile-Base-Class-Problem verhindern?,"Eine Möglichkeit zur Vermeidung des Problems besteht darin, explizite Schnittstellen oder Vererbungsinterfaces einzuführen, die genau definieren, welche Eigenschaften und Methoden von Subklassen erwartet werden. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie ""virtual"" und ""override,"" um die Überschreibbarkeit und das Verhalten von Methoden in der Vererbungshierarchie zu steuern."
,Wie hat sich der Programmierstil im Laufe der Zeit entwickelt?,"In den letzten Jahrzehnten gab es einen Wandel im Programmierstil weg von einem mathematisch prägnanten Stil hin zu einem prosaisch-verbosen Stil. Früher wurden oft kurze und kryptische Bezeichner für Variablen verwendet, während heute der Trend zu aussagekräftigen und selbstdokumentierenden Bezeichnern geht. Ein Beispiel zeigt den Unterschied zwischen den beiden Stilen: Früher wurden Variablen oft als ""i"" bezeichnet, während heute aussagekräftigere Namen verwendet werden, die im Kontext ihre Bedeutung klar machen."
,Wie wird die Prüfung der Substituierbarkeit in der Praxis durchgeführt?,"In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren, insbesondere die Prüfung der Typkonformität, angenähert. Dabei wird jedoch betont, dass nicht einmal eine Substituierbarkeit ausgeschlossen werden kann, wenn mangelnde Typkonformität vorliegt. Substituierbarkeit erfordert auch eine Betrachtung des Verhaltens der Objekte."
,Wie kann das Problem des dynamischen Bindens und der Unsicherheit bei Methodenaufrufen in Bezug auf Subtyping ausgedrückt werden?,"Das Problem kann als ein Problem der formalen Programmverifikation ausgedrückt werden. Es geht darum, wie bewiesen werden kann, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts korrekt gebunden werden können. Dies erfordert genaue Kenntnisse darüber, welchen Effekt der Methodenaufruf hat, was die Kenntnis der Implementierung der Methode erfordert."
,"Wie kann das Problem der Substituierbarkeit dazu beitragen, das Problem des dynamischen Bindens und der Unsicherheit bei Methodenaufrufen zu lösen?","Das Konzept der Substituierbarkeit zielt darauf ab, sicherzustellen, dass eine lokale, ""modulare"" Betrachtung ausreicht, um zu verstehen, welchen Effekt ein Methodenaufruf haben wird, ohne eine umfassende Analyse des gesamten Programms durchführen zu müssen. Substituierbarkeit soll sicherstellen, dass die Bedingungen, unter denen die Methodenaufrufe korrekt sind, bekannt sind, und dass die Implementierungen von Methoden für Subtypen eines bestimmten Typs korrekt verwendet werden können."
,"Warum wurde die Frage nach ""guter Programmierung"" besonders mit der Einführung von Hochsprachen und großen Programmen relevant?","Die Frage nach ""guter Programmierung"" wurde relevant, weil mit der Verfügbarkeit von Hochsprachen und immer größer werdenden Programmen die Diskrepanz zwischen dem statischen, linearen Programmtext und dem dynamischen, stark verzweigten Programmablauf immer offensichtlicher wurde."
,Warum wurde die Goto-Anweisung als Hauptverursacher für schlechte Programmierung identifiziert?,"Die Goto-Anweisung erlaubt Sprünge von beliebigen Stellen eines Programms zu anderen Stellen und bricht dabei das Lokalitätsprinzip von Programmen, bei dem zusammengehörende Anweisungen im Programmtext nahe beieinander stehen. Dies führte zu einer Unübersichtlichkeit im Programmtext und erschwerte das Verstehen und Debuggen von Programmen."
,Warum wird das dynamische Binden von Skeptikern und Gegnern der objektorientierten Programmierung manchmal als eine Art Goto der 90er Jahre betrachtet?,"Das dynamische Binden wird manchmal als eine Art Goto der 90er Jahre betrachtet, weil es ähnliche Probleme in Bezug auf Tracebarkeit und Verständlichkeit von Programmen verursachen kann. Es erfordert, den Programmablauf im Kontext des dynamisch aufgerufenen Codes zu verstehen, was die Nachverfolgung und das Debuggen erschwert."
,Was bedeutet Zuweisungskompatibilität zwischen verschiedenen Typen?,"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs an Stellen verwendet werden können, an denen Objekte eines anderen Typs erwartet werden. Es bedeutet, dass die Objekte auf der linken Seite der Zuweisung durch die Objekte auf der rechten Seite substituiert werden können."
,Was bedeutet die strengste Auslegung des Begriffs der Substituierbarkeit?,"In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dies bedeutet, dass die Objekte nicht nur gleich implementiert sein müssen, sondern sich auch im selben Zustand befinden müssen."
,Warum ist die Unabhängigkeit vom konkreten Zustand der Objekte wichtig im Zusammenhang mit der Substituierbarkeit?,"Die Unabhängigkeit vom konkreten Zustand der Objekte ermöglicht es, die Substituierbarkeit von der Laufzeit auf die Übersetzungs- oder Entwurfszeit zu verlagern. Auf dieser Ebene ist das Verhalten aller Objekte einer Klasse gleich, da sie durch dieselbe Klassendefinition spezifiziert sind."
,"Warum könnten funktional äquivalente, aber verschiedene Typen ausgetauscht werden?","Funktional äquivalente, aber verschiedene Typen können ausgetauscht werden, wenn Unterschiede im Verhalten toleriert oder sogar gewünscht werden. Ein Beispiel dafür ist die plattformunabhängige GUI-Programmierung, bei der GUI-Elemente funktional äquivalent sein können, sich jedoch im Aussehen und Detailverhalten unterscheiden."
,"Was bedeutet ""verhaltensbasiertes Subtyping"" oder ""Behavior Subtyping""?","""Verhaltensbasiertes Subtyping"" oder ""Behavior Subtyping"" bezieht sich auf eine Subtypenbeziehung, bei der die Bedingungen erfüllt sein müssen, damit die Spezifikation des Subtyps die des Supertyps erfüllt und als verhaltenskonform betrachtet werden kann. Dies bedeutet, dass das Verhalten der Objekte des Subtyps mit dem Verhalten des Supertyps übereinstimmen muss."
,"Warum kann es zu Problemen kommen, wenn Objekte vom Typ S von einem Klienten als Typ T betrachtet werden?","Es können Probleme auftreten, wenn Objekte vom Typ S von einem Klienten als Typ T betrachtet werden, da dies zu Aliasen führen kann, bei denen das Objekt von verschiedenen Klienten unterschiedliche Typen hat. Dies kann dazu führen, dass Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und kann für Benutzer, die das Objekt als T betrachten, nicht akzeptabel sein."
,Warum reicht eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit nicht aus?,"Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht nicht aus, da Aliasings in der objektorientierten Programmierung dazu führen kann, dass ein Objekt vom Typ S von verschiedenen Klienten unterschiedliche Typen hat und Methodenaufrufe auf dem Objekt Zustandsänderungen verursachen können, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Daher muss eine umfassendere Betrachtung erfolgen, die die Auswirkungen des Verhaltens auf den Zustand und die Spezifikation des Typs berücksichtigt."
,Warum hängt die Substituierbarkeit von Typen von ihrer jeweiligen Verwendung ab?,"Die Substituierbarkeit von Typen hängt von ihrer jeweiligen Verwendung ab, da verschiedene Anwendungsfälle unterschiedliche Anforderungen an Typen und deren Objekte haben können. Ein Typ kann in einem bestimmten Kontext problemlos durch einen anderen Typen ersetzt werden, während dies in einem anderen Kontext nicht der Fall sein kann. Die Substituierbarkeit ist daher relativ zur Verwendung der Typen."
,Warum ist der Name Fragile-Base-Class-Problem etwas irreführend?,"Der Name ist etwas irreführend, da nicht unbedingt die Basisklassen, sondern eher die abgeleiteten Klassen als ""anfällig"" oder ""zerbrechlich"" gelten."
,Können Sie ein einfaches Beispiel für das Fragile-Base-Class-Problem geben?,"Ja, nehmen wir an, es gibt eine Klasse namens ""TapeArchive"", die Videobänder archiviert. Später wird eine Subklasse namens ""NotifyingTapeArchive"" erstellt, die Nachrichten sendet, wenn Bänder archiviert werden. Das Problem besteht darin, dass Änderungen in der Basisklasse ""TapeArchive"" sich unerwartet auf die Subklasse ""NotifyingTapeArchive"" auswirken können."
,"Warum ist es schwierig, das Fragile-Base-Class-Problem zu erkennen?","Es ist schwer zu erkennen, da die Basisklasse auf den ersten Blick korrekt erscheint. Das Problem besteht darin, dass die Subklasse von bestimmtem Verhalten der Basisklasse abhängt, ohne dass dies in der Basisklasse explizit dokumentiert ist."
,"Warum ist es wichtig, aussagekräftige Bezeichner in Programmen zu verwenden?","Die Verwendung von aussagekräftigen Bezeichnern in Programmen trägt zur Verständlichkeit des Codes bei. Gut gewählte Bezeichner drücken im Kontext ihre Bedeutung aus, sodass Kommentare zur Erklärung der Programmelemente oft unnötig werden. Dies erleichtert anderen Entwicklerinnen das Verständnis des Codes und erhöht die Lesbarkeit und Wartbarkeit des Programms."
,"Warum könnte es in einigen Fällen sinnvoll sein, eine geistreichere Lösung mit einem erklärenden Kommentar zu versehen?","In einigen Fällen könnte eine Lösung, auch wenn sie in ihrer verständlichsten Form vorliegt, weniger elegant sein als eine raffinierte Variante, die nicht jedem sofort ersichtlich ist. In solchen Situationen kann die Versuchung groß sein, die geistreichere Lösung zu wählen und sie mit einem erklärenden Kommentar zu versehen, um sicherzustellen, dass auch weniger erfahrene Entwicklerinnen den Code nachvollziehen können. Dies ermöglicht es, komplexe Algorithmen oder unkonventionelle Ansätze zu dokumentieren und zu erläutern."
,Warum werden große Klassen (mit vielen Attributen und Methoden) in der objektorientierten Programmierung in der Regel vermieden?,"Große Klassen gelten in der Regel als schlechter Stil, da sie die Anwendungsdomäne nicht angemessen widerspiegeln. In der Anwendungsdomäne sind komplexe Dinge normalerweise aus einfacheren Teilen zusammengesetzt, die selbst wieder aus kleineren Teilen bestehen."
,Warum sind innere Klassen (in Java) allein keine ausreichende Lösung für die Strukturierung von Klassen?,"Innere Klassen in Java können Klassen strukturieren, aber sie werden relativ wenig verwendet, da sie sich nicht als besonders nützlich erweisen. Objekte einer Klasse sind nicht immer Teile von Objekten anderer Klassen, daher ist die hierarchische Struktur auf Klassenebene nicht immer passend."
,Warum können Konzepte wie Pakete (Java) oder Assemblies (C-Sharp) den Begriff der Komponente nicht ersetzen?,"Pakete (Java) oder Assemblies (C-Sharp) gruppieren lediglich Klassen und berücksichtigen nicht, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann. Sie können den Begriff der Komponente daher nicht vollständig ersetzen."
,"Warum ist die Substituierbarkeit fraglich, wenn keine Typerweiterung vorliegt?","Die Substituierbarkeit ist fraglich, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies führt zu Problemen, wenn Objekte eines Subtyps an Stellen verwendet werden, an denen Objekte des Supertyps erwartet werden."
,Warum kann die Unterdrückung von Eigenschaften bei abgeleiteten Typen in Java problematisch sein?,"In Java ist die Unterdrückung von Eigenschaften bei abgeleiteten Typen problematisch, da sie dazu führen kann, dass an Stellen im Programm, an denen ein Objekt des Supertyps erwartet wird, ein Objekt des Subtyps auftaucht. Dies kann zu schwerwiegenden Programmierfehlern führen, da die erwarteten Funktionen des Supertyps möglicherweise nicht verfügbar sind."
,"Warum können keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" gebildet werden, wenn X (Bag oder Set) als Subtyp von Y (dem jeweils anderen Typ) betrachtet wird?","Es können keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" gebildet werden, wenn X (Bag oder Set) als Subtyp von Y (dem jeweils anderen Typ) betrachtet wird, da die charakteristischen Eigenschaften der beiden Typen im Widerspruch zueinander stehen. Dies entspricht nicht der Definition des Subtypings, da die Bedingungen der Ko- und Kontravarianz nicht erfüllt sind."
,"Warum reicht die Typkonformität allein nicht aus, um Substituierbarkeit sicherzustellen?","Die Typkonformität allein reicht nicht aus, um Substituierbarkeit sicherzustellen, da auch das Verhalten der Objekte betrachtet werden muss. Typkonformität bedeutet nicht automatisch Substituierbarkeit. Substituierbarkeit erfordert eine Betrachtung des Verhaltens der Objekte."
,"Warum ist es wichtig zu wissen, wie Methoden einer neu eingeführten Klasse in ein bestehendes Programm integriert werden können?","Es ist wichtig zu wissen, wie Methoden einer neu eingeführten Klasse in ein bestehendes Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert und keine unerwarteten Verhaltensänderungen auftreten. Dies ist notwendig, um sicherzustellen, dass die neuen Implementierungen sich nahtlos in das bestehende Programm einfügen und die Programmfunktionalität nicht gefährden."
,Warum sind nicht alle Aufgaben gleichermaßen zur Lösung per objektorientierter Programmierung geeignet?,"Nicht alle Aufgaben sind gleichermaßen zur Lösung per objektorientierter Programmierung geeignet, da einige Aufgaben besser mit anderen Programmierparadigmen wie funktionale oder logische Programmiersprachen gelöst werden können. Auch Batch- und Scripting-Probleme, die einen imperativ-prozeduralen Charakter haben, eignen sich möglicherweise nicht optimal für die objektorientierte Programmierung."
,Warum ist die gute objektorientierte Programmierung bei Problemen mit einem hohen algorithmischen Anteil und einfachen Datenstrukturen möglicherweise weniger geeignet?,"Die gute objektorientierte Programmierung erfordert, den Code auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Bei Problemen mit einfachen Datenstrukturen und einem hohen algorithmischen Anteil müssen größere Probleme jedoch in der Regel auf durch verschiedene Klassen definierte Daten zugreifen. Dies kann dazu führen, dass der Code durch seine Datenbindung regelrecht zerfleddert wird."
,"Warum ist die objektorientierte Programmierung möglicherweise nicht ideal für Programme, in denen es hauptsächlich um Abläufe geht?","In Programmen, in denen es hauptsächlich um Abläufe geht, möchte man oft, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten, was die objektorientierte Programmierung weniger ideal macht."
,Warum ist die Wahl einer geeigneten Programmiersprache in der Praxis oft ein Abwägungsproblem?,"Die Wahl einer geeigneten Programmiersprache ist oft ein Abwägungsproblem, da verschiedene Programmiersprachen unterschiedliche Vor- und Nachteile haben. Bei der objektorientierten Programmierung kann die Organisation der Funktionen auf der Strecke bleiben, während bei der prozeduralen Programmierung die Daten häufig in unüberschaubarer Weise hin- und hergeschickt werden oder global sind."
,"Warum eignen sich Programmiersprachen, die eine Mischung mehrerer Paradigmen erlauben, weniger für Anfängerinnen?","Programmiersprachen, die eine Mischung mehrerer Paradigmen erlauben, können Anfängerinnen aufgrund ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen überfordern, wie man ein einzelnes Problem lösen kann."
,Warum wird bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung oft von einem Impedanzmismatch gesprochen?,"Bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung besteht häufig ein Impedanzmismatch, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Die beiden Ansätze verwenden unterschiedliche Mittel zur Darstellung von Beziehungen und Datenstrukturen."
,Warum muss man bei der Verarbeitung von relationalen Daten durch objektorientierte Programme oft Prinzipien der relationalen Welt anpassen?,"Bei der Verarbeitung von relationalen Daten durch objektorientierte Programme muss man sich an die Prinzipien der relationalen Welt anpassen, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Dies erfordert häufig, einen Teil dessen, was Objektorientierung ausmacht, aufzugeben."
,Warum ist die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung?,"Die GUI-Programmierung ist nicht unbedingt ein Heimspiel für die objektorientierte Programmierung, da die Instanzen einer Klasse alle Methoden teilen und es nicht möglich ist, für verschiedene GUI-Elemente derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Dies kann zu Problemen führen, insbesondere wenn es um das gemeinsame Verhalten von GUI-Elementen geht."
,"Warum wird darauf hingewiesen, dass das Liskov-Substitutionsprinzip nicht ausschließlich auf die Arbeiten von Barbara Liskov und Jeannette Wing beschränkt ist?","Es wird darauf hingewiesen, dass das Liskov-Substitutionsprinzip nicht ausschließlich auf die Arbeiten von Barbara Liskov und Jeannette Wing beschränkt ist, um anzuerkennen, dass es frühere Arbeiten gab, die ebenfalls zur Entwicklung dieses Prinzips beigetragen haben. Das Prinzip selbst ist eine wichtige Konzeption in Bezug auf Subtyping und geht über die Beiträge einzelner Personen hinaus."
,Warum ist das Liskov-Substitutionsprinzip möglicherweise zu streng formuliert?,"Das Liskov-Substitutionsprinzip (LSP) könnte zu streng formuliert sein, da es einige problematische Aspekte aufweist. Zum Beispiel geht es davon aus, dass Objekte genau die Typen T oder S haben, was nicht auf abstrakte Typen und Interfaces anwendbar ist. Außerdem verlangt es, dass alle Eigenschaften von T auch für S gelten, was im Widerspruch zur eigentlichen Absicht des Subtypings steht, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Daher könnte eine weniger strenge Formulierung des Prinzips notwendig sein."
,Warum könnte das Liskov-Substitutionsprinzip in der Praxis als zu restriktiv angesehen werden?,"Das Liskov-Substitutionsprinzip (LSP) könnte in der Praxis als zu restriktiv angesehen werden, da es strengere Anforderungen an die Subtypen stellt und einige gültige Programme ablehnt. Zum Beispiel kann es vorkommen, dass ein Subtyp spezifische Methodenaufrufe erlaubt, die nicht im Supertyp vorhanden sind, aber dennoch in bestimmten Kontexten korrekt und sicher sind. Das LSP kann diese Fälle nicht berücksichtigen, was zu einer unnötigen Ablehnung von gültigen Programmen führen kann."
,Warum stellt die Klassenhierarchie keine Form der hierarchischen Modularisierung dar?,"Die Klassenhierarchie stellt keine Form der hierarchischen Modularisierung dar, da das Herauslösen eines Teilbaums der Vererbungshierarchie praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen trennt. Somit werden Beziehungen zwischen Klassenmitgliedern gestört."
,"Warum kann bei größeren Programmen das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren?","Bei größeren Programmen kann das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren, da verschiedene Vererbungshierarchien oder andere Strukturierungskriterien gleichzeitig relevant sein können, ähnlich wie in der Biologie, wo Arten nach verschiedenen Gesichtspunkten klassifiziert werden. Dies erfordert jedoch, dass die verschiedenen Darstellungen getrennt gepflegt werden und keine Inkonsistenzen oder ungewollten Interferenzen entstehen."
,Warum wird die Trennung der Belange in der objektorientierten Programmierung als unzureichend unterstützt angesehen?,"Die Trennung der Belange, auch als Separation of Concerns bekannt, wird in der objektorientierten Programmierung als unzureichend unterstützt angesehen, da es schwer ist, verschiedene Aspekte eines Systems sauber voneinander zu trennen. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar diskutiert, haben jedoch keine breite Akzeptanz gefunden. Die Gründe dafür können vielfältig sein, aber letztendlich ist es schwierig, die essentielle Komplexität eines Problems durch programmiersprachliche Mittel vollständig zu beseitigen."
,"Warum werden Softwaresysteme als die kompliziertesten technischen Artefakte bezeichnet, die die Menschheit jemals hervorgebracht hat?","Softwaresysteme werden als die kompliziertesten technischen Artefakte bezeichnet, die die Menschheit jemals hervorgebracht hat, weil sie eine immense Komplexität aufweisen. Die Trennung der Belange und die Bewältigung dieser Komplexität sind nach wie vor große Herausforderungen in der Softwareentwicklung. Daher wird darauf hingewiesen, dass Einfachheit in diesem Kontext schwer zu erreichen ist."
,"Was war die anfängliche Erwartung in Bezug auf Kapselung in der objektorientierten Programmierung, und warum?","Anfangs glaubte man, dass die objektorientierte Programmierung durch das Konzept der Klassen eine natürliche Form der Kapselung gefunden hatte. Dies wurde auch mit der Theorie der abstrakten Datentypen in Einklang gebracht. Klassen sollten natürliche Repräsentanten von Allgemeinbegriffen sein, und Daten sowie Implementierungsdetails sollten hinter der Klassenschnittstelle verborgen werden."
,Warum können private Instanzvariablen allein das Aliasing-Problem nicht lösen?,"Private Instanzvariablen können allein das Aliasing-Problem nicht lösen, da sie lediglich Namen verbergen und nicht verhindern können, dass Repräsentationsobjekte (Implementierungsdetails) Aliasen ausgesetzt sind."
,Warum kann das Verbot von Aliasing in einigen Programmiersprachen nicht immer eine geeignete Lösung sein?,"Das Verbot von Aliasing in einigen Programmiersprachen kann nicht immer eine geeignete Lösung sein, da es zahlreiche Anwendungsfälle gibt, in denen die Verwendung von Aliasing notwendig oder sinnvoll ist. Zum Beispiel können bestimmte Datenstrukturen oder Container von Natur aus Aliase erfordern, um effizient zu arbeiten."
,"Welches Mittel wird empfohlen, um unnötigen Aufwand und Konflikte in Bezug auf Formatierung zu vermeiden?","Es wird empfohlen, automatische Codeformatierer zu verwenden, die auf Knopfdruck bestimmte Formatierungskonventionen anwenden. Selbst wenn man alleine arbeitet, sollte man solche Tools nutzen, um sich an allgemein übliche Formatierungsstandards zu halten und die Entwicklung eines persönlichen Programmierstils nicht zu weit von der Norm entfernen zu lassen. Individualität in der Programmierung ist nicht geeignet, um effizienten und wartbaren Code zu produzieren."
,Welche Vorteile haben Namenskonventionen in der Programmierung?,"Namenskonventionen in der Programmierung haben mehrere Vorteile. Sie erleichtern die Bezeichnerwahl, begrenzen die schöpferische Freiheit der Programmiererin, was als Entlastung empfunden werden kann, und machen das Lesen von Code einfacher, da Entwicklerinnen, die die Konventionen kennen, die Bedeutung der Bezeichner schneller entschlüsseln können und sich somit schneller zurechtfinden."
,Welche Wortarten einer natürlichen Sprache sollten für verschiedene Arten von Programmelementen verwendet werden?,"Es ist angemessen, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. Zum Beispiel werden in der objektorientierten Programmierung Substantive oft für Klassennamen verwendet."
,"Welche Art von Methoden wird oft mit Verben benannt, und welche Formen von Verben können verwendet werden?","Methoden, die eine Aktion implementieren (Befehle), werden oft mit Verben benannt. Bei der Wahl der Verben ist es eine Stilfrage, ob man die Infinitiv- oder die Imperativform bevorzugt. Beispielsweise kann man ""hinzufügen"" (Infinitivform) oder ""entfernen"" (Imperativform) verwenden."
,"Welche Namenskonvention wird für Methoden, die Abfragen darstellen (Queries), vorgeschlagen?","Für Methoden, die Abfragen darstellen (Queries), werden oft Adjektive oder Kopula plus Prädikatsnomen verwendet. Beispiele hierfür sind ""istLeer"" oder ""hatInhalt."""
,"Welche Wortarten werden für Instanzvariablen verwendet, abhängig davon, ob sie Attribute oder Beziehungen repräsentieren?","Für Instanzvariablen, die Attribute repräsentieren, wie Größe oder Farbe, verwendet man oft den Namen der Qualität als Substantiv. Wenn es sich um zweiwertige (Boolesche) Attribute handelt, nimmt man das entsprechende Adjektiv oder ein Gerundivum. Für Instanzvariablen, die Beziehungen repräsentieren, verwendet man oft den Namen der Gegenrolle, wie ""mutter"" in einer Kind-Mutter-Beziehung."
,"Was ist eine interessante Option für Programmiererinnen, deren Muttersprache nicht Englisch ist, in Bezug auf die Wahl der Bezeichner?","Programmiererinnen, deren Muttersprache nicht Englisch ist, haben die Möglichkeit, zwischen zwei Sprachen bei der Wahl der Bezeichner zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Man kann deutsche Bezeichner für Begrifflichkeiten aus der Anwendungsdomäne und englische Bezeichner für technische Umsetzungselemente verwenden, oder alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von denen aus Bibliotheken und Frameworks zu unterscheiden."
,"Welche Faustregel wird genannt, um einen guten Namen für ein Programmelement auszuwählen?","Als Faustregel wird genannt, dass ein Name dann gut gewählt ist, wenn man alle Ausdrücke, in denen er vorkommt, schnell und klar verstehen kann. Ein gut gewählter Name sollte keine falschen Assoziationen oder Vermutungen hervorrufen und sollte somit leicht verständlich sein. Es ist ratsam, sich Zeit für die Auswahl eines passenden Namens zu nehmen, da dies eine sorgfältige Überlegung erfordert und die Lesbarkeit des Codes erheblich verbessern kann."
,Welche Vorteile ergeben sich aus kurzen Methoden in der objektorientierten Programmierung?,"Kurze Methoden in der objektorientierten Programmierung fördern die Lesbarkeit und den objektorientierten Stil. Sie erlauben es, Teile einer Methode in separate, klar benannte Methoden auszulagern, was die Lesbarkeit und Wartbarkeit des Codes verbessert. Dieser Stil fördert auch die Verwendung von aussagekräftigen Bezeichnern und trägt zur besseren Dokumentation des Codes bei."
,"Welches Refactoring-Verfahren wird häufig angewendet, um Teile einer Methode in separate Methoden auszulagern?","Das ""Extract-method""-Refactoring-Verfahren wird häufig angewendet, um Teile einer Methode in separate Methoden auszulagern. Dieses Verfahren ermöglicht es, Teile des Codes in neue Methoden auszulagern, selbst wenn diese Teile vorerst nur von ihrer ursprünglichen Position aus aufgerufen werden, um die Lesbarkeit zu verbessern. Es handelt sich um eine gängige Praxis in der objektorientierten Programmierung."
,Was ist ein wichtiges Merkmal der objektorientierten Programmierung in Bezug auf die Größe von Klassen?,"Ein wichtiges Merkmal der objektorientierten Programmierung ist, dass Klassen nicht ins Uferlose wachsen sollten. Wenn der Methodenumfang einer Klasse zu groß wird, deutet dies darauf hin, dass die Klasse möglicherweise mehrere Abstraktionen repräsentiert oder auf einem höheren Abstraktionsniveau steht als die aktuelle Implementierung."
,"Welche Gründe können dazu führen, dass eine Klasse in der objektorientierten Programmierung zu groß wird?","Es gibt zwei mögliche Gründe, warum eine Klasse in der objektorientierten Programmierung zu groß werden kann: Die Klasse repräsentiert nicht nur eine Abstraktion der Anwendungsdomäne, sondern mehrere. In diesem Fall sollte die Klasse in mehrere Teilklassen aufgeteilt werden, wobei jede Teilklassen eine Abstraktion darstellt, und die Daten und Methoden entsprechend zugeordnet werden. Die Klasse repräsentiert eine Abstraktion der Anwendungsdomäne auf einem höheren Abstraktionsniveau als die aktuelle Implementierung. Dies kann entweder bedeuten, dass die Klasse eine Generalisierung darstellt und alle Spezialisierungen in einer Klasse zusammengefasst sind oder dass die Klasse eine Aggregation oder Komposition darstellt und Teile als logische Einheiten identifiziert werden müssen."
,"Welche Schritte sollten unternommen werden, wenn eine Klasse zu groß wird?","Wenn eine Klasse zu groß wird, sollten die folgenden Schritte unternommen werden, abhängig von der Ursache der Größe: Wenn die Klasse mehrere Abstraktionen repräsentiert, sollte die Klasse in mehrere Teilklassen aufgeteilt werden, wobei jede Teilklassen eine Abstraktion darstellt, und die Daten und Methoden entsprechend zugeordnet werden. Wenn die Klasse eine Generalisierung darstellt, sollten die unterschiedlichen Spezialisierungen identifiziert und die jeweils darauf bezogenen Daten und Funktionen in neu zu schaffende Subklassen verlagert werden. Das gemeinsame Protokoll sollte idealerweise in der neuen Superklasse verbleiben. Wenn die Klasse eine Aggregation oder Komposition darstellt, sollten die Teile als logische Einheiten identifiziert und neue Klassen formuliert werden. Falls diese neuen Klassen außerhalb der Abstraktion keine Bedeutung haben, kann in Erwägung gezogen werden, sie als innere Klassen zu deklarieren, um den Namensraum nicht unnötig zu überfrachten und die Anzahl der wahrgenommenen Klassen nicht unnötig zu erhöhen."
,Was ist eine gängige Namenskonvention in Bezug auf Interfacetypen?,"Eine gängige Namenskonvention ist, Namen von Interfacetypen mit einem großen ""I"" beginnen zu lassen. Zum Beispiel könnte ein Interface ""Auto"" als ""IAuto"" benannt werden."
,Was ist die ungarische Notation in Bezug auf Namenskonventionen?,"Die ungarische Notation ist eine Namenskonvention, bei der Bezeichner, die für ein Objekt oder einen Wert stehen (wie Variablen und Funktionsnamen), den Typ dieses Objekts oder Werts widerspiegeln. Es gibt verschiedene Auslegungen der ungarischen Notation."
,Was ist eine mögliche Auslegung der ungarischen Notation?,"Eine mögliche Auslegung der ungarischen Notation verlangt, dass Variablen, die Strings bezeichnen, mit ""str"" beginnen. Diese Auslegung kann jedoch als weniger sinnvoll angesehen werden, da Compiler und IDE bereits Informationen über den Typ der Variablen bereitstellen und diese Information den Namen der Variablen nicht zusätzlich belasten sollte."
,Welche sinnvollere Auslegung der ungarischen Notation wird vorgeschlagen?,"Eine sinnvollere Auslegung der ungarischen Notation schlägt vor, Variablen um die Verwendung ihres Inhalts zu ergänzen. Das bedeutet, die Funktion des durch die Variable bezeichneten Objekts oder Werts innerhalb des Kontextes anzugeben, in dem die Variable gültig ist. Dies ermöglicht es, die Funktion kontextbezogen auszudrücken, ohne den Namen der Variable mit redundanten Informationen zu belasten. In der objektorientierten Programmierung kann diese kontextbezogene Funktion oft auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt werden, was vom Compiler überprüft werden kann."
,Welche Rolle spielen Bibliotheken in der objektorientierten Programmierung?,Bibliotheken spielen eine entscheidende Rolle in der objektorientierten Programmierung. Sie sind ein wesentlicher Bestandteil des objektorientierten Programmierstils und tragen maßgeblich zum Erfolg dieses Ansatzes bei.
,Welche Techniken und Praktiken kennzeichnen den deklarativen Programmierstil in der objektorientierten Programmierung?,"Der deklarative Programmierstil in der objektorientierten Programmierung zeichnet sich durch folgende Techniken und Praktiken aus: Verwendung von aussagekräftigen Bezeichnern, die beschreiben, was eine Methode tut. Aufteilung von komplexen Funktionen in separate Methoden mit klaren Namen. Betonung des ""Was"" anstelle des ""Wie"" bei der Formulierung des Codes. Verwendung von Zusicherungen (Vor- und Nachbedingungen, Invarianten) anstelle von Kommentaren, um die Absichten und Bedingungen des Codes deutlicher zu machen. Zurückhaltung bei der Verwendung von Optimierungen, die die funktionale Äquivalenz gefährden könnten, bis ihre Auswirkungen vollständig verstanden sind."
,Was ist der Sinn und Zweck des Gesetzes Demeters in der objektorientierten Programmierung?,"Der Sinn und Zweck des Gesetzes Demeters ist es, die Kopplung und die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wenn das Gesetz Demeters verletzt wird, kann eine Änderung des Protokolls einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zur Klasse stehen, was vermieden werden sollte."
,Welche Art von Zugriffsregel führt Demeters Gesetz faktisch ein?,"Demeters Gesetz führt faktisch eine neue, kontextabhängige Zugriffsregel ein: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt, auf die es aber nicht zugreifen darf. Dies führt zu einer klaren Trennung zwischen direkten und indirekten Beziehungen zwischen Objekten."
,Wie kann die Einhaltung von Namenskonventionen die Kreativität der Entwicklerinnen fördern?,"Die Einhaltung von Namenskonventionen kann die Kreativität der Entwicklerinnen fördern, indem sie die schöpferische Energie auf die relevanten Aspekte lenkt. Durch die Festlegung bestimmter Regeln wird die Entwicklerin in ihrer kreativen Gestaltung eingeschränkt, was jedoch dazu führen kann, dass die Kreativität gezielter eingesetzt wird und besser zur Geltung kommt."
,Wie kann die Analysephase eines Projekts zur Identifizierung der Klassen eines Systems beitragen?,"In der Analysephase eines Projekts können alle Substantive aus der Spezifikation extrahiert werden, um auf der Basis dieser Liste die Menge der Klassen eines Systems zu identifizieren. Dies ist eine vielzitierte objektorientierte Technik."
,Wann sollte der lange Name einer Variable bevorzugt werden?,"Der lange Name einer Variable sollte bevorzugt werden, sobald dies nicht mehr der Fall ist, wenn die Sichtbarkeit der Variable über die unmittelbare Umgebung der Deklaration hinausgeht, wie es typischerweise bei der Deklaration von Instanzvariablen der Fall ist. Dies gilt auch, wenn der Typ der Variable aus dem Kontext abgeleitet werden kann (Typinferenz)."
,Wie kann man die Einhaltung des Gesetzes Demeters sicherstellen und dennoch die Funktionalität von Ausdrücken beibehalten?,"Um sowohl die Funktionalität von Ausdrücken beizubehalten als auch das Gesetz Demeters einzuhalten, kann man das Protokoll der Klasse des ersten Nachrichtenempfängers erweitern. Dies bedeutet, dass die Klasse des von ""a"" benannten Objekts um die Methode ""doY"" erweitert wird, wenn ""a"" das Ergebnis von ""doX"" ist. Dadurch wird sicherer gestellt, dass ""a"" auch die Methode ""doY"" aufruft und das Ergebnis zurückgibt."
,"Wann wird das Gesetz Demeters typischerweise verletzt, und wie äußert sich diese Verletzung?","Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks vorliegen. Dies tritt oft bei Kettenaufrufen auf oder kann durch eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen. Eine Verletzung des Gesetzes Demeters äußert sich darin, dass Nachrichten an Objekte gesendet werden, die nicht vom Sender direkt gekannt oder erzeugt wurden."
,Wie wird das Gesetz Demeters oft in einer kurzen Phrase zusammengefasst?,"Das Gesetz Demeters wird oft in folgender Phrase zusammengefasst: ""Sprich nicht mit Fremden."" In Bezug auf SMALLTALK bedeutet dies, dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen."
,Warum ist die Vererbung ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung?,"Die Vererbung ist ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung, weil sie einerseits ein mächtiges Konzept zur Wiederverwendung von Code und zur Erstellung von Klassenhierarchien darstellt, andererseits aber auch dazu führen kann, dass Änderungen an einer Klasse sich auf alle davon abgeleiteten Klassen auswirken. Dies kann die Wartbarkeit und Erweiterbarkeit des Codes beeinträchtigen und zu unerwartetem Verhalten führen."
,Was besagt die gewichtigste Regel im Zusammenhang mit Vererbung?,"Die gewichtigste Regel im Zusammenhang mit Vererbung besagt: ""Deklariere jede Klasse entweder als abstrakt oder als final."" Das bedeutet, dass Klassen entweder als abstrakt (nicht instanziierbar) oder als final (nicht ableitbar) deklariert werden sollten."
,Warum sollten nur die Blätter der Klassenhierarchie instanziierbar sein?,"Die Blätter der Klassenhierarchie sollten instanziierbar sein, weil dies sicherstellt, dass Änderungen an einer Klasse nur Auswirkungen auf diese Klasse selbst haben und nicht auf alle davon abgeleiteten Klassen. Wenn eine Klasse in der Hierarchie geändert werden muss, können diese Änderungen in der Klasse selbst oder in ihren Subklassen vorgenommen werden, ohne die anderen Klassen in der Hierarchie zu beeinflussen."
,"Warum ist es wichtig, Klassen als abstrakt oder final zu deklarieren, um Änderungen an der Funktionalität der Klasse zu ermöglichen?","Das Deklarieren von Klassen als abstrakt oder final ermöglicht es, Änderungen an der Funktionalität der Klasse auf sichere Weise durchzuführen. Wenn eine Klasse als abstrakt deklariert ist, können Änderungen in den abgeleiteten Subklassen vorgenommen werden, ohne die anderen Klassen in der Hierarchie zu beeinflussen. Wenn eine Klasse als final deklariert ist, kann sie nicht abgeleitet werden, was bedeutet, dass ihre Funktionalität nicht geändert werden kann. Dies ermöglicht es, den Vertrag zwischen der Klasse und ihren Klienten zu schützen und unerwartete Verhaltensänderungen zu verhindern."
,"Warum ist die Verwendung von abstrakten Klassen in Bibliotheken eine Möglichkeit, die Beschränkungen von finalen Klassen zu umgehen?","Die Verwendung von abstrakten Klassen in Bibliotheken ermöglicht es, die Beschränkungen von finalen Klassen zu umgehen, indem sie eine Schicht der Abstraktion hinzufügen. Anstatt eine Klasse als final zu deklarieren, wird sie als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die konkret (instanziierbar) und final ist. Auf diese Weise können Klienten der Bibliothek von der abgeleiteten, finalen Klasse erben und diese verwenden, ohne die ursprüngliche Klasse ändern zu müssen. Wenn Änderungen erforderlich sind, können sie in der finalen Klasse vorgenommen werden, und nur wenn sie für alle Klienten geeignet sind, werden sie in der abstrakten Superklasse durchgeführt. Dies ermöglicht eine gewisse Flexibilität bei der Aktualisierung von Bibliotheken, ohne den Vertrag mit den Klienten zu brechen."
,Warum sind Formatierungskonventionen in der Programmierung wichtig?,"Formatierungskonventionen in der Programmierung sind wichtig, da sie die Lesbarkeit des Codes verbessern. Sie regeln Dinge wie Einrückungen, Zeilenumbrüche, Leerzeichen und Leerzeilen, um den Code übersichtlicher zu gestalten."
,Warum sind Formatierungskonventionen besonders in Teamprojekten wichtig?,"In Teamprojekten sind Formatierungskonventionen besonders wichtig, um zu verhindern, dass jede Entwicklerin im Team ihre eigenen Formatierungsvorlieben pflegt. Ohne einheitliche Konventionen kann es passieren, dass Entwicklerinnen den Code anderer Teammitglieder nach ihren eigenen Vorlieben formatieren, was zu Konflikten und ineffizienter Arbeit führen kann."
,"Warum ist es wichtig, dass Namenskonventionen genau festgeschrieben sind und von allen akzeptiert werden?","Es ist wichtig, dass Namenskonventionen genau festgeschrieben sind und von allen akzeptiert werden, da andernfalls individuelle Auslegungen der Regeln Verwirrung stiften können. Wenn jede Person ihre eigene Auslegung hat, verliert die Namenskonvention ihren Nutzen und kann sogar zu mehr Verwirrung führen."
,Warum werden Interfaces oft mit Substantiven oder Adjektiven bezeichnet?,"Interfaces sind wie Klassen Typen, aber sie bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte spielen können. Diese Rollen werden häufig durch Substantive oder Adjektive bezeichnet. Zum Beispiel enden viele Interfacenamen im Englischen auf „able“ oder „ible“, wie ""Serializable."""
,"Warum könnte die Verwendung langer, sprechender Bezeichner in der Programmierung problematisch sein?","Die Verwendung langer, sprechender Bezeichner kann in der Programmierung problematisch sein, da der Programmtext dadurch übermäßig lang wird. Anweisungen, die normalerweise in eine Zeile passen würden, müssen möglicherweise mehrfach umgebrochen werden, was die Lesbarkeit beeinträchtigen kann. Außerdem hört man gelegentlich das Argument, dass lange Namen zusätzliche Schreibarbeit für die Entwicklerin bedeuten. Dieses Argument wird jedoch in der Regel nicht akzeptiert, da die meisten Entwicklungsumgebungen über automatische Vervollständigungsfunktionen verfügen, die das Tippen erleichtern."
,Warum sind die Methoden in objektorientierten Programmen im Durchschnitt ziemlich kurz?,"Die Methoden in objektorientierten Programmen sind im Durchschnitt ziemlich kurz, weil in der objektorientierten Programmierung die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Wenn eine Funktion verschiedene Arten von Daten manipuliert, wird die Funktionalität wahrscheinlich nicht vollständig in einer Methode implementiert."
,Warum ist die Verwendung von Bibliotheken in der objektorientierten Programmierung wichtig?,"Die Verwendung von Bibliotheken in der objektorientierten Programmierung bietet mehrere Vorteile: Sie ermöglicht es, Lösungen für Probleme aus vorhandenen, bewährten und weit verbreiteten Bibliotheken zusammenzustellen, was Zeit und Aufwand spart. Bibliotheken enthalten in der Regel korrekte Implementierungen von Funktionen und berücksichtigen Probleme sowie Sonderfälle, die ein einzelner Entwickler möglicherweise übersehen würde. Die Wartung und Anpassung von Bibliotheken wird oft von anderen Entwicklern übernommen, was die Entwickler entlastet. Die Verwendung weit verbreiteter Bibliotheken erleichtert die Kommunikation und Zusammenarbeit mit anderen Entwicklern, da diese bereits mit den Bibliotheken vertraut sind."
,Warum sollten Entwickler in der objektorientierten Programmierung Bibliotheken nutzen?,"Entwickler sollten Bibliotheken in der objektorientierten Programmierung nutzen, um Zeit zu sparen, Fehler zu vermeiden, auf bewährte Lösungen zuzugreifen und den Entwicklungsprozess effizienter zu gestalten. Die Verwendung von Bibliotheken ermöglicht es Entwicklern, sich auf die spezifischen Anforderungen ihres Projekts zu konzentrieren, anstatt grundlegende Funktionen und Implementierungen selbst zu schreiben. Dies trägt zur Produktivität und Qualität der Software bei."
,Was kennzeichnet den deklarativen Programmierstil in der objektorientierten Programmierung?,"Der deklarative Programmierstil in der objektorientierten Programmierung legt mehr Wert auf das ""Was"" als auf das ""Wie"". Er betont die Ausdrucksform und verschiebt mögliche Optimierungen auf den Compiler oder später in der Entwicklung. Das bedeutet, dass die Programmiererin sich auf das Beschreiben dessen konzentriert, was erreicht werden soll, anstatt detaillierte Anweisungen zur Durchführung zu geben."
,Warum ist der deklarative Programmierstil in der objektorientierten Programmierung trotz ihres eher imperativen Charakters relevant?,"Der deklarative Programmierstil ist in der objektorientierten Programmierung relevant, da er die Lesbarkeit und Wartbarkeit des Codes verbessert. Obwohl die objektorientierte Programmierung tendenziell eher imperativ ist, kann der deklarative Stil durch den Einsatz von aussagekräftigen Bezeichnern und die Aufteilung von Funktionalität in separate Methoden erreicht werden. Dies führt dazu, dass der Code leichter zu verstehen ist und die Absicht der Programmiererin klarer hervortritt."
,Warum sind Abkürzungen in der Programmierung nicht grundsätzlich zu vermeiden?,"Abkürzungen in der Programmierung sind nicht grundsätzlich zu vermeiden, besonders wenn sie etabliert sind und die Leserin des Programms wahrscheinlich weiß, was sie bedeuten. Dies kann dazu beitragen, zu lange Namen zu vermeiden und den Code lesbarer zu machen."
,Warum sollte man auf selbst erstellte Abkürzungen verzichten?,"Auf selbst erstellte Abkürzungen sollte man verzichten, da ihre Bedeutung oft nur von der Person bekannt ist, die sie erstellt hat. Dies kann die Lesbarkeit des Codes für andere Programmiererinnen beeinträchtigen und zu Missverständnissen führen."
,In welchen Fällen ist die Verwendung von Abkürzungen in Java und ähnlichen objektorientierten Programmiersprachen legitim?,"In Java und ähnlichen objektorientierten Programmiersprachen ist die Verwendung von Abkürzungen legitim, wenn Typen und Variablen denselben Namen haben und sich nur in der Groß- bzw. Kleinschreibung ihres Anfangsbuchstabens unterscheiden. Dies kann in Fällen auftreten, in denen es keinen besseren Namen für die Variable gibt und die Sichtbarkeit der Variable auf die unmittelbare Umgebung der Deklaration beschränkt ist."
,"Ist es möglich, die Einhaltung des Gesetzes Demeters automatisch zu überprüfen? Warum oder warum nicht?","Die automatische Überprüfung des Gesetzes Demeters gestaltet sich schwierig, da das Gesetz in Bezug auf Objekte formuliert ist und die Auswertung von konkreten Zuweisungen und dynamischen Programmfluss erfordern würde, was mechanisch extrem aufwendig oder sogar unmöglich ist. Stattdessen überprüfen automatische Checker des Gesetzes Demeters in der Regel die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters haben."
,Warum ist die automatische Überprüfung des Gesetzes Demeters in SMALLTALK nicht möglich?,"In SMALLTALK ist die automatische Überprüfung des Gesetzes Demeters nicht möglich, da Ausdrücke in SMALLTALK nicht typisiert sind. Daher können Checker nicht feststellen, ob die Art und Weise, wie auf Objekte zugegriffen wird, dem Gesetz Demeters entspricht."
,"Was wird komplizierter, wenn die Verkettung von Methodenaufrufen länger ist?","Die Sache wird komplizierter, wenn die Verkettung von Methodenaufrufen länger ist, da dann alle Methoden in der Verkettung zur Klasse des ersten Nachrichtenempfängers hinzugefügt und mit entsprechenden Implementierungen versehen werden müssen. Dies führt zu einem Wachstum des Protokolls der Klasse des ersten Nachrichtenempfängers."
,Was besagt das Gesetz Demeters in Bezug auf die Nachrichtenübermittlung in der objektorientierten Programmierung?,"Das Gesetz Demeters besagt, dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, indem es auf eine Variable direkt zugreift, die das andere Objekt benennt. Die Dauer des Kennens kann variieren, wobei Instanzvariablen eine dauerhafte Bindung darstellen, während formale Parameter einer Methode temporär bekannt sind."
,Warum muss man bei der Verwendung von Collections als Zwischenobjekte immer eine Ausnahme von Demeters Gesetz machen?,"Bei der Verwendung von Collections als Zwischenobjekte muss man eine Ausnahme von Demeters Gesetz machen, weil die Verwendung von Iteratoren und Methoden wie ""detect:"" eine Verkettung von Nachrichten erzeugt, die in direktem Widerspruch zum Gesetz Demeters steht. Dies liegt daran, dass die Klausel ""detect:"" auf einer Kollektion nicht dem Prinzip des Gesetzes Demeters entspricht, bei dem Nachrichten nur an Objekte gesendet werden dürfen, die der Sender selbst kennt oder erzeugt."
,Warum ist das Gesetz Demeters umstritten und nicht allgemein anerkannt?,"Das Gesetz Demeters ist umstritten und nicht allgemein anerkannt, weil es in einigen Fällen schwer umsetzbar sein kann und zu unpraktischem Code führen kann. Es erfordert, dass Verkettungen von Nachrichten vermieden werden, was in einigen Fällen zu einer unnötigen Fragmentierung des Codes führen kann. Einige Entwickler sehen das Gesetz Demeters als zu restriktiv an und argumentieren, dass es in bestimmten Situationen vernünftiger ist, Verkettungen von Nachrichten zu verwenden, um den Code lesbarer und effizienter zu gestalten. Dennoch ist es wichtig, das Gesetz Demeters zu verstehen und in Betracht zu ziehen, da es in vielen Fällen dazu beitragen kann, die Kopplung zwischen Klassen zu verringern und den Code wartbarer zu machen."
"Hinter dem Nachrichtenversand in SMALLTALK verbirgt sich der Methodenaufruf. Wann immer ein Objekt eine Nachricht an ein Empfängerobjekt verschickt, wechselt der Kontrollfluss damit zum Empfängerobjekt, genauer gesagt zur Methode des Empfängerobjekts, die zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung der Methode kehrt der Kontrollfluss an das sendende Objekt (genauer: zur Methode, aus der die Nachricht versandt wurde) zurück und setzt seine Arbeit dort fort. Bei der Rückkehr wird auch das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird.",Was ist der Nachrichtenversand in SMALLTALK?,"Hinter dem Nachrichtenversand in SMALLTALK verbirgt sich der Methodenaufruf. Wenn ein Objekt eine Nachricht an ein Empfängerobjekt sendet, wird der Kontrollfluss zur Methode des Empfängerobjekts verschoben, die zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung dieser Methode kehrt der Kontrollfluss an das sendende Objekt zurück und setzt seine Arbeit dort fort."
"Hinter dem Nachrichtenversand in SMALLTALK verbirgt sich der Methodenaufruf. Wann immer ein Objekt eine Nachricht an ein Empfängerobjekt verschickt, wechselt der Kontrollfluss damit zum Empfängerobjekt, genauer gesagt zur Methode des Empfängerobjekts, die zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung der Methode kehrt der Kontrollfluss an das sendende Objekt (genauer: zur Methode, aus der die Nachricht versandt wurde) zurück und setzt seine Arbeit dort fort. Bei der Rückkehr wird auch das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird.",Was passiert nach einer Methode in SMALLTALK?,"Bei der Rückkehr nach der Abarbeitung einer Methode in SMALLTALK wird das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Dies ermöglicht die Weiterverarbeitung des Ergebnisses im Kontext des aufrufenden Objekts."
"Man könnte nun versucht sein, den Zusammenhang von Klassen und Typen auch unter Vererbung bzw. Subtyping beizubehalten und damit zu erwarten, dass eine Instanz einer Subklasse einer Klasse dem Wertebereich des zur Superklasse gehörenden Typs angehört. Das ist jedoch dann nicht der Fall, wenn in der Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, also z. B. Methoden gelöscht oder inkompatibel redefiniert werden. Die meisten objektorientierten Programmiersprachen verbieten das jedoch, so dass sich die Subklassenbeziehung tatsächlich auf eine parallele Subtypenbeziehung übertragen lässt.",Was ist der Unterschied zwischen Klassen und Typen in objektorientierten Programmiersprachen?,"In objektorientierten Programmiersprachen repräsentieren Klassen eine Art Bauplan für Objekte, während Typen die Eigenschaften von Objekten beschreiben. Eine Instanz einer Subklasse gehört nicht automatisch dem Wertebereich des zur Superklasse gehörenden Typs an, wenn in der Subklasse Änderungen vorgenommen werden, die eine Typkonformität aufheben. Die meisten objektorientierten Programmiersprachen verbieten das, so dass sich die Subklassenbeziehung tatsächlich auf eine parallele Subtypenbeziehung übertragen lässt."
"Man könnte nun versucht sein, den Zusammenhang von Klassen und Typen auch unter Vererbung bzw. Subtyping beizubehalten und damit zu erwarten, dass eine Instanz einer Subklasse einer Klasse dem Wertebereich des zur Superklasse gehörenden Typs angehört. Das ist jedoch dann nicht der Fall, wenn in der Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, also z. B. Methoden gelöscht oder inkompatibel redefiniert werden. Die meisten objektorientierten Programmiersprachen verbieten das jedoch, so dass sich die Subklassenbeziehung tatsächlich auf eine parallele Subtypenbeziehung übertragen lässt.","Was passiert mit der Typkonformität zwischen Super- und Subklasse, wenn Methoden gelöscht oder inkompatibel redefiniert werden?","Wenn in der Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, also z. B. Methoden gelöscht oder inkompatibel redefiniert werden, dann ist eine Instanz einer Subklasse nicht mehr dem Wertebereich des zur Superklasse gehörenden Typs zugehörig."
"Man könnte nun versucht sein, den Zusammenhang von Klassen und Typen auch unter Vererbung bzw. Subtyping beizubehalten und damit zu erwarten, dass eine Instanz einer Subklasse einer Klasse dem Wertebereich des zur Superklasse gehörenden Typs angehört. Das ist jedoch dann nicht der Fall, wenn in der Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, also z. B. Methoden gelöscht oder inkompatibel redefiniert werden. Die meisten objektorientierten Programmiersprachen verbieten das jedoch, so dass sich die Subklassenbeziehung tatsächlich auf eine parallele Subtypenbeziehung übertragen lässt.",Was ist der Unterschied zwischen Typen und Klassen?,"Klassen sind eine Art Bauplan für Objekte, während Typen eine Menge von Werten sind, die eine bestimmte Eigenschaft erfüllen. In einigen objektorientierten Programmiersprachen, wie z.B. Java, sind Klassen und Typen eng miteinander verbunden, aber in anderen Sprachen, wie z.B. Smalltalk, können Klassen und Typen unabhängig voneinander sein."
"Man könnte nun versucht sein, den Zusammenhang von Klassen und Typen auch unter Vererbung bzw. Subtyping beizubehalten und damit zu erwarten, dass eine Instanz einer Subklasse einer Klasse dem Wertebereich des zur Superklasse gehörenden Typs angehört. Das ist jedoch dann nicht der Fall, wenn in der Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, also z. B. Methoden gelöscht oder inkompatibel redefiniert werden. Die meisten objektorientierten Programmiersprachen verbieten das jedoch, so dass sich die Subklassenbeziehung tatsächlich auf eine parallele Subtypenbeziehung übertragen lässt.","Was passiert, wenn in einer Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben?","Wenn in einer Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, dann ist eine Instanz der Subklasse nicht mehr mit dem Typ der Superklasse kompatibel. Das ist in den meisten objektorientierten Programmiersprachen nicht erlaubt."
"Man könnte nun versucht sein, den Zusammenhang von Klassen und Typen auch unter Vererbung bzw. Subtyping beizubehalten und damit zu erwarten, dass eine Instanz einer Subklasse einer Klasse dem Wertebereich des zur Superklasse gehörenden Typs angehört. Das ist jedoch dann nicht der Fall, wenn in der Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, also z. B. Methoden gelöscht oder inkompatibel redefiniert werden. Die meisten objektorientierten Programmiersprachen verbieten das jedoch, so dass sich die Subklassenbeziehung tatsächlich auf eine parallele Subtypenbeziehung übertragen lässt.",Was bedeutet die Subklassenbeziehung in objektorientierten Programmiersprachen?,"In den meisten objektorientierten Programmiersprachen bedeutet die Subklassenbeziehung, dass eine Subklasse eine spezielle Art von Superklasse ist und dass eine Instanz der Subklasse auch als Instanz der Superklasse betrachtet werden kann. Wenn die Subklasse jedoch Änderungen vornimmt, die eine Typkonformität aufheben, dann ist diese Beziehung nicht mehr gegeben."
"Mithilfe von Metaklassen lassen sich in SMALLTALK auf natürliche Art und Weise sogenannte Konstruktoren definieren. Ein Konstruktor ist eine Methode, die, wenn sie auf einer Klasse aufgerufen wird, eine neue Instanz dieser Klasse zurückgibt (es handelt sich also aus Sicht der Instanzen der Klasse um eine Klassenmethode). Wir haben bereits zwei Konstruktoren in SMALLTALK kennengelernt: Sie werden über die Selektoren ""new"" (für Objekte ohne indizierte Instanzvariablen) und ""new:"" (für Objekte mit indizierten Instanzvariablen) aufgerufen.",Was ist ein Konstruktor in SMALLTALK?,"In SMALLTALK werden Konstruktoren mithilfe von Metaklassen definiert. Ein Konstruktor ist eine Methode, die, wenn sie auf einer Klasse aufgerufen wird, eine neue Instanz dieser Klasse zurückgibt. Es gibt zwei Konstruktoren in SMALLTALK: ""new"" für Objekte ohne indizierte Instanzvariablen und ""new:"" für Objekte mit indizierten Instanzvariablen."
"Da Klassen selbst Objekte sind, sind ""new"" und ""new:"" Instanzmethoden der Klassen. Dabei sind ""basicNew"" und ""basicNew:"" ebenfalls Instanzmethoden der Klasse, deren Implementierung allerdings primitiv ist. Sie geben eine neue Instanz (ein neues Objekt) der Klasse, auf der sie aufgerufen wurden, zurück. Da durch ""basicNew"" und ""basicNew:"" alle Instanzvariablen der erzeugten Objekte den Wert ""nil"" zugewiesen bekommen, wird auf den neuen Objekten vor ihrer Rückgabe die Methode ""initialize"" aufgerufen. ""Initialize"" ist eine Instanzmethode des neuen Objekts, die die Instanzvariablen je nach Klasse, in der die Methode definiert ist, anders belegt.","Was sind ""basicNew"" und ""basicNew:"" in Bezug auf Klassen?","""basicNew"" und ""basicNew:"" sind Instanzmethoden der Klasse, die eine neue Instanz der Klasse zurückgeben, auf der sie aufgerufen wurden. Alle Instanzvariablen der erzeugten Objekte bekommen den Wert ""nil"" zugewiesen."
"Da Klassen selbst Objekte sind, sind ""new"" und ""new:"" Instanzmethoden der Klassen. Dabei sind ""basicNew"" und ""basicNew:"" ebenfalls Instanzmethoden der Klasse, deren Implementierung allerdings primitiv ist. Sie geben eine neue Instanz (ein neues Objekt) der Klasse, auf der sie aufgerufen wurden, zurück. Da durch ""basicNew"" und ""basicNew:"" alle Instanzvariablen der erzeugten Objekte den Wert ""nil"" zugewiesen bekommen, wird auf den neuen Objekten vor ihrer Rückgabe die Methode ""initialize"" aufgerufen. ""Initialize"" ist eine Instanzmethode des neuen Objekts, die die Instanzvariablen je nach Klasse, in der die Methode definiert ist, anders belegt.",Was passiert nach dem Aufruf von basicNew und basicNew:?,"Nach dem Aufruf von basicNew und basicNew: wird auf den neuen Objekten vor ihrer Rückgabe die Methode ""initialize"" aufgerufen."
"Da Klassen selbst Objekte sind, sind ""new"" und ""new:"" Instanzmethoden der Klassen. Dabei sind ""basicNew"" und ""basicNew:"" ebenfalls Instanzmethoden der Klasse, deren Implementierung allerdings primitiv ist. Sie geben eine neue Instanz (ein neues Objekt) der Klasse, auf der sie aufgerufen wurden, zurück. Da durch ""basicNew"" und ""basicNew:"" alle Instanzvariablen der erzeugten Objekte den Wert ""nil"" zugewiesen bekommen, wird auf den neuen Objekten vor ihrer Rückgabe die Methode ""initialize"" aufgerufen. ""Initialize"" ist eine Instanzmethode des neuen Objekts, die die Instanzvariablen je nach Klasse, in der die Methode definiert ist, anders belegt.","Was ist die Aufgabe der Methode ""initialize""?","Die Methode ""initialize"" ist eine Instanzmethode des neuen Objekts, die die Instanzvariablen je nach Klasse, in der die Methode definiert ist, anders belegt."
,"Warum sind identische Objekte immer gleich, gleiche Objekte aber nicht identisch?","Objekte sind Stellen im Speicher, an denen die Daten, die ein Objekt ausmachen, hinterlegt sind. Die Identität eines Objekts ist mit der Speicherstelle gleichzusetzen. Das erklärt auf technische Weise, warum identische Objekte immer gleich, gleiche Objekte aber nicht identisch sind und warum die Veränderung (der Eigenschaften) eines Objekts seine Identität nicht berührt."
,"Welchen Sinn hat es, den Programmierenden zu erlauben für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll?","Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird für die objektorientierte Programmierung eher als Nachteil angesehen. Manche Programmiersprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll. Auf diesem Weg kann man Aliase vermeiden. Dies sollte man dann tun, wenn man verhindern möchte, dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt. Bei einer Zuweisung unter Wertsemantik muss, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist) und ein Objekt nicht in zwei Variablen gespeichert sein kann, eine Kopie angefertigt werden."
,Was sind Instanzvariablen?,"Jedem Objekt kann eine Menge von lokalen Variablen zugeordnet werden, die Instanzvariablen. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: In SMALLTALK sind sie für andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschränkt."
,Wie gelangen in SMALLTALK Objekte in den Besitz von Instanzvariablen?,"Man verbindet die Instanzvariablen mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse gehören, beschreiben. Klassendefinitionen bilden also eine Art Vorlage für Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht. Mittels Instanziierung und Klassen hat man nun die Möglichkeit, neue - und neuartige - Objekte programmatisch, also per Programmausführung, zu erzeugen. Dies geschieht standardmäßig, indem man der Klasse, von der man eine Instanz haben möchte, die Nachricht new (für Klassen ohne indizierte Instanzvariablen) oder new: (für Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert."
,Wie werden Beziehungen eines Objekts zu einem anderen in SMALLTALK realisiert?,"Die Beziehung eines Objekts zu einem anderen wird auf natürliche Weise durch eine benannte Instanzvariable ausgedrückt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung trägt. Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren andern stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die Namen der Gegenüber sind einfach Indizes: 1, 2, 3 usw."
,Wie werden Beziehungen eines Objekts zu mehreren anderen in SMALLTALK realisiert?,"Die Beziehung eines Objekts zu einem anderen wird auf natürliche Weise durch eine benannte Instanzvariable ausgedrückt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung trägt. Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren andern stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die Namen der Gegenüber sind einfach Indizes: 1, 2, 3 usw."
,Wie kann man die Komposition in objektorientierten Programmiersprachen umsetzen?,"Die meisten (objektorientierten) Programmiersprachen bieten leider überhaupt kein Sprachkonstrukt an, das speziell für die Teil-Ganzes-Beziehung gedacht wäre. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden: Da bei Wertsemantik mit der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt werden, kann man hier tatsächlich von der Umsetzung einer bestimmten Form von Teil- Ganzes-Beziehung sprechen, nämlich einer solchen, bei der die Existenz der Teile von der Existenz des Ganzen abhängt (in der UML auch Komposition genannt)."
,Was macht den Zustand eines Objektes aus?,"Der Zustand eines Objektes ist die Summe der Belegungen seiner Instanzvariablen - er wird ausschließlich durch die Verknüpfung mit anderen Objekten definiert. Es folgt, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, der über die Zuweisung von Instanzvariablen ist."
,Wie verändert man den Zustand eines Objektes?,"Der Zustand eines Objektes ist die Summe der Belegungen seiner Instanzvariablen - er wird ausschließlich durch die Verknüpfung mit anderen Objekten definiert. Es folgt, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, der über die Zuweisung von Instanzvariablen ist."
,Welche beiden Formen von Ausdrücken sind wichtige Ausdrucksformen für die objektorientierte Programmierung?,"Die Zuweisungen und die Nachrichtenausdrücke sind wichtig. Zuweisungen bewirken als einzige Ausdrücke den Zustandswechsel von Objekten. Die Nachrichtenausdrücke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand ändern. Nachrichtenausdrücke werden ausgewertet, in dem die Nachricht an das Empfängerobjekt mit den Parametern gesendet und das Empfängerobjekt als Ergebnis der Nachricht ein Objekt zurückliefert."
,Warum sind Zuweisungen wichtige Ausdrucksformen?,"Die Zuweisungen und die Nachrichtenausdrücke sind wichtig. Zuweisungen bewirken als einzige Ausdrücke den Zustandswechsel von Objekten. Die Nachrichtenausdrücke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand ändern. Nachrichtenausdrücke werden ausgewertet, in dem die Nachricht an das Empfängerobjekt mit den Parametern gesendet und das Empfängerobjekt als Ergebnis der Nachricht ein Objekt zurückliefert."
,Warum sind Nachrichtenausdrücke wichtige Ausdrucksformen?,"Die Zuweisungen und die Nachrichtenausdrücke sind wichtig. Zuweisungen bewirken als einzige Ausdrücke den Zustandswechsel von Objekten. Die Nachrichtenausdrücke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand ändern. Nachrichtenausdrücke werden ausgewertet, in dem die Nachricht an das Empfängerobjekt mit den Parametern gesendet und das Empfängerobjekt als Ergebnis der Nachricht ein Objekt zurückliefert."
,Was beschreiben Methodendefinitionen?,"Methodendefinitionen beschreiben, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll."
,Wie funktioniert das Versenden von Nachrichten in SMALLTALK?,"Aus Effizienzgründen wird in SMALLTALK ein Nachrichtenausdruck in einen Methodenaufruf übersetzt. Wann immer ein Objekt eine Nachricht an ein Empfängerobjekt verschickt, wechselt der Kontrollfluss damit zum Empfängerobjekt, genauer zu der Methode des Empfängerobjekts, das zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung der Methode kehrt der Kontrollfluss an das sendende Objekt (genauer: zu der Methode, aus der die Nachricht versandt wurde) zurück und setzt seine Arbeit dort fort. Bei der Rückkehr wird auch das Ergebnis der Methode, (eine Referenz auf) ein Objekt, geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Es gibt aber auch die Variante mittels perform:. In SMALLTALK sind auch Nachrichten Objekte. Um tatsächlich als Nachrichtenobjekt an ein Objekt verschickt zu werden, muss man sich eines speziellen Methodenaufrufs, perform:, bedienen, der es erlaubt, einem Empfängerobjekt eine Nachricht als Objekt (wenn auch nur als Parameter von perform:) zu senden. Das Empfängerobjekt reagiert darauf mit der Abarbeitung der zur Nachricht passenden Methode ganz so, als hätte es direkt einen entsprechenden Methodenaufruf erhalten."
,Was ist der Unterschied von Methodenaufrufen in der objektorientierten Programmierung zum gewöhnlichen Prozeduraufruf,"Methodenaufrufe in der objektorientierten Programmierung werden oft mit Funktionsaufrufen in der prozeduralen Programmierung verglichen. Der Unterschied besteht in der Abhängigkeit vom Empfängerobjekt: Die Entscheidung, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, hängt nicht von dem Nachrichtenselektor allein ab, sondern auch von dem Objekt, an das die Nachricht geschickt wird. Es ist nämlich durchaus üblich, dass verschiedene Objekte mit gleichen Methodensignaturen unterschiedliche Methodenimplementierungen verbinden; so implementieren beispielsweise Zahlen und Symbole die Methode printString jeweils anders. Aus der Abhängigkeit des Methodenaufrufs vom Empfängerobjekt folgt, dass nicht immer schon zur übersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgewählt werden muss. Wenn nämlich das Empfängerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird, kann die Zuordnung einer Methodendefinition zu einem Nachrichtenausdruck erst zum Zeitpunkt der Auswertung des Nachrichtenausdrucks und damit erst zur Laufzeit erfolgen (dynamisches Binden)."
,Was unterscheidet die klassenbasierte von der prototypenbasierten Form der objektorientierten Programmierung?,"Es ist bei der klassenbasierten Form nicht vorgesehen, dass verschiedene Instanzen einer Klasse über verschiedene Definitionen einer Methode (genauer: über verschiedene Definitionen von zu der Nachricht passenden Methoden) verfügen. Die prototypenbasierte Form der Objektorientierung kann sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen, z.B. indem sie eine Methodendefinition nur für ein einziges Objekt abzuändern erlaubt. Letzteres ist z.B. bei der Programmierung von grafschen Bedienoberflächen, bei der das Drücken verschiedener Buttons jeweils verschiedene Ereignisse auslöst (Methoden aufruft), sehr praktisch."
,"Warum ist es sinnvoll, dass zu jeder Klasse des SMALLTALK-Systems genau eine Metaklasse gehört?","Die Programmierpraxis hat gezeigt, dass es günstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu müssen. Um dies zu ermöglichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können. Und genau das ist in SMALLTALK der Fall. Zu jeder Klasse des SMALLTALK-Systems gehört nämlich genau eine Klasse, von der erstere (und nur diese) eine Instanz ist. Diese zweite Klasse wird Metaklasse der ersten genannt."
,Was ist ein Konstruktor?,"Ein Konstruktor ist eine Methode, die, auf einer Klasse aufgerufen, eine neue Instanz dieser Klasse zurückgibt (es handelt sich also aus Sicht der erzeugten Instanz um eine Klassenmethode)."
,Was sind Factory-Methoden?,"Eine Factory-Methode ist eine Methode, die wie ein Konstruktor eine neue Instanz liefert, die aber die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode gehört, abhängig macht. Zum Beispiel könnte eine Klasse Number eine (Klassen-)Methode fromString: vorsehen, die anhand eines zu analysierenden Strings entweder eine Instanz der Klasse Integer oder eine der Klasse Float zurückgibt. Da in SMALLTALK Konstruktoren ganz normale Klassenmethoden sind, sind sie an keine besonderen Konventionen gebunden. Sie müssen also insbesondere nicht ein neues Objekt genau der Klasse, der sie angehören, zurückgeben. Die Factory-Methoden sind dann solche Klassenmethoden."
,Was geschieht bei der Generalisierung/Spezialisierung?,"Während die Generalisierung Eigenschaften weglässt oder generalisiert (Abstraktion), fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene."
,Was versteht man in der objektorientierten Programmierung unter Vererbung?,Unter Vererbung versteht man in der objektorientierten Programmierung die übertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere. Vererbung dient vor allem der Wiederverwendung von Code und damit der ökonomie in der Softwareentwicklung.
,Wie hängen Generalisierung/Spezialisierung und Vererbung zusammen?,"Wenn man das Prinzip von Generalisierung und Spezialisierung vor Augen hat, dann ist die Vererbung eigentlich nur noch ein Mechanismus, der Definitionen von einer Klasse auf eine andere überträgt. So wird jede benannte Instanzvariable, die in einer Generalisierung deklariert ist, nicht nur für Instanzen dieser Generalisierung (so sie denn welche hat) angelegt, sondern auch für die Instanzen all ihrer Spezialisierungen. Analog stehen Methoden, die in einer Generalisierung definiert werden, auch ihren Spezialisierungen zur Verfügung, und zwar beinahe so, als wären sie in den Spezialisierungen definiert. Verwendet man Vererbung zur Ausnutzung von ähnlichkeiten, so ist nicht sichergestellt, dass auch eine Spezialisierungs- bzw. Generalisierungsbeziehung besteht."
,Was versteht man unter offener Rekursion?,"Der Aufruf einer abstrakten, d. h. in der Klasse nicht implementierten Methode aus der Klasse selbst heraus ist ein gängiges Muster der objektorientierten Programmierung. Man nennt es auch offene Rekursion, da der Aufruf auf dem Objekt selbst erfolgt (also gewissermaßen rekursiv ist), aber an der aufrufenden Stelle noch nicht klar (offen) ist, welche (erbende) Klasse die Implementierung liefert."
,Wie geht (in SMALLTALK) das dynamische Binden von Methodenaufrufen vonstatten?,"Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Wird die Methode gefunden, dann wird sie ausgeführt. Wird sie nicht gefunden, wird zunächst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument."
,Was versteht man unter aktiven Objekten?,"Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive."
,Wie kann man parallele Prozesse synchronisieren?,"Man synchronisiert parallele Prozesse mittels geteilter Warteschlangen: Man verwendet die Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gezählt werden) Objekte aufnehmen und die eine Synchronisation über next und nextPut: erlauben. Wenn man nun eine solche Shared queue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann hat man tatsächlich ""aktive Objekte, die einander Nachrichten schicken""."
,Was sind Typen?,"Typen sind abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben."
,Warum typisiert man Variablen und Programmelemente?,"Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm. Durch das Typsystem entsteht eine Modularisierung des Programms, wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt. Typen dienen damit der Wahrung des Implementationsgeheimnisses / Einhaltung der Schnittstellen durch den Compiler. Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss. Dies ist jedoch naturgemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Programmierung, insbesondere für Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung."
,"Was muss ein Typsystem überprüfen, um in einem Programm Freiheit von semantischen Fehlern zu garantieren?","Ein Typsystem muss lediglich alle Wertzuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu zählen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen, die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind."
,Was versteht man unter dynamischer Typprüfung?,"Bei der dynamischen Typprüfung prüft man zur Laufzeit vor einer Variablenzuweisung, ob der zuzuweisende Wert den von der Variable geforderten Typ hat."
,Führt SMALLTALK dynamische Typprüfung durch?,"SMALLTALK führt keine dynamische Typprüfung durchführt, da Typfehler erst im letztmöglichen Moment offenbar werden, nämlich wenn auf einer Variable eine Methode aufgerufen werden soll, die für das Objekt, auf das die Variable verweist, gar nicht definiert ist."
,Was versteht man unter statischer Typprüfung?,"Bei der statischen Typprüfung soll die Typkorrektheit zur übersetzungszeit gewährleistet werden. Die Typprüfung ist Aufgabe des Compilers. Nachteil der rein statischen Typprüfung ist, dass sie auch Programme zurückweist, die nützlich, sinnvoll und typkorrekt sind."
,Was versteht man unter statischer Typprüfung?,"Bei der statischen Typprüfung soll die Typkorrektheit zur übersetzungszeit gewährleistet werden. Die Typprüfung ist Aufgabe des Compilers. Nachteil der rein statischen Typprüfung ist, dass sie auch Programme zurückweist, die nützlich, sinnvoll und typkorrekt sind."
,Was ist ein Suptyp?,"Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall da auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht für eine besondere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung. Die Gegenrolle heißt Supertyp. Ein Subtyp ist also mit seinem Supertyp per Definition zuweisungskompatibel. Es gilt die folgende Regel: ""Wenn ein Typ Y ein Subtyp eines Typs X ist, dann müssen alle Bedingungen, die für Objekte des Typs X erfüllt sind, auch für Objekte des Typs Y erfüllt sein."""
,Wann verzichtet man auf die statische Typprüfung zugunsten einer dynamischen Typprüfung?,"In Java ist das Array Loewe[ ] Subtyp des Katzen-Array Katze[ ], wenn Loewe Subtyp von Katze ist. Man hat hier auf die statische Typprüfung zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Beispiele dafür sind Programme, die Prozeduren verwenden, die auf einer Menge von Objekten durchgeführt werden können sollen, die aber nicht verlangen, dass die Elemente alle vom gleichen Typ sind, sondern statt dessen gestatten, dass auch Elemente von Subtypen darunter vorkommen."
,Was versteht man unter Inklusionspolymorphie?,"Unter Inklusionspolymorphie versteht man im Wesentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, können Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert). Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus gebräuchlich; sonst redet man eher von Subtyping."
,Warum hält eine Klassendefinition in der Regel sinnvollerweise auch als Typdefinition her?,"Klassen dienen der Angabe von Implementierungen und damit als Container von ausführbarem Code; Typen dienen der Formulierung von Invarianten, die für Variablenbelegungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmierfehler hinweist. Da beide im Wesentlichen über die gleichen Elemente verfügen, lässt sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausführung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen läßt (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann."
,Wo manifestiert sich der Unterschied der beiden Konzepte Klasse und Typ?,"Klassen dienen der Angabe von Implementierungen und damit als Container von ausführbarem Code; Typen dienen der Formulierung von Invarianten, die für Variablenbelegungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmierfehler hinweist. Da beide im Wesentlichen über die gleichen Elemente verfügen, lässt sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausführung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen läßt (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann."
,Was versteht man unter Instanziierung des parametrischen Typs?,"Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden müssen, sondern durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich."
,Zu welchem Zeitpunkt führt die Verwendung eines parametrisch definierten Typs zu einer Zuweisung an die Typvariable?,Die Verwendung eines parametrisch definierten Typs führt bereits zur übersetzungszeit zu einer Zuweisung an die Typvariablen.
,Welche Klassen sind ein Standardanwendungsfall für parametrischen Polymorphismus?,Dies sind Collections mit Typvariablen E und Dictionary mit den Typvariablen S und E.
,Warum benötigt man den einfachen parametrischen Polymorphismus?,"Zur Vermeidung einer Sicherheitslücke in der statischen Typprüfung: Collections sind das typische Beispiel für die Verwendung des parametrschen Polymorphismus. Man könnte die Collections aber auch als Collections von Object definieren. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. Wenn ein solches Objekt von einem Subtyp von Object ist, muss man eine Typumwandlung durchführen, wenn man spezielle Subtypeigenschaften dieses Objektes nutzen will. Die Zulässigkeit dieses Down cast ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt."
,Welche Unzulänglichkeiten hat der einfache parametrische Polymorphismus?,"Auch beim einfachen parametrischen Polymorphismus kann man nicht vollständig auf Typumwandlungen verzichten, weil eine Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ speichern kann. Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft s. den Beispieltyp MyCollection, dessen Werte solche Collections sein sollen, deren Elemente sortiert und nummeriert werden können. Dieser Typ sei ein Subtyp von Collection und verfüge weiterhin über entsprechende Methoden sortieren und summieren. Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren läßt, der vom Typ Number oder einem Subtypen davon ist. Man kann daraus schließen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müssen, die einen solchen Wert zurückliefern. Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft."
,Wozu benötigt man den beschränkten parametrischen Polymorphismus?,"Da die Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den Typ implementierenden Klassen) keine Aussagen über den Typ machen. Außerhalb, bei der Verwendung (Instanziierung) der Typdefinition, geht das schon, da hier die Typvariable durch einen Typ ersetzt ist. Was man also gern hätte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist, und zwar derart, dass man bei den als Werte zulässigen Typen ein bestimmtes, benötigtes Protokoll voraussetzen kann. Die aktuellen Typparameter sind dann nicht mehr beliebig zu wählen, sondern nur noch aus solchen Typen, die die Einschränkungen erfüllen. Um dies zu erreichen, wählt man Supertypen als Schranken."
,Was ist der Unterschied zwischen überschreiben und überladen?,"überschreiben bedeutet, dass eine Methode mit der gleichen Signatur (bestehend aus Methodenname und formalen Parametertypen) noch einmal definiert werden kann, und zwar mit geänderter Implementierung. Auch darf die Methode den Rückgabetyp kovariant, also nach unten, abändern. Nun kann man in JAVA auch Methoden mit gleichem Namen, aber verschiedenen Parametertypen in derselben oder einer Subklasse haben. Diese Methoden nennt man dann überladen. In JAVA sind überladen und überschreiben zwei grundverschiedene Dinge, obwohl man in beiden Fällen nichts weiter tut als eine Methode mit bereits vorhandenem Namen noch einmal zu definieren: Beim überladen wird eine neue Methode eingeführt, beim überschreiben wird eine bereits bestehende redefiniert."
,"Wie kann die Regel ""Wenn ein Typ Y ein Subtyp eines Typs X ist, dann müssen alle Bedingungen, die für Objekte des Typs X erfüllt sind, auch für Objekte des Typs Y erfüllt sein"" überprüft werden?","Das Liskov-Substitutionsprinzip lautet: überschreibende Methoden in S erhalten das Verhalten der überschriebenen Methoden in T. Dazu gehört die Kontravarianz der Argumenttypen der überschreibenden Methode, die Kovarianz des Ergebnistyps der überschreibenden Methode, die Kovarianz der Ausnahmen der überschreibenden Methode (die Typen der geworfenen Exceptions sind entweder Subtypen von den Typen der Exceptions der überschriebenen Methode oder die Exceptions werden gar nicht geworfen; keinesfalls kommen Exceptions hinzu), die Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden und die Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Das Liskov-Substitutionsprinzip lautet weiter: Die Invarianten von S implizieren die von T."
,"Was unternimmt C#, um das Fragile-base-class-Problem zu vermeiden?","In C# sind dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort virtual. Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort override deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts new bekanntzugeben. Dadurch markiert man alle Stellen im Programm, an denen das sog. Fragile-base-class-Problem auftreten kann."
,"Wie kann ein Objekt verbergen, welche Objekte es kennt?",Es kann dies über lokale Instanzvariablen tun.
,Welchen Schutz bietet die mangelnde Sichtbarkeit von Variablen vor unerwünschtem Zugriff auf Objekte?,"Aufgrund des Aliasing kann ein Objekt, dessen einer Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, über einen anderen zugreifbar sein, ohne dass der erste Name etwas dagegen machen könnte. über lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt; es kann aber nicht verhindern, dass andere Objekte diese Objekte schon kennen und, ohne sein Wissen, manipulieren. Es ist somit wegen der etwaigen Existenz von Aliasen nicht möglich, dass ein Objekt seinen inneren Aufbau vor der Außenwelt abkapselt, es sein denn, es hat ganz spezielle Vorkehrungen dafür getroffen."
,Welchen einen starken konzeptuellen Hintergrund hat die Unterscheidung von Wert- und Referenztypen einer Klasse in EIFFEL?,"Die Unterscheidung von Wert- und Referenztypen einer Klasse unterstützt die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten, nämlich der, die das Enthaltensein von Objekten in anderen ausdrückt. Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) zu haben."
,"Wie funktionieren in EIFFEL Zuweisungen zwischen Variablen, die unterschiedliche Semantik haben?","Bei der Zuweisung zwischen zwei Variablen mit Wertsemantik wird der Wert der einen Variable in die andere Variable kopiert. Bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik wird lediglich der Zeiger kopiert. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte - statt dessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: es werden die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert). Wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt und eine Referenz auf diesen Klon übergeben."
,Was sind Repräsentationsobjekte?,"Dies sind Objekte, die die Implementierung eines Objektes ausmachen und die hinter der Schnittstelle des Objektes verborgen werden sollen."
,Welchen Lösungsansatz gibt es für das Problem der mangelnden Kapselung?,"Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes- Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt."
,"Wie versucht C#, das Problem der mangelnden Kaspelung zu lösen?","In C# kann man die ""Klasse"" der Teil-Objekte per struct definieren. (Aus Werttypen können, genau wie in PASCAL oder C, mittels des Typkonstruktors struct (dem C-äquivalent von PASCALs record) neue Werttypen erzeugt werden, die sogar Methoden und Konstruktoren haben können, die aber keine Klassen sind (und insbesondere keine Typerweiterung und somit auch keine Vererbung erlauben))"
,Welche Lösung bietet EIFFEL für das Problem der mangelnden Kapselung an?,"Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, so dass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei."
,Wozu benötigt man Zwischenobjekte?,"Bei durch indizierte Instanzvariablen eines Objekts realisierten Zu-n-Beziehungen kann nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden - die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden Zu-n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer über Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die Zu-n-Beziehung ggf. mit weiteren Attributen (z.B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o.ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die Zu-n-Beziehung eigentlich haben sollte, steht dann statt dessen in einer von einer benannten Instanzvariable hergestellten Zu-1-Beziehung zu dem Zwischenobjekt, das die Zu-n-Beziehung herstellt."
,Was sind die Vorteile von Zwischenobjekten?,"Der Umstand, dass Zu-n-Beziehungen über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, erlaubt, die Beziehung beliebig auszugestalten. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z.B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z.B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schlüssels können auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z.B. spezielle Schleifen) anbieten können, sind der Ausgestaltung von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt."
,"Was ist ein Nachteil von Zwischenobjekten, wenn man an guten objektorientierten Stil denkt?",Mit Zwischenobjekten wird das Gesetz Demeters verletzt.
,"Was sind zwei verschiedene Arten, auf die man neue Objekte erzeugen kann?","Per Instanziierung, verbunden mit der klassenbasierten objektorientierten Programmierung."
"Per Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung.",Was sind verschiedene Arten von Beziehungen?,"Beziehungen zwischen Klassen, das ist im Wesentlichen die Subklassen- oder Vererbungsbeziehung. Beziehungen zwischen Klassen und Instanzen, das ist im Wesentlichen die Instanziierungs- oder Klassikationsbeziehung Beziehungen zwischen Instanzen (oder Objekten), das sind im Wesentlichen beliebige Assoziationen (wie Mutter-Tochter) und bestimmte spezielle wie Komposition oder Aggregation."
"Per Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung.",In welchem Fall ist die Reservierung von an die Objektgröße angepasstem Speicherplatz für Variablen unnötig?,"Die Reservierung von an die Objektgröße angepasstem Speicherplatz für Variablen ist im Fall der in der objektorientierten Programmierung dominierenden Referenzsemantik unnötig - in Variablen werden nur Referenzen gespeichert, die immer gleich groß sind."
"Per Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung.",Wozu braucht man beschränkten parametrischen Polymorphismus?,"Um Bedingungen auszudrücken, die der tatsächliche Typparameter, also der für die Typvariable eingesetzte Typ, einhalten muss. Die Bedingung wird dabei durch die Angabe eines Typs genannt, der Supertyp des tatsächlichen Typparameters sein muss (eine obere Schranke). Dadurch wird garantiert, dass der tatsächliche Typparameter alle in der Schranke vereinten Eigenschaften besitzt."
"Per Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung.",Was sind die Nachteile des Subtyping Eiffels!,"Eiffel erlaubt Kovarianz bei Parametertypen und Feldern, was die Substituierbarkeit einschränkt und im Gegensatz zur Vererbung der Vorbedingungen steht, die zu einer Kontravarianz (schwächere Vorbedingungen der in Subtypen überschriebenen Methoden) führt."
"Per Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung.",Wie lautet das Gesetz Demeters?,"Sprich nicht mit Fremden - jedes Objekt soll nur auf Objekte zugreifen, die es selbst kennt, auf die also seine eigenen Instanzvariablen (oder die Parameter seiner Methoden) verweisen. Insbesondere sog. Kettenaufrufe sind nach dem Gesetz Demeters nicht erlaubt. Das Gesetz hat jedoch enge praktische Grenzen."
Klassen haben in Java mehrere Funktionen: Neben der offensichtlichen Funktion als Vorlage für die Erzeugung von Objekten liefern sie auch Typen für ein Programm und dienen der Modularisierung.,Was sind die Funktionen von Klassen in Java?,"Klassen in Java haben drei Funktionen: Sie dienen als Vorlage für die Erzeugung von Objekten, sie liefern Typen für ein Programm und sie dienen der Modularisierung."
"Pakete hingegen dienen der Sammlung von Klassen und sind zugleich Namensräume für sie (keine zwei Klassen innerhalb eines Pakets dürfen denselben Namen haben). Außerdem gelten für Klassen innerhalb eines Pakets laxere gegenseitige Zugriffsbeschränkungen als für Klassen aus verschiedenen Paketen. Zwar können Pakete hierarchisch organisiert sein, aber diese Organisation hat keine Bedeutung. Insbesondere erlauben Pakete keinen privilegierten Zugriff auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen können, bedarf es expliziter Import-Deklarationen unter Nennung der jeweiligen Paketnamen.",Was ist die Funktion von Paketen in der Programmierung?,"Pakete dienen der Sammlung von Klassen und sind zugleich Namensräume für sie. Sie erlauben eine hierarchische Organisation, haben aber keine Bedeutung für den Zugriff auf Klassen. Für Klassenübergreifenden Zugriff sind explizite Import-Deklarationen notwendig."
"Pakete hingegen dienen der Sammlung von Klassen und sind zugleich Namensräume für sie (keine zwei Klassen innerhalb eines Pakets dürfen denselben Namen haben). Außerdem gelten für Klassen innerhalb eines Pakets laxere gegenseitige Zugriffsbeschränkungen als für Klassen aus verschiedenen Paketen. Zwar können Pakete hierarchisch organisiert sein, aber diese Organisation hat keine Bedeutung. Insbesondere erlauben Pakete keinen privilegierten Zugriff auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen können, bedarf es expliziter Import-Deklarationen unter Nennung der jeweiligen Paketnamen.",Was sind Pakete in der Programmierung?,"Pakete sind in der Programmierung Sammlungen von Klassen und dienen gleichzeitig als Namensräume für sie. Sie haben eine hierarchische Organisation, aber diese hat keine Bedeutung. Pakete erlauben keinen privilegierten Zugriff auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen können, bedarf es expliziter Import-Deklarationen unter Nennung der jeweiligen Paketnamen."
"Die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) wird in Java durch sogenannte Zugriffsmodifikatoren (engl. access modifiers) eingeschränkt. Dies sind private, protected, public sowie das sogenannte ""Package local,"" für das es kein Schlüsselwort gibt und das in Klassen bei Fehlen eines der drei anderen angenommen wird (bei Interfaces wird public angenommen). Innerhalb der Klasse selbst sind alle Elemente ihrer Definition zugreifbar. Innerhalb ihrer Subklassen sind diejenigen, die public oder protected deklariert wurden, zugänglich. Innerhalb der Klassen desselben Pakets sind alle, die public, protected oder ohne Zugriffsmodifikator deklariert wurden, zugänglich, während in anderen Paketen nur noch diejenigen zugänglich sind, die public deklariert wurden. Faktisch werden Typdefinitionen somit relativ: Was ein Typ anbietet, hängt nicht nur vom Typ selbst ab, sondern auch davon, wo er verwendet wird. Konzeptionell hat die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, jedoch nichts mit dem Typ selbst zu tun, sondern ist vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.",Was sind Zugriffsmodifikatoren in Java?,"Zugriffsmodifikatoren in Java sind private, protected, public sowie das sogenannte ""Package local"". Sie werden verwendet, um die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) einzuschränken. Die Zugriffsmodifikatoren bestimmen, welche Klassen, Typen und Elemente von anderen Klassen, Typen und Elementen zugreifbar sind."
"Die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) wird in Java durch sogenannte Zugriffsmodifikatoren (engl. access modifiers) eingeschränkt. Dies sind private, protected, public sowie das sogenannte ""Package local,"" für das es kein Schlüsselwort gibt und das in Klassen bei Fehlen eines der drei anderen angenommen wird (bei Interfaces wird public angenommen). Innerhalb der Klasse selbst sind alle Elemente ihrer Definition zugreifbar. Innerhalb ihrer Subklassen sind diejenigen, die public oder protected deklariert wurden, zugänglich. Innerhalb der Klassen desselben Pakets sind alle, die public, protected oder ohne Zugriffsmodifikator deklariert wurden, zugänglich, während in anderen Paketen nur noch diejenigen zugänglich sind, die public deklariert wurden. Faktisch werden Typdefinitionen somit relativ: Was ein Typ anbietet, hängt nicht nur vom Typ selbst ab, sondern auch davon, wo er verwendet wird. Konzeptionell hat die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, jedoch nichts mit dem Typ selbst zu tun, sondern ist vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.","Wie wird der Zugriff auf Klassen, Typen und deren Elemente in Java eingeschränkt?","In Java wird der Zugriff auf Klassen, Typen und deren Elemente durch sogenannte Zugriffsmodifikatoren eingeschränkt. Es gibt vier Zugriffsmodifikatoren: private, protected, public und ""Package local"". Die Zugriffsbeschränkung ist konzeptionell eine Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist."
"Die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) wird in Java durch sogenannte Zugriffsmodifikatoren (engl. access modifiers) eingeschränkt. Dies sind private, protected, public sowie das sogenannte ""Package local,"" für das es kein Schlüsselwort gibt und das in Klassen bei Fehlen eines der drei anderen angenommen wird (bei Interfaces wird public angenommen). Innerhalb der Klasse selbst sind alle Elemente ihrer Definition zugreifbar. Innerhalb ihrer Subklassen sind diejenigen, die public oder protected deklariert wurden, zugänglich. Innerhalb der Klassen desselben Pakets sind alle, die public, protected oder ohne Zugriffsmodifikator deklariert wurden, zugänglich, während in anderen Paketen nur noch diejenigen zugänglich sind, die public deklariert wurden. Faktisch werden Typdefinitionen somit relativ: Was ein Typ anbietet, hängt nicht nur vom Typ selbst ab, sondern auch davon, wo er verwendet wird. Konzeptionell hat die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, jedoch nichts mit dem Typ selbst zu tun, sondern ist vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.",Was regeln die Zugriffsmodifikatoren in Java?,"Die Zugriffsmodifikatoren in Java regeln die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) in Abhängigkeit von der Position, an der sie verwendet werden. Es gibt vier Zugriffsmodifikatoren: private, protected, public und ""Package local"". Die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, ist konzeptionell jedoch nicht mit dem Typ selbst verbunden, sondern vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist."
"Die Bedeutung von Klassen als Module wird ausführlicher in Kapitel 59 von Kurseinheit 6 behandelt. Hier betrachten wir noch kurz die konkreten Auswirkungen der Zugriffsbeschränkungen: Eine Klasse kann nur auf Instanzvariablen und Instanzmethoden der Klasse selbst und ihrer Superklassen zugreifen. Eine Instanzvariable ist nur innerhalb der Klasse sichtbar, in der sie deklariert ist. Eine Instanzmethode kann nur auf Instanzvariablen und Instanzmethoden der Klasse, in der sie deklariert ist, und ihrer Superklassen zugreifen. Eine Klasse kann nur auf Klassenvariablen und Klassenmethoden der Klasse selbst zugreifen. Eine Klassenvariable ist nur innerhalb der Klasse sichtbar, in der sie deklariert ist. Eine Klassenmethode kann nur auf Klassenvariablen und Klassenmethoden der Klasse, in der sie deklariert ist, zugreifen.",Wie ist der Zugriff auf Instanzvariablen und Instanzmethoden geregelt?,"Eine Klasse kann nur auf Instanzvariablen und Instanzmethoden der Klasse selbst und ihrer Superklassen zugreifen. Eine Instanzvariable ist nur innerhalb der Klasse sichtbar, in der sie deklariert ist. Eine Instanzmethode kann nur auf Instanzvariablen und Instanzmethoden der Klasse, in der sie deklariert ist, und ihrer Superklassen zugreifen."
"Die Bedeutung von Klassen als Module wird ausführlicher in Kapitel 59 von Kurseinheit 6 behandelt. Hier betrachten wir noch kurz die konkreten Auswirkungen der Zugriffsbeschränkungen: Eine Klasse kann nur auf Instanzvariablen und Instanzmethoden der Klasse selbst und ihrer Superklassen zugreifen. Eine Instanzvariable ist nur innerhalb der Klasse sichtbar, in der sie deklariert ist. Eine Instanzmethode kann nur auf Instanzvariablen und Instanzmethoden der Klasse, in der sie deklariert ist, und ihrer Superklassen zugreifen. Eine Klasse kann nur auf Klassenvariablen und Klassenmethoden der Klasse selbst zugreifen. Eine Klassenvariable ist nur innerhalb der Klasse sichtbar, in der sie deklariert ist. Eine Klassenmethode kann nur auf Klassenvariablen und Klassenmethoden der Klasse, in der sie deklariert ist, zugreifen.",Wie wirken sich Zugriffsbeschränkungen auf die Verwendung von Variablen und Methoden aus?,"Eine Klasse kann die Instanzvariablen und Instanzmethoden anderer Klassen nicht verwenden, wenn diese mit private deklariert sind. Eine Instanzmethode kann die Instanzvariablen und Instanzmethoden anderer Objekte nicht verwenden, wenn diese mit private deklariert sind. Eine Klasse kann die Klassenvariablen und Klassenmethoden anderer Klassen jedoch immer verwenden, unabhängig von der Deklaration. Eine Instanzmethode kann die Instanzvariablen und Instanzmethoden des Empfängers sowie die Klassenvariablen und Klassenmethoden anderer Klassen immer verwenden, unabhängig von der Deklaration."
"Zugriffsbeschränkungen auf Instanzvariablen und Klassenvariablen verhindern, dass diese von außen verändert werden. Zugriffsbeschränkungen auf Methoden verhindern, dass diese von außen aufgerufen werden.",Was verhindern Zugriffsbeschränkungen auf Instanzvariablen und Klassenvariablen?,"Zugriffsbeschränkungen auf Instanzvariablen und Klassenvariablen verhindern, dass diese von außen verändert werden."
"Zugriffsbeschränkungen auf Instanzvariablen und Klassenvariablen verhindern, dass diese von außen verändert werden. Zugriffsbeschränkungen auf Methoden verhindern, dass diese von außen aufgerufen werden.",Was verhindern Zugriffsbeschränkungen auf Methoden?,"Zugriffsbeschränkungen auf Methoden verhindern, dass diese von außen aufgerufen werden."
"Die Sichtbarkeit bezieht sich in Java auf lexikalische Scopes. Sie wird durch Hiding, Shadowing und Obscuring eingeschränkt und kann bisweilen über Qualifizierer wiederhergestellt werden.",Was ist Sichtbarkeit in Java?,"In Java bezieht sich Sichtbarkeit auf lexikalische Scopes und wird durch Hiding, Shadowing und Obscuring eingeschränkt. Sie kann bisweilen über Qualifizierer wiederhergestellt werden."
"Die Verknüpfung von Typ und Zugriffsbeschränkung (Schnittstelle) ist in Java etabliert und kommt auch in anderen Sprachen vor (z. B. EIFFEL, C-Sharp und C++). Sie hat den Vorteil der sprachlichen Knappheit (Typ- und Schnittstellendeklaration in einem) und den Nachteil, dass die Zugriffsbeschränkungen nur grob eingestellt werden können. Insbesondere ist es nicht möglich, dass sich zwei inhaltlich eng zusammengehörende Klassen gegenseitig einen freieren Zugriff gestatten als allen anderen, es sei denn, man packt diese beiden in ein Paket. Außerdem hat sie den Nachteil, dass zwei unterschiedliche Konzepte der Programmierung zusammengeführt werden und dadurch von Programmierern u. U. nicht mehr als unterschiedlich wahrgenommen werden. Java-Compiler unterscheiden jedoch immerhin zwischen Typfehlern und Zugriffsfehlern (z. B. ""is undefined"" vs. ""is not visible"" in ECLIPSE, wobei letzteres freilich ""is not accessible"" hätte heißen müssen).",Was ist die Verknüpfung von Typ und Zugriffsbeschränkung in Java?,"In Java sind Typ und Zugriffsbeschränkung verknüpft, was den Vorteil der sprachlichen Knappheit hat, aber den Nachteil, dass die Zugriffsbeschränkungen nur grob eingestellt werden können. Zudem werden zwei unterschiedliche Konzepte der Programmierung zusammengeführt, was von Programmierern u. U. nicht mehr als unterschiedlich wahrgenommen wird."
"Die Verknüpfung von Typ und Zugriffsbeschränkung (Schnittstelle) ist in Java etabliert und kommt auch in anderen Sprachen vor (z. B. EIFFEL, C-Sharp und C++). Sie hat den Vorteil der sprachlichen Knappheit (Typ- und Schnittstellendeklaration in einem) und den Nachteil, dass die Zugriffsbeschränkungen nur grob eingestellt werden können. Insbesondere ist es nicht möglich, dass sich zwei inhaltlich eng zusammengehörende Klassen gegenseitig einen freieren Zugriff gestatten als allen anderen, es sei denn, man packt diese beiden in ein Paket. Außerdem hat sie den Nachteil, dass zwei unterschiedliche Konzepte der Programmierung zusammengeführt werden und dadurch von Programmierern u. U. nicht mehr als unterschiedlich wahrgenommen werden. Java-Compiler unterscheiden jedoch immerhin zwischen Typfehlern und Zugriffsfehlern (z. B. ""is undefined"" vs. ""is not visible"" in ECLIPSE, wobei letzteres freilich ""is not accessible"" hätte heißen müssen).",Was ist der Vorteil der Verknüpfung von Typ und Zugriffsbeschränkung in Java?,"Der Vorteil der Verknüpfung von Typ und Zugriffsbeschränkung in Java ist die sprachliche Knappheit, da Typ- und Schnittstellendeklaration in einem angegeben werden können."
"In Java gibt es Literale für Zahlen, Zeichen und Strings. Für Arrays gibt es, da sie nicht aus Literalen zusammengesetzt sein müssen, etwas Ähnliches, nämlich die sogenannten Array-Initialisierer; sie werden in Kapitel 41 behandelt. Ob ""true"" und ""false"" bzw. ""null"" in Java Literale oder Schlüsselwörter sind, hängt vom Standpunkt ab: Die meisten Syntaxeditoren behandeln sie wie Schlüsselwörter, gemäß der Sprachdefinition handelt es sich jedoch um Literale, die die beiden booleschen Wahrheitswerte ""wahr"" und ""falsch"" bzw. den Wert des Nulltypen (UndefinedObject in SMALLTALK, in Java umbenannt) repräsentieren.",Was sind Literale in Java?,"In Java gibt es Literale für Zahlen, Zeichen und Strings. ""true"" und ""false"" bzw. ""null"" werden gemäß der Sprachdefinition ebenfalls als Literale behandelt, die die beiden booleschen Wahrheitswerte und den Wert des Nulltyps repräsentieren."
"In Java gibt es Literale für Zahlen, Zeichen und Strings. Für Arrays gibt es, da sie nicht aus Literalen zusammengesetzt sein müssen, etwas Ähnliches, nämlich die sogenannten Array-Initialisierer; sie werden in Kapitel 41 behandelt. Ob ""true"" und ""false"" bzw. ""null"" in Java Literale oder Schlüsselwörter sind, hängt vom Standpunkt ab: Die meisten Syntaxeditoren behandeln sie wie Schlüsselwörter, gemäß der Sprachdefinition handelt es sich jedoch um Literale, die die beiden booleschen Wahrheitswerte ""wahr"" und ""falsch"" bzw. den Wert des Nulltypen (UndefinedObject in SMALLTALK, in Java umbenannt) repräsentieren.",Was sind Array-Initialisierer in Java und wofür werden sie verwendet?,"Array-Initialisierer in Java sind eine Möglichkeit, Arrays mit Werten zu initialisieren. Sie werden verwendet, um die Elemente eines Arrays bei der Erstellung des Arrays zu initialisieren. Die Elemente werden in geschweiften Klammern ({}) aufgelistet, getrennt durch Kommas. Zum Beispiel: int[] arr = {1, 2, 3}; erstellt ein Array von ganzen Zahlen mit den Werten 1, 2 und 3."
"Zahlenliterale in Java können eine Vielzahl von Formen annehmen. Für drei besondere Werte im Fließkommabereich stehen jedoch keine Literale, sondern nur Konstanten zur Verfügung: Es handelt sich um ""NaN"" (für das englische ""Not a Number"") sowie ""POSITIVE_INFINITY"" und ""NEGATIVE_INFINITY"". Zeichenliterale werden in Java durch einfache Anführungsstriche eingeschlossen, String-Literale durch doppelte Anführungsstriche. Beide können Escape-Sequenzen zur Darstellung von Sonderzeichen enthalten.",Wie werden Zahlenliterale in Java dargestellt?,"Zahlenliterale in Java können eine Vielzahl von Formen annehmen. Für drei besondere Werte im Fließkommabereich stehen jedoch keine Literale, sondern nur Konstanten zur Verfügung: Es handelt sich um ""NaN"" (für das englische ""Not a Number"") sowie ""POSITIVE\_INFINITY"" und ""NEGATIVE\_INFINITY""."
"Zahlenliterale in Java können eine Vielzahl von Formen annehmen. Für drei besondere Werte im Fließkommabereich stehen jedoch keine Literale, sondern nur Konstanten zur Verfügung: Es handelt sich um ""NaN"" (für das englische ""Not a Number"") sowie ""POSITIVE_INFINITY"" und ""NEGATIVE_INFINITY"". Zeichenliterale werden in Java durch einfache Anführungsstriche eingeschlossen, String-Literale durch doppelte Anführungsstriche. Beide können Escape-Sequenzen zur Darstellung von Sonderzeichen enthalten.",Was sind die Unterschiede zwischen Zeichenliteralen und String-Literalen in Java?,"Zeichenliterale in Java werden durch einfache Anführungsstriche eingeschlossen und repräsentieren ein einzelnes Zeichen, während String-Literale durch doppelte Anführungsstriche eingeschlossen sind und eine Folge von Zeichen repräsentieren. Beide können Escape-Sequenzen zur Darstellung von Sonderzeichen enthalten."
"Anders als in SMALLTALK sind in Java Klassen keine Objekte. Dennoch muss man in Programmen gelegentlich Klassen als Werte angeben. Das geht dann nicht (wie in SMALLTALK) per Angabe des Klassennamens (der dort ja zugleich als Pseudovariable definiert war), sondern mittels eines sogenannten Klassenliterals. Dieses besteht aus dem Namen der Klasse, gefolgt von "".class"", also beispielsweise ""Klasse.class"".",Was ist ein Klassenliteral in Java?,"Ein Klassenliteral in Java ist eine Notation, die aus dem Namen der Klasse, gefolgt von "".class"" besteht, und mit der man Klassen als Werte angeben kann."
"Anders als in SMALLTALK sind in Java Klassen keine Objekte. Dennoch muss man in Programmen gelegentlich Klassen als Werte angeben. Das geht dann nicht (wie in SMALLTALK) per Angabe des Klassennamens (der dort ja zugleich als Pseudovariable definiert war), sondern mittels eines sogenannten Klassenliterals. Dieses besteht aus dem Namen der Klasse, gefolgt von "".class"", also beispielsweise ""Klasse.class"".",Wie kann man in Java Klassen als Werte angeben?,"In Java können Klassen als Werte angegeben werden, indem man ein sogenanntes Klassenliteral verwendet, das aus dem Namen der Klasse, gefolgt von "".class"" besteht, also beispielsweise ""Klasse.class""."
"Der Typ eines solchen Klassenliterals ist ""Class<T>"", also im obigen Beispiel ""Class<Object>"". Da in Java-Programmen Klassennamen auch direkt vorkommen dürfen, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof"" (siehe Abschnitt 35.4), sind Klassenliterale eher selten anzutreffen. Die ganze Unterscheidung von Klassennamen und Klassenliteralen in Java ist meiner Meinung nach alles andere als glücklich.",Was ist ein Klassenliteral in Java?,"Ein Klassenliteral in Java ist eine Repräsentation einer Klasse, die in der Syntax der Programmiersprache ausgedrückt wird. Der Typ eines solchen Klassenliterals ist ""Class<T>"", also im obigen Beispiel ""Class<Object>"". Klassenliterale sind eher selten anzutreffen, da Klassennamen auch direkt vorkommen dürfen, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof""."
"Der Typ eines solchen Klassenliterals ist ""Class<T>"", also im obigen Beispiel ""Class<Object>"". Da in Java-Programmen Klassennamen auch direkt vorkommen dürfen, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof"" (siehe Abschnitt 35.4), sind Klassenliterale eher selten anzutreffen. Die ganze Unterscheidung von Klassennamen und Klassenliteralen in Java ist meiner Meinung nach alles andere als glücklich.",Was ist der Unterschied zwischen Klassennamen und Klassenliteralen in Java?,"In Java sind Klassennamen und Klassenliteralen zwei verschiedene Dinge. Klassennamen werden direkt verwendet, zum Beispiel als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof"". Klassenliteralen hingegen sind Objekte, die die Metaklasse einer Klasse repräsentieren. Sie werden mit dem Schlüsselwort ""Class"" und dem Klassennamen in spitzen Klammern erzeugt. Die Unterscheidung von Klassennamen und Klassenliteralen in Java ist nicht sehr intuitiv und wird eher selten verwendet."
"Wie Sie sehen, ist das Problem der kovarianten Redefinition ziemlich hartnäckig. Man muss aber gar nicht so weit gehen, um an die praktischen Grenzen der Typisierung zu gelangen. Nun könnte man einen Typ NotZero definieren und x als von diesem Typ deklarieren, womit der obige Ausdruck kein Problem mehr wäre. Selbst wenn es Typsysteme gibt, die das können, so sind diese kaum praxistauglich.",Was ist das Problem der kovarianten Redefinition?,"Das Problem der kovarianten Redefinition ist, dass es zu Typinkonsistenzen führen kann, wenn eine Unterklasse eine Methode mit demselben Namen wie eine Methode der Oberklasse definiert, aber mit einem anderen Rückgabetyp."
"Wie Sie sehen, ist das Problem der kovarianten Redefinition ziemlich hartnäckig. Man muss aber gar nicht so weit gehen, um an die praktischen Grenzen der Typisierung zu gelangen. Nun könnte man einen Typ NotZero definieren und x als von diesem Typ deklarieren, womit der obige Ausdruck kein Problem mehr wäre. Selbst wenn es Typsysteme gibt, die das können, so sind diese kaum praxistauglich.","Warum sind Typsysteme, die kovariante Redefinition erlauben, kaum praxistauglich?","Typsysteme, die kovariante Redefinition erlauben, sind kaum praxistauglich, weil sie zu Problemen führen können, wenn Objekte mit unterschiedlichen Typen miteinander interagieren. Wenn beispielsweise eine Methode, die ein Objekt erwartet, das von Typ A ist, ein Objekt erhält, das von Typ B ist, aber B von A abgeleitet ist, kann dies zu unerwarteten Ergebnissen führen, wenn die Methode versucht, auf die spezifischen Eigenschaften von A zuzugreifen, die in B nicht vorhanden sind. Dies kann zu Laufzeitfehlern führen und die Wartbarkeit und Zuverlässigkeit des Codes beeinträchtigen."
"Die Regeln des Subtypings aus Kapitel 26 und die damit verbundene Regelung der Zuweisungskompatibilität bezogen sich lediglich auf die Elemente einer Typdeklaration und somit auf rein statische Informationen. Um nun auch das Verhalten der Objekte eines Typs zu berücksichtigen, greift man auf eine Idee aus der formalen Programmverifikation zurück, nämlich die Überführung von Vorbedingungen in Nachbedingungen, ähnlich wie in (54.1).",Was ist die Idee hinter der Überführung von Vorbedingungen in Nachbedingungen?,"Die Idee hinter der Überführung von Vorbedingungen in Nachbedingungen stammt aus der formalen Programmverifikation und wird genutzt, um auch das Verhalten der Objekte eines Typs zu berücksichtigen. Dabei werden Vorbedingungen in Nachbedingungen überführt, um die Zuweisungskompatibilität zu regeln."
"Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methodenausführung, verletzt werden).","Was bedeutet es, wenn ein Typ als korrekt implementiert gilt?","Ein Typ wird als korrekt implementiert betrachtet, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt und dass die Invarianten des Typs höchstens temporär während der Methodenausführung verletzt werden."
"Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methodenausführung, verletzt werden).",Was ist eine Vorbedingung und Nachbedingung in der Objektorientierung?,"In der Objektorientierung ist eine Vorbedingung eine Bedingung, die vor der Ausführung einer Methode erfüllt sein muss. Die Nachbedingung ist eine Bedingung, die nach der Ausführung einer Methode erfüllt sein muss. Ein Typ gilt als korrekt implementiert, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung die Nachbedingung folgt."
"Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methodenausführung, verletzt werden).",Was beschreibt die Nachbedingung einer Methode?,"Die Nachbedingung einer Methode beschreibt den Zustand, in dem sich das Objekt nach der Ausführung der Methode befindet."
"Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methodenausführung, verletzt werden).",Was beschreibt die Vorbedingung einer Methode?,"Die Vorbedingung einer Methode beschreibt den Zustand, in dem sich ein Objekt befinden muss, damit die Methode aufgerufen werden kann."
"Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methodenausführung, verletzt werden).",Was sind Invarianten?,"Invarianten sind Bedingungen, die für alle Zustände eines Objekts gelten müssen."
"Damit meinen wir, dass für eine Implementierung von m in der zugehörigen Klasse von T, die auf einem Empfängerobjekt vom Typ T (einer Instanz der entsprechenden Klasse) aufgerufen wird, die Nachbedingung aus der Vorbedingung folgt. Wir müssen diesen Beweis jedoch nicht führen, da unser Interesse hier nicht auf der Korrektheit der Implementierungen an sich liegt, sondern vielmehr daran, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird und es durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Mehr dazu in Abschnitt 54.5.","Was ist der Zweck der Prüfung, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext?","Der Zweck der Prüfung ist es, festzustellen, ob ein Objekt durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird."
"Damit meinen wir, dass für eine Implementierung von m in der zugehörigen Klasse von T, die auf einem Empfängerobjekt vom Typ T (einer Instanz der entsprechenden Klasse) aufgerufen wird, die Nachbedingung aus der Vorbedingung folgt. Wir müssen diesen Beweis jedoch nicht führen, da unser Interesse hier nicht auf der Korrektheit der Implementierungen an sich liegt, sondern vielmehr daran, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird und es durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Mehr dazu in Abschnitt 54.5.",Was ist der Zweck der Nachbedingung in der objektorientierten Programmierung?,"Der Zweck der Nachbedingung in der objektorientierten Programmierung ist es, die Korrektheit der Implementierung zu gewährleisten. Die Nachbedingung wird aus der Vorbedingung abgeleitet und gilt für die Implementierung einer Methode in der zugehörigen Klasse. Der Beweis für die Nachbedingung muss nicht geführt werden, da es hier um die Austauschbarkeit von Implementierungen abhängig vom Verwendungskontext geht."
"Uns interessiert, ob eine umfassende Substituierung möglich ist. Konkret: Wir möchten eine verhaltensbasierte Subtypenrelation betrachten, das heißt, wir möchten die Bedingungen verstehen, die potenzielle Subtypen erfüllen müssen, damit sie die Spezifikation des Supertyps erfüllen und als verhaltenskonform betrachtet werden können. Dabei handelt es sich um eine Subtypenbeziehung, wie sie in Kapitel 26 beschrieben wird. Dies ist dann der Fall, wenn die obige Implikation auch für Objekte des potenziellen Subtypen S gilt.",Was ist eine verhaltensbasierte Subtypenrelation?,"Eine verhaltensbasierte Subtypenrelation ist eine Beziehung zwischen potenziellen Subtypen und Supertypen, bei der die Bedingungen betrachtet werden, die erfüllt sein müssen, damit die potenziellen Subtypen die Spezifikation des Supertyps erfüllen und als verhaltenskonform betrachtet werden können. Diese Beziehung wird in Kapitel 26 beschrieben."
"Man spricht dann von einem Behavior Subtyping, was am besten als verhaltensbasiertes Subtyping wiedergegeben wird.",Was ist verhaltensbasiertes Subtyping?,"Verhaltensbasiertes Subtyping, auch bekannt als Behavior Subtyping, ist ein Prinzip in der objektorientierten Programmierung, bei dem ein Untertyp die gleichen Methoden wie sein Obertyp haben muss, aber nicht unbedingt die gleichen Attribute. Das bedeutet, dass ein Objekt eines Untertyps die gleichen Methoden wie ein Objekt des Obertyps aufrufen kann, aber nicht umgekehrt."
"Man spricht dann von einem Behavior Subtyping, was am besten als verhaltensbasiertes Subtyping wiedergegeben wird.",Was ist Behavior Subtyping?,"Behavior Subtyping, auch verhaltensbasiertes Subtyping genannt, ist eine Art von Subtyping, bei der ein Untertyp die gleichen Methoden wie sein Obertyp haben muss, aber nicht unbedingt die gleichen Attribute."
"Wir müssen also sicherstellen, dass (6.3) erfüllt ist. Bei der Spezifikation der Methoden des (potenziellen Sub-)Typs S werden wir zunächst nicht auf die Vor- und Nachbedingungen von T zurückgreifen, sondern unsere eigenen definieren. Dies ist jedoch im Allgemeinen nicht der Fall. Die Frage lautet also: Wie müssen 𝑝𝑟𝑒𝑚S, 𝑝𝑟𝑒𝑚T, 𝑝𝑜𝑠𝑡𝑚S und 𝑝𝑜𝑠𝑡𝑚T miteinander in Beziehung stehen, damit Objekte vom Typ S die Anforderungen für Objekte vom Typ T erfüllen? Formal ausgedrückt: Was müssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), dem Verhalten von m in T angewandt auf Objekte aus S, folgt?Leider reicht es nicht aus, diese Frage zu beantworten. Aufgrund des weit verbreiteten Aliasings in der objektorientierten Programmierung kann ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel. Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht also nicht aus. Man kann bereits erahnen, dass diese Angelegenheit komplex wird.",Was ist das Problem mit der methodenweisen Betrachtung von Bedingungen für die Substituierbarkeit?,"Die methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht nicht aus, weil sie nicht berücksichtigt, dass ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden kann. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel."
"Wir müssen also sicherstellen, dass (6.3) erfüllt ist. Bei der Spezifikation der Methoden des (potenziellen Sub-)Typs S werden wir zunächst nicht auf die Vor- und Nachbedingungen von T zurückgreifen, sondern unsere eigenen definieren. Dies ist jedoch im Allgemeinen nicht der Fall. Die Frage lautet also: Wie müssen 𝑝𝑟𝑒𝑚S, 𝑝𝑟𝑒𝑚T, 𝑝𝑜𝑠𝑡𝑚S und 𝑝𝑜𝑠𝑡𝑚T miteinander in Beziehung stehen, damit Objekte vom Typ S die Anforderungen für Objekte vom Typ T erfüllen? Formal ausgedrückt: Was müssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), dem Verhalten von m in T angewandt auf Objekte aus S, folgt?Leider reicht es nicht aus, diese Frage zu beantworten. Aufgrund des weit verbreiteten Aliasings in der objektorientierten Programmierung kann ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel. Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht also nicht aus. Man kann bereits erahnen, dass diese Angelegenheit komplex wird.",Was ist das Problem mit der Substituierbarkeit von Objekten in der objektorientierten Programmierung?,"Das Problem ist, dass ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden kann. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel."
"Wir müssen also sicherstellen, dass (6.3) erfüllt ist. Bei der Spezifikation der Methoden des (potenziellen Sub-)Typs S werden wir zunächst nicht auf die Vor- und Nachbedingungen von T zurückgreifen, sondern unsere eigenen definieren. Dies ist jedoch im Allgemeinen nicht der Fall. Die Frage lautet also: Wie müssen 𝑝𝑟𝑒𝑚S, 𝑝𝑟𝑒𝑚T, 𝑝𝑜𝑠𝑡𝑚S und 𝑝𝑜𝑠𝑡𝑚T miteinander in Beziehung stehen, damit Objekte vom Typ S die Anforderungen für Objekte vom Typ T erfüllen? Formal ausgedrückt: Was müssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), dem Verhalten von m in T angewandt auf Objekte aus S, folgt?Leider reicht es nicht aus, diese Frage zu beantworten. Aufgrund des weit verbreiteten Aliasings in der objektorientierten Programmierung kann ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel. Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht also nicht aus. Man kann bereits erahnen, dass diese Angelegenheit komplex wird.",Was ist Aliasing in der objektorientierten Programmierung?,"Aliasing in der objektorientierten Programmierung bedeutet, dass mehrere Variablen auf dasselbe Objekt verweisen. Das kann dazu führen, dass Zustandsänderungen an dem Objekt von einem Klienten unerwartet für einen anderen Klienten sichtbar werden, da beide Klienten das Objekt über eine eigene Variable referenzieren."
"Wie Sie gesehen haben, hat das Typsystem Javas eine starke statische Komponente. Gleichwohl können nicht alle Typprüfungen zur Übersetzungszeit durchgeführt werden. Während man die dynamischen Typprüfungen bei Arrays (Kapitel 41) noch durch die Einführung von Wildcards hätte vermeiden können, gilt das nicht für die gelegentlich notwendigen Typumwandlungen (Type casts; zumindest nicht für alle).",Was ist das Typsystem von Java?,"Das Typsystem von Java hat eine starke statische Komponente, bei der jedoch nicht alle Typprüfungen zur Übersetzungszeit durchgeführt werden können. Für manche Typumwandlungen sind dynamische Typprüfungen notwendig."
"Wie Sie gesehen haben, hat das Typsystem Javas eine starke statische Komponente. Gleichwohl können nicht alle Typprüfungen zur Übersetzungszeit durchgeführt werden. Während man die dynamischen Typprüfungen bei Arrays (Kapitel 41) noch durch die Einführung von Wildcards hätte vermeiden können, gilt das nicht für die gelegentlich notwendigen Typumwandlungen (Type casts; zumindest nicht für alle).",Was ist der Zweck von Wildcards in Java?,"Der Zweck von Wildcards in Java ist es, die dynamischen Typprüfungen bei Arrays zu vermeiden."
"Wie Sie gesehen haben, hat das Typsystem Javas eine starke statische Komponente. Gleichwohl können nicht alle Typprüfungen zur Übersetzungszeit durchgeführt werden. Während man die dynamischen Typprüfungen bei Arrays (Kapitel 41) noch durch die Einführung von Wildcards hätte vermeiden können, gilt das nicht für die gelegentlich notwendigen Typumwandlungen (Type casts; zumindest nicht für alle).",Was sind Wildcards in Java?,"Wildcards in Java sind eine Möglichkeit, dynamische Typprüfungen bei Arrays zu vermeiden. Sie ermöglichen es, Arrays mit unterschiedlichen Typen zu verwenden, ohne dass statische Typprüfungen zur Übersetzungszeit erforderlich sind."
"In Java, wie auch in SMALLTALK, ist vorgesehen, dass alle Klassen außer Object von bereits existierenden Klassen ableiten können. Java verwendet dazu das Schlüsselwort ""extends."" Dadurch wird das Bestehen einer Subklassenbeziehung zwischen B und A deklariert. Die Verwendung von ""extends"" legt nahe, dass es sich dabei um eine Typerweiterung handelt, aus der (gemäß Kapitel 23) Zuweisungskompatibilität folgt, was tatsächlich der Fall ist.","Was bedeutet es, wenn eine Java-Klasse von einer anderen Klasse ableitet?","Wenn eine Java-Klasse von einer anderen Klasse ableitet, wird eine Subklassenbeziehung zwischen den beiden Klassen deklariert. Die abgeleitete Klasse erbt alle Eigenschaften und Methoden der Basisklasse und kann diese erweitern oder überschreiben. Diese Beziehung ermöglicht auch Zuweisungskompatibilität, was bedeutet, dass eine Instanz der abgeleiteten Klasse auch als Instanz der Basisklasse behandelt werden kann."
"Durch die Angabe einer ""extends""-Klausel gibt eine Klasse an, von welcher anderen Klasse sie die nicht als ""static"" deklarierten Member erbt. Da die erbende Klasse, auch in Java als Subklasse bezeichnet, die geerbten Methoden nur invariant überschreiben darf (und geerbte Felder in ihrer Sichtbarkeit nicht reduziert werden dürfen; s. Abschnitt 39.1), ist ihr Typ automatisch ein Subtyp des Typs der Klasse, von der sie erbt.","Was bedeutet die ""extends""-Klausel in einer Klassendeklaration in Java?","Durch die Angabe einer ""extends""-Klausel gibt eine Klasse in Java an, von welcher anderen Klasse sie die nicht als ""static"" deklarierten Member erbt. Die erbende Klasse ist automatisch ein Subtyp des Typs der Klasse, von der sie erbt."
"Durch die Angabe einer ""extends""-Klausel gibt eine Klasse an, von welcher anderen Klasse sie die nicht als ""static"" deklarierten Member erbt. Da die erbende Klasse, auch in Java als Subklasse bezeichnet, die geerbten Methoden nur invariant überschreiben darf (und geerbte Felder in ihrer Sichtbarkeit nicht reduziert werden dürfen; s. Abschnitt 39.1), ist ihr Typ automatisch ein Subtyp des Typs der Klasse, von der sie erbt.",Was ist der Unterschied zwischen einer Klasse und einem Objekt?,"Eine Klasse ist eine Art Blaupause oder Vorlage für die Erstellung von Objekten, während ein Objekt eine konkrete Instanz einer Klasse ist. Ein Objekt besitzt einen Zustand und ein Verhalten, das durch die Methoden der Klasse definiert wird, von der es abgeleitet ist."
"Durch die Angabe einer ""extends""-Klausel gibt eine Klasse an, von welcher anderen Klasse sie die nicht als ""static"" deklarierten Member erbt. Da die erbende Klasse, auch in Java als Subklasse bezeichnet, die geerbten Methoden nur invariant überschreiben darf (und geerbte Felder in ihrer Sichtbarkeit nicht reduziert werden dürfen; s. Abschnitt 39.1), ist ihr Typ automatisch ein Subtyp des Typs der Klasse, von der sie erbt.",Was ist der Unterschied zwischen einem Typ und einer Klasse?,"Ein Typ ist eine Menge von Objekten, die eine bestimmte Schnittstelle implementieren, während eine Klasse eine Blaupause oder Vorlage für die Erstellung von Objekten ist. Eine Klasse definiert den Zustand und das Verhalten ihrer Objekte, und ein Typ definiert die Schnittstelle, die von den Objekten implementiert werden muss."
"Durch die Angabe einer ""extends""-Klausel gibt eine Klasse an, von welcher anderen Klasse sie die nicht als ""static"" deklarierten Member erbt. Da die erbende Klasse, auch in Java als Subklasse bezeichnet, die geerbten Methoden nur invariant überschreiben darf (und geerbte Felder in ihrer Sichtbarkeit nicht reduziert werden dürfen; s. Abschnitt 39.1), ist ihr Typ automatisch ein Subtyp des Typs der Klasse, von der sie erbt.","Was bedeutet es, wenn der Typ einer Variablen eine Subklasse ist?","Wenn der Typ einer Variablen eine Subklasse ist, kann die Variable auf Objekte der Subklasse und der Oberklasse verweisen. Das bedeutet, dass die Variable auf Objekte verweisen kann, die die Methoden und Attribute der Oberklasse und der Subklasse besitzen."
"Wie in SMALLTALK gibt es in Java abstrakte Klassen. Anders als in SMALLTALK verwendet Java jedoch das Schlüsselwort ""abstract,"" mit dem man eine Klasse als abstrakt und damit als nicht instanziierbar deklarieren kann.",Wie werden abstrakte Klassen in Java deklariert?,"In Java werden abstrakte Klassen mit dem Schlüsselwort ""abstract"" deklariert, um sie als abstrakt und damit als nicht instanziierbar zu kennzeichnen."
"Wie in SMALLTALK gibt es in Java abstrakte Klassen. Anders als in SMALLTALK verwendet Java jedoch das Schlüsselwort ""abstract,"" mit dem man eine Klasse als abstrakt und damit als nicht instanziierbar deklarieren kann.","Was bedeutet es, wenn eine Klasse in Java als abstrakt deklariert wird?","Wenn eine Klasse in Java als abstrakt deklariert wird, bedeutet das, dass sie nicht instanziiert werden kann, d.h. es können keine Objekte dieser Klasse erzeugt werden. Diese Klasse dient lediglich als Basisklasse für andere Klassen und enthält in der Regel eine oder mehrere abstrakte Methoden, die von den Unterklassen implementiert werden müssen."
"Das bedeutet, dass von einer solchen Klasse keine Instanzen mehr gebildet werden dürfen (vgl. Abschnitt 10.3). Dieses Verbot, dessen Einhaltung vom Compiler überprüft wird, gilt unabhängig davon, ob von der Klasse Instanzen erstellt werden könnten. Selbst wenn alles, was für das Funktionieren der Instanzen benötigt wird, in der Klasse vorhanden ist (einschließlich Konstruktoren), darf sie nicht instanziiert werden. Häufiger fehlt jedoch in der Klasse die Implementierung von einer oder mehreren (bis hin zu allen) benötigten Methoden. Diese Methoden werden dann in der Klasse lediglich deklariert, und zwar ebenfalls mit dem Schlüsselwort ""abstract.""","Was bedeutet es, wenn eine Klasse als abstrakt markiert wird?","Wenn eine Klasse als abstrakt markiert wird, dürfen keine Instanzen mehr von dieser Klasse gebildet werden. Dieses Verbot gilt unabhängig davon, ob von der Klasse Instanzen erstellt werden könnten. Selbst wenn alles, was für das Funktionieren der Instanzen benötigt wird, in der Klasse vorhanden ist, darf sie nicht instanziiert werden."
"Man gibt dann hinter der Methodensignatur (also dem Namen und den Parametern) keine Implementierung (in geschweiften Klammern) an, sondern lediglich ein abschließendes Semikolon. Im Gegensatz dazu muss in SMALLTALK eine abstrakte Methode durch einen Aufruf von ""implementedBySubclass"" o. ä. gekennzeichnet werden (s. Abschnitt 10.3 in Kurseinheit 2).",Wie wird eine abstrakte Methode in SMALLTALK gekennzeichnet?,"In SMALLTALK wird eine abstrakte Methode durch einen Aufruf von ""implementedBySubclass"" o. ä. gekennzeichnet."
"Man gibt dann hinter der Methodensignatur (also dem Namen und den Parametern) keine Implementierung (in geschweiften Klammern) an, sondern lediglich ein abschließendes Semikolon. Im Gegensatz dazu muss in SMALLTALK eine abstrakte Methode durch einen Aufruf von ""implementedBySubclass"" o. ä. gekennzeichnet werden (s. Abschnitt 10.3 in Kurseinheit 2).",Wie wird eine abstrakte Methode in Smalltalk deklariert?,"In Smalltalk wird eine abstrakte Methode hinter der Methodensignatur (also dem Namen und den Parametern) nicht mit einer Implementierung (in geschweiften Klammern) deklariert, sondern lediglich mit einem abschließenden Semikolon. Zusätzlich muss die Methode durch einen Aufruf von ""implementedBySubclass"" o. ä. gekennzeichnet werden."
"Man gibt dann hinter der Methodensignatur (also dem Namen und den Parametern) keine Implementierung (in geschweiften Klammern) an, sondern lediglich ein abschließendes Semikolon. Im Gegensatz dazu muss in SMALLTALK eine abstrakte Methode durch einen Aufruf von ""implementedBySubclass"" o. ä. gekennzeichnet werden (s. Abschnitt 10.3 in Kurseinheit 2).",Was ist der Begriff des Ausdrucks in der objektorientierten Programmierung?,"In der objektorientierten Programmierung ist ein Ausdruck eine Kombination von Operatoren und Operanden, die zu einem neuen Wert ausgewertet wird. Ein Ausdruck kann eine Variable, eine Konstante, eine Funktion, eine Methode oder eine Kombination aus diesen Elementen sein. Er beschreibt das Verhalten eines Objekts, indem er eine Aktion ausführt oder eine Information bereitstellt."
"Die Aufforderung, eine abstrakte Methode in einer Subklasse zu implementieren, gibt es in Java ebenfalls, jedoch nicht als Laufzeitfehler auf der Programmausführungsebene, sondern auf der Compiler-Ebene. Wenn man von einer abstrakten Klasse (per ""extends"") ableitet, dann muss die abgeleitete Klasse entweder selbst als abstrakt deklariert sein, oder man muss alle abstrakten Methoden der Klasse, von der sie ableitet, mit Implementierungen versehen. Tut man das nicht, erhält man vom Compiler eine entsprechende Aufforderung.","Was passiert, wenn man in Java eine abstrakte Klasse ableitet und die abstrakten Methoden nicht implementiert?","Wenn man in Java eine abstrakte Klasse ableitet und die abstrakten Methoden nicht implementiert, erhält man vom Compiler eine entsprechende Aufforderung."
"Komplementär zur ""abstract""-Deklaration gibt es in Java auch die Möglichkeit, zu verhindern, dass von einer Klasse abgeleitet wird. Man verwendet dafür einfach das Schlüsselwort ""final."" Das Gleiche gilt für einzelne Methoden, deren Überschreiben in einer Subklasse durch eine ""final""-Deklaration verhindert werden kann. Eine einfache, goldene Regel der objektorientierten Programmierung besagt übrigens, dass man alle Klassen entweder als abstrakt oder als final deklarieren sollte. Dies fördert das Prinzip der abstrakten Generalisierung und vermeidet die Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien (Kapitel 9 in Kurseinheit 2 und 69 in Kurseinheit 6).","Was bedeutet es, wenn eine Klasse in Java als ""final"" deklariert wird?","Wenn eine Klasse in Java als ""final"" deklariert wird, verhindert es, dass von dieser Klasse abgeleitet wird."
"Komplementär zur ""abstract""-Deklaration gibt es in Java auch die Möglichkeit, zu verhindern, dass von einer Klasse abgeleitet wird. Man verwendet dafür einfach das Schlüsselwort ""final."" Das Gleiche gilt für einzelne Methoden, deren Überschreiben in einer Subklasse durch eine ""final""-Deklaration verhindert werden kann. Eine einfache, goldene Regel der objektorientierten Programmierung besagt übrigens, dass man alle Klassen entweder als abstrakt oder als final deklarieren sollte. Dies fördert das Prinzip der abstrakten Generalisierung und vermeidet die Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien (Kapitel 9 in Kurseinheit 2 und 69 in Kurseinheit 6).","Was bewirkt die ""final""-Deklaration einer Methode in Java?","Durch die ""final""-Deklaration einer Methode in Java wird das Überschreiben der Methode in einer Subklasse verhindert."
"Komplementär zur ""abstract""-Deklaration gibt es in Java auch die Möglichkeit, zu verhindern, dass von einer Klasse abgeleitet wird. Man verwendet dafür einfach das Schlüsselwort ""final."" Das Gleiche gilt für einzelne Methoden, deren Überschreiben in einer Subklasse durch eine ""final""-Deklaration verhindert werden kann. Eine einfache, goldene Regel der objektorientierten Programmierung besagt übrigens, dass man alle Klassen entweder als abstrakt oder als final deklarieren sollte. Dies fördert das Prinzip der abstrakten Generalisierung und vermeidet die Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien (Kapitel 9 in Kurseinheit 2 und 69 in Kurseinheit 6).",Was besagt die goldene Regel der objektorientierten Programmierung bezüglich der Deklaration von Klassen als abstrakt oder final?,"Die goldene Regel der objektorientierten Programmierung besagt, dass man alle Klassen entweder als abstrakt oder als final deklarieren sollte. Dies fördert das Prinzip der abstrakten Generalisierung und vermeidet die Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien."
"Die öffentliche Schnittstelle einer Klasse in Java ist die Menge ihrer Instanzvariablen und -methoden (in Java zusammen auch Member genannt), die public deklariert sind. Nun gibt es in Java die Möglichkeit, eine öffentliche Schnittstelle als eigenständiges Konstrukt zu deklarieren, das von dem der Klasse unabhängig ist, das aber genauso wie eine Klasse einen Typ definiert. Es geschieht dies mit Hilfe des Schlüsselwortes ""interface"":",Was ist eine öffentliche Schnittstelle in Java?,"In Java ist eine öffentliche Schnittstelle eine eigenständige Deklaration, die von der Klasse unabhängig ist und einen Typ definiert. Sie wird mit Hilfe des Schlüsselwortes ""interface"" deklariert und enthält eine Menge von Instanzvariablen und -methoden, die public deklariert sind."
"Die öffentliche Schnittstelle einer Klasse in Java ist die Menge ihrer Instanzvariablen und -methoden (in Java zusammen auch Member genannt), die public deklariert sind. Nun gibt es in Java die Möglichkeit, eine öffentliche Schnittstelle als eigenständiges Konstrukt zu deklarieren, das von dem der Klasse unabhängig ist, das aber genauso wie eine Klasse einen Typ definiert. Es geschieht dies mit Hilfe des Schlüsselwortes ""interface"":",Was ist der Unterschied zwischen einer Klasse und einem Interface in Java?,"Ein Interface in Java ist ein eigenständiges Konstrukt, das eine öffentliche Schnittstelle definiert, während eine Klasse sowohl eine öffentliche Schnittstelle als auch eine Implementierung der Methoden bereitstellt. Ein Interface kann nur Methoden deklarieren, aber keine Implementierungen bereitstellen. Eine Klasse hingegen kann eine Implementierung für die Methoden bereitstellen, die in einem Interface deklariert sind. Ein Interface kann von mehreren Klassen implementiert werden, während eine Klasse nur von einer Superklasse erben kann."
"Anders als bei Klassen entspricht hier das Fehlen eines Zugriffsmodifikators der Zugreifbarkeit ""public"" — alles andere scheint für eine Schnittstelle auch unsinnig. Folgende weitere syntaktischen Unterschiede der Interfacedeklaration in den Zeilen 1029–1032 zur Klassendefinition der Zeilen 986–991 fallen auf: die Verwendung des Schlüsselwortes ""interface"" anstelle von ""class"" (klar), das Fehlen von Felddeklarationen und der Umstand, dass der Methodendeklaration keine Implementierung mehr folgt, sondern lediglich das abschließende Semikolon.",Was ist der Unterschied zwischen einer Klassendeklaration und einer Interfacedeklaration?,"Eine Klassendeklaration enthält Felddeklarationen und eine Implementierung der Methoden, während eine Interfacedeklaration nur die Methodensignatur ohne Implementierung enthält und keine Felddeklarationen. Zudem wird für eine Interfacedeklaration das Schlüsselwort ""interface"" anstelle von ""class"" verwendet."
"Das Schlüsselwort ""abstract"", das eine Klasse für eine solche Methodendeklaration anführen müsste, wird in Interfaces automatisch angenommen; Interfaces liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begründung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen Deklaration und Implementierung (Definition; s. Kapitel 19 in Kurseinheit 3) unterschieden werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch für eine Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes), wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter und Setter) ersetzt werden kann.",Was ist der Zweck von Interfaces in der objektorientierten Programmierung?,"Interfaces in der objektorientierten Programmierung definieren eine Schnittstelle für Klassen, die die Methoden und Konstanten enthalten, die eine Klasse implementieren muss, um ein bestimmtes Verhalten zu zeigen. Sie liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Felder werden aus den Interfaces verbannt, können aber durch Zugriffsmethoden (Accessoren) ersetzt werden."
"Das Schlüsselwort ""abstract"", das eine Klasse für eine solche Methodendeklaration anführen müsste, wird in Interfaces automatisch angenommen; Interfaces liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begründung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen Deklaration und Implementierung (Definition; s. Kapitel 19 in Kurseinheit 3) unterschieden werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch für eine Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes), wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter und Setter) ersetzt werden kann.",Warum können Interfaces keine Implementierungen oder Objekte liefern?,"Interfaces können keine Implementierungen oder Objekte liefern, weil sie lediglich eine Schnittstelle definieren, die von Klassen implementiert werden kann. Sie legen lediglich fest, welche Methoden eine Klasse implementieren muss, um ein bestimmtes Interface zu implementieren."
"Das Schlüsselwort ""abstract"", das eine Klasse für eine solche Methodendeklaration anführen müsste, wird in Interfaces automatisch angenommen; Interfaces liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begründung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen Deklaration und Implementierung (Definition; s. Kapitel 19 in Kurseinheit 3) unterschieden werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch für eine Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes), wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter und Setter) ersetzt werden kann.",Warum gibt es in Interfaces keine Felder?,"In Interfaces gibt es keine Felder, weil bei Feldern nicht zwischen Deklaration und Implementierung unterschieden werden kann. Da Interfaces lediglich Schnittstellen definieren, die von Klassen implementiert werden können, wurden Felder aus den Interfaces verbannt. Stattdessen können Feldzugriffe in Interfaces durch Zugriffsmethoden (Accessoren) ersetzt werden."
"Eine Klasse kann nun angeben, dass sie ein Interface implementiert. Sie tut das unter Verwendung des Schlüsselwortes ""implements"". Damit verpflichtet sich die Klasse, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten. Dabei kann eine Klasse mehrere Interfaces gleichzeitig implementieren (die entsprechenden Namen werden einfach, durch Kommata getrennt, überlassen; in diesem Fall muss die Methode aber zumindest als abstrakt deklariert werden. Interface - aneinandergehängt); zugleich ist die Angabe der implementierten Interfaces eine nominale Typkonformitätsdeklaration, d. h., Instanzen der Klasse sind mit allen Variablen jedes der genannten Interfaces zuweisungskompatibel.","Was bedeutet es, wenn eine Klasse ein Interface implementiert?","Wenn eine Klasse ein Interface implementiert, verpflichtet sie sich, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten. Zudem ist die Angabe der implementierten Interfaces eine nominale Typkonformitätsdeklaration, d.h. Instanzen der Klasse sind mit allen Variablen jedes der genannten Interfaces zuweisungskompatibel."
"Es definieren also die Interfaces von Java genau wie Klassen Typen und können daher genauso wie Klassen in Variablendeklarationen verwendet werden. Der Type checker garantiert dann, dass auf der Variable mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ. Eine genauere Betrachtung der Bedeutung der Verwendung von Interfaces erfolgt in Kapitel 45.",Was ist die Funktion von Interfaces in Java?,"Interfaces definieren Typen in Java und können daher in Variablendeklarationen verwendet werden. Der Type checker garantiert, dass auf der Variablen mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können."
"Es definieren also die Interfaces von Java genau wie Klassen Typen und können daher genauso wie Klassen in Variablendeklarationen verwendet werden. Der Type checker garantiert dann, dass auf der Variable mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ. Eine genauere Betrachtung der Bedeutung der Verwendung von Interfaces erfolgt in Kapitel 45.",Was sind Interfaces in Java und wie werden sie verwendet?,"Interfaces in Java definieren Typen und können daher in Variablendeklarationen verwendet werden. Der Type checker garantiert, dass auf der Variablen mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ."
"Es kann also eine Klasse in Java zwar nur direkte Subklasse genau einer anderen Klasse sein, dafür aber mehrere Interfaces gleichzeitig implementieren. Diese mögliche „Mehrfachimplementierung“ von Interfaces wurde häufig als Ersatz für die in Java fehlende Möglichkeit der Mehrfachvererbung angepriesen — das aber war Unsinn, denn bei der Implementierung eines Interfaces wurde nichts vererbt (sieht man mal von der sog. Interfacevererbung ab, die aber auch keine wirkliche Vererbung ist, denn auch die Deklarationen werden nicht automatisch von einem Interface auf seine implementierenden Klassen übertragen, sondern müssen dort wiederholt werden). Vielmehr hat man es mit einer Art Mehrfach - Subtyping zu tun, das aber auch ganz nett ist, wie die Überlegungen in Kapitel 45 zeigen werden.",Was ist Interfacevererbung in Java?,"Interfacevererbung in Java bedeutet, dass eine Klasse mehrere Interfaces gleichzeitig implementieren kann. Dabei wird nichts vererbt, sondern es handelt sich um eine Art Mehrfach-Subtyping."
"Es kann also eine Klasse in Java zwar nur direkte Subklasse genau einer anderen Klasse sein, dafür aber mehrere Interfaces gleichzeitig implementieren. Diese mögliche „Mehrfachimplementierung“ von Interfaces wurde häufig als Ersatz für die in Java fehlende Möglichkeit der Mehrfachvererbung angepriesen — das aber war Unsinn, denn bei der Implementierung eines Interfaces wurde nichts vererbt (sieht man mal von der sog. Interfacevererbung ab, die aber auch keine wirkliche Vererbung ist, denn auch die Deklarationen werden nicht automatisch von einem Interface auf seine implementierenden Klassen übertragen, sondern müssen dort wiederholt werden). Vielmehr hat man es mit einer Art Mehrfach - Subtyping zu tun, das aber auch ganz nett ist, wie die Überlegungen in Kapitel 45 zeigen werden.",Was ist der Unterschied zwischen Mehrfachvererbung und Mehrfach-Subtyping in Java?,"Mehrfachvererbung bezieht sich auf die Fähigkeit einer Klasse, Eigenschaften und Methoden von mehr als einer Superklasse zu erben, während Mehrfach-Subtyping darauf beruht, dass eine Klasse mehr als einem Interface gleichzeitig implementieren kann. Im Gegensatz zur Mehrfachvererbung wird bei der Implementierung eines Interface nichts vererbt, sondern es wird eine Art Mehrfach-Subtyping erreicht, das auch nützlich sein kann."
"In Java ist die Typkonformität und damit die Zuweisungskompatibilität unter Referenztypen an Subtyping gebunden. Damit Ausdrücke von einem Typ Variablen eines anderen zugeordnet werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen den beiden bestehen. In den meisten Fällen muss die Subtypbeziehung explizit deklariert werden; Java setzt also auf nominale Typkonformität. Dies hat den Vorteil der Filterfunktion, wie in Abschnitt 22.2 von Kurseinheit 3 beschrieben, aber auch den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen. Dies kann insbesondere bei verteilten Anwendungen problematisch sein, deren Teile nicht von vornherein für einander entworfen wurden (zum Beispiel Web Services).",Was ist Typkonformität in Java?,"In Java ist die Typkonformität und damit die Zuweisungskompatibilität unter Referenztypen an Subtyping gebunden. Damit Ausdrücke von einem Typ Variablen eines anderen zugeordnet werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen den beiden bestehen. Java setzt auf nominale Typkonformität, das heißt, dass Subtypen ihre Supertypen namentlich kennen müssen."
"In Java ist die Typkonformität und damit die Zuweisungskompatibilität unter Referenztypen an Subtyping gebunden. Damit Ausdrücke von einem Typ Variablen eines anderen zugeordnet werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen den beiden bestehen. In den meisten Fällen muss die Subtypbeziehung explizit deklariert werden; Java setzt also auf nominale Typkonformität. Dies hat den Vorteil der Filterfunktion, wie in Abschnitt 22.2 von Kurseinheit 3 beschrieben, aber auch den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen. Dies kann insbesondere bei verteilten Anwendungen problematisch sein, deren Teile nicht von vornherein für einander entworfen wurden (zum Beispiel Web Services).",Was ist nominale Typkonformität in Java?,"In Java ist nominale Typkonformität eine Art von Typkonformität, bei der die Typen entweder identisch sein müssen oder eine Subtypbeziehung zwischen den beiden bestehen muss, die explizit deklariert werden muss. Das bedeutet, dass Subtypen ihre Supertypen namentlich kennen müssen."
"Weiterhin verlangt das Subtyping in Java, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen. Java verlangt also Kovarianz. Dadurch wird zumindest eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt (vergleiche Abschnitt 26.3 und Kapitel 54 in Kurseinheit 6). Allerdings kann der Rückgabetyp von Methoden kovariant redefiniert werden; mehr dazu in Abschnitt 36.4.",Was ist Kovarianz in Java?,"In Java ist Kovarianz eine Regel im Subtyping, die vorschreibt, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen. Dadurch wird eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt."
"Weiterhin verlangt das Subtyping in Java, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen. Java verlangt also Kovarianz. Dadurch wird zumindest eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt (vergleiche Abschnitt 26.3 und Kapitel 54 in Kurseinheit 6). Allerdings kann der Rückgabetyp von Methoden kovariant redefiniert werden; mehr dazu in Abschnitt 36.4.",Was verlangt das Subtyping in Java?,"Das Subtyping in Java verlangt, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen, was Kovarianz bedeutet. Dadurch wird eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt. Allerdings kann der Rückgabetyp von Methoden kovariant redefiniert werden."
"Im Gegensatz zu ihren Vorläufern SMALLTALK und C++ ist Java eine Sprache mit einem strengen Typsystem. Das bedeutet insbesondere, dass in Java alle Typfehler entweder schon während der Übersetzung durch den Compiler oder während der Laufzeit, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung (bei der eine Typinvariante verletzt wird), erkannt werden. In einem Fall kann jedoch die Meinung vertreten werden, dass die Typinvarianten in Java zu lasch sind und Zuweisungen gestattet werden, bei denen nicht ausgeschlossen werden kann, dass sie später zu einem Typfehler führen. Hierzu mehr in Kapitel 41.",Wie ist das Typsystem in Java im Vergleich zu SMALLTALK und C++?,"Im Gegensatz zu SMALLTALK und C++ ist Java eine Sprache mit einem strengen Typsystem, bei der alle Typfehler entweder während der Übersetzung durch den Compiler oder während der Laufzeit erkannt werden."
"Im Gegensatz zu ihren Vorläufern SMALLTALK und C++ ist Java eine Sprache mit einem strengen Typsystem. Das bedeutet insbesondere, dass in Java alle Typfehler entweder schon während der Übersetzung durch den Compiler oder während der Laufzeit, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung (bei der eine Typinvariante verletzt wird), erkannt werden. In einem Fall kann jedoch die Meinung vertreten werden, dass die Typinvarianten in Java zu lasch sind und Zuweisungen gestattet werden, bei denen nicht ausgeschlossen werden kann, dass sie später zu einem Typfehler führen. Hierzu mehr in Kapitel 41.",Was ist ein strenges Typsystem in Java?,"Ein strenges Typsystem in Java bedeutet, dass alle Typfehler während der Übersetzung durch den Compiler oder während der Laufzeit erkannt werden, insbesondere bei einer Wertzuweisung, bei der eine Typinvariante verletzt wird."
"Ausdrücke allein sind lediglich syntaktische Elemente; um das Objekt zu erhalten, für das sie stehen, müssen sie ausgewertet werden. Die Auswertung ist der Prozess, bei dem ein Programm tatsächlich ""etwas tut"".",Was ist die Auswertung von Ausdrücken?,"Die Auswertung von Ausdrücken ist der Prozess, bei dem ein Programm tatsächlich Aktionen ausführt. Sie ist wichtig, weil sie den eigentlichen ""Tätigkeitsprozess"" eines Programms darstellt und sicherstellt, dass die gewünschten Operationen durchgeführt werden."
"Eine der grundlegendsten Aktionen, die ein Programm durchführen kann, ist die Auswertung einer Zuweisung, wie zum Beispiel y := x. Diese Auswertung bewirkt, dass die Variable y nach der Zuweisung auf dasselbe Objekt verweist wie zuvor x. Dabei steht der gesamte Ausdruck y := x für (eine Referenz auf) das Objekt, auf das x (und nach seiner Auswertung auch y) verweist. Die Zuweisung dieses Objektes an y ist eine Art Seiteneffekt der Auswertung des Ausdrucks.Es ist wichtig zu beachten, dass der Zuweisungsoperator := keinen (binären) Nachrichtenselektor darstellt. Hier wird keine Nachricht an ein Objekt gesendet, sondern der Inhalt einer Variable wird verändert. Die Zuweisung ist tatsächlich eine der wenigen Primitiven Ausdrücke in SMALLTALK und gehört zu den fest in die Sprache integrierten Operationen.",Was ist eine Zuweisung?,"Eine Zuweisung ist eine Aktion, bei der der Inhalt einer Variable geändert wird. Die Zuweisung selbst steht für (eine Referenz auf) das Objekt. Dies ist eine Art von Seiteneffekt der Auswertung des Ausdrucks."
"Eine der grundlegendsten Aktionen, die ein Programm durchführen kann, ist die Auswertung einer Zuweisung, wie zum Beispiel y := x. Diese Auswertung bewirkt, dass die Variable y nach der Zuweisung auf dasselbe Objekt verweist wie zuvor x. Dabei steht der gesamte Ausdruck y := x für (eine Referenz auf) das Objekt, auf das x (und nach seiner Auswertung auch y) verweist. Die Zuweisung dieses Objektes an y ist eine Art Seiteneffekt der Auswertung des Ausdrucks.Es ist wichtig zu beachten, dass der Zuweisungsoperator := keinen (binären) Nachrichtenselektor darstellt. Hier wird keine Nachricht an ein Objekt gesendet, sondern der Inhalt einer Variable wird verändert. Die Zuweisung ist tatsächlich eine der wenigen Primitiven Ausdrücke in SMALLTALK und gehört zu den fest in die Sprache integrierten Operationen.",Was sind primitive Ausdrücke in SMALLTALK?,Die Zuweisung wird in SMALLTALK als primitiver Ausdruck betrachtet.
"Die Verwendung des Begriffs ""Seiteneffekt"" ist möglicherweise nicht notwendig, wenn ""Wirkung"" oder ""Effekt"" verwendet wird, da der erzielte Effekt das Hauptziel einer Zuweisung ist.Nachrichtenausdrücke werden ausgewertet, indem die Nachricht (das Prädikat des Satzes) an das Empfängerobjekt (das Subjekt) mit den Parametern (den Prädikatsergänzungen) gesendet wird, und das Empfängerobjekt liefert als Ergebnis der Nachricht ein Objekt zurück. Die genauen Mechanismen zur Bestimmung des Ergebnisobjekts durch das Empfängerobjekt werden später erläutert. Hier ist nur wichtig zu wissen, dass der Nachrichtenausdruck während der Auswertung praktisch durch das Objekt ersetzt wird, für das er steht. Dies kann ähnlich betrachtet werden wie die Auswertung einer (mathematischen) Funktion f, deren Funktionsanwendung f(x) für den Funktionswert steht.Eine häufig verwendete unäre Nachricht, die von allen Objekten verstanden wird, ist printString. In Reaktion darauf gibt das Empfängerobjekt normalerweise eine textuelle Repräsentation von sich zurück.",Wie werden Nachrichtenausdrücke in SMALLTALK ausgewertet?,"Nachrichtenausdrücke in SMALLTALK werden ausgewertet, indem die Nachricht (das Prädikat) an das Empfängerobjekt (das Subjekt) mit den Parametern (Prädikatsergänzungen) gesendet wird. Nach der Auswertung repräsentiert der Nachrichtenausdruck das Ergebnis der Nachricht, das von dem Empfängerobjekt zurückgegeben wird."
"In SMALLTALK, anders als in Sprachen wie Java oder C-Sharp, bei denen Methoden mit dem Rückgabetyp ""void"" deklariert werden können, ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben. Dies könnte in Zeile 70 als sinnvoll angesehen werden, da dort lediglich an dem (Seiten-)Effekt, der Ausgabe von „12“ auf dem Transcript, interessiert ist. Wenn die Methode, die zur Nachricht gehört, keinen sinnvollen Rückgabewert hat, wird standardmäßig immer das Empfängerobjekt zurückgegeben. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API. Wenn der Rückgabewert des Nachrichtenausdrucks im Kontext der Nachricht keine Verwendung findet, verfällt er einfach. Die Existenz des Objekts wird jedoch nur dann beeinflusst, wenn es keine weiteren Referenzen auf das Objekt gibt und es bei der nächsten Speicherbereinigung entfernt wird.","Ist es in SMALLTALK möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben?","In SMALLTALK ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben, da jeder Nachrichtenversand ein Ergebnis zurückgibt. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API (fließende Programmierung)."
"Die Auswertung eines Nachrichtenausdrucks führt zur Ausführung der Anweisungen im Rumpf einer Methode, weshalb sie auch als Methodenaufruf bezeichnet wird.Zusammenfassend wird: Ein Literal zu dem Objekt ausgewertet wird, das es repräsentiert. Eine Variable zu dem Objekt ausgewertet wird, das sie benennt. Eine Zuweisung zu dem Objekt ausgewertet wird, zu dem der Ausdruck auf der rechten Seite der Zuweisung ausgewertet wird. Ein Nachrichtenausdruck zu dem Objekt ausgewertet wird, das als Antwort auf die Nachricht zurückgegeben wird. Ein kaskadierter Nachrichtenausdruck zu dem Objekt ausgewertet wird, zu dem sein letzter Nachrichtenausdruck ausgewertet wird.",Was ist ein Methodenaufruf?,"Ein Methodenaufruf ist die Auswertung eines Nachrichtenausdrucks, da diese zur Ausführung der Anweisungen im Rumpf einer Methode führt."
"Objekte, die keine literale Repräsentation haben, müssen in Java (wie in SMALLTALK) explizit als Instanzen von Klassen erzeugt werden. Dafür gibt es in Java eine spezielle Kategorie von Methoden, die als Konstruktoren bezeichnet werden. Im Unterschied zu SMALLTALK sind Konstruktoren in Java keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne kann man Konstruktoren als Instanzmethoden betrachten, die auf der neu erzeugten Instanz aufgerufen werden.",Was sind Konstruktoren in Java?,"Konstruktoren sind spezielle Methoden in Java, die verwendet werden, um Objekte zu erzeugen, die keine literale Repräsentation haben. Sie sind keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können."
"Objekte, die keine literale Repräsentation haben, müssen in Java (wie in SMALLTALK) explizit als Instanzen von Klassen erzeugt werden. Dafür gibt es in Java eine spezielle Kategorie von Methoden, die als Konstruktoren bezeichnet werden. Im Unterschied zu SMALLTALK sind Konstruktoren in Java keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne kann man Konstruktoren als Instanzmethoden betrachten, die auf der neu erzeugten Instanz aufgerufen werden.",Was unterscheidet Konstruktoren in Java im Vergleich zu SMALLTALK?,"Im Gegensatz zu SMALLTALK sind Konstruktoren in Java keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Sie verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne können Konstruktoren als Instanzmethoden betrachtet werden, die auf der neu erzeugten Instanz aufgerufen werden."
"Konstruktoren können somit alle Anweisungen enthalten, die in SMALLTALK durch die spezielle Methode ""initialize"" notwendig waren (vgl. Abschnitt 8.2 in Kurseinheit 2). Allerdings sind Konstruktoren auch wie Klassenmethoden, da sie nicht auf einer Instanz, sondern auf der Klasse aufgerufen werden. In Java wird dafür jedoch kein spezieller Methodenname wie ""new"" wie in SMALLTALK verwendet, sondern der Klassennamen selbst.",Wie werden Konstruktoren in Java definiert?,"In Java werden Konstruktoren definiert, indem man eine Methode mit demselben Namen wie die Klasse erstellt, die keine Rückgabewerte besitzt. Sie werden aufgerufen, indem man den Klassennamen verwendet, gefolgt von Klammern."
"Konstruktoren können somit alle Anweisungen enthalten, die in SMALLTALK durch die spezielle Methode ""initialize"" notwendig waren (vgl. Abschnitt 8.2 in Kurseinheit 2). Allerdings sind Konstruktoren auch wie Klassenmethoden, da sie nicht auf einer Instanz, sondern auf der Klasse aufgerufen werden. In Java wird dafür jedoch kein spezieller Methodenname wie ""new"" wie in SMALLTALK verwendet, sondern der Klassennamen selbst.",Wie werden Konstruktoren in Java aufgerufen?,"In Java werden Konstruktoren nicht durch einen speziellen Methodennamen wie ""new"" aufgerufen, sondern durch den Klassennamen selbst."
"Konstruktoren können somit alle Anweisungen enthalten, die in SMALLTALK durch die spezielle Methode ""initialize"" notwendig waren (vgl. Abschnitt 8.2 in Kurseinheit 2). Allerdings sind Konstruktoren auch wie Klassenmethoden, da sie nicht auf einer Instanz, sondern auf der Klasse aufgerufen werden. In Java wird dafür jedoch kein spezieller Methodenname wie ""new"" wie in SMALLTALK verwendet, sondern der Klassennamen selbst.",Was ist der Unterschied zwischen Konstruktoren und Klassenmethoden in Java?,"Der Unterschied zwischen Konstruktoren und Klassenmethoden in Java ist, dass Konstruktoren auf der Klasse aufgerufen werden und dazu dienen, ein neues Objekt zu initialisieren, während Klassenmethoden ebenfalls auf der Klasse aufgerufen werden, aber kein neues Objekt erstellen."
"Im Vergleich zu anderen Methoden erlauben Konstruktordefinitionen in Java keine Angabe eines Rückgabetyps. Da die erzeugte Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist, ist der Typ festgelegt. Die Angabe des Rückgabetyps in Konstruktordefinitionen ist daher nicht erforderlich.",Warum wird im Kontext kein Rückgabetyp für den Konstruktor angegeben?,"Im Vergleich zu anderen Methoden erlauben Konstruktordefinitionen in Java keine Angabe eines Rückgabetyps. Da die erzeugte Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist, ist der Typ festgelegt."
"Im Vergleich zu anderen Methoden erlauben Konstruktordefinitionen in Java keine Angabe eines Rückgabetyps. Da die erzeugte Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist, ist der Typ festgelegt. Die Angabe des Rückgabetyps in Konstruktordefinitionen ist daher nicht erforderlich.",Warum ist die Angabe des Rückgabetyps in Konstruktordefinitionen in Java nicht erforderlich?,"In Konstruktordefinitionen in Java ist die Angabe des Rückgabetyps nicht erforderlich, weil der Typ der erzeugten Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist. Somit ist der Typ der Instanz bereits festgelegt und muss nicht explizit angegeben werden."
"Wenn kein Konstruktor definiert wird, verwendet Java standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse. Konstruktoren werden nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen. Um dieses Verhalten zu überschreiben, kann man innerhalb eines Konstruktors einen Konstruktor der Superklasse mittels ""super"" aufrufen. Dabei werden die in ""super"" aufgerufenen Methoden dynamisch gebunden, was dazu führen kann, dass auf noch nicht initialisierte Variablen zugegriffen wird. Die gesamte Thematik rund um Konstruktoren und die Initialisierung von Variablen in Java ist recht komplex. Da Instanziierung und Initialisierung grundlegende und für jedes Programm unverzichtbare Vorgänge sind, ist Java möglicherweise nicht die ideale Programmiersprache für Anfänger.",Was ist der Zweck eines Konstruktors in Java?,"Der Zweck eines Konstruktors in Java ist es, eine neue Instanz der Klasse zu erzeugen und gegebenenfalls die Variablen der Klasse zu initialisieren. Wird kein Konstruktor definiert, wird standardmäßig ein impliziter parameterloser Konstruktor verwendet. Konstruktoren werden nicht vererbt, aber beim Erzeugen einer Instanz einer Subklasse wird automatisch der Standardkonstruktor der Superklasse aufgerufen."
"Wenn kein Konstruktor definiert wird, verwendet Java standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse. Konstruktoren werden nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen. Um dieses Verhalten zu überschreiben, kann man innerhalb eines Konstruktors einen Konstruktor der Superklasse mittels ""super"" aufrufen. Dabei werden die in ""super"" aufgerufenen Methoden dynamisch gebunden, was dazu führen kann, dass auf noch nicht initialisierte Variablen zugegriffen wird. Die gesamte Thematik rund um Konstruktoren und die Initialisierung von Variablen in Java ist recht komplex. Da Instanziierung und Initialisierung grundlegende und für jedes Programm unverzichtbare Vorgänge sind, ist Java möglicherweise nicht die ideale Programmiersprache für Anfänger.","Was passiert, wenn kein Konstruktor in Java definiert wird?","Wenn kein Konstruktor in Java definiert wird, verwendet Java standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse."
"Wenn kein Konstruktor definiert wird, verwendet Java standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse. Konstruktoren werden nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen. Um dieses Verhalten zu überschreiben, kann man innerhalb eines Konstruktors einen Konstruktor der Superklasse mittels ""super"" aufrufen. Dabei werden die in ""super"" aufgerufenen Methoden dynamisch gebunden, was dazu führen kann, dass auf noch nicht initialisierte Variablen zugegriffen wird. Die gesamte Thematik rund um Konstruktoren und die Initialisierung von Variablen in Java ist recht komplex. Da Instanziierung und Initialisierung grundlegende und für jedes Programm unverzichtbare Vorgänge sind, ist Java möglicherweise nicht die ideale Programmiersprache für Anfänger.","Was bewirkt der Aufruf von ""super"" in einem Konstruktor?","Durch den Aufruf von ""super"" in einem Konstruktor werden die in ""super"" aufgerufenen Methoden dynamisch gebunden, was dazu führen kann, dass auf noch nicht initialisierte Variablen zugegriffen wird."
"Wenn kein Konstruktor definiert wird, verwendet Java standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse. Konstruktoren werden nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen. Um dieses Verhalten zu überschreiben, kann man innerhalb eines Konstruktors einen Konstruktor der Superklasse mittels ""super"" aufrufen. Dabei werden die in ""super"" aufgerufenen Methoden dynamisch gebunden, was dazu führen kann, dass auf noch nicht initialisierte Variablen zugegriffen wird. Die gesamte Thematik rund um Konstruktoren und die Initialisierung von Variablen in Java ist recht komplex. Da Instanziierung und Initialisierung grundlegende und für jedes Programm unverzichtbare Vorgänge sind, ist Java möglicherweise nicht die ideale Programmiersprache für Anfänger.",Wird der Standardkonstruktor einer Klasse beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen?,"Ja, der Standardkonstruktor einer Klasse wird beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen."
"In Java ist es übrigens auch möglich, Konstruktoren für die Objekterzeugung mit Klassenmethoden zu verwenden. In diesem Fall muss die Klassenmethode im Rumpf einen Konstruktor aufrufen, wie es in Zeile 1006 geschieht. Solche Klassenmethoden werden auch als Factory-Methoden bezeichnet (vgl. Abschnitt 8.3 in Kurseinheit 2). Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben.",Was sind Factory-Methoden in Java?,"Factory-Methoden sind Klassenmethoden in Java, die zur Objekterzeugung verwendet werden können. Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben."
"In Java ist es übrigens auch möglich, Konstruktoren für die Objekterzeugung mit Klassenmethoden zu verwenden. In diesem Fall muss die Klassenmethode im Rumpf einen Konstruktor aufrufen, wie es in Zeile 1006 geschieht. Solche Klassenmethoden werden auch als Factory-Methoden bezeichnet (vgl. Abschnitt 8.3 in Kurseinheit 2). Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben.",Was ist der Unterschied zwischen Klassenmethoden und Konstruktoren?,"Klassenmethoden sind Methoden, die auf die Klasse als Ganzes angewendet werden, während Konstruktoren beim Erzeugen eines Objekts aufgerufen werden und der Initialisierung der Instanzvariablen dienen."
"In rein objektorientierten Programmiersprachen sind sämtliche Daten, die ein Programm verarbeiten kann, in Form von Objekten im Speicher abgelegt. Der Reiz dieses Merkmals der objektorientierten Programmierung ist, dass unser Weltbild, zumindest in weiten Teilen, auf einem ähnlichen Modell basiert: Die Welt besteht aus Objekten, die miteinander in Beziehung stehen. Dabei ist der Objektbegriff nicht auf das rein Materielle beschränkt: Nach allgemeinem Verständnis sind Personen ebenso Objekte wie Dokumente, Zahlen oder Zeichen.Bei der Übertragung von realen (d. h. aus einer Anwendungsdomäne stammenden) Sachverhalten in ein objektorientiertes Programm ergibt sich das Problem, dass die Übertragung, aufgrund der Homogenität der Objektorientierung (alles ist ein Objekt), gewisse fundamentale Unterschiedlichkeiten der Kategorien unserer Begriffswelt ignoriert: Zahlen beispielsweise sind im Gegensatz zu Dingen Objekte ohne Identität, Zustand oder Lebensdauer (sie werden daher auch häufig als Werte bezeichnet); Mengen sind nicht weiter abgrenzbare Elemente wie z. B. 1 Liter Wasser, die gar keine Objekte im eigentlichen Sinn haben (auch sie haben keine Identität) usw. Gleichwohl kommen sie alle in objektorientierten Programmen vor und werden dort — zumindest der reinen Lehre nach — durch Objekte repräsentiert. Der Ansatz, alles trotz evidenter ontologischer Unterschiede programmiersprachlich über einen Kamm zu scheren, führt hier und da zu gewissen Inkonsistenzen im ansonsten klaren, ja puristischen objektorientierten Weltbild, mit denen wir leben müssen, wenn wir objektorientiert programmieren wollen. Es ist dies der Preis des auch als ""Ockhams Rasiermesser"" bekannten Sparsamkeitsprinzips, das auch für die objektorientierte Programmierung Leitlinie ist.",Was sind Objekte in der objektorientierten Programmierung?,"Objekte sind in der objektorientierten Programmierung Daten, die im Speicher abgelegt sind und in der Lage sind, Informationen zu speichern und Aktionen auszuführen. Sie repräsentieren Dinge aus der realen Welt und können miteinander in Beziehung stehen."
"In rein objektorientierten Programmiersprachen sind sämtliche Daten, die ein Programm verarbeiten kann, in Form von Objekten im Speicher abgelegt. Der Reiz dieses Merkmals der objektorientierten Programmierung ist, dass unser Weltbild, zumindest in weiten Teilen, auf einem ähnlichen Modell basiert: Die Welt besteht aus Objekten, die miteinander in Beziehung stehen. Dabei ist der Objektbegriff nicht auf das rein Materielle beschränkt: Nach allgemeinem Verständnis sind Personen ebenso Objekte wie Dokumente, Zahlen oder Zeichen.Bei der Übertragung von realen (d. h. aus einer Anwendungsdomäne stammenden) Sachverhalten in ein objektorientiertes Programm ergibt sich das Problem, dass die Übertragung, aufgrund der Homogenität der Objektorientierung (alles ist ein Objekt), gewisse fundamentale Unterschiedlichkeiten der Kategorien unserer Begriffswelt ignoriert: Zahlen beispielsweise sind im Gegensatz zu Dingen Objekte ohne Identität, Zustand oder Lebensdauer (sie werden daher auch häufig als Werte bezeichnet); Mengen sind nicht weiter abgrenzbare Elemente wie z. B. 1 Liter Wasser, die gar keine Objekte im eigentlichen Sinn haben (auch sie haben keine Identität) usw. Gleichwohl kommen sie alle in objektorientierten Programmen vor und werden dort — zumindest der reinen Lehre nach — durch Objekte repräsentiert. Der Ansatz, alles trotz evidenter ontologischer Unterschiede programmiersprachlich über einen Kamm zu scheren, führt hier und da zu gewissen Inkonsistenzen im ansonsten klaren, ja puristischen objektorientierten Weltbild, mit denen wir leben müssen, wenn wir objektorientiert programmieren wollen. Es ist dies der Preis des auch als ""Ockhams Rasiermesser"" bekannten Sparsamkeitsprinzips, das auch für die objektorientierte Programmierung Leitlinie ist.",Was sind Inkonsistenzen im objektorientierten Weltbild?,"In der objektorientierten Programmierung werden verschiedene Arten von Sachverhalten, die in der realen Welt unterschiedliche Eigenschaften haben, durch Objekte repräsentiert. Dies kann zu Inkonsistenzen führen, da nicht alle Sachverhalte dieselben Eigenschaften wie Objekte haben. Dies ist auf die homogene Natur der Objektorientierung zurückzuführen."
"Wie bereits erwähnt, sind Objekte im Speicher abgelegte Daten. Dabei ist jedes Objekt an genau einer Stelle im Speicher abgelegt: Es wird damit durch seine Speicherstelle eindeutig identifiziert. Aufgrund dieser eindeutigen Identifizierbarkeit spricht man auch von der Identität eines Objekts; sie kann aus technischer Sicht mit der Speicherstelle, an der das Objekt abgelegt ist, gleichgesetzt werden. Da keine zwei Objekte an derselben Stelle abgelegt werden können, haben auch keine zwei Objekte dieselbe Identität.Objekte sind grundsätzlich von Werten zu unterscheiden. Werte werden auch im Speicher abgelegt, haben aber keine Identität. Es folgt, dass derselbe Wert an verschiedenen Stellen im Speicher vorkommen kann. Viele objektorientierte Programmiersprachen (wie etwa Java oder C-Sharp) unterscheiden ganz offen zwischen Werten und Objekten; SMALLTALK tut dies nur hinter den Kulissen und folgt ansonsten seinem Motto ""alles ist ein Objekt"".",Was unterscheidet ein Objekt und ein Wert?,"Objekte haben eine eindeutige Identität und sind an einer bestimmten Stelle im Speicher abgelegt, während Werte an verschiedenen Stellen im Speicher vorkommen können und keine Identität haben."
"Wie bereits erwähnt, sind Objekte im Speicher abgelegte Daten. Dabei ist jedes Objekt an genau einer Stelle im Speicher abgelegt: Es wird damit durch seine Speicherstelle eindeutig identifiziert. Aufgrund dieser eindeutigen Identifizierbarkeit spricht man auch von der Identität eines Objekts; sie kann aus technischer Sicht mit der Speicherstelle, an der das Objekt abgelegt ist, gleichgesetzt werden. Da keine zwei Objekte an derselben Stelle abgelegt werden können, haben auch keine zwei Objekte dieselbe Identität.Objekte sind grundsätzlich von Werten zu unterscheiden. Werte werden auch im Speicher abgelegt, haben aber keine Identität. Es folgt, dass derselbe Wert an verschiedenen Stellen im Speicher vorkommen kann. Viele objektorientierte Programmiersprachen (wie etwa Java oder C-Sharp) unterscheiden ganz offen zwischen Werten und Objekten; SMALLTALK tut dies nur hinter den Kulissen und folgt ansonsten seinem Motto ""alles ist ein Objekt"".",Was ist das Motto von SMALLTALK?,"Das Motto von SMALLTALK lautet ""alles ist ein Objekt""."
"Die Menge des Speichers, den ein Objekt belegt, ist aus technischen Gründen konstant. Objekte können somit weder wachsen noch schrumpfen. Sollte dies trotzdem notwendig sein, bleibt nur, ein neues Objekt zu erzeugen, das an die Stelle (nicht die Speicherstelle!) des anderen tritt. Das neue Objekt hat jedoch eine andere Identität, sodass alle Stellen im Programm, die sich auf das alte Objekt beziehen, entsprechend angepasst werden müssen.",Warum haben Objekte im Speicher eine konstante Größe?,"Objekte im Speicher haben eine feste Größe, die aus technischen Gründen nicht verändert werden kann. Wenn ein Objekt mehr Platz benötigt oder verkleinert werden muss, muss ein neues Objekt erzeugt werden, das an die Stelle des alten tritt. Dieses neue Objekt hat jedoch eine andere Identität."
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen. Für diese Variablen ist die Zuweisung nicht zulässig.Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden. Nicht zuletzt sind auch alle Klassennamen Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.",Was sind Pseudovariablen in SMALLTALK?,"Pseudovariablen in SMALLTALK sind Variablen wie ""true"", ""false"", ""nil"", ""self"", ""super"" und formale Parameter von Methoden sowie Klassennamen, denen der Programmierer keinen Wert zuweisen kann."
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen. Für diese Variablen ist die Zuweisung nicht zulässig.Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden. Nicht zuletzt sind auch alle Klassennamen Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.",Warum werden Pseudovariablen als solche bezeichnet?,"Sie werden als Pseudovariablen bezeichnet, da sie ihren Wert entweder nicht ändern können oder ihren Wert vom System erhalten."
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen. Für diese Variablen ist die Zuweisung nicht zulässig.Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden. Nicht zuletzt sind auch alle Klassennamen Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.",Warum ist die Zuweisung für Pseudovariablen in SMALLTALK nicht zulässig?,"Die Zuweisung für Pseudovariablen ist in SMALLTALK nicht zulässig, da sie auf Objekte von spezifischer Bedeutung verweisen und diese Bedeutung nicht verändert werden sollte."
"Wer sich den Quellcode objektorientierter Programme ansieht, wird feststellen, dass die Methoden im Durchschnitt ziemlich kurz sind. Wie bereits in Kurseinheit 6, Kapitel 56 erwähnt, ist dies eine Folge des Umstandes, dass in der objektorientierten Programmierung die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Sobald eine Funktion verschiedene Arten von Daten manipuliert (also Objekte, die Instanzen verschiedener Klassen sind), ist es wahrscheinlich, dass diese Funktion nicht vollständig in einer Methode implementiert wird.",Warum sind Methoden in objektorientierter Programmierung im Durchschnitt kurz?,"Die Methoden sind im Durchschnitt kurz, weil die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Sobald eine Funktion verschiedene Arten von Daten manipuliert, ist es wahrscheinlich, dass diese Funktion nicht vollständig in einer Methode implementiert wird."
"Wer sich den Quellcode objektorientierter Programme ansieht, wird feststellen, dass die Methoden im Durchschnitt ziemlich kurz sind. Wie bereits in Kurseinheit 6, Kapitel 56 erwähnt, ist dies eine Folge des Umstandes, dass in der objektorientierten Programmierung die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Sobald eine Funktion verschiedene Arten von Daten manipuliert (also Objekte, die Instanzen verschiedener Klassen sind), ist es wahrscheinlich, dass diese Funktion nicht vollständig in einer Methode implementiert wird.",Warum sind Methoden in objektorientierter Programmierung im Durchschnitt kurz?,"Methoden in objektorientierter Programmierung sind im Durchschnitt kurz, weil die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Sobald eine Funktion verschiedene Arten von Daten manipuliert, ist es wahrscheinlich, dass diese Funktion nicht vollständig in einer Methode implementiert wird."
"Was zunächst wie eine unmittelbare Folge des objektorientierten Paradigmas erscheint, hat sich zu einem objektorientierten Stil weiterentwickelt: Eine typische objektorientierte Programmiererin scheut sich nicht davor, Methoden zu schreiben, die nur aus einer Zeile bestehen (oder die nur eine Anweisung, wenn auch mit geschachtelten Ausdrücken, enthalten) – im Gegenteil, sie fühlt sich sogar gut dabei, denn was sie gerade produziert, gilt als objektorientierter Stil. So ist es sogar üblich, Teile einer Methode in eine neue auszulagern (das ""Extract-method""-Refactoring, das einige vielleicht aus ECLIPSE und ähnlichen Entwicklungsumgebungen kennen), auch wenn dieser Teil (zunächst) ausschließlich von seiner ursprünglichen Position aus aufgerufen wird, wenn es nur der besseren Lesbarkeit dient (insbesondere Wiederverwendung spielt keine Rolle). Ein positiver Nebeneffekt dieser starken Zerlegung von Funktionalität ist die hohe Dichte an Bezeichnern in objektorientierten Programmen: Da jede Teilfunktion, die in eine Methode ausgelagert wird, einen eigenen, eindeutigen Namen haben muss (bis auf Überladen/Überschreiben), wird die Programmiererin dazu gezwungen, sich ständig (in Form der Namenswahl für Bezeichner) dazu zu äußern, was sie gerade tut.",Warum bevorzugen objektorientierte Programmierer kurze Methoden?,"Objektorientierte Programmierer bevorzugen kurze Methoden, weil sie als objektorientierter Stil gelten. Diese Methoden können nur aus einer Zeile bestehen und die Funktionalität wird stark zerlegt. Dies führt zu einer hohen Dichte an Bezeichnern in objektorientierten Programmen, da jede Teilfunktion, die in eine Methode ausgelagert wird, einen eigenen, eindeutigen Namen haben muss."
"Was zunächst wie eine unmittelbare Folge des objektorientierten Paradigmas erscheint, hat sich zu einem objektorientierten Stil weiterentwickelt: Eine typische objektorientierte Programmiererin scheut sich nicht davor, Methoden zu schreiben, die nur aus einer Zeile bestehen (oder die nur eine Anweisung, wenn auch mit geschachtelten Ausdrücken, enthalten) – im Gegenteil, sie fühlt sich sogar gut dabei, denn was sie gerade produziert, gilt als objektorientierter Stil. So ist es sogar üblich, Teile einer Methode in eine neue auszulagern (das ""Extract-method""-Refactoring, das einige vielleicht aus ECLIPSE und ähnlichen Entwicklungsumgebungen kennen), auch wenn dieser Teil (zunächst) ausschließlich von seiner ursprünglichen Position aus aufgerufen wird, wenn es nur der besseren Lesbarkeit dient (insbesondere Wiederverwendung spielt keine Rolle). Ein positiver Nebeneffekt dieser starken Zerlegung von Funktionalität ist die hohe Dichte an Bezeichnern in objektorientierten Programmen: Da jede Teilfunktion, die in eine Methode ausgelagert wird, einen eigenen, eindeutigen Namen haben muss (bis auf Überladen/Überschreiben), wird die Programmiererin dazu gezwungen, sich ständig (in Form der Namenswahl für Bezeichner) dazu zu äußern, was sie gerade tut.","Warum ist es üblich, Teile einer Methode in eine neue auszulagern?","Es ist üblich, Teile einer Methode in eine neue auszulagern, um die Lesbarkeit zu verbessern und die Funktionalität besser zu zerlegen. Dies wird auch als ""Extract-method""-Refactoring bezeichnet. Jede Teilfunktion, die in eine Methode ausgelagert wird, muss einen eigenen, eindeutigen Namen haben, was die Programmiererin dazu zwingt, sich ständig (in Form der Namenswahl für Bezeichner) dazu zu äußern, was sie gerade tut."
"Wie Sie bereits in den Anweisungen in Kapitel 38 gesehen haben, bietet Java ein sogenanntes Exception Handling. Beim Exception Handling handelt es sich um eine Möglichkeit, bei der Spezifikation des Kontrollflusses eines Programms zunächst mögliche Ausnahmesituationen und deren Behandlung unberücksichtigt zu lassen und so zu tun, als würde immer alles gutgehen. Da dies normalerweise der Fall sein sollte, erlaubt es sowohl der Autorin als auch dem Leser eines Programms, sich auf die Hauptfunktion zu konzentrieren, mit dem Motto ""Zu den Ausnahmen kommen wir später!""",Was ist Exception Handling in Java?,"Exception Handling in Java ist eine Möglichkeit, bei der Spezifikation des Kontrollflusses eines Programms zunächst mögliche Ausnahmesituationen und deren Behandlung unberücksichtigt zu lassen und so zu tun, als würde immer alles gutgehen. Es erlaubt sowohl der Autorin als auch dem Leser eines Programms, sich auf die Hauptfunktion zu konzentrieren, mit dem Motto ""Zu den Ausnahmen kommen wir später!""."
"Die möglichen Ausnahmesituationen eines Programms werden in Java in Klassen unterteilt, deren Instanzen jeweils eine konkrete Ausnahmesituation während des Programmablaufs repräsentieren. Wenn beispielsweise in einem Programm auf ein Element eines Arrays zugegriffen werden soll, dessen Index außerhalb der Grenzen des Arrays liegt, erzeugt die JVM, die über die Einhaltung der Array-Grenzen wacht, eine Instanz der Klasse ArrayIndexOutOfBoundsException und wirft diese. Das Werfen einer Exception (genauer gesagt, einer Instanz einer Exception-Klasse) bedeutet, dass der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt wird, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist. Dies erfordert, dass der Codeabschnitt, in dem die Exception auftreten kann, in einen Try-Catch-Block eingefasst wird.",Was ist eine Exception in Java?,"In Java sind Exceptions Instanzen von Klassen, die jeweils eine konkrete Ausnahmesituation während des Programmablaufs repräsentieren. Wenn eine Exception geworfen wird, wird der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist."
"Die möglichen Ausnahmesituationen eines Programms werden in Java in Klassen unterteilt, deren Instanzen jeweils eine konkrete Ausnahmesituation während des Programmablaufs repräsentieren. Wenn beispielsweise in einem Programm auf ein Element eines Arrays zugegriffen werden soll, dessen Index außerhalb der Grenzen des Arrays liegt, erzeugt die JVM, die über die Einhaltung der Array-Grenzen wacht, eine Instanz der Klasse ArrayIndexOutOfBoundsException und wirft diese. Das Werfen einer Exception (genauer gesagt, einer Instanz einer Exception-Klasse) bedeutet, dass der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt wird, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist. Dies erfordert, dass der Codeabschnitt, in dem die Exception auftreten kann, in einen Try-Catch-Block eingefasst wird.",Was ist der Zweck von Try-Catch-Blöcken in Java?,"Try-Catch-Blöcke in Java werden verwendet, um Ausnahmesituationen während des Programmablaufs abzufangen und zu behandeln. Der Codeabschnitt, in dem die Exception auftreten kann, wird in den Try-Block eingefasst, während der Catch-Block den Code enthält, der die Exception behandelt."
"Die möglichen Ausnahmesituationen eines Programms werden in Java in Klassen unterteilt, deren Instanzen jeweils eine konkrete Ausnahmesituation während des Programmablaufs repräsentieren. Wenn beispielsweise in einem Programm auf ein Element eines Arrays zugegriffen werden soll, dessen Index außerhalb der Grenzen des Arrays liegt, erzeugt die JVM, die über die Einhaltung der Array-Grenzen wacht, eine Instanz der Klasse ArrayIndexOutOfBoundsException und wirft diese. Das Werfen einer Exception (genauer gesagt, einer Instanz einer Exception-Klasse) bedeutet, dass der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt wird, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist. Dies erfordert, dass der Codeabschnitt, in dem die Exception auftreten kann, in einen Try-Catch-Block eingefasst wird.","Was passiert, wenn eine Exception geworfen wird?","Wenn eine Exception geworfen wird, wird der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist. Der Codeabschnitt, in dem die Exception auftreten kann, muss in einen Try-Catch-Block eingefasst sein."
"Wenn der Typ der geworfenen Exception nicht in einer der Catch-Klauseln aufgeführt ist, wird die Exception als unbehandelt betrachtet, und die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung (""Exception in thread ..."").","Was passiert, wenn der Typ der geworfenen Exception nicht in einer der Catch-Klauseln aufgeführt ist?","Wenn der Typ der geworfenen Exception nicht in einer der Catch-Klauseln aufgeführt ist, wird die Exception als unbehandelt betrachtet, und die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung (""Exception in thread ..."")."
"Ausnahmesituationen können jedoch auch vom Programm selbst erkannt und gemeldet werden, indem die bereits erwähnte Throw-Anweisung verwendet wird, um eine entsprechende Exception-Klasse zu instanziieren. Dies ermöglicht es, die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.",Wie können Ausnahmesituationen in einem Programm erkannt und gemeldet werden?,"Ausnahmesituationen können durch die Verwendung der Throw-Anweisung erkannt und gemeldet werden, um die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern."
"Ausnahmesituationen können jedoch auch vom Programm selbst erkannt und gemeldet werden, indem die bereits erwähnte Throw-Anweisung verwendet wird, um eine entsprechende Exception-Klasse zu instanziieren. Dies ermöglicht es, die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.",Wie können Ausnahmesituationen in einem Programm behandelt werden?,"Ausnahmesituationen können vom Programm selbst erkannt und gemeldet werden, indem die Throw-Anweisung verwendet wird, um eine entsprechende Exception-Klasse zu instanziieren. Dies ermöglicht es, die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern."
"Ausnahmesituationen können jedoch auch vom Programm selbst erkannt und gemeldet werden, indem die bereits erwähnte Throw-Anweisung verwendet wird, um eine entsprechende Exception-Klasse zu instanziieren. Dies ermöglicht es, die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.",Was ermöglicht die Throw-Anweisung in Java?,"Die Throw-Anweisung in Java ermöglicht es, Ausnahmesituationen vom Programm selbst zu erkennen und eine entsprechende Exception-Klasse zu instanziieren, um die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern."
"Try-Catch-Anweisungen in Java werden, wie fast alle Anweisungen, im Körper von Methoden platziert. Wenn eine Methode eine bestimmte Exception wirft, ohne sie selbst abzufangen (d. h., wenn die Throw-Anweisung nicht innerhalb eines Try-Catch-Blocks verwendet wird, der eine passende Catch-Klausel enthält), muss die Methode dies deklarieren. Dies geschieht durch Hinzufügen einer Throws-Klausel zur Methodendeklaration.",Was ist der Zweck der Throws-Klausel in Java?,"Die Throws-Klausel in Java wird verwendet, um eine Methode zu deklarieren, dass sie eine bestimmte Exception wirft, ohne sie selbst abzufangen. Dies muss geschehen, wenn die Methode eine Exception wirft und kein passender Catch-Block vorhanden ist."
"Eine Methode, die die obige Methode aufruft, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft.",Was ist ein Try-Catch-Block in der Programmierung?,"Ein Try-Catch-Block ist eine Programmstruktur, die eine Ausnahmebehandlung ermöglicht. Der Try-Block enthält den Code, der möglicherweise eine Ausnahme auslöst, während der Catch-Block den Code enthält, der die Ausnahme behandelt."
"Eine Methode, die die obige Methode aufruft, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft.","Was muss eine Methode tun, wenn sie eine Exception aufruft, die von einer anderen Methode geworfen wird?","Eine Methode, die eine Exception aufruft, die von einer anderen Methode geworfen wird, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft."
"Eine Methode, die die obige Methode aufruft, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft.","Was muss eine Methode tun, wenn sie eine Exception aufruft, die sie nicht behandeln kann?","Wenn eine Methode eine Exception aufruft, die sie nicht behandeln kann, muss sie diese Exception weiterwerfen oder sie in einem Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält."
"Diese Praxis kann zwar zu erheblichem Schreibaufwand führen, stellt jedoch die einzige Möglichkeit dar, sicherzustellen, dass die Programmierer sich der möglichen Ausnahmesituationen bewusst sind, ohne die Kontrollflussspezifikation übermäßig zu belasten. Exceptions, die eine Deklaration im Methodenkopf erfordern oder innerhalb der Methode behandelt werden müssen, werden als Checked Exceptions bezeichnet.",Was sind Checked Exceptions?,"Checked Exceptions sind Exceptions, die eine Deklaration im Methodenkopf erfordern oder innerhalb der Methode behandelt werden müssen. Diese Praxis kann zwar zu erheblichem Schreibaufwand führen, stellt jedoch sicher, dass die Programmierer sich der möglichen Ausnahmesituationen bewusst sind, ohne die Kontrollflussspezifikation übermäßig zu belasten."
"Es gibt jedoch auch Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Im Gegensatz zu Checked Exceptions können Unchecked Exceptions in der Praxis überall auftreten. Ein prominentes Beispiel ist die ""Out of Memory Exception"", die auftritt, wenn eine Speicheranforderung des Programms von der JVM nicht erfüllt werden kann. Eine weitere häufige, aber programmatisch vermeidbare Exception ist die ""Null Pointer Exception"", die auftritt, wenn ein Ausdruck, auf dem auf ein Feld oder eine Methode zugegriffen wird, zu null ausgewertet wird. In dieselbe Kategorie fällt auch die ""Array Index Out of Bounds Exception"", die durch sorgfältiges Programmieren vermieden werden könnte, aber dennoch häufig vorkommt.",Was sind Unchecked Exceptions?,"Unchecked Exceptions sind Exceptions, die in der Praxis überall auftreten können und nicht explizit deklariert werden müssen. Einige Beispiele für Unchecked Exceptions sind ""Out of Memory Exception"", ""Null Pointer Exception"" und ""Array Index Out of Bounds Exception""."
"Es wäre äußerst mühsam, jede Anweisung, bei der eine solche Exception auftreten könnte, mit einem Try-Catch-Block abzusichern. Daher gibt es in Java Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Die Unterscheidung, ob eine Exception als Checked oder Unchecked gilt, liegt nicht in der Hand der Programmiererin, die sie wirft, sondern erfolgt anhand der Vererbungshierarchie der Exception-Klassen. Alle Exceptions, die von der Klasse RuntimeException abgeleitet sind, werden per Definition als Unchecked betrachtet. RuntimeException selbst ist eine Subklasse der Klasse Exception, die wiederum eine Subklasse von Throwable ist. Throwable ist die Superklasse aller Klassen, die in Throw-Anweisungen, Catch-Zweigen und Throws-Klauseln verwendet werden dürfen. Mit RuntimeException wird also ein Zweig der Exception-Klassenhierarchie eingeleitet, dessen Elemente alle als Unchecked gelten.",Was sind Unchecked Exceptions in Java?,"Unchecked Exceptions in Java sind Exceptions, bei denen es nicht erforderlich ist, jede Anweisung, bei der eine solche Exception auftreten könnte, mit einem Try-Catch-Block abzusichern. Alle Exceptions, die von der Klasse RuntimeException abgeleitet sind, werden als Unchecked Exceptions betrachtet."
"Neben Exception ist auch Error eine Subklasse von Throwable. Errors sollten jedoch nicht abgefangen werden und führen zu einem sofortigen Programmabbruch. Auslassungszeichen stehen für die Formulierung einer Invariante, wurde früher zur Emulation der mittlerweile vorhandenen Assert-Anweisung verwendet. Auch heute sollte man Errors eigentlich nur während der Testphase eines Programms einsetzen. Genauso wie Exceptions der Sorte RuntimeException sind Errors unchecked.",Was ist der Unterschied zwischen Exceptions und Errors in Java?,"Exceptions und Errors sind beides Unterklassen von Throwable, aber Errors sollten nicht abgefangen werden und führen zu einem sofortigen Programmabbruch. Exceptions sind checked und müssen abgefangen werden, während Errors unchecked sind und nicht abgefangen werden sollten. Auslassungszeichen in Java werden zur Formulierung einer Invariante verwendet und wurden früher zur Emulation der mittlerweile vorhandenen Assert-Anweisung verwendet. Auch heute sollte man Errors eigentlich nur während der Testphase eines Programms einsetzen."
"Ein weiteres Kennzeichen der objektorientierten Programmierung ist, dass Klassen nicht ins Uferlose wachsen sollten. Wenn der Methodenumfang einer Klasse immer weiter ansteigt, wird die erfahrene objektorientierte Programmiererin bald den Verdacht schöpfen, dass es sich bei der Klasse in Wirklichkeit nicht um eine, sondern um mehrere handelt. Dafür gibt es zwei Erklärungen: Die Klasse steht nicht nur für eine Abstraktion der Anwendungsdomäne, sondern für mehrere. In diesem Fall sollte die Aufteilung der Klasse in mehrere Teilklassen – eine für jede Abstraktion – leicht fallen: Sie ordnen zunächst die Daten den Abstraktionen (Allgemeinbegriffen) zu und lassen dann die Methoden den Daten folgen. Die Klasse steht zwar für eine Abstraktion der Anwendungsdomäne, aber dies auf einem höheren Abstraktionsniveau als das der Implementierung, die Sie gerade betrachten. Dafür gibt es wiederum mindestens zwei mögliche Erklärungen: a. Die Abstraktion ist eine Generalisierung (s. Kurseinheit 1, Abschnitt 9.1), und Sie haben alle ihre Spezialisierungen in einer Klasse zusammengefasst. In diesem Fall müssen Sie lediglich die unterschiedlichen Spezialisierungen identifizieren und die jeweils darauf bezogenen (dafür charakteristischen) Daten und Funktionen in neu zu schaffende Subklassen verlagern. Lediglich das allen Fällen gemeinsame Protokoll verbleibt dann in der (idealerweise abstrakten) neuen Superklasse. Ein guter Indikator für diesen Fall ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen (vgl. dazu auch das sog. ""Replace-conditional-with-polymorphism-Refactoring""). b. Die Abstraktion ist eine Aggregation (oder Komposition, s. Kurseinheit 1, Abschnitt 2.3), also eine Zusammensetzung eines Ganzen aus mehreren Teilen. In diesem Fall müssen Sie die Teile als logische Einheiten identifizieren und dafür neue Klassen formulieren. Falls diese neuen Klassen außerhalb der Abstraktion keine Bedeutung haben, können Sie in Erwägung ziehen, sie als innere Klassen zu deklarieren (sofern Ihre Programmiersprache dies erlaubt), um den Namensraum nicht unnötig zu überfrachten und die von anderen wahrgenommene Anzahl der Klassen nicht unnötig zu erhöhen.","Was ist ein Indikator dafür, dass eine Klasse in mehrere Subklassen aufgeteilt werden sollte?","Ein guter Indikator dafür ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen."
"Ein weiteres Kennzeichen der objektorientierten Programmierung ist, dass Klassen nicht ins Uferlose wachsen sollten. Wenn der Methodenumfang einer Klasse immer weiter ansteigt, wird die erfahrene objektorientierte Programmiererin bald den Verdacht schöpfen, dass es sich bei der Klasse in Wirklichkeit nicht um eine, sondern um mehrere handelt. Dafür gibt es zwei Erklärungen: Die Klasse steht nicht nur für eine Abstraktion der Anwendungsdomäne, sondern für mehrere. In diesem Fall sollte die Aufteilung der Klasse in mehrere Teilklassen – eine für jede Abstraktion – leicht fallen: Sie ordnen zunächst die Daten den Abstraktionen (Allgemeinbegriffen) zu und lassen dann die Methoden den Daten folgen. Die Klasse steht zwar für eine Abstraktion der Anwendungsdomäne, aber dies auf einem höheren Abstraktionsniveau als das der Implementierung, die Sie gerade betrachten. Dafür gibt es wiederum mindestens zwei mögliche Erklärungen: a. Die Abstraktion ist eine Generalisierung (s. Kurseinheit 1, Abschnitt 9.1), und Sie haben alle ihre Spezialisierungen in einer Klasse zusammengefasst. In diesem Fall müssen Sie lediglich die unterschiedlichen Spezialisierungen identifizieren und die jeweils darauf bezogenen (dafür charakteristischen) Daten und Funktionen in neu zu schaffende Subklassen verlagern. Lediglich das allen Fällen gemeinsame Protokoll verbleibt dann in der (idealerweise abstrakten) neuen Superklasse. Ein guter Indikator für diesen Fall ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen (vgl. dazu auch das sog. ""Replace-conditional-with-polymorphism-Refactoring""). b. Die Abstraktion ist eine Aggregation (oder Komposition, s. Kurseinheit 1, Abschnitt 2.3), also eine Zusammensetzung eines Ganzen aus mehreren Teilen. In diesem Fall müssen Sie die Teile als logische Einheiten identifizieren und dafür neue Klassen formulieren. Falls diese neuen Klassen außerhalb der Abstraktion keine Bedeutung haben, können Sie in Erwägung ziehen, sie als innere Klassen zu deklarieren (sofern Ihre Programmiersprache dies erlaubt), um den Namensraum nicht unnötig zu überfrachten und die von anderen wahrgenommene Anzahl der Klassen nicht unnötig zu erhöhen.","Was ist ein Indikator dafür, dass eine Klasse nicht nur für eine Abstraktion der Anwendungsdomäne steht, sondern für mehrere?","Ein guter Indikator dafür ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen."
"Ein weiteres Kennzeichen der objektorientierten Programmierung ist, dass Klassen nicht ins Uferlose wachsen sollten. Wenn der Methodenumfang einer Klasse immer weiter ansteigt, wird die erfahrene objektorientierte Programmiererin bald den Verdacht schöpfen, dass es sich bei der Klasse in Wirklichkeit nicht um eine, sondern um mehrere handelt. Dafür gibt es zwei Erklärungen: Die Klasse steht nicht nur für eine Abstraktion der Anwendungsdomäne, sondern für mehrere. In diesem Fall sollte die Aufteilung der Klasse in mehrere Teilklassen – eine für jede Abstraktion – leicht fallen: Sie ordnen zunächst die Daten den Abstraktionen (Allgemeinbegriffen) zu und lassen dann die Methoden den Daten folgen. Die Klasse steht zwar für eine Abstraktion der Anwendungsdomäne, aber dies auf einem höheren Abstraktionsniveau als das der Implementierung, die Sie gerade betrachten. Dafür gibt es wiederum mindestens zwei mögliche Erklärungen: a. Die Abstraktion ist eine Generalisierung (s. Kurseinheit 1, Abschnitt 9.1), und Sie haben alle ihre Spezialisierungen in einer Klasse zusammengefasst. In diesem Fall müssen Sie lediglich die unterschiedlichen Spezialisierungen identifizieren und die jeweils darauf bezogenen (dafür charakteristischen) Daten und Funktionen in neu zu schaffende Subklassen verlagern. Lediglich das allen Fällen gemeinsame Protokoll verbleibt dann in der (idealerweise abstrakten) neuen Superklasse. Ein guter Indikator für diesen Fall ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen (vgl. dazu auch das sog. ""Replace-conditional-with-polymorphism-Refactoring""). b. Die Abstraktion ist eine Aggregation (oder Komposition, s. Kurseinheit 1, Abschnitt 2.3), also eine Zusammensetzung eines Ganzen aus mehreren Teilen. In diesem Fall müssen Sie die Teile als logische Einheiten identifizieren und dafür neue Klassen formulieren. Falls diese neuen Klassen außerhalb der Abstraktion keine Bedeutung haben, können Sie in Erwägung ziehen, sie als innere Klassen zu deklarieren (sofern Ihre Programmiersprache dies erlaubt), um den Namensraum nicht unnötig zu überfrachten und die von anderen wahrgenommene Anzahl der Klassen nicht unnötig zu erhöhen.","Was ist ein Indikator dafür, dass eine Klasse in mehrere Spezialisierungen aufgeteilt werden sollte?","Ein guter Indikator dafür ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen."
"Ein- und Ausgabeströme spielen in der konventionellen (objektorientierten) Programmierung eine wichtige Rolle, da über sie Eingaben in und Ausgaben aus dem System erfolgen, und zwar sowohl von/zu der Benutzerin als auch vom/zum Dateisystem. Nun ist SMALLTALK aber als fensterbasiertes, grafisches System konzipiert, das der zeilenorientierten und textbasierten Ein- und Ausgabe der damals vorherrschenden Programme eine Alternative gegenüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden. Da ist es nur konsequent, dass die Ein- und Ausgabe über Streams wenig Gewicht hat.",Wie wird in SMALLTALK mit Ein- und Ausgabeströmen umgegangen?,"In SMALLTALK spielt die Ein- und Ausgabe über Streams eine untergeordnete Rolle, da SMALLTALK als fensterbasiertes, grafisches System konzipiert ist und mit dem Image alle Objekte dauerhaft gespeichert werden können."
"Ein- und Ausgabeströme spielen in der konventionellen (objektorientierten) Programmierung eine wichtige Rolle, da über sie Eingaben in und Ausgaben aus dem System erfolgen, und zwar sowohl von/zu der Benutzerin als auch vom/zum Dateisystem. Nun ist SMALLTALK aber als fensterbasiertes, grafisches System konzipiert, das der zeilenorientierten und textbasierten Ein- und Ausgabe der damals vorherrschenden Programme eine Alternative gegenüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden. Da ist es nur konsequent, dass die Ein- und Ausgabe über Streams wenig Gewicht hat.",Warum spielen Ein- und Ausgabeströme in Smalltalk eine untergeordnete Rolle?,"In Smalltalk spielen Ein- und Ausgabeströme eine untergeordnete Rolle, da Smalltalk als fensterbasiertes, grafisches System konzipiert ist, das der zeilenorientierten und textbasierten Ein- und Ausgabe der damals vorherrschenden Programme eine Alternative gegenüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden."
"Ein- und Ausgabeströme spielen in der konventionellen (objektorientierten) Programmierung eine wichtige Rolle, da über sie Eingaben in und Ausgaben aus dem System erfolgen, und zwar sowohl von/zu der Benutzerin als auch vom/zum Dateisystem. Nun ist SMALLTALK aber als fensterbasiertes, grafisches System konzipiert, das der zeilenorientierten und textbasierten Ein- und Ausgabe der damals vorherrschenden Programme eine Alternative gegenüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden. Da ist es nur konsequent, dass die Ein- und Ausgabe über Streams wenig Gewicht hat.",Warum spielen Ein- und Ausgabeströme in SMALLTALK eine weniger wichtige Rolle als in konventioneller Programmierung?,"In SMALLTALK spielen Ein- und Ausgabeströme eine weniger wichtige Rolle als in konventioneller Programmierung, weil SMALLTALK als fensterbasiertes, grafisches System konzipiert ist, das der zeilenorientierten und textbasierten Ein- und Ausgabe eine Alternative gegenüberstellen wollte. Zudem ist eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden."
"In SMALLTALK haben Streams somit zunächst auch eine andere Aufgabe: Sie erlauben eine Form des Zugriffs auf Collections, die das Collection-Protokoll nicht bieten kann, nämlich: den sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen (bei den Iteratoren wird immer in einem Schritt, oder in einer Anweisung, über die ganze Collection iteriert) sowie den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Collection durch mehrere andere Objekte.",Was ist die Aufgabe von Streams in SMALLTALK?,In SMALLTALK erlauben Streams einen sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen und den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Collection durch mehrere andere Objekte.
"Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die zu liefern ist die Funktion von Streams. Streams werden zunächst immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält. Das Basisprotokoll auf Instanzebene enthält die folgenden Methoden: atEnd: gibt an, ob der Stream bereits am Ende seiner Basis angekommen ist. next: gibt das nächste Element der Basis zurück und rückt den Stream auf dieses Element vor. upToEnd: gibt eine Collection zurück, die alle Elemente der Basis bis zum Ende enthält. upTo: gibt eine Collection zurück, die alle Elemente der Basis bis zu einem bestimmten Element enthält. copyFrom: kopiert einen Teil der Basis in den Stream. reset: setzt den Stream auf den Anfang der Basis zurück.",Was ist die Funktion von Streams in einer Collection?,"Die Funktion von Streams in einer Collection ist es, Positionszeiger in die Collection hineinzuliefern."
"Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die zu liefern ist die Funktion von Streams. Streams werden zunächst immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält. Das Basisprotokoll auf Instanzebene enthält die folgenden Methoden: atEnd: gibt an, ob der Stream bereits am Ende seiner Basis angekommen ist. next: gibt das nächste Element der Basis zurück und rückt den Stream auf dieses Element vor. upToEnd: gibt eine Collection zurück, die alle Elemente der Basis bis zum Ende enthält. upTo: gibt eine Collection zurück, die alle Elemente der Basis bis zu einem bestimmten Element enthält. copyFrom: kopiert einen Teil der Basis in den Stream. reset: setzt den Stream auf den Anfang der Basis zurück.",Wofür werden Streams in der Programmierung verwendet?,"Streams werden in der Programmierung verwendet, um auf eine Collection zuzugreifen und deren Elemente zu verarbeiten. Sie werden auf einer Collection erzeugt und bieten Methoden, um das nächste Element zu ermitteln, zu prüfen, ob das Ende der Collection erreicht ist, oder um eine Teilmenge der Collection zu kopieren."
"Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die zu liefern ist die Funktion von Streams. Streams werden zunächst immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält. Das Basisprotokoll auf Instanzebene enthält die folgenden Methoden: atEnd: gibt an, ob der Stream bereits am Ende seiner Basis angekommen ist. next: gibt das nächste Element der Basis zurück und rückt den Stream auf dieses Element vor. upToEnd: gibt eine Collection zurück, die alle Elemente der Basis bis zum Ende enthält. upTo: gibt eine Collection zurück, die alle Elemente der Basis bis zu einem bestimmten Element enthält. copyFrom: kopiert einen Teil der Basis in den Stream. reset: setzt den Stream auf den Anfang der Basis zurück.",Wie wird ein Stream erzeugt?,"Ein Stream wird immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält."
"Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die zu liefern ist die Funktion von Streams. Streams werden zunächst immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält. Das Basisprotokoll auf Instanzebene enthält die folgenden Methoden: atEnd: gibt an, ob der Stream bereits am Ende seiner Basis angekommen ist. next: gibt das nächste Element der Basis zurück und rückt den Stream auf dieses Element vor. upToEnd: gibt eine Collection zurück, die alle Elemente der Basis bis zum Ende enthält. upTo: gibt eine Collection zurück, die alle Elemente der Basis bis zu einem bestimmten Element enthält. copyFrom: kopiert einen Teil der Basis in den Stream. reset: setzt den Stream auf den Anfang der Basis zurück.",Wie wird ein Stream auf einer Collection erzeugt?,"Ein Stream wird auf einer Collection erzeugt, indem die Klassenmethode on: aufgerufen wird und die Collection als Parameter übergeben wird."
"Für frei positionierbare Streams kommt noch das Protokoll zur Änderung des Zeigers hinzu:, next: gibt das nächste Element zurück und bewegt den Zeiger auf das folgende Element, previous: gibt das vorherige Element zurück und bewegt den Zeiger auf das vorherige Element, at: gibt das Element am aktuellen Zeigerposition zurück, ohne den Zeiger zu bewegen, before: setzt den Zeiger auf das vorherige Element, after: setzt den Zeiger auf das folgende Element, at:setzt den Zeiger auf das angegebene Element.Diese Protokolle sind in der Lage, den Zeiger an eine bestimmte Position zu verschieben.",Was ist das Protokoll zur Änderung des Zeigers für frei positionierbare Streams?,"Das Protokoll zur Änderung des Zeigers für frei positionierbare Streams umfasst die Methoden next, previous, at, before, after und at:. Diese Methoden ermöglichen das Navigieren und Abrufen von Elementen in einem Stream."
"Für peek ist die freie Positionierbarkeit notwendig, weil man dazu erst das nächste Element anspringen und dann wieder einen Schritt zurückgehen muss. Da ein Stream (wie eine Collection) eine Menge von Objekten repräsentiert, möchte man darüber (genau wie über eine Collection) iterieren können. Die Iteratoren von Streams sind jedoch etwas spezieller als die von Collections. Sie sind sog. ""Single-use""-Iteratoren, d.h. nachdem man einmal next() aufgerufen hat, ist das Iterator-Objekt ungültig. Außerdem wird natürlich zwischen (nur) lesbaren und schreibbaren Streams unterschieden.",Was ist ein Single-use Iterator?,"Ein Single-use Iterator ist ein Iterator, der, nachdem man einmal die next()-Methode aufgerufen hat, ungültig wird. Das bedeutet, dass man ihn nicht mehr verwenden kann, um weitere Elemente des Streams zu iterieren."
"Für peek ist die freie Positionierbarkeit notwendig, weil man dazu erst das nächste Element anspringen und dann wieder einen Schritt zurückgehen muss. Da ein Stream (wie eine Collection) eine Menge von Objekten repräsentiert, möchte man darüber (genau wie über eine Collection) iterieren können. Die Iteratoren von Streams sind jedoch etwas spezieller als die von Collections. Sie sind sog. ""Single-use""-Iteratoren, d.h. nachdem man einmal next() aufgerufen hat, ist das Iterator-Objekt ungültig. Außerdem wird natürlich zwischen (nur) lesbaren und schreibbaren Streams unterschieden.",Was ist der Unterschied zwischen lesbaren und schreibbaren Streams?,"Lesbare Streams sind Ströme, die nur zum Lesen von Daten verwendet werden können, während schreibbare Streams zum Schreiben von Daten verwendet werden können."
"Erst eine weitere Kategorie von Streams operiert nicht auf Collections, sondern auf externen Daten. Dazu gehören insbesondere die File streams. In SMALLTALK-80 wurde mit den Klassen FileDirectory, File und FilePage (die selbst keine Streams sind) ein eigenes Dateisystem geschaffen; die meisten heute gebräuchlichen Implementierungen nehmen jedoch eine Abbildung auf das Betriebssystem vor, für das sie geschrieben wurden. Man erkennt hier noch sehr schön, welche Funktion SMALLTALK ursprünglich zugedacht war: die der einzigen Software auf einem Computer.",Wofür werden File streams in Smalltalk verwendet?,"File streams in Smalltalk werden für die Verarbeitung externer Daten verwendet, insbesondere für die Arbeit mit Dateien. In Smalltalk-80 wurde dafür ein eigenes Dateisystem geschaffen, aber heutige Implementierungen bilden meist das Betriebssystem ab, für das sie geschrieben wurden."
"Als Java entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht privat deklariert ist, ist zugreifbar), nach außen sind jedoch nur öffentlich deklarierte Programmelemente sichtbar.",Wie ist der Zugriff auf Klassen in Java geregelt?,"In Java gewähren Klassen sich untereinander privilegierten Zugriff, während nach außen nur öffentlich deklarierte Programmelemente sichtbar sind."
"Als Java entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht privat deklariert ist, ist zugreifbar), nach außen sind jedoch nur öffentlich deklarierte Programmelemente sichtbar.",Wie ist der Zugriff auf Programmelemente in Java geregelt?,"In Java ist der Zugriff auf Programmelemente so geregelt, dass Klassen eines Programms untereinander privilegierten Zugriff haben, während nach außen nur öffentlich deklarierte Programmelemente sichtbar sind."
"Als Java entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht privat deklariert ist, ist zugreifbar), nach außen sind jedoch nur öffentlich deklarierte Programmelemente sichtbar.",Was ist der Zugriffsschutz in Java?,"In Java wird der Zugriffsschutz durch die Zugriffskontrollmodifikatoren private, protected und public realisiert. Diese Modifikatoren bestimmen, welche Klassen auf die Elemente einer anderen Klasse zugreifen können. Standardmäßig ist alles, was nicht explizit als privat, geschützt oder öffentlich deklariert ist, in Java package-private, d.h. nur innerhalb des Pakets sichtbar."
"Als Java entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht privat deklariert ist, ist zugreifbar), nach außen sind jedoch nur öffentlich deklarierte Programmelemente sichtbar.",Wie wird der Zugriffsschutz in Java realisiert?,"Der Zugriffsschutz in Java wird durch die Zugriffskontrollmodifikatoren private, protected und public realisiert. Diese Modifikatoren bestimmen, welche Klassen auf die Elemente einer anderen Klasse zugreifen können. Standardmäßig ist alles, was nicht explizit als privat, geschützt oder öffentlich deklariert ist, in Java package-private, d.h. nur innerhalb des Pakets sichtbar."
"Als Java entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht privat deklariert ist, ist zugreifbar), nach außen sind jedoch nur öffentlich deklarierte Programmelemente sichtbar.",Was ist der privilegierte Zugriff in Java?,"In Java wird der privilegierte Zugriff durch die Zugriffskontrollmodifikatoren private, protected und public realisiert. Diese Modifikatoren bestimmen, welche Klassen auf die Elemente einer anderen Klasse zugreifen können. Klassen, die sich im selben Paket befinden, können auf package-private Elemente zugreifen, und Klassen, die eine Klasse erweitern, können auf protected Elemente zugreifen. Somit gewähren sich die Klassen eines Programms untereinander privilegierten Zugriff."
"Als Java entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht privat deklariert ist, ist zugreifbar), nach außen sind jedoch nur öffentlich deklarierte Programmelemente sichtbar.",Wie wird der Zugriff auf die Elemente einer anderen Klasse in Java geregelt?,"Der Zugriff auf die Elemente einer anderen Klasse in Java wird durch die Zugriffskontrollmodifikatoren private, protected und public geregelt. Diese Modifikatoren bestimmen, welche Klassen auf die"
"Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.","Was passiert, wenn Programme auf mehrere Pakete aufgeteilt werden?","Wenn Programme auf mehrere Pakete aufgeteilt werden und zwischen den Paketen Abhängigkeiten bestehen, sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete."
"Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.",Warum führen Abhängigkeiten zwischen Paketen zu öffentlichen Deklarationen?,"Wenn zwischen Paketen Abhängigkeiten bestehen, sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente für alle gleichermaßen sichtbar machen."
"Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.",Was ist der Unterschied zwischen Paketen und Modulen?,"Der Unterschied zwischen Paketen und Modulen besteht darin, dass Module neben einer öffentlichen Schnittstelle auch eine private Schnittstelle haben, die für andere Module nicht sichtbar ist, wodurch die Kapselung von Details gewährleistet wird."
"Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.",Was ist die private Schnittstelle eines Moduls?,"Die private Schnittstelle eines Moduls besteht aus allen Deklarationen, die nicht Teil der öffentlichen Schnittstelle sind."
"Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.",Was ist die öffentliche Schnittstelle eines Moduls?,"Die öffentliche Schnittstelle eines Moduls besteht aus allen Deklarationen, die mit einem Schlüsselwort als öffentlich gekennzeichnet sind."
"Diese unbefriedigende Situation wurde von der Java-Community aufgegriffen, die mit der Open Services Gateway Initiative (OSGi) einen Standard etablierte, der die Zusammenfassung von Java-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation erlaubte. Dieser Standard ist unter anderem die Grundlage von Eclipse, das nicht nur eine Java-IDE, sondern im Kern ein Framework für die Entwicklung beliebig komplexer Java-Programme (sog. Rich Clients) ist.",Was ist die Open Services Gateway Initiative (OSGi)?,"Die Open Services Gateway Initiative (OSGi) ist ein Standard, der die Zusammenfassung von Java-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation erlaubt. Dieser Standard ist unter anderem die Grundlage von Eclipse, das nicht nur eine Java-IDE, sondern im Kern ein Framework für die Entwicklung beliebig komplexer Java-Programme (sog. Rich Clients) ist."
"Mit Java 9 wurde dann Java ein eigenes, über Klassen und Paketen stehendes Modulkonzept verpasst. Ein Modul ist demnach eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Eine Moduldeklaration besteht aus einem (eindeutigen) Namen des Moduls, einer Deklaration der angebotenen Schnittstelle (bislang über öffentliche Deklarationen hergestellt) und einer Deklaration der benötigten Schnittstelle (bislang ausschließlich über import-Direktiven deklariert). Neben den allgemeinen Export tritt der sog. qualifizierte Export, wie er auch in EIFFEL vorgesehen ist: Er nennt die Module, an die exportiert wird, namentlich und erlaubt so einen „privaten“ Austausch zwischen bestimmten Modulen (die somit ihre eigenen, oder privaten, Schnittstellen haben).",Was ist ein Modul in Java?,"Ein Modul in Java 9 ist eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Eine Moduldeklaration besteht aus einem (eindeutigen) Namen des Moduls, einer Deklaration der angebotenen Schnittstelle und einer Deklaration der benötigten Schnittstelle. Neben den allgemeinen Export tritt der sog. qualifizierte Export, der den Austausch zwischen bestimmten Modulen erlaubt."
"Das Besondere an der Moduldefinition von Java ist, dass die Einhaltung der damit einhergehenden Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit erzwungen wird. Außerdem kontrolliert sie auch den reflektiven Zugriff auf Programmelemente, der bislang gar nicht unterbunden werden konnte. Java-Programme werden dadurch erheblich sicherer.",Was wird durch die Moduldefinition in Java erzwungen?,"Die Einhaltung der Schnittstellenspezifikationen wird sowohl zur Übersetzungszeit als auch zur Laufzeit erzwungen. Zudem wird der reflektive Zugriff auf Programmelemente kontrolliert, was die Sicherheit von Java-Programmen erhöht."
"Da in SMALLTALK auch eine Klasse ein Objekt ist, kann die Klasse selbst, genau wie alle anderen Objekte, Instanzvariablen und -methoden haben. Aber wo werden diese definiert? Der Analogie der Objekte, die Instanzen der Klasse sind, folgend müsste das in der jeweiligen Klasse der Klasse, also der Klasse, von der die Klasse (als Objekt) eine Instanz ist, erfolgen. Und so ist es tatsächlich auch.",Wo werden Instanzvariablen und -methoden von Klassen definiert?,"Da in SMALLTALK auch eine Klasse ein Objekt ist, kann die Klasse selbst, genau wie alle anderen Objekte, Instanzvariablen und -methoden haben. Diese werden in der jeweiligen Klasse der Klasse, also der Klasse, von der die Klasse (als Objekt) eine Instanz ist, definiert."
"Zunächst könnte man annehmen, dass alle Klassen Instanzen einer speziellen Klasse, nennen wir sie ""Class"", sind. Jede Klasse hätte dann (als Instanz dieser Klasse) die Instanzvariablen und Methoden, die in ""Class"" definiert sind. Insbesondere hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden. Dies scheint zunächst auch sinnvoll, denn bei den Klassen handelt es sich ja um Objekte derselben Art, nämlich einheitlich um Klassen.","Warum sind Klassen keine Instanzen einer speziellen Klasse ""Class""?","Wenn Klassen Instanzen einer speziellen Klasse ""Class"" wären, hätten sie dieselbe Menge von Instanzvariablen und Methoden. Das würde aber bedeuten, dass alle Klassen gleich wären, was nicht der Fall ist. Jede Klasse hat ihre eigene, einzigartige Menge von Instanzvariablen und Methoden. Deshalb sind Klassen keine Instanzen einer speziellen Klasse ""Class""."
"Zunächst könnte man annehmen, dass alle Klassen Instanzen einer speziellen Klasse, nennen wir sie ""Class"", sind. Jede Klasse hätte dann (als Instanz dieser Klasse) die Instanzvariablen und Methoden, die in ""Class"" definiert sind. Insbesondere hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden. Dies scheint zunächst auch sinnvoll, denn bei den Klassen handelt es sich ja um Objekte derselben Art, nämlich einheitlich um Klassen.","Was wäre die Folge davon, wenn jede Klasse Instanzen einer speziellen Klasse ""Class"" wäre?","Wenn jede Klasse Instanzen einer speziellen Klasse ""Class"" wäre, hätten alle Klassen dieselbe Menge von Instanzvariablen und Methoden. Das würde bedeuten, dass alle Klassen gleich wären, was aber nicht der Fall ist. Daher ist es notwendig, dass jede Klasse ihre eigenen Instanzvariablen und Methoden hat."
"Zunächst könnte man annehmen, dass alle Klassen Instanzen einer speziellen Klasse, nennen wir sie ""Class"", sind. Jede Klasse hätte dann (als Instanz dieser Klasse) die Instanzvariablen und Methoden, die in ""Class"" definiert sind. Insbesondere hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden. Dies scheint zunächst auch sinnvoll, denn bei den Klassen handelt es sich ja um Objekte derselben Art, nämlich einheitlich um Klassen.","Warum hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden, wenn sie Instanzen einer speziellen Klasse ""Class"" wären?","Wenn jede Klasse Instanzen einer speziellen Klasse ""Class"" wäre, hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden, weil sie alle Instanzen derselben Klasse sind und somit dieselben Attribute und Methoden haben sollten."
"Es stellt sich dann die Frage, welche Instanzvariablen und Methoden alle Klassen gleichermaßen charakterisieren könnten. Es könnte z. B. jede Klasse eine Instanzvariable haben, die alle von der Klasse instanziierten Objekte enthält, sowie eine weitere, die diese Objekte zählt. Eine typische Methode jeder Klasse wäre z. B. ""new"", die eine neue Instanz dieser Klasse zurückgibt. Was aber, wenn man weitere Eigenschaften (Instanzvariablen oder Methoden) für eine Klasse haben möchte, die diese nicht mit allen anderen teilt? Was, wenn man eine Methode wie z. B. ""new"" für eine Klasse anders definieren will als für andere? Im Fall von ""new"" z. B. ist es denkbar, dass man sie für bestimmte Klassen so umschreiben möchte, dass die Instanzvariablen der neu erzeugten Instanzen bestimmte Startwerte zugewiesen bekommen (so wie es beim Beispiel mit ""Stack"" oben der Fall wäre).",Wozu können Instanzvariablen und Methoden in einer Klasse dienen?,"Instanzvariablen und Methoden in einer Klasse können dazu dienen, alle von der Klasse instanziierten Objekte zu enthalten, diese Objekte zu zählen, eine neue Instanz der Klasse zurückzugeben, bestimmte Startwerte zu Instanzvariablen neuer Instanzen zuzuweisen oder weitere Eigenschaften zu definieren, die die Klasse nicht mit allen anderen teilt."
"Es stellt sich dann die Frage, welche Instanzvariablen und Methoden alle Klassen gleichermaßen charakterisieren könnten. Es könnte z. B. jede Klasse eine Instanzvariable haben, die alle von der Klasse instanziierten Objekte enthält, sowie eine weitere, die diese Objekte zählt. Eine typische Methode jeder Klasse wäre z. B. ""new"", die eine neue Instanz dieser Klasse zurückgibt. Was aber, wenn man weitere Eigenschaften (Instanzvariablen oder Methoden) für eine Klasse haben möchte, die diese nicht mit allen anderen teilt? Was, wenn man eine Methode wie z. B. ""new"" für eine Klasse anders definieren will als für andere? Im Fall von ""new"" z. B. ist es denkbar, dass man sie für bestimmte Klassen so umschreiben möchte, dass die Instanzvariablen der neu erzeugten Instanzen bestimmte Startwerte zugewiesen bekommen (so wie es beim Beispiel mit ""Stack"" oben der Fall wäre).","Was könnte man tun, wenn man weitere Eigenschaften für eine Klasse haben möchte, die diese nicht mit allen anderen teilt?","In diesem Fall kann man eine Unterklasse erstellen, die die gewünschten Eigenschaften besitzt."
"Es stellt sich dann die Frage, welche Instanzvariablen und Methoden alle Klassen gleichermaßen charakterisieren könnten. Es könnte z. B. jede Klasse eine Instanzvariable haben, die alle von der Klasse instanziierten Objekte enthält, sowie eine weitere, die diese Objekte zählt. Eine typische Methode jeder Klasse wäre z. B. ""new"", die eine neue Instanz dieser Klasse zurückgibt. Was aber, wenn man weitere Eigenschaften (Instanzvariablen oder Methoden) für eine Klasse haben möchte, die diese nicht mit allen anderen teilt? Was, wenn man eine Methode wie z. B. ""new"" für eine Klasse anders definieren will als für andere? Im Fall von ""new"" z. B. ist es denkbar, dass man sie für bestimmte Klassen so umschreiben möchte, dass die Instanzvariablen der neu erzeugten Instanzen bestimmte Startwerte zugewiesen bekommen (so wie es beim Beispiel mit ""Stack"" oben der Fall wäre).","Was könnte man tun, wenn man eine Methode wie z.B. ""new"" für eine Klasse anders definieren will als für andere?","In diesem Fall kann man eine Unterklasse erstellen und die Methode ""new"" in der Unterklasse anders definieren."
"Es stellt sich dann die Frage, welche Instanzvariablen und Methoden alle Klassen gleichermaßen charakterisieren könnten. Es könnte z. B. jede Klasse eine Instanzvariable haben, die alle von der Klasse instanziierten Objekte enthält, sowie eine weitere, die diese Objekte zählt. Eine typische Methode jeder Klasse wäre z. B. ""new"", die eine neue Instanz dieser Klasse zurückgibt. Was aber, wenn man weitere Eigenschaften (Instanzvariablen oder Methoden) für eine Klasse haben möchte, die diese nicht mit allen anderen teilt? Was, wenn man eine Methode wie z. B. ""new"" für eine Klasse anders definieren will als für andere? Im Fall von ""new"" z. B. ist es denkbar, dass man sie für bestimmte Klassen so umschreiben möchte, dass die Instanzvariablen der neu erzeugten Instanzen bestimmte Startwerte zugewiesen bekommen (so wie es beim Beispiel mit ""Stack"" oben der Fall wäre).","Warum kann es sinnvoll sein, eine Methode wie ""new"" für bestimmte Klassen anders zu definieren?","Es kann sinnvoll sein, eine Methode wie ""new"" für bestimmte Klassen anders zu definieren, um die Instanzvariablen der neu erzeugten Instanzen bestimmte Startwerte zuzuweisen oder um das Verhalten der Methode an die Anforderungen der Klasse anzupassen."
"Tatsächlich hat die Programmierpraxis gezeigt, dass es günstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu müssen. Um dies zu ermöglichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können. Und genau das ist in SMALLTALK der Fall.",Was ist der Zweck von Klassen in SMALLTALK?,"In SMALLTALK hat jede Klasse Instanz ihre eigenen Instanzvariablen und Methoden, die nur für sie angelegt werden können. Dies ermöglicht eine Programmierpraxis, bei der jede Klasse ihre eigenen Instanzvariablen und Methoden besitzt und die Programmiererin diese frei bestimmen kann, ohne dabei an andere Klassen denken zu müssen."
"Tatsächlich hat die Programmierpraxis gezeigt, dass es günstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu müssen. Um dies zu ermöglichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können. Und genau das ist in SMALLTALK der Fall.","Was ermöglicht es in Smalltalk, dass jede Klasse ihre eigenen Instanzvariablen und Methoden besitzt?","In Smalltalk kann jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können, da jede Klasse Instanz einer eigenen Klasse ist."
"Tatsächlich hat die Programmierpraxis gezeigt, dass es günstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu müssen. Um dies zu ermöglichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können. Und genau das ist in SMALLTALK der Fall.","Warum ist es günstig, wenn jede Klasse ihre eigenen Instanzvariablen und Methoden besitzt?","Es ist günstig, wenn jede Klasse ihre eigenen Instanzvariablen und Methoden besitzt, weil es die Programmiererin ermöglicht, diese frei zu bestimmen, ohne dabei an andere Klassen denken zu müssen. Dies führt zu einer besseren Kapselung und Modularität des Codes."
"Zu jeder Klasse des SMALLTALK-Systems gehört nämlich genau eine Klasse, von der erstere (und nur diese) eine Instanz ist. Diese zweite Klasse wird Metaklasse der ersten genannt. Da eine 1-zu-1-Beziehung zwischen Klassen und ihren Metaklassen besteht, ist es nicht sinnvoll, ihre Benennung den Programmiererinnen zu überlassen; sie wird in SMALLTALK stets durch den Ausdruck ""<Klassenname> class"", also beispielsweise ""Stack class"", bezeichnet. Daraus folgt bereits, dass die Programmiererin die Metaklasse nicht selbst anlegen muss (denn dabei müsste sie ja auch einen Namen vergeben) — sie wird vielmehr automatisch mit angelegt, wenn die Programmiererin eine neue Klasse definiert.",Was ist eine Metaklasse in SMALLTALK?,"In SMALLTALK ist eine Metaklasse eine Klasse, die genau einer Klasse zugeordnet ist und von der diese Instanz ist. Die Benennung der Metaklasse erfolgt automatisch durch den Ausdruck ""<Klassenname> class"". Die Programmiererin muss die Metaklasse nicht selbst anlegen, sie wird automatisch mit angelegt, wenn eine neue Klasse definiert wird."
"Im Prinzip ist die Definition einer Metaklasse genauso aufgebaut wie die einer normalen Klasse: Sie besteht aus der Angabe einer Menge von benannten Instanzvariablen und einer Menge von Instanzmethodendefinitionen. Lediglich indizierte Instanzvariablen sind nicht vorgesehen, und der Klassenname kann wie gesagt nicht frei angegeben werden.",Wie ist die Definition einer Metaklasse aufgebaut?,"Die Definition einer Metaklasse ist ähnlich wie die einer normalen Klasse aufgebaut, bestehend aus benannten Instanzvariablen und Instanzmethodendefinitionen. Der Klassenname kann jedoch nicht frei angegeben werden. Indizierte Instanzvariablen sind nicht vorgesehen."
"Im Prinzip ist die Definition einer Metaklasse genauso aufgebaut wie die einer normalen Klasse: Sie besteht aus der Angabe einer Menge von benannten Instanzvariablen und einer Menge von Instanzmethodendefinitionen. Lediglich indizierte Instanzvariablen sind nicht vorgesehen, und der Klassenname kann wie gesagt nicht frei angegeben werden.",Was ist der Unterschied zwischen einer Metaklasse und einer normalen Klasse?,"Der Unterschied zwischen einer Metaklasse und einer normalen Klasse besteht darin, dass Metaklassen keine indizierten Instanzvariablen enthalten dürfen und der Klassenname nicht frei angegeben werden kann."
"Im Prinzip ist die Definition einer Metaklasse genauso aufgebaut wie die einer normalen Klasse: Sie besteht aus der Angabe einer Menge von benannten Instanzvariablen und einer Menge von Instanzmethodendefinitionen. Lediglich indizierte Instanzvariablen sind nicht vorgesehen, und der Klassenname kann wie gesagt nicht frei angegeben werden.",Was ist eine Instanz?,Eine Instanz ist ein konkretes Exemplar einer Klasse.
"Im Prinzip ist die Definition einer Metaklasse genauso aufgebaut wie die einer normalen Klasse: Sie besteht aus der Angabe einer Menge von benannten Instanzvariablen und einer Menge von Instanzmethodendefinitionen. Lediglich indizierte Instanzvariablen sind nicht vorgesehen, und der Klassenname kann wie gesagt nicht frei angegeben werden.",Was ist eine explizite Zuweisung?,"Eine explizite Zuweisung ist eine Zuweisung, die durch den Zuweisungsoperator vorgenommen wird."
"Im Prinzip ist die Definition einer Metaklasse genauso aufgebaut wie die einer normalen Klasse: Sie besteht aus der Angabe einer Menge von benannten Instanzvariablen und einer Menge von Instanzmethodendefinitionen. Lediglich indizierte Instanzvariablen sind nicht vorgesehen, und der Klassenname kann wie gesagt nicht frei angegeben werden.",Was ist eine implizite Zuweisung?,"Eine implizite Zuweisung ist eine Zuweisung, die bei Methodenaufrufen vorgenommen wird."
"Für die Implementierung der Methode ""new"" fehlt uns noch etwas; sie wird im nächsten Abschnitt nachgeliefert. Hier ist wichtig, dass Sie verstehen, dass ""new"" eine Instanzmethode der Metaklasse ""Stack class"" ist und damit das Verhalten der Klasse ""Stack"" bestimmt und nicht ihrer Objekte.","Was ist die Methode ""new""?","Die Methode ""new"" ist eine Instanzmethode der Metaklasse ""Stack class"" und bestimmt das Verhalten der Klasse ""Stack"" und nicht ihrer Objekte. Die Implementierung der Methode ""new"" fehlt noch und wird im nächsten Abschnitt nachgeliefert."
"Aufgrund der bestehenden 1-zu-1-Beziehung zwischen Klassen und Metaklassen werden diese in SMALLTALK nicht getrennt voneinander definiert, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt demnach neben den Abschnitten zur Deklaration der Instanzvariablen und zur Definition der Methoden auch noch über zwei Abschnitte für die entsprechenden Angaben zur ihrer Metaklasse, die Angabe der sogenannten Klassenvariablen und -methoden: Es sind dies die Variablen bzw. Methoden, die den Klassen als Instanzen ihrer Metaklassen zugeordnet sind.",Wie ist das Verhältnis von Klassen und Metaklassen in SMALLTALK?,"Aufgrund der bestehenden 1-zu-1-Beziehung zwischen Klassen und Metaklassen werden diese in SMALLTALK nicht getrennt voneinander definiert, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt demnach neben den Abschnitten zur Deklaration der Instanzvariablen und zur Definition der Methoden auch noch über zwei Abschnitte für die entsprechenden Angaben zur ihrer Metaklasse, die Angabe der sogenannten Klassenvariablen und -methoden."
"Aufgrund der bestehenden 1-zu-1-Beziehung zwischen Klassen und Metaklassen werden diese in SMALLTALK nicht getrennt voneinander definiert, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt demnach neben den Abschnitten zur Deklaration der Instanzvariablen und zur Definition der Methoden auch noch über zwei Abschnitte für die entsprechenden Angaben zur ihrer Metaklasse, die Angabe der sogenannten Klassenvariablen und -methoden: Es sind dies die Variablen bzw. Methoden, die den Klassen als Instanzen ihrer Metaklassen zugeordnet sind.",Was ist die Beziehung zwischen Klassen und Metaklassen in Smalltalk?,"In Smalltalk besteht eine 1-zu-1-Beziehung zwischen Klassen und Metaklassen, die nicht getrennt voneinander definiert werden, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt über Abschnitte für die Deklaration der Instanzvariablen, Definition der Methoden, Angabe der Klassenvariablen und -methoden."
"Aufgrund der bestehenden 1-zu-1-Beziehung zwischen Klassen und Metaklassen werden diese in SMALLTALK nicht getrennt voneinander definiert, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt demnach neben den Abschnitten zur Deklaration der Instanzvariablen und zur Definition der Methoden auch noch über zwei Abschnitte für die entsprechenden Angaben zur ihrer Metaklasse, die Angabe der sogenannten Klassenvariablen und -methoden: Es sind dies die Variablen bzw. Methoden, die den Klassen als Instanzen ihrer Metaklassen zugeordnet sind.",Was sind Klassenvariablen und Klassenmethoden in Smalltalk?,"Klassenvariablen und Klassenmethoden sind Variablen und Methoden, die den Klassen als Instanzen ihrer Metaklassen zugeordnet sind. Sie werden in den Abschnitten für die entsprechenden Angaben zur Metaklasse in einer Klassendefinition definiert."
"Klassenvariablen sind übrigens relativ zu den Instanzen der Klassen global; sie beginnen deswegen mit einem Großbuchstaben. Klassenmethoden schreibt man jedoch wie Instanzmethoden klein. Beachten Sie, dass Klassenvariablen nur einmal pro Klasse angelegt werden — sie sind also für alle Instanzen einer Klasse dieselben.",Was sind Klassenvariablen und wie werden sie geschrieben?,"Klassenvariablen sind Variablen, die relativ zu den Instanzen der Klassen global sind und deshalb mit einem Großbuchstaben beginnen. Im Gegensatz dazu werden Klassenmethoden wie Instanzmethoden klein geschrieben. Klassenvariablen werden nur einmal pro Klasse angelegt und sind deshalb für alle Instanzen einer Klasse dieselben."
"Klassenvariablen sind übrigens relativ zu den Instanzen der Klassen global; sie beginnen deswegen mit einem Großbuchstaben. Klassenmethoden schreibt man jedoch wie Instanzmethoden klein. Beachten Sie, dass Klassenvariablen nur einmal pro Klasse angelegt werden — sie sind also für alle Instanzen einer Klasse dieselben.",Was sind Klassenvariablen und wie werden Klassenmethoden geschrieben?,"Klassenvariablen sind Variablen, die für alle Instanzen einer Klasse dieselben sind und mit einem Großbuchstaben beginnen. Klassenmethoden hingegen werden wie Instanzmethoden klein geschrieben."
"Ein Beispiel für eine Klassenvariable ist ""Dependents Fields"" in der Klasse ""Object"" (zu ihrer Verwendung s. Abschnitt 14.3), eins für eine Klassenmethode ist ""pi"" in der Klasse ""Float"":",Was sind Klassenvariablen und Klassenmethoden?,"Klassenvariablen und Klassenmethoden sind Variablen und Methoden, die allen Instanzen einer Klasse gemeinsam sind. Klassenvariablen werden mit einem Doppelpunkt und dem Klassennamen deklariert, Klassenmethoden mit einem Pluszeichen und dem Klassennamen. Sie können von allen Instanzen der Klasse aus aufgerufen werden. Ein Beispiel für eine Klassenvariable ist ""Dependents Fields"" in der Klasse ""Object"", eins für eine Klassenmethode ist ""pi"" in der Klasse ""Float""."
"Sie retourniert (den Inhalt der) Klassenvariable ""Pi"" und ist, da sie eine Klassenmethode ist, allen Instanzen der Klasse ""Float"" zugeordnet. Dazu, wie der Wert in ""Pi"" hineinkommt, s. Abschnitt 8.2.",Was ist eine Klassenvariable?,"Eine Klassenvariable ist eine Variable, die einer Klasse gehört und allen Instanzen dieser Klasse gemeinsam ist. In diesem Fall gehört die Klassenvariable ""Pi"" der Klasse ""Float"" und ist allen Instanzen dieser Klasse zugeordnet."
"Sie retourniert (den Inhalt der) Klassenvariable ""Pi"" und ist, da sie eine Klassenmethode ist, allen Instanzen der Klasse ""Float"" zugeordnet. Dazu, wie der Wert in ""Pi"" hineinkommt, s. Abschnitt 8.2.",Was ist eine Klassenvariable und wie wird ihr Wert zugeordnet?,"Eine Klassenvariable ist eine Variable, die einer Klasse gehört und nicht den Instanzen der Klasse. Ihr Wert wird zugeordnet, indem er in den Abschnitt 8.2 geschrieben wird. Die Klassenvariable ""Pi"" wird in der Klassenmethode ""pi"" zurückgegeben."
"Sie retourniert (den Inhalt der) Klassenvariable ""Pi"" und ist, da sie eine Klassenmethode ist, allen Instanzen der Klasse ""Float"" zugeordnet. Dazu, wie der Wert in ""Pi"" hineinkommt, s. Abschnitt 8.2.","Was macht die Instanzmethode ""printOn:""?","Die Instanzmethode ""printOn:"" ist eine Methode, die jedem Objekt zugeordnet ist und aufgerufen wird, wenn ein Objekt ausgegeben werden soll, z.B. im Rahmen einer Fehlermeldung."
"Sie retourniert (den Inhalt der) Klassenvariable ""Pi"" und ist, da sie eine Klassenmethode ist, allen Instanzen der Klasse ""Float"" zugeordnet. Dazu, wie der Wert in ""Pi"" hineinkommt, s. Abschnitt 8.2.","Was macht die Klassenmethode ""new""?","Die Klassenmethode ""new"" ist eine Methode, die jedem Objekt zugeordnet ist und aufgerufen wird, wenn ein neues Objekt erzeugt werden soll."
"Sie retourniert (den Inhalt der) Klassenvariable ""Pi"" und ist, da sie eine Klassenmethode ist, allen Instanzen der Klasse ""Float"" zugeordnet. Dazu, wie der Wert in ""Pi"" hineinkommt, s. Abschnitt 8.2.","Was macht die Instanzmethode ""+"", wenn sie aufgerufen wird?","Die Instanzmethode ""+"" ist eine Methode, die jedem Objekt zugeordnet ist und aufgerufen wird, wenn zwei Objekte addiert werden sollen."
"Wir sehen also, dass die Bezeichnungen Klassenvariable bzw. -methode und Instanzvariable bzw. -methode eigentlich nur relative Bedeutung haben, da es sich in beiden Fällen um Variablen und Methoden handelt, die Objekten zugeordnet sind. Da man von Instanzen einer Klasse aus aber auch häufiger auf die Variablen und Methoden ihrer Klassen zugreift, ist es guter Brauch (und vermeidet umständliche Formulierungen), stets die längeren Bezeichnungen zu führen. Zudem gibt es neben Instanz- und Klassenvariablen ja auch noch andere Variabletypen (formale Parameter und temporäre Variablen), so dass die Verwendung von „Variable“ allein meist mehrdeutig wäre. Lediglich bei Methoden hat es sich eingebürgert, anstelle von Instanzmethoden nur von Methoden zu sprechen. Wenn der Kontext nichts anderes nahelegt, können Sie dann immer davon ausgehen, dass Instanzmethoden gemeint sind.",Was ist der Unterschied zwischen Instanzvariablen und Klassenvariablen?,"Der Unterschied zwischen Instanzvariablen und Klassenvariablen liegt darin, dass Instanzvariablen jeweils zu einer Instanz gehören, während Klassenvariablen zu einer Klasse gehören. Das bedeutet, dass jede Instanz einer Klasse ihre eigenen Werte für die Instanzvariablen hat, während alle Instanzen einer Klasse die gleichen Werte für die Klassenvariablen teilen."
"Von SMALLTALK kennen Sie bereits die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren (die interne Iteration; siehe Abschnitt 4.6.4 in Kurseinheit 1 und Kapitel 13 in Kurseinheit 2). Mit Version 8 wurden nun auch in Java (anonyme) Funktionen (die sog. Lambda-Ausdrücke) eingeführt, die interne Iterationen à la SMALLTALK erlauben. Allerdings wurde für die Implementierung der Methoden forEach, filter, map und reduce (entsprechend SMALLTALKs do, select, collect und inject) ein eigenes Framework geschaffen: die sog. Streams.",Was sind Streams in Java?,"Streams in Java sind ein Framework, das interne Iterationen à la SMALLTALK erlaubt. Mit Hilfe von Streams können Methoden wie forEach, filter, map und reduce definiert werden, die auf Collection-Klassen angewendet werden können."
"Streams sind ein mit Java 8 neu eingeführtes Konstrukt, das eine Datenverarbeitung in Pipelines ganz ähnlich wie die Collections in SMALLTALK ermöglicht: Das Ergebnis einer Operation wie filter oder map, auf einem Stream ausgeführt, ist wieder ein Stream, auf dem weitere Operationen dieser Art ausgeführt werden können (das Pipelining). Das Besondere an Streams ist, dass sie keine Datenspeicher wie Collections sind, sondern interne Iteratoren: Jeder Stream für sich hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen. Dabei dienen Streams entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren (wie beispielsweise ein Zufallszahlengenerator oder eine Vorschrift zur Berechnung einer Fibonacci-Folge) als Quelle. Ein Ergebnis liefert eine Stream-Pipeline (die auch aus nur einem Element bestehen kann) immer erst durch einen sog. Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert (eine Collection im Falle von collect).",Was sind Streams in Java 8?,"Streams in Java 8 sind ein neues Konstrukt, das eine Datenverarbeitung in Pipelines ermöglicht. Sie sind interne Iteratoren, die eine potenziell unendliche Folge von Elementen halten. Streams können entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren als Quelle dienen. Ein Ergebnis liefert eine Stream-Pipeline immer durch einen Abschluss, also eine Methode, die ein anderes Ergebnis als einen Stream liefert."
"Das Stream-Framework von Java ermöglicht für viele Pipelines eine besonders effiziente Ausführung. So muss jedes Element einer Datenquelle in der Regel nur einmal angefragt werden, und die interne Speicherung von Zwischenergebnissen wird automatisch gering gehalten. Insbesondere wird gegenüber einer naiven Implementierung von Pipelines, die eine Iteration je Element der Pipeline benötigt, in vielen Fällen nur eine Iteration benötigt (die sog. Stream-Fusion). Zudem kann durch die Wahl des Streams (und nicht der Operationen) bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt. Gleichwohl ist die Performanz von Java-Pipelines nicht leicht vorherzusagen, und eine gewinnbringende Verwendung setzt sicherlich einiges an Erfahrung und Kenntnissen der Implementierung voraus.",Was ermöglicht das Stream-Framework von Java?,"Das Stream-Framework von Java ermöglicht eine besonders effiziente Ausführung für viele Pipelines, indem jedes Element einer Datenquelle nur einmal angefragt wird und die interne Speicherung von Zwischenergebnissen automatisch gering gehalten wird. Es kann auch bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt."
"Beim Subtyping unterscheidet man, wie bei der Typäquivalenz und -konformität, zwischen nominalem und strukturellem Subtyping. Nominales Subtyping liegt vor, wenn ein Subtyp aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. Strukturelles Subtyping liegt vor, wenn ein Typ lediglich die obige Definition von Subtyp erfüllen muss, um als solcher zu gelten. Nominales Subtyping impliziert strukturelles; analog zur Typkonformität macht das nominale Subtyping die Subtypenbeziehung antisymmetrisch, das strukturelle hingegen nicht.",Was ist der Unterschied zwischen nominalem und strukturellem Subtyping?,"Nominales Subtyping liegt vor, wenn ein Subtyp aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. Strukturelles Subtyping liegt vor, wenn ein Typ lediglich die obige Definition von Subtyp erfüllen muss, um als solcher zu gelten. Nominales Subtyping impliziert strukturelles, während strukturelles Subtyping die Subtypenbeziehung nicht antisymmetrisch macht."
"Eine gängige Namenskonvention ist beispielsweise, Namen von Interfacetypen mit einem großen ""I"" beginnen zu lassen. Andere Namenskonventionen verlangen, dass Bezeichner, die für ein Objekt oder einen Wert stehen (also Variablen und Funktionsnamen), den Typ dieses Objekts oder Werts widerspiegeln — die sog. ungarische Notation, von der es allerdings verschiedene Auslegungen gibt. Nach einer eher unklugen Auslegung müssen beispielsweise alle Variablen, die Strings bezeichnen, mit ""str"" beginnen (eine Information, die Compiler und IDE ohnehin bereithalten und die deswegen nicht noch den Namen belasten muss). Nach einer sinnvolleren Auslegung sollten Variablen um die Verwendung ihres so bezeichneten Inhalts ergänzt werden. Das bedeutet, die Funktion des durch sie bezeichneten Objekts oder Werts innerhalb des Kontextes, in dem die Variable gültig ist, anzugeben. Diese kontextbezogene Funktion kann in der objektorientierten Programmierung jedoch auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt und somit auch vom Compiler überprüft werden.",Was ist die ungarische Notation?,"Die ungarische Notation ist eine Namenskonvention, bei der Bezeichner, die für ein Objekt oder einen Wert stehen, den Typ dieses Objekts oder Werts widerspiegeln. Es gibt verschiedene Auslegungen der ungarischen Notation, eine davon verlangt, dass alle Variablen, die Strings bezeichnen, mit ""str"" beginnen. Eine sinnvollere Auslegung ist, Variablen um die Verwendung ihres so bezeichneten Inhalts zu ergänzen, was in der objektorientierten Programmierung auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt werden kann."
"Eine gängige Namenskonvention ist beispielsweise, Namen von Interfacetypen mit einem großen ""I"" beginnen zu lassen. Andere Namenskonventionen verlangen, dass Bezeichner, die für ein Objekt oder einen Wert stehen (also Variablen und Funktionsnamen), den Typ dieses Objekts oder Werts widerspiegeln — die sog. ungarische Notation, von der es allerdings verschiedene Auslegungen gibt. Nach einer eher unklugen Auslegung müssen beispielsweise alle Variablen, die Strings bezeichnen, mit ""str"" beginnen (eine Information, die Compiler und IDE ohnehin bereithalten und die deswegen nicht noch den Namen belasten muss). Nach einer sinnvolleren Auslegung sollten Variablen um die Verwendung ihres so bezeichneten Inhalts ergänzt werden. Das bedeutet, die Funktion des durch sie bezeichneten Objekts oder Werts innerhalb des Kontextes, in dem die Variable gültig ist, anzugeben. Diese kontextbezogene Funktion kann in der objektorientierten Programmierung jedoch auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt und somit auch vom Compiler überprüft werden.",Wozu dienen Namenskonventionen?,"Namenskonventionen werden verwendet, um die Bedeutung von Bezeichnern zu verdeutlichen und die Lesbarkeit des Codes zu erhöhen. Eine gängige Namenskonvention ist beispielsweise, Namen von Interfacetypen mit einem großen ""I"" beginnen zu lassen. Nach einer sinnvolleren Auslegung der ungarischen Notation sollten Variablen um die Verwendung ihres so bezeichneten Inhalts ergänzt werden. Das bedeutet, die Funktion des durch sie bezeichneten Objekts oder Werts innerhalb des Kontextes, in dem die Variable gültig ist, anzugeben. Diese kontextbezogene Funktion kann in der objektorientierten Programmierung jedoch auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt und somit auch vom Compiler überprüft werden."
"Wie bereits in Abschnitt 10.3 erwähnt, wird die Programmiererin, die eine abstrakte, weil unvollständige, Klasse instanziiert, irgendwann damit bestraft, dass das Versenden einer Nachricht an die entsprechende Instanz zu einer Fehlermeldung führt, die ihr (per subclassResponsibility oder implementedBySubclass, die, genau wie doesNotUnderstand:, in der Klasse Object definiert ist) anzeigt, dass die Methode (erst) in einer Subklasse implementiert werden sollte. Dummerweise bekommt die Programmiererin diesen Hinweis erst zur Laufzeit des Programms zu Gesicht, also dann, wenn es schon zu spät ist (es sei denn, man testet gerade). Man erkennt hieran sehr schön den interaktiven Geist des SMALLTALK-Systems, insbesondere die Philosophie, nach der Programmieren nichts weiter ist als das iterative Zurechtbiegen und Erweitern eines bereits bestehenden, funktionierenden Systems. Man muss eine Weile damit gespielt haben, um diesem Charme zu erliegen.",Was ist die Philosophie des SMALLTALK-Systems?,"Die Philosophie des SMALLTALK-Systems ist, dass Programmieren nichts weiter ist als das iterative Zurechtbiegen und Erweitern eines bereits bestehenden, funktionierenden Systems. Diese Philosophie spiegelt sich in der Interaktivität des SMALLTALK-Systems wider."
"Wie bereits in Abschnitt 10.3 erwähnt, wird die Programmiererin, die eine abstrakte, weil unvollständige, Klasse instanziiert, irgendwann damit bestraft, dass das Versenden einer Nachricht an die entsprechende Instanz zu einer Fehlermeldung führt, die ihr (per subclassResponsibility oder implementedBySubclass, die, genau wie doesNotUnderstand:, in der Klasse Object definiert ist) anzeigt, dass die Methode (erst) in einer Subklasse implementiert werden sollte. Dummerweise bekommt die Programmiererin diesen Hinweis erst zur Laufzeit des Programms zu Gesicht, also dann, wenn es schon zu spät ist (es sei denn, man testet gerade). Man erkennt hieran sehr schön den interaktiven Geist des SMALLTALK-Systems, insbesondere die Philosophie, nach der Programmieren nichts weiter ist als das iterative Zurechtbiegen und Erweitern eines bereits bestehenden, funktionierenden Systems. Man muss eine Weile damit gespielt haben, um diesem Charme zu erliegen.","Was passiert, wenn eine Programmiererin eine abstrakte Klasse instanziiert und eine Nachricht an die entsprechende Instanz sendet?","Wenn eine Programmiererin eine abstrakte Klasse instanziiert und eine Nachricht an die entsprechende Instanz sendet, führt dies zu einer Fehlermeldung, die ihr anzeigt, dass die Methode (erst) in einer Subklasse implementiert werden sollte. Diese Fehlermeldung bekommt die Programmiererin allerdings erst zur Laufzeit des Programms zu Gesicht, was bedeutet, dass sie das Problem erst bemerkt, wenn es bereits zu spät ist."
"Wie bereits in Abschnitt 10.3 erwähnt, wird die Programmiererin, die eine abstrakte, weil unvollständige, Klasse instanziiert, irgendwann damit bestraft, dass das Versenden einer Nachricht an die entsprechende Instanz zu einer Fehlermeldung führt, die ihr (per subclassResponsibility oder implementedBySubclass, die, genau wie doesNotUnderstand:, in der Klasse Object definiert ist) anzeigt, dass die Methode (erst) in einer Subklasse implementiert werden sollte. Dummerweise bekommt die Programmiererin diesen Hinweis erst zur Laufzeit des Programms zu Gesicht, also dann, wenn es schon zu spät ist (es sei denn, man testet gerade). Man erkennt hieran sehr schön den interaktiven Geist des SMALLTALK-Systems, insbesondere die Philosophie, nach der Programmieren nichts weiter ist als das iterative Zurechtbiegen und Erweitern eines bereits bestehenden, funktionierenden Systems. Man muss eine Weile damit gespielt haben, um diesem Charme zu erliegen.",Was ist der interaktive Geist des SMALLTALK-Systems?,"Der interaktive Geist des SMALLTALK-Systems liegt in der Philosophie, nach der Programmieren nichts weiter ist als das iterative Zurechtbiegen und Erweitern eines bereits bestehenden, funktionierenden Systems. Diese Philosophie ermöglicht es, dass Fehlermeldungen erst zur Laufzeit des Programms auftreten, was die Programmiererin dazu zwingt, das System interaktiv zu testen und zu erweitern."
"Wenn man sich erst einmal damit abgefunden hat, dass man als Programmiererin Methoden schreibt, die ausschließlich dem Zweck dienen, sich selbst oder eine Kollegin auf Programmierfehler hinzuweisen, dann erscheint einem eine weitere SMALLTALK-Konvention geradezu als elegant, nämlich die, geerbte Methoden durch Überschreiben auszulöschen. Tatsächlich ist genau hierfür eine weitere Methode in der Klasse Object mit dem Namen „shouldNotImplement“ vorgesehen, die zu einer entsprechenden Fehlermeldung führt. Eine Klasse, die also eine geerbte Methode löschen möchte, überschreibt diese einfach mit shouldNotImplement. Bevor Sie jetzt als disziplinierte Programmiererin den Stab über SMALLTALK brechen, erlauben Sie noch den Hinweis, dass der Wunsch, geerbte Methoden zu löschen, eine direkte Folge der vorrangigen Orientierung an Vererbung ist, die bereits oben kritisiert wurde: Wäre die Superklasse auf Grundlage des Prinzips der Generalisierung ausgewählt worden, käme man gar nicht in die Verlegenheit, Methoden löschen zu wollen, denn alles, was für die Generalisierung sinnvoll ist, ist grundsätzlich auch für ihre Spezialisierungen sinnvoll, oder die Generalisierung ist keine Generalisierung. Außerdem haben Sie auch in Sprachen mit starker Typprüfung, in denen das Löschen von Methoden nicht möglich ist, als Programmiererin immer die Freiheit, eine Methode so zu überschreiben, dass sie garantiert nichts tut, was mit der Idee der Klasse, von der sie geerbt ist, in Einklang zu bringen wäre. Auch hier wäre ein Laufzeitfehler die unvermeidbare Folge. Mehr dazu in Kurseinheit 3; hier sei nur so viel bemerkt wie, dass wenn man sich bei der Organisation seiner Klassenhierarchie auf das Prinzip der Generalisierung stützt, man dann auch nicht in die Verlegenheit kommt, Methoden löschen zu wollen.","Wozu dient die Methode ""shouldNotImplement"" in Smalltalk?","Die Methode ""shouldNotImplement"" in Smalltalk dient dazu, geerbte Methoden durch Überschreiben auszulöschen und eine entsprechende Fehlermeldung zu erzeugen."
"C-Sharp ist nicht nur ein Nachahmer von Java, sondern war auch ein Pionier für Spracherweiterungen, die es inzwischen auch in Java gibt: So gab es in C-Sharp von Anfang an sog. Attributes, die in Java in der Version 5 als Annotationen (was in jedem Fall der bessere Name ist) Einzug gehalten haben. C-Sharp hatte auch schon ab der Version 3.0 Lambda-Ausdrücke (ein Element funktionaler Programmiersprachen, in SMALLTALK — in Form von Blöcken — schon immer vorhanden und ein Grundelement der Sprache); Java ist erst mit Version 8 nachgezogen. Die Gefahr besteht jedoch darin, dass sich die beiden Sprachen gegenseitig übertrumpfen könnten — irgendwann wird jemand auf die Idee kommen, aus den besten Eigenschaften beider eine neue Sprache zu destillieren (KOTLIN mag hier ein erstes Beispiel sein). Vielleicht wird bei der Gelegenheit auch endlich mit dem C-Erbe aufgeräumt und die fürchterliche Syntax entsorgt.",Was sind Annotationen in Java?,"Annotationen in Java sind eine Spracherweiterung, die es ermöglicht, zusätzliche Informationen zu Klassen, Methoden und Variablen hinzuzufügen. Sie wurden von C-Sharp inspiriert und ermöglichen es, Metadaten zu definieren, die von Compilern, Tools und Frameworks ausgewertet werden können."
"C-Sharp ist nicht nur ein Nachahmer von Java, sondern war auch ein Pionier für Spracherweiterungen, die es inzwischen auch in Java gibt: So gab es in C-Sharp von Anfang an sog. Attributes, die in Java in der Version 5 als Annotationen (was in jedem Fall der bessere Name ist) Einzug gehalten haben. C-Sharp hatte auch schon ab der Version 3.0 Lambda-Ausdrücke (ein Element funktionaler Programmiersprachen, in SMALLTALK — in Form von Blöcken — schon immer vorhanden und ein Grundelement der Sprache); Java ist erst mit Version 8 nachgezogen. Die Gefahr besteht jedoch darin, dass sich die beiden Sprachen gegenseitig übertrumpfen könnten — irgendwann wird jemand auf die Idee kommen, aus den besten Eigenschaften beider eine neue Sprache zu destillieren (KOTLIN mag hier ein erstes Beispiel sein). Vielleicht wird bei der Gelegenheit auch endlich mit dem C-Erbe aufgeräumt und die fürchterliche Syntax entsorgt.",Was ist der Unterschied zwischen C-Sharp und Java?,"C-Sharp und Java sind beides objektorientierte Programmiersprachen, aber C-Sharp war ein Pionier für Spracherweiterungen, die es inzwischen auch in Java gibt, wie zum Beispiel Attribute und Lambda-Ausdrücke. Die Gefahr besteht jedoch darin, dass sich die beiden Sprachen gegenseitig übertrumpfen könnten und irgendwann jemand auf die Idee kommt, eine neue Sprache zu destillieren, die die besten Eigenschaften beider Sprachen vereint. Vielleicht wird bei der Gelegenheit auch endlich mit dem C-Erbe aufgeräumt und die fürchterliche Syntax von C-Sharp entsorgt."
"Sprachphilosophisch gesehen ist eine Klasse ein Allgemeinbegriff wie etwa ""Person"", ""Haus"" oder ""Dokument"". Diese Allgemeinbegriffe stehen in der Regel für eine ganze Menge von Objekten, also etwa alle Personen, Häuser oder Dokumente. Gleichwohl ist die Klasse selbst immer ein Singular — sie ist nämlich selbst ein Objekt, das unter den Allgemeinbegriff ""Klasse"" fällt. Diese Sprachregelung wird auch in der objektorientierten Programmierung eingehalten (obwohl sie natürlich nicht, da Computer unsere Sprache nicht kennen, überprüft werden kann und deswegen Abweichungen immer wieder vorkommen): Alle Klassennamen sind Singular.",Was sind Klassen sprachphilosophisch?,"Sprachphilosophisch betrachtet ist eine Klasse ein Allgemeinbegriff. Diese Allgemeinbegriffe repräsentieren in der Regel eine Menge von Objekten,. Dennoch ist die Klasse selbst immer im Singular, da sie selbst ein Objekt ist, das unter den Allgemeinbegriff ""Klasse"" fällt."
"Jede Klasse ist mit bestimmten Eigenschaften verbunden, die charakteristisch für sie sind. Diese Eigenschaften ordnen wir jedoch nicht der Klasse selbst zu, sondern den Objekten, die dieser Klasse angehören. Zum Beispiel sind mit dem Allgemeinbegriff ""Person"" Eigenschaften wie Name, Geburtstag und möglicherweise weitere Attribute verknüpft, aber auch bestimmtes, für Personen charakteristisches Verhalten. Dasselbe Prinzip gilt für ""Haus"", ""Dokument"" und alle anderen Allgemeinbegriffe. Existenz und Adäquatheit von Allgemeinbegriffen sind Themen großer philosophischer Diskurse wie etwa dem sog. Universalienstreit und stehen hier nicht zur Debatte. Wichtig ist, dass mit ihnen stets Sätze wie „<ein Individuum> ist ein <ein Allgemeinbegriff>“ gebildet werden können, also etwa „Peter ist eine Person“. Mit solchen Sätzen verbindet sich nämlich die Übertragung aller Eigenschaften, die mit einem Allgemeinbegriff verbunden sind (s. o.), auf das Individuum. So hat Peter, wenn er eine Person ist und ""Person"" wie oben definiert wurde, eben auch einen Namen und einen Geburtstag.",Was sind die Eigenschaften einer Klasse?,"Die Eigenschaften einer Klasse ordnen wir den Objekten zu, die dieser Klasse angehören. Zum Beispiel sind mit dem Allgemeinbegriff ""Person"" Eigenschaften wie Name, Geburtstag und möglicherweise weitere Attribute verknüpft, aber auch bestimmtes Verhalten, das für Personen charakteristisch ist. Diese Eigenschaften gehören den individuellen Objekten an, die Teil der Klasse ""Person"" sind."
"Jede Klasse ist mit bestimmten Eigenschaften verbunden, die charakteristisch für sie sind. Diese Eigenschaften ordnen wir jedoch nicht der Klasse selbst zu, sondern den Objekten, die dieser Klasse angehören. Zum Beispiel sind mit dem Allgemeinbegriff ""Person"" Eigenschaften wie Name, Geburtstag und möglicherweise weitere Attribute verknüpft, aber auch bestimmtes, für Personen charakteristisches Verhalten. Dasselbe Prinzip gilt für ""Haus"", ""Dokument"" und alle anderen Allgemeinbegriffe. Existenz und Adäquatheit von Allgemeinbegriffen sind Themen großer philosophischer Diskurse wie etwa dem sog. Universalienstreit und stehen hier nicht zur Debatte. Wichtig ist, dass mit ihnen stets Sätze wie „<ein Individuum> ist ein <ein Allgemeinbegriff>“ gebildet werden können, also etwa „Peter ist eine Person“. Mit solchen Sätzen verbindet sich nämlich die Übertragung aller Eigenschaften, die mit einem Allgemeinbegriff verbunden sind (s. o.), auf das Individuum. So hat Peter, wenn er eine Person ist und ""Person"" wie oben definiert wurde, eben auch einen Namen und einen Geburtstag.",Was ermöglicht die Sprachregelung in der objektorientierten Programmierung bezüglich der Klassennamen?,"Die Sprachregelung in der objektorientierten Programmierung besagt, dass alle Klassennamen im Singular sind. Dies bedeutet, dass jeder Klassenname einen Singularausdruck verwendet, um die Klasse zu benennen, selbst wenn die Klasse eine Menge von Objekten repräsentiert."
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.","Was ist der ""Inhalt"" einer Variable?","Der ""Inhalt"" einer Variable bezieht sich auf das Objekt, das von der Variable bezeichnet wird."
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.",Was ist Verweis- oder Referenzsemantik?,"Bei Verweis- oder Referenzsemantik haben Variablen nur Verweise die Speicherstellen, an denen die Objekte abgelegt sind."
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.",Was ist Wertsemantik?,Bei Wertsemantik macht das bezeichnete Objekt tatsächlich den Inhalt der Variable aus.
"Aus technischer Sicht entspricht eine Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.",Was ist eine Variable aus technischer Sicht?,Aus technischer Sicht entspricht eine Variable einer Stelle im Speicher.
"Aus technischer Sicht entspricht eine Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.",Was sind Variablen mit Verweissemantik?,Es handelt sich bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen.
"Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen, während Verweissemantik erlaubt, dass mehrere Variablen auf dasselbe Objekt verweisen. Da die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. Java); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).",Was unterscheidet Verweissemantik und Wertsemantik bei Variablen?,"Unter Wertsemantik können zwei Variablen niemals dasselbe Objekt bezeichnen, während Verweissemantik erlaubt, dass mehrere Variablen auf dasselbe Objekt verweisen."
"Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen, während Verweissemantik erlaubt, dass mehrere Variablen auf dasselbe Objekt verweisen. Da die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. Java); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).",Warum wird in der objektorientierten Programmierung häufig Verweissemantik verwendet?,"Verweissemantik wird in der objektorientierten Programmierung häufig verwendet, da sie einen speicher- und recheneffizienten Umgang mit Objekten ermöglicht und unterschiedliche Objekte unterschiedlich viel Speicherplatz belegen."
"Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen, während Verweissemantik erlaubt, dass mehrere Variablen auf dasselbe Objekt verweisen. Da die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. Java); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).",Haben Variablen Wert- oder Verweissemantik?,"In manchen Sprachen haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik, z. B. Java. Andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll, z. B. C++ und EIFFEL."
"Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.",Welche Variablen haben in SMALLTALK Wertsemantik?,"In den meisten SMALLTALK-Implementationen haben Variablen, die Zeichen, kleine Zahlen und boolesche Werte bezeichnen, Wertsemantik, um Speicherplatz zu sparen, obwohl der Begriff der Identität für diese Objekte verloren geht. Die mehrfache Existenz identischer Objekte im Speicher hat in der Regel keine große Bedeutung, da Gleichheit an die Stelle der Identität treten kann."
"Einen Typ, dessen Definition alle deklarierten Elemente der Definition eines anderen Typen enthält, nennt man mit dem anderen typkonform. So ist InternationalesBüro im obigen Beispiel mit Büro typkonform. Typkonformität ist in vielen Sprachen eine notwendige und hinreichende Voraussetzung für die Zuweisungskompatibilität: Es darf dann ein Objekt vom Typ InternationalesBüro einer Variable vom Typ Büro zugewiesen werden.","Was bedeutet es, wenn ein Typ mit einem anderen typkonform ist?","Wenn ein Typ mit einem anderen typkonform ist, bedeutet das, dass die Definition dieses Typs alle deklarierten Elemente der Definition des anderen Typs enthält."
"Einen Typ, dessen Definition alle deklarierten Elemente der Definition eines anderen Typen enthält, nennt man mit dem anderen typkonform. So ist InternationalesBüro im obigen Beispiel mit Büro typkonform. Typkonformität ist in vielen Sprachen eine notwendige und hinreichende Voraussetzung für die Zuweisungskompatibilität: Es darf dann ein Objekt vom Typ InternationalesBüro einer Variable vom Typ Büro zugewiesen werden.",Was ist Typkonformität?,"Typkonformität ist eine Beziehung zwischen zwei Typen, bei der die Definition des einen Typs alle deklarierten Elemente der Definition des anderen Typs enthält. In vielen Programmiersprachen ist Typkonformität eine notwendige und hinreichende Voraussetzung für die Zuweisungskompatibilität."
"Typkonformität ist aber reflexiv, d.h., jeder Typ ist konform zu sich selbst. Sie ist weiterhin transitiv: Wenn A typkonform zu B ist und B typkonform zu C, dann ist auch A typkonform zu C. Wie man sich leicht denken kann, ist die Typkonformität jedoch im Gegensatz zur Typäquivalenz nicht symmetrisch: Aus der Tatsache, dass ein Typ B typkonform zu einem Typ A ist, folgt nicht, dass auch A typkonform zu B ist. Vielmehr ist dies mit einer kleinen Ausnahme sogar zwingend nicht der Fall: Typkonformität ist meistens antisymmetrisch, was bedeutet, dass wenn B zu A und A zu B typkonform ist, dann müssen A und B identisch sein.",Was ist Typkonformität?,"Typkonformität ist ein Begriff in der Typentheorie, der angibt, dass ein Typ A zu einem anderen Typ B konform ist, wenn ein Wert vom Typ A in einem Kontext, in dem ein Wert vom Typ B erwartet wird, verwendet werden kann, ohne dass es zu einer Typenverletzung kommt. Typkonformität ist reflexiv und transitiv, aber nicht symmetrisch. Sie ist meistens antisymmetrisch, was bedeutet, dass wenn B zu A und A zu B typkonform ist, dann müssen A und B identisch sein."
"Typkonformität ist aber reflexiv, d.h., jeder Typ ist konform zu sich selbst. Sie ist weiterhin transitiv: Wenn A typkonform zu B ist und B typkonform zu C, dann ist auch A typkonform zu C. Wie man sich leicht denken kann, ist die Typkonformität jedoch im Gegensatz zur Typäquivalenz nicht symmetrisch: Aus der Tatsache, dass ein Typ B typkonform zu einem Typ A ist, folgt nicht, dass auch A typkonform zu B ist. Vielmehr ist dies mit einer kleinen Ausnahme sogar zwingend nicht der Fall: Typkonformität ist meistens antisymmetrisch, was bedeutet, dass wenn B zu A und A zu B typkonform ist, dann müssen A und B identisch sein.",Was bedeutet die Antisymmetrie der Typkonformität?,"Die Antisymmetrie der Typkonformität bedeutet, dass wenn ein Typ B typkonform zu einem Typ A ist und A zu B typkonform ist, dann müssen A und B identisch sein. Das heißt, dass es keine zwei verschiedenen Typen geben kann, die beide typkonform zu einander sind."
"Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.",Was ist strukturelle Typkonformität?,"Strukturelle Typkonformität bedeutet, dass der konforme Typ alle Elemente des Typs, zu dem er konform sein soll, enthält."
"Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.",Was ist namensgebundene Typkonformität?,"Namensgebundene Typkonformität bedeutet, dass der konforme Typ nicht nur die Elemente des Typs, zu dem er konform sein soll, enthält, sondern dass er auch ausdrücklich als konform zu diesem Typ erklärt wurde."
"Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.",Wie wird Typkonformität in der objektorientierten Programmierung gehandhabt?,In der objektorientierten Programmierung wird die Typkonformität in der Regel namensgebunden gehandhabt.
"Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.",Warum ist strukturelle Typkonformität in der objektorientierten Programmierung weniger gebräuchlich?,"Strukturelle Typkonformität ist in der objektorientierten Programmierung weniger gebräuchlich, weil sie die statische Typisierung untergraben würde."
"Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.",Was ist statische Typisierung?,"Statische Typisierung ist eine Eigenschaft von Sprachen, die die"
"Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.",Was ist der Unterschied zwischen struktureller Typkonformität und namensgebundener Typkonformität?,"Strukturelle Typkonformität besteht, wenn der konforme Typ alle Elemente des Typs, zu dem er konform sein soll, enthält. Nominale Typkonformität hingegen bezieht sich auf die Übereinstimmung von Typnamen, unabhängig davon, ob die Typen strukturell identisch sind oder nicht."
"Für die nominale Konformität muss zusätzlich und explizit die Erweiterung eines (oder Ableitung von einem) anderen Typ angegeben werden. Da bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben, folgt die Konformität aus der Erweiterung.",Was bedeutet nominale Konformität?,"Nominale Konformität bedeutet, dass für die Konformität einer Erweiterung nicht nur die Struktur, sondern auch der Name des Typs, der erweitert wird, explizit angegeben werden muss."
"Für die nominale Konformität muss zusätzlich und explizit die Erweiterung eines (oder Ableitung von einem) anderen Typ angegeben werden. Da bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben, folgt die Konformität aus der Erweiterung.",Warum folgt die Konformität aus der Erweiterung?,"Die Konformität folgt aus der Erweiterung, weil bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben."
"Nun ist die Teilmengenbeziehung reflexiv, was auf die Typerweiterung übertragen bedeutet, dass ein Typ eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.","Was bedeutet es, wenn ein Typ reflexiv ist?","Wenn ein Typ reflexiv ist, bedeutet das, dass er eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen."
"Nun ist die Teilmengenbeziehung reflexiv, was auf die Typerweiterung übertragen bedeutet, dass ein Typ eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.","Was bedeutet es, wenn ein Typ eine Erweiterung eines anderen ist, ohne tatsächlich etwas hinzuzufügen?","In diesem Fall spricht man von Typerweiterung, bei der ein Typ eine Untermenge eines anderen Typs ist und somit alle Eigenschaften und Methoden des übergeordneten Typs besitzt, aber keine zusätzlichen Eigenschaften oder Methoden hinzufügt. Dies ist eine reflexive Beziehung, was bedeutet, dass ein Typ auch sich selbst als Untertyp haben kann."
"Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.",Was bedeutet Typäquivalenz?,"Typäquivalenz bedeutet, dass zwei Typen in ihrer nominalen oder strukturellen Form übereinstimmen und somit Typkonformität implizieren, also austauschbar sind."
"Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.",Was ist der Unterschied zwischen nominaler und struktureller Typäquivalenz?,"Nominale Typäquivalenz bezieht sich auf die Übereinstimmung von Typnamen, während strukturelle Typäquivalenz die Übereinstimmung der Typstruktur betrifft."
"Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.",Was bedeutet Typkonformität?,"Typkonformität bedeutet, dass ein Typ mit einem anderen kompatibel ist und somit als Argument für eine Funktion oder Methode verwendet werden kann, die den anderen Typ erwartet."
"Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.",Ist Typäquivalenz gleichbedeutend mit Typkonformität?,"Nein, Typäquivalenz impliziert Typkonformität, aber nicht umgekehrt. Zwei äquivalente Typen sind auch immer konform, aber ein konformer Typ ist nicht unbedingt äquivalent zu einem anderen Typ."
"Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.",Was bedeutet Typäquivalenz?,"Typäquivalenz ist ein Begriff in der Typentheorie, der angibt, dass zwei Typen gleichwertig sind. Es gibt zwei Formen von Typäquivalenz: nominale und strukturelle. Nominale Typäquivalenz bedeutet, dass zwei Typen den gleichen Namen haben, während strukturelle Typäquivalenz bedeutet, dass zwei Typen die gleiche Struktur haben, unabhängig von ihrem Namen. Typäquivalenz impliziert Typkonformität, d.h. zwei äquivalente Typen sind auch immer konform."
"Genau wie bei der Typäquivalenz hat die nominale Typkonformität zusätzlich zur Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von Typfehlern (die ja auch bei einer strukturellen Typkonformität schon gegeben wäre) eine Filterfunktion: Es sind nur Objekte von solchen Typen Variablen zuweisbar, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorgesehen hat. Auf diese Filterfunktion werden wir später im Zusammenhang mit sogenannten Tagging oder Marker Interfaces (in Kurseinheit 4, Kapitel 45) noch zurückkommen.",Was ist die Filterfunktion der nominalen Typkonformität?,"Die nominale Typkonformität hat neben der Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von Typfehlern eine Filterfunktion. Diese Filterfunktion ermöglicht es, dass nur Objekte von solchen Typen Variablen zugewiesen werden können, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich vorgesehen hat."
"Genau wie bei der Typäquivalenz hat die nominale Typkonformität zusätzlich zur Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von Typfehlern (die ja auch bei einer strukturellen Typkonformität schon gegeben wäre) eine Filterfunktion: Es sind nur Objekte von solchen Typen Variablen zuweisbar, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorgesehen hat. Auf diese Filterfunktion werden wir später im Zusammenhang mit sogenannten Tagging oder Marker Interfaces (in Kurseinheit 4, Kapitel 45) noch zurückkommen.",Was ist die Filterfunktion der nominalen Typkonformität?,"Die Filterfunktion der nominalen Typkonformität besteht darin, dass nur Objekte von solchen Typen Variablen zugewiesen werden können, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorgesehen hat."
"Da die Typkonformität bei Nennung des Typs, von dem ein neuer per Erweiterung abgeleitet wird, automatisch gegeben ist (und so keine aufwendigen, fallweisen Konformitätstests durchgeführt werden müssen), setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität. Interessanterweise wurde STRONGTALK, das ursprünglich ein auf struktureller Konformität beruhendes Typsystem (inkl. Type branding) hatte, inzwischen auf nominale Typkonformität umgestellt. Als Begründung wurde angeführt, dass ein strukturelles Typsystem, insbesondere eines, bei dem Typen nicht explizit benannt werden, es der Programmiererin nicht erlaubt, ihre Absicht (intendierte Semantik, die obengenannte Filterfunktion) auszudrücken, was Programme schwerer zu lesen und zu debuggen macht, und dass die Fehlermeldungen, die eine strukturelle Typprüfung produziert, sich oft nicht auf die eigentliche Fehlerquelle beziehen und sehr schwer zu verstehen sind [STRONGTALK 2.0].",Was ist der Unterschied zwischen nominaler und struktureller Typkonformität?,"Nominale Typkonformität ist eine Bedingung für die Zuweisungskompatibilität, bei der die Typkonformität gegeben ist, wenn der Typ namentlich angegeben wird. Strukturelle Typkonformität ist dagegen gegeben, wenn die Struktur des Typs übereinstimmt, unabhängig davon, wie er benannt ist. STRONGTALK hat ursprünglich ein strukturelles Typsystem verwendet, das später durch ein nominales Typsystem ersetzt wurde, da die strukturelle Typprüfung es schwieriger macht, die Absicht der Programmiererin auszudrücken und Fehlermeldungen sind oft schwer zu verstehen."
"Da die Typkonformität bei Nennung des Typs, von dem ein neuer per Erweiterung abgeleitet wird, automatisch gegeben ist (und so keine aufwendigen, fallweisen Konformitätstests durchgeführt werden müssen), setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität. Interessanterweise wurde STRONGTALK, das ursprünglich ein auf struktureller Konformität beruhendes Typsystem (inkl. Type branding) hatte, inzwischen auf nominale Typkonformität umgestellt. Als Begründung wurde angeführt, dass ein strukturelles Typsystem, insbesondere eines, bei dem Typen nicht explizit benannt werden, es der Programmiererin nicht erlaubt, ihre Absicht (intendierte Semantik, die obengenannte Filterfunktion) auszudrücken, was Programme schwerer zu lesen und zu debuggen macht, und dass die Fehlermeldungen, die eine strukturelle Typprüfung produziert, sich oft nicht auf die eigentliche Fehlerquelle beziehen und sehr schwer zu verstehen sind [STRONGTALK 2.0].",Was ist der Unterschied zwischen nominaler und struktureller Typkonformität?,"Nominale Typkonformität bezieht sich auf die Übereinstimmung der Typnamen, während strukturelle Typkonformität die Übereinstimmung der Typstruktur betrifft. In anderen Worten, bei nominaler Typkonformität muss der Typ explizit benannt werden, während bei struktureller Typkonformität die Übereinstimmung der Typstruktur ausreicht."
"Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.",Was sind Zuweisungskompatibilität unter Typerweiterung und Funktionsaufrufe?,"Zuweisungskompatibilität unter Typerweiterung bezieht sich auf die Möglichkeit, Werte verschiedener Typen einander zuzuweisen, wenn der Zieltyp eine Erweiterung des Quelltyps ist. Funktionsaufrufe sind Anweisungen, die eine Funktion mit bestimmten Argumenten aufrufen. Wenn eine Funktion aufgerufen wird, werden implizite Zuweisungen durchgeführt, bei denen die Typen der Argumente mit den Parametern der Funktion kompatibel sein müssen. Diese Zuweisungskompatibilität spielt auch bei Funktionsaufrufen eine wichtige Rolle."
"Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.",Was sind Zuweisungskompatibilität unter Typerweiterung und wann spielen sie eine wichtige Rolle?,"Zuweisungskompatibilität unter Typerweiterung bezieht sich auf die Möglichkeit, Werte von Variablen mit einem bestimmten Typ einer Variablen mit einem erweiterten Typ zuzuweisen. Sie spielen eine wichtige Rolle bei Funktionsaufrufen, bei denen implizite Zuweisungen auftreten, wie in Abschnitt 4.3.2 beschrieben."
"Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.",Was sind implizite Zuweisungen?,"Implizite Zuweisungen treten bei Funktionsaufrufen auf, bei denen die Funktion eine Kopie des Objekts erhält, auf das die Funktionsargument-Variable verweist."
"Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.",Was sind Funktionsaufrufe?,"Funktionsaufrufe sind Anweisungen, die eine Funktion aufrufen und deren Ergebnis berechnen. Sie werden verwendet, um Werte zu berechnen, Objekte zu manipulieren oder die Kontrolle in einem Programm zu übertragen."
"Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.",Was ist Typerweiterung?,"Typerweiterung ist ein Konzept in der objektorientierten Programmierung, bei dem eine Unterklasse eine Oberklasse erweitert, indem sie neue Attribute und Methoden hinzufügt oder bestehende Methoden überschreibt."
"Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.",Was sind Zuweisungskompatibilität?,"Zuweisungskompatibilität bezieht sich darauf, ob ein Wert einer Variablen zugewiesen werden kann, ohne dass eine Kompatibilitätsprüfung fehlschlägt. In der objektorientierten Programmierung ist dies oft abhängig von der Typhierarchie und der Zuweisungskompatibilität von Unter- und Oberklassen."
"Genau wie unparametrisierte (nicht generische) Typen in Java nicht aus eigenständigen Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces einhergehen, so werden auch parametrische (generische) Typen nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Da aber die formalen Typparameter einer Klassen- bzw. Interfacedefinition durch verschiedene Typen ersetzt werden können, wird die alte 1-zu-1-Beziehung zwischen Klassen und Typen aufgebrochen: Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbesondere führt die „Instanziierung“68 einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Deswegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen den Typparameter als Typ verwenden und sich insofern unterscheiden.",Wie werden parametrische Typen definiert?,"Parametrische Typen werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Die Instanziierung einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter führt nur zu einem neuen Typ, aber nicht zu einer neuen Klasse."
"Genau wie unparametrisierte (nicht generische) Typen in Java nicht aus eigenständigen Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces einhergehen, so werden auch parametrische (generische) Typen nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Da aber die formalen Typparameter einer Klassen- bzw. Interfacedefinition durch verschiedene Typen ersetzt werden können, wird die alte 1-zu-1-Beziehung zwischen Klassen und Typen aufgebrochen: Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbesondere führt die „Instanziierung“68 einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Deswegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen den Typparameter als Typ verwenden und sich insofern unterscheiden.",Was ist der Unterschied zwischen parametrischen und unparametrischen Typen in Java?,"Unparametrisierte Typen in Java werden nicht aus eigenständigen Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces einhergehen. Parametrische Typen hingegen werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbesondere führt die „Instanziierung“ einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Deswegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen den Typparameter als Typ verwenden und sich insofern unterscheiden."
"Die klassische Anwendung generischer Typen findet man bei Collections: Genauso, wie man in Java Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt Java ähnlich wie SMALLTALK über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die Java-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition Javas, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen. Da es vor Java 5 keine Möglichkeit gab, bei der Deklaration einer Variable mit einer Collection als Typ anzugeben, welchen Typ die Elemente der Collection haben sollen, wurde implizit davon ausgegangen, dass diese vom Typ Object sind. So hatte z. B. die Klasse ArrayList ein (privates) Feld elementData vom Typ Object[], in dem die Elemente gespeichert wurden. Da Object der Supertyp aller Referenztypen in Java ist, konnten auch Instanzen aller Referenztypen in elementData und somit in Instanzen von ArrayList gespeichert werden.",Was ist der Supertyp aller Referenztypen in Java?,Object ist der Supertyp aller Referenztypen in Java.
"Die klassische Anwendung generischer Typen findet man bei Collections: Genauso, wie man in Java Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt Java ähnlich wie SMALLTALK über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die Java-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition Javas, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen. Da es vor Java 5 keine Möglichkeit gab, bei der Deklaration einer Variable mit einer Collection als Typ anzugeben, welchen Typ die Elemente der Collection haben sollen, wurde implizit davon ausgegangen, dass diese vom Typ Object sind. So hatte z. B. die Klasse ArrayList ein (privates) Feld elementData vom Typ Object[], in dem die Elemente gespeichert wurden. Da Object der Supertyp aller Referenztypen in Java ist, konnten auch Instanzen aller Referenztypen in elementData und somit in Instanzen von ArrayList gespeichert werden.",Was sind die klassischen Anwendungsfälle generischer Typen?,"Die klassische Anwendung generischer Typen findet man bei Collections. Genauso, wie man in Java Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt Java über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die Java-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition Javas, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen."
"Die klassische Anwendung generischer Typen findet man bei Collections: Genauso, wie man in Java Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt Java ähnlich wie SMALLTALK über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die Java-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition Javas, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen. Da es vor Java 5 keine Möglichkeit gab, bei der Deklaration einer Variable mit einer Collection als Typ anzugeben, welchen Typ die Elemente der Collection haben sollen, wurde implizit davon ausgegangen, dass diese vom Typ Object sind. So hatte z. B. die Klasse ArrayList ein (privates) Feld elementData vom Typ Object[], in dem die Elemente gespeichert wurden. Da Object der Supertyp aller Referenztypen in Java ist, konnten auch Instanzen aller Referenztypen in elementData und somit in Instanzen von ArrayList gespeichert werden.",Warum können in Java Arrays über einen bestimmten Elementtyp gebildet werden?,"In Java können Arrays über einen bestimmten Elementtyp gebildet werden, weil es in Java eine Sprachdefinition für Arrays gibt, die eine solche Möglichkeit vorsieht. Dies ermöglicht eine bessere Typsicherheit und Effizienz, da die Elemente eines Arrays alle vom gleichen Typ sind und somit keine Typumwandlung bei der Zuweisung oder beim Zugriff notwendig ist."
"Dank der generischen Typen ist es aber möglich, bei der Deklaration einer Variable vom Typ einer Collection — in Analogie zur Deklaration einer Variable vom Typ eines Arrays über einen Elementtyp — den Elementtyp mit anzugeben. Um beispielsweise eine Liste von Integern zu deklarieren und zu initialisieren, muss man lediglich List<Integer> liste = new ArrayList<>(); schreiben.",Was ist der Zweck der generischen Typen bei der Deklaration einer Variablen?,"Dank der generischen Typen ist es möglich, bei der Deklaration einer Variablen vom Typ einer Collection den Elementtyp mit anzugeben. Dadurch wird eine Liste von Integern beispielsweise durch List<Integer> liste = new ArrayList<>(); deklariert und initialisiert."
"Dank der generischen Typen ist es aber möglich, bei der Deklaration einer Variable vom Typ einer Collection — in Analogie zur Deklaration einer Variable vom Typ eines Arrays über einen Elementtyp — den Elementtyp mit anzugeben. Um beispielsweise eine Liste von Integern zu deklarieren und zu initialisieren, muss man lediglich List<Integer> liste = new ArrayList<>(); schreiben.",Was ist der Vorteil von generischen Typen?,"Der Vorteil von generischen Typen ist, dass sie es ermöglichen, bei der Deklaration einer Variablen den Elementtyp mit anzugeben, was die Typsicherheit erhöht und die Notwendigkeit von expliziten Typumwandlungen verringert."
"Dabei ist das in spitzen Klammern stehende E der (formale) Typparameter der Definition von ArrayList. Die bereits in Abschnitt 29.1 erwähnte Konvention, einzelne Großbuchstaben für Typparameter zu wählen, wurde auch in Java übernommen, ganz einfach, um Typparameter von Klassen- und Variablennamen im Programmtext besser unterscheiden zu können. So steht E üblicherweise für den Elementtyp von Containern, wie es die Collections sind. Durch die Sprachdefinition erzwungen wird das jedoch nicht.",Was bedeuten spitze Klammern in Java?,"Spitze Klammern < > werden in Java verwendet, um Typparameter in generischen Klassen oder Methoden zu definieren. Sie werden auch als Diamant-Operator bezeichnet."
"Die Zuweisung von Zeile 1051 ist übrigens nur gültig, wenn der (parametrisierte) Typ ArrayList<Integer> Subtyp von List<Integer> ist. Dies wird, in Java-Syntax, durch die Deklaration List<Integer> liste; (nominales Subtyping) sichergestellt. Man beachte, dass die Variable E hier eine logische Bedingung ausdrückt, nämlich die, dass ein bei der Verwendung von ArrayList<E> angegebener tatsächlicher Typparameter auch in die Definition von List<E> eingesetzt werden muss.",Was bedeutet nominales Subtyping?,"Nominales Subtyping bedeutet, dass eine Variable eines bestimmten Typs auch einem Untertyp dieses Typs zugewiesen werden kann. In Java-Syntax wird dies durch die Deklaration List<Integer> liste; sichergestellt, wodurch die Variable liste auch mit einem ArrayList<Integer>-Objekt initialisiert werden kann."
"Der Compiler weiß nun aufgrund der Ersetzung des formalen Parameters E mit dem tatsächlichen Parameter Integer in Zeile 1051, dass die Elemente der Variable liste alle vom Typ Integer sind und dass eine Zuweisung der Form get(0) = 42; typkorrekt ist. Um das zu überprüfen, muss er nämlich nur den Wert des Typparameters in der Deklaration von liste, Integer, in die Variable E der Implementierung von get einsetzen. Er kann dann feststellen, dass der Rückgabetyp des Ausdrucks mit der Variable zuweisungskompatibel ist. Man beachte, dass ohne Typparameter in Zeile 1064 eine Typumwandlung von Object auf Integer (Downcast) notwendig wäre, die aber zu einem Laufzeitfehler führen kann. Die Einführung von Generics erhöht hingegen die Typsicherheit statisch, also zur Übersetzungszeit, ein fundamentaler Gewinn.",Was ist der Zweck von Typparametern in Programmierung?,"Typparameter werden in Programmierung eingesetzt, um die Typsicherheit zu erhöhen und die Überprüfung der Typkompatibilität zur Übersetzungszeit durchzuführen. Ohne Typparameter müsste eine Typumwandlung zur Laufzeit erfolgen, was zu Laufzeitfehlern führen kann."
"Der Compiler weiß nun aufgrund der Ersetzung des formalen Parameters E mit dem tatsächlichen Parameter Integer in Zeile 1051, dass die Elemente der Variable liste alle vom Typ Integer sind und dass eine Zuweisung der Form get(0) = 42; typkorrekt ist. Um das zu überprüfen, muss er nämlich nur den Wert des Typparameters in der Deklaration von liste, Integer, in die Variable E der Implementierung von get einsetzen. Er kann dann feststellen, dass der Rückgabetyp des Ausdrucks mit der Variable zuweisungskompatibel ist. Man beachte, dass ohne Typparameter in Zeile 1064 eine Typumwandlung von Object auf Integer (Downcast) notwendig wäre, die aber zu einem Laufzeitfehler führen kann. Die Einführung von Generics erhöht hingegen die Typsicherheit statisch, also zur Übersetzungszeit, ein fundamentaler Gewinn.",Was ist der Zweck von Typparametern in Generics?,"Typparameter in Generics erhöhen die Typsicherheit statisch, also zur Übersetzungszeit, was einen fundamentalen Gewinn darstellt. Ohne Typparameter müsste eine Typumwandlung von Object auf Integer (Downcast) durchgeführt werden, was zu einem Laufzeitfehler führen kann."
"Der Compiler weiß nun aufgrund der Ersetzung des formalen Parameters E mit dem tatsächlichen Parameter Integer in Zeile 1051, dass die Elemente der Variable liste alle vom Typ Integer sind und dass eine Zuweisung der Form get(0) = 42; typkorrekt ist. Um das zu überprüfen, muss er nämlich nur den Wert des Typparameters in der Deklaration von liste, Integer, in die Variable E der Implementierung von get einsetzen. Er kann dann feststellen, dass der Rückgabetyp des Ausdrucks mit der Variable zuweisungskompatibel ist. Man beachte, dass ohne Typparameter in Zeile 1064 eine Typumwandlung von Object auf Integer (Downcast) notwendig wäre, die aber zu einem Laufzeitfehler führen kann. Die Einführung von Generics erhöht hingegen die Typsicherheit statisch, also zur Übersetzungszeit, ein fundamentaler Gewinn.",Was ist der Zweck der Verwendung von Generics in Java?,"Der Zweck der Verwendung von Generics in Java ist es, die Typsicherheit statisch, also zur Übersetzungszeit, zu erhöhen und die Notwendigkeit von Typumwandlungen (Downcast) zu verringern, die zu Laufzeitfehlern führen können."
"Nun wissen Sie ja bereits aus der Schilderung aus Kapitel 41, dass List<Integer> nicht unbedingt ein Subtyp von List<Object> sein sollte, selbst wenn Integer ein Subtyp von Object ist. Man hat den oben diskutierten Kompromiss offenbar nicht weiter fortführen wollen.",Warum sollte List<Integer> nicht unbedingt ein Subtyp von List<Object> sein?,"Der Kompromiss, dass List<Integer> ein Subtyp von List<Object> sein sollte, wurde offenbar nicht weiter fortgeführt, weil Integer ein Subtyp von Object ist. Das liegt daran, dass dies zu inkonsistenten Typzuweisungen führen könnte, was die Typsicherheit des Programms beeinträchtigen würde."
"Es stellt sich nun die Frage, wann ein Typ mit einem anderen zuweisungskompatibel ist. Offensichtlich ist dies der Fall, wenn die Typen identisch sind. Wie bereits oben erwähnt, ist dies jedoch keine notwendige Voraussetzung für die Zuweisungskompatibilität. Es ist nämlich auch möglich, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind. Man spricht in diesen Fällen von einer Typäquivalenz.",Was ist Typäquivalenz?,"Typäquivalenz bedeutet, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind."
"Es stellt sich nun die Frage, wann ein Typ mit einem anderen zuweisungskompatibel ist. Offensichtlich ist dies der Fall, wenn die Typen identisch sind. Wie bereits oben erwähnt, ist dies jedoch keine notwendige Voraussetzung für die Zuweisungskompatibilität. Es ist nämlich auch möglich, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind. Man spricht in diesen Fällen von einer Typäquivalenz.",Wann sind zwei Typen zuweisungskompatibel?,"Zwei Typen sind zuweisungskompatibel, wenn sie identisch sind oder wenn sie eine Typäquivalenz aufweisen, d.h. wenn sie bis auf ihre Namen gleich sind."
"Es stellt sich nun die Frage, wann ein Typ mit einem anderen zuweisungskompatibel ist. Offensichtlich ist dies der Fall, wenn die Typen identisch sind. Wie bereits oben erwähnt, ist dies jedoch keine notwendige Voraussetzung für die Zuweisungskompatibilität. Es ist nämlich auch möglich, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind. Man spricht in diesen Fällen von einer Typäquivalenz.",Was ist die Voraussetzung für die Zuweisungskompatibilität von zwei Typen?,"Die Voraussetzung für die Zuweisungskompatibilität von zwei Typen ist, dass sie identisch sind oder eine Typäquivalenz aufweisen, d.h. sich die Typdefinitionen bis auf ihre Namen gleichen."
"Von der Typäquivalenz gibt es zwei Arten: die nominale (sich auf den Namen beziehende) Typäquivalenz, auch Namensäquivalenz genannt, und die strukturelle Typäquivalenz, auch als Strukturäquivalenz bezeichnet. Während die nominale Typäquivalenz verlangt, dass zwei Deklarationen (beispielsweise von Variablen) dieselben Typen angeben, damit Zuweisungskompatibilität vorliegt, kommt es bei der strukturellen Typäquivalenz lediglich darauf an, dass die Typen paarweise gleich definiert sind (also die gleichen Eigenschaften von ihren Werten verlangen). Die Typen müssen sich also in ihrer Struktur, aber nicht unbedingt in ihren Namen gleichen.",Was ist der Unterschied zwischen nominaler und struktureller Typäquivalenz?,"Nominale Typäquivalenz bezieht sich auf den Namen von Typen, während strukturelle Typäquivalenz auf die Struktur von Typen abzielt. Bei nominaler Typäquivalenz müssen zwei Deklarationen denselben Typnamen haben, während bei struktureller Typäquivalenz die Typen paarweise gleich definiert sein müssen, d.h. sie müssen die gleichen Eigenschaften von ihren Werten verlangen."
"Typäquivalenz ist eine symmetrische Eigenschaft: Wenn ein Typ A (nominal oder strukturell) äquivalent zu einem Typ B ist, dann ist B genauso äquivalent zu A. Die Reflexivität der Typäquivalenz, also dass jeder Typ äquivalent zu sich selbst ist, ergibt sich von selbst. Außerdem ist Typäquivalenz transitiv: Wenn A (nominal oder strukturell) äquivalent zu B ist und B in der gleichen Art äquivalent zu C ist, dann ist auch A äquivalent zu C (und, aufgrund der Symmetrie, C äquivalent zu A).",Was ist Typäquivalenz?,"Typäquivalenz ist eine Eigenschaft, die angibt, ob zwei Typen gleichwertig sind. Sie ist symmetrisch, reflexiv und transitiv. Das bedeutet, dass wenn Typ A äquivalent zu Typ B ist, dann ist auch Typ B äquivalent zu Typ A, Typ A äquivalent zu sich selbst und wenn Typ A äquivalent zu Typ B und Typ B äquivalent zu Typ C, dann ist auch Typ A äquivalent zu Typ C."
"Typäquivalenz ist eine symmetrische Eigenschaft: Wenn ein Typ A (nominal oder strukturell) äquivalent zu einem Typ B ist, dann ist B genauso äquivalent zu A. Die Reflexivität der Typäquivalenz, also dass jeder Typ äquivalent zu sich selbst ist, ergibt sich von selbst. Außerdem ist Typäquivalenz transitiv: Wenn A (nominal oder strukturell) äquivalent zu B ist und B in der gleichen Art äquivalent zu C ist, dann ist auch A äquivalent zu C (und, aufgrund der Symmetrie, C äquivalent zu A).",Was ist Typäquivalenz und welche Eigenschaften hat sie?,"Typäquivalenz ist eine Eigenschaft, die angibt, ob zwei Typen gleichwertig sind. Sie ist symmetrisch, reflexiv und transitiv. Das bedeutet, wenn Typ A äquivalent zu Typ B ist, dann ist auch B äquivalent zu A, jeder Typ ist äquivalent zu sich selbst und wenn A äquivalent zu B ist und B äquivalent zu C, dann ist auch A äquivalent zu C."
"Typäquivalenz ist eine symmetrische Eigenschaft: Wenn ein Typ A (nominal oder strukturell) äquivalent zu einem Typ B ist, dann ist B genauso äquivalent zu A. Die Reflexivität der Typäquivalenz, also dass jeder Typ äquivalent zu sich selbst ist, ergibt sich von selbst. Außerdem ist Typäquivalenz transitiv: Wenn A (nominal oder strukturell) äquivalent zu B ist und B in der gleichen Art äquivalent zu C ist, dann ist auch A äquivalent zu C (und, aufgrund der Symmetrie, C äquivalent zu A).",Was ist die Transitivität der Typäquivalenz?,"Die Transitivität der Typäquivalenz bedeutet, dass wenn ein Typ A äquivalent zu einem Typ B ist und Typ B wiederum äquivalent zu einem Typ C ist, dann ist auch Typ A äquivalent zu Typ C. Diese Eigenschaft ist wichtig, um sicherzustellen, dass die Typäquivalenz konsistent ist und dass die Typisierung von Ausdrücken und Variablen in einem Programm konsistent bleibt."
"Wenn Ihnen das noch nicht kompliziert genug ist, geht es noch weiter: Tatsächlich würde auch ""Comparable"" selbst von einer Parametrisierung profitieren. In einem ersten Ansatz würde man verlangen, dass von zwei vergleichbaren Elementen beide vom gleichen Typ sein müssen. Bei genauerer Betrachtung stellt sich jedoch heraus, dass die Bedingung, dass die zu vergleichenden Elemente für eine Sortierung alle vom selben Typ sein müssen, zu restriktiv ist. Vielmehr würde es ausreichen, wenn die Objekte der sortierten Liste unter anderem mit Objekten desselben Typs vergleichbar wären – sie könnten auch mit Objekten von noch mehr Typen vergleichbar sein. Die Bedingung muss also lauten, dass der Parametertyp von ""Comparable"" mindestens ""E"" umfassen muss. Er kann jedoch auch allgemeiner sein, z. B. ""Object"" (für einen Vergleich beliebiger Objekte, wie auch immer dieser durchgeführt werden soll). Im gegebenen Fall muss es sich bei dem für das Wildcard einzusetzenden Typ um einen (direkten oder indirekten) Supertypen von ""E"" handeln (wobei ""E"" ja selbst eine Typvariable ist, die erst bei einer Variablendeklaration an einen konkreten Typ gebunden wird).","Was bedeutet es, wenn der Parametertyp von ""Comparable"" mindestens ""E"" umfassen muss?","Das bedeutet, dass die Objekte der sortierten Liste mit Objekten vom Typ ""E"" oder mit Objekten eines Supertyps von ""E"" vergleichbar sein müssen."
"Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Bei der Behandlung von Java sind wir bereits auf die Assert-Anweisung gestoßen, die es erlaubte, Zusicherungen zur Laufzeit auszuwerten und das Programm bei einer Verletzung ggf. abzubrechen. Da es sich jedoch um eine Anweisung handelte, gab es keine von der Sprachdefinition vorgesehenen Orte, an denen solche Zusicherungen auftreten sollten — ihre Platzierung lag ganz im Ermessen der Programmiererin. In EIFFEL ist dies anders.",Wie werden Zusicherungen in EIFFEL behandelt?,"In EIFFEL werden Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen integriert. Das bedeutet, dass die Zusicherungen an bestimmten Stellen in der Sprache vorgesehen sind und nicht willkürlich platziert werden können."
"Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Bei der Behandlung von Java sind wir bereits auf die Assert-Anweisung gestoßen, die es erlaubte, Zusicherungen zur Laufzeit auszuwerten und das Programm bei einer Verletzung ggf. abzubrechen. Da es sich jedoch um eine Anweisung handelte, gab es keine von der Sprachdefinition vorgesehenen Orte, an denen solche Zusicherungen auftreten sollten — ihre Platzierung lag ganz im Ermessen der Programmiererin. In EIFFEL ist dies anders.",Was ist eine Besonderheit von EIFFEL in Bezug auf Zusicherungen?,"In EIFFEL sind Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen integriert. Das bedeutet, dass es für Zusicherungen vorgesehene Orte gibt und sie nicht ganz im Ermessen der Programmiererin liegen."
"Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Bei der Behandlung von Java sind wir bereits auf die Assert-Anweisung gestoßen, die es erlaubte, Zusicherungen zur Laufzeit auszuwerten und das Programm bei einer Verletzung ggf. abzubrechen. Da es sich jedoch um eine Anweisung handelte, gab es keine von der Sprachdefinition vorgesehenen Orte, an denen solche Zusicherungen auftreten sollten — ihre Platzierung lag ganz im Ermessen der Programmiererin. In EIFFEL ist dies anders.",Was ist der Unterschied zwischen der Verwendung von Zusicherungen in EIFFEL und Java?,"In EIFFEL sind Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen integriert, während in Java die Assert-Anweisung verwendet wird, die es erlaubt, Zusicherungen zur Laufzeit auszuwerten, aber keine von der Sprachdefinition vorgesehenen Orte für ihre Platzierung gibt."
"Die Syntax zur Definition einer Methode in EIFFEL sieht zwei Schlüsselwörter vor, ""require"" und ""ensure"", von denen das erste vor der Implementierung der Methode (dem Methodenrumpf) und das zweite danach auftreten kann. Beiden Schlüsselwörtern folgen Boolesche Ausdrücke, die alle zu ""wahr"" ausgewertet werden müssen. Die Idee hinter einer ""Require""-Klausel ist, dass die darin ausgedrückten Bedingungen erfüllt sein müssen, damit die betreffende Methode ordnungsgemäß funktionieren kann. Zum Beispiel macht es Sinn, für die Methode ""pop"" in der Klasse ""STACK"" zu verlangen, dass der Stapel, auf dem die Methode aufgerufen wird, nicht leer ist. Die Idee hinter einer ""Ensure""-Klausel ist, dass eine Methode, deren ""Require""-Klausel erfüllt war, im Gegenzug garantieren muss, dass die in der ""Ensure""-Klausel ausgedrückten Bedingungen erfüllt sind. Im Fall des Stacks bedeutet das beispielsweise, dass nach einem ""push"" das übergebene Element tatsächlich oben auf dem Stapel liegt, sodass die Methode ""top"" beispielsweise das soeben auf den Stapel gelegte Element zurückgeben kann. Um ihre Bedingungen zu formulieren, dürfen die Ausdrücke in beiden Klauseln auf Abfragen (queries) der Klasse zurückgreifen. Diese sollten jedoch tunlichst nebenwirkungsfrei sein, zum einen, weil die ""Ensure""-Klausel sonst nicht garantieren kann, dass eine geprüfte Bedingung auch nach ihrer vollständigen Auswertung immer noch wahr ist (man stelle sich vor, was passieren würde, wenn die ""Ensure""-Klausel in ""push"" die Methode ""pop"" aufrufen würde!), zum anderen, weil in EIFFEL (wie in Java) die Überprüfung der Zusicherungen zur Laufzeit deaktiviert werden kann (wodurch das Programm bei Überprüfung der Zusicherungen eine andere Semantik hätte als ohne; vergleiche die Anmerkungen zur Assert-Anweisung in Java in Kurseinheit 4, Kapitel 38).","Was ist die Funktion von ""require"" und ""ensure"" in EIFFEL?","""Require"" und ""ensure"" sind Schlüsselwörter in EIFFEL, die Boolesche Ausdrücke folgen. ""Require""-Klauseln sollten erfüllt sein, damit die Methode korrekt funktioniert, während ""Ensure""-Klauseln garantieren, dass die Methode bestimmte Bedingungen erfüllt. Beide Klauseln dürfen nebenwirkungsfreie Abfragen der Klasse verwenden."
"Neben der Möglichkeit, Vor- und Nachbedingungen zu formulieren, gibt es in EIFFEL auch die Möglichkeit, sog. Klasseninvarianten (Schlüsselwort ""invariant"") zu deklarieren. Klasseninvarianten müssen jederzeit zwischen zwei Methodenaufrufen gelten; man kann sich vorstellen, dass sie jeder Vor- und Nachbedingung per Konjunktion hinzugefügt werden. Auf die etwas subtilen Probleme, die das Aliasing in Zusammenhang mit Zusicherungen schafft, wollen wir an dieser Stelle nicht eingehen; dies wird ausführlicher in Kurs 01853 behandelt.",Was sind Klasseninvarianten in EIFFEL?,"Klasseninvarianten sind in EIFFEL eine Möglichkeit, Zusicherungen zu formulieren, die zwischen zwei Methodenaufrufen gelten müssen. Sie werden mit dem Schlüsselwort ""invariant"" deklariert und können sich vorstellen, dass sie jeder Vor- und Nachbedingung per Konjunktion hinzugefügt werden."
"Zusicherungen werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen auch Vor- und Nachbedingungen angepasst werden. Allerdings gilt hierbei, dass die Vorbedingung nur abgeschwächt und die Nachbedingung nur verschärft werden darf. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.",Was ist der Zusammenhang zwischen Zusicherungen und Methoden in EIFFEL?,"In EIFFEL werden Zusicherungen wie Vor- und Nachbedingungen von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen auch die Zusicherungen angepasst werden, allerdings gilt hierbei, dass die Vorbedingung nur abgeschwächt und die Nachbedingung nur verschärft werden darf. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird."
"Zusicherungen werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen auch Vor- und Nachbedingungen angepasst werden. Allerdings gilt hierbei, dass die Vorbedingung nur abgeschwächt und die Nachbedingung nur verschärft werden darf. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.",Was passiert mit Zusicherungen (Vor- und Nachbedingungen) bei der Redefinition einer Methode in EIFFEL?,"Bei der Redefinition einer Methode in EIFFEL dürfen die Vorbedingungen nur abgeschwächt und die Nachbedingungen nur verschärft werden. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird."
"Zusicherungen werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen auch Vor- und Nachbedingungen angepasst werden. Allerdings gilt hierbei, dass die Vorbedingung nur abgeschwächt und die Nachbedingung nur verschärft werden darf. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.",Was ist der Unterschied zwischen Vor- und Nachbedingungen in EIFFEL?,"In EIFFEL sind Vorbedingungen (preconditions) Bedingungen, die vor der Ausführung einer Methode erfüllt sein müssen, während Nachbedingungen (postconditions) Bedingungen sind, die nach der Ausführung einer Methode erfüllt sein müssen. Vorbedingungen werden verwendet, um sicherzustellen, dass die Methode nur dann aufgerufen wird, wenn die Voraussetzungen erfüllt sind, während Nachbedingungen sicherstellen, dass die Methode das gewünschte Ergebnis liefert."
"EIFFEL nimmt unter den hier behandelten Sprachen eine Sonderstellung ein. Es soll nämlich mehrere Dinge auf einmal sein: eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache.",Was ist die Sprache EIFFEL?,"EIFFEL ist eine Sprache, die für objektorientierte Analyse und Design, kommerzielle Programmierung und akademische Lehre verwendet wird."
"EIFFEL nimmt unter den hier behandelten Sprachen eine Sonderstellung ein. Es soll nämlich mehrere Dinge auf einmal sein: eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache.",Was ist die Sonderstellung von EIFFEL unter den hier behandelten Sprachen?,"EIFFEL ist eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache."
"Das herausragende Merkmal, das EIFFEL zu dieser Multifunktion qualifiziert, ist die Integration von Zusicherungen (die Formulierung von Vorbedingungen, Nachbedingungen und Klasseninvarianten), die als Verträge zwischen dienstanbietenden und dienstnehmenden Klassen interpretiert werden können. Dies erlaubt, das ""Was"" einer Software zumindest teilweise unabhängig vom ""Wie"" zu spezifizieren. Die Typsysteme, die Sie in den vorangegangenen Kapiteln kennengelernt haben und von denen auch EIFFEL eines besitzt, erlauben zwar auch schon, Zusicherungen auszudrücken, aber diese beziehen sich jeweils auf die möglichen Werte einer Variable und bleiben dabei sowohl voneinander als auch von der Zeit unabhängig. EIFFEL erlaubt darüber hinaus, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können.",Was ist die Besonderheit von EIFFEL?,"Die Besonderheit von EIFFEL ist die Integration von Zusicherungen, die als Verträge zwischen dienstanbietenden und dienstnehmenden Klassen interpretiert werden können. Diese erlauben, das ""Was"" einer Software zumindest teilweise unabhängig vom ""Wie"" zu spezifizieren. EIFFEL erlaubt darüber hinaus, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können."
"Das herausragende Merkmal, das EIFFEL zu dieser Multifunktion qualifiziert, ist die Integration von Zusicherungen (die Formulierung von Vorbedingungen, Nachbedingungen und Klasseninvarianten), die als Verträge zwischen dienstanbietenden und dienstnehmenden Klassen interpretiert werden können. Dies erlaubt, das ""Was"" einer Software zumindest teilweise unabhängig vom ""Wie"" zu spezifizieren. Die Typsysteme, die Sie in den vorangegangenen Kapiteln kennengelernt haben und von denen auch EIFFEL eines besitzt, erlauben zwar auch schon, Zusicherungen auszudrücken, aber diese beziehen sich jeweils auf die möglichen Werte einer Variable und bleiben dabei sowohl voneinander als auch von der Zeit unabhängig. EIFFEL erlaubt darüber hinaus, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können.",Was ermöglicht EIFFEL im Vergleich zu anderen Typsystemen?,"EIFFEL ermöglicht es, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können. Im Gegensatz zu anderen Typsystemen, die sich jeweils auf die möglichen Werte einer Variablen beziehen und dabei voneinander und von der Zeit unabhängig bleiben."
"EIFFEL tritt in vielerlei Hinsicht in die Fußstapfen von PASCAL: Es ist nicht nur syntaktisch ähnlich, sondern ist auch um Sparsamkeit, Klarheit und Orthogonalität der Konzepte bemüht. Viele Dinge sind in EIFFEL ein klein bisschen anders als in anderen Sprachen, weswegen man meinen könnte, es sei aus Prinzip anders; die meisten Abweichungen sind jedoch wohlbegründet und vermitteln mitunter eine angenehm andere Perspektive auf vertraute Dinge. So ist es eigentlich nur folgerichtig, dass der Erschaffer von EIFFEL, BERTRAND MEYER, Nachfolger von NIKLAUS WIRTH auf dessen Lehrstuhl an der ETH Zürich wurde.",Was ist EIFFEL?,"EIFFEL ist eine objektorientierte Programmiersprache, die um Sparsamkeit, Klarheit und Orthogonalität der Konzepte bemüht ist. Sie wurde von Bertrand Meyer entwickelt und ist syntaktisch ähnlich zu Pascal."
"EIFFEL tritt in vielerlei Hinsicht in die Fußstapfen von PASCAL: Es ist nicht nur syntaktisch ähnlich, sondern ist auch um Sparsamkeit, Klarheit und Orthogonalität der Konzepte bemüht. Viele Dinge sind in EIFFEL ein klein bisschen anders als in anderen Sprachen, weswegen man meinen könnte, es sei aus Prinzip anders; die meisten Abweichungen sind jedoch wohlbegründet und vermitteln mitunter eine angenehm andere Perspektive auf vertraute Dinge. So ist es eigentlich nur folgerichtig, dass der Erschaffer von EIFFEL, BERTRAND MEYER, Nachfolger von NIKLAUS WIRTH auf dessen Lehrstuhl an der ETH Zürich wurde.",Wer ist der Erfinder der Programmiersprache EIFFEL?,Der Erfinder der Programmiersprache EIFFEL ist Bertrand Meyer.
"Es ist mir nicht ganz klar, warum EIFFEL kein größerer Erfolg beschieden ist. Es mag zum einen an der über Jahre absolut unzureichenden Implementierung der Werkzeuge liegen, insbesondere des Compilers. Anfangs wurde er noch nach C übersetzt, was beim Debuggen sicherlich keine Freude für Programmierende war. Zum anderen könnte es an der Natur von BERTRAND MEYER liegen, der sich mit seiner Kompromisslosigkeit nicht nur Freunde gemacht hat. Eine Rolle spielt sicherlich auch das unmögliche, aber trotzdem angestrebte Spagat zwischen kommerzieller Einsetzbarkeit und akademischer Eignung. Viele Programmierweisen, die in der Praxis üblich sind und auf die kaum eine Entwicklerin verzichten will, sind akademisch verpönt. Das Typsystem von EIFFEL trägt, wie Sie sich in Abschnitt 52.5 selbst vergewissern können, auch nicht unbedingt zur Akzeptanz bei. Auf der anderen Seite hat EIFFEL neben SMALLTALK noch am ehesten das Format und die Art, wie man über das Programmieren denkt, zu beeinflussen.",Warum ist EIFFEL kein größerer Erfolg beschieden?,"Es gibt mehrere Gründe, warum EIFFEL kein größerer Erfolg beschieden ist. Dazu gehören die anfänglich unzureichende Implementierung der Werkzeuge, insbesondere des Compilers, die Natur von Bertrand Meyer, der sich mit seiner Kompromisslosigkeit nicht nur Freunde gemacht hat, und der Spagat zwischen kommerzieller Einsetzbarkeit und akademischer Eignung. Zudem ist das Typsystem von EIFFEL nicht unbedingt zur Akzeptanz beigetragen. Trotzdem hat EIFFEL neben Smalltalk am ehesten das Format und die Art, wie man über das Programmieren denkt, beeinflusst."
"In C-Sharp sind, genau wie in Java, alle Variablen typisiert. Anders als in Java wird jedoch zunächst nicht zwischen Wert- (primitiven) und Referenztypen unterschieden: Alle Typen, auch die primitiven, gelten als von Object (genauer: System.Object) abgeleitet. Da lohnt es sich, auf die Typhierarchie etwas genauer einzugehen. Die wichtigsten primitiven Typen sind: int (integer), float, bool (boolean), char (character), double, long, ushort, short, byte. Die wichtigsten Referenztypen sind: string, array, delegate, interface, object. Die primitiven Typen sind in C-Sharp als Werttypen implementiert. Das bedeutet, dass sie auf dem Stack abgelegt werden und bei der Übergabe an eine Methode kopiert werden. Referenztypen werden dagegen auf dem Heap abgelegt und bei der Übergabe an eine Methode nur der Verweis kopiert.",Was ist der Unterschied zwischen Wert- und Referenztypen in C-Sharp?,"In C-Sharp werden primitiven Typen als Werttypen implementiert, die auf dem Stack abgelegt und bei der Übergabe an eine Methode kopiert werden. Referenztypen werden dagegen auf dem Heap abgelegt und bei der Übergabe an eine Methode nur der Verweis kopiert."
"In C-Sharp sind, genau wie in Java, alle Variablen typisiert. Anders als in Java wird jedoch zunächst nicht zwischen Wert- (primitiven) und Referenztypen unterschieden: Alle Typen, auch die primitiven, gelten als von Object (genauer: System.Object) abgeleitet. Da lohnt es sich, auf die Typhierarchie etwas genauer einzugehen. Die wichtigsten primitiven Typen sind: int (integer), float, bool (boolean), char (character), double, long, ushort, short, byte. Die wichtigsten Referenztypen sind: string, array, delegate, interface, object. Die primitiven Typen sind in C-Sharp als Werttypen implementiert. Das bedeutet, dass sie auf dem Stack abgelegt werden und bei der Übergabe an eine Methode kopiert werden. Referenztypen werden dagegen auf dem Heap abgelegt und bei der Übergabe an eine Methode nur der Verweis kopiert.",Wie ist die Typenhierarchie in C-Sharp aufgebaut?,"In C-Sharp sind alle Variablen typisiert. Anders als in Java wird zunächst nicht zwischen Wert- (primitiven) und Referenztypen unterschieden: Alle Typen, auch die primitiven, gelten als von Object (genauer: System.Object) abgeleitet."
"In C-Sharp sind, genau wie in Java, alle Variablen typisiert. Anders als in Java wird jedoch zunächst nicht zwischen Wert- (primitiven) und Referenztypen unterschieden: Alle Typen, auch die primitiven, gelten als von Object (genauer: System.Object) abgeleitet. Da lohnt es sich, auf die Typhierarchie etwas genauer einzugehen. Die wichtigsten primitiven Typen sind: int (integer), float, bool (boolean), char (character), double, long, ushort, short, byte. Die wichtigsten Referenztypen sind: string, array, delegate, interface, object. Die primitiven Typen sind in C-Sharp als Werttypen implementiert. Das bedeutet, dass sie auf dem Stack abgelegt werden und bei der Übergabe an eine Methode kopiert werden. Referenztypen werden dagegen auf dem Heap abgelegt und bei der Übergabe an eine Methode nur der Verweis kopiert.",Was ist eine Typhierarchie in C-Sharp?,"In C-Sharp ist eine Typhierarchie eine Vererbungshierarchie, die die Beziehungen zwischen den verschiedenen Datentypen definiert. Alle Typen, einschließlich primitiver Typen, gelten als von Object (genauer: System.Object) abgeleitet. Diese Hierarchie ermöglicht es, Objekte verschiedener Typen zu behandeln, als ob sie vom gleichen Typ wären, was Polymorphie ermöglicht."
"Genaugenommen ist die Typhierarchie von C-Sharp gar nicht die Typhierarchie von C-Sharp, sondern die von .NET: Sie ist nämlich für alle .NET-Sprachen dieselbe. Das liegt daran, dass .NET für alle seine Sprachen ein gemeinsames Typsystem vorsieht, nämlich das Common Type System (CTS). Das CTS sorgt dafür, dass Typen, die in einer Sprache definiert wurden, auch in einer anderen Sprache verwendet werden können, und zwar ganz so, als wären sie in der anderen Sprache selbst definiert worden. Wie man sich leicht vorstellen kann, sind dafür einige Konventionen notwendig.",Wie ist die Typhierarchie von C-Sharp definiert?,"Die Typhierarchie von C-Sharp ist Teil des Common Type Systems (CTS) von .NET und ist für alle .NET-Sprachen dieselbe. Sie ermöglicht es, Typen, die in einer Sprache definiert wurden, in einer anderen Sprache zu verwenden, als wären sie in der anderen Sprache selbst definiert worden."
"Genaugenommen ist die Typhierarchie von C-Sharp gar nicht die Typhierarchie von C-Sharp, sondern die von .NET: Sie ist nämlich für alle .NET-Sprachen dieselbe. Das liegt daran, dass .NET für alle seine Sprachen ein gemeinsames Typsystem vorsieht, nämlich das Common Type System (CTS). Das CTS sorgt dafür, dass Typen, die in einer Sprache definiert wurden, auch in einer anderen Sprache verwendet werden können, und zwar ganz so, als wären sie in der anderen Sprache selbst definiert worden. Wie man sich leicht vorstellen kann, sind dafür einige Konventionen notwendig.",Was ist das Common Type System (CTS) in .NET?,"Das Common Type System (CTS) ist ein gemeinsames Typsystem in .NET, das sicherstellt, dass Typen, die in einer .NET-Sprache definiert wurden, auch in einer anderen Sprache verwendet werden können, als wären sie in der anderen Sprache selbst definiert worden. Es ermöglicht die Interoperabilität zwischen verschiedenen .NET-Sprachen."
"Das erste Merkmal des CTS ist, dass alle Typen in einer Hierarchie untergebracht sind. Anders als in Java gibt es also keine Ausgrenzung der primitiven Typen. Tatsächlich sind die primitiven Typen als eine von mehreren Arten von Werttypen in der Hierarchie angesiedelt. Eine weitere wichtige Form von Werttypen sind die Aufzählungstypen, die aus PASCAL bekannt sind und inzwischen auch in Java verwendet werden, allerdings dort als Referenztypen. Bei den Werttypen handelt es sich um Typen, die von der Programmiererin selbst angegeben werden können (im Gegensatz zu den primitiven Typen, deren Werte mit der Sprachdefinition vorgegeben sind). Werttypen können, genau wie in PASCAL oder C, mittels des Typkonstruktors ""struct"" (das C-Äquivalent von PASCALs ""record"") erzeugt werden. Diese Typen können sogar Methoden und Konstruktoren haben, sind jedoch keine Klassen und erlauben keine Typerweiterung oder Vererbung.",Was ist das erste Merkmal des CTS?,"Das erste Merkmal des CTS ist, dass alle Typen in einer Hierarchie untergebracht sind. Anders als in Java gibt es also keine Ausgrenzung der primitiven Typen."
"Das erste Merkmal des CTS ist, dass alle Typen in einer Hierarchie untergebracht sind. Anders als in Java gibt es also keine Ausgrenzung der primitiven Typen. Tatsächlich sind die primitiven Typen als eine von mehreren Arten von Werttypen in der Hierarchie angesiedelt. Eine weitere wichtige Form von Werttypen sind die Aufzählungstypen, die aus PASCAL bekannt sind und inzwischen auch in Java verwendet werden, allerdings dort als Referenztypen. Bei den Werttypen handelt es sich um Typen, die von der Programmiererin selbst angegeben werden können (im Gegensatz zu den primitiven Typen, deren Werte mit der Sprachdefinition vorgegeben sind). Werttypen können, genau wie in PASCAL oder C, mittels des Typkonstruktors ""struct"" (das C-Äquivalent von PASCALs ""record"") erzeugt werden. Diese Typen können sogar Methoden und Konstruktoren haben, sind jedoch keine Klassen und erlauben keine Typerweiterung oder Vererbung.",Was sind Werttypen in CTS?,"Werttypen in CTS sind Typen, die von der Programmiererin selbst angegeben werden können und die aus primitiven Typen und Aufzählungstypen bestehen. Im Gegensatz zu Referenztypen, erlauben Werttypen keine Typerweiterung oder Vererbung."
"Eine weitere Unterscheidung ergibt sich bei den Referenztypen. Neben Klassen, Interfaces und Arrays gibt es auch Delegates, die im Wesentlichen Zeiger auf an ein Objekt gebundene einzelne Methoden sind. Delegates ersetzen die aus anderen Sprachen bekannten Funktionspointer. In Java bis zur Version 8 wurden sie recht umständlich über Interfaces und anonyme innere Klassen emuliert, wobei heute Lambda-Ausdrücke in Java anstelle davon verwendet werden können. Delegates sind für verschiedene Problemstellungen, wie z. B. Listener-Mechanismen, sehr nützlich.",Was sind Delegates in der Programmierung?,"Delegates sind Referenztypen, die im Wesentlichen Zeiger auf an ein Objekt gebundene einzelne Methoden sind. Sie werden oft für verschiedene Problemstellungen, wie z. B. Listener-Mechanismen, verwendet. In Java bis zur Version 8 wurden Delegates recht umständlich über Interfaces und anonyme innere Klassen emuliert, während heute Lambda-Ausdrücke in Java anstelle von Delegates verwendet werden können."
"Zuletzt gibt es in C-Sharp auch noch Attribut-Typen (Attributes), die im Wesentlichen den Annotationen entsprechen, die es seit Version 5 auch in Java gibt. Annotationen haben jedoch nichts unmittelbar mit objektorientierter Programmierung zu tun und sind daher nicht Gegenstand dieses Kurses.",Was sind Attribute in C-Sharp?,"Attribute in C-Sharp sind eine Möglichkeit, zusätzliche Informationen zu einem Programmelement hinzuzufügen. Sie sind ähnlich wie Annotationen in Java und haben nichts unmittelbar mit objektorientierter Programmierung zu tun."
"Zuletzt gibt es in C-Sharp auch noch Attribut-Typen (Attributes), die im Wesentlichen den Annotationen entsprechen, die es seit Version 5 auch in Java gibt. Annotationen haben jedoch nichts unmittelbar mit objektorientierter Programmierung zu tun und sind daher nicht Gegenstand dieses Kurses.",Was sind Attribute in C-Sharp und wie unterscheiden sie sich von Annotationen in Java?,"Attribute in C-Sharp sind ähnlich wie Annotationen in Java, die es seit Version 5 gibt. Sie werden beide verwendet, um zusätzliche Metadaten zu einem Programmelement hinzuzufügen. Der Hauptunterschied besteht darin, dass Attribute in C-Sharp direkt in der Sprache definiert und verwendet werden, während Annotationen in Java eine Erweiterung der Sprache sind und eine zusätzliche Bibliothek erfordern."
"Es ergibt sich die folgende grobe Einteilung der Typen in C-Sharp: Werttypen, and Referenztypen: Klassen, Interfaces, Arrays, Delegates, Attribut-Typen",Wie können Typen in C-Sharp eingeteilt werden?,"In C-Sharp gibt es eine grobe Einteilung der Typen in Werttypen und Referenztypen, wobei zu den Referenztypen Klassen, Interfaces, Arrays, Delegates und Attribut-Typen gehören."
"Es ergibt sich die folgende grobe Einteilung der Typen in C-Sharp: Werttypen, and Referenztypen: Klassen, Interfaces, Arrays, Delegates, Attribut-Typen",Was ist der Unterschied zwischen Werttypen und Referenztypen in C-Sharp?,"Werttypen werden direkt auf dem Stack gespeichert und enthalten einen Wert, während Referenztypen auf dem Heap gespeichert werden und eine Referenz auf ein Objekt enthalten. Werttypen werden beim Zuweisen oder Übergeben an eine Methode kopiert, während Referenztypen nur eine Kopie der Referenz erstellen."
"Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C-Sharp. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C-Sharp, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:",Was ist eine Klassenhierarchie in C-Sharp?,"Eine Klassenhierarchie in C-Sharp ist eine Vererbungshierarchie, die die verschiedenen Arten von Typen in C-Sharp einteilt. Sie ist wesentlich komplexer und vereinheitlicht das Typsystem von C-Sharp, indem alle Typen von System.Object abgeleitet sind."
"Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C-Sharp. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C-Sharp, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:",Was ist der Unterschied zwischen einer Klassenhierarchie und der Einteilung der verschiedenen Arten von Typen in C-Sharp?,"Die Klassenhierarchie ist eine Vererbungshierarchie, die alle Typen von System.Object ableitet und das Typsystem von C-Sharp vereinheitlicht. Die Einteilung der verschiedenen Arten von Typen in C-Sharp ist eine Einteilung, die die verschiedenen Arten von Typen in C-Sharp in ValueType, Delegate und class einteilt."
"Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C-Sharp. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C-Sharp, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:",Was ist eine Einteilung der verschiedenen Arten von Typen in C-Sharp?,"Die Einteilung der verschiedenen Arten von Typen in C-Sharp ist eine Einteilung, die die verschiedenen Arten von Typen in C-Sharp in ValueType, Delegate und class einteilt."
"Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C-Sharp. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C-Sharp, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:","Was ist der Unterschied zwischen ValueType, Delegate und class in C-Sharp?","ValueType ist ein Wertetyp, der von System.ValueType abgeleitet ist und auf dem Stack gespeichert wird. Delegate ist ein Verweistyp, der von System.Delegate abgeleitet ist und Delegate-Objekte repräsentiert. class ist ein Verweistyp, der von System.Object abgeleitet ist und Klassenobjekte repräsentiert."
"Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C-Sharp. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C-Sharp, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:",Was ist ein Wertetyp in C-Sharp?,"Ein Wertetyp ist ein Typ, der von System.ValueType abgeleitet"
"Wie Ihnen sicher aufgefallen ist, sind einige der Arten von Typen aus der obigen Liste jeweils durch eine spezielle Klasse (Array, Delegate, Attribute) vertreten. Man kann dies als Hinweis darauf verstehen, dass tatsächlich alle Arten von Typen integriert sind und es keine grundsätzlichen Barrieren zwischen ihnen gibt. In C-Sharp haben alle Klassen außer System.Object, genau wie in Java, genau eine Superklasse. Sie können jedoch beliebig viele Interfaces implementieren. Die Tatsache, dass Werttypen als Subtypen eines Referenztypen (nämlich Object) deklariert sind, verrät außerdem, dass C-Sharp über Auto-Boxing und Unboxing verfügt.",Was ist Auto-Boxing und Unboxing in C-Sharp?,"Auto-Boxing ist eine automatische Konvertierung eines Werttyps in einen Referenztyp, während Unboxing die umgekehrte Konvertierung ist. Diese Funktionen ermöglichen es, Werttypen als Subtypen eines Referenztyps (nämlich Object) zu deklarieren."
"Wie Ihnen sicher aufgefallen ist, sind einige der Arten von Typen aus der obigen Liste jeweils durch eine spezielle Klasse (Array, Delegate, Attribute) vertreten. Man kann dies als Hinweis darauf verstehen, dass tatsächlich alle Arten von Typen integriert sind und es keine grundsätzlichen Barrieren zwischen ihnen gibt. In C-Sharp haben alle Klassen außer System.Object, genau wie in Java, genau eine Superklasse. Sie können jedoch beliebig viele Interfaces implementieren. Die Tatsache, dass Werttypen als Subtypen eines Referenztypen (nämlich Object) deklariert sind, verrät außerdem, dass C-Sharp über Auto-Boxing und Unboxing verfügt.",Wie sind alle Arten von Typen in C-Sharp integriert?,"Alle Arten von Typen sind in C-Sharp integriert, was daran zu erkennen ist, dass einige Arten von Typen durch spezielle Klassen (Array, Delegate, Attribute) vertreten sind. Klassen, außer System.Object, haben genau eine Superklasse und können beliebig viele Interfaces implementieren. Die Tatsache, dass Werttypen als Subtypen eines Referenztyps (nämlich Object) deklariert sind, verrät außerdem, dass C-Sharp über Auto-Boxing und Unboxing verfügt."
"Eine der vielleicht interessantesten Methoden in SMALLTALK ist die Methode become:. Sie bewirkt, dass das Empfängerobjekt die Identität des Parameterobjekts annimmt bzw. mit ihm tauscht (je nach Dialekt). Das hat unter anderem zur Folge, dass alle Variablen, die vor der Ausführung der Methode den Empfänger benannten (genauer: auf das Empfängerobjekt verwiesen), danach den Parameter benennen (auf ihn verweisen).",Was bewirkt die Methode become: in SMALLTALK?,"Die Methode become: in SMALLTALK bewirkt, dass das Empfängerobjekt die Identität des Parameterobjekts annimmt bzw. mit ihm tauscht. Das hat zur Folge, dass alle Variablen, die vor der Ausführung der Methode den Empfänger benannten, danach den Parameter benennen."
"Eine mögliche Anwendung ist das Vergrößern von Objekten: Wenn einem Objekt der ihm zur Verfügung gestellte Speicherplatz nicht mehr ausreicht, muss es ""umziehen"", d.h., seine Repräsentation im Speicher muss an eine andere Stelle kopiert werden. Da aber alle Referenzen auf das Objekt noch auf die alte Stelle verweisen, legt man am besten die neue Stelle als entsprechend groß dimensioniertes Objekt an (beispielsweise mittels new:) und lässt dann das alte Objekt zum neuen werden. So könnte man beispielsweise eine Methode grow in der Klasse ArrayedCollection wie folgt definieren:",Wie kann man ein Objekt vergrößern?,"Eine Möglichkeit, ein Objekt zu vergrößern, ist das ""Umziehen"" der Repräsentation des Objekts in den Speicher. Dazu wird ein neues Objekt mit der doppelten Größe angelegt, die Daten werden in das neue Objekt kopiert und das alte Objekt wird durch das neue Objekt ersetzt. Die Methode grow erzeugt eine neue ArrayedCollection mit einer um 100 erhöhten Größe und kopiert den Inhalt der alten ArrayedCollection in die neue. Anschließend gibt sie die neue ArrayedCollection zurück."
"Eine mögliche Anwendung ist das Vergrößern von Objekten: Wenn einem Objekt der ihm zur Verfügung gestellte Speicherplatz nicht mehr ausreicht, muss es ""umziehen"", d.h., seine Repräsentation im Speicher muss an eine andere Stelle kopiert werden. Da aber alle Referenzen auf das Objekt noch auf die alte Stelle verweisen, legt man am besten die neue Stelle als entsprechend groß dimensioniertes Objekt an (beispielsweise mittels new:) und lässt dann das alte Objekt zum neuen werden. So könnte man beispielsweise eine Methode grow in der Klasse ArrayedCollection wie folgt definieren:",Was macht die Methode grow in der Klasse ArrayedCollection?,"Die Methode grow in der Klasse ArrayedCollection erzeugt eine neue ArrayedCollection mit einer um 100 erhöhten Größe und kopiert den Inhalt der alten ArrayedCollection in die neue. Anschließend gibt sie die neue ArrayedCollection zurück. Diese Methode wird verwendet, wenn einem Objekt der zur Verfügung gestellte Speicherplatz nicht mehr ausreicht, um den Zustand des Objekts zu speichern."
"Eine andere mögliche Anwendung von become: ist die Durchführung eines sogenannten Rollbacks. Wenn also, nachdem an einem Objekt (oder Objektgeflecht) eine Menge von Änderungen durchgeführt worden sind, der ursprüngliche Zustand wiederhergestellt werden soll, legt man einfach vor den Änderungen eine (tiefe) Kopie des Objekts (der Wurzel des Objektgeflechts) an und ersetzt beim Rollback das ursprüngliche (und inzwischen geänderte) Objekt(geflecht) mittels become: durch die Kopie.",Was ist ein Anwendungsfall von become:?,"Eine Anwendung von become: ist die Durchführung eines sogenannten Rollbacks. Dabei wird der ursprüngliche Zustand eines Objekts oder Objektgeflechts wiederhergestellt, indem eine Kopie des Objekts vor den Änderungen angelegt und das ursprüngliche Objekt mittels become: durch die Kopie ersetzt wird."
"Eine andere mögliche Anwendung von become: ist die Durchführung eines sogenannten Rollbacks. Wenn also, nachdem an einem Objekt (oder Objektgeflecht) eine Menge von Änderungen durchgeführt worden sind, der ursprüngliche Zustand wiederhergestellt werden soll, legt man einfach vor den Änderungen eine (tiefe) Kopie des Objekts (der Wurzel des Objektgeflechts) an und ersetzt beim Rollback das ursprüngliche (und inzwischen geänderte) Objekt(geflecht) mittels become: durch die Kopie.",Was ist ein Rollback?,"Ein Rollback ist eine Möglichkeit, den ursprünglichen Zustand eines Objekts oder Objektgeflechts wiederherzustellen, indem eine Kopie des Objekts vor der Durchführung einer Menge von Änderungen angelegt und das ursprüngliche Objekt durch die Kopie ersetzt wird."
"Ein Großteil des Erfolgs der objektorientierten Programmierung hängt von der Verfügbarkeit und der systematischen Verwendung von Bibliotheken ab. In SMALLTALK ist das selbstverständlich, da hier Sprache und Bibliothek praktisch nicht zu trennen sind. Aber auch in Java ist ein Teil der Sprachdefinition in bestimmte, spezielle Klassen wie ""Object"", ""Thread"" und ""Throwable"" verlagert (vgl. Kapitel 47). Auch kommt praktisch kein Java-Programm ohne die Verwendung bestimmter Bibliotheksklassen aus – man denke nur an die allgegenwärtige Verwendung des Collection-Frameworks, ohne das Programmierer zur ständigen Abfassung ewig gleichen Codes verdammt wären.",Warum sind Bibliotheken wichtig für die objektorientierte Programmierung?,"Bibliotheken sind wichtig für die objektorientierte Programmierung, da sie einen Großteil des Erfolgs ausmachen. Sie enthalten wiederverwendbare Klassen und Methoden, die die Entwicklung von Programmen erleichtern und beschleunigen. In SMALLTALK sind Sprache und Bibliothek praktisch nicht zu trennen, während in Java ein Teil der Sprachdefinition in bestimmte Klassen verlagert ist. Auch wird praktisch kein Java-Programm ohne die Verwendung bestimmter Bibliotheksklassen auskommen."
"Ein Großteil des Erfolgs der objektorientierten Programmierung hängt von der Verfügbarkeit und der systematischen Verwendung von Bibliotheken ab. In SMALLTALK ist das selbstverständlich, da hier Sprache und Bibliothek praktisch nicht zu trennen sind. Aber auch in Java ist ein Teil der Sprachdefinition in bestimmte, spezielle Klassen wie ""Object"", ""Thread"" und ""Throwable"" verlagert (vgl. Kapitel 47). Auch kommt praktisch kein Java-Programm ohne die Verwendung bestimmter Bibliotheksklassen aus – man denke nur an die allgegenwärtige Verwendung des Collection-Frameworks, ohne das Programmierer zur ständigen Abfassung ewig gleichen Codes verdammt wären.",Warum hängt der Erfolg der objektorientierten Programmierung von der Verfügbarkeit und systematischen Verwendung von Bibliotheken ab?,"Der Erfolg der objektorientierten Programmierung hängt von der Verfügbarkeit und systematischen Verwendung von Bibliotheken ab, weil sie wiederverwendbaren Code bereitstellen, der die Entwicklungszeit verkürzt und die Fehleranfälligkeit reduziert. Sie ermöglichen es den Programmierern, auf bereits getesteten und bewährten Funktionen zurückzugreifen, anstatt das Rad immer wieder neu zu erfinden. In Smalltalk ist dies besonders ausgeprägt, da Sprache und Bibliothek praktisch nicht zu trennen sind. Auch in Java ist ein Teil der Sprachdefinition in bestimmte, spezielle Klassen verlagert und ein Großteil der Programme verwenden bestimmte Bibliotheksklassen, wie das Collection-Framework."
"Zum objektorientierten Programmierstil gehört es, eine Lösung eines konkreten Problems möglichst umfassend aus existierenden, idealerweise verbreiteten und bewährten Bibliotheken zusammenzustellen. Jede nicht selbst geschriebene Programmzeile ist ein Gewinn, jede Implementierung einer noch so kleinen Funktion, die es bereits in irgendeiner Bibliothek gibt, ist ein Verlust. Dabei sind die Vorteile der Verwendung von Bibliotheken mannigfaltig: In der Regel können Sie davon ausgehen, dass die Implementierungen korrekt sind (und Probleme sowie Sonderfälle berücksichtigen, an die Sie im Traum nicht gedacht hätten), die Wartung und Anpassung übernehmen andere für Sie, und nicht zuletzt dürfen Sie bei weit verbreiteten Bibliotheken voraussetzen, dass deren Funktionalität auch anderen Programmierern bekannt ist, sodass die Verwendung einer Bibliotheksklasse keiner weiteren Erklärung bedarf. Ihr eigener Beitrag wird dadurch klein und überschaubar, was man Ihnen in keinem Fall als Faulheit oder Arbeitsverweigerung auslegen sollte, sondern als wahre Größe: Sie kennen das Werk anderer, Sie wissen es zu schätzen und zu nutzen.","Warum ist es vorteilhaft, existierende Bibliotheken in der objektorientierten Programmierung zu verwenden?","Es ist vorteilhaft, existierende Bibliotheken in der objektorientierten Programmierung zu verwenden, da die Implementierungen in der Regel korrekt sind, die Wartung und Anpassung übernommen wird, die Funktionalität bekannt ist und die eigene Arbeit klein und überschaubar bleibt."
"Das Konzept des Home Context eines Blocks geht aber noch weiter: Es umfasst nicht nur die sichtbaren Variablen aus dem Kontext der Definition des Blocks, sondern auch den sogenannten Call Stack. Dabei handelt es sich um den Speicher, in dem die Rücksprungadressen von Methodenaufrufen abgelegt werden. Folglich bedeutet eine Return-Anweisung innerhalb eines Blocks bei seiner Auswertung immer die unmittelbare Rückkehr in den Kontext, in dem der Block definiert wurde, also in den Home Context (der Methode), und nicht in den Kontext, in dem der Block durch Senden von value ausgewertet wird.",Was ist der Home Contexts eines Blocks?,"Das Konzept des Home Contexts eines Blocks in SMALLTALK umfasst nicht nur die sichtbaren Variablen aus dem Kontext der Definition des Blocks, sondern auch den sogenannten Call Stack, der die Rücksprungadressen von Methodenaufrufen speichert."
"Continuations spielen bei der Implementierung von Kontrollstrukturen in SMALLTALK eine entscheidende Rolle. Das Prinzip der Continuation gilt übrigens auch für geschachtelte Blöcke. Explizite Return-Anweisungen aus Blöcken kehrt immer dahin zurück, wo die Definition des Blocks angestoßen wurde.Continuations können jedoch zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde. Return-Anweisungen in Blöcken sind ein umstrittenes Konzept, können jedoch für SMALLTALK unverzichtbar sein, da sie zur Implementierung von nahezu allen Kontrollstrukturen verwendet werden.",Was ist eine Continuation?,"Im Kontext von Blöcken in SMALLTALK bezieht sich ""Continuation"" auf das Konzept, dass eine Return-Anweisung innerhalb eines Blocks immer zur unmittelbaren Rückkehr in den Home Context des Blocks führt. Dieses Konzept stammt aus der Welt der funktionalen Programmierung und spielt bei der Implementierung von Kontrollstrukturen in SMALLTALK eine wichtige Rolle."
"Continuations spielen bei der Implementierung von Kontrollstrukturen in SMALLTALK eine entscheidende Rolle. Das Prinzip der Continuation gilt übrigens auch für geschachtelte Blöcke. Explizite Return-Anweisungen aus Blöcken kehrt immer dahin zurück, wo die Definition des Blocks angestoßen wurde.Continuations können jedoch zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde. Return-Anweisungen in Blöcken sind ein umstrittenes Konzept, können jedoch für SMALLTALK unverzichtbar sein, da sie zur Implementierung von nahezu allen Kontrollstrukturen verwendet werden.",Warum können Continuations zu Laufzeitfehlern führen?,"Continuations können zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde. Return-Anweisungen in Blöcken sind daher ein umstrittenes Konzept."
"Man kann nun argumentieren, dass die Substituierbarkeit im Einzelfall von der jeweiligen Verwendung der Typen abhängt (vgl. Fußnote 86). Im Beispiel von ""Set"" und ""Bag"" kann man daher nicht grundsätzlich behaupten, dass das eine den Ersatz des anderen ausschließt. Es kann durchaus Anwendungsfälle für den einen oder anderen Typ geben, in denen der jeweils andere als Ersatz dienen kann. Das Vorhandensein einer tatsächlichen Substituierbarkeit hängt also nicht allein von den beteiligten Typen ab, sondern auch von ihrer Verwendung. Dies wiederum bedeutet (auch vor dem Hintergrund des oben Gesagten zur funktionalen Äquivalenz), dass es so etwas wie eine absolute Substituierbarkeit, die von jeder möglichen Verwendung losgelöst ist, eigentlich nicht existiert.",Was ist Substituierbarkeit und wie hängt sie von der Verwendung der Typen ab?,"Substituierbarkeit bezieht sich auf die Möglichkeit, einen Typ durch einen anderen Typ ersetzen zu können. Im Beispiel von ""Set"" und ""Bag"" kann die Substituierbarkeit nicht grundsätzlich ausgeschlossen werden, da es Anwendungsfälle geben kann, in denen der eine Typ den anderen ersetzen kann. Die tatsächliche Substituierbarkeit hängt jedoch nicht nur von den beteiligten Typen ab, sondern auch von ihrer Verwendung. Es gibt also keine absolute Substituierbarkeit, die von jeder möglichen Verwendung losgelöst ist."
"Man kann nun argumentieren, dass die Substituierbarkeit im Einzelfall von der jeweiligen Verwendung der Typen abhängt (vgl. Fußnote 86). Im Beispiel von ""Set"" und ""Bag"" kann man daher nicht grundsätzlich behaupten, dass das eine den Ersatz des anderen ausschließt. Es kann durchaus Anwendungsfälle für den einen oder anderen Typ geben, in denen der jeweils andere als Ersatz dienen kann. Das Vorhandensein einer tatsächlichen Substituierbarkeit hängt also nicht allein von den beteiligten Typen ab, sondern auch von ihrer Verwendung. Dies wiederum bedeutet (auch vor dem Hintergrund des oben Gesagten zur funktionalen Äquivalenz), dass es so etwas wie eine absolute Substituierbarkeit, die von jeder möglichen Verwendung losgelöst ist, eigentlich nicht existiert.",Was bestimmt die Substituierbarkeit von Typen?,"Die Substituierbarkeit von Typen hängt nicht nur von den beteiligten Typen ab, sondern auch von ihrer Verwendung. Es gibt also keine absolute Substituierbarkeit, die von jeder möglichen Verwendung losgelöst ist."
"Wie kann man diesem Umstand begegnen? Nun, indem man nicht nur die Sichtweise der Programmiererin berücksichtigt, die die Typen erstellt und sich um deren Substituierbarkeit (sowie die darauf basierende Subtypenbeziehung) kümmert, sondern auch die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte. Nur diese Programmiererin weiß genau, welche Erwartungen sie an einen Typen (genauer gesagt, an die Objekte eines Typs) hat, und nur sie kann beurteilen, welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind.",Wie kann man mit der Substituierbarkeit von Typen umgehen?,"Man kann der Substituierbarkeit von Typen begegnen, indem man die Sichtweise der Programmiererin berücksichtigt, die die Typen für einen bestimmten Zweck verwenden möchte. Diese Programmiererin weiß genau, welche Erwartungen sie an einen Typen hat und kann beurteilen, welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind."
"Wie kann man diesem Umstand begegnen? Nun, indem man nicht nur die Sichtweise der Programmiererin berücksichtigt, die die Typen erstellt und sich um deren Substituierbarkeit (sowie die darauf basierende Subtypenbeziehung) kümmert, sondern auch die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte. Nur diese Programmiererin weiß genau, welche Erwartungen sie an einen Typen (genauer gesagt, an die Objekte eines Typs) hat, und nur sie kann beurteilen, welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind.",Wie kann man die Substituierbarkeit von Typen und die darauf basierende Subtypenbeziehung berücksichtigen?,"Man kann dies tun, indem man die Sichtweise der Programmiererin berücksichtigt, die die Typen erstellt und sich um deren Substituierbarkeit kümmert, sowie die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte. Nur diese Programmiererin weiß genau, welche Erwartungen sie an einen Typen hat, und nur sie kann beurteilen, welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind."
"Wie kann man diesem Umstand begegnen? Nun, indem man nicht nur die Sichtweise der Programmiererin berücksichtigt, die die Typen erstellt und sich um deren Substituierbarkeit (sowie die darauf basierende Subtypenbeziehung) kümmert, sondern auch die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte. Nur diese Programmiererin weiß genau, welche Erwartungen sie an einen Typen (genauer gesagt, an die Objekte eines Typs) hat, und nur sie kann beurteilen, welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind.","Warum ist die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte, wichtig?","Die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte, ist wichtig, weil sie genau weiß, welche Erwartungen sie an einen Typen hat und welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind."
"Wie drückt aber die Programmiererin ihre Erwartungen aus? Die Antwort ist überraschend einfach: Sie definiert selbst einen Typen, dessen Definition nur die Eigenschaften umfasst, die sie benötigt. Ein solcher Typ spezifiziert gewissermaßen die Rolle, die die Objekte im Kontext der Verwendung spielen sollen. In der Regel wird dieser Typ nur einen Teil der Eigenschaften umfassen, die allgemeine Typen wie ""Set"" oder ""Bag"" spezifizieren. Im Gegenzug erweitert sich jedoch die Auswahl der Typen, deren Objekte für ihre speziellen Zwecke in Frage kommen.",Wie können Programmierer ihre Erwartungen an Objekte ausdrücken?,"Programmierer können ihre Erwartungen an Objekte ausdrücken, indem sie selbst einen Typen definieren, der nur die Eigenschaften umfasst, die sie benötigen. Ein solcher Typ spezifiziert gewissermaßen die Rolle, die die Objekte im Kontext der Verwendung spielen sollen."
"Die einzige Voraussetzung dafür, dass Objekte die ihnen aus Sicht der Anwenderin zugewiesene Rolle auch tatsächlich spielen können, ist, dass sie typkonform sind.","Was ist die Voraussetzung dafür, dass Objekte ihre Rolle spielen können?","Die einzige Voraussetzung dafür ist, dass sie typkonform sind."
"Die einzige Voraussetzung dafür, dass Objekte die ihnen aus Sicht der Anwenderin zugewiesene Rolle auch tatsächlich spielen können, ist, dass sie typkonform sind.","Was bedeutet es, wenn ein Objekt typkonform ist?","Wenn ein Objekt typkonform ist, bedeutet das, dass es die Eigenschaften und Verhaltensweisen besitzt, die von einem Objekt seines Typs erwartet werden. Es erfüllt also die Anforderungen, die an Objekte dieses Typs gestellt werden."
"Die einzige Voraussetzung dafür, dass Objekte die ihnen aus Sicht der Anwenderin zugewiesene Rolle auch tatsächlich spielen können, ist, dass sie typkonform sind.","Warum ist es wichtig, dass Objekte typkonform sind?","Es ist wichtig, dass Objekte typkonform sind, weil sie nur dann die ihnen zugewiesene Rolle spielen können. Wenn Objekte nicht typkonform sind, können sie nicht die gewünschten Funktionen erfüllen und können zu Fehlern im Programm führen."
"Die einzige Voraussetzung dafür, dass Objekte die ihnen aus Sicht der Anwenderin zugewiesene Rolle auch tatsächlich spielen können, ist, dass sie typkonform sind.","Was ist die Voraussetzung dafür, dass Objekte typkonform sind?","Die Voraussetzung dafür, dass Objekte typkonform sind, ist, dass sie die Eigenschaften und Verhaltensweisen besitzen, die von einem Objekt seines Typs erwartet werden."
"Die einzige Voraussetzung dafür, dass Objekte die ihnen aus Sicht der Anwenderin zugewiesene Rolle auch tatsächlich spielen können, ist, dass sie typkonform sind.","Was passiert, wenn ein Objekt nicht typkonform ist?","Wenn ein Objekt nicht typkonform ist, kann es nicht die gewünschten Funktionen erfüllen und kann zu Fehlern im Programm führen."
"Diese doppelte Sichtweise auf Typen, sowohl aus Sicht der Nutzerin als auch aus Sicht der Anbieterin, beginnt sich erst langsam durchzusetzen. Die Programmiersprachen Java und später auch C-Sharp bieten immerhin das Konzept von ""Interfaces als Typen"" an (siehe Kapitel 40 in Kurseinheit 4 und Abschnitt 50.4.2 in Kurseinheit 5), mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. In der Praxis wird diese Möglichkeit jedoch in beiden Sprachen selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen. Möglicherweise wird dies in Zukunft anders gehandhabt.",Was ist der Unterschied zwischen der Sicht der Nutzerin und der Sicht der Anbieterin auf Typen?,"Die Sicht der Nutzerin auf Typen ist, wie sie in einem Programm verwendet werden, während die Sicht der Anbieterin sich auf die Implementierung des Typs bezieht. Die Programmiersprachen Java und C-Sharp bieten das Konzept von ""Interfaces als Typen"" an, mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. In der Praxis wird diese Möglichkeit jedoch selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen."
"Diese doppelte Sichtweise auf Typen, sowohl aus Sicht der Nutzerin als auch aus Sicht der Anbieterin, beginnt sich erst langsam durchzusetzen. Die Programmiersprachen Java und später auch C-Sharp bieten immerhin das Konzept von ""Interfaces als Typen"" an (siehe Kapitel 40 in Kurseinheit 4 und Abschnitt 50.4.2 in Kurseinheit 5), mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. In der Praxis wird diese Möglichkeit jedoch in beiden Sprachen selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen. Möglicherweise wird dies in Zukunft anders gehandhabt.",Was sind Interfaces als Typen?,"Interfaces als Typen sind ein Konzept in Programmiersprachen wie Java und C-Sharp, mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. Diese Möglichkeit wird jedoch selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen."
"Das Fragile-Base-Class-Problem bezieht sich auf eine ganze Familie von Problemen, die eng mit der Vererbung zusammenhängen. Der Name ist insofern etwas irreführend, als nicht unbedingt die Basisklassen, also die Superklassen (siehe Abschnitt 11.1), als ""anfällig"" oder ""zerbrechlich"" gelten, sondern eher die Klassen, die von ihnen erben. Ein einfaches Beispiel soll verdeutlichen, um was es geht.",Was ist das Fragile-Base-Class-Problem?,"Das Fragile-Base-Class-Problem bezieht sich auf eine Familie von Problemen, die eng mit der Vererbung zusammenhängen. Es tritt auf, wenn eine Unterklasse eine Methode der Superklasse überschreibt und diese Änderung unbeabsichtigte Auswirkungen auf andere Unterklassen hat, die ebenfalls diese Methode überschreiben."
"Angenommen, wir haben eine Klasse namens TapeArchive geschrieben, die Videobänder archiviert. Da es sich nicht um eine einfache Desktop-Anwendung handelt, sondern um ein kommerzielles System, erfolgt die Datenhaltung in einer Datenbank. In der objektorientierten Programmierung ist es üblich, solche Klassen wiederzuverwenden, indem man von ihnen neue Klassen ableitet. Wenn beispielsweise eine Anforderung von Kunden besteht, bei jeder Archivierung eine Nachricht zu senden, und diese Anforderung nicht für alle Kunden der Software gleichermaßen interessant ist, dann schreibt man eine Subklasse, die dieses geänderte Verhalten bereitstellt. Das Schöne an der Objektorientierung ist dabei, dass man nur die Unterschiede (Differentia) spezifizieren muss, der Rest wird einfach geerbt. Im gegebenen Fall genügt es, die Initialisierung und die Methode addTape: anzupassen. Das Verhalten von addAllTapes: kann unverändert bleiben, da es die (dynamisch gebundene) Methode addTape: aufruft und somit auch das von NotifyingTapeArchive geforderte Verhalten, nämlich die Benachrichtigung aller archivierten Bänder, garantiert.",Was ist die Bedeutung von Differentia in der Objektorientierung?,"In der Objektorientierung ist Differentia der Teil, der spezifiziert werden muss, während der Rest einfach geerbt wird. Es ist der Unterschied, der eine Klasse von anderen Klassen unterscheidet."
"Das Problem ist jedoch, dass man der Klasse TapeArchive nicht ansieht, was sie garantiert oder wovon die Korrektheit ihrer Subklassen abhängt. Wenn später eine andere Kundin bemängelt, dass das Hinzufügen großer Mengen von Bändern zu lange dauert, und das wiederholte Aufrufen von addTape: aus addAllTapes: als Ursache identifiziert, könnte sie vorschlagen, nicht nur die nörgelnde Kundin, sondern alle Kundinnen mit der optimierten Implementierung von TapeArchive zu beglücken. Das klingt verlockend, aber hier liegt bereits das Problem.Vermutlich können die meisten von Ihnen nicht sofort sagen, was dagegen spricht, denn in der Klasse TapeArchive scheint alles in Ordnung zu sein. Der Fehler liegt darin, dass die Korrektheit der Methode addAllTapes: davon abhängt, dass sie addTape: aufruft - nicht unbedingt für die Klasse TapeArchive selbst, aber für ihre Subklasse NotifyingTapeArchive. Hier werden nun nur noch für einzeln archivierte Bänder Benachrichtigungen verschickt. Hätten Sie diesen Fehler vorhergesehen? Wahrscheinlich nicht, da die Täuschung darin besteht, dass addAllTapes: in TapeArchive die Methode addTape: der benachbarten Methode aufruft. Wenn Sie den Aufruf von addTape: in addAllTapes: entfernen und nur den Beitrag von addTape: in addAllTapes: verlagern, wäre dies eine semantikerhaltende Umstrukturierung (ein sogenanntes Refactoring). Allerdings beraubt dies die Subklassen der Möglichkeit, eigenes Verhalten genau an dieser Stelle, dem Aufruf von addTape:, einzubringen. Wenn diese Beraubung im Nachhinein erfolgt, kann sie den Code ""zerbrechen"".",Was ist ein Refactoring?,"Refactoring ist eine semantikerhaltende Umstrukturierung von Code, bei der der Verhaltensumfang der Methode nicht verändert wird, sondern nur die innere Struktur der Methode."
"Das Problem ist, dass nicht einmal klar ist, wem die Schuld zuzuweisen ist - TapeArchive, weil es einen Vertrag bricht, den es nicht abgeschlossen hat (oder weil es keine Rücksicht auf Subklassen nimmt, die es nicht kennt), oder NotifyingTapeArchive, weil es sich grundlos darauf verlässt, dass die geerbten Methoden dauerhaft die eigenen Methoden aufrufen? Wenn die Schuld nicht einmal feststeht, wie kann man das Problem verhindern?","Wie kann das Fragile Base-Class-Problem verhindert werden, wenn die Schuld nicht feststeht?","Das Fragile Base-Class-Problem kann verhindert werden, indem man eine klare Schnittstelle definiert und sicherstellt, dass alle Klassen diese Schnittstelle einhalten. Zudem sollten Subklassen die Möglichkeit haben, die Verhaltensweise der übergeordneten Klassen zu überschreiben, ohne dass dies zu unerwarteten Nebenwirkungen führt. Das Problem kann außerdem verhindert werden, indem man eine klare Dokumentation und Kommunikation zwischen den Subklassen und Superklassen pflegt, um sicherzustellen, dass die geerbten Methoden die eigenen Methoden aufrufen. Zudem kann man eine Schnittstelle definieren, die von der Superklasse und allen Subklassen eingehalten wird, um sicherzustellen, dass die Methodenaufrufe konsistent sind."
"Es gibt zahlreiche Varianten des Fragile-Base-Class-Problems, die hier nicht alle aufgeführt werden sollen. Ihnen allen ist gemeinsam, dass zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, die nur unvollständig dokumentiert sind. Es könnte angenommen werden, dass von allem, was vererbt wird, eine Abhängigkeit ausgeht, die bei Änderungen berücksichtigt werden muss. Dies würde jedoch die Möglichkeiten, in Superklassen Änderungen vorzunehmen, so stark einschränken, dass das gesamte Konzept ad absurdum geführt würde. Es bleibt daher wenig mehr, als bei der Verwendung von Vererbung äußerst vorsichtig zu sein oder sie gänzlich zu verbieten.",Was ist das Fragile-Base-Class-Problem?,"Das Fragile-Base-Class-Problem beschreibt die Situation, in der zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, die nur unvollständig dokumentiert sind. Diese Abhängigkeiten können bei Änderungen berücksichtigt werden müssen, was die Möglichkeiten, in Superklassen Änderungen vorzunehmen, einschränken kann."
"Die Vererbung von Implementierung - die Fähigkeit, eine Komponente von einer anderen Komponente abzuleiten oder Teile ihrer Funktionalität zu erben - ist eine sehr nützliche Technologie zum Erstellen von Anwendungen. Die Vererbung von Implementierung kann jedoch viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen.",Was ist die Vererbung von Implementierung?,"Die Vererbung von Implementierung ist eine Technologie zum Erstellen von Anwendungen, bei der eine Komponente von einer anderen Komponente abgeleitet wird oder Teile ihrer Funktionalität erbt."
"Die Vererbung von Implementierung - die Fähigkeit, eine Komponente von einer anderen Komponente abzuleiten oder Teile ihrer Funktionalität zu erben - ist eine sehr nützliche Technologie zum Erstellen von Anwendungen. Die Vererbung von Implementierung kann jedoch viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen.",Was ist Vererbung von Implementierung und welche Probleme kann sie verursachen?,"Vererbung von Implementierung ist eine Technologie, die es ermöglicht, eine Komponente von einer anderen Komponente abzuleiten oder Teile ihrer Funktionalität zu erben. Diese Technologie kann jedoch viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen, da sie die Kopplung zwischen Komponenten erhöht und die Änderungen in der Basiskomponente Auswirkungen auf die abgeleiteten Komponenten haben können."
"Das Problem bei der Vererbung von Implementierung besteht darin, dass der ""Vertrag"" oder die Beziehung zwischen Komponenten in einer Implementierungshierarchie nicht klar definiert ist. Sie ist implizit und mehrdeutig. Wenn die Eltern- oder Kindkomponente unerwartet ihr Verhalten ändert, kann dies zu undefiniertem Verhalten verwandter Komponenten führen. Dies ist kein Problem, wenn die Implementierungshierarchie von einer definierten Gruppe von Programmierern kontrolliert wird, die Updates an allen Komponenten gleichzeitig vornehmen können. Genau diese Fähigkeit zur Kontrolle und Änderung einer Gruppe von verwandten Komponenten unterscheidet jedoch eine Anwendung, selbst eine komplexe Anwendung, von einem echten verteilten Objektsystem. Daher kann die Implementierungsvererbung zwar sehr nützlich sein, um Anwendungen zu erstellen, ist jedoch nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert.","Warum ist die Implementierungsvererbung nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert?","Die Implementierungsvererbung ist nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert, weil sie implizit und mehrdeutig ist. Wenn die Eltern- oder Kindkomponente unerwartet ihr Verhalten ändert, kann dies zu undefiniertem Verhalten verwandter Komponenten führen. Diese Unsicherheit ist nicht akzeptabel in einem System, das von vielen verschiedenen Programmierern entwickelt wird, die nicht alle gleichzeitig Updates an allen Komponenten vornehmen können."
"In einem System, das aus Komponenten verschiedener Anbieter besteht, ist es entscheidend, dass ein bestimmter Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet. Um dies zu erreichen, muss die tatsächliche Schnittstelle auf der von solchen Clients verwendeten Komponente für beide Parteien kristallklar sein. Andernfalls, wie kann der Komponentenanbieter sicherstellen, dass er diese Schnittstelle beibehält und somit die bestehenden Clients nicht stört?","Warum ist es wichtig, dass die Schnittstelle einer Komponente für den Anbieter und den Client klar definiert ist?","Damit der Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet."
"In einem System, das aus Komponenten verschiedener Anbieter besteht, ist es entscheidend, dass ein bestimmter Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet. Um dies zu erreichen, muss die tatsächliche Schnittstelle auf der von solchen Clients verwendeten Komponente für beide Parteien kristallklar sein. Andernfalls, wie kann der Komponentenanbieter sicherstellen, dass er diese Schnittstelle beibehält und somit die bestehenden Clients nicht stört?","Warum ist es wichtig, dass die Schnittstelle einer Komponente für beide Parteien kristallklar ist?","Damit der Komponentenanbieter sicherstellen kann, dass er die Schnittstelle beibehält und somit die bestehenden Clients nicht stört."
"Übertragen auf die objektorientierte Programmierung besteht das Problem darin, dass der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen. Die Vererbung von Implementierung wurde aus der Spezifikation von Microsofts Component Object Model (COM) verbannt und durch die Vererbung von Schnittstellen (was als Subtyping bezeichnet wird) ersetzt. Trotzdem bleiben Vorbehalte gegenüber dem dynamischen Binden bestehen.",Warum wurde die Vererbung von Implementierung in Microsofts Component Object Model (COM) verbannt?,"Die Vererbung von Implementierung wurde in COM verbannt, weil der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen."
"Übertragen auf die objektorientierte Programmierung besteht das Problem darin, dass der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen. Die Vererbung von Implementierung wurde aus der Spezifikation von Microsofts Component Object Model (COM) verbannt und durch die Vererbung von Schnittstellen (was als Subtyping bezeichnet wird) ersetzt. Trotzdem bleiben Vorbehalte gegenüber dem dynamischen Binden bestehen.",Was ist der Vorteil von Interfaces gegenüber der Vererbung von Implementierung?,"Der Vorteil von Interfaces gegenüber der Vererbung von Implementierung ist, dass sie den Vertrag zwischen Klassen klar definiert und das dynamische Binden ermöglicht, ohne sich um die Implementierungsdetails kümmern zu müssen."
"Übertragen auf die objektorientierte Programmierung besteht das Problem darin, dass der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen. Die Vererbung von Implementierung wurde aus der Spezifikation von Microsofts Component Object Model (COM) verbannt und durch die Vererbung von Schnittstellen (was als Subtyping bezeichnet wird) ersetzt. Trotzdem bleiben Vorbehalte gegenüber dem dynamischen Binden bestehen.",Was ist der Nachteil von Interfaces gegenüber der Vererbung von Implementierung?,"Der Nachteil von Interfaces gegenüber der Vererbung von Implementierung ist, dass sie keine gemeinsam genutzten Implementierungen ermöglicht und die Code-Duplizierung erhöhen kann."
"Es liegt nahe, in Bezug auf die Vererbung das zu tun, was man bei Abhängigkeiten immer tut: Schnittstellen einführen. Im Gegensatz zu der Schnittstelle, die einem Client einer Klasse angeboten wird (der diese Schnittstelle nutzt, indem er seine Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann), handelt es sich bei der Schnittstelle zwischen einer Klasse und ihren Subklassen jedoch um eine etwas anders geartete. Hier gibt es lediglich zwei Variablen, self (oder this) und super, die jedoch keine Abhängigkeit von anderen Objekten ausdrücken und nicht explizit typisiert sind. Die damit verbundene Schnittstelle, also die Menge der Eigenschaften, auf die man über diese Variable zugreifen kann, und wo man diese Eigenschaften findet (also wo sie definiert sind), muss man selbst zusammensuchen. Dies hat nichts mit Information Hiding und dem Verbergen von Implementationsdetails zu tun. Was stattdessen benötigt wird, ist ein explizites Vererbungsinterface.",Was ist ein explizites Vererbungsinterface?,"Ein explizites Vererbungsinterface ist eine Schnittstelle zwischen einer Klasse und ihren Subklassen, die die Eigenschaften definiert, auf die man über die Variablen self oder super zugreifen kann. Im Gegensatz zu anderen Schnittstellen handelt es sich hierbei nicht um eine Abhängigkeit zu anderen Objekten, sondern um eine Schnittstelle, die das Verhalten zwischen einer Klasse und ihren Subklassen regelt."
"Es liegt nahe, in Bezug auf die Vererbung das zu tun, was man bei Abhängigkeiten immer tut: Schnittstellen einführen. Im Gegensatz zu der Schnittstelle, die einem Client einer Klasse angeboten wird (der diese Schnittstelle nutzt, indem er seine Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann), handelt es sich bei der Schnittstelle zwischen einer Klasse und ihren Subklassen jedoch um eine etwas anders geartete. Hier gibt es lediglich zwei Variablen, self (oder this) und super, die jedoch keine Abhängigkeit von anderen Objekten ausdrücken und nicht explizit typisiert sind. Die damit verbundene Schnittstelle, also die Menge der Eigenschaften, auf die man über diese Variable zugreifen kann, und wo man diese Eigenschaften findet (also wo sie definiert sind), muss man selbst zusammensuchen. Dies hat nichts mit Information Hiding und dem Verbergen von Implementationsdetails zu tun. Was stattdessen benötigt wird, ist ein explizites Vererbungsinterface.","Was ist der Unterschied zwischen der Schnittstelle, die einem Client einer Klasse angeboten wird und der Schnittstelle zwischen einer Klasse und ihren Subklassen?","Die Schnittstelle, die einem Client einer Klasse angeboten wird, ist die Schnittstelle, die der Client nutzt, indem er Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann. Die Schnittstelle zwischen einer Klasse und ihren Subklassen hingegen ist eine etwas anders geartete Schnittstelle, die lediglich zwei Variablen, self (oder this) und super, umfasst und nicht explizit typisiert ist. Die Schnittstelle zwischen einer Klasse und ihren Subklassen muss man selbst zusammensuchen und ist nicht mit Information Hiding und dem Verbergen von Implementationsdetails zu tun."
"Einige erste Ansätze zur Einführung expliziter Vererbungsinterfaces wurden bereits gesehen, wie die Verwendung des Zugriffsmodifikators protected in Java, C-Sharp und C++ sowie die explizite Deklaration von Überschreibbarkeit und Überschreibung mittels virtual und override in C-Sharp (und C++). Im obigen Beispiel würde die Deklaration von addTape: als nicht überschreibbar (und somit als statisch gebunden, nicht dynamisch gebunden) verhindern, dass NotifyingTapeArchive diese Methode ändert und sich darauf verlässt, dass die geerbte Methode addAllTapes: die überschreibende Version von addTape: aufruft (obwohl sie sie immer noch neu einführen könnte, würde diese neue Version bei der Bindung in addAllTapes: nicht berücksichtigt). NotifyingTapeArchive müsste dann beide Methoden neu implementieren und sicherstellen, dass addAllTapes: keinen Fehler macht. Dies hätte jedoch zur Folge, dass bei einem direkten Aufruf von addTape: von außerhalb auf einer Variable vom Typ TapeArchive, die eine Instanz vom Typ NotifyingTapeArchive hält, die überschreibende Implementierung ignoriert wird (da keine dynamische Bindung mehr stattfindet). Im Gegensatz dazu würde die Verwendung von virtual bei addTape: in TapeArchive darauf hinweisen, dass die Methode in Subklassen relevante Modifikationen enthalten kann, so dass Aufrufe dieser Methode nicht einfach gekürzt werden können, wie im obigen Beispiel geschehen.",Was ist der Unterschied zwischen statischer und dynamischer Bindung?,"Statische Bindung findet zur Übersetzungszeit statt und ist damit schneller, während dynamische Bindung zur Laufzeit erfolgt und damit etwas langsamer ist. Statische Bindung wird verwendet, wenn der Compiler die Methodenaufrufe bereits zur Übersetzungszeit auflösen kann, während dynamische Bindung verwendet wird, wenn der Compiler die Methodenaufrufe nicht auflösen kann und sie daher zur Laufzeit auflösen muss."
"Bei der Definition von Java wurde dies jedoch nicht berücksichtigt. Der Zugriffsmodifikator protected, virtual und override sind mehr als Symbole für das Bewusstsein, dass es das Fragile-Base-Class-Problem gibt.",Was ist das Fragile-Base-Class-Problem in Java?,"Das Fragile-Base-Class-Problem in Java ist ein Problem, bei dem Änderungen an der Superklasse (Basisklasse) eine Unterklasse brechen können, wenn der Zugriffsmodifikator protected, virtual und override nicht berücksichtigt werden."
"Wie bereits zu Beginn erwähnt (in Abschnitt 7.1), entspricht die Klassifikation sprachlich der ""Ist-ein-Abstraktionsbeziehung"" zwischen Individuen und ihren Klassen: ""Peter ist ein Mensch,"" ""SMALLTALK ist eine Programmiersprache,"" usw. sind alles Beispiele für eine Art der Abstraktion, bei der man von einem Individuum zu seinem Allgemeinbegriff übergeht. Es gibt jedoch eine zweite Form der Ist-ein-Abstraktion, die sich von der ersten grundlegend unterscheidet, aber ebenfalls eine charakteristische Rolle in der objektorientierten Programmierung spielt: die Generalisierung. Sprachlich zeigt sich diese Form in Sätzen wie ""Ein Mensch ist ein Säugetier,"" ""Ein Säugetier ist ein Lebewesen"" oder ""Eine Programmiersprache ist ein Werkzeug."" Der Unterschied zur ersten Form der Abstraktion liegt offensichtlich darin, dass hier zwei Allgemeinbegriffe miteinander in Beziehung gesetzt werden, anstelle eines Individuums und eines Allgemeinbegriffs. Ein weiterer, etwas subtilerer, aber sehr wesentlicher Unterschied besteht darin, dass die Klassifikation nicht transitiv ist, während die Generalisierung es ist. So ergibt sich aus ""Ein Mensch ist ein Säugetier"" und ""Ein Säugetier ist ein Lebewesen"" logischerweise ""Ein Mensch ist ein Lebewesen,"" aber aus ""Peter ist ein Mensch"" und ""Mensch ist eine Art"" ergibt sich nicht ""Peter ist eine Art.""",Was ist die Unterscheidung zwischen Klassifikation und Generalisierung in der objektorientierten Programmierung?,"Klassifikation ist eine Form der Ist-ein-Abstraktion, bei der man von einem Individuum zu seinem Allgemeinbegriff übergeht, während Generalisierung zwei Allgemeinbegriffe miteinander in Beziehung setzt. Ein weiterer Unterschied besteht darin, dass die Klassifikation nicht transitiv ist, während die Generalisierung es ist."
"Im Prozess der Generalisierung werden mehrere Klassen, deren Definitionen inhaltlich verwandt sind, zusammengefasst. Das Ergebnis dieser Generalisierung, auch als Generalisierungsklasse bezeichnet, enthält nur diejenigen Elemente der Definitionen der generalisierten Klassen, die allen gemeinsam sind. So lässt sich beispielsweise aus den beiden ähnlichen, aber nicht identischen Klassen Mensch und Vogel per Generalisierung die Klasse Zweibeiner herausarbeiten. Diese Klasse Zweibeiner enthält die gemeinsamen Eigenschaften (Instanzvariablen und Methoden) der Klassen Mensch und Vogel.",Was ist Generalisierung in der objektorientierten Programmierung?,"Generalisierung ist ein Prozess in der objektorientierten Programmierung, bei dem mehrere Klassen, deren Definitionen inhaltlich verwandt sind, zusammengefasst werden. Das Ergebnis dieser Generalisierung, auch als Generalisierungsklasse bezeichnet, enthält nur diejenigen Elemente der Definitionen der generalisierten Klassen, die allen gemeinsam sind."
"Da die Eigenschaften, die einer Generalisierung als Klasse zugeordnet sind, per Definition automatisch auch für alle Klassen gelten, von denen die Generalisierung abstrahiert (denn das war ja die Bedingung für die Konstruktion der Generalisierung), müssen diese Klassen die Eigenschaften nicht wiederholen, sondern nur auf ihre Generalisierung verweisen. Diese Klassen müssen dann nur noch die Unterschiede definieren, die sie von der Klasse Zweibeiner sowie voneinander unterscheiden.",Was ist die Funktion von Generalisierungen in der objektorientierten Programmierung?,"Die Funktion von Generalisierungen in der objektorientierten Programmierung ist es, Eigenschaften zu definieren, die automatisch auch für alle Klassen gelten, von denen die Generalisierung abstrahiert. Diese Klassen müssen dann nur noch die Unterschiede definieren, die sie von der Generalisierung und voneinander unterscheiden."
"Da die Eigenschaften, die einer Generalisierung als Klasse zugeordnet sind, per Definition automatisch auch für alle Klassen gelten, von denen die Generalisierung abstrahiert (denn das war ja die Bedingung für die Konstruktion der Generalisierung), müssen diese Klassen die Eigenschaften nicht wiederholen, sondern nur auf ihre Generalisierung verweisen. Diese Klassen müssen dann nur noch die Unterschiede definieren, die sie von der Klasse Zweibeiner sowie voneinander unterscheiden.","Was ist die Aufgabe der Klassen, die von einer Generalisierung abstrahiert?","Die Aufgabe der Klassen, die von einer Generalisierung abstrahiert, ist es, nur noch die Unterschiede zu definieren, die sie von der Generalisierung und voneinander unterscheiden. Sie müssen nicht die Eigenschaften wiederholen, die der Generalisierung zugeordnet sind, da diese per Definition automatisch auch für sie gelten."
"Diese zweite Form der Abstraktion, die Generalisierung, ist also genau wie die Klassifikation Bestandteil der klassenbasierten objektorientierten Programmierung. Anders als bei der Klassifikation ist bei der Generalisierung jedoch die Höhe der Abstraktionshierarchie nicht durch praktische Überlegungen beschränkt, sondern kann von der Programmiererin nach Belieben festgelegt werden. Sprachphilosophisch betrachtet sind Generalisierungen ebenfalls Allgemeinbegriffe, nur noch allgemeiner. Generalisierungen können selbst wiederum Generalisierungen haben, und so weiter. Wie es für eine Abstraktionshierarchie typisch ist, werden die Definitionen, die Intensionen, dabei immer präziser. Gleichzeitig wächst jedoch die Extension (das bereits in Abschnitt 7.1 erwähnte Prinzip vom inversen Zusammenhang der beiden).",Was ist Generalisierung in der objektorientierten Programmierung?,"Generalisierung ist eine Form der Abstraktion in der objektorientierten Programmierung, die Bestandteil der klassenbasierten objektorientierten Programmierung ist. Im Gegensatz zur Klassifikation ist bei der Generalisierung die Höhe der Abstraktionshierarchie nicht beschränkt und kann von der Programmiererin festgelegt werden. Generalisierungen können selbst wiederum Generalisierungen haben, wodurch eine Abstraktionshierarchie entsteht."
"Diese zweite Form der Abstraktion, die Generalisierung, ist also genau wie die Klassifikation Bestandteil der klassenbasierten objektorientierten Programmierung. Anders als bei der Klassifikation ist bei der Generalisierung jedoch die Höhe der Abstraktionshierarchie nicht durch praktische Überlegungen beschränkt, sondern kann von der Programmiererin nach Belieben festgelegt werden. Sprachphilosophisch betrachtet sind Generalisierungen ebenfalls Allgemeinbegriffe, nur noch allgemeiner. Generalisierungen können selbst wiederum Generalisierungen haben, und so weiter. Wie es für eine Abstraktionshierarchie typisch ist, werden die Definitionen, die Intensionen, dabei immer präziser. Gleichzeitig wächst jedoch die Extension (das bereits in Abschnitt 7.1 erwähnte Prinzip vom inversen Zusammenhang der beiden).",Was ist der Unterschied zwischen Generalisierung und Klassifikation in der objektorientierten Programmierung?,"Im Gegensatz zur Klassifikation, die durch praktische Überlegungen beschränkt ist, kann die Höhe der Abstraktionshierarchie bei der Generalisierung von der Programmiererin nach Belieben festgelegt werden. Sprachphilosophisch betrachtet sind Generalisierungen ebenfalls Allgemeinbegriffe, nur noch allgemeiner. Generalisierungen können selbst wiederum Generalisierungen haben, und so weiter. Wie es für eine Abstraktionshierarchie typisch ist, werden die Definitionen, die Intensionen, dabei immer präziser. Gleichzeitig wächst jedoch die Extension (das bereits in Abschnitt 7.1 erwähnte Prinzip vom inversen Zusammenhang der beiden)."
"Übrigens stammt das Prinzip der Generalisierung von Aristoteles' Prinzip von Genus et differentia ab, das gemeinsame Abstammung und Unterschiede betrifft. Das Genus ist die nächst allgemeinere Kategorie, unter die die Objekte der zu generalisierenden Klassen (der Spezies) fallen, und die Differentia sind die Kriterien, anhand derer sich die Objekte aufgrund ihrer Natur unterscheiden, wie sie in den verschiedenen Klassendefinitionen festgelegt sind (und nicht etwa durch spezielle Werte von Instanzvariablen). So haben die Klassen Mensch und Vogel beispielsweise das gemeinsame Genus Zweibeiner als (biologisch nicht ganz korrekte) Generalisierung, in der festgelegt ist, dass alle Exemplare von Zweibeinern (und damit auch von Menschen und Vögeln) ein linkes und ein rechtes Bein sowie einen Aufenthaltsort haben. Die Unterschiede (Differentia) sind dann in den jeweiligen Klassen ausgearbeitet. Beachten Sie, dass Genera keine eigenen Individuen haben, das heißt, es gibt keine Zweibeiner, die nicht entweder Mensch oder Vogel sind.",Was ist das Prinzip der Generalisierung?,"Das Prinzip der Generalisierung ist ein Konzept, das auf Aristoteles' Prinzip von Genus et differentia zurückgeht. Dabei werden gemeinsame Abstammungen und Unterschiede betrachtet. Das Genus ist die nächst allgemeinere Kategorie, unter die die Objekte der zu generalisierenden Klassen (der Spezies) fallen. Die Differentia sind die Kriterien, anhand derer sich die Objekte aufgrund ihrer Natur unterscheiden, wie sie in den verschiedenen Klassendefinitionen festgelegt sind. Genera haben keine eigenen Individuen, das heißt, es gibt keine Zweibeiner, die nicht entweder Mensch oder Vogel sind."
"Wie die Klassifikation hat auch das Ordnungsprinzip der Generalisierung eine einfache mengentheoretische Interpretation. Demnach enthält die Menge der Instanzen einer Generalisierung alle Instanzen der Klassen, von denen sie eine Generalisierung ist. Wenn also Mensch und Vogel Ausgangsklassen einer Generalisierung namens Zweibeiner sind, dann ist die Menge der Instanzen, die Zweibeiner repräsentiert (für die Zweibeiner den Allgemeinbegriff bereitstellen), eine Obermenge der Vereinigung der Menge der Instanzen von Mensch und Vogel. Die Menge der Instanzen von Zweibeiner ist eine echte Obermenge, wenn Zweibeiner auch eigene Instanzen haben (also Instanzen, die nicht Instanzen von Mensch und Vogel sind; im Kontext der Instanziierung spricht man von direkten Instanzen; siehe Abschnitt 7.3). Andernfalls ist sie nur eine unechte Obermenge (genau gleich der Vereinigung). Die folgende Grafik zeigt diese Beziehung (wobei schwarze Punkte die Instanzen und Ellipsen die Klassen darstellen sollen).",Wie wird das Ordnungsprinzip der Generalisierung in der Mengenlehre interpretiert?,"Das Ordnungsprinzip der Generalisierung wird in der Mengenlehre interpretiert, indem die Menge der Instanzen einer Generalisierung alle Instanzen der Klassen enthält, von denen sie eine Generalisierung ist. Wenn also Mensch und Vogel Ausgangsklassen einer Generalisierung namens Zweibeiner sind, dann ist die Menge der Instanzen, die Zweibeiner repräsentiert, eine Obermenge der Vereinigung der Menge der Instanzen von Mensch und Vogel."
"Wie die Klassifikation hat auch das Ordnungsprinzip der Generalisierung eine einfache mengentheoretische Interpretation. Demnach enthält die Menge der Instanzen einer Generalisierung alle Instanzen der Klassen, von denen sie eine Generalisierung ist. Wenn also Mensch und Vogel Ausgangsklassen einer Generalisierung namens Zweibeiner sind, dann ist die Menge der Instanzen, die Zweibeiner repräsentiert (für die Zweibeiner den Allgemeinbegriff bereitstellen), eine Obermenge der Vereinigung der Menge der Instanzen von Mensch und Vogel. Die Menge der Instanzen von Zweibeiner ist eine echte Obermenge, wenn Zweibeiner auch eigene Instanzen haben (also Instanzen, die nicht Instanzen von Mensch und Vogel sind; im Kontext der Instanziierung spricht man von direkten Instanzen; siehe Abschnitt 7.3). Andernfalls ist sie nur eine unechte Obermenge (genau gleich der Vereinigung). Die folgende Grafik zeigt diese Beziehung (wobei schwarze Punkte die Instanzen und Ellipsen die Klassen darstellen sollen).",Was ist Generalisierung in der objektorientierten Programmierung?,"In der objektorientierten Programmierung ist Generalisierung ein Ordnungsprinzip, bei dem eine Klasse eine Obermenge von Instanzen enthält, die auch Instanzen von anderen Klassen sind. Zum Beispiel ist die Klasse Zweibeiner eine Obermenge von Instanzen, die auch Instanzen von Mensch und Vogel sind."
"In der Praxis ist es gute Praxis (wie bereits angedeutet), wenn Generalisierungen keine eigenen, direkten Instanzen haben, sondern Genera im oben beschriebenen Sinne sind. Dies ist jedoch in der objektorientierten Praxis (leider) nicht immer selbstverständlich, wie sich im nächsten Kapitel noch zeigen wird (siehe auch Kapitel 69 in Kurseinheit 7).",Was ist der Unterschied zwischen Generalisierungen und Genera in der objektorientierten Praxis?,"Generalisierungen sollten idealerweise keine eigenen, direkten Instanzen haben, sondern Genera sein, die keine direkten Instanzen haben. In der Praxis ist es jedoch nicht immer selbstverständlich, diese Empfehlung einzuhalten."
"In der Praxis ist es gute Praxis (wie bereits angedeutet), wenn Generalisierungen keine eigenen, direkten Instanzen haben, sondern Genera im oben beschriebenen Sinne sind. Dies ist jedoch in der objektorientierten Praxis (leider) nicht immer selbstverständlich, wie sich im nächsten Kapitel noch zeigen wird (siehe auch Kapitel 69 in Kurseinheit 7).",Was sind Genera in der objektorientierten Praxis?,"Genera sind in der objektorientierten Praxis Generalisierungen, die keine eigenen, direkten Instanzen haben, sondern als abstrakte Objekte fungieren, die von konkreteren Klassen geerbt werden."
"Die mengentheoretische Interpretation der Generalisierung als Obermengenbildung legt nahe, dass Instanzen von Mensch und Vogel (als Elemente der entsprechenden Extensionen) auch Instanzen von Zweibeiner sind. Wenn man das so betrachten möchte, sollte man jedoch zur notwendigen Unterscheidung von indirekten Instanzen (anstelle von direkten Instanzen; siehe Abschnitt 7.3) sprechen.",Was ist die mengentheoretische Interpretation der Generalisierung?,"Die mengentheoretische Interpretation der Generalisierung als Obermengenbildung legt nahe, dass Instanzen von Mensch und Vogel (als Elemente der entsprechenden Extensionen) auch Instanzen von Zweibeiner sind."
"Die mengentheoretische Interpretation der Generalisierung als Obermengenbildung legt nahe, dass Instanzen von Mensch und Vogel (als Elemente der entsprechenden Extensionen) auch Instanzen von Zweibeiner sind. Wenn man das so betrachten möchte, sollte man jedoch zur notwendigen Unterscheidung von indirekten Instanzen (anstelle von direkten Instanzen; siehe Abschnitt 7.3) sprechen.",Was ist der Unterschied zwischen direkten und indirekten Instanzen?,"Direkte Instanzen sind Elemente der Extension einer Klasse, während indirekte Instanzen Elemente der Extension einer Unterklasse sind, die nicht direkt der Oberklasse zugeordnet ist."
"Die mengentheoretische Interpretation der Generalisierung als Obermengenbildung legt nahe, dass Instanzen von Mensch und Vogel (als Elemente der entsprechenden Extensionen) auch Instanzen von Zweibeiner sind. Wenn man das so betrachten möchte, sollte man jedoch zur notwendigen Unterscheidung von indirekten Instanzen (anstelle von direkten Instanzen; siehe Abschnitt 7.3) sprechen.",Was ist die Konsequenz der mengentheoretischen Interpretation der Generalisierung?,"Die Konsequenz der mengentheoretischen Interpretation der Generalisierung ist, dass Instanzen von Mensch und Vogel (als Elemente der entsprechenden Extensionen) auch Instanzen von Zweibeiner sind."
"Bei der Generalisierung können also Eigenschaften, die verschiedene, aber ähnliche Klassen unterscheiden, weggelassen (oder ""abstrahiert"") werden. Das Weglassen ist jedoch nicht die einzige Form der Generalisierung. Es können auch Eigenschaften generalisiert werden, wobei dann der Begriff der Generalisierung rekursiv angewendet wird. Unter der Generalisierung von Attributen (oder allgemeiner von Instanzvariablen; siehe Abschnitt 2.4) versteht man, dass ihr Wertebereich von einem spezielleren (kleineren) zu einem allgemeineren (größeren) erweitert wird. Zum Beispiel würde das Attribut ""Aufenthaltsort,"" das mit (Instanzen der) Klasse Mensch assoziiert ist, bei der Generalisierung zu Zweibeiner von Punkten auf der Erdoberfläche zu Punkten einschließlich des Luftraums darüber generalisiert, um auch den Wertebereich für Vögel abzudecken. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen. Wie Sie später sehen werden, erlauben die meisten Programmiersprachen, die die Möglichkeit der Wertebeschränkung von Variablen bieten, aus guten Gründen nicht, Attributwertebereiche bei der Generalisierung ebenfalls zu generalisieren (die sogenannte kovariante Redefinition; siehe dazu auch die Kapitel 25 und Abschnitt 26.3 in Kurseinheit 3).",Was ist Generalisierung in der objektorientierten Programmierung?,"In der Objektorientierten Programmierung ist Generalisierung ein Prozess, bei dem Eigenschaften, die verschiedene, aber ähnliche Klassen unterscheiden, weggelassen oder abstrahiert werden. Dies kann auch rekursiv angewendet werden, indem der Begriff der Generalisierung auf Attribute oder Instanzvariablen angewendet wird, wodurch ihr Wertebereich von einem spezielleren auf ein allgemeineres erweitert wird. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen."
"Bei der Generalisierung können also Eigenschaften, die verschiedene, aber ähnliche Klassen unterscheiden, weggelassen (oder ""abstrahiert"") werden. Das Weglassen ist jedoch nicht die einzige Form der Generalisierung. Es können auch Eigenschaften generalisiert werden, wobei dann der Begriff der Generalisierung rekursiv angewendet wird. Unter der Generalisierung von Attributen (oder allgemeiner von Instanzvariablen; siehe Abschnitt 2.4) versteht man, dass ihr Wertebereich von einem spezielleren (kleineren) zu einem allgemeineren (größeren) erweitert wird. Zum Beispiel würde das Attribut ""Aufenthaltsort,"" das mit (Instanzen der) Klasse Mensch assoziiert ist, bei der Generalisierung zu Zweibeiner von Punkten auf der Erdoberfläche zu Punkten einschließlich des Luftraums darüber generalisiert, um auch den Wertebereich für Vögel abzudecken. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen. Wie Sie später sehen werden, erlauben die meisten Programmiersprachen, die die Möglichkeit der Wertebeschränkung von Variablen bieten, aus guten Gründen nicht, Attributwertebereiche bei der Generalisierung ebenfalls zu generalisieren (die sogenannte kovariante Redefinition; siehe dazu auch die Kapitel 25 und Abschnitt 26.3 in Kurseinheit 3).",Was ist Generalisierung bei Attributen?,"Bei der Generalisierung von Attributen wird ihr Wertebereich von einem spezielleren (kleineren) zu einem allgemeineren (größeren) erweitert. Zum Beispiel würde das Attribut ""Aufenthaltsort"" bei der Generalisierung von Mensch zu Zweibeiner von Punkten auf der Erdoberfläche zu Punkten einschließlich des Luftraums darüber generalisiert. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen."
"Obwohl bisher so getan wurde, als ob die Generalisierung eine inhärente Eigenschaft des betrachteten Objekts sei, gibt es in der Praxis oft verschiedene Perspektiven, nach denen Generalisierungen durchgeführt werden können. Die Generalisierung von Vogel und Mensch zu Zweibeiner ist also nicht die einzige (und sicherlich nicht die einzige sinnvolle) Möglichkeit. Es könnte durchaus mehrere unabhängige Generalisierungshierarchien geben, in denen dieselben Klassen auftreten. In der Praxis führt dies jedoch dazu, dass die strenge Hierarchieform der Generalisierung verloren geht (da sich mehrere Hierarchien überlappen), es sei denn, es wird erlaubt, verschiedene Arten der Generalisierung voneinander zu unterscheiden. Beide Ansätze bringen jedoch Komplikationen mit sich, daher werden wir hier nicht auf ""mehrfache Generalisierungen"" eingehen.",Was ist eine Generalisierungshierarchie?,"Eine Generalisierungshierarchie ist eine hierarchische Struktur, in der Klassen nach ihrer Allgemeinheit geordnet sind. Dabei gilt, dass eine allgemeinere Klasse eine speziellere Klasse als Unterklasse enthält. Die Generalisierungshierarchie ist eine wichtige Konzept in der objektorientierten Programmierung, da sie die Beziehung zwischen Klassen und Objekten definiert."
"Obwohl bisher so getan wurde, als ob die Generalisierung eine inhärente Eigenschaft des betrachteten Objekts sei, gibt es in der Praxis oft verschiedene Perspektiven, nach denen Generalisierungen durchgeführt werden können. Die Generalisierung von Vogel und Mensch zu Zweibeiner ist also nicht die einzige (und sicherlich nicht die einzige sinnvolle) Möglichkeit. Es könnte durchaus mehrere unabhängige Generalisierungshierarchien geben, in denen dieselben Klassen auftreten. In der Praxis führt dies jedoch dazu, dass die strenge Hierarchieform der Generalisierung verloren geht (da sich mehrere Hierarchien überlappen), es sei denn, es wird erlaubt, verschiedene Arten der Generalisierung voneinander zu unterscheiden. Beide Ansätze bringen jedoch Komplikationen mit sich, daher werden wir hier nicht auf ""mehrfache Generalisierungen"" eingehen.","Warum gibt es in der Praxis oft verschiedene Perspektiven, nach denen Generalisierungen durchgeführt werden können?","In der Praxis gibt es oft verschiedene Perspektiven, nach denen Generalisierungen durchgeführt werden können, da die Generalisierung nicht immer eindeutig ist und es verschiedene Möglichkeiten gibt, Klassen zu gruppieren und zu organisieren. Zum Beispiel kann man Vogel und Mensch als Zweibeiner gruppieren, aber man könnte sie auch als Flugtiere und Landtiere gruppieren. Beide Gruppierungen sind gültig und können je nach Kontext sinnvoll sein."
"Bis Java 1.4 waren class, interface und [] (Array) die einzigen Typkonstruktoren; mit Java 1.5 ist auch enum für Aufzählungstypen hinzugekommen, wobei diese unter die Klassentypen fallen: Neben der Angabe der Elemente der Aufzählung kann man auch Felder und Methoden angeben, die auf ihnen definiert sind. Damit werden die Elemente einer Aufzählung gewissermaßen zu Konstanten, also zu lebenslang gültigen Namen für Objekte einer Klasse, die den Aufzählungstyp repräsentiert.",Was sind Aufzählungstypen in Java?,"Aufzählungstypen in Java sind mit Java 1.5 hinzugekommen und stellen eine Unterart der Klassentypen dar. Sie werden mit dem Schlüsselwort enum definiert und können Elemente, Felder und Methoden enthalten. Die Elemente einer Aufzählung werden zu Konstanten, also zu lebenslang gültigen Namen für Objekte einer Klasse, die den Aufzählungstyp repräsentiert."
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden.",Was bezeichnet eine Variable?,Eine Variable bezeichnet ein Objekt.
"Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.",Wie wird der Zugriff auf Variablen einzuschränken?,"Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen."
"Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.",Was ist die Sichtbarkeit einer Variable?,"Die Sichtbarkeit einer Variable bezieht sich immer auf einen Abschnitt des Programmcodes, in dem der Variablenname verwendet werden kann und damit Zugriff auf das von diesem Namen bezeichnete Objekt besteht."
"Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".",Was ist der Unterschiede zwischen globalen und lokalen Variablen?,"Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht. Globale Variablen sind auch außerhalb davon von überall her sichtbar."
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.",Was ist Runtime Type Information (RTTI) in C++?,"RTTI ist eine Bibliotheksfunktion in C++, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören."
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.",Wie wird RTTI in C++ implementiert?,"RTTI wird in C++ durch einen Zeiger auf die Sprungtabelle der virtuellen Methoden implementiert, der für alle Objekte einer Klasse gleich ist und somit als eine Art Repräsentation der Klasse angesehen werden kann."
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.",Wozu wird RTTI in C++ verwendet?,"RTTI wird in C++ verwendet, um die Klasse eines Objekts zur Laufzeit zu bestimmen, wenn dies zur Laufzeit erforderlich ist."
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.",Wann ist die Verwendung von RTTI in C++ sinnvoll?,"Die Verwendung von RTTI in C++ ist sinnvoll, wenn die Klasse eines Objekts zur Laufzeit bestimmt werden muss, um beispielsweise eine geeignete Methode für die Ausführung auszuwählen."
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.",Ist RTTI in C++ immer verfügbar?,"Nein, RTTI ist in C++ nicht immer verfügbar, da es nur für Objekte mit dynamisch gebundenen Methoden zur Verfügung steht."
"Konkret kann RTTI folgendermaßen genutzt werden: Es gibt eine Funktion namens typeid, die auf einer Referenz aufgerufen werden kann. Da diese Funktion auf Klassennamen überladen ist und eine Struktur zurückgibt, auf der == als Gleichheitstest definiert ist, kann der Typ eines Objekts ermittelt werden. Eine weitere nützliche Funktion, die RTTI verwendet, ist dynamic_cast<T>(x). Diese Funktion nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt, andernfalls gibt sie 0 zurück.",Was ist RTTI und wie kann es genutzt werden?,"RTTI (Runtime Type Information) ist eine Funktion, die auf einer Referenz aufgerufen werden kann, um den Typ eines Objekts zu ermitteln. In diesem Fall gibt es eine Funktion namens typeid, die auf einer Referenz aufgerufen werden kann, um den Klassennamen des Objekts zu ermitteln. Diese Funktion ist überladen und gibt eine Struktur zurück, auf der == als Gleichheitstest definiert ist."
"Konkret kann RTTI folgendermaßen genutzt werden: Es gibt eine Funktion namens typeid, die auf einer Referenz aufgerufen werden kann. Da diese Funktion auf Klassennamen überladen ist und eine Struktur zurückgibt, auf der == als Gleichheitstest definiert ist, kann der Typ eines Objekts ermittelt werden. Eine weitere nützliche Funktion, die RTTI verwendet, ist dynamic_cast<T>(x). Diese Funktion nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt, andernfalls gibt sie 0 zurück.","Was passiert, wenn ein Objekt eine Nachricht erhält, die es nicht versteht?","Wenn ein Objekt eine Nachricht erhält, die es nicht versteht, wird eine Methode Not a Understand aufgerufen, die eine Fehlermeldung ausgeben kann."
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".",Wozu dient die liberale Zuweisungskompatibilität bei generischen Typen?,"Die liberale Zuweisungskompatibilität bei generischen Typen ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel kann so eine Methode ""sort"" mit Objekten verschiedener Instanzen von ""ArrayList<E>"" aufgerufen werden, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>""."
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".","Warum ist es sinnvoll, für generische Typen eine liberalere Form der Zuweisungskompatibilität zuzulassen?","Es ist sinnvoll, weil es so möglich ist, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel kann so eine Methode ""sort"" mit Objekten verschiedener Instanzen von ""ArrayList<E>"" aufgerufen werden, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>""."
"Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?","Wie kann man die Zuweisungskompatibilität zwischen ""ArrayList<Integer>"" und ""ArrayList<Comparable<Integer>>"" herstellen?","Die Zuweisungskompatibilität zwischen ""ArrayList<Integer>"" und ""ArrayList<Comparable<Integer>>"" kann durch die Verwendung des Upper-Bounded Wildcards hergestellt werden. Dazu wird der generische Typ mit einem Fragezeichen und dem Upper-Bound (in diesem Fall ""Comparable<Integer>"") angegeben, was bedeutet, dass der generische Typ jede Klasse sein kann, die ein Subtyp von ""Comparable<Integer>"" ist. Somit ist ""Integer"" ein Subtyp von ""Comparable<Integer>"" und die Zuweisungskompatibilität wird hergestellt."
"Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?","Was ist die Lösung für das Problem der fehlenden Zuweisungskompatibilität zwischen ""ArrayList<Integer>"" und ""ArrayList<Comparable>""?","Die Lösung für das Problem der fehlenden Zuweisungskompatibilität zwischen ""ArrayList<Integer>"" und ""ArrayList<Comparable>"" ist die Verwendung von Generics. Generics ermöglichen es, den Typ der Elemente in einer ArrayList bei der Erstellung der ArrayList anzugeben. Dadurch wird sichergestellt, dass nur Elemente des angegebenen Typs in die ArrayList aufgenommen werden können. Wenn man also eine ArrayList<Integer> erstellt, kann man nicht versehentlich eine ArrayList<String> zuweisen, und umgekehrt."
"In Java wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel.",Was sind Typ-Wildcards in Java?,"Typ-Wildcards, auch als Typ-Joker oder Platzhalter bezeichnet, sind ein Konzept in Java, das eingeführt wurde, um das Problem der Instanziierung eines generischen Typs mit einem beliebigen Typ zu lösen. Sie können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel."
"Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C-Sharp existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).",Was ist der Unterschied zwischen Use-site-Variance und Declaration-site-Variance?,"Use-site-Variance bedeutet, dass Wildcards bei der Verwendung an der Stelle definiert werden, an der sie benötigt werden, während Declaration-site-Variance bedeutet, dass Wildcards an der Stelle definiert werden, an der sie erklärt werden, wie beispielsweise in C-Sharp."
"Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C-Sharp existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).",Was sind Wildcards und wie werden sie definiert?,"Wildcards sind Platzhalter, die anstelle eines bestimmten Typs verwendet werden können. Im Gegensatz zu Typvariablen werden Wildcards bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance."
"List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie ""List<?>"" und ""ArrayList<?>"", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt. Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen, da nicht sichergestellt werden kann, dass ""list"" tatsächlich auf ein Objekt vom Typ ""List<Integer>"" verweist. Die einzige gültige Zuweisung an Elemente von ""list"" ist die von ""null"". Umgekehrt kann beim Lesen der Elemente aus ""list"" kein anderer Typ als ""Object"" angenommen werden, da ""list"" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.",Was sind Wildcard-Typen in Java?,"Wildcard-Typen wie ""List<?>"" und ""ArrayList<?>"" sind abstrakt und haben keine direkten Instanzen. Das Fragezeichen selbst ist kein Typ oder eine Typvariable."
"Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.",Was sind per extends beschränkte Typ-Wildcards?,"Per extends beschränkte Typ-Wildcards erlauben eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird."
"Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.",Was erlauben per extends beschränkte Typ-Wildcards?,"Per extends beschränkte Typ-Wildcards erlauben eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt)."
"Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.",Was ist umgekehrtes Subtyping?,"Umgekehrtes Subtyping ist eine Art des Subtypings, bei der nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf."
"""List<? super Integer>"" ist also ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.","Was ist der Supertyp ""List<? super Integer>"" in Java?","""List<? super Integer>"" ist ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist."
"Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.","Was bedeutet es, wenn man sagt, dass das Subtyping mit ""extends"" beschränkter Wildcard-Typen kovariant ist?","Das Subtyping mit ""extends"" beschränkter Wildcard-Typen ist kovariant, das heißt, wenn ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>""."
"Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.","Was bedeutet es, wenn man sagt, dass das Subtyping mit ""super"" beschränkter Wildcard-Typen kontravariant ist?","Das Subtyping mit ""super"" beschränkter Wildcard-Typen ist kontravariant, das heißt, ""List<? super Integer>"" ist ein Supertyp von ""List<? super Number>"", wenn ""Integer"" ein Subtyp von ""Number"" ist."
"Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.",Wie hängen die Subtyp-Beziehungen von generischen Typen mit Typ-Wildcards zusammen?,"Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant."
"Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.",Was bedeutet kovarianter Subtyping von Wildcard-Typen?,"Kovarianter Subtyping von Wildcard-Typen bedeutet, dass wenn ein Typ S ein Subtyp von T ist, dann ist auch der mit ""extends"" nach oben beschränkte Wildcard-Typ ""List<? extends S>"" ein Subtyp von ""List<? extends T>"""
"In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert ""nil"". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet.",Was ist die Funktion von Konstruktoren in SMALLTALK?,"Konstruktoren in SMALLTALK sind Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert ""nil"". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet."
"In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert ""nil"". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet.",Was ist der Unterschied zwischen Konstruktoren und Initialisierung in Smalltalk?,"In Smalltalk sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert ""nil"". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet. Somit ist der Unterschied, dass Konstruktor ein Klassenmethode ist, die eine neue Instanz erzeugt, während Initialisierung ein Vorgang ist, bei dem Instanzvariablen sinnvolle Anfangswerte zugewiesen bekommen."
"Es ist jedoch nicht immer erforderlich, alle Instanzen einer Klasse auf die gleiche Weise zu initialisieren. Daher ist es möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu definieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die Klasse ""Time"" sind unten gegeben, wobei beide die Klassenmethode ""seconds:"" auf ""Time"" aufrufen (repräsentiert durch ""self""), die wiederum mit ""basicNew"" eine Instanz von ""Time"" erzeugt und anschließend initialisiert.",Was sind alternative Konstruktoren in der objektorientierten Programmierung?,"Alternative Konstruktoren sind Klassenmethoden, die die neuen Objekte einer Klasse jeweils unterschiedlich initialisieren. Sie ermöglichen es, Instanzen einer Klasse auf verschiedene Weise zu initialisieren."
"Es ist jedoch nicht immer erforderlich, alle Instanzen einer Klasse auf die gleiche Weise zu initialisieren. Daher ist es möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu definieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die Klasse ""Time"" sind unten gegeben, wobei beide die Klassenmethode ""seconds:"" auf ""Time"" aufrufen (repräsentiert durch ""self""), die wiederum mit ""basicNew"" eine Instanz von ""Time"" erzeugt und anschließend initialisiert.",Was ist der Zweck von Konstruktoren in der objektorientierten Programmierung?,"Konstruktoren sind spezielle Methoden in der objektorientierten Programmierung, die verwendet werden, um neue Objekte einer Klasse zu initialisieren. Sie werden aufgerufen, wenn ein neues Objekt erstellt wird und werden verwendet, um die Anfangswerte der Attribute des Objekts festzulegen. In dem gegebenen Beispiel, werden zwei alternative Konstruktoren für die Klasse ""Time"" definiert, die die neuen Objekte jeweils unterschiedlich initialisieren."
"Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar sind, kann auch eine Klassenmethode wie ""new"" nicht auf sie zugreifen. Die Initialisierung muss daher von Instanzmethoden wie ""ticks:"" durchgeführt werden, die jedoch nicht ausschließlich der Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen werden können. Dies kann problematisch sein, wenn Instanzvariablen initialisiert werden müssen, deren Existenz nach außen verborgen werden soll. Aus diesem Grund sehen ""new"" und ""new:"" standardmäßig den Aufruf der Methode ""initialize"" vor (siehe Zeilen 307 und 309 oben), in der alle Initialisierungen vorgenommen werden können, ohne dass etwas über den Aufbau der Instanzen nach außen verraten würde.","Wozu dient die Methode ""initialize"" in diesem Kontext?","Die Methode ""initialize"" dient dazu, Initialisierungen von Instanzvariablen durchzuführen, ohne dass etwas über den Aufbau der Instanzen nach außen verraten wird. Diese Methode wird standardmäßig von ""new"" und ""new:"" aufgerufen."
"Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar sind, kann auch eine Klassenmethode wie ""new"" nicht auf sie zugreifen. Die Initialisierung muss daher von Instanzmethoden wie ""ticks:"" durchgeführt werden, die jedoch nicht ausschließlich der Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen werden können. Dies kann problematisch sein, wenn Instanzvariablen initialisiert werden müssen, deren Existenz nach außen verborgen werden soll. Aus diesem Grund sehen ""new"" und ""new:"" standardmäßig den Aufruf der Methode ""initialize"" vor (siehe Zeilen 307 und 309 oben), in der alle Initialisierungen vorgenommen werden können, ohne dass etwas über den Aufbau der Instanzen nach außen verraten würde.",Wie können Instanzvariablen in einer Klasse initialisiert werden?,"Instanzvariablen können in einer Klasse durch den Aufruf der Methode ""initialize"" initialisiert werden, die standardmäßig von den Methoden ""new"" und ""new:"" aufgerufen wird."
"Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar sind, kann auch eine Klassenmethode wie ""new"" nicht auf sie zugreifen. Die Initialisierung muss daher von Instanzmethoden wie ""ticks:"" durchgeführt werden, die jedoch nicht ausschließlich der Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen werden können. Dies kann problematisch sein, wenn Instanzvariablen initialisiert werden müssen, deren Existenz nach außen verborgen werden soll. Aus diesem Grund sehen ""new"" und ""new:"" standardmäßig den Aufruf der Methode ""initialize"" vor (siehe Zeilen 307 und 309 oben), in der alle Initialisierungen vorgenommen werden können, ohne dass etwas über den Aufbau der Instanzen nach außen verraten würde.",Wie wird die Initialisierung von Instanzvariablen in Smalltalk durchgeführt?,"In Smalltalk wird die Initialisierung von Instanzvariablen durchgeführt, indem die Methode ""initialize"" aufgerufen wird, die standardmäßig von den Methoden ""new"" und ""new:"" vorgesehen ist. Diese Methode kann alle Initialisierungen vornehmen, ohne dass etwas über den Aufbau der Instanzen nach außen verraten wird."
"In anderen Sprachen wie C++, Java oder C-Sharp sind Konstruktoren daher auch keine Klassenmethoden, sondern haben eine Art Zwitterstatus: Sie werden auf einer Klasse aufgerufen, aber sie werden wie Instanzmethoden auf der neuen Instanz ausgeführt und können somit auf die Instanzvariablen der neu erzeugten Instanz zugreifen. Beachten Sie jedoch, dass die Methode ""ticks:"" keine Informationen über die Implementierung der Instanzvariablen der Klasse ""Time"" preisgibt.","Was ist der Unterschied zwischen Konstruktoren in SMALLTALK und Konstruktoren in Sprachen wie C++, Java oder C-Sharp?","In SMALLTALK sind Konstruktoren Klassenmethoden, während sie in Sprachen wie C++, Java oder C-Sharp eine Art Zwitterstatus haben und sowohl auf der Klasse als auch auf der neuen Instanz aufgerufen werden können. SMALLTALK-Konstruktoren können nicht auf die Instanzvariablen der neu erzeugten Instanz zugreifen, während Konstruktoren in C++, Java oder C-Sharp dies können."
"Alternativ zur obigen Konstruktion kann die Initialisierung von Instanzvariablen auch zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt werden. Dies wird als ""Lazy initialization"" bezeichnet, da die Initialisierung solange wie möglich verschoben wird. Bei der Verwendung von Lazy initialization muss jedoch vor jedem lesebasierten Zugriff auf die (faul initialisierte) Instanzvariable überprüft werden, ob ihr Wert immer noch ""nil"" ist. Wenn dies der Fall ist, muss er durch den gewünschten Anfangswert ersetzt werden, der normalerweise in der Standardinitialisierungsmethode zu finden wäre. Um das Hinzufügen von Abfragen bei jedem lesebasierten Zugriff auf die Variable im Programm zu vermeiden, empfiehlt es sich, bei der Verwendung von Lazy initialization alle Zugriffe auf Instanzvariablen, einschließlich interner Klassenzugriffe, über entsprechende Getter-Methoden durchzuführen. Diese Getter-Methoden prüfen den Inhalt der Variable, bevor sie ihn zurückgeben, und setzen ihn gegebenenfalls. Die Lazy initialization erfordert zusätzlichen Code, der bei einer Standardinitialisierung nicht erforderlich wäre. Das laufende Programm spart jedoch den Preis der Initialisierung, wenn diese nie notwendig wird, d.h., wenn der Wert der zu initialisierenden Variable im Programmablauf nie oder erst nach einer anderen Zuweisung abgefragt wird. Lazy initialization lohnt sich daher immer dann, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Ein weiterer Vorteil der Lazy initialization besteht darin, dass die Initialisierung nie vergessen werden kann. Dies ist insbesondere dann wertvoll, wenn die Initialisierung nicht wie oben beschrieben vom Konstruktor selbst, sondern von einer separaten Methode durchgeführt wird und die Benutzer der entsprechenden Klasse möglicherweise nicht klar ist, dass sie nach dem Konstruktor auch noch die Initialisierungsmethode aufrufen müssen. Konstruktoren, die wie in Zeilen 307 und 309 oben implementiert wurden, versuchen dies zu verhindern, indem sie die Initialisierungsmethode selbst aufrufen. Manchmal kann der Konstruktor jedoch nicht einfach geändert werden, und es wird nicht verhindert, dass ""basicNew"" direkt und ohne ""initialize"" aufgerufen wird.","Was ist ""Lazy initialization"" und wann wird sie angewendet?","""Lazy initialization"" ist eine Technik, bei der die Initialisierung von Instanzvariablen zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt wird. Sie wird angewendet, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Dadurch wird verhindert, dass die Initialisierung vergessen wird und der Preis der Initialisierung gespart, wenn sie nie notwendig wird."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C-Sharp, syntaktisch die Form von Variablen an:",Wie werden auf Attribute in EIFFEL zugegriffen?,"In EIFFEL werden auf Attribute über Zugriffsmethoden zugegriffen, die syntaktisch wie Variablen aussehen. Um das Attribut a eines Objekts x zu ändern, wird ein Zuweisungsausdruck verwendet: x.a := b."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C-Sharp, syntaktisch die Form von Variablen an:",Wozu dienen Zugriffsmethoden in EIFFEL?,"Zugriffsmethoden in EIFFEL dienen dazu, auf die privaten Instanzvariablen oder Felder einer Klasse von außen zugreifen zu können. Sie nehmen syntaktisch die Form von Variablen an, sodass der Code, der auf die Instanzvariablen zugreift, lesbarer und einfacher zu verstehen ist. Diese Zugriffsmethoden werden vom System automatisch bereitgestellt."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C-Sharp, syntaktisch die Form von Variablen an:",Wie können in Eiffel auf Instanzvariablen zugegriffen werden?,"In Eiffel können auf Instanzvariablen, die als Attribute bezeichnet werden, nur über Zugriffsmethoden zugegriffen werden. Diese Zugriffsmethoden nehmen syntaktisch die Form von Variablen an, werden jedoch vom System automatisch bereitgestellt."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C-Sharp, syntaktisch die Form von Variablen an:",Was sind Zugriffsmethoden in Eiffel?,"Zugriffsmethoden in Eiffel sind Methoden, die vom System automatisch bereitgestellt werden, um auf Instanzvariablen zuzugreifen. Sie nehmen syntaktisch die Form von Variablen an, ermöglichen aber dennoch die Datenkapselung."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C-Sharp, syntaktisch die Form von Variablen an:",Warum werden in Eiffel Zugriffsmethoden verwendet?,"In Eiffel werden Zugriffsmethoden verwendet, um den Zugriff auf Instanzvariablen zu ermöglichen und gleichzeitig die Datenkapselung zu gewährleisten."
"Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).",Was ist eine Setter-Funktion?,"Eine Setter-Funktion ist eine Funktion, die mit einem Parameter aufgerufen wird und üblicherweise einen Wert setzt."
"Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).",Was ist eine Getter-Funktion?,"Eine Getter-Funktion ist eine Funktion, die einen Wert zurückgibt und üblicherweise mit einer Zuweisung an eine Variable verwendet wird."
"Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).",Was ist der Zweck eines Setters und Getters?,"Ein Setter ist eine Funktion, die mit einem Parameter aufgerufen wird und den Zustand eines Objekts ändert. Ein Getter ist eine Funktion, die aufgerufen wird, um einen Wert zurückzugeben, der mit einer y-Zuweisung kompatibel ist."
"Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).",Was sind Setter und Getter?,"Setter und Getter sind Funktionen, die den Zustand eines Objekts ändern oder abfragen. Ein Setter wird mit einem Parameter aufgerufen, um den Zustand des Objekts zu ändern, während ein Getter aufgerufen wird, um einen Wert zurückzugeben, der mit dem Zustand des Objekts kompatibel ist."
"Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C-Sharp. Beachten Sie, dass es in EIFFEL auch Indexer gibt.",Welche Aufgaben können Zugriffsmethoden in der Programmierung erfüllen?,"Zugriffsmethoden dienen normalerweise dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen, wie das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen oder das Anbieten etwas, das wie eine Instanzvariable aussieht, ohne sich auf eine tatsächliche Instanzvariable festzulegen."
"Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C-Sharp. Beachten Sie, dass es in EIFFEL auch Indexer gibt.",Was ermöglichen Zugriffsmethoden?,"Zugriffsmethoden ermöglichen das Setzen oder Lesen von Instanzvariablen, das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen, die Repräsentationsunabhängigkeit und das Anbieten von etwas, das wie eine Instanzvariable aussieht, ohne sich auf eine tatsächliche Instanzvariable festzulegen. Zudem gibt es in EIFFEL auch Indexer."
"Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.",Was ist der Unterschied zwischen Abfragen und Befehlen in EIFFEL?,"In EIFFEL werden Methoden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern."
"In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).",Was sind Features in EIFFEL?,In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet. Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL.
"In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).",Was sind die einzigen Elemente einer Klassendefinition in EIFFEL?,In EIFFEL sind Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet und die einzigen Elemente einer Klassendefinition.
"In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).",Gibt es in EIFFEL die Möglichkeit Klassendefinitionen zu schachteln?,"Nein, in EIFFEL gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen)."
"In EIFFEL gibt es keine Zugriffsmodifikatoren wie in Java/C-Sharp/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.",Wie ist die Zugriffsmodellierung in EIFFEL?,"In EIFFEL gibt es keine Zugriffsmodifikatoren wie in Java/C-Sharp/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt. Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis."
"In EIFFEL gibt es keine Zugriffsmodifikatoren wie in Java/C-Sharp/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.",Wie ist die Zugriffsebene von Features in EIFFEL festgelegt?,"In EIFFEL gibt es keine Zugriffsmodifikatoren wie in Java/C-Sharp/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt. Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis."
"In EIFFEL gibt es keine Zugriffsmodifikatoren wie in Java/C-Sharp/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.",Wie wird der Zustand eines Objekts in EIFFEL gekapselt?,"In EIFFEL wird der Zustand eines Objekts automatisch gekapselt, indem Attribute nur über Zugriffsmethoden zugänglich sind. Diese Zugriffsmethoden müssen nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis."
"Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in Java und C-Sharp) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in Java, wobei er in Java nur für Module und nicht für Klassen definiert ist.",Wie wird die Sichtbarkeit von Features in EIFFEL geregelt?,"In EIFFEL wird die Sichtbarkeit von Features durch den dedizierten Export geregelt, bei dem die Klassen genannt werden, die auf die Features zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was privat in anderen Sprachen entspricht."
"Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in Java und C-Sharp) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in Java, wobei er in Java nur für Module und nicht für Klassen definiert ist.",Wie werden Features in EIFFEL exportiert?,"In EIFFEL können Features gezielt exportiert werden, indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren."
"Einhergehend mit kurzen Methoden und aussagekräftigen Bezeichnern ist ein deklarativer Programmierstil für die objektorientierte Programmierung typisch: Die Ausdrucksform bemüht sich mehr um das ""Was"" als um das ""Wie"". Der Effizienzgedanke ist dabei sekundär – mögliche Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben, wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung zu ineffizient ist.",Was ist ein deklarativer Programmierstil in der objektorientierten Programmierung?,"Ein deklarativer Programmierstil in der objektorientierten Programmierung bemüht sich mehr um das ""Was"" als um das ""Wie"". Er ist typisch für die objektorientierte Programmierung und geht einher mit kurzen Methoden und aussagekräftigen Bezeichnern. Der Effizienzgedanke ist dabei sekundär – mögliche Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben, wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung zu ineffizient ist."
"Einhergehend mit kurzen Methoden und aussagekräftigen Bezeichnern ist ein deklarativer Programmierstil für die objektorientierte Programmierung typisch: Die Ausdrucksform bemüht sich mehr um das ""Was"" als um das ""Wie"". Der Effizienzgedanke ist dabei sekundär – mögliche Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben, wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung zu ineffizient ist.",Was ist der Unterschied zwischen einem deklarativen und einem imperativen Programmierstil?,"Ein deklarativer Programmierstil beschäftigt sich mehr mit dem ""Was"" als mit dem ""Wie"" und beschreibt, was das Programm tun soll, während ein imperativer Programmierstil sich mehr auf die Anweisungen und die Reihenfolge der Befehle konzentriert, die das Programm ausführen soll, um ein bestimmtes Ergebnis zu erzielen."
"Da die objektorientierte Programmierung ihrem Wesen nach eher imperativ als deklarativ ist, beschränkt sich das Deklarative im Wesentlichen auf den Aufruf von Methoden, die nach dem benannt sind, was sie tun. So ist es in der objektorientierten Programmierung durchaus üblich, einzelne Schleifen, in denen beispielsweise ein Element gesucht wird, aus einem Methodenrumpf in eine eigene Methode zu verschieben und durch einen entsprechenden Methodenaufruf zu ersetzen. Das Programm liest sich also nur deklarativ und ist es nicht wirklich – es handelt sich ja auch nur um einen Stil.",Wie ist die objektorientierte Programmierung im Hinblick auf imperative und deklarative Programmierung?,"Objektorientierte Programmierung ist eher imperativ als deklarativ, aber es ist möglich, einen deklarativen Stil zu verwenden, indem man einzelne Schleifen in eigene Methoden verschiebt und durch Methodenaufrufe ersetzt."
"Da die objektorientierte Programmierung ihrem Wesen nach eher imperativ als deklarativ ist, beschränkt sich das Deklarative im Wesentlichen auf den Aufruf von Methoden, die nach dem benannt sind, was sie tun. So ist es in der objektorientierten Programmierung durchaus üblich, einzelne Schleifen, in denen beispielsweise ein Element gesucht wird, aus einem Methodenrumpf in eine eigene Methode zu verschieben und durch einen entsprechenden Methodenaufruf zu ersetzen. Das Programm liest sich also nur deklarativ und ist es nicht wirklich – es handelt sich ja auch nur um einen Stil.",Was ist der Unterschied zwischen imperativer und deklarativer Programmierung?,"Imperative Programmierung ist eine Programmierparadigme, bei der der Programmierer explizit die Schritte angibt, die der Computer ausführen soll, um ein Problem zu lösen. Deklarative Programmierung hingegen ist eine Programmierparadigme, bei der der Programmierer lediglich die gewünschte Lösung angibt, ohne die Schritte zur Lösung des Problems zu spezifizieren. In der objektorientierten Programmierung ist es durchaus üblich, einzelne Schleifen aus einem Methodenrumpf in eine eigene Methode zu verschieben und durch einen entsprechenden Methodenaufruf zu ersetzen, um das Programm deklarativer zu gestalten, aber es ist immer noch imperativ."
"Für beide Alternativen der Methode ""auswerten"" in Klasse ""Klausel"" gibt es übrigens eine ""Shortcut""-Variante (die so heißt, weil die Iteration ggf. vorzeitig abgebrochen wird).",Was ist eine Shortcut-Variante in der Programmierung?,"Eine Shortcut-Variante ist eine abgekürzte oder optimierte Variante einer Methode, die eine Iteration ggf. vorzeitig abbricht, wenn eine bestimmte Bedingung erfüllt ist. Sie wird auch als ""Schnellausgang"" oder ""Frühausgang"" bezeichnet."
"Aber solange man sich nicht sicher ist, dass eine (vermeintliche) Abkürzung funktional äquivalent ist (also dasselbe Ergebnis liefert), sollte man von solchen Optimierungen die Finger lassen. (Es könnte beispielsweise sein, dass ""auswerten"" für ""Literale"" einen Seiteneffekt hat; in diesem Fall wären die optimierten Versionen nicht mehr äquivalent!)",Warum sollte man bei Optimierungen vorsichtig sein?,"Man sollte bei Optimierungen vorsichtig sein, weil nicht sichergestellt ist, dass die optimierte Version funktional äquivalent ist und dasselbe Ergebnis liefert. Zum Beispiel könnte ""auswerten"" für ""Literale"" einen Seiteneffekt haben, was die optimierten Versionen ungleich machen würde."
"Aber solange man sich nicht sicher ist, dass eine (vermeintliche) Abkürzung funktional äquivalent ist (also dasselbe Ergebnis liefert), sollte man von solchen Optimierungen die Finger lassen. (Es könnte beispielsweise sein, dass ""auswerten"" für ""Literale"" einen Seiteneffekt hat; in diesem Fall wären die optimierten Versionen nicht mehr äquivalent!)",Was sollte man bei vermeintlichen Abkürzungen beachten?,"Man sollte sicherstellen, dass die Abkürzung funktional äquivalent ist, d.h. dasselbe Ergebnis liefert, bevor man solche Optimierungen vornimmt. Wenn beispielsweise ""auswerten"" für ""Literale"" einen Seiteneffekt hat, wären die optimierten Versionen nicht mehr äquivalent."
"Aber solange man sich nicht sicher ist, dass eine (vermeintliche) Abkürzung funktional äquivalent ist (also dasselbe Ergebnis liefert), sollte man von solchen Optimierungen die Finger lassen. (Es könnte beispielsweise sein, dass ""auswerten"" für ""Literale"" einen Seiteneffekt hat; in diesem Fall wären die optimierten Versionen nicht mehr äquivalent!)",Was bedeutet funktional äquivalent?,"Funktional äquivalent bedeutet, dass zwei Ausdrücke das gleiche Ergebnis liefern, wenn sie mit den gleichen Eingabewerten ausgeführt werden."
"Ein anderes Zeichen eines deklarativen Programmierstils ist die Verwendung von Zusicherungen (Vor- und Nachbedingungen, Invarianten) anstelle von Kommentaren.",Was sind Zusicherungen in einem deklarativen Programmierstil?,"Zusicherungen sind Vor- und Nachbedingungen sowie Invarianten, die anstelle von Kommentaren in einem deklarativen Programmierstil verwendet werden."
"Wenn es die Sprache zulässt. Damit schlägt man zwei Fliegen mit einer Klappe: Man kann die Zusicherungen zur Laufzeitverifikation einsetzen und zeigt dem Aufrufer der Methode, wie er selbst prüfen kann, ob die Vorbedingung eingehalten ist.",Was ist die Bedeutung von Zusicherungen (Assertions) in der Programmierung?,"Zusicherungen (Assertions) sind in der Programmierung eine Möglichkeit, die Richtigkeit von Bedingungen zu einem bestimmten Zeitpunkt während der Ausführung eines Programms zu überprüfen. Wenn die Sprache dies zulässt, können sie auch dazu verwendet werden, dem Aufrufer der Methode zu zeigen, wie er selbst prüfen kann, ob die Vorbedingung eingehalten ist."
"Wenn es die Sprache zulässt. Damit schlägt man zwei Fliegen mit einer Klappe: Man kann die Zusicherungen zur Laufzeitverifikation einsetzen und zeigt dem Aufrufer der Methode, wie er selbst prüfen kann, ob die Vorbedingung eingehalten ist.",Wozu können Zusicherungen in der objektorientierten Programmierung eingesetzt werden?,"Zusicherungen können in der objektorientierten Programmierung eingesetzt werden, um die Laufzeitverifikation zu ermöglichen und dem Aufrufer der Methode zu zeigen, wie er prüfen kann, ob die Vorbedingung eingehalten ist."
"Wenn Sie If und While schon kennen, kennen Sie sicher auch For. Die klassische Form der For-Schleife verwendet eine Zählvariable, einen Anfangswert, ein Inkrement (das auch negativ, also ein Dekrement sein kann) sowie einen Endwert. Solche For-Schleifen gibt es in SMALLTALK auch.Hier interessiert uns aber vor allem eine Form der Iteration, die nicht einer einfachen Zählschleife entspricht, sondern über eine Menge von beliebigen Objekten geht. Solche Mengen sind uns ja schon begegnet, wenn auch nur in Gestalt von literalen Arrays.Anders als in vielen anderen Sprachen kann man in SMALLTALK über die Elemente eines Arrays direkt, also ohne die Verwendung einer Zählschleife, deren Laufvariable als Index in das Array dient, iterieren. i ist aber diesmal keine Zählvariable, da hier nichts gezählt wird; es ist vielmehr eine Laufvariable, der der Reihe nach die Elemente des literalen Arrays #(5) zugewiesen werden. do: ersetzt also ganz offensichtlich das aus manchen anderen Sprachen bekannte For-each-Konstrukt.Wie wir gleich sehen werden, ist die Iteration, also das Fortschalten der Elemente und die Überprüfung der Abbruchbedingung, in der Collection, über die iteriert wird, implementiert. Deshalb nennt man dieses Verfahren auch interne Iteration (im Gegensatz zur herkömmlichen externen Iteration, bei der die Laufvariable selbst gesetzt und abgefragt werden muss).Die Implementierung der Kontrollstruktur erfolgt wiederum selbst in SMALLTALK und ist ziemlich einfach. Dabei ist to:do: für Ganzahlen analog zu dem bereits erwähnten to:by:do implementiert. Die Zählvariable index des Blocks läuft von 1 bis zur Anzahl der indizierten Instanzvariablen des Empfängers von do: (im obigen Beispiel ein Array). Diese Anzahl wird über den Aufruf von size auf dem Empfänger (repräsentiert durch self) abgefragt. Der Inhalt der indizierten Instanzvariable n des Empfängers wird dann der Reihe nach als Parameter mittels value: an den Block aBlock zur Auswertung geschickt.",Wie wird die Iteration in SMALLTALK realisiert?,"Die Iteration in SMALLTALK erfolgt durch eine Form der internen Iteration, bei der die Steuerstruktur für das Fortschreiten durch Elemente und die Überprüfung der Abbruchbedingung innerhalb der Sammlung erfolgt, über die iteriert wird."
"Wenn Sie If und While schon kennen, kennen Sie sicher auch For. Die klassische Form der For-Schleife verwendet eine Zählvariable, einen Anfangswert, ein Inkrement (das auch negativ, also ein Dekrement sein kann) sowie einen Endwert. Solche For-Schleifen gibt es in SMALLTALK auch.Hier interessiert uns aber vor allem eine Form der Iteration, die nicht einer einfachen Zählschleife entspricht, sondern über eine Menge von beliebigen Objekten geht. Solche Mengen sind uns ja schon begegnet, wenn auch nur in Gestalt von literalen Arrays.Anders als in vielen anderen Sprachen kann man in SMALLTALK über die Elemente eines Arrays direkt, also ohne die Verwendung einer Zählschleife, deren Laufvariable als Index in das Array dient, iterieren. i ist aber diesmal keine Zählvariable, da hier nichts gezählt wird; es ist vielmehr eine Laufvariable, der der Reihe nach die Elemente des literalen Arrays #(5) zugewiesen werden. do: ersetzt also ganz offensichtlich das aus manchen anderen Sprachen bekannte For-each-Konstrukt.Wie wir gleich sehen werden, ist die Iteration, also das Fortschalten der Elemente und die Überprüfung der Abbruchbedingung, in der Collection, über die iteriert wird, implementiert. Deshalb nennt man dieses Verfahren auch interne Iteration (im Gegensatz zur herkömmlichen externen Iteration, bei der die Laufvariable selbst gesetzt und abgefragt werden muss).Die Implementierung der Kontrollstruktur erfolgt wiederum selbst in SMALLTALK und ist ziemlich einfach. Dabei ist to:do: für Ganzahlen analog zu dem bereits erwähnten to:by:do implementiert. Die Zählvariable index des Blocks läuft von 1 bis zur Anzahl der indizierten Instanzvariablen des Empfängers von do: (im obigen Beispiel ein Array). Diese Anzahl wird über den Aufruf von size auf dem Empfänger (repräsentiert durch self) abgefragt. Der Inhalt der indizierten Instanzvariable n des Empfängers wird dann der Reihe nach als Parameter mittels value: an den Block aBlock zur Auswertung geschickt.",Was ist interne Iteration?,"Bei der internen Iteration erfolgt die Steuerstruktur für das Fortschreiten durch Elemente und die Überprüfung der Abbruchbedingung innerhalb der Sammlung erfolgt, über die iteriert wird."
"Wenn Sie If und While schon kennen, kennen Sie sicher auch For. Die klassische Form der For-Schleife verwendet eine Zählvariable, einen Anfangswert, ein Inkrement (das auch negativ, also ein Dekrement sein kann) sowie einen Endwert. Solche For-Schleifen gibt es in SMALLTALK auch.Hier interessiert uns aber vor allem eine Form der Iteration, die nicht einer einfachen Zählschleife entspricht, sondern über eine Menge von beliebigen Objekten geht. Solche Mengen sind uns ja schon begegnet, wenn auch nur in Gestalt von literalen Arrays.Anders als in vielen anderen Sprachen kann man in SMALLTALK über die Elemente eines Arrays direkt, also ohne die Verwendung einer Zählschleife, deren Laufvariable als Index in das Array dient, iterieren. i ist aber diesmal keine Zählvariable, da hier nichts gezählt wird; es ist vielmehr eine Laufvariable, der der Reihe nach die Elemente des literalen Arrays #(5) zugewiesen werden. do: ersetzt also ganz offensichtlich das aus manchen anderen Sprachen bekannte For-each-Konstrukt.Wie wir gleich sehen werden, ist die Iteration, also das Fortschalten der Elemente und die Überprüfung der Abbruchbedingung, in der Collection, über die iteriert wird, implementiert. Deshalb nennt man dieses Verfahren auch interne Iteration (im Gegensatz zur herkömmlichen externen Iteration, bei der die Laufvariable selbst gesetzt und abgefragt werden muss).Die Implementierung der Kontrollstruktur erfolgt wiederum selbst in SMALLTALK und ist ziemlich einfach. Dabei ist to:do: für Ganzahlen analog zu dem bereits erwähnten to:by:do implementiert. Die Zählvariable index des Blocks läuft von 1 bis zur Anzahl der indizierten Instanzvariablen des Empfängers von do: (im obigen Beispiel ein Array). Diese Anzahl wird über den Aufruf von size auf dem Empfänger (repräsentiert durch self) abgefragt. Der Inhalt der indizierten Instanzvariable n des Empfängers wird dann der Reihe nach als Parameter mittels value: an den Block aBlock zur Auswertung geschickt.",Was ist externe Iteration?,Bei der traditionellen externen Iteration muss manuell eine Schleifenvariable als Index verwaltet werden.
"Die Unterscheidung zwischen lokalen und globalen Variablen dient unter anderem dazu, Geheimnisse zu verbergen, was auch als Geheimnisprinzip oder Information Hiding bezeichnet wird. Genauer gesagt geht es dabei um das Verbergen von Implementationsdetails. Es ist fast immer sinnvoll, die Struktur zusammengesetzter Objekte vor den Objekten zu verbergen, die sie verwenden, damit Änderungen an dieser Struktur vorgenommen werden können, ohne dass die verwendenden (abhängigen) Objekte davon betroffen sind. Solche Änderungsabhängigkeiten werden vermieden, indem die Variablen von außen nicht zugänglich sind, was automatisch für lokale Variablen gilt, da sie von außen unsichtbar sind.",Was ist das Geheimnisprinzip?,"Das Geheimnisprinzip oder Information Hiding bezieht sich auf das Verbergen von Implementationsdetails eines Objekts, insbesondere der Struktur zusammengesetzter Objekte, vor den Objekten, die sie verwenden. Dadurch können Änderungen an der Struktur vorgenommen werden, ohne dass abhängige Objekte davon betroffen sind."
"Von dieser Idee des Geheimnisprinzips zu unterscheiden ist der Begriff der Kapselung, der eng mit der objektorientierten Programmierung verknüpft ist. Hierbei geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann. Im Gegensatz zum Information Hiding handelt es sich bei der Kapselung nicht um die Veränderung der Struktur von Objekten, sondern um die Veränderung ihres Zustands. Leider lässt sich die Kapselung nicht mit denselben Mitteln wie das Geheimnisprinzip umsetzen. Aufgrund von Aliasing kann ein Objekt, dessen Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, über einen anderen Namen zugänglich sein, ohne dass der erste Name dagegen etwas unternehmen könnte. Über lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt, aber es kann nicht verhindern, dass andere Objekte diese Objekte auch kennen und ohne sein Wissen manipulieren. Aufgrund der möglichen Existenz von Aliasen ist es daher nicht möglich, dass ein Objekt seinen inneren Aufbau vor der Außenwelt vollständig abschottet, es sei denn, es trifft spezielle Vorkehrungen. Diese Vorkehrungen sind derzeit noch nicht in gängige objektorientierte Programmiersprachen integriert und müssen explizit programmiert werden.",Was ist Kapselung?,"Bei der Kapselung geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann."
"Von dieser Idee des Geheimnisprinzips zu unterscheiden ist der Begriff der Kapselung, der eng mit der objektorientierten Programmierung verknüpft ist. Hierbei geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann. Im Gegensatz zum Information Hiding handelt es sich bei der Kapselung nicht um die Veränderung der Struktur von Objekten, sondern um die Veränderung ihres Zustands. Leider lässt sich die Kapselung nicht mit denselben Mitteln wie das Geheimnisprinzip umsetzen. Aufgrund von Aliasing kann ein Objekt, dessen Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, über einen anderen Namen zugänglich sein, ohne dass der erste Name dagegen etwas unternehmen könnte. Über lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt, aber es kann nicht verhindern, dass andere Objekte diese Objekte auch kennen und ohne sein Wissen manipulieren. Aufgrund der möglichen Existenz von Aliasen ist es daher nicht möglich, dass ein Objekt seinen inneren Aufbau vor der Außenwelt vollständig abschottet, es sei denn, es trifft spezielle Vorkehrungen. Diese Vorkehrungen sind derzeit noch nicht in gängige objektorientierte Programmiersprachen integriert und müssen explizit programmiert werden.",Was unterscheidet das Geheimnisprinzip und die Kapselung?,"Der Unterschied besteht darin, dass das Geheimnisprinzip sich auf das Verbergen von Implementationsdetails und Struktur bezieht, während die Kapselung sich auf das Verbergen und die Kontrolle des Zustands eines Objekts bezieht."
"Von dieser Idee des Geheimnisprinzips zu unterscheiden ist der Begriff der Kapselung, der eng mit der objektorientierten Programmierung verknüpft ist. Hierbei geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann. Im Gegensatz zum Information Hiding handelt es sich bei der Kapselung nicht um die Veränderung der Struktur von Objekten, sondern um die Veränderung ihres Zustands. Leider lässt sich die Kapselung nicht mit denselben Mitteln wie das Geheimnisprinzip umsetzen. Aufgrund von Aliasing kann ein Objekt, dessen Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, über einen anderen Namen zugänglich sein, ohne dass der erste Name dagegen etwas unternehmen könnte. Über lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt, aber es kann nicht verhindern, dass andere Objekte diese Objekte auch kennen und ohne sein Wissen manipulieren. Aufgrund der möglichen Existenz von Aliasen ist es daher nicht möglich, dass ein Objekt seinen inneren Aufbau vor der Außenwelt vollständig abschottet, es sei denn, es trifft spezielle Vorkehrungen. Diese Vorkehrungen sind derzeit noch nicht in gängige objektorientierte Programmiersprachen integriert und müssen explizit programmiert werden.",Wie wird die Kapselung umgesetzt?,"Über lokale Instanzvariablen kann ein Objekt verbergen, welche Objekte es kennt. Aber aufgrund von Aliasing kann ein Objekt, dessen Name unsichtbar ist, über einen anderen Namen zugänglich sein kann."
"Von dieser Idee des Geheimnisprinzips zu unterscheiden ist der Begriff der Kapselung, der eng mit der objektorientierten Programmierung verknüpft ist. Hierbei geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann. Im Gegensatz zum Information Hiding handelt es sich bei der Kapselung nicht um die Veränderung der Struktur von Objekten, sondern um die Veränderung ihres Zustands. Leider lässt sich die Kapselung nicht mit denselben Mitteln wie das Geheimnisprinzip umsetzen. Aufgrund von Aliasing kann ein Objekt, dessen Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, über einen anderen Namen zugänglich sein, ohne dass der erste Name dagegen etwas unternehmen könnte. Über lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt, aber es kann nicht verhindern, dass andere Objekte diese Objekte auch kennen und ohne sein Wissen manipulieren. Aufgrund der möglichen Existenz von Aliasen ist es daher nicht möglich, dass ein Objekt seinen inneren Aufbau vor der Außenwelt vollständig abschottet, es sei denn, es trifft spezielle Vorkehrungen. Diese Vorkehrungen sind derzeit noch nicht in gängige objektorientierte Programmiersprachen integriert und müssen explizit programmiert werden.",Warum kann ein Objekt seinen inneren Aufbau nicht kapseln?,"Ein Objekt kann seinen inneren Aufbau nicht vollständig vor der Außenwelt abkapseln, da aufgrund der möglichen Existenz von Aliasen andere Objekte diese Objekte kennen und ohne sein Wissen manipulieren können. Die Abschottung erfordert spezielle Vorkehrungen, die derzeit nicht in gängige objektorientierte Programmiersprachen integriert sind und explizit programmiert werden müssen."
"Neben vielen anderen Neuerungen wird SMALLTALK auch das Model-View-Controller-Entwurfsmuster (MVC-Pattern) zugeschrieben, das sich heute noch (auch in Web-Anwendungen) großer Beliebtheit erfreut. Beim MVC-Pattern gibt es verschiedene (An-)Sichten auf ein logisches Modell, und da Änderungen im Modell potenziell alle Sichten betreffen, muss jede Änderung alle Sichten darüber unterrichten. Es ist also eine Eins-zu-viele-Kommunikation erforderlich, die nicht durch den normalen Nachrichtenversand abgedeckt wird.",Was ist das Model-View-Controller-Entwurfsmuster (MVC-Pattern)?,"Das MVC-Pattern ist ein Entwurfsmuster, das in SMALLTALK eingeführt wurde und sich heute noch großer Beliebtheit erfreut. Es gibt verschiedene Ansichten auf ein logisches Modell, und Änderungen im Modell können potenziell alle Sichten betreffen. Daher muss jede Änderung alle Sichten darüber unterrichten, was eine Eins-zu-viele-Kommunikation erfordert, die nicht durch den normalen Nachrichtenversand abgedeckt wird."
"Neben vielen anderen Neuerungen wird SMALLTALK auch das Model-View-Controller-Entwurfsmuster (MVC-Pattern) zugeschrieben, das sich heute noch (auch in Web-Anwendungen) großer Beliebtheit erfreut. Beim MVC-Pattern gibt es verschiedene (An-)Sichten auf ein logisches Modell, und da Änderungen im Modell potenziell alle Sichten betreffen, muss jede Änderung alle Sichten darüber unterrichten. Es ist also eine Eins-zu-viele-Kommunikation erforderlich, die nicht durch den normalen Nachrichtenversand abgedeckt wird.",Was ist das MVC-Pattern und wofür wird es verwendet?,"Das MVC-Pattern (Model-View-Controller-Entwurfsmuster) ist ein Entwurfsmuster, das in SMALLTALK eingeführt wurde und heute noch in vielen Anwendungen, auch Webanwendungen, verwendet wird. Es gibt verschiedene Ansichten auf ein logisches Modell. Änderungen im Modell können alle Sichten betreffen, daher muss jede Änderung alle Sichten darüber unterrichten. Das MVC-Pattern erfordert eine Eins-zu-viele-Kommunikation, die nicht durch den normalen Nachrichtenversand abgedeckt wird."
"Das folgende Protokoll setzt diese Form der Kommunikation in SMALLTALK um; es ist vollständig in SMALLTALK implementiert und sollte Ihnen inzwischen kein Problem mehr bereiten. Beachten Sie, dass Object keine Lazy Initialization seiner Klassenvariable Dependents vorsieht; die Methode initDependents muss daher bei Erzeugung einer neuen Klasse jeweils einmal aufgerufen werden.",Was ist Lazy Initialization?,"Lazy Initialization ist eine Technik, bei der die Initialisierung einer Variablen oder eines Objekts verzögert wird, bis sie tatsächlich benötigt wird. Diese Technik wird eingesetzt, um Ressourcen zu sparen und die Leistung zu verbessern."
"Das folgende Protokoll setzt diese Form der Kommunikation in SMALLTALK um; es ist vollständig in SMALLTALK implementiert und sollte Ihnen inzwischen kein Problem mehr bereiten. Beachten Sie, dass Object keine Lazy Initialization seiner Klassenvariable Dependents vorsieht; die Methode initDependents muss daher bei Erzeugung einer neuen Klasse jeweils einmal aufgerufen werden.",Was ist eine Klassenvariable?,"Eine Klassenvariable ist eine Variable, die allen Instanzen einer Klasse gemeinsam ist und deren Wert für alle Instanzen gleich ist."
"Das folgende Protokoll setzt diese Form der Kommunikation in SMALLTALK um; es ist vollständig in SMALLTALK implementiert und sollte Ihnen inzwischen kein Problem mehr bereiten. Beachten Sie, dass Object keine Lazy Initialization seiner Klassenvariable Dependents vorsieht; die Methode initDependents muss daher bei Erzeugung einer neuen Klasse jeweils einmal aufgerufen werden.",Was ist die Methode initDependents?,"Die Methode initDependents ist eine Methode, die bei der Erzeugung einer neuen Klasse aufgerufen werden muss, um die Klassenvariable Dependents zu initialisieren."
"Das folgende Protokoll setzt diese Form der Kommunikation in SMALLTALK um; es ist vollständig in SMALLTALK implementiert und sollte Ihnen inzwischen kein Problem mehr bereiten. Beachten Sie, dass Object keine Lazy Initialization seiner Klassenvariable Dependents vorsieht; die Methode initDependents muss daher bei Erzeugung einer neuen Klasse jeweils einmal aufgerufen werden.",Was ist das Protokoll in SMALLTALK?,"Das Protokoll ist eine Sammlung von Methoden, die eine bestimmte Funktionalität bereitstellen. In SMALLTALK ist das Protokoll vollständig in SMALLTALK implementiert und ermöglicht die Kommunikation zwischen Objekten."
"Grundsätzlich sollte eine Klassenbibliothek mit den Mitteln der Sprache programmiert werden, aber von der Sprachdefinition unabhängig und somit austauschbar sein. Dies gilt natürlich genauso für die Prozeduren in imperativen Sprachen: Auch diese sollten nicht Teil der Sprache sein, sondern lediglich darin geschrieben werden. Nun hat man sich aber schon bei den edelsten imperativen Sprachen nicht daran gehalten (in PASCAL beispielsweise sind read und write Bestandteil der Sprache, und der Compiler weiß, dass ihnen — als einzige Prozeduren — beliebig viele Parameter übergeben werden dürfen, wobei jeder einzelne Parameter in seinem Typ nicht festgelegt ist); bei den objektorientierten Sprachen tut man es erst recht nicht. So sind in Java einige Klassen von der Sprache fest vorgegeben und können nicht beliebig ersetzt werden.","Warum sollte eine Klassenbibliothek mit den Mitteln der Sprache programmiert werden, aber von der Sprachdefinition unabhängig sein?","Das hat den Vorteil, dass die Klassenbibliothek austauschbar ist und somit die Sprache flexibler einsetzbar wird."
"Grundsätzlich sollte eine Klassenbibliothek mit den Mitteln der Sprache programmiert werden, aber von der Sprachdefinition unabhängig und somit austauschbar sein. Dies gilt natürlich genauso für die Prozeduren in imperativen Sprachen: Auch diese sollten nicht Teil der Sprache sein, sondern lediglich darin geschrieben werden. Nun hat man sich aber schon bei den edelsten imperativen Sprachen nicht daran gehalten (in PASCAL beispielsweise sind read und write Bestandteil der Sprache, und der Compiler weiß, dass ihnen — als einzige Prozeduren — beliebig viele Parameter übergeben werden dürfen, wobei jeder einzelne Parameter in seinem Typ nicht festgelegt ist); bei den objektorientierten Sprachen tut man es erst recht nicht. So sind in Java einige Klassen von der Sprache fest vorgegeben und können nicht beliebig ersetzt werden.","Warum wird in objektorientierten Sprachen oft nicht daran gehalten, Klassenbibliotheken von der Sprachdefinition unabhängig zu programmieren?","Das liegt daran, dass die Sprache selbst oft bestimmte Klassen vorgibt, die nicht beliebig ersetzt werden können."
"In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar (und somit auch zugreifbar). Genauer gesagt, sind die Methoden die einzigen Stellen im gesamten Programm, an denen auf die Instanzvariablen des Objekts, dem die Methoden zugeordnet sind, direkt zugegriffen werden kann. Die Struktur des Objekts bleibt somit verborgen, und sein Zustand wird gekapselt.",Wie sind Instanzvariablen in SMALLTALK sichtbar?,"In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar, um den Zustand des Objekts zu kapseln und seine Struktur vor direktem Zugriff von außen zu schützen."
"Um die Belegung der Instanzvariablen und damit den Zustand eines Objekts auszulesen oder zu verändern, sind Methoden erforderlich. Beispielsweise muss das Objekt eine Methode bereitstellen, die den Wert einer Instanzvariable mit dem Namen ""a"" zurückgibt.Diese Methode entspricht im Wesentlichen einem in Java gebräuchlichen sogenannten ""Getter"" für eine ansonsten nicht zugreifbare Variable. Es ist wichtig zu beachten, dass die Namensgleichheit von Methode und Variable nicht darüber hinwegtäuschen sollte, dass es sich um verschiedene Dinge handelt - Methode und Variable könnten genauso gut unterschiedliche Namen haben. Um einen Wert zu setzen, definiert man üblicherweise ""Setter"" genannte Methoden. Getter und Setter werden zusammen auch als ""Zugriffsmethoden"" oder ""Accessoren"" bezeichnet.",Was sind Zugriffsmethoden?,"Zugriffsmethoden sind Methoden, um die Belegung der Instanzvariablen und damit den Zustand eines Objekts auszulesen oder zu verändern. In Java gibt es dafür Getter und Setter."
"Auf der anderen Seite bedeutet die begrenzte Sichtbarkeit von Instanzvariablen nicht, dass der Zugriff auf Objekte, auf die sie verweisen, verhindert wird (aufgrund von möglichen Aliasen). In SMALLTALK ist ein direkter Zugriff auf die Instanzvariable von außen wie in Java nicht möglich. Der Zugriff auf eine Instanzvariable kann also durch das Fehlen entsprechender Zugriffsmethoden verhindert werden, oder er kann auf Lesen oder Schreiben beschränkt werden, indem nur die jeweilige Zugriffsmethode zur Verfügung gestellt wird.Schließlich sei darauf hingewiesen, dass im Gegensatz zu benannten Instanzvariablen indizierte Instanzvariablen nicht direkt, sondern nur über die beiden vordefinierten Nachrichten ""at:"" und ""at:put:"" gelesen und geschrieben werden können. Es ist in SMALLTALK also nicht möglich, indizierte Instanzvariablen eines Objekts (im Gegensatz zu benannten) durch Nicht-Deklaration von Zugriffsmethoden zu verbergen (vor Zugriff zu schützen). Zugleich folgt aus der festen Vorgabe der beiden Zugriffsmethoden, dass jedes Objekt nur genau eine (unbenannte) Menge von indizierten Instanzvariablen haben kann.",Was unterscheidet eine benannte Instanzvariable und eine indizierte Instanzvariable in SMALLTALK?,"In SMALLTALK können benannte Instanzvariablen direkt über ihren Namen zugegriffen werden, während indizierte Instanzvariablen nur über die vordefinierten Nachrichten ""at:"" und ""at:put:"" gelesen und geschrieben werden können. Der Zugriff auf indizierte Instanzvariablen erfolgt nicht über Zugriffsmethoden, sondern über diese Nachrichten."
"Die ausschließliche Abfrage und Änderung des Zustandes von Objekten über Methoden hat den Vorteil, dass man sich nicht darauf festlegt, wie der Zustand eines Objekts tatsächlich codiert ist. So können beispielsweise einem Punktobjekt Methoden zum Setzen und Abfragen sowohl von kartesischen als auch von polaren Koordinaten zugeordnet werden. Dabei muss nur eine Instanzvariable für eine Art von Koordinaten vorgesehen werden, und die anderen können jeweils berechnet werden. Dies ermöglicht eine flexible Gestaltung der Zustandsrepräsentation eines Objekts, während die Schnittstelle zur Abfrage und Änderung des Zustands durch Methoden definiert wird.Man betrachtet die Art und Weise, wie ein Objekt seinen Zustand codiert, als sein Implementationsgeheimnis und die Menge der Methodensignaturen, die den Zugriff auf das Objekt (seinen Zustand) erlauben, als sein Interface.",Was ist das Interface eines Objekts?,"Das Interface eines Objekts ist die Art und Weise, wie ein Objekt seinen Zustand codiert, als sein Implementationsgeheimnis und die Menge der Methodensignaturen, die den Zugriff auf das Objekt (seinen Zustand) erlauben."
"Eine Klassendefinition liefert die Intension einer Klasse. Sie besteht in SMALLTALK zunächst aus der Angabe eines nicht anderweitig verwendeten, durch ein Symbol repräsentierten Klassennamens sowie der Angabe der die Objekte der Klasse beschreibenden Instanzvariablen und Methodendefinitionen. Anders als in vielen anderen objektorientierten Programmiersprachen erfolgt in SMALLTALK die Klassendefinition nicht in einer Datei (was hätte eine Datei auch mit den Konzepten einer Programmiersprache zu tun?), sondern durch Eintragungen in eine dafür vorgesehene Datenstruktur (genauer: durch Erzeugung eines die Klasse beschreibenden Objekts). Es gibt also auch insbesondere keine Syntax für eine Klassendefinition, sondern nur ein Schema.",Was ist eine Klassendefinition?,"Eine Klassendefinition liefert die Intension oder Beschreibung einer Klasse. Sie besteht aus dem Namen der Klasse, der Liste der benannten Instanzvariablen, Angaben zu indizierten Instanzvariablen, Informationen zur Atomarität, und einer Liste von Instanzmethoden."
"Eine Klassendefinition liefert die Intension einer Klasse. Sie besteht in SMALLTALK zunächst aus der Angabe eines nicht anderweitig verwendeten, durch ein Symbol repräsentierten Klassennamens sowie der Angabe der die Objekte der Klasse beschreibenden Instanzvariablen und Methodendefinitionen. Anders als in vielen anderen objektorientierten Programmiersprachen erfolgt in SMALLTALK die Klassendefinition nicht in einer Datei (was hätte eine Datei auch mit den Konzepten einer Programmiersprache zu tun?), sondern durch Eintragungen in eine dafür vorgesehene Datenstruktur (genauer: durch Erzeugung eines die Klasse beschreibenden Objekts). Es gibt also auch insbesondere keine Syntax für eine Klassendefinition, sondern nur ein Schema.",Wie werden Klassendefinitionen in SMALLTALK umgesetzt?,"In SMALLTALK erfolgt die Klassendefinition nicht in einer separaten Datei wie in vielen anderen objektorientierten Programmiersprachen. Stattdessen werden Klassendefinitionen durch Eintragungen in eine Datenstruktur oder das Erzeugen eines Objekts repräsentiert. Es gibt keine spezielle Syntax für Klassendefinitionen, nur ein Schema."
"Alle Instanzen einer Klasse verfügen somit über den gleichen Satz von Instanzvariablen, aber nicht denselben, was so viel bedeutet wie, dass jede Instanz der Klasse (jedes Objekt, das zur Extension der Klasse gehört) diese Variablen individuell belegen kann. Im Gegensatz dazu verstehen alle Instanzen einer Klasse nicht nur dieselben Nachrichten, sie verwenden auch dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren. Instanzen einer Klasse können sich also nur insoweit in ihrem Verhalten unterscheiden, wie sich die Methodendefinitionen auf die Werte der Instanzvariablen beziehen, wie also das in den Methoden spezifizierte Verhalten vom Inhalt der Instanzvariablen abhängt. Insbesondere ist es nicht vorgesehen, dass verschiedene Instanzen einer Klasse über verschiedene Definitionen einer Methode (genauer: über verschiedene Definitionen von zu der Nachricht passenden Methoden) verfügen. Das unterscheidet die klassenbasierte von der prototypenbasierten Form der objektorientierten Programmierung.",Was sind Instanzen einer Klasse?,"Eine Instanz der Klasse ist das Objekt, das zur Extension der Klasse gehört. Jede Instanz belegt den Satz an Instanzvariablen individuell. Alle Instanzen einer Klasse verstehen dieselben Nachrichten und verwenden dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren."
"Die beiden Einträge „indizierte Instanzvariablen“ und „atomar“ stehen übrigens dafür, ob eine Instanz der Klasse indizierte Instanzvariablen haben soll (klar) und falls ja, ob diese Variablen dann eine binäre Repräsentation (ja) oder Referenzen (nein) enthalten. Mithilfe von indizierten Instanzvariablen, die binäre Repräsentationen enthalten, werden z.B. Zahlen, Strings, aber auch Bitmaps wie Fensterinhalte, der Cursor oder Fonts intern dargestellt. Da man als Programmierer solche Klassen in der Regel nicht selbst anlegt, werde ich den Eintrag „atomar“ zukünftig unter den Tisch fallen lassen.",Was sind indizierte Instanzvariablen?,Indizierten Instanzvariablen enthalten binäre Repräsentationen.
"Eine Klasse (das Objekt, das die Klassen repräsentiert, nicht ihr Name) wird in SMALLTALK nach ihrer Erzeugung übrigens durch eine globale Pseudovariable repräsentiert, deren Name der Name der Klasse ist. Da die Variable global ist, muss sie (und damit auch der Name der Klasse) immer mit einem Großbuchstaben beginnen. Die Variable wird automatisch mit der Klassendefinition eingeführt (vereinbart); ihr „Wert“, die Klasse, auf die sie verweist, ist das Objekt, das ihr bei der Anlage der Klasse zugewiesen wird. Da Klassennamen globale Variablen sind, da sie insbesondere absolut global sind und nicht nur in Bezug auf irgendeine Programmeinheit (wie etwa eine Methodendefinition), sind sie von überall her zugreifbar. Außerdem wird jede neue Klasse in eine Art Systemwörterbuch namens „Smalltalk“ (repräsentiert von der globalen Variable Smalltalk) eingetragen, und ihr Name (als Symbol) in die Symboltabelle SymbolTable. Mittels einer solchen Klassendefinition ist man nun in der Lage, das SMALLTALK-System um neue, eigene Klassen zu erweitern.",Was sind globale Pseudovariablen?,"In SMALLTALK wird jede Klasse nach ihrer Erzeugung durch eine globale Pseudovariable repräsentiert, deren Name dem Namen der Klasse entspricht. Diese globale Pseudovariable ist notwendig, um auf die Klasse und ihre Methoden zugreifen zu können. Klassennamen sind global und von überall aus im Code zugreifbar."
"EIFFEL ist, wie alle anderen hier behandelten Sprachen (mit Ausnahme von C++), eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist. Klassen können (mit der in Abschnitt 52.5 gemachten Einschränkung) separat übersetzt werden. Die Ausführung von EIFFEL erfolgt nicht auf einer virtuellen Maschine, sondern direkt auf der Zielmaschine. Es gibt jedoch mittlerweile auch eine Version von EIFFEL für .NET, die wie alle .NET-Sprachen zunächst in CIL übersetzt wird und dann in Maschinencode. Die Sprache selbst sieht aufgrund ihrer Einfachheit keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Eventuelle Performance-Verbesserungen werden ganz der Verantwortung eines optimierenden Compilers überlassen. EIFFEL verwendet Garbage Collection zur Speicherfreigabe. Es handelt sich um eine akademische Sprache.",Ist EIFFEL eine objektorientierte Programmiersprache?,"Ja, EIFFEL ist eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist."
"EIFFEL ist, wie alle anderen hier behandelten Sprachen (mit Ausnahme von C++), eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist. Klassen können (mit der in Abschnitt 52.5 gemachten Einschränkung) separat übersetzt werden. Die Ausführung von EIFFEL erfolgt nicht auf einer virtuellen Maschine, sondern direkt auf der Zielmaschine. Es gibt jedoch mittlerweile auch eine Version von EIFFEL für .NET, die wie alle .NET-Sprachen zunächst in CIL übersetzt wird und dann in Maschinencode. Die Sprache selbst sieht aufgrund ihrer Einfachheit keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Eventuelle Performance-Verbesserungen werden ganz der Verantwortung eines optimierenden Compilers überlassen. EIFFEL verwendet Garbage Collection zur Speicherfreigabe. Es handelt sich um eine akademische Sprache.",Was ist EIFFEL und welche Eigenschaften hat sie?,"EIFFEL ist eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist. Sie wird direkt auf der Zielmaschine ausgeführt, mit Ausnahme einer Version für .NET, die zunächst in CIL übersetzt wird. EIFFEL verwendet Garbage Collection zur Speicherfreigabe und ist eine akademische Sprache. Sie sieht keine speziellen Konstrukte für leistungsstarke und weniger leistungsstarke Implementierungen vor, diese werden einem optimierenden Compiler überlassen."
"Um strukturelle Typäquivalenz festzustellen, werden die Definitionen der beteiligten Typen rekursiv expandiert, was so viel heißt wie, dass in einer Typdefinition vorkommende Namen anderer Typen durch ihre Struktur ersetzt werden.",Was ist strukturelle Typäquivalenz?,"Strukturelle Typäquivalenz ist ein Verfahren, um festzustellen, ob zwei Typen gleich sind. Dabei werden die Definitionen der beteiligten Typen rekursiv expandiert, was bedeutet, dass in einer Typdefinition vorkommende Namen anderer Typen durch ihre Struktur ersetzt werden."
"Dann sind die Typen Person und Firma sowie Wohnung und Büro jeweils strukturäquivalent, aber nicht namensäquivalent. Bei der Strukturäquivalenz haben Namen also lediglich die Funktion der abkürzenden Schreibweise, bei der Namensäquivalenz hingegen auch eine von der Struktur unabhängige Bedeutung. Namensäquivalenz impliziert Strukturäquivalenz, aber nicht umgekehrt; Namensäquivalenz ist somit das stärkere Konzept.",Was ist der Unterschied zwischen Strukturäquivalenz und Namensäquivalenz?,"Strukturäquivalenz bedeutet, dass zwei Typen die gleiche Struktur haben, aber die Namen können unterschiedlich sein. Bei Namensäquivalenz hingegen haben die Namen eine von der Struktur unabhängige Bedeutung, d.h. sie sind identisch. Namensäquivalenz impliziert Strukturäquivalenz, aber nicht umgekehrt."
"Strukturäquivalenz als Bedingung der Zuweisungskompatibilität reicht aus, um Typfehler, also logische und Laufzeitfehler, die auf der Annahme einer nicht vorliegenden Eigenschaft (Methode) bei einem Wert einer Variable basieren, zu verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.",Was ist Strukturäquivalenz als Bedingung der Zuweisungskompatibilität?,"Strukturäquivalenz als Bedingung der Zuweisungskompatibilität bedeutet, dass die Struktur zweier Objekte gleich sein muss, damit sie einander zugewiesen werden können. Diese Bedingung verhindert Typfehler, indem sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten durchgeführt werden können."
"Strukturäquivalenz als Bedingung der Zuweisungskompatibilität reicht aus, um Typfehler, also logische und Laufzeitfehler, die auf der Annahme einer nicht vorliegenden Eigenschaft (Methode) bei einem Wert einer Variable basieren, zu verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.",Was ist Strukturäquivalenz?,"Strukturäquivalenz ist eine Bedingung der Zuweisungskompatibilität, die ausreicht, um Typfehler zu verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten durchgeführt werden können."
"Strukturäquivalenz als Bedingung der Zuweisungskompatibilität reicht aus, um Typfehler, also logische und Laufzeitfehler, die auf der Annahme einer nicht vorliegenden Eigenschaft (Methode) bei einem Wert einer Variable basieren, zu verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.",Was ist Strukturäquivalenz und wie verhindert sie Typfehler?,"Strukturäquivalenz ist eine Bedingung der Zuweisungskompatibilität, die dazu dient, Typfehler zu verhindern. Sie besagt, dass zwei Objekte, die einer Variablen zugewiesen werden können, die gleiche Struktur haben müssen, d.h. sie müssen über die gleichen Attribute und Methoden verfügen. Durch diese Bedingung wird sichergestellt, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten durchgeführt werden können, und somit logische und Laufzeitfehler vermieden werden."
"Strukturäquivalenz ist eine rein syntaktische Bedingung. Insbesondere können bei geforderter Strukturäquivalenz Typen zufällig zuweisungskompatibel sein, die inhaltlich überhaupt nichts miteinander zu tun haben. Dadurch können Objekte, die eigentlich getrennten Typen (disjunkten Wertebereichen) angehören, über Kreuz und über die Typgrenzen hinweg zugewiesen werden. Semantische Fehler sind also immer noch möglich. Man trifft daher in Sprachen mit Strukturäquivalenz gelegentlich die Praxis an, jedem Typ eine für ihn charakteristische Methode exklusiv zuzuordnen, so dass er mit keinem anderen mehr strukturäquivalent ist. Diese Technik nennt man Type branding.",Was ist Type branding?,"Type branding ist eine Technik, bei der jedem Typ eine für ihn charakteristische Methode exklusiv zugeordnet wird, sodass er mit keinem anderen mehr strukturäquivalent ist. Diese Technik wird gelegentlich in Sprachen mit Strukturäquivalenz angewendet, um semantische Fehler durch das Zuweisen von Objekten über Typgrenzen hinweg zu vermeiden."
"Strukturäquivalenz ist eine rein syntaktische Bedingung. Insbesondere können bei geforderter Strukturäquivalenz Typen zufällig zuweisungskompatibel sein, die inhaltlich überhaupt nichts miteinander zu tun haben. Dadurch können Objekte, die eigentlich getrennten Typen (disjunkten Wertebereichen) angehören, über Kreuz und über die Typgrenzen hinweg zugewiesen werden. Semantische Fehler sind also immer noch möglich. Man trifft daher in Sprachen mit Strukturäquivalenz gelegentlich die Praxis an, jedem Typ eine für ihn charakteristische Methode exklusiv zuzuordnen, so dass er mit keinem anderen mehr strukturäquivalent ist. Diese Technik nennt man Type branding.",Was ist Strukturäquivalenz?,"Strukturäquivalenz ist eine rein syntaktische Bedingung, die festlegt, ob zwei Objekte gleich aufgebaut sind. Insbesondere können bei geforderter Strukturäquivalenz Typen zufällig zuweisungskompatibel sein, die inhaltlich überhaupt nichts miteinander zu tun haben."
"Getreu seinem Motto, alle Freiheit in die Hand der Programmiererin zu legen und ihr nicht mit einer gouvernantenhaften ""Du-kannst-das-bestimmt-nicht""-Attitüde zu begegnen, bietet C++ (im Gegensatz zu SMALLTALK, Java und C-Sharp) uneingeschränkte Mehrfachvererbung. Das kann aus verschiedenen Gründen sinnvoll erscheinen: Eine Klasse, die von mehreren vollständig abstrakten (also mit keinerlei Implementierung versehenen) Klassen erbt, implementiert damit faktisch mehrere Interfaces. Der einzige Nachteil ist, dass die Programmiererin nicht in Mitteln der Sprache ausdrücken kann, ob eine abstrakte Klasse die Funktion eines Interfaces oder die einer Generalisierung (von der man Implementierung erben kann; vgl. Abschnitt 9.1) haben soll – dazu sind dann schon Namenskonventionen notwendig. Nicht selten ergibt sich aus der Aufgabenstellung, dass eine Klasse Eigenschaften von mehreren anderen gebrauchen könnte. In Sprachen mit Einfachvererbung muss man sich dann für eine Klasse als Superklasse entscheiden und den Beitrag der anderen Klassen wiederholen, also erneut implementieren oder per Delegation bzw. Forwarding einbinden. Mehrfachvererbung erlaubt im Gegensatz dazu, sich alles zusammenzuerben, was man benötigt.",Was ist der Unterschied zwischen Mehrfachvererbung und Einfachvererbung?,"Im Gegensatz zur Einfachvererbung, bei der eine Klasse nur eine Superklasse haben kann, erlaubt Mehrfachvererbung, dass eine Klasse von mehreren Superklassen erbt."
"Da das Erben jedoch nicht selektiv (im Sinne, dass man sich aussuchen könnte, was man von einer Klasse erbt) erfolgt und das Löschen von geerbten Membern in C++ nicht möglich ist, fühlt man sich häufig bemüßigt, die Klassen, von denen man erbt, in viele kleine Teile aufzusplitten und nur die zu beerben, deren Eigenschaften man braucht, um sich von unnötigem Ballast freizuhalten. Mehrfachvererbung ist etwas, das sich Programmiererinnen gerne wünschen. Sie bringt jedoch einige praktische Probleme mit sich, unter anderem die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements (Feld oder Methode) erbt. Da die Klasse sich dann für eine der beiden Definitionen entscheiden muss, geht die der anderen verloren. Dies kann, insbesondere im Zusammenhang mit dynamischem Binden und offener Rekursion, zu unerwartetem Verhalten führen. Darüber hinaus führt die Mehrfachvererbung noch zu zahlreichen weiteren Problemen, die hier nicht weiter ausgeführt werden sollen.",Was ist Mehrfachvererbung?,"Mehrfachvererbung ist eine Konstruktion in der objektorientierten Programmierung, bei der eine Klasse von mehreren anderen Klassen erben kann. Sie wird häufig von Programmiererinnen gewünscht, bringt aber praktische Probleme mit sich, wie zum Beispiel die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements erbt."
"Da das Erben jedoch nicht selektiv (im Sinne, dass man sich aussuchen könnte, was man von einer Klasse erbt) erfolgt und das Löschen von geerbten Membern in C++ nicht möglich ist, fühlt man sich häufig bemüßigt, die Klassen, von denen man erbt, in viele kleine Teile aufzusplitten und nur die zu beerben, deren Eigenschaften man braucht, um sich von unnötigem Ballast freizuhalten. Mehrfachvererbung ist etwas, das sich Programmiererinnen gerne wünschen. Sie bringt jedoch einige praktische Probleme mit sich, unter anderem die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements (Feld oder Methode) erbt. Da die Klasse sich dann für eine der beiden Definitionen entscheiden muss, geht die der anderen verloren. Dies kann, insbesondere im Zusammenhang mit dynamischem Binden und offener Rekursion, zu unerwartetem Verhalten führen. Darüber hinaus führt die Mehrfachvererbung noch zu zahlreichen weiteren Problemen, die hier nicht weiter ausgeführt werden sollen.",Welche Probleme bringt Mehrfachvererbung mit sich?,"Mehrfachvererbung bringt einige praktische Probleme mit sich, wie zum Beispiel die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements (Feld oder Methode) erbt. Darüber hinaus führt die Mehrfachvererbung noch zu zahlreichen weiteren Problemen, wie zum Beispiel das unerwartete Verhalten im Zusammenhang mit dynamischem Binden und offener Rekursion."
"Abkürzungen sind nicht grundsätzlich zu vermeiden — im Gegenteil, wenn sie etabliert sind und man davon ausgehen darf, dass eine Leserin des Programms sie kennt, ist ihre Verwendung (aus den oben angeführten Gründen gegen zu lange Namen) sogar angezeigt. Auf hausgemachte Abkürzungen, deren Bedeutung nur von einem selbst bekannt ist, sollte man hingegen verzichten.",Sind Abkürzungen in der Programmierung zu vermeiden?,"Abkürzungen sind nicht grundsätzlich zu vermeiden. Wenn sie etabliert sind und man davon ausgehen darf, dass eine Leserin des Programms sie kennt, ist ihre Verwendung sogar angezeigt. Man sollte jedoch auf hausgemachte Abkürzungen verzichten, deren Bedeutung nur von einem selbst bekannt ist."
"Bei der Programmierung mit Java und anderen typisierten objektorientierten Programmiersprachen begegnet man häufig dem Phänomen, dass Typen und Variablen gleich heißen, sich nur in der Groß- bzw. Kleinschreibung ihres Anfangsbuchstabens unterscheiden. Ein typisches Beispiel dafür ist das folgende:",Wie werden Typen und Variablen in Java bezeichnet?,"In Java werden Typen und Variablen häufig gleich benannt, sich nur in der Groß- bzw. Kleinschreibung ihres Anfangsbuchstabens unterscheidend. Ein typisches Beispiel dafür ist das folgende:"
"In diesen Fällen, wenn es keinen besseren Namen für die Variable gibt, ist es vollkommen legitim, eine Abkürzung für den Variablennamen zu wählen, insbesondere dann, wenn die Sichtbarkeit der Variable auf die unmittelbare Umgebung der Deklaration beschränkt ist. Sobald dies jedoch nicht der Fall ist (typischerweise schon bei der Deklaration von Instanzvariablen), sollte der lange Name bevorzugt werden. Dies gilt auch für den Fall, dass der Typ der Variable aus dem Kontext abgeleitet werden kann und deswegen nicht mehr angegeben wird (Typinferenz).",Wann sollte man einen langen Namen für eine Variable bevorzugen?,"Einen langen Namen für eine Variable sollte man bevorzugen, wenn der Typ der Variablen nicht mehr angegeben wird (Typinferenz), wenn die Sichtbarkeit der Variablen nicht auf die unmittelbare Umgebung der Deklaration beschränkt ist oder wenn der Typ der Variable aus dem Kontext nicht abgeleitet werden kann."
"In diesen Fällen, wenn es keinen besseren Namen für die Variable gibt, ist es vollkommen legitim, eine Abkürzung für den Variablennamen zu wählen, insbesondere dann, wenn die Sichtbarkeit der Variable auf die unmittelbare Umgebung der Deklaration beschränkt ist. Sobald dies jedoch nicht der Fall ist (typischerweise schon bei der Deklaration von Instanzvariablen), sollte der lange Name bevorzugt werden. Dies gilt auch für den Fall, dass der Typ der Variable aus dem Kontext abgeleitet werden kann und deswegen nicht mehr angegeben wird (Typinferenz).","Warum sollte man den langen Namen einer Variablen bevorzugen, wenn sie nicht nur in ihrer unmittelbaren Umgebung sichtbar ist?","Der lange Name einer Variablen sollte bevorzugt werden, wenn sie nicht nur in ihrer unmittelbaren Umgebung sichtbar ist, um die Lesbarkeit und Verständlichkeit des Codes zu erhöhen. Ein aussagekräftiger und beschreibender Name hilft anderen Programmierern und auch dem zukünftigen Selbst, den Zweck und die Funktion der Variablen besser zu verstehen."
"C-Sharp unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von Java. Es ist in C-Sharp allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C-Sharp besitzt dafür das Schlüsselwort ""operator"", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:",Was kann in C-Sharp zu überladen werden?,"In C-Sharp ist es möglich, Operatoren wie +, -, ==, new, ( ), ||, &&, = etc. zu überladen."
"C-Sharp unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von Java. Es ist in C-Sharp allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C-Sharp besitzt dafür das Schlüsselwort ""operator"", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:",Was ist Operatorüberladung in C-Sharp?,"In C-Sharp ist es möglich, Operatoren wie +, -, ==, new, ( ), ||, &&, = etc. zu überladen. Dies wird durch das Schlüsselwort ""operator"" in einer Operatordefinition erreicht, die der Definition einer Methode ähnelt."
"C-Sharp unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von Java. Es ist in C-Sharp allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C-Sharp besitzt dafür das Schlüsselwort ""operator"", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:",Was ist in C-Sharp ein Operator?,"In C-Sharp ist ein Operator ein Symbol, das einen Operanden entgegennimmt und einen neuen Wert berechnet. Es gibt verschiedene Arten von Operatoren, wie arithmetische Operatoren (+, -, \*, /), Vergleichsoperatoren (==, !=, <, >) und logische Operatoren (&&, ||). In C-Sharp können Operatoren überladen werden, was bedeutet, dass sie eine benutzerdefinierte Funktionalität haben können, wenn sie auf benutzerdefinierte Datentypen angewendet werden."
"Außerdem ist es in C-Sharp Konvention, Methodennamen mit einem Großbuchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C-Sharp, Call by reference nach dem Vorbild von PASCAL (also ohne explizite Pointer; s. o.) zu erlauben und damit Funktionen wie das Vertauschen von Variableninhalten (die Methode ""swap"") sicher zu programmieren. Allerdings muss ""ref"" — anders als in PASCAL ""var"" — auch an der Aufrufstelle verwendet werden. Formale Parameter können auch mit ""out"" modifiziert werden (wobei für die Aufrufstelle dasselbe gilt wie für ""ref"").",Was ist die Konvention für das Benennen von Methodennamen in C-Sharp?,"Die Konvention für das Benennen von Methodennamen in C-Sharp ist, sie mit einem Großbuchstaben beginnen zu lassen."
"Außerdem ist es in C-Sharp Konvention, Methodennamen mit einem Großbuchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C-Sharp, Call by reference nach dem Vorbild von PASCAL (also ohne explizite Pointer; s. o.) zu erlauben und damit Funktionen wie das Vertauschen von Variableninhalten (die Methode ""swap"") sicher zu programmieren. Allerdings muss ""ref"" — anders als in PASCAL ""var"" — auch an der Aufrufstelle verwendet werden. Formale Parameter können auch mit ""out"" modifiziert werden (wobei für die Aufrufstelle dasselbe gilt wie für ""ref"").",Was ist eine Besonderheit von C-Sharp in Bezug auf das Vertauschen von Variableninhalten?,"C-Sharp erlaubt Call by reference nach dem Vorbild von PASCAL, was das sichere Programmieren von Funktionen wie dem Vertauschen von Variableninhalten ermöglicht."
"Außerdem ist es in C-Sharp Konvention, Methodennamen mit einem Großbuchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C-Sharp, Call by reference nach dem Vorbild von PASCAL (also ohne explizite Pointer; s. o.) zu erlauben und damit Funktionen wie das Vertauschen von Variableninhalten (die Methode ""swap"") sicher zu programmieren. Allerdings muss ""ref"" — anders als in PASCAL ""var"" — auch an der Aufrufstelle verwendet werden. Formale Parameter können auch mit ""out"" modifiziert werden (wobei für die Aufrufstelle dasselbe gilt wie für ""ref"").",Was ist Call by reference in C-Sharp?,"Call by reference in C-Sharp ist eine Möglichkeit, Funktionen oder Methoden zu schreiben, bei der die Funktions- oder Methodenparameter als Referenzen übergeben werden, anstatt als Werte. Das bedeutet, dass die Funktion oder Methode direkt auf die Originalvariablen zugreifen und diese ändern kann, anstatt Kopien der Variablen zu verwenden. Diese Funktionalität ist ähnlich wie in Pascal, aber in C-Sharp wird es ohne explizite Pointer implementiert. Diese Funktionalität ist besonders nützlich für Methoden wie ""swap"", die die Werte von zwei Variablen vertauschen."
"Der Unterschied ist der, dass bei Verwendung von ""ref"" die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekommen haben) muss, während dies bei ""out"" nicht der Fall ist. Dafür muss bei ""out"" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Dass ""ref"" und ""out"" in C-Sharp anders als ""var"" in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil, dass die Programmiererin weiß, dass ihre die tatsächlichen Parameter liefernden Variablen nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer Zuweisung in beide Richtungen (hin und zurück) aus. Sowohl ""ref"" als auch ""out"" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Da diese Möglichkeit in Java und SMALLTALK fehlt, findet man in diesen Sprachen häufig Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt 52.7).","Was ist der Unterschied zwischen ""ref"" und ""out"" in C-Sharp?","Bei ""ref"" muss die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein, während dies bei ""out"" nicht der Fall ist. Dafür muss bei ""out"" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Der Unterschied liegt also in der Richtung der Zuweisung."
"Der Unterschied ist der, dass bei Verwendung von ""ref"" die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekommen haben) muss, während dies bei ""out"" nicht der Fall ist. Dafür muss bei ""out"" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Dass ""ref"" und ""out"" in C-Sharp anders als ""var"" in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil, dass die Programmiererin weiß, dass ihre die tatsächlichen Parameter liefernden Variablen nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer Zuweisung in beide Richtungen (hin und zurück) aus. Sowohl ""ref"" als auch ""out"" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Da diese Möglichkeit in Java und SMALLTALK fehlt, findet man in diesen Sprachen häufig Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt 52.7).","Was sind ""ref"" und ""out"" in C-Sharp?","""ref"" und ""out"" sind Mechanismen in einigen Programmiersprachen wie C-Sharp, die es einer Methode ermöglichen, mehr als einen Rückgabewert zu haben. Diese Mechanismen sind in Sprachen wie Java und SMALLTALK nicht vorhanden, weshalb man dort häufig Klassen findet, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken."
"Der Unterschied ist der, dass bei Verwendung von ""ref"" die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekommen haben) muss, während dies bei ""out"" nicht der Fall ist. Dafür muss bei ""out"" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Dass ""ref"" und ""out"" in C-Sharp anders als ""var"" in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil, dass die Programmiererin weiß, dass ihre die tatsächlichen Parameter liefernden Variablen nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer Zuweisung in beide Richtungen (hin und zurück) aus. Sowohl ""ref"" als auch ""out"" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Da diese Möglichkeit in Java und SMALLTALK fehlt, findet man in diesen Sprachen häufig Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt 52.7).","Wofür werden ""ref"" und ""out"" verwendet?","Sowohl ""ref"" als auch ""out"" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Sie werden verwendet, um mehrere Rückgabewerte in einem Objekt zu verpacken."
"Nun verdient C-Sharp im Kontext von Methodenaufrufen nicht nur lobende Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C-Sharp keine ""Throws""-Klauseln in Methodendeklarationen gibt — die aus Java bekannte Unterscheidung von Checked exceptions und Unchecked exceptions (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions. Das bedeutet, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzudenken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass bei einer stark geschichteten Architektur (beispielsweise beim Einsatz von Middleware) das Wissen um Exceptions auf der ganzen Wegstrecke von der Exception-Quelle bis zum Exception handler vorhanden sein muss, obwohl die mittleren Schichten naturgemäß an Art und Auftreten von Ausnahmen keinerlei Interesse haben. Das mit Java Version 1.4 eingeführte sog. ""Exception chaining"" erlaubt, eine Checked exception in einer Unchecked exception zu verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut zu werfen). Das sog. ""Exception tunneling"" bietet ebenfalls Abhilfe. Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Unterschied bei Methoden ergibt sich im Zusammenhang mit dem Überschreiben: Während in Java alle Methoden im Prinzip überschrieben werden können (es sei denn, ihre Definition trägt den Zusatz ""final""), so dass der Compiler zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C-Sharp, der Tradition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort ""virtual"". Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort ""override"" deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts ""new"" bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanzgründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern auch gewichtige programmiertechnische: Man markiert alle Stellen im Programm, an denen das sog. ""Fragile-base-class-Problem"" (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. Keine Deklaration.",Wie wird eine Methode in C-Sharp überschrieben?,"In C-Sharp muss eine Methode, die überschrieben werden soll, mit dem Schlüsselwort ""virtual"" deklariert werden. Die überschreibende Methode muss mit dem Schlüsselwort ""override"" deklariert werden."
"Nun verdient C-Sharp im Kontext von Methodenaufrufen nicht nur lobende Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C-Sharp keine ""Throws""-Klauseln in Methodendeklarationen gibt — die aus Java bekannte Unterscheidung von Checked exceptions und Unchecked exceptions (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions. Das bedeutet, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzudenken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass bei einer stark geschichteten Architektur (beispielsweise beim Einsatz von Middleware) das Wissen um Exceptions auf der ganzen Wegstrecke von der Exception-Quelle bis zum Exception handler vorhanden sein muss, obwohl die mittleren Schichten naturgemäß an Art und Auftreten von Ausnahmen keinerlei Interesse haben. Das mit Java Version 1.4 eingeführte sog. ""Exception chaining"" erlaubt, eine Checked exception in einer Unchecked exception zu verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut zu werfen). Das sog. ""Exception tunneling"" bietet ebenfalls Abhilfe. Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Unterschied bei Methoden ergibt sich im Zusammenhang mit dem Überschreiben: Während in Java alle Methoden im Prinzip überschrieben werden können (es sei denn, ihre Definition trägt den Zusatz ""final""), so dass der Compiler zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C-Sharp, der Tradition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort ""virtual"". Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort ""override"" deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts ""new"" bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanzgründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern auch gewichtige programmiertechnische: Man markiert alle Stellen im Programm, an denen das sog. ""Fragile-base-class-Problem"" (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. Keine Deklaration.",Was ist der Unterschied zwischen dem Überschreiben von Methoden in Java und C-Sharp?,"In Java können alle Methoden überschrieben werden, während in C-Sharp dynamisch zu bindende Methoden unbedingt als solche zu deklarieren sind und eine überschreibende Methode mit dem Schlüsselwort ""override"" deklariert werden muss. Wenn eine Methode gleicher Signatur in einer Subklasse neu eingeführt werden soll, muss dies durch Verwendung des Schlüsselworts ""new"" bekanntgegeben werden. Diese Deklaration vermindert die Zahl der dynamischen Bindungen in einem Programm und markiert alle Stellen im Programm, an denen das sog. ""Fragile-base-class-Problem"" auftreten kann."
"Einige Sprachkonstrukte verwenden in C-Sharp andere Schlüsselwörter als Java, so ""lock"" anstatt ""synchronized"" sowie ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer Bedeutung leicht von denen Javas ab: So sind auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen (in Java erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anweisung enthält, muss mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen werden. Außerdem hat C-Sharp eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. All dies hat allerdings nichts mit Objektorientierung zu tun.",Wie unterscheidet sich C-Sharp von Java in Bezug auf Schlüsselwörter und Kontrollflussanweisungen?,"In C-Sharp werden einige Sprachkonstrukte mit anderen Schlüsselwörtern als in Java verwendet, wie zum Beispiel ""lock"" anstatt ""synchronized"" und ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen. Zudem sind in C-Sharp auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen und jeder Zweig muss mit einer expliziten Kontrollflussanweisung abgeschlossen werden. Im Gegensatz zu Java verfügt C-Sharp über eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. Diese Unterschiede haben jedoch nichts mit Objektorientierung zu tun."
"Einige Sprachkonstrukte verwenden in C-Sharp andere Schlüsselwörter als Java, so ""lock"" anstatt ""synchronized"" sowie ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer Bedeutung leicht von denen Javas ab: So sind auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen (in Java erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anweisung enthält, muss mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen werden. Außerdem hat C-Sharp eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. All dies hat allerdings nichts mit Objektorientierung zu tun.",Was sind die Unterschiede zwischen C-Sharp und Java in Bezug auf Sprachkonstrukte?,"Einige Sprachkonstrukte verwenden in C-Sharp andere Schlüsselwörter als Java, wie zum Beispiel ""lock"" anstatt ""synchronized"" und ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen. Andere weichen in ihrer Bedeutung leicht von denen Javas ab, wie zum Beispiel die Zulassung von ""Strings"" als Basis einer ""Switch""-Anweisung in C-Sharp und die Notwendigkeit einer expliziten Kontrollflussanweisung am Ende jedes Zweigs. Zudem hat C-Sharp eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. Diese Unterschiede haben jedoch nichts mit Objektorientierung zu tun."
"Wenn Sie sich bereits vor diesem Kurs mit objektorientierter Programmierung befasst haben, fragen Sie sich vielleicht, warum die Begriffe Superklasse und Subklasse bislang nicht erwähnt wurden. Das liegt daran, dass diese Begriffe in verschiedenen Programmiersprachen unterschiedliche Bedeutungen haben, während die Begriffe Generalisierung, Spezialisierung, Vererbung und abstrakte Klassen recht einheitlich interpretiert werden.",Was ist der Unterschied zwischen Superklasse und Subklasse?,"Die Begriffe Superklasse und Subklasse können in verschiedenen Programmiersprachen unterschiedliche Bedeutungen haben. In einigen Sprachen bezeichnet Superklasse die Oberklasse und Subklasse die Unterklasse, während in anderen Sprachen die Bedeutungen vertauscht sind. Daher werden in diesem Kurs die Begriffe Generalisierung und Spezialisierung verwendet, um die Beziehung zwischen Ober- und Unterklassen zu beschreiben."
"Die Subklassenbeziehung ist, genau wie die Generalisierung, Spezialisierung und Vererbung, eine Beziehung zwischen Klassen. Die beiden Enden dieser Beziehung tragen die Rollen Superklasse bzw. Subklasse; die Präfixe legen nahe, dass die Subklassenbeziehung eine Klassenhierarchie aufbaut, in der die Superklassen über den Subklassen stehen. Außerdem ist die Subklassenbeziehung transitiv: Wenn A eine Subklasse von B ist und B eine von C, dann ist A auch eine Subklasse von C. Analoges gilt natürlich auch für Superklassen. Man spricht übrigens von einer direkten Subklasse bzw. einer direkten Superklasse, wenn es keine weitere Klasse gibt, die in der Subklassenbeziehung dazwischen steht. Die Subklassenbeziehung ist (anders als die Subtypenbeziehung; vgl. Kapitel 26) nicht reflexiv (irreflexiv) — eine Klasse kann also keine Subklasse von sich selbst sein.",Was ist die Subklassenbeziehung in der Klassenhierarchie?,"Die Subklassenbeziehung ist eine Beziehung zwischen Klassen, bei der die Subklasse eine spezialisiertere Form der Superklasse ist. Die Subklassenbeziehung ist transitiv, d.h. wenn A eine Subklasse von B ist und B eine von C, dann ist A auch eine Subklasse von C. Eine Klasse kann nicht gleichzeitig Superklasse und Subklasse einer anderen Klasse sein."
"Generalisierung und Spezialisierung, wie oben dargestellt, sind eher theoretisch motivierte Konzepte. In der Programmierung orientiert man sich jedoch häufig, wie im obigen Beispiel mit Pinguinen angedeutet, an praktischen Gesichtspunkten. Daher haben nicht Generalisierung und Spezialisierung die Entwicklung objektorientierter Programmiersprachen geprägt, sondern abstrakte Klassen und Vererbung. Diese pragmatische Ausrichtung ist jedoch nicht ohne Probleme, und daher werden uns die Überlegungen zu Generalisierung und Spezialisierung spätestens in Kurseinheit 3 wieder begegnen.",Was sind abstrakte Klassen und Vererbung?,"Abstrakte Klassen und Vererbung sind wichtige Konzepte in der objektorientierten Programmierung. Abstrakte Klassen sind Klassen, die nicht instanziiert werden können, sondern nur als Basisklasse für andere Klassen dienen. Vererbung ist ein Mechanismus, bei dem eine Klasse (die Unterklasse) die Eigenschaften und Verhalten einer anderen Klasse (der Oberklasse) erbt. Die Unterklasse kann die Eigenschaften und Verhalten der Oberklasse erweitern oder modifizieren. Diese Konzepte ermöglichen es, Code zu modularisieren und wiederzuverwenden."
"Generalisierung und Spezialisierung, wie oben dargestellt, sind eher theoretisch motivierte Konzepte. In der Programmierung orientiert man sich jedoch häufig, wie im obigen Beispiel mit Pinguinen angedeutet, an praktischen Gesichtspunkten. Daher haben nicht Generalisierung und Spezialisierung die Entwicklung objektorientierter Programmiersprachen geprägt, sondern abstrakte Klassen und Vererbung. Diese pragmatische Ausrichtung ist jedoch nicht ohne Probleme, und daher werden uns die Überlegungen zu Generalisierung und Spezialisierung spätestens in Kurseinheit 3 wieder begegnen.","Was sind die praktischen Gesichtspunkte, die die Entwicklung objektorientierter Programmiersprachen geprägt haben?","Die praktischen Gesichtspunkte, die die Entwicklung objektorientierter Programmiersprachen geprägt haben, sind abstrakte Klassen und Vererbung. Diese Konzepte sind an praktischen Beispielen wie der Programmierung von Pinguinen ausgerichtet."
"Wie bereits in Kapitel 21 angedeutet, verlangt die Zuweisungskompatibilität nicht unbedingt Typäquivalenz. Tatsächlich reicht es aus, bei einer rein strukturellen (syntaktischen) Betrachtung, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält, um in der Folge Typfehler zu vermeiden. Anders ausgedrückt: Der Typ auf der rechten Seite einer Zuweisung darf eine Erweiterung dessen auf der linken Seite um zusätzliche Methoden sein.",Was ist die Bedingung für Typkompatibilität bei Zuweisungen in SMALLTALK?,"Für Typkompatibilität bei Zuweisungen in SMALLTALK reicht es aus, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält. Der Typ auf der rechten Seite einer Zuweisung darf also eine Erweiterung dessen auf der linken Seite um zusätzliche Methoden sein."
"Wie bereits in Kapitel 21 angedeutet, verlangt die Zuweisungskompatibilität nicht unbedingt Typäquivalenz. Tatsächlich reicht es aus, bei einer rein strukturellen (syntaktischen) Betrachtung, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält, um in der Folge Typfehler zu vermeiden. Anders ausgedrückt: Der Typ auf der rechten Seite einer Zuweisung darf eine Erweiterung dessen auf der linken Seite um zusätzliche Methoden sein.",Was ist für die Zuweisungskompatibilität notwendig?,"Für die Zuweisungskompatibilität ist es ausreichend, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält, um Typfehler zu vermeiden. Der Typ auf der rechten Seite einer Zuweisung darf eine Erweiterung dessen auf der linken Seite um zusätzliche Methoden sein."
"Wie bereits in Kapitel 21 angedeutet, verlangt die Zuweisungskompatibilität nicht unbedingt Typäquivalenz. Tatsächlich reicht es aus, bei einer rein strukturellen (syntaktischen) Betrachtung, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält, um in der Folge Typfehler zu vermeiden. Anders ausgedrückt: Der Typ auf der rechten Seite einer Zuweisung darf eine Erweiterung dessen auf der linken Seite um zusätzliche Methoden sein.",Was ist die Bedingung für Zuweisungskompatibilität in objektorientierten Programmiersprachen?,"Für Zuweisungskompatibilität in objektorientierten Programmiersprachen reicht es aus, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält, um Typfehler zu vermeiden."
"Die sogenannte Typerweiterung (engl. type extension; ""extension"" hier im Sinne von Erweiterung und nicht im Sinne der Ausdehnung als Gegenstück zur Intension) sieht genau dies vor.",Was ist Typerweiterung?,"Typerweiterung ist eine Technik, um bestehende Datentypen zu erweitern. Dabei wird ein neuer Datentyp definiert, der auf einem bestehenden Datentyp aufbaut und diesen erweitert. Diese Technik ermöglicht es, bestehende Datentypen zu nutzen und gleichzeitig neue Funktionen hinzuzufügen, ohne den ursprünglichen Datentyp zu verändern."
"Die sogenannte Typerweiterung (engl. type extension; ""extension"" hier im Sinne von Erweiterung und nicht im Sinne der Ausdehnung als Gegenstück zur Intension) sieht genau dies vor.",Wie funktioniert Typerweiterung?,"Typerweiterung wird zum Beispiel durch die Definition neuer Module erreicht, die den ursprünglichen Datentyp erweitern, indem sie neue Methoden hinzufügen. Diese neuen Module können dann verwendet werden, um auf die erweiterten Funktionen des Datentyps zuzugreifen, ohne den ursprünglichen Code zu ändern."
"Die sogenannte Typerweiterung (engl. type extension; ""extension"" hier im Sinne von Erweiterung und nicht im Sinne der Ausdehnung als Gegenstück zur Intension) sieht genau dies vor.",Was sind die Vorteile von Typerweiterung?,"Die Vorteile von Typerweiterung sind, dass sie es ermöglicht, bestehenden Code wiederzuverwenden und neue Funktionalität hinzuzufügen, ohne den ursprünglichen Code zu ändern. Dies führt zu einer besseren Codequalität, da weniger Änderungen am Code vorgenommen werden müssen und die Wahrscheinlichkeit von Fehlern reduziert wird."
"Die sogenannte Typerweiterung (engl. type extension; ""extension"" hier im Sinne von Erweiterung und nicht im Sinne der Ausdehnung als Gegenstück zur Intension) sieht genau dies vor.",Was sind die Nachteile von Typerweiterung?,"Die Nachteile von Typerweiterung sind, dass sie die Komplexität des Codes erhöhen kann, da es mehrere Versionen des gleichen Datentyps gibt. Dies kann zu Verwirrung führen und die Wartbarkeit des Codes beeinträchtigen. Außerdem kann Typerweiterung zu einer unkontrollierten Ausdehnung des Codes führen, wenn nicht sorgfältig geplant und implementiert wird."
"Der erweiternde Typ wird also relativ zu einem bereits bestehenden, dem erweiterten Typ definiert. Die Methodendeklarationen des erweiterten Typs werden dabei gewissermaßen an den erweiternden Typ vererbt; dieser braucht sie also nicht noch einmal zu wiederholen. Die Zuweisungskompatibilität unter Typerweiterung regelt der Begriff der Typkonformität.",Was ist ein erweiternder Typ?,"Ein erweiternder Typ, auch Untertyp genannt, ist eine Typdefinition, die auf einer bestehenden Typdefinition aufbaut und diese erweitert. Die Methodendeklarationen des erweiterten Typs werden dabei vererbt und müssen nicht noch einmal wiederholt werden."
"Der erweiternde Typ wird also relativ zu einem bereits bestehenden, dem erweiterten Typ definiert. Die Methodendeklarationen des erweiterten Typs werden dabei gewissermaßen an den erweiternden Typ vererbt; dieser braucht sie also nicht noch einmal zu wiederholen. Die Zuweisungskompatibilität unter Typerweiterung regelt der Begriff der Typkonformität.",Was ist der Begriff der Typkonformität?,Der Begriff der Typkonformität regelt die Zuweisungskompatibilität unter Typerweiterung.
"Analog zur Einführung von parametrisierten Typen abstrahieren die generischen Typen von Java von Typen, indem sie die Referenzierung eines oder mehrerer Typen innerhalb einer Typdefinition durch Typvariablen ersetzen. Anders als in STRONGTALK stehen die Typvariablen in Java jedoch nicht in eckigen, sondern in spitzen Klammern.",Was sind generische Typen in Java?,"Generische Typen in Java sind eine Abstraktion von Typen, bei der die Referenzierung eines oder mehrerer Typen innerhalb einer Typdefinition durch Typvariablen ersetzt wird. Diese Typvariablen stehen in Java jedoch nicht in eckigen, sondern in spitzen Klammern."
"Analog zur Einführung von parametrisierten Typen abstrahieren die generischen Typen von Java von Typen, indem sie die Referenzierung eines oder mehrerer Typen innerhalb einer Typdefinition durch Typvariablen ersetzen. Anders als in STRONGTALK stehen die Typvariablen in Java jedoch nicht in eckigen, sondern in spitzen Klammern.",Wie werden Typvariablen in Java bezeichnet?,In Java werden Typvariablen in generischen Typen in spitzen Klammern bezeichnet.
"Unabhängig davon, wie formal sie sind, sind Programmiersprachen Sprachen und ermöglichen es einer Autorin, sich auf eine persönliche Art und Weise auszudrücken. Die Ausdrucksweise bestimmt dabei nicht den Inhalt des Programms (seine Funktion), sondern seine Qualität. Zum Beispiel, wie effizient ein gegebenes Problem gelöst wird oder wie verständlich die Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat viel mit Schreibstil zu tun, aber auch andere Faktoren spielen in Stilfragen eine Rolle, wie Mode und Ästhetik (Eleganz).",Wie beeinflusst die Ausdrucksweise einer Programmiersprache die Qualität eines Programms?,"Die Ausdrucksweise einer Programmiersprache beeinflusst die Qualität eines Programms, indem sie die Effizienz der Problemlösung und die Verständlichkeit der Formulierung beeinflusst. Dies hängt von Faktoren wie Schreibstil, Mode und Ästhetik ab."
"Unabhängig davon, wie formal sie sind, sind Programmiersprachen Sprachen und ermöglichen es einer Autorin, sich auf eine persönliche Art und Weise auszudrücken. Die Ausdrucksweise bestimmt dabei nicht den Inhalt des Programms (seine Funktion), sondern seine Qualität. Zum Beispiel, wie effizient ein gegebenes Problem gelöst wird oder wie verständlich die Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat viel mit Schreibstil zu tun, aber auch andere Faktoren spielen in Stilfragen eine Rolle, wie Mode und Ästhetik (Eleganz).",Wie beeinflusst die Ausdrucksweise die Qualität eines Programms?,"Die Ausdrucksweise in Programmiersprachen beeinflusst die Qualität eines Programms, indem sie die Effizienz der Problemlösung und die Verständlichkeit der Formulierung beeinflusst. Dies hängt von Faktoren wie Schreibstil, Mode und Ästhetik ab."
"Unabhängig davon, wie formal sie sind, sind Programmiersprachen Sprachen und ermöglichen es einer Autorin, sich auf eine persönliche Art und Weise auszudrücken. Die Ausdrucksweise bestimmt dabei nicht den Inhalt des Programms (seine Funktion), sondern seine Qualität. Zum Beispiel, wie effizient ein gegebenes Problem gelöst wird oder wie verständlich die Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat viel mit Schreibstil zu tun, aber auch andere Faktoren spielen in Stilfragen eine Rolle, wie Mode und Ästhetik (Eleganz).",Warum spielt die Ausdrucksweise in Programmiersprachen eine Rolle?,"Die Ausdrucksweise in Programmiersprachen bestimmt nicht den Inhalt des Programms, sondern seine Qualität. Sie beeinflusst, wie effizient ein gegebenes Problem gelöst wird oder wie verständlich die Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat viel mit Schreibstil zu tun, aber auch andere Faktoren wie Mode und Ästhetik (Eleganz) spielen eine Rolle."
"Es hat zweifellos in den letzten Jahrzehnten einen Wandel in Stilfragen gegeben, weg von einem mathematisch prägnanten Stil hin zu einem prosaisch-verbosen Stil.",Was ist der Unterschied zwischen einem mathematisch prägnanten Stil und einem prosaisch-verbosen Stil in der Programmierung?,"Ein mathematisch prägnanter Stil in der Programmierung zeichnet sich durch eine kompakte und präzise Schreibweise aus, während ein prosaisch-verboser Stil durch eine ausführliche und detaillierte Schreibweise gekennzeichnet ist."
"Es hat zweifellos in den letzten Jahrzehnten einen Wandel in Stilfragen gegeben, weg von einem mathematisch prägnanten Stil hin zu einem prosaisch-verbosen Stil.",Was versteht man unter einem mathematisch prägnanten Stil in der Programmierung?,"Ein mathematisch prägnanter Stil in der Programmierung zeichnet sich durch eine kompakte, präzise und logische Schreibweise aus, die an die mathematische Notation erinnert. Er vermeidet unnötige Wiederholungen und nutzt stattdessen abstrakte Konzepte und Funktionen, um die Absicht des Programmcodes klar und eindeutig auszudrücken. Diese Art der Programmierung wird oft als ""sauber"" und ""elegant"" angesehen, da sie die Komplexität reduziert und die Wartbarkeit des Codes verbessert."
"Es handelt sich dabei um ein PASCAL-Programm zur Lösung des Problems der stabilen Heirat. Ein bedeutender Anteil aller Variablen in Programmen trägt oft den Namen ""i"". In diesem Beispiel sind die Variablen jedoch als ""r"", ""m"", ""w"" usw. benannt. Das grundlegende Problem bleibt jedoch dasselbe: Man muss sich vertieft in das Programm und den dazugehörigen Text einarbeiten, um zu verstehen, wofür die Variablen stehen.",Warum ist die Verwendung aussagekräftiger Variablennamen wichtig?,"Die Verwendung aussagekräftiger Variablennamen ist wichtig, um das Verständnis des Programms zu erleichtern. Wenn Variablennamen wie ""i"" verwendet werden, ist es schwieriger zu verstehen, wofür die Variablen stehen. Durch die Verwendung aussagekräftiger Variablennamen wie ""r"", ""m"" oder ""w"" in diesem Beispiel wird das Programm jedoch leichter verständlich."
"Es handelt sich dabei um ein PASCAL-Programm zur Lösung des Problems der stabilen Heirat. Ein bedeutender Anteil aller Variablen in Programmen trägt oft den Namen ""i"". In diesem Beispiel sind die Variablen jedoch als ""r"", ""m"", ""w"" usw. benannt. Das grundlegende Problem bleibt jedoch dasselbe: Man muss sich vertieft in das Programm und den dazugehörigen Text einarbeiten, um zu verstehen, wofür die Variablen stehen.","Was ist das grundlegende Problem bei der Verwendung von Variablennamen wie ""i"" in Programmen?","Das grundlegende Problem ist, dass man sich vertieft in das Programm und den dazugehörigen Text einarbeiten muss, um zu verstehen, wofür die Variablen stehen."
"Es handelt sich dabei um ein PASCAL-Programm zur Lösung des Problems der stabilen Heirat. Ein bedeutender Anteil aller Variablen in Programmen trägt oft den Namen ""i"". In diesem Beispiel sind die Variablen jedoch als ""r"", ""m"", ""w"" usw. benannt. Das grundlegende Problem bleibt jedoch dasselbe: Man muss sich vertieft in das Programm und den dazugehörigen Text einarbeiten, um zu verstehen, wofür die Variablen stehen.",Wozu können temporäre Variablen in Programmen dienen?,"Temporäre Variablen können in Programmen zur besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben."
"Es handelt sich dabei um ein PASCAL-Programm zur Lösung des Problems der stabilen Heirat. Ein bedeutender Anteil aller Variablen in Programmen trägt oft den Namen ""i"". In diesem Beispiel sind die Variablen jedoch als ""r"", ""m"", ""w"" usw. benannt. Das grundlegende Problem bleibt jedoch dasselbe: Man muss sich vertieft in das Programm und den dazugehörigen Text einarbeiten, um zu verstehen, wofür die Variablen stehen.",Wann werden temporäre Variablen vom System entfernt?,Temporäre Variablen werden vom System nach Beendigung der Methode entfernt.
"Es handelt sich dabei um ein PASCAL-Programm zur Lösung des Problems der stabilen Heirat. Ein bedeutender Anteil aller Variablen in Programmen trägt oft den Namen ""i"". In diesem Beispiel sind die Variablen jedoch als ""r"", ""m"", ""w"" usw. benannt. Das grundlegende Problem bleibt jedoch dasselbe: Man muss sich vertieft in das Programm und den dazugehörigen Text einarbeiten, um zu verstehen, wofür die Variablen stehen.",Sind die Werte temporärer Variablen außerhalb der Methode sichtbar?,"Nein, die Werte temporärer Variablen sind außerhalb der Methode nicht sichtbar."
"Es handelt sich dabei um ein PASCAL-Programm zur Lösung des Problems der stabilen Heirat. Ein bedeutender Anteil aller Variablen in Programmen trägt oft den Namen ""i"". In diesem Beispiel sind die Variablen jedoch als ""r"", ""m"", ""w"" usw. benannt. Das grundlegende Problem bleibt jedoch dasselbe: Man muss sich vertieft in das Programm und den dazugehörigen Text einarbeiten, um zu verstehen, wofür die Variablen stehen.",Wann müssen temporäre Variablen in einer Methode deklariert werden?,Temporäre Variablen müssen in einer Methode zu Beginn der Methode (nach der Methodensignatur und vor der ersten Anweisung) deklariert werden.
"Heute ist es üblich, Bezeichner (Namen für Module, Typen, Variablen, Prozeduren und Funktionen) in einem Programm so zu wählen, dass Kommentare zur Bedeutung der jeweiligen Programmelemente unnötig sind, da die Bezeichner ihre Bedeutung bereits im Kontext ausdrücken. Es wird sogar argumentiert, dass ein gut geschriebenes objektorientiertes Programm keine Kommentare benötigt. Trotzdem gibt es Fälle, in denen eine Lösung, auch wenn sie in ihrer verständlichsten Form vorliegt, weniger elegant ist als eine raffinierte Variante, die nicht jedem sofort ersichtlich ist. In solchen Situationen ist die Versuchung groß, die geistreichere Lösung zu wählen und sie mit einem erklärenden Kommentar zu versehen, für diejenigen Leserinnen, die nicht sofort folgen können. Einige der berühmtesten Algorithmen sind nicht offensichtlich und haben ihren Autoren zu Ruhm verholfen.",Warum sind Kommentare in einem Programm nicht immer notwendig?,"Heutzutage ist es üblich, Bezeichner in einem Programm so zu wählen, dass Kommentare zur Bedeutung der jeweiligen Programmelemente unnötig sind, da die Bezeichner ihre Bedeutung bereits im Kontext ausdrücken. Ein gut geschriebenes objektorientiertes Programm benötigt daher eigentlich keine Kommentare."
"Heute ist es üblich, Bezeichner (Namen für Module, Typen, Variablen, Prozeduren und Funktionen) in einem Programm so zu wählen, dass Kommentare zur Bedeutung der jeweiligen Programmelemente unnötig sind, da die Bezeichner ihre Bedeutung bereits im Kontext ausdrücken. Es wird sogar argumentiert, dass ein gut geschriebenes objektorientiertes Programm keine Kommentare benötigt. Trotzdem gibt es Fälle, in denen eine Lösung, auch wenn sie in ihrer verständlichsten Form vorliegt, weniger elegant ist als eine raffinierte Variante, die nicht jedem sofort ersichtlich ist. In solchen Situationen ist die Versuchung groß, die geistreichere Lösung zu wählen und sie mit einem erklärenden Kommentar zu versehen, für diejenigen Leserinnen, die nicht sofort folgen können. Einige der berühmtesten Algorithmen sind nicht offensichtlich und haben ihren Autoren zu Ruhm verholfen.",Warum werden Kommentare in einem gut geschriebenen objektorientierten Programm nicht benötigt?,"In einem gut geschriebenen objektorientierten Programm werden Bezeichner (Namen für Module, Typen, Variablen, Prozeduren und Funktionen) so gewählt, dass sie ihre Bedeutung bereits im Kontext ausdrücken, wodurch Kommentare unnötig werden."
"Da die meisten von Ihnen wahrscheinlich nie beruflich mit SMALLTALK programmieren werden, werden wir uns in dieser und der nächsten Kurseinheit anderen objektorientierten Programmiersprachen zuwenden. Dabei wird Java den größten Raum einnehmen. Einerseits ist Java immer noch die am weitesten verbreitete objektorientierte Programmiersprache, und andererseits erlaubt es viele Parallelen zu SMALLTALK, was eine gute Brücke zu anderen Programmiersprachen schafft. Aus theoretischer Sicht nimmt Java jedoch keine besondere Position ein, und sein Erfolg war wahrscheinlich eher auf das Internet zurückzuführen (Java hatte zuvor die Rolle, die heute JavaSCRIPT hat), als auf ein besonders geniales Sprachdesign.Aus der Ferne betrachtet ist Java eine Mischung aus SMALLTALK und C++. Von C++ wurden weite Teile der Syntax und der statischen Typüberprüfung übernommen sowie der eher klassisch prozedurale Charakter (Methodenaufrufe anstelle von Nachrichtenversand). Von SMALLTALK übernahm es die umfassende Objektorientierung (es gibt keinen Code außerhalb von Klassen), die Einfachvererbung sowie die Garbage Collection (um nur die wichtigsten Punkte zu nennen). Wenn Sie jedoch genauer verstehen möchten, was Java ist und warum es so ist, wie es ist, sollten Sie einen Blick in seine Geschichte werfen. Ich empfehle dringend, ""The Long Strange Trip to Java"" von PATRICK NAUGHTON zu lesen; danach wird Ihnen wahrscheinlich einiges klarer sein.",Wie würden Sie die Programmiersprache Java beschreiben?,"Java ist eine Programmiersprache, die eine Mischung aus SMALLTALK und C++ ist. Es übernahm weite Teile der Syntax und der statischen Typüberprüfung von C++ sowie den eher klassisch prozeduralen Charakter. Andererseits übernahm es die umfassende Objektorientierung, die Einfachvererbung und die Garbage Collection von SMALLTALK."
"Da die meisten von Ihnen wahrscheinlich nie beruflich mit SMALLTALK programmieren werden, werden wir uns in dieser und der nächsten Kurseinheit anderen objektorientierten Programmiersprachen zuwenden. Dabei wird Java den größten Raum einnehmen. Einerseits ist Java immer noch die am weitesten verbreitete objektorientierte Programmiersprache, und andererseits erlaubt es viele Parallelen zu SMALLTALK, was eine gute Brücke zu anderen Programmiersprachen schafft. Aus theoretischer Sicht nimmt Java jedoch keine besondere Position ein, und sein Erfolg war wahrscheinlich eher auf das Internet zurückzuführen (Java hatte zuvor die Rolle, die heute JavaSCRIPT hat), als auf ein besonders geniales Sprachdesign.Aus der Ferne betrachtet ist Java eine Mischung aus SMALLTALK und C++. Von C++ wurden weite Teile der Syntax und der statischen Typüberprüfung übernommen sowie der eher klassisch prozedurale Charakter (Methodenaufrufe anstelle von Nachrichtenversand). Von SMALLTALK übernahm es die umfassende Objektorientierung (es gibt keinen Code außerhalb von Klassen), die Einfachvererbung sowie die Garbage Collection (um nur die wichtigsten Punkte zu nennen). Wenn Sie jedoch genauer verstehen möchten, was Java ist und warum es so ist, wie es ist, sollten Sie einen Blick in seine Geschichte werfen. Ich empfehle dringend, ""The Long Strange Trip to Java"" von PATRICK NAUGHTON zu lesen; danach wird Ihnen wahrscheinlich einiges klarer sein.",Was ist Java und warum hat es Merkmale von SMALLTALK und C++ übernommen?,"Java ist eine Programmiersprache, die Merkmale von SMALLTALK und C++ übernommen hat. Es hat die Syntax und die statische Typüberprüfung von C++ sowie den eher klassisch prozeduralen Charakter übernommen. Andererseits hat es die umfassende Objektorientierung, die Einfachvererbung und die Garbage Collection von SMALLTALK übernommen. Die Gründe dafür liegen in seiner Geschichte, die man in ""The Long Strange Trip to Java"" von PATRICK NAUGHTON nachlesen kann."
"Indexer übertragen gewissermaßen das Konzept der indizierten Instanzvariablen von SMALLTALK auf C-Sharp: Jede Instanz einer Klasse, für die ein Indexer definiert ist, hat eine Menge von (scheinbar unbenannten) Instanzvariablen, auf die über einen Index zugegriffen werden kann. Allerdings muss die indizierte Instanzvariable klassenintern durch eine normale, benannte Instanzvariable (Feld) repräsentiert werden. Indexer ähneln Properties insofern, als der Zugriff über einen Index mittels entsprechender Get- und Set-Abbildungen auf einen Zugriff auf eine benannte Instanzvariable übertragen wird. Dabei wird das Schlüsselwort ""this"" missbraucht, um anzudeuten, dass bei Zugriffen auf die indizierte Instanzvariable kein Name einer Instanzvariable (eines Feldes) steht, sondern lediglich der Name des Objekts, zu dem sie gehört.",Was sind Indexer in C-Sharp?,"Indexer in C-Sharp sind eine Möglichkeit, auf Instanzvariablen über einen Index zuzugreifen. Sie ähneln Properties, da der Zugriff über einen Index mittels entsprechender Get- und Set-Abbildungen auf einen Zugriff auf eine benannte Instanzvariable übertragen wird. Jede Instanz einer Klasse, für die ein Indexer definiert ist, hat eine Menge von (scheinbar unbenannten) Instanzvariablen, auf die über einen Index zugegriffen werden kann."
"Indexer übertragen gewissermaßen das Konzept der indizierten Instanzvariablen von SMALLTALK auf C-Sharp: Jede Instanz einer Klasse, für die ein Indexer definiert ist, hat eine Menge von (scheinbar unbenannten) Instanzvariablen, auf die über einen Index zugegriffen werden kann. Allerdings muss die indizierte Instanzvariable klassenintern durch eine normale, benannte Instanzvariable (Feld) repräsentiert werden. Indexer ähneln Properties insofern, als der Zugriff über einen Index mittels entsprechender Get- und Set-Abbildungen auf einen Zugriff auf eine benannte Instanzvariable übertragen wird. Dabei wird das Schlüsselwort ""this"" missbraucht, um anzudeuten, dass bei Zugriffen auf die indizierte Instanzvariable kein Name einer Instanzvariable (eines Feldes) steht, sondern lediglich der Name des Objekts, zu dem sie gehört.","Was bedeutet der Einsatz des Schlüsselworts ""this"" in Bezug auf Indexer?","Im Kontext von Indexer wird das Schlüsselwort ""this"" missbraucht, um anzudeuten, dass bei Zugriffen auf die indizierte Instanzvariable kein Name einer Instanzvariable (eines Feldes) steht, sondern lediglich der Name des Objekts, zu dem sie gehört."
"Nun darf der Indexer in C-Sharp überladen werden, sodass ein Objekt mehrere indizierte Instanzvariablen haben kann. Der Zugriff erfolgt aufgrund des fehlenden Namens einzig über den Typ des Indexes. Durch das Überladen ist es wiederum möglich, nicht eine, sondern mehrere indizierte Instanzvariablen zu simulieren, wobei jedoch die Einschränkung besteht, dass der Elementtyp (der Rückgabetyp beim Überladen) gleich bleiben muss. Schließlich muss ein Indexer in C-Sharp auf keine interne (benannte) Instanzvariable zugreifen – alle Inhalte können, genau wie bei Properties, auch berechnet werden.","Was bedeutet es, wenn der Indexer in C-Sharp überladen wird?","Wenn der Indexer in C-Sharp überladen wird, kann ein Objekt mehrere indizierte Instanzvariablen haben. Der Zugriff erfolgt aufgrund des fehlenden Namens einzig über den Typ des Indexes. Durch das Überladen ist es wiederum möglich, nicht eine, sondern mehrere indizierte Instanzvariablen zu simulieren, wobei jedoch die Einschränkung besteht, dass der Elementtyp (der Rückgabetyp beim Überladen) gleich bleiben muss."
"Nun darf der Indexer in C-Sharp überladen werden, sodass ein Objekt mehrere indizierte Instanzvariablen haben kann. Der Zugriff erfolgt aufgrund des fehlenden Namens einzig über den Typ des Indexes. Durch das Überladen ist es wiederum möglich, nicht eine, sondern mehrere indizierte Instanzvariablen zu simulieren, wobei jedoch die Einschränkung besteht, dass der Elementtyp (der Rückgabetyp beim Überladen) gleich bleiben muss. Schließlich muss ein Indexer in C-Sharp auf keine interne (benannte) Instanzvariable zugreifen – alle Inhalte können, genau wie bei Properties, auch berechnet werden.",Was ist ein Indexer in C-Sharp?,"Ein Indexer in C-Sharp ist eine spezielle Art von Methode, die es ermöglicht, auf Instanzvariablen eines Objekts über einen Index zuzugreifen. Der Indexer kann überladen werden, um mehrere indizierte Instanzvariablen zu simulieren, wobei der Elementtyp (der Rückgabetyp beim Überladen) gleich bleiben muss. Der Zugriff auf den Indexer erfolgt aufgrund des fehlenden Namens einzig über den Typ des Indexes. Der Inhalt des Indexers muss nicht zwangsläufig auf eine interne Instanzvariable zugreifen, sondern kann auch berechnet werden."
"Nun darf der Indexer in C-Sharp überladen werden, sodass ein Objekt mehrere indizierte Instanzvariablen haben kann. Der Zugriff erfolgt aufgrund des fehlenden Namens einzig über den Typ des Indexes. Durch das Überladen ist es wiederum möglich, nicht eine, sondern mehrere indizierte Instanzvariablen zu simulieren, wobei jedoch die Einschränkung besteht, dass der Elementtyp (der Rückgabetyp beim Überladen) gleich bleiben muss. Schließlich muss ein Indexer in C-Sharp auf keine interne (benannte) Instanzvariable zugreifen – alle Inhalte können, genau wie bei Properties, auch berechnet werden.",Was ist ein Indexer in C-Sharp und wie kann er verwendet werden?,"Ein Indexer in C-Sharp ist eine Art Eigenschaft, die es ermöglicht, auf Objekte über einen Index zuzugreifen, anstatt über einen Namen. Er kann überladen werden, um mehrere indizierte Instanzvariablen zu simulieren, wobei der Elementtyp gleich bleiben muss. Der Indexer muss nicht auf eine interne Instanzvariable zugreifen, sondern kann auch auf berechnete Werte zugreifen."
"Man kann sich fragen, ob sich die Einhaltung des Law of Demeter so wie die Einhaltung der Zugreifbarkeitsregeln automatisch überprüfen lässt. Dabei gibt es aber ein Problem: Das Gesetz ist nämlich oben in Termini von Objekten, nicht von Variablen oder Typen formuliert. Eine Überprüfung würde also die Auswertung von konkreten Zuweisungen und damit des dynamischen Programmflusses erfordern, die aber mechanisch extrem aufwendig bis gar nicht durchzuführen ist. Statt dessen prüfen automatische Checker des Law of Demeter zumeist lediglich die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters (wenn der Aufruf aus einer Methode heraus erfolgt, was meistens der Fall ist) haben. Daraus folgt, dass eine solche Prüfung in SMALLTALK nicht möglich ist (da Ausdrücke nicht typisiert sind).",Kann die Einhaltung des Law of Demeter automatisch überprüft werden?,"Die Einhaltung des Law of Demeter kann nicht automatisch überprüft werden, da das Gesetz in Termini von Objekten und nicht von Variablen oder Typen formuliert ist. Automatische Checker prüfen zumeist nur die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters haben. In SMALLTALK ist eine solche Prüfung nicht möglich, da Ausdrücke nicht typisiert sind."
"Man kann sich fragen, ob sich die Einhaltung des Law of Demeter so wie die Einhaltung der Zugreifbarkeitsregeln automatisch überprüfen lässt. Dabei gibt es aber ein Problem: Das Gesetz ist nämlich oben in Termini von Objekten, nicht von Variablen oder Typen formuliert. Eine Überprüfung würde also die Auswertung von konkreten Zuweisungen und damit des dynamischen Programmflusses erfordern, die aber mechanisch extrem aufwendig bis gar nicht durchzuführen ist. Statt dessen prüfen automatische Checker des Law of Demeter zumeist lediglich die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters (wenn der Aufruf aus einer Methode heraus erfolgt, was meistens der Fall ist) haben. Daraus folgt, dass eine solche Prüfung in SMALLTALK nicht möglich ist (da Ausdrücke nicht typisiert sind).","Warum ist es in SMALLTALK nicht möglich, das Law of Demeter automatisch zu überprüfen?","Das Law of Demeter kann in SMALLTALK nicht automatisch überprüft werden, da Ausdrücke nicht typisiert sind und die Prüfung daher nicht auf Variablendeklarationen und Methodenaufrufe beschränkt werden kann. Stattdessen würde eine Überprüfung die Auswertung von konkreten Zuweisungen und damit des dynamischen Programmflusses erfordern, was mechanisch extrem aufwendig bis gar nicht durchführbar ist."
"Was aber tun, wenn man gleichzeitig die Funktion von Ausdrücken haben will und Demeters Gesetz folgen möchte? Die Antwort ist einfach: Man erweitert das Protokoll der Klasse des ersten Nachrichtenempfängers um die Methode(n), die man nicht verkettet aufrufen darf, also beispielsweise die Klasse des von ""a"" benannten Objekts um die Methode ""doY"". Da ""a"" das Ergebnis von ""doX"" ist, nennen wir es ""b"", muss ""a"" auch die Methode ""doY"" aufrufen und das Ergebnis zurückgeben. Die Implementierung von ""doY"" würde dann durch ""^ b doY"" abgeschlossen.",Wie kann man Demeters Gesetz folgen und gleichzeitig die Funktion von Ausdrücken haben?,"Man erweitert das Protokoll der Klasse des ersten Nachrichtenempfängers um die Methode(n), die man nicht verkettet aufrufen darf, und lässt das Ergebnis von ""doX"" die Methode ""doY"" aufrufen und das Ergebnis zurückgeben."
"Komplizierter wird die Sache jedoch, wenn die Verkettung länger ist, wenn also der zu vermeidende Ausdruck ""a doX doY doZ"" heißen würde, denn dann müsste auch noch ""doZ"" zur Klasse von ""a"" hinzugefügt und mit entsprechenden Implementierungen versehen werden. Man ahnt schon, wohin das führt: zu einem Wachstum des Protokolls von ""a"".","Was passiert, wenn die Verkettung von Nachrichtenausdrücken länger wird?","Wenn die Verkettung von Nachrichtenausdrücken länger wird, wird das Protokoll der Klasse von ""a"" komplexer und muss mit entsprechenden Implementierungen versehen werden."
"Nicht selten möchte eine überschreibende Methode die überschriebene Methode nicht vollständig ersetzen, sondern lediglich modifizieren. Dies ist z. B. regelmäßig bei den als Konstruktoren fungierenden Klassenmethoden new und new: der Fall: Selbst wenn sie überschrieben werden, müssen sie doch das grundlegende Verhalten beibehalten, also neue Instanzen der Klasse zurückgeben. Dies geschieht am sinnvollsten, indem aus der überschreibenden Methode die überschriebene Methode aufgerufen und um die gewünschten zusätzlichen Ausdrücke ergänzt wird. Nur leider ist diese nicht mehr sichtbar — sie wurde ja gerade überschrieben. Für diesen Zweck verfügt SMALLTALK über eine weitere Pseudovariable namens „super“.",Was ist die Funktion der Pseudovariablen „super“ in SMALLTALK?,"Die Pseudovariable „super“ in SMALLTALK wird verwendet, um die überschriebene Methode aufzurufen, wenn eine überschreibende Methode lediglich modifizieren möchte, aber das grundlegende Verhalten beibehalten muss."
"Die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der (direkten) Superklasse der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet.",Was bewirkt die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition?,"Die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der (direkten) Superklasse der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet."
"Die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der (direkten) Superklasse der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet.",Was bewirkt die Verwendung von self als Nachrichtenempfänger in einer Methodendefinition?,"Die Verwendung von self als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet."
"Die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der (direkten) Superklasse der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet.",Was bewirkt die Verwendung von this als Nachrichtenempfänger in einer Methodendefinition?,"Die Verwendung von this als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet."
"Man beachte, dass die Suche anders als bei self unabhängig von der Klasse des Objekts ist, für das super steht: Obwohl super genau wie self als Objekt stets den aktuellen Nachrichtenempfänger bezeichnet, bewirkt super immer eine von der Klasse des konkreten Empfängerobjekts losgelöste Suche, die eben mit der Superklasse der Klasse, in der super verwendet wird, beginnt und nicht etwa mit der Superklasse der Klasse, von der das (durch super bezeichnete) Empfängerobjekt eine direkte Instanz ist.",Was ist der Unterschied zwischen self und super in der Objektsuche?,"Der Unterschied liegt darin, dass die Suche bei self von der Klasse des Objekts abhängt, für das self steht, während die Suche bei super unabhängig von der Klasse des Objekts ist, für das super steht. Super beginnt die Suche immer mit der Superklasse der Klasse, in der super verwendet wird, und nicht mit der Superklasse der Klasse, von der das Empfängerobjekt eine direkte Instanz ist."
"Man beachte, dass die Suche anders als bei self unabhängig von der Klasse des Objekts ist, für das super steht: Obwohl super genau wie self als Objekt stets den aktuellen Nachrichtenempfänger bezeichnet, bewirkt super immer eine von der Klasse des konkreten Empfängerobjekts losgelöste Suche, die eben mit der Superklasse der Klasse, in der super verwendet wird, beginnt und nicht etwa mit der Superklasse der Klasse, von der das (durch super bezeichnete) Empfängerobjekt eine direkte Instanz ist.",Was bewirkt die Verwendung von super?,"Die Verwendung von super bewirkt eine Suche, die mit der Superklasse der Klasse beginnt, in der super verwendet wird, und nicht mit der Superklasse der Klasse, von der das Empfängerobjekt eine direkte Instanz ist."
"Man beachte, dass die Suche anders als bei self unabhängig von der Klasse des Objekts ist, für das super steht: Obwohl super genau wie self als Objekt stets den aktuellen Nachrichtenempfänger bezeichnet, bewirkt super immer eine von der Klasse des konkreten Empfängerobjekts losgelöste Suche, die eben mit der Superklasse der Klasse, in der super verwendet wird, beginnt und nicht etwa mit der Superklasse der Klasse, von der das (durch super bezeichnete) Empfängerobjekt eine direkte Instanz ist.",Wie unterscheidet sich die Suche bei self und super?,"Die Suche bei self ist abhängig von der Klasse des Objekts, für das self steht, während die Suche bei super unabhängig von der Klasse des Objekts ist, für das super steht. Bei super beginnt die Suche mit der Superklasse der Klasse, in der super verwendet wird, und nicht mit der Superklasse der Klasse, von der das Empfängerobjekt eine direkte Instanz ist."
"In SMALLTALK muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. So kann also insbesondere self nicht (wie beispielsweise this in Java) weggelassen werden, wenn ein Objekt eine Nachricht an sich selbst senden möchte. Wie bereits in Abschnitt 4.3.1 erwähnt, bezeichnet die Pseudovariable self immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind. (Die einzige Ausnahme hiervon bilden Blöcke, in denen self sich auf den Empfänger des Home-Kontexts bezieht; siehe Abschnitt 4.4.1 in Kurseinheit 1).",Wie wird das Empfängerobjekt eines Nachrichtenversands in SMALLTALK angegeben?,"In SMALLTALK muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. So kann also insbesondere self nicht weggelassen werden, wenn ein Objekt eine Nachricht an sich selbst senden möchte."
"In SMALLTALK muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. So kann also insbesondere self nicht (wie beispielsweise this in Java) weggelassen werden, wenn ein Objekt eine Nachricht an sich selbst senden möchte. Wie bereits in Abschnitt 4.3.1 erwähnt, bezeichnet die Pseudovariable self immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind. (Die einzige Ausnahme hiervon bilden Blöcke, in denen self sich auf den Empfänger des Home-Kontexts bezieht; siehe Abschnitt 4.4.1 in Kurseinheit 1).",Was ist die Rolle von self in Smalltalk?,"In Smalltalk muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. self bezeichnet immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind."
"In SMALLTALK muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. So kann also insbesondere self nicht (wie beispielsweise this in Java) weggelassen werden, wenn ein Objekt eine Nachricht an sich selbst senden möchte. Wie bereits in Abschnitt 4.3.1 erwähnt, bezeichnet die Pseudovariable self immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind. (Die einzige Ausnahme hiervon bilden Blöcke, in denen self sich auf den Empfänger des Home-Kontexts bezieht; siehe Abschnitt 4.4.1 in Kurseinheit 1).",Was bezeichnet die Pseudovariable self in Smalltalk?,"Die Pseudovariable self bezeichnet immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind."
"Dabei ist allerdings zu beachten, dass die Klasse des durch self bezeichneten Objekts nicht unbedingt dieselbe sein muss, in der die gerade ausgeführte Methode (in der auch das self steht) definiert ist, denn das kann ja aufgrund von Vererbung durchaus eine Superklasse sein. Das hat eine fundamentale Auswirkung: Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden, nämlich dann, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde.",Was ist die Bedeutung von self in Smalltalk?,"In Smalltalk bezieht sich self auf das Objekt, auf das die gerade ausgeführte Methode angewendet wird. Die Klasse des durch self bezeichneten Objekts muss nicht unbedingt dieselbe sein, in der die Methode definiert ist, sondern kann durchaus eine Superklasse sein. Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden."
"Dabei ist allerdings zu beachten, dass die Klasse des durch self bezeichneten Objekts nicht unbedingt dieselbe sein muss, in der die gerade ausgeführte Methode (in der auch das self steht) definiert ist, denn das kann ja aufgrund von Vererbung durchaus eine Superklasse sein. Das hat eine fundamentale Auswirkung: Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden, nämlich dann, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde.","Was passiert, wenn an self eine Nachricht geschickt wird?","Wenn an self eine Nachricht geschickt wird, wird die zu dieser Nachricht passende Methode gesucht. Die Suche beginnt in der Klasse, in der die gerade ausgeführte Methode definiert ist. Wenn die Methode nicht in dieser Klasse gefunden wird, wird die Suche in der Kette der Superklassen fortgesetzt, bis die Methode gefunden wird."
"Dabei ist allerdings zu beachten, dass die Klasse des durch self bezeichneten Objekts nicht unbedingt dieselbe sein muss, in der die gerade ausgeführte Methode (in der auch das self steht) definiert ist, denn das kann ja aufgrund von Vererbung durchaus eine Superklasse sein. Das hat eine fundamentale Auswirkung: Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden, nämlich dann, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde.","Was passiert, wenn an self eine Nachricht geschickt wird, die in der Klasse des Objekts nicht definiert ist?","Wenn an self eine Nachricht geschickt wird, die in der Klasse des Objekts nicht definiert ist, wird die Suche nach der passenden Methode in der Kette der Superklassen fortgesetzt, bis die Methode gefunden wird."
"Man beachte, dass Vererbung tatsächlich eine Kopieren-und-Einfügen-Semantik hat, wie in Abschnitt 11.2 bereits nahegelegt: Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.",Wie funktioniert die Vererbung in SMALLTALK?,"In SMALLTALK hat Vererbung eine Kopieren-und-Einfügen-Semantik, d.h. wenn man die Implementierung einer Methode aus der Superklasse in die Subklasse wiederholt, erhält man das gleiche Ergebnis."
"Man beachte, dass Vererbung tatsächlich eine Kopieren-und-Einfügen-Semantik hat, wie in Abschnitt 11.2 bereits nahegelegt: Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.",Was bedeutet die Vererbung in der objektorientierten Programmierung?,"In der objektorientierten Programmierung hat Vererbung eine Kopieren-und-Einfügen-Semantik, was bedeutet, dass wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt."
"Man beachte, dass Vererbung tatsächlich eine Kopieren-und-Einfügen-Semantik hat, wie in Abschnitt 11.2 bereits nahegelegt: Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.",Was versteht man unter Kopieren-und-Einfügen-Semantik bei Vererbung?,"Bei der Kopieren-und-Einfügen-Semantik bei Vererbung wird die Implementierung der übergeordneten Klasse in die Unterklasse kopiert und kann dann in der Unterklasse gegebenenfalls angepasst werden. Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt."
"Während offene Rekursion im gegebenen Beispiel durchaus erwünscht ist und ihr Effekt wohl auch den Erwartungen der Programmiererin entspricht, ergeben sich doch immer wieder Konstellationen, in denen man unangenehm überrascht wird. Das Problem ist unter dem Namen ""Fragile-base-class-Problem"" bekannt geworden; es wird in Kapitel 55 (Kurseinheit 6) ausführlicher behandelt. Fragile-base-class-Probleme entstehen durch die Möglichkeit der offenen Rekursion.",Wann sollte man offene Rekursion nicht verwenden?,"Man sollte offene Rekursion nicht verwenden, wenn sie zu Problemen führen kann, die als ""Fragile-base-class-Problem"" bekannt sind."
"Die objektorientierte Weltsicht, die auch in diesem Kurs propagiert wird (nämlich die von den Objekten, die einander Nachrichten schicken und die auf den Empfang von Nachrichten reagieren, indem sie ihren Zustand ändern und weitere Nachrichten verschicken), legt nahe, dass Objekte aktiv sind, will sagen, dass sie über einen eigenen Rechenprozess verfügen. Doch schon in Abschnitt 4.3.2 wurde klar, dass es damit in der Realität nicht weit her ist: Es werden in der Praxis keine Nachrichten verschickt, sondern lediglich Methoden aufgerufen. Abgesehen vom dynamischen Binden dieser Methoden unterscheidet sich damit das Ausführungsmodell der objektorientierten Programmierung nicht von dem der prozeduralen Programmierung (à la PASCAL); insbesondere sind alle Objekte passiv (was soviel bedeutet, wie dass sie nur aktiv sind, solange sie gerade eine Methode ausführen).",Sind Objekte in der objektorientierten Programmierung aktiv oder passiv?,"Objekte in der objektorientierten Programmierung sind passiv, was bedeutet, dass sie nur aktiv sind, solange sie gerade eine Methode ausführen."
"Die objektorientierte Weltsicht, die auch in diesem Kurs propagiert wird (nämlich die von den Objekten, die einander Nachrichten schicken und die auf den Empfang von Nachrichten reagieren, indem sie ihren Zustand ändern und weitere Nachrichten verschicken), legt nahe, dass Objekte aktiv sind, will sagen, dass sie über einen eigenen Rechenprozess verfügen. Doch schon in Abschnitt 4.3.2 wurde klar, dass es damit in der Realität nicht weit her ist: Es werden in der Praxis keine Nachrichten verschickt, sondern lediglich Methoden aufgerufen. Abgesehen vom dynamischen Binden dieser Methoden unterscheidet sich damit das Ausführungsmodell der objektorientierten Programmierung nicht von dem der prozeduralen Programmierung (à la PASCAL); insbesondere sind alle Objekte passiv (was soviel bedeutet, wie dass sie nur aktiv sind, solange sie gerade eine Methode ausführen).","Was bedeutet es, dass Objekte passiv sind?","Objekte sind passiv, was bedeutet, dass sie nur aktiv sind, solange sie gerade eine Methode ausführen. Im Wesentlichen sind Objekte in der objektorientierten Programmierung nicht anders als Variablen in prozeduralen Programmiersprachen. Sie enthalten Daten und können auf diese Daten zugreifen, aber sie können nicht von sich aus Aktionen ausführen. Stattdessen müssen ihnen Nachrichten gesendet werden, um sie zu aktivieren und sie dazu zu bringen, eine Methode auszuführen."
"Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.",Was sind aktive Objekte?,"Aktive Objekte sind Objekte, die über einen eigenen Prozess verfügen, der nur die eigenen Methoden ausführt. Sie arbeiten Nachrichten ab, sobald sie die Zeit dazu haben, was zu einem asynchronen Kommunikationsablauf führt."
"Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.",Was ist der Unterschied zwischen aktiven Objekten und passiven Objekten?,"Aktive Objekte verfügen über einen eigenen Prozess, während passive Objekte keinen eigenen Prozess haben. Aktive Objekte arbeiten Nachrichten asynchron ab, während passive Objekte dies synchron tun."
"Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.",Warum werden in der objektorientierten Programmierung in der Praxis eher passive Objekte verwendet?,"Aktive Objekte sind sehr aufwendig, weshalb in der objektorientierten Programmierung in der Praxis eher passive Objekte verwendet werden."
"Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.",Wie würden aktive Objekte kommunizieren?,"Aktive Objekte würden asynchron kommunizieren, indem sie Nachrichten (Methodenaufrufe) ohne Prozess empfangen und dann abarbeiten, wenn sie die Zeit dazu haben."
"Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.",Warum werden aktive Objekte in der objektorientierten Programmierung in der Praxis nicht eingesetzt?,"Aktive Objekte sind sehr aufwendig, daher werden in der objektorientierten Programmierung in der Praxis passive Objekte eingesetzt, die synchron kommunizieren."
"Gleichwohl ist auch in der objektorientierten Programmierung Parallelverarbeitung möglich. Nur kommt sie (zumindest in SMALLTALK, aber auch z. B. in Java) nicht in Form von aktiven Objekten daher, sondern in Form von parallelen Prozessen. Jeder dieser Prozesse führt zu einer Zeit eine Methode aus; er besucht zwar mit dem Methodenaufruf die Empfängerobjekte, diese bleiben jedoch selbst passiv (haben also kein Eigenleben).",Kann es in der objektorientierten Programmierung Parallelverarbeitung geben?,"Ja, in der objektorientierten Programmierung ist Parallelverarbeitung möglich, jedoch nicht in Form von aktiven Objekten, sondern in Form von parallelen Prozessen, die jeweils eine Methode ausführen."
"Gleichwohl ist auch in der objektorientierten Programmierung Parallelverarbeitung möglich. Nur kommt sie (zumindest in SMALLTALK, aber auch z. B. in Java) nicht in Form von aktiven Objekten daher, sondern in Form von parallelen Prozessen. Jeder dieser Prozesse führt zu einer Zeit eine Methode aus; er besucht zwar mit dem Methodenaufruf die Empfängerobjekte, diese bleiben jedoch selbst passiv (haben also kein Eigenleben).",Wie wird Parallelverarbeitung in Smalltalk und Java umgesetzt?,"In Smalltalk und Java wird Parallelverarbeitung durch parallele Prozesse umgesetzt, die zu einer Zeit eine Methode ausführen. Diese Prozesse besuchen mit dem Methodenaufruf die Empfängerobjekte, die jedoch selbst passiv bleiben und kein Eigenleben haben."
"Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neuen Prozess zu starten: Man schickt einfach einem Block die Nachricht ""fork"". ""fork"" entspricht im Wesentlichen ""value"", nur dass der Block dadurch in einem eigenen, unabhängigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von ""fork"" auch nicht darauf, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zurückliefert; tatsächlich liefert sie auch nicht (wie ""value"") das Ergebnis des Blocks zurück, sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann geht dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert.",Wie kann man in SMALLTALK einen neuen Prozess starten?,"In SMALLTALK kann man einen neuen Prozess starten, indem man einem Block die Nachricht ""fork"" sendet. Diese entspricht im Wesentlichen ""value"", nur dass der Block in einem eigenen, unabhängigen Prozess ausgeführt wird."
"Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neuen Prozess zu starten: Man schickt einfach einem Block die Nachricht ""fork"". ""fork"" entspricht im Wesentlichen ""value"", nur dass der Block dadurch in einem eigenen, unabhängigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von ""fork"" auch nicht darauf, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zurückliefert; tatsächlich liefert sie auch nicht (wie ""value"") das Ergebnis des Blocks zurück, sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann geht dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert.","Was passiert, wenn man einem Block in SMALLTALK die Nachricht ""fork"" schickt?","Wenn man einem Block in SMALLTALK die Nachricht ""fork"" schickt, wird ein neuer Prozess gestartet, in dem der Block unabhängig ausgeführt wird. Die Ausführung von ""fork"" liefert den Block selbst (als Objekt) zurück und wartet nicht darauf, dass die Ausführung des Blocks beendet wird. Wenn der Block ein Ergebnis hat, geht dieses verloren, und der Aufrufer kann nur die Seiteneffekte der Ausführung des Blocks sehen, wie z.B. Änderungen am Zustand eines Objekts, das im Block vorkommt."
"Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neuen Prozess zu starten: Man schickt einfach einem Block die Nachricht ""fork"". ""fork"" entspricht im Wesentlichen ""value"", nur dass der Block dadurch in einem eigenen, unabhängigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von ""fork"" auch nicht darauf, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zurückliefert; tatsächlich liefert sie auch nicht (wie ""value"") das Ergebnis des Blocks zurück, sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann geht dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert.","Was passiert, wenn ein Block ein Ergebnis hat und mit fork aufgerufen wird?","Wenn ein Block ein Ergebnis hat und mit fork aufgerufen wird, dann geht dieses Ergebnis verloren und aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert."
"Soll ein (paralleler) Prozess nicht sofort starten, so braucht man ein Objekt, das diesen Prozess repräsentiert und dem man dann zu einem späteren Zeitpunkt die Nachricht ""resume"" schicken kann, die den Prozess startet. Ein solches Objekt erhält man, indem man dem Block ""newProcess"" schickt.Um einen parametrisierten Block (also einen Block mit Parametern) als Prozess zu starten, verwendet man statt ""newProcess"" ""newProcessWith:"" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält.",Wie startet man einen parametrisierten Block als Prozess?,"Um einen parametrisierten Block als Prozess zu starten, verwendet man ""newProcessWith:"" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält."
"Mit den Nachrichten ""suspend"" und ""terminate"" kann man den Prozess dann temporär anhalten bzw. beenden. Angehaltene Prozesse können später mit ""resume"" wieder gestartet werden, beendete nicht.","Was bewirken die Nachrichten ""suspend"" und ""terminate"" in Bezug auf einen Prozess?","Mit der Nachricht ""suspend"" kann ein Prozess temporär angehalten werden, während er mit ""terminate"" beendet wird. Ein angehaltener Prozess kann später mit ""resume"" wieder gestartet werden, während ein beendeter Prozess nicht wieder gestartet werden kann."
"Die Synchronisation von parallelen Prozessen erfolgt in SMALLTALK zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen dazu über zwei Methoden, ""wait"" und ""signal"", und eine Instanzvariable, die für jedes Empfangen von ""signal"" um 1 erhöht und für jedes Empfangen von ""wait"" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt (mittels ""suspend""). Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht ""signal"" und es gibt noch Prozesse, die schlafen (erkennbar an einem Zähler kleiner als 1), dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden (mittels ""resume"") und weitermachen.",Was sind Semaphoren in SMALLTALK und wie werden sie verwendet?,"Semaphoren in SMALLTALK sind Objekte, die zur Synchronisation von parallelen Prozessen verwendet werden. Sie verfügen über zwei Methoden, ""wait"" und ""signal"", und eine Instanzvariable, die für jedes Empfangen von ""signal"" um 1 erhöht und für jedes Empfangen von ""wait"" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt. Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht ""signal"" und es gibt noch Prozesse, die schlafen, dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden und weitermachen."
"Die Synchronisation von parallelen Prozessen erfolgt in SMALLTALK zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen dazu über zwei Methoden, ""wait"" und ""signal"", und eine Instanzvariable, die für jedes Empfangen von ""signal"" um 1 erhöht und für jedes Empfangen von ""wait"" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt (mittels ""suspend""). Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht ""signal"" und es gibt noch Prozesse, die schlafen (erkennbar an einem Zähler kleiner als 1), dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden (mittels ""resume"") und weitermachen.",Wie erfolgt die Synchronisation von parallelen Prozessen in SMALLTALK?,"In SMALLTALK erfolgt die Synchronisation von parallelen Prozessen zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen über zwei Methoden, ""wait"" und ""signal"", und eine Instanzvariable, die für jedes Empfangen von ""signal"" um 1 erhöht und für jedes Empfangen von ""wait"" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt. Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht ""signal"" und es gibt noch Prozesse, die schlafen, dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden und weitermachen."
"Die Synchronisation mittels Semaphoren ist recht elementar und von aktiven Objekten noch weit entfernt. Deutlich näher rückt man mit der Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gezählt werden) Objekte aufnehmen und die eine Synchronisation über ""next"" und ""nextPut:"" erlauben. Das Protokoll sieht wie folgt aus:",Was ist eine SharedQueue?,"SharedQueue ist eine Unterklasse von OrderedCollection, die Objekte aufnimmt und eine Synchronisation über ""next"" und ""nextPut:"" erlaubt."
"Die Instanzvariable ""queue"" ist eine Warteschlange, die auf die Objekte wartet, die in die Instanz von SharedQueue eingefügt werden sollen. Die Methode ""next"" gibt das nächste Objekt aus der Warteschlange zurück, während ""nextPut:"" ein Objekt in die Warteschlange einfügt.","Was ist die Funktion der Instanzvariable ""queue"" in der Klasse SharedQueue?","Die Instanzvariable ""queue"" in der Klasse SharedQueue ist eine Warteschlange, die auf die Objekte wartet, die in die Instanz von SharedQueue eingefügt werden sollen."
"Wenn man nun eine solche SharedQueue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann hat man tatsächlich „aktive Objekte, die einander Nachrichten schicken“.",Was sind aktive Objekte im Kontext von SharedQueue?,"Aktive Objekte sind Objekte, die einander Nachrichten schicken, indem sie Nachrichten in eine SharedQueue einstellen und diese von einem anderen Objekt ausgelesen werden, das in einer Endlosschleife läuft."
"Wie bereits angerissen, verbirgt sich hinter dem Nachrichtenversand ein dynamisch gebundener Methodenaufruf. Dabei ist die Auswahl der Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt abhängig. In Abschnitt 11.2 hatten wir bereits angedeutet, wie in Superklassen definierte Methoden für ihre Subklassen zugreifbar sind; hier schauen wir uns nun etwas genauer an, wie die dynamische Bindung von Methodenaufrufen vonstatten geht.",Was ist ein dynamisch gebundener Methodenaufruf?,"Ein dynamisch gebundener Methodenaufruf ist eine Methode, bei der die Auswahl der Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt abhängig ist."
"Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Dies kann man auch selbst tun: Es gibt dafür in der Klasse Behavior eine Instanzmethode oder so ähnlich (je nach System), die somit allen Klassen (als Klassenmethode) zur Verfügung steht. (Behavior ist ja eine Superklasse von Class, die wiederum Superklasse aller Metaklassen ist, von denen jede Klasse eine Instanz ist, so dass alle Klassen die Methode includesSelector: verstehen.)",Wie wird eine Methode in SMALLTALK aufgerufen?,"In SMALLTALK wird eine Methode auf einem Empfängerobjekt aufgerufen, indem zunächst geprüft wird, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Diese Prüfung kann man auch selbst durchführen, indem man die Instanzmethode includesSelector: der Klasse Behavior aufruft, die allen Klassen zur Verfügung steht."
"Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Dies kann man auch selbst tun: Es gibt dafür in der Klasse Behavior eine Instanzmethode oder so ähnlich (je nach System), die somit allen Klassen (als Klassenmethode) zur Verfügung steht. (Behavior ist ja eine Superklasse von Class, die wiederum Superklasse aller Metaklassen ist, von denen jede Klasse eine Instanz ist, so dass alle Klassen die Methode includesSelector: verstehen.)","Wie wird überprüft, ob eine Methode in der Klasse eines Empfängers enthalten ist?","Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Diese Überprüfung kann man auch selbst durchführen, indem man die Instanzmethode includesSelector: der Klasse Behavior aufruft, die allen Klassen als Klassenmethode zur Verfügung steht."
"Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Dies kann man auch selbst tun: Es gibt dafür in der Klasse Behavior eine Instanzmethode oder so ähnlich (je nach System), die somit allen Klassen (als Klassenmethode) zur Verfügung steht. (Behavior ist ja eine Superklasse von Class, die wiederum Superklasse aller Metaklassen ist, von denen jede Klasse eine Instanz ist, so dass alle Klassen die Methode includesSelector: verstehen.)",Was ist das Methodenwörterbuch in Smalltalk?,"Das Methodenwörterbuch in Smalltalk ist eine Tabelle, die alle Methoden enthält, die zu einer bestimmten Klasse gehören. Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist."
"Wird die Methode gefunden, dann wird sie ausgeführt. Wird sie nicht gefunden, wird zunächst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum bereits erwähnten Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument.","Was passiert, wenn eine Methode nicht gefunden wird?","Wenn eine Methode nicht gefunden wird, wird in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument."
"Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Methode einer Superklasse des Empfängerobjekts ausgeführt wird, das Objekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilierung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden — handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch Instanz seiner Klasse ist. Die gerade ausgeführte Methode betrachtet es lediglich wie ein Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die Bedeutung der Pseudovariable super, wie wir noch sehen werden.","Was passiert, wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind?","Wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind, kann sie dies tun, wenn sie in der gleichen Klasse definiert ist. Wenn die Methode jedoch in einer Superklasse definiert ist, kann sie nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind, und nicht auf Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind."
"Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Methode einer Superklasse des Empfängerobjekts ausgeführt wird, das Objekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilierung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden — handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch Instanz seiner Klasse ist. Die gerade ausgeführte Methode betrachtet es lediglich wie ein Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die Bedeutung der Pseudovariable super, wie wir noch sehen werden.","Was passiert, wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind, aber in der Unterklasse hinzugekommen sind?","Die Methode kann nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar."
"Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Methode einer Superklasse des Empfängerobjekts ausgeführt wird, das Objekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilierung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden — handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch Instanz seiner Klasse ist. Die gerade ausgeführte Methode betrachtet es lediglich wie ein Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die Bedeutung der Pseudovariable super, wie wir noch sehen werden.","Was passiert, wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind, aber in einer Superklasse definiert wurde?","Die Methode kann nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar."
"Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, aus Effizienzgründen direkt in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im Wesentlichen äquivalent zu der der Methode canUnderstand:, die genau wie includesSelector: in der Klasse Behavior definiert ist.",Wo ist der Suchalgorithmus für Methodenaufrufe implementiert?,Der Suchalgorithmus für Methodenaufrufe ist direkt in der virtuellen Maschine implementiert.
"Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, aus Effizienzgründen direkt in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im Wesentlichen äquivalent zu der der Methode canUnderstand:, die genau wie includesSelector: in der Klasse Behavior definiert ist.",Wie ist die Implementierung des Suchalgorithmus für Methodenaufrufe im Vergleich zur Methode canUnderstand:?,"Die Implementierung des Suchalgorithmus für Methodenaufrufe ist im Wesentlichen äquivalent zur Implementierung der Methode canUnderstand:, die in der Klasse Behavior definiert ist."
"Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, aus Effizienzgründen direkt in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im Wesentlichen äquivalent zu der der Methode canUnderstand:, die genau wie includesSelector: in der Klasse Behavior definiert ist.",Was ist das Ziel des Suchalgorithmus?,"Das Ziel des Suchalgorithmus ist, eine Methode mit der angeforderten Bezeichnung zu finden und auszuführen."
"Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, aus Effizienzgründen direkt in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im Wesentlichen äquivalent zu der der Methode canUnderstand:, die genau wie includesSelector: in der Klasse Behavior definiert ist.",Wie werden temporäre Variablen im Suchalgorithmus verwendet?,"Temporäre Variablen können im Suchalgorithmus verwendet werden, um Zwischenergebnisse zu speichern und die Lesbarkeit zu verbessern."
"Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, aus Effizienzgründen direkt in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im Wesentlichen äquivalent zu der der Methode canUnderstand:, die genau wie includesSelector: in der Klasse Behavior definiert ist.",Was ist der Suchalgorithmus in der objektorientierten Programmierung?,"Der Suchalgorithmus ist ein Algorithmus, der in der virtuellen Maschine implementiert ist und dazu dient, die passende Methode für einen bestimmten Methodenaufruf zu finden. Er ist im Wesentlichen äquivalent zur Methode canUnderstand:, die in der Klasse Behavior definiert ist."
"Man beachte übrigens, wie wenig Aufwand es ist, aus dem klassenbasierten Methoden-Lookup einen objektbasierten zu machen: Man muss dazu lediglich jedem einzelnen Objekt sein eigenes Methodenwörterbuch zur Verfügung stellen. Wenn man zusätzlich noch Objekte von Objekten anstelle von Klassen von Klassen erben lässt, dann hat man schon die prototypenbasierte Form der objektorientierten Programmierung. Der Unterschied ist also technisch nicht besonders groß — konzeptuell hingegen schon, denn mit den Klassen entfielen auch die sonst so nützlichen Begriffe von Generalisierung und Spezialisierung (von der Generalisierung von Objekten zu sprechen erscheint wenig sinnvoll).",Was ist der Unterschied zwischen klassenbasierter und prototypenbasierter Form der objektorientierten Programmierung?,"Der Unterschied ist technisch nicht besonders groß, aber konzeptuell schon. In der klassenbasierten Form der objektorientierten Programmierung gibt es die Begriffe Generalisierung und Spezialisierung, die sinnvoll sind. In der prototypenbasierten Form hingegen spricht man eher von Objekten, die von anderen Objekten erben, als von Klassen, die von Klassen erben."
"Man beachte übrigens, wie wenig Aufwand es ist, aus dem klassenbasierten Methoden-Lookup einen objektbasierten zu machen: Man muss dazu lediglich jedem einzelnen Objekt sein eigenes Methodenwörterbuch zur Verfügung stellen. Wenn man zusätzlich noch Objekte von Objekten anstelle von Klassen von Klassen erben lässt, dann hat man schon die prototypenbasierte Form der objektorientierten Programmierung. Der Unterschied ist also technisch nicht besonders groß — konzeptuell hingegen schon, denn mit den Klassen entfielen auch die sonst so nützlichen Begriffe von Generalisierung und Spezialisierung (von der Generalisierung von Objekten zu sprechen erscheint wenig sinnvoll).",Was ist der Unterschied zwischen dem klassenbasierten Methoden-Lookup und dem objektbasierten Methoden-Lookup?,"Der Unterschied zwischen dem klassenbasierten Methoden-Lookup und dem objektbasierten Methoden-Lookup besteht darin, dass man beim objektbasierten Methoden-Lookup jedem Objekt sein eigenes Methodenwörterbuch zur Verfügung stellt, während beim klassenbasierten Methoden-Lookup die Methoden in der Klasse gespeichert sind."
"Man beachte übrigens, wie wenig Aufwand es ist, aus dem klassenbasierten Methoden-Lookup einen objektbasierten zu machen: Man muss dazu lediglich jedem einzelnen Objekt sein eigenes Methodenwörterbuch zur Verfügung stellen. Wenn man zusätzlich noch Objekte von Objekten anstelle von Klassen von Klassen erben lässt, dann hat man schon die prototypenbasierte Form der objektorientierten Programmierung. Der Unterschied ist also technisch nicht besonders groß — konzeptuell hingegen schon, denn mit den Klassen entfielen auch die sonst so nützlichen Begriffe von Generalisierung und Spezialisierung (von der Generalisierung von Objekten zu sprechen erscheint wenig sinnvoll).","Was passiert mit den Begriffen Generalisierung und Spezialisierung, wenn man von Objekten statt von Klassen spricht?","Wenn man von Objekten statt von Klassen spricht, erscheint es wenig sinnvoll, von Generalisierung und Spezialisierung zu sprechen."
"Eines der immer wieder vorgetragenen Hauptargumente gegen den Einsatz von SMALLTALK in der kommerziellen Programmierung ist der Umstand, dass das dynamische Binden wirklich vollkommen dynamisch ist: Dass einem Objekt eine Nachricht geschickt wird, die es nicht versteht, tritt immer erst zur Laufzeit zutage. In den statisch typgeprüften Sprachen, die wir in den nächsten Kurseinheiten kennenlernen werden, ist das charakteristischerweise nicht so. Dem kann man entgegenhalten, dass die heutigen (auch) statisch typgeprüften Programmiersprachen wie Java, C-Sharp oder C++ sämtliche nicht ohne dynamische Typumwandlungen auskommen, die ebenfalls zu Laufzeitfehlern führen können. Tatsächlich ist es sowohl in SMALLTALK als auch in Java und C-Sharp (in C++ nur mit Einschränkungen; s. Abschnitt 51.5) nicht nur möglich, sondern sogar geboten, Laufzeitfehler da, wo möglich, zu vermeiden, indem man vor einem Methodenaufruf explizit prüft, ob ein Objekt die gewünschte Methode auch hat — in SMALLTALK mittels canUnderstand:, in Java et al. mittels eines entsprechenden Typtests vor einem Downcast. Die größere Flexibilität, die die objektorientierte Programmierung durch das dynamische Binden bietet, hat eben den Preis, dass bestimmte Laufzeitprüfungen durchgeführt werden müssen. Statische Typprüfung kann das Risiko von Typfehlern verringern, aber nicht ausschließen — gleichzeitig schränkt es die Flexibilität beim Programmieren ein, ein Umstand, der so manchen, der schon einmal größere Programme in SMALLTALK geschrieben hat, an der Verwendung typgeprüfter Sprachen stört.",Was ist der Unterschied zwischen dynamischem und statischem Binden in der objektorientierten Programmierung?,"Beim dynamischen Binden wird eine Nachricht an ein Objekt geschickt und es wird zur Laufzeit entschieden, welche Methode aufgerufen wird. Beim statischen Binden wird dies bereits zur Übersetzungszeit entschieden. Ein Vorteil des dynamischen Bindens ist die größere Flexibilität, allerdings müssen dafür bestimmte Laufzeitprüfungen durchgeführt werden. Statische Typprüfung kann das Risiko von Typfehlern verringern, schränkt aber die Flexibilität beim Programmieren ein."
"Eines der immer wieder vorgetragenen Hauptargumente gegen den Einsatz von SMALLTALK in der kommerziellen Programmierung ist der Umstand, dass das dynamische Binden wirklich vollkommen dynamisch ist: Dass einem Objekt eine Nachricht geschickt wird, die es nicht versteht, tritt immer erst zur Laufzeit zutage. In den statisch typgeprüften Sprachen, die wir in den nächsten Kurseinheiten kennenlernen werden, ist das charakteristischerweise nicht so. Dem kann man entgegenhalten, dass die heutigen (auch) statisch typgeprüften Programmiersprachen wie Java, C-Sharp oder C++ sämtliche nicht ohne dynamische Typumwandlungen auskommen, die ebenfalls zu Laufzeitfehlern führen können. Tatsächlich ist es sowohl in SMALLTALK als auch in Java und C-Sharp (in C++ nur mit Einschränkungen; s. Abschnitt 51.5) nicht nur möglich, sondern sogar geboten, Laufzeitfehler da, wo möglich, zu vermeiden, indem man vor einem Methodenaufruf explizit prüft, ob ein Objekt die gewünschte Methode auch hat — in SMALLTALK mittels canUnderstand:, in Java et al. mittels eines entsprechenden Typtests vor einem Downcast. Die größere Flexibilität, die die objektorientierte Programmierung durch das dynamische Binden bietet, hat eben den Preis, dass bestimmte Laufzeitprüfungen durchgeführt werden müssen. Statische Typprüfung kann das Risiko von Typfehlern verringern, aber nicht ausschließen — gleichzeitig schränkt es die Flexibilität beim Programmieren ein, ein Umstand, der so manchen, der schon einmal größere Programme in SMALLTALK geschrieben hat, an der Verwendung typgeprüfter Sprachen stört.",Was ist das Hauptargument gegen den Einsatz von SMALLTALK in der kommerziellen Programmierung?,"Das Hauptargument gegen den Einsatz von SMALLTALK in der kommerziellen Programmierung ist, dass das dynamische Binden wirklich vollkommen dynamisch ist, was bedeutet, dass einem Objekt eine Nachricht geschickt wird, die es nicht versteht, erst zur Laufzeit auffällt."
"Eines der immer wieder vorgetragenen Hauptargumente gegen den Einsatz von SMALLTALK in der kommerziellen Programmierung ist der Umstand, dass das dynamische Binden wirklich vollkommen dynamisch ist: Dass einem Objekt eine Nachricht geschickt wird, die es nicht versteht, tritt immer erst zur Laufzeit zutage. In den statisch typgeprüften Sprachen, die wir in den nächsten Kurseinheiten kennenlernen werden, ist das charakteristischerweise nicht so. Dem kann man entgegenhalten, dass die heutigen (auch) statisch typgeprüften Programmiersprachen wie Java, C-Sharp oder C++ sämtliche nicht ohne dynamische Typumwandlungen auskommen, die ebenfalls zu Laufzeitfehlern führen können. Tatsächlich ist es sowohl in SMALLTALK als auch in Java und C-Sharp (in C++ nur mit Einschränkungen; s. Abschnitt 51.5) nicht nur möglich, sondern sogar geboten, Laufzeitfehler da, wo möglich, zu vermeiden, indem man vor einem Methodenaufruf explizit prüft, ob ein Objekt die gewünschte Methode auch hat — in SMALLTALK mittels canUnderstand:, in Java et al. mittels eines entsprechenden Typtests vor einem Downcast. Die größere Flexibilität, die die objektorientierte Programmierung durch das dynamische Binden bietet, hat eben den Preis, dass bestimmte Laufzeitprüfungen durchgeführt werden müssen. Statische Typprüfung kann das Risiko von Typfehlern verringern, aber nicht ausschließen — gleichzeitig schränkt es die Flexibilität beim Programmieren ein, ein Umstand, der so manchen, der schon einmal größere Programme in SMALLTALK geschrieben hat, an der Verwendung typgeprüfter Sprachen stört.",Was ist der Unterschied zwischen dynamischem Binden und statischer Typprüfung?,"Dynamisches Binden bedeutet, dass eine Nachricht, die an ein Objekt geschickt wird, erst zur Laufzeit geprüft wird, ob das Objekt die Nachricht versteht. Statische Typprüfung hingegen bedeutet, dass diese Prüfung bereits vor der Ausführung des Programms durchgeführt wird. Statische Typprüfung kann das Risiko von Typfehlern verringern, aber nicht ausschließen, während dynamisches Binden die Flexibilität beim Programmieren erhöht, allerdings auch bestimmte Laufzeitprüfungen erfordert."
"Die Klasse kann dann Instanzen erzeugen, die Objekte der Klasse sind. Die Objekte besitzen einen Zustand, der sich aus den Werten ihrer Instanzvariablen zusammensetzt. Die Instanzvariablen können durch Methoden der Klasse manipuliert werden. Die Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members.",Was ist eine Klasse in Java?,"In Java ist eine Klasse eine Vorlage für die Erstellung von Objekten. Sie definiert den Zustand und das Verhalten der Objekte. Der Zustand eines Objekts setzt sich aus den Werten seiner Instanzvariablen zusammen, und das Verhalten wird durch die Methoden der Klasse bestimmt. Instanzvariablen können durch Methoden der Klasse manipuliert werden."
"Die Klasse kann dann Instanzen erzeugen, die Objekte der Klasse sind. Die Objekte besitzen einen Zustand, der sich aus den Werten ihrer Instanzvariablen zusammensetzt. Die Instanzvariablen können durch Methoden der Klasse manipuliert werden. Die Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members.",Was sind Instanzvariablen und Instanzmethoden in Java?,"Instanzvariablen und Instanzmethoden sind Bestandteile einer Klassendefinition in Java. Sie werden zusammenfassend auch als ""Member"" bezeichnet. Instanzvariablen, auch Felder genannt, sind Variablen, die zu einer Instanz einer Klasse gehören. Instanzmethoden sind Methoden, die auf eine Instanz einer Klasse angewendet werden können."
"Die Klasse kann dann Instanzen erzeugen, die Objekte der Klasse sind. Die Objekte besitzen einen Zustand, der sich aus den Werten ihrer Instanzvariablen zusammensetzt. Die Instanzvariablen können durch Methoden der Klasse manipuliert werden. Die Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members.","Was ist der Begriff ""Member"" in Java?","Der Begriff ""Member"" in Java bezieht sich auf die Klassendefinition und umfasst Instanzvariablen und Instanzmethoden."
"Die Klasse kann dann Instanzen erzeugen, die Objekte der Klasse sind. Die Objekte besitzen einen Zustand, der sich aus den Werten ihrer Instanzvariablen zusammensetzt. Die Instanzvariablen können durch Methoden der Klasse manipuliert werden. Die Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members.",Sind Konstruktoren Members in Java?,"Nein, Konstruktoren zählen nicht zu den Members in Java."
"Die Klasse kann dann Instanzen erzeugen, die Objekte der Klasse sind. Die Objekte besitzen einen Zustand, der sich aus den Werten ihrer Instanzvariablen zusammensetzt. Die Instanzvariablen können durch Methoden der Klasse manipuliert werden. Die Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members.",Was sind Instanzvariablen und Instanzmethoden in Java?,"Instanzvariablen, auch als Felder bezeichnet, und Instanzmethoden sind die beiden Bestandteile einer Klassendefinition in Java. Sie werden zusammenfassend auch als ""Member"" bezeichnet. Instanzvariablen speichern den Zustand eines Objekts, während Instanzmethoden das Verhalten eines Objekts definieren. Konstruktoren zählen nicht zu den Members."
"Die Klasse kann dann Instanzen erzeugen, die Objekte der Klasse sind. Die Objekte besitzen einen Zustand, der sich aus den Werten ihrer Instanzvariablen zusammensetzt. Die Instanzvariablen können durch Methoden der Klasse manipuliert werden. Die Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members.",Was ist der Unterschied zwischen Members und Konstruktoren in Java?,"Members einer Klasse sind Instanzvariablen und Instanzmethoden, während Konstruktoren keine Members sind. Konstruktoren werden separat in Abschnitt 36.3 behandelt."
"Die Klasse kann dann Instanzen erzeugen, die Objekte der Klasse sind. Die Objekte besitzen einen Zustand, der sich aus den Werten ihrer Instanzvariablen zusammensetzt. Die Instanzvariablen können durch Methoden der Klasse manipuliert werden. Die Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members.",Was ist der Zweck von Konstruktoren in Java?,"Konstruktoren werden verwendet, um die Initialisierung von Objekten zu definieren, wenn sie erstellt werden. Sie werden nicht als Members einer Klasse betrachtet."
"Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.",Was sind innere Klassen in Java?,"Innere Klassen in Java sind Klassendefinitionen, die innerhalb einer anderen Klasse definiert werden. Sie sind vor allem sinnvoll, wenn die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Instanzen innerer Klassen liegen ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen."
"Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.",Wozu werden innere Klassen in Java verwendet?,"Innere Klassen in Java werden verwendet, um die enge Beziehung zwischen zwei Klassen auszudrücken. Sie werden vor allem dann sinnvoll, wenn die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Zum Beispiel, wenn verknüpfte Listen implementiert werden, wird die Klasse der Listenelemente innerhalb der Klasse der Liste definiert. Instanzen innerer Klassen liegen immer ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen."
"Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.","Was bedeutet es, wenn Members in Java als ""static"" deklariert werden?","Wenn Members in Java als ""static"" deklariert werden, beziehen sie sich nicht auf Objekte, sondern auf die Klasse selbst. Es handelt sich also um Klassenvariablen und -methoden, die nicht dynamisch gebunden werden."
"Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.","Was bedeutet es, wenn Members als ""static"" deklariert werden?","Wenn Members als ""static"" deklariert werden, beziehen sie sich nicht auf Objekte, sondern auf die Klasse selbst. Es handelt sich also um Klassenvariablen und -methoden. Diese werden nicht dynamisch gebunden, sondern sind während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können."
"Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","Was ist der Unterschied zwischen ""static"" und ""final"" in Java?","""static"" deklarierte Felder sind nicht konstant, während ""final"" dazu verwendet wird, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variablen genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in Smalltalk konstante Methoden für Konstanten. ""final"" in Java verhindert auch, dass eine Methode in Subklassen überschrieben wird."
"Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","Was bedeutet das Schlüsselwort ""final"" in Java?","In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren, was bedeutet, dass einer Variablen genau einmal ein Wert zugewiesen werden darf. Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen."
"Wenn Sie bereits in anderen Programmiersprachen wie z. B. PASCAL, C oder Java programmiert haben, kennen Sie sicherlich Schlüsselwörter wie if, else, for und while. Diese Schlüsselwörter repräsentieren Kontrollstrukturen, feste Bestandteile der Sprache, die dazu dienen, den Ablauf eines Programms durch die Programmiererin zu steuern. Es wurde bereits vor langer Zeit (im Rahmen der Diskussion zur sogenannten strukturierten Programmierung) festgelegt, dass jede Programmiersprache über die Kontrollstrukturen Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf verfügen sollte. Während die einfache Sequenz von Anweisungen während der Ausführung durch die lineare Reihenfolge der Anweisungen im Programmtext festgelegt ist, wurden für Abweichungen vom linearen Kontrollfluss, wie Verzweigungen, Wiederholungen und Aufrufe, spezielle Flusssteuerungskonstrukte entwickelt. Das Goto gehört übrigens nicht dazu; es wird seit dem Aufkommen der strukturierten Programmierung als unerwünscht angesehen.",Was sind Schlüsselwörter?,"In Programmiersprachen wie PASCAL, C oder Java repräsentieren Schlüsselwörter Kontrollstrukturen."
"Wenn Sie bereits in anderen Programmiersprachen wie z. B. PASCAL, C oder Java programmiert haben, kennen Sie sicherlich Schlüsselwörter wie if, else, for und while. Diese Schlüsselwörter repräsentieren Kontrollstrukturen, feste Bestandteile der Sprache, die dazu dienen, den Ablauf eines Programms durch die Programmiererin zu steuern. Es wurde bereits vor langer Zeit (im Rahmen der Diskussion zur sogenannten strukturierten Programmierung) festgelegt, dass jede Programmiersprache über die Kontrollstrukturen Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf verfügen sollte. Während die einfache Sequenz von Anweisungen während der Ausführung durch die lineare Reihenfolge der Anweisungen im Programmtext festgelegt ist, wurden für Abweichungen vom linearen Kontrollfluss, wie Verzweigungen, Wiederholungen und Aufrufe, spezielle Flusssteuerungskonstrukte entwickelt. Das Goto gehört übrigens nicht dazu; es wird seit dem Aufkommen der strukturierten Programmierung als unerwünscht angesehen.",Was sind Kontrollstrukturen?,"Die grundlegenden Kontrollstrukturen sind: Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf."
"Wenn Sie bereits in anderen Programmiersprachen wie z. B. PASCAL, C oder Java programmiert haben, kennen Sie sicherlich Schlüsselwörter wie if, else, for und while. Diese Schlüsselwörter repräsentieren Kontrollstrukturen, feste Bestandteile der Sprache, die dazu dienen, den Ablauf eines Programms durch die Programmiererin zu steuern. Es wurde bereits vor langer Zeit (im Rahmen der Diskussion zur sogenannten strukturierten Programmierung) festgelegt, dass jede Programmiersprache über die Kontrollstrukturen Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf verfügen sollte. Während die einfache Sequenz von Anweisungen während der Ausführung durch die lineare Reihenfolge der Anweisungen im Programmtext festgelegt ist, wurden für Abweichungen vom linearen Kontrollfluss, wie Verzweigungen, Wiederholungen und Aufrufe, spezielle Flusssteuerungskonstrukte entwickelt. Das Goto gehört übrigens nicht dazu; es wird seit dem Aufkommen der strukturierten Programmierung als unerwünscht angesehen.",Wie ist das Goto angesehen?,Das Goto wird in der strukturierten Programmierung als unerwünscht angesehen.
"In SMALLTALK wurden die durch die Syntax der Sprache vorgegebenen Kontrollstrukturen auf Sequenz und Aufruf, letzteres ausgedrückt durch das Versenden einer Nachricht an ein Objekt, beschränkt. Alle anderen Kontrollstrukturen müssen mithilfe der Sprache simuliert werden. Was anfangs wie eine erhebliche Einschränkung erscheinen mag, erweist sich in der Praxis als bedeutender Vorteil: Die Programmiererin kann nämlich selbst, wenn sie es wünscht, neue Kontrollstrukturen einführen.",Was sind Kontrollstrukturen in SMALLTALK?,"In SMALLTALK sind Kontrollstrukturen auf Sequenz und Aufruf begrenzt. Alle anderen Kontrollstrukturen, einschließlich Verzweigung und Wiederholung, müssen mithilfe der Sprache simuliert werden."
"In SMALLTALK wurden die durch die Syntax der Sprache vorgegebenen Kontrollstrukturen auf Sequenz und Aufruf, letzteres ausgedrückt durch das Versenden einer Nachricht an ein Objekt, beschränkt. Alle anderen Kontrollstrukturen müssen mithilfe der Sprache simuliert werden. Was anfangs wie eine erhebliche Einschränkung erscheinen mag, erweist sich in der Praxis als bedeutender Vorteil: Die Programmiererin kann nämlich selbst, wenn sie es wünscht, neue Kontrollstrukturen einführen.",Was ist der Vorteil der Kontrollstrukturen in SMALLTALK?,"In SMALLTALK wird es als bedeutender Vorteil angesehen, dass Programmierer neue Kontrollstrukturen einführen können, wenn sie es wünschen."
"Gemäß der SMALLTALK-Philosophie müssen auch Metaklassen (als Objekte) Instanzen von Klassen sein. Es erscheint jedoch nicht mehr sinnvoll, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen. Daher ist es nicht notwendig, dass jede Metaklasse (als Klasse) ihre eigene Meta-Metaklasse (als Metaklasse der Klasse) hat. Für die Praxis reicht es aus, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind. In Übereinstimmung mit der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz ""<eine Instanz> ist ein <Klassenname>"" korrekt ergänzen, wird diese Klasse als ""Metaclass"" bezeichnet, da alle ihre Instanzen Metaklassen sind.","Was ist die Rolle der Metaklasse ""Metaclass"" in SMALLTALK?","Die Metaklasse ""Metaclass"" in SMALLTALK ist eine gemeinsame Metaklasse, von der alle Metaklassen Instanzen sind. Sie wird verwendet, um die Instanzvariablen und Methoden für Metaklassen bereitzustellen, da es nicht notwendig ist, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen."
"Gemäß der SMALLTALK-Philosophie müssen auch Metaklassen (als Objekte) Instanzen von Klassen sein. Es erscheint jedoch nicht mehr sinnvoll, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen. Daher ist es nicht notwendig, dass jede Metaklasse (als Klasse) ihre eigene Meta-Metaklasse (als Metaklasse der Klasse) hat. Für die Praxis reicht es aus, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind. In Übereinstimmung mit der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz ""<eine Instanz> ist ein <Klassenname>"" korrekt ergänzen, wird diese Klasse als ""Metaclass"" bezeichnet, da alle ihre Instanzen Metaklassen sind.",Wozu dient die Metaclass in Smalltalk?,"Die Metaclass in Smalltalk dient als gemeinsame Meta-Metaklasse für alle Metaklassen, von der alle Metaklassen Instanzen sind."
"Gemäß der SMALLTALK-Philosophie müssen auch Metaklassen (als Objekte) Instanzen von Klassen sein. Es erscheint jedoch nicht mehr sinnvoll, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen. Daher ist es nicht notwendig, dass jede Metaklasse (als Klasse) ihre eigene Meta-Metaklasse (als Metaklasse der Klasse) hat. Für die Praxis reicht es aus, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind. In Übereinstimmung mit der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz ""<eine Instanz> ist ein <Klassenname>"" korrekt ergänzen, wird diese Klasse als ""Metaclass"" bezeichnet, da alle ihre Instanzen Metaklassen sind.","Was ist die Benennungspraxis in SMALLTALK für die Klasse, von der alle Metaklassen Instanzen sind?","Die Benennungspraxis in SMALLTALK für die Klasse, von der alle Metaklassen Instanzen sind, ist ""Metaclass""."
"Die Frage ergibt sich sofort, von welcher Klasse die Klasse ""Metaclass"" eine Instanz ist. Tatsächlich muss laut der SMALLTALK-Philosophie, nach der Klassen Objekte und jedes Objekt Instanz einer Klasse ist, auch die ""Metaclass"" eine Instanz einer Klasse sein. Um diese Hierarchie nicht ins Unendliche fortsetzen zu müssen, wurde in SMALLTALK zu einem einfachen Trick gegriffen: Die Klasse ""Metaclass"" von ""Metaclass"" wird selbst nur als einfache Metaklasse betrachtet (obwohl sie eigentlich eine Meta-Meta-Metaklasse ist). Genau wie alle anderen Metaklassen ist sie eine Instanz von ""Metaclass"". Für ""Metaclass"" gilt daher: Metaclass ist eine Instanz von Metaclass.",Was ist die Metaklasse von Metaclass?,Die Metaklasse von Metaclass ist selbst nur eine einfache Metaklasse und wird als Instanz von Metaclass betrachtet.
"Die Frage ergibt sich sofort, von welcher Klasse die Klasse ""Metaclass"" eine Instanz ist. Tatsächlich muss laut der SMALLTALK-Philosophie, nach der Klassen Objekte und jedes Objekt Instanz einer Klasse ist, auch die ""Metaclass"" eine Instanz einer Klasse sein. Um diese Hierarchie nicht ins Unendliche fortsetzen zu müssen, wurde in SMALLTALK zu einem einfachen Trick gegriffen: Die Klasse ""Metaclass"" von ""Metaclass"" wird selbst nur als einfache Metaklasse betrachtet (obwohl sie eigentlich eine Meta-Meta-Metaklasse ist). Genau wie alle anderen Metaklassen ist sie eine Instanz von ""Metaclass"". Für ""Metaclass"" gilt daher: Metaclass ist eine Instanz von Metaclass.",Was ist die Klasse von Metaclass in Smalltalk?,Die Klasse von Metaclass in Smalltalk ist Metaclass selbst.
"Das folgende Diagramm veranschaulicht die Zusammenhänge. Beachten Sie, dass alle Objekte außerhalb der Ebene 0 gleichzeitig Klassen und Instanzen sind. Der gestrichelte Pfeil stellt die ""Ist-eine-Instanz-von""-Beziehung dar (in UML-Notation).","Was repräsentiert die ""Ist-eine-Instanz-von""-Beziehungn?","Die ""Ist-eine-Instanz-von""-Beziehung stellt die Beziehung zwischen einer Klasse und einer Instanz dar, was bedeutet, dass die Instanz ein Objekt der Klasse ist."
"Die aufmerksame Leserin wird sofort bemerken, dass dieser Kunstgriff, die Hierarchie zu beenden, die Interpretation von Klassen als Mengen von Objekten und deren Instanzen als Elemente dieser Mengen im Sinne von Abschnitt 7.3 verhindert. Andernfalls wäre die Menge von Objekten, die zu ""Metaclass"" gehört, indirekt ein Element von sich selbst, was nicht möglich ist. Dies hat jedoch keine praktischen Auswirkungen.","Was ist der Kunstgriff, um die Hierarchie zu beenden?","Der Kunstgriff, um die Hierarchie zu beenden, besteht darin, die Interpretation von Klassen als Mengen von Objekten und deren Instanzen als Elemente dieser Mengen zu verhindern. Dadurch wird vermieden, dass die Menge von Objekten, die zu ""Metaclass"" gehört, indirekt ein Element von sich selbst wird, was nicht möglich ist. Dies hat jedoch keine praktischen Auswirkungen."
"Die aufmerksame Leserin wird sofort bemerken, dass dieser Kunstgriff, die Hierarchie zu beenden, die Interpretation von Klassen als Mengen von Objekten und deren Instanzen als Elemente dieser Mengen im Sinne von Abschnitt 7.3 verhindert. Andernfalls wäre die Menge von Objekten, die zu ""Metaclass"" gehört, indirekt ein Element von sich selbst, was nicht möglich ist. Dies hat jedoch keine praktischen Auswirkungen.",Was verhindert die Interpretation von Klassen als Mengen von Objekten?,"Die Interpretation von Klassen als Mengen von Objekten wird durch den Kunstgriff verhindert, die Hierarchie zu beenden, was im Widerspruch zu Abschnitt 7.3 stünde."
"Die aufmerksame Leserin wird sofort bemerken, dass dieser Kunstgriff, die Hierarchie zu beenden, die Interpretation von Klassen als Mengen von Objekten und deren Instanzen als Elemente dieser Mengen im Sinne von Abschnitt 7.3 verhindert. Andernfalls wäre die Menge von Objekten, die zu ""Metaclass"" gehört, indirekt ein Element von sich selbst, was nicht möglich ist. Dies hat jedoch keine praktischen Auswirkungen.",Was verhindert die Interpretation von Klassen als Mengen von Objekten und deren Instanzen als Elemente dieser Mengen?,"Die Tatsache, dass wenn Klassen als Mengen von Objekten interpretiert werden, die Menge von Objekten, die zu ""Metaclass"" gehört, indirekt ein Element von sich selbst wäre, was nicht möglich ist."
"In SMALLTALK haben wir es also mit einem mehrstufigen Zusammenspiel von Klassen und Instanzen zu tun. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht.",Wie ist das Zusammenspiel von Klassen und Instanzen in SMALLTALK?,"In SMALLTALK gibt es ein mehrstufiges Zusammenspiel von Klassen und Instanzen. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht."
"In SMALLTALK haben wir es also mit einem mehrstufigen Zusammenspiel von Klassen und Instanzen zu tun. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht.",Wie ist die Beziehung zwischen Klassen und Objekten in SMALLTALK?,In SMALLTALK gibt es eine 1:n-Beziehung zwischen Klassen und Objekten. Klassen stellen die Definitionen für Objekte bereit und repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit. Objekte werden durch Instanziierung von Klassen erstellt.
"In SMALLTALK haben wir es also mit einem mehrstufigen Zusammenspiel von Klassen und Instanzen zu tun. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht.",Was ist der Unterschied zwischen Objekten der Ebene 0 und Klassen der Ebene 1 in Smalltalk?,"Objekte der Ebene 0 sind konkrete Instanzen, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Klassen der Ebene 1 hingegen stellen die Definition (Instanzvariablen und -methoden) dieser Objekte bereit und repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit. Sie sind instanziierbar und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar."
"Die Klassen der Ebene 1 sind selbst Objekte und daher Instanzen von Klassen, die auf Ebene 2 stehen. Die Klassen der Ebene 2, die Metaklassen, definieren die Klassen auf Ebene 1. Da es nicht sinnvoll ist, mehrere Instanzen derselben Klasse der Ebene 1 zu haben, die alle über dieselbe Definition verfügen, hat jede Metaklasse genau eine Instanz. Es besteht also eine 1-zu-1-Beziehung zwischen Metaklassen und ihren Instanzen, den Klassen der Ebene 1, die die Objekte der Anwendung beschreiben.",Was ist die Beziehung zwischen Metaklassen und Klassen der Ebene 1?,"Es besteht eine 1-zu-1-Beziehung zwischen Metaklassen und ihren Instanzen, den Klassen der Ebene 1, die die Objekte der Anwendung beschreiben."
"Die Klassen der Ebene 1 sind selbst Objekte und daher Instanzen von Klassen, die auf Ebene 2 stehen. Die Klassen der Ebene 2, die Metaklassen, definieren die Klassen auf Ebene 1. Da es nicht sinnvoll ist, mehrere Instanzen derselben Klasse der Ebene 1 zu haben, die alle über dieselbe Definition verfügen, hat jede Metaklasse genau eine Instanz. Es besteht also eine 1-zu-1-Beziehung zwischen Metaklassen und ihren Instanzen, den Klassen der Ebene 1, die die Objekte der Anwendung beschreiben.",Was sind Metaklassen?,"Metaklassen sind Klassen, die auf einer höheren Ebene als die Klassen stehen, die die Objekte der Anwendung beschreiben. Sie definieren die Klassen der Ebene 1 und haben eine 1-zu-1-Beziehung zu diesen. Jede Metaklasse hat genau eine Instanz."
"Auf Ebene 3 erhalten alle Metaklassen eine gemeinsame Klasse, von der sie Instanzen sind, nämlich die Klasse ""Metaclass"". Beachten Sie, dass hier wieder eine 1: n-Beziehung vorliegt. Anders als auf Ebene 2, auf der verschiedene Konzepte jeweils eine eigene Klasse haben, wird auf Ebene 3 die Vielfalt auf genau eine Klasse reduziert. Diese Klasse hat dann wieder genau eine Metaklasse.","Was ist die Klasse ""Metaclass"" in der Metaklassenhierarchie?","Die Klasse ""Metaclass"" ist die gemeinsame Klasse für alle Metaklassen auf Ebene 3. Sie ist die Superklasse von allen Metaklassen und hat selbst genau eine Metaklasse."
"Auf Ebene 3 erhalten alle Metaklassen eine gemeinsame Klasse, von der sie Instanzen sind, nämlich die Klasse ""Metaclass"". Beachten Sie, dass hier wieder eine 1: n-Beziehung vorliegt. Anders als auf Ebene 2, auf der verschiedene Konzepte jeweils eine eigene Klasse haben, wird auf Ebene 3 die Vielfalt auf genau eine Klasse reduziert. Diese Klasse hat dann wieder genau eine Metaklasse.","Was ist die Klasse ""Metaclass"" auf Ebene 3?","Auf Ebene 3 erhalten alle Metaklassen eine gemeinsame Klasse, von der sie Instanzen sind, nämlich die Klasse ""Metaclass""."
"Ausdrücke in Java können sein: Literale, Variablen, die spezielle Variable this, Operatoranwendungen, Feldzugriffe der Form a.x, wobei a für den Besitzer des Feldes (ein Objekt oder eine Klasse) und x für das Feld (die Instanz- bzw. Klassenvariable) steht (a kann auch durch super ersetzt werden), Methodenaufrufe der Form a.m(...), wobei a für den Empfänger des Aufrufs steht oder für super, m für die Methode und ... für die tatsächlichen Parameter (die wiederum Ausdrücke sind), Array-Zugriffe der Form a[i], wobei a für das Array und i für einen Index steht (eine ganze, positive Zahl; bei mehrdimensionalen Arrays können entsprechend weitere Indizes in eckigen Klammern angegeben werden), Klasseninstanziierungen der Form new <Klassenname>(<Parameter>), Array-Instanziierungen der Form new <Basistypname>[<n>], wobei <Basistypname> für den Typ der Elemente steht (z. B. int bei einem Array von Integern) und <n> für einen Ausdruck, dessen Auswertung eine ganze, positive Zahl liefert (es können auch mehrere Dimensionen angegeben werden), Konditionalausdrücke der Form <Boolescher Ausdruck> ? <Ausdruck 1> : <Ausdruck 2>, wobei in Abhängigkeit davon, ob <Boolescher Ausdruck> zu wahr oder zu falsch auswertet, entweder <Ausdruck 1> oder <Ausdruck 2> ausgewertet wird und das Ergebnis des Gesamtausdrucks liefert, Cast-Ausdrücke der Form (<Typname>) <Ausdruck>, wobei <Typname> für das Ziel des Casts steht und <Ausdruck> für den Ausdruck, dessen Ergebnis den mit <Typname> bezeichneten Typ annehmen soll, Lambda-Ausdrücke der Form (<Parameterdeklarationen>) -> <Rumpf>, wobei <Parameterdeklarationen> den formalen Parameterdeklarationen einer Methode entspricht und <Rumpf> entweder eine einzelne Anweisung oder ein Block von Anweisungen, entsprechend einem Methodenrumpf (inklusive der geschweiften Klammern), ist. Falls nur ein Parameter deklariert wird, können die runden Klammern auch weggelassen werden.",Was sind die verschiedenen Arten von Ausdrücken in Java?,"In Java gibt es Literale, Variablen, Operatoranwendungen, Feldzugriffe, Methodenaufrufe, Array-Zugriffe, Klasseninstanziierungen, Array-Instanziierungen, Konditionalausdrücke, Cast-Ausdrücke, Lambda-Ausdrücke."
"Wie man sieht, können in Java Ausdrücke rekursiv aus anderen aufgebaut werden. Methodenausdrücke beinhalten einen Ausdruck für den Empfänger sowie möglicherweise weitere Ausdrücke für die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung des Indexes bzw. der Größe, usw. Dabei müssen alle Ausdrücke korrekt typisiert sein, was bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks, an der Stelle, an der er eingesetzt wird, zuweisungskompatibel sein muss.",Was ist ein Methodenausdruck in Java?,Ein Methodenausdruck in Java beinhaltet einen Ausdruck für den Empfänger sowie möglicherweise weitere Ausdrücke für die Parameter des Methodenaufrufs.
"Wie man sieht, können in Java Ausdrücke rekursiv aus anderen aufgebaut werden. Methodenausdrücke beinhalten einen Ausdruck für den Empfänger sowie möglicherweise weitere Ausdrücke für die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung des Indexes bzw. der Größe, usw. Dabei müssen alle Ausdrücke korrekt typisiert sein, was bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks, an der Stelle, an der er eingesetzt wird, zuweisungskompatibel sein muss.","Was bedeutet es, dass alle Ausdrücke korrekt typisiert sein müssen in Java?","Das bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks, an der Stelle, an der er eingesetzt wird, zuweisungskompatibel sein muss."
"In Java gibt es nur Call by Value und kein Call by Reference, ähnlich wie in SMALLTALK. Das bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Das ist eine erhebliche Einschränkung.",Gibt es in Java Call by Reference?,"Nein, in Java gibt es nur Call by Value und keine Call by Reference."
"In Java gibt es nur Call by Value und kein Call by Reference, ähnlich wie in SMALLTALK. Das bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Das ist eine erhebliche Einschränkung.",Was ist der Unterschied zwischen Call by Value und Call by Reference in Programmiersprachen?,"Call by Value bedeutet, dass der Wert eines Parameters an eine Methode übergeben wird, während Call by Reference bedeutet, dass eine Referenz auf den Speicherort des Parameters übergeben wird. In Java und SMALLTALK gibt es nur Call by Value, was bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können."
"Lambda-Ausdrücke in Java, die mit Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren, die ein Interface (siehe Abschnitt 40) mit nur einer Methode implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Die Funktionen, die Lambda-Ausdrücke darstellen, erhalten über das Interface einen Namen. Anonyme Funktionen oder Blöcke wie in SMALLTALK können in Java über vordefinierte Interfaces erstellt werden.",Was sind Lambda-Ausdrücke in Java?,"Lambda-Ausdrücke in Java sind eine Möglichkeit, Funktionen zu definieren, die mit Version 8 eingeführt wurden. Sie ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Die Funktionen, die Lambda-Ausdrücke darstellen, erhalten über das Interface einen Namen."
"Lambda-Ausdrücke in Java, die mit Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren, die ein Interface (siehe Abschnitt 40) mit nur einer Methode implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Die Funktionen, die Lambda-Ausdrücke darstellen, erhalten über das Interface einen Namen. Anonyme Funktionen oder Blöcke wie in SMALLTALK können in Java über vordefinierte Interfaces erstellt werden.",Wie können anonyme Funktionen oder Blöcke in Java erstellt werden?,In Java können anonyme Funktionen oder Blöcke über vordefinierte Interfaces erstellt werden.
"Es gibt einige Unterschiede zwischen Java-Ausdrücken und SMALLTALK-Ausdrücken, darunter die Verwendung von direkten Feldzugriffen in Java (a.x) und das Fehlen von indizierten Instanzvariablen. Außerdem unterscheidet Java zwischen Operatoranwendungen (+, -, etc.), Methodenaufrufen, Konstruktoraufrufen und Arrayzugriffen, während in SMALLTALK nur Methodenaufrufe existieren.",Wie unterscheiden sich Java-Ausdrücke und SMALLTALK-Ausdrücke?,"Es gibt einige Unterschiede zwischen Java-Ausdrücken und SMALLTALK-Ausdrücken, darunter die Verwendung von direkten Feldzugriffen in Java (a.x) und das Fehlen von indizierten Instanzvariablen in SMALLTALK. Außerdem unterscheidet Java zwischen Operatoranwendungen (+, -, etc.), Methodenaufrufen, Konstruktoraufrufen und Arrayzugriffen, während in SMALLTALK nur Methodenaufrufe existieren."
"In der Daten- und Softwaremodellierung werden Beziehungen (oder Relationen) häufig mit sog. Kardinalitäten versehen. (Manchmal, besonders im Kontext der Softwaremodellierung mit der Unified Modeling Language UML, werden diese auch Multiplizitäten genannt.) Sie geben an, mit wie vielen anderen Objekten ein Objekt gleichzeitig in derselben Beziehung stehen kann. Beispielsweise kann eine Person zu mehreren anderen Personen in einer Verwandtschaftsbeziehung stehen. Häufig sind die möglichen Kardinalitäten auf ein Intervall beschränkt; sie werden dann durch eben dieses Intervall beschrieben.",Was sind Kardinalitäten?,"Kardinalitäten sind in der Daten- und Softwaremodellierung häufig verwendete Beziehungsattribute, die angeben, wie viele andere Objekte ein Objekt in einer Beziehung haben kann."
"Von den theoretisch unendlich vielen möglichen Intervallen, die die Kardinalität beschränken können, sind vor allem drei interessant: [0..1], [1..1] und [0..∞). Dabei ist [1..1], also dass ein Objekt immer mit genau einem in Beziehung stehen muss, technisch nur schwer umzusetzen, sodass [1..1] hier nicht weiter betrachtet wird. Die untere Schranke 0, die den beiden verbleibenden Intervallen gemeinsam ist und die ausdrückt, dass ein Objekt auch mit gar keinem anderen in der Beziehung stehen kann, muss daher nicht erwähnt werden. Im Fall von [0..1] sprechen wir also von Zu-eins-Beziehungen (im folgenden mit Zu-1-Beziehung notiert), im Fall von [0..∞) von Zu-n-Beziehungen (Zu-n-Beziehungen), wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.",Welche Beziehungen gibt es?,"Es gibt Zu-1-Beziehungen und Zu-n-Beziehungen wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt."
"Die Beziehung eines Objekts zu einem anderen, also eine Zu-1-Beziehung, wird auf natürliche Weise durch eine benannte Instanzvariable ausgedrückt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung trägt. So zeigt die Instanzvariable arbeitgeber beispielsweise auf das Objekt, das in der Beziehung Anstellung aus Sicht des Arbeitnehmerobjekts die Rolle des Arbeitgebers spielt. Hat auch das Arbeitgeberobjekt einen Verweis auf das Arbeitnehmerobjekt (die Rückrichtung), so wird die entsprechende Variable sinnvollerweise nach der Gegenrolle arbeitnehmer genannt. Steht ein Arbeitnehmerobjekt zurzeit in keinem Anstellungsverhältnis, ist seine Instanzvariable arbeitgeber leer, was in SMALLTALK durch den Verweis auf das Objekt nil ausgedrückt wird.",Wie werden Zu-1-Beziehungen umgesetzt?,Zu-1-Beziehungen können direkt durch benannte Instanzvariablen zwischen Objekten umgesetzt werden.
"Beziehungen sind nicht von Natur aus auf ein Gegenüber eingeschränkt: Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren anderen stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die „Namen“ der Gegenüber sind einfach Indizes: 1, 2, 3 usw.Es ergibt sich nun aber das Problem, dass bei durch indizierte Instanzvariablen eines Objekts realisierten Zu-n-Beziehungen nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden kann — die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden Zu-n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer über Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die Zu-n-Beziehung ggf. mit weiteren Attributen (z. B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o. ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die Zu-n-Beziehung eigentlich haben sollte, steht dann stattdessen in einer von einer benannten Instanzvariable hergestellten Zu-1-Beziehung zu dem Zwischenobjekt, das die Zu-n-Beziehung herstellt.Wie wir noch sehen werden, erlaubt der Umstand, dass Zu-n-Beziehungen über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, die Beziehungen beliebig auszugestalten. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z. B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z. B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schlüssels können auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z. B. spezielle Schleifen) anbieten können, sind der Ausgestaltung von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt.",Wie werden Zu-n-Beziehungen umgesetzt?,"Zu-n-Beziehungen werden meistens über Zwischenobjekte umgesetzt, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen."
"Beziehungen sind nicht von Natur aus auf ein Gegenüber eingeschränkt: Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren anderen stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die „Namen“ der Gegenüber sind einfach Indizes: 1, 2, 3 usw.Es ergibt sich nun aber das Problem, dass bei durch indizierte Instanzvariablen eines Objekts realisierten Zu-n-Beziehungen nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden kann — die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden Zu-n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer über Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die Zu-n-Beziehung ggf. mit weiteren Attributen (z. B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o. ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die Zu-n-Beziehung eigentlich haben sollte, steht dann stattdessen in einer von einer benannten Instanzvariable hergestellten Zu-1-Beziehung zu dem Zwischenobjekt, das die Zu-n-Beziehung herstellt.Wie wir noch sehen werden, erlaubt der Umstand, dass Zu-n-Beziehungen über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, die Beziehungen beliebig auszugestalten. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z. B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z. B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schlüssels können auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z. B. spezielle Schleifen) anbieten können, sind der Ausgestaltung von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt.",Warum werden Zu-n-Beziehungen über Zwischenobjekte umgesetzt?,"Zu-n-Beziehungen werden über Zwischenobjekte umgesetzt, da die indizierten Instanzvariablen eines Objekts nicht benannt sind und daher nicht zwischen verschiedenen Zu-n-Beziehungen unterschieden werden kann"
"Beziehungen sind nicht von Natur aus auf ein Gegenüber eingeschränkt: Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren anderen stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die „Namen“ der Gegenüber sind einfach Indizes: 1, 2, 3 usw.Es ergibt sich nun aber das Problem, dass bei durch indizierte Instanzvariablen eines Objekts realisierten Zu-n-Beziehungen nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden kann — die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden Zu-n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer über Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die Zu-n-Beziehung ggf. mit weiteren Attributen (z. B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o. ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die Zu-n-Beziehung eigentlich haben sollte, steht dann stattdessen in einer von einer benannten Instanzvariable hergestellten Zu-1-Beziehung zu dem Zwischenobjekt, das die Zu-n-Beziehung herstellt.Wie wir noch sehen werden, erlaubt der Umstand, dass Zu-n-Beziehungen über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, die Beziehungen beliebig auszugestalten. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z. B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z. B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schlüssels können auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z. B. spezielle Schleifen) anbieten können, sind der Ausgestaltung von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt.",Was sind Zwischenobjekte?,"Die Aufgabe von Zwischenobjekten ist es, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Zwischenobjekte können zusätzliche Attribute enthalten, die in ihren benannten Instanzvariablen gespeichert werden."
"MEYERs klassisches Beispiel zur Motivation kovarianter Redefinition und verankerter Typen à la EIFFEL soll Ihnen hier nicht vorenthalten werden. Es wird immer wieder zitiert und ist, abgesehen davon, dass es zu Bemerkungen abseits der Informatik einlädt, intuitiv gut verständlich. Das Beispiel beginnt wie folgt: ""Eine Klasse 'GESTELL' hat eine Unterklasse 'VIERBEINIGES_GESTELL'. Die Klasse 'VIERBEINIGES_GESTELL' hat eine Unterklasse 'TISCH'. Die Klasse 'TISCH' hat eine Unterklasse 'COUCHTISCH'. Die Klasse 'COUCHTISCH' hat eine Unterklasse 'ESSTISCH'. Die Klasse 'ESSTISCH' hat eine Unterklasse 'KONFERENZTISCH'. Die Klasse 'KONFERENZTISCH' hat eine Unterklasse 'KONFERENZTISCH_MIT_RUNDER_TISCHPLATTE'. Die Klasse 'KONFERENZTISCH_MIT_RUNDER_TISCHPLATTE' hat eine Unterklasse 'KONFERENZTISCH_MIT_RUNDER_TISCHPLATTE_UND_TISCHBEINEN'.""",Wie wird das klassische Beispiel zur Motivation kovarianter Redefinition und verankerter Typen beschrieben?,"Das klassische Beispiel zur Motivation kovarianter Redefinition und verankerter Typen beinhaltet eine Klasse KUNSTWERK, die Informationen über ein Kunstwerk verwaltet. Es gibt zwei Unterklassen, BILD und SKULPTUR, die spezifische Informationen über Gemälde und Skulpturen verwalten. BILD hat eine Instanzvariable HÖHE, die die Höhe des Gemäldes in cm speichert, während SKULPTUR eine Instanzvariable GEWICHT hat, die das Gewicht der Skulptur in kg speichert."
"EIFFEL besitzt ein einheitliches Typsystem (keine separaten Referenz- und Werttypen) und unterscheidet auch nicht (wie Java) zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden: Die Operation + auf Integern beispielsweise ist (wie in SMALLTALK) nichts weiter als eine syntaktische Variante einer Methode ""plus"" definiert in einer Klasse ""INTEGER"" mit gleichem Parametertyp (EIFFEL verwendet per Konvention für Klassen und Typen vollständige Großschreibung; allerdings ist EIFFEL — wie PASCAL — nicht case-sensitive). Die Einheitlichkeit des Typsystems von EIFFEL geht dabei über die von C-Sharp insofern hinaus, als es keine an bestimmte Typkonstruktoren gebundene Unterscheidung von Wert- und Referenztypen gibt; gleichzeitig unterscheidet es sich aber von SMALLTALK (das sich zumindest dem Anschein nach vollständig auf Referenztypen festgelegt hat) insofern, als es auch Werttypen zulässt. Mehr dazu gleich.",Was ist das Typsystem in EIFFEL?,"Das Typsystem in EIFFEL ist ein einheitliches Typsystem, das keine separaten Referenz- und Werttypen kennt. Es unterscheidet auch nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden."
"EIFFEL besitzt ein einheitliches Typsystem (keine separaten Referenz- und Werttypen) und unterscheidet auch nicht (wie Java) zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden: Die Operation + auf Integern beispielsweise ist (wie in SMALLTALK) nichts weiter als eine syntaktische Variante einer Methode ""plus"" definiert in einer Klasse ""INTEGER"" mit gleichem Parametertyp (EIFFEL verwendet per Konvention für Klassen und Typen vollständige Großschreibung; allerdings ist EIFFEL — wie PASCAL — nicht case-sensitive). Die Einheitlichkeit des Typsystems von EIFFEL geht dabei über die von C-Sharp insofern hinaus, als es keine an bestimmte Typkonstruktoren gebundene Unterscheidung von Wert- und Referenztypen gibt; gleichzeitig unterscheidet es sich aber von SMALLTALK (das sich zumindest dem Anschein nach vollständig auf Referenztypen festgelegt hat) insofern, als es auch Werttypen zulässt. Mehr dazu gleich.",Welche Unterscheidung gibt es im Typsystem von EIFFEL nicht?,EIFFEL besitzt ein einheitliches Typsystem und unterscheidet nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden. Auch gibt es keine an bestimmte Typkonstruktoren gebundene Unterscheidung von Wert- und Referenztypen.
"EIFFEL besitzt ein einheitliches Typsystem (keine separaten Referenz- und Werttypen) und unterscheidet auch nicht (wie Java) zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden: Die Operation + auf Integern beispielsweise ist (wie in SMALLTALK) nichts weiter als eine syntaktische Variante einer Methode ""plus"" definiert in einer Klasse ""INTEGER"" mit gleichem Parametertyp (EIFFEL verwendet per Konvention für Klassen und Typen vollständige Großschreibung; allerdings ist EIFFEL — wie PASCAL — nicht case-sensitive). Die Einheitlichkeit des Typsystems von EIFFEL geht dabei über die von C-Sharp insofern hinaus, als es keine an bestimmte Typkonstruktoren gebundene Unterscheidung von Wert- und Referenztypen gibt; gleichzeitig unterscheidet es sich aber von SMALLTALK (das sich zumindest dem Anschein nach vollständig auf Referenztypen festgelegt hat) insofern, als es auch Werttypen zulässt. Mehr dazu gleich.",Was unterscheidet EIFFEL von SMALLTALK und C-Sharp in Bezug auf das Typsystem?,"EIFFEL hat ein einheitliches Typsystem, das keine separate Unterscheidung zwischen Referenz- und Werttypen macht, im Gegensatz zu C-Sharp. Im Gegensatz zu SMALLTALK, das sich auf Referenztypen festgelegt hat, unterstützt EIFFEL auch Werttypen."
"Zu den prominentesten Eigenschaften des Typsystems von EIFFEL zählen: Mehrfachvererbung. Generizität (genauer: beschränkter parametrischer Polymorphismus; siehe Abschnitt 29.4 in Kurseinheit 3). Das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden; siehe dazu auch Abschnitt 11.3 in Kurseinheit 1). Kovariante Redefinition, unterstützt durch sog. ""verankerte Typen"" (engl. ""anchored types""; so gut wie ein Alleinstellungsmerkmal von EIFFEL).",Was sind die prominentesten Eigenschaften des Typsystems von EIFFEL?,"Die prominentesten Eigenschaften des Typsystems von EIFFEL sind Mehrfachvererbung, Generizität, das Unterdrücken von Instanzvariablen und Methoden in Subklassen, und kovariante Redefinition, unterstützt durch sog. ""verankerte Typen""."
"Zu den prominentesten Eigenschaften des Typsystems von EIFFEL zählen: Mehrfachvererbung. Generizität (genauer: beschränkter parametrischer Polymorphismus; siehe Abschnitt 29.4 in Kurseinheit 3). Das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden; siehe dazu auch Abschnitt 11.3 in Kurseinheit 1). Kovariante Redefinition, unterstützt durch sog. ""verankerte Typen"" (engl. ""anchored types""; so gut wie ein Alleinstellungsmerkmal von EIFFEL).",Was ist Mehrfachvererbung in EIFFEL?,"Mehrfachvererbung in EIFFEL ist eine Eigenschaft des Typsystems, die es ermöglicht, dass eine Klasse von mehreren übergeordneten Klassen erben kann. Das bedeutet, dass eine Klasse Merkmale und Eigenschaften von mehreren Elternklassen erben kann, was die Wiederverwendung von Code und die Flexibilität bei der Gestaltung von Klassenhierarchien erhöht."
"In gewisser Weise kann man das Unterdrücken von Methoden eines Typs in seinen Subtypen in EIFFEL als einen Spezialfall der kovarianten Redefinition ansehen, nämlich einen, in dem die Menge der möglichen Parameterobjekte auf die leere Menge eingeschränkt wird, so dass es keinen gültigen Aufruf gibt (vgl. Kapitel in Kurseinheit 3). Auch sind die Probleme, die kovariante Redefinition und Unterdrückung verursachen, ähnlich. Deshalb beschränken wir uns bei der Motivation (der Erklärung, warum EIFFEL über diese Eigenschaften verfügt), auf ein Beispiel für kovariante Redefinition.",Was ist kovariante Redefinition in EIFFEL?,"In EIFFEL, kovariante Redefinition ist eine Eigenschaft, bei der die Menge der möglichen Parameterobjekte in einer Unterklasse eingeschränkt wird, so dass es keinen gültigen Aufruf gibt. Diese Eigenschaft ist ähnlich wie das Unterdrücken von Methoden eines Typs in seinen Subtypen."
"Unter einem Type cast (einer Typumwandlung) versteht man den Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde. Type casts werden also insbesondere auf Variablen und auf Methodenausdrücke angewendet, und zwar immer dann, wenn man diese einer Variable zuweisen will, zu der keine Zuweisungskompatibilität besteht, oder wenn man darauf eine Methode aufrufen (oder ein Feld zugreifen) will, das der deklarierte Typ nicht anbietet.",Was ist ein Type cast?,"Ein Type cast ist der Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde. Type casts werden auf Variablen und Methodenausdrücke angewendet, um Zuweisungskompatibilität herzustellen oder auf Methoden zuzugreifen, die der deklarierte Typ nicht anbietet."
"Wie schon in Kapitel 27, so unterscheiden wir auch hier in Abhängigkeit davon, wie die beteiligten Typen, der Ausgangstyp und der Zieltyp eines Type casts, miteinander in Beziehung stehen, drei Arten von Typumwandlungen: Up casts: Der Zieltyp ist ein Supertyp des Ausgangstyps. Down casts: Der Zieltyp ist ein Subtyp des Ausgangstyps. Cross casts: Zieltyp und Ausgangstyp stehen in keiner Subtypenbeziehung zueinander, stehen also gewissermaßen nebeneinander.","Was sind Up casts, Down casts und Cross casts?","Up casts sind Typumwandlungen, bei denen der Zieltyp ein Supertyp des Ausgangstyps ist. Down casts sind Typumwandlungen, bei denen der Zieltyp ein Subtyp des Ausgangstyps ist. Cross casts sind Typumwandlungen, bei denen Zieltyp und Ausgangstyp in keiner Subtypenbeziehung zueinander stehen."
"Wie schon in Kapitel 27, so unterscheiden wir auch hier in Abhängigkeit davon, wie die beteiligten Typen, der Ausgangstyp und der Zieltyp eines Type casts, miteinander in Beziehung stehen, drei Arten von Typumwandlungen: Up casts: Der Zieltyp ist ein Supertyp des Ausgangstyps. Down casts: Der Zieltyp ist ein Subtyp des Ausgangstyps. Cross casts: Zieltyp und Ausgangstyp stehen in keiner Subtypenbeziehung zueinander, stehen also gewissermaßen nebeneinander.","Was ist der Unterschied zwischen Up casts, Down casts und Cross casts?","Up casts sind Typumwandlungen, bei denen der Zieltyp ein Supertyp des Ausgangstyps ist, Down casts sind Typumwandlungen, bei denen der Zieltyp ein Subtyp des Ausgangstyps ist und Cross casts sind Typumwandlungen, bei denen Zieltyp und Ausgangstyp in keiner Subtypenbeziehung zueinander stehen."
"Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen. Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.",Was ist ein Up cast in Java?,"Ein Up cast in Java ist ein Typumwandlungsausdruck, der ein Objekt in einen seiner Supertypen umwandelt. Ein Up cast ist immer sicher und kann daher auch weggelassen werden."
"Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen. Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.",Was ist ein Down cast in Java?,"Ein Down cast in Java ist ein Typumwandlungsausdruck, der ein Objekt in einen seiner Subtypen umwandelt. Ein Down cast kann zu Laufzeittypfehlern führen, wenn das Objekt nicht den Zieltyp oder einen Subtyp davon hat."
"Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen. Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.",Was ist ein Cross cast in Java?,"Ein Cross cast in Java ist ein Typumwandlungsausdruck, der ein Objekt in einen beliebigen anderen Typ umwandelt. Ein Cross cast kann zu Laufzeittypfehlern führen, wenn das Objekt nicht den Zieltyp oder einen Subtyp davon hat."
"Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen. Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.",Wann können Down und Cross casts in Java zu Laufzeittypfehlern führen?,"Down und Cross casts können zu Laufzeittypfehlern führen, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, nicht den Zieltyp oder einen Subtyp davon hat."
"Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen. Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.",Was ist eine ClassCastException in Java?,"Eine ClassCastException in Java ist eine Laufzeittypfehlermeldung, die geworfen wird, wenn ein Down oder Cross cast zu einem Objekt durchgeführt wird, das nicht den Zieltyp oder einen Subtyp davon hat."
"Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen. Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.",Wann ist ein Up cast in Java sicher?,"Ein Up cast in Java ist immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat. Der Up cast kann daher weggelassen werden."
"Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen. Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.",Wann sind Down und Cross casts in Java erfolgreich?,"Down und Cross casts sind in Java nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden und kann daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen."
"Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen. Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.","Was ist der Unterschied zwischen Up cast, Down cast und Cross cast?","Ein Up cast ist eine Typumwandlung, die ein Objekt in einen seiner Supertypen umwandelt, während ein Down cast ein Objekt in einen seiner Subtypen umwandelt. Ein Cross cast ist eine Typumwandlung, die ein Objekt in einen Typ umwandelt, der nicht direkt mit seinem Typ verwandt ist. Ein Up cast ist immer sicher, während Down und Cross casts nur erfolgreich sind, wenn das Objekt den Zieltyp (oder einen Subtyp davon) hat, und können zu Laufzeittypfehlern führen."
"Methoden sind immer Objekten, den sogenannten Empfängerobjekten, zugeordnet. In dieser Kurseinheit werden wir uns nicht darauf festlegen, wie diese Zuordnung erfolgt. Sie dürfen jedoch davon ausgehen, dass jedes Objekt über einen Katalog von Methoden verfügt und somit auf die entsprechenden Nachrichten reagieren kann. Diesen Katalog nennt man auch das Protokoll eines Objekts.",Wie sind Methoden Objekten zugeordnet?,"Methoden sind immer Objekten, den sogenannten Empfängerobjekten, zugeordnet."
"Methoden sind immer Objekten, den sogenannten Empfängerobjekten, zugeordnet. In dieser Kurseinheit werden wir uns nicht darauf festlegen, wie diese Zuordnung erfolgt. Sie dürfen jedoch davon ausgehen, dass jedes Objekt über einen Katalog von Methoden verfügt und somit auf die entsprechenden Nachrichten reagieren kann. Diesen Katalog nennt man auch das Protokoll eines Objekts.",Was ist das Protokoll eines Objekts?,"Das Protokoll eines Objekts ist der Katalog von Methoden, über den ein Objekt verfügt und auf den es entsprechend reagieren kann."
"Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen. Da der Zustand eines Objekts durch die Belegung seiner Instanzvariablen repräsentiert wird und weil in den Methoden das Verhalten eines Objekts spezifiziert ist, ergibt sich, dass das Verhalten vom Zustand des Objekts abhängt (durch Berücksichtigung seiner Instanzvariablen) und es gleichzeitig beeinflussen kann (durch Zuweisungen an die Instanzvariablen). Da Instanzvariablen lokale Variablen sind (lokal zum besitzenden Objekt), sind Methoden sogar die einzige Stelle, an der der Zustand von Objekten geändert werden kann.Neben den formalen Parametern der Methode und den Instanzvariablen des Empfängerobjekts ist im Rumpf jeder Methode eine weitere Variable zugreifbar, die den Namen ""self"" trägt. Diese Variable, die wie die formalen Parameter eine Pseudovariable ist, verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird immer dann benötigt, wenn eine Nachricht aus einer Methode heraus (also per darin enthaltener Anweisung) an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. ""self"" ist somit gewissermaßen der implizite erste Parameter einer Methode.",Warum ist die Zuordnung von Methoden zu Objekten wichtig?,"Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen und somit das Verhalten des Objekts zu spezifizieren und zu beeinflussen."
"Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen. Da der Zustand eines Objekts durch die Belegung seiner Instanzvariablen repräsentiert wird und weil in den Methoden das Verhalten eines Objekts spezifiziert ist, ergibt sich, dass das Verhalten vom Zustand des Objekts abhängt (durch Berücksichtigung seiner Instanzvariablen) und es gleichzeitig beeinflussen kann (durch Zuweisungen an die Instanzvariablen). Da Instanzvariablen lokale Variablen sind (lokal zum besitzenden Objekt), sind Methoden sogar die einzige Stelle, an der der Zustand von Objekten geändert werden kann.Neben den formalen Parametern der Methode und den Instanzvariablen des Empfängerobjekts ist im Rumpf jeder Methode eine weitere Variable zugreifbar, die den Namen ""self"" trägt. Diese Variable, die wie die formalen Parameter eine Pseudovariable ist, verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird immer dann benötigt, wenn eine Nachricht aus einer Methode heraus (also per darin enthaltener Anweisung) an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. ""self"" ist somit gewissermaßen der implizite erste Parameter einer Methode.","Was ist die Variable ""self"" in Methoden?","Die Variable ""self"" verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird benötigt, wenn eine Nachricht aus einer Methode heraus an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. ""self"" ist somit der implizite erste Parameter einer Methode."
"Nicht zuletzt werden auch ganz banale Arrays häufig verwendet, insbesondere wegen der Möglichkeit der einfachen literalen Definition. So kann man ohne viel Aufwand über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung iterieren. Beispielsweise weist der Laufparameter des Blocks, ""element"", nacheinander die Elemente des literalen Arrays zu.",Wofür werden Arrays häufig verwendet?,"Arrays werden häufig wegen der Möglichkeit der einfachen literalen Definition verwendet, insbesondere um über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung zu iterieren."
"Nicht zuletzt werden auch ganz banale Arrays häufig verwendet, insbesondere wegen der Möglichkeit der einfachen literalen Definition. So kann man ohne viel Aufwand über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung iterieren. Beispielsweise weist der Laufparameter des Blocks, ""element"", nacheinander die Elemente des literalen Arrays zu.",Was ist die Funktion von Arrays in der Programmierung?,"Arrays werden in der Programmierung häufig verwendet, insbesondere wegen der Möglichkeit der einfachen literalen Definition. Sie ermöglichen es, einfach über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung zu iterieren. Zum Beispiel kann man den Laufparameter eines Blocks, ""element"", nacheinander die Elemente des literalen Arrays zuweisen."
"Der wesentliche Nachteil von Arrays ist, dass ihre Größe beschränkt ist. Benötigt man eine geordnete Collection, die beliebig wachsen kann, der also am Anfang, am Ende oder an einer beliebigen Position dazwischen Elemente hinzugefügt werden können, dann kann man auf Instanzen der Klasse ""OrderedCollection"" zurückgreifen. Diese eignen sich aufgrund des angebotenen Methodensatzes und ihres Protokolls speziell für die Implementierung von Stapeln (Stacks) und Puffern (Queues).","Wofür eignen sich Instanzen der Klasse ""OrderedCollection""?","Instanzen der Klasse ""OrderedCollection"" eignen sich für die Implementierung von Stapeln (Stacks) und Puffern (Queues), da sie eine geordnete Collection sind, die beliebig wachsen kann und Elemente am Anfang, am Ende oder an einer beliebigen Position dazwischen hinzufügen kann."
"Der wesentliche Nachteil von Arrays ist, dass ihre Größe beschränkt ist. Benötigt man eine geordnete Collection, die beliebig wachsen kann, der also am Anfang, am Ende oder an einer beliebigen Position dazwischen Elemente hinzugefügt werden können, dann kann man auf Instanzen der Klasse ""OrderedCollection"" zurückgreifen. Diese eignen sich aufgrund des angebotenen Methodensatzes und ihres Protokolls speziell für die Implementierung von Stapeln (Stacks) und Puffern (Queues).",Was sind die Nachteile von Arrays?,"Der wesentliche Nachteil von Arrays ist, dass ihre Größe beschränkt ist und dass sie nicht beliebig wachsen können."
"In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen (der Umgang mit Konstruktoren in EIFFEL unterscheidet sich erheblich von dem in SMALLTALK und auch von dem in Java/C-Sharp/C++; hierauf wird jedoch nicht weiter eingegangen) sowie den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat. In der Praxis kann dies lästig sein, zu sehr ausgedehnten Programmen führen und dürfte ein Grund für die geringe Akzeptanz von EIFFEL unter professionellen Programmierern sein. Trotzdem bietet EIFFEL ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet (insbesondere erlaubt es ein ""Retry"", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss). Auf Einzelheiten des Exception Handling in EIFFEL wird hier jedoch nicht eingegangen, da es nur begrenzt mit der Objektorientierung zu tun hat.",Was sind die Anweisungen in EIFFEL?,"In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. Jede Kontrollstruktur hat genau einen Eingang und einen Ausgang. EIFFEL bietet ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet."
"In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen (der Umgang mit Konstruktoren in EIFFEL unterscheidet sich erheblich von dem in SMALLTALK und auch von dem in Java/C-Sharp/C++; hierauf wird jedoch nicht weiter eingegangen) sowie den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat. In der Praxis kann dies lästig sein, zu sehr ausgedehnten Programmen führen und dürfte ein Grund für die geringe Akzeptanz von EIFFEL unter professionellen Programmierern sein. Trotzdem bietet EIFFEL ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet (insbesondere erlaubt es ein ""Retry"", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss). Auf Einzelheiten des Exception Handling in EIFFEL wird hier jedoch nicht eingegangen, da es nur begrenzt mit der Objektorientierung zu tun hat.",Was sind die Bestandteile einer Anweisung in EIFFEL?,"In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. Jede Kontrollstruktur hat genau einen Eingang und einen Ausgang. EIFFEL bietet ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet."
"In EIFFEL, ähnlich wie in PASCAL, dient das Semikolon als Trennzeichen und ist kein Bestandteil einer Anweisung. Darüber hinaus kann es am Ende einer Zeile auch weggelassen werden. Kleine EIFFEL-Programme wirken daher optisch aufgeräumt, und aufgrund des Verzichts auf Blöcke außerhalb von Kontrollstrukturen - es gibt weder { ... } noch ""begin ... end"" - wirken große Programme jedoch schnell aufgebläht.",Wie wird das Semikolon in EIFFEL verwendet?,"Im Gegensatz zu anderen Programmiersprachen dient das Semikolon in EIFFEL nicht als Ende einer Anweisung, sondern als Trennzeichen zwischen Anweisungen. Es kann am Ende einer Zeile weggelassen werden."
"Properties sind gewissermaßen die Umkehrung von Zugriffsmethoden (Settern und Gettern; s. Abschnitt 4.3.4 in Kurseinheit 1): Anstatt auf ein Feld eines Objektes über Methoden (lesend und schreibend) zuzugreifen, ruft man Methoden über das auf, was syntaktisch wie ein Feldzugriff aussieht. Dies erlaubt es, (lesende und schreibende) Feldzugriffe mit Nebeneffekten zu versehen (wie z. B. einer dynamischen Typprüfung bei schreibendem Zugriff, wenn man kovariante Redefinition imitieren will). Dabei sind ""get"" und ""set"" Schlüsselwörter von C-Sharp, und ""value"" ist eine spezielle Variable (vergleichbar mit ""this""), die den Eingabewert eines Setters hält. Um einem Punkt seine Koordinaten zuzuweisen bzw. darauf zuzugreifen, kann man dann die Properties X, Y, Winkel und Radius wie Felder verwenden. Keine große Sache, aber es macht den Code auf der Aufruferinnenseite knapper und besser lesbar. Den Getter oder den Setter kann man wahlweise auch weglassen; auf diese Weise lassen sich Felder mit Nur-Lese- bzw. Nur-Schreib-Zugriff simulieren.",Was sind Properties in C-Sharp?,"Properties in C-Sharp sind eine Möglichkeit, gewissermaßen die Umkehrung von Zugriffsmethoden zu erreichen. Statt auf ein Feld eines Objekts über Methoden zuzugreifen, ruft man Methoden über das auf, was syntaktisch wie ein Feldzugriff aussieht. Dies erlaubt es, Feldzugriffe mit Nebeneffekten zu versehen, wie zum Beispiel einer dynamischen Typprüfung bei schreibendem Zugriff. Properties können auch dazu verwendet werden, Felder mit Nur-Lese- oder Nur-Schreib-Zugriff zu simulieren."
"Properties sind gewissermaßen die Umkehrung von Zugriffsmethoden (Settern und Gettern; s. Abschnitt 4.3.4 in Kurseinheit 1): Anstatt auf ein Feld eines Objektes über Methoden (lesend und schreibend) zuzugreifen, ruft man Methoden über das auf, was syntaktisch wie ein Feldzugriff aussieht. Dies erlaubt es, (lesende und schreibende) Feldzugriffe mit Nebeneffekten zu versehen (wie z. B. einer dynamischen Typprüfung bei schreibendem Zugriff, wenn man kovariante Redefinition imitieren will). Dabei sind ""get"" und ""set"" Schlüsselwörter von C-Sharp, und ""value"" ist eine spezielle Variable (vergleichbar mit ""this""), die den Eingabewert eines Setters hält. Um einem Punkt seine Koordinaten zuzuweisen bzw. darauf zuzugreifen, kann man dann die Properties X, Y, Winkel und Radius wie Felder verwenden. Keine große Sache, aber es macht den Code auf der Aufruferinnenseite knapper und besser lesbar. Den Getter oder den Setter kann man wahlweise auch weglassen; auf diese Weise lassen sich Felder mit Nur-Lese- bzw. Nur-Schreib-Zugriff simulieren.",Wie werden Properties in C-Sharp verwendet?,"Properties werden verwendet, um (lesend und schreibend) Feldzugriffe zu ermöglichen, die wie Feldzugriffe aussehen, aber mit zusätzlichen Funktionalitäten. Sie können auch verwendet werden, um Felder mit Nur-Lese- oder Nur-Schreib-Zugriff zu simulieren."
"Zwar besteht jedes laufende objektorientierte Programm aus einer Menge von Objekten, jede Spezifikation eines solchen Programms besteht jedoch bei den heute gebräuchlichen klassenbasierten objektorientierten Programmiersprachen aus einer Menge von Klassen. Die strukturbildende Einheit der objektorientierten Programmierung auf Programmebene ist daher die Klasse. Größere Einheiten sind innerhalb der gängigsten objektorientierten Programmiersprachen nicht vorgesehen: Javas Packages und ähnliche Konstrukte sind allenfalls Namensräume und Einheiten der Auslieferung — der Status eines Sprachkonstrukts vergleichbar mit Klasse oder Methode kommt ihnen kaum zu.",Was ist die strukturbildende Einheit der objektorientierten Programmierung auf Programmebene?,Die strukturbildende Einheit der objektorientierten Programmierung auf Programmebene ist die Klasse.
"Nun sind Klassen relativ feingranulare Gebilde. Zwar hindert einen nichts daran, große Klassen (mit Hunderten von Attributen und Methoden) zu schreiben, aber dies gilt nicht nur als schlechter Stil, es spiegelt auch die Anwendungsdomäne in aller Regel nicht angemessen wider. Dort sind nämlich alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Dasselbe gilt auch für die Artefakte anderer Ingenieursdisziplinen: Baupläne sind in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert. Da wünscht man sich natürlich analoge Möglichkeiten in der objektorientierten Programmierung.",Wozu dienen feingranulare Klassen in der objektorientierten Programmierung?,"Feingranulare Klassen in der objektorientierten Programmierung sind nützlich, um die Anwendungsdomäne angemessen abzubilden und die Komplexität der Klassen zu reduzieren. Sie ermöglichen eine bessere Strukturierung der Klassen und erleichtern die Wartung und Weiterentwicklung des Codes."
"Nun sind Klassen relativ feingranulare Gebilde. Zwar hindert einen nichts daran, große Klassen (mit Hunderten von Attributen und Methoden) zu schreiben, aber dies gilt nicht nur als schlechter Stil, es spiegelt auch die Anwendungsdomäne in aller Regel nicht angemessen wider. Dort sind nämlich alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Dasselbe gilt auch für die Artefakte anderer Ingenieursdisziplinen: Baupläne sind in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert. Da wünscht man sich natürlich analoge Möglichkeiten in der objektorientierten Programmierung.",Warum sollten Klassen nicht zu groß sein?,"Klassen sollten nicht zu groß sein, da dies als schlechter Stil gilt und die Anwendungsdomäne nicht angemessen widerspiegelt. Stattdessen sollten große Dinge in einfachere zusammengesetzt werden, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind. Diese Art der Strukturierung findet man auch in anderen Ingenieursdisziplinen wie dem Bauwesen."
"Nun sind Klassen relativ feingranulare Gebilde. Zwar hindert einen nichts daran, große Klassen (mit Hunderten von Attributen und Methoden) zu schreiben, aber dies gilt nicht nur als schlechter Stil, es spiegelt auch die Anwendungsdomäne in aller Regel nicht angemessen wider. Dort sind nämlich alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Dasselbe gilt auch für die Artefakte anderer Ingenieursdisziplinen: Baupläne sind in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert. Da wünscht man sich natürlich analoge Möglichkeiten in der objektorientierten Programmierung.",Warum sind Klassen in objektorientierter Programmierung relativ feingranular?,"Klassen sind in objektorientierter Programmierung relativ feingranular, weil große Klassen mit Hunderten von Attributen und Methoden als schlechter Stil gelten und die Anwendungsdomäne nicht angemessen widerspiegeln. Stattdessen sind alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Diese Art der Strukturierung findet man auch in anderen Ingenieursdisziplinen wie dem Bauwesen, wo Baupläne in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert sind."
"Nun ist es zwar möglich, Objekte mithilfe der Teil-Ganzes-Beziehung rekursiv aufzubauen (und im oben diskutierten Rahmen auch zu kapseln, also Teile vollständig hinter Ganzen zu verbergen), aber für Klassen gilt das nicht. Zwar ist es hier möglich, über sogenannte innere Klassen (in Java) Klassen zu strukturieren, aber allein schon die Tatsache, wie relativ wenig davon Gebrauch gemacht wird, zeigt, dass es sich dabei um keinen besonders nützlichen Mechanismus handelt.93 Tatsächlich ist es nämlich — wie schon in Kapitel 58 angesprochen — so, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind (und schon gar nicht immer der gleichen Klasse), sondern vielmehr einzelne Exemplare (Instanzen) Teil sein und vielleicht sogar selbst Teile haben können. Man kann also die hierarchische Struktur objektorientierter Systeme genauso wenig auf Klassenebene vorschreiben, wie man den Aufbau einer Maschine anhand lediglich der Typen ihrer Teile (Schrauben etc.) beschreiben könnte (ohne festzulegen, wo jede einzelne Instanz genau hingehört). Was man vielmehr bräuchte, sind Komponenten als zusätzliches, von Klassen und Objekten verschiedenes Programmiersprachenkonstrukt.",Wie können Objekte in objektorientierten Systemen strukturiert werden?,"Objekte können in objektorientierten Systemen mithilfe der Teil-Ganzes-Beziehung rekursiv aufgebaut werden, wobei Teile hinter Ganzen verbergen können. Für Klassen gilt das nicht, da Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind. Stattdessen können Objekte einzelne Exemplare (Instanzen) sein, die Teile haben können. Komponenten als zusätzliches Programmiersprachenkonstrukt können hierbei helfen, die Struktur von objektorientierten Systemen zu beschreiben."
"Nun ist es zwar möglich, Objekte mithilfe der Teil-Ganzes-Beziehung rekursiv aufzubauen (und im oben diskutierten Rahmen auch zu kapseln, also Teile vollständig hinter Ganzen zu verbergen), aber für Klassen gilt das nicht. Zwar ist es hier möglich, über sogenannte innere Klassen (in Java) Klassen zu strukturieren, aber allein schon die Tatsache, wie relativ wenig davon Gebrauch gemacht wird, zeigt, dass es sich dabei um keinen besonders nützlichen Mechanismus handelt.93 Tatsächlich ist es nämlich — wie schon in Kapitel 58 angesprochen — so, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind (und schon gar nicht immer der gleichen Klasse), sondern vielmehr einzelne Exemplare (Instanzen) Teil sein und vielleicht sogar selbst Teile haben können. Man kann also die hierarchische Struktur objektorientierter Systeme genauso wenig auf Klassenebene vorschreiben, wie man den Aufbau einer Maschine anhand lediglich der Typen ihrer Teile (Schrauben etc.) beschreiben könnte (ohne festzulegen, wo jede einzelne Instanz genau hingehört). Was man vielmehr bräuchte, sind Komponenten als zusätzliches, von Klassen und Objekten verschiedenes Programmiersprachenkonstrukt.",Was ist der Unterschied zwischen Objekten und Klassen in Bezug auf die Teil-Ganzes-Beziehung?,"Objekte können mithilfe der Teil-Ganzes-Beziehung rekursiv aufgebaut werden, während Klassen nicht hierarchisch strukturiert werden können. Objekte sind einzelne Exemplare (Instanzen) und können Teile haben, während Klassen Typen von Objekten sind und nicht immer Teile von anderen Klassen sind."
"Nun ist es zwar möglich, Objekte mithilfe der Teil-Ganzes-Beziehung rekursiv aufzubauen (und im oben diskutierten Rahmen auch zu kapseln, also Teile vollständig hinter Ganzen zu verbergen), aber für Klassen gilt das nicht. Zwar ist es hier möglich, über sogenannte innere Klassen (in Java) Klassen zu strukturieren, aber allein schon die Tatsache, wie relativ wenig davon Gebrauch gemacht wird, zeigt, dass es sich dabei um keinen besonders nützlichen Mechanismus handelt.93 Tatsächlich ist es nämlich — wie schon in Kapitel 58 angesprochen — so, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind (und schon gar nicht immer der gleichen Klasse), sondern vielmehr einzelne Exemplare (Instanzen) Teil sein und vielleicht sogar selbst Teile haben können. Man kann also die hierarchische Struktur objektorientierter Systeme genauso wenig auf Klassenebene vorschreiben, wie man den Aufbau einer Maschine anhand lediglich der Typen ihrer Teile (Schrauben etc.) beschreiben könnte (ohne festzulegen, wo jede einzelne Instanz genau hingehört). Was man vielmehr bräuchte, sind Komponenten als zusätzliches, von Klassen und Objekten verschiedenes Programmiersprachenkonstrukt.",Warum sind innere Klassen in Java nicht ein besonders nützlicher Mechanismus?,"Obwohl in Java innere Klassen genutzt werden können, um Klassen zu strukturieren, wird davon relativ wenig Gebrauch gemacht. Dies liegt daran, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind und vielmehr einzelne Exemplare (Instanzen) sein und vielleicht sogar selbst Teile haben können. Einzelne Instanzen können nicht durch innere Klassen beschrieben werden, weshalb sie als ein nicht besonders nützlicher Mechanismus angesehen werden."
"Leider ist es mit der Einführung von Komponenten in objektorientierte Programmiersprachen bislang noch nicht besonders weit. Das merkt man schon daran, dass keine weit verbreitete objektorientierte Programmiersprache das Schlüsselwort ""component"" verwendet, ja nicht einmal reserviert. Stattdessen lässt man die Programmierer alles in Form von Klassen definieren und Komponenten immer zur Laufzeit, per Aggregation von Objekten, zusammenbauen. So schwache Konzepte wie Pakete (Java) oder Assemblies (C-Sharp) können dabei keineswegs einen Komponentenbegriff ersetzen, da sie lediglich Klassen gruppieren (und dabei auch noch ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann). Es ist meine persönliche Vermutung, dass an dieser Front in den nächsten Jahren noch der größte Fortschritt erzielt werden kann.",Wie werden Komponenten in objektorientierten Programmiersprachen bisher behandelt?,"Bislang ist es mit der Einführung von Komponenten in objektorientierten Programmiersprachen noch nicht besonders weit. Es gibt kein weit verbreitetes Schlüsselwort ""component"" und Komponenten werden immer zur Laufzeit, per Aggregation von Objekten, zusammengebaut. Pakete oder Assemblies können keinen Komponentenbegriff ersetzen, da sie lediglich Klassen gruppieren."
"Leider ist es mit der Einführung von Komponenten in objektorientierte Programmiersprachen bislang noch nicht besonders weit. Das merkt man schon daran, dass keine weit verbreitete objektorientierte Programmiersprache das Schlüsselwort ""component"" verwendet, ja nicht einmal reserviert. Stattdessen lässt man die Programmierer alles in Form von Klassen definieren und Komponenten immer zur Laufzeit, per Aggregation von Objekten, zusammenbauen. So schwache Konzepte wie Pakete (Java) oder Assemblies (C-Sharp) können dabei keineswegs einen Komponentenbegriff ersetzen, da sie lediglich Klassen gruppieren (und dabei auch noch ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann). Es ist meine persönliche Vermutung, dass an dieser Front in den nächsten Jahren noch der größte Fortschritt erzielt werden kann.",Was ist der Unterschied zwischen Komponenten und Klassen in objektorientierten Programmiersprachen?,"Im Gegensatz zu Klassen, die in objektorientierten Programmiersprachen verwendet werden, um Objekte zu definieren, werden Komponenten verwendet, um Objekte zur Laufzeit zusammenzubauen. Leider ist der Begriff ""Komponente"" in objektorientierten Programmiersprachen noch nicht weit verbreitet und wird oft durch andere Konzepte wie Pakete oder Assemblies ersetzt, die lediglich Klassen gruppieren."
"Leider ist es mit der Einführung von Komponenten in objektorientierte Programmiersprachen bislang noch nicht besonders weit. Das merkt man schon daran, dass keine weit verbreitete objektorientierte Programmiersprache das Schlüsselwort ""component"" verwendet, ja nicht einmal reserviert. Stattdessen lässt man die Programmierer alles in Form von Klassen definieren und Komponenten immer zur Laufzeit, per Aggregation von Objekten, zusammenbauen. So schwache Konzepte wie Pakete (Java) oder Assemblies (C-Sharp) können dabei keineswegs einen Komponentenbegriff ersetzen, da sie lediglich Klassen gruppieren (und dabei auch noch ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann). Es ist meine persönliche Vermutung, dass an dieser Front in den nächsten Jahren noch der größte Fortschritt erzielt werden kann.",Was sind Komponenten in objektorientierter Programmierung?,"In objektorientierter Programmierung werden Komponenten als wiederverwendbare, selbstbeschreibende und austauschbare Einheiten angesehen, die eine bestimmte Funktionalität bereitstellen. Sie werden in der Regel zur Laufzeit, per Aggregation von Objekten, zusammengebaut. Leider ist es mit der Einführung von Komponenten in objektorientierten Programmiersprachen noch nicht besonders weit, da keine weit verbreitete objektorientierte Programmiersprache das Schlüsselwort ""component"" verwendet oder reserviert. Stattdessen werden Programmierer dazu veranlasst, alles in Form von Klassen zu definieren. Konzepte wie Pakete (Java) oder Assemblies (C-Sharp) können einen Komponentenbegriff nicht ersetzen, da sie lediglich Klassen gruppieren und dabei ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann. Es wird vermutet, dass in den nächsten Jahren in diesem Bereich noch der größte Fortschritt erzielt werden kann."
"Um Zu-n-Beziehungen zu pflegen, also Objekte zu einer Beziehung hinzuzufügen und wieder zu entfernen, sieht SMALLTALK standardmäßig die Methoden add: und remove: vor, die beide jeweils das Argumentobjekt zurückliefern. Beide sind in der abstrakten Klasse Collection definiert, die Wurzel einer Hierarchie von Klassen, den Collection-Klassen, ist, die allesamt der Verwirklichung von : n-Beziehungen dienen. Unsere Zwischenobjekte, die diese Beziehungen repräsentieren, sind also alle indirekte Instanzen von Collection. Die Methoden add: und remove: bleiben zunächst (in Collection) abstrakt. Da sie von der tatsächlichen Realisierung einer Collection abhängen, können sie erst in den entsprechenden Subklassen (durch Überschreiben) realisiert werden.",Wofür werden die Methoden add: und remove: in SMALLTALK verwendet?,"Die Methoden add: und remove: werden in SMALLTALK verwendet, um Zu-n-Beziehungen zu pflegen, also Objekte zu einer Beziehung hinzuzufügen und wieder zu entfernen. Beide Methoden geben das Argumentobjekt zurück."
"Beim Entfernen eines Objektes aus einer Collection mittels remove: gibt es zwei Sonderfälle zu berücksichtigen: Das Objekt ist nicht vorhanden oder das Objekt ist mehrfach vorhanden. Im ersten Fall wird ein Fehler gemeldet, während im zweiten Fall nur ein Vorkommen des Objekts aus der Collection entfernt wird (das erste, wie auch immer die Reihenfolge festgelegt ist). Da es immer vorkommen kann, dass ein zu entfernendes Objekt gar nicht vorhanden ist, und ein entsprechender vorheriger Test auf Vorhandensein (siehe unten) wieder eine stereotype Handlung ist, bietet SMALLTALK eine Variante von remove:, die einem genau das erspart: remove: anObject ifAbsent: anExceptionBlock. Sollte das zu entfernende Objekt fehlen, wird stattdessen anExceptionBlock ausgeführt, und dessen Ergebnis wird zurückgeliefert. Will man, dass beim Versuch, ein nicht vorhandenes Objekt zu entfernen, nichts passiert, so gibt man einfach den leeren Block [] für anExceptionBlock an. Sollen mehrere Objekte auf einmal einer Beziehung hinzugefügt bzw. daraus entfernt werden, so stehen hierfür die Methoden addAll: aCollection bzw. removeAll: aCollection zur Verfügung, die jeweils eine Collection als Parameter erwarten.","Was passiert, wenn man versucht, ein nicht vorhandenes Objekt aus einer Collection zu entfernen?","Wenn man versucht, ein nicht vorhandenes Objekt aus einer Collection zu entfernen, wird ein Fehler gemeldet."
"Beim Entfernen eines Objektes aus einer Collection mittels remove: gibt es zwei Sonderfälle zu berücksichtigen: Das Objekt ist nicht vorhanden oder das Objekt ist mehrfach vorhanden. Im ersten Fall wird ein Fehler gemeldet, während im zweiten Fall nur ein Vorkommen des Objekts aus der Collection entfernt wird (das erste, wie auch immer die Reihenfolge festgelegt ist). Da es immer vorkommen kann, dass ein zu entfernendes Objekt gar nicht vorhanden ist, und ein entsprechender vorheriger Test auf Vorhandensein (siehe unten) wieder eine stereotype Handlung ist, bietet SMALLTALK eine Variante von remove:, die einem genau das erspart: remove: anObject ifAbsent: anExceptionBlock. Sollte das zu entfernende Objekt fehlen, wird stattdessen anExceptionBlock ausgeführt, und dessen Ergebnis wird zurückgeliefert. Will man, dass beim Versuch, ein nicht vorhandenes Objekt zu entfernen, nichts passiert, so gibt man einfach den leeren Block [] für anExceptionBlock an. Sollen mehrere Objekte auf einmal einer Beziehung hinzugefügt bzw. daraus entfernt werden, so stehen hierfür die Methoden addAll: aCollection bzw. removeAll: aCollection zur Verfügung, die jeweils eine Collection als Parameter erwarten.","Was ist die Lösung für das Problem, dass beim Entfernen eines Objekts aus einer Collection ein Fehler gemeldet wird, wenn das Objekt nicht vorhanden ist?","Die Lösung ist die Verwendung der Methode remove: anObject ifAbsent: anExceptionBlock, die einen Block ausführt, wenn das zu entfernende Objekt nicht vorhanden ist."
"Es ist wichtig zu beachten, dass es sich bei den entsprechenden Instanzen prinzipiell um eigenständige Objekte handelt, die hier lediglich die Funktion eines Zwischenobjektes haben, um die Beziehungen zu realisieren. Subklassen von Collection müssen also die Methoden add: und remove:ifAbsent: überschreiben. Dabei offenbart sich gleich ein Charakterzug von SMALLTALK: Da seine Klassenhierarchie keine Generalisierungshierarchie ist, kommt es vor, dass Subklassen die Methoden add:, remove: und remove:ifAbsent: löschen. Während beispielsweise in der Klasse OrderedCollection add: und remove:ifAbsent: überschrieben werden, werden sie in der Klasse FixedSizeCollection, die ebenfalls eine Subklasse von Collection ist, gelöscht.","Was ist der Charakterzug von SMALLTALK, der sich in der Klassenhierarchie zeigt?","Der Charakterzug von SMALLTALK ist, dass seine Klassenhierarchie keine Generalisierungshierarchie ist. Das bedeutet, dass Subklassen die Methoden add:, remove: und remove:ifAbsent: löschen können, obwohl sie in der Oberklasse Collection definiert sind."
"Es ist wichtig zu beachten, dass es sich bei den entsprechenden Instanzen prinzipiell um eigenständige Objekte handelt, die hier lediglich die Funktion eines Zwischenobjektes haben, um die Beziehungen zu realisieren. Subklassen von Collection müssen also die Methoden add: und remove:ifAbsent: überschreiben. Dabei offenbart sich gleich ein Charakterzug von SMALLTALK: Da seine Klassenhierarchie keine Generalisierungshierarchie ist, kommt es vor, dass Subklassen die Methoden add:, remove: und remove:ifAbsent: löschen. Während beispielsweise in der Klasse OrderedCollection add: und remove:ifAbsent: überschrieben werden, werden sie in der Klasse FixedSizeCollection, die ebenfalls eine Subklasse von Collection ist, gelöscht.",Warum können Subklassen von Collection in Smalltalk Methoden löschen?,"In Smalltalk ist die Klassenhierarchie keine Generalisierungshierarchie, was bedeutet, dass Subklassen nicht verpflichtet sind, die Methoden ihrer Superklassen zu implementieren. Sie können sie sogar löschen, wenn sie dies für nicht notwendig erachten. Dies ist beispielsweise in der Klasse FixedSizeCollection der Fall, die Methoden add:, remove: und remove:ifAbsent: löscht, die in der Klasse Collection definiert sind."
"Die Methoden add: und remove: werden durch die Methoden addAll: und removeAll: komplettiert; die Implementierung von addAll: können Sie den Zeilen 427–431 oben entnehmen, removeAll: verläuft im Prinzip analog (warum SMALLTALK EXPRESS hier eine Kopie zurückgibt, weiß ich nicht). Die Methode addAll: wird dazu benutzt, eine Collection in eine andere zu konvertieren. Dabei ist addAll: nur einmal, nämlich in Collection, definiert. Man beachte, dass dabei ein Objekt nicht seine Klasse wechselt, sondern lediglich der Inhalt einer Collection in eine neue übertragen wird. Diese Übertragung ist immer dann sinnvoll, wenn die Klasse der neuen Collection Eigenschaften hat, die man gern nutzen möchte. Ein Beispiel hierfür finden Sie in Zeile 525 unten. Die Nachricht yourself (von Object geerbt) liefert übrigens ihren Empfänger zurück; sie wird am Ende von kaskadierten Nachrichtenausdrücken in Return-Anweisungen verwendet, um den Empfänger zurückzuliefern.",Was macht die Nachricht addAll:?,Die Nachricht addAll: fügt alle Elemente einer Collection zu einer anderen Collection hinzu. Sie ist nur in der Klasse Collection definiert.
"Zum Pflegen seiner Beziehungen ist es manchmal vorteilhaft, zu wissen, mit wie vielen Objekten man in Beziehung steht und mit welchen. Die Klasse Collection sieht dafür die Methoden size, isEmpty und notEmpty, includes: sowie occurencesOf: vor, die jeweils die naheliegende Bedeutung haben.","Was können die Methoden size, isEmpty und notEmpty, includes: sowie occurencesOf: in der Klasse Collection tun?","Diese Methoden können verwendet werden, um die Anzahl der Objekte in einer Kollektion zu ermitteln, zu überprüfen, ob eine Kollektion leer ist oder nicht, zu überprüfen, ob ein bestimmtes Objekt in der Kollektion enthalten ist, und die Anzahl der Vorkommen eines bestimmten Objekts in der Kollektion zu ermitteln."
"In SMALLTALK gibt es also eine Hierarchie, die auf dem Konzept der Klassifikation aufbaut. Aufgrund praktischer Überlegungen ist diese Hierarchie beschränkt; sie ist mit der Sprachdefinition festgelegt und stellt gewissermaßen einen Teil derselben dar. Konzeptionell ist diese Hierarchie eine Abstraktionshierarchie: Von den konkreten Objekten der Ebene 0 geht es über die Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Konzepte auf Ebene 2 und schließlich zur Fassung von Definitionen allgemein auf Ebene 3. Mit jeder Stufe, mit Ausnahme der mittleren, wird die Zahl der Objekte, die unter die darin angesiedelten Konzepte fallen, drastisch reduziert: von Ebene 0 auf Ebene 1 von theoretisch unendlich vielen Objekten einer Anwendung zur Zahl der Anwendungsklassen, von Ebene 2 auf Ebene 3.",Was ist eine Hierarchie in SMALLTALK?,"In SMALLTALK gibt es eine Hierarchie, die auf dem Konzept der Klassifikation aufbaut. Diese Hierarchie ist beschränkt und stellt einen Teil der Sprachdefinition dar. Sie ist eine Abstraktionshierarchie, bei der die Zahl der Objekte mit jeder Stufe reduziert wird, mit Ausnahme der mittleren."
"In SMALLTALK gibt es also eine Hierarchie, die auf dem Konzept der Klassifikation aufbaut. Aufgrund praktischer Überlegungen ist diese Hierarchie beschränkt; sie ist mit der Sprachdefinition festgelegt und stellt gewissermaßen einen Teil derselben dar. Konzeptionell ist diese Hierarchie eine Abstraktionshierarchie: Von den konkreten Objekten der Ebene 0 geht es über die Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Konzepte auf Ebene 2 und schließlich zur Fassung von Definitionen allgemein auf Ebene 3. Mit jeder Stufe, mit Ausnahme der mittleren, wird die Zahl der Objekte, die unter die darin angesiedelten Konzepte fallen, drastisch reduziert: von Ebene 0 auf Ebene 1 von theoretisch unendlich vielen Objekten einer Anwendung zur Zahl der Anwendungsklassen, von Ebene 2 auf Ebene 3.",Was ist eine Abstraktionshierarchie in Smalltalk?,"Eine Abstraktionshierarchie in Smalltalk ist eine Hierarchie, die auf dem Konzept der Klassifikation aufbaut und mit der Sprachdefinition festgelegt ist. Sie ist eine Hierarchie, die von den konkreten Objekten der Ebene 0 über die Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Konzepte auf Ebene 2 und schließlich zur Fassung von Definitionen allgemein auf Ebene 3 führt. Mit jeder Stufe, mit Ausnahme der mittleren, wird die Zahl der Objekte, die unter die darin angesiedelten Konzepte fallen, drastisch reduziert."
"In der Praxis bewegen Sie sich jedoch vor allem auf Ebene 1: Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen Sie also nur eine Abstraktionsstufe für die Programmierung.",Wie viele Abstraktionsstufen gibt es in der Programmierung mit Smalltalk?,Es gibt zwei Abstraktionsstufen: Die Definition von Anwendungsklassen und die Erzeugung von Anwendungsobjekten zur Laufzeit.
"In der Praxis bewegen Sie sich jedoch vor allem auf Ebene 1: Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen Sie also nur eine Abstraktionsstufe für die Programmierung.",Was sind Anwendungsklassen?,"Anwendungsklassen sind Klassen, die zur Laufzeit des Programms für die Erzeugung von Anwendungsobjekten genutzt werden."
"In der Praxis bewegen Sie sich jedoch vor allem auf Ebene 1: Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen Sie also nur eine Abstraktionsstufe für die Programmierung.",Was sind Anwendungsobjekte?,"Anwendungsobjekte sind Objekte, die zur Laufzeit des Programms aus Anwendungsklassen erzeugt werden."
"In der Praxis bewegen Sie sich jedoch vor allem auf Ebene 1: Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen Sie also nur eine Abstraktionsstufe für die Programmierung.",Auf welcher Abstraktionsstufe programmieren Sie direkt in Smalltalk?,Sie programmieren direkt auf der Ebene der Anwendungsklassen.
"In der Praxis bewegen Sie sich jedoch vor allem auf Ebene 1: Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen Sie also nur eine Abstraktionsstufe für die Programmierung.",Wie viele Abstraktionsstufen werden in der Programmierpraxis hauptsächlich genutzt?,"In der Praxis werden sich Programmierer hauptsächlich auf Ebene 1 bewegen, indem sie Anwendungsklassen definieren, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Das bedeutet, dass nur eine Abstraktionsstufe genutzt wird."
"Die Klasse ""Collection"" ist, wie gesagt, abstrakt. SMALLTALK sieht nun eine ganze Hierarchie von spezielleren, instanziierbaren (konkreten) Collection-Klassen vor, die für die unterschiedlichsten Zwecke eingesetzt werden können. Darunter sind so offensichtliche wie ""Set"" (für ungeordnete Collections, in denen jedes Element höchstens einmal vorkommen darf, also Mengen) und ""Bag"" (für solche, in denen die letzte Einschränkung aufgehoben ist). ""Set"" und ""Bag"" haben (neben der mangelnden Ordnung ihrer Elemente) gemeinsam, dass die Elemente in beiden nicht über einen Index zugreifbar sind. Im Gegensatz dazu stehen geordnete Collections (Klasse ""SequenceableCollection"" oder ""IndexedCollection"", je nach System), in denen das i-te Element eindeutig bestimmt ist und die entsprechend die Methoden ""at:"" und ""at:put:"" implementieren (genaugenommen überschreiben, denn diese Methoden sind ja für alle Objekte, die über indizierte Instanzvariablen verfügen, schon definiert und werden lediglich für ungeordnete Collections wieder gelöscht). Aber auch ungeordnete Collections (in denen keine Reihenfolge festgelegt ist) können indiziert sein: In Objekten der Klasse ""Dictionary"" wird jedes Element unter einem Schlüssel, der selbst wieder ein Objekt sein kann, gespeichert. Die dazugehörigen Methoden heißen wiederum ""at:"" und ""at:put:"", erlauben aber Objekte anderer Klassen als Integer als Indizes.","Was ist die Klasse ""Collection"" in SMALLTALK?","Die Klasse ""Collection"" ist eine abstrakte Klasse in SMALLTALK, die eine Hierarchie von spezielleren, instanziierbaren (konkreten) Collection-Klassen umfasst, die für unterschiedlichste Zwecke eingesetzt werden können. Dazu gehören zum Beispiel ""Set"" für ungeordnete Collections, in denen jedes Element höchstens einmal vorkommen darf, und ""Bag"" für Collections, in denen die letzte Einschränkung aufgehoben ist. ""Set"" und ""Bag"" haben gemeinsam, dass die Elemente in beiden nicht über einen Index zugreifbar sind."
"Die Klasse ""Collection"" ist, wie gesagt, abstrakt. SMALLTALK sieht nun eine ganze Hierarchie von spezielleren, instanziierbaren (konkreten) Collection-Klassen vor, die für die unterschiedlichsten Zwecke eingesetzt werden können. Darunter sind so offensichtliche wie ""Set"" (für ungeordnete Collections, in denen jedes Element höchstens einmal vorkommen darf, also Mengen) und ""Bag"" (für solche, in denen die letzte Einschränkung aufgehoben ist). ""Set"" und ""Bag"" haben (neben der mangelnden Ordnung ihrer Elemente) gemeinsam, dass die Elemente in beiden nicht über einen Index zugreifbar sind. Im Gegensatz dazu stehen geordnete Collections (Klasse ""SequenceableCollection"" oder ""IndexedCollection"", je nach System), in denen das i-te Element eindeutig bestimmt ist und die entsprechend die Methoden ""at:"" und ""at:put:"" implementieren (genaugenommen überschreiben, denn diese Methoden sind ja für alle Objekte, die über indizierte Instanzvariablen verfügen, schon definiert und werden lediglich für ungeordnete Collections wieder gelöscht). Aber auch ungeordnete Collections (in denen keine Reihenfolge festgelegt ist) können indiziert sein: In Objekten der Klasse ""Dictionary"" wird jedes Element unter einem Schlüssel, der selbst wieder ein Objekt sein kann, gespeichert. Die dazugehörigen Methoden heißen wiederum ""at:"" und ""at:put:"", erlauben aber Objekte anderer Klassen als Integer als Indizes.","Was ist der Unterschied zwischen den Klassen ""Set"" und ""Bag"" in Smalltalk?","Die Klasse ""Set"" ist eine ungeordnete Collection, in der jedes Element höchstens einmal vorkommen darf, während die Klasse ""Bag"" eine ungeordnete Collection ist, in der die letzte Einschränkung aufgehoben ist, d.h. in der ein Element mehrfach vorkommen kann."
"Bei allen Bemühungen, für EIFFEL ein möglichst ""wasserdichtes"" Typsystem vorzulegen und dabei so viel wie möglich zur Übersetzungszeit zu erledigen, bleibt es natürlich auch in EIFFEL-Programmen nicht aus, dass man in einen Container (eine Variable oder eine Collection) Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden (einem dynamisch gebundenen Methodenaufruf) überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt.",Wozu können Typprüfungen in EIFFEL notwendig sein?,"Typprüfungen können in EIFFEL notwendig sein, wenn man in einen Container Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt."
"Bei allen Bemühungen, für EIFFEL ein möglichst ""wasserdichtes"" Typsystem vorzulegen und dabei so viel wie möglich zur Übersetzungszeit zu erledigen, bleibt es natürlich auch in EIFFEL-Programmen nicht aus, dass man in einen Container (eine Variable oder eine Collection) Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden (einem dynamisch gebundenen Methodenaufruf) überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt.","Warum ist es manchmal notwendig, den Typ explizit zu prüfen und innerhalb einer Methode zu verzweigen?","Es ist manchmal notwendig, den Typ explizit zu prüfen und innerhalb einer Methode zu verzweigen, wenn man in einen Container (eine Variable oder eine Collection) Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt."
"Solche Typtests werden in EIFFEL von einem sogenannten Zuweisungsversuch (engl. ""assignment attempt"") übernommen, der bei mangelnder (dynamisch festgestellter) Zuweisungskompatibilität einfach ""void"" (das Äquivalent von ""nil"" in SMALLTALK und ""null"" in Java) zuweist.",Was ist ein Zuweisungsversuch in EIFFEL?,"In EIFFEL wird ein Zuweisungsversuch verwendet, um einen Typtest durchzuführen. Wenn die Zuweisungskompatibilität nicht gegeben ist, wird einfach ""void"" zugewiesen."
"Dies ergibt nie einen Typfehler, sondern führt höchstens dazu, dass ""a"" ""void"" zugewiesen wird. Es bleibt dann die Aufgabe der Programmiererin, ""a"" nach der Zuweisung zu kontrollieren. Es entspricht dies direkt dem ""as"" aus C-Sharp, dem ""dynamic_cast<T>(x)"" aus C++ sowie dem Java-Konstrukt.","Was passiert, wenn man einem Objekt eine Nachricht schickt, die nicht zu seinem Typ passt?","Wenn man einem Objekt eine Nachricht schickt, die nicht zu seinem Typ passt, führt dies nicht zu einem Typfehler, sondern höchstens dazu, dass das Objekt ""void"" zugewiesen wird. Die Programmiererin muss dann selbst sicherstellen, dass das Objekt nach der Zuweisung korrekt verwendet wird. Dies entspricht dem ""as"" aus C-Sharp, dem ""dynamic\_cast<T>(x)"" aus C++ sowie dem Java-Konstrukt."
"Dies ergibt nie einen Typfehler, sondern führt höchstens dazu, dass ""a"" ""void"" zugewiesen wird. Es bleibt dann die Aufgabe der Programmiererin, ""a"" nach der Zuweisung zu kontrollieren. Es entspricht dies direkt dem ""as"" aus C-Sharp, dem ""dynamic_cast<T>(x)"" aus C++ sowie dem Java-Konstrukt.","Was passiert, wenn man ein Objekt einer anderen Klasse zuweist?","Wenn man ein Objekt einer anderen Klasse zuweist, wird höchstens dazu führen, dass das Objekt ""void"" zugewiesen wird, und es liegt dann in der Verantwortung der Programmiererin, das Objekt nach der Zuweisung zu überprüfen. Dies entspricht dem ""as"" aus C-Sharp, dem ""dynamic\_cast<T>(x)"" aus C++ und dem Java-Konstrukt."
"Explizite Typumwandlungen gibt es in EIFFEL nicht; sie können also auch keine Laufzeitfehler verursachen. Der Zuweisungsversuch erfüllt aber weitgehend die Funktion einer Typumwandlung, denn er ist nur erfolgreich, wenn die rechte Seite zuweisungskompatibel mit der linken ist, was per Definition nur dann der Fall ist, wenn die rechte Seite ein Objekt eines Subtyps (einschließlich Gleichheit) der linken Seite hat. Es wird hier allerdings die Typumwandlung immer mit einer Zuweisung verbunden; man braucht also unter Umständen eine temporäre Variable, die man sich sonst hätte sparen können. Dass der Zuweisungsversuch in EIFFEL anders als der Downcast in Java keinen Laufzeitfehler verursachen kann, ist wenig tröstlich, denn der Wert ""void"" in einer Variable kann es natürlich schon; in Wirklichkeit wird hier lediglich ein Typumwandlungsfehler gegen eine Nullzeiger-Ausnahme getauscht.",Was ist der Unterschied zwischen dem Zuweisungsversuch in EIFFEL und dem Downcast in Java?,Im Gegensatz zum Zuweisungsversuch in EIFFEL kann der Downcast in Java einen Laufzeitfehler verursachen.
"Explizite Typumwandlungen gibt es in EIFFEL nicht; sie können also auch keine Laufzeitfehler verursachen. Der Zuweisungsversuch erfüllt aber weitgehend die Funktion einer Typumwandlung, denn er ist nur erfolgreich, wenn die rechte Seite zuweisungskompatibel mit der linken ist, was per Definition nur dann der Fall ist, wenn die rechte Seite ein Objekt eines Subtyps (einschließlich Gleichheit) der linken Seite hat. Es wird hier allerdings die Typumwandlung immer mit einer Zuweisung verbunden; man braucht also unter Umständen eine temporäre Variable, die man sich sonst hätte sparen können. Dass der Zuweisungsversuch in EIFFEL anders als der Downcast in Java keinen Laufzeitfehler verursachen kann, ist wenig tröstlich, denn der Wert ""void"" in einer Variable kann es natürlich schon; in Wirklichkeit wird hier lediglich ein Typumwandlungsfehler gegen eine Nullzeiger-Ausnahme getauscht.",Was ist der Unterschied zwischen expliziten Typumwandlungen in EIFFEL und Java?,"In EIFFEL gibt es keine expliziten Typumwandlungen, während es in Java welche gibt. In EIFFEL kann der Zuweisungsversuch die Funktion einer Typumwandlung erfüllen, während er in Java einen Laufzeitfehler verursachen kann. Allerdings kann der Zuweisungsversuch in EIFFEL auch einen Typumwandlungsfehler verursachen, der jedoch als Nullzeiger-Ausnahme behandelt wird."
"Explizite Typumwandlungen gibt es in EIFFEL nicht; sie können also auch keine Laufzeitfehler verursachen. Der Zuweisungsversuch erfüllt aber weitgehend die Funktion einer Typumwandlung, denn er ist nur erfolgreich, wenn die rechte Seite zuweisungskompatibel mit der linken ist, was per Definition nur dann der Fall ist, wenn die rechte Seite ein Objekt eines Subtyps (einschließlich Gleichheit) der linken Seite hat. Es wird hier allerdings die Typumwandlung immer mit einer Zuweisung verbunden; man braucht also unter Umständen eine temporäre Variable, die man sich sonst hätte sparen können. Dass der Zuweisungsversuch in EIFFEL anders als der Downcast in Java keinen Laufzeitfehler verursachen kann, ist wenig tröstlich, denn der Wert ""void"" in einer Variable kann es natürlich schon; in Wirklichkeit wird hier lediglich ein Typumwandlungsfehler gegen eine Nullzeiger-Ausnahme getauscht.",Was ist der Unterschied zwischen Zuweisungskompatibilität und Gleichheit in EIFFEL?,"In EIFFEL sind zwei Typen zuweisungskompatibel, wenn der Zieltyp ein Subtyp des Quelltyps ist, einschließlich der Gleichheit. Das bedeutet, dass der Quelltyp entweder genau dem Zieltyp entspricht oder ein Subtyp des Zieltyps ist. Gleichheit hingegen bedeutet, dass die beiden Typen identisch sind, d.h. der Quelltyp und der Zieltyp sind exakt der gleiche Typ."
"Die Typumwandlung wird in EIFFEL aber auch noch für etwas anderes gebraucht, nämlich für das Binden von Aufrufen kovariant redefinierter Methoden. Da EIFFEL ja, wie oben beschrieben, polymorphe CAT-Calls verbieten muss, diese aber gleichwohl notwendig sein können, hat man nur die Möglichkeit, die dynamische Bindung programmatisch zu emulieren. Und dafür braucht man Zuweisungsversuche.",Wofür wird die Typumwandlung in EIFFEL verwendet?,"In EIFFEL wird die Typumwandlung für das Binden von Aufrufen kovariant redefinierter Methoden verwendet. Da EIFFEL polymorphe CAT-Calls verbieten muss, diese aber gleichwohl notwendig sein können, hat man nur die Möglichkeit, die dynamische Bindung programmatisch zu emulieren. Und dafür braucht man Zuweisungsversuche."
"Die Typumwandlung wird in EIFFEL aber auch noch für etwas anderes gebraucht, nämlich für das Binden von Aufrufen kovariant redefinierter Methoden. Da EIFFEL ja, wie oben beschrieben, polymorphe CAT-Calls verbieten muss, diese aber gleichwohl notwendig sein können, hat man nur die Möglichkeit, die dynamische Bindung programmatisch zu emulieren. Und dafür braucht man Zuweisungsversuche.",Was ist das Binden von Aufrufen kovariant redefinierter Methoden?,"Das Binden von Aufrufen kovariant redefinierter Methoden ist ein Mechanismus in EIFFEL, bei dem die dynamische Bindung von Methodenaufrufen programmatisch emuliert wird, um polymorphe CAT-Calls zu ermöglichen. Dabei werden Zuweisungsversuche verwendet, um die richtige Methode zur Laufzeit zu bestimmen."
"Nun mögen Sie sich vielleicht fragen, warum Typen und Klassen über so viele Seiten hinweg als getrennte Begriffe dargestellt wurden, nur um am Ende zum Schluss zu kommen, dass eine Klassendefinition in der Regel auch als Typdefinition herhält. Nun, erstens ist das nicht in allen Sprachen der Fall, und zweitens ist es selbst in den Sprachen, in denen es so zu sein scheint, nicht immer der Fall (siehe Fußnote 54). Es handelt sich eher um eine Symbiose zweier verschiedener Konzepte, die unterschiedlichen Zwecken dienen, deren strukturelle Ähnlichkeit sich jedoch durch eine syntaktische Zusammenlegung ausnutzen lässt: Klassen dienen der Angabe von Implementierungen und damit als Container für ausführbaren Code. Typen dienen der Formulierung von Invarianten, die für Variablenzuweisungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmfehler hinweist.",Was ist der Unterschied zwischen Typen und Klassen?,"Typen und Klassen sind zwei verschiedene Konzepte, die unterschiedlichen Zwecken dienen. Klassen dienen der Angabe von Implementierungen und damit als Container für ausführbaren Code. Typen dienen der Formulierung von Invarianten, die für Variablenzuweisungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmfehler hinweist. In einigen Sprachen können diese beiden Konzepte jedoch zusammengelegt werden."
"Da beide im Wesentlichen über die gleichen Elemente verfügen, lässt sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied zwischen den beiden Konzepten, Klasse und Typ, manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante abbrechen lässt (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zu identifizierenden Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms, indem sie die Grundlage des dynamischen Bindens bildet und in einem Programm als Eigenschaft von Objekten abgefragt werden kann. In Sprachen, in denen jede Klasse einen Typ definiert, ist diese Unterscheidung jedoch nicht immer klar getroffen und wird deswegen von Programmierern nicht unbedingt wahrgenommen.",Was ist der Unterschied zwischen Klasse und Typ?,"Klasse und Typ sind Konzepte, die sich in der Rolle unterscheiden, die sie zur Laufzeit eines Programms spielen. Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante abbrechen lässt und damit einem anderen, schwieriger zu identifizierenden Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms, indem sie die Grundlage des dynamischen Bindens bildet und in einem Programm als Eigenschaft von Objekten abgefragt werden kann. In Sprachen, in denen jede Klasse einen Typ definiert, ist diese Unterscheidung jedoch nicht immer klar getroffen und wird deswegen von Programmierern nicht unbedingt wahrgenommen."
"Es stellt sich die Frage, wie der Mechanismus der Vererbung genau umgesetzt wird. Eine Möglichkeit wäre z. B., die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Das wäre zwar möglich und würde auch die Semantik der Vererbung korrekt wiedergeben, würde aber das (technische) Problem mit sich bringen, dass bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müssten.",Wie könnte der Mechanismus der Vererbung umgesetzt werden?,"Eine Möglichkeit wäre, die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Das würde die Semantik der Vererbung korrekt wiedergeben, würde aber das Problem mit sich bringen, dass bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müssten."
"Es stellt sich die Frage, wie der Mechanismus der Vererbung genau umgesetzt wird. Eine Möglichkeit wäre z. B., die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Das wäre zwar möglich und würde auch die Semantik der Vererbung korrekt wiedergeben, würde aber das (technische) Problem mit sich bringen, dass bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müssten.","Was wäre eine Möglichkeit, die Vererbung umzusetzen?","Eine Möglichkeit wäre, die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Diese Methode würde die Semantik der Vererbung korrekt wiedergeben, würde aber das Problem mit sich bringen, dass bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müssten."
"Es stellt sich die Frage, wie der Mechanismus der Vererbung genau umgesetzt wird. Eine Möglichkeit wäre z. B., die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Das wäre zwar möglich und würde auch die Semantik der Vererbung korrekt wiedergeben, würde aber das (technische) Problem mit sich bringen, dass bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müssten.",Was ist die Vererbung?,"Die Vererbung ist ein Mechanismus, der es ermöglicht, die Definition einer Klasse (der Superklasse) auf eine andere Klasse (die Subklasse) zu übertragen. Dabei wird die gesamte Definition der Superklasse auf die Subklasse kopiert."
"Es stellt sich die Frage, wie der Mechanismus der Vererbung genau umgesetzt wird. Eine Möglichkeit wäre z. B., die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Das wäre zwar möglich und würde auch die Semantik der Vererbung korrekt wiedergeben, würde aber das (technische) Problem mit sich bringen, dass bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müssten.",Was ist der Zweck der Vererbung?,"Der Zweck der Vererbung ist es, die Definition einer Superklasse auf eine Subklasse zu übertragen, um die Code-Reusability zu erhöhen und die Wartbarkeit des Codes zu verbessern."
"Eine weitere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch je eine Instanz aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Diese Umsetzung der Vererbung steht jedoch im Konflikt mit dem Konzept der Identität von Objekten: Ein Objekt einer Subklasse hätte auf einmal mehrere Identitäten, und zwar eine für sich selbst und eine pro Superklasse, von der sie erbt. Auch das wäre problematisch.","Was ist das Problem an der Umsetzung der Vererbung, bei der für jede Instanz einer Subklasse automatisch je eine Instanz aller ihrer Superklassen erzeugt wird?","Diese Umsetzung der Vererbung steht im Konflikt mit dem Konzept der Identität von Objekten: Ein Objekt einer Subklasse hätte auf einmal mehrere Identitäten, und zwar eine für sich selbst und eine pro Superklasse, von der sie erbt."
"Eine weitere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch je eine Instanz aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Diese Umsetzung der Vererbung steht jedoch im Konflikt mit dem Konzept der Identität von Objekten: Ein Objekt einer Subklasse hätte auf einmal mehrere Identitäten, und zwar eine für sich selbst und eine pro Superklasse, von der sie erbt. Auch das wäre problematisch.",Was ist das Problem bei der Erzeugung einer Instanz einer Subklasse und gleichzeitig einer Instanz jeder Superklasse?,"Das Problem ist, dass ein Objekt einer Subklasse auf einmal mehrere Identitäten hätte, und zwar eine für sich selbst und eine pro Superklasse, von der es erbt. Das würde dem Konzept der Identität von Objekten widersprechen."
"Eine weitere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch je eine Instanz aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Diese Umsetzung der Vererbung steht jedoch im Konflikt mit dem Konzept der Identität von Objekten: Ein Objekt einer Subklasse hätte auf einmal mehrere Identitäten, und zwar eine für sich selbst und eine pro Superklasse, von der sie erbt. Auch das wäre problematisch.","Was wäre problematisch, wenn jede Instanz einer Subklasse automatisch je eine Instanz aller ihrer Superklassen erzeugen würde?","Das wäre problematisch, weil ein Objekt einer Subklasse auf einmal mehrere Identitäten hätte, und zwar eine für sich selbst und eine pro Superklasse, von der sie erbt. Das Konzept der Identität von Objekten würde verletzt werden."
"Stattdessen wird die Vererbung in SMALLTALK und vielen anderen objektorientierten Programmiersprachen als ein Teilen der Klassendefinitionen realisiert: Vereinbarungen, die in einer Klasse getroffen wurden, gelten automatisch auch für alle Subklassen, es sei denn, diese spezifizieren etwas anderes. Dabei werden die Vereinbarungen nicht übertragen (wie per Kopieren und Einfügen), sondern einfach nur gemeinsam genutzt.",Wie wird Vererbung in SMALLTALK realisiert?,"In SMALLTALK und vielen anderen objektorientierten Programmiersprachen wird Vererbung als ein Teilen der Klassendefinitionen realisiert, bei dem Vereinbarungen, die in einer Klasse getroffen wurden, automatisch auch für alle Subklassen gelten, es sei denn, diese spezifizieren etwas anderes. Die Vereinbarungen werden nicht übertragen, sondern einfach nur gemeinsam genutzt."
"Eine Sonderrolle unter den Beziehungen nimmt die sogenannte Teil-Ganzes-Beziehung ein, die je nach Kontext und Jargon auch als Komposition oder Aggregation bezeichnet wird. Teil-Ganzes-Beziehungen bestimmen ganz wesentlich unsere Weltsicht: Alles, was wir anfassen oder betrachten können, ist aus kleineren Teilen zusammengesetzt, die selbst wieder Zusammensetzungen (Aggregate, Komposita) sind, bis hinunter zu den elementaren, unteilbaren Bausteinen.",Was ist die Teil-Ganzes-Beziehung?,"Die Teil-Ganzes-Beziehung bestimmt die Weltansicht, dass alles aus kleineren Teilen zusammengesetzt ist, die selbst wieder Zusammensetzungen (Aggregate, Komposita) sind, bis hinunter zu den elementaren, unteilbaren Bausteinen."
"Leider ist der Begriff der Teil-Ganzes-Beziehung nicht so klar definiert, wie es auf den ersten Blick scheint. Tatsächlich bestehen, je nach Art der Zusammensetzung, zum Teil völlig unterschiedliche Wechselwirkungen zwischen dem Ganzen und seinen Teilen. Zudem gibt es neben der physischen Teil-Ganzes-Beziehung auch eine logische: So ist zum Beispiel der Deutsche Bundestag aus einer Anzahl von Abgeordneten zusammengesetzt, und jede Familie besteht aus ihren Mitgliedern. Tatsächlich gibt es so viele Varianten der Teil-Ganzes-Beziehung, dass der philosophische Diskurs darüber ganze Regale füllt und zu einer eigenen Disziplin geführt hat (die sogenannte Mereologie). Verständlicherweise kann dem eine Programmiersprache nicht folgen und für jede dieser Beziehungen ein eigenes Sprachkonstrukt anbieten.",Warum ist die Teil-Ganzes-Beziehung komplixiert?,"Die Definition der Teil-Ganzes-Beziehung ist komplex, da es verschiedene Arten von Beziehungen zwischen einem Ganzen und seinen Teilen gibt, die je nach Art der Zusammensetzung unterschiedliche Wechselwirkungen aufweisen. Es existieren sowohl physische als auch logische Teil-Ganzes-Beziehungen, und diese Vielfalt macht es schwer, eine klare und einheitliche Definition zu finden."
"Stattdessen bieten die meisten (objektorientierten) Programmiersprachen leider überhaupt kein Sprachkonstrukt an, das speziell für die Teil-Ganzes-Beziehung gedacht wäre. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden: Bei Wertsemantik wird mit der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt. Hier kann man tatsächlich von der Umsetzung einer bestimmten Form von Teil-Ganzes-Beziehung sprechen, nämlich einer solchen, bei der die Existenz der Teile von der Existenz des Ganzen abhängt (in der UML auch Komposition genannt). Für andere Formen, wie zum Beispiel die Bildung einer Gruppe von Objekten als Objekt mit eigener Identität (zum Beispiel ein Verein), ist dieses Modell jedoch nicht geeignet, da sonst mit der Auflösung der Gruppe auch die Gruppenmitglieder verschwinden würden. Für die SMALLTALK-Programmiererin sind diese Überlegungen jedoch kein Thema, denn sie hat die Wahl, diese spezielle Beziehung zu modellieren oder nicht. Die Möglichkeit des (rekursiven) Aufbaus eines Software-Systems aus Teilen, die jeweils ihren inneren Aufbau (ihre Komposition) kapseln und insbesondere die Nichtexistenz von Aliases auf ihre Teile garantieren, ist genau das, was der objektorientierten Programmierung im Wesentlichen bis heute fehlt.",Was bieten objektorientierte Programmiersprachen für die Teil-Ganzes-Beziehung?,"Die meisten objektorientierten Programmiersprachen bieten keine speziellen Sprachkonstrukte für die Teil-Ganzes-Beziehung. Stattdessen können Programmierer die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik nutzen, um eine bestimmte Form der Teil-Ganzes-Beziehung darzustellen. Bei Wertsemantik werden beim Entfernen eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt."
"Stattdessen bieten die meisten (objektorientierten) Programmiersprachen leider überhaupt kein Sprachkonstrukt an, das speziell für die Teil-Ganzes-Beziehung gedacht wäre. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden: Bei Wertsemantik wird mit der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt. Hier kann man tatsächlich von der Umsetzung einer bestimmten Form von Teil-Ganzes-Beziehung sprechen, nämlich einer solchen, bei der die Existenz der Teile von der Existenz des Ganzen abhängt (in der UML auch Komposition genannt). Für andere Formen, wie zum Beispiel die Bildung einer Gruppe von Objekten als Objekt mit eigener Identität (zum Beispiel ein Verein), ist dieses Modell jedoch nicht geeignet, da sonst mit der Auflösung der Gruppe auch die Gruppenmitglieder verschwinden würden. Für die SMALLTALK-Programmiererin sind diese Überlegungen jedoch kein Thema, denn sie hat die Wahl, diese spezielle Beziehung zu modellieren oder nicht. Die Möglichkeit des (rekursiven) Aufbaus eines Software-Systems aus Teilen, die jeweils ihren inneren Aufbau (ihre Komposition) kapseln und insbesondere die Nichtexistenz von Aliases auf ihre Teile garantieren, ist genau das, was der objektorientierten Programmierung im Wesentlichen bis heute fehlt.",Warum ist die Teil-Ganzes-Beziehung in der objektorientierten Programmierung von Bedeutung?,"Die Teil-Ganzes-Beziehung ist in der objektorientierten Programmierung wichtig, da sie es ermöglicht, komplexe Software-Systeme aus Teilen aufzubauen, wobei jeder Teil seine eigene interne Struktur kapselt. Dies hilft dabei, sicherzustellen, dass keine Aliasnamen für Teile existieren und Änderungen an einem Teil nicht unabsichtlich andere Teile beeinflussen. Dieses Konzept ist entscheidend für die Entwicklung komplexer und intakter Software-Systeme."
"Wie auch in Java definiert jede unparametrisierte Klasse in EIFFEL einen Typ, und jede parametrisierte Klasse eine (generische) Menge von Typen. Alle Variablen (einschließlich Methoden und deren Parameter) müssen einen Typ haben. Die Zuweisungskompatibilität ist an nominale Typkonformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung genannt) einhergeht, ganz wie in Java. Anders als in Java ist es jedoch zulässig, Instanzvariablen und Funktionsparameter wie im obigen Beispiel kovariant zu redefinieren. Von kontravarianter Redefinition will MEYER nichts wissen (eine Begründung sollten Sie mittlerweile selbst zur Verfügung haben). Das bedeutet jedoch mangelnde Substituierbarkeit und bereitet EIFFEL erwartungsgemäß einige nicht triviale Probleme.",Was ist nominale Typkonformität in EIFFEL?,"In EIFFEL ist nominale Typkonformität die Zuweisungskompatibilität, die mit der Typerweiterung (Vererbung) einhergeht. Das bedeutet, dass eine Unterklasse mit einer Oberklasse kompatibel ist und eine Variable der Oberklasse mit einem Objekt der Unterklasse zugewiesen werden kann."
"Wie auch in Java definiert jede unparametrisierte Klasse in EIFFEL einen Typ, und jede parametrisierte Klasse eine (generische) Menge von Typen. Alle Variablen (einschließlich Methoden und deren Parameter) müssen einen Typ haben. Die Zuweisungskompatibilität ist an nominale Typkonformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung genannt) einhergeht, ganz wie in Java. Anders als in Java ist es jedoch zulässig, Instanzvariablen und Funktionsparameter wie im obigen Beispiel kovariant zu redefinieren. Von kontravarianter Redefinition will MEYER nichts wissen (eine Begründung sollten Sie mittlerweile selbst zur Verfügung haben). Das bedeutet jedoch mangelnde Substituierbarkeit und bereitet EIFFEL erwartungsgemäß einige nicht triviale Probleme.",Wie ist die Zuweisungskompatibilität in EIFFEL gebunden?,"Die Zuweisungskompatibilität ist in EIFFEL an nominale Typkonformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung genannt) einhergeht, ganz wie in Java."
"Zunächst einmal wollen wir uns das Typsystem von EIFFEL noch genauer ansehen. Es basiert, wie in der objektorientierten Programmierung üblich, auf dem Begriff der Typkonformität (Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ U typkonform zu einem Typ T: Wenn U und T gleich sind, Wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder Wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist (U ist eine indirekte Erweiterung von T).",Auf welcher Basis beruht das Typsystem von EIFFEL?,Das Typsystem von EIFFEL basiert auf dem Begriff der Typkonformität.
"Zunächst einmal wollen wir uns das Typsystem von EIFFEL noch genauer ansehen. Es basiert, wie in der objektorientierten Programmierung üblich, auf dem Begriff der Typkonformität (Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ U typkonform zu einem Typ T: Wenn U und T gleich sind, Wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder Wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist (U ist eine indirekte Erweiterung von T).","Was bedeutet es, wenn ein Typ U in EIFFEL typkonform zu einem Typ T ist?","U ist typkonform zu T, wenn U und T gleich sind, wenn U eine direkte Erweiterung von T ist und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist."
"Zunächst einmal wollen wir uns das Typsystem von EIFFEL noch genauer ansehen. Es basiert, wie in der objektorientierten Programmierung üblich, auf dem Begriff der Typkonformität (Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ U typkonform zu einem Typ T: Wenn U und T gleich sind, Wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder Wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist (U ist eine indirekte Erweiterung von T).",Was ist der Unterschied zwischen direkter und indirekter Erweiterung in EIFFEL?,"Eine direkte Erweiterung bedeutet, dass U direkt von T erbt, während eine indirekte Erweiterung bedeutet, dass es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist."
"Außerdem gibt es in EIFFEL noch einen Typkonstruktor like <ein Ausdruck>, dessen erzeugter Typ typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der Basistyp konform, keiner seiner Subtypen.",Was ist der Typkonstruktor like <ein Ausdruck> in EIFFEL?,"Der Typkonstruktor like <ein Ausdruck> in EIFFEL erzeugt einen Typ, der typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der Basistyp konform, keiner seiner Subtypen."
EIFFEL benutzt also eckige Klammern und einem Pfeil (->) anstelle von spitzen Klammern und extends in Java.,Wie werden Methoden in EIFFEL aufgerufen?,In EIFFEL werden Methoden mit eckigen Klammern und einem Pfeil (->) aufgerufen.
EIFFEL benutzt also eckige Klammern und einem Pfeil (->) anstelle von spitzen Klammern und extends in Java.,Wie werden in EIFFEL Vererbungsbeziehungen ausgedrückt?,In EIFFEL werden Vererbungsbeziehungen durch eckige Klammern und einem Pfeil (->) anstelle von spitzen Klammern und extends in Java ausgedrückt.
EIFFEL benutzt also eckige Klammern und einem Pfeil (->) anstelle von spitzen Klammern und extends in Java.,Was ist der Unterschied zwischen EIFFEL und Java in Bezug auf die Syntax für Vererbung?,"In EIFFEL wird Vererbung durch eckige Klammern und Pfeil (->) dargestellt, während in Java spitze Klammern und extends verwendet werden."
"In EIFFEL wird übrigens anders als in C-Sharp nicht pro Typkonstruktor zwischen Wert- und Referenztypen unterschieden. Zu jedem Typ kann es (ähnlich wie in C++) beide Formen geben. Dazu gibt es in EIFFEL die Möglichkeit, bei einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik, also ein Objekt anstelle einer Referenz auf ein Objekt zum Inhalt haben sollen. Dies ist manchmal für alle Variablen eines Typs sinnvoll, z. B. bei Zahlen und Wahrheitswerten, manchmal aber auch nur für manche. So gibt es in EIFFEL einen Typkonstruktor expanded, der einer einzelnen Variable Wertsemantik gibt und in Klassendefinitionen allen Variablen des entsprechenden Typs automatisch Wertsemantik gibt. EIFFELs Typkonstruktor expanded entspricht also gewissermaßen einer Umkehrung des in PASCAL-artigen Sprachen verwendeten Typkonstruktors ^ (Zeiger auf). Die Unterscheidung von Wert- und Referenztypen einer Klasse hat in EIFFEL einen starken konzeptuellen Hintergrund, da sie die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen (vgl. dazu auch Kapitel 59 in Kurseinheit 6).",Wie wird in EIFFEL die Unterscheidung zwischen Wert- und Referenztypen einer Klasse umgesetzt?,"In EIFFEL wird die Unterscheidung zwischen Wert- und Referenztypen einer Klasse durch den Typkonstruktor expanded umgesetzt. Dieser gibt einer einzelnen Variable Wertsemantik und in Klassendefinitionen allen Variablen des entsprechenden Typs automatisch Wertsemantik. Diese Unterscheidung hat in EIFFEL einen starken konzeptuellen Hintergrund, da sie die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen."
"In EIFFEL wird übrigens anders als in C-Sharp nicht pro Typkonstruktor zwischen Wert- und Referenztypen unterschieden. Zu jedem Typ kann es (ähnlich wie in C++) beide Formen geben. Dazu gibt es in EIFFEL die Möglichkeit, bei einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik, also ein Objekt anstelle einer Referenz auf ein Objekt zum Inhalt haben sollen. Dies ist manchmal für alle Variablen eines Typs sinnvoll, z. B. bei Zahlen und Wahrheitswerten, manchmal aber auch nur für manche. So gibt es in EIFFEL einen Typkonstruktor expanded, der einer einzelnen Variable Wertsemantik gibt und in Klassendefinitionen allen Variablen des entsprechenden Typs automatisch Wertsemantik gibt. EIFFELs Typkonstruktor expanded entspricht also gewissermaßen einer Umkehrung des in PASCAL-artigen Sprachen verwendeten Typkonstruktors ^ (Zeiger auf). Die Unterscheidung von Wert- und Referenztypen einer Klasse hat in EIFFEL einen starken konzeptuellen Hintergrund, da sie die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen (vgl. dazu auch Kapitel 59 in Kurseinheit 6).",Was ist der Unterschied zwischen Wert- und Referenztypen in EIFFEL?,"In EIFFEL gibt es die Möglichkeit, bei einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik haben sollen, was bedeutet, dass sie ein Objekt anstelle einer Referenz auf ein Objekt zum Inhalt haben. Dies ist manchmal für alle Variablen eines Typs sinnvoll, z.B. bei Zahlen und Wahrheitswerten, manchmal aber auch nur für manche. Der Unterschied von Wert- und Referenztypen hat in EIFFEL einen starken konzeptuellen Hintergrund, da er die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen."
"Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer Typkonstruktoren für entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) zu haben. Dieses Feature ist nicht in C-Sharp (zumindest nicht im Safe mode) verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen. In C++ (und im Unsafe mode von C-Sharp) kann man es simulieren, zahlt jedoch den Preis, mit expliziten Pointern umgehen zu müssen.",Was ist der Unterschied zwischen expanded Variablen und normalen Variablen in EIFFEL?,"In EIFFEL können Instanzen einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) haben. Expanded Variablen sind Komponentenobjekte, während normale Variablen freie Objekte sind. Dieses Feature ist in C-Sharp (zumindest nicht im Safe mode) nicht verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen."
"Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer Typkonstruktoren für entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) zu haben. Dieses Feature ist nicht in C-Sharp (zumindest nicht im Safe mode) verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen. In C++ (und im Unsafe mode von C-Sharp) kann man es simulieren, zahlt jedoch den Preis, mit expliziten Pointern umgehen zu müssen.",Was ist der Unterschied zwischen Komponentenobjekten und freien Objekten in EIFFEL?,"In EIFFEL können Instanzen einer Klasse fallweise Komponentenobjekte und freie Objekte haben. Komponentenobjekte werden über expanded Variablen definiert und sind in anderen Objekten enthalten, während freie Objekte über normale Variablen definiert werden und nirgends enthalten sind."
"Nun stand bereits in Kurseinheit 1, Abschnitt 1.6 zu lesen, dass bei der Zuweisung zwischen zwei Variablen mit Wertsemantik der Wert der einen Variable in die andere Variable kopiert wird, während bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik lediglich der Zeiger kopiert wird. Dies ist auch in EIFFEL so. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte. Stattdessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert). Im umgekehrten Fall, also wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt, und eine Referenz auf diesen Klon wird übergeben.",Was passiert bei der Zuweisung zwischen zwei Variablen mit unterschiedlicher Semantik?,"Wenn eine Variable mit Referenzsemantik an eine Variable mit Wertsemantik zugewiesen wird, wird das Objekt, auf das der Zeiger verweist, kopiert. Wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt und eine Referenz auf diesen Klon wird übergeben."
"Nun stand bereits in Kurseinheit 1, Abschnitt 1.6 zu lesen, dass bei der Zuweisung zwischen zwei Variablen mit Wertsemantik der Wert der einen Variable in die andere Variable kopiert wird, während bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik lediglich der Zeiger kopiert wird. Dies ist auch in EIFFEL so. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte. Stattdessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert). Im umgekehrten Fall, also wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt, und eine Referenz auf diesen Klon wird übergeben.",Was passiert bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik?,"Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik wird das Objekt, auf das der Zeiger verweist, kopiert. Genauer: die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert."
"Eine solche Verankerung bewirkt, dass sich der Typ von x automatisch mit dem von y verändert. Dies hat zunächst noch nichts mit Kovarianz zu tun. Da die Typen der Parameter von setF und getF alle per Deklaration dieselben sind wie der Typ von f, muss in der Definition von B textuell nichts anderes stehen. Da nun aber in EIFFEL die Redefinition von Instanzvariablen per Definition immer kovariant sein muss, muss Y ein Subtyp von X sein. Der Rückgabetyp von getF und der Parametertyp von setF ändern sich damit automatisch ebenfalls kovariant.",Was bedeutet kovarianter Rückgabetyp und kovarianter Parametertyp?,"Wenn eine Unterklasse eine Instanzvariable oder eine Methode redefiniert, dann muss der Typ der Instanzvariable oder der Rückgabetyp der Methode in der Unterklasse ein Subtyp des Typs in der Oberklasse sein. Dies wird als kovarianter Typ bezeichnet. Wenn der Parametertyp einer Methode in der Unterklasse ein Subtyp des Parametertyps in der Oberklasse ist, dann wird dies als kovarianter Parametertyp bezeichnet."
"Ein besonderer Fall von verankerten Typen ergibt sich bei rekursiven Typen, also Typen, deren Definition den definierten Typ selbst referenziert. In diesem Fall schreibt man in EIFFEL anstelle der Typreferenz bei der Deklaration einer Variable vom zu definierenden Typ like Current. Bei einem entsprechend deklarierten Feld ändert sich der Typ bei der Vererbung also immer automatisch zum erbenden Typ hin, also immer mit dem Typ und damit kovariant. Für das Beispiel der zu trennenden Skifahrerinnen (Zeilen 1391–1425) ergibt sich damit. Die beiden erbenden Klassen GIRL und BOY müssen dann nichts mehr redefinieren.Wir können nun zur Lösung des Problems der Kovarianz in EIFFEL kommen. Die obige Konstruktion (hier unverändert wiederholt) wird dann vom Type checker zur Übersetzungszeit zurückgewiesen, da g1 nicht vom Typ like s1 ist, was aber laut den Typkonformitätsregeln von EIFFEL notwendig wäre. Leider ist das nur ein Teilerfolg.",Was ist das Problem der Kovarianz in EIFFEL?,"Das Problem der Kovarianz in EIFFEL tritt auf, wenn eine Konstruktion vom Type checker zur Übersetzungszeit zurückgewiesen wird, weil der Typ des Objekts nicht mit den Typkonformitätsregeln übereinstimmt."
"Ein besonderer Fall von verankerten Typen ergibt sich bei rekursiven Typen, also Typen, deren Definition den definierten Typ selbst referenziert. In diesem Fall schreibt man in EIFFEL anstelle der Typreferenz bei der Deklaration einer Variable vom zu definierenden Typ like Current. Bei einem entsprechend deklarierten Feld ändert sich der Typ bei der Vererbung also immer automatisch zum erbenden Typ hin, also immer mit dem Typ und damit kovariant. Für das Beispiel der zu trennenden Skifahrerinnen (Zeilen 1391–1425) ergibt sich damit. Die beiden erbenden Klassen GIRL und BOY müssen dann nichts mehr redefinieren.Wir können nun zur Lösung des Problems der Kovarianz in EIFFEL kommen. Die obige Konstruktion (hier unverändert wiederholt) wird dann vom Type checker zur Übersetzungszeit zurückgewiesen, da g1 nicht vom Typ like s1 ist, was aber laut den Typkonformitätsregeln von EIFFEL notwendig wäre. Leider ist das nur ein Teilerfolg.",Wie kann das Problem der Kovarianz in EIFFEL gelöst werden?,"Eine Lösung für das Problem der Kovarianz kann sein, die Typkonformitätsregeln von EIFFEL zu ändern, um die Kovarianz zu ermöglichen."
"Die erste und einfachste Möglichkeit, dies zu verhindern, wäre, die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einzuschränken und unter ihnen nur noch Typäquivalenz zu akzeptieren. Es wären dann nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit solchen, die ihn als Anker benutzen, erlaubt. Insbesondere wäre eine Zuweisung wie s1 := g1 (die ja notwendig war, um ein Objekt vom Typ GIRL so zu „verpacken“, dass es an g2 mit seinem verankerten Typ like s1 zugewiesen werden kann) damit nicht mehr möglich. Alle anderen Zuweisungen wären natürlich weiterhin zugelassen. Dies hätte jedoch zur Konsequenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem wäre es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll.","Was wäre eine Möglichkeit, Zuweisungskompatibilität für Variablen mit verankerten Typen einzuschränken?","Eine Möglichkeit wäre, Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs nur noch mit solchen zu erlauben, die ihn als Anker benutzen. Dadurch würden geschlossene Zirkel entstehen, aus denen kein Objekt hinaus und in die keines hinein käme. Diese Methode hätte jedoch den Nachteil, dass es für die Programmiererin schwer wäre, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll."
"Die erste und einfachste Möglichkeit, dies zu verhindern, wäre, die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einzuschränken und unter ihnen nur noch Typäquivalenz zu akzeptieren. Es wären dann nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit solchen, die ihn als Anker benutzen, erlaubt. Insbesondere wäre eine Zuweisung wie s1 := g1 (die ja notwendig war, um ein Objekt vom Typ GIRL so zu „verpacken“, dass es an g2 mit seinem verankerten Typ like s1 zugewiesen werden kann) damit nicht mehr möglich. Alle anderen Zuweisungen wären natürlich weiterhin zugelassen. Dies hätte jedoch zur Konsequenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem wäre es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll.","Was würde passieren, wenn man die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einschränken würde?","Wenn man die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einschränken würde, wären nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit solchen, die ihn als Anker benutzen, erlaubt. Das hätte zur Konsequenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem wäre es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll."
"Die zweite Möglichkeit wäre, eine Typinferenz für das gesamte Programm durchzuführen, um die möglichen Zuweisungen an Variablen zu sammeln. Dazu sind insbesondere alle Methodenaufrufe anzusehen. Diese können je nach Konfiguration des endgültigen Systems sehr unterschiedlich ausfallen. Eine solche Typinferenz ist jedoch in den meisten Fällen unrealistisch.",Warum ist eine Typinferenz für das gesamte Programm in den meisten Fällen unrealistisch?,"Eine Typinferenz für das gesamte Programm ist unrealistisch, da sie alle Methodenaufrufe im System berücksichtigen muss, die je nach Konfiguration sehr unterschiedlich ausfallen können. Zudem ist sie sehr aufwendig und erfordert eine komplexe Algorithmik."
"Die dritte Möglichkeit ist die, alle dynamisch gebundenen Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“) ändern (die von MEYER so genannten CAT-Calls, wobei CAT für „Change Availability or Type“ steht), zu verbieten. Ein Aufruf von share auf s1 wie oben ist damit verboten, weil share in BOY und GIRL kovariant redefiniert wird. Auf einer Variable vom Typ GIRL oder BOY wäre er hingegen zulässig, solange sichergestellt ist, dass diese Variable keinen Wert von einem Subtyp von GIRL bzw. BOY zugewiesen bekommen kann. Das ist möglich, wenn kein solcher Subtyp existiert oder wenn keine Zuweisung an die Variable existiert, bei der die rechte Seite ein Subtyp der Variable ist. Das erste ist lokal nicht nachzuweisen, das zweite hingegen schon, jedoch nur für explizite Zuweisungen (inklusive der Instanziierung, die in EIFFEL auf einer Variable durchgeführt wird und ihr automatisch einen Wert gibt). Für die Zuweisung an formale Parameter kann dies jedoch nicht lokal nachgewiesen werden, weil im Gegensatz zu expliziten Zuweisungen an Variablen die Methodenaufrufe von überall her erfolgen können.",Was sind CAT-Calls in Eiffel?,"CAT-Calls (Change Availability or Type Calls) sind dynamisch gebundene Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen ändern können. Ein Beispiel für einen CAT-Call ist der Aufruf von share auf s1 wie oben, der verboten ist, weil share in BOY und GIRL kovariant redefiniert wird."
"Die dritte Möglichkeit ist die, alle dynamisch gebundenen Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“) ändern (die von MEYER so genannten CAT-Calls, wobei CAT für „Change Availability or Type“ steht), zu verbieten. Ein Aufruf von share auf s1 wie oben ist damit verboten, weil share in BOY und GIRL kovariant redefiniert wird. Auf einer Variable vom Typ GIRL oder BOY wäre er hingegen zulässig, solange sichergestellt ist, dass diese Variable keinen Wert von einem Subtyp von GIRL bzw. BOY zugewiesen bekommen kann. Das ist möglich, wenn kein solcher Subtyp existiert oder wenn keine Zuweisung an die Variable existiert, bei der die rechte Seite ein Subtyp der Variable ist. Das erste ist lokal nicht nachzuweisen, das zweite hingegen schon, jedoch nur für explizite Zuweisungen (inklusive der Instanziierung, die in EIFFEL auf einer Variable durchgeführt wird und ihr automatisch einen Wert gibt). Für die Zuweisung an formale Parameter kann dies jedoch nicht lokal nachgewiesen werden, weil im Gegensatz zu expliziten Zuweisungen an Variablen die Methodenaufrufe von überall her erfolgen können.","Was für Möglichkeiten gibt es in EIFFEL, dynamisch gebundene Aufrufe von Methoden zu behandeln?","Die drei Möglichkeiten sind: 1) Alle dynamisch gebundenen Aufrufe von Methoden zuzulassen, 2) Alle dynamisch gebundenen Aufrufe von Methoden zu verbieten, die in überschriebenen Versionen („Redefinitionen“) verfügbar oder deren Parametertypen sich ändern und 3) Alle dynamisch gebundenen Aufrufe von Methoden zu verbieten, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“) ändern (die von MEYER so genannten CAT-Calls). Die erste Möglichkeit erlaubt alle dynamisch gebundenen Aufrufe von Methoden, die zweite verbietet alle und die dritte verbietet nur die, die in überschriebenen Versionen („Redefinitionen“) verfügbar oder deren Parametertypen sich ändern."
"Wie Sie sehen, sind die Bedingungen ziemlich restriktiv, und man kommt nicht umhin, das Typsystem von EIFFEL als etwas eigenartig zu empfinden. Wie es sich in der Praxis auswirkt, ist mir leider nicht bekannt; MEYER behauptet, dass die Probleme praktisch keine Rolle spielen. Ich möchte hinzufügen, dass falls doch, die durchschnittliche Programmiererin kaum verstehen wird, was denn nun genau das Problem ist und was sie tun kann, es zu umgehen.",Wie wirkt sich das Typsystem von EIFFEL in der Praxis aus?,"Der Autor des Textes ist nicht sicher, wie sich das Typsystem von EIFFEL in der Praxis auswirkt, da er keine praktischen Erfahrungen damit hat. Er weist jedoch darauf hin, dass der Schöpfer von EIFFEL, Bertrand Meyer, behauptet, dass die damit verbundenen Probleme praktisch keine Rolle spielen. Der Autor fügt hinzu, dass falls doch, die durchschnittliche Programmiererin kaum verstehen wird, was das Problem ist und was sie tun kann, um es zu umgehen."
"Wie Sie sehen, sind die Bedingungen ziemlich restriktiv, und man kommt nicht umhin, das Typsystem von EIFFEL als etwas eigenartig zu empfinden. Wie es sich in der Praxis auswirkt, ist mir leider nicht bekannt; MEYER behauptet, dass die Probleme praktisch keine Rolle spielen. Ich möchte hinzufügen, dass falls doch, die durchschnittliche Programmiererin kaum verstehen wird, was denn nun genau das Problem ist und was sie tun kann, es zu umgehen.",Was kann man über das Typsystem von EIFFEL sagen?,"Das Typsystem von EIFFEL ist ziemlich restriktiv und wird von einigen als eigenartig empfunden. Obwohl die Probleme in der Praxis laut MEYER kaum eine Rolle spielen, ist es möglich, dass sie auftreten. Wenn dies der Fall ist, versteht die durchschnittliche Programmiererin wahrscheinlich nicht, was das Problem ist und was sie tun kann, um es zu umgehen."
"Modul und Interface sind eigentlich ein Begriffspaar — das eine lässt sich nur mithilfe des anderen definieren. Die Interfaces in Java sind jedoch durchaus eigenständige Konstrukte, die inzwischen weit über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle zu definieren, hinausgehen. Auch wenn Javas Interfaces Vorgänger haben, betrachte ich sie doch als einen von Javas wichtigsten Beiträgen für die Entwicklung objektorientierter Programmiersprachen.",Was sind Interfaces in Java?,"Interfaces in Java sind eigenständige Konstrukte, die über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle zu definieren, hinausgehen. Sie sind ein wichtiger Beitrag von Java zur Entwicklung objektorientierter Programmiersprachen."
"Modul und Interface sind eigentlich ein Begriffspaar — das eine lässt sich nur mithilfe des anderen definieren. Die Interfaces in Java sind jedoch durchaus eigenständige Konstrukte, die inzwischen weit über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle zu definieren, hinausgehen. Auch wenn Javas Interfaces Vorgänger haben, betrachte ich sie doch als einen von Javas wichtigsten Beiträgen für die Entwicklung objektorientierter Programmiersprachen.",Was ist der Unterschied zwischen Modul und Interface?,"Modul und Interface sind eigentlich ein Begriffspaar, das sich nur mithilfe des anderen definieren lässt. Interfaces in Java sind jedoch eigenständige Konstrukte, die über die eigentliche Bedeutung des Begriffs hinausgehen."
"Modul und Interface sind eigentlich ein Begriffspaar — das eine lässt sich nur mithilfe des anderen definieren. Die Interfaces in Java sind jedoch durchaus eigenständige Konstrukte, die inzwischen weit über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle zu definieren, hinausgehen. Auch wenn Javas Interfaces Vorgänger haben, betrachte ich sie doch als einen von Javas wichtigsten Beiträgen für die Entwicklung objektorientierter Programmiersprachen.",Warum sind Interfaces in Java wichtig?,"Interfaces in Java sind wichtig, weil sie über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle zu definieren, hinausgehen und ein wichtiger Beitrag von Java zur Entwicklung objektorientierter Programmiersprachen sind."
"Ähnlich wie bei der Klassifikation kann man das Prinzip der Generalisierung umkehren. Man spricht dann von der Spezialisierung. Während die Generalisierung Eigenschaften weglässt oder generalisiert (Abstraktion), fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene. Man kann also von jeder Klasse sagen, dass sie eine Spezialisierung ihrer Generalisierungen ist (sofern sie welche hat).",Was ist Spezialisierung?,"Spezialisierung ist das Prinzip, bei dem Eigenschaften hinzugefügt oder bereits vorhandene spezialisiert werden, im Gegensatz zur Generalisierung, bei der Eigenschaften weggelassen oder generalisiert werden. Jede Klasse ist eine Spezialisierung ihrer Generalisierungen, sofern sie welche hat."
"Ähnlich wie bei der Klassifikation kann man das Prinzip der Generalisierung umkehren. Man spricht dann von der Spezialisierung. Während die Generalisierung Eigenschaften weglässt oder generalisiert (Abstraktion), fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene. Man kann also von jeder Klasse sagen, dass sie eine Spezialisierung ihrer Generalisierungen ist (sofern sie welche hat).",Was ist Spezialisierung in der objektorientierten Programmierung?,"Spezialisierung ist ein Prinzip in der objektorientierten Programmierung, bei dem Eigenschaften hinzugefügt oder bereits vorhandene spezialisiert werden, um eine Unterklasse zu erstellen, die eine spezifischere Version der Oberklasse darstellt. Jede Klasse ist eine Spezialisierung ihrer Generalisierungen (sofern sie welche hat)."
"Dass eine Generalisierung bereits über Spezialisierungen verfügt, hindert eine Klasse nicht daran, neue hinzuzufügen. So ist es beispielsweise im obigen Beispiel von ""Zweibeiner"" denkbar, dass man im Nachhinein noch ""Menschenaffe"" als Spezialisierung ergänzt. Als Unterscheidungsmerkmal könnte z. B. eine Methode ""klettern"" dienen, die Mensch und Vogel fehlt. Sie zu ergänzen stellt überhaupt kein Problem dar - ja, es ist sogar eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind. Mehr dazu in Kapitel 26 in Kurseinheit 3.","Kann eine Klasse neue Spezialisierungen hinzufügen, wenn sie bereits Generalisierungen besitzt?","Ja, eine Klasse kann neue Spezialisierungen hinzufügen, auch wenn sie bereits Generalisierungen besitzt. Das ist eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind."
"Dass eine Generalisierung bereits über Spezialisierungen verfügt, hindert eine Klasse nicht daran, neue hinzuzufügen. So ist es beispielsweise im obigen Beispiel von ""Zweibeiner"" denkbar, dass man im Nachhinein noch ""Menschenaffe"" als Spezialisierung ergänzt. Als Unterscheidungsmerkmal könnte z. B. eine Methode ""klettern"" dienen, die Mensch und Vogel fehlt. Sie zu ergänzen stellt überhaupt kein Problem dar - ja, es ist sogar eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind. Mehr dazu in Kapitel 26 in Kurseinheit 3.","Kann eine Klasse neue Spezialisierungen hinzufügen, wenn die Generalisierung bereits über Spezialisierungen verfügt?","Ja, eine Klasse kann neue Spezialisierungen hinzufügen, wenn die Generalisierung bereits über Spezialisierungen verfügt. Das ist eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind."
"Dass eine Generalisierung bereits über Spezialisierungen verfügt, hindert eine Klasse nicht daran, neue hinzuzufügen. So ist es beispielsweise im obigen Beispiel von ""Zweibeiner"" denkbar, dass man im Nachhinein noch ""Menschenaffe"" als Spezialisierung ergänzt. Als Unterscheidungsmerkmal könnte z. B. eine Methode ""klettern"" dienen, die Mensch und Vogel fehlt. Sie zu ergänzen stellt überhaupt kein Problem dar - ja, es ist sogar eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind. Mehr dazu in Kapitel 26 in Kurseinheit 3.",Wie wirkt sich die Generalisierung auf Spezialisierungen aus?,"Die Generalisierung hindert eine Klasse nicht daran, neue Spezialisierungen hinzuzufügen. Das bedeutet, dass eine Klasse, die bereits eine Generalisierung hat, immer noch neue Spezialisierungen hinzufügen kann, ohne die bestehenden Teile des Programms zu beeinflussen. Diese Fähigkeit, Programmiererweiterungen modular hinzuzufügen, ist eine der größten Errungenschaften der objektorientierten Programmierung."
"Leider ist es in der Programmierpraxis nicht immer ganz so einfach. Oftmals findet man Klassen (bzw. Instanzen), die ungefähr das tun, was man möchte, und denen man nur noch ein wenig hinzufügen möchte. Man möchte dann von einer Klasse spezialisieren, die selbst keine Generalisierung im oben genannten Sinne ist.","Was bedeutet es, wenn man von einer Klasse spezialisiert?","Wenn man von einer Klasse spezialisiert, erweitert man diese Klasse um neue Eigenschaften und Verhaltensweisen. Die spezialisierte Klasse ist eine Unterklasse der ursprünglichen Klasse und erbt alle Eigenschaften und Verhaltensweisen von dieser."
"Leider ist es in der Programmierpraxis nicht immer ganz so einfach. Oftmals findet man Klassen (bzw. Instanzen), die ungefähr das tun, was man möchte, und denen man nur noch ein wenig hinzufügen möchte. Man möchte dann von einer Klasse spezialisieren, die selbst keine Generalisierung im oben genannten Sinne ist.","Was bedeutet es, wenn man von einer Klasse spezialisieren möchte, die selbst keine Generalisierung ist?","In diesem Fall spricht man von einer Spezialisierung durch Verengung (engl. narrowing). Dabei wird eine bestehende Klasse so spezialisiert, dass sie weniger Fähigkeiten besitzt als die ursprüngliche Klasse. Diese Art der Spezialisierung ist in der objektorientierten Programmierung eher unüblich, kann aber in manchen Fällen sinnvoll sein."
"Leider ist es in der Programmierpraxis nicht immer ganz so einfach. Oftmals findet man Klassen (bzw. Instanzen), die ungefähr das tun, was man möchte, und denen man nur noch ein wenig hinzufügen möchte. Man möchte dann von einer Klasse spezialisieren, die selbst keine Generalisierung im oben genannten Sinne ist.",Was ist Spezialisierung in der Programmierung?,"Spezialisierung in der Programmierung ist der Prozess der Erstellung einer neuen Klasse, die auf einer bestehenden Klasse basiert und diese erweitert oder verändert, um spezifischere Funktionalitäten bereitzustellen. Die neue Klasse wird als spezialisiertere Version der ursprünglichen Klasse angesehen, da sie die gleichen allgemeinen Merkmale und Verhalten besitzt, aber zusätzliche Merkmale und Verhalten hinzufügt, um ihre Funktionalität zu erweitern."
"Ähnlich wie bei der Generalisierung ist es bei der Spezialisierung auch möglich, dies ohne das Hinzufügen von Eigenschaften zu erreichen, nämlich durch das Beschränken von Eigenschaften. So kann z. B. bei der Spezialisierung von ""Säugetier"" zu ""Zweibeiner"" der Wertebereich der Instanzvariable ""anzahlBeine"" von {2, 4} (also entweder zwei oder vier) auf {2} (also nur noch zwei) eingeschränkt werden. Die sprachlichen Möglichkeiten, dies auf Klassendefinitionsebene auszudrücken, sind allerdings in SMALLTALK (wie bereits im Zusammenhang mit der Generalisierung erwähnt) nicht gegeben; diese kommen erst mit der Typisierung von Variablen (Kapitel 18 in Kurseinheit 3). Die Beschränkung des Wertebereichs durch Spezialisierung ist jedoch in jedem Fall von der Instanziierung zu unterscheiden, bei der (gegebenenfalls durch Initialisierung) einer Instanzvariable eines Objekts ein Element aus dem Wertebereich (wie z. B. 2) zugewiesen wird. Dass im Fall von ""Zweibeiner"" dafür nur noch ein Element als Wert in Frage kommt, spielt dabei keine Rolle.",Was ist der Unterschied zwischen Spezialisierung und Instanziierung?,"Spezialisierung und Instanziierung sind zwei verschiedene Vorgänge. Spezialisierung bedeutet, den Wertebereich einer Instanzvariable einzuschränken, während Instanziierung bedeutet, einer Instanzvariable eines Objekts ein Element aus dem Wertebereich zuzuweisen. Im Fall von ""Zweibeiner"" kann durch Spezialisierung der Wertebereich der Instanzvariable ""anzahlBeine"" auf {2} eingeschränkt werden, während durch Instanziierung einer Instanzvariable eines Objekts der Wert 2 zugewiesen wird."
"Ähnlich wie bei der Generalisierung ist es bei der Spezialisierung auch möglich, dies ohne das Hinzufügen von Eigenschaften zu erreichen, nämlich durch das Beschränken von Eigenschaften. So kann z. B. bei der Spezialisierung von ""Säugetier"" zu ""Zweibeiner"" der Wertebereich der Instanzvariable ""anzahlBeine"" von {2, 4} (also entweder zwei oder vier) auf {2} (also nur noch zwei) eingeschränkt werden. Die sprachlichen Möglichkeiten, dies auf Klassendefinitionsebene auszudrücken, sind allerdings in SMALLTALK (wie bereits im Zusammenhang mit der Generalisierung erwähnt) nicht gegeben; diese kommen erst mit der Typisierung von Variablen (Kapitel 18 in Kurseinheit 3). Die Beschränkung des Wertebereichs durch Spezialisierung ist jedoch in jedem Fall von der Instanziierung zu unterscheiden, bei der (gegebenenfalls durch Initialisierung) einer Instanzvariable eines Objekts ein Element aus dem Wertebereich (wie z. B. 2) zugewiesen wird. Dass im Fall von ""Zweibeiner"" dafür nur noch ein Element als Wert in Frage kommt, spielt dabei keine Rolle.",Was ist Spezialisierung in der objektorientierten Programmierung?,"Spezialisierung in der objektorientierten Programmierung bedeutet, eine Klasse durch Einschränkung der Eigenschaften zu verfeinern. Dies kann erreicht werden, indem der Wertebereich einer Instanzvariable eingeschränkt wird. Zum Beispiel kann die Klasse ""Säugetier"" durch Spezialisierung zu ""Zweibeiner"" werden, indem der Wertebereich der Instanzvariable ""anzahlBeine"" von {2, 4} auf {2} eingeschränkt wird."
"Ähnlich wie bei der Generalisierung ist es bei der Spezialisierung auch möglich, dies ohne das Hinzufügen von Eigenschaften zu erreichen, nämlich durch das Beschränken von Eigenschaften. So kann z. B. bei der Spezialisierung von ""Säugetier"" zu ""Zweibeiner"" der Wertebereich der Instanzvariable ""anzahlBeine"" von {2, 4} (also entweder zwei oder vier) auf {2} (also nur noch zwei) eingeschränkt werden. Die sprachlichen Möglichkeiten, dies auf Klassendefinitionsebene auszudrücken, sind allerdings in SMALLTALK (wie bereits im Zusammenhang mit der Generalisierung erwähnt) nicht gegeben; diese kommen erst mit der Typisierung von Variablen (Kapitel 18 in Kurseinheit 3). Die Beschränkung des Wertebereichs durch Spezialisierung ist jedoch in jedem Fall von der Instanziierung zu unterscheiden, bei der (gegebenenfalls durch Initialisierung) einer Instanzvariable eines Objekts ein Element aus dem Wertebereich (wie z. B. 2) zugewiesen wird. Dass im Fall von ""Zweibeiner"" dafür nur noch ein Element als Wert in Frage kommt, spielt dabei keine Rolle.",Was ist Spezialisierung und wie kann sie erreicht werden?,"Spezialisierung ist ein Prozess, bei dem eine allgemeinere Klasse in eine speziellere Klasse aufgeteilt wird, indem der Wertebereich einer Instanzvariable eingeschränkt wird. In Smalltalk kann dies nicht direkt auf Klassendefinitionsebene ausgedrückt werden, sondern muss durch die Instanziierung und Initialisierung der Instanzvariable erfolgen."
"Vollkommen unvereinbar mit der Spezialisierung ist übrigens das Entfernen von Instanzvariablen oder Methoden. Dies ergibt sich schon daraus, dass die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Die Richtung von Spezialisierung und Generalisierung würde zudem, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte, beliebig werden.","Kann man Instanzvariablen oder Methoden entfernen, wenn man sie nicht mehr benötigt?","Nein, das ist nicht möglich. Das Entfernen von Instanzvariablen oder Methoden ist unvereinbar mit der Spezialisierung. Die Richtung von Spezialisierung und Generalisierung würde beliebig werden, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte."
"Vollkommen unvereinbar mit der Spezialisierung ist übrigens das Entfernen von Instanzvariablen oder Methoden. Dies ergibt sich schon daraus, dass die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Die Richtung von Spezialisierung und Generalisierung würde zudem, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte, beliebig werden.",Was ist die Folge von Entfernen von Instanzvariablen oder Methoden?,"Entfernen von Instanzvariablen oder Methoden ist unvereinbar mit der Spezialisierung. Die Richtung von Spezialisierung und Generalisierung würde beliebig werden, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte."
"Vollkommen unvereinbar mit der Spezialisierung ist übrigens das Entfernen von Instanzvariablen oder Methoden. Dies ergibt sich schon daraus, dass die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Die Richtung von Spezialisierung und Generalisierung würde zudem, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte, beliebig werden.",Warum ist das Entfernen von Instanzvariablen oder Methoden unvereinbar mit der Spezialisierung?,"Das Entfernen von Instanzvariablen oder Methoden ist unvereinbar mit der Spezialisierung, weil die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Zudem würde die Richtung von Spezialisierung und Generalisierung beliebig werden, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte."
"Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Damit dies erreicht wird, muss die Abhängigkeit der Module möglichst gering ausfallen. Dabei bedeutet Abhängigkeit in der Regel Änderungsabhängigkeit: Wenn sich in einem Teil etwas ändert, muss sich auch im davon abhängigen Teil etwas ändern. Sie ergibt sich regelmäßig aus einer Benutzungsbeziehung. In der objektorientierten Programmierung kommt jedoch noch die Vererbungsabhängigkeit hinzu. Module, die vollkommen unabhängig voneinander sind, sind ein Indikator dafür, dass man nicht ein Programm entwickelt, sondern mehrere. Wo keine Abhängigkeiten bestehen, gibt es auch kein Zusammenspiel.",Wozu dient die Aufteilung eines Programms in Module?,Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Dabei muss die Abhängigkeit der Module möglichst gering ausfallen.
"Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Damit dies erreicht wird, muss die Abhängigkeit der Module möglichst gering ausfallen. Dabei bedeutet Abhängigkeit in der Regel Änderungsabhängigkeit: Wenn sich in einem Teil etwas ändert, muss sich auch im davon abhängigen Teil etwas ändern. Sie ergibt sich regelmäßig aus einer Benutzungsbeziehung. In der objektorientierten Programmierung kommt jedoch noch die Vererbungsabhängigkeit hinzu. Module, die vollkommen unabhängig voneinander sind, sind ein Indikator dafür, dass man nicht ein Programm entwickelt, sondern mehrere. Wo keine Abhängigkeiten bestehen, gibt es auch kein Zusammenspiel.",Was ist die Folge von Abhängigkeit in der objektorientierten Programmierung?,"Die Folge von Abhängigkeit in der objektorientierten Programmierung ist Änderungsabhängigkeit, die sich aus einer Benutzungsbeziehung ergibt. Wenn sich in einem Teil etwas ändert, muss sich auch im davon abhängigen Teil etwas ändern. Zusätzlich gibt es in der objektorientierten Programmierung auch Vererbungsabhängigkeit."
"Abhängigkeit ist eine gerichtete Beziehung: Dass A von B abhängt, heißt nicht, dass auch B von A abhängt. Und so manifestieren sich auch in den Klassen als Modulen der Java-Programmierung die zwei Richtungen von Abhängigkeit in zwei verschiedenen Formen: Dass eine Klasse von (der Schnittstelle) einer anderen abhängt, erkennt man daran, dass auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich wiederum daran, dass Variablen des entsprechenden Typs deklariert werden und, sofern sich die andere Klasse in einem anderen Paket befindet, die Klasse oder sogar das ganze Paket importiert wird. Dass eine Klasse einige ihrer Member anderen zur Benutzung anbietet und diese dadurch von ihr abhängig werden können, erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht private sind, sowie an der Implementierung von Interfaces.",Wie äußert sich die Abhängigkeit zwischen Klassen in Java?,"Die Abhängigkeit zwischen Klassen in Java manifestiert sich in zwei verschiedenen Formen: Zum einen, wenn eine Klasse auf Objekte einer anderen Klasse zugreift, was sich durch die Deklaration von Variablen des entsprechenden Typs und gegebenenfalls durch das Importieren der Klasse oder des Pakets zeigt. Zum anderen, wenn eine Klasse einige ihrer Member anderen zur Benutzung anbietet, was sich durch die Verwendung von Zugriffsmodifikatoren, die nicht private sind, sowie an der Implementierung von Interfaces zeigt."
"In Java sind zunächst zirkuläre Abhängigkeiten erlaubt. Insbesondere dürfen sich zwei Klassen (genauer: Kompilierungseinheiten) wechselseitig importieren. In der Softwareentwicklung ist dies jedoch verpönt, schon weil eine wechselseitige Abhängigkeit eine enge Kopplung dokumentiert, die zwischen Modulen grundsätzlich vermieden werden sollte. Für Java-Module (siehe unten) sind zirkuläre Abhängigkeiten daher verboten. Wenn Sie einmal in die Verlegenheit kommen sollten, selbst Java-Module zu definieren, werden Sie feststellen, dass dieses Verbot eine sehr sorgfältige Planung der Modularisierung erzwingt, was an sich schon von großem Wert ist.",Sind zirkuläre Abhängigkeiten in Java erlaubt?,"Nein, zirkuläre Abhängigkeiten sind in Java nicht erlaubt, außer bei Klassen (genauer: Kompilierungseinheiten). Für Java-Module sind sie jedoch verboten."
"In Java sind zunächst zirkuläre Abhängigkeiten erlaubt. Insbesondere dürfen sich zwei Klassen (genauer: Kompilierungseinheiten) wechselseitig importieren. In der Softwareentwicklung ist dies jedoch verpönt, schon weil eine wechselseitige Abhängigkeit eine enge Kopplung dokumentiert, die zwischen Modulen grundsätzlich vermieden werden sollte. Für Java-Module (siehe unten) sind zirkuläre Abhängigkeiten daher verboten. Wenn Sie einmal in die Verlegenheit kommen sollten, selbst Java-Module zu definieren, werden Sie feststellen, dass dieses Verbot eine sehr sorgfältige Planung der Modularisierung erzwingt, was an sich schon von großem Wert ist.",Warum sind zirkuläre Abhängigkeiten in Java-Modulen verboten?,"Zirkuläre Abhängigkeiten sind in Java-Modulen verboten, um eine enge Kopplung zwischen Modulen zu vermeiden und eine sorgfältige Planung der Modularisierung zu erzwingen."
"Vererbungsabhängigkeiten zwischen Klassen, die in Java durch die Verwendung des Zugriffsmodifikators protected und der Annotation @Override zumindest angedeutet werden (mehr dazu in Kurseinheit 6, Kapitel 55), sind naturgemäß nicht zirkulär. Bei der Ausdehnung der Abhängigkeit von Klassen auf Pakete können jedoch auch zirkuläre Abhängigkeiten entstehen.",Was sind zirkuläre Abhängigkeiten zwischen Paketen?,"Zirkuläre Abhängigkeiten zwischen Paketen sind Abhängigkeiten, bei denen zwei oder mehr Pakete aufeinander referenzieren, so dass ein Kreislauf entsteht. Diese Abhängigkeiten können die Modularisierung und Wartbarkeit des Codes erschweren."
"Wir hatten bereits ausgenutzt, dass alle Objekte in SMALLTALK eine (mehr oder weniger aussagekräftige) String-Repräsentation besitzen. Die Methode printString gibt eine Darstellung des Objekts als String zurück. Dies ist für Ausgaben auf dem Transcript interessant, aber auch für die Inspektion von Objekten und für das Debugging, bei denen sich die Objekte unter Verwendung dieser Methode der Betrachterin präsentieren.",Was macht die Methode printString in SMALLTALK?,"Die Methode printString gibt eine Darstellung des Objekts als String zurück. Diese Methode ist für Ausgaben auf dem Transcript interessant, aber auch für die Inspektion von Objekten und für das Debugging."
"Die Methode inspect startet auf dem Empfänger einen Inspektor und gibt den Empfänger zurück. Dies ist nützlich, wenn man ein Zwischenergebnis eines Ausdrucks inspizieren möchte, ohne den Ausdruck dazu in zwei aufteilen zu wollen. Man fügt einfach inspect an der Stelle des Ausdrucks ein, an der das zu inspizierende Objekt gewonnen wurde.",Was macht die Methode inspect in SMALLTALK?,Die Methode inspect startet auf dem Empfänger einen Inspektor und gibt den Empfänger zurück.
"Die Methode storeOn: erlaubt, ein Objekt so auf einen Ausgabestrom zu schreiben, dass es daraus rekonstruiert werden kann. Dabei wird keine binäre, sondern eine textuelle Repräsentation verwendet. So schreibt beispielsweise SQUEAK bei Auswertung von Time noon storeOn: aStream die Zeichenfolge '12:00 pm' auf den durch aStream bezeichneten Ausgabestrom und (Interval from: 1 to: 5) die Zeichenfolge '(1 to: 5)'.",Was macht die Methode storeOn: in SMALLTALK?,"Die Methode storeOn: erlaubt, ein Objekt so auf einen Ausgabestrom zu schreiben, dass es daraus rekonstruiert werden kann. Dabei wird eine textuelle Repräsentation verwendet."
"Die Methode storeOn: erlaubt, ein Objekt so auf einen Ausgabestrom zu schreiben, dass es daraus rekonstruiert werden kann. Dabei wird keine binäre, sondern eine textuelle Repräsentation verwendet. So schreibt beispielsweise SQUEAK bei Auswertung von Time noon storeOn: aStream die Zeichenfolge '12:00 pm' auf den durch aStream bezeichneten Ausgabestrom und (Interval from: 1 to: 5) die Zeichenfolge '(1 to: 5)'.",Was macht die Methode reconstructFrom: in SMALLTALK?,"Die Methode reconstructFrom: erlaubt, ein Objekt aus einer binären Repräsentation auf einem Eingabestrom zu rekonstruieren."
"Die Methode storeOn: erlaubt, ein Objekt so auf einen Ausgabestrom zu schreiben, dass es daraus rekonstruiert werden kann. Dabei wird keine binäre, sondern eine textuelle Repräsentation verwendet. So schreibt beispielsweise SQUEAK bei Auswertung von Time noon storeOn: aStream die Zeichenfolge '12:00 pm' auf den durch aStream bezeichneten Ausgabestrom und (Interval from: 1 to: 5) die Zeichenfolge '(1 to: 5)'.",Was macht die Methode printOn: in SMALLTALK?,"Die Methode printOn: gibt die textuelle Repräsentation eines Objekts auf einem Ausgabestrom aus, die für Menschen lesbar ist."
"Die Methode storeOn: erlaubt, ein Objekt so auf einen Ausgabestrom zu schreiben, dass es daraus rekonstruiert werden kann. Dabei wird keine binäre, sondern eine textuelle Repräsentation verwendet. So schreibt beispielsweise SQUEAK bei Auswertung von Time noon storeOn: aStream die Zeichenfolge '12:00 pm' auf den durch aStream bezeichneten Ausgabestrom und (Interval from: 1 to: 5) die Zeichenfolge '(1 to: 5)'.",Was macht die Methode nextPutAll: in SMALLTALK?,Die Methode nextPutAll: gibt eine Sequenz von Objekten auf einem Ausgabestrom aus.
"Die Methode storeOn: erlaubt, ein Objekt so auf einen Ausgabestrom zu schreiben, dass es daraus rekonstruiert werden kann. Dabei wird keine binäre, sondern eine textuelle Repräsentation verwendet. So schreibt beispielsweise SQUEAK bei Auswertung von Time noon storeOn: aStream die Zeichenfolge '12:00 pm' auf den durch aStream bezeichneten Ausgabestrom und (Interval from: 1 to: 5) die Zeichenfolge '(1 to: 5)'.",Was macht die Methode nextPut: in SMALLTALK?,Die Methode nextPut: gibt ein Objekt auf einem Ausgabestrom aus.
"Die Methode storeOn: erlaubt, ein Objekt so auf einen Ausgabestrom zu schreiben, dass es daraus rekonstruiert werden kann. Dabei wird keine binäre, sondern eine textuelle Repräsentation verwendet. So schreibt beispielsweise SQUEAK bei Auswertung von Time noon storeOn: aStream die Zeichenfolge '12:00 pm' auf den durch aStream bezeichneten Ausgabestrom und (Interval from: 1 to: 5) die Zeichenfolge '(1 to: 5)'.",Was macht die Methode readFrom: in SMALLTALK?,"Die Methode readFrom: erlaubt, ein Objekt aus einem Eingabestrom zu lesen."
"Die einfache Verzweigung wird in SMALLTALK durch das Versenden einer Nachricht, die die bedingt auszuführenden Anweisungen in Form eines Blocks als Parameter enthält, an einen Wahrheitswert realisiert. Zum Beispiel gibt die Meldung „x > 5“ genau dann auf der Konsole aus, wenn x > 5 zu true auswertet.",Wie wird die einfache Verzweigung in SMALLTALK realisiert?,In SMALLTALK wird die einfache Verzweigung durch das Versenden einer Nachricht an einen Wahrheitswert realisiert. Diese Nachricht enthält die bedingt auszuführenden Anweisungen in Form eines Blocks als Parameter.
"Ein von Christopher Strachey, einem der Urväter der Programmierung als wissenschaftliche Disziplin, eingeführter Begriff ist der der Polymorphie. Polymorphie bedeutet allgemein Vielgestaltigkeit und wird vor allem in der Biologie verwendet. In der Programmierung steht er für verschiedene Dinge, die jedoch alle mit Typen zu tun haben. Unter Inklusionspolymorphie, auch Subtyp-Polymorphie genannt, versteht man im Wesentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, können Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert). Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus (engl. parametric polymorphism, s. Kapitel 29) gebräuchlich; sonst redet man eher von Subtyping. Das Interessante an der Inklusionspolymorphie ist, dass sich der Wertebereich von Typen dadurch auf unvorhergesehene Umfänge aufweiten lässt. Dies ist insbesondere für die Weiterentwicklung und Wiederverwendung von Programmen interessant, bei der einfach neue Typen hinzugefügt werden können, die anstelle bereits existierender eingesetzt werden können, ohne dass dazu am Programm sonst etwas geändert werden müsste. Die Regeln einer strengen Typprüfung werden durch Inklusionspolymorphie aufgelockert, ohne an Typsicherheit zu verlieren. Insgesamt krankt die Definition des Subtypings und der Inklusionspolymorphie in der objektorientierten Programmierung jedoch daran, dass nicht klar definiert ist, was alles zu verlangen ist, damit ein Objekt eines Typs tatsächlich auch da auftauchen kann, wo ein Objekt eines anderen Typs erwartet wird. Zwar gibt die Regel von Ko- und Kontravarianz eine klare Bedingung vor, aber wie Sie schon gesehen haben, ist diese Bedingung aus praktischen Gründen nicht unumstritten. Dazu kommt, dass die Regel einerseits gar nicht ausreicht, um Ersetzbarkeit zu garantieren, und andererseits zu streng ist (s. Kurseinheit 6, Kapitel 54). Da Ersetzbarkeit jedoch der Definition des Subtypenbegriffs zugrunde liegt, bleibt das Ganze schwammig. In dieser Kurseinheit habe ich mich, den meisten gängigen objektorientierten Programmiersprachen folgend, darauf zurückgezogen, zu garantieren, dass keine Typfehler auftreten können, also keine Fehler der Art, dass eine bestimmte geforderte Eigenschaft (Methode) bei einem Objekt nicht vorhanden ist; alles weitere wird dann in Kapitel 54 behandelt.",Was ist Inklusionspolymorphie?,"Inklusionspolymorphie, auch Subtyp-Polymorphie genannt, ist ein Begriff aus der Programmierung, der bedeutet, dass Objekte eines Typs anstelle von Objekten eines anderen Typs verwendet werden können, wenn der erste Typ den zweiten einschließt (subsumiert). Das ist vor allem für die Weiterentwicklung und Wiederverwendung von Programmen interessant, da neue Typen hinzugefügt werden können, ohne dass dazu am Programm sonst etwas geändert werden muss."
"Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraussetzung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (beispielsweise der Verwendung von Nicht-Zahlen in arithmetischen Ausdrücken), muss bekannt sein, welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden werden können, schnell gefasst: Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein Protokoll. Ein solches Protokoll definiert einen Typ: Er umfasst die Menge der Objekte, die über das Protokoll verfügen.",Wie wird ein Typ in SMALLTALK definiert?,"In SMALLTALK wird ein Typ durch das Protokoll definiert, das heißt, durch die Menge der Methoden, die ein Objekt versteht."
"Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraussetzung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (beispielsweise der Verwendung von Nicht-Zahlen in arithmetischen Ausdrücken), muss bekannt sein, welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden werden können, schnell gefasst: Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein Protokoll. Ein solches Protokoll definiert einen Typ: Er umfasst die Menge der Objekte, die über das Protokoll verfügen.",Wozu dient ein Typsystem in der Programmierung?,"Ein Typsystem dient dazu, Fehler auszuschließen, die auf der Voraussetzung von Eigenschaften von Objekten beruhen, die diese gar nicht haben. Zum Beispiel der Verwendung von Nicht-Zahlen in arithmetischen Ausdrücken."
"Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraussetzung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (beispielsweise der Verwendung von Nicht-Zahlen in arithmetischen Ausdrücken), muss bekannt sein, welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden werden können, schnell gefasst: Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein Protokoll. Ein solches Protokoll definiert einen Typ: Er umfasst die Menge der Objekte, die über das Protokoll verfügen.",Was ist ein Protokoll in Smalltalk?,"In Smalltalk ist ein Protokoll die Menge der Methoden, die ein Objekt versteht. Es definiert einen Typ, der die Menge der Objekte umfasst, die über das Protokoll verfügen."
"Wenn man nun eine Variable mit einem solchen Protokoll als Typ typisiert und das Programm typkorrekt ist, dann ist garantiert, dass jede Methode, die im Protokoll enthalten ist und die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist. Typfehler, also Fehler der Sorte „does not understand“, treten dann nicht mehr auf.",Wozu dient die Typisierung einer Variablen mit einem Protokoll?,"Die Typisierung einer Variablen mit einem Protokoll dient dazu, Typfehler zu vermeiden. Wenn das Programm typkorrekt ist, ist garantiert, dass jede Methode, die im Protokoll enthalten ist und auf der Variablen aufgerufen wird, auch für den Inhalt der Variablen definiert ist."
"Wenn man nun eine Variable mit einem solchen Protokoll als Typ typisiert und das Programm typkorrekt ist, dann ist garantiert, dass jede Methode, die im Protokoll enthalten ist und die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist. Typfehler, also Fehler der Sorte „does not understand“, treten dann nicht mehr auf.","Was wird verhindert, wenn man eine Variable mit einem Protokoll als Typ typisiert und das Programm typkorrekt ist?","Wenn man eine Variable mit einem Protokoll als Typ typisiert und das Programm typkorrekt ist, wird verhindert, dass Typfehler auftreten, also Fehler der Sorte „does not understand“, die auftreten, wenn eine Methode aufgerufen wird, die für den Inhalt der Variable, das referenzierte Objekt, nicht definiert ist."
"Nun kommen in Protokollen aber selbst Variablen vor, nämlich die formalen Parameter der Methoden, die das Protokoll ausmachen. Außerdem ist eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Objekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle definieren also nicht nur Typen, sie verwenden auch selbst welche, nämlich indem sie die Typen der Ein- und Ausgabeobjekte spezifizieren. Ein einfaches Beispiel für eine Typdefinition, die selbst Typen verwendet, ist die folgende:",Was sind formale Parameter von Methoden in Protokollen?,"Formale Parameter von Methoden sind Variablen, die das Protokoll ausmachen."
"Nun kommen in Protokollen aber selbst Variablen vor, nämlich die formalen Parameter der Methoden, die das Protokoll ausmachen. Außerdem ist eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Objekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle definieren also nicht nur Typen, sie verwenden auch selbst welche, nämlich indem sie die Typen der Ein- und Ausgabeobjekte spezifizieren. Ein einfaches Beispiel für eine Typdefinition, die selbst Typen verwendet, ist die folgende:",Was sind Protokolle und welche Rolle spielen Variablen in ihnen?,"Protokolle sind eine Art von Typdefinition, die die Methoden und Eigenschaften beschreiben, die ein Objekt haben muss, um eine bestimmte Rolle zu erfüllen. Variablen spielen in Protokollen eine Rolle, indem sie als formale Parameter in Methoden auftauchen und als Typen für die Ein- und Ausgabeobjekte spezifiziert werden."
"Wie schon bei einer temporären Variable stehen die Typannotationen von formalen Parametern in STRONGTALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kennzeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Methode ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zurück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo-Typvariable (entsprechend der Pseudovariable self, deren Typ sie darstellt).",Wie werden der Rückgabetyp und die Typannotationen von formalen Parametern in STRONGTALK gekennzeichnet?,Die Typannotationen von formalen Parametern in STRONGTALK stehen in spitzen Klammern dahinter und der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet.
"Wie schon bei einer temporären Variable stehen die Typannotationen von formalen Parametern in STRONGTALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kennzeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Methode ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zurück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo-Typvariable (entsprechend der Pseudovariable self, deren Typ sie darstellt).",Wie werden Rückgabetypen in STRONGTALK angegeben?,"Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben, muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden."
"Wie schon bei einer temporären Variable stehen die Typannotationen von formalen Parametern in STRONGTALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kennzeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Methode ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zurück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo-Typvariable (entsprechend der Pseudovariable self, deren Typ sie darstellt).",Was repräsentiert der Rückgabetyp Self in Smalltalk?,Der Rückgabetyp Self in Smalltalk repräsentiert den Typ des Empfängerobjekts.
"Falls Sie sich wundern, dass obige Zeilen kein Schlüsselwort zur Einleitung der Typdefinition beinhalten: STRONGTALK ist, genau wie SMALLTALK, ein interaktives, browsergestütztes System, in dem Typen in Formulare eingetragen und nicht in Textdateien spezifiziert werden. Gleichwohl fällt auf, dass innerhalb der Typdefinition in Typen als Teile von den spitzen Klammern (also da, wo Typen stehen sollen) keine Typdefinition auftauchen, sondern Namen. Und tatsächlich wird in STRONGTALK jeder Typ benannt (in seiner Typdefinition mit einem Namen versehen). Im folgenden werden Typen, ähnlich wie Klassen, in tabellarischer Form notiert.",Wie werden Typen in STRONGTALK definiert?,"In STRONGTALK werden Typen in tabellarischer Form definiert und mit einem Namen versehen. Die Typdefinition enthält keine Typdefinitionen, sondern Namen."
"In STRONGTALK ist die Protokollbildung der einzige sogenannte Typkonstruktor, d. h., das einzige Sprachkonstrukt, mit dem man neue Typen definieren kann. Andere Programmiersprachen sehen ein reichhaltigeres Angebot vor: In PASCAL beispielsweise gibt es die Typkonstruktoren record, array of, set of, file of, Zeiger auf (^) sowie Aufzählungen (enumerations) und Teilbereiche (ranges). In C++ gibt es u. a. class und struct (entsprechend record in PASCAL), Java, C-Sharp und EIFFEL bieten auch jeweils verschiedene Typkonstruktoren an. Für eine puristische Sprache wie SMALLTALK bzw. STRONGTALK reicht jedoch einer vollkommen aus.",Was ist die Protokollbildung in STRONGTALK?,"In STRONGTALK ist daieProtokollbildung der einzige Typkonstruktor, mit dem man neue Typen definieren kann."
"In STRONGTALK ist die Protokollbildung der einzige sogenannte Typkonstruktor, d. h., das einzige Sprachkonstrukt, mit dem man neue Typen definieren kann. Andere Programmiersprachen sehen ein reichhaltigeres Angebot vor: In PASCAL beispielsweise gibt es die Typkonstruktoren record, array of, set of, file of, Zeiger auf (^) sowie Aufzählungen (enumerations) und Teilbereiche (ranges). In C++ gibt es u. a. class und struct (entsprechend record in PASCAL), Java, C-Sharp und EIFFEL bieten auch jeweils verschiedene Typkonstruktoren an. Für eine puristische Sprache wie SMALLTALK bzw. STRONGTALK reicht jedoch einer vollkommen aus.",Was ist der einzige Typkonstruktor in STRONGTALK?,In STRONGTALK ist die Protokollbildung der einzige Typkonstruktor.
"Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten. Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das wirft natürlich die Frage auf, wie man Typen unter zwangsläufiger Selbstbezüglichkeit überhaupt eine Bedeutung beimessen kann.",Was gibt es in STRONGTALK nicht?,"In STRONGTALK gibt es keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten."
"Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten. Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das wirft natürlich die Frage auf, wie man Typen unter zwangsläufiger Selbstbezüglichkeit überhaupt eine Bedeutung beimessen kann.",Gibt es in STRONGTALK primitiven Typen?,"Nein, in STRONGTALK gibt es keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten."
"Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten. Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das wirft natürlich die Frage auf, wie man Typen unter zwangsläufiger Selbstbezüglichkeit überhaupt eine Bedeutung beimessen kann.",Was ist der Unterschied zwischen STRONGTALK und anderen Programmiersprachen hinsichtlich primitiver Typen?,"Im Gegensatz zu STRONGTALK haben andere Programmiersprachen oft primitiver Typen, deren Definitionen nicht auf andere Typen zurückgeführt werden müssen. In STRONGTALK gibt es keine primitiven Typen, alle Typen sind selbstbezüglich."
"Laufzeitfehler der obigen Art vermeidet man in Java mithilfe sogenannter Typtests, die man vor einer Typumwandlung durchführt. Das dazugehörige Schlüsselwort heißt instanceof.",Was sind Typtests in Java?,"Typtests in Java sind eine Methode, um Laufzeitfehler zu vermeiden. Sie werden durchgeführt, bevor eine Typumwandlung durchgeführt wird. Das Schlüsselwort hierfür ist instanceof."
"Laufzeitfehler der obigen Art vermeidet man in Java mithilfe sogenannter Typtests, die man vor einer Typumwandlung durchführt. Das dazugehörige Schlüsselwort heißt instanceof.",Wie vermeidet man in Java Laufzeitfehler durch Typumwandlung?,"In Java vermeidet man Laufzeitfehler durch Typumwandlung mithilfe von Typtests, die man mit dem Schlüsselwort instanceof durchführt."
"Laufzeitfehler der obigen Art vermeidet man in Java mithilfe sogenannter Typtests, die man vor einer Typumwandlung durchführt. Das dazugehörige Schlüsselwort heißt instanceof.",Was ist der Zweck des Schlüsselworts instanceof in Java?,"Das Schlüsselwort instanceof in Java wird verwendet, um vor einer Typumwandlung einen Typtest durchzuführen, um Laufzeitfehler zu vermeiden."
"Typtests in Kombination mit bedingten Umwandlungen (Casting) bilden die typsichere Variante der Typumwandlung. Es bleibt allerdings an der Programmiererin hängen, zu sagen, was passieren soll, wenn der Wert von 'o' nicht den geforderten Typ (hier String) hat.",Was sind typsichere Varianten der Typumwandlung?,"Typtests in Kombination mit bedingten Umwandlungen (Casting) bilden die typsichere Variante der Typumwandlung. Die Programmiererin muss jedoch festlegen, was passieren soll, wenn der Wert eines Objekts nicht den geforderten Typ hat."
"Neben in Typdefinitionen können Typvariablen (formale Typparameter) auch in Methodendefinitionen eingeführt (deklariert) werden. In diesem Fall ist die Sichtbarkeit der Typparameter auf die jeweilige Methode beschränkt. Es lassen sich damit variable Über- und Rückgabeparametertypen für eine Methode deklarieren. Die Belegung der Typparameter mit konkreten Typen als Werten erfolgt dann bei der Bindung eines Methodenaufrufs zur Übersetzungszeit. Der tatsächliche Typparameter muss dabei nicht angegeben werden, wenn er sich aus dem Kontext eindeutig ergibt (sog. Typinferenz).",Wozu können Typparameter in Methodendefinitionen eingesetzt werden?,"Typparameter in Methodendefinitionen können dazu genutzt werden, variable Über- und Rückgabeparametertypen für eine Methode zu deklarieren. Die Belegung der Typparameter mit konkreten Typen als Werten erfolgt dann bei der Bindung eines Methodenaufrufs zur Übersetzungszeit."
"Neben in Typdefinitionen können Typvariablen (formale Typparameter) auch in Methodendefinitionen eingeführt (deklariert) werden. In diesem Fall ist die Sichtbarkeit der Typparameter auf die jeweilige Methode beschränkt. Es lassen sich damit variable Über- und Rückgabeparametertypen für eine Methode deklarieren. Die Belegung der Typparameter mit konkreten Typen als Werten erfolgt dann bei der Bindung eines Methodenaufrufs zur Übersetzungszeit. Der tatsächliche Typparameter muss dabei nicht angegeben werden, wenn er sich aus dem Kontext eindeutig ergibt (sog. Typinferenz).",Was sind Typparameter in der Programmierung?,"Typparameter, auch formale Typparameter genannt, sind Variablen, die in Typdefinitionen oder Methodendefinitionen eingeführt werden können. Sie ermöglichen die Deklaration variabler Über- und Rückgabeparametertypen für eine Methode. Die Belegung der Typparameter mit konkreten Typen als Werten erfolgt bei der Bindung eines Methodenaufrufs zur Übersetzungszeit."
"Beim Aufruf einer parametrischen Methode muss der tatsächliche Typparameter angegeben werden. Allerdings erlaubt der Java-Compiler, diesen wegzulassen, wenn er sich aus dem Aufruf erschließen lässt (die oben erwähnte Typinferenz).",Was ist ein tatsächlicher Typparameter bei einer parametrischen Methode?,"Beim Aufruf einer parametrischen Methode muss der tatsächliche Typparameter angegeben werden, der den formalen Typparametern zugeordnet wird. Allerdings erlaubt der Java-Compiler, diesen wegzulassen, wenn er sich aus dem Aufruf erschließen lässt (die oben erwähnte Typinferenz)."
"Beim Aufruf einer parametrischen Methode muss der tatsächliche Typparameter angegeben werden. Allerdings erlaubt der Java-Compiler, diesen wegzulassen, wenn er sich aus dem Aufruf erschließen lässt (die oben erwähnte Typinferenz).",Was ist Typinferenz in Java?,"Typinferenz in Java ist eine Funktion des Compilers, die es ermöglicht, den tatsächlichen Typparameter bei einem Aufruf einer parametrischen Methode wegzulassen, wenn er sich aus dem Aufruf erschließen lässt."
"Der (formale) Typparameter einer generischen Methode kann zunächst an jeden beliebigen Typ gebunden werden. Genau wie bei generischen Klassen reduziert dies jedoch entweder die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode unbekannt ist. Es ist also, wieder genau wie bei generischen Klassen, möglich, den Typparameter mit extends zu beschränken.","Was bedeutet es, einen Typparameter mit extends zu beschränken?","Wenn ein Typparameter mit extends beschränkt wird, kann er nur an einen Typ gebunden werden, der eine Unterklasse des angegebenen Typs ist. Dadurch wird die Verwendbarkeit oder Typsicherheit der mit dem Parameter übergebenen Objekte innerhalb der Methode eingeschränkt."
"Der (formale) Typparameter einer generischen Methode kann zunächst an jeden beliebigen Typ gebunden werden. Genau wie bei generischen Klassen reduziert dies jedoch entweder die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode unbekannt ist. Es ist also, wieder genau wie bei generischen Klassen, möglich, den Typparameter mit extends zu beschränken.",Was ist der Zweck von Typparametern in generischen Methoden?,"Der Typparameter einer generischen Methode kann an jeden beliebigen Typ gebunden werden. Er reduziert jedoch entweder die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode unbekannt ist. Daher ist es möglich, den Typparameter mit extends zu beschränken."
"Der (formale) Typparameter einer generischen Methode kann zunächst an jeden beliebigen Typ gebunden werden. Genau wie bei generischen Klassen reduziert dies jedoch entweder die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode unbekannt ist. Es ist also, wieder genau wie bei generischen Klassen, möglich, den Typparameter mit extends zu beschränken.","Was bedeutet es, den Typparameter einer generischen Methode mit extends zu beschränken?","Wenn man den Typparameter einer generischen Methode mit extends beschränkt, kann er nur an Typen gebunden werden, die eine Unterklasse der angegebenen Klasse sind. Das erhöht die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode bekannt ist."
"Nicht selten wird der Typparameter (nicht die mit ihm deklarierten Parameter!) innerhalb der Methode nicht mehr verwendet. Eine Variable, die nur einmal vorkommt, kann man aber auch weglassen oder zumindest unbenannt lassen. Und so ist es in diesen Fällen gute Praxis, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard zu verwenden.",Was ist ein Typparameter und wann sollte man eine Typ-Wildcard verwenden?,"Ein Typparameter ist ein Parameter, der innerhalb einer Methode nicht mehr verwendet wird. Wenn eine Variable nur einmal vorkommt, kann man sie weglassen oder zumindest unbenannt lassen. In diesen Fällen ist es gute Praxis, anstelle des Typparameters eine Typ-Wildcard zu verwenden."
"Nicht selten wird der Typparameter (nicht die mit ihm deklarierten Parameter!) innerhalb der Methode nicht mehr verwendet. Eine Variable, die nur einmal vorkommt, kann man aber auch weglassen oder zumindest unbenannt lassen. Und so ist es in diesen Fällen gute Praxis, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard zu verwenden.","Was ist eine gute Praxis, wenn eine Variable nur einmal innerhalb einer Methode vorkommt?","Wenn eine Variable nur einmal innerhalb einer Methode vorkommt, ist es gute Praxis, anstelle des Typparameters ein entsprechend beschränktes Typ-Wildcard zu verwenden."
"Nicht selten wird der Typparameter (nicht die mit ihm deklarierten Parameter!) innerhalb der Methode nicht mehr verwendet. Eine Variable, die nur einmal vorkommt, kann man aber auch weglassen oder zumindest unbenannt lassen. Und so ist es in diesen Fällen gute Praxis, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard zu verwenden.",Was ist eine Typparameter und wann sollte man eine Typ-Wildcard anstelle des Typparameters verwenden?,"Ein Typparameter ist ein Parameter, der in einer Methode verwendet wird, um einen Typ anzugeben. Es ist gute Praxis, eine Typ-Wildcard anstelle des Typparameters zu verwenden, wenn die Variable nur einmal vorkommt und nicht mehr verwendet wird. Eine Typ-Wildcard ist eine eingeschränkte Version des Typparameters, die anzeigt, dass die Variable mit einem beliebigen Typ initialisiert werden kann."
"Ein relativ neues Feature in EIFFEL sind die sogenannten Tupel. Tupel ermöglichen es, ohne großen Aufwand mehrere Objekte zu gruppieren, insbesondere ohne die Notwendigkeit, eine Klasse zu definieren. Tupel sind besonders interessant, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugeordnet wird. Dies ist besonders prominent bei Methoden, die mehrere Werte anstelle eines einzigen Wertes zurückgeben sollen.",Was sind Tupel in EIFFEL?,"Tupel in EIFFEL sind eine Möglichkeit, mehrere Objekte ohne großen Aufwand zu gruppieren, insbesondere ohne die Notwendigkeit, eine Klasse zu definieren. Tupel sind besonders interessant, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugeordnet wird. Dies ist besonders prominent bei Methoden, die mehrere Werte anstelle eines einzigen Wertes zurückgeben sollen."
"Ein relativ neues Feature in EIFFEL sind die sogenannten Tupel. Tupel ermöglichen es, ohne großen Aufwand mehrere Objekte zu gruppieren, insbesondere ohne die Notwendigkeit, eine Klasse zu definieren. Tupel sind besonders interessant, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugeordnet wird. Dies ist besonders prominent bei Methoden, die mehrere Werte anstelle eines einzigen Wertes zurückgeben sollen.",Wofür werden Tupel in EIFFEL verwendet?,"Tupel werden in EIFFEL als eine Möglichkeit verwendet, mehrere Objekte ohne großen Aufwand zu gruppieren, insbesondere ohne die Notwendigkeit, eine Klasse zu definieren. Sie sind besonders interessant, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugeordnet wird. Dies ist beispielsweise bei Methoden der Fall, die mehrere Werte anstelle eines einzigen Wertes zurückgeben sollen."
"Tupeltypen werden deklariert, indem für jede Position ein Typ angegeben wird. Konkrete Werte eines Tupels werden in eckigen Klammern notiert. Die Positionen eines Tupels können auch Namen erhalten. Da Tupeltypen anonym sind, erfolgt die Zuordnung eines Tupels zu einem Tupeltyp (normalerweise während der Instanziierung) durch den Abgleich der vorhandenen Positionen mit den deklarierten Positionstypen sowie gegebenenfalls den Positionsnamen.",Was sind Tupeltypen?,"Tupeltypen sind eine Möglichkeit, Werte mit mehreren Komponenten zu definieren, bei der jeder Komponente ein eigener Typ zugeordnet ist."
"Genau wie in SMALLTALK werden in Java Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Anders als in SMALLTALK gibt es in Java jedoch eine Vielzahl von Schlüsselwörtern, die Anweisungen einleiten. Dennoch ist es auch in Java möglich, bestimmte Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden Ausdruck durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen (siehe Kapitel 37) direkt zu Anweisungen. Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK, das Semikolon in Java kein Trennzeichen ist, sondern Teil der Anweisung.",Wie werden Ausdrücke in Java zu Anweisungen?,"In Java können bestimmte Ausdrücke zu Anweisungen gemacht werden, indem sie durch ein Semikolon abgeschlossen werden. Dazu gehören Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen."
"Genau wie in SMALLTALK werden in Java Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Anders als in SMALLTALK gibt es in Java jedoch eine Vielzahl von Schlüsselwörtern, die Anweisungen einleiten. Dennoch ist es auch in Java möglich, bestimmte Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden Ausdruck durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen (siehe Kapitel 37) direkt zu Anweisungen. Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK, das Semikolon in Java kein Trennzeichen ist, sondern Teil der Anweisung.",Was ist der Unterschied zwischen einem Ausdruck und einer Anweisung in Java?,"In Java werden Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Ein Ausdruck wird zu einer Anweisung, indem er mit einem Semikolon abgeschlossen wird. Im Gegensatz zum Semikolon in PASCAL oder dem Punkt in SMALLTALK ist das Semikolon in Java kein Trennzeichen, sondern Teil der Anweisung. Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen sind in Java direkt als Anweisungen möglich."
"Nahezu alle Anweisungen finden sich in Java-Programmen innerhalb von Methoden. Blöcke sind in Java lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt Java erst seit Version 8, mit der Einführung der Lambda-Ausdrücke.",Was sind Blöcke in Java?,"In Java sind Blöcke lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt Java erst seit Version 8, mit der Einführung der Lambda-Ausdrücke."
"Es sind also Variablendeklarationen, Methodenaufrufe (inklusive der Konstruktoraufrufe) und Zuweisungen Anweisungen. Alle anderen Anweisungen werden durch Schlüsselwörter eingeleitet und realisieren Kontrollstrukturen, die den Kontrollfluss eines Programms dazu bringen, von der normalen, sequentiellen Ausführung abzuweichen. Im Einzelnen sind dies: while-Anweisungen, repeat-Anweisungen, for-Anweisungen, case-Anweisungen.",Was sind die Kontrollstrukturen in der Programmierung?,"Die Kontrollstrukturen in der Programmierung sind if-Anweisungen, while-Anweisungen, repeat-Anweisungen, for-Anweisungen und case-Anweisungen. Sie dienen dazu, den Kontrollfluss eines Programms von der normalen, sequentiellen Ausführung abzuweichen."
"Es sind also Variablendeklarationen, Methodenaufrufe (inklusive der Konstruktoraufrufe) und Zuweisungen Anweisungen. Alle anderen Anweisungen werden durch Schlüsselwörter eingeleitet und realisieren Kontrollstrukturen, die den Kontrollfluss eines Programms dazu bringen, von der normalen, sequentiellen Ausführung abzuweichen. Im Einzelnen sind dies: while-Anweisungen, repeat-Anweisungen, for-Anweisungen, case-Anweisungen.",Was sind die Anweisungen die den Kontrollfluss eines Programms beeinflussen?,"Die Anweisungen die den Kontrollfluss eines Programms beeinflussen sind: if-Anweisungen, while-Anweisungen, repeat-Anweisungen, case-Anweisungen, for-Anweisungen, loop-Anweisungen, exit-Anweisungen und return-Anweisungen."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was bewirkt eine If-Anweisung in der Programmierung?,"Eine If-Anweisung in der Programmierung führt genau dann das angegebene Statement aus, wenn der boole'sche Ausdruck zu true auswertet."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was ist ein boolescher Ausdruck?,"Ein boolescher Ausdruck ist ein Ausdruck, der entweder zu true oder false auswertet. Er wird in If-Anweisungen verwendet, um die Bedingung zu testen, die entscheidet, ob das Statement ausgeführt wird oder nicht."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was bedeutet die If-else-Anweisung in der Programmierung?,"Die If-else-Anweisung ist eine Steuerungsstruktur, die es ermöglicht, eine bestimmte Anweisung auszuführen, wenn ein boolescher Ausdruck wahr ist, und eine andere Anweisung auszuführen, wenn der boolesche Ausdruck falsch ist. Die Anweisung, die ausgeführt wird, wenn der boolesche Ausdruck wahr ist, wird als <Statement 1> bezeichnet, und die Anweisung, die ausgeführt wird, wenn der boolesche Ausdruck falsch ist, wird als <Statement 2> bezeichnet."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was ist die Switch-Anweisung in Java?,"Die Switch-Anweisung in Java ist eine Steuerungsanweisung, die einen Ausdruck mit einem oder mehreren Literalen vergleicht und eine entsprechende Anweisungsliste ausführt. Der Ausdruck und die Literale müssen vom Typ char, byte, short, int, String oder einem Aufzählungstyp sein. Die Anweisungslisten können mit einem break abgeschlossen werden, müssen aber nicht. Wenn keines der Literale mit dem Ausdruck übereinstimmt, wird die default-Anweisungsliste ausgeführt."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was macht eine While-Anweisung?,"Die While-Anweisung wiederholt eine Anweisung, solange eine boolesche Bedingung wahr ist."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was ist die Do-Anweisung in der Programmierung?,"Die Do-Anweisung ist eine Steuerungsstruktur, die eine Anweisung wiederholt ausführt, solange eine bestimmte Bedingung wahr ist. Die Do-Anweisung in der Form do <Statement> while (<Boolescher Ausdruck>) führt die Anweisung <Statement> aus und wertet dann den booleschen Ausdruck aus. Wenn der boolesche Ausdruck wahr ist, wird die Anweisung erneut ausgeführt. Diese Form unterscheidet sich vom While-Statement dadurch, dass der boolesche Ausdruck erst nach Ausführung der Anweisung ausgewertet wird."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was ist der Unterschied zwischen der Do-Anweisung und dem While-Statement?,"Der Unterschied liegt darin, dass bei der Do-Anweisung der boolesche Ausdruck erst nach Ausführung des Statements ausgewertet wird, während beim While-Statement der boolesche Ausdruck vor der Ausführung des Statements ausgewertet wird."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was ist die For-Anweisung in der Programmierung?,"Die For-Anweisung ist eine Kontrollstruktur in der Programmierung, die eine Schleife durchläuft, wobei sie drei Segmente innerhalb der Klammern enthält: Initialisierungsausdruck, booleschen Ausdruck und Veränderungsausdruck. Diese Segmente können auch mehrere Ausdrücke enthalten, die durch Kommata getrennt werden. Das <Statement> wird so lange wiederholt, bis der boolesche Ausdruck nicht mehr wahr ist. Diese Schleifenkonstruktion ist ein Erbe von C."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was ist eine erweiterte For-Anweisung?,"Die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement> führt <Statement> für alle Werte, die <Ausdruck> liefert, einmal aus, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was bewirkt die Break-Anweisung in Programmiersprachen?,"Die Break-Anweisung führt dazu, dass eine Schleife oder ein Switch-Statement sofort verlassen wird. Sie kann mit einem Label versehen werden, auf das sie sich bezieht, um eine äußere Schleife oder ein äußeres Switch-Statement zu verlassen."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was bewirkt die Continue-Anweisung in Schleifen?,"Die Continue-Anweisung führt dazu, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird."
"Die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet; die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst; die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen); die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet; die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement); die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen); die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden); die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt; die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.",Was bewirkt die Return-Anweisung in einer Methode?,"Die Return-Anweisung bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird."
"die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen);die Synchronized-Anweisung der Form synchronized (<Ausdruck>) <Block>, die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem <Ausdruck> ausgewertet wird, verbundene Lock dies zulässt (siehe Abschnitt 47.3);",Was bewirkt die Synchronized-Anweisung in Java?,"Die Synchronized-Anweisung in Java sorgt dafür, dass der durch den Block bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem der Ausdruck ausgewertet wird, verbundene Lock dies zulässt."
"die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen);die Synchronized-Anweisung der Form synchronized (<Ausdruck>) <Block>, die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem <Ausdruck> ausgewertet wird, verbundene Lock dies zulässt (siehe Abschnitt 47.3);",Was ist eine Try-Anweisung?,"Eine Try-Anweisung ist eine Programmstruktur, die versucht, einen bestimmten Block auszuführen, während sie verschiedene Arten von Laufzeitfehlern behandeln kann. Sie besteht aus einem Try-Block, einem oder mehreren Catch-Blöcken und einem optionalen Finally-Block. Der Try-Block enthält den Code, der versucht wird auszuführen. Die Catch-Blöcke enthalten Code, der ausgeführt wird, wenn ein Laufzeitfehler auftritt. Der Finally-Block enthält Code, der immer ausgeführt wird, unabhängig davon, ob ein Fehler aufgetreten ist oder nicht."
"die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen);die Synchronized-Anweisung der Form synchronized (<Ausdruck>) <Block>, die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem <Ausdruck> ausgewertet wird, verbundene Lock dies zulässt (siehe Abschnitt 47.3);",Was bewirkt die Throw-Anweisung in einem Programm?,"Die Throw-Anweisung lässt das Programm eine Exception werfen, was zu einer Ausnahmesituation führt."
"die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C. die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss; die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde; die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler); die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen);die Synchronized-Anweisung der Form synchronized (<Ausdruck>) <Block>, die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem <Ausdruck> ausgewertet wird, verbundene Lock dies zulässt (siehe Abschnitt 47.3);",Was bewirkt die Assert-Anweisung?,"Die Assert-Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn der angegebene Boolesche Ausdruck falsch ist. Sie kann auch verwendet werden, um zusätzliche Informationen auszugeben, wenn der Ausdruck wahr ist."
"Bemerkungen: Das Weglassen von break; am Ende einer Liste von Anweisungen in einem Case-Zweig der Switch-Anweisung wird als ""Fall durch"" bezeichnet und bewirkt, dass mit den Anweisungen des nächsten Case-Zweigs fortgefahren wird. Dies ermöglicht das Zusammenführen mehrerer Fälle, ist jedoch eines der fehlerträchtigsten Konstrukte C-artiger Sprachen. Die Assert-Anweisung kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen. Wenn der Ablauf des Programms von diesen Werten abhängt, macht es einen Unterschied, ob ein Programm mit oder ohne Prüfung der Assertions ausgeführt wird. Das ist ein starkes Stück.",Was ist die Assert-Anweisung und welche Wirkung kann sie haben?,"Die Assert-Anweisung ist eine Programmieranweisung, die dazu dient, bestimmte Bedingungen während der Ausführung eines Programms zu überprüfen. Sie kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen. Wenn der Ablauf des Programms von diesen Werten abhängt, macht es einen Unterschied, ob ein Programm mit oder ohne Prüfung der Assertions ausgeführt wird."
"Bemerkungen: Das Weglassen von break; am Ende einer Liste von Anweisungen in einem Case-Zweig der Switch-Anweisung wird als ""Fall durch"" bezeichnet und bewirkt, dass mit den Anweisungen des nächsten Case-Zweigs fortgefahren wird. Dies ermöglicht das Zusammenführen mehrerer Fälle, ist jedoch eines der fehlerträchtigsten Konstrukte C-artiger Sprachen. Die Assert-Anweisung kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen. Wenn der Ablauf des Programms von diesen Werten abhängt, macht es einen Unterschied, ob ein Programm mit oder ohne Prüfung der Assertions ausgeführt wird. Das ist ein starkes Stück.",Was sind die möglichen Seiteneffekte der Assert-Anweisung?,"Die Assert-Anweisung kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen."
"Assert-Anweisungen sind ein erster zarter Versuch, in Java auch noch andere Invarianten als die Typinvarianten unterzubringen. Dabei findet die Überprüfung dieser mittels assert eingebrachten Invarianten im Gegensatz zum Großteil der Typprüfung erst zur Laufzeit statt, indem die entsprechenden Statements ausgeführt werden. Dabei beziehen sich die Bedingungen, die die Invarianten formulieren, häufig auf Methoden des Programms, für die die Invarianten angegeben werden sollen. Da diese Methoden aber auch den Zustand des Programms ändern können, kann man einer Zusicherung mit assert nicht ansehen, ob sie seiteneffektfrei ist. Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden nicht als Anweisungen formuliert, sondern als Quellcodeannotationen und stellen zudem sicher, dass alle Zugriffe auf Programmelemente, die zur Laufzeit notwendig sind, den Zustand des Programms nicht verändern.",Was sind Assert-Anweisungen in Java?,"Assert-Anweisungen in Java sind ein Verfahren, um Invarianten in einem Programm zu überprüfen. Dabei werden die Bedingungen, die die Invarianten formulieren, zur Laufzeit überprüft, indem die entsprechenden Statements ausgeführt werden. Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden jedoch als Quellcodeannotationen formuliert und stellen sicher, dass alle Zugriffe auf Programmelemente den Zustand des Programms nicht verändern."
"Assert-Anweisungen sind ein erster zarter Versuch, in Java auch noch andere Invarianten als die Typinvarianten unterzubringen. Dabei findet die Überprüfung dieser mittels assert eingebrachten Invarianten im Gegensatz zum Großteil der Typprüfung erst zur Laufzeit statt, indem die entsprechenden Statements ausgeführt werden. Dabei beziehen sich die Bedingungen, die die Invarianten formulieren, häufig auf Methoden des Programms, für die die Invarianten angegeben werden sollen. Da diese Methoden aber auch den Zustand des Programms ändern können, kann man einer Zusicherung mit assert nicht ansehen, ob sie seiteneffektfrei ist. Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden nicht als Anweisungen formuliert, sondern als Quellcodeannotationen und stellen zudem sicher, dass alle Zugriffe auf Programmelemente, die zur Laufzeit notwendig sind, den Zustand des Programms nicht verändern.",Wozu werden Assert-Anweisungen in Java verwendet?,"Assert-Anweisungen in Java werden verwendet, um sicherzustellen, dass bestimmte Bedingungen während der Laufzeit erfüllt sind. Dabei werden die Bedingungen in Form von Statements formuliert, die zur Laufzeit ausgeführt werden. Assert-Anweisungen beziehen sich häufig auf Methoden des Programms, für die die Invarianten angegeben werden sollen. Allerdings können diese Methoden den Zustand des Programms ändern, weshalb man einer Zusicherung mit assert nicht ansehen kann, ob sie seiteneffektfrei ist."
"Klassendefinitionen bilden also eine Art Vorlage für Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht — sie ist gewissermaßen die Umkehrung der Klassifikation, also des Übergangs vom Individuum zu seiner Klasse (wobei die Klassifikation, anders als die Instanziierung, in der Programmierung kein Vorgang ist). Vom erzeugten Objekt sagt man dann, es sei Instanz dieser Klasse. Tatsächlich spricht man in SMALLTALK, da ja auch Klassen Objekte sind, häufig von Instanzen anstelle von Objekten, wenn keine Klassen gemeint sind. In SMALLTALK sind auch Klassen Instanzen. So gesehen handelt es sich bei den Begriffen Instanz und Klasse also eher um Rollen von Objekten, die im Verhältnis der Instanziierung zueinander stehen. Die Begriffsbildung der objektorientierten Programmierung ist an dieser Stelle aber leider nicht besonders gelungen.In SMALLTALK ist jedes Objekt Instanz genau einer Klasse. Genaugenommen ist es direkte Instanz genau einer Klasse. Dabei weiß jedes Objekt, von welcher Klasse es eine Instanz ist; diese Information lässt sich dem Objekt durch Senden der Nachricht class entlocken; der entsprechende Ausdruck liefert das Objekt, das die Klasse repräsentiert, zurück.Mit der Instanziierung wird der Extension einer Klasse ein neues Element hinzugefügt. Das Elementsein auf Mengenebene entspricht also in etwa dem Instanzsein auf programmiersprachlicher Ebene (in UML wie im obigen Diagramm durch einen gestrichelten Pfeil angedeutet). Wir werden noch öfter auf diese mengentheoretische Interpretation zurückkommen.",Was ist Instanziierung?,"Instanziierung ist der Prozess, bei dem ein neues Objekt einer bestimmten Klasse erstellt wird. Das neue Objekt wird eine Instanz dieser Klasse genannt und hat die Eigenschaften (Instanzvariablen und Methoden), die durch die Definition (Intension) der Klasse festgelegt sind."
"Klassendefinitionen bilden also eine Art Vorlage für Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht — sie ist gewissermaßen die Umkehrung der Klassifikation, also des Übergangs vom Individuum zu seiner Klasse (wobei die Klassifikation, anders als die Instanziierung, in der Programmierung kein Vorgang ist). Vom erzeugten Objekt sagt man dann, es sei Instanz dieser Klasse. Tatsächlich spricht man in SMALLTALK, da ja auch Klassen Objekte sind, häufig von Instanzen anstelle von Objekten, wenn keine Klassen gemeint sind. In SMALLTALK sind auch Klassen Instanzen. So gesehen handelt es sich bei den Begriffen Instanz und Klasse also eher um Rollen von Objekten, die im Verhältnis der Instanziierung zueinander stehen. Die Begriffsbildung der objektorientierten Programmierung ist an dieser Stelle aber leider nicht besonders gelungen.In SMALLTALK ist jedes Objekt Instanz genau einer Klasse. Genaugenommen ist es direkte Instanz genau einer Klasse. Dabei weiß jedes Objekt, von welcher Klasse es eine Instanz ist; diese Information lässt sich dem Objekt durch Senden der Nachricht class entlocken; der entsprechende Ausdruck liefert das Objekt, das die Klasse repräsentiert, zurück.Mit der Instanziierung wird der Extension einer Klasse ein neues Element hinzugefügt. Das Elementsein auf Mengenebene entspricht also in etwa dem Instanzsein auf programmiersprachlicher Ebene (in UML wie im obigen Diagramm durch einen gestrichelten Pfeil angedeutet). Wir werden noch öfter auf diese mengentheoretische Interpretation zurückkommen.",Was ist eine Instanz?,"In SMALLTALK ist jedes Objekt Instanz genau einer Klasse. Genaugenommen ist es direkte Instanz genau einer Klasse. Dabei weiß jedes Objekt, von welcher Klasse es eine Instanz ist."
"Die Objekte, die durch Literale repräsentiert werden, sind, da sie vom Compiler erzeugt werden, aus Sicht des Programms „schon da“, wenn es ausgeführt wird. Mittels Instanziierung und Klassen hat man nun die Möglichkeit, neue — und neuartige — Objekte programmatisch, also per Programmausführung, zu erzeugen. Dies geschieht standardmäßig, indem man der Klasse, von der man eine Instanz haben möchte, die Nachricht new (für Klassen ohne indizierte Instanzvariablen) oder new: (für Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert. Der Parameter der Nachricht von Objekten, nämlich solche, die instanziierbar sind, und solche, die es nicht sind. Instanziierbare Objekte sind immer (auch) Klassen; für solche, die es nicht sind, gibt es leider keine spezielle Bezeichnung. Man könnte sie jedoch Ebene-0-Objekte nennen.new: muss immer eine natürliche Zahl sein und legt die Anzahl der indizierten Instanzvariablen fest, über die ein Objekt verfügt. Hat ein Objekt (per Klassendefinition) keine indizierten Instanzvariablen, führt new: zu einem Laufzeitfehler.",Wie passiert in SMALLTALK die Instanziierung?,"In SMALLTALK wird normalerweise die Instanziierung eines Objekts durch Senden der Nachricht ""new"" (für Klassen ohne indizierte Instanzvariablen) oder ""new:"" (für Klassen mit indizierten Instanzvariablen) an die Klasse durchgeführt. Das neue Objekt wird im Speicher angelegt, und seine Instanzvariablen werden alle mit ""nil"" initialisiert."
"Eine Alternative zum Instanziieren ist übrigens das Klonen. Beim Klonen wird ein neues Objekt auf der Basis eines bereits existierenden erzeugt. Der Klon stellt also eine Kopie dar. Beim Klonvorgang ist festzulegen, wie weit (tief) das Kopieren gehen soll, also ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht (auf die die Instanzvariablen verweisen) kopiert werden sollen. Während in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse ja nicht kennen, Klonen die einzige Möglichkeit ist, neue Objekte zu erstellen, müssen bei Programmiersprachen mit Klassen, in denen jedes Objekt Instanz einer Klasse sein muss, Klone in der Regel durch Instanziierung und Übertragung der Inhalte der Instanzvariablen erzeugt werden. Da wir hier aber die klassenbasierte Linie verfolgen und auf klassenlose objektorientierte Programmiersprachen nur eingehen, wo dies interessant erscheint, werden wir das Klonen, das in klassenbasierten objektorientierten Programmiersprachen eine untergeordnete Rolle spielt, erst später vertiefen.",Welche Alternative gibt es zur Instanziierung?,Eine Alternative zur Instanziierung ist das Klonen.
"Eine Alternative zum Instanziieren ist übrigens das Klonen. Beim Klonen wird ein neues Objekt auf der Basis eines bereits existierenden erzeugt. Der Klon stellt also eine Kopie dar. Beim Klonvorgang ist festzulegen, wie weit (tief) das Kopieren gehen soll, also ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht (auf die die Instanzvariablen verweisen) kopiert werden sollen. Während in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse ja nicht kennen, Klonen die einzige Möglichkeit ist, neue Objekte zu erstellen, müssen bei Programmiersprachen mit Klassen, in denen jedes Objekt Instanz einer Klasse sein muss, Klone in der Regel durch Instanziierung und Übertragung der Inhalte der Instanzvariablen erzeugt werden. Da wir hier aber die klassenbasierte Linie verfolgen und auf klassenlose objektorientierte Programmiersprachen nur eingehen, wo dies interessant erscheint, werden wir das Klonen, das in klassenbasierten objektorientierten Programmiersprachen eine untergeordnete Rolle spielt, erst später vertiefen.",Was ist das Klonen?,"Das Klone ist ein Prozess, bei dem ein neues Objekt auf der Basis eines bereits existierenden Objekts erstellt wird. Der Klon ist eine Kopie des Originalobjekts. Beim Klonen muss festgelegt werden, wie tief die Kopie gehen soll, dh ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht, kopiert werden sollen. Während das Klonen in klassenbasierten objektorientierten Programmiersprachen in der Regel durch Instanziierung und Übertragung von Inhaltsdaten der Instanzvariablen erzeugt wird, erfolgt das Klonen in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse nicht kennen, durch einfaches Kopieren. In SMALLTALK wird die Instanziierung normalerweise bevorzugt, da es sich um eine klassenbasierte Sprache handelt."
"Java ist eine stark typisierte Sprache: Alle Ausdrücke haben einen Typ. Das gilt auch für Variablen, deren Typ bei ihrer Deklaration angegeben werden muss. In Java gibt es Variablen mit Referenz- und Wertsemantik. Welche Semantik eine Variable hat, richtet sich nach ihrem Typ. Typen, die zu Variablen mit Wertsemantik führen, sind die oben genannten primitiven, nämlich byte, short, int, long, float, double, boolean und char. Variablen, die mit einem anderen Typ deklariert werden, haben Referenzsemantik.",Was ist der Unterschied zwischen Referenz- und Wertsemantik in Java?,"In Java haben Variablen mit Referenzsemantik einen Wert, der auf ein Objekt verweist, während Variablen mit Wertsemantik den Wert direkt enthalten. Der Unterschied liegt darin, dass Variablen mit Referenzsemantik den Wert des Objekts nicht direkt enthalten, sondern nur eine Referenz auf das Objekt halten."
"Java ist eine stark typisierte Sprache: Alle Ausdrücke haben einen Typ. Das gilt auch für Variablen, deren Typ bei ihrer Deklaration angegeben werden muss. In Java gibt es Variablen mit Referenz- und Wertsemantik. Welche Semantik eine Variable hat, richtet sich nach ihrem Typ. Typen, die zu Variablen mit Wertsemantik führen, sind die oben genannten primitiven, nämlich byte, short, int, long, float, double, boolean und char. Variablen, die mit einem anderen Typ deklariert werden, haben Referenzsemantik.",Welche Semantik haben Variablen in Java?,"In Java haben Variablen entweder Referenz- oder Wertsemantik, je nachdem welchen Typ sie haben. Variablen mit primitiven Typen wie byte, short, int, long, float, double, boolean und char haben Wertsemantik, während Variablen mit anderen Typen Referenzsemantik haben."
"Java ist eine stark typisierte Sprache: Alle Ausdrücke haben einen Typ. Das gilt auch für Variablen, deren Typ bei ihrer Deklaration angegeben werden muss. In Java gibt es Variablen mit Referenz- und Wertsemantik. Welche Semantik eine Variable hat, richtet sich nach ihrem Typ. Typen, die zu Variablen mit Wertsemantik führen, sind die oben genannten primitiven, nämlich byte, short, int, long, float, double, boolean und char. Variablen, die mit einem anderen Typ deklariert werden, haben Referenzsemantik.",Was ist der Unterschied zwischen Variablen mit Wert- und Referenzsemantik in Java?,"In Java haben Variablen mit Wertsemantik einen konkreten Wert, während Variablen mit Referenzsemantik einen Verweis auf ein Objekt speichern. Wenn man eine Variable mit Referenzsemantik ändert, wird nur der Verweis geändert, nicht das Objekt selbst. Bei Variablen mit Wertsemantik hingegen wird der Wert direkt geändert."
"Variablen werden in Java genauso wie in SMALLTALK explizit per Zuweisungsoperator ""="" und implizit per Methodenaufruf Werte zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten.",Wie werden Variablen in Java Werte zugewiesen?,"In Java werden Variablen Werte explizit per Zuweisungsoperator ""="" und implizit per Methodenaufruf zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten."
"Variablen werden in Java genauso wie in SMALLTALK explizit per Zuweisungsoperator ""="" und implizit per Methodenaufruf Werte zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten.",Was ist der Unterschied zwischen Zuweisungen an Variablen primitiver Typen und solchen anderer Typen in Java?,"Bei Zuweisungen an Variablen primitiver Typen wird der Wert selbst kopiert, während bei Zuweisungen an Variablen anderer Typen eine Referenz auf das Objekt kopiert wird."
"In Java ist es nicht möglich, Pointervariablen explizit zu deklarieren. Daher gibt es insbesondere beim Methodenaufruf (und den damit verbundenen impliziten Zuweisungen) kein ""Call by reference"" in Java, sondern nur ein ""Call by value"". Dies ändert sich auch nicht, wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben. Weitere Informationen finden Sie auch in den Bemerkungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.",Wie funktioniert die Parameterübergabe in Java?,"In Java gibt es nur ""Call by value"", d.h. bei Methodenaufrufen werden immer Kopien der Werte an die formalen Parameter übergeben. Selbst wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben, werden bei Methodenaufrufen immer Kopien der Zeiger übergeben."
"In Java ist es nicht möglich, Pointervariablen explizit zu deklarieren. Daher gibt es insbesondere beim Methodenaufruf (und den damit verbundenen impliziten Zuweisungen) kein ""Call by reference"" in Java, sondern nur ein ""Call by value"". Dies ändert sich auch nicht, wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben. Weitere Informationen finden Sie auch in den Bemerkungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.",Wie werden Parameter in Java übergeben?,"In Java werden Parameter immer durch Wertübertragung übergeben, auch wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben."
"In Java ist es nicht möglich, Pointervariablen explizit zu deklarieren. Daher gibt es insbesondere beim Methodenaufruf (und den damit verbundenen impliziten Zuweisungen) kein ""Call by reference"" in Java, sondern nur ein ""Call by value"". Dies ändert sich auch nicht, wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben. Weitere Informationen finden Sie auch in den Bemerkungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.","Gibt es in Java ""Call by reference""?","Nein, in Java gibt es kein ""Call by reference"", sondern nur ""Call by value"". Bei Methodenaufrufen mit impliziten Zuweisungen wird immer eine Kopie des Zeigers an die formalen Parameter übergeben, auch wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben."
"Seit Java 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" bzw. ""Auto unboxing"". Dabei können jedoch, ähnlich wie bei der Handhabung bestimmter Werte als Objekte in SMALLTALK (siehe Abschnitt 1.4 in Kurseinheit 1), unerwartete Phänomene auftreten: Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, in Java sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte. Andernfalls können schwer zu findende Programmierfehler auftreten.",Was ist der Unterschied zwischen der equals-Methode und dem Test auf Identität (==) in Java?,"Die equals-Methode testet, ob zwei Objekte den gleichen Wert repräsentieren, während der Test auf Identität (==) prüft, ob zwei Objekte identisch sind."
"Seit Java 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" bzw. ""Auto unboxing"". Dabei können jedoch, ähnlich wie bei der Handhabung bestimmter Werte als Objekte in SMALLTALK (siehe Abschnitt 1.4 in Kurseinheit 1), unerwartete Phänomene auftreten: Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, in Java sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte. Andernfalls können schwer zu findende Programmierfehler auftreten.",Was ist Auto boxing und Auto unboxing in Java?,"Seit Java 5 können Werte primitiver Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" bzw. ""Auto unboxing"". Dabei ist es wichtig, in Java sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte, um unerwartete Phänomene zu vermeiden."
"Die Typisierung von Variablen (und anderen Programmelementen – wenn im nachfolgenden nur von Variablen die Rede ist, dann sind letztere meistens mitgemeint) soll also bewirken, dass in einem Programm jede Variable nur die Werte haben kann, für die sie (die Variable) vorgesehen ist (die Einhaltung der Typinvariante). Voraussetzung dafür ist zum einen, dass jeder Variable ein Typ zugeordnet ist, zum anderen, dass auch jedes Objekt sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Ersteres geschieht in sogenannten Variablendeklarationen, letzteres ergibt sich aus den zu einem Typsystem gehörenden Regeln zur Zuordnung eines Typs zu Ausdrücken, nämlich bei Literalen aus der Art des Literals, dessen Typ dem Compiler bekannt ist, bei der Instanziierung aus dem noch zu klärenden Zusammenhang von der instanziierten Klasse mit den Typen eines Programms sowie bei Nachrichtenausdrücken aus der Deklaration der dazugehörigen Methode, die ja (genau wie eine Variablendeklaration) angeben muss, welchen Typs die Objekte sind, die sie liefert.",Wozu dient die Typisierung von Variablen?,"Die Typisierung von Variablen soll bewirken, dass in einem Programm jede Variable nur die Werte haben kann, für die sie vorgesehen ist. Dafür muss jeder Variable ein Typ zugeordnet sein und jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ haben."
"Die Typisierung von Variablen (und anderen Programmelementen – wenn im nachfolgenden nur von Variablen die Rede ist, dann sind letztere meistens mitgemeint) soll also bewirken, dass in einem Programm jede Variable nur die Werte haben kann, für die sie (die Variable) vorgesehen ist (die Einhaltung der Typinvariante). Voraussetzung dafür ist zum einen, dass jeder Variable ein Typ zugeordnet ist, zum anderen, dass auch jedes Objekt sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Ersteres geschieht in sogenannten Variablendeklarationen, letzteres ergibt sich aus den zu einem Typsystem gehörenden Regeln zur Zuordnung eines Typs zu Ausdrücken, nämlich bei Literalen aus der Art des Literals, dessen Typ dem Compiler bekannt ist, bei der Instanziierung aus dem noch zu klärenden Zusammenhang von der instanziierten Klasse mit den Typen eines Programms sowie bei Nachrichtenausdrücken aus der Deklaration der dazugehörigen Methode, die ja (genau wie eine Variablendeklaration) angeben muss, welchen Typs die Objekte sind, die sie liefert.",Was ist die Typisierung von Variablen und wie wird sie erreicht?,"Die Typisierung von Variablen ist ein Konzept, bei dem jede Variable nur die Werte haben kann, für die sie vorgesehen ist. Sie wird erreicht, indem jeder Variablen ein Typ zugeordnet wird, und indem auch jedes Objekt sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Dies geschieht durch Variablendeklarationen, die Zuordnung von Typen zu Literalen, die Instanziierung von Klassen und die Deklaration von Methoden, die angeben muss, welchen Typs die Objekte sind, die sie liefert."
"Es bleibt die Frage nach den ebenfalls zu einem Typsystem gehörenden Typregeln, die von Ausdrücken einzuhalten sind, nämlich wie die Typkorrektheit bzw. andernfalls die Verletzung einer Typinvariante genau festgestellt wird. Es ist ja bereits klar, dass es dazu ausreicht, die Wertzuweisungen in einem Programm zu überprüfen. Diese Überprüfung findet in der Regel in Form der Feststellung der sog. Zuweisungskompatibilität statt. Die Sprachregelung ist hier leider nicht ganz einheitlich, aber im folgenden gehen wir davon aus, dass alle typisierten Sprachen den Begriff der Zuweisungskompatibilität kennen und sich lediglich in ihren Definitionen der Regeln, die für das Bestehen einer Zuweisungskompatibilität eingehalten werden müssen, unterscheiden. Vor allem darum wird es in den nächsten Kapiteln gehen.",Was ist Zuweisungskompatibilität?,"Zuweisungskompatibilität ist ein Begriff, der in typisierten Sprachen verwendet wird, um die Typkorrektheit von Wertzuweisungen zu überprüfen. Die Regeln, die für das Bestehen einer Zuweisungskompatibilität eingehalten werden müssen, können sich in verschiedenen Sprachen unterscheiden."
"Dann sind, unter der Annahme, dass 12 vom Typ Integer ist und true vom Typ Boolean, die Zuweisungen zulässig (da sie keine Typinvariante verletzen), hingegen nicht. Ist eine Zuweisung zulässig, dann spricht man auch von einer Zuweisungskompatibilität der beteiligten Typen. Die für das Programmieren relevante Implikation ist allerdings die umgekehrte: Wenn zwei Typen zuweisungskompatibel sind, dann gilt, dass eine entsprechende Zuweisung zulässig ist, also zu keiner Verletzung einer Typinvariante führt. Wie Sie noch sehen werden, verlangt Zuweisungskompatibilität keineswegs identische Typen; daraus ergibt sich aber eine sprachliche Uneindeutigkeit, die zunächst behoben werden muss.",Wann sind zwei Typen zuweisungskompatibel?,"Zwei Typen zuweisungskompatibel, wenn eine entsprechende Zuweisung zulässig ist, also zu keiner Verletzung einer Typinvariante führt."
"Dem Satz „a ist zuweisungskompatibel mit b“ kann man nicht eindeutig entnehmen, ob nun a b zugewiesen werden kann oder b a. Dass beides geht, ist nur dann der Fall, wenn die beteiligten Typen äquivalent in einem noch zu bestimmenden Sinne sind, was aber, wie schon gesagt, nicht unbedingt der Fall sein muss. Im Folgenden soll daher die Richtung der erlaubten Zuweisung so gelesen werden, dass beim Satz „a ist zuweisungskompatibel mit b“ die Zuweisung b := a zulässig ist. Die umgekehrte Richtung, a := b, kann ebenfalls zulässig sein; dies wird durch den Satz jedoch nicht ausgesagt. Zuweisungskompatibilität ist übrigens (in der Regel) eine transitive Eigenschaft: Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c, dann ist auch a zuweisungskompatibel mit c.","Was bedeutet es, wenn eine Variable a zuweisungskompatibel mit einer Variablen b ist?","Wenn eine Variable a zuweisungskompatibel mit einer Variablen b ist, dann bedeutet das, dass der Wert von b der Variablen a zugewiesen werden kann. Diese Zuweisungskompatibilität ist eine transitive Eigenschaft, d.h. wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c, dann ist auch a zuweisungskompatibel mit c."
"Auch bei impliziten Zuweisungen wie der Parameterübergabe von Methodenaufrufen (den dabei stattfindenden Zuweisungen der tatsächlichen an die formalen Parameter) impliziert Zuweisungskompatibilität Typkorrektheit. Außerdem kann eine Methode, wenn sie Werte zurückgibt, ja selbst in rechten Seiten von Zuweisungen auftreten; der Typ dieser Werte muss dann mit der Variable auf der linken Seite zuweisungskompatibel sein.",Was bedeutet Zuweisungskompatibilität?,"Zuweisungskompatibilität bedeutet, dass der Typ der Variablen auf der linken Seite einer Zuweisung mit dem Typ des Wertes auf der rechten Seite der Zuweisung kompatibel sein muss. Diese Kompatibilität impliziert Typkorrektheit, sowohl bei impliziten Zuweisungen wie der Parameterübergabe von Methodenaufrufen als auch bei expliziten Zuweisungen."
"Auch bei impliziten Zuweisungen wie der Parameterübergabe von Methodenaufrufen (den dabei stattfindenden Zuweisungen der tatsächlichen an die formalen Parameter) impliziert Zuweisungskompatibilität Typkorrektheit. Außerdem kann eine Methode, wenn sie Werte zurückgibt, ja selbst in rechten Seiten von Zuweisungen auftreten; der Typ dieser Werte muss dann mit der Variable auf der linken Seite zuweisungskompatibel sein.",Was bedeutet Zuweisungskompatibilität bei Methodenaufrufen?,"Zuweisungskompatibilität bei Methodenaufrufen bedeutet, dass die tatsächlichen Parameter bei der Übergabe an die formalen Parameter zuweisungskompatibel sein müssen. Das heißt, der Typ des tatsächlichen Parameters muss mit dem Typ des formalen Parameters übereinstimmen oder der tatsächliche Parameter muss in den formalen Parameter zuweisungskompatibel sein."
"Die Bedeutung der Subklassenbeziehung variiert von Sprache zu Sprache. Wie Sie sich vielleicht schon gedacht haben, kann man die Subklassenbeziehung mit der Spezialisierungsbeziehung gleichsetzen oder auch mit der Vererbung; es sind aber auch noch andere Definitionen möglich. Tatsächlich wird die hier eingeführte Beziehung zwischen Klassen, die als Subklassenbeziehung bezeichnet wird, nicht immer so genannt. Entsprechend heißen dann die Rollen auch nicht Sub- und Superklasse, sondern z. B. abgeleitete Klassen und Basisklassen. Im Englischen sind hierfür neben Derived class und Base class auch die Begriffe Child class bzw. Parent class in Gebrauch.",Wie wird die Subklassenbeziehung in verschiedenen Programmiersprachen bezeichnet?,"Die Subklassenbeziehung kann in verschiedenen Programmiersprachen mit Spezialisierungsbeziehung, Vererbung, abgeleitete Klassen und Basisklassen, Child class und Parent class gleichgesetzt werden."
"Die Bedeutung der Subklassenbeziehung variiert von Sprache zu Sprache. Wie Sie sich vielleicht schon gedacht haben, kann man die Subklassenbeziehung mit der Spezialisierungsbeziehung gleichsetzen oder auch mit der Vererbung; es sind aber auch noch andere Definitionen möglich. Tatsächlich wird die hier eingeführte Beziehung zwischen Klassen, die als Subklassenbeziehung bezeichnet wird, nicht immer so genannt. Entsprechend heißen dann die Rollen auch nicht Sub- und Superklasse, sondern z. B. abgeleitete Klassen und Basisklassen. Im Englischen sind hierfür neben Derived class und Base class auch die Begriffe Child class bzw. Parent class in Gebrauch.",Was ist die Subklassenbeziehung in der objektorientierten Programmierung?,"Die Subklassenbeziehung ist eine Beziehung zwischen Klassen, bei der eine Klasse eine Unterklasse einer anderen Klasse ist. Diese Beziehung kann auch als Spezialisierungsbeziehung oder Vererbung bezeichnet werden. Die Unterklasse erweitert oder spezialisiert die Oberklasse und erbt gleichzeitig ihre Eigenschaften und Methoden. Die Bezeichnungen für die Rollen der Klassen können je nach Programmiersprache variieren, wie zum Beispiel Sub- und Superklasse, abgeleitete Klasse und Basisklasse, oder Child- und Parent-Klasse."
"In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Eine Subklasse erbt demnach alle Instanzvariablen und Methoden ihrer Superklasse. Dass sie darüber hinaus auch noch ihre Klassenvariablen und -methoden erbt, ist nicht selbstverständlich. Wichtig ist hier, festzuhalten, dass durch eine existierende Subklassenbeziehung zwischen zwei Klassen nicht ausgedrückt wird, dass die Subklasse eine Spezialisierung der Superklasse ist oder gar die Superklasse eine Generalisierung der Subklasse. Dies sicherzustellen obliegt der Verantwortung des Programmierers.",Was ist die Subklassenbeziehung in SMALLTALK?,"In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt, d.h. eine Subklasse erbt alle Instanzvariablen und Methoden ihrer Superklasse. Es wird jedoch nicht ausgedrückt, dass die Subklasse eine Spezialisierung der Superklasse ist oder die Superklasse eine Generalisierung der Subklasse. Diese Sicherstellung obliegt der Verantwortung des Programmierers."
"In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Eine Subklasse erbt demnach alle Instanzvariablen und Methoden ihrer Superklasse. Dass sie darüber hinaus auch noch ihre Klassenvariablen und -methoden erbt, ist nicht selbstverständlich. Wichtig ist hier, festzuhalten, dass durch eine existierende Subklassenbeziehung zwischen zwei Klassen nicht ausgedrückt wird, dass die Subklasse eine Spezialisierung der Superklasse ist oder gar die Superklasse eine Generalisierung der Subklasse. Dies sicherzustellen obliegt der Verantwortung des Programmierers.",Was wird durch eine Subklassenbeziehung zwischen zwei Klassen ausgedrückt?,"Durch eine Subklassenbeziehung zwischen zwei Klassen wird ausgedrückt, dass die Subklasse alle Instanzvariablen und Methoden der Superklasse erbt. Es wird jedoch nicht ausgedrückt, dass die Subklasse eine Spezialisierung der Superklasse ist oder die Superklasse eine Generalisierung der Subklasse. Diese Sicherstellung obliegt der Verantwortung des Programmierers."
"Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet.",Wie wird in SMALLTALK eine neue Klasse erstellt und welche Superklasse muss angegeben werden?,"In SMALLTALK wird eine neue Klasse erstellt, indem man ihrer Superklasse eine entsprechende Nachricht sendet. Dabei ist es notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird."
"Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet.",Wie wird eine neue Klasse in SMALLTALK erstellt?,"Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben. Dazu muss beim Erzeugen einer neuen Klasse die Superklasse angegeben werden, indem man ihrer Superklasse eine entsprechende Nachricht sendet."
"Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet.",Wie werden in Smalltalk Klassen importiert?,"In Smalltalk gibt es keine explizite Möglichkeit, eine Klasse zu importieren. Stattdessen werden alle Klassen, die in einem SMALLTALK-System zur Verfügung stehen, in einem gemeinsamen Namensraum verwaltet."
"Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet.",Wie werden in Smalltalk Klassen in einem gemeinsamen Namensraum verwaltet?,"In Smalltalk werden alle Klassen, die in einem SMALLTALK-System zur Verfügung stehen, in einem gemeinsamen Namensraum verwaltet."
"Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet.",Wie werden in Smalltalk Klassen verwaltet?,"In Smalltalk werden alle Klassen, die in einem SMALLTALK-System zur Verfügung stehen, in einem gemeinsamen Namensraum verwaltet."
"Damit eine Subklassenbeziehung zwischen zwei Klassen zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden. Entsprechende Regeln in anderen Programmiersprachen können teilweise erheblich komplexer sein.",Was sind die Bedingungen für eine zulässige Subklassenbeziehung in SMALLTALK?,"Für eine zulässige Subklassenbeziehung zwischen zwei Klassen müssen deren Definitionen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden."
"Damit eine Subklassenbeziehung zwischen zwei Klassen zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden. Entsprechende Regeln in anderen Programmiersprachen können teilweise erheblich komplexer sein.",Welche Bedingungen müssen für eine zulässige Subklassenbeziehung erfüllt sein?,"Für eine zulässige Subklassenbeziehung müssen die Definitionen der Klassen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden."
"Damit eine Subklassenbeziehung zwischen zwei Klassen zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden. Entsprechende Regeln in anderen Programmiersprachen können teilweise erheblich komplexer sein.",Was muss bei der Definition einer Subklasse in SMALLTALK beachtet werden?,"In SMALLTALK müssen bei der Definition einer Subklasse neue, benannte Instanz- und Klassenvariablen andere Namen als Variablen in Superklassen haben und indizierte Instanzvariablen müssen vorhanden sein, wenn die Superklasse solche hat. Methodendefinitionen mit derselben Signatur überschreiben einfach die geerbten Methoden."
"Da die Subklassenbeziehung auch in SMALLTALK nicht reflexiv ist, muss es mindestens eine Klasse geben, die keine Subklasse ist (und entsprechend keine Superklasse hat). Dies ist die Klasse ""Object"", die oberste aller Superklassen. In ihr sind die Definitionen angelegt, die den Instanzen aller Klassen zugutekommen sollen (z. B. die Methode ""printString""). Diese Methoden werden per Vererbung auf alle anderen Klassen übertragen, wodurch sie deren Instanzen zur Verfügung stehen. Eine ganze Reihe nützlicher Methoden, die in ""Object"" definiert sind, werden wir in Kapitel 14 kennenlernen.","Was ist die Klasse ""Object"" in SMALLTALK?","Die Klasse ""Object"" ist die oberste Superklasse in SMALLTALK, von der alle anderen Klassen abgeleitet sind. Sie enthält Definitionen, die den Instanzen aller Klassen zugutekommen sollen, wie zum Beispiel die Methode ""printString"". Diese Methoden werden durch Vererbung auf alle anderen Klassen übertragen, wodurch sie deren Instanzen zur Verfügung stehen."
"Zuweisungskompatibilität unter Subtyping erlaubt also die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps. Für die statische Typprüfung ergibt sich daraus kein Problem, weil sichergestellt ist, dass die Subtypen alle Eigenschaften ihrer Supertypen erhalten, so dass keine Typfehler auftreten können. Für die Programmiererin ergibt sich aber manchmal das Problem, dass sie ein Objekt, auf das eine Variable eines Supertyps verweist, wie ein Objekt seines tatsächlichen Typs verwenden möchte, in der Regel, weil sie eine Methode darauf aufrufen möchte, die der Supertyp nicht hat. Genau diesen Methodenaufruf würde die Typprüfung aber zurückweisen.",Was ist Zuweisungskompatibilität unter Subtyping?,Zuweisungskompatibilität unter Subtyping erlaubt die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps.
"Zuweisungskompatibilität unter Subtyping erlaubt also die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps. Für die statische Typprüfung ergibt sich daraus kein Problem, weil sichergestellt ist, dass die Subtypen alle Eigenschaften ihrer Supertypen erhalten, so dass keine Typfehler auftreten können. Für die Programmiererin ergibt sich aber manchmal das Problem, dass sie ein Objekt, auf das eine Variable eines Supertyps verweist, wie ein Objekt seines tatsächlichen Typs verwenden möchte, in der Regel, weil sie eine Methode darauf aufrufen möchte, die der Supertyp nicht hat. Genau diesen Methodenaufruf würde die Typprüfung aber zurückweisen.",Warum ist Zuweisungskompatibilität unter Subtyping möglich?,"Zuweisungskompatibilität unter Subtyping ist möglich, weil Subtypen alle Eigenschaften ihrer Supertypen erben und somit keine Typfehler auftreten können."
"Für diesen Zweck gibt es die Möglichkeit der Typumwandlung (engl. type cast). Eine Typumwandlung ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen konvertiert wird. Mit dem Objekt, für das der Ausdruck steht, passiert dabei gar nichts — es wird lediglich der Compiler (bzw. der Type Checker) davon überzeugt, dass der Ausdruck den bei der Umwandlung angegebenen Typ hat. Sollte sich zur Laufzeit herausstellen, dass das nicht der Fall ist, kann ein Laufzeittypsystem — soweit vorhanden — dies bei seiner dynamischen Typprüfung bemerken und ggf. einen entsprechenden Fehler melden (vgl. die Anmerkungen dazu in Kapitel 18).",Was ist eine Typumwandlung?,"Eine Typumwandlung ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks in einen vorgegebenen konvertiert wird. Dabei passiert mit dem Objekt selbst nichts, sondern nur der Compiler wird davon überzeugt, dass der Ausdruck den angegebenen Typ hat."
"Typumwandlungen können grundsätzlich in verschiedene Richtungen erfolgen: zu Supertypen, zu Subtypen oder zu solchen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Man spricht entsprechend von Upcast, Downcast oder Crosscast. Upcasts sind immer typsicher, Downcasts und Crosscasts nicht. Downcasts sind relativ häufig; sie kommen vor allem dort vor, wo kein parametrischer Polymorphismus (Kapitel 29) zur Verfügung steht oder wo ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten; in der interfacebasierten Programmierung stehen sie für einen Rollenwechsel eines Objekts.",Was ist ein Upcast in der Typumwandlung?,Ein Upcast ist eine Typumwandlung von einem Typ zu einem Supertyp. Upcasts sind immer typsicher.
"Typumwandlungen können grundsätzlich in verschiedene Richtungen erfolgen: zu Supertypen, zu Subtypen oder zu solchen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Man spricht entsprechend von Upcast, Downcast oder Crosscast. Upcasts sind immer typsicher, Downcasts und Crosscasts nicht. Downcasts sind relativ häufig; sie kommen vor allem dort vor, wo kein parametrischer Polymorphismus (Kapitel 29) zur Verfügung steht oder wo ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten; in der interfacebasierten Programmierung stehen sie für einen Rollenwechsel eines Objekts.","Was ist der Unterschied zwischen Upcast, Downcast und Crosscast?","Upcasts sind Typumwandlungen zu Supertypen, Downcasts sind Typumwandlungen zu Subtypen und Crosscasts sind Typumwandlungen zu Typen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Upcasts sind immer typsicher, Downcasts und Crosscasts hingegen nicht. Downcasts werden häufig verwendet, wenn kein parametrischer Polymorphismus zur Verfügung steht oder wenn ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten und stehen für einen Rollenwechsel eines Objekts."
"Nun sind Typumwandlungen entweder überflüssig oder unsicher. Man sollte daher versuchen, auf sie zu verzichten. Wo unverzichtbar, sollten Typumwandlungen mit einem Typtest abgesichert werden. Dabei wird zur Laufzeit geprüft, ob das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat. Ist das nicht der Fall, sollten die Teile des Programms, die den bei der Typumwandlung genannten Typ voraussetzen, nicht ausgeführt werden. Sie werden in späteren Kapiteln zu den einzelnen Programmiersprachen noch Beispiele für diese Praxis zu sehen bekommen.",Was ist der Zweck von Typumwandlungen in der Programmierung?,"Typumwandlungen sind in der Programmierung entweder überflüssig oder unsicher. Wenn sie unverzichtbar sind, sollten sie mit einem Typtest abgesichert werden, um sicherzustellen, dass das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat."
"Nun sind Typumwandlungen entweder überflüssig oder unsicher. Man sollte daher versuchen, auf sie zu verzichten. Wo unverzichtbar, sollten Typumwandlungen mit einem Typtest abgesichert werden. Dabei wird zur Laufzeit geprüft, ob das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat. Ist das nicht der Fall, sollten die Teile des Programms, die den bei der Typumwandlung genannten Typ voraussetzen, nicht ausgeführt werden. Sie werden in späteren Kapiteln zu den einzelnen Programmiersprachen noch Beispiele für diese Praxis zu sehen bekommen.",Warum sollte man auf Typumwandlungen verzichten?,"Typumwandlungen können überflüssig oder unsicher sein. Daher ist es besser, auf sie zu verzichten, um Fehler zu vermeiden. Wenn sie unverzichtbar sind, sollten sie mit einem Typtest abgesichert werden, um sicherzustellen, dass das Objekt, für das der typgewandelte Ausdruck steht, den gewünschten Typ hat."
"Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit immer dann fraglich ist, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies soll nun etwas genauer beleuchtet werden.",Was ist Substituierbarkeit in Bezug auf Typerweiterung und Typeinschränkung?,"Substituierbarkeit bedeutet, dass ein Objekt eines Typs durch ein Objekt eines anderen Typs ersetzt werden kann, ohne dass die Korrektheit des Programms beeinträchtigt wird. Wenn eine Typerweiterung vorliegt, ist die Substituierbarkeit in der Regel unproblematisch. Wenn jedoch eine Typeinschränkung vorliegt, kann die Substituierbarkeit fraglich sein, da das ersetzende Objekt möglicherweise nicht die gleichen Eigenschaften und Methoden aufweist wie das ursprüngliche Objekt."
"Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit immer dann fraglich ist, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies soll nun etwas genauer beleuchtet werden.","Was ist fraglich bei der Substituierbarkeit, wenn es sich um eine Typeinschränkung handelt?","Wenn es sich um eine Typeinschränkung handelt, ist die Substituierbarkeit fraglich."
"Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit immer dann fraglich ist, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies soll nun etwas genauer beleuchtet werden.",Wann ist die Substituierbarkeit fraglich?,"Die Substituierbarkeit ist fraglich, wenn die neue Klasse eine Eigenschaft besitzt, die die alte Klasse nicht besitzt."
"In Java ist die Klasse Stack als Subklasse der Klasse Vector definiert, wobei Vector kein Vektor im mathematischen Sinne ist, sondern eher ein dynamisches Array, das in seiner Größe wachsen kann. Dies führt jedoch dazu, dass an Stellen im Programm, an denen eine indizierte Sammlung von Objekten mit wahlfreiem Zugriff erwartet wird (also ein Objekt vom Typ Vector), ein Objekt vom Typ Stack auftauchen kann. Obwohl Stack intern möglicherweise auf einem dynamischen Array ähnlich Vector aufbaut (und daher von Vector erbt), muss es an seiner öffentlich zugänglichen Schnittstelle die Funktionen für den wahlfreien Zugriff unterdrücken. In Java ist dies jedoch nicht möglich. Sollte das Programm also, in Erwartung einer indizierten Sammlung, auf ein Element zugreifen und stattdessen einen Stack vorfinden, kann das Programm nicht fortgesetzt werden, es sei denn, es findet vor dem Zugriff eine entsprechende Prüfung (und möglicherweise eine Verzweigung zu alternativen Verfahren) statt. Eine solche Prüfung muss jedoch zur Laufzeit erfolgen, und wenn sie vergessen wird (nicht implementiert), kann dies zu einem schwerwiegenden Programmierfehler führen. Solche Fehler lassen sich einfach vermeiden, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.",Warum können in Java abgeleitete Typen keine Eigenschaften unterdrücken?,"In Java können abgeleitete Typen keine Eigenschaften unterdrücken, weil es in Java nicht möglich ist, die öffentlich zugängliche Schnittstelle eines abgeleiteten Typs von der des Basistyps zu unterscheiden. Wenn ein Objekt vom Typ Stack in einem Programmabschnitt erwartet wird, in dem ein Objekt vom Typ Vector auftauchen kann, kann das Programm nicht fortgesetzt werden, wenn es auf ein Element zugreifen will, wenn stattdessen ein Stack vorliegt. Eine solche Prüfung muss zur Laufzeit erfolgen, und wenn sie vergessen wird, kann dies zu einem schwerwiegenden Programmierfehler führen. Solche Fehler lassen sich einfach vermeiden, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken."
"Eine schwächere Variante, die jedoch ähnlich katastrophale Folgen haben kann und deren Vorliegen nur schwer festzustellen ist, tritt auf, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht. Dies ist beispielsweise bei den beiden Typen Set (Menge) und Bag (Multimenge) der Fall. Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist. Die Funktionen ""Hinzufügen eines Elements"", ""Entfernen eines Elements"" sowie die Angabe der Größe und der Test auf das Vorhandensein eines Elements werden von Set genauso unterstützt wie von Bag. Der einzige Unterschied scheint zu sein, dass das Hinzufügen eines bereits vorhandenen Elements in der Menge von Set keine Veränderung bewirkt.","Was ist eine mögliche Folge davon, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht?","Eine mögliche Folge davon ist, dass das Verhalten des Programms schwer vorherzusagen und zu verstehen ist, was zu Fehlern und unerwarteten Ergebnissen führen kann."
"Eine schwächere Variante, die jedoch ähnlich katastrophale Folgen haben kann und deren Vorliegen nur schwer festzustellen ist, tritt auf, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht. Dies ist beispielsweise bei den beiden Typen Set (Menge) und Bag (Multimenge) der Fall. Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist. Die Funktionen ""Hinzufügen eines Elements"", ""Entfernen eines Elements"" sowie die Angabe der Größe und der Test auf das Vorhandensein eines Elements werden von Set genauso unterstützt wie von Bag. Der einzige Unterschied scheint zu sein, dass das Hinzufügen eines bereits vorhandenen Elements in der Menge von Set keine Veränderung bewirkt.",Was ist der Unterschied zwischen Set und Bag?,"Set und Bag sind zwei verschiedene Datentypen. Set ist eine Menge, die nur einmal jedes Element enthalten kann, während Bag eine Multimenge ist, die mehrere Vorkommen desselben Elements enthalten kann."
"Eine schwächere Variante, die jedoch ähnlich katastrophale Folgen haben kann und deren Vorliegen nur schwer festzustellen ist, tritt auf, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht. Dies ist beispielsweise bei den beiden Typen Set (Menge) und Bag (Multimenge) der Fall. Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist. Die Funktionen ""Hinzufügen eines Elements"", ""Entfernen eines Elements"" sowie die Angabe der Größe und der Test auf das Vorhandensein eines Elements werden von Set genauso unterstützt wie von Bag. Der einzige Unterschied scheint zu sein, dass das Hinzufügen eines bereits vorhandenen Elements in der Menge von Set keine Veränderung bewirkt.","Was passiert, wenn man Set als Subtyp von Bag annimmt?","Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist."
"Bei genauerer Betrachtung ergibt sich jedoch das Problem, dass Set durch seine Eigenheit mehrere charakteristische Eigenschaften von Multimengen verletzt. Zum Beispiel gilt für Sets nicht wie für Bags, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden; doppelte Einfügungen werden von Set einfach ignoriert. Ein Programm, das auf die Eigenschaften von Bags setzt und stattdessen mit einem Set arbeiten muss, funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.",Was sind die Eigenschaften von Sets?,"Sets sind eine Datenstruktur, die die Eigenschaften besitzt, dass jedes Hinzufügen eines Elements die Größe nicht unbedingt um 1 erhöht und dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden. Doppelte Einfügungen werden von Sets einfach ignoriert."
"Bei genauerer Betrachtung ergibt sich jedoch das Problem, dass Set durch seine Eigenheit mehrere charakteristische Eigenschaften von Multimengen verletzt. Zum Beispiel gilt für Sets nicht wie für Bags, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden; doppelte Einfügungen werden von Set einfach ignoriert. Ein Programm, das auf die Eigenschaften von Bags setzt und stattdessen mit einem Set arbeiten muss, funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.",Was sind die charakteristischen Eigenschaften von Multimengen (Bags)?,"Die charakteristischen Eigenschaften von Multimengen (Bags) sind, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht und dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden."
"Umgekehrt würde, wenn man Bag als Subtyp von Set annähme, die für Set charakteristische Eigenschaft verletzt, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden.","Was ist ein mögliches Problem, wenn man Bag als Subtyp von Set annimmt?","Wenn man Bag als Subtyp von Set annimmt, kann dies dazu führen, dass die für Set charakteristische Eigenschaft verletzt wird, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden."
"Umgekehrt würde, wenn man Bag als Subtyp von Set annähme, die für Set charakteristische Eigenschaft verletzt, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden.","Was ist der Grund für den Typfehler, wenn man Bag als Subtyp von Set annimmt?","Der Grund für den Typfehler ist, dass die für Set charakteristische Eigenschaft verletzt wird, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt."
"Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des jeweils anderen implizieren, und dass sie sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" bilden, wobei die Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird. Dies entspricht jedoch genau der Definition des Subtypings aus Kurseinheit 3, Abschnitt 26.1. Tatsächlich ist es mehr oder weniger eine Frage der Interpretation, ob die in Kapitel 26 genannten syntaktischen Bedingungen, insbesondere die Ko- und Kontravarianz, für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen.",Was ist das Problem bei der Definition von Subtypen für Bag und Set?,"Die charakteristischen Eigenschaften von Bag und Set stehen im Widerspruch zueinander, so dass sich keine korrekten Aussagen bilden lassen, die für alle Objekte vom Typ X gelten sollen, die auch die vom jeweils anderen Typen Y einschließen. Dies steht im Widerspruch zur Definition des Subtypings, daher ist es eine Frage der Interpretation, ob die syntaktischen Bedingungen für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen."
"Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des jeweils anderen implizieren, und dass sie sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" bilden, wobei die Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird. Dies entspricht jedoch genau der Definition des Subtypings aus Kurseinheit 3, Abschnitt 26.1. Tatsächlich ist es mehr oder weniger eine Frage der Interpretation, ob die in Kapitel 26 genannten syntaktischen Bedingungen, insbesondere die Ko- und Kontravarianz, für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen.",Was ist das Problem bei der Definition von Subtypen?,"Das Problem bei der Definition von Subtypen ist, dass die charakteristischen Eigenschaften eines Typs nicht die des anderen implizieren und sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen bilden, die Objekte vom Typ X einschließen sollen, die auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird."
"Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des jeweils anderen implizieren, und dass sie sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" bilden, wobei die Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird. Dies entspricht jedoch genau der Definition des Subtypings aus Kurseinheit 3, Abschnitt 26.1. Tatsächlich ist es mehr oder weniger eine Frage der Interpretation, ob die in Kapitel 26 genannten syntaktischen Bedingungen, insbesondere die Ko- und Kontravarianz, für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen.","Warum können keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" gebildet werden, wobei die Objekte vom Typ X immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird?","Die charakteristischen Eigenschaften der beiden Typen Bag und Set stehen im Widerspruch zueinander, daher lassen sich keine korrekten Aussagen bilden, die die Eigenschaften beider Typen implizieren."
"In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren in Form der Prüfung der Typkonformität immer nur angenähert. Tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen werden, wenn mangelnde Typkonformität vorliegt. Dennoch werden entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet jedoch Typkonformität nicht automatisch auch Substituierbarkeit. Dazu ist auch eine Betrachtung des Verhaltens notwendig.",Was ist der Unterschied zwischen Typkonformität und Substituierbarkeit?,"Typkonformität bedeutet, dass ein Objekt dem erwarteten Typ entspricht, während Substituierbarkeit bedeutet, dass ein Objekt anstelle eines anderen Objekts verwendet werden kann, ohne dass sich das Verhalten des Programms ändert. Typkonformität ist eine notwendige, aber nicht hinreichende Bedingung für Substituierbarkeit."
"In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren in Form der Prüfung der Typkonformität immer nur angenähert. Tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen werden, wenn mangelnde Typkonformität vorliegt. Dennoch werden entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet jedoch Typkonformität nicht automatisch auch Substituierbarkeit. Dazu ist auch eine Betrachtung des Verhaltens notwendig.",Was bedeutet Typkonformität nicht automatisch auch Substituierbarkeit?,"Typkonformität bedeutet nicht automatisch auch Substituierbarkeit, weil auch bei Typkonformität das Verhalten der Objekte verglichen werden muss, um sicherzustellen, dass die Substituierbarkeit gegeben ist."
"Wenn in dieser Kurseinheit bislang ausschließlich von Typen die Rede war und Klassen dabei ignoriert wurden, so hat das gute Gründe: Während eine Klasse die Implementierung ihrer Objekte festlegt, ist eine Typdefinition vollkommen frei von Implementierungsaspekten. Zwar können auch abstrakte Klassen ausschließlich aus Methodendeklarationen bestehen, also ohne jeden Implementierungsanteil, aber auch ihr Zweck ist in der Regel, zumindest eine partielle Implementierung vorzugeben, die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können. Schließlich drückt die Klassenhierarchie ja eine „genetische“ Verwandtschaft aus (s. Abschnitt 10.1 und Kapitel 11). Eine Typprüfung soll aber ohne Ansehen der Implementierung stattfinden; sie baut daher auf abstrakte Spezifikationen, eben auf Typen.",Was ist der Unterschied zwischen Klassen und Typen?,"Klassen definieren die Implementierung ihrer Objekte, während Typen frei von Implementierungsaspekten sind. Typen sind abstrakte Spezifikationen, die auf eine Typprüfung ohne Ansehen der Implementierung abzielen. Klassen können zumindest eine partielle Implementierung vorgeben, die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können."
"Es sind also Typen abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. Im Gegensatz dazu sind Klassen Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Da Objekte aber auch den Wertebereich von Typen ausmachen, stellt sich natürlich die Frage, welcher Art der Zusammenhang zwischen Typen und Klassen ist.",Was ist der Zusammenhang zwischen Typen und Klassen?,"Typen sind abstrakte Spezifikationen, die den Wertebereich von Variablen einschränken und das Protokoll von Objekten angeben. Klassen hingegen sind Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Objekte können den Wertebereich von Typen ausmachen, weshalb es eine enge Beziehung zwischen Typen und Klassen gibt."
"Es sind also Typen abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. Im Gegensatz dazu sind Klassen Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Da Objekte aber auch den Wertebereich von Typen ausmachen, stellt sich natürlich die Frage, welcher Art der Zusammenhang zwischen Typen und Klassen ist.",Was ist der Unterschied zwischen Typen und Klassen?,"Typen sind abstrakte Spezifikationen, die den Wertebereich von Variablen einschränken und das Protokoll von Objekten angeben. Klassen hingegen sind Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Objekte können den Wertebereich von Typen ausmachen, aber Typen und Klassen sind nicht dasselbe."
"Es fällt zunächst auf, dass bestimmte Elemente einer Klassendefinition auch in einer Typdefinition auftauchen. Im Einzelnen sind dies: ein (eindeutiger) Name, ein zweiter Name, von dessen dazugehöriger Definition abgeleitet wird sowie eine Menge von Methodennamen, jeweils mit einer Anzahl formaler Parameter.",Welche Gemeinsamkeiten gibt es zwischen einer Klassendefinition und einer Typdefinition?,"Sowohl in einer Klassendefinition als auch in einer Typdefinition gibt es einen eindeutigen Namen, einen zweiten Namen, von dessen dazugehöriger Definition abgeleitet wird, sowie eine Menge von Methodennamen mit einer Anzahl formaler Parameter."
"Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in Java oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).",Wie werden Typen in SMALLTALK verwendet?,"In SMALLTALK werden keine Typen verwendet. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht."
"Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in Java oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).",Wie ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen in STRONGTALK?,"In STRONGTALK sind die formalen Parameter der Methoden in den Klassendefinitionen typisiert, was die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer macht."
"Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in Java oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).",Können Instanzvariablen ein Bestandteil einer Typdefinition in STRONGTALK sein?,"Nein, anders als z. B. in Java oder C++, können Instanzvariablen kein Bestandteil einer Typdefinition in STRONGTALK sein."
"Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in Java oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).",Wie werden Typen in Smalltalk definiert?,"In Smalltalk werden keine Typen verwendet, stattdessen findet man in Smalltalk-Programmen manchmal Namen wie ""aString"", ""anInteger"" etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht."
"Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in Java oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).",Was ist der Unterschied zwischen Klassendefinitionen in Smalltalk und Strongtalk?,"In Smalltalk werden in Klassendefinitionen keine Typen verwendet, während in Strongtalk die formalen Parameter der Methoden in den Klassendefinitionen typisiert sind. Zudem können in Strongtalk Instanzvariablen kein Bestandteil einer Typdefinition sein, im Gegensatz zu Java oder C++."
"Nun dient ja ein Typsystem in der objektorientierten Programmierung vor allem der Sicherstellung des Umstands, dass alle von einem Objekt aufgrund des deklarierten Typs der Variablen, die es benennt, erwarteten Eigenschaften (Methoden) bei diesem Objekt auch vorhanden sind. Dies ist aber immer dann der Fall, wenn sich die Elemente der Typdefinition in der Klassendefinition des Objekts wiederfinden, die Klassendefinition also mit der Typdefinition gewissermaßen strukturell konform ist, so dass die Zuweisung einer Instanz der Klasse an eine Variable des Typs die Anforderungen der Zuweisungskompatibilität erfüllt. Um einen Compiler diese Zuweisungskompatibilität auf einfachere Weise als die Prüfung der Strukturkonformität, die ja eine rekursive Expansion der Typdefinitionen erfordert, feststellen zu lassen, gibt es zwei Möglichkeiten (bei beiden handelt es sich gewissermaßen um Varianten einer Namenskonformität): Jede Klasse sagt explizit, mit welchen Typen sie konform ist, oder: Jede Klasse spezifiziert implizit selbst einen Typ.",Wozu dient ein Typsystem in der objektorientierten Programmierung?,"Ein Typsystem in der objektorientierten Programmierung dient der Sicherstellung, dass alle von einem Objekt aufgrund des deklarierten Typs der Variablen, die es benennt, erwarteten Eigenschaften (Methoden) bei diesem Objekt auch vorhanden sind."
"Im ersten Fall müsste der Compiler noch prüfen, ob eine Klasse tatsächlich auch über alle Eigenschaften der von ihr genannten Typen verfügt; im zweiten Fall ist das automatisch der Fall, da der Typ ja gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den allermeisten typisierten, objektorientierten Programmiersprachen bevorzugt, doch auch die erste kommt in populären Sprachen vor: So kann beispielsweise in Java und C-Sharp jede Klasse angeben, mit Variablen welcher Interface-Typen ihre Instanzen zuweisungskompatibel sein sollen. Auch STRONGTALK stellt beide Möglichkeiten zur Verfügung.",Was ist der Unterschied zwischen den beiden Arten von Typisierung in STRONGTALK?,"STRONGTALK bietet zwei Arten von Typisierung: Die erste Art erfordert vom Compiler eine Prüfung, ob eine Klasse tatsächlich über alle Eigenschaften der von ihr genannten Typen verfügt. Bei der zweiten Art ist diese Prüfung automatisch der Fall, da der Typ gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den meisten typisierten, objektorientierten Programmiersprachen bevorzugt, während die erste Art in Sprachen wie Java und C-Sharp vorkommt."
"Im ersten Fall müsste der Compiler noch prüfen, ob eine Klasse tatsächlich auch über alle Eigenschaften der von ihr genannten Typen verfügt; im zweiten Fall ist das automatisch der Fall, da der Typ ja gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den allermeisten typisierten, objektorientierten Programmiersprachen bevorzugt, doch auch die erste kommt in populären Sprachen vor: So kann beispielsweise in Java und C-Sharp jede Klasse angeben, mit Variablen welcher Interface-Typen ihre Instanzen zuweisungskompatibel sein sollen. Auch STRONGTALK stellt beide Möglichkeiten zur Verfügung.",Was ist der Unterschied zwischen den zwei Arten von Typisierung in objektorientierten Programmiersprachen?,"Die zwei Arten von Typisierung in objektorientierten Programmiersprachen sind: die statische Typisierung und die dynamische Typisierung. Bei der statischen Typisierung muss der Compiler prüfen, ob eine Klasse tatsächlich über alle Eigenschaften der von ihr genannten Typen verfügt. Bei der dynamischen Typisierung ist das automatisch der Fall, da der Typ gewissermaßen aus der Klasse erzeugt wird."
"Man kann zwischen veränderlichen und unveränderlichen Objekten unterscheiden. Veränderungen an veränderlichen Objekten erfolgen im Laufe der Zeit, und die Objekte ändern dabei ihren Zustand. Unveränderliche Objekte hingegen haben keinen Zustand.Der Zustand eines Objektes setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert. Darüber hinaus folgt daraus, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, in der Zuweisung von Instanzvariablen liegt, was gleichbedeutend mit der Änderung seiner Beziehungen ist.",Was unterscheidet veränderliche und unveränderliche Objekte?,"Veränderliche Objekte können ihren Zustand im Laufe der Zeit ändern, während unveränderliche Objekte keinen Zustand haben und ihre Werte konstant bleiben."
"Man kann zwischen veränderlichen und unveränderlichen Objekten unterscheiden. Veränderungen an veränderlichen Objekten erfolgen im Laufe der Zeit, und die Objekte ändern dabei ihren Zustand. Unveränderliche Objekte hingegen haben keinen Zustand.Der Zustand eines Objektes setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert. Darüber hinaus folgt daraus, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, in der Zuweisung von Instanzvariablen liegt, was gleichbedeutend mit der Änderung seiner Beziehungen ist.",Was ist der Zustand eines Objekts?,"Der Zustand eines Objekts setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert."
"Man kann zwischen veränderlichen und unveränderlichen Objekten unterscheiden. Veränderungen an veränderlichen Objekten erfolgen im Laufe der Zeit, und die Objekte ändern dabei ihren Zustand. Unveränderliche Objekte hingegen haben keinen Zustand.Der Zustand eines Objektes setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert. Darüber hinaus folgt daraus, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, in der Zuweisung von Instanzvariablen liegt, was gleichbedeutend mit der Änderung seiner Beziehungen ist.",Wie wird der Zustand eines Objekts verändern?,"Die einzige Möglichkeit, den Zustand eines Objekts zu ändern, besteht darin, die Werte seiner Instanzvariablen zuzuweisen, was gleichbedeutend mit der Änderung seiner Beziehungen ist."
"Ein interessantes Konzept von C++, das einen direkten Bezug zur objektorientierten Programmierung hat, ist das Friends-Konzept. In der Praxis kommt es häufig vor, dass ein bestimmtes Teilproblem nicht von einer Klasse allein, sondern nur durch das Zusammenwirken mehrerer Klassen gelöst werden kann. Während diese Klassen untereinander eng kooperieren müssen und deshalb (relativ) intime Kenntnis voneinander benötigen (das heißt, auf Elemente zugreifen können müssen, die anderen Klassen verborgen bleiben sollen), gilt das für andere Klassen nicht unbedingt. Die Schnittstelle solcher kooperierenden Klassen sollte also nicht absolut, sondern relativ zu anderen Klassen definierbar sein.",Was ist das Friends-Konzept in C++?,"Das Friends-Konzept in C++ ist ein Mechanismus, der eine enge Kooperation zwischen Klassen ermöglicht. Dabei kann eine Klasse auf Elemente einer anderen Klasse zugreifen, die anderen Klassen verborgen bleiben sollen. Die Schnittstelle solcher kooperierender Klassen kann somit relativ zu anderen Klassen definiert werden."
"Ein interessantes Konzept von C++, das einen direkten Bezug zur objektorientierten Programmierung hat, ist das Friends-Konzept. In der Praxis kommt es häufig vor, dass ein bestimmtes Teilproblem nicht von einer Klasse allein, sondern nur durch das Zusammenwirken mehrerer Klassen gelöst werden kann. Während diese Klassen untereinander eng kooperieren müssen und deshalb (relativ) intime Kenntnis voneinander benötigen (das heißt, auf Elemente zugreifen können müssen, die anderen Klassen verborgen bleiben sollen), gilt das für andere Klassen nicht unbedingt. Die Schnittstelle solcher kooperierenden Klassen sollte also nicht absolut, sondern relativ zu anderen Klassen definierbar sein.",Wofür wird das Friends-Konzept in C++ verwendet?,"Das Friends-Konzept wird verwendet, um die Schnittstelle von kooperierenden Klassen relativ zu anderen Klassen definieren zu können, indem es den Zugriff auf private und protected Elemente erlaubt, die anderen Klassen verborgen bleiben sollen."
"In Java hatte man dazu bis zur Version 8 nur die Möglichkeit, die besagten Klassen in ein Paket zu verfrachten und die fraglichen Elemente mit paketweitem Zugriff (also ohne Zugriffsmodifizierer) zu deklarieren (Abschnitt 39.1 in Kurseinheit 4). Das hat jedoch den Nachteil, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben; wenn es eine Klasse gibt, die eine ansonsten unsichtbare Eigenschaft x einer Klasse A sehen und eine andere, die eine Eigenschaft y derselben Klasse sehen soll, dann gibt es keine Aufteilung der Klassen auf Pakete, die genau dieses gestattet. Was man stattdessen gern hätte, ist ein dedizierter Export von Elementen einer Klasse, also ein zur Verfügung Stellen von Elementen an genau benannte Klassen. Dies bietet, in etwas gröberer Form, das Friends-Konzept von C++: Die Definition friend class B; friend class C; bewirkt, dass (Instanzen von) B und (von) C auf alle privat deklarierten Elemente von (Instanzen von) A zugreifen können (jedoch weder umgekehrt von A auf B und C noch B und C gegenseitig). Ein spezifischer, dedizierter Export von einzelnen Membern an bestimmte Klassen ist in C++ nicht möglich; diesen gibt es dafür in EIFFEL (s. Abschnitt 52.2). Mit Javas Modulen und dem dedizierten (qualifiziert genannten) Export wird das Friend-Konzept auf Ebene der Pakete zumindest angenähert.",Was ist das Friends-Konzept in C++?,"Das Friends-Konzept in C++ ist ein Mechanismus, der es einer Klasse erlaubt, anderen Klassen oder Funktionen den Zugriff auf ihre privaten Elemente zu gestatten. Dies wird durch die Deklaration friend class B; friend class C; erreicht, die angibt, dass Instanzen von B und C auf alle privat deklarierten Elemente von A zugreifen können."
"In Java hatte man dazu bis zur Version 8 nur die Möglichkeit, die besagten Klassen in ein Paket zu verfrachten und die fraglichen Elemente mit paketweitem Zugriff (also ohne Zugriffsmodifizierer) zu deklarieren (Abschnitt 39.1 in Kurseinheit 4). Das hat jedoch den Nachteil, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben; wenn es eine Klasse gibt, die eine ansonsten unsichtbare Eigenschaft x einer Klasse A sehen und eine andere, die eine Eigenschaft y derselben Klasse sehen soll, dann gibt es keine Aufteilung der Klassen auf Pakete, die genau dieses gestattet. Was man stattdessen gern hätte, ist ein dedizierter Export von Elementen einer Klasse, also ein zur Verfügung Stellen von Elementen an genau benannte Klassen. Dies bietet, in etwas gröberer Form, das Friends-Konzept von C++: Die Definition friend class B; friend class C; bewirkt, dass (Instanzen von) B und (von) C auf alle privat deklarierten Elemente von (Instanzen von) A zugreifen können (jedoch weder umgekehrt von A auf B und C noch B und C gegenseitig). Ein spezifischer, dedizierter Export von einzelnen Membern an bestimmte Klassen ist in C++ nicht möglich; diesen gibt es dafür in EIFFEL (s. Abschnitt 52.2). Mit Javas Modulen und dem dedizierten (qualifiziert genannten) Export wird das Friend-Konzept auf Ebene der Pakete zumindest angenähert.",Was bietet das Friends-Konzept in C++?,"Das Friends-Konzept in C++ ermöglicht es, dass bestimmte Klassen auf alle privat deklarierten Elemente einer anderen Klasse zugreifen können. Das heißt, dass die Definition friend class B; friend class C; bewirkt, dass (Instanzen von) B und (von) C auf alle privat deklarierten Elemente von (Instanzen von) A zugreifen können. Jedoch können weder A auf B und C noch B und C gegenseitig darauf zugreifen."
"Das Gesetz Demeters besagt nicht mehr, als dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Dabei ist ""kennen"" im Sinne von Kurseinheit 1 zu verstehen: Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, wenn es also auf eine Variable direkt (also ohne den Umweg über ein anderes Objekt) zugreift, die das andere Objekt benennt. Es kennt das andere Objekt dauerhaft (oder zumindest für eine längere Dauer), wenn es sich bei der Variable um eine Instanzvariable handelt, und temporär, wenn es sich bei der Variable um den formalen Parameter einer Methode handelt (wobei die Dauer des Kennens dann auf die Dauer der Abarbeitung der Methode beschränkt ist, es sei denn, der formale Parameter wird einer Instanzvariable zugewiesen). Temporäre (lokale) Variablen werden beim Gesetz Demeters nicht mitgezählt.",Was besagt das Gesetz Demeters?,"Das Gesetz Demeters besagt, dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Dabei ist ""kennen"" im Sinne von Kurseinheit 1 zu verstehen: Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, wenn es also auf eine Variable direkt (also ohne den Umweg über ein anderes Objekt) zugreift, die das andere Objekt benennt."
"Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet (Methoden auf Objekten aufgerufen) werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks (Methodenaufrufs) vorliegen. Dies ist in der Regel bei Kettenaufrufen der Fall (s. u.), kann aber auch über eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen.",Was verstößt gegen das Gesetz Demeters?,"Das Gesetz Demeters wird verletzt, wenn Nachrichten an Objekte gesendet werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks vorliegen, wie zum Beispiel bei Kettenaufrufen oder über eine zwischenzeitliche Zuweisung zu einer temporären Variablen."
"Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet (Methoden auf Objekten aufgerufen) werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks (Methodenaufrufs) vorliegen. Dies ist in der Regel bei Kettenaufrufen der Fall (s. u.), kann aber auch über eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen.",Wann wird das Gesetz Demeters typischerweise verletzt?,"Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks vorliegen, wie zum Beispiel bei Kettenaufrufen oder über eine zwischenzeitliche Zuweisung zu einer temporären Variablen."
"Sinn und Zweck des Gesetzes Demeters ist, die Kopplung und damit die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wird das Gesetz Demeters verletzt, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen (sondern eben nur in einer mittelbaren, die nach dem Gesetz vermieden werden soll).",Was ist das Ziel des Gesetzes Demeters?,"Das Ziel des Gesetzes Demeters ist es, die Kopplung und damit die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wenn das Gesetz Demeters verletzt wird, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen."
"Das Gesetz Demeters wird oft (und leicht verkürzt) in folgender Phrase zusammengefasst: ""Sprich nicht mit Fremden"" Bezogen auf SMALLTALK heißt das, dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen.",Was bedeutet das Gesetz Demeters in Bezug SMALLTALK?,"Das Gesetz Demeters ist ein Prinzip der objektorientierten Programmierung, das besagt, dass ein Objekt nur mit seinen direkten Nachbarn kommunizieren sollte, anstatt sich in die inneren Angelegenheiten anderer Objekte einzumischen. In SMALLTALK bedeutet ""Sprich nicht mit Fremden"", dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen. Das heißt, ein Objekt darf eine Methode auf einem anderen Objekt aufrufen, aber es sollte nicht erwarten, dass dieses Objekt eine Methode auf einem dritten Objekt aufruft."
"Man beachte, dass Demeters Gesetz faktisch eine neue, kontextabhängige Zugriffbarkeitsregel einführt: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt, auf die es aber nicht zugreifen darf.",Was führt das Demeters Gesetz ein?,"Demeters Gesetz ist führt eine neue, kontextabhängige Zugriffbarkeitsregel ein, die besagt, dass ein Objekt nicht direkt auf Eigenschaften von Objekten zugreifen soll, die es nicht selbst kennt. Stattdessen soll es Nachrichten an andere Objekte senden, um die gewünschten Informationen zu erhalten."
"Eine etwas eingeschränktere Sicht auf den Zustand eines Objekts berücksichtigt lediglich seine Attributwerte. Dies setzt jedoch voraus, dass überhaupt eine klare Unterscheidung zwischen Attributen und Beziehungen getroffen werden kann. In Ermangelung spezieller Schlüsselwörter könnte dies, wie bereits oben diskutiert, allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese Unterscheidung ist jedoch nicht immer eindeutig, und in einigen Programmiersprachen ist sie gar nicht zutreffend (z.B., in Java, in dem Strings zwar unveränderlich sind und daher eigentlich als Werte gelten, aber dennoch Referenzsemantik aufweisen). In SMALLTALK hingegen, in dem alle Instanzvariablen Referenzen sein können, ist diese Einschränkung nicht anwendbar.",Wie lässt sich der Zustand eines Objekts eingrenzen?,"Der Zustand eines Objekts ließe sich auf seine Attributwerte eingrenzen. Da es jedoch keine klare Unterscheidung zwischen Attributen und Beziehungen gibt, kann dies allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen."
"Eine etwas eingeschränktere Sicht auf den Zustand eines Objekts berücksichtigt lediglich seine Attributwerte. Dies setzt jedoch voraus, dass überhaupt eine klare Unterscheidung zwischen Attributen und Beziehungen getroffen werden kann. In Ermangelung spezieller Schlüsselwörter könnte dies, wie bereits oben diskutiert, allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese Unterscheidung ist jedoch nicht immer eindeutig, und in einigen Programmiersprachen ist sie gar nicht zutreffend (z.B., in Java, in dem Strings zwar unveränderlich sind und daher eigentlich als Werte gelten, aber dennoch Referenzsemantik aufweisen). In SMALLTALK hingegen, in dem alle Instanzvariablen Referenzen sein können, ist diese Einschränkung nicht anwendbar.",Was unterscheidet Attribute und Beziehungen?,Die Unterscheidung zwischen Attributen und Beziehungen kann in Ermangelung spezieller Schlüsselwörter allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese ist jedoch in einigen Programmiersprachen nicht immer eindeutig ist und beispielsweise in Java gar nicht zutreffend.
"Man könnte nun die oben genannte Aussage, dass Zustandsänderungen eines Objekts ausschließlich über Zuweisungen an seine Instanzvariablen erfolgen können, anzweifeln und fragen, ob sich der Zustand eines Objekts auch dann ändert, wenn sich der Zustand eines Objekts, auf das es (per Instanzvariable) verweist, ändert. Zunächst würde man diese Frage verneinen, da andernfalls jede Änderung an einem Objekt fast immer zu einer Kettenreaktion führen würde. Der Zustand aller Objekte, die direkt oder indirekt darauf verweisen, würde sich ändern. Diese Definition von Zustand würde jedoch kaum unserem Weltbild entsprechen. Zum Beispiel würde eine Änderung Ihres Familienstandes kaum etwas an meinem Zustand ändern, obwohl wir in einer (direkten oder indirekten) Beziehung stehen. Doch wie ist es, wenn ich meinen Namen ändere? Ändert sich dann mein Zustand?Während man diese Frage sicherlich mit ""ja"" beantworten wird, ist Ihr Name als String ein eigenständiges Objekt, das seinen Zustand ändert, wenn einzelne Buchstaben darin ausgetauscht oder hinzugefügt werden. Nach der oben genannten Auffassung ändert sich jedoch mein Zustand als Besitzer des Namens dadurch nicht. Für einen solchen Fall lässt sich technisch kein Sonderfall begründen. Das objektorientierte Denkmodell ist daher nicht ganz ohne Herausforderungen und Programmierfehler können in vermeintlich simplen Situationen auftreten. Es ist daher sinnvoll, wenn Strings, wie von einigen SMALLTALK-Dialekten (und übrigens auch von Java) vorgesehen, immer unveränderlich (immutable) sind.",Warum ändert sich der Zustand eines Objekts nur über Instanzvariablen?,"Wenn Änderungen am Zustand eines Objekts, auf das ein anderes Objekt per Instanzvariable verweist, als Änderung des Zustands des ersten Objekts betrachtet würden, könnte jede Änderung an einem Objekt zu einer Kettenreaktion führen, da der Zustand aller Objekte, die darauf verweisen, sich ändern würde. Dies entspricht nicht unserem üblichen Verständnis von Zustand."
"Man könnte nun die oben genannte Aussage, dass Zustandsänderungen eines Objekts ausschließlich über Zuweisungen an seine Instanzvariablen erfolgen können, anzweifeln und fragen, ob sich der Zustand eines Objekts auch dann ändert, wenn sich der Zustand eines Objekts, auf das es (per Instanzvariable) verweist, ändert. Zunächst würde man diese Frage verneinen, da andernfalls jede Änderung an einem Objekt fast immer zu einer Kettenreaktion führen würde. Der Zustand aller Objekte, die direkt oder indirekt darauf verweisen, würde sich ändern. Diese Definition von Zustand würde jedoch kaum unserem Weltbild entsprechen. Zum Beispiel würde eine Änderung Ihres Familienstandes kaum etwas an meinem Zustand ändern, obwohl wir in einer (direkten oder indirekten) Beziehung stehen. Doch wie ist es, wenn ich meinen Namen ändere? Ändert sich dann mein Zustand?Während man diese Frage sicherlich mit ""ja"" beantworten wird, ist Ihr Name als String ein eigenständiges Objekt, das seinen Zustand ändert, wenn einzelne Buchstaben darin ausgetauscht oder hinzugefügt werden. Nach der oben genannten Auffassung ändert sich jedoch mein Zustand als Besitzer des Namens dadurch nicht. Für einen solchen Fall lässt sich technisch kein Sonderfall begründen. Das objektorientierte Denkmodell ist daher nicht ganz ohne Herausforderungen und Programmierfehler können in vermeintlich simplen Situationen auftreten. Es ist daher sinnvoll, wenn Strings, wie von einigen SMALLTALK-Dialekten (und übrigens auch von Java) vorgesehen, immer unveränderlich (immutable) sind.",Warum ist der Zustandsbegriff nicht auf mehrere Objekte im Allgemeinen ausgedehnt?,"Der Zustandsbegriff kann nicht auf mehrere Objekte im Allgemeinen ausgedehnt werden, da dies zu komplexen Problemen führen würde und das objektorientierte Modell nicht ohne Herausforderungen ist. Programmierfehler könnten in vermeintlich simplen Situationen auftreten."
"Obwohl es nicht sinnvoll ist, den Zustandsbegriff auf mehrere Objekte im Allgemeinen auszudehnen, ist dies für Kompositionen, also für aus Teilen zusammengesetzte Ganze, durchaus angemessen. Wenn zum Beispiel ein Dokument aus mehreren Seiten besteht, die wiederum aus Zeilen und Spalten bestehen, ändert sich der Zustand des gesamten Dokuments, wenn eine Zeile geändert wird. Dies wird weiter unten noch eine Rolle spielen, insbesondere im Zusammenhang mit Aliasing. Wenn man davon ausgeht, dass Zustandsänderungen eines Objekts immer die Angelegenheit des Objekts selbst sind, dürfen keine externen Aliase auf seine Teile existieren. Andernfalls könnte eine Zustandsänderung von außen aufgezwungen werden. Die Zustandsänderung sollte daher gekapselt sein.","Wann ist es angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen?","Es ist angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen, wenn es sich um Kompositionen handelt, also um aus Teilen zusammengesetzte Ganze."
"SMALLTALK stammt aus einer Zeit, in der man noch relativ wenig praktische Erfahrung mit objektorientierter Programmierung gesammelt hatte. Damals war man der Ansicht, dass einer der Hauptvorteile der objektorientierten Programmierung die Wiederverwendung von Code durch Vererbung sei. Wie in Abschnitt 10.1 dargelegt, hat die Vererbung etwas mit der auf Generalisierung bzw. Spezialisierung beruhenden Abstraktionshierarchie zu tun: Der allgemeinere Begriff (die Superklasse) überträgt (vererbt) alle seine Eigenschaften auf die spezielleren Begriffe (Subklassen), und der speziellere erbt sie von den allgemeineren. Dies liegt in der Natur der Sache. Problematisch wird es jedoch, sobald man den kausalen Zusammenhang umkehren und von einer möglichen Vererbung auf eine Generalisierung/Spezialisierung schließen will: Nur weil eine Klasse (zufällig) Eigenschaften einer anderen geerbt haben könnte, heißt das noch lange nicht, dass die erbende Klasse auch eine Spezialisierung der vererbenden ist. Ein klassisches Beispiel hierzu hatten wir bereits mit der Ableitung der Klasse Rechteck von der Klasse Quadrat kennengelernt; den unangenehmen Folgen solch vererbungsorientierter Vorgehensweisen werden wir in der nächsten Kurseinheit noch begegnen.",Was ist die Problematik bei der Vererbung in SMALLTALK?,"Die Problematik bei der Vererbung in SMALLTALK ist, dass man davon ausgeht, dass Vererbung etwas mit der auf Generalisierung bzw. Spezialisierung beruhenden Abstraktionshierarchie zu tun hat. Dies ist jedoch nicht immer der Fall, wie das Beispiel der Ableitung der Klasse Rechteck von der Klasse Quadrat zeigt. Diese vererbungsorientierte Vorgehensweise kann zu unangenehmen Folgen führen."
"SMALLTALK stammt aus einer Zeit, in der man noch relativ wenig praktische Erfahrung mit objektorientierter Programmierung gesammelt hatte. Damals war man der Ansicht, dass einer der Hauptvorteile der objektorientierten Programmierung die Wiederverwendung von Code durch Vererbung sei. Wie in Abschnitt 10.1 dargelegt, hat die Vererbung etwas mit der auf Generalisierung bzw. Spezialisierung beruhenden Abstraktionshierarchie zu tun: Der allgemeinere Begriff (die Superklasse) überträgt (vererbt) alle seine Eigenschaften auf die spezielleren Begriffe (Subklassen), und der speziellere erbt sie von den allgemeineren. Dies liegt in der Natur der Sache. Problematisch wird es jedoch, sobald man den kausalen Zusammenhang umkehren und von einer möglichen Vererbung auf eine Generalisierung/Spezialisierung schließen will: Nur weil eine Klasse (zufällig) Eigenschaften einer anderen geerbt haben könnte, heißt das noch lange nicht, dass die erbende Klasse auch eine Spezialisierung der vererbenden ist. Ein klassisches Beispiel hierzu hatten wir bereits mit der Ableitung der Klasse Rechteck von der Klasse Quadrat kennengelernt; den unangenehmen Folgen solch vererbungsorientierter Vorgehensweisen werden wir in der nächsten Kurseinheit noch begegnen.",Warum ist die Vererbung in der objektorientierten Programmierung problematisch?,"Die Vererbung in der objektorientierten Programmierung ist problematisch, weil sie oft fälschlicherweise als ein Zeichen für eine Generalisierung/Spezialisierung interpretiert wird. Es ist jedoch möglich, dass eine Klasse Eigenschaften einer anderen Klasse erbt, ohne dass sie eine Spezialisierung der vererbenden Klasse ist. Ein klassisches Beispiel hierfür ist die Ableitung der Klasse Rechteck von der Klasse Quadrat, was zu unangenehmen Folgen führen kann."
"Java-Programme sind objektorientierte Programme. Zur Laufzeit bestehen sie aus einer Menge interagierender Objekte. Dabei ist Java stark typisiert: Jedes Objekt gehört zum Wertebereich eines oder mehrerer Typen. Anders als in SMALLTALK gibt es in Java neben Objekten auch Werte wie Zahlen, Zeichen und Wahrheitswerte, die keine Objekte sind.",Was ist der Unterschied zwischen Java und SMALLTALK in Bezug auf die Objektorientierung?,"In Java sind neben Objekten auch Werte wie Zahlen, Zeichen und Wahrheitswerte vorhanden, die keine Objekte sind. Im Gegensatz dazu sind in SMALLTALK alle Werte Objekte."
"Java-Programme sind objektorientierte Programme. Zur Laufzeit bestehen sie aus einer Menge interagierender Objekte. Dabei ist Java stark typisiert: Jedes Objekt gehört zum Wertebereich eines oder mehrerer Typen. Anders als in SMALLTALK gibt es in Java neben Objekten auch Werte wie Zahlen, Zeichen und Wahrheitswerte, die keine Objekte sind.",Was ist die Hauptunterschiede zwischen Java und SMALLTALK?,"Der Hauptunterschied zwischen Java und SMALLTALK ist, dass Java stark typisiert ist und neben Objekten auch Werte wie Zahlen, Zeichen und Wahrheitswerte kennt, die keine Objekte sind. Im Gegensatz dazu ist SMALLTALK dynamisch typisiert und kennt nur Objekte."
"Java-Programme sind objektorientierte Programme. Zur Laufzeit bestehen sie aus einer Menge interagierender Objekte. Dabei ist Java stark typisiert: Jedes Objekt gehört zum Wertebereich eines oder mehrerer Typen. Anders als in SMALLTALK gibt es in Java neben Objekten auch Werte wie Zahlen, Zeichen und Wahrheitswerte, die keine Objekte sind.",Was ist der Unterschied zwischen Objekten und Werten in Java?,"In Java sind Objekte Instanzen von Klassen und haben einen Verweis auf einen Speicherbereich, in dem ihre Attribute gespeichert sind. Währenddessen sind Werte wie Zahlen, Zeichen und Wahrheitswerte nicht instanziiert und haben keinen Verweis auf einen Speicherbereich. Sie sind direkt in den Variablen gespeichert."
"In Java werden zunächst sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen. Von Klassen- und Interfacetypen gibt es seit Java 5 auch parametrisierte Varianten, die denen von STRONGTALK stark ähneln (die Java-Generics stammen teilweise von Autoren von STRONGTALK). Die primitiven Typen sind in der Sprachdefinition festgelegt. Es handelt sich um byte, short, int, long, float, double, boolean und char. Sie unterscheiden sich nicht wesentlich von den Typen in gängigen, statisch typgeprüften prozeduralen Sprachen.",Wie viele Arten von Typen werden in Java unterschieden?,"In Java werden sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen."
"Alle anderen Typen werden in Java durch Typkonstruktion mittels entsprechender Sprachkonstrukte definiert. Ein Teil dieser Typen ist jedoch in der Sprachdefinition bereits festgelegt. Java sieht für jeden primitiven Typ einen im Wesentlichen gleichnamigen Referenztyp vor, dessen Werte jeweils einen Wert eines entsprechenden primitiven Typs aufnehmen können. Diese Typen, nämlich Byte, Short, Integer, Long, Float, Double, Boolean und Character, nennt man deshalb Wrapper-Typen (sie verpacken gewissermaßen einen Wert eines primitiven Typs). Weitere Typen, die die Java-Sprachdefinition voraussetzt, sind Object, String, Throwable, Error, Exception, RuntimeException und Thread. Diese werden an entsprechenden Stellen unten weiter erläutert.",Was sind Wrapper-Typen in Java?,"In Java werden für jeden primitiven Typ Referenztypen definiert, die Werte eines entsprechenden primitiven Typs aufnehmen können. Diese Typen, nämlich Byte, Short, Integer, Long, Float, Double, Boolean und Character, werden Wrapper-Typen genannt."
"Genau wie in SMALLTALK müssen auch in Java die Objekte irgendwoher kommen. Neben der Instanziierung von Klassen, wie Sie sie auch schon von SMALLTALK kennen, gibt es dafür auch in Java Literale: Ganze Zahlen (Integer-Literale), Gleitkommazahlen (Floating-Point-Literale), Zeichen (Character-Literale), Zeichenketten (String-Literale), Boolean-Literale, Null-Literale",Was sind Literale in Java?,"Literale sind in Java fest definierte Werte, die direkt in den Quellcode eingebettet werden können. Sie werden vom Compiler in Maschinencode übersetzt. In Java gibt es Literale für die folgenden Datentypen: Ganze Zahlen (Integer-Literale), Gleitkommazahlen (Floating-Point-Literale), Zeichen (Character-Literale), Zeichenketten (String-Literale), Boolean-Literale und Null-Literale. Ganze Zahlen"
"Genau wie in SMALLTALK müssen auch in Java die Objekte irgendwoher kommen. Neben der Instanziierung von Klassen, wie Sie sie auch schon von SMALLTALK kennen, gibt es dafür auch in Java Literale: Ganze Zahlen (Integer-Literale), Gleitkommazahlen (Floating-Point-Literale), Zeichen (Character-Literale), Zeichenketten (String-Literale), Boolean-Literale, Null-Literale",Was ist der Unterschied zwischen lokalen Variablen und Instanzvariablen in Java?,"Lokale Variablen sind Variablen, die innerhalb einer Methode deklariert werden und nur innerhalb dieser Methode sichtbar sind. Instanzvariablen sind Variablen, die in einer Klasse deklariert werden und für alle Instanzen dieser Klasse gültig sind. Instanzvariablen werden initialisiert, wenn ein Objekt erzeugt wird und behalten ihren Wert zwischen verschiedenen Methodenaufrufen bei."
"Genau wie in SMALLTALK müssen auch in Java die Objekte irgendwoher kommen. Neben der Instanziierung von Klassen, wie Sie sie auch schon von SMALLTALK kennen, gibt es dafür auch in Java Literale: Ganze Zahlen (Integer-Literale), Gleitkommazahlen (Floating-Point-Literale), Zeichen (Character-Literale), Zeichenketten (String-Literale), Boolean-Literale, Null-Literale",Was ist der Unterschied zwischen einem Objekt und einem Literal in Java?,"Der Unterschied zwischen einem Objekt und einem Literal in Java ist, dass ein Objekt eine Instanz einer Klasse ist, die zur Laufzeit erzeugt wird, während ein Literal ein Wert ist, der direkt in den Quellcode eingebettet ist und zur Laufzeit als konkreter Wert zur Verfügung gestellt wird. Objekte haben einen Klassentyp, während Literale einen primitiven Typ haben."
"In gewisser Weise hat man es beim rekursiv beschränkten parametrischen Polymorphismus wie oben vorgestellt mit einem Fall von kovarianter Redefinition zu tun: Der Parametertyp der Methode = ändert sich mit dem Empfängertyp. Allerdings ergibt sich daraus, anders als bei der Verwendung von Self als Typvariable, kein Widerspruch zur Kontravarianzregel des Subtyping, denn Integer wird dadurch unmittelbar ja lediglich zu einem Subtyp von Equatable[Integer] und nicht etwa von Equatable[Object]. Tatsächlich sind Equatable[Integer] und Equatable[Object] ja zwei vollkommen verschiedene Typen (mit disjunkten Wertebereichen), und Equatable[T] ist gar kein Typ (so dass man auch keine Variable mit ihm deklarieren kann), sodass keinerlei Zuweisungskompatibilität und damit auch kein Problem mit Typkorrektheit besteht.",Was ist kovariante Redefinition?,"Kovariante Redefinition bezieht sich auf eine Situation, in der der Parametertyp einer Methode sich mit dem Empfängertyp ändert. Im Fall des rekursiv beschränkten parametrischen Polymorphismus wird der Parametertyp der Methode zu einem Subtyp des Empfängertyps, was keinen Widerspruch zur Kontravarianzregel des Subtyping darstellt."
"In gewisser Weise hat man es beim rekursiv beschränkten parametrischen Polymorphismus wie oben vorgestellt mit einem Fall von kovarianter Redefinition zu tun: Der Parametertyp der Methode = ändert sich mit dem Empfängertyp. Allerdings ergibt sich daraus, anders als bei der Verwendung von Self als Typvariable, kein Widerspruch zur Kontravarianzregel des Subtyping, denn Integer wird dadurch unmittelbar ja lediglich zu einem Subtyp von Equatable[Integer] und nicht etwa von Equatable[Object]. Tatsächlich sind Equatable[Integer] und Equatable[Object] ja zwei vollkommen verschiedene Typen (mit disjunkten Wertebereichen), und Equatable[T] ist gar kein Typ (so dass man auch keine Variable mit ihm deklarieren kann), sodass keinerlei Zuweisungskompatibilität und damit auch kein Problem mit Typkorrektheit besteht.",Was ist der Unterschied zwischen kovarianter Redefinition und kontravarianter Redefinition?,"Kovariante Redefinition tritt auf, wenn der Parametertyp der Methode sich mit dem Empfängertyp ändert, während kontravariante Redefinition auftritt, wenn der Parametertyp der Methode sich in die entgegengesetzte Richtung zum Empfängertyp ändert. In diesem Fall ist es kein Widerspruch zur Kontravarianzregel des Subtyping, da Integer unmittelbar zu einem Subtyp von Equatable[Integer] wird und nicht von Equatable[Object]. Equatable[Integer] und Equatable[Object] sind zwei vollkommen verschiedene Typen mit disjunkten Wertebereichen, und Equatable[T] ist kein Typ, sodass keinerlei Zuweisungskompatibilität und damit auch kein Problem mit Typkorrektheit besteht."
"Trotzdem stellt sich die Frage, ob sich das in Abschnitt 26.3 angesprochene allgemeine Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischen Polymorphismus nicht irgendwie lösen lässt. Die Antwort ist unbefriedigend: nur zum Teil.",Was ist das Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden?,"Das Problem ist, dass wenn eine Unterklasse eine Methode der Oberklasse redefiniert, die Eingabeparameter der Unterklassenmethode nicht kovariant mit den Eingabeparametern der Oberklassenmethode sein dürfen, was aber wünschenswert wäre."
"Trotzdem stellt sich die Frage, ob sich das in Abschnitt 26.3 angesprochene allgemeine Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischen Polymorphismus nicht irgendwie lösen lässt. Die Antwort ist unbefriedigend: nur zum Teil.",Was bedeutet kovariant?,"Kovariant bedeutet, dass die Typen der Eingabeparameter der Unterklassenmethode mit den Typen der Eingabeparameter der Oberklassenmethode kompatibel sein müssen, aber nicht unbedingt identisch sein müssen."
"Trotzdem stellt sich die Frage, ob sich das in Abschnitt 26.3 angesprochene allgemeine Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischen Polymorphismus nicht irgendwie lösen lässt. Die Antwort ist unbefriedigend: nur zum Teil.",Was ist parametrischer Polymorphismus?,"Parametrischer Polymorphismus ist eine Technik, bei der eine Funktion oder Methode mit verschiedenen Typen von Eingabeparametern verwendet werden kann, ohne dass eine separate Funktion oder Methode für jeden Typ definiert werden muss."
"Trotzdem stellt sich die Frage, ob sich das in Abschnitt 26.3 angesprochene allgemeine Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischen Polymorphismus nicht irgendwie lösen lässt. Die Antwort ist unbefriedigend: nur zum Teil.",Kann das Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mit parametrischen Polymorphismus gelöst werden?,"Nur zum Teil, da parametrischer Polymorphismus zwar die Verwendung von verschiedenen Typen von Eingabeparametern ermöglicht, aber nicht die kovariante Redefinition von Eingabeparametern in Unterklassenmethoden."
"Die Kovarianz ist in keiner Typdefinition festgehalten, sondern lediglich in der Deklaration von z. Es hindert einen insbesondere nichts daran, dieselbe oder eine andere Variable zu deklarieren. Man beachte, dass es hier keine Möglichkeit gibt, einen bestimmten Wert für einen Typparameter vorzuschreiben. Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie lässt sich auch mittels parametrischer Typen nicht hinbekommen.",Was ist Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie?,"Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie ist eine Technik in der objektorientierten Programmierung, bei der ein Subtyp eine Methode seines Obertyps mit einem spezifischeren Rückgabetyp neu definieren kann, während er gleichzeitig die Liskov-Substitutionsprinzip einhält. Diese Technik kann jedoch nicht mit parametrischen Typen erreicht werden."
"Typen beschränken die Wertebereiche von Variablen und Methoden. Inklusionspolymorphie lockert diese Beschränkung insofern, als dadurch Wertebereiche von Typen um die von Subtypen erweitert werden können, selbst wenn diese Subtypen zum Zeitpunkt der Typdefinition noch gar nicht bekannt waren. Nun ist Inklusionspolymorphie nicht die einzige Möglichkeit, den Wertebereich eines Typs variabel zu halten, ohne die statische Typprüfung aufgeben zu müssen. Eine andere ist, einen Typ mit einem oder mehreren anderen zu parametrisieren.",Was ist Parametrisierung von Typen?,"Parametrisierung von Typen ist eine Möglichkeit, den Wertebereich eines Typs variabel zu halten, ohne die statische Typprüfung aufgeben zu müssen. Dabei wird der Typ mit einem oder mehreren anderen Typen parametrisiert."
"Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden müssen, sondern durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich. Dieser Umstand ist bei der Betrachtung von Zuweisungskompatibilität unter parametrischem Polymorphismus wichtig.",Was ist eine parametrische Typdefinition?,"Eine parametrische Typdefinition ist eine Art von Typdefinition, die Platzhalter für andere Typen verwendet, die durch Typparameter, auch Typvariablen genannt, vertreten werden. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt."
"Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden müssen, sondern durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich. Dieser Umstand ist bei der Betrachtung von Zuweisungskompatibilität unter parametrischem Polymorphismus wichtig.",Was ist der Unterschied zwischen einer parametrischen Typdefinition und einer normalen Typdefinition?,"Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit auf Typen beschränkt ist. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt."
"Die Idee des parametrischen Polymorphismus ist, aus einer Typdefinition durch Parametrisierung viele zu machen. Eine parametrische Typdefinition steht also nicht für einen Typ, sondern für (theoretisch) beliebig viele — sie erlaubt es gewissermaßen, Unterschiede zur Typen nach Bedarf zu generieren. Wohl deswegen bezeichnet man parametrische Typen (Typdefinitionen) auch als generische Typen (Typdefinitionen) oder kurz als Generics. Wie eben schon erwähnt, wird der Wertebereich bei einer solchen Typgeneration jeweils mitgeneriert.",Was ist parametrischer Polymorphismus?,"Parametrischer Polymorphismus ist ein Konzept, bei dem aus einer Typdefinition durch Parametrisierung viele verschiedene Typen erzeugt werden können. Diese parametrische Typdefinition wird auch als generische Typdefinition oder kurz als Generics bezeichnet. Der Wertebereich wird bei der Typgeneration mitgeneriert."
"Es erfolgt also die Zuweisung eines Typs zu einer Typvariable bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, beispielsweise der Deklaration einer Variable oder des Rückgabewerts einer Methode. Oberflächlich betrachtet entspricht diese Verwendung in etwa dem Aufruf einer (ja auch an einer anderen Stelle definierten) Methode oder besser (und schon aufgrund der Verwendung des Begriffs Instanziierung) eines Konstruktors; deswegen nennt man die Typvariablen, die in parametrischen Typdefinitionen vorkommen, auch formale Typparameter und die konkreten Typen, die bei der Verwendung des Typen in Deklarationen in die formalen Parameter eingesetzt werden, auch tatsächliche Typparameter. Trotz dieser Analogie zu Methoden- bzw. Konstruktoraufrufen muss man sich immer vor Augen halten, dass die Verwendung eines parametrisch definierten Typs bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen führt, man es also keineswegs mit etwas Dynamischem zu tun hat. Insbesondere müssen Typen keine Objekte sein, um Typvariablen zugewiesen werden zu können.",Was sind formale Typparameter und tatsächliche Typparameter?,"Formale Typparameter sind die Typvariablen, die in parametrischen Typdefinitionen vorkommen. Tatsächliche Typparameter sind die konkreten Typen, die bei der Verwendung des Typs in Deklarationen in die formalen Parameter eingesetzt werden."
"In SMALLTALK sind Konstruktoren ganz normale Klassenmethoden und daher an keine besonderen Konventionen gebunden. Insbesondere müssen sie nicht zwingend ein neues Objekt genau der Klasse zurückgeben, zu der sie gehören. Dies ermöglicht die Verwendung sogenannter Factory-Methoden.",Was sind Konstruktoren in SMALLTALK?,"In SMALLTALK sind Konstruktoren ganz normale Klassenmethoden und daher an keine besonderen Konventionen gebunden. Sie können ein neues Objekt genau der Klasse zurückgeben, zu der sie gehören, aber auch nicht zwingend. Das ermöglicht die Verwendung sogenannter Factory-Methoden."
"In SMALLTALK sind Konstruktoren ganz normale Klassenmethoden und daher an keine besonderen Konventionen gebunden. Insbesondere müssen sie nicht zwingend ein neues Objekt genau der Klasse zurückgeben, zu der sie gehören. Dies ermöglicht die Verwendung sogenannter Factory-Methoden.",Was sind Factory-Methoden?,"Factory-Methoden sind Methoden, die ein Objekt zurückgeben, das nicht unbedingt zur Klasse gehört, zu der die Methode gehört."
"In SMALLTALK sind Konstruktoren ganz normale Klassenmethoden und daher an keine besonderen Konventionen gebunden. Insbesondere müssen sie nicht zwingend ein neues Objekt genau der Klasse zurückgeben, zu der sie gehören. Dies ermöglicht die Verwendung sogenannter Factory-Methoden.",Wozu dienen Factory-Methoden?,"Factory-Methoden dienen dazu, Objekte zu erzeugen und zurückzugeben, die nicht unbedingt zur Klasse gehören, zu der die Methode gehört. Das ermöglicht eine flexiblere Objektinitialisierung."
"In SMALLTALK sind Konstruktoren ganz normale Klassenmethoden und daher an keine besonderen Konventionen gebunden. Insbesondere müssen sie nicht zwingend ein neues Objekt genau der Klasse zurückgeben, zu der sie gehören. Dies ermöglicht die Verwendung sogenannter Factory-Methoden.",Was sind Factory-Methoden in SMALLTALK?,"Factory-Methoden sind Konstruktoren in SMALLTALK, die nicht zwingend ein neues Objekt genau der Klasse zurückgeben, zu der sie gehören. Sie sind ganz normale Klassenmethoden und daher nicht an besondere Konventionen gebunden."
"Eine Factory-Methode ist eine Methode, die ähnlich wie ein Konstruktor eine neue Instanz liefert. Allerdings macht sie die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode gehört, abhängig. Zum Beispiel könnte eine Klasse ""Number"" eine Klassenmethode ""fromString:"" bereitstellen, die anhand eines zu analysierenden Strings entweder eine Instanz der Klasse ""Integer"" oder eine Instanz der Klasse ""Float"" zurückgibt. Die Implementierung solcher Factory-Methoden ist in SMALLTALK einfach möglich und sie unterscheiden sich formal nicht von Konstruktoren – es handelt sich einfach um Klassenmethoden.",Was ist eine Factory-Methode?,"Eine Factory-Methode ist eine Methode, die eine neue Instanz liefert und die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode gehört, abhängig macht. In SMALLTALK sind Factory-Methoden einfach zu implementieren und unterscheiden sich formal nicht von Konstruktoren – es handelt sich einfach um Klassenmethoden."
"Eine Factory-Methode ist eine Methode, die ähnlich wie ein Konstruktor eine neue Instanz liefert. Allerdings macht sie die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode gehört, abhängig. Zum Beispiel könnte eine Klasse ""Number"" eine Klassenmethode ""fromString:"" bereitstellen, die anhand eines zu analysierenden Strings entweder eine Instanz der Klasse ""Integer"" oder eine Instanz der Klasse ""Float"" zurückgibt. Die Implementierung solcher Factory-Methoden ist in SMALLTALK einfach möglich und sie unterscheiden sich formal nicht von Konstruktoren – es handelt sich einfach um Klassenmethoden.",Was ist eine Factory-Methode und wie unterscheidet sie sich von Konstruktoren?,"Eine Factory-Methode ist eine Methode, die eine neue Instanz liefert, ähnlich wie ein Konstruktor. Der Unterschied liegt darin, dass die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode gehört, abhängig gemacht wird. In SMALLTALK sind Factory-Methoden einfach zu implementieren und unterscheiden sich formal nicht von Konstruktoren, da es sich einfach um Klassenmethoden handelt."
"Diese Factory-Methode ""fromString:"" in der Klasse ""Number"" analysiert den übergebenen String. Wenn der Parameter ""aString"" einen Dezimalpunkt enthält, wird eine neue Fließkommazahl zurückgegeben (mittels der Methode ""asFloat"", die in der Klasse ""String"" implementiert ist und eine Instanz der Klasse ""Float"" zurückliefert). Andernfalls wird eine Ganzzahl zurückgegeben. Diese Art von Factory-Methoden ermöglicht eine flexible Instanziierung von Objekten abhängig von den gegebenen Eingaben.",Wie funktionieren Factory-Methoden?,"Factory-Methoden sind statische Methoden, die eine Instanz einer bestimmten Unterklasse erzeugen und zurückgeben, anstatt die Instanz direkt zu instanziieren. Sie entscheiden dynamisch, welche Unterklasse instanziiert werden soll, abhängig von den gegebenen Eingaben. Dadurch können sie die richtige Instanzklasse auswählen und eine Instanz dieser Klasse zurückgeben, ohne dass der Aufrufer sich um die Details der Instanziierung kümmern muss."
"In Kapitel 26 sind wir bereits ausführlich auf den Begriff des Subtypings eingegangen. Subtyping sollte die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen, dh. erlauben, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Dies führt nun zu dem Problem, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat.82 Gemäß den Regeln gängiger objektorientierter Programmiersprachen zur Zuweisungskompatibilität wissen wir lediglich, dass es sich beim Typ des Empfängerobjekts e um einen Subtyp von T handeln muss83, jedoch wissen wir nicht genau, um welchen Subtyp es sich handelt. In einer statischen, lokalen Betrachtung84, also bei mangelnder Kenntnis des Typs des von e bezeichneten Objekts sowie aller infrage kommenden Subtypen von T, befinden wir uns in einem Zustand völliger Unsicherheit. Da die Erweiterung um Subklassen bzw. Subtypen jedoch eine der Errungenschaften der objektorientierten Programmierung ist, handelt es sich hierbei um ein echtes Problem.",Was ist Subtyping in der objektorientierten Programmierung?,"Subtyping ist ein Konzept in der objektorientierten Programmierung, das die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen soll. Es erlaubt, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Dadurch wird die Erweiterung um Subklassen oder Subtypen ermöglicht."
"In Kapitel 26 sind wir bereits ausführlich auf den Begriff des Subtypings eingegangen. Subtyping sollte die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen, dh. erlauben, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Dies führt nun zu dem Problem, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat.82 Gemäß den Regeln gängiger objektorientierter Programmiersprachen zur Zuweisungskompatibilität wissen wir lediglich, dass es sich beim Typ des Empfängerobjekts e um einen Subtyp von T handeln muss83, jedoch wissen wir nicht genau, um welchen Subtyp es sich handelt. In einer statischen, lokalen Betrachtung84, also bei mangelnder Kenntnis des Typs des von e bezeichneten Objekts sowie aller infrage kommenden Subtypen von T, befinden wir uns in einem Zustand völliger Unsicherheit. Da die Erweiterung um Subklassen bzw. Subtypen jedoch eine der Errungenschaften der objektorientierten Programmierung ist, handelt es sich hierbei um ein echtes Problem.",Was ist Subtyping und welches Problem ergibt sich daraus?,"Subtyping ist ein Begriff in der objektorientierten Programmierung, der die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen soll. Das bedeutet, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Das Problem, das sich daraus ergibt, ist, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat. In einer statischen, lokalen Betrachtung befinden wir uns in einem Zustand völliger Unsicherheit."
"Das Problem lässt sich als ein Problem der formalen Programmverifikation ausdrücken: Wie kann bewiesen werden, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts gebunden werden können? Es handelt sich um die Beziehung P {e m} Q (54.1), bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse darüber, was der Methodenaufruf tatsächlich bewirkt oder vielmehr, welchen Effekt er hat. Dafür ist die Kenntnis der Implementierung der Methode erforderlich. Andererseits ist es wichtig für die Pflege und Weiterentwicklung eines Programms zu wissen, unter welchen Bedingungen die Methoden einer neu eingeführten Klasse in das bestehende Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert. Die Bedingungen müssen bekannt sein, um sicherzustellen, dass die neue Implementierung sich in den Kanon der bereits bestehenden einordnet und kein unerwartetes Verhalten hervorruft. Nur wenn diese Zusicherungen in Form von (54.1) für alle Aufrufe erfüllt sind, ist das Funktionieren des Programms nicht gefährdet. Andernfalls könnte es beeinträchtigt sein. Daher müssen die Bedingungen bekannt sein.",Was ist das Problem der formalen Programmverifikation?,"Das Problem der formalen Programmverifikation ist die Beziehung P {e m} Q, bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse über die Implementierung der Methode."
"Das Problem lässt sich als ein Problem der formalen Programmverifikation ausdrücken: Wie kann bewiesen werden, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts gebunden werden können? Es handelt sich um die Beziehung P {e m} Q (54.1), bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse darüber, was der Methodenaufruf tatsächlich bewirkt oder vielmehr, welchen Effekt er hat. Dafür ist die Kenntnis der Implementierung der Methode erforderlich. Andererseits ist es wichtig für die Pflege und Weiterentwicklung eines Programms zu wissen, unter welchen Bedingungen die Methoden einer neu eingeführten Klasse in das bestehende Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert. Die Bedingungen müssen bekannt sein, um sicherzustellen, dass die neue Implementierung sich in den Kanon der bereits bestehenden einordnet und kein unerwartetes Verhalten hervorruft. Nur wenn diese Zusicherungen in Form von (54.1) für alle Aufrufe erfüllt sind, ist das Funktionieren des Programms nicht gefährdet. Andernfalls könnte es beeinträchtigt sein. Daher müssen die Bedingungen bekannt sein.","Warum ist es wichtig, die Bedingungen zu kennen, unter denen Methoden in ein bestehendes Programm integriert werden können?","Es ist wichtig, die Bedingungen zu kennen, unter denen Methoden in ein bestehendes Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert und kein unerwartetes Verhalten hervorruft. Nur wenn diese Zusicherungen in Form von (54.1) für alle Aufrufe erfüllt sind, ist das Funktionieren des Programms nicht gefährdet."
"Die Frage, wie der Effekt aller Implementierungen von m für Subtypen von T (einschließlich T selbst) erfasst werden kann, steht im Raum. Eine naive Antwort auf diese Frage würde vorschlagen, dass man sich alle diese Implementierungen ansieht und auf dieser Grundlage eine Fallunterscheidung präsentiert: Wenn das Objekt e vom Typ T ist, dann hat m den und den Effekt, wenn es von Subtyp T1 ist, dann hat m den und den Effekt, usw. Die Zusammenfassung dieser Fallunterscheidungen würde dann alle Effekte logisch mit einem Oder verknüpfen. Diese Möglichkeit hat jedoch den Nachteil der Unhandlichkeit und berücksichtigt nicht vorhandene Implementierungen nicht. Was man stattdessen möchte, ist die Gewissheit, dass eine lokale, ""modulare"" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte. Genau das soll der Begriff der Substituierbarkeit ermöglichen.",Was ist der Begriff der Substituierbarkeit?,"Der Begriff der Substituierbarkeit ermöglicht eine lokale, ""modulare"" Betrachtung bei der Analyse von Methodenaufrufen, indem er die Gewissheit bietet, dass man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte."
"Die Frage, wie der Effekt aller Implementierungen von m für Subtypen von T (einschließlich T selbst) erfasst werden kann, steht im Raum. Eine naive Antwort auf diese Frage würde vorschlagen, dass man sich alle diese Implementierungen ansieht und auf dieser Grundlage eine Fallunterscheidung präsentiert: Wenn das Objekt e vom Typ T ist, dann hat m den und den Effekt, wenn es von Subtyp T1 ist, dann hat m den und den Effekt, usw. Die Zusammenfassung dieser Fallunterscheidungen würde dann alle Effekte logisch mit einem Oder verknüpfen. Diese Möglichkeit hat jedoch den Nachteil der Unhandlichkeit und berücksichtigt nicht vorhandene Implementierungen nicht. Was man stattdessen möchte, ist die Gewissheit, dass eine lokale, ""modulare"" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte. Genau das soll der Begriff der Substituierbarkeit ermöglichen.",Was ist der Zweck der Substituierbarkeit?,"Der Zweck der Substituierbarkeit in der objektorientierten Programmierung ist es, die Gewissheit zu haben, dass eine lokale, ""modulare"" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte."
"Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean: Alle seine Operationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergebnis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte externe Formalismen abzubilden. Im Beispiel von Boolean ist dies natürlich die boolesche Algebra. Jeder, der die boolesche Algebra kennt und akzeptiert, wird auch den Typ Boolean sofort verstehen und akzeptieren (sofern er den Erwartungen entsprechend definiert ist). Entsprechend lässt sich ein Typ Fraction mit den Operationen +, –, *, und / definieren, der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-gleichsoperationen wie =, >, <, etc. hinzufügen, ohne in Interpretationsprobleme zu geraten. Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition rekursiv auf solche Typen zurückgeführt werden können, kann man ""induktiv über deren Aufbau"" eine Bedeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeutung eine denotationale Semantik. Eine andere, für die praktische Programmierung relevantere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten oder realen, Hauptsache gut spezifizierten) Maschine abzubilden. Die Abbildung für Basistypen wie Rational oder Boolean ist in der Programmiersprache bzw. deren Compiler gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann dies hingegen nicht der Fall sein; deren Bedeutung kann aber vom Compiler, wiederum ""induktiv über deren Aufbau"", aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Man nennt dies dann auch eine operationale Semantik. Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht ""hart verdrahtet"" ist, sondern auf dynamisches Binden abgewälzt wird, so sind dennoch mindestens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und Float (nicht jedoch Fraction!) sind ""fest verdrahtet"", inklusive der Vergleichsrelationen (die ja die Wahrheitswerte zum Ergebnis haben). Wenn Sie Kurs 01661 (""Datenstrukturen"") bereits belegt haben oder ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen. Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrieben, deren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs: 1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte keinen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die Operationen ausgeführt werden, nicht ihren Zustand wechseln. Stattdessen geben Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also gewissermaßen alle unveränderlich (vgl. Kurseinheit 1, Abschnitt 4.3.5). 2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar vom Typ des Datentyps selbst. Dieses Argument entspricht in der objektorientierten Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self. Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Programmiersprache mit einer Semantik zu versehen.",Wie kann man Typen in einer Programmiersprache Bedeutung verleihen?,"Es gibt verschiedene Möglichkeiten, Typen in einer Programmiersprache Bedeutung zu verleihen. Eine Möglichkeit ist, Typen auf bekannte externe Formalismen abzubilden, wie zum Beispiel den booleschen Algebra für den Typ Boolean. Eine andere Möglichkeit ist, Typen und ihre Operationen auf Anweisungen einer (gedachten oder realen) Maschine abzubilden. Für von der Programmiererin definierte Typen kann die Bedeutung vom Compiler aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Diese Art der Bedeutungsvergabe wird operationale Semantik genannt. Eine weitere Möglichkeit ist, Typen und ihre Operationen auf abstrakte Datentypen abzubilden, die in der Programmiersprache definiert sind."
"Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean: Alle seine Operationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergebnis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte externe Formalismen abzubilden. Im Beispiel von Boolean ist dies natürlich die boolesche Algebra. Jeder, der die boolesche Algebra kennt und akzeptiert, wird auch den Typ Boolean sofort verstehen und akzeptieren (sofern er den Erwartungen entsprechend definiert ist). Entsprechend lässt sich ein Typ Fraction mit den Operationen +, –, *, und / definieren, der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-gleichsoperationen wie =, >, <, etc. hinzufügen, ohne in Interpretationsprobleme zu geraten. Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition rekursiv auf solche Typen zurückgeführt werden können, kann man ""induktiv über deren Aufbau"" eine Bedeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeutung eine denotationale Semantik. Eine andere, für die praktische Programmierung relevantere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten oder realen, Hauptsache gut spezifizierten) Maschine abzubilden. Die Abbildung für Basistypen wie Rational oder Boolean ist in der Programmiersprache bzw. deren Compiler gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann dies hingegen nicht der Fall sein; deren Bedeutung kann aber vom Compiler, wiederum ""induktiv über deren Aufbau"", aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Man nennt dies dann auch eine operationale Semantik. Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht ""hart verdrahtet"" ist, sondern auf dynamisches Binden abgewälzt wird, so sind dennoch mindestens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und Float (nicht jedoch Fraction!) sind ""fest verdrahtet"", inklusive der Vergleichsrelationen (die ja die Wahrheitswerte zum Ergebnis haben). Wenn Sie Kurs 01661 (""Datenstrukturen"") bereits belegt haben oder ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen. Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrieben, deren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs: 1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte keinen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die Operationen ausgeführt werden, nicht ihren Zustand wechseln. Stattdessen geben Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also gewissermaßen alle unveränderlich (vgl. Kurseinheit 1, Abschnitt 4.3.5). 2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar vom Typ des Datentyps selbst. Dieses Argument entspricht in der objektorientierten Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self. Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Programmiersprache mit einer Semantik zu versehen.",Was ist eine denotationale Semantik?,"Eine denotationale Semantik ist eine Möglichkeit, einem Typ und seinen Operationen eine Bedeutung zu geben, indem sie auf externe Formalismen abgebildet werden. Ein klassisches Beispiel hierfür ist der Typ Boolean, der auf die boolesche Algebra abgebildet wird."
"Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean: Alle seine Operationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergebnis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte externe Formalismen abzubilden. Im Beispiel von Boolean ist dies natürlich die boolesche Algebra. Jeder, der die boolesche Algebra kennt und akzeptiert, wird auch den Typ Boolean sofort verstehen und akzeptieren (sofern er den Erwartungen entsprechend definiert ist). Entsprechend lässt sich ein Typ Fraction mit den Operationen +, –, *, und / definieren, der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-gleichsoperationen wie =, >, <, etc. hinzufügen, ohne in Interpretationsprobleme zu geraten. Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition rekursiv auf solche Typen zurückgeführt werden können, kann man ""induktiv über deren Aufbau"" eine Bedeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeutung eine denotationale Semantik. Eine andere, für die praktische Programmierung relevantere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten oder realen, Hauptsache gut spezifizierten) Maschine abzubilden. Die Abbildung für Basistypen wie Rational oder Boolean ist in der Programmiersprache bzw. deren Compiler gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann dies hingegen nicht der Fall sein; deren Bedeutung kann aber vom Compiler, wiederum ""induktiv über deren Aufbau"", aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Man nennt dies dann auch eine operationale Semantik. Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht ""hart verdrahtet"" ist, sondern auf dynamisches Binden abgewälzt wird, so sind dennoch mindestens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und Float (nicht jedoch Fraction!) sind ""fest verdrahtet"", inklusive der Vergleichsrelationen (die ja die Wahrheitswerte zum Ergebnis haben). Wenn Sie Kurs 01661 (""Datenstrukturen"") bereits belegt haben oder ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen. Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrieben, deren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs: 1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte keinen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die Operationen ausgeführt werden, nicht ihren Zustand wechseln. Stattdessen geben Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also gewissermaßen alle unveränderlich (vgl. Kurseinheit 1, Abschnitt 4.3.5). 2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar vom Typ des Datentyps selbst. Dieses Argument entspricht in der objektorientierten Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self. Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Programmiersprache mit einer Semantik zu versehen.",Wie können Typen in einer Programmiersprache mit Bedeutung versehen werden?,"Es gibt verschiedene Möglichkeiten, Typen in einer Programmiersprache mit Bedeutung zu versehen. Eine Möglichkeit ist, sie auf bekannte externe Formalismen abzubilden, wie beispielsweise die boolesche Algebra für den Typ Boolean. Eine andere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer Maschine abzubilden. Für von der Programmiererin definierte Typen kann die Bedeutung vom Compiler ""induktiv über deren Aufbau"" aus der Bedeutung von Typen abgeleitet werden, die eine vorgegebene Semantik haben. Diese Art der Semantik wird operationale Semantik genannt. Eine weitere Möglichkeit ist, Typen über abstrakte Datentypen zu definieren, die in der Programmiersprache syntaktisch als eine Menge von Operationen beschrieben werden, deren Operanden alle selbst typisiert sind."
"C-Sharp ist Microsofts Antwort auf Java. Oberflächlich betrachtet ähnelt es Java recht stark, dennoch enthält C-Sharp einige zusätzliche Merkmale von C++, aber auch von Microsofts hauseigener Sprache, Visual Basic. Dabei ist die Entwicklung von C-Sharp wohl weniger ein Versuch, mit Microsofts eigener Marktmacht einen proprietären Standard durchzusetzen (was bei Programmiersprachen meines Wissens nach bisher noch nie gelungen ist), sondern vielmehr dem Umstand geschuldet, dass Java keine volle Kontrolle über Hardware und Betriebssystem bietet und somit nicht für jede kommerzielle Softwareentwicklung geeignet ist. Zwar hat sich Sun bemüht, bekannte Schwächen zu beheben, doch gestaltete sich dieser Prozess recht träge. Angesichts des nicht zu übersehenden Erfolgs von Java in der Entwicklergemeinschaft war die Entwicklung einer eigenen, Java-ähnlichen, aber dennoch in wichtigen Punkten unterschiedlichen Sprache eigentlich nur folgerichtig.",Was ist C-Sharp und wie unterscheidet es sich von Java?,"C-Sharp ist eine von Microsoft entwickelte Programmiersprache, die Java ähnelt, aber auch Merkmale von C++ und Visual Basic enthält. Im Gegensatz zu Java bietet C-Sharp volle Kontrolle über Hardware und Betriebssystem, was es für die kommerzielle Softwareentwicklung geeigneter macht. Die Entwicklung von C-Sharp war eher eine Reaktion auf die Schwächen von Java und die Notwendigkeit einer schnelleren Entwicklungsumgebung als ein Versuch, mit Microsofts Marktmacht einen proprietären Standard durchzusetzen."
"In SMALLTALK gibt es keine frei bezeichenbaren Konstanten, sondern nur Literale. Da verschiedene Vorkommen gleicher Literale jedoch (außer bei Symbolen) verschiedene Objekte erzeugen, sind Literale nicht für alle Zwecke ausreichend. Hierfür gibt es einen Trick, um dasselbe Literal mehrfach verwenden zu können, nämlich durch eine sogenannte konstante Methode.An einer konstanten Methode ist nichts weiter konstant, als dass sie immer dasselbe Objekt zurückgibt. Der Trick besteht darin, dass das zum Literal gehörende Objekt nur einmal, nämlich zur Übersetzungszeit der Methode, erzeugt wird, und die Ausführung der Methode immer auf dieses und damit dasselbe Objekt zurückgreift.",Was sind konstante Methoden?,"Konstante Methoden sind Methoden, die immer dasselbe Objekt zurückgeben. Sie werden häufig verwendet, um Literale auf eine Weise zu repräsentieren, die sicherstellt, dass sie konsistent sind und immer auf dasselbe Objekt verweisen."
"In SMALLTALK gibt es keine frei bezeichenbaren Konstanten, sondern nur Literale. Da verschiedene Vorkommen gleicher Literale jedoch (außer bei Symbolen) verschiedene Objekte erzeugen, sind Literale nicht für alle Zwecke ausreichend. Hierfür gibt es einen Trick, um dasselbe Literal mehrfach verwenden zu können, nämlich durch eine sogenannte konstante Methode.An einer konstanten Methode ist nichts weiter konstant, als dass sie immer dasselbe Objekt zurückgibt. Der Trick besteht darin, dass das zum Literal gehörende Objekt nur einmal, nämlich zur Übersetzungszeit der Methode, erzeugt wird, und die Ausführung der Methode immer auf dieses und damit dasselbe Objekt zurückgreift.",Warum werden konstante Methoden verwendet?,"Konstante Methoden werden verwendet, um sicherzustellen, dass bestimmte Literale in einem Programm konsistent sind und immer auf dasselbe Objekt verweisen. Dies ist wichtig, um Probleme im Zusammenhang mit Objektidentität und Vergleichen zu vermeiden."
"Es gibt jedoch zwei Probleme. Das erste ist offensichtlich: Bei einer erneuten Übersetzung der Methode wird auch ein neues Objekt erzeugt, das dann nicht mehr identisch ist mit dem früher zurückgegebenen (abgesehen von den bereits bekannten Ausnahmen). Das kann zu Problemen führen, wenn das früher zurückgegebene Objekt in Variablen gespeichert wurde und nun mit dem neuen auf Identität verglichen werden soll. Daher sollte man dies tunlichst vermeiden.Das zweite Problem ist subtiler: Bei der konstanten Methode eines Objekts o und nach Auswertung der Anweisungen b := o konstanteMethode. enthält b an erster Stelle ebenfalls eine 0! Die vermeintlich konstante Methode ist also alles andere als konstant! Interessanterweise ist das Ergebnis dieses Experiments genau das Gegenteil dessen, was wir erwartet hätten.Zumindest das zweite Problem lässt sich eindämmen, indem man auf Sprachebene durch Literale erzeugte Objekte als unveränderlich annimmt und Änderungen der Art von b := o konstanteMethode. vermeidet. Die eigentliche Erkenntnis ist jedoch, dass die Referenzsemantik von Variablen und das damit verbundene Aliasing von Objekten zu höchst subtilen Problemen führen kann, derer man sich immer bewusst sein sollte.",Was ist ein Problem bei konstanten Methoden?,"Bei der erneuten Übersetzung einer Methode mit einer konstanten Methode wird möglicherweise ein neues Objekt erzeugt, das nicht identisch mit dem zuvor zurückgegebenen Objekt ist. Dies kann zu Problemen führen, wenn das zuvor zurückgegebene Objekt in Variablen gespeichert wurde und mit dem neuen Objekt auf Identität verglichen wird."
"Auch wenn es in großen Teilen recht ähnlich aussieht, weicht das Typsystem von C-Sharp in mehreren wesentlichen Punkten von dem von Java ab: der Art der Unterscheidung von Wert- und Referenztypen, den angebotenen Typkonstruktoren für Wert- und Referenztypen und dem Umgang mit Interfaces als Typen.",Wie unterscheidet sich das Typsystem von C-Sharp von dem von Java?,"Das Typsystem von C-Sharp unterscheidet sich von dem von Java in der Art der Unterscheidung von Wert- und Referenztypen, den angebotenen Typkonstruktoren für Wert- und Referenztypen und dem Umgang mit Interfaces als Typen."
"Auch wenn es in großen Teilen recht ähnlich aussieht, weicht das Typsystem von C-Sharp in mehreren wesentlichen Punkten von dem von Java ab: der Art der Unterscheidung von Wert- und Referenztypen, den angebotenen Typkonstruktoren für Wert- und Referenztypen und dem Umgang mit Interfaces als Typen.",Wann wird in C-Sharp die Unterscheidung von Wert- und Referenztypen getroffen?,In C-Sharp wird die Unterscheidung von Wert- und Referenztypen dynamisch zur Laufzeit getroffen.
"Auch wenn es in großen Teilen recht ähnlich aussieht, weicht das Typsystem von C-Sharp in mehreren wesentlichen Punkten von dem von Java ab: der Art der Unterscheidung von Wert- und Referenztypen, den angebotenen Typkonstruktoren für Wert- und Referenztypen und dem Umgang mit Interfaces als Typen.",Welche Typkonstruktoren bietet C-Sharp für Wert- und Referenztypen an?,"C-Sharp bietet für Wert-Typen die Typkonstruktoren struct und enum, für Referenz-Typen die Typkonstruktoren class und interface an."
"Auch wenn es in großen Teilen recht ähnlich aussieht, weicht das Typsystem von C-Sharp in mehreren wesentlichen Punkten von dem von Java ab: der Art der Unterscheidung von Wert- und Referenztypen, den angebotenen Typkonstruktoren für Wert- und Referenztypen und dem Umgang mit Interfaces als Typen.",Wie werden Interfaces in C-Sharp verwendet?,"In C-Sharp können Interfaces als Typen verwendet werden, das heißt, dass eine Variable einen Interface-Typ haben kann."
"Darüber hinaus hat C-Sharp noch eine ganze Reihe weiterer Verbesserungen, die mit dem Typsystem in Verbindung gebracht werden können; auf sie wird hier aber nur am Rande eingegangen.",Welche Verbesserungen bietet C-Sharp in Verbindung mit dem Typsystem?,"C-Sharp bietet eine ganze Reihe von Verbesserungen in Verbindung mit dem Typsystem, auf die hier aber nicht näher eingegangen wird."
"Darüber hinaus hat C-Sharp noch eine ganze Reihe weiterer Verbesserungen, die mit dem Typsystem in Verbindung gebracht werden können; auf sie wird hier aber nur am Rande eingegangen.","Was sind die Verbesserungen von C-Sharp im Vergleich zu C++, die mit dem Typsystem in Verbindung gebracht werden können?","C-Sharp hat eine ganze Reihe weiterer Verbesserungen im Vergleich zu C++, die mit dem Typsystem in Verbindung gebracht werden können, wie zum Beispiel die Unterstützung von generischen Typen, die eine bessere Typsicherheit und eine bessere Leistung ermöglichen. C-Sharp hat auch eine bessere Unterstützung für die Typparameter-Inferenz, die es dem Compiler ermöglicht, die Typparameter in generischen Typen automatisch zu ermitteln. Darüber hinaus hat C-Sharp eine bessere Unterstützung für die automatische Speicherverwaltung, die es dem Programmierer ermöglicht, sich weniger um die Speicherverwaltung kümmern zu müssen."
"Zuweisungsausdrücke setzen sich aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite zusammen. Wie bereits erwähnt, bewirken Zuweisungen als einzige Ausdrücke den Zustandswechsel von Objekten. Da eine Zuweisung selbst ein Ausdruck ist, kann sie auch auf der rechten Seite einer anderen Zuweisung erscheinen.",Was sind Zuweisungsausdrücke?,"Zuweisungsausdrücke bestehen aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite. Sie bewirken den Zustandswechsel von Objekten und sind die einzigen Ausdrücke, die dies tun."
"Zuweisungsausdrücke setzen sich aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite zusammen. Wie bereits erwähnt, bewirken Zuweisungen als einzige Ausdrücke den Zustandswechsel von Objekten. Da eine Zuweisung selbst ein Ausdruck ist, kann sie auch auf der rechten Seite einer anderen Zuweisung erscheinen.",Welche Auswirkung haben Zuweisungsausdrücke auf Objekte?,"Zuweisungsausdrücke ändern den Zustand von Objekten, indem sie neue Werte in Variablen zuweisen."
"Wie bereits in Kurseinheit 3, Abschnitt 29.4 erwähnt, erwirbt man mit einfachem parametrischem Polymorphismus außerhalb der Typdefinition Typsicherheit auf Kosten der fehlenden Typsicherheit innerhalb. Solange man keine Aussagen über den konkreten Typ machen kann, der für einen Typparameter eingesetzt wird, kann man bei der Implementierung einer Klasse, die den parametrischen Typ definiert, auch keine Eigenschaften der Objekte voraussetzen, die von dem (unbekannten) Typ sein sollen. Was man stattdessen benötigt, ist beschränkter parametrischer Polymorphismus. Natürlich gibt es diesen auch in Java.",Was ist beschränkter parametrischer Polymorphismus?,"Beschränkter parametrischer Polymorphismus ist eine Erweiterung des einfachen parametrischen Polymorphismus, bei dem man zusätzliche Bedingungen an den Typparameter stellen kann. Dadurch kann man bei der Implementierung einer Klasse, die den parametrischen Typ definiert, Eigenschaften der Objekte voraussetzen, die von dem (bekannten) Typ sein sollen."
"Wie bereits in Kurseinheit 3, Abschnitt 29.4 erwähnt, erwirbt man mit einfachem parametrischem Polymorphismus außerhalb der Typdefinition Typsicherheit auf Kosten der fehlenden Typsicherheit innerhalb. Solange man keine Aussagen über den konkreten Typ machen kann, der für einen Typparameter eingesetzt wird, kann man bei der Implementierung einer Klasse, die den parametrischen Typ definiert, auch keine Eigenschaften der Objekte voraussetzen, die von dem (unbekannten) Typ sein sollen. Was man stattdessen benötigt, ist beschränkter parametrischer Polymorphismus. Natürlich gibt es diesen auch in Java.",Was ist der Unterschied zwischen parametrischen Polymorphismus und beschränktem parametrischen Polymorphismus in Java?,"Parametrischer Polymorphismus in Java erlaubt es, eine Klasse oder Methode mit einem Typparameter zu definieren, der bei der Instanziierung mit einem konkreten Typ ersetzt wird. Beschränkter parametrischer Polymorphismus hingegen erlaubt es, zusätzlich zu dem Typparameter, bestimmte Eigenschaften des konkreten Typs vorauszusetzen, der für den Typparameter eingesetzt wird. Dadurch kann man in der Implementierung der Klasse oder Methode, die den Typparameter definiert, davon ausgehen, dass diese Eigenschaften beim konkreten Typ vorhanden sind, und diese nutzen."
"Die möglichen Werte der Typvariable ""E"" werden dadurch auf Typen eingeschränkt, die ""Comparable"" (direkt oder indirekt) erweitern. Die Implementierung der Methode zum Einfügen und Entfernen von Elementen in sortierten Listen kann also davon ausgehen, dass alle Objekte, die in einer solchen Liste gespeichert sind, die Methode ""compareTo(.)"" verstehen, die vom Interface ""Comparable"" vorgeschrieben wird. Beachten Sie, dass dadurch keine neue Subtypenrelation zwischen irgendwelchen Typen hergestellt wird. Es werden lediglich die Möglichkeiten eingeschränkt, konkrete Typen (z. B. in Variablendeklarationen) zu bilden. Wobei ""String"" ein Subtyp von ""Comparable"" ist, ist also möglich. Dennoch ist ""SortedList<String>"" kein Subtyp von ""SortedList<Comparable>"".","Was bedeutet es, wenn eine Typvariable auf einen generischen Typ eingeschränkt wird?","Wenn eine Typvariable auf einen generischen Typ eingeschränkt wird, werden die möglichen Werte der Typvariable auf Typen eingeschränkt, die den eingeschränkten Typ direkt oder indirekt erweitern. Dadurch werden die Möglichkeiten konkreter Typen (z.B. in Variablendeklarationen) zu bilden eingeschränkt. Es wird jedoch keine neue Subtypenrelation zwischen irgendwelchen Typen hergestellt."
"Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Die Genauigkeit dieser informellen Aussage hängt von der eher subtilen Frage ab, was einen Ausführungsfehler darstellt. Selbst wenn dies geklärt ist, ist die Typsicherheit einer Programmiersprache (das Fehlen bestimmter Ausführungsfehler in allen Programmläufen) eine nicht-triviale Eigenschaft. Eine sorgfältige Analyse ist erforderlich, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden. Als Konsequenz hat sich die Klassifikation, Beschreibung und Erforschung von Typsystemen zu einer formalen Disziplin entwickelt.",Was ist der Zweck eines Typsystems?,"Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern."
"Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Die Genauigkeit dieser informellen Aussage hängt von der eher subtilen Frage ab, was einen Ausführungsfehler darstellt. Selbst wenn dies geklärt ist, ist die Typsicherheit einer Programmiersprache (das Fehlen bestimmter Ausführungsfehler in allen Programmläufen) eine nicht-triviale Eigenschaft. Eine sorgfältige Analyse ist erforderlich, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden. Als Konsequenz hat sich die Klassifikation, Beschreibung und Erforschung von Typsystemen zu einer formalen Disziplin entwickelt.",Was ist Typsicherheit?,"Typsicherheit ist die Eigenschaft einer Programmiersprache, die das Fehlen bestimmter Ausführungsfehler in allen Programmläufen gewährleistet."
"Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Die Genauigkeit dieser informellen Aussage hängt von der eher subtilen Frage ab, was einen Ausführungsfehler darstellt. Selbst wenn dies geklärt ist, ist die Typsicherheit einer Programmiersprache (das Fehlen bestimmter Ausführungsfehler in allen Programmläufen) eine nicht-triviale Eigenschaft. Eine sorgfältige Analyse ist erforderlich, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden. Als Konsequenz hat sich die Klassifikation, Beschreibung und Erforschung von Typsystemen zu einer formalen Disziplin entwickelt.",Warum ist die Typsicherheit eine nicht-triviale Eigenschaft?,"Die Typsicherheit ist eine nicht-triviale Eigenschaft, weil eine sorgfältige Analyse erforderlich ist, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden."
"Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Die Genauigkeit dieser informellen Aussage hängt von der eher subtilen Frage ab, was einen Ausführungsfehler darstellt. Selbst wenn dies geklärt ist, ist die Typsicherheit einer Programmiersprache (das Fehlen bestimmter Ausführungsfehler in allen Programmläufen) eine nicht-triviale Eigenschaft. Eine sorgfältige Analyse ist erforderlich, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden. Als Konsequenz hat sich die Klassifikation, Beschreibung und Erforschung von Typsystemen zu einer formalen Disziplin entwickelt.","Warum hat sich die Klassifikation, Beschreibung und Erforschung von Typsystemen zu einer formalen Disziplin entwickelt?","Die Klassifikation, Beschreibung und Erforschung von Typsystemen hat sich zu einer formalen Disziplin entwickelt, weil die Typsicherheit eine nicht-triviale Eigenschaft ist und eine sorgfältige Analyse erforderlich ist, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden."
"Im Gegensatz zu SMALLTALK sind die meisten objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration (siehe Kapitel 19) Typen zugeordnet werden. Ein Typ beschränkt die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache. Wenn Sie eine solche Sprache neu erlernen, würden Sie normalerweise nicht daran denken, das Typsystem von der restlichen Sprachdefinition zu trennen. Dennoch sind Typen prinzipiell für das Funktionieren eines Programms entbehrlich, und es kann sich durchaus lohnen, das Typsystem einer Sprache von ihrem Rest zu isolieren, insbesondere wenn Sie es austauschen oder verbessern möchten. Dies gilt umso mehr, da gängige Typsysteme heute entweder ziemlich schwach oder ziemlich komplex sind.",Was ist der Unterschied zwischen SMALLTALK und typisierten objektorientierten Programmiersprachen?,"Im Gegensatz zu SMALLTALK sind die meisten objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration Typen zugeordnet werden. Ein Typ beschränkt die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache."
"Im Gegensatz zu SMALLTALK sind die meisten objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration (siehe Kapitel 19) Typen zugeordnet werden. Ein Typ beschränkt die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache. Wenn Sie eine solche Sprache neu erlernen, würden Sie normalerweise nicht daran denken, das Typsystem von der restlichen Sprachdefinition zu trennen. Dennoch sind Typen prinzipiell für das Funktionieren eines Programms entbehrlich, und es kann sich durchaus lohnen, das Typsystem einer Sprache von ihrem Rest zu isolieren, insbesondere wenn Sie es austauschen oder verbessern möchten. Dies gilt umso mehr, da gängige Typsysteme heute entweder ziemlich schwach oder ziemlich komplex sind.",Was ist der Unterschied zwischen typisierten und nicht typisierten Programmiersprachen?,"Im Gegensatz zu typisierten Programmiersprachen, in denen Programmelementen bei ihrer Deklaration Typen zugeordnet werden, sind nicht typisierte Sprachen so konzipiert, dass Typen bei der Deklaration entbehrlich sind. Typen beschränken die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache, aber in nicht typisierten Sprachen können Typen von der restlichen Sprachdefinition getrennt werden, um sie auszutauschen oder zu verbessern."
"Im Gegensatz zu SMALLTALK sind die meisten objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration (siehe Kapitel 19) Typen zugeordnet werden. Ein Typ beschränkt die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache. Wenn Sie eine solche Sprache neu erlernen, würden Sie normalerweise nicht daran denken, das Typsystem von der restlichen Sprachdefinition zu trennen. Dennoch sind Typen prinzipiell für das Funktionieren eines Programms entbehrlich, und es kann sich durchaus lohnen, das Typsystem einer Sprache von ihrem Rest zu isolieren, insbesondere wenn Sie es austauschen oder verbessern möchten. Dies gilt umso mehr, da gängige Typsysteme heute entweder ziemlich schwach oder ziemlich komplex sind.",Was ist der Zweck von Typen in objektorientierten Programmiersprachen?,"Der Zweck von Typen in objektorientierten Programmiersprachen ist es, Programmelementen bei ihrer Deklaration Typen zuzuordnen, die die Menge der Objekte beschränken, für die sie stehen können, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache und können das Funktionieren eines Programms sicherstellen."
"Daher führt diese Kurseinheit in Typsysteme am Beispiel von STRONGTALK ein, einer SMALLTALK-Erweiterung um ein optionales Typsystem. Sie geht dabei langsam und inkrementell vor. Wer das als zu langweilig empfindet, sei gewarnt: Es wird noch kompliziert genug, und nicht jede Leserin wird alles, was sie in diesem Kurs über Typsysteme liest, auf Anhieb verstehen. Es wäre auch eine Option, diese Kurseinheit anhand einer bekannteren Sprache mit einem obligatorischen Typsystem zu erstellen. Dies hätte jedoch den Nachteil, dass das konkrete Typsystem als gegeben angesehen werden müsste. Wenn Sie dann später eine andere Sprache kennenlernen, hätten Sie wahrscheinlich Schwierigkeiten, das Gelernte abzulegen und sich an die neuen Gegebenheiten anzupassen. Das Ziel dieser Kurseinheit ist jedoch, dass Sie Typsysteme als das verstehen, was sie sind: eine Möglichkeit zur Spezifikation redundanter Informationen, die die Qualität von Programmen erhöhen sollen.",Was ist STRONGTALK und wie wird es in dieser Kurseinheit eingeführt?,"STRONGTALK ist eine SMALLTALK-Erweiterung um ein optionales Typsystem. In dieser Kurseinheit wird es langsam und inkrementell eingeführt, um den Teilnehmerinnen die Möglichkeit zu geben, Typsysteme als das zu verstehen, was sie sind: eine Möglichkeit zur Spezifikation redundanter Informationen, die die Qualität von Programmen erhöhen sollen."
"Daher führt diese Kurseinheit in Typsysteme am Beispiel von STRONGTALK ein, einer SMALLTALK-Erweiterung um ein optionales Typsystem. Sie geht dabei langsam und inkrementell vor. Wer das als zu langweilig empfindet, sei gewarnt: Es wird noch kompliziert genug, und nicht jede Leserin wird alles, was sie in diesem Kurs über Typsysteme liest, auf Anhieb verstehen. Es wäre auch eine Option, diese Kurseinheit anhand einer bekannteren Sprache mit einem obligatorischen Typsystem zu erstellen. Dies hätte jedoch den Nachteil, dass das konkrete Typsystem als gegeben angesehen werden müsste. Wenn Sie dann später eine andere Sprache kennenlernen, hätten Sie wahrscheinlich Schwierigkeiten, das Gelernte abzulegen und sich an die neuen Gegebenheiten anzupassen. Das Ziel dieser Kurseinheit ist jedoch, dass Sie Typsysteme als das verstehen, was sie sind: eine Möglichkeit zur Spezifikation redundanter Informationen, die die Qualität von Programmen erhöhen sollen.","Warum ist es von Vorteil, Typsysteme anhand einer Sprache mit optionalem Typsystem zu lernen?","Es ist von Vorteil, Typsysteme anhand einer Sprache mit optionalem Typsystem zu lernen, weil man so die Grundlagen von Typsystemen verstehen und die Möglichkeit hat, das Gelernte auf andere Sprachen mit optionalen oder obligatorischen Typsystemen anzuwenden. Wenn man direkt mit einer Sprache mit obligatorischem Typsystem beginnt, besteht die Gefahr, dass man sich an die spezifischen Eigenschaften dieses Typsystems gewöhnt und Schwierigkeiten hat, das Gelernte auf andere Sprachen zu übertragen."
"Wenn Objekte ihren Zustand kapseln, ist es ausschließlich ihr Verhalten, welches ihn ändert, und somit das Verhalten, das Zustandsänderungen eines Objekts herbeiführt. Umgekehrt hängt das Verhalten eines Objekts in der Regel von seinem Zustand ab. Wie aber wird das Verhalten eines Objekts beschrieben? Bevor wir uns dieser Frage zuwenden, müssen wir zuerst den Begriff des Ausdrucks klären.",Was ist das Verhalten eines Objekts?,"Wenn Objekte ihren Zustand kapseln, ist ausschließlich sas Verhalten eines Objekts dafür verantwortlich, den Zustand eines Objekts zu ändern und die Interaktion mit diesem Objekt zu steuern. Das Verhalten bestimmt, wie ein Objekt auf Nachrichten reagiert und welche Operationen es auf seinem internen Zustand durchführt."
"Wenn Objekte ihren Zustand kapseln, ist es ausschließlich ihr Verhalten, welches ihn ändert, und somit das Verhalten, das Zustandsänderungen eines Objekts herbeiführt. Umgekehrt hängt das Verhalten eines Objekts in der Regel von seinem Zustand ab. Wie aber wird das Verhalten eines Objekts beschrieben? Bevor wir uns dieser Frage zuwenden, müssen wir zuerst den Begriff des Ausdrucks klären.",Warum hängt das Verhalten eines Objekts von seinem Zustand ab?,"Das Verhalten eines Objekts hängt in der Regel von seinem Zustand ab, weil der Zustand eines Objekts die Informationen enthält, die benötigt werden, um die richtigen Entscheidungen zu treffen und die entsprechenden Aktionen auszuführen. Das Verhalten eines Objekts basiert auf den Daten in seinem Zustand, und diese Daten beeinflussen, wie das Objekt auf Nachrichten reagiert."
"Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Ein Beispiel für einen rekursiven Typ hatten Sie oben schon kennengelernt: Der (zur Klasse Person gehörende) Typ Person hat Methoden, die Person als Parameter- bzw. Rückgabetypen haben. Rekursive Typen sind ein wichtiges Instrument der Programmierung. Ohne sie wären dynamische Strukturen wie beispielsweise verschachtelte Listen oder Bäume kaum möglich. Rekursive Typen bringen jedoch auch bestimmte Probleme mit sich. Zum Beispiel ist die strukturelle Äquivalenz zweier rekursiver Typen nicht so leicht festzustellen, da die dazu notwendige Expansion rekursiver Typen (das Einsetzen der Struktur für jeden darin vorkommenden Typnamen) unendlich große Definitionen ergeben kann.",Was sind rekursive Typen?,"Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Sie sind ein wichtiges Instrument der Programmierung, um dynamische Strukturen wie verschachtelte Listen oder Bäume zu ermöglichen. Allerdings bringen sie auch Probleme mit sich, wie zum Beispiel die Feststellung der strukturellen Äquivalenz zweier rekursiver Typen, die aufgrund der notwendigen Expansion unendlich große Definitionen ergeben kann."
"Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Ein Beispiel für einen rekursiven Typ hatten Sie oben schon kennengelernt: Der (zur Klasse Person gehörende) Typ Person hat Methoden, die Person als Parameter- bzw. Rückgabetypen haben. Rekursive Typen sind ein wichtiges Instrument der Programmierung. Ohne sie wären dynamische Strukturen wie beispielsweise verschachtelte Listen oder Bäume kaum möglich. Rekursive Typen bringen jedoch auch bestimmte Probleme mit sich. Zum Beispiel ist die strukturelle Äquivalenz zweier rekursiver Typen nicht so leicht festzustellen, da die dazu notwendige Expansion rekursiver Typen (das Einsetzen der Struktur für jeden darin vorkommenden Typnamen) unendlich große Definitionen ergeben kann.",Wozu werden rekursive Typen verwendet?,"Rekursive Typen werden verwendet, um dynamische Strukturen wie verschachtelte Listen oder Bäume zu definieren. Sie sind ein wichtiges Instrument der Programmierung, bringen aber auch Probleme mit sich, wie zum Beispiel die Schwierigkeit, die strukturelle Äquivalenz zweier rekursiver Typen festzustellen."
"Ein weiteres Problem ergibt sich, wenn man in einer parametrischen Typdefinition den Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel halten möchte, dieser Typ jedoch der definierte Typ ist (eine binäre Methode; siehe Fußnote 21 in Kapitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.",Was ist das Problem bei der Variabilität des Typs eines Methodenarguments in einer parametrischen Typdefinition?,"Das Problem ist, dass der Typ des Methodenarguments der definierte Typ ist und man dennoch den Typ variabel halten möchte. Zum Beispiel bei der Definition des Test auf Gleichheit, wo das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte."
"Ein weiteres Problem ergibt sich, wenn man in einer parametrischen Typdefinition den Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel halten möchte, dieser Typ jedoch der definierte Typ ist (eine binäre Methode; siehe Fußnote 21 in Kapitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.",Was ist das Problem bei der Verwendung von variablen Typen in einer parametrischen Typdefinition?,"Das Problem ist, dass der Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel sein soll, aber der Typ bereits definiert ist. Dies tritt auf, wenn man beispielsweise den Test auf Gleichheit so definieren möchte, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte."
"Ein weiteres Problem ergibt sich, wenn man in einer parametrischen Typdefinition den Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel halten möchte, dieser Typ jedoch der definierte Typ ist (eine binäre Methode; siehe Fußnote 21 in Kapitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.",Warum möchte man den Typ eines Methodenarguments variabel halten in einer parametrischen Typdefinition?,"Man möchte den Typ eines Methodenarguments variabel halten, um beispielsweise den Test auf Gleichheit so zu definieren, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte."
"Nun ist jedoch Number ein Subtyp von Object, sodass man die Deklaration von ""="" eigentlich aus Object übernehmen könnte, wenn der Typ des Parameters automatisch so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre man vielleicht versucht, den Gleichheitstest in Object einfach als ""= einObject <Self> ^ <Boolean>"" zu deklarieren, aber das würde, wenn die Pseudo-Typvariable Self beim Subtyping jeweils den Subtyp annimmt, zu einer kovarianten Redefinition mit den bereits bekannten Problemen führen. Auch hier bietet der parametrische Polymorphismus eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.",Was ist der parametrische Polymorphismus?,"Der parametrische Polymorphismus ist eine Technik in der objektorientierten Programmierung, bei der eine Funktion oder Methode mit verschiedenen Typen verwendet werden kann, indem die Typen als Parameter übergeben werden. In diesem Fall wird der Gleichheitstest in Object als parametrische Methode deklariert, die den Typ des Parameters automatisch an den definierten Typ anpasst."
"Nun ist jedoch Number ein Subtyp von Object, sodass man die Deklaration von ""="" eigentlich aus Object übernehmen könnte, wenn der Typ des Parameters automatisch so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre man vielleicht versucht, den Gleichheitstest in Object einfach als ""= einObject <Self> ^ <Boolean>"" zu deklarieren, aber das würde, wenn die Pseudo-Typvariable Self beim Subtyping jeweils den Subtyp annimmt, zu einer kovarianten Redefinition mit den bereits bekannten Problemen führen. Auch hier bietet der parametrische Polymorphismus eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.","Was ist das Problem bei der kovarianten Redefinition von ""="" in Object?","Das Problem bei der kovarianten Redefinition von ""="" in Object ist, dass es zu Problemen führen würde, wenn die Pseudo-Typvariable Self beim Subtyping jeweils den Subtyp annimmt."
"Nun ist jedoch Number ein Subtyp von Object, sodass man die Deklaration von ""="" eigentlich aus Object übernehmen könnte, wenn der Typ des Parameters automatisch so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre man vielleicht versucht, den Gleichheitstest in Object einfach als ""= einObject <Self> ^ <Boolean>"" zu deklarieren, aber das würde, wenn die Pseudo-Typvariable Self beim Subtyping jeweils den Subtyp annimmt, zu einer kovarianten Redefinition mit den bereits bekannten Problemen führen. Auch hier bietet der parametrische Polymorphismus eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.","Was ist der Unterschied zwischen Invarianz, Kovarianz und Kontravarianz?","Invarianz, Kovarianz und Kontravarianz sind Konzepte in der objektorientierten Programmierung, die sich auf die Beziehung zwischen dem Typ eines Objekts und dem Typ eines seiner Untertypen beziehen. Invarianz bedeutet, dass der Typ eines Objekts unverändert bleibt, wenn es in ein Untertyp-Objekt konvertiert wird. Kovarianz bedeutet, dass der Typ eines Objekts sich auf die gleiche Weise ändert wie der Typ des Untertyps, wenn es in ein Untertyp-Objekt konvertiert wird. Kontravarianz bedeutet, dass der Typ eines Objekts sich entgegengesetzt zum Typ des Untertyps ändert, wenn es in ein Untertyp-Objekt konvertiert wird."
"Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.",Was ist eine Typvariable?,"Eine Typvariable ist ein Platzhalter für einen Typ, der in diesem Fall verwendet wird, um den Typ des Parameters durch eine Variable zu ersetzen, um einen allgemeinen parametrischen Typ zu definieren."
"Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.",Wozu dient ein allgemeiner parametrischer Typ ?,"Ein allgemeiner parametrischer Typ dient dem Zweck, den Parametertyp des Tests variabel zu halten und nur für den Gleichheitstest verwendet zu werden."
"Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.",Was ist ein parametrischer Typ?,"Ein parametrischer Typ ist ein Typ, der einen oder mehrere Typvariablen enthält, die bei der Instanziierung durch konkrete Typen ersetzt werden. Dies ermöglicht die Erstellung von generischen Klassen und Methoden, die für verschiedene Typen verwendet werden können."
"Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.",Wozu dient ein parametrischer Typ im Gleichheitstest?,"Ein parametrischer Typ wird im Gleichheitstest verwendet, um den Typ des Parameters variabel zu halten und einen allgemeinen Gleichheitstest zu definieren, der für verschiedene Typen verwendet werden kann."
"Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht parametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.",Wie kann man Rekursion in einem parametrisierten Typ herstellen?,"Man kann die gewünschte Rekursion indirekt herstellen, indem man einen nicht parametrischen Typ als Subtyp des parametrisierten Typs Equatable definiert und gleichzeitig den zu definierenden Typ als tatsächlichen Typparameter einsetzt."
"Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht parametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.",Wie kann man Rekursion in Smalltalk definieren?,"In Smalltalk kann man Rekursion indirekt definieren, indem man einen nicht parametrischen Typ als Subtyp des parametrisierten Typs Equatable definiert und gleichzeitig als tatsächlichen Typparameter einsetzt."
"Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht parametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.",Wie kann man Rekursion in der Programmierung herstellen?,"Eine Möglichkeit, Rekursion in der Programmierung herzustellen, ist die Verwendung eines nicht parametrischen Typs als Subtyp eines parametrisierten Typs, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt."
"Genau diese Beschränkung des tatsächlichen Typparameters kann man nun mit einer stilistischen Figur erreichen, die vermutlich manch einen von Ihnen erhebliche Kopfschmerzen bereiten wird (zumindest macht sie das mir immer wieder aufs Neue): Man beschränkt den formalen Typparameter T von Equatable auf einen Subtyp von Equatable[T], wobei das Vorkommen von T in Equatable[T] eine Verwendung der gerade erst eingeführten Typvariable T darstellt.",Was ist eine stilistische Figur in Bezug auf den formalen Typparameter T von Equatable?,Eine stilistische Figur in Bezug auf den formalen Typparameter T von Equatable ist die Beschränkung von T auf einen Subtyp von Equatable[T].
"Wenn Sie hier ein Verständnisproblem haben, trösten Sie sich. Es dauert eine Weile, bis man es verstanden hat, und noch länger, bis solche Figuren zum aktiven Repertoire gehören. Gleichwohl sollten Sie sich damit befassen. Das Java-Collections-Framework in der Version von Java 5 ist voll solcher Typdefinitionen. Nicht weil sie schön sind, sondern weil man sie braucht, um das Framework typsicher zu machen, ohne seine Flexibilität zu opfern. Auch Sie werden, wenn Sie objektorientiert programmieren, über kurz oder lang solche Konstrukte verwenden müssen.",Wozu dienen Typdefinitionen in objektorientierter Programmierung?,"Typdefinitionen in objektorientierter Programmierung dienen dazu, das Framework typsicher zu machen, ohne seine Flexibilität zu opfern. Sie werden sie benötigen, wenn Sie objektorientiert programmieren."
"Wenn Sie hier ein Verständnisproblem haben, trösten Sie sich. Es dauert eine Weile, bis man es verstanden hat, und noch länger, bis solche Figuren zum aktiven Repertoire gehören. Gleichwohl sollten Sie sich damit befassen. Das Java-Collections-Framework in der Version von Java 5 ist voll solcher Typdefinitionen. Nicht weil sie schön sind, sondern weil man sie braucht, um das Framework typsicher zu machen, ohne seine Flexibilität zu opfern. Auch Sie werden, wenn Sie objektorientiert programmieren, über kurz oder lang solche Konstrukte verwenden müssen.",Warum werden komplexe Typdefinitionen in Java benötigt?,"Sie werden benötigt, um das Java-Collections-Framework typsicher zu machen, ohne seine Flexibilität zu opfern. Auch wenn man objektorientiert programmiert, wird man über kurz oder lang solche Konstrukte verwenden müssen."
"Das Programmiermodell von C++ ist ein klassisches: Programme werden als eine Menge von Quellcode-Dateien geschrieben, die auf einer Zielmaschine direkt in ausführbaren Maschinencode übersetzt werden. Die getrennte Übersetzung von Programmteilen ist dank sogenannter Header-Dateien möglich, die die Schnittstellen der Teile enthalten. Getrennt übersetzte Programmteile müssen vor der Ausführung verknüpft werden; das dynamische (Nach-)Laden von Funktionen ist möglich, muss aber explizit (programmgesteuert) erfolgen.",Was ist das Programmiermodell von C++?,"Das Programmiermodell von C++ ist ein klassisches Modell, bei dem Programme als eine Menge von Quellcode-Dateien geschrieben werden, die auf einer Zielmaschine direkt in ausführbaren Maschinencode übersetzt werden. Die getrennte Übersetzung von Programmteilen ist möglich, dank sogenannter Header-Dateien, die die Schnittstellen der Teile enthalten. Getrennt übersetzte Programmteile müssen vor der Ausführung verknüpft werden, und das dynamische (Nach-)Laden von Funktionen ist möglich, muss aber explizit (programmgesteuert) erfolgen."
C++ ist als objektorientierter Nachfolger von C konzipiert und ermöglicht so einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung. Dies ist besonders nützlich für die Migration von Altsystemen zur Objektorientierung. Infolgedessen zielt C++ auf die gleiche Klasse von Anwendungen wie C ab: maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen. Extreme Speicher- und Recheneffizienz sind dabei oft oberste Kriterien.,Was ist C++ und welche Art von Programmierung unterstützt es?,"C++ ist ein objektorientierter Nachfolger von C, der eine stufenlose Übergang von der prozeduralen zur objektorientierten Programmierung ermöglicht. Es zielt auf die gleiche Klasse von Anwendungen wie C ab, wie maschinennahe Programmierung bei Betriebs- oder eingebetteten Systemen. Extreme Speicher- und Recheneffizienz sind oft oberste Kriterien."
C++ ist als objektorientierter Nachfolger von C konzipiert und ermöglicht so einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung. Dies ist besonders nützlich für die Migration von Altsystemen zur Objektorientierung. Infolgedessen zielt C++ auf die gleiche Klasse von Anwendungen wie C ab: maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen. Extreme Speicher- und Recheneffizienz sind dabei oft oberste Kriterien.,Was ist C++ und wofür wird es eingesetzt?,"C++ ist ein objektorientierter Nachfolger von C, der einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung ermöglicht. Es wird hauptsächlich für maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen eingesetzt, bei denen extreme Speicher- und Recheneffizienz oft oberste Kriterien sind."
C++ ist als objektorientierter Nachfolger von C konzipiert und ermöglicht so einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung. Dies ist besonders nützlich für die Migration von Altsystemen zur Objektorientierung. Infolgedessen zielt C++ auf die gleiche Klasse von Anwendungen wie C ab: maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen. Extreme Speicher- und Recheneffizienz sind dabei oft oberste Kriterien.,Was ist C++ und welche Art von Anwendungen zielt es ab?,"C++ ist ein objektorientierter Nachfolger von C, der einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung ermöglicht. Es zielt auf die gleiche Klasse von Anwendungen wie C ab, wie maschinennahe Programmierung bei Betriebs- oder eingebetteten Systemen. Extreme Speicher- und Recheneffizienz sind oft oberste Kriterien."
"Dass Typerweiterung als Basis des Subtyping keine technischen Probleme bereitet, sollte hinreichend klargeworden sein: Typfehler sind damit ausgeschlossen, und es bleibt lediglich das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind (wie im Beispiel von zweidimensionalen und dreidimensionalen Punkten). Es bleibt noch die Frage, ob und falls ja, in welchem Umfang Typeinschränkung im Rahmen des Subtyping erlaubt ist. Diese Frage soll an einem Beispiel beantwortet werden.",Was ist Typerweiterung als Basis des Subtyping?,"Typerweiterung als Basis des Subtyping bedeutet, dass ein neuer Typ, der ein Supertyp ist, zusätzliche Eigenschaften und Methoden enthalten kann, aber die Eigenschaften und Methoden des Supertyps haben muss. Dadurch sind Typfehler ausgeschlossen, und es bleibt lediglich das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind."
"Dass Typerweiterung als Basis des Subtyping keine technischen Probleme bereitet, sollte hinreichend klargeworden sein: Typfehler sind damit ausgeschlossen, und es bleibt lediglich das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind (wie im Beispiel von zweidimensionalen und dreidimensionalen Punkten). Es bleibt noch die Frage, ob und falls ja, in welchem Umfang Typeinschränkung im Rahmen des Subtyping erlaubt ist. Diese Frage soll an einem Beispiel beantwortet werden.",Was ist Typerweiterung und warum bereitet sie keine technischen Probleme?,"Typerweiterung ist eine Möglichkeit, eine neue Unterklasse von einer bestehenden Klasse abzuleiten, indem neue Attribute und Methoden hinzugefügt werden. Es bereitet keine technischen Probleme, weil es keine Typfehler verursacht, da die Unterklasse alle Merkmale der Oberklasse erbt und zusätzliche Merkmale hinzufügen kann. Das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind, kann nicht immer vermieden werden, aber es ist kein technisches Problem."
"Welche Bedingungen sind an die Parametertypen bei der Redefinition zu stellen, damit eine Zuweisung eines Objekts vom Typ B an eine Variable vom Typ A in der Folge zu keiner Verletzung einer (anderen) Typinvariante führt? Die Antwort lässt sich systematisch herleiten. Es ergibt sich, dass sich bei einer Redefinition einer Methode die Eingabeparametertypen einer Funktion nur „nach oben“ (also zu einem Supertypen hin), die Ausgabeparameter hingegen nur „nach unten“ (hin zu einem Subtyp) verändern dürfen, wenn die Typkorrektheit eines Programms nicht verletzt werden soll.","Welche Bedingungen müssen an die Parametertypen bei der Redefinition einer Methode gestellt werden, um eine Verletzung einer Typinvariante zu vermeiden?","Die Typinvariante muss für den neuen Parametertyp und den alten Parametertyp gelten, d.h. der neue Parametertyp muss eine Unterklasse des alten Parametertyps sein."
"Welche Bedingungen sind an die Parametertypen bei der Redefinition zu stellen, damit eine Zuweisung eines Objekts vom Typ B an eine Variable vom Typ A in der Folge zu keiner Verletzung einer (anderen) Typinvariante führt? Die Antwort lässt sich systematisch herleiten. Es ergibt sich, dass sich bei einer Redefinition einer Methode die Eingabeparametertypen einer Funktion nur „nach oben“ (also zu einem Supertypen hin), die Ausgabeparameter hingegen nur „nach unten“ (hin zu einem Subtyp) verändern dürfen, wenn die Typkorrektheit eines Programms nicht verletzt werden soll.",Wie verändern sich die Eingabe- und Ausgabeparameter bei einer Methodenredefinition?,"Bei einer Methodenredefinition dürfen sich die Eingabeparameter nur zu einem Supertypen hin und die Ausgabeparameter nur zu einem Subtyp hin verändern, um die Typkorrektheit des Programms zu gewährleisten."
"Welche Bedingungen sind an die Parametertypen bei der Redefinition zu stellen, damit eine Zuweisung eines Objekts vom Typ B an eine Variable vom Typ A in der Folge zu keiner Verletzung einer (anderen) Typinvariante führt? Die Antwort lässt sich systematisch herleiten. Es ergibt sich, dass sich bei einer Redefinition einer Methode die Eingabeparametertypen einer Funktion nur „nach oben“ (also zu einem Supertypen hin), die Ausgabeparameter hingegen nur „nach unten“ (hin zu einem Subtyp) verändern dürfen, wenn die Typkorrektheit eines Programms nicht verletzt werden soll.",Was passiert bei der Redefinition einer Methode mit den Eingabe- und Ausgabeparametern?,"Bei der Redefinition einer Methode dürfen sich die Eingabeparameter nur zu einem Supertypen ändern, während die Ausgabeparameter nur zu einem Subtyp geändert werden dürfen, um die Typkorrektheit des Programms zu gewährleisten."
"Nun ändern sich aber bei der Redefinition einer Methode nicht nur die Parametertypen (Ein- und Ausgabe bzw. Rückgabe), sondern auch der Typ des Empfängers. Dieser ändert sich bei der Redefinition aber immer nach unten (da der redefinierende Typ ja als Subtyp vom redefinierten abgeleitet wird). Es folgt also, dass die Eingabeparameter zum Empfängertyp gegenläufig variieren müssen, der Ausgabeparameter hingegen gleichgerichtet. Man spricht im ersten Fall daher von einer Kontravarianz, im zweiten von einer Kovarianz, und sagt: Die Eingabeparameter sind kontravariant und der Ausgabeparameter ist kovariant. Man spricht im Kontext von Subtyping auch von Typkonformität des Subtypen mit dem Supertypen.",Was bedeutet Kontravarianz und Kovarianz bei der Redefinition von Methoden?,"Bei der Redefinition von Methoden bedeutet Kontravarianz, dass die Eingabeparameter zum Empfängertyp gegenläufig variieren, während Kovarianz bedeutet, dass der Ausgabeparameter gleichgerichtet variiert. Die Eingabeparameter sind kontravariant und der Ausgabeparameter ist kovariant."
"Nun ändern sich aber bei der Redefinition einer Methode nicht nur die Parametertypen (Ein- und Ausgabe bzw. Rückgabe), sondern auch der Typ des Empfängers. Dieser ändert sich bei der Redefinition aber immer nach unten (da der redefinierende Typ ja als Subtyp vom redefinierten abgeleitet wird). Es folgt also, dass die Eingabeparameter zum Empfängertyp gegenläufig variieren müssen, der Ausgabeparameter hingegen gleichgerichtet. Man spricht im ersten Fall daher von einer Kontravarianz, im zweiten von einer Kovarianz, und sagt: Die Eingabeparameter sind kontravariant und der Ausgabeparameter ist kovariant. Man spricht im Kontext von Subtyping auch von Typkonformität des Subtypen mit dem Supertypen.",Was ist Kontravarianz und Kovarianz?,"Kontravarianz und Kovarianz sind zwei Begriffe, die die Richtung der Variation von Parametern bei der Redefinition von Methoden beschreiben. Kontravarianz bezieht sich auf die Eingabeparameter, die gegenläufig zum Empfängertyp variieren, während Kovarianz sich auf den Ausgabeparameter bezieht, der gleichgerichtet zum Empfängertyp variiert."
"Nun ändern sich aber bei der Redefinition einer Methode nicht nur die Parametertypen (Ein- und Ausgabe bzw. Rückgabe), sondern auch der Typ des Empfängers. Dieser ändert sich bei der Redefinition aber immer nach unten (da der redefinierende Typ ja als Subtyp vom redefinierten abgeleitet wird). Es folgt also, dass die Eingabeparameter zum Empfängertyp gegenläufig variieren müssen, der Ausgabeparameter hingegen gleichgerichtet. Man spricht im ersten Fall daher von einer Kontravarianz, im zweiten von einer Kovarianz, und sagt: Die Eingabeparameter sind kontravariant und der Ausgabeparameter ist kovariant. Man spricht im Kontext von Subtyping auch von Typkonformität des Subtypen mit dem Supertypen.",Was ist Subtyping?,"Subtyping, auch bekannt als Typkonformität, ist eine Beziehung zwischen zwei Typen, bei der der Subtyp die Eigenschaften des Supertyps erbt und somit mit ihm kompatibel ist."
"Nun ändern sich aber bei der Redefinition einer Methode nicht nur die Parametertypen (Ein- und Ausgabe bzw. Rückgabe), sondern auch der Typ des Empfängers. Dieser ändert sich bei der Redefinition aber immer nach unten (da der redefinierende Typ ja als Subtyp vom redefinierten abgeleitet wird). Es folgt also, dass die Eingabeparameter zum Empfängertyp gegenläufig variieren müssen, der Ausgabeparameter hingegen gleichgerichtet. Man spricht im ersten Fall daher von einer Kontravarianz, im zweiten von einer Kovarianz, und sagt: Die Eingabeparameter sind kontravariant und der Ausgabeparameter ist kovariant. Man spricht im Kontext von Subtyping auch von Typkonformität des Subtypen mit dem Supertypen.",Was versteht man unter Typkonformität im Kontext von Subtyping?,"Typkonformität im Kontext von Subtyping bedeutet, dass der Subtyp den vom Supertypen definierten Vertrag einhält und somit kompatibel mit dem Supertypen ist. Das heißt, dass der Subtyp alle Methoden und Eigenschaften des Supertyps besitzt und die Methoden des Supertyps korrekt implementiert. Dadurch kann der Subtyp an jeder Stelle eingesetzt werden, an der der Supertyp erwartet wird."
"Nun enthält die Idee von der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren einen kleinen Schönheitsfehler: Wenn es sich nämlich bei der Eingabe in eine Funktion und bei ihrer Ausgabe um dasselbe Objekt handelt, kann diesem nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden, denn der Subtyp verlangt ja mehr Eigenschaften, als der Supertyp garantiert.",Was ist das Problem bei der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren?,"Das Problem ist, dass wenn das Eingabe-Objekt und das Ausgabe-Objekt identisch sind, nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden kann, da der Subtyp mehr Eigenschaften verlangt als der Supertyp garantiert."
"Nun enthält die Idee von der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren einen kleinen Schönheitsfehler: Wenn es sich nämlich bei der Eingabe in eine Funktion und bei ihrer Ausgabe um dasselbe Objekt handelt, kann diesem nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden, denn der Subtyp verlangt ja mehr Eigenschaften, als der Supertyp garantiert.",Was ist der Schönheitsfehler bei der Idee von der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren?,"Der Schönheitsfehler ist, dass wenn es sich bei der Eingabe in eine Funktion und bei ihrer Ausgabe um dasselbe Objekt handelt, kann diesem nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden, denn der Subtyp verlangt ja mehr Eigenschaften, als der Supertyp garantiert."
"Nun enthält die Idee von der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren einen kleinen Schönheitsfehler: Wenn es sich nämlich bei der Eingabe in eine Funktion und bei ihrer Ausgabe um dasselbe Objekt handelt, kann diesem nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden, denn der Subtyp verlangt ja mehr Eigenschaften, als der Supertyp garantiert.",Warum kann einem Objekt nicht einmal ein Supertyp und einmal ein Subtyp zugedacht werden?,"Das ist nicht möglich, weil ein Subtyp mehr Eigenschaften verlangt als ein Supertyp garantiert. Wenn es sich bei der Eingabe in eine Funktion und bei ihrer Ausgabe um dasselbe Objekt handelt, kann diesem nicht einmal ein Supertyp und einmal ein Subtyp zugedacht werden, da dies zu inkonsistenten Zuständen führen würde."
"Da das Umgekehrte freilich auch nicht geht, bleibt nichts anderes, als die Unveränderlichkeit der Parametertypen, auch als Invarianz oder besser (da das dazu passende Adjektiv „invariant“ in seiner Bedeutung schon belegt ist) als Novarianz bezeichnet, zu verlangen.",Was ist Novarianz?,Novarianz ist die Unveränderlichkeit der Parametertypen in einem Programm.
"Da das Umgekehrte freilich auch nicht geht, bleibt nichts anderes, als die Unveränderlichkeit der Parametertypen, auch als Invarianz oder besser (da das dazu passende Adjektiv „invariant“ in seiner Bedeutung schon belegt ist) als Novarianz bezeichnet, zu verlangen.",Was bedeutet Novarianz?,"Novarianz bedeutet, dass die Parametertypen unveränderlich sein müssen, um die Integrität der Objekte zu gewährleisten. Diese Unveränderlichkeit wird auch als Invarianz bezeichnet."
"Obige analytischen Überlegungen führen also, mit der eben gemachten Einschränkung, zur Regel von den kontravarianten Parameter- und den kovarianten Rückgabetypredefinitionen. Es gibt aber noch einen zweiten Ansatz zur Klärung der Frage nach der richtigen Varianz der Parametertypen redefinierter Funktionen, die diese Betrachtung deutlich in Frage stellen. Dazu soll (wie schon in Kapitel 25) die Interpretation von Methoden als Relationen bzw., da hier der Rückgabetyp mit berücksichtigt wird, als Funktionen oder Abbildungen herhalten. Der hier zweistellige Definitionsbereich (Empfängertyp plus Parametertyp) der Funktion steht dabei stellvertretend für beliebige Stellenzahl, also für Methoden mit beliebig vielen Parametern. Der Wertebereich ist hingegen immer einstellig, da eine Methode stets nur einen Wert zurückgibt.",Wie können Methoden als Relationen interpretiert werden?,"Methoden können als Relationen interpretiert werden, wobei der Definitionsbereich (Empfängertyp plus Parametertyp) stellvertretend für beliebige Stellenzahl steht und der Wertebereich einstellig ist, da eine Methode stets nur einen Wert zurückgibt."
"Obige analytischen Überlegungen führen also, mit der eben gemachten Einschränkung, zur Regel von den kontravarianten Parameter- und den kovarianten Rückgabetypredefinitionen. Es gibt aber noch einen zweiten Ansatz zur Klärung der Frage nach der richtigen Varianz der Parametertypen redefinierter Funktionen, die diese Betrachtung deutlich in Frage stellen. Dazu soll (wie schon in Kapitel 25) die Interpretation von Methoden als Relationen bzw., da hier der Rückgabetyp mit berücksichtigt wird, als Funktionen oder Abbildungen herhalten. Der hier zweistellige Definitionsbereich (Empfängertyp plus Parametertyp) der Funktion steht dabei stellvertretend für beliebige Stellenzahl, also für Methoden mit beliebig vielen Parametern. Der Wertebereich ist hingegen immer einstellig, da eine Methode stets nur einen Wert zurückgibt.",Wie können Methoden interpretiert werden?,"Methoden können als Relationen interpretiert werden, oder, da hier der Rückgabetyp mit berücksichtigt wird, als Funktionen oder Abbildungen."
"Obige analytischen Überlegungen führen also, mit der eben gemachten Einschränkung, zur Regel von den kontravarianten Parameter- und den kovarianten Rückgabetypredefinitionen. Es gibt aber noch einen zweiten Ansatz zur Klärung der Frage nach der richtigen Varianz der Parametertypen redefinierter Funktionen, die diese Betrachtung deutlich in Frage stellen. Dazu soll (wie schon in Kapitel 25) die Interpretation von Methoden als Relationen bzw., da hier der Rückgabetyp mit berücksichtigt wird, als Funktionen oder Abbildungen herhalten. Der hier zweistellige Definitionsbereich (Empfängertyp plus Parametertyp) der Funktion steht dabei stellvertretend für beliebige Stellenzahl, also für Methoden mit beliebig vielen Parametern. Der Wertebereich ist hingegen immer einstellig, da eine Methode stets nur einen Wert zurückgibt.",Was ist der zweite Ansatz zur Klärung der Frage nach der richtigen Varianz der Parametertypen redefinierter Funktionen?,"Der zweite Ansatz zur Klärung der Frage nach der richtigen Varianz der Parametertypen redefinierter Funktionen ist die Interpretation von Methoden als Relationen bzw. als Funktionen oder Abbildungen. Hier steht der zweistellige Definitionsbereich (Empfängertyp plus Parametertyp) der Funktion stellvertretend für beliebige Stellenzahl, also für Methoden mit beliebig vielen Parametern. Der Wertebereich ist hingegen immer einstellig, da eine Methode stets nur einen Wert zurückgibt."
"Wenn man nun die Anzahl der Empfängerobjekte einschränkt (was ja beim Übergang zu einem Subtypen geschieht), dann schrumpft damit nicht nur der Wertebereich der Funktion (wie in Kapitel 25 schon illustriert), sondern auch die Menge der möglichen Eingabewerte (der zweite und alle weiteren Definitionsbereiche), die mit der bereits eingeschränkten Menge der Empfänger gemeinsam auftreten können. Es verhalten sich also nicht nur die Ergebnistypen, sondern auch die Parametertypen kovariant.","Was bedeutet es, wenn Parametertypen kovariant sind?","Wenn Parametertypen kovariant sind, dann schrumpft die Menge der möglichen Eingabewerte, wenn man die Anzahl der Empfängerobjekte einschränkt."
"Wenn man nun die Anzahl der Empfängerobjekte einschränkt (was ja beim Übergang zu einem Subtypen geschieht), dann schrumpft damit nicht nur der Wertebereich der Funktion (wie in Kapitel 25 schon illustriert), sondern auch die Menge der möglichen Eingabewerte (der zweite und alle weiteren Definitionsbereiche), die mit der bereits eingeschränkten Menge der Empfänger gemeinsam auftreten können. Es verhalten sich also nicht nur die Ergebnistypen, sondern auch die Parametertypen kovariant.",Was bedeutet kovariant?,"Kovariant bedeutet, dass die Parametertypen sich entsprechend der Variation der Ergebnistypen verhalten. Wenn also der Ergebnistyp eingeschränkt wird, werden auch die Parametertypen entsprechend eingeschränkt."
"Dieses Ergebnis ist gewissermaßen frustrierend, da es die soeben hergeleitete Kontravarianzregel für Parametertypen infrage stellt: Was programmiertechnisch möglich und sinnvoll erscheint, hat in der Realität (der Interpretation oder Semantik) keine Bedeutung. Auf der anderen Seite erklärt es aber, warum kontravariante Parameterredefinitionen in der Programmierpraxis nicht benötigt werden. Kovarianz für Parametertypen zuzulassen, so sinnvoll es auch zu sein scheint, erlaubt jedoch typinkorrekte Programme; Sie werden im Kontext der Programmiersprache EIFFEL (Kurseinheit 5, Abschnitt 52.5) noch ausführlicher auf das Problem und eine mögliche Lösung hingewiesen.",Was bedeutet die Kontravarianzregel für Parametertypen?,"Die Kontravarianzregel für Parametertypen bedeutet, dass eine Unterklasse eine Methode mit einem formellen Parameter vom Typ der Oberklasse aufrufen kann, wobei der tatsächliche Parameter vom Typ der Unterklasse ist. Diese Regel ist in der Realität jedoch nicht sinnvoll und wird in der Programmierpraxis nicht benötigt."
"Dieses Ergebnis ist gewissermaßen frustrierend, da es die soeben hergeleitete Kontravarianzregel für Parametertypen infrage stellt: Was programmiertechnisch möglich und sinnvoll erscheint, hat in der Realität (der Interpretation oder Semantik) keine Bedeutung. Auf der anderen Seite erklärt es aber, warum kontravariante Parameterredefinitionen in der Programmierpraxis nicht benötigt werden. Kovarianz für Parametertypen zuzulassen, so sinnvoll es auch zu sein scheint, erlaubt jedoch typinkorrekte Programme; Sie werden im Kontext der Programmiersprache EIFFEL (Kurseinheit 5, Abschnitt 52.5) noch ausführlicher auf das Problem und eine mögliche Lösung hingewiesen.",Was bedeutet Kontravarianz für Parametertypen?,"Kontravarianz für Parametertypen bedeutet, dass eine Unterklasse einen Parametertyp eines übergeordneten Typs ersetzen kann. Dies ist in der Programmierpraxis jedoch nicht notwendig, da es in der Realität keine Bedeutung hat."
"Dieses Ergebnis ist gewissermaßen frustrierend, da es die soeben hergeleitete Kontravarianzregel für Parametertypen infrage stellt: Was programmiertechnisch möglich und sinnvoll erscheint, hat in der Realität (der Interpretation oder Semantik) keine Bedeutung. Auf der anderen Seite erklärt es aber, warum kontravariante Parameterredefinitionen in der Programmierpraxis nicht benötigt werden. Kovarianz für Parametertypen zuzulassen, so sinnvoll es auch zu sein scheint, erlaubt jedoch typinkorrekte Programme; Sie werden im Kontext der Programmiersprache EIFFEL (Kurseinheit 5, Abschnitt 52.5) noch ausführlicher auf das Problem und eine mögliche Lösung hingewiesen.",Was ist die Kontravarianzregel für Parametertypen?,"Die Kontravarianzregel für Parametertypen ist eine Regel in der objektorientierten Programmierung, die besagt, dass ein Untertyp eines Parametertyps als Argument für eine Methode verwendet werden kann, die den Obertyp des Parametertyps erwartet. Diese Regel wird infrage gestellt, weil sie in der Realität (der Interpretation oder Semantik) keine Bedeutung hat, aber in der Programmierpraxis nicht benötigt wird."
"Während der obige Leitspruch aus akademischer Sicht sicherlich richtig ist, können sich Praktikerinnen (und solche, die es werden wollen) diese Einstellung nicht erlauben. Stattdessen müssen sie die Programmiersprachen kennen, die auf dem Markt gefragt sind. In dieser Kurseinheit zeichnen sich die behandelten Sprachen, mit Ausnahme von EIFFEL, weniger durch revolutionäre Konzepte oder neuartige Sichtweisen aus, sondern vielmehr dadurch, dass sie in der Praxis weit verbreitet sind. Dennoch könnten einige Eigenheiten der einzelnen Sprachen Leserinnen Anlass geben, ihre bisherigen Denkweisen zu überprüfen.","Warum werden in der akademischen Sicht Programmiersprachen wie Java, C++ oder Python weniger durch revolutionäre Konzepte oder neuartige Sichtweisen ausgezeichnet?","In der akademischen Sicht werden Programmiersprachen wie Java, C++ oder Python weniger durch revolutionäre Konzepte oder neuartige Sichtweisen ausgezeichnet, sondern vielmehr durch ihre weite Verbreitung in der Praxis."
"Während der obige Leitspruch aus akademischer Sicht sicherlich richtig ist, können sich Praktikerinnen (und solche, die es werden wollen) diese Einstellung nicht erlauben. Stattdessen müssen sie die Programmiersprachen kennen, die auf dem Markt gefragt sind. In dieser Kurseinheit zeichnen sich die behandelten Sprachen, mit Ausnahme von EIFFEL, weniger durch revolutionäre Konzepte oder neuartige Sichtweisen aus, sondern vielmehr dadurch, dass sie in der Praxis weit verbreitet sind. Dennoch könnten einige Eigenheiten der einzelnen Sprachen Leserinnen Anlass geben, ihre bisherigen Denkweisen zu überprüfen.",Warum werden in der akademischen Sichtweise bestimmte Programmiersprachen bevorzugt?,"In der akademischen Sichtweise werden Programmiersprachen bevorzugt, die durch revolutionäre Konzepte oder neuartige Sichtweisen auffallen, anstatt durch ihre Verbreitung in der Praxis. Diese Sprachen können Leserinnen dazu ermutigen, ihre bisherigen Denkweisen zu überprüfen."
"Während der obige Leitspruch aus akademischer Sicht sicherlich richtig ist, können sich Praktikerinnen (und solche, die es werden wollen) diese Einstellung nicht erlauben. Stattdessen müssen sie die Programmiersprachen kennen, die auf dem Markt gefragt sind. In dieser Kurseinheit zeichnen sich die behandelten Sprachen, mit Ausnahme von EIFFEL, weniger durch revolutionäre Konzepte oder neuartige Sichtweisen aus, sondern vielmehr dadurch, dass sie in der Praxis weit verbreitet sind. Dennoch könnten einige Eigenheiten der einzelnen Sprachen Leserinnen Anlass geben, ihre bisherigen Denkweisen zu überprüfen.","Warum ist es wichtig für Praktikerinnen, die Programmiersprachen zu kennen, die auf dem Markt gefragt sind?","Für Praktikerinnen ist es wichtig, die Programmiersprachen zu kennen, die auf dem Markt gefragt sind, weil sie so in der Lage sind, die Sprachen zu verwenden, die in der Industrie und im Geschäftsleben am häufigsten eingesetzt werden. Dies erhöht ihre Beschäftigungsfähigkeit und ermöglicht es ihnen, an einer Vielzahl von Projekten zu arbeiten."
"Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark an die der englischen Sprache angelehnt ist. Sie verlangt ein Subjekt (den Empfänger der Nachricht), ein Prädikat (die Nachricht) sowie eine optionale Liste von Objekten als Prädikatsergänzungen (die Parameter der Nachricht). Dabei wird auf die in anderen Sprachen übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und Klammern zum Umschließen der Parameterliste verzichtet. Stattdessen verwendet man bei Zustandswechsel von zwei oder mehr Parametern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nachrichtenteile, die den Parametern vorangestellt werden. Ein Parameter kann auch eine Variable sein oder ein anderer Ausdruck.In SMALLTALK werden parameterlose Nachrichten auch als ""unär"" (unary messages) bezeichnet, da sie trotz fehlender expliziter Argumente als ""unär"" bezeichnet werden, weil der Empfänger das erste, implizite Argument ist. Nachrichten mit einem Parameter werden als ""binäre Nachrichten"" (binary messages) bezeichnet, da sie nur einen Parameter haben, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.Binäre Nachrichten bestehen aus einem oder mehreren nicht alphanumerischen Zeichen, die keine reservierten Zeichen sind. Alle anderen Nachrichten, die neben dem Empfänger mindestens ein Argument erfordern, werden in SMALLTALK Schlüsselwortnachrichten (keyword messages) genannt. Diese Nachrichten enthalten normalerweise keinen Schlüsselwort im herkömmlichen Sinne, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.",Welche Ausdrucksform ist neben der Zuweisung wichtig?,Neben der Zuweisung ist der Nachrichtenversand eine wichtige Ausdrucksform.
"Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark an die der englischen Sprache angelehnt ist. Sie verlangt ein Subjekt (den Empfänger der Nachricht), ein Prädikat (die Nachricht) sowie eine optionale Liste von Objekten als Prädikatsergänzungen (die Parameter der Nachricht). Dabei wird auf die in anderen Sprachen übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und Klammern zum Umschließen der Parameterliste verzichtet. Stattdessen verwendet man bei Zustandswechsel von zwei oder mehr Parametern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nachrichtenteile, die den Parametern vorangestellt werden. Ein Parameter kann auch eine Variable sein oder ein anderer Ausdruck.In SMALLTALK werden parameterlose Nachrichten auch als ""unär"" (unary messages) bezeichnet, da sie trotz fehlender expliziter Argumente als ""unär"" bezeichnet werden, weil der Empfänger das erste, implizite Argument ist. Nachrichten mit einem Parameter werden als ""binäre Nachrichten"" (binary messages) bezeichnet, da sie nur einen Parameter haben, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.Binäre Nachrichten bestehen aus einem oder mehreren nicht alphanumerischen Zeichen, die keine reservierten Zeichen sind. Alle anderen Nachrichten, die neben dem Empfänger mindestens ein Argument erfordern, werden in SMALLTALK Schlüsselwortnachrichten (keyword messages) genannt. Diese Nachrichten enthalten normalerweise keinen Schlüsselwort im herkömmlichen Sinne, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.",Was sind unäre Nachrichten?,"Unäre Nachrichten sind parameterlose Nachrichten, die den Empfänger als implizites erstes Argument haben."
"Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark an die der englischen Sprache angelehnt ist. Sie verlangt ein Subjekt (den Empfänger der Nachricht), ein Prädikat (die Nachricht) sowie eine optionale Liste von Objekten als Prädikatsergänzungen (die Parameter der Nachricht). Dabei wird auf die in anderen Sprachen übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und Klammern zum Umschließen der Parameterliste verzichtet. Stattdessen verwendet man bei Zustandswechsel von zwei oder mehr Parametern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nachrichtenteile, die den Parametern vorangestellt werden. Ein Parameter kann auch eine Variable sein oder ein anderer Ausdruck.In SMALLTALK werden parameterlose Nachrichten auch als ""unär"" (unary messages) bezeichnet, da sie trotz fehlender expliziter Argumente als ""unär"" bezeichnet werden, weil der Empfänger das erste, implizite Argument ist. Nachrichten mit einem Parameter werden als ""binäre Nachrichten"" (binary messages) bezeichnet, da sie nur einen Parameter haben, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.Binäre Nachrichten bestehen aus einem oder mehreren nicht alphanumerischen Zeichen, die keine reservierten Zeichen sind. Alle anderen Nachrichten, die neben dem Empfänger mindestens ein Argument erfordern, werden in SMALLTALK Schlüsselwortnachrichten (keyword messages) genannt. Diese Nachrichten enthalten normalerweise keinen Schlüsselwort im herkömmlichen Sinne, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.",Was sind binäre Nachrichten?,"Binäre Nachrichten sind Nachrichten mit einem Parameter, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument."
"Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark an die der englischen Sprache angelehnt ist. Sie verlangt ein Subjekt (den Empfänger der Nachricht), ein Prädikat (die Nachricht) sowie eine optionale Liste von Objekten als Prädikatsergänzungen (die Parameter der Nachricht). Dabei wird auf die in anderen Sprachen übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und Klammern zum Umschließen der Parameterliste verzichtet. Stattdessen verwendet man bei Zustandswechsel von zwei oder mehr Parametern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nachrichtenteile, die den Parametern vorangestellt werden. Ein Parameter kann auch eine Variable sein oder ein anderer Ausdruck.In SMALLTALK werden parameterlose Nachrichten auch als ""unär"" (unary messages) bezeichnet, da sie trotz fehlender expliziter Argumente als ""unär"" bezeichnet werden, weil der Empfänger das erste, implizite Argument ist. Nachrichten mit einem Parameter werden als ""binäre Nachrichten"" (binary messages) bezeichnet, da sie nur einen Parameter haben, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.Binäre Nachrichten bestehen aus einem oder mehreren nicht alphanumerischen Zeichen, die keine reservierten Zeichen sind. Alle anderen Nachrichten, die neben dem Empfänger mindestens ein Argument erfordern, werden in SMALLTALK Schlüsselwortnachrichten (keyword messages) genannt. Diese Nachrichten enthalten normalerweise keinen Schlüsselwort im herkömmlichen Sinne, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.",Was sind Schlüsselwortnachrichten in SMALLTALK?,"Schlüsselwortnachrichten sind Nachrichten in SMALLTALK, die neben dem Empfänger mindestens ein Argument erfordern. Sie enthalten normalerweise kein herkömmliches Schlüsselwort im Sinne von Schlüsselwort-Argumenten, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet."
"Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken, die die Teile des Nachrichtenselektors sperren. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.Da ein Nachrichtenausdruck für ein Objekt steht, kann er selbst Teil eines anderen Nachrichtenausdrucks sein, entweder als Empfänger der Nachricht oder als eines ihrer Argumente. In diesem Fall ist es möglicherweise notwendig, den geschachtelten Nachrichtenausdruck in Klammern zu setzen, um sicherzustellen, dass er korrekt erkannt wird.Die Kaskadierung ist eine syntaktische Abkürzung, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen.",Was ist ein Nachrichtenausdruck?,"Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger."
"Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken, die die Teile des Nachrichtenselektors sperren. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.Da ein Nachrichtenausdruck für ein Objekt steht, kann er selbst Teil eines anderen Nachrichtenausdrucks sein, entweder als Empfänger der Nachricht oder als eines ihrer Argumente. In diesem Fall ist es möglicherweise notwendig, den geschachtelten Nachrichtenausdruck in Klammern zu setzen, um sicherzustellen, dass er korrekt erkannt wird.Die Kaskadierung ist eine syntaktische Abkürzung, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen.",Was ist die Kaskadierung in SMALLTALK?,"Die Kaskadierung ist eine syntaktische Abkürzung in SMALLTALK, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen. Dies erleichtert das Verketten von Nachrichten an dasselbe Objekt."
"Es ist wichtig zu beachten, dass die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor die Bedeutung der Nachricht bestimmt. Die an das Objekt gesendete Nachricht, der sogenannte Nachrichtenselektor, ist immer ein Symbol, das aus der Konkatenation aller seiner Teile besteht. Die Namen der Nachrichtenteile sind frei wählbar, beginnen jedoch konventionell mit einem Kleinbuchstaben.Die Verwendung der Kaskadierung kann die Einführung temporärer Variablen in einigen Fällen vermeiden, insbesondere wenn ein Ausdruck, der das Empfängerobjekt liefert und nur einmal ausgewertet werden soll, anstelle einer Variablen steht.",Ist die Reihenfolge der Nachrichtenteile in SMALLTALK von Bedeutung?,"Die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor bestimmt die Bedeutung der Nachricht. Der Nachrichtenselektor selbst ist ein Symbol, das aus der Konkatenation aller seiner Teile besteht."
"Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.",Was ist das Hammerprinzip in der objektorientierten Programmierung?,"Das Hammerprinzip in der objektorientierten Programmierung bedeutet, dass Programmiererinnen dazu neigen, alle Probleme mit objektorientierter Programmierung zu lösen, auch wenn andere Programmierparadigmen besser geeignet wären."
"Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.",Warum sind Probleme mit hohem algorithmischen Anteil und einfachen Datenstrukturen weniger geeignet für die objektorientierte Programmierung?,"Probleme mit hohem algorithmischen Anteil und einfachen Datenstrukturen sind weniger geeignet für die objektorientierte Programmierung, da sie eine Zerfledderung des Codes durch die Datenbindung verursachen. Die Funktionalität wird in der objektorientierten Programmierung auf die Klassen aufgeteilt, die die Daten definieren, auf denen der Code arbeitet."
"Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.",Was ist weniger geeignet für die objektorientierte Programmierung?,"Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, sind weniger geeignet für die objektorientierte Programmierung."
"Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.",Was ist das Ziel der Objektorientierung?,"Das Ziel der Objektorientierung ist es, die Komplexität von Software zu reduzieren, indem sie die Software in kleinere, leichter zu verstehende Einheiten aufteilt, die Objekte genannt werden und Instanzen von Klassen sind."
"Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.","Warum ist die objektorientierte Programmierung nicht ideal, wenn das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten liegt?","In der objektorientierten Programmierung liegt der Fokus auf der Struktur der Daten, indem Objekte mit ihren Daten und Methoden im Vordergrund stehen. Wenn das Interesse jedoch hauptsächlich an der Struktur der Funktionen liegt, kann die objektorientierte Programmierung ineffizient sein, da die Funktionen auf zahlreiche Klassen aufgeteilt werden müssen. In solchen Fällen ist es besser, die Abläufe in einem Stück festzuhalten, um die Lesbarkeit und Wartbarkeit des Codes zu verbessern."
"So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.","Warum eignen sich Sprachen, die mehrere Programmierparadigmen erlauben, weniger für die Didaktik?","Sprachen, die mehrere Programmierparadigmen erlauben, sind für Anfängerinnen oft überfordernd, da sie eine große Auswahl an Konstrukten und eine unüberschaubare Anzahl von Alternativen bieten, um ein einzelnes Problem zu lösen."
"So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.",Was sind die Nachteile der objektorientierten Programmierung?,"Die Nachteile der objektorientierten Programmierung sind, dass die Organisation der Funktionen auf der Strecke bleibt und dass die Daten hin- und hergeschickt werden müssen."
"So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.",Was sind die Nachteile der prozeduralen Programmierung?,"Die Nachteile der prozeduralen Programmierung sind, dass die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt werden oder global sind."
"So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.","Was sind die Vorteile von Sprachen, die eine Mischung mehrerer Programmierparadigmen erlauben?","Die Vorteile von Sprachen, die eine Mischung mehrerer Programmierparadigmen erlauben, sind, dass sie eine größere Auswahl an Konstrukten bieten und eine unüberschaubare Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann."
"Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).",Was ist ein Impedanzmismatch zwischen relationalen Datenbanken und objektorientierten Programmen?,"Ein Impedanzmismatch zwischen relationalen Datenbanken und objektorientierten Programmen ist das Problem, dass sich beide Welten in ihrer Art und Weise unterscheiden, wie sie Daten und Beziehungen darstellen. Relationale Datenbanken sind wertbasiert und stellen Beziehungen über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen her, während objektorientierte Programme zeigerbasiert sind und Beziehungen über Referenzen und deren Dereferenzierung (Navigation) herstellen. Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Daher muss man sich, wenn relationale Daten durch objektorientierte Programme verarbeitet werden sollen, an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben."
"Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).",Was ist ein Impedanzmismatch?,"Ein Impedanzmismatch ist ein Problem, das auftritt, wenn relationale Daten durch objektorientierte Programme verarbeitet werden sollen. Dies liegt daran, dass relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Um dieses Problem zu lösen, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben."
"Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine Objektorientiertierung zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.","Warum kann es sinnvoll sein, eine relationale Datenbank für die Simulation einer Objektorientiertierung zu verwenden?","Es kann sinnvoll sein, eine relationale Datenbank für die Simulation einer objektorientierten zu verwenden, wenn bereits relationale Datenbanken im betrieblichen Umfeld erfolgreich eingesetzt werden und die Umstellung auf Objektorientierung in der Datenhaltung mit Risiken verbunden scheint. Die Daten sind häufig der eigentliche Wert eines Softwaresystems. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird durch ein Persistenzlayer erreicht, das Programm muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern."
"Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in Java über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C-Sharp über Funktionszeiger (Delegates in C-Sharp). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JavaSCRIPT seit Jahren einen heimlichen Siegeszug feiert).",Warum ist die objektorientierte Programmierung nicht gut für GUI-Programmierung geeignet?,"Objektorientierte Programmierung ist nicht gut für GUI-Programmierung geeignet, weil sich die Instanzen einer Klasse alle Methoden teilen, was es nicht möglich macht, für verschiedene Objekte derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Um dies zu erreichen, muss eine Indirektion eingebaut werden, wie zum Beispiel in Smalltalk über einen Block, in Java über anonyme innere Klassen, in C++ und C-Sharp über Funktionszeiger (Delegates in C-Sharp). Die prototypenbasierte Variante der objektorientierten Programmierung, wie sie in JavaScript verwendet wird, scheint hier besser geeignet zu sein."
"Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in Java über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C-Sharp über Funktionszeiger (Delegates in C-Sharp). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JavaSCRIPT seit Jahren einen heimlichen Siegeszug feiert).","Warum ist es nicht möglich, für verschiedene Instanzen einer Klasse verschiedene Implementierungen einer Methode anzugeben?","Da sich die Instanzen einer Klasse alle Methoden teilen, ist es nicht möglich, für verschiedene Instanzen derselben Klasse verschiedene Implementierungen einer Methode anzugeben."
"Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in Java über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C-Sharp über Funktionszeiger (Delegates in C-Sharp). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JavaSCRIPT seit Jahren einen heimlichen Siegeszug feiert).",Warum können in objektorientierter Programmierung nicht für verschiedene Instanzen einer Klasse verschiedene Implementierungen einer Methode angegeben werden?,"In objektorientierter Programmierung können für verschiedene Instanzen einer Klasse nicht verschiedene Implementierungen einer Methode angegeben werden, weil alle Instanzen einer Klasse dieselben Methoden teilen. Um dieses Problem zu lösen, können Indirektionen eingebaut werden, wie zum Beispiel in Smalltalk über einen Block, in Java über anonyme innere Klassen, in C++ und C-Sharp über Funktionszeiger (Delegates in C-Sharp). Eine bessere Eignung scheint hier die prototypenbasierte Variante der objektorientierten Programmierung zu haben, wie sie in JavaScript seit Jahren erfolgreich eingesetzt wird."
"In SMALLTALK werden Klassen erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Dies ist notwendig, da Instanzen, für die es keine literale Repräsentation gibt, in SMALLTALK grundsätzlich über Konstruktoren erstellt werden, und jede Klasse ist eine Instanz ihrer Metaklasse. Dies wirft die Frage auf, wie Klassen in SMALLTALK tatsächlich erzeugt werden können. Allein die Existenz eines Browsers mit entsprechender Funktion erklärt dies nicht ausreichend. Andererseits kann man auch nicht einfach ""new"" oder ähnliches an die Metaklasse einer Klasse senden, da diese zu diesem Zeitpunkt noch nicht existiert. Dies führt uns in gewisser Weise zur sprichwörtlichen Frage nach dem Huhn und dem Ei – genauer gesagt, wer von beiden zuerst existieren muss.",Wie werden Klassen in SMALLTALK erzeugt?,"In SMALLTALK werden Klassen erzeugt, indem einer anderen Klasse eine entsprechende Nachricht gesendet wird. Dies ist notwendig, da Instanzen, für die es keine literale Repräsentation gibt, in SMALLTALK grundsätzlich über Konstruktoren erstellt werden, und jede Klasse ist eine Instanz ihrer Metaklasse."
"Dieses Dilemma wird intern von SMALLTALK gelöst. Eine Klasse wird in SMALLTALK erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet.",Wie wird eine Klasse in SMALLTALK erzeugt?,"In SMALLTALK wird eine Klasse erzeugt, indem einer anderen Klasse eine entsprechende Nachricht gesendet wird."
"Dieses Dilemma wird intern von SMALLTALK gelöst. Eine Klasse wird in SMALLTALK erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet.","Welche Nachricht wird in SMALLTALK gesendet, um eine Klasse zu erzeugen?","Die Nachricht, die man sendet, um eine Klasse in SMALLTALK zu erzeugen, lautet 'subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:'."
"Dieses Dilemma wird intern von SMALLTALK gelöst. Eine Klasse wird in SMALLTALK erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet.",Was repräsentieren die Instanzvariablennamen in SMALLTALK?,"Die Instanzvariablennamen in SMALLTALK sind eine Liste von Symbolen, die die Namen der Instanzvariablen der neuen Klasse repräsentieren."
"Durch Ausführung dieser Methode wird eine neue Klasse und gleichzeitig ihre Metaklasse erstellt. Dem Kommentar kann entnommen werden, dass die neue Klasse eine Subklasse des Empfängers (einer Klasse) werden soll. Die Bedeutung dieses Vorgangs wird im Kapitel 11 näher erläutert. An dieser Stelle möchten wir uns eher der Frage widmen, welche Klassen die mit erzeugten Metaklassen als Instanzen haben.",Welche Klassen haben die erzeugten Metaklassen als Instanzen?,"Die erzeugten Metaklassen haben die Klasse ""Metaclass"" als Instanzen."
"Durch Ausführung dieser Methode wird eine neue Klasse und gleichzeitig ihre Metaklasse erstellt. Dem Kommentar kann entnommen werden, dass die neue Klasse eine Subklasse des Empfängers (einer Klasse) werden soll. Die Bedeutung dieses Vorgangs wird im Kapitel 11 näher erläutert. An dieser Stelle möchten wir uns eher der Frage widmen, welche Klassen die mit erzeugten Metaklassen als Instanzen haben.",Was wird durch Ausführung dieser Methode erstellt?,Durch Ausführung dieser Methode wird eine neue Klasse und gleichzeitig ihre Metaklasse erstellt.
"Am Anfang dieses Kapitels wurde von dem Mysterium des Nachrichtenversands gesprochen. Tatsächlich ist jedoch zumindest in SMALLTALK seine Realisierung in Form von Methodenaufrufen nur ein Kompromiss zugunsten der Ausführungseffizienz. In SMALLTALK sind Nachrichten (oder genauer gesagt Nachrichtenselektoren) selbst Objekte - schließlich soll in SMALLTALK alles ein Objekt sein. Um tatsächlich als Nachrichtenobjekt an ein anderes Objekt verschickt zu werden, muss man jedoch eine spezielle Methode (genauer gesagt, einen speziellen Methodenaufruf), nämlich ""perform:"", verwenden. Diese Methode ermöglicht es, einem Empfängerobjekt eine Nachricht als Objekt (wenn auch nur als Parameter von ""perform:"") zu senden. Das Empfängerobjekt reagiert darauf, indem es die zur Nachricht passende Methode ausführt, als hätte es direkt einen entsprechenden Methodenaufruf erhalten.Der Nachrichtenselektor ist immer ein Symbol und darf beim ""Versand"" mittels ""perform:"" anders als beim direkten Aufruf auch in einer Variable gespeichert sein. Bei binären und höherwertigen Nachrichten werden zusätzlich Argumente (Parameter) benötigt, die an den Nachrichtenselektor angehängt werden können. Dies erfolgt durch Erweiterung von ""perform:"" zu ""perform:with:"", ""perform:with:with:"", usw.",Wie kann man Nachrichten in SMALLTALK als Objekte verwenden?,"In SMALLTALK kann man Nachrichten (oder Nachrichtenselektoren) selbst als Objekte verwenden, indem man die Methode ""perform:"" verwendet. Diese Methode ermöglicht es, einem Empfängerobjekt eine Nachricht als Objekt zu senden, und das Empfängerobjekt führt die zur Nachricht passende Methode aus, als hätte es einen entsprechenden Methodenaufruf erhalten."
"Am Anfang dieses Kapitels wurde von dem Mysterium des Nachrichtenversands gesprochen. Tatsächlich ist jedoch zumindest in SMALLTALK seine Realisierung in Form von Methodenaufrufen nur ein Kompromiss zugunsten der Ausführungseffizienz. In SMALLTALK sind Nachrichten (oder genauer gesagt Nachrichtenselektoren) selbst Objekte - schließlich soll in SMALLTALK alles ein Objekt sein. Um tatsächlich als Nachrichtenobjekt an ein anderes Objekt verschickt zu werden, muss man jedoch eine spezielle Methode (genauer gesagt, einen speziellen Methodenaufruf), nämlich ""perform:"", verwenden. Diese Methode ermöglicht es, einem Empfängerobjekt eine Nachricht als Objekt (wenn auch nur als Parameter von ""perform:"") zu senden. Das Empfängerobjekt reagiert darauf, indem es die zur Nachricht passende Methode ausführt, als hätte es direkt einen entsprechenden Methodenaufruf erhalten.Der Nachrichtenselektor ist immer ein Symbol und darf beim ""Versand"" mittels ""perform:"" anders als beim direkten Aufruf auch in einer Variable gespeichert sein. Bei binären und höherwertigen Nachrichten werden zusätzlich Argumente (Parameter) benötigt, die an den Nachrichtenselektor angehängt werden können. Dies erfolgt durch Erweiterung von ""perform:"" zu ""perform:with:"", ""perform:with:with:"", usw.",Was ist der Nachrichtenselektor?,"Der Nachrichtenselektor ist der Name der Nachricht, die an ein Objekt gesendet wird. Der Nachrichtenselektor ist wichtig, da er angibt, welche Methode auf dem Empfängerobjekt aufgerufen werden soll."
"In Bezug auf verhaltensbasiertes Subtyping haben die Arbeiten von Barbara Liskov und Jeannette Wing die größte Bekanntheit erlangt. Tatsächlich ist das sogenannte Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) eines der am häufigsten diskutierten Themen im Zusammenhang mit Subtyping, daher sollte es hier ebenfalls behandelt werden. Ohne die Verdienste der beiden schmälern zu wollen, sollte jedoch beachtet werden, dass die Anerkennung dieser Prinzipien nicht ausschließlich auf ihre Arbeit beschränkt ist. Es gab frühere Arbeiten, die ebenfalls Anerkennung verdienen, und außerdem ist das LSP, wie Sie noch sehen werden, zu streng formuliert und schließt nützliche und praxisrelevante Fälle des verhaltensbasierten Subtypings aus.",Was ist Liskov-Substitutionsprinzip (LSP)?,"Das Liskov-Substitutionsprinzip (LSP) ist ein Prinzip im Zusammenhang mit verhaltensbasiertem Subtyping. Es besagt, dass ein Objekt der Unterklasse eines anderen Objekts der Oberklasse ohne Einschränkung der Korrektheit des Programms ersetzt werden kann. Es ist eines der am häufigsten diskutierten Themen im Zusammenhang mit Subtyping."
"Der historische Hintergrund des Liskov-Substitutionsprinzips bestand darin, eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen zu finden. Wie wir bereits in Kapitel 26 (Einheit 3) festgestellt hatten, reicht es in den meisten Programmiersprachen aus, wenn ein Typ B deklariert, ein Subtyp eines Typs A zu sein, damit die Zuweisungskompatibilität von B nach A festgestellt werden kann. Hierbei war es jedoch erforderlich, dass die Eigenschaften von A auf B übertragen (vererbt) wurden und dabei die Regeln für die ko- bzw. kontravariante Neudeklaration von Parametertypen eingehalten wurden. Dies wird im Allgemeinen durch die Sprachdefinition und den Compiler sichergestellt.",Was ist das Liskov-Substitutionsprinzip?,"Das Liskov-Substitutionsprinzip ist eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen. Es besagt, dass ein Typ B, der als Subtyp eines Typs A deklariert ist, in einem Programm an allen Stellen, an denen ein Objekt vom Typ A erwartet wird, durch ein Objekt vom Typ B ersetzt werden kann, ohne dass das Programm dadurch in seiner Funktionalität beeinträchtigt wird."
"Das verhaltensbezogene Subtyping geht über die syntaktische Subtypenbeziehung hinaus, die sich auf die Kontrolle der Parametertypen beschränkt, und fordert stattdessen, dass sich Objekte eines Subtyps und seines Supertyps gleich verhalten sollten. Dies sollte für jeden erkennbar sein, der das Objekt oder ein beliebiges Programm, das es verwendet, betrachtet. Diese Forderung kulminiert in der Regel als ""Subtype Requirement"": ""Lassen Sie φ(x) eine über Objekte x des Typs T bewiesene Eigenschaft sein. Dann sollte φ(y) für Objekte y des Typs S wahr sein, wobei S ein Subtyp von T ist."" Eine deutsche Paraphrase dieser Idee wurde bereits im Abschnitt 26.1 gegeben.",Was ist verhaltensbezogenes Subtyping?,"Verhaltensbezogenes Subtyping geht über die syntaktische Subtypenbeziehung hinaus und fordert, dass sich Objekte eines Subtyps und seines Supertyps gleich verhalten sollten. Diese Forderung wird als ""Subtype Requirement"" bezeichnet und besagt, dass eine Eigenschaft, die für Objekte eines Typs gilt, auch für Objekte eines Subtyps gelten sollte."
"Diese Definition weist mehrere problematische Aspekte auf: Da sie die Subtypenbeziehung definiert, wird davon ausgegangen, dass x genau vom Typ T und y genau vom Typ S ist. Dies bedeutet insbesondere, dass x und y keine Objekte von Subtypen von T bzw. S sein können. Daher ist diese Definition nicht auf abstrakte Typen und Interfaces anwendbar. Die Aussage ist unabhängig von einem konkreten Gebrauch der Objekte. Wie im Abschnitt 54.5 näher erläutert wird, kann Substituierbarkeit in einem bestimmten Kontext durchaus existieren, selbst wenn die Typen nach obiger Definition nicht substituierbar sind. In einem solchen Fall könnten die Anforderungen in einem Interfacetypen festgehalten werden, der nur die im Kontext benötigten Eigenschaften spezifiziert. Dieser Typ hat jedoch (gemäß Punkt 1) keine Objekte x. Die Aussage bezieht sich implizit auf alle möglichen Eigenschaften (Prädikate) φ, was bedeutet, dass alle Eigenschaften von T auch für S gelten sollen. Dies stellt die Idee des Subtypings in Frage, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Dies steht im Widerspruch zur eigentlichen Absicht des Subtypings: Wenn ein Objekt keine zusätzlichen Funktionen bietet, warum sollte man es dann überhaupt verwenden?",Was ist die Subtypenbeziehung?,"Die Subtypenbeziehung ist eine Beziehung zwischen zwei Typen, bei der der Untertyp alle Eigenschaften des Obertyps erfüllt. Das bedeutet, dass ein Objekt des Untertyps auch als Objekt des Obertyps behandelt werden kann. Diese Beziehung wird oft durch eine Hierarchie von Klassen dargestellt, bei der eine Unterklasse eine spezifischere Version einer Oberklasse ist."
"Es ist jedoch zu beachten, dass die Bedingung in Punkt 3 möglicherweise abgeschwächt werden kann, indem sie sich auf das Verhalten des Programms bezieht und sicherstellt, dass es immer noch seinen beabsichtigten Zweck erfüllt, d.h., seiner Spezifikation genügt. Dies unterscheidet sich jedoch von dem, was im Prinzip ausgedrückt wird.",Was ist der Unterschied zwischen Verhalten des Programms und seiner Spezifikation?,"Die Spezifikation eines Programms beschreibt, was das Programm tun soll, während das Verhalten des Programms beschreibt, was das Programm tatsächlich tut. Die Spezifikation ist eine Art Blaupause oder Anleitung für das Programm, während das Verhalten das Ergebnis der Ausführung des Programms ist."
"Liskov und Wing definieren zunächst eine Subtypenbeziehung zwischen S und T, die das oben genannte Subtype Requirement erfüllt. Diese Beziehung wird durch folgende Regeln beschrieben: Überschreibende Methoden in S übernehmen das Verhalten der überschriebenen Methoden in T. Dies umfasst: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode (die Typen der geworfenen Ausnahmen sind entweder Subtypen der Typen der Ausnahmen der überschriebenen Methode oder es werden überhaupt keine Ausnahmen ausgelöst; es dürfen keine zusätzlichen Ausnahmen auftreten). d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T.",Was definiert die Subtypenbeziehung zwischen S und T?,"Die Subtypenbeziehung zwischen S und T wird durch das Subtype Requirement definiert, das durch die folgenden Regeln beschrieben wird: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode. d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T."
"Liskov und Wing definieren zunächst eine Subtypenbeziehung zwischen S und T, die das oben genannte Subtype Requirement erfüllt. Diese Beziehung wird durch folgende Regeln beschrieben: Überschreibende Methoden in S übernehmen das Verhalten der überschriebenen Methoden in T. Dies umfasst: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode (die Typen der geworfenen Ausnahmen sind entweder Subtypen der Typen der Ausnahmen der überschriebenen Methode oder es werden überhaupt keine Ausnahmen ausgelöst; es dürfen keine zusätzlichen Ausnahmen auftreten). d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T.",Was besagt die Kontravarianz der Argumenttypen der überschreibenden Methode?,"Die Kontravarianz der Argumenttypen der überschreibenden Methode besagt, dass der Typ des Arguments der überschreibenden Methode ein Subtyp des Arguments der überschriebenen Methode sein muss."
"Es ist zu beachten, dass die semantischen Regeln 1.d und 1.e die syntaktischen Regeln 1.a bis 1.c implizieren. In typlosen Sprachen wie Smalltalk würden die entsprechenden Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert, und die Menge der ausgelösten Ausnahmen wäre Teil der Nachbedingungen.",Was sind Vor- und Nachbedingungen in typlosen Sprachen?,"In typlosen Sprachen wie Smalltalk werden die Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert. Vorbedingungen beschreiben die Bedingungen, die vor der Ausführung einer Methode erfüllt sein müssen, während Nachbedingungen die Bedingungen beschreiben, die nach der Ausführung der Methode erfüllt sein müssen. Die Menge der ausgelösten Ausnahmen ist Teil der Nachbedingungen."
Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.,Was bedeutet Substituierbarkeit in diesem Kontext?,"In diesem Kontext bedeutet Substituierbarkeit, dass ein Objekt eines Untertyps an jeder Stelle, an der ein Objekt des Obertyps erwartet wird, verwendet werden kann, ohne dass die Korrektheit des Programms beeinträchtigt wird."
Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.,Was bedeutet die Wirksamkeit der Bedingungen in diesem Kontext?,"Die Wirksamkeit der Bedingungen bedeutet, dass die Subtypenregeln und die Korrektheit der überschreibenden Methode in S die gewünschte Substituierbarkeit gewährleisten."
Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.,Was bedeuten die Subtypenregeln und die Korrektheit der überschreibenden Methode in S für die Substituierbarkeit?,"Die Subtypenregeln und die Korrektheit der überschreibenden Methode in S bedeuten, dass die Unterklasse S die Bedingungen erfüllt, um eine Substitutionsinstanz der Oberklasse zu sein. Das heißt, dass ein Objekt der Unterklasse S an jeder Stelle, an der ein Objekt der Oberklasse erwartet wird, verwendet werden kann, ohne dass die Korrektheit des Programms beeinträchtigt wird."
"Dennoch bleibt das zu Beginn beschriebene Problem mit Aliasbildung und der Möglichkeit zusätzlicher Methodenaufrufe bestehen. Liskov und Wing identifizieren zwei Lösungen: 1. Die erste Lösung besteht darin, die Aliasbildung zu vermeiden, indem man die Objekte, die als Argumente übergeben werden, kopiert. Dadurch wird sichergestellt, dass die Methode nur auf eine Kopie des Objekts zugreift und nicht auf das Original. Diese Lösung ist jedoch nicht immer möglich, da sie nur für kleine Objekte sinnvoll ist, die schnell kopiert werden können. 2. Die zweite Lösung besteht darin, die Aliasbildung zuzulassen, aber die Methodenaufrufe zu begrenzen. Das bedeutet, dass die Methode nur auf die Objekte zugreifen kann, die ihr als Argumente übergeben werden, und nicht auf die Objekte, auf die diese Objekte verweisen. Diese Lösung ist einfacher zu implementieren, da keine Kopien erstellt werden müssen, und sie ist auch für größere Objekte geeignet.",Wie kann das Problem der Aliasbildung bei der Übergabe von Objekten als Argumente gelöst werden?,"Das Problem der Aliasbildung kann durch zwei Lösungen gelöst werden: Die Aliasbildung wird vermieden, indem die Objekte, die als Argumente übergeben werden, kopiert werden. Dadurch wird sichergestellt, dass die Methode nur auf eine Kopie des Objekts zugreift und nicht auf das Original. Oder die Aliasbildung wird zugelassen, aber die Methodenaufrufe werden begrenzt, was bedeutet, dass die Methode nur auf die Objekte zugreifen kann, die ihr als Argumente übergeben werden, und nicht auf die Objekte, auf die diese Objekte verweisen."
"Dennoch bleibt das zu Beginn beschriebene Problem mit Aliasbildung und der Möglichkeit zusätzlicher Methodenaufrufe bestehen. Liskov und Wing identifizieren zwei Lösungen: 1. Die erste Lösung besteht darin, die Aliasbildung zu vermeiden, indem man die Objekte, die als Argumente übergeben werden, kopiert. Dadurch wird sichergestellt, dass die Methode nur auf eine Kopie des Objekts zugreift und nicht auf das Original. Diese Lösung ist jedoch nicht immer möglich, da sie nur für kleine Objekte sinnvoll ist, die schnell kopiert werden können. 2. Die zweite Lösung besteht darin, die Aliasbildung zuzulassen, aber die Methodenaufrufe zu begrenzen. Das bedeutet, dass die Methode nur auf die Objekte zugreifen kann, die ihr als Argumente übergeben werden, und nicht auf die Objekte, auf die diese Objekte verweisen. Diese Lösung ist einfacher zu implementieren, da keine Kopien erstellt werden müssen, und sie ist auch für größere Objekte geeignet.",Wie kann das Problem der Aliasbildung gelöst werden?,"Das Problem der Aliasbildung kann durch die Verwendung von lokalen Variablen gelöst werden, die eine Kopie des Objekts enthalten, oder durch die Verwendung von lokalen Prozeduren, die das Objekt manipulieren, ohne dass es zu einer Aliasbildung kommt."
"Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existiert (oder deren überschriebene, verhaltenskonforme Varianten), die denselben Effekt wie die zusätzliche Methode hat und vom Klienten des Objekts selbst oder von einem anderen Klienten, der jedoch das Objekt als denselben Typ sieht, durchgeführt werden kann. Diese Bedingung ist ziemlich restriktiv, da sie im Wesentlichen besagt, dass ein Subtyp lediglich Makros hinzufügen darf. Auf der anderen Seite ist die Einhaltung dieser Bedingung, wenn auch nicht automatisch, zumindest intuitiv einfacher nachzuweisen, was in der Praxis von großer Bedeutung ist.","Was bedeutet es, wenn das Verhalten eines Subtyps mit dem des Supertyps kompatibel ist?","Das Verhalten eines Subtyps ist mit dem des Supertyps kompatibel, wenn sämtliches zusätzliches Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Das bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existiert, die denselben Effekt wie die zusätzliche Methode hat und vom Klienten des Objekts selbst oder von einem anderen Klienten, der jedoch das Objekt als denselben Typ sieht, durchgeführt werden kann."
"Die zweite Lösung ist weniger restriktiv, aber in der Praxis schwerer nachzuweisen. Sie erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden (einschließlich der üblichen Vor- und Nachbedingungen) die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet. Dazu wäre eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Das Problem dabei ist jedoch, dass die Zustände eines Objekts nicht abstrakt existieren, sondern sich in der Belegung von Instanzvariablen manifestieren. Daher ergibt sich der Zustandsraum kombinatorisch (abzüglich der funktionalen Abhängigkeiten der Attribute). Um dies zu umgehen, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss.",Was sind Zustandswechselinvarianten?,"Zustandswechselinvarianten sind Verlaufseigenschaften, die die möglichen Zustandsänderungen von Objekten betreffen. Sie werden benötigt, um eine weniger restriktive Lösung für die Spezifikation von Methoden zu ermöglichen, die neben Vor- und Nachbedingungen auch die Zustandsänderungen von Objekten berücksichtigt. Dazu ist eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Um den Zustandsraum kombinatorisch zu vermeiden, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss."
"Es ist wichtig zu beachten, dass die Einhaltung der ersten Lösung die Einhaltung der zweiten Lösung impliziert: Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.",Wie hängen historische Invarianten und Zustandswechselinvarianten zusammen?,"Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt."
"Es ist wichtig zu beachten, dass die Einhaltung der ersten Lösung die Einhaltung der zweiten Lösung impliziert: Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.",Was sind historische Invarianten und Zustandswechselinvarianten?,"Historische Invarianten sind Bedingungen, die für den Zustand eines Objekts während seiner gesamten Lebensdauer gelten. Zustandswechselinvarianten sind Bedingungen, die für den Zustand eines Objekts während eines Zustandsübergangs gelten. Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt."
"Obwohl das Liskov-Substitutionsprinzip gut begründet ist, erweist es sich in der Praxis als zu restriktiv. Zum Beispiel könnte in einem Typ T eine Methode ""echo: i <Integer> ^Integer"" definiert werden, die den Eingabeparameter einfach ausgibt (die sogenannte Identitätsfunktion). In einem Subtyp S könnte diese Methode so überschrieben werden, dass sie beliebige Objekte entgegennimmt und sie unverändert zurückgibt: ""echo: i <Object> ^ Object"". Die Methode ist daher in ihrem Eingabeparameter kontravariant, aber nicht kovariant im Ausgabeparameter. Sie erfüllt somit nicht die Bedingungen des LSP. Dennoch kann ""echo:"" auf einem Objekt vom Typ S überall dort aufgerufen werden, wo es auf einem Objekt vom Typ T aufgerufen werden kann, ohne dass die Kovarianzregel des Ausgabeparameters verletzt wird. Das Liskov-Substitutionsprinzip stellt daher eine Typüberprüfung dar, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.",Was ist der Nachteil des Liskov-Substitutionsprinzips?,"Der Nachteil des Liskov-Substitutionsprinzips ist, dass es in der Praxis als zu restriktiv erweist und eine Typüberprüfung darstellt, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung."
"Obwohl das Liskov-Substitutionsprinzip gut begründet ist, erweist es sich in der Praxis als zu restriktiv. Zum Beispiel könnte in einem Typ T eine Methode ""echo: i <Integer> ^Integer"" definiert werden, die den Eingabeparameter einfach ausgibt (die sogenannte Identitätsfunktion). In einem Subtyp S könnte diese Methode so überschrieben werden, dass sie beliebige Objekte entgegennimmt und sie unverändert zurückgibt: ""echo: i <Object> ^ Object"". Die Methode ist daher in ihrem Eingabeparameter kontravariant, aber nicht kovariant im Ausgabeparameter. Sie erfüllt somit nicht die Bedingungen des LSP. Dennoch kann ""echo:"" auf einem Objekt vom Typ S überall dort aufgerufen werden, wo es auf einem Objekt vom Typ T aufgerufen werden kann, ohne dass die Kovarianzregel des Ausgabeparameters verletzt wird. Das Liskov-Substitutionsprinzip stellt daher eine Typüberprüfung dar, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.",Warum erweist sich das Liskov-Substitutionsprinzip in der Praxis als zu restriktiv?,"Das Liskov-Substitutionsprinzip erweist sich in der Praxis als zu restriktiv, weil es eine Typüberprüfung darstellt, die gültige Programme ablehnt. Zum Beispiel, wenn eine Methode in einem Subtyp kontravariant im Eingabeparameter und nicht kovariant im Ausgabeparameter ist, erfüllt sie nicht die Bedingungen des LSP, aber sie kann trotzdem an jeder Stelle, an der die Methode im Basistyp erwartet wird, ohne Probleme verwendet werden. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung."
"In SMALLTALK ist das Interface eines Objekts die Menge der Nachrichten, die es versteht. Dieses Interface wird in Form der sogenannten Protokollbeschreibung oder kurz des Protokolls spezifiziert. Es besteht aus den Methodensignaturen und den Kommentaren der zu den Nachrichten passenden Methoden, und es steht in Kontrast zur Implementierung, also der Liste der Methodenrümpfe, sowie den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Dieses Geheimnis bleibt hinter seiner Protokollbeschreibung, also dem Interface, verborgen. Die Kommentare dürfen übrigens, wie in den meisten anderen Sprachen auch, als eine Art schwacher Ersatz für eine formale Spezifikation des Verhaltens angesehen werden, das in einer Methode implementiert wird.Um die Programmierung zu erleichtern, wird das Protokoll von Objekten in den meisten SMALLTALK-Systemen in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien tragen jeweils einen Namen, der die in der Kategorie enthaltenen Methodennamen zusammenfasst. Da jede Methode genau in eine Nachrichtenkategorie fallen muss, stellen diese Kategorien eine Partitionierung des Interfaces eines Objekts dar. Einige dieser Kategorien können das Wort „private“ enthalten, was darauf hinweist, dass deren Methoden vorzugsweise nur vom Objekt selbst (über self) aufgerufen werden sollten. Beachten Sie jedoch, dass dies nicht vom Compiler erzwungen wird. Nachrichtenkategorien haben darüber hinaus keine weitere Bedeutung für die Programmausführung und dienen lediglich der besseren Lesbarkeit.Protokolle werden in SMALLTALK nicht auf Objektebene, sondern auf Klassenebene spezifiziert. In STRONGTALK, einer Erweiterung von SMALLTALK um ein (optionales) Typsystem, werden Protokolle zu Typen erhoben. Da Protokolle nur Methoden enthalten, sind sie den Interfaces in Java sehr ähnlich. Tatsächlich werden Protokolle in STRONGTALK manchmal auch Interfaces genannt.",Was ist das Protokoll in SMALLTALK?,"In SMALLTALK ist das Protokoll eines Objekts die Menge der Nachrichten, die es versteht. Es wird in Form der Protokollbeschreibung spezifiziert und besteht aus den Methodensignaturen und den dazugehörigen Kommentaren der Methoden. Das Protokoll beschreibt das Interface eines Objekts."
"In SMALLTALK ist das Interface eines Objekts die Menge der Nachrichten, die es versteht. Dieses Interface wird in Form der sogenannten Protokollbeschreibung oder kurz des Protokolls spezifiziert. Es besteht aus den Methodensignaturen und den Kommentaren der zu den Nachrichten passenden Methoden, und es steht in Kontrast zur Implementierung, also der Liste der Methodenrümpfe, sowie den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Dieses Geheimnis bleibt hinter seiner Protokollbeschreibung, also dem Interface, verborgen. Die Kommentare dürfen übrigens, wie in den meisten anderen Sprachen auch, als eine Art schwacher Ersatz für eine formale Spezifikation des Verhaltens angesehen werden, das in einer Methode implementiert wird.Um die Programmierung zu erleichtern, wird das Protokoll von Objekten in den meisten SMALLTALK-Systemen in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien tragen jeweils einen Namen, der die in der Kategorie enthaltenen Methodennamen zusammenfasst. Da jede Methode genau in eine Nachrichtenkategorie fallen muss, stellen diese Kategorien eine Partitionierung des Interfaces eines Objekts dar. Einige dieser Kategorien können das Wort „private“ enthalten, was darauf hinweist, dass deren Methoden vorzugsweise nur vom Objekt selbst (über self) aufgerufen werden sollten. Beachten Sie jedoch, dass dies nicht vom Compiler erzwungen wird. Nachrichtenkategorien haben darüber hinaus keine weitere Bedeutung für die Programmausführung und dienen lediglich der besseren Lesbarkeit.Protokolle werden in SMALLTALK nicht auf Objektebene, sondern auf Klassenebene spezifiziert. In STRONGTALK, einer Erweiterung von SMALLTALK um ein (optionales) Typsystem, werden Protokolle zu Typen erhoben. Da Protokolle nur Methoden enthalten, sind sie den Interfaces in Java sehr ähnlich. Tatsächlich werden Protokolle in STRONGTALK manchmal auch Interfaces genannt.",Wie wird das Protokoll in SMALLTALK unterteilt?,"Das Protokoll von Objekten in SMALLTALK wird oft in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien haben Namen, die die enthaltenen Methodennamen zusammenfassen. Nachrichtenkategorien dienen der besseren Lesbarkeit und partitionieren das Interface eines Objekts. Einige Kategorien können das Wort ""private"" enthalten, um anzuzeigen, dass die darin enthaltenen Methoden vorzugsweise nur vom Objekt selbst aufgerufen werden sollten."
"In SMALLTALK ist das Interface eines Objekts die Menge der Nachrichten, die es versteht. Dieses Interface wird in Form der sogenannten Protokollbeschreibung oder kurz des Protokolls spezifiziert. Es besteht aus den Methodensignaturen und den Kommentaren der zu den Nachrichten passenden Methoden, und es steht in Kontrast zur Implementierung, also der Liste der Methodenrümpfe, sowie den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Dieses Geheimnis bleibt hinter seiner Protokollbeschreibung, also dem Interface, verborgen. Die Kommentare dürfen übrigens, wie in den meisten anderen Sprachen auch, als eine Art schwacher Ersatz für eine formale Spezifikation des Verhaltens angesehen werden, das in einer Methode implementiert wird.Um die Programmierung zu erleichtern, wird das Protokoll von Objekten in den meisten SMALLTALK-Systemen in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien tragen jeweils einen Namen, der die in der Kategorie enthaltenen Methodennamen zusammenfasst. Da jede Methode genau in eine Nachrichtenkategorie fallen muss, stellen diese Kategorien eine Partitionierung des Interfaces eines Objekts dar. Einige dieser Kategorien können das Wort „private“ enthalten, was darauf hinweist, dass deren Methoden vorzugsweise nur vom Objekt selbst (über self) aufgerufen werden sollten. Beachten Sie jedoch, dass dies nicht vom Compiler erzwungen wird. Nachrichtenkategorien haben darüber hinaus keine weitere Bedeutung für die Programmausführung und dienen lediglich der besseren Lesbarkeit.Protokolle werden in SMALLTALK nicht auf Objektebene, sondern auf Klassenebene spezifiziert. In STRONGTALK, einer Erweiterung von SMALLTALK um ein (optionales) Typsystem, werden Protokolle zu Typen erhoben. Da Protokolle nur Methoden enthalten, sind sie den Interfaces in Java sehr ähnlich. Tatsächlich werden Protokolle in STRONGTALK manchmal auch Interfaces genannt.",Was unterscheidet Protokoll und Implementierung in SMALLTALK?,"Das Protokoll beschreibt das Interface eines Objekts und umfasst die Methodensignaturen und dazugehörigen Kommentare. Die Implementierung hingegen besteht aus den tatsächlichen Methodenrümpfen und den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Das Protokoll dient dazu, das Verhalten eines Objekts zu beschreiben, während die Implementierung die Details der Umsetzung enthält."
"In SMALLTALK ist das Interface eines Objekts die Menge der Nachrichten, die es versteht. Dieses Interface wird in Form der sogenannten Protokollbeschreibung oder kurz des Protokolls spezifiziert. Es besteht aus den Methodensignaturen und den Kommentaren der zu den Nachrichten passenden Methoden, und es steht in Kontrast zur Implementierung, also der Liste der Methodenrümpfe, sowie den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Dieses Geheimnis bleibt hinter seiner Protokollbeschreibung, also dem Interface, verborgen. Die Kommentare dürfen übrigens, wie in den meisten anderen Sprachen auch, als eine Art schwacher Ersatz für eine formale Spezifikation des Verhaltens angesehen werden, das in einer Methode implementiert wird.Um die Programmierung zu erleichtern, wird das Protokoll von Objekten in den meisten SMALLTALK-Systemen in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien tragen jeweils einen Namen, der die in der Kategorie enthaltenen Methodennamen zusammenfasst. Da jede Methode genau in eine Nachrichtenkategorie fallen muss, stellen diese Kategorien eine Partitionierung des Interfaces eines Objekts dar. Einige dieser Kategorien können das Wort „private“ enthalten, was darauf hinweist, dass deren Methoden vorzugsweise nur vom Objekt selbst (über self) aufgerufen werden sollten. Beachten Sie jedoch, dass dies nicht vom Compiler erzwungen wird. Nachrichtenkategorien haben darüber hinaus keine weitere Bedeutung für die Programmausführung und dienen lediglich der besseren Lesbarkeit.Protokolle werden in SMALLTALK nicht auf Objektebene, sondern auf Klassenebene spezifiziert. In STRONGTALK, einer Erweiterung von SMALLTALK um ein (optionales) Typsystem, werden Protokolle zu Typen erhoben. Da Protokolle nur Methoden enthalten, sind sie den Interfaces in Java sehr ähnlich. Tatsächlich werden Protokolle in STRONGTALK manchmal auch Interfaces genannt.",Wie werden Protokolle in SMALLTALK spezifiziert?,"In SMALLTALK werden Protokolle nicht auf Objektebene, sondern auf Klassenebene spezifiziert. Dies bedeutet, dass eine Klasse ein bestimmtes Protokoll implementiert und die Objekte dieser Klasse dieses Protokoll erben. In STRONGTALK, einer Erweiterung von SMALLTALK, werden Protokolle zu Typen erhoben und ähneln Interfaces in Java."
"Wenn das Versenden von Nachrichten bisher als die Übergabe eines entsprechenden Nachrichtenobjekts an den Empfänger dargestellt wurde, ist das nicht ganz korrekt. Vielmehr wird ein Nachrichtenausdruck auch in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung (wie z.B. in PASCAL oder C) vergleichbar ist.",Wie wird ein Nachrichtenausdruck in SMALLTALK übersetzt?,"Ein Nachrichtenausdruck wird in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung vergleichbar ist."
"Dennoch wird das Mysterium des Nachrichtenversands in der objektorientierten Literatur aus didaktischen Gründen weiter gepflegt. Es gibt jedoch auch einen kleinen, feinen Unterschied zum gewöhnlichen Prozeduraufruf.Die Entscheidung darüber, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Es ist nämlich durchaus üblich, dass verschiedene Objekte mit gleichen Methodensignaturen unterschiedliche Methodenimplementierungen verbinden. Beispielsweise implementieren Zahlen und Symbole die Methode ""printString"" jeweils anders. Somit führt der Ausdruck ""1 + 2"" zu einem anderen Methodenaufruf als ""a + b"", wenn ""a"" und ""b"" unterschiedliche Objekte sind.",Von welchem Objekt hängt die Auswahl der Methode ab?,"Die Auswahl der Methode, die aufgerufen wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Verschiedene Objekte mit gleichen Methodensignaturen können unterschiedliche Methodenimplementierungen haben."
"Aus der Abhängigkeit des Methodenaufrufs vom Empfängerobjekt folgt, dass nicht immer schon zur Übersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgewählt werden muss. Dies geschieht erst zur Laufzeit, wenn das Empfängerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird. Dies nennt man dynamisches Binden (im Gegensatz zum statischen Binden, bei dem ein Aufruf schon zur Übersetzungszeit an eine Implementierung gebunden wird). Das dynamische Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung und wird auch als Polymorphismus oder Polymorphie bezeichnet. Details dazu werden in den nächsten Kapiteln erläutert.",Was ist dynamisches Binden?,"Dynamisches Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung, bei der die Auswahl der Methodenimplementierung erst zur Laufzeit erfolgt, abhängig vom Empfängerobjekt des Methodenaufrufs. Dies wird auch als Polymorphismus oder Polymorphie bezeichnet."
"Aus der Abhängigkeit des Methodenaufrufs vom Empfängerobjekt folgt, dass nicht immer schon zur Übersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgewählt werden muss. Dies geschieht erst zur Laufzeit, wenn das Empfängerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird. Dies nennt man dynamisches Binden (im Gegensatz zum statischen Binden, bei dem ein Aufruf schon zur Übersetzungszeit an eine Implementierung gebunden wird). Das dynamische Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung und wird auch als Polymorphismus oder Polymorphie bezeichnet. Details dazu werden in den nächsten Kapiteln erläutert.",Was ist statisches Binden?,Bei statischem Binden wird ein Methodenaufruf schon zur Übersetzungszeit an eine Implementierung gebunden.
"Nachdem festgelegt wurde, welche Methode aufgerufen wird, erfolgt die Zuweisung der formalen Parameter mit Objekten. Dies geschieht durch eine implizite Zuweisung der tatsächlichen Parameter des Aufrufs an die formalen Parameter der Methode. Die tatsächlichen Parameter sind die Objekte, die an der Stelle des Methodenaufrufs als Argumente stehen. Je nach Sichtweise kann bei der Ausführung einer Return-Anweisung eine weitere implizite Zuweisung erfolgen, wobei das Ergebnis des Ausdrucks der Return-Anweisung der ""Variable"" des Methodennamens zugewiesen wird.",Wie erfolgt die Zuweisung der formalen Parameter in einer Methode?,Die Zuweisung der formalen Parameter erfolgt in einer Methode durch eine implizite Zuweisung der tatsächlichen Parameter des Methodenaufrufs an die formalen Parameter der Methode.
"Es ist jedoch zu beachten, dass formale Parameter in SMALLTALK Pseudovariablen sind und daher keine explizite Zuweisung an sie erlaubt ist (außer bei der impliziten Zuweisung beim Aufruf).Was passiert, wenn ein Methodenaufruf ins Leere läuft, ist ebenfalls von Interesse. Da in SMALLTALK Ausdrücke beliebige Objekte liefern können, kann der Compiler nicht garantieren, dass das Empfängerobjekt tatsächlich über eine entsprechende Methode verfügt. In solchen Fällen wird der Methodenaufruf in einen Aufruf der Methode ""doesNotUnderstand:"" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung wie ""<Objekt> does not understand: <Nachrichtenselektor>"". Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren.","Was passiert, wenn ein Methodenaufruf in SMALLTALK ins Leere läuft?","Wenn ein Methodenaufruf ins Leere läuft, wird er in einen Aufruf der Methode ""doesNotUnderstand:"" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung, die besagt, dass das Objekt die Nachricht nicht versteht. Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren."
"Ein laufendes objektorientiertes Programm muss man sich als eine Menge interagierender Objekte vorstellen. Damit die Objekte interagieren können, müssen sie verbunden sein; sie bilden dazu ein Geflecht, das neben Objekten aus Beziehungen zwischen diesen besteht. Das Geflecht verändert sich dynamisch infolge der Interaktion zwischen Objekten; es unterliegt aber gewissen, durch das Programm vorgegebenen statischen Strukturen. Die Unterscheidung zwischen Statik und Dynamik ist eine klassische der Programmierung. Während Programme traditionell statische Gebilde sind, die auf Papier oder in einem Nur-Lese-Speicher festgehalten werden können, ist ihre Ausführung immer etwas Dynamisches. Wenn aber Programme selbst als Daten aufgefasst werden, dann verwischt die Grenze zwischen Statik und Dynamik: Programme werden veränderlich. Insbesondere, wenn Programme sich selbst verändern können, ist die Unterscheidung zwischen Statik und Dynamik nur noch bedingt nützlich. Alternativ zu Statik und Dynamik kann man auch zwischen Struktur und Verhalten unterscheiden, wobei mit Struktur das oben erwähnte Objektgeflecht und mit Verhalten die (Spezifikation der) Folge seiner Veränderungen gemeint ist. Diese Unterscheidung liegt der Gliederung des Rests dieser Kurseinheit zugrunde: von Objekten (Kapitel 1) und Beziehungen zwischen diesen (Kapitel 2) geht es über den Zustand als Bindeglied (Kapitel 3) zu den Elementen der Verhaltensbeschreibung (Kapitel 4).",Was ist das Objektgeflecht in einem laufenden objektorientierten Programm?,Das Objektgeflecht in einem laufenden objektorientierten Programm besteht aus Objekten und den Beziehungen zwischen diesen.
"Ein laufendes objektorientiertes Programm muss man sich als eine Menge interagierender Objekte vorstellen. Damit die Objekte interagieren können, müssen sie verbunden sein; sie bilden dazu ein Geflecht, das neben Objekten aus Beziehungen zwischen diesen besteht. Das Geflecht verändert sich dynamisch infolge der Interaktion zwischen Objekten; es unterliegt aber gewissen, durch das Programm vorgegebenen statischen Strukturen. Die Unterscheidung zwischen Statik und Dynamik ist eine klassische der Programmierung. Während Programme traditionell statische Gebilde sind, die auf Papier oder in einem Nur-Lese-Speicher festgehalten werden können, ist ihre Ausführung immer etwas Dynamisches. Wenn aber Programme selbst als Daten aufgefasst werden, dann verwischt die Grenze zwischen Statik und Dynamik: Programme werden veränderlich. Insbesondere, wenn Programme sich selbst verändern können, ist die Unterscheidung zwischen Statik und Dynamik nur noch bedingt nützlich. Alternativ zu Statik und Dynamik kann man auch zwischen Struktur und Verhalten unterscheiden, wobei mit Struktur das oben erwähnte Objektgeflecht und mit Verhalten die (Spezifikation der) Folge seiner Veränderungen gemeint ist. Diese Unterscheidung liegt der Gliederung des Rests dieser Kurseinheit zugrunde: von Objekten (Kapitel 1) und Beziehungen zwischen diesen (Kapitel 2) geht es über den Zustand als Bindeglied (Kapitel 3) zu den Elementen der Verhaltensbeschreibung (Kapitel 4).",Was ist der Unterschied zwischen Statik und Dynamik in der Programmierung?,"In der Programmierung wird traditionell zwischen Statik und Dynamik unterschieden. Statik bezieht sich auf die statischen Strukturen eines Programms, die auf Papier oder in einem Nur-Lese-Speicher festgehalten werden können. Dynamik hingegen bezieht sich auf die Ausführung des Programms, die immer etwas Veränderliches ist. Wenn Programme selbst als Daten aufgefasst werden und sich sogar selbst verändern können, wird die Unterscheidung zwischen Statik und Dynamik nur noch bedingt nützlich. Alternativ kann man auch zwischen Struktur und Verhalten unterscheiden, wobei Struktur das Objektgeflecht und Verhalten die Folge seiner Veränderungen meint."
"Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).",Was ist Inklusionspolymorphie?,"Inklusionspolymorphie, auch bekannt als Subtyping, ist eine Form der Polymorphie, bei der ein Objekt eines Untertyps an einer Stelle verwendet werden kann, an der ein Objekt des Supertyps erwartet wird. Das bedeutet, dass eine Collection, die Objekte eines bestimmten Typs enthält, auch Objekte eines Untertyps dieses Typs enthalten kann."
"Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).",Was ist Subtyping?,"Subtyping, auch bekannt als Inklusionspolymorphie, ist eine Form der Polymorphie, bei der ein Objekt eines Untertyps an einer Stelle verwendet werden kann, an der ein Objekt des Supertyps erwartet wird. Das bedeutet, dass eine Collection, die Objekte eines bestimmten Typs enthält, auch Objekte eines Untertyps dieses Typs enthalten kann."
"Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).",Was ist der Unterschied zwischen parametrischen Polymorphismus und Inklusionspolymorphie?,"Parametrischer Polymorphismus ist eine Technik, die es ermöglicht, dass eine Funktion oder Methode mit Argumenten verschiedener Typen aufgerufen werden kann, während Inklusionspolymorphie (Subtyping) eine Beziehung zwischen Typen ist, bei der ein Typ B ein Untertyp eines anderen Typs A ist, wenn ein Wert vom Typ B auch als Wert vom Typ A behandelt werden kann. Im Falle von Collections bedeutet dies, dass eine Collection, die auf Objekte eines bestimmten Typs ausgelegt ist, auch Objekte eines Untertyps dieses Typs aufnehmen kann."
"An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.",Was ist eine Collection in STRONGTALK und wie wird sie verwendet?,"In STRONGTALK ist eine Collection ein Objekt, das eine Sammlung von anderen Objekten enthält. Alle Typen sind Subtypen von Object, wodurch jedes beliebige Objekt in einer Collection gespeichert werden kann. In der Klasse Person, die Collection verwendet, würde kinder als vom Typ Collection (ohne Typparameter) deklariert. Allerdings kann es bei der Verwendung von Objekten in Collections zu Typfehlern kommen, die durch Downcasting behoben werden können. Diese Lösung bietet jedoch eine Sicherheitslücke in der statischen Typprüfung, die durch parametrische Polymorphie behoben wird."
"An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.",Was ist eine Collection in Strongtalk und welchen Typ hat die Variable E?,"In Strongtalk ist eine Collection ein Objekt, das eine Sammlung von Objekten speichert. Die Variable E wird durch den Typ Object ersetzt, da alle Typen in Strongtalk Subtypen von Object sind. Das bedeutet, dass man jedes beliebige Objekt in einer Collection speichern kann."
"An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.","Was ist die Sicherheitslücke in der statischen Typprüfung, die durch die Inklusionspolymorphie entsteht?","Die Sicherheitslücke in der statischen Typprüfung, die durch die Inklusionspolymorphie entsteht, ist, dass der Compiler nicht oder nur sehr aufwendig feststellen kann, ob das Ergebnis von p kinder at: 1 vom Typ Object in eine Methode kinder von Typ Person umgewandelt werden kann."
"Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.",Was ist parametrischer Polymorphismus?,"Parametrischer Polymorphismus ist eine Technik in der objektorientierten Programmierung, bei der eine Funktion oder Methode mit verschiedenen Datentypen verwendet werden kann. Es ist jedoch nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern, ohne Inklusionspolymorphie zu verwenden."
"Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.",Was ist der Unterschied zwischen parametrischen Polymorphismus und Inklusionspolymorphismus?,"Parametrischer Polymorphismus ermöglicht es, eine Funktion oder Methode mit verschiedenen Datentypen aufzurufen, während Inklusionspolymorphismus es ermöglicht, Objekte verschiedener Subtypen in einer Collection zu speichern. Ohne Inklusionspolymorphismus wäre es nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern."
"Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumindest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft. Dies verlangt nach Erklärung.",Was ist der Trade-off zwischen Typsicherheit und Typsicherheit innerhalb der Typdefinition bei der Verwendung von parametrisch definierten Typen?,"Der Trade-off besteht darin, dass die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst einhergeht. Das bedeutet, dass man bei der Verwendung von parametrisch definierten Typen zwar eine höhere Typsicherheit hat, aber gleichzeitig innerhalb der Typdefinition selbst mit einer geringeren Typsicherheit rechnen muss."
"Nun kann aber die Definition eines parametrischen Typs nicht wissen, wie sie hinterher verwendet wird, und wenn eine Operation durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.",Was ist die erhöhte Typsicherheit außerhalb der Typdefinition und die verminderte Typsicherheit innerhalb der Typdefinition?,"Die erhöhte Typsicherheit außerhalb der Typdefinition bedeutet, dass die Verwendung des parametrischen Typs sicherer ist, da er nur mit Typen von addierbaren Objekten instanziiert wird. Die verminderte Typsicherheit innerhalb der Typdefinition bedeutet, dass die Definition des parametrischen Typs nicht wissen kann, wie er hinterher verwendet wird, und daher bei der Addition auf die Verwendung von addierbaren Objekten angewiesen ist."
"Nun kann aber die Definition eines parametrischen Typs nicht wissen, wie sie hinterher verwendet wird, und wenn eine Operation durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.",Was ist die erhöhte Typsicherheit außerhalb der Typdefinition und die verminderte Typsicherheit innerhalb?,"Die erhöhte Typsicherheit außerhalb der Typdefinition bedeutet, dass die Verwendung des parametrischen Typs MyCollection sichergestellt ist, dass er nur mit Typen von addierbaren Objekten instanziiert wird. Die verminderte Typsicherheit innerhalb bedeutet, dass die Definition des parametrischen Typs MyCollection nicht wissen kann, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird."
"Nun kann aber die Definition eines parametrischen Typs nicht wissen, wie sie hinterher verwendet wird, und wenn eine Operation durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.",Was ist der Nachteil der erhöhten Typsicherheit außerhalb der Typdefinition?,Der Nachteil der erhöhten Typsicherheit außerhalb der Typdefinition ist die verminderte Typsicherheit innerhalb der Typdefinition.
"Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicherheit, dass alle Typen, die für E eingesetzt werden können, bestimmte Eigenschaften haben, im gegebenen Beispiel, dass sie sortierbar und addierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, sondern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, nämlich bei der Verwendung (der Instanziierung) der parametrischen Typdefinition in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Polymorphismus, der im nächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.",Was ist der beschränkte parametrische Polymorphismus?,"Der beschränkte parametrische Polymorphismus ist eine Technik, die es ermöglicht, Typen zu verwenden, die bestimmte Eigenschaften haben. Dadurch kann ein Typfehler bereits an der Stelle moniert werden, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, anstatt erst später im Programm."
"Schließlich ist es in Java auch noch möglich, Variablen generisch zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Allerdings geht das, da eine Variable anders als eine Klasse oder Methoden keinen neuen Sichtbarkeitsbereich definiert, nur mit anonymen Typvariablen, also Wildcards. Man beachte jedoch, dass eine solche Variablendeklaration, genau wie eine generische Methodendefinition, keinen neuen Typ einführt (siehe Fußnote 72); vielmehr handelt es sich bei dem durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzten Typ selbst um einen konkreten Typ. Der per ""Wildcard"" deklarierten Variable ""liste"" können also Listen beliebigen Elementtyps zugewiesen werden, einfach weil ""List<?>"" (unter den in Abschnitt 43.2 genannten Einschränkungen) Supertyp aller Instanziierungen von ""List<T>"" ist.","Was bedeutet es, Variablen generisch zu deklarieren?","In Java ist es möglich, Variablen generisch zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Dies ist jedoch nur mit anonymen Typvariablen, also Wildcards, möglich. Eine solche Variablendeklaration führt keinen neuen Typ ein, sondern die per ""Wildcard"" deklarierte Variable kann Listen beliebigen Elementtyps zugewiesen werden, weil ""List<>"" Supertyp aller Instanziierungen von ""List<T>"" ist."
"Schließlich ist es in Java auch noch möglich, Variablen generisch zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Allerdings geht das, da eine Variable anders als eine Klasse oder Methoden keinen neuen Sichtbarkeitsbereich definiert, nur mit anonymen Typvariablen, also Wildcards. Man beachte jedoch, dass eine solche Variablendeklaration, genau wie eine generische Methodendefinition, keinen neuen Typ einführt (siehe Fußnote 72); vielmehr handelt es sich bei dem durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzten Typ selbst um einen konkreten Typ. Der per ""Wildcard"" deklarierten Variable ""liste"" können also Listen beliebigen Elementtyps zugewiesen werden, einfach weil ""List<?>"" (unter den in Abschnitt 43.2 genannten Einschränkungen) Supertyp aller Instanziierungen von ""List<T>"" ist.",Was ist der Zweck von generischen Variablen in Java?,"Der Zweck von generischen Variablen in Java ist es, Variablen zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Dies ist möglich, da eine Variable keinen neuen Sichtbarkeitsbereich definiert, jedoch nur mit anonymen Typvariablen, also Wildcards. Der per ""Wildcard"" deklarierten Variable können also Listen beliebigen Elementtyps zugewiesen werden, weil ""List<?>"" Supertyp aller Instanziierungen von ""List<T>"" ist."
Unter Vererbung versteht man in der objektorientierten Programmierung die Übertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere. Vererbung dient vor allem der Wiederverwendung von Code und damit der Ökonomie in der Softwareentwicklung.,Was ist Vererbung in der objektorientierten Programmierung?,Vererbung ist die Übertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere. Sie dient vor allem der Wiederverwendung von Code und damit der Ökonomie in der Softwareentwicklung.
"Wenn man das Prinzip von Generalisierung und Spezialisierung vor Augen hat, dann ist die Vererbung eigentlich nur noch ein Mechanismus, der Definitionen von einer Klasse auf eine andere überträgt. So wird jede benannte Instanzvariable, die in einer Generalisierung deklariert ist, nicht nur für Instanzen dieser Generalisierung (so sie denn welche hat) angelegt, sondern auch für die Instanzen all ihrer Spezialisierungen. Analog stehen Methoden, die in einer Generalisierung definiert werden, auch ihren Spezialisierungen zur Verfügung, und zwar beinahe so, als wären sie in den Spezialisierungen definiert.",Was ist Vererbung in der objektorientierten Programmierung?,"Vererbung ist ein Mechanismus in der objektorientierten Programmierung, der Definitionen von einer Generalisierungsklasse auf eine Spezialisierungsklasse überträgt. So werden benannte Instanzvariablen und Methoden, die in einer Generalisierungsklasse deklariert sind, auch für die Instanzen all ihrer Spezialisierungen verfügbar gemacht."
"Spezialisierung und Vererbung scheinen also Hand in Hand zu gehen. Doch ist dies nur solange der Fall, wie man von der Spezialisierung ausgeht und die Vererbung als ökonomisches Abfallprodukt erhält. In der Praxis lässt man sich jedoch leider häufig von oberflächlichen Gewinnerwartungen leiten und folgt der (vermeintlichen) Ökonomie der Vererbung, ohne dabei auf die Prinzipien von Generalisierung und Spezialisierung einzugehen. Obiges Beispiel von Pinguinen und Vögeln hatte bereits gezeigt, zu welchen Komplikationen eine unbedachte Spezialisierung führen kann; im Folgenden soll gezeigt werden, zu welchen Problemen eine Fixierung auf die Nutzung der Vererbung führt.",Was ist der Unterschied zwischen Spezialisierung und Vererbung?,"Spezialisierung und Vererbung scheinen Hand in Hand zu gehen, aber in der Praxis kann eine unbedachte Spezialisierung zu Komplikationen führen und eine Fixierung auf die Nutzung der Vererbung zu Problemen. Spezialisierung bezieht sich auf das Erstellen einer Unterklasse, die eine Oberklasse erweitert, während Vererbung ein Mechanismus ist, bei dem eine Unterklasse die Eigenschaften und Methoden einer Oberklasse erbt."
"Nun möchte man eine zweite Klasse Rechteck definieren und dabei ausnutzen, dass man bereits eine ähnliche Klasse, nämlich Quadrat, hat. Aus Quadrat könnte man nämlich die Instanzvariable laenge übernehmen. (Das Beispiel wurde absichtlich einfach gewählt, auch wenn es dadurch wenig überzeugend wirkt; das Problem sollte aber trotzdem klar werden.)",Wie kann man eine Instanzvariable von einer Klasse in eine andere Klasse übernehmen?,"Man kann eine Instanzvariable von einer Klasse in eine andere Klasse übernehmen, indem man den Code der Variablen in die neue Klasse kopiert. In diesem Fall kann man die Instanzvariable laenge aus der Klasse Quadrat in die Klasse Rechteck übernehmen, indem man den Code für laenge in die Klasse Rechteck kopiert."
"Was die Instanzvariablen angeht, so muss Rechteck die Instanzvariable laenge nicht neu definieren, sondern lediglich breite hinzufügen. Allerdings können die Methoden zur Berechnung von Fläche und Umfang nicht mitgeerbt werden, obwohl Quadrate und Rechtecke die Eigenschaft teilen, über solche Merkmale zu verfügen. Die entsprechenden Methoden müssen also in Rechteck neu definiert werden. Man nennt das Überschreiben, weil die neuen Methoden dasselbe tun wie die alten. Die Möglichkeit des Überschreibens ist häufig Voraussetzung dafür, Vererbung überhaupt sinnvoll einzusetzen.",Was ist Überschreiben in Bezug auf Vererbung?,"Überschreiben bedeutet, dass eine abgeleitete Klasse dieselben Methoden wie die Basisklasse besitzt, aber die Methoden anders implementiert. Das ist häufig Voraussetzung dafür, Vererbung sinnvoll einzusetzen."
"Was die Instanzvariablen angeht, so muss Rechteck die Instanzvariable laenge nicht neu definieren, sondern lediglich breite hinzufügen. Allerdings können die Methoden zur Berechnung von Fläche und Umfang nicht mitgeerbt werden, obwohl Quadrate und Rechtecke die Eigenschaft teilen, über solche Merkmale zu verfügen. Die entsprechenden Methoden müssen also in Rechteck neu definiert werden. Man nennt das Überschreiben, weil die neuen Methoden dasselbe tun wie die alten. Die Möglichkeit des Überschreibens ist häufig Voraussetzung dafür, Vererbung überhaupt sinnvoll einzusetzen.",Was ist Überschreiben in der objektorientierten Programmierung?,"Überschreiben bedeutet, dass eine Unterklasse dieselben Methoden wie ihre Superklasse besitzt, aber die Unterklasse die Methoden anders implementiert. Das ist häufig Voraussetzung dafür, Vererbung überhaupt sinnvoll einzusetzen."
"Wenn man nun glaubt, man hätte gleichzeitig mit der Vererbung auch eine Spezialisierungs- bzw. Generalisierungsbeziehung geschaffen, irrt man sich: Die Menge der Quadrate enthält nicht die Menge der Rechtecke, was eine charakteristische Begleiterscheinung der Generalisierung gewesen wäre. Dass die Intension von Rechteck umfangreicher ist als die von Quadrat (sie enthält eine Instanzvariable mehr), ist eine Täuschung: Ein Quadrat hat, genau wie ein Rechteck, vier Seiten, nur ist die Bedingung für diese vier Seiten in Quadraten die, dass sie alle gleich lang sind, so dass man sich drei Instanzvariablen sparen kann; für Rechtecke sind nur jeweils zwei Seiten gleich lang, so dass man sich nur zwei Instanzvariablen spart. Die Intension für Quadrate ist aber trotzdem restriktiver als die für Rechtecke (sie enthält eine zusätzliche Bedingung), so dass der inverse Zusammenhang von Intension und Extension auch für Quadrate und Rechtecke gilt: je größer die Intension, desto kleiner die Extension (und umgekehrt).",Wie hängt die Intension und Extension zusammen?,"Je größer die Intension (die Menge der Eigenschaften) ist, desto kleiner ist die Extension (die Menge der Objekte, die diese Eigenschaften erfüllen)."
"Wenn man nun glaubt, man hätte gleichzeitig mit der Vererbung auch eine Spezialisierungs- bzw. Generalisierungsbeziehung geschaffen, irrt man sich: Die Menge der Quadrate enthält nicht die Menge der Rechtecke, was eine charakteristische Begleiterscheinung der Generalisierung gewesen wäre. Dass die Intension von Rechteck umfangreicher ist als die von Quadrat (sie enthält eine Instanzvariable mehr), ist eine Täuschung: Ein Quadrat hat, genau wie ein Rechteck, vier Seiten, nur ist die Bedingung für diese vier Seiten in Quadraten die, dass sie alle gleich lang sind, so dass man sich drei Instanzvariablen sparen kann; für Rechtecke sind nur jeweils zwei Seiten gleich lang, so dass man sich nur zwei Instanzvariablen spart. Die Intension für Quadrate ist aber trotzdem restriktiver als die für Rechtecke (sie enthält eine zusätzliche Bedingung), so dass der inverse Zusammenhang von Intension und Extension auch für Quadrate und Rechtecke gilt: je größer die Intension, desto kleiner die Extension (und umgekehrt).",Was ist der Unterschied zwischen Vererbung und Generalisierung?,"Vererbung und Generalisierung sind zwei verschiedene Konzepte. Wenn man denkt, man hätte mit der Vererbung auch eine Generalisierungsbeziehung geschaffen, ist man auf dem Holzweg. Ein Beispiel: Die Menge der Quadrate enthält nicht die Menge der Rechtecke, was eine charakteristische Begleiterscheinung der Generalisierung gewesen wäre. Der Unterschied liegt in der Intension und Extension: Die Intension von Rechteck ist umfangreicher als die von Quadrat, da sie eine Instanzvariable mehr enthält. Die Intension von Quadrat ist aber trotzdem restriktiver als die von Rechteck, da sie eine zusätzliche Bedingung enthält."
"Das Problem mit der Vererbung ist nun, dass sie auf die oberflächliche Wiederverwendung von Elementen einer Klassendefinition ausgerichtet ist. Sie lässt dabei insbesondere den Zusammenhang der Extensionen der beteiligten Klassen, der für Generalisierung/Spezialisierung wesentlich ist, außer Acht. Diese Ignoranz hat jedoch weitreichende Konsequenzen, die wir in Kapitel 26 von Kurseinheit 3 noch kennenlernen werden.",Was ist das Problem mit der Vererbung?,"Das Problem mit der Vererbung ist, dass sie auf die oberflächliche Wiederverwendung von Elementen einer Klassendefinition ausgerichtet ist und dabei den Zusammenhang der Extensionen der beteiligten Klassen außer Acht lässt, was für Generalisierung/Spezialisierung wesentlich ist. Diese Ignoranz hat weitreichende Konsequenzen."
"Man hätte nun auch umgekehrt vorgehen können und dabei das Prinzip von Generalisierung und Spezialisierung hochhalten können, indem man Quadrat von Rechteck erben lässt (sofern man akzeptiert, dass die Generalisierung Rechteck eigene Instanzen hat). Der Nachteil dieses Ansatzes wäre jedoch, dass Quadrat dann ebenfalls zwei Instanzvariablen für Seitenlängen hätte, obwohl eine ausgereicht hätte. Auf der anderen Seite hätte man die Methoden für Fläche und Umfang nicht überschreiben müssen, denn wenn laenge und breite gleich sind, unterscheiden sich die beiden obigen Implementierungen von flaeche und umfang im Ergebnis nicht. Man muss nur sicherstellen, dass in Instanzen von Quadrat laenge und breite tatsächlich immer gleiche Werte haben.",Was ist Generalisierung und Spezialisierung in Bezug auf objektorientierte Programmierung?,"Generalisierung und Spezialisierung sind Prinzipien in der objektorientierten Programmierung. Dabei wird eine allgemeine Klasse (Generalisation) erstellt, die dann durch eine spezifischere Klasse (Spezialisation) erweitert wird. In diesem Fall wird die Klasse Rechteck als allgemeine Klasse angesehen und Quadrat als spezifischere Klasse, die von Rechteck erbt."
"Nun kann man aber auch auf die Idee kommen, die zu viel geerbte Instanzvariable breite einfach wieder zu löschen. Tatsächlich ist dies vom Standpunkt der Vererbung aus kein Problem: Genauso, wie man Teile der Definition überschreiben kann, kann man sie auch löschen. Im konkreten Fall der Klasse Quadrat, die von Rechteck erbt, müsste man mit dem Löschen von breite aber auch die Methoden flaeche und umfang überschreiben. (Das Löschen von Methoden wäre auch möglich, wird hier aber nicht gebraucht.)","Kann man eine Instanzvariable löschen, die von einer übergeordneten Klasse geerbt wurde?","Ja, man kann eine Instanzvariable löschen, die von einer übergeordneten Klasse geerbt wurde. Allerdings muss man dann auch die Methoden, die diese Instanzvariable verwenden, überschreiben."
"Nun kann man aber auch auf die Idee kommen, die zu viel geerbte Instanzvariable breite einfach wieder zu löschen. Tatsächlich ist dies vom Standpunkt der Vererbung aus kein Problem: Genauso, wie man Teile der Definition überschreiben kann, kann man sie auch löschen. Im konkreten Fall der Klasse Quadrat, die von Rechteck erbt, müsste man mit dem Löschen von breite aber auch die Methoden flaeche und umfang überschreiben. (Das Löschen von Methoden wäre auch möglich, wird hier aber nicht gebraucht.)","Was passiert, wenn man eine Instanzvariable löscht, die von einer übergeordneten Klasse geerbt wurde?","Wenn man eine Instanzvariable löscht, die von einer übergeordneten Klasse geerbt wurde, muss man auch die Methoden, die diese Instanzvariable verwenden, überschreiben."
"Was bleibt, ist ein Eindruck von Beliebigkeit bei der Vererbungsrichtung, die für Generalisierung/Spezialisierung nicht existiert. In gewisser Weise spiegeln Generalisierung/Spezialisierung und Vererbung auch zwei verschiedene Weltansichten wider: Generalisierung/Spezialisierung steht für die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze (die sog. Client-Schnittstelle), Vererbung für die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung (die Vererbungsschnittstelle). Vererbung stellt eine Art genetischen Zusammenhang zwischen Klassen dar, der deren Entstehung aus Vorhandenem widerspiegelt, Generalisierung/Spezialisierung eher eine abstrakte Ordnung. Vererbung bringt Komplexität in ein System, Generalisierung/Spezialisierung versucht, sie durch Strukturierung zu reduzieren. Wie Sie gesehen haben, führen beide Sichten nicht automatisch zum selben Ergebnis; sie zu vereinen ist die hohe Kunst des objektorientierten Entwurfs.",Was ist der Unterschied zwischen Generalisierung/Spezialisierung und Vererbung in der objektorientierten Programmierung?,"Generalisierung/Spezialisierung und Vererbung sind zwei verschiedene Konzepte in der objektorientierten Programmierung. Generalisierung/Spezialisierung steht für die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze, während Vererbung für die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung steht. Vererbung stellt eine Art genetischen Zusammenhang zwischen Klassen dar, während Generalisierung/Spezialisierung eher eine abstrakte Ordnung ist. Vererbung bringt Komplexität in ein System, während Generalisierung/Spezialisierung versucht, sie durch Strukturierung zu reduzieren."
"Klassen sind die Module der objektorientierten Programmierung. Die Menge der Module und damit das Programm werden durch die Vererbungshierarchie weiter strukturiert. Parallel dazu (und weitgehend, bis auf die Vererbung von Beziehungen unabhängig) gibt es noch eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen (genauer: das Bestehen der Möglichkeit von Beziehungen zwischen Objekten der Klassen; s. Kapitel 2 in Kurseinheit 1) geprägt ist. Diese ist jedoch nicht hierarchisch und insgesamt eher unorganisiert, weshalb sie sich nicht zur systematischen Programmorganisation eignet. Außerdem besteht ein gewisser Konflikt zwischen der Hierarchie der Subklassenbeziehung und den Beziehungen zwischen Objekten: Wenn man einen Teilbaum der Vererbungshierarchie herauslöst, trennt man damit praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen. Die Klassenhierarchie stellt also insbesondere keine Form der hierarchischen Modularisierung dar.",Wie werden Klassen in der objektorientierten Programmierung strukturiert?,"Die Menge der Module und damit das Programm werden durch die Vererbungshierarchie weiter strukturiert. Parallel dazu gibt es noch eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen geprägt ist. Diese ist jedoch nicht hierarchisch und insgesamt eher unorganisiert. Die Klassenhierarchie stellt also insbesondere keine Form der hierarchischen Modularisierung dar."
"Insbesondere bei größeren Programmen kann leicht das Bedürfnis aufkommen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren. Dies kann beispielsweise verschiedene Vererbungshierarchien betreffen. So, wie man in der Biologie eine Taxonomie der Arten nach Herkunft (Genetik) und nach Merkmalen erstellen kann und da beide ihren Nutzen haben, man weder auf die eine noch auf die andere ohne Not verzichten möchte, so kann man ein Programm beispielsweise unter dem Gesichtspunkt der Vererbung von Funktionalität und von Daten alternativ strukturieren wollen. Voraussetzung hierfür ist allerdings, dass die verschiedenen Darstellungen getrennt voneinander gepflegt werden und dass durch sie weder Inkonsistenzen im Code noch ungewollte Interferenzen entstehen können.","Warum ist es wichtig, verschiedene Vererbungshierarchien in einem Programm getrennt voneinander zu pflegen?","Es ist wichtig, verschiedene Vererbungshierarchien in einem Programm getrennt voneinander zu pflegen, um Inkonsistenzen im Code und ungewollte Interferenzen zu vermeiden."
"Insbesondere bei größeren Programmen kann leicht das Bedürfnis aufkommen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren. Dies kann beispielsweise verschiedene Vererbungshierarchien betreffen. So, wie man in der Biologie eine Taxonomie der Arten nach Herkunft (Genetik) und nach Merkmalen erstellen kann und da beide ihren Nutzen haben, man weder auf die eine noch auf die andere ohne Not verzichten möchte, so kann man ein Programm beispielsweise unter dem Gesichtspunkt der Vererbung von Funktionalität und von Daten alternativ strukturieren wollen. Voraussetzung hierfür ist allerdings, dass die verschiedenen Darstellungen getrennt voneinander gepflegt werden und dass durch sie weder Inkonsistenzen im Code noch ungewollte Interferenzen entstehen können.","Warum ist es wichtig, verschiedene Darstellungen eines Programms getrennt voneinander zu pflegen?","Es ist wichtig, verschiedene Darstellungen eines Programms getrennt voneinander zu pflegen, um Inkonsistenzen im Code und ungewollte Interferenzen zu vermeiden."
"Ein Nachteil der objektorientierten Programmierung (wie auch aller anderen heute bekannten Programmierparadigmen) ist sicherlich, dass die sog. Trennung der Belange, besser bekannt als die Separation of Concerns, nur unzureichend unterstützt wird. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar hoch gehandelt, sind aber dennoch nicht im Mainstream angekommen. Die Gründe dafür mögen vielfältig sein, aber letztlich ist es wohl immer illusorisch zu versprechen, man könne die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen. Insbesondere die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten: Wie so oft muss das Ganze mehr sein als die Summe seiner Teile, um seinen Zweck zu erfüllen. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen.",Was ist die Trennung der Belange (Separation of Concerns) in der objektorientierten Programmierung?,"Die Trennung der Belange, auch Separation of Concerns genannt, ist ein Prinzip in der objektorientierten Programmierung, das die Aufgaben und Verantwortlichkeiten von Objekten und Komponenten klar trennen soll. Es ist jedoch unzureichend unterstützt und kann die Komplexität nur in das Zusammenführen der Sichten verschieben."
"Ein Nachteil der objektorientierten Programmierung (wie auch aller anderen heute bekannten Programmierparadigmen) ist sicherlich, dass die sog. Trennung der Belange, besser bekannt als die Separation of Concerns, nur unzureichend unterstützt wird. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar hoch gehandelt, sind aber dennoch nicht im Mainstream angekommen. Die Gründe dafür mögen vielfältig sein, aber letztlich ist es wohl immer illusorisch zu versprechen, man könne die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen. Insbesondere die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten: Wie so oft muss das Ganze mehr sein als die Summe seiner Teile, um seinen Zweck zu erfüllen. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen.",Warum wird die Trennung der Belange in der objektorientierten Programmierung nur unzureichend unterstützt?,"Die Trennung der Belange wird in der objektorientierten Programmierung nur unzureichend unterstützt, weil die Ansätze wie das Subject- oder Aspect-oriented Programming zwar hoch gehandelt wurden, aber noch nicht im Mainstream angekommen sind. Die Gründe dafür sind vielfältig, aber letztlich ist es illusorisch, die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen zu wollen. Die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen."
"Als man mit der objektorientierten Programmierung begann, war man glücklich, weil man glaubte, mit dem Konzept der Klassen eine natürliche Form der Kapselung (engl. encapsulation) gefunden zu haben, die zudem noch mit der hochangesehenen Theorie der abstrakten Datentypen in Einklang steht (zumindest einigermaßen): Klassen ergeben sich auf natürliche Weise aus der Anwendungsdomäne (als Repräsentanten von Allgemeinbegriffen; siehe Kurseinheit 1, Kapitel 7), und Daten sowie Implementierungsdetails lassen sich hinter der Klassenschnittstelle (dem Protokoll der Objekte) verbergen.",Was ist die Bedeutung der Kapselung in der objektorientierten Programmierung?,"Die Kapselung ist ein Konzept in der objektorientierten Programmierung, bei dem Daten und Implementierungsdetails hinter der Klassenschnittstelle verbergen werden können. Das Konzept der Kapselung ermöglicht es, Klassen auf natürliche Weise aus der Anwendungsdomäne abzuleiten und trägt zur besseren Organisation und Strukturierung des Codes bei."
"Als man mit der objektorientierten Programmierung begann, war man glücklich, weil man glaubte, mit dem Konzept der Klassen eine natürliche Form der Kapselung (engl. encapsulation) gefunden zu haben, die zudem noch mit der hochangesehenen Theorie der abstrakten Datentypen in Einklang steht (zumindest einigermaßen): Klassen ergeben sich auf natürliche Weise aus der Anwendungsdomäne (als Repräsentanten von Allgemeinbegriffen; siehe Kurseinheit 1, Kapitel 7), und Daten sowie Implementierungsdetails lassen sich hinter der Klassenschnittstelle (dem Protokoll der Objekte) verbergen.",Was ist Kapselung in der objektorientierten Programmierung?,"Kapselung in der objektorientierten Programmierung ist ein Konzept, bei dem Daten und Implementierungsdetails in einer Klasse verborgen werden und nur über eine Schnittstelle (das Protokoll der Objekte) zugänglich sind. Dies ermöglicht es, die Komplexität von Systemen zu reduzieren und die Wartbarkeit und Erweiterbarkeit von Code zu verbessern."
"Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls gefeierte Vererbung die Kapselung von Klassen auf unangenehme Weise aufbrach: Wie in Kapitel 55 bemerkt, erzeugt die Vererbung starke Abhängigkeiten (auch zwischen den Implementierungsdetails!) von Klassen und ihren Subklassen. Diese Abhängigkeiten explizit zu machen kann zwar vor Programmierfehlern schützen, sie kann aber die Abhängigkeiten nicht beseitigen, sondern lediglich dokumentieren. Die Abhängigkeiten zu beschränken bedeutet wiederum, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das nun einmal: Alles hat seinen Preis.",Wie wirkt sich Vererbung auf die Kapselung von Klassen aus?,"Vererbung kann die Kapselung von Klassen auf unangenehme Weise aufbrechen, indem sie starke Abhängigkeiten zwischen Klassen und ihren Subklassen erzeugt. Diese Abhängigkeiten explizit zu machen, kann zwar vor Programmierfehlern schützen, aber die Abhängigkeiten nicht beseitigen. Die Abhängigkeiten zu beschränken, bedeutet, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben."
"Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls gefeierte Vererbung die Kapselung von Klassen auf unangenehme Weise aufbrach: Wie in Kapitel 55 bemerkt, erzeugt die Vererbung starke Abhängigkeiten (auch zwischen den Implementierungsdetails!) von Klassen und ihren Subklassen. Diese Abhängigkeiten explizit zu machen kann zwar vor Programmierfehlern schützen, sie kann aber die Abhängigkeiten nicht beseitigen, sondern lediglich dokumentieren. Die Abhängigkeiten zu beschränken bedeutet wiederum, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das nun einmal: Alles hat seinen Preis.",Was sind die Nachteile der Vererbung in objektorientierter Programmierung?,"Die Vererbung in objektorientierter Programmierung kann die Kapselung von Klassen auf unangenehme Weise aufbrechen und starke Abhängigkeiten zwischen Klassen und ihren Subklassen erzeugen. Diese Abhängigkeiten explizit zu machen, kann zwar vor Programmierfehlern schützen, aber sie nicht beseitigen. Die Abhängigkeiten zu beschränken, bedeutet, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben."
"Sehr viel dramatischer (und sehr viel weniger in aller Munde) ist jedoch ein ganz anderes Problem, das die gesamten bisherigen Bemühungen der Objektorientierung um Kapselung aushebeln kann: das Aliasing-Problem. Wenn nämlich ein Objekt, das durch ein anderes Objekt gekapselt wird, indem das andere es in einer seiner Instanzvariablen hält, einen (weiteren) Alias besitzt, der nicht selbst dem kapselnden Objekt gehört, dann nützt es nichts, wenn diese Instanzvariable von außen unzugreifbar ist91 — sie wird nämlich gar nicht gebraucht, um auf das gekapselte Objekt zuzugreifen. Man bedient sich einfach des Aliases.",Was ist das Aliasing-Problem in der Objektorientierung?,"Das Aliasing-Problem ist ein Problem in der Objektorientierung, bei dem ein Objekt, das durch ein anderes Objekt gekapselt wird, einen weiteren Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dadurch kann man auf das gekapselte Objekt zugegriffen werden, auch wenn die Instanzvariable von außen unzugreifbar ist."
"In SMALLTALK wird das Problem in folgendem Beispiel klar: Hier soll ein neues Objekt der Klasse A erzeugt werden und die Erzeugungszeit in einer entsprechenden Instanzvariable des Objekts festgehalten werden. Die Variable ""jetzt"" hält aber einen Alias auf das Objekt, das diese Zeit repräsentiert; ändert man dieses Zeitobjekt (wie in Zeile 1534), dann betrifft dies auch die Erzeugungszeit des Objekts ""a"".92 Nun könnte man meinen, es genügte, man ersparte sich einfach den (offensichtlichen) Alias ""jetzt"". Dies ist aber nicht möglich, weil ""Time now"" ein Ausdruck ist, der zur Laufzeit ausgewertet wird, während die Instanzvariable ""erzeugungsZeit"" zur Erzeugungszeit initialisiert werden muss. Dies führt aber zu einem anderen Problem: Die Variable ""a"" ist eine Verweisvariable, d.h. sie enthält nicht den Wert des Objekts, sondern einen Verweis auf das Objekt. Die Zuweisung in Zeile 1535 erzeugt daher keinen neuen Zeitpunkt, sondern verändert den bestehenden. Dies führt aber zu einem noch unerwarteteren Ergebnis: Die Variable ""a"" enthält einen Verweis auf ein neues Objekt, aber die Instanzvariable ""erzeugungsZeit"" des Objekts enthält den Wert der Instanzvariable ""erzeugungsZeit"" des alten Objekts.",Was ist der Unterschied zwischen Verweisvariablen und Wertvariablen?,"Verweisvariablen enthalten einen Verweis auf ein Objekt, während Wertvariablen den Wert des Objekts enthalten."
"In SMALLTALK wird das Problem in folgendem Beispiel klar: Hier soll ein neues Objekt der Klasse A erzeugt werden und die Erzeugungszeit in einer entsprechenden Instanzvariable des Objekts festgehalten werden. Die Variable ""jetzt"" hält aber einen Alias auf das Objekt, das diese Zeit repräsentiert; ändert man dieses Zeitobjekt (wie in Zeile 1534), dann betrifft dies auch die Erzeugungszeit des Objekts ""a"".92 Nun könnte man meinen, es genügte, man ersparte sich einfach den (offensichtlichen) Alias ""jetzt"". Dies ist aber nicht möglich, weil ""Time now"" ein Ausdruck ist, der zur Laufzeit ausgewertet wird, während die Instanzvariable ""erzeugungsZeit"" zur Erzeugungszeit initialisiert werden muss. Dies führt aber zu einem anderen Problem: Die Variable ""a"" ist eine Verweisvariable, d.h. sie enthält nicht den Wert des Objekts, sondern einen Verweis auf das Objekt. Die Zuweisung in Zeile 1535 erzeugt daher keinen neuen Zeitpunkt, sondern verändert den bestehenden. Dies führt aber zu einem noch unerwarteteren Ergebnis: Die Variable ""a"" enthält einen Verweis auf ein neues Objekt, aber die Instanzvariable ""erzeugungsZeit"" des Objekts enthält den Wert der Instanzvariable ""erzeugungsZeit"" des alten Objekts.",Was ist der Unterschied zwischen einem Alias und einem Wert?,"Ein Alias ist eine Referenz auf ein Objekt, während ein Wert eine eigene Kopie des Objekts ist. Wenn man einen Alias ändert, dann ändert man das Originalobjekt, während man bei einem Wert nur die Kopie ändert. Im Beispiel von ""jetzt"" und ""Time now"" sind beide Alias auf das gleiche Zeitobjekt, und wenn man das Zeitobjekt ändert, dann ändert sich auch die Erzeugungszeit von ""a""."
"Woher weiß man aber, dass die Methode ""now"" in der Klasse ""Time"" nicht einen Alias auf jedes neu erzeugte Objekt anlegt (beispielsweise weil ""Time"" Buch darüber führt, welche Instanzen es von ihr gibt) und diesen Alias nicht herausgibt oder selbst verwendet, um die Objekte zu manipulieren? Auch die alternative scheinbare Lösung, ""Erzeugungsdatum"" funktioniert aus gleichem Grunde nicht zuverlässig, denn auch ""copy"" kann sich (heimlich) Aliase anlegen.","Wie kann man sicherstellen, dass eine Methode in einer Klasse keine Aliase anlegt und verwendet?","Um sicherzustellen, dass eine Methode in einer Klasse keine Aliase anlegt und verwendet, kann man die Implementierung der Klasse überprüfen und sicherstellen, dass sie keine Aliase erstellt oder verwendet. Zusätzlich kann man die Sprache und die Laufzeitumgebung überprüfen, um sicherzustellen, dass sie keine Aliase automatisch erzeugen."
"Ein anderes Beispiel, bei dem Aliase fehlerhaft eingesetzt werden, ist das folgende. Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Das ist hier aber gar nicht der Punkt.",Was ist ein Beispiel für fehlerhafte Verwendung von Aliase?,"Ein Beispiel für fehlerhafte Verwendung von Aliase ist das folgende: Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Wenn man Aliase fehlerhaft einsetzt, kann es passieren, dass eine Änderung an einer Leuchte sich auf andere Leuchten auswirkt, obwohl dies nicht beabsichtigt war."
"Man nennt Objekte, die die Implementierung eines Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen, ""Repräsentationsobjekte"". Die Leuchten des obigen Beispiels sind allesamt Repräsentationsobjekte; sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen. Insbesondere gibt es in obigem Beispiel keine Verwendung einer Leuchte losgelöst von einer Ampel. Dies muss aber nicht für alle Leuchten der Fall sein — es ist durchaus denkbar, dass Leuchtenobjekte in anderen oder sogar im selben Programm auch ein unabhängiges Leben (außerhalb von Ampeln) führen. Aber selbst das ist gar nicht notwendig — im gegebenen Beispiel wäre es auch denkbar, dass mit Leuchten noch einiges gemacht wird, bevor sie in eine Ampel eingebaut werden, so dass man das Aliasing-Problem weder pauschal an die Klasse ""Leuchte"" noch an deren Verwendung als Lieferant für Repräsentationsobjekte knüpfen kann.",Was sind Repräsentationsobjekte?,"Repräsentationsobjekte sind Objekte, die die Implementierung eines anderen Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen. Sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen."
"Wenn Aliase also schlecht sind, könnte man sie ja auch einfach verbieten. Tatsächlich bieten einige Programmiersprachen wie C-Sharp, C++ und EIFFEL die Möglichkeit, Klassen als Werttypen zu definieren, sodass bei Zuweisungen nicht automatisch Aliase entstehen. Aber durch eine derart einfache Lösung schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein, wie das folgende Beispiel zeigt:","Was sind die Nachteile, wenn Aliase in Programmiersprachen verboten werden?","Wenn Aliase in Programmiersprachen verboten werden, schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein. Ein Beispiel dafür ist die Verwendung von Klassen als Werttypen in Programmiersprachen wie C-Sharp, C++ und EIFFEL, bei der bei Zuweisungen nicht automatisch Aliase entstehen."
"Wenn Aliase also schlecht sind, könnte man sie ja auch einfach verbieten. Tatsächlich bieten einige Programmiersprachen wie C-Sharp, C++ und EIFFEL die Möglichkeit, Klassen als Werttypen zu definieren, sodass bei Zuweisungen nicht automatisch Aliase entstehen. Aber durch eine derart einfache Lösung schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein, wie das folgende Beispiel zeigt:",Warum können Aliase ein Problem sein?,"Aliase sind Variablen, die auf das gleiche Objekt verweisen. Sie können schlecht sein, weil sie zu unerwarteten Nebenwirkungen führen können, wenn man nicht vorsichtig ist. Wenn man beispielsweise den Zustand eines Objekts über eine Variable ändert, kann dies auch den Zustand über eine andere Variable beeinflussen, die auf dasselbe Objekt verweist. Dies kann zu Verwirrung und Fehlern führen. Einige Programmiersprachen bieten die Möglichkeit, Klassen als Werttypen zu definieren, um das Entstehen von Aliase zu vermeiden."
"Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.",Was ist der Unterschied zwischen einer Kopie und einem Zeiger in Bezug auf Objekte?,"In Bezug auf Objekte ist eine Kopie eine unabhängige Instanz des Objekts, während ein Zeiger auf das originale Objekt verweist. In Sprachen ohne Referenzsemantik ist es nicht möglich, Zeiger zu verwenden, während Sprachen mit Referenzsemantik dies ermöglichen."
"Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.",Was ist Aliasing und wie kann es bei der Spezifikation von sicherheitskritischen Anwendungen problematisch sein?,"Aliasing bedeutet, dass mehrere Variablen auf das gleiche Objekt verweisen. Bei der Spezifikation von sicherheitskritischen Anwendungen kann Aliasing problematisch sein, da es mit der Spezifikation nicht vereinbar wäre, wenn es von außen auf geheime Daten- oder Funktionsträger gibt. Am Programmverhalten ist dies jedoch nicht zu erkennen."
"Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.",Warum können Aliase ein Problem bei sicherheitskritischen Anwendungen darstellen?,"Aliase können ein Problem bei sicherheitskritischen Anwendungen darstellen, da sie mit der Spezifikation nicht vereinbar wären. Wenn es Aliase von außen auf geheime Daten- oder Funktionsträger gibt, ist die Spezifikation nicht erfüllt."
"Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.",Was ist Aliasing und wie kann es zu Problemen führen?,"Aliasing bedeutet, dass mehrere Variablen auf das gleiche Objekt verweisen. Dies kann zu Problemen führen, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, da Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger zugreifen können. Dies ist bei sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Am Programmverhalten ist dies jedoch nicht zu erkennen."
"Nachdem das Problem nun hinreichend klar geworden sein sollte, was kann man dagegen tun? Zunächst einmal muss noch einmal klargestellt werden, dass die Deklaration von Instanzvariablen als von außen unzugreifbar (private) lediglich Namen verbirgt — man kann über die Schnittstelle des Objekts nicht herausfinden, wie es intern aufgebaut ist. Dieser Namensschutz (engl. name protection) ist das, was man landläufig (mit dem Wissen vom Aliasing-Problem) mit Geheimnisprinzip (engl. information hiding) verbindet: Es verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, so dass diese problemlos geändert (z. B. umbenannt oder entfernt) werden können.",Was ist der Unterschied zwischen Namensschutz und Geheimnisprinzip?,"Namensschutz (name protection) verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, indem es ihre Namen verbirgt. Das Geheimnisprinzip (information hiding) hingegen verhindert, dass andere Klassen von der Implementierung eines Objekts abhängen, indem es die Möglichkeit schafft, die Implementierung ohne Auswirkungen auf andere Klassen zu ändern."
"Nachdem das Problem nun hinreichend klar geworden sein sollte, was kann man dagegen tun? Zunächst einmal muss noch einmal klargestellt werden, dass die Deklaration von Instanzvariablen als von außen unzugreifbar (private) lediglich Namen verbirgt — man kann über die Schnittstelle des Objekts nicht herausfinden, wie es intern aufgebaut ist. Dieser Namensschutz (engl. name protection) ist das, was man landläufig (mit dem Wissen vom Aliasing-Problem) mit Geheimnisprinzip (engl. information hiding) verbindet: Es verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, so dass diese problemlos geändert (z. B. umbenannt oder entfernt) werden können.",Was wird durch den Namensschutz verhindert?,"Der Namensschutz verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, sodass diese problemlos geändert werden können."
"Das Geheimnisprinzip vermag jedoch nicht zu verhindern, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen. Dies kann z. B. immer dann der Fall sein (und ist vom Objekt, das sein Implementationsgeheimnis wahren will, kaum zu verhindern), wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt (genau so, wie das in den obigen Beispielen in den Zeilen 1533, 1535 und 1540 der Fall war). Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter, aber das wäre dann vom „verbergenden“ Objekt selbst zu verantworten (und zu verhindern gewesen).",Was besagt das Geheimnisprinzip?,"Das Geheimnisprinzip besagt, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen können, z.B. wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt. Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter."
"Das Geheimnisprinzip vermag jedoch nicht zu verhindern, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen. Dies kann z. B. immer dann der Fall sein (und ist vom Objekt, das sein Implementationsgeheimnis wahren will, kaum zu verhindern), wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt (genau so, wie das in den obigen Beispielen in den Zeilen 1533, 1535 und 1540 der Fall war). Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter, aber das wäre dann vom „verbergenden“ Objekt selbst zu verantworten (und zu verhindern gewesen).",Wie kann das Geheimnisprinzip umgangen werden?,"Das Geheimnisprinzip kann umgangen werden, indem Repräsentationsobjekte, deren Namen verborgen werden sollen, noch andere Namen besitzen, zum Beispiel wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt oder wenn das Objekt selbst eine Referenz auf ein Repräsentationsobjekt herausgibt, beispielsweise durch einen Getter."
"Sobald also die Möglichkeit des Aliasing besteht, ist eine echte Kapselung über das Geheimnisprinzip allein nicht mehr zu gewährleisten. Man muss also das Aliasing irgendwie kontrollieren. Die Frage ist nur: Wie?",Was ist Aliasing und wie kann es kontrolliert werden?,"Aliasing bedeutet, dass mehrere Variablen auf ein und dasselbe Objekt verweisen. Um Aliasing zu kontrollieren, muss man sicherstellen, dass dies nicht geschieht oder dass es bei der Ausführung des Programms keine negativen Auswirkungen hat. Dies kann durch verschiedene Methoden erreicht werden, wie zum Beispiel durch die Verwendung von lokalen Variablen oder durch Kopien von Objekten anstelle von Referenzen."
"Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5 genannten Programmiersprachen ist das jedoch nur in C-Sharp, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.","Wie kann man die Teil-Ganzes-Beziehung zwischen Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, in Programmierung verstehen?","Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können."
"Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5 genannten Programmiersprachen ist das jedoch nur in C-Sharp, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.","Wie kann man verhindern, dass Objekte von anderen Objekten referenziert werden können?","Eine Möglichkeit, dies zu verhindern, ist, aus den Objekten Wertobjekte zu machen und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Dies ist jedoch nur in einigen Programmiersprachen möglich, wie zum Beispiel in C-Sharp im Safe mode, wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde. Diese Vorgehensweise ist jedoch nur selten ohne unerwünschte Nebenwirkungen, da alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was die Anwendungsdomäne in der Regel nicht korrekt abbildet."
"Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5 genannten Programmiersprachen ist das jedoch nur in C-Sharp, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.","Warum verhindert die Verwendung von Wertobjekten in C-Sharp, dass die Objekte referenziert werden können?","In C-Sharp können, wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde, keine Zeiger auf Wertobjekte erstellt werden, was bedeutet, dass die Objekte nicht von anderen Objekten referenziert werden können."
"Vor diesem Hintergrund scheint der in Abschnitt 52.5.2 dargelegte Umgang EIFFELs mit Referenz- und Wertvariablen ziemlich schlau ausgedacht zu sein. Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei. Dumm ist nur, wenn man innerhalb der Kapsel Aliase auf Wertobjekte braucht. Weitergehende Mechanismen zur Aliaskontrolle in objektorientierten Programmiersprachen befinden sich derzeit alle noch in der Vorschlags- und Erprobungsphase und sollen hier deswegen nicht weiter behandelt werden.",Wie geht EIFFEL mit Referenz- und Wertvariablen um?,"EIFFEL erlaubt, auf Wertobjekte Referenzen zu haben, aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Somit sind Wertobjekte in EIFFEL aliasfrei."
"Weil Literale immer die gleichen Objekte repräsentieren, reichen sie zum Programmieren nicht aus. Was man vielmehr auch noch benötigt, sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können, die sogenannten Variablen.Genau wie ein Literal steht eine Variable in einem Programm für ein Objekt. Anders als bei Literalen wird aus einer Variable jedoch kein Objekt erzeugt: Sie ist lediglich ein Name für ein bereits existierendes Objekt. Dazu kommt, dass eine Variable zu unterschiedlichen Zeitpunkten für unterschiedliche Objekte stehen kann (deshalb der Name „Variable“!). Es können zudem Variablen mit unterschiedlichen Namen für dasselbe Objekt stehen, das damit gewissermaßen verschiedene Namen hat, die sogenannten Aliase. Im Folgenden werden wir daher davon sprechen, dass Variablen Objekte benennen oder bezeichnen.",Warum reichen Literale zum Programmieren nicht aus?,"Literale reichen zum Programmieren nicht aus, weil sie immer die gleichen Objekte repräsentieren."
"Weil Literale immer die gleichen Objekte repräsentieren, reichen sie zum Programmieren nicht aus. Was man vielmehr auch noch benötigt, sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können, die sogenannten Variablen.Genau wie ein Literal steht eine Variable in einem Programm für ein Objekt. Anders als bei Literalen wird aus einer Variable jedoch kein Objekt erzeugt: Sie ist lediglich ein Name für ein bereits existierendes Objekt. Dazu kommt, dass eine Variable zu unterschiedlichen Zeitpunkten für unterschiedliche Objekte stehen kann (deshalb der Name „Variable“!). Es können zudem Variablen mit unterschiedlichen Namen für dasselbe Objekt stehen, das damit gewissermaßen verschiedene Namen hat, die sogenannten Aliase. Im Folgenden werden wir daher davon sprechen, dass Variablen Objekte benennen oder bezeichnen.",Was sind Variablen?,"Variablen sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können."
"Weil Literale immer die gleichen Objekte repräsentieren, reichen sie zum Programmieren nicht aus. Was man vielmehr auch noch benötigt, sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können, die sogenannten Variablen.Genau wie ein Literal steht eine Variable in einem Programm für ein Objekt. Anders als bei Literalen wird aus einer Variable jedoch kein Objekt erzeugt: Sie ist lediglich ein Name für ein bereits existierendes Objekt. Dazu kommt, dass eine Variable zu unterschiedlichen Zeitpunkten für unterschiedliche Objekte stehen kann (deshalb der Name „Variable“!). Es können zudem Variablen mit unterschiedlichen Namen für dasselbe Objekt stehen, das damit gewissermaßen verschiedene Namen hat, die sogenannten Aliase. Im Folgenden werden wir daher davon sprechen, dass Variablen Objekte benennen oder bezeichnen.",Warum gibt es Variablen?,"Variablen sind notwendig, weil Literale immer die gleichen Objekte repräsentieren, weshalb sie zum Programmieren nicht ausreichen."
"Weil Literale immer die gleichen Objekte repräsentieren, reichen sie zum Programmieren nicht aus. Was man vielmehr auch noch benötigt, sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können, die sogenannten Variablen.Genau wie ein Literal steht eine Variable in einem Programm für ein Objekt. Anders als bei Literalen wird aus einer Variable jedoch kein Objekt erzeugt: Sie ist lediglich ein Name für ein bereits existierendes Objekt. Dazu kommt, dass eine Variable zu unterschiedlichen Zeitpunkten für unterschiedliche Objekte stehen kann (deshalb der Name „Variable“!). Es können zudem Variablen mit unterschiedlichen Namen für dasselbe Objekt stehen, das damit gewissermaßen verschiedene Namen hat, die sogenannten Aliase. Im Folgenden werden wir daher davon sprechen, dass Variablen Objekte benennen oder bezeichnen.",Was unterscheidet Variablen und Literale?,"Anders als bei Literalen wird aus einer Variable kein Objekt erzeugt, sie ist lediglich ein Name für ein bereits existierendes Objekt."
"In Java wird, genau wie in SMALLTALK, zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) (wobei (.) hier für einen nicht näher spezifizierten Parameter steht) geprüft, die Identität mittels == (bzw. != für das Negativ). equals(.) wird von der Klasse Object (in Java genau wie in SMALLTALK die Superklasse aller Klassen) geerbt und sollte in den Subklassen entsprechend der jeweiligen Bedeutung von Gleichheit überschrieben werden. Die Verwechslung von equals(.) und == ist auch in Java ein ziemlich häufiger Programmierfehler (siehe Abschnitt 1.4 in Kurseinheit 1). Das Gleichheitszeichen = steht in Java übrigens (genau wie in C, C++ und C-Sharp) für die Wertzuweisung, was ich persönlich für eine der großen Tragödien in der Informatik halte.",Wie wird die Gleichheit von Objekten in Java geprüft?,Die Gleichheit von Objekten wird in Java mittels der Methode equals(.) geprüft.
"In Java wird, genau wie in SMALLTALK, zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) (wobei (.) hier für einen nicht näher spezifizierten Parameter steht) geprüft, die Identität mittels == (bzw. != für das Negativ). equals(.) wird von der Klasse Object (in Java genau wie in SMALLTALK die Superklasse aller Klassen) geerbt und sollte in den Subklassen entsprechend der jeweiligen Bedeutung von Gleichheit überschrieben werden. Die Verwechslung von equals(.) und == ist auch in Java ein ziemlich häufiger Programmierfehler (siehe Abschnitt 1.4 in Kurseinheit 1). Das Gleichheitszeichen = steht in Java übrigens (genau wie in C, C++ und C-Sharp) für die Wertzuweisung, was ich persönlich für eine der großen Tragödien in der Informatik halte.",Wie unterscheidet man in Java zwischen Gleichheit und Identität von Objekten?,"In Java wird zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) geprüft, die Identität mittels == (bzw. != für das Negativ). equals(.) wird von der Klasse Object geerbt und sollte in den Subklassen entsprechend der jeweiligen Bedeutung von Gleichheit überschrieben werden. Das Gleichheitszeichen = steht in Java für die Wertzuweisung."
"Da Ausdrücke andere Ausdrücke enthalten können, stellt sich die Frage nach der Reihenfolge der Auswertung von geschachtelten Ausdrücken. Diese Reihenfolge wird, wie in anderen Programmiersprachen, implizit durch Präzedenzen und explizit durch Klammern festgelegt.Betrachten wir zunächst die doppelte Zuweisung in Zeile 38 oben. Anfangs mag es nicht sofort klar sein, welche der beiden Zuweisungen zuerst ausgewertet (ausgeführt) werden soll: y := x oder x := 1. Wenn man jedoch berücksichtigt, dass y := x := 1 ein geschachtelter Ausdruck ist, und jeder (Teil-)Ausdruck für ein Objekt steht, ergibt sich, dass der zweite Ausdruck zuerst ausgewertet und durch das Ergebnis, nämlich ""1"", ersetzt werden muss. Andernfalls würde die ""1"" dem Ergebnis von y := x zugewiesen, was aber gemäß Abschnitt 4.1.3 ein Objekt und keine Variable ist. Zeile 38 weist also zuerst x und dann y das Objekt ""1"" zu, und die Auswertung erfolgt von rechts nach links.Dies ist jedoch ein Sonderfall. Im Allgemeinen werden in SMALLTALK alle Ausdrücke von links nach rechts ausgewertet. Dabei haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke wiederum haben Vorrang vor Schlüsselwortnachrichten. Bei gleichrangigen Ausdrücken erfolgt die Auswertung von links nach rechts.Um die Präzedenz zu ändern, können Sie einfach Klammern verwenden. SMALLTALK unterstützt keine individuellen Operatorpräzedenzen wie beispielsweise ""Punktrechnung vor Strichrechnung"".Bei mehrstelligen Nachrichten mit Schlüsselwörtern werden alle Schlüsselwörter eines Ausdrucks als zu einer Nachricht gehörig interpretiert, es sei denn, es werden Klammern gesetzt.",Wie ist die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK?,Die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK wird durch Präzedenzen und Klammern festgelegt.
"Da Ausdrücke andere Ausdrücke enthalten können, stellt sich die Frage nach der Reihenfolge der Auswertung von geschachtelten Ausdrücken. Diese Reihenfolge wird, wie in anderen Programmiersprachen, implizit durch Präzedenzen und explizit durch Klammern festgelegt.Betrachten wir zunächst die doppelte Zuweisung in Zeile 38 oben. Anfangs mag es nicht sofort klar sein, welche der beiden Zuweisungen zuerst ausgewertet (ausgeführt) werden soll: y := x oder x := 1. Wenn man jedoch berücksichtigt, dass y := x := 1 ein geschachtelter Ausdruck ist, und jeder (Teil-)Ausdruck für ein Objekt steht, ergibt sich, dass der zweite Ausdruck zuerst ausgewertet und durch das Ergebnis, nämlich ""1"", ersetzt werden muss. Andernfalls würde die ""1"" dem Ergebnis von y := x zugewiesen, was aber gemäß Abschnitt 4.1.3 ein Objekt und keine Variable ist. Zeile 38 weist also zuerst x und dann y das Objekt ""1"" zu, und die Auswertung erfolgt von rechts nach links.Dies ist jedoch ein Sonderfall. Im Allgemeinen werden in SMALLTALK alle Ausdrücke von links nach rechts ausgewertet. Dabei haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke wiederum haben Vorrang vor Schlüsselwortnachrichten. Bei gleichrangigen Ausdrücken erfolgt die Auswertung von links nach rechts.Um die Präzedenz zu ändern, können Sie einfach Klammern verwenden. SMALLTALK unterstützt keine individuellen Operatorpräzedenzen wie beispielsweise ""Punktrechnung vor Strichrechnung"".Bei mehrstelligen Nachrichten mit Schlüsselwörtern werden alle Schlüsselwörter eines Ausdrucks als zu einer Nachricht gehörig interpretiert, es sei denn, es werden Klammern gesetzt.",In welcher Reihenfolge werden Ausdrücke ausgewertet?,In SMALLTALK werden Ausdrücke normalerweise von links nach rechts ausgewertet.
"Da Ausdrücke andere Ausdrücke enthalten können, stellt sich die Frage nach der Reihenfolge der Auswertung von geschachtelten Ausdrücken. Diese Reihenfolge wird, wie in anderen Programmiersprachen, implizit durch Präzedenzen und explizit durch Klammern festgelegt.Betrachten wir zunächst die doppelte Zuweisung in Zeile 38 oben. Anfangs mag es nicht sofort klar sein, welche der beiden Zuweisungen zuerst ausgewertet (ausgeführt) werden soll: y := x oder x := 1. Wenn man jedoch berücksichtigt, dass y := x := 1 ein geschachtelter Ausdruck ist, und jeder (Teil-)Ausdruck für ein Objekt steht, ergibt sich, dass der zweite Ausdruck zuerst ausgewertet und durch das Ergebnis, nämlich ""1"", ersetzt werden muss. Andernfalls würde die ""1"" dem Ergebnis von y := x zugewiesen, was aber gemäß Abschnitt 4.1.3 ein Objekt und keine Variable ist. Zeile 38 weist also zuerst x und dann y das Objekt ""1"" zu, und die Auswertung erfolgt von rechts nach links.Dies ist jedoch ein Sonderfall. Im Allgemeinen werden in SMALLTALK alle Ausdrücke von links nach rechts ausgewertet. Dabei haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke wiederum haben Vorrang vor Schlüsselwortnachrichten. Bei gleichrangigen Ausdrücken erfolgt die Auswertung von links nach rechts.Um die Präzedenz zu ändern, können Sie einfach Klammern verwenden. SMALLTALK unterstützt keine individuellen Operatorpräzedenzen wie beispielsweise ""Punktrechnung vor Strichrechnung"".Bei mehrstelligen Nachrichten mit Schlüsselwörtern werden alle Schlüsselwörter eines Ausdrucks als zu einer Nachricht gehörig interpretiert, es sei denn, es werden Klammern gesetzt.",Welche Ausdrücke haben in SMALLTALK Vorrang?,"In SMALLTALK haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke haben Vorrang vor Schlüsselwortnachrichten."
"Da Ausdrücke andere Ausdrücke enthalten können, stellt sich die Frage nach der Reihenfolge der Auswertung von geschachtelten Ausdrücken. Diese Reihenfolge wird, wie in anderen Programmiersprachen, implizit durch Präzedenzen und explizit durch Klammern festgelegt.Betrachten wir zunächst die doppelte Zuweisung in Zeile 38 oben. Anfangs mag es nicht sofort klar sein, welche der beiden Zuweisungen zuerst ausgewertet (ausgeführt) werden soll: y := x oder x := 1. Wenn man jedoch berücksichtigt, dass y := x := 1 ein geschachtelter Ausdruck ist, und jeder (Teil-)Ausdruck für ein Objekt steht, ergibt sich, dass der zweite Ausdruck zuerst ausgewertet und durch das Ergebnis, nämlich ""1"", ersetzt werden muss. Andernfalls würde die ""1"" dem Ergebnis von y := x zugewiesen, was aber gemäß Abschnitt 4.1.3 ein Objekt und keine Variable ist. Zeile 38 weist also zuerst x und dann y das Objekt ""1"" zu, und die Auswertung erfolgt von rechts nach links.Dies ist jedoch ein Sonderfall. Im Allgemeinen werden in SMALLTALK alle Ausdrücke von links nach rechts ausgewertet. Dabei haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke wiederum haben Vorrang vor Schlüsselwortnachrichten. Bei gleichrangigen Ausdrücken erfolgt die Auswertung von links nach rechts.Um die Präzedenz zu ändern, können Sie einfach Klammern verwenden. SMALLTALK unterstützt keine individuellen Operatorpräzedenzen wie beispielsweise ""Punktrechnung vor Strichrechnung"".Bei mehrstelligen Nachrichten mit Schlüsselwörtern werden alle Schlüsselwörter eines Ausdrucks als zu einer Nachricht gehörig interpretiert, es sei denn, es werden Klammern gesetzt.",Wie kann die Reihenfolge der Auswertung in SMALLTALK verändert werden?,"Um die Reihenfolge der Auswertung in SMALLTALK zu ändern, können Klammern verwendet werden, um sicherzustellen, dass bestimmte Teile eines Ausdrucks zuerst ausgewertet werden."
"Kein Objekt existiert isoliert. Im Gegenteil, Objekte müssen in Beziehung zueinander stehen, um Bedeutung zu erlangen. Zum Beispiel hat das Objekt ""1"" keine Bedeutung, solange es nicht eine spezifische Eigenschaft eines anderen Objekts beschreibt, wie die Hausnummer eines Hauses oder die Anzahl der Elemente in einem Array. Tatsächlich werden die meisten Objekte in einem System erst durch ihre Beziehungen zu anderen Objekten nützlich. Ein Objekt, das eine Person repräsentiert, wird erst dann durch den Namen ""Hans Mustermann"" identifizierbar, wenn es in einer entsprechenden Beziehung zur Person steht, und umgekehrt.",Warum stehen Objekte in Beziehung zueinander?,"Objekte stehen in Beziehung zueinander, um Bedeutung zu erlangen. Die meisten Objekte in einem System werden erst durch ihre Beziehungen zu anderen Objekten nützlich."
"In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt. Dieses Geflecht kann: navigiert werden, um von einem Datum (Stück Information) zu einem anderen zu kommen, oder auch manipuliert werden, um die repräsentierte Information zu verändern.Das Datenmodell der objektorientierten Programmierung ähnelt dem Netzwerkmodell, das vor einigen Jahrzehnten die Grundlage für große Datenbankmanagementsysteme bildete, bevor es vom relationalen Datenmodell verdrängt wurde. Erst mit der Einführung objektorientierter Datenbanken gewinnt das Netzwerkmodell wieder an theoretischer Bedeutung.",Wie werden Informationen dargestellt?,In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt. Dieses Geflecht kann navigiert und manipuliert werden.
"In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt. Dieses Geflecht kann: navigiert werden, um von einem Datum (Stück Information) zu einem anderen zu kommen, oder auch manipuliert werden, um die repräsentierte Information zu verändern.Das Datenmodell der objektorientierten Programmierung ähnelt dem Netzwerkmodell, das vor einigen Jahrzehnten die Grundlage für große Datenbankmanagementsysteme bildete, bevor es vom relationalen Datenmodell verdrängt wurde. Erst mit der Einführung objektorientierter Datenbanken gewinnt das Netzwerkmodell wieder an theoretischer Bedeutung.",Wie wird das Geflecht von Objekten genutzt?,"Das Geflecht von Objekten kann navigiert werden, um von einem Datum zu einem anderen zu kommen, oder auch manipuliert werden, um die repräsentierte Information zu verändern."
"In der objektorientierten Programmierung werden Beziehungen zwischen Objekten über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten ""navigieren"". Es ist wichtig zu beachten, dass diese Verknüpfung immer gerichtet ist. Das bedeutet, dass man von einem Objekt zu einem anderen navigieren kann, aber nicht zwangsläufig wieder zurück. Dafür wäre ein Zeiger in Gegenrichtung erforderlich.Variablen selbst enthalten ebenfalls Verweise. Wer also Zugriff auf die Variable hat, kann auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.",Wie werden Beziehungen zwischen Objekten hergestellt?,"Beziehungen zwischen Objekten werden über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten ""navigieren"". Dabei ist zu beachten, dass diese Verknüpfung immer gerichtet ist und man nicht zwangsläufig wieder zurücknavigieren kann."
"In der objektorientierten Programmierung werden Beziehungen zwischen Objekten über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten ""navigieren"". Es ist wichtig zu beachten, dass diese Verknüpfung immer gerichtet ist. Das bedeutet, dass man von einem Objekt zu einem anderen navigieren kann, aber nicht zwangsläufig wieder zurück. Dafür wäre ein Zeiger in Gegenrichtung erforderlich.Variablen selbst enthalten ebenfalls Verweise. Wer also Zugriff auf die Variable hat, kann auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.",Wie werden Variablen für Beziehungen genutzt?,"Variablen enthalten Verweise. Wenn jemand Zugriff auf die Variable hat, kann er auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden."
"Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.",Was ist das Ziel des Typsystems von C++?,"Das Typsystem von C++ versucht, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen."
"Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.",Was ist die Zuweisung in der objektorientierten Programmierung?,"Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung, das durch den Zuweisungsoperator durchgeführt wird. Es gibt jedoch auch implizite Zuweisungen, die bei Methodenaufrufen vorkommen."
"Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.",Was ist die Rolle des Typsystems in C++?,"Das Typsystem von C++ ist ein wichtiger Bestandteil der Sprache und umfasst primitive Datentypen wie int, bool, etc., sowie die Typkonstruktoren struct und union. Diese Typen sind alle Typen mit Wertsemantik. Es ist auch möglich, Zeigertypen auf diese Typen zu definieren."
"Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.",Welche Datentypen gibt es in C++?,"In C++ gibt es primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct und union. Alle diese Typen sind Typen mit Wertsemantik. Es lassen sich jedoch auch Zeigertypen darauf definieren."
"Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.",Was ist der Unterschied zwischen Typen mit Wertsemantik und Typen mit Referenzsemantik in C++?,"In C++ haben Typen mit Wertsemantik eine eigene Kopie im Speicher, während Typen mit Referenzsemantik (Zeiger) nur einen Speicherort im Speicher referenzieren. Das bedeutet, dass bei der Zuweisung von Werten mit Wertsemantik eine Kopie erstellt wird, während bei der Zuweisung von Werten mit Referenzsemantik nur der Speicherort kopiert wird."
"Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C-Sharp) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.",Was ist Mehrfachvererbung in C++?,"Mehrfachvererbung in C++ bedeutet, dass eine Klasse von mehreren anderen Klassen abgeleitet werden kann. Die Syntax von C++ sieht vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten."
"Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C-Sharp) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.",Was erlaubt C++ und unterscheidet sich dadurch von vielen anderen objektorientierten Programmiersprachen?,"C++ erlaubt Mehrfachvererbung, das heißt, eine Klasse kann von mehreren anderen Klassen abgeleitet werden. Diese Funktionalität unterscheidet C++ von den zuvor diskutierten Sprachen, die nur die Einfachvererbung unterstützen."
"Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie Java oder C-Sharp; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.",Was ist das Problem bei der Mehrfachvererbung in C++?,"Das Problem bei der Mehrfachvererbung in C++ ist, dass verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren können. Der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann."
"Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie Java oder C-Sharp; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.",Wie wird Mehrfachvererbung in C++ emuliert?,"In C++ wird Mehrfachvererbung durch rein abstrakte Klassen emuliert, da C++ keine Interfaces wie Java oder C-Sharp kennt."
"Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie Java oder C-Sharp; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.",Was ist die Folge der Mehrfachvererbung für das Typsystem?,"Die Folge der Mehrfachvererbung für das Typsystem ist, dass ein von einer Klasse abgeleiteter Typ beliebig viele direkte Supertypen haben kann (nämlich einen pro direkte Superklasse)."
"Obwohl die Zuweisungskompatibilität in C++ wie in Java über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C-Sharp) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.",Was bedeutet statische Bindung in C++?,"In C++ werden Methoden standardmäßig statisch gebunden, das heißt, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ des Objekts wird also ignoriert."
"Obwohl die Zuweisungskompatibilität in C++ wie in Java über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C-Sharp) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.",Wie werden Methoden in C++ gebunden?,"In C++ werden Methoden standardmäßig statisch gebunden, das bedeutet, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert."
"Bei virtuellen Methoden wird hingegen wie in Java zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und Java-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In Java hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C-Sharp hat man diese Entscheidung nicht nachvollzogen.",Was ist eine virtuelle Methode?,"Bei virtuellen Methoden wird zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Dies geschieht über eine Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt als teuer und sollte daher nur verwendet werden, wenn unbedingt notwendig."
"Bei virtuellen Methoden wird hingegen wie in Java zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und Java-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In Java hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C-Sharp hat man diese Entscheidung nicht nachvollzogen.",Wie wird bei einer virtuellen Methode die richtige Implementierung ermittelt?,"Zur Ermittlung der richtigen Implementierung wird eine sog. Virtual function table verwendet, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer und sollte daher nur verwendet werden, wenn unbedingt notwendig."
"Bei virtuellen Methoden wird hingegen wie in Java zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und Java-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In Java hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C-Sharp hat man diese Entscheidung nicht nachvollzogen.",Was ist eine Virtual function table und wozu wird sie verwendet?,"Eine Virtual function table ist eine Tabelle, die im Laufzeitsystem gehalten wird und in der die zum Objekt passende Implementierung einer virtuellen Methode nachgeschlagen werden kann. Sie wird verwendet, um zur Laufzeit zu prüfen, welchen Typs das Objekt ist und dann zur entsprechenden Methodenimplementierung zu verzweigen."
"In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu Java (und genau wie z. B. in ADA) werden aus Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expandiert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer Template) ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.",Wie wird Generizität in C++ erreicht?,"In C++ wird Generizität mithilfe von Templates erreicht. Templates sind Muster, anhand derer neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu Java werden aus Templates tatsächlich neue Klassen erzeugt, die kompiliert werden. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen, der vom Präprozessor umgesetzt wird."
"Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in Java oder C-Sharp wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen: ""Type casts are not checked at run time; they are checked at compile time. If the type of the expression does not match the required type, the program is ill-formed and will not compile. Type casts are not checked at run-time. If they are not done correctly, the program will not work. If you are not sure whether a type cast is necessary or whether it is done correctly, do not do it. If you are sure, then do it, but be prepared to debug the resulting problems. Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup. Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften Javas gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.",Was ist das Typsystem von C++?,"Das Typsystem von C++ ist rein statisch, aber nicht strikt. Es erlaubt Typumwandlungen (Type casts), die nur zur Kompilierungszeit überprüft werden. Während der Laufzeit wird die Zulässigkeit der Typumwandlung nicht überprüft."
"Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in Java oder C-Sharp wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen: ""Type casts are not checked at run time; they are checked at compile time. If the type of the expression does not match the required type, the program is ill-formed and will not compile. Type casts are not checked at run-time. If they are not done correctly, the program will not work. If you are not sure whether a type cast is necessary or whether it is done correctly, do not do it. If you are sure, then do it, but be prepared to debug the resulting problems. Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup. Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften Javas gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.",Was ist der Unterschied zwischen statischen und strikten Typsystemen?,"Ein statisches Typsystem ist ein Typsystem, in dem die Typen der Ausdrücke bereits zur Übersetzungszeit bestimmt werden. Ein striktes Typsystem ist ein Typsystem, in dem die Typen der Ausdrücke nicht nur zur Übersetzungszeit, sondern auch zur Laufzeit überprüft werden und die Zulässigkeit von Typumwandlungen sichergestellt wird."
"Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in Java oder C-Sharp wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen: ""Type casts are not checked at run time; they are checked at compile time. If the type of the expression does not match the required type, the program is ill-formed and will not compile. Type casts are not checked at run-time. If they are not done correctly, the program will not work. If you are not sure whether a type cast is necessary or whether it is done correctly, do not do it. If you are sure, then do it, but be prepared to debug the resulting problems. Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup. Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften Javas gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.",Was wird durch explizite Typumwandlung vermieden?,"Explicit type conversion ist am besten zu vermeiden. Durch die Verwendung eines Casts wird die vom Compiler bereitgestellte Typüberprüfung unterdrückt und wird daher zu Überraschungen führen, es sei denn, die Programmiererin hat recht."
"Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in Java oder C-Sharp wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen: ""Type casts are not checked at run time; they are checked at compile time. If the type of the expression does not match the required type, the program is ill-formed and will not compile. Type casts are not checked at run-time. If they are not done correctly, the program will not work. If you are not sure whether a type cast is necessary or whether it is done correctly, do not do it. If you are sure, then do it, but be prepared to debug the resulting problems. Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup. Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften Javas gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.",Was ist explizite Typkonvertierung und warum sollte sie vermieden werden?,"Explicit type conversion, auch bekannt als ""casting"", ist eine Technik, bei der der Programmierer den Typ einer Variablen manuell ändert. Diese Technik sollte vermieden werden, da sie die Typüberprüfung des Compilers unterdrückt und daher zu unerwarteten Ergebnissen führen kann, es sei denn, der Programmierer hat recht."
"Die Auswertung von Nachrichtenausdrücken, also von Nachrichten, die an Objekte verschickt werden, erfolgt mithilfe sogenannter Methoden. Eine Methode beschreibt, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf, der in SMALLTALK auch als ""Message pattern"" bezeichnet wird, aber allgemein und im Folgenden eher als Methodensignatur bezeichnet wird. Es enthält eine optionale Liste von lokalen Variablen und einen Methodenrumpf. Der Methodenrumpf enthält die Anweisungen, die die Methode ausmachen und die zur Auswertung eines Nachrichtenausdrucks ausgeführt werden. Es ist üblich, jede Methode mit einem Kommentar in doppelten Anführungsstrichen zu versehen, der beschreibt, was diese Methode tut.",Was ist eine Methode?,"Eine Methode beschreibt, was ein Objekt in Reaktion auf den Erhalt einer bestimmten Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf (Methodensignatur), einer optionalen Liste von lokalen Variablen und einem Methodenrumpf, der die Anweisungen für die Ausführung der Methode enthält."
"Die Methodensignatur besteht aus dem Namen der Methode und der Liste ihrer formalen Parameter. Formale Parameter sind lokale Variablen, denen beim Aufruf der Methode automatisch ein Wert, der als sogenannter tatsächlicher Parameter bezeichnet wird, zugewiesen wird. Die Sichtbarkeit der formalen Parameter ist auf die Methode beschränkt, in deren Methodensignatur sie vorkommen. Wie alle lokalen Variablen müssen sie mit einem Kleinbuchstaben beginnen und sind temporäre Variablen. Das bedeutet, dass sie nur für die Dauer der Ausführung der Methode existieren. Alle durch formale Parameter gebildeten Aliase sind ebenfalls temporär. In SMALLTALK sind formale Parameter zudem Pseudovariablen, d.h., es kann ihnen innerhalb der Methode, für die sie sichtbar sind, nichts zugewiesen werden. Syntaktisch unterscheidet sich SMALLTALK von den meisten anderen Programmiersprachen auch in der Methodendefinition dadurch, dass die formalen Parameter nicht durch Kommata getrennt in einer in Klammern eingeschlossenen Liste hinter dem Methodennamen stehen, sondern jeder Parameter wird einzeln von einem Nachrichtenbestandteil eingeleitet.Die Methodensignatur dient der Auswahl der zu einer Nachricht passenden Methode. Sie ist das Gegenstück zum Nachrichtenselektor, anhand dessen die Auswahl der zu einem Nachrichtenausdruck passenden Methode durchgeführt wird. Anders als ein Nachrichtenausdruck nennt eine Methodensignatur jedoch kein Empfängerobjekt, und die offenen Stellen eines Nachrichtenselektors werden ausschließlich durch Variablen, nämlich die formalen Parameter, und nicht durch beliebige Ausdrücke besetzt.",Was ist eine Methodensignatur?,"Eine Methodensignatur beschreibt, welche Parameter eine Methode erwartet und wie sie in SMALLTALK aufgerufen wird. Sie besteht aus dem Methodennamen und der Liste der formalen Parameter."
"Die Methodensignatur besteht aus dem Namen der Methode und der Liste ihrer formalen Parameter. Formale Parameter sind lokale Variablen, denen beim Aufruf der Methode automatisch ein Wert, der als sogenannter tatsächlicher Parameter bezeichnet wird, zugewiesen wird. Die Sichtbarkeit der formalen Parameter ist auf die Methode beschränkt, in deren Methodensignatur sie vorkommen. Wie alle lokalen Variablen müssen sie mit einem Kleinbuchstaben beginnen und sind temporäre Variablen. Das bedeutet, dass sie nur für die Dauer der Ausführung der Methode existieren. Alle durch formale Parameter gebildeten Aliase sind ebenfalls temporär. In SMALLTALK sind formale Parameter zudem Pseudovariablen, d.h., es kann ihnen innerhalb der Methode, für die sie sichtbar sind, nichts zugewiesen werden. Syntaktisch unterscheidet sich SMALLTALK von den meisten anderen Programmiersprachen auch in der Methodendefinition dadurch, dass die formalen Parameter nicht durch Kommata getrennt in einer in Klammern eingeschlossenen Liste hinter dem Methodennamen stehen, sondern jeder Parameter wird einzeln von einem Nachrichtenbestandteil eingeleitet.Die Methodensignatur dient der Auswahl der zu einer Nachricht passenden Methode. Sie ist das Gegenstück zum Nachrichtenselektor, anhand dessen die Auswahl der zu einem Nachrichtenausdruck passenden Methode durchgeführt wird. Anders als ein Nachrichtenausdruck nennt eine Methodensignatur jedoch kein Empfängerobjekt, und die offenen Stellen eines Nachrichtenselektors werden ausschließlich durch Variablen, nämlich die formalen Parameter, und nicht durch beliebige Ausdrücke besetzt.",Was ist ein Nachrichtenselektor?,"Ein Nachrichtenselektor ist Teil eines Nachrichtenausdrucks und gibt an, welche Nachricht an ein Objekt gesendet wird."
"Die Methodensignatur besteht aus dem Namen der Methode und der Liste ihrer formalen Parameter. Formale Parameter sind lokale Variablen, denen beim Aufruf der Methode automatisch ein Wert, der als sogenannter tatsächlicher Parameter bezeichnet wird, zugewiesen wird. Die Sichtbarkeit der formalen Parameter ist auf die Methode beschränkt, in deren Methodensignatur sie vorkommen. Wie alle lokalen Variablen müssen sie mit einem Kleinbuchstaben beginnen und sind temporäre Variablen. Das bedeutet, dass sie nur für die Dauer der Ausführung der Methode existieren. Alle durch formale Parameter gebildeten Aliase sind ebenfalls temporär. In SMALLTALK sind formale Parameter zudem Pseudovariablen, d.h., es kann ihnen innerhalb der Methode, für die sie sichtbar sind, nichts zugewiesen werden. Syntaktisch unterscheidet sich SMALLTALK von den meisten anderen Programmiersprachen auch in der Methodendefinition dadurch, dass die formalen Parameter nicht durch Kommata getrennt in einer in Klammern eingeschlossenen Liste hinter dem Methodennamen stehen, sondern jeder Parameter wird einzeln von einem Nachrichtenbestandteil eingeleitet.Die Methodensignatur dient der Auswahl der zu einer Nachricht passenden Methode. Sie ist das Gegenstück zum Nachrichtenselektor, anhand dessen die Auswahl der zu einem Nachrichtenausdruck passenden Methode durchgeführt wird. Anders als ein Nachrichtenausdruck nennt eine Methodensignatur jedoch kein Empfängerobjekt, und die offenen Stellen eines Nachrichtenselektors werden ausschließlich durch Variablen, nämlich die formalen Parameter, und nicht durch beliebige Ausdrücke besetzt.",Was unterscheidet eine Methodensignatur und einen Nachrichtenselektor?,Die Methodensignatur ist das Gegenstück zum Nachrichtenselektor.
"Die Methodenrümpfe bestehen aus einer Folge von Anweisungen, die jeweils durch einen Punkt getrennt sind. Wenn die Anweisungen nichts anderes vorsehen, wird die Ausführung einer Methode nach Abarbeitung der letzten Anweisung explizit mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung vorgesehen. Eine Return-Anweisung darf an beliebigen Stellen innerhalb der Methode auftreten, wodurch die Abarbeitung der Methode vor Erreichen der textuell letzten Anweisung beendet werden kann. Die Return-Anweisung beeinflusst somit den Kontrollfluss des Programms. Wichtig ist, dass eine Methode immer ein Objekt zurückgibt. Ein Nachrichtenausdruck (oder Methodenaufruf) steht immer für ein Objekt. Prozeduren im Sinne von PASCAL oder Void-Methoden im Sinne von C, Java usw. gibt es in SMALLTALK nicht.",Was sind Methodenrümpfe?,Methodenrümpfe bestehen aus einer Folge von Anweisungen.
"Die Methodenrümpfe bestehen aus einer Folge von Anweisungen, die jeweils durch einen Punkt getrennt sind. Wenn die Anweisungen nichts anderes vorsehen, wird die Ausführung einer Methode nach Abarbeitung der letzten Anweisung explizit mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung vorgesehen. Eine Return-Anweisung darf an beliebigen Stellen innerhalb der Methode auftreten, wodurch die Abarbeitung der Methode vor Erreichen der textuell letzten Anweisung beendet werden kann. Die Return-Anweisung beeinflusst somit den Kontrollfluss des Programms. Wichtig ist, dass eine Methode immer ein Objekt zurückgibt. Ein Nachrichtenausdruck (oder Methodenaufruf) steht immer für ein Objekt. Prozeduren im Sinne von PASCAL oder Void-Methoden im Sinne von C, Java usw. gibt es in SMALLTALK nicht.",Wie wird die Ausführung einer Methode beendet?,Die Ausführung einer Methode wird standardmäßig nach Abarbeitung der letzten Anweisung mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung da.
"Die Methodenrümpfe bestehen aus einer Folge von Anweisungen, die jeweils durch einen Punkt getrennt sind. Wenn die Anweisungen nichts anderes vorsehen, wird die Ausführung einer Methode nach Abarbeitung der letzten Anweisung explizit mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung vorgesehen. Eine Return-Anweisung darf an beliebigen Stellen innerhalb der Methode auftreten, wodurch die Abarbeitung der Methode vor Erreichen der textuell letzten Anweisung beendet werden kann. Die Return-Anweisung beeinflusst somit den Kontrollfluss des Programms. Wichtig ist, dass eine Methode immer ein Objekt zurückgibt. Ein Nachrichtenausdruck (oder Methodenaufruf) steht immer für ein Objekt. Prozeduren im Sinne von PASCAL oder Void-Methoden im Sinne von C, Java usw. gibt es in SMALLTALK nicht.",Was ist die Return-Anweisung?,Die Return-Anweisung ermöglicht eine explizite Beendigung der Methode und die Rückgabe eines anderen Objekts als des Empfängers. Die Return-Anweisung kann an beliebigen Stellen innerhalb der Methode auftreten und beeinflusst den Kontrollfluss des Programms.
"Sollte eine Methode temporäre Variablen für ihre Berechnungen benötigen, müssen diese zu Beginn der Methode (nach der Methodensignatur und vor der ersten Anweisung) deklariert werden. Die Werte dieser Variablen werden standardmäßig mit nil initialisiert und sind außerhalb der Methode nicht sichtbar. Die Variablen werden nach Abarbeitung der Methode vom System wieder entfernt, und sie können sich daher zwischen zwei Ausführungen einer Methode nichts merken. Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben. Umgekehrt können temporäre Variablen, die nur einmal verwendet werden, eingespart werden, indem man kaskadierte Nachrichtenausdrücke verwendet.",Was sind temporäre Variablen?,"Eine Methode kann temporäre Variablen für ihre Berechnungen benötigen. Temporäre Variablen existieren nur für die Dauer der Ausführung der Methode und werden vom System nach Beendigung der Methode entfernt. Die Werte sind außerhalb der Methode nicht sichtbar. Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben."
"Methoden sind die Einheiten des Programms, in denen Sie als Programmiererin Ihre Anweisungen unterbringen. Sie werden nach der Eingabe (und bei jeder Änderung) mit dem ""Speichern"" kompiliert. Beachten Sie dabei, dass Methoden nicht in Dateien gespeichert werden, sondern in einer Datenstruktur von SMALLTALK, und zwar in Form von Objekten. Tatsächlich besteht der Großteil eines jeden SMALLTALK-Programms, ja des gesamten SMALLTALK-Systems, aus Methodendefinitionen. Die Methodendefinitionen entsprechen im Wesentlichen der Definition von Funktionen (oder, mit obiger Einschränkung, Prozeduren) in anderen Sprachen. In SMALLTALK ist es jedoch nicht möglich (und in der objektorientierten Programmierung allgemein nicht üblich), Methoden zu verschachteln, d.h., eine Methode innerhalb einer anderen Methode zu deklarieren. Außerdem gibt es in SMALLTALK keine ""Hauptmethode"" wie beispielsweise die Main-Methoden in der C-Sprachfamilie. Sie müssen dem SMALLTALK-System explizit mitteilen, welche Methode Sie ausführen möchten, indem Sie einen entsprechenden Ausdruck eingeben und auswerten lassen.",Was sind Methoden?,"Methoden sind die Einheiten des Programms, in denen die Anweisungen untergebracht sind."
"Methoden sind die Einheiten des Programms, in denen Sie als Programmiererin Ihre Anweisungen unterbringen. Sie werden nach der Eingabe (und bei jeder Änderung) mit dem ""Speichern"" kompiliert. Beachten Sie dabei, dass Methoden nicht in Dateien gespeichert werden, sondern in einer Datenstruktur von SMALLTALK, und zwar in Form von Objekten. Tatsächlich besteht der Großteil eines jeden SMALLTALK-Programms, ja des gesamten SMALLTALK-Systems, aus Methodendefinitionen. Die Methodendefinitionen entsprechen im Wesentlichen der Definition von Funktionen (oder, mit obiger Einschränkung, Prozeduren) in anderen Sprachen. In SMALLTALK ist es jedoch nicht möglich (und in der objektorientierten Programmierung allgemein nicht üblich), Methoden zu verschachteln, d.h., eine Methode innerhalb einer anderen Methode zu deklarieren. Außerdem gibt es in SMALLTALK keine ""Hauptmethode"" wie beispielsweise die Main-Methoden in der C-Sprachfamilie. Sie müssen dem SMALLTALK-System explizit mitteilen, welche Methode Sie ausführen möchten, indem Sie einen entsprechenden Ausdruck eingeben und auswerten lassen.",Wie werden Methoden kompiliert?,"Methoden werden werden nach der Eingabe und bei jeder Änderung mit dem ""Speichern"" kompiliert."
"Methoden sind die Einheiten des Programms, in denen Sie als Programmiererin Ihre Anweisungen unterbringen. Sie werden nach der Eingabe (und bei jeder Änderung) mit dem ""Speichern"" kompiliert. Beachten Sie dabei, dass Methoden nicht in Dateien gespeichert werden, sondern in einer Datenstruktur von SMALLTALK, und zwar in Form von Objekten. Tatsächlich besteht der Großteil eines jeden SMALLTALK-Programms, ja des gesamten SMALLTALK-Systems, aus Methodendefinitionen. Die Methodendefinitionen entsprechen im Wesentlichen der Definition von Funktionen (oder, mit obiger Einschränkung, Prozeduren) in anderen Sprachen. In SMALLTALK ist es jedoch nicht möglich (und in der objektorientierten Programmierung allgemein nicht üblich), Methoden zu verschachteln, d.h., eine Methode innerhalb einer anderen Methode zu deklarieren. Außerdem gibt es in SMALLTALK keine ""Hauptmethode"" wie beispielsweise die Main-Methoden in der C-Sprachfamilie. Sie müssen dem SMALLTALK-System explizit mitteilen, welche Methode Sie ausführen möchten, indem Sie einen entsprechenden Ausdruck eingeben und auswerten lassen.",Wie werden Methoden in SMALLTALK gespeichert?,"Methoden werden in SMALLTALK nicht in Dateien gespeichert, sondern in einer Datenstruktur von SMALLTALK, nämlich in Form von Objekten. Dies bedeutet, dass der Großteil eines jeden SMALLTALK-Programms aus Methodendefinitionen besteht, die im SMALLTALK-System als Objekte gespeichert sind."
"Ähnlich wie in SMALLTALK erlaubt auch Java das Programmieren von parallelen Ausführungssträngen. Diese werden in Java jedoch als Threads und nicht als Prozesse bezeichnet. Threads sind im Gegensatz zu den Prozessen eines Betriebssystems leichtgewichtig, was bedeutet, dass Threads keine separate Allokation von Ressourcen wie Hauptspeicher erfordern und alle auf denselben Ressourcen arbeiten. Daher können mehrere Threads innerhalb eines Prozesses ausgeführt werden. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst implementiert werden müssen, während sie bei Prozessen über die Inter-Prozess-Kommunikation des Betriebssystems geregelt sind. (Bei den ""Prozessen"" in SMALLTALK handelt es sich also eher um Threads als um Prozesse im oben beschriebenen Sinn.)",Wie werden parallele Ausführungsstränge in Java bezeichnet?,In Java werden parallele Ausführungsstränge als Threads bezeichnet.
"Ähnlich wie in SMALLTALK erlaubt auch Java das Programmieren von parallelen Ausführungssträngen. Diese werden in Java jedoch als Threads und nicht als Prozesse bezeichnet. Threads sind im Gegensatz zu den Prozessen eines Betriebssystems leichtgewichtig, was bedeutet, dass Threads keine separate Allokation von Ressourcen wie Hauptspeicher erfordern und alle auf denselben Ressourcen arbeiten. Daher können mehrere Threads innerhalb eines Prozesses ausgeführt werden. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst implementiert werden müssen, während sie bei Prozessen über die Inter-Prozess-Kommunikation des Betriebssystems geregelt sind. (Bei den ""Prozessen"" in SMALLTALK handelt es sich also eher um Threads als um Prozesse im oben beschriebenen Sinn.)",Was ist der Unterschied zwischen Threads und Prozessen in Java?,"In Java werden parallele Ausführungsstränge als Threads bezeichnet, im Gegensatz zu Prozessen in anderen Programmiersprachen. Threads sind leichtgewichtiger als Prozesse, da sie keine separate Allokation von Ressourcen wie Hauptspeicher erfordern und alle auf denselben Ressourcen arbeiten. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst implementiert werden müssen, während sie bei Prozessen über die Inter-Prozess-Kommunikation des Betriebssystems geregelt sind."
"In Java wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.",Wie wird in Java ein neuer Thread gestartet?,"In Java wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft."
"Die Frage ist nun, was dieser Thread tun soll. Die Klasse Thread enthält eine Methode namens run(), die von start() aufgerufen wird. Diese Methode ist jedoch standardmäßig leer, sodass der Thread sofort beendet wird. Um sicherzustellen, dass ein neuer Thread sinnvolle Aufgaben ausführt, gibt es zwei Möglichkeiten: Man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen oder zumindest anzustoßen. Man lässt eine Klasse das Interface Runnable implementieren, implementiert dann in der Klasse die vom Interface geforderte Methode run(), erzeugt eine Instanz dieser Klasse und startet deren Methode run() mit (new Thread(i)).start(), wobei i die Instanz darstellt.","Wie kann man sicherstellen, dass ein neuer Thread sinnvolle Aufgaben ausführt?","Es gibt zwei Möglichkeiten: Man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen oder zumindest anzustoßen. Man lässt eine Klasse das Interface Runnable implementieren, implementiert dann in der Klasse die vom Interface geforderte Methode run(), erzeugt eine Instanz dieser Klasse und startet deren Methode run() mit (new Thread(i)).start(), wobei i die Instanz darstellt."
"Auch im zweiten Fall wird eine Instanz der Klasse Thread erzeugt, die den neuen Thread repräsentiert. Es ist jedoch wichtig zu beachten, dass diese Instanz nicht selbst der Thread ist. Der Thread ist, wie bereits erwähnt, ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Aktive Objekte, die ihren eigenen Ausführungsstrang haben und behalten (wie im Kapitel 16 beschrieben), müssen in Java genauso wie in SMALLTALK simuliert werden. Jeder Thread hat jedoch ein Thread-Objekt, das ihn repräsentiert und spezifische Daten wie den Namen des Threads und seine Priorität speichert. Dieses Objekt kann mit Thread.currentThread() abgefragt werden.",Was ist das Verhältnis zwischen einem Thread und einem Thread-Objekt in Java?,"Ein Thread ist ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Jeder Thread hat jedoch ein Thread-Objekt, das ihn repräsentiert und spezifische Daten wie den Namen des Threads und seine Priorität speichert. Das Thread-Objekt kann mit Thread.currentThread() abgefragt werden."
"Auch im zweiten Fall wird eine Instanz der Klasse Thread erzeugt, die den neuen Thread repräsentiert. Es ist jedoch wichtig zu beachten, dass diese Instanz nicht selbst der Thread ist. Der Thread ist, wie bereits erwähnt, ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Aktive Objekte, die ihren eigenen Ausführungsstrang haben und behalten (wie im Kapitel 16 beschrieben), müssen in Java genauso wie in SMALLTALK simuliert werden. Jeder Thread hat jedoch ein Thread-Objekt, das ihn repräsentiert und spezifische Daten wie den Namen des Threads und seine Priorität speichert. Dieses Objekt kann mit Thread.currentThread() abgefragt werden.",Was repräsentiert eine Instanz der Klasse Thread in Java?,"Eine Instanz der Klasse Thread in Java repräsentiert nicht den Thread selbst, sondern simuliert einen aktiven Objekt, der seinen eigenen Ausführungsstrang hat und behält. Der Thread ist ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Das Thread-Objekt speichert spezifische Daten wie den Namen des Threads und seine Priorität."
"Die Threads in Java erfordern daher eine explizite Synchronisation. Ähnlich wie bei den Prozessen in SMALLTALK funktioniert dies mit Semaphoren, die in Java als Monitore bezeichnet werden. Jeder Monitor ist mit einem Objekt verknüpft (und jedes Objekt mit einem Monitor). Wenn ein Thread einen Monitor eines Objekts sperrt (""lockt""), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.",Wie wird die Synchronisation von Threads in Java erreicht?,"Die Synchronisation von Threads in Java erfolgt mit Monitoren, die mit Objekten verknüpft sind. Wenn ein Thread einen Monitor eines Objekts sperrt, kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird."
"Die Threads in Java erfordern daher eine explizite Synchronisation. Ähnlich wie bei den Prozessen in SMALLTALK funktioniert dies mit Semaphoren, die in Java als Monitore bezeichnet werden. Jeder Monitor ist mit einem Objekt verknüpft (und jedes Objekt mit einem Monitor). Wenn ein Thread einen Monitor eines Objekts sperrt (""lockt""), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.",Was ist der Zweck von Monitoren in Java?,"Monitoren in Java werden verwendet, um den Zugriff auf ein Objekt durch mehrere Threads zu synchronisieren. Wenn ein Thread einen Monitor sperrt, kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird."
"Es gibt zwei Möglichkeiten, die Synchronisation von Threads zu erzwingen. Die erste Möglichkeit erfolgt durch die Verwendung der synchronized-Anweisung, die Sie bereits kurz kennengelernt haben. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden. Häufig ist dies das Schlüsselwort this, das auf das Objekt im Kontext des Blocks verweist.",Wie kann die Synchronisation von Threads erzwungen werden?,"Die Synchronisation von Threads kann durch die Verwendung der synchronized-Anweisung erzwungen werden. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden."
"Es gibt zwei Möglichkeiten, die Synchronisation von Threads zu erzwingen. Die erste Möglichkeit erfolgt durch die Verwendung der synchronized-Anweisung, die Sie bereits kurz kennengelernt haben. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden. Häufig ist dies das Schlüsselwort this, das auf das Objekt im Kontext des Blocks verweist.",Was ist der Zweck der synchronized-Anweisung in Java?,"Die synchronized-Anweisung in Java wird verwendet, um die Synchronisation von Threads zu erzwingen. Sie stellt sicher, dass die Anweisungen innerhalb des synchronisierten Blocks nur dann ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden."
"Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren. Wenn es sich um eine Instanzmethode handelt, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird. Wenn es sich um eine Klassenmethode (also eine static deklarierte Methode) handelt, wird die Sperre auf das Objekt angewendet, das die Klasse repräsentiert. Beachten Sie jedoch, dass Felder nicht als synchronized deklariert werden können.",Wie kann eine Methode in Java synchronisiert werden?,"Eine Methode kann in Java synchronisiert werden, indem sie mit dem Schlüsselwort ""synchronized"" deklariert wird. Es gibt zwei Möglichkeiten, eine Methode zu synchronisieren: entweder durch die Synchronisierung der gesamten Methode oder durch die Synchronisierung eines bestimmten Blocks innerhalb der Methode. Wenn es sich um eine Instanzmethode handelt, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird. Wenn es sich um eine Klassenmethode handelt, wird die Sperre auf das Objekt angewendet, das die Klasse repräsentiert. Felder können jedoch nicht als synchronized deklariert werden."
"Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren. Wenn es sich um eine Instanzmethode handelt, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird. Wenn es sich um eine Klassenmethode (also eine static deklarierte Methode) handelt, wird die Sperre auf das Objekt angewendet, das die Klasse repräsentiert. Beachten Sie jedoch, dass Felder nicht als synchronized deklariert werden können.","Was passiert, wenn eine Instanzmethode mit synchronized deklariert wird?","Wenn eine Instanzmethode mit synchronized deklariert wird, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird."
"C-Sharp soll genau wie Java und anders als C++ eine typsichere Sprache sein, also eine strikte Typprüfung durchführen. Da aber (ebenfalls genau wie in Java) nicht alles zur Übersetzungszeit geschehen kann, hat auch das Typsystem von C-Sharp eine Laufzeitkomponente.",Was ist die Aufgabe der Laufzeitkomponente des Typsystems in C-Sharp?,"Die Laufzeitkomponente des Typsystems in C-Sharp führt eine strikte Typprüfung durch, um sicherzustellen, dass die Variablen und Ausdrücke nur mit Werten verwendet werden, die zum jeweiligen Typ passen."
"C-Sharp soll genau wie Java und anders als C++ eine typsichere Sprache sein, also eine strikte Typprüfung durchführen. Da aber (ebenfalls genau wie in Java) nicht alles zur Übersetzungszeit geschehen kann, hat auch das Typsystem von C-Sharp eine Laufzeitkomponente.",Ist C-Sharp eine typsichere Sprache?,"Ja, C-Sharp ist eine typsichere Sprache, die eine strikte Typprüfung durchführt. Allerdings hat das Typsystem von C-Sharp auch eine Laufzeitkomponente, da nicht alles zur Übersetzungszeit geschehen kann."
"C-Sharp soll genau wie Java und anders als C++ eine typsichere Sprache sein, also eine strikte Typprüfung durchführen. Da aber (ebenfalls genau wie in Java) nicht alles zur Übersetzungszeit geschehen kann, hat auch das Typsystem von C-Sharp eine Laufzeitkomponente.",Was ist der Unterschied zwischen C-Sharp und C++ in Bezug auf Typsicherheit?,"Im Gegensatz zu C++ ist C-Sharp eine typsichere Sprache, die eine strikte Typprüfung durchführt. Diese Typprüfung erfolgt sowohl zur Übersetzungszeit als auch zur Laufzeit. In C++ hingegen wird keine Laufzeitprüfung durchgeführt, was zu potenziellen Sicherheitsrisiken führen kann."
"Um einen Ausdruck einer Typumwandlung zu unterziehen, bietet C-Sharp genau wie Java und C++ Casts an. Auch die Syntax unterscheidet sich nicht.",Wie kann man in C-Sharp einen Ausdruck einer Typumwandlung unterziehen?,"In C-Sharp kann man einen Ausdruck einer Typumwandlung unterziehen, indem man Casts verwendet, genau wie in Java und C++. Die Syntax unterscheidet sich nicht."
"Dies bewirkt, dass der Ausdruck a den Typ T aufgedrückt bekommt. Ist dies nicht möglich, weil der tatsächliche Typ des Objekts, auf das a verweist, kein Subtyp von T ist oder weil keine entsprechende Typumwandlung definiert ist (einschließlich Boxing/Unboxing), wird dies mit einem Laufzeitfehler quittiert. Casts sind also typsicher (in dem Sinne, dass keiner Variable ein Wert zugewiesen wird, den sie nicht haben darf), aber nicht sicher (sie können zu Ausnahmesituationen und, im Falle einer Nichtbehandlung, zu Programmabbrüchen führen).",Was ist ein Cast in der Programmierung?,"Ein Cast ist eine Anweisung, die einem Objekt einen bestimmten Typ aufdrückt. Ist dies nicht möglich, wird dies mit einem Laufzeitfehler quittiert. Casts sind typsicher, aber nicht sicher, da sie zu Ausnahmesituationen führen können."
"Dies bewirkt, dass der Ausdruck a den Typ T aufgedrückt bekommt. Ist dies nicht möglich, weil der tatsächliche Typ des Objekts, auf das a verweist, kein Subtyp von T ist oder weil keine entsprechende Typumwandlung definiert ist (einschließlich Boxing/Unboxing), wird dies mit einem Laufzeitfehler quittiert. Casts sind also typsicher (in dem Sinne, dass keiner Variable ein Wert zugewiesen wird, den sie nicht haben darf), aber nicht sicher (sie können zu Ausnahmesituationen und, im Falle einer Nichtbehandlung, zu Programmabbrüchen führen).",Was ist der Zweck eines Casts in der Programmierung?,"Der Zweck eines Casts in der Programmierung ist, einem Objekt einen bestimmten Typ aufzudrücken. Ist dies nicht möglich, wird dies mit einem Laufzeitfehler quittiert. Casts sind typsicher, aber nicht sicher, da sie zu Ausnahmesituationen und Programmabbrüchen führen können."
"Dies bewirkt, dass der Ausdruck a den Typ T aufgedrückt bekommt. Ist dies nicht möglich, weil der tatsächliche Typ des Objekts, auf das a verweist, kein Subtyp von T ist oder weil keine entsprechende Typumwandlung definiert ist (einschließlich Boxing/Unboxing), wird dies mit einem Laufzeitfehler quittiert. Casts sind also typsicher (in dem Sinne, dass keiner Variable ein Wert zugewiesen wird, den sie nicht haben darf), aber nicht sicher (sie können zu Ausnahmesituationen und, im Falle einer Nichtbehandlung, zu Programmabbrüchen führen).","Was passiert, wenn ein Cast nicht möglich ist?","Wenn ein Cast nicht möglich ist, weil der tatsächliche Typ des Objekts, auf das a verweist, kein Subtyp von T ist oder weil keine entsprechende Typumwandlung definiert ist (einschließlich Boxing/Unboxing), wird dies mit einem Laufzeitfehler quittiert."
"Um Casts sicher zu machen, bietet C-Sharp den Operator is. Er entspricht im Wesentlichen dem instanceof von Java, wobei a für einen beliebigen Ausdruck und T für einen Typ steht, zurück, ob das Ergebnis der Auswertung von a mit einer Variable vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.",Was macht der Operator is in C-Sharp?,"Der Operator is in C-Sharp prüft, ob das Ergebnis der Auswertung eines beliebigen Ausdrucks a mit einer Variablen vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt."
"Um Casts sicher zu machen, bietet C-Sharp den Operator is. Er entspricht im Wesentlichen dem instanceof von Java, wobei a für einen beliebigen Ausdruck und T für einen Typ steht, zurück, ob das Ergebnis der Auswertung von a mit einer Variable vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.",Was gibt der Operator is in C-Sharp zurück?,"Der Operator is in C-Sharp gibt zurück, ob das Ergebnis der Auswertung eines beliebigen Ausdrucks a mit einer Variablen vom Typ T zuweisungskompatibel ist, wobei er sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt."
"Um Casts sicher zu machen, bietet C-Sharp den Operator is. Er entspricht im Wesentlichen dem instanceof von Java, wobei a für einen beliebigen Ausdruck und T für einen Typ steht, zurück, ob das Ergebnis der Auswertung von a mit einer Variable vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.",Was ist der Zweck von Casts in C++?,"Der Zweck von Casts in C++ ist es, die statische Typisierung zu umgehen und den Compiler zu zwingen, den Ausdruck auf der linken Seite des Casts als Typ zu interpretieren, der auf der rechten Seite angegeben ist."
"Um Casts sicher zu machen, bietet C-Sharp den Operator is. Er entspricht im Wesentlichen dem instanceof von Java, wobei a für einen beliebigen Ausdruck und T für einen Typ steht, zurück, ob das Ergebnis der Auswertung von a mit einer Variable vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.",Was passiert bei der Verwendung von Casts in C++?,"Bei der Verwendung von Casts in C++ wird der Compiler gezwungen, den Ausdruck auf der linken Seite des Casts als Typ zu interpretieren, der auf der rechten Seite angegeben ist, wodurch die statische Typisierung umgangen wird."
"Um Casts sicher zu machen, bietet C-Sharp den Operator is. Er entspricht im Wesentlichen dem instanceof von Java, wobei a für einen beliebigen Ausdruck und T für einen Typ steht, zurück, ob das Ergebnis der Auswertung von a mit einer Variable vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.",Wie kann man in C++ die statische Typisierung umgehen?,In C++ kann man die statische Typisierung mit
"Definierte Typen können in Programmen verwendet werden, in STRONGTALK bei der Deklaration von (anderen) Typen, von Variablen, von Blöcken und von Methoden. Man spricht dann von einer Typisierung der deklarierten Programmelemente. Die Verwendung in Typdefinitionen haben Sie bereits oben kennengelernt, die Verwendung in Methoden verläuft analog. Variablen (Instanzvariablen, temporäre Variablen, etc.) werden in STRONGTALK genauso wie formale Parameter (die ebenfalls Variablen sind) typisiert, nämlich durch die Anfügung eines Typnamens in spitzen Klammern. Bei Blöcken taucht der Rückgabetyp im selben Segment wie die formalen Parameter auf, also vor dem Seperator.",Wozu werden Typen in STRONGTALK verwendet?,"In STRONGTALK werden Typen verwendet, um (andere) Typen, Variablen, Blöcke und Methoden zu definieren. Dies wird als Typisierung der deklarierten Programmelemente bezeichnet."
"Definierte Typen können in Programmen verwendet werden, in STRONGTALK bei der Deklaration von (anderen) Typen, von Variablen, von Blöcken und von Methoden. Man spricht dann von einer Typisierung der deklarierten Programmelemente. Die Verwendung in Typdefinitionen haben Sie bereits oben kennengelernt, die Verwendung in Methoden verläuft analog. Variablen (Instanzvariablen, temporäre Variablen, etc.) werden in STRONGTALK genauso wie formale Parameter (die ebenfalls Variablen sind) typisiert, nämlich durch die Anfügung eines Typnamens in spitzen Klammern. Bei Blöcken taucht der Rückgabetyp im selben Segment wie die formalen Parameter auf, also vor dem Seperator.",Wozu dient die Typisierung in Programmiersprachen?,"Die Typisierung in Programmiersprachen dient dazu, die Verwendung von Variablen, Blöcken und Methoden zu regeln und zu beschränken. Durch die Angabe eines Typs wird festgelegt, welche Werte eine Variable speichern kann, welche Werte ein Block zurückgeben kann und welche Werte eine Methode erwartet oder zurückgibt. Dies hilft, Fehler zu vermeiden und die Lesbarkeit und Wartbarkeit des Codes zu verbessern."
"Dictionaries repräsentieren sogenannte qualifizierte Beziehungen, bei denen jedes Element der Beziehung durch einen Qualifizierer eindeutig bestimmt wird. Der Qualifizierer heißt auch Schlüssel (engl. key; vergleichbar mit dem Primärschlüssel relationaler Datenbanken), das qualifizierte Element der Beziehung nennt man auch Wert (engl. value). Ein Element einer qualifizierten Beziehung besteht also gewissermaßen aus einer Assoziation eines Schlüssels mit einem Wert. Der Clou an der Implementierung von Dictionaries ist, dass man Werte unter ihren Schlüsseln extrem schnell (im Idealfall ohne jede Suche) auffinden kann. Das wird heute fast immer über sogenanntes Hashing erreicht.",Was sind Dictionaries und wie werden Werte darin aufgefunden?,"Dictionaries sind eine Art qualifizierter Beziehung, bei der jedes Element durch einen Qualifizierer, auch Schlüssel genannt, eindeutig bestimmt wird. Der Wert ist das qualifizierte Element der Beziehung. In der Implementierung von Dictionaries werden Werte unter ihren Schlüsseln extrem schnell gefunden, was heute meist über Hashing erreicht wird."
"Dictionaries repräsentieren sogenannte qualifizierte Beziehungen, bei denen jedes Element der Beziehung durch einen Qualifizierer eindeutig bestimmt wird. Der Qualifizierer heißt auch Schlüssel (engl. key; vergleichbar mit dem Primärschlüssel relationaler Datenbanken), das qualifizierte Element der Beziehung nennt man auch Wert (engl. value). Ein Element einer qualifizierten Beziehung besteht also gewissermaßen aus einer Assoziation eines Schlüssels mit einem Wert. Der Clou an der Implementierung von Dictionaries ist, dass man Werte unter ihren Schlüsseln extrem schnell (im Idealfall ohne jede Suche) auffinden kann. Das wird heute fast immer über sogenanntes Hashing erreicht.",Was ist der Unterschied zwischen Schlüssel und Wert in einem Dictionary?,"Der Schlüssel (key) ist ein eindeutiger Bezeichner für ein Element in einem Dictionary, während der Wert (value) das Element selbst ist, das unter diesem Schlüssel gespeichert ist."
"Die Klasse Dictionary hat für die Programmierung besondere Bedeutung: Sie realisiert sogenannte Assoziativspeicher, also Speicher, bei dem auf eine Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet. So werden beispielsweise Methoden in Dictionaries hinterlegt (wobei der Nachrichtenselektor die Rolle des Schlüssels spielt und als Wertobjekt die kompilierte Methode gespeichert ist). Aber auch andere Arten von Collections lassen sich mit Hilfe von Dictionaries sehr einfach realisieren.",Was ist die Klasse Dictionary in SMALLTALK?,"Die Klasse Dictionary in SMALLTALK realisiert sogenannte Assoziativspeicher, bei denen auf eine Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet, zum Beispiel für das Hinterlegen von Methoden in Dictionaries."
"Dabei wird einfach die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag, solange diese nicht Null ist, in einem Dictionary unter dem Element als Schlüssel gespeichert.",Was wird in einem Dictionary unter dem Element als Schlüssel gespeichert?,In dem Dictionary wird die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag gespeichert.
"Dabei wird einfach die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag, solange diese nicht Null ist, in einem Dictionary unter dem Element als Schlüssel gespeichert.",Was wird in einem Dictionary während der Ausführung einer Methode gespeichert?,"In einem Dictionary wird während der Ausführung einer Methode die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag, solange diese nicht Null ist, in einem Dictionary unter dem Element als Schlüssel gespeichert."
"Dabei wird einfach die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag, solange diese nicht Null ist, in einem Dictionary unter dem Element als Schlüssel gespeichert.",Wie wird die Anzahl der Vorkommen eines Elements in einem Bag in Smalltalk gezählt?,"In Smalltalk wird die Anzahl der Vorkommen eines Elements in einem Bag gezählt, indem ein Dictionary verwendet wird, in dem das Element als Schlüssel und die Anzahl seiner Vorkommen als Wert gespeichert wird. Die Anzahl der Vorkommen wird solange inkrementiert, bis das Element nicht mehr in der Bag vorhanden ist."
"Man beachte hierbei, dass Bag die Klasse Dictionary nutzt, ohne von ihr zu erben. Stattdessen hält sich jede Instanz von Bag eine Instanz von Dictionary als Sklavin, die für sie den Dienst verrichtet. Man spricht hier auch von einer Delegation; da die Delegation in den prototypenbasierten objektorientierten Programmiersprachen tatsächlich die Funktion der Vererbung übernimmt und zudem dynamisch (also nachdem eine Instanz erzeugt wurde) eingerichtet werden kann und da sie zudem von Fragen der Generalisierung/Spezialisierung völlig befreit ist, erfreut sie sich in der objektorientierten Programmierung großer Beliebtheit.",Was ist Delegation in der objektorientierten Programmierung?,"Delegation ist eine Technik in der objektorientierten Programmierung, bei der eine Instanz eine andere Instanz als Sklavin hält, die für sie den Dienst verrichtet. Sie wird oft genutzt, um die Funktion der Vererbung zu übernehmen, da sie dynamisch eingerichtet werden kann und nicht an Fragen der Generalisierung/Spezialisierung gebunden ist."
"ng, bei der eine Instanz eine andere Instanz als Sklavin hält, die für sie einen Dienst verrichtet. Im Gegensatz zur Vererbung kann die Delegation dynamisch eingerichtet werden und ist nicht an Fragen der Generalisierung/Spezialisierung gebunden.",Was ist Delegation und wie wird sie in prototypenbasierten objektorientierten Programmiersprachen genutzt?,"Delegation ist eine Beziehung zwischen zwei Objekten, bei der ein Objekt (Delegierter) die Verantwortung für die Bearbeitung bestimmter Anfragen an ein anderes Objekt (Delegator) überträgt. In prototypenbasierten objektorientierten Programmiersprachen wird Delegation genutzt, um die Funktion der Vererbung zu übernehmen. Sie kann dynamisch eingerichtet werden und ist von Fragen der Generalisierung/Spezialisierung befreit, was sie zu einer beliebten Alternative zur Vererbung macht."
"Je länger Sie in SMALLTALK programmieren, desto häufiger werden Sie feststellen, dass Sie durch Verwendung eines Dictionaries Ihren Code deutlich vereinfachen können. Tatsächlich erlauben es Dictionaries (bzw. der von ihnen realisierte Assoziativspeicher), Assoziationsketten, die Grundlage vieler menschlicher Denkprozesse sind, direkt in einem Programm nachzubilden. Fragen Sie sich also, wann immer Sie es mit einer Menge von Objekten zu tun haben, wie Sie auf die Elemente der Menge zugreifen wollen; wenn dies über einen Schlüssel erfolgt, dann ist Dictionary die Klasse Ihrer Wahl.",Wofür können Dictionaries in SMALLTALK verwendet werden?,"Dictionaries können in SMALLTALK verwendet werden, um Assoziationsketten direkt in einem Programm nachzubilden. Sie erlauben es, auf die Elemente einer Menge über einen Schlüssel zuzugreifen."
"Je länger Sie in SMALLTALK programmieren, desto häufiger werden Sie feststellen, dass Sie durch Verwendung eines Dictionaries Ihren Code deutlich vereinfachen können. Tatsächlich erlauben es Dictionaries (bzw. der von ihnen realisierte Assoziativspeicher), Assoziationsketten, die Grundlage vieler menschlicher Denkprozesse sind, direkt in einem Programm nachzubilden. Fragen Sie sich also, wann immer Sie es mit einer Menge von Objekten zu tun haben, wie Sie auf die Elemente der Menge zugreifen wollen; wenn dies über einen Schlüssel erfolgt, dann ist Dictionary die Klasse Ihrer Wahl.",Was ist der Zweck von Dictionaries in SMALLTALK?,"Dictionaries in SMALLTALK werden verwendet, um Assoziationsketten zu simulieren und den Zugriff auf Elemente einer Menge über einen Schlüssel zu ermöglichen. Sie erleichtern das Programmieren, indem sie die Verwendung von Assoziativspeicher ermöglichen, der die Grundlage vieler menschlicher Denkprozesse ist."
"Es darf übrigens der Schlüssel eines in einem Dictionary gespeicherten Objekts ruhig ein Attribut (der Inhalt einer Instanzvariable) des Objekts sein; dies kommt sogar recht häufig vor. Beispielsweise wird man Personen in einem Dictionary unter ihrem Nachnamen oder einer Ausweisnummer speichern. Allerdings sollte dieses Attribut dann unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden wird.","Sollte das Attribut, das als Schlüssel verwendet wird, unveränderlich sein?","Ja, das Attribut, das als Schlüssel verwendet wird, sollte unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden wird."
"Es darf übrigens der Schlüssel eines in einem Dictionary gespeicherten Objekts ruhig ein Attribut (der Inhalt einer Instanzvariable) des Objekts sein; dies kommt sogar recht häufig vor. Beispielsweise wird man Personen in einem Dictionary unter ihrem Nachnamen oder einer Ausweisnummer speichern. Allerdings sollte dieses Attribut dann unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden wird.","Warum sollte das Attribut, das als Schlüssel in einem Dictionary verwendet wird, unveränderlich sein?","Das Attribut, das als Schlüssel in einem Dictionary verwendet wird, sollte unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden wird. Wenn das Attribut veränderlich ist, kann es zu Problemen bei der Suche nach dem Objekt im Dictionary führen, da der alte Attributwert nicht mehr gültig ist."
"In der klassenbasierten Form der objektorientierten Programmierung ist die Vererbung an Klassen gebunden: Selbst wenn sich die Definitionen eigentlich auf die Instanzen der Klassen beziehen, so ist es doch die Klasse, die Teile ihrer Definition (Intension) von anderen erbt. Im Gegensatz dazu ist die Vererbung in prototypenbasierten objektorientierten Programmiersprachen, in denen es ja keine Klassen gibt, vollständig zwischen Objekten definiert: Jedes Objekt gibt eines oder mehrere andere an, deren Eigenschaften und Verhalten es übernimmt. Dabei kann es geerbte Teile der Definition überschreiben und auch löschen.",Wie ist die Vererbung in der klassenbasierten und prototypenbasierten objektorientierten Programmierung definiert?,"In der klassenbasierten Form der objektorientierten Programmierung ist die Vererbung an Klassen gebunden, während in prototypenbasierten objektorientierten Programmiersprachen die Vererbung vollständig zwischen Objekten definiert ist."
"In der klassenbasierten Form der objektorientierten Programmierung ist die Vererbung an Klassen gebunden: Selbst wenn sich die Definitionen eigentlich auf die Instanzen der Klassen beziehen, so ist es doch die Klasse, die Teile ihrer Definition (Intension) von anderen erbt. Im Gegensatz dazu ist die Vererbung in prototypenbasierten objektorientierten Programmiersprachen, in denen es ja keine Klassen gibt, vollständig zwischen Objekten definiert: Jedes Objekt gibt eines oder mehrere andere an, deren Eigenschaften und Verhalten es übernimmt. Dabei kann es geerbte Teile der Definition überschreiben und auch löschen.",Wie ist die Vererbung in der klassenbasierten Form der objektorientierten Programmierung gebunden?,"In der klassenbasierten Form der objektorientierten Programmierung ist die Vererbung an Klassen gebunden, d.h. Selbst wenn sich die Definitionen eigentlich auf die Instanzen der Klassen beziehen, so ist es doch die Klasse, die Teile ihrer Definition (Intension) von anderen erbt."
"In der klassenbasierten Form der objektorientierten Programmierung ist die Vererbung an Klassen gebunden: Selbst wenn sich die Definitionen eigentlich auf die Instanzen der Klassen beziehen, so ist es doch die Klasse, die Teile ihrer Definition (Intension) von anderen erbt. Im Gegensatz dazu ist die Vererbung in prototypenbasierten objektorientierten Programmiersprachen, in denen es ja keine Klassen gibt, vollständig zwischen Objekten definiert: Jedes Objekt gibt eines oder mehrere andere an, deren Eigenschaften und Verhalten es übernimmt. Dabei kann es geerbte Teile der Definition überschreiben und auch löschen.",Was ist der Unterschied zwischen klassenbasierter und prototypenbasierter objektorientierter Programmierung in Bezug auf Vererbung?,"In der klassenbasierten Form der objektorientierten Programmierung ist die Vererbung an Klassen gebunden, während in prototypenbasierten objektorientierten Programmiersprachen, in denen es ja keine Klassen gibt, die Vererbung vollständig zwischen Objekten definiert ist."
"Auf den ersten Blick scheint es so, als sei dies sogar der natürlichere Weg der Vererbung: Schließlich findet in der Natur Vererbung ja auch ausschließlich zwischen Individuen statt, ja genaugenommen gibt es so etwas wie biologische Klassen (Arten etc.) in der Natur überhaupt nicht. Denn es differenzieren sich ständig einzelne „Arten“ zu neuen, und es ist nicht ausgeschlossen, dass einmal ausdifferenzierte Arten irgendwann wieder verschmelzen. Abgesehen davon ist, wie bereits in Kapitel 7 erwähnt, die reale Existenz von Allgemeinbegriffen strittig (der Universalienstreit).",Wie verhält sich die Vererbung in der Natur?,"In der Natur findet Vererbung ausschließlich zwischen Individuen statt. Es gibt keine biologischen Klassen wie Arten, sondern Individuen differenzieren sich ständig zu neuen Arten und können wieder verschmelzen."
"Auf den ersten Blick scheint es so, als sei dies sogar der natürlichere Weg der Vererbung: Schließlich findet in der Natur Vererbung ja auch ausschließlich zwischen Individuen statt, ja genaugenommen gibt es so etwas wie biologische Klassen (Arten etc.) in der Natur überhaupt nicht. Denn es differenzieren sich ständig einzelne „Arten“ zu neuen, und es ist nicht ausgeschlossen, dass einmal ausdifferenzierte Arten irgendwann wieder verschmelzen. Abgesehen davon ist, wie bereits in Kapitel 7 erwähnt, die reale Existenz von Allgemeinbegriffen strittig (der Universalienstreit).",Was ist der natürlichere Weg der Vererbung?,"Auf den ersten Blick scheint es so, als sei der natürlichere Weg der Vererbung, dass sie ausschließlich zwischen Individuen stattfindet, wie es auch in der Natur der Fall ist."
"Man kann dem freilich entgegenhalten, dass man als Programmierer keine einzelnen Objekte, sondern Klassen entwirft, die damit die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Auch sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung, eben der Evolution, und somit sind auch Klassendefinitionen im ständigen Wandel. Eine Übertragung der Vererbung auf Klassen ist also nicht vollkommen unnatürlich.",Kann man in der objektorientierten Programmierung Klassen entwerfen?,"Ja, in der objektorientierten Programmierung kann man Klassen entwerfen, die die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Objekte werden durch Instanzen dieser Klassen erzeugt."
"Man kann dem freilich entgegenhalten, dass man als Programmierer keine einzelnen Objekte, sondern Klassen entwirft, die damit die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Auch sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung, eben der Evolution, und somit sind auch Klassendefinitionen im ständigen Wandel. Eine Übertragung der Vererbung auf Klassen ist also nicht vollkommen unnatürlich.",Sind Klassendefinitionen in der objektorientierten Programmierung ständig im Wandel?,"Ja, Klassendefinitionen unterliegen in der objektorientierten Programmierung der ständigen Anpassung und somit der Evolution."
"Man kann dem freilich entgegenhalten, dass man als Programmierer keine einzelnen Objekte, sondern Klassen entwirft, die damit die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Auch sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung, eben der Evolution, und somit sind auch Klassendefinitionen im ständigen Wandel. Eine Übertragung der Vererbung auf Klassen ist also nicht vollkommen unnatürlich.",Ist eine Übertragung der Vererbung auf Klassen in der objektorientierten Programmierung unnatürlich?,"Nein, eine Übertragung der Vererbung auf Klassen ist in der objektorientierten Programmierung nicht unnatürlich."
"Man kann dem freilich entgegenhalten, dass man als Programmierer keine einzelnen Objekte, sondern Klassen entwirft, die damit die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Auch sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung, eben der Evolution, und somit sind auch Klassendefinitionen im ständigen Wandel. Eine Übertragung der Vererbung auf Klassen ist also nicht vollkommen unnatürlich.",Kann man Klassen als Schöpfung der objektorientierten Programmierung betrachten?,"Objektorientierte Programmierung ist eine Weltsicht, die auf der Schöpfung von Objekten basiert, aber man kann dem freilich entgegenhalten, dass man als Programmierer keine einzelnen Objekte, sondern Klassen entwirft, die damit die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben."
"Man kann dem freilich entgegenhalten, dass man als Programmierer keine einzelnen Objekte, sondern Klassen entwirft, die damit die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Auch sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung, eben der Evolution, und somit sind auch Klassendefinitionen im ständigen Wandel. Eine Übertragung der Vererbung auf Klassen ist also nicht vollkommen unnatürlich.",Warum ist die Übertragung der Vererbung auf Klassen nicht vollkommen unnatürlich?,"Die Übertragung der Vererbung auf Klassen ist nicht vollkommen unnatürlich, weil Programmierer in objektorientierten Programmen Klassen entwerfen, die die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Zudem sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung und somit sind auch Klassendefinitionen im ständigen Wandel."
"Nicht zuletzt muss man auch erkennen, dass viele Anwendungsdomänen, für die programmiert wird, aus massenhaft gleichen Objekten bestehen, die durch den klassenbasierten Ansatz besser abgedeckt werden als durch den prototypenbasierten. Und so macht denn auch die Vererbung unter Instanzen das Nachvollziehen (und Debuggen) eines Programms eher noch schwieriger als die Vererbung unter Klassen ohnehin schon (s. Kapitel 56 in Kurseinheit 6).",Was ist der Unterschied zwischen klassenbasiertem und prototypenbasiertem Ansatz in der Programmierung?,"Im klassenbasierten Ansatz werden Objekte durch Klassen definiert, die eine Art ""Blaupause"" für die Objekte sind. Im Gegensatz dazu werden Objekte im prototypenbasierten Ansatz durch andere Objekte erzeugt, die als Prototypen dienen."
"Nicht zuletzt muss man auch erkennen, dass viele Anwendungsdomänen, für die programmiert wird, aus massenhaft gleichen Objekten bestehen, die durch den klassenbasierten Ansatz besser abgedeckt werden als durch den prototypenbasierten. Und so macht denn auch die Vererbung unter Instanzen das Nachvollziehen (und Debuggen) eines Programms eher noch schwieriger als die Vererbung unter Klassen ohnehin schon (s. Kapitel 56 in Kurseinheit 6).",Warum ist die Vererbung unter Instanzen das Nachvollziehen (und Debuggen) eines Programms schwieriger als die Vererbung unter Klassen?,"Die Vererbung unter Instanzen kann das Nachvollziehen und Debuggen eines Programms schwieriger machen, da die Vererbungshierarchie nicht so einfach zu verfolgen ist wie bei der Vererbung unter Klassen. Die Vererbung unter Klassen ist üblicherweise hierarchisch und bietet eine klare Struktur, während die Vererbung unter Instanzen eher netzartig sein kann und daher schwieriger nachzuvollziehen ist."
"Nicht zuletzt muss man auch erkennen, dass viele Anwendungsdomänen, für die programmiert wird, aus massenhaft gleichen Objekten bestehen, die durch den klassenbasierten Ansatz besser abgedeckt werden als durch den prototypenbasierten. Und so macht denn auch die Vererbung unter Instanzen das Nachvollziehen (und Debuggen) eines Programms eher noch schwieriger als die Vererbung unter Klassen ohnehin schon (s. Kapitel 56 in Kurseinheit 6).",Was ist der Unterschied zwischen dem klassenbasierten und dem prototypenbasierten Ansatz in der objektorientierten Programmierung?,"Im klassenbasierten Ansatz werden sämtliche Informationen als ein Geflecht von Objekten dargestellt, die auf Klassen basieren. In einem prototypenbasierten Ansatz hingegen werden Objekte als Prototypen verwendet, die als Vorlage für andere Objekte dienen. Der klassenbasierte Ansatz ist besser geeignet, wenn es viele gleiche Objekte gibt, während der prototypenbasierte Ansatz eher für die Erstellung von einzigartigen Objekten geeignet ist."
"Nicht zuletzt muss man auch erkennen, dass viele Anwendungsdomänen, für die programmiert wird, aus massenhaft gleichen Objekten bestehen, die durch den klassenbasierten Ansatz besser abgedeckt werden als durch den prototypenbasierten. Und so macht denn auch die Vererbung unter Instanzen das Nachvollziehen (und Debuggen) eines Programms eher noch schwieriger als die Vererbung unter Klassen ohnehin schon (s. Kapitel 56 in Kurseinheit 6).",Was sind die Vorteile des klassenbasierten Ansatzes gegenüber dem prototypenbasierten Ansatz?,"Der klassenbasierte Ansatz ist besser geeignet, um massenhaft gleiche Objekte abzudecken, was in vielen Anwendungsdomänen der Fall ist. Im Vergleich zur Vererbung unter Instanzen, die der prototypenbasierte Ansatz bietet, ist die Vererbung unter Klassen im klassenbasierten Ansatz einfacher nachzuvollziehen und zu debuggen."
"Durch die Zuordnung von Individuen oder Objekten zu Allgemeinbegriffen oder Klassen findet eine Klassifikation statt. Diese Klassifikation erlaubt eine Ordnung oder Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen nur noch für die Klassen getroffen werden müssen und nicht mehr für jedes einzelne Objekt. Anstatt also, wie in der vorangegangenen Kurseinheit, Instanzvariablen und Methoden direkt Objekten zuzuordnen, verbindet man sie mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse gehören, beschreiben.",Was ist die Klassifikation?,"Eine Klassifikation ist eine Zuordnung von Individuen oder Objekten zu bestimmten Allgemeinbegriffen oder Klassen. Diese Klassifikation ermöglicht eine Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen und Eigenschaften nur noch für die Klassen im Allgemeinen getroffen werden müssen, anstatt für jedes einzelne Objekt. Statt also Eigenschaften und Methoden direkt Objekten zuzuweisen, verbindet man sie mit Klassen und legt fest, dass sie die einzelnen Objekte, die zu dieser Klasse gehören, beschreiben."
"In diesem Zusammenhang ist es sinnvoll, die Unterscheidung von Extension und Intension eines Begriffs ins Spiel zu bringen. Unter der Extension (Ausdehnung oder Erstreckung) eines (Allgemein-)Begriffs versteht man die Menge der Objekte, die darunterfallen. Im Fall von ""Person"" etwa ist das die Menge aller Personen, im Fall von ""Dokument"" die Menge aller Dokumente. Die Intension (nicht zu verwechseln mit Intention!) eines (Allgemein-)Begriffs hingegen ist die Summe der Merkmale, die den Begriff ausmachen und die die Objekte, die darunter fallen, charakterisieren. Sie ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die zu einem beliebigen Element entscheidet, ob es unter den Begriff fällt. Schon Aristoteles fiel auf, dass Intension und Extension in einem inversen Größenverhältnis zueinander stehen: Mit wachsender Intension schrumpft die Extension und umgekehrt. Dies ist freilich nicht weiter verwunderlich: Je umfangreicher die Charakterisierung einer Menge von Objekten ist, d.h., je strenger die Bedingungen sind, die ein Objekt erfüllen muss, um dazuzugehören, desto weniger Objekte erfüllen diese Bedingungen, und desto kleiner ist entsprechend die Menge. Wir werden in Kapitel 9 noch einmal darauf zurückkommen.",Was ist die Extension?,"Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören."
"In diesem Zusammenhang ist es sinnvoll, die Unterscheidung von Extension und Intension eines Begriffs ins Spiel zu bringen. Unter der Extension (Ausdehnung oder Erstreckung) eines (Allgemein-)Begriffs versteht man die Menge der Objekte, die darunterfallen. Im Fall von ""Person"" etwa ist das die Menge aller Personen, im Fall von ""Dokument"" die Menge aller Dokumente. Die Intension (nicht zu verwechseln mit Intention!) eines (Allgemein-)Begriffs hingegen ist die Summe der Merkmale, die den Begriff ausmachen und die die Objekte, die darunter fallen, charakterisieren. Sie ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die zu einem beliebigen Element entscheidet, ob es unter den Begriff fällt. Schon Aristoteles fiel auf, dass Intension und Extension in einem inversen Größenverhältnis zueinander stehen: Mit wachsender Intension schrumpft die Extension und umgekehrt. Dies ist freilich nicht weiter verwunderlich: Je umfangreicher die Charakterisierung einer Menge von Objekten ist, d.h., je strenger die Bedingungen sind, die ein Objekt erfüllen muss, um dazuzugehören, desto weniger Objekte erfüllen diese Bedingungen, und desto kleiner ist entsprechend die Menge. Wir werden in Kapitel 9 noch einmal darauf zurückkommen.",Was ist die Intension?,"Die Intension ist die Summe der Merkmale oder Eigenschaften, die den Begriff ausmachen und die Objekte charakterisieren, die zu dieser Klasse gehören. Die Intension ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die entscheidet, ob ein beliebiges Element unter den Begriff fällt."
"In diesem Zusammenhang ist es sinnvoll, die Unterscheidung von Extension und Intension eines Begriffs ins Spiel zu bringen. Unter der Extension (Ausdehnung oder Erstreckung) eines (Allgemein-)Begriffs versteht man die Menge der Objekte, die darunterfallen. Im Fall von ""Person"" etwa ist das die Menge aller Personen, im Fall von ""Dokument"" die Menge aller Dokumente. Die Intension (nicht zu verwechseln mit Intention!) eines (Allgemein-)Begriffs hingegen ist die Summe der Merkmale, die den Begriff ausmachen und die die Objekte, die darunter fallen, charakterisieren. Sie ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die zu einem beliebigen Element entscheidet, ob es unter den Begriff fällt. Schon Aristoteles fiel auf, dass Intension und Extension in einem inversen Größenverhältnis zueinander stehen: Mit wachsender Intension schrumpft die Extension und umgekehrt. Dies ist freilich nicht weiter verwunderlich: Je umfangreicher die Charakterisierung einer Menge von Objekten ist, d.h., je strenger die Bedingungen sind, die ein Objekt erfüllen muss, um dazuzugehören, desto weniger Objekte erfüllen diese Bedingungen, und desto kleiner ist entsprechend die Menge. Wir werden in Kapitel 9 noch einmal darauf zurückkommen.",Was unterscheidet Extension und Intension?,"Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören. Die Intension ist die Summe der Merkmale oder Eigenschaften, die den Begriff ausmachen und die Objekte charakterisieren, die zu dieser Klasse gehören. Mit steigender Intension wird die Extension kleiner, und umgekehrt."
"Allgemeinbegriffe sind die Vorbilder für Klassen in der objektorientierten Programmierung. Interessanterweise bildet eine wichtige philosophische Abweichung vom Glauben an die Adäquatheit von Allgemeinbegriffen, die Idee der Familienähnlichkeiten, wie sie von Ludwig Wittgenstein in seiner späten Philosophie entworfen wurde, die Grundlage für die schon erwähnte Alternative zu den Klassen, nämlich die Prototypen. Die Idee Wittgensteins, wie auch der prototypenbasierten Programmierung, ist, dass ein Allgemeinbegriff (eine Klasse) niemals eine adäquate Beschreibung aller Individuen (Objekte) sein kann, die man mit dem Begriff verbindet. Wittgenstein verwendet dafür das Beispiel vom ""Spiel"": Auch wenn es Spiele gibt, die einander stark ähneln, so ist der Begriff vom ""Spiel"" doch nicht so scharf gefasst, dass es eine Grenze gäbe, innerhalb derer etwas ein Spiel wie alle anderen, außerhalb derer es aber kein Spiel mehr ist. Vielmehr gibt es, nach Wittgenstein, mehr oder weniger ""spielhafte"" Spiele, also prototypische Spiele und solche, die diesen mehr oder weniger gleichen.",Was sind Allgemeinbegriffe ?,"Allgemeinbegriffe sind die Vorbilder für Klassen in der objektorientierten Programmierung. In SMALLTALK werden Allgemeinbegriffe in Form von Klassen repräsentiert. Klassen sind die Vorbilder für Objekte in der objektorientierten Programmierung. Jede Klasse kann Instanzvariablen und Methoden haben, die das Verhalten und die Eigenschaften der Objekte beschreiben, die zu dieser Klasse gehören."
"Zwar gibt es Anwendungsdomänen, in denen Wittgensteins Familienähnlichkeiten die Sachlage besser beschreiben als die traditionellen Allgemeinbegriffe (man denke z.B. an Musik, in der es zwar Töne und Noten gibt, aber dennoch zwei Töne selten genau gleich klingen sollen und die Notenzeichen entsprechend vielfältig variieren), aber insgesamt sind die üblichen Anwendungen doch eher der Natur, dass es von einigen wenigen Sorten eine große Menge von Objekten gibt, die alle mehr oder weniger gleich zu behandeln sind. Und so vereinfachen Allgemeinbegriffe oder Klassen unsere Weltsicht ganz erheblich und damit auch die Programme, die wir schreiben, um unsere Weltsicht zu reflektieren.Nachdem wir uns also auf Klassen festgelegt haben, können wir nun endlich zur Lüftung des Geheimnisses kommen, wo in einem SMALLTALK-Programm die Instanzvariablen und Methoden, die Objekte ihr eigen nennen, vereinbart (deklariert) und im Falle der Methoden auch definiert (mit Inhalt versehen) werden: in Klassen.",Was machen Allgemeinbegriffe und Klassen in der objektorientierten Programmierung?,Allgemeinbegriffe oder Klassen vereinfachen die Strukturierung von Objekten und die Beschreibung von Eigenschaften und Verhalten in der objektorientierten Programmierung.
"Die Genera Aristoteles' sind allesamt abstrakt — es gibt keine Säugetiere, die nicht Mensch, Hund, Katze oder etwas Konkretes wären. Übertragen auf die objektorientierte Programmierung bedeutet das: Generalisierungen, also Klassen, die aus Generalisierungen hervorgegangen sind, haben selbst keine Instanzen und sind daher insbesondere nicht instanziierbar.","Was bedeutet es, wenn Generalisierungen in der objektorientierten Programmierung abstrakt sind?","Das bedeutet, dass Generalisierungen, also Klassen, die aus Generalisierungen hervorgegangen sind, selbst keine Instanzen haben und daher nicht instanziierbar sind."
"Die Genera Aristoteles' sind allesamt abstrakt — es gibt keine Säugetiere, die nicht Mensch, Hund, Katze oder etwas Konkretes wären. Übertragen auf die objektorientierte Programmierung bedeutet das: Generalisierungen, also Klassen, die aus Generalisierungen hervorgegangen sind, haben selbst keine Instanzen und sind daher insbesondere nicht instanziierbar.",Was sind Generalisierungen in der objektorientierten Programmierung?,"Generalisierungen in der objektorientierten Programmierung sind Klassen, die aus Generalisierungen hervorgegangen sind und selbst keine Instanzen haben. Sie sind daher nicht instanziierbar."
"In der objektorientierten Programmierung nennt man nicht instanziierbare Klassen abstrakt. Der Grund für die mangelnde Instanziierbarkeit ist nicht immer konzeptuell (wie beispielsweise das Prinzip, dass eine Klasse eine Generalisierung ist und daher nicht instanziierbar sein sollte), sondern oft rein technisch. Abstrakten Klassen fehlen in der Regel Angaben, die das Verhalten ihrer Instanzen vollständig spezifizieren und diese somit brauchbar machen würden. Instanzen dieser Klassen wären unvollständig definiert und würden zu Laufzeitfehlern führen. Diese fehlenden Eigenschaften werden in den Klassen geliefert, die von den abstrakten erben (siehe nächstes Kapitel), wobei die Idee ist, dass sich die Eigenschaften von Klasse zu Klasse unterscheiden. Klassen, die nicht abstrakt sind und eigene Instanzen haben können, nennt man konkret. Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse Collection.",Was ist eine abstrakte Klasse in der objektorientierten Programmierung?,"Abstrakte Klassen in der objektorientierten Programmierung sind nicht instanziierbare Klassen. Der Grund für die mangelnde Instanziierbarkeit kann konzeptuell oder rein technisch sein. Instanzen dieser Klassen wären unvollständig definiert und würden zu Laufzeitfehlern führen. Diese fehlenden Eigenschaften werden in den Klassen geliefert, die von den abstrakten erben. Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse Collection."
"In der objektorientierten Programmierung nennt man nicht instanziierbare Klassen abstrakt. Der Grund für die mangelnde Instanziierbarkeit ist nicht immer konzeptuell (wie beispielsweise das Prinzip, dass eine Klasse eine Generalisierung ist und daher nicht instanziierbar sein sollte), sondern oft rein technisch. Abstrakten Klassen fehlen in der Regel Angaben, die das Verhalten ihrer Instanzen vollständig spezifizieren und diese somit brauchbar machen würden. Instanzen dieser Klassen wären unvollständig definiert und würden zu Laufzeitfehlern führen. Diese fehlenden Eigenschaften werden in den Klassen geliefert, die von den abstrakten erben (siehe nächstes Kapitel), wobei die Idee ist, dass sich die Eigenschaften von Klasse zu Klasse unterscheiden. Klassen, die nicht abstrakt sind und eigene Instanzen haben können, nennt man konkret. Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse Collection.",Was ist der Unterschied zwischen abstrakten und konkreten Klassen?,"Abstrakte Klassen sind nicht instanziierbar, da sie in der Regel Angaben fehlen, die das Verhalten ihrer Instanzen vollständig spezifizieren. Konkrete Klassen hingegen haben eigene Instanzen und können instanziiert werden."
"Schon am Fehlen von Instanzvariablen erkennt man, dass die Implementierung von Collection begrenzt ist. Instanzen wären schlicht zustandslos und daher kaum zu gebrauchen. Besonders deutlich wird die Abstraktheit jedoch an der Implementation der Methode add:. Hier wird anstatt etwas Entsprechendes zu tun, die Methode implementedBySubclass aufgerufen, die eine Fehlermeldung ausgibt. Wenn jemand versuchen würde, add: auf einer Instanz von Collection oder einer ihrer Subklassen aufzurufen, würde das zu einer Enttäuschung führen.",Warum ist die Implementierung von Collection begrenzt?,"Die Implementierung von Collection ist begrenzt, weil sie keine Instanzvariablen besitzt und die Methode add: lediglich eine Fehlermeldung ausgibt, anstatt etwas Entsprechendes zu tun."
"Schon am Fehlen von Instanzvariablen erkennt man, dass die Implementierung von Collection begrenzt ist. Instanzen wären schlicht zustandslos und daher kaum zu gebrauchen. Besonders deutlich wird die Abstraktheit jedoch an der Implementation der Methode add:. Hier wird anstatt etwas Entsprechendes zu tun, die Methode implementedBySubclass aufgerufen, die eine Fehlermeldung ausgibt. Wenn jemand versuchen würde, add: auf einer Instanz von Collection oder einer ihrer Subklassen aufzurufen, würde das zu einer Enttäuschung führen.",Was ist der Zweck der Methode implementedBySubclass in der Klasse Collection?,"Der Zweck der Methode implementedBySubclass in der Klasse Collection ist es, eine Fehlermeldung auszugeben, wenn jemand versucht, die Methode add: auf einer Instanz von Collection oder einer ihrer Subklassen aufzurufen. Dies wird getan, um zu verdeutlichen, dass die Implementierung von Collection begrenzt ist und Instanzen von Collection oder ihren Subklassen zustandslos sind und daher kaum zu gebrauchen wären."
"Allerdings tritt diese Enttäuschung erst zur Laufzeit auf. Viele andere Sprachen verlangen daher, dass man abstrakte Klassen mit einem Schlüsselwort wie ""abstract"" markiert und verbieten dann (durch den Compiler), die Klasse zu instanziieren. Dies ist in SMALLTALK jedoch nicht möglich, da Klassen in Variablen gespeichert werden können und der Compiler nicht wissen kann, welches Objekt die Variable nun gerade bezeichnet.","Warum ist es in Smalltalk nicht möglich, abstrakte Klassen mit einem Schlüsselwort wie ""abstract"" zu markieren und sie vom Compiler verbieten zu lassen?","In Smalltalk werden Klassen in Variablen gespeichert, und der Compiler kann nicht wissen, welches Objekt die Variable nun gerade bezeichnet. Daher ist es in Smalltalk nicht möglich, abstrakte Klassen mit einem Schlüsselwort wie ""abstract"" zu markieren und sie vom Compiler verbieten zu lassen."
"Der Hinweis, dass man eine abstrakte Klasse instanziiert hat, erfolgt in SMALLTALK nicht nur zur Laufzeit, sondern auch dann, wenn man versucht, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere ""new"" und ""new:"", entsprechend überschreiben. Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von Collection erben, was kaum zumutbar ist. Diese Klassen müssten dann ""new"" und ""new:"" wieder neu einführen, da ""new"" und ""new:"" primitive Methoden aufrufen.","Was passiert, wenn man versucht, eine nicht implementierte Methode in SMALLTALK aufzurufen?","Wenn man versucht, eine nicht implementierte Methode in SMALLTALK aufzurufen, erfolgt ein Hinweis, dass man eine abstrakte Klasse instanziiert hat."
"Der Hinweis, dass man eine abstrakte Klasse instanziiert hat, erfolgt in SMALLTALK nicht nur zur Laufzeit, sondern auch dann, wenn man versucht, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere ""new"" und ""new:"", entsprechend überschreiben. Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von Collection erben, was kaum zumutbar ist. Diese Klassen müssten dann ""new"" und ""new:"" wieder neu einführen, da ""new"" und ""new:"" primitive Methoden aufrufen.","Was passiert, wenn man eine abstrakte Klasse in SMALLTALK instanziiert?","In SMALLTALK wird ein Hinweis zur Instanziierung einer abstrakten Klasse sowohl zur Laufzeit als auch dann ausgelöst, wenn man versucht, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere ""new"" und ""new:"", entsprechend überschreiben. Dies wäre jedoch nicht praktikabel, da es auch die Instanziierung der Klassen verhindern würde, die von Collection erben."
"Man könnte in SMALLTALK die Methode add: in der Klasse Collection ganz weglassen. Ein Aufruf von add: auf einer Instanz von Collection oder einer ihrer Subklassen würde dann zu einem Aufruf von doesNotUnderstand und der Ausgabe einer entsprechenden Fehlermeldung führen. Diese Fehlermeldung wäre jedoch weniger aufschlussreich für die Programmierer, da sie nicht zwischen einem falschen Methodennamen und dem Vergessen der Implementierung in einer Subklasse unterscheiden könnte. Es ist sinnvoll, eine Methode wie add: in Collection bereitzustellen, die auf ein Versäumnis hinweist, falls eines vorliegt.","Warum ist es sinnvoll, eine Methode wie add: in Collection bereitzustellen?","Es ist sinnvoll, eine Methode wie add: in Collection bereitzustellen, um eine aufschlussreichere Fehlermeldung auszugeben, falls eine Subklasse die Implementierung der Methode vergisst."
"Der Aufruf einer abstrakten, in der Klasse nicht implementierten Methode aus derselben Klasse heraus (mit ""self"" als Empfänger) ist ein gängiges Muster in der objektorientierten Programmierung. Man nennt es auch ""offene Rekursion"", da der Aufruf auf dem Objekt selbst erfolgt und noch nicht klar ist, welche erbende Klasse die Implementierung liefert. Dieses Muster wird auch verwendet, um das oben beschriebene Dilemma von Quadrat und Rechteck aufzulösen.",Was ist offene Rekursion?,"Offene Rekursion ist ein Muster in der objektorientierten Programmierung, bei dem eine abstrakte, in der Klasse nicht implementierte Methode aus derselben Klasse heraus mit ""self"" als Empfänger aufgerufen wird. Dieses Muster wird verwendet, um die Implementierung der Methode in einer erbenden Klasse zu ermöglichen."
"Nicht alle Collections dienen der Umsetzung von Zu-n-Beziehungen. Ein gutes Beispiel ist die Klasse ""Interval"". Eine Intervall-Collection enthält eine Anzahl von Elementen, die durch eine untere und obere Grenze bestimmt sind. Die untere Grenze ist inklusiv, die obere Grenze exklusiv. Die Anzahl der Elemente ist also die Differenz zwischen der oberen und unteren Grenze. Die Elemente eines Intervalls sind die ganzen Zahlen, die zwischen der unteren und oberen Grenze liegen.",Wozu dient die Intervall-Collection?,"Die Intervall-Collection dient der Umsetzung von Zu-n-Beziehungen und enthält eine Anzahl von Elementen, die durch eine untere und obere Grenze bestimmt sind. Die untere Grenze ist inklusiv, die obere Grenze exklusiv. Die Anzahl der Elemente ist also die Differenz zwischen der oberen und unteren Grenze. Die Elemente eines Intervalls sind die ganzen Zahlen, die zwischen der unteren und oberen Grenze liegen."
"Nicht alle Collections dienen der Umsetzung von Zu-n-Beziehungen. Ein gutes Beispiel ist die Klasse ""Interval"". Eine Intervall-Collection enthält eine Anzahl von Elementen, die durch eine untere und obere Grenze bestimmt sind. Die untere Grenze ist inklusiv, die obere Grenze exklusiv. Die Anzahl der Elemente ist also die Differenz zwischen der oberen und unteren Grenze. Die Elemente eines Intervalls sind die ganzen Zahlen, die zwischen der unteren und oberen Grenze liegen.","Welche Art von Beziehungen kann die Klasse ""Interval"" nicht umsetzen?","Die Klasse ""Interval"" ist nicht geeignet, um Zu-n-Beziehungen umzusetzen."
"Nicht alle Collections dienen der Umsetzung von Zu-n-Beziehungen. Ein gutes Beispiel ist die Klasse ""Interval"". Eine Intervall-Collection enthält eine Anzahl von Elementen, die durch eine untere und obere Grenze bestimmt sind. Die untere Grenze ist inklusiv, die obere Grenze exklusiv. Die Anzahl der Elemente ist also die Differenz zwischen der oberen und unteren Grenze. Die Elemente eines Intervalls sind die ganzen Zahlen, die zwischen der unteren und oberen Grenze liegen.","Was ist eine der Eigenschaften der Klasse ""Interval""?","Eine der Eigenschaften der Klasse ""Interval"" ist, dass sie eine zusammenhängende Sequenz von Objekten repräsentiert, die durch einen Start- und Endwert definiert sind."
"Bei Instanzen der Klasse ""Interval"" handelt es sich um endliche arithmetische Folgen, also um beschränkte Folgen von Zahlen, die alle denselben Abstand zueinander haben. Die Elemente einer solchen Collection müssen deswegen nicht gespeichert, sondern können berechnet werden. Die Spezifikation eines Intervalls umfasst seinen Anfangs- und seinen Endwert sowie die Schrittweite, die auch negativ sein darf.","Was sind Instanzen der Klasse ""Interval""?","Instanzen der Klasse ""Interval"" sind endliche arithmetische Folgen, also beschränkte Folgen von Zahlen, die alle denselben Abstand zueinander haben. Die Elemente einer solchen Collection müssen nicht gespeichert, sondern können berechnet werden. Die Spezifikation eines Intervalls umfasst seinen Anfangs- und seinen Endwert sowie die Schrittweite, die auch negativ sein darf."
"""5 to: 1 by: -2"" erzeugt ein Intervall, das die Zahlen 5, 3 und 1 enthält. Intervalle dienen vor allem dem Zweck, sog. ""For""-Schleifen zu emulieren. Um der geschätzten Programmiererin auch noch die Klammern zu ersparen, wurde gleich noch die Methode ""to:by:do:"" hinzugefügt. ""to:do:"" ist eine Methode, die eine Schleife über eine Sequenz von Zahlen erzeugt. Die Sequenz beginnt mit dem ersten Wert, der als Argument übergeben wird, und endet mit dem letzten Wert, der ebenfalls als Argument übergeben wird. Die Methode ""to:by:do:"" ist eine Variante von ""to:do:"", die eine Schrittweite als drittes Argument akzeptiert.","Was macht die Methode ""to:by:do:""?","Die Methode ""to:by:do:"" ist eine Methode in SMALLTALK, die eine Zählung von einer Startzahl bis zu einer Endzahl mit einem bestimmten Schritt durchführt. Dabei wird eine Block-Variable verwendet, die für jeden Schritt ausgeführt wird. Die Syntax lautet: ""to:end by:increment do:aBlock"""
"""5 to: 1 by: -2"" erzeugt ein Intervall, das die Zahlen 5, 3 und 1 enthält. Intervalle dienen vor allem dem Zweck, sog. ""For""-Schleifen zu emulieren. Um der geschätzten Programmiererin auch noch die Klammern zu ersparen, wurde gleich noch die Methode ""to:by:do:"" hinzugefügt. ""to:do:"" ist eine Methode, die eine Schleife über eine Sequenz von Zahlen erzeugt. Die Sequenz beginnt mit dem ersten Wert, der als Argument übergeben wird, und endet mit dem letzten Wert, der ebenfalls als Argument übergeben wird. Die Methode ""to:by:do:"" ist eine Variante von ""to:do:"", die eine Schrittweite als drittes Argument akzeptiert.","Was macht die Methode ""to:do:"" in Smalltalk?","Die Methode ""to:do:"" in Smalltalk erzeugt eine Schleife über eine Sequenz von Zahlen, die mit dem ersten Wert beginnt und mit dem letzten Wert endet, die als Argumente übergeben werden. Die Methode akzeptiert eine Blockvariable, die für jede Zahl in der Sequenz verwendet wird."
"(Manche beachten, dass hier der Iterator in der Klasse ""Number"" und nicht in einer Collection wie ""Interval"" definiert wurde.) Wie man sieht, ist es in SMALLTALK möglich, ohne großen Aufwand neue Ausdrucksformen hinzuzufügen, ohne dazu (wie in den meisten anderen Sprachen notwendig) die Syntax ändern zu müssen.",Wie können neue Ausdrucksformen in SMALLTALK hinzugefügt werden?,"In SMALLTALK können neue Ausdrucksformen ohne großen Aufwand hinzugefügt werden, ohne dazu die Syntax ändern zu müssen."
"Wenn Variablen keine Objekte enthalten, sondern lediglich auf sie verweisen, wenn sie also Verweissemantik haben, ist es möglich, dass mehrere Variablen gleichzeitig dasselbe Objekt benennen. Das nennt man Aliasing. Das Aliasing ist eines der wichtigsten Phänomene der objektorientierten Programmierung; zugleich ist es leider nur wenig als solches bekannt. Versuchen Sie trotzdem, es sich stets bewusst zu machen — es wird Sie vor manch böser Überraschung bewahren.",Was ist Aliasing?,"Aliasing bezieht sich auf die Situation, in der mehrere Variablen gleichzeitig auf dasselbe Objekt verweisen. Das bedeutet, dass ein Objekt mehrere Namen, Aliase, haben kann."
"Aliase, also weitere Namen für ein bereits benanntes Objekt, entstehen immer bei der Zuweisung. Dazu ist es notwendig, dass die Variable auf der linken Seite Verweissemantik hat. Da in SMALLTALK die Semantik von Variablen nicht mit der Variablendeklaration festgelegt wird, sondern von der Art eines Objekts abhängt, ist nicht immer klar, bei welcher Zuweisung ein Alias entsteht. Dabei kann beides, die fälschliche Annahme von Verweissemantik bei tatsächlicher Wertsemantik und die Entstehung von Aliasen, zu erheblichen (und schwer zu findenden) Programmierfehlern führen.",Wann entstehen Aliase?,"Aliase entstehen immer bei der Zuweisung, wenn die Variable auf der linken Seite Verweissemantik hat."
"Das Aliasing ist zunächst erwünscht: Da jedes Objekt nur einmal im Speicher hinterlegt werden muss, ermöglicht es die extrem effiziente Informationsverarbeitung (es ist weder ein Kopieren notwendig, wenn ein Objekt weitergereicht werden soll, noch müssen die Änderungen an den verschiedenen Kopien zusammengeführt werden, die notwendig sind, wenn die Kopien immer noch dasselbe logische Objekt bezeichnen sollen). Doch diese Effizienz hat ihren Preis.",Warum kann das Aliasing erwünscht sein?,"Aliasing ist zunächst erwünscht, da es die Effizienz der Informationsverarbeitung erhöht. Es ermöglicht das Teilen von Objekten ohne Kopieren."
"Dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt, kann nämlich unerwünscht sein und zu einem Programmierfehler führen. Wenn die Änderung an einer weit entfernten Stelle im Programm erfolgt, ist die Identität der benannten Objekte nicht mehr offensichtlich. Tatsächlich hat man es dann mit einem recht subtilen und schwer zu findenden Programmierfehler zu tun. Deswegen sind in einigen SMALLTALK-Systemen alle auf Basis literaler Repräsentationen erzeugten Objekte als unveränderlich markiert (wenn Sie es nicht schon sind, wie beispielsweise Zahlen), so dass Programmierfehler dieser Art vermieden werden. Sollte eine Zuweisung mit Wertsemantik benötigt werden, so schreibt man “copy”. Dabei sorgt das hintangestellte ""copy"" dafür, dass von dem Objekt eine Kopie angefertigt wird, also ein neues Objekt, das dem alten gleicht (mehr zur Syntax und dazu, wofür ""copy"" steht, folgt unten). Nicht nötig wird das Kopieren, wenn ich die Änderung durch die Zuweisung eines neuen Objekts bewerkstellige.",Warum kann Aliasing zu Programmierfehlern führen?,"Aliasing kann zu Programmierfehlern führen, weil Änderungen an einem Objekt, das durch eine Variable bezeichnet wird, sich auf alle Aliase dieses Objekts auswirken. Unerwartete Veränderungen an einem Alias können schwer zu erkennen und zu debuggen sein."
"Dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt, kann nämlich unerwünscht sein und zu einem Programmierfehler führen. Wenn die Änderung an einer weit entfernten Stelle im Programm erfolgt, ist die Identität der benannten Objekte nicht mehr offensichtlich. Tatsächlich hat man es dann mit einem recht subtilen und schwer zu findenden Programmierfehler zu tun. Deswegen sind in einigen SMALLTALK-Systemen alle auf Basis literaler Repräsentationen erzeugten Objekte als unveränderlich markiert (wenn Sie es nicht schon sind, wie beispielsweise Zahlen), so dass Programmierfehler dieser Art vermieden werden. Sollte eine Zuweisung mit Wertsemantik benötigt werden, so schreibt man “copy”. Dabei sorgt das hintangestellte ""copy"" dafür, dass von dem Objekt eine Kopie angefertigt wird, also ein neues Objekt, das dem alten gleicht (mehr zur Syntax und dazu, wofür ""copy"" steht, folgt unten). Nicht nötig wird das Kopieren, wenn ich die Änderung durch die Zuweisung eines neuen Objekts bewerkstellige.",Wie werden in SMALLTALK Programmierfehler durch Aliasing verhindert?,"Um Programmierfehler durch Aliasing in SMALLTALK zu verhindern, werden auf Basis literaler Repräsentationen erzeugte Objekte als unveränderlich markiert. Wenn eine Zuweisung mit Wertsemantik benötigt wird, kann das Kopieren des Objekts verwendet werden."
"Dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt, kann nämlich unerwünscht sein und zu einem Programmierfehler führen. Wenn die Änderung an einer weit entfernten Stelle im Programm erfolgt, ist die Identität der benannten Objekte nicht mehr offensichtlich. Tatsächlich hat man es dann mit einem recht subtilen und schwer zu findenden Programmierfehler zu tun. Deswegen sind in einigen SMALLTALK-Systemen alle auf Basis literaler Repräsentationen erzeugten Objekte als unveränderlich markiert (wenn Sie es nicht schon sind, wie beispielsweise Zahlen), so dass Programmierfehler dieser Art vermieden werden. Sollte eine Zuweisung mit Wertsemantik benötigt werden, so schreibt man “copy”. Dabei sorgt das hintangestellte ""copy"" dafür, dass von dem Objekt eine Kopie angefertigt wird, also ein neues Objekt, das dem alten gleicht (mehr zur Syntax und dazu, wofür ""copy"" steht, folgt unten). Nicht nötig wird das Kopieren, wenn ich die Änderung durch die Zuweisung eines neuen Objekts bewerkstellige.","Was ist das Schlüsselword ""copy"" in SMALLTALK?","In SMALLTALK kann das Schlüsselwort ""copy"" verwendet werden, um von einem Objekt eine Kopie anzufertigen, anstatt eine Referenz auf dasselbe Objekt zu erstellen. Dies verhindert Aliasing."
"Fehler dieser Art sind häufig die Folge dessen, dass sich eine Programmiererin der aliasbildenden Wirkung der Zuweisung nicht bewusst war. Das ist insbesondere bei den Programmiererinnen der Fall, die nicht mit der objektorientierten Programmierung großgeworden sind, die insbesondere bei einer Zuweisung ""y := x"" das Kopieren des Inhalts der Variablen auf der rechten Seite (x) vermuten. Tatsächlich muss man in anderen Sprachen (wie beispielsweise PASCAL oder C) eine Variable explizit als Pointervariable deklarieren, um einen Alias bilden zu können. In SMALLTALK, genau wie in Java und C-Sharp, ist Aliasing jedoch der Regelfall und Kopie die Ausnahme. Wer das nicht verinnerlicht hat, schreibt höchstens zufällig korrekte Programme.",Was ist wichtig in Bezug auf Aliase?,"Es ist wichtig, sich der aliasbildenden Wirkung der Zuweisung bewusst zu sein, da dies in Sprachen wie SMALLTALK der Regelfall ist."
"In der Klasse Object ist das Protokoll definiert, das allen Objekten gemeinsam ist, d. h., für das alle Klassen Methodendefinitionen haben, und zwar entweder eigene oder geerbte. Object gibt zu diesem Zweck Standardimplementierungen vor, die von den meisten Objekten direkt übernommen werden können (und nur von den wenigen überschrieben werden müssen). Dazu zählen z. B. die bereits mehrfach erwähnten isNil und notNil (die nur von UndefinedObject überschrieben werden) sowie zahlreiche weitere Typtests (isInteger, isFloat usw.). Daneben gibt es auch noch eine ganze Reihe anderer Methoden, deren Kenntnis sich lohnt.",Was ist das Protokoll in der Klasse Object?,"Das Protokoll in der Klasse Object ist das gemeinsame Protokoll für alle Objekte, das Methodendefinitionen enthält, die von allen Klassen übernommen werden können. Dazu gehören Standardimplementierungen für Typtests wie isNil, notNil, isInteger, isFloat usw."
"Für die Implementierung von Wiederholungen (Schleifen) müssen wir etwas weiter ausholen: Da das Abbruchkriterium von Schleifen immer wieder (bei jedem Schleifendurchlauf) ausgewertet werden muss, kann nicht einfach einmal eine Nachricht an eine Variable mit Inhalt true oder false gesendet werden. Vielmehr muss die Auswertung des Abbruchkriteriums selbst in einem Block stattfinden, der bei jedem Schleifendurchlauf erneut ausgewertet wird. Aber auch das ist kein Problem: Der Nachrichtenempfänger ist einfach ein Block, dessen Auswertung entweder true oder false zurückliefert; der Parameter der Nachricht ist dann der Block, der den Schleifenrumpf darstellt.Die Schleife wird durch eine sogenannte Endrekursion simuliert: whileTrue: ruft sich am Ende selbst wieder auf. Wegen der Performanz (oder möglicher Beschränkungen der Anzahl der Schleifendurchläufe durch die Größe des Aufrufstacks) brauchen Sie sich dabei keine Sorgen zu machen: Da hinter dem rekursiven Aufruf nichts mehr passiert (deshalb Endrekursion), kann dieser vom Compiler in eine echte Schleife übersetzt werden.Für die ebenfalls aus anderen Sprachen bekannten For-Schleifen hat SMALLTALK eine andere elegante Lösung parat, auf die wir im nächsten Abschnitt eingehen werden.",Wie wird die Wiederholungen (Schleifen) in SMALLTALK realisiert?,"In SMALLTALK wird die Implementierung von Wiederholungen (Schleifen) durch Endrekursion simuliert. Dabei wird eine Methode wie whileTrue: am Ende selbst wieder aufgerufen. Der Schleifenrumpf wird durch einen Block dargestellt, und das Abbruchkriterium wird ebenfalls in einem Block ausgewertet. Der rekursive Aufruf am Ende der Methode kann vom Compiler in eine echte Schleife übersetzt werden."
"Es ist Ihnen vielleicht aufgefallen, dass im oben beschriebenen Verfahren zum Auffinden der auszuführenden Methode nur das Empfängerobjekt, jedoch nicht die Parameterobjekte berücksichtigt wurden. Das erscheint zunächst natürlich. Manchmal hängt jedoch die Auswahl einer geeigneten Methode auch von den tatsächlichen Parametern ab.",Wann wird das Empfängerobjekt und die Parameterobjekte bei der Auswahl einer Methode berücksichtigt?,"Das Empfängerobjekt und die Parameterobjekte werden bei der Auswahl einer Methode berücksichtigt, wenn die Auswahl der geeigneten Methode von den tatsächlichen Parametern abhängt."
"Es ist Ihnen vielleicht aufgefallen, dass im oben beschriebenen Verfahren zum Auffinden der auszuführenden Methode nur das Empfängerobjekt, jedoch nicht die Parameterobjekte berücksichtigt wurden. Das erscheint zunächst natürlich. Manchmal hängt jedoch die Auswahl einer geeigneten Methode auch von den tatsächlichen Parametern ab.",Wann hängt die Auswahl einer Methode von den tatsächlichen Parametern ab?,"Manchmal hängt die Auswahl einer geeigneten Methode nicht nur vom Empfängerobjekt, sondern auch von den tatsächlichen Parametern ab."
"Es ist Ihnen vielleicht aufgefallen, dass im oben beschriebenen Verfahren zum Auffinden der auszuführenden Methode nur das Empfängerobjekt, jedoch nicht die Parameterobjekte berücksichtigt wurden. Das erscheint zunächst natürlich. Manchmal hängt jedoch die Auswahl einer geeigneten Methode auch von den tatsächlichen Parametern ab.",Was ist Parametrische Polymorphie?,"Parametrische Polymorphie ist eine Art der Polymorphie, bei der die Auswahl einer Methode von den tatsächlichen Parametern abhängt. Wenn die Methode, die für eine bestimmte Nachricht vorgesehen ist, nicht für alle möglichen Parameter geeignet ist, muss eine alternative Methode ausgewählt werden, die besser zu den tatsächlichen Parametern passt."
"Es ist Ihnen vielleicht aufgefallen, dass im oben beschriebenen Verfahren zum Auffinden der auszuführenden Methode nur das Empfängerobjekt, jedoch nicht die Parameterobjekte berücksichtigt wurden. Das erscheint zunächst natürlich. Manchmal hängt jedoch die Auswahl einer geeigneten Methode auch von den tatsächlichen Parametern ab.",Wie wird die Parametrische Polymorphie in der objektorientierten Programmierung implementiert?,"In der objektorientierten Programmierung wird Parametrische Polymorphie in der Regel durch Überladen von Methoden implementiert. Dabei werden mehrere Methoden mit dem gleichen Namen, aber unterschiedlichen Parametern definiert. Wenn eine Nachricht gesendet wird, wird die Methode mit den passenden Parametern ausgewählt und ausgeführt."
"Typische Fälle, in denen auch die tatsächlichen Parameter eine Rolle bei der Methodenauswahl spielen, sind arithmetische Operatoren wie +, –, *, und /. Diese sind nämlich sowohl für Ganzzahlen als auch für Brüche und Gleitkommazahlen definiert, wobei die Implementierung einer Operation von der Art der Operanden abhängt. Nehmen wir beispielsweise an, es gäbe zwei primitive Methoden für die Addition, und zwar eine effiziente für die Integer-Addition (IAdd) und eine weniger effiziente für die Float-Addition (FAdd), und man möchte Additionen für beliebige Kombinationen von Summanden möglichst effizient durchführen können.",Wann spielen die tatsächlichen Parameter eine Rolle bei der Methodenauswahl?,"Die tatsächlichen Parameter spielen eine Rolle bei der Methodenauswahl, wenn eine Methode für verschiedene Datentypen unterschiedlich implementiert ist, wie zum Beispiel bei arithmetischen Operatoren."
"Typische Fälle, in denen auch die tatsächlichen Parameter eine Rolle bei der Methodenauswahl spielen, sind arithmetische Operatoren wie +, –, *, und /. Diese sind nämlich sowohl für Ganzzahlen als auch für Brüche und Gleitkommazahlen definiert, wobei die Implementierung einer Operation von der Art der Operanden abhängt. Nehmen wir beispielsweise an, es gäbe zwei primitive Methoden für die Addition, und zwar eine effiziente für die Integer-Addition (IAdd) und eine weniger effiziente für die Float-Addition (FAdd), und man möchte Additionen für beliebige Kombinationen von Summanden möglichst effizient durchführen können.","Wie können arithmetische Operatoren wie +, –, *, und / effizient implementiert werden?","Durch die Verwendung von zwei primitive Methoden für die Addition, eine effiziente für die Integer-Addition (IAdd) und eine weniger effiziente für die Float-Addition (FAdd), und durch die Möglichkeit, Additionen für beliebige Kombinationen von Summanden möglichst effizient durchzuführen. Die Implementierung einer Operation hängt von der Art der Operanden ab."
"Während die Unterscheidung nach Empfängerobjekten vom dynamischen Binden und damit dem Laufzeitsystem vorgenommen wird, bleibt die Frage, wie man die Unterscheidung nach den Parameterobjekten vornimmt: Zumindest die Implementation der Addition in der Klasse Integer muss ja danach unterscheiden, ob der Parameter auch ein Integer oder vielleicht ein Float ist. Anstatt nun diese Fallunterscheidung (mittels entsprechender Methoden wie isInteger bzw. isFloat) explizit zu machen, kann man sich eines einfachen Tricks bedienen: Man ruft im Rumpf einer Methode dieselbe Methode einfach noch einmal auf und vertauscht dabei Empfänger (self) und Parameter. Damit es dabei nicht zu unendlichen Rekursionen kommt, kodiert man die Klasse des Empfängers im Nachrichtenselektor der neu aufgerufenen Methode42, also z. B. plusFloat: anstelle von nur plus:.",Wie kann man die Unterscheidung nach den Parameterobjekten in Smalltalk vornehmen?,"Statt die Fallunterscheidung explizit zu machen, kann man sich eines Tricks bedienen, bei dem man im Rumpf einer Methode dieselbe Methode erneut aufruft und Empfänger und Parameter vertauscht. Dabei kodiert man die Klasse des Empfängers im Nachrichtenselektor der neu aufgerufenen Methode, z. B. plusFloat: anstelle von plus:."
"Diese Technik, nämlich eine Methode gleicher Bedeutung unter Vertauschung von Sender und Empfänger aufzurufen, nennt man ""Double Dispatch"", und zwar deshalb, weil die dynamische Bindung (auch Method oder Message dispatching genannt) zweimal, und zwar unmittelbar hintereinander, erfolgt. Die Technik des Double Dispatch wurde übrigens von DAN INGALLS am Beispiel von SMALLTALK erstmals beschrieben; sie findet auch in anderen Sprachen mit Single Dispatch (wie Java und C-Sharp) verbreitet Anwendung. Double Dispatch wird in Sprachen, bei denen bei der (dynamischen) Methodenauswahl von Haus aus die Parametertypen mit berücksichtigt werden (die sog. Multi Dispatch -Sprachen), naturgemäß nicht benötigt.",Was ist Double Dispatch und wofür wird es verwendet?,"Double Dispatch ist eine Technik, bei der eine Methode gleicher Bedeutung unter Vertauschung von Sender und Empfänger aufgerufen wird. Diese Technik wird verwendet, um die dynamische Bindung zweimal hintereinander durchzuführen. Double Dispatch wurde erstmals von Dan Ingalls am Beispiel von Smalltalk beschrieben und findet auch in anderen Sprachen mit Single Dispatch Anwendung. In Sprachen, bei denen bei der dynamischen Methodenauswahl die Parametertypen berücksichtigt werden, wird Double Dispatch nicht benötigt."
"In Kapitel 2 von Kurseinheit 1 waren wir bereits auf Zu-n-Beziehungen eingegangen, die logisch gleichberechtigt neben Zu-1-Beziehungen stehen, die aber in der Umsetzung besonderer Mechanismen bedürfen. Als Basis der Umsetzung hatten Sie bereits Zwischenobjekte kennengelernt, die über ihre indizierten Instanzvariablen solche Beziehungen — wenn auch nur indirekt — herstellen können. Tatsächlich könnte man, wenn man sich der Häufigkeit des Vorkommens von Zu-n-Beziehungen in der Programmierung bewusst ist, vermuten, dass indizierte Instanzvariablen speziell für diesen Zweck eingeführt wurden. Auf den ersten Blick bedauerlich ist nur, dass dafür eben diese Zwischenobjekte notwendig sind.",Wofür werden indizierte Instanzvariablen verwendet?,"Indizierte Instanzvariablen werden verwendet, um Zu-n-Beziehungen zwischen Objekten herzustellen. Sie sind speziell für diesen Zweck eingeführt worden, um die Häufigkeit des Vorkommens von Zu-n-Beziehungen in der Programmierung zu unterstützen."
"In Kapitel 2 von Kurseinheit 1 waren wir bereits auf Zu-n-Beziehungen eingegangen, die logisch gleichberechtigt neben Zu-1-Beziehungen stehen, die aber in der Umsetzung besonderer Mechanismen bedürfen. Als Basis der Umsetzung hatten Sie bereits Zwischenobjekte kennengelernt, die über ihre indizierten Instanzvariablen solche Beziehungen — wenn auch nur indirekt — herstellen können. Tatsächlich könnte man, wenn man sich der Häufigkeit des Vorkommens von Zu-n-Beziehungen in der Programmierung bewusst ist, vermuten, dass indizierte Instanzvariablen speziell für diesen Zweck eingeführt wurden. Auf den ersten Blick bedauerlich ist nur, dass dafür eben diese Zwischenobjekte notwendig sind.",Was sind Zu-n-Beziehungen und wie werden sie umgesetzt?,"Zu-n-Beziehungen sind logisch gleichberechtigt neben Zu-1-Beziehungen, die aber in der Umsetzung besonderer Mechanismen bedürfen. Sie werden durch indizierte Instanzvariablen umgesetzt, die über Zwischenobjekte solche Beziehungen herstellen. Diese Zwischenobjekte sind notwendig, um Zu-n-Beziehungen in der Programmierung umzusetzen."
"Es ergibt sich aus diesem Umstand aber auch ein entscheidender Vorteil. Da auch diese Zwischenobjekte Instanzen von Klassen sein müssen, ist es möglich, verschiedene Arten von Zu-n-Beziehungen zu definieren und diese jeweils mit Verhalten zu versehen, das speziell auf die Art der Beziehung bezogen ist. So ist es beispielsweise möglich, Zu-n-Beziehungen zu definieren, deren Elemente (die in Beziehung stehenden Objekte) jeweils nur einmal darin vorkommen dürfen (mengenwertige Beziehungen) oder nach einem bestimmten Kriterium sortiert sind. Auch können Operationen wie das Hinzufügen oder Entfernen von Objekten zu einer Beziehung, die bei Zu-1-Beziehungen über die Zuweisung zu einer Instanzvariable erfolgen (das Entfernen durch Zuweisung von nil), beliebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu erhalten.",Was ist der Vorteil von Zu-n-Beziehungen in der objektorientierten Programmierung?,"Der Vorteil von Zu-n-Beziehungen in der objektorientierten Programmierung ist, dass verschiedene Arten von Zu-n-Beziehungen definiert werden können, die jeweils mit Verhalten versehen sind, das speziell auf die Art der Beziehung bezogen ist. So können Operationen wie das Hinzufügen oder Entfernen von Objekten zu einer Beziehung beliebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu erhalten."
"Es ergibt sich aus diesem Umstand aber auch ein entscheidender Vorteil. Da auch diese Zwischenobjekte Instanzen von Klassen sein müssen, ist es möglich, verschiedene Arten von Zu-n-Beziehungen zu definieren und diese jeweils mit Verhalten zu versehen, das speziell auf die Art der Beziehung bezogen ist. So ist es beispielsweise möglich, Zu-n-Beziehungen zu definieren, deren Elemente (die in Beziehung stehenden Objekte) jeweils nur einmal darin vorkommen dürfen (mengenwertige Beziehungen) oder nach einem bestimmten Kriterium sortiert sind. Auch können Operationen wie das Hinzufügen oder Entfernen von Objekten zu einer Beziehung, die bei Zu-1-Beziehungen über die Zuweisung zu einer Instanzvariable erfolgen (das Entfernen durch Zuweisung von nil), beliebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu erhalten.",Was ist eine Zu-n-Beziehung?,"Eine Zu-n-Beziehung ist eine Beziehung, die definiert, wie sich ein Objekt auf eine Gruppe von anderen Objekten bezieht. Diese Beziehung kann mit Verhalten versehen werden, das speziell auf die Art der Beziehung bezogen ist, wie zum Beispiel das Hinzufügen oder Entfernen von Objekten zu einer Beziehung, die Sortierung oder die Mengenwertigkeit."
"Besonders attraktiv ist jedoch die in SMALLTALK bestehende Möglichkeit, eigene Kontrollstrukturen für Zu-n-Beziehungen zu spezifizieren. Die Standarditeratoren haben je nach Art der Beziehung unterschiedliche Eigenschaften. Außerdem ist es natürlich möglich, mit eigenen Arten von Beziehungen auch spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren.","Was ist eine Möglichkeit in SMALLTALK, eigene Kontrollstrukturen für Zu-n-Beziehungen zu spezifizieren?","In SMALLTALK ist es möglich, eigene Kontrollstrukturen für Zu-n-Beziehungen zu spezifizieren, indem man eigene Arten von Beziehungen definiert und für diese spezielle Kontrollstrukturen spezifiziert."
"In Java ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden. Anders als z. B. in PASCAL können aber über den Array-Typkonstruktor keine neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration.",Kann man in Java Arrays von primitiven Typen bilden?,"Ja, in Java ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden."
"In Java ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden. Anders als z. B. in PASCAL können aber über den Array-Typkonstruktor keine neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration.",Kann man in Java neue Typen über den Array-Typkonstruktor benennen?,"Nein, in Java können über den Array-Typkonstruktor keine neuen Typen benannt werden. Die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration."
"In Java ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden. Anders als z. B. in PASCAL können aber über den Array-Typkonstruktor keine neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration.",Was ist der Unterschied zwischen primitiven (Wert-)Typen und Referenztypen in Java?,"Primitiven (Wert-)Typen werden direkt im Speicher abgelegt, während Referenztypen auf einen Speicherbereich verweisen, der die Daten enthält. Der Hauptunterschied liegt darin, wie sie in Arrays abgelegt werden. Für primitiven Typen wird ein neuer Typ benannt, während für Referenztypen die Typkonstruktion immer implizit in einer Variablendeklaration erfolgt."
"In Java sind zwei Variablen vereinbart, wovon die erste ein Array von Fließkommazahlen zum Typ hat und die zweite ein Array von Objekten. Die alternative Schreibweise ist ebenfalls gebräuchlich. Anders als z. B. in PASCAL wird die Größe des Arrays in der Deklaration nicht festgelegt — dies geschieht erst bei der Initialisierung.",Wie wird die Größe eines Arrays in Java festgelegt?,"Die Größe eines Arrays in Java wird nicht in der Deklaration festgelegt, sondern erst bei der Initialisierung."
"In Java ist es möglich, Arrays bei ihrer Deklaration zu initialisieren. Man beachte die Ähnlichkeit zu literalen Arrays in SMALLTALK (Abschnitt 1.2); allerdings müssen die Elemente der Arrays in Java nicht selbst Literale sein, sondern dürfen auch andere Ausdrücke sein. Die Größe des Arrays (in diesem Fall 2) wird bei der Initialisierung automatisch festgelegt; ansonsten muss dies bei der Erzeugung des Arrays mittels eines Konstruktors explizit geschehen.",Wie können Arrays in Java initialisiert werden?,"In Java können Arrays bei ihrer Deklaration initialisiert werden, indem man ihnen Werte zuweist. Die Größe des Arrays wird dabei automatisch festgelegt. Die Elemente des Arrays müssen nicht selbst Literale sein, sondern dürfen auch andere Ausdrücke sein."
"Alle Elemente des Arrays enthalten danach jedoch null (Javas Äquivalent von SMALLTALKs nil). Java-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.",Wie ist die Initialisierung von Elementen in Java-Arrays?,Alle Elemente des Arrays enthalten nach der Initialisierung den Wert null (Javas Äquivalent von SMALLTALKs nil).
"Alle Elemente des Arrays enthalten danach jedoch null (Javas Äquivalent von SMALLTALKs nil). Java-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.",Wie ist die Nummerierung der Indizes in Java-Arrays?,"Java-Arrays sind 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.)"
"Alle Elemente des Arrays enthalten danach jedoch null (Javas Äquivalent von SMALLTALKs nil). Java-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.",Wie können Array-Initialisierer in Java sein?,Array-Initialisierer können in Java auch geschachtelt werden und somit mehrere Dimensionen umfassen.
"Alle Elemente des Arrays enthalten danach jedoch null (Javas Äquivalent von SMALLTALKs nil). Java-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.",Was passiert mit den Elementen eines Arrays nach der Initialisierung in Java?,Nach der Initialisierung eines Arrays in Java enthalten alle Elemente den Wert null.
"Alle Elemente des Arrays enthalten danach jedoch null (Javas Äquivalent von SMALLTALKs nil). Java-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.","Was bedeutet es, wenn ein Array in Java 0-basiert ist?","Wenn ein Array in Java 0-basiert ist, hat das erste Element den Index 0."
"Alle Elemente des Arrays enthalten danach jedoch null (Javas Äquivalent von SMALLTALKs nil). Java-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.",Was kann ein Array-Initialisierer in Java umfassen?,Ein Array-Initialisierer in Java kann mehrere Dimensionen umfassen.
"Alle Elemente des Arrays enthalten danach jedoch null (Javas Äquivalent von SMALLTALKs nil). Java-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.",Was ist ein Array-Initialisierer in Java?,"Ein Array-Initialisierer in Java ist eine Möglichkeit, ein Array mit Werten zu initialisieren."
"Alle Elemente des Arrays enthalten danach jedoch null (Javas Äquivalent von SMALLTALKs nil). Java-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.",Was ist der Index des ersten Elements in einem 0-basierten Array?,Der Index des ersten Elements in einem 0-basierten Array ist 0.
"Beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimensionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays in Java auch gar nicht um mehrdimensionale Arrays, sondern um Arrays von Arrays).",Was sind Ragged oder Jagged arrays in Java?,"Ragged oder Jagged arrays in Java sind mehrdimensionalen Arrays, bei denen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten müssen."
"Beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimensionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays in Java auch gar nicht um mehrdimensionale Arrays, sondern um Arrays von Arrays).",Wie werden mehrdimensionale Arrays in Java deklariert?,Mehrdimensionale Arrays in Java werden als Arrays von Arrays deklariert.
"Beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimensionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays in Java auch gar nicht um mehrdimensionale Arrays, sondern um Arrays von Arrays).",Gibt es eine Einschränkung bei der Größe der Dimensionen in Java?,"Nein, in Java gibt es keine Einschränkung bei der Größe der Dimensionen."
"Interessanterweise haben in Java Array-Variablen immer und unabhängig vom Basistyp Referenzsemantik. Bei der Zuweisung an die Variable f oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer darauf. Dies hat vermutlich den Hintergrund, dass Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Warum auch immer, im Ergebnis kann f an eine Variable vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit auch nicht damit zuweisungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn sie wie Klassen und Interfaces Typen bilden, außer ihrem Basistyp (also beispielsweise float oder Object) keine weiteren Definitionselemente anzugeben erlauben; insbesondere kann man für einen Array-Typen keine weiteren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die (Pseudo-)Variable length definiert, deren Inhalt die Größe des Arrays (Anzahl Elemente) angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.",Wie verhält sich die Zuweisungskompatibilität von Array-Variablen in Java?,"In Java haben Array-Variablen immer Referenzsemantik. Eine Zuweisung von f an eine Variable vom Typ Object ist zulässig, während eine Zuweisung von f an eine Variable vom Typ Object[] nicht zulässig ist. Dies liegt daran, dass float[] kein Subtyp von Object[] ist."
"Interessanterweise haben in Java Array-Variablen immer und unabhängig vom Basistyp Referenzsemantik. Bei der Zuweisung an die Variable f oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer darauf. Dies hat vermutlich den Hintergrund, dass Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Warum auch immer, im Ergebnis kann f an eine Variable vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit auch nicht damit zuweisungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn sie wie Klassen und Interfaces Typen bilden, außer ihrem Basistyp (also beispielsweise float oder Object) keine weiteren Definitionselemente anzugeben erlauben; insbesondere kann man für einen Array-Typen keine weiteren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die (Pseudo-)Variable length definiert, deren Inhalt die Größe des Arrays (Anzahl Elemente) angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.",Was ist das Verhalten von Array-Variablen in Java?,"In Java haben Array-Variablen immer Referenzsemantik, unabhängig vom Basistyp. Bei der Zuweisung an die Variable f wird also nur ein Pointer auf das Array übergeben, nicht das gesamte Array als Kopie. Dies hat den Hintergrund, dass Array-Kopieroperationen sehr teuer sind und selten benötigt werden. Eine Zuweisung von f an eine Variable vom Typ Object ist möglich, während eine Zuweisung von f an eine Variable vom Typ Object[] nicht zulässig ist. Arrays sind außer ihrem Basistyp (z.B. float oder Object) nicht weiter definierbar, und es können keine weiteren Eigenschaften (Felder oder Methoden) für einen Array-Typen definiert werden. Für jedes Array ist jedoch die (Pseudo-)Variable length definiert, die die Größe des Arrays (Anzahl der Elemente) angibt. Die Methode clone() aus Object wird für Arrays überschrieben, um ein Objekt gleichen Typs zurückzugeben."
"Interessanterweise haben in Java Array-Variablen immer und unabhängig vom Basistyp Referenzsemantik. Bei der Zuweisung an die Variable f oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer darauf. Dies hat vermutlich den Hintergrund, dass Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Warum auch immer, im Ergebnis kann f an eine Variable vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit auch nicht damit zuweisungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn sie wie Klassen und Interfaces Typen bilden, außer ihrem Basistyp (also beispielsweise float oder Object) keine weiteren Definitionselemente anzugeben erlauben; insbesondere kann man für einen Array-Typen keine weiteren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die (Pseudo-)Variable length definiert, deren Inhalt die Größe des Arrays (Anzahl Elemente) angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.",Warum haben Array-Variablen in Java immer Referenzsemantik?,"Array-Variablen haben in Java immer Referenzsemantik, weil Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Dies hat den Hintergrund, dass bei der Zuweisung an die Variable f lediglich ein Pointer darauf übergeben wird, anstatt ein ganzes Array als Kopie."
"Die bemerkte mangelnde Zuweisungskompatibilität von Object[] und float[] wirft natürlich sofort die Frage auf, ob denn auch die Zuweisung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] unzulässig ist. Wir hatten ja in Abschnitt 29.3 von Kurseinheit 3 am Beispiel zweier Instanzen eines parametrischen Typs bemerkt, dass dies zu einem nicht ganz offensichtlichen Problem führt, das sich analog auf Arrays übertragen lässt. Die Überraschung folgt hier auf den Fuß: Die Zuweisung ist in Java zulässig.","Ist die Zuweisung einer Variablen vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] in Java zulässig?","Ja, die Zuweisung ist in Java zulässig."
"Die bemerkte mangelnde Zuweisungskompatibilität von Object[] und float[] wirft natürlich sofort die Frage auf, ob denn auch die Zuweisung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] unzulässig ist. Wir hatten ja in Abschnitt 29.3 von Kurseinheit 3 am Beispiel zweier Instanzen eines parametrischen Typs bemerkt, dass dies zu einem nicht ganz offensichtlichen Problem führt, das sich analog auf Arrays übertragen lässt. Die Überraschung folgt hier auf den Fuß: Die Zuweisung ist in Java zulässig.","Warum ist die Zuweisung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] zulässig in Java?","In Java ist die Zuweisung einer Variablen vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] zulässig, weil Java eine polymorphe Zuweisung von Arrays erlaubt. Dies bedeutet, dass ein Array-Referenzvariablen jeder Kompatibilitätsebene einen Wert zugewiesen werden kann, der eine Array-Instanz eines beliebigen Subtyps der angegebenen Kompatibilitätsebene ist."
"Warum aber geht man dieses Risiko ein und überträgt die Zuweisungskompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man anschließend schreibend (wie in Zeile 1046) auf das Array zugreift und dann noch mit dem falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen). Da man diese Bedingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein Laufzeittest durchgeführt. Ein klassischer Kompromiss, der diesmal zugunsten der Flexibilität beim Programmieren ausging.",Warum wird auf statische Typprüfung verzichtet und stattdessen eine dynamische Typprüfung mit möglicher Meldung eines Laufzeitfehlers durchgeführt?,"Dies geschieht, um die Möglichkeit der statischen Typprüfung zu vermeiden, die auf Basis mangelnder Typkonformität einen Typfehler bei der Zuweisung melden würde. Stattdessen wird eine dynamische Typprüfung durchgeführt, um die Flexibilität beim Programmieren zu erhöhen, auch wenn dies zu einem Laufzeitfehler führen kann."
"Warum aber geht man dieses Risiko ein und überträgt die Zuweisungskompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man anschließend schreibend (wie in Zeile 1046) auf das Array zugreift und dann noch mit dem falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen). Da man diese Bedingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein Laufzeittest durchgeführt. Ein klassischer Kompromiss, der diesmal zugunsten der Flexibilität beim Programmieren ausging.",Warum wird auf die statische Typprüfung zugunsten einer dynamischen Typprüfung verzichtet?,"Der Verzicht auf die statische Typprüfung zugunsten einer dynamischen Typprüfung wird vorgenommen, um die Möglichkeit der statischen Typprüfung zu verhindern, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung melden würde. Dies geschieht, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies vom Compiler garantiert werden könnte."
"Warum aber geht man dieses Risiko ein und überträgt die Zuweisungskompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man anschließend schreibend (wie in Zeile 1046) auf das Array zugreift und dann noch mit dem falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen). Da man diese Bedingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein Laufzeittest durchgeführt. Ein klassischer Kompromiss, der diesmal zugunsten der Flexibilität beim Programmieren ausging.",Warum wird in diesem Fall auf die statische Typprüfung verzichtet und stattdessen eine dynamische Typprüfung durchgeführt?,"Der Verzicht auf die statische Typprüfung zugunsten einer dynamischen Typprüfung wird vorgenommen, um die Möglichkeit zu haben, Programme zu schreiben, die zwar korrekt sein können, aber von dem Compiler nicht garantiert werden können. Dies geschieht, um die Flexibilität beim Programmieren zu erhöhen. Ein Laufzeittest wird durchgeführt, um sicherzustellen, dass der Typ beim Zugriff auf das Array korrekt ist."
"Warum aber will man Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs und damit Zuweisungen wie die in Zeile 1045 unbedingt haben? Die Antwort ist einfach: weil es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern lediglich nach oben beschränken wollen. So gibt es beispielsweise in Java den Interfacetyp Comparable. Dieser Interfacetyp kann als statischer Typ für Array-Elemente verwendet werden, um Arrays zu definieren, deren Elemente eine beliebige Klasse sind, die das Interface Comparable implementiert.",Wozu dient Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs?,"Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs ist nützlich, wenn es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern nur nach oben beschränken wollen. Zum Beispiel kann der Interfacetyp Comparable<T> als statischer Typ für Array-Elemente verwendet werden, um zu signalisieren, dass die Array-Elemente eine Methode compareTo(T o) implementieren müssen. Die tatsächliche Klasse der Array-Elemente muss diese Methode nicht unbedingt von Comparable<T> erben, sie kann auch eine eigene Klasse sein, die compareTo(T o) implementiert."
"Warum aber will man Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs und damit Zuweisungen wie die in Zeile 1045 unbedingt haben? Die Antwort ist einfach: weil es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern lediglich nach oben beschränken wollen. So gibt es beispielsweise in Java den Interfacetyp Comparable. Dieser Interfacetyp kann als statischer Typ für Array-Elemente verwendet werden, um Arrays zu definieren, deren Elemente eine beliebige Klasse sind, die das Interface Comparable implementiert.",Warum ist Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs wünschenswert?,"Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs ist wünschenswert, weil es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern lediglich nach oben beschränken wollen. So kann eine Prozedur mit einem Array von Objekten aufgerufen werden, die den Typ Comparable<T> implementieren, unabhängig davon, welcher Typ T das ist."
"Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.",Was macht die Methode compareTo?,"Die Methode compareTo vergleicht das Empfänger-Objekt mit dem Parameterobjekt und gibt einen Wert zurück, der angibt, wie der Vergleich ausgegangen ist."
"Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.",Was ist die Aufgabe der Methode sort?,"Die Methode sort sortiert ein Array von Objekten, die das Interface Comparable implementieren."
"Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.",Was ist der Vorteil der dynamischen Typprüfung in Bezug auf die Methode sort?,"Der Vorteil der dynamischen Typprüfung ist, dass sie die Verwendung der Methode sort erlaubt, obwohl das statische Typsystem dies nicht zugelassen hätte. Dadurch wird eine sichere Verwendung ermöglicht."
"Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.",Warum ist die Methode sort faktisch sicher?,"Die Methode sort ist faktisch sicher, weil beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, und daher kein Typfehler von der Art der Zeile 1046 auftreten kann."
"Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.",Warum ist der Kompromiss zwischen statischer und dynamischen Typprüfung vertretbar?,"Der Kompromiss zwischen statischer und dynamischen Typprüfung ist vertretbar, weil er die Verwendung der Methode sort erlaubt, die Arrays beliebiger Elementtypen zum Sortieren annehmen kann, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind."
"Sie kennen vielleicht aus anderen Programmiersprachen, dass Variablen und anderen Programmelementen bei ihrer Deklaration (Kapitel 19) ein Typ zugeordnet wird. Dieser Typ schränkt die möglichen Werte der deklarierten Elemente ein. So lassen sich beispielsweise in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zeichenketten speichern.",Was ist der Zweck der Typisierung in Programmiersprachen?,"Der Zweck der Typisierung in Programmiersprachen ist es, den möglichen Wertebereich von Variablen und anderen Programmelementen einzuschränken. So lassen sich beispielsweise in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zeichenketten speichern."
"Typ ist ein primitiver Begriff, vergleichbar etwa mit dem Begriff der Menge in der Mengentheorie. Ein Typ hat eine Intension und eine Extension, wobei erstere der Definition des Typs entspricht, letztere seinem Wertebereich, also der Menge der Elemente (Objekte), die zu dem Typ gehören (man sagt auch, „die den Typ haben“ oder „die von dem Typ sind“). Häufig hat ein Typ auch einen Namen, den Typbezeichner. Typen sind die Grundlage von Typsystemen.",Was ist ein Typ?,"Ein Typ ist ein primitiver Begriff, der vergleichbar ist mit dem Begriff der Menge in der Mengentheorie. Ein Typ hat eine Intension, die der Definition des Typs entspricht, und eine Extension, die dem Wertebereich entspricht, also der Menge der Elemente, die zu dem Typ gehören. Typen sind die Grundlage von Typsystemen."
"Typ ist ein primitiver Begriff, vergleichbar etwa mit dem Begriff der Menge in der Mengentheorie. Ein Typ hat eine Intension und eine Extension, wobei erstere der Definition des Typs entspricht, letztere seinem Wertebereich, also der Menge der Elemente (Objekte), die zu dem Typ gehören (man sagt auch, „die den Typ haben“ oder „die von dem Typ sind“). Häufig hat ein Typ auch einen Namen, den Typbezeichner. Typen sind die Grundlage von Typsystemen.",Was ist der Unterschied zwischen Intension und Extension eines Typs?,"Die Intension eines Typs entspricht seiner Definition, während die Extension dem Wertebereich des Typs entspricht, also der Menge der Elemente (Objekte), die zu dem Typ gehören."
"Ihnen fällt wahrscheinlich sofort die Ähnlichkeit zum Konstrukt der Klasse, wie es in der letzten Kurseinheit eingeführt wurde, auf. Tatsächlich gibt es hier auch einen Zusammenhang. Um Sie aber nicht gleich in für diese Kurseinheit eher schädliche Denkmuster verfallen zu lassen, soll dieser Zusammenhang zunächst zurückgestellt werden. Eine Aufklärung erfolgt dann in Kapitel 28.",Wie hängen Klassen und temporäre Variablen zusammen?,"Es gibt eine Ähnlichkeit zwischen Klassen und temporären Variablen, die in der letzten Kurseinheit eingeführt wurde. Der Zusammenhang wird in Kapitel 28 aufgeklärt."
"Ihnen fällt wahrscheinlich sofort die Ähnlichkeit zum Konstrukt der Klasse, wie es in der letzten Kurseinheit eingeführt wurde, auf. Tatsächlich gibt es hier auch einen Zusammenhang. Um Sie aber nicht gleich in für diese Kurseinheit eher schädliche Denkmuster verfallen zu lassen, soll dieser Zusammenhang zunächst zurückgestellt werden. Eine Aufklärung erfolgt dann in Kapitel 28.",Was ist der Zusammenhang zwischen Objekt und Klasse?,"Objekt und Klasse sind eng verwandt, aber nicht dasselbe. Eine Klasse ist eine Art Bauplan oder Schablone, die beschreibt, wie ein Objekt aussehen sollte und was es können sollte. Ein Objekt ist eine konkrete Instanz einer Klasse, die einen bestimmten Zustand und ein bestimmtes Verhalten aufweist."
"Ihnen fällt wahrscheinlich sofort die Ähnlichkeit zum Konstrukt der Klasse, wie es in der letzten Kurseinheit eingeführt wurde, auf. Tatsächlich gibt es hier auch einen Zusammenhang. Um Sie aber nicht gleich in für diese Kurseinheit eher schädliche Denkmuster verfallen zu lassen, soll dieser Zusammenhang zunächst zurückgestellt werden. Eine Aufklärung erfolgt dann in Kapitel 28.",Warum sollte der Zusammenhang zwischen Objekt und Klasse zurückgestellt werden?,"Der Zusammenhang zwischen Objekt und Klasse sollte zurückgestellt werden, um den Schülern nicht in Denkmuster zu verfallen, die für das Verständnis der aktuellen Kurseinheit eher schädlich sind. Eine Aufklärung erfolgt dann in Kapitel 28."
"Ein Typsystem umfasst Typausdrücke, Objekt- oder Wertausdrücke, Regeln, die Wertausdrücken Typen zuordnen, und Regeln, die von Wertausdrücken einzuhalten sind (zusammen die Typregeln). Wertausdrücke (bzw. schlicht Ausdrücke, wenn es nicht um die Abgrenzung von Typausdrücken geht) kennen Sie schon: In SMALLTALK sind es die in Kurseinheit 1, Kapitel 4.1 aufgeführten. Mit den anderen Konzepten werden Sie in den nachfolgenden Kapiteln vertraut gemacht, allerdings in weniger formaler Form, als Sie das nach dieser Definition vielleicht befürchten.",Was ist ein Typsystem?,"Ein Typsystem umfasst Typausdrücke, Objekt- oder Wertausdrücke, Regeln, die Wertausdrücken Typen zuordnen, und Regeln, die von Wertausdrücken einzuhalten sind(zusammen die Typregeln)."
Warum aber typisiert man Variablen und andere Programmelemente? Dafür gibt es mindestens vier gute Gründe: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm.,Welche Vorteile bietet die Typisierung von Variablen und anderen Programmelementen?,"Typisierung regelt das Speicher-Layout, erlaubt die effizientere Ausführung eines Programms, erhöht die Lesbarkeit eines Programms und ermöglicht das automatische Finden von logischen Fehlern in einem Programm."
"Zu 1.: Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss. Dies ist jedoch naturgemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Programmierung, insbesondere für Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung.",Wie bestimmt der Compiler den Speicherbedarf für Variablen?,"Der Compiler kann anhand des Typs einer Variablen bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss."
"Zu 1.: Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss. Dies ist jedoch naturgemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Programmierung, insbesondere für Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung.",Wofür ist der Typ einer Variablen in der objektorientierten Programmierung relevant?,"In der objektorientierten Programmierung ist der Typ einer Variablen nur für Variablen mit Wertsemantik relevant, was jedoch in Sprachen wie SMALLTALK, in denen Referenzsemantik vorherrscht, von untergeordneter Bedeutung ist."
"Zu 1.: Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss. Dies ist jedoch naturgemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Programmierung, insbesondere für Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung.",Warum ist der Typ einer Variablen für die objektorientierte Programmierung von untergeordneter Bedeutung?,"In der objektorientierten Programmierung, insbesondere in Sprachen wie SMALLTALK, ist Referenzsemantik vorherrschend. Daher ist der Typ einer Variablen nicht so wichtig, da der Compiler nicht anhand des Typs bestimmen kann, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss. Stattdessen wird der Speicherplatz für die Aufnahme eines Objektwertes zur Laufzeit bestimmt."
"Zu 2.: Wenn man weiß, dass die Werte einer Variable immer vom selben Typ sind, also alle demselben Wertebereich entstammen, dann lassen sich bestimmte Optimierungen durchführen. Wenn man z. B. aufgrund der Deklaration einer Variable x für gegeben annehmen kann, dass x nur ganze Zahlen enthält, dann kann der Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkrement-Anweisung des Prozessors verwenden. Kennt der Compiler den Typ von x hingegen nicht, dann muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist — handelt es sich um eine Fließkommazahl, so muss es zu der entsprechenden Operation verzweigen, handelt es sich womöglich um gar keine Zahl, dann muss es einen Laufzeitfehler signalisieren oder sich etwas anderes einfallen lassen. Dem kann man entgegenhalten, dass im Falle der objektorientierten Programmierung selbst bei einer Typisierung aller Variablen gelegentlich noch Laufzeittests durchgeführt (oder andernfalls schwere Programmfehler in Kauf genommen) werden müssen, und dass sich die zur Optimierung benötigte Information auch anders als über explizite Typisierung von Variablen (z. B. über die sog. Typinferenz, also die Ausnutzung impliziter Typinformation) gewinnen lässt.",Was ist der Vorteil einer expliziten Typisierung von Variablen?,"Wenn man weiß, dass die Werte einer Variable immer vom selben Typ sind, also alle demselben Wertebereich entstammen, dann lassen sich bestimmte Optimierungen durchführen. Zum Beispiel kann der Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkrement-Anweisung des Prozessors verwenden."
"Zu 2.: Wenn man weiß, dass die Werte einer Variable immer vom selben Typ sind, also alle demselben Wertebereich entstammen, dann lassen sich bestimmte Optimierungen durchführen. Wenn man z. B. aufgrund der Deklaration einer Variable x für gegeben annehmen kann, dass x nur ganze Zahlen enthält, dann kann der Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkrement-Anweisung des Prozessors verwenden. Kennt der Compiler den Typ von x hingegen nicht, dann muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist — handelt es sich um eine Fließkommazahl, so muss es zu der entsprechenden Operation verzweigen, handelt es sich womöglich um gar keine Zahl, dann muss es einen Laufzeitfehler signalisieren oder sich etwas anderes einfallen lassen. Dem kann man entgegenhalten, dass im Falle der objektorientierten Programmierung selbst bei einer Typisierung aller Variablen gelegentlich noch Laufzeittests durchgeführt (oder andernfalls schwere Programmfehler in Kauf genommen) werden müssen, und dass sich die zur Optimierung benötigte Information auch anders als über explizite Typisierung von Variablen (z. B. über die sog. Typinferenz, also die Ausnutzung impliziter Typinformation) gewinnen lässt.","Warum ist es vorteilhaft, wenn man den Typ einer Variablen kennt?","Wenn man den Typ einer Variablen kennt, kann der Compiler bestimmte Optimierungen durchführen, wie z.B. die Ganzzahladdition oder die Inkrement-Anweisung des Prozessors verwenden. Wenn der Compiler den Typ nicht kennt, muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist, was zu Laufzeitverzögerungen führen kann."
"Zu 3.: In der Vergangenheit hatten Variablen eher kurze, wenig selbsterklärende Namen (vgl. dazu auch Kapitel 62 in Kurseinheit 7). Es ist dann sinnvoll, wenigstens an der Stelle der ersten Erwähnung der Variablen (in der Regel deren Deklaration) einen Hinweis darauf zu haben, wofür (für welche Menge von Objekten) die Variable steht. Dies kann über einen Kommentar erfolgen, aber auch durch die Assoziation mit einem Typen, die aussagt, welcher Art die Werte der Variable sein müssen. Doch nicht nur Variablen-, auch Methodennamen können für sich genommen wenig aussagekräftig sein und durch die Verknüpfung mit Typen aussagekräftiger gemacht werden: Eine Deklaration der Methode next etwa, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, legt nahe, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren. Dem mag man freilich entgegenhalten, dass man stattdessen ja auch selbsterklärende Namen für Variablen und Methoden vergeben könnte (mehr dazu in Kurseinheit 7, Kapitel 62).","Warum ist es sinnvoll, temporären Variablen einen Hinweis auf den Typ der Werte zu geben?","Es ist sinnvoll, temporären Variablen einen Hinweis auf den Typ der Werte zu geben, um die Lesbarkeit des Codes zu verbessern und die Funktion der Variablen für die Nutzerin der Funktion, die die Implementation nicht kennt, transparenter zu gestalten."
"Zu 3.: In der Vergangenheit hatten Variablen eher kurze, wenig selbsterklärende Namen (vgl. dazu auch Kapitel 62 in Kurseinheit 7). Es ist dann sinnvoll, wenigstens an der Stelle der ersten Erwähnung der Variablen (in der Regel deren Deklaration) einen Hinweis darauf zu haben, wofür (für welche Menge von Objekten) die Variable steht. Dies kann über einen Kommentar erfolgen, aber auch durch die Assoziation mit einem Typen, die aussagt, welcher Art die Werte der Variable sein müssen. Doch nicht nur Variablen-, auch Methodennamen können für sich genommen wenig aussagekräftig sein und durch die Verknüpfung mit Typen aussagekräftiger gemacht werden: Eine Deklaration der Methode next etwa, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, legt nahe, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren. Dem mag man freilich entgegenhalten, dass man stattdessen ja auch selbsterklärende Namen für Variablen und Methoden vergeben könnte (mehr dazu in Kurseinheit 7, Kapitel 62).","Warum ist es sinnvoll, Variablen und Methoden mit Typen zu assoziieren?","Es ist sinnvoll, Variablen und Methoden mit Typen zu assoziieren, um die Bedeutung der Variablen und Methoden für den Nutzer zu verdeutlichen. Zum Beispiel kann eine Deklaration der Methode next, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, nahelegen, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren."
"Es bleibt aber in jedem Fall Punkt 4, das Aufdecken von logischen Fehlern in einem Programm. Ohne externes Wissen, was ein Programm tun soll, verlangt das Finden von Fehlern jedoch ein gewisses Maß an Redundanz, also die mehrfache Lieferung gleicher Information, im Programm, denn nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen logischen Programmierfehler hinweisen. Die Verknüpfung von deklarierten Elementen mit Typen erlaubt aber genau die Angabe solcher redundanter Information. Die Schaffung dieser Redundanz verlangt jedoch vermehrte Denk- und Schreibarbeit und ist zudem auch noch, im Falle eines fehlerfreien Programms, überflüssig. Dem kann man allerdings entgegenhalten, dass kaum eine Programmiererin auf Anhieb korrekte Programme schreibt, und wenn eine Typisierung Fehler zu finden in der Lage ist und somit nicht minder aufwendige Tests ersetzt, dann ist das natürlich gut.",Warum kann die Verknüpfung von deklarierten Elementen mit Typen hilfreich sein?,"Die Verknüpfung von deklarierten Elementen mit Typen erlaubt die Angabe redundanter Information im Programm, was das Aufdecken von logischen Fehlern ermöglichen kann. Die Schaffung dieser Redundanz verlangt jedoch vermehrte Denk- und Schreibarbeit und ist zudem auch noch überflüssig, wenn das Programm fehlerfrei ist. Allerdings kann eine Typisierung Fehler finden und somit nicht minder aufwendige Tests ersetzen."
"Es bleibt aber in jedem Fall Punkt 4, das Aufdecken von logischen Fehlern in einem Programm. Ohne externes Wissen, was ein Programm tun soll, verlangt das Finden von Fehlern jedoch ein gewisses Maß an Redundanz, also die mehrfache Lieferung gleicher Information, im Programm, denn nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen logischen Programmierfehler hinweisen. Die Verknüpfung von deklarierten Elementen mit Typen erlaubt aber genau die Angabe solcher redundanter Information. Die Schaffung dieser Redundanz verlangt jedoch vermehrte Denk- und Schreibarbeit und ist zudem auch noch, im Falle eines fehlerfreien Programms, überflüssig. Dem kann man allerdings entgegenhalten, dass kaum eine Programmiererin auf Anhieb korrekte Programme schreibt, und wenn eine Typisierung Fehler zu finden in der Lage ist und somit nicht minder aufwendige Tests ersetzt, dann ist das natürlich gut.",Wozu dient die Verknüpfung von deklarierten Elementen mit Typen?,"Die Verknüpfung von deklarierten Elementen mit Typen erlaubt die Angabe redundanter Information im Programm, was das Aufdecken von logischen Fehlern erleichtert. Denn nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen logischen Programmierfehler hinweisen."
"Es bleibt aber in jedem Fall Punkt 4, das Aufdecken von logischen Fehlern in einem Programm. Ohne externes Wissen, was ein Programm tun soll, verlangt das Finden von Fehlern jedoch ein gewisses Maß an Redundanz, also die mehrfache Lieferung gleicher Information, im Programm, denn nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen logischen Programmierfehler hinweisen. Die Verknüpfung von deklarierten Elementen mit Typen erlaubt aber genau die Angabe solcher redundanter Information. Die Schaffung dieser Redundanz verlangt jedoch vermehrte Denk- und Schreibarbeit und ist zudem auch noch, im Falle eines fehlerfreien Programms, überflüssig. Dem kann man allerdings entgegenhalten, dass kaum eine Programmiererin auf Anhieb korrekte Programme schreibt, und wenn eine Typisierung Fehler zu finden in der Lage ist und somit nicht minder aufwendige Tests ersetzt, dann ist das natürlich gut.",Warum erlaubt die Verknüpfung von deklarierten Elementen mit Typen die Angabe redundanter Information?,"Die Verknüpfung von deklarierten Elementen mit Typen erlaubt die Angabe redundanter Information, weil sie eine zusätzliche Information über die Variablen und Funktionen bereitstellt, die in der Programmlogik selbst nicht zwingend erforderlich ist. Diese zusätzliche Information kann dazu beitragen, logische Fehler im Programm zu entdecken, indem sie Widersprüche aufzeigt."
"Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der heute üblichen Typsysteme ist übrigens die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt.",Was ist ein Vorteil von Typsystemen?,"Ein Vorteil von Typsystemen ist die dadurch entstehende Modularisierung von Programmen, wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt."
"Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der heute üblichen Typsysteme ist übrigens die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt.",Was ist ein weiterer Grund für die Verwendung von Typsystemen?,"Ein weiterer Grund für die Verwendung von Typsystemen ist die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt."
"Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der heute üblichen Typsysteme ist übrigens die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt.",Was ist die Aufgabe des Verhaltens eines Objekts?,"Das Verhalten eines Objekts ist dafür verantwortlich, den Zustand des Objekts zu ändern und somit Zustandsänderungen eines Objekts herbeizuführen."
"Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der heute üblichen Typsysteme ist übrigens die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt.",Warum hängt das Verhalten eines Objekts von seinem Zustand ab?,"Das Verhalten eines Objekts hängt in der Regel von seinem Zustand ab, weil der Zustand eines Objekts die Informationen enthält, die benötigt werden, um die richtigen Entscheidungen zu treffen und die entsprechenden Aktionen auszuführen. Das Verhalten eines Objekts basiert auf den Daten in seinem Zustand, und diese Daten beeinflussen, wie das Objekt auf Nachrichten reagiert."
"Die der Fehlerentdeckung mittels Typsystemen zugrundeliegende These ist, dass ein guter Teil logischer Programmierfehler bereits frühzeitig daran erkannt werden kann, dass eine Variable einen Wert hat, den sie eigentlich niemals haben dürfte. So zeugt beispielsweise von einem Fehler, wenn einer Variable, die für Zahlen gedacht war, eine Zeichenkette zugewiesen wird. Wenn dann nämlich einem Ausdruck mit einer arithmetischen Operation, die Zahlen als Operanden verlangt, eine solchermaßen fehlbelegte Variable zugeführt wird, kann dieser nicht ausgewertet werden. Ohne Typprüfung würde dieser Fehler erst zur Laufzeit, also wenn der Ausdruck tatsächlich ausgewertet werden soll, in Erscheinung treten und hätte dann in aller Regel einen Programmabbruch zur Folge. Man nennt einen solchen Programmierfehler einen Typfehler.",Was ist die Aufgabe von Typsystemen in der Fehlerentdeckung?,"Die Aufgabe von Typsystemen in der Fehlerentdeckung ist es, einen Teil logischer Programmierfehler frühzeitig zu erkennen, indem sie prüfen, ob eine Variable einen Wert hat, den sie eigentlich niemals haben dürfte. Zum Beispiel wird ein Fehler erkannt, wenn einer Variable, die für Zahlen gedacht ist, eine Zeichenkette zugewiesen wird."
"Die der Fehlerentdeckung mittels Typsystemen zugrundeliegende These ist, dass ein guter Teil logischer Programmierfehler bereits frühzeitig daran erkannt werden kann, dass eine Variable einen Wert hat, den sie eigentlich niemals haben dürfte. So zeugt beispielsweise von einem Fehler, wenn einer Variable, die für Zahlen gedacht war, eine Zeichenkette zugewiesen wird. Wenn dann nämlich einem Ausdruck mit einer arithmetischen Operation, die Zahlen als Operanden verlangt, eine solchermaßen fehlbelegte Variable zugeführt wird, kann dieser nicht ausgewertet werden. Ohne Typprüfung würde dieser Fehler erst zur Laufzeit, also wenn der Ausdruck tatsächlich ausgewertet werden soll, in Erscheinung treten und hätte dann in aller Regel einen Programmabbruch zur Folge. Man nennt einen solchen Programmierfehler einen Typfehler.",Was ist der Zweck von Typsystemen in der Fehlerentdeckung?,"Typsysteme in der Fehlerentdeckung zielen darauf ab, einen Teil logischer Programmierfehler frühzeitig zu erkennen, indem sie Variablen daran hindern, Werte anzunehmen, die sie eigentlich nicht haben dürften. Dies hilft, Fehler zu vermeiden, die erst zur Laufzeit auftreten und in der Regel einen Programmabbruch verursachen. Diese Art von Fehlern werden als Typfehler bezeichnet."
"Während ein Programmabbruch wenigstens noch eine erkennbare Reaktion auf einen Programmierfehler darstellt, ist es fast noch schlimmer, wenn ein logischer Fehler ohne solche bleibt. So kann es beispielsweise vorkommen, dass man einer Variable, deren Inhalt eine Strecke darstellen soll, eine andere zuweist, deren Inhalt eine Zeit repräsentiert. Mit beiden ließe sich gleich rechnen (dieselben Rechenoperationen durchführen), aber das Ergebnis wäre vermutlich falsch. Merken muss man das allerdings selbst, denn das Programm läuft einfach weiter.",Was ist ein logischer Fehler in einem Programm?,"Ein logischer Fehler in einem Programm ist ein Fehler, bei dem das Programm zwar fehlerfrei läuft, aber das Ergebnis falsch ist. Im Gegensatz zu einem Programmabbruch, der auf einen Programmierfehler hinweist, bleibt ein logischer Fehler oft unbemerkt."
"Während ein Programmabbruch wenigstens noch eine erkennbare Reaktion auf einen Programmierfehler darstellt, ist es fast noch schlimmer, wenn ein logischer Fehler ohne solche bleibt. So kann es beispielsweise vorkommen, dass man einer Variable, deren Inhalt eine Strecke darstellen soll, eine andere zuweist, deren Inhalt eine Zeit repräsentiert. Mit beiden ließe sich gleich rechnen (dieselben Rechenoperationen durchführen), aber das Ergebnis wäre vermutlich falsch. Merken muss man das allerdings selbst, denn das Programm läuft einfach weiter.",Was sind die Folgen eines logischen Fehlers in einem Programm?,"Ein logischer Fehler in einem Programm kann dazu führen, dass das Programm weiterläuft, aber das Ergebnis falsch ist. Es ist schwieriger zu erkennen als ein Programmabbruch, da keine erkennbare Reaktion auf einen Programmierfehler stattfindet."
"Während ein Programmabbruch wenigstens noch eine erkennbare Reaktion auf einen Programmierfehler darstellt, ist es fast noch schlimmer, wenn ein logischer Fehler ohne solche bleibt. So kann es beispielsweise vorkommen, dass man einer Variable, deren Inhalt eine Strecke darstellen soll, eine andere zuweist, deren Inhalt eine Zeit repräsentiert. Mit beiden ließe sich gleich rechnen (dieselben Rechenoperationen durchführen), aber das Ergebnis wäre vermutlich falsch. Merken muss man das allerdings selbst, denn das Programm läuft einfach weiter.",Was ist ein Programmabbruch und was ist ein logischer Fehler?,"Ein Programmabbruch ist ein Fehler, der zu einer erkennbaren Reaktion führt, während ein logischer Fehler ein Fehler ist, der ohne solche Reaktion weiterläuft. Ein Beispiel für einen logischen Fehler ist das versehentliche Zuweisen einer falschen Variablen, die zwar gleich rechnen lässt, aber das Ergebnis falsch macht."
"Man kann Variablenfehlbelegungen dieser Art verhindern, indem man Variablen mit expliziten Typinvarianten versieht, die die Menge ihrer zulässigen Werte beschränken, und dann darüber wacht, dass diese Invarianten immer eingehalten werden. Eine besonders einfache Möglichkeit, solche Invarianten zu spezifizieren, erlauben sogenannte Typannotationen, also die Verbindung einer Variable mit einem Typen, wobei der Typ eine Menge von Werten festlegt, die die Variable ausschließlich haben darf. In typisierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Variablendeklaration; in nicht oder nur optional typisierten Sprachen kann sie auch (für einzelne oder alle Variablen) hergeleitet (inferiert; die Typinferenz) werden und ist dann implizit.",Was sind Typinvarianten?,"Typinvarianten sind eine Möglichkeit, Variablenfehlbelegungen zu verhindern. Sie beschränken die Menge der zulässigen Werte einer Variablen. In typisierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Variablendeklaration. In nicht oder nur optional typisierten Sprachen kann sie auch hergeleitet (inferiert) werden."
"Man kann Variablenfehlbelegungen dieser Art verhindern, indem man Variablen mit expliziten Typinvarianten versieht, die die Menge ihrer zulässigen Werte beschränken, und dann darüber wacht, dass diese Invarianten immer eingehalten werden. Eine besonders einfache Möglichkeit, solche Invarianten zu spezifizieren, erlauben sogenannte Typannotationen, also die Verbindung einer Variable mit einem Typen, wobei der Typ eine Menge von Werten festlegt, die die Variable ausschließlich haben darf. In typisierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Variablendeklaration; in nicht oder nur optional typisierten Sprachen kann sie auch (für einzelne oder alle Variablen) hergeleitet (inferiert; die Typinferenz) werden und ist dann implizit.",Was sind Typannotationen?,"Typannotationen sind eine Möglichkeit, Variablen mit expliziten Typinvarianten zu versehen, die die Menge ihrer zulässigen Werte beschränken. Sie werden in typisierten Programmiersprachen explizit und zwingend bei der Variablendeklaration angegeben, während sie in nicht oder nur optional typisierten Sprachen hergeleitet und implizit sein können."
"Ein Programm, in dem alle Variablenbelegungen immer alle Typinvarianten erfüllen, heißt typkorrekt. In einer Sprache, die durch ihr Typsystem Typkorrektheit festzustellen erlaubt, nennt man die logischen Fehler, die sich in unzulässigen Wertzuweisungen ausdrücken, auch semantische Fehler (und zwar, weil der Inhalt eines Programmelements nicht seiner intendierten Bedeutung entspricht). Dabei ist die Semantik des Programmelements im Programm zweimal, auf redundante, aber unterschiedliche Art, spezifiziert: in Form seines Typs und in Form seiner tatsächlichen Verwendung (festgelegt durch Zuweisungen und Methodenaufrufe). Lässt sich aus beiden ein Widerspruch ableiten, muss eine von beiden falsch gewesen sein.",Was sind semantische Fehler in einem Programm?,"Semantische Fehler in einem Programm sind logische Fehler, die sich in unzulässigen Wertzuweisungen ausdrücken. Sie entstehen, wenn die tatsächliche Verwendung eines Programmelements nicht seiner intendierten Bedeutung entspricht, die im Typ des Programmelements spezifiziert ist."
"Der einzige Weg, eine mit der Typisierung einer Variable ausgedrückte Invariante zu verletzen, also Typinkorrektheit herzustellen, ist per Wertzuweisung an die Variable. Ein Typsystem muss also lediglich alle Wertzuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu zählen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen, die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind. Im Folgenden heißen Zuweisungen und Methodenaufrufe, die nicht zu typinkorrekten Programmen führen können, zulässig.",Was ist das Typsystem?,"Das Typsystem ist ein Mechanismus, der überprüft, ob eine Wertzuweisung an eine Variable die Typinvarianz verletzt und somit zu semantischen Fehlern führt. Es muss alle Wertzuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu garantieren, einschließlich impliziter Zuweisungen bei Methodenaufrufen."
"Der einzige Weg, eine mit der Typisierung einer Variable ausgedrückte Invariante zu verletzen, also Typinkorrektheit herzustellen, ist per Wertzuweisung an die Variable. Ein Typsystem muss also lediglich alle Wertzuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu zählen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen, die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind. Im Folgenden heißen Zuweisungen und Methodenaufrufe, die nicht zu typinkorrekten Programmen führen können, zulässig.",Was ist der Zweck eines Typsystems in der Programmierung?,"Ein Typsystem in der Programmierung überprüft alle Wertzuweisungen in einem Programm, um Freiheit von semantischen Fehlern zu garantieren. Dazu zählen auch die impliziten Zuweisungen bei Methodenaufrufen, die wegen des dynamischen Bindens nicht immer offensichtlich sind."
"Der einzige Weg, eine mit der Typisierung einer Variable ausgedrückte Invariante zu verletzen, also Typinkorrektheit herzustellen, ist per Wertzuweisung an die Variable. Ein Typsystem muss also lediglich alle Wertzuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu zählen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen, die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind. Im Folgenden heißen Zuweisungen und Methodenaufrufe, die nicht zu typinkorrekten Programmen führen können, zulässig.","Was ist der einzige Weg, eine mit der Typisierung einer Variablen ausgedrückte Invariante zu verletzen?","Der einzige Weg, eine mit der Typisierung einer Variablen ausgedrückte Invariante zu verletzen, ist per Wertzuweisung an die Variable."
"Nun kann man sich vorstellen, dass es für einen Compiler selbst in einfachen Fällen nicht leicht ist, festzustellen, ob eine Wertzuweisung eine Invariante verletzt und somit zu einem typinkorrekten Programm führt. So ist das folgende STRONGTALK-Programmfragment das zunächst eine temporäre Variable i mit dem Typ Integer (in STRONGTALK wird die Typannotation hinter der Variable in spitzen Klammern angeführt) deklariert und ihr dann, in einer Folge von Anweisungen, zunächst 0 und dann 1 (beides Werte vom Typ Integer) zuweist, zwar typkorrekt im Sinne obiger Definition, aber um das zu erschließen, muss man schon wissen, dass die Bedingung in Zeile 835 immer erfüllt ist, der False-Zweig, der zu einer Verletzung der Invariante von i (nämlich dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen) führen würde, also nie ausgeführt wird. Im gegebenen Fall ist das zwar offensichtlich (und bereits von einer recht einfachen Programmanalyse feststellbar), aber es lassen sich auch Fälle konstruieren, in denen eine automatische Programmanalyse streiken muss.",Was ist eine temporäre Variable in STRONGTALK?,"In STRONGTALK ist eine temporäre Variable eine Variable, die für eine Methode deklariert wird und nur für die Dauer der Ausführung der Methode existiert. Sie wird vom System nach Beendigung der Methode entfernt und die Werte sind außerhalb der Methode nicht sichtbar. Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben. Im Gegensatz zu anderen Programmiersprachen müssen temporäre Variablen in STRONGTALK mit ihrem Typ annotiert werden."
"Nun kann man sich vorstellen, dass es für einen Compiler selbst in einfachen Fällen nicht leicht ist, festzustellen, ob eine Wertzuweisung eine Invariante verletzt und somit zu einem typinkorrekten Programm führt. So ist das folgende STRONGTALK-Programmfragment das zunächst eine temporäre Variable i mit dem Typ Integer (in STRONGTALK wird die Typannotation hinter der Variable in spitzen Klammern angeführt) deklariert und ihr dann, in einer Folge von Anweisungen, zunächst 0 und dann 1 (beides Werte vom Typ Integer) zuweist, zwar typkorrekt im Sinne obiger Definition, aber um das zu erschließen, muss man schon wissen, dass die Bedingung in Zeile 835 immer erfüllt ist, der False-Zweig, der zu einer Verletzung der Invariante von i (nämlich dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen) führen würde, also nie ausgeführt wird. Im gegebenen Fall ist das zwar offensichtlich (und bereits von einer recht einfachen Programmanalyse feststellbar), aber es lassen sich auch Fälle konstruieren, in denen eine automatische Programmanalyse streiken muss.",Was ist eine Invariante?,"Eine Invariante ist eine Bedingung, die während der Ausführung eines Programms immer erfüllt sein muss. Im gegebenen Beispiel ist die Invariante von i, dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen."
"Was man jedoch immer tun kann, um Typkorrektheit zu gewährleisten, ist, dass man zur Laufzeit vor einer Variablenzuweisung prüft, ob der zuzuweisende Wert den von der Variable geforderten Typ hat. Diese sogenannte dynamische Typprüfung (engl. dynamic type checking) hat jedoch den entscheidenden Nachteil, dass sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes machen kann als einen Fehler zu signalisieren (der dann günstigenfalls durch eine dafür vorgesehene Fehlerbehandlungsmethode aufgefangen wird, der aber in der Praxis häufig nur zu einem Programmabbruch führt). Man kann jedoch argumentieren, dass auch letzteres immer noch besser ist, als mit falschen Werten weiterzuarbeiten und damit entweder einen Programmabbruch an einer anderen Stelle, die nicht mehr so leicht mit der fehlerhaften Wertzuweisung in Zusammenhang zu bringen ist, in Kauf zu nehmen oder gar einen logischen Fehler, der überhaupt nicht erkannt wird.",Was ist dynamische Typprüfung?,"Dynamische Typprüfung ist eine Methode zur Gewährleistung von Typkorrektheit, bei der zur Laufzeit vor einer Variablenzuweisung geprüft wird, ob der zuzuweisende Wert den von der Variablen geforderten Typ hat. Der Nachteil ist, dass diese Prüfung zu spät kommt und häufig nur zu einem Programmabbruch führt."
"Was man jedoch immer tun kann, um Typkorrektheit zu gewährleisten, ist, dass man zur Laufzeit vor einer Variablenzuweisung prüft, ob der zuzuweisende Wert den von der Variable geforderten Typ hat. Diese sogenannte dynamische Typprüfung (engl. dynamic type checking) hat jedoch den entscheidenden Nachteil, dass sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes machen kann als einen Fehler zu signalisieren (der dann günstigenfalls durch eine dafür vorgesehene Fehlerbehandlungsmethode aufgefangen wird, der aber in der Praxis häufig nur zu einem Programmabbruch führt). Man kann jedoch argumentieren, dass auch letzteres immer noch besser ist, als mit falschen Werten weiterzuarbeiten und damit entweder einen Programmabbruch an einer anderen Stelle, die nicht mehr so leicht mit der fehlerhaften Wertzuweisung in Zusammenhang zu bringen ist, in Kauf zu nehmen oder gar einen logischen Fehler, der überhaupt nicht erkannt wird.",Was ist der Nachteil der dynamischen Typprüfung?,"Der Nachteil der dynamischen Typprüfung ist, dass sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes machen kann als einen Fehler zu signalisieren."
"Man beachte übrigens, dass nach diesem Kriterium SMALLTALK — entgegen häufig zu lesenden Behauptungen — keine dynamische Typprüfung durchführt, da Typfehler erst im letztmöglichen Moment offenbar werden, nämlich wenn auf einer Variable eine Methode aufgerufen werden soll, die für das Objekt, auf das die Variable verweist, gar nicht definiert ist. Um das zu verhindern, findet man in SMALLTALK-Code gelegentlich Figuren wie (SMALLTALK EXPRESS entnommen). Dies entspricht natürlich genau einer dynamischen Typprüfung, nur dass hier Typ durch Klasse ersetzt wurde und die Prüfung eben nicht automatisch durch ein Laufzeittypsystem erfolgt, sondern ausprogrammiert werden muss.",Führt SMALLTALK dynamische Typprüfung durch?,"Nein, SMALLTALK führt keine dynamische Typprüfung durch. Typfehler werden erst im letztmöglichen Moment offenbar, wenn auf einer Variablen eine Methode aufgerufen werden soll, die für das Objekt, auf das die Variable verweist, gar nicht definiert ist."
"Man beachte übrigens, dass nach diesem Kriterium SMALLTALK — entgegen häufig zu lesenden Behauptungen — keine dynamische Typprüfung durchführt, da Typfehler erst im letztmöglichen Moment offenbar werden, nämlich wenn auf einer Variable eine Methode aufgerufen werden soll, die für das Objekt, auf das die Variable verweist, gar nicht definiert ist. Um das zu verhindern, findet man in SMALLTALK-Code gelegentlich Figuren wie (SMALLTALK EXPRESS entnommen). Dies entspricht natürlich genau einer dynamischen Typprüfung, nur dass hier Typ durch Klasse ersetzt wurde und die Prüfung eben nicht automatisch durch ein Laufzeittypsystem erfolgt, sondern ausprogrammiert werden muss.",Was ist dynamische Typprüfung und warum wird sie in Smalltalk nicht durchgeführt?,"Dynamische Typprüfung ist eine Technik, bei der die Typen der Variablen zur Laufzeit überprüft werden, um sicherzustellen, dass sie mit den erwarteten Typen übereinstimmen. In Smalltalk wird diese Art von Prüfung nicht automatisch durchgeführt, da Typfehler erst im letzten Moment offenbar werden, wenn auf einer Variablen eine Methode aufgerufen wird, die für das Objekt, auf das die Variable verweist, gar nicht definiert ist. Stattdessen muss die Prüfung ausprogrammiert werden, wie in dem Beispiel (SMALLTALK EXPRESS entnommen) gezeigt wird, bei dem Typ durch Klasse ersetzt wurde."
"Eine Typisierung findet in SMALLTALK gar nicht, auch nicht zur Laufzeit, statt. Außerdem ist mit dynamischer Typisierung in der Regel dynamische Typprüfung gemeint. Was ein dynamischer Typ sein soll, ist auch gar nicht klar. dynamische",Gibt es in SMALLTALK eine Typisierung?,"Nein, in SMALLTALK gibt es keine Typisierung, weder statisch noch dynamisch."
"Eine Typisierung findet in SMALLTALK gar nicht, auch nicht zur Laufzeit, statt. Außerdem ist mit dynamischer Typisierung in der Regel dynamische Typprüfung gemeint. Was ein dynamischer Typ sein soll, ist auch gar nicht klar. dynamische",Was ist dynamische Typisierung?,"Dynamische Typisierung ist die Tatsache, dass der Typ eines Objekts zur Laufzeit bekannt ist. Im Gegensatz zur statischen Typisierung, bei der der Typ zur Übersetzungszeit bekannt ist."
"Sehr viel nützlicher als die dynamische Typprüfung ist die statische Typprüfung, bei der, trotz aller theoretischen Hindernisse, die Typkorrektheit zur Übersetzungszeit gewährleistet werden soll. Die Typprüfung ist damit Aufgabe des Compilers und nicht, wie im Fall der dynamischen Typprüfung, Aufgabe des Laufzeitsystems oder gar der Programmiererin. Wie wir schon gesehen haben, bedeutet dies nicht weniger, als einen Beweis zu führen, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird. In der Praxis bedeutet dies aber, dass eine rein statische Typprüfung immer auch Programme zurückweist, die nützlich, sinnvoll und typkorrekt sind (s. obiges Beispiel der Zeilen",Was ist statische Typprüfung?,"Die statische Typprüfung ist ein Verfahren, bei dem die Typkorrektheit eines Programms bereits während der Übersetzungszeit geprüft wird. Im Gegensatz zur dynamischen Typprüfung, die zur Laufzeit erfolgt, wird bei der statischen Typprüfung der Beweis erbracht, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird."
"Sehr viel nützlicher als die dynamische Typprüfung ist die statische Typprüfung, bei der, trotz aller theoretischen Hindernisse, die Typkorrektheit zur Übersetzungszeit gewährleistet werden soll. Die Typprüfung ist damit Aufgabe des Compilers und nicht, wie im Fall der dynamischen Typprüfung, Aufgabe des Laufzeitsystems oder gar der Programmiererin. Wie wir schon gesehen haben, bedeutet dies nicht weniger, als einen Beweis zu führen, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird. In der Praxis bedeutet dies aber, dass eine rein statische Typprüfung immer auch Programme zurückweist, die nützlich, sinnvoll und typkorrekt sind (s. obiges Beispiel der Zeilen",Was ist der Unterschied zwischen dynamischer und statischer Typprüfung?,"Dynamische Typprüfung findet zur Laufzeit eines Programms statt und wird vom Laufzeitsystem oder der Programmiererin durchgeführt, während statische Typprüfung zur Übersetzungszeit stattfindet und vom Compiler durchgeführt wird. Statische Typprüfung stellt sicher, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird, während dynamische Typprüfung dies zur Laufzeit überprüft. Statische Typprüfung ist nützlicher als dynamische Typprüfung, lehnt aber auch Programme ab, die nützlich, sinnvoll und typkorrekt sind."
"Zwar kann man versuchen, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen, aber wie man sich leicht vorstellen kann, wird mit steigender Genauigkeit das dazu notwendige Typsystem immer aufwendiger und schwieriger zu benutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken soll (so dass man bei auftretenden Typfehlern erst einmal prüfen muss, ob die Ursache tatsächlich in einem fehlerhaften Programm oder vielleicht nur in fehlerhaften Typannotationen liegt).","Was passiert, wenn das Typsystem eines Programms zu kompliziert wird?","Wenn das Typsystem eines Programms zu kompliziert wird, wird es schwieriger zu benutzen und kann sogar so kompliziert sein wie das Programm, dessen Fehler es entdecken soll. In diesem Fall muss man bei auftretenden Typfehlern prüfen, ob die Ursache in einem fehlerhaften Programm oder in fehlerhaften Typannotationen liegt."
"Zwar kann man versuchen, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen, aber wie man sich leicht vorstellen kann, wird mit steigender Genauigkeit das dazu notwendige Typsystem immer aufwendiger und schwieriger zu benutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken soll (so dass man bei auftretenden Typfehlern erst einmal prüfen muss, ob die Ursache tatsächlich in einem fehlerhaften Programm oder vielleicht nur in fehlerhaften Typannotationen liegt).","Was passiert, wenn man versucht, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen?","Wenn man versucht, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen, wird das dazu notwendige Typsystem immer aufwendiger und schwieriger zu benutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken soll. In diesem Fall muss man bei auftretenden Typfehlern prüfen, ob die Ursache tatsächlich in einem fehlerhaften Programm oder in fehlerhaften Typannotationen liegt."
"So ist die Suche nach einem guten Typsystem immer die Suche nach einem guten Kompromiss. Die meisten heute in der Praxis verwendeten Typsysteme basieren auf einem solchen: einer statischen Komponente, die möglichst viele Fehler findet, ohne dabei die Programmiererin allzu sehr einzuschränken, und einer dynamischen Komponente, die den Rest erledigt. Eine erwähnenswerte Ausnahme von diesem Muster bildet das STRONGTALK-Typsystem.",Was ist das STRONGTALK-Typsystem?,"Das STRONGTALK-Typsystem ist ein Typsystem, das eine erwähnenswerte Ausnahme von den meisten heute in der Praxis verwendeten Typsystemen darstellt, die auf einer statischen und dynamischen Komponente basieren."
"Ein weiterer Kompromiss betrifft die Ausdruckskraft des Typsystems. Je ausdruckskräftiger ein Typsystem ist, desto mehr Informationen kann es in einer Typannotation unterbringen und desto mehr Typfehler lassen sich aufdecken. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass es in einem konkreten Fall notwendig ist, eine aufwändige (und unter Umständen nicht einmal terminierende) Typprüfung durchzuführen. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen (Interfaces, siehe Kapitel 62) deutlich erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können (dies ist in der objektorientierten Programmierung ein schwer wiegendes Manko, da das gemeinsame Arbeiten von Klassen aus verschiedenen Bibliotheken die Regel ist).",Was ist ein Typsystem und wie wirkt sich seine Ausdruckskraft auf die Komplexität aus?,"Ein Typsystem ist ein Mechanismus, der Typen von Variablen und Ausdrücken überprüft. Je ausdruckskräftiger ein Typsystem ist, desto mehr Informationen kann es in einer Typannotation unterbringen und desto mehr Typfehler lassen sich aufdecken. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass es in einem konkreten Fall notwendig ist, eine aufwändige (und unter Umständen nicht einmal terminierende) Typprüfung durchzuführen."
"Ein weiterer Kompromiss betrifft die Ausdruckskraft des Typsystems. Je ausdruckskräftiger ein Typsystem ist, desto mehr Informationen kann es in einer Typannotation unterbringen und desto mehr Typfehler lassen sich aufdecken. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass es in einem konkreten Fall notwendig ist, eine aufwändige (und unter Umständen nicht einmal terminierende) Typprüfung durchzuführen. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen (Interfaces, siehe Kapitel 62) deutlich erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können (dies ist in der objektorientierten Programmierung ein schwer wiegendes Manko, da das gemeinsame Arbeiten von Klassen aus verschiedenen Bibliotheken die Regel ist).",Was ist ein ausdruckskräftiges Typsystem?,"Ein ausdruckskräftiges Typsystem ist ein Typsystem, das in einer Typannotation mehr Informationen unterbringen und damit mehr Typfehler aufdecken kann. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass eine aufwändige Typprüfung notwendig ist. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können."
"Ein weiterer Kompromiss betrifft die Ausdruckskraft des Typsystems. Je ausdruckskräftiger ein Typsystem ist, desto mehr Informationen kann es in einer Typannotation unterbringen und desto mehr Typfehler lassen sich aufdecken. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass es in einem konkreten Fall notwendig ist, eine aufwändige (und unter Umständen nicht einmal terminierende) Typprüfung durchzuführen. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen (Interfaces, siehe Kapitel 62) deutlich erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können (dies ist in der objektorientierten Programmierung ein schwer wiegendes Manko, da das gemeinsame Arbeiten von Klassen aus verschiedenen Bibliotheken die Regel ist).",Was ist ein Nachteil von ausdruckskräftigen Typsystemen?,"Ein Nachteil von ausdruckskräftigen Typsystemen ist, dass sie die Gestaltung von Schnittstellen erschweren können und die beteiligten Programme nicht ohne weiteres zusammenarbeiten können."
"Die folgende Grafik zeigt, wie die Typisierung von Variablen und anderen Programmkonstrukten in den verschiedenen Phasen eines Entwicklungszyklus verwendet werden kann: 1. In der Phase der statischen Typisierung wird der Typ einer Variablen bereits bei der Deklaration festgelegt. 2. In der Phase der dynamischen Typisierung wird der Typ einer Variablen erst zur Laufzeit bestimmt. 3. In der Phase der statischen Typprüfung wird der Typ einer Variablen bereits vor der Ausführung des Programms geprüft. 4. In der Phase der dynamischen Typprüfung wird der Typ einer Variablen erst zur Laufzeit geprüft. In der Analysephase wird die Typisierung von Variablen und anderen Programmkonstrukten nicht verwendet. In der Designphase wird die Typisierung von Variablen und anderen Programmkonstrukten verwendet, um die Struktur des Systems zu beschreiben. In der Implementierungsphase wird die Typisierung von Variablen und anderen Programmkonstrukten verwendet, um die statische Integrität des Systems zu gewährleisten. In der Testphase wird die Typisierung von Variablen und anderen Programmkonstrukten verwendet, um die dynamische Integrität des Systems zu gewährleisten. In der Wartungsphase wird die Typisierung von Variablen und anderen Programmkonstrukten verwendet, um die Korrektheit des Systems zu gewährleisten.",Wann wird die Typisierung von Variablen und anderen Programmkonstrukten in der Implementierungsphase verwendet?,"In der Implementierungsphase wird die Typisierung von Variablen und anderen Programmkonstrukten verwendet, um die statische Integrität des Systems zu gewährleisten."
"Die folgende Grafik zeigt, wie die Typisierung von Variablen und anderen Programmkonstrukten in den verschiedenen Phasen eines Entwicklungszyklus verwendet werden kann: 1. In der Phase der statischen Typisierung wird der Typ einer Variablen bereits bei der Deklaration festgelegt. 2. In der Phase der dynamischen Typisierung wird der Typ einer Variablen erst zur Laufzeit bestimmt. 3. In der Phase der statischen Typprüfung wird der Typ einer Variablen bereits vor der Ausführung des Programms geprüft. 4. In der Phase der dynamischen Typprüfung wird der Typ einer Variablen erst zur Laufzeit geprüft. In der Analysephase wird die Typisierung von Variablen und anderen Programmkonstrukten nicht verwendet. In der Designphase wird die Typisierung von Variablen und anderen Programmkonstrukten verwendet, um die Struktur des Systems zu beschreiben. In der Implementierungsphase wird die Typisierung von Variablen und anderen Programmkonstrukten verwendet, um die statische Integrität des Systems zu gewährleisten. In der Testphase wird die Typisierung von Variablen und anderen Programmkonstrukten verwendet, um die dynamische Integrität des Systems zu gewährleisten. In der Wartungsphase wird die Typisierung von Variablen und anderen Programmkonstrukten verwendet, um die Korrektheit des Systems zu gewährleisten.",Wie wird die Typisierung von Variablen und anderen Programmkonstrukten in den verschiedenen Phasen eines Entwicklungszyklus verwendet?,"Die Typisierung von Variablen und anderen Programmkonstrukten wird in den verschiedenen Phasen eines Entwicklungszyklus verwendet, um die Korrektheit und Konsistenz des Codes zu gewährleisten. In der Designphase wird die Typisierung verwendet, um die Architektur des Systems zu definieren und die Beziehungen zwischen den verschiedenen Komponenten zu beschreiben. In der Implementierungsphase wird die Typisierung verwendet, um die Syntax und Semantik des Codes zu überprüfen und sicherzustellen, dass er den Anforderungen entspricht. In der Testphase wird die Typisierung verwendet, um die Funktionalität des Codes zu überprüfen und sicherzustellen, dass er die erwarteten Ergebnisse liefert. In der Wartungsphase wird die Typisierung verwendet, um sicherzustellen, dass Änderungen am Code nicht unbeabsichtigte Auswirkungen haben und dass der Code weiterhin den Anforderungen entspricht."
"Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode entworfen und implementiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. Testphase: In dieser Phase wird das Programm getestet, um sicherzustellen, dass es korrekt funktioniert. Die Typisierung kann dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode definiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren, und sie kann auch verwendet werden, um die Konsistenz der Daten während der Ausführung des Programms zu gewährleisten. Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben. Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält. Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert. Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.",Wozu dient die Typisierung in den verschiedenen Phasen des Programmentwicklungsprozesses?,"In der Entwurfsphase hilft die Typisierung, die Struktur des Programms zu definieren, indem sie abstrakte Datentypen und Schnittstellen spezifiziert. In der Implementierungsphase wird sie verwendet, um die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. In der Testphase kann die Typisierung dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen."
"Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode entworfen und implementiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. Testphase: In dieser Phase wird das Programm getestet, um sicherzustellen, dass es korrekt funktioniert. Die Typisierung kann dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode definiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren, und sie kann auch verwendet werden, um die Konsistenz der Daten während der Ausführung des Programms zu gewährleisten. Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben. Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält. Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert. Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.",Wozu kann die Typisierung in der Entwurfsphase verwendet werden?,"In der Entwurfsphase kann die Typisierung dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt."
"Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode entworfen und implementiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. Testphase: In dieser Phase wird das Programm getestet, um sicherzustellen, dass es korrekt funktioniert. Die Typisierung kann dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode definiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren, und sie kann auch verwendet werden, um die Konsistenz der Daten während der Ausführung des Programms zu gewährleisten. Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben. Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält. Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert. Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.",Wozu kann die Typisierung in der Implementierungsphase verwendet werden?,"In der Implementierungsphase kann die Typisierung dazu verwendet werden, die richtigen Methoden für die richtigen Objekte aufzurufen."
"Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode entworfen und implementiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. Testphase: In dieser Phase wird das Programm getestet, um sicherzustellen, dass es korrekt funktioniert. Die Typisierung kann dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode definiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren, und sie kann auch verwendet werden, um die Konsistenz der Daten während der Ausführung des Programms zu gewährleisten. Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben. Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält. Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert. Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.",Wozu kann die Typisierung in der Testphase verwendet werden?,"In der Testphase kann die Typisierung dazu verwendet werden, die Art der Daten zu überprüfen, die an Methoden übergeben werden."
"Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode entworfen und implementiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. Testphase: In dieser Phase wird das Programm getestet, um sicherzustellen, dass es korrekt funktioniert. Die Typisierung kann dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode definiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren, und sie kann auch verwendet werden, um die Konsistenz der Daten während der Ausführung des Programms zu gewährleisten. Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben. Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält. Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert. Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.",Wozu kann die Typisierung in der Wartungsphase verwendet werden?,"In der Wartungsphase kann die Typisierung dazu verwendet werden, die Auswirkungen von Änderungen zu verstehen und zu kontrollieren."
"Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode entworfen und implementiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. Testphase: In dieser Phase wird das Programm getestet, um sicherzustellen, dass es korrekt funktioniert. Die Typisierung kann dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode definiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren, und sie kann auch verwendet werden, um die Konsistenz der Daten während der Ausführung des Programms zu gewährleisten. Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben. Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält. Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert. Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.",Wie hilft die Typisierung während der Implementierungsphase?,"Die Typisierung hilft während der Implementierungsphase sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben."
"Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode entworfen und implementiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. Testphase: In dieser Phase wird das Programm getestet, um sicherzustellen, dass es korrekt funktioniert. Die Typisierung kann dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode definiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren, und sie kann auch verwendet werden, um die Konsistenz der Daten während der Ausführung des Programms zu gewährleisten. Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben. Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält. Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert. Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.",Was ist das Ziel von Typisierung in der Testphase?,"Das Ziel von Typisierung in der Testphase ist es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält."
"Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode entworfen und implementiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. Testphase: In dieser Phase wird das Programm getestet, um sicherzustellen, dass es korrekt funktioniert. Die Typisierung kann dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode definiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren, und sie kann auch verwendet werden, um die Konsistenz der Daten während der Ausführung des Programms zu gewährleisten. Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben. Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält. Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert. Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.",Wie kann die Typisierung bei der Wartung eines Programms helfen?,"Die Typisierung kann bei der Wartung eines Programms dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert."
"Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode entworfen und implementiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. Testphase: In dieser Phase wird das Programm getestet, um sicherzustellen, dass es korrekt funktioniert. Die Typisierung kann dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen. Implementierungsphase: In dieser Phase wird der Algorithmus für jede Methode definiert. Die Typisierung hilft, die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren, und sie kann auch verwendet werden, um die Konsistenz der Daten während der Ausführung des Programms zu gewährleisten. Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben. Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält. Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert. Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.",Wozu dienen Typinformationen in der Dokumentation?,"Typinformationen in der Dokumentation helfen anderen Entwicklern, den Code zu verstehen und korrekt zu verwenden."
"Zusammenfassend kann man sagen, dass Typisierung in der Softwareentwicklung eine wichtige Rolle spielt, um die Qualität, Sicherheit und Wartbarkeit von Programmen zu erhöhen. Sie ermöglicht es, Fehler frühzeitig zu erkennen, die Lesbarkeit des Codes zu verbessern und die Zusammenarbeit in größeren Entwicklungsprojekten zu erleichtern. Es gibt verschiedene Ansätze zur Typisierung, von dynamischer Typprüfung zur Laufzeit bis hin zu statischer Typprüfung während der Übersetzungsphase, und die Wahl des richtigen Typsystems hängt von den Anforderungen des jeweiligen Projekts ab.",Was ist der Zweck der Typisierung in der Softwareentwicklung?,"Der Zweck der Typisierung in der Softwareentwicklung ist es, die Qualität, Sicherheit und Wartbarkeit von Programmen zu erhöhen. Sie ermöglicht es, Fehler frühzeitig zu erkennen, die Lesbarkeit des Codes zu verbessern und die Zusammenarbeit in größeren Entwicklungsprojekten zu erleichtern."
"Zusammenfassend kann man sagen, dass Typisierung in der Softwareentwicklung eine wichtige Rolle spielt, um die Qualität, Sicherheit und Wartbarkeit von Programmen zu erhöhen. Sie ermöglicht es, Fehler frühzeitig zu erkennen, die Lesbarkeit des Codes zu verbessern und die Zusammenarbeit in größeren Entwicklungsprojekten zu erleichtern. Es gibt verschiedene Ansätze zur Typisierung, von dynamischer Typprüfung zur Laufzeit bis hin zu statischer Typprüfung während der Übersetzungsphase, und die Wahl des richtigen Typsystems hängt von den Anforderungen des jeweiligen Projekts ab.",Was sind die Vorteile von Typisierung in der Softwareentwicklung?,"Typisierung in der Softwareentwicklung erhöht die Qualität, Sicherheit und Wartbarkeit von Programmen, indem sie Fehler frühzeitig erkennt, die Lesbarkeit des Codes verbessert und die Zusammenarbeit in größeren Entwicklungsprojekten erleichtert."
