20.1 Induktiver Aufbau von Typen und Semantik

Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean: Alle seine Operationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergebnis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte externe Formalismen abzubilden. Im Beispiel von Boolean ist dies natürlich die boolesche Algebra. Jeder, der die boolesche Algebra kennt und akzeptiert, wird auch den Typ Boolean sofort verstehen und akzeptieren (sofern er den Erwartungen entsprechend definiert ist). Entsprechend lässt sich ein Typ Fraction mit den Operationen +, –, *, und / definieren, der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-gleichsoperationen wie =, >, <, etc. hinzufügen, ohne in Interpretationsprobleme zu geraten. Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition rekursiv auf solche Typen zurückgeführt werden können, kann man "induktiv über deren Aufbau" eine Bedeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeutung eine denotationale Semantik. Eine andere, für die praktische Programmierung relevantere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten oder realen, Hauptsache gut spezifizierten) Maschine abzubilden. Die Abbildung für Basistypen wie Rational oder Boolean ist in der Programmiersprache bzw. deren Compiler gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann dies hingegen nicht der Fall sein; deren Bedeutung kann aber vom Compiler, wiederum "induktiv über deren Aufbau", aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Man nennt dies dann auch eine operationale Semantik. Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht "hart verdrahtet" ist, sondern auf dynamisches Binden abgewälzt wird, so sind dennoch mindestens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und Float (nicht jedoch Fraction!) sind "fest verdrahtet", inklusive der Vergleichsrelationen (die ja die Wahrheitswerte zum Ergebnis haben). Wenn Sie Kurs 01661 ("Datenstrukturen") bereits belegt haben oder ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen. Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrieben, deren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs: 1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte keinen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die Operationen ausgeführt werden, nicht ihren Zustand wechseln. Stattdessen geben Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also gewissermaßen alle unveränderlich (vgl. Kurseinheit 1, Abschnitt 4.3.5). 2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar vom Typ des Datentyps selbst. Dieses Argument entspricht in der objektorientierten Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self. Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Programmiersprache mit einer Semantik zu versehen.

Frage: Was sind Typen, die sich ausschließlich auf sich selbst beziehen, und wie erhalten sie Bedeutung?
Antwort: Typen, die sich ausschließlich auf sich selbst beziehen, sind solche, deren Bedeutung nicht von anderen Typen abhängt. Ein Beispiel dafür ist der Typ "Boolean". Sie können Bedeutung erhalten, indem sie auf bekannte externe Formalismen abgebildet werden, wie die boolesche Algebra.

Frage: Was ist eine denotationale Semantik in Bezug auf die Bedeutung von Typen?
Antwort: Eine denotationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf bekannte externe Formalismen abgebildet werden. Dies kann beispielsweise bedeuten, dass die Operationen eines Typs auf mathematische oder logische Konzepte abgebildet werden, die in der Programmierung verwendet werden.

Frage: Was ist eine operationale Semantik in Bezug auf die Bedeutung von Typen?
Antwort: Eine operationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf Anweisungen einer (gedachten oder realen) Maschine abgebildet werden. Dies bedeutet, dass die Operationen eines Typs auf die Ausführung von Maschinenbefehlen oder anderen niedrigstufigen Operationen abgebildet werden.

Frage: Gibt es vollständig in sich selbst definierte Typsysteme, die von externen Einflüssen unabhängig sind?
Antwort: Nein, es gibt keine vollständig in sich selbst definierten Typsysteme, die vollständig unabhängig von externen Einflüssen sind. Selbst in Typsystemen wie SMALLTALK oder STRONGTALK sind mindestens einige grundlegende Typen oder Konzepte, wie Wahrheitswerte oder Ganzzahlen, von externen Formalismen oder vorgegebenen Semantiken abhängig.

Frage: Was sind die Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs?
Antwort: Es gibt mindestens zwei wichtige Unterschiede: Abstrakte Datentypen sind nicht objektorientiert, während STRONGTALK-Typen objektorientiert sind und Objekte Zustand haben können. Abstrakte Datentypen haben Funktionen mit einem Argument mehr, das dem Typ des Datentyps selbst entspricht. In objektorientierten Sprachen entspricht dies dem Nachrichtenempfänger, dem impliziten Parameter "self".