8.5 Die Metaklassenleiter in SMALLTALK

Gemäß der SMALLTALK-Philosophie müssen auch Metaklassen (als Objekte) Instanzen von Klassen sein. Es erscheint jedoch nicht mehr sinnvoll, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen. Daher ist es nicht notwendig, dass jede Metaklasse (als Klasse) ihre eigene Meta-Metaklasse (als Metaklasse der Klasse) hat. Für die Praxis reicht es aus, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind. In Übereinstimmung mit der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz "<eine Instanz> ist ein <Klassenname>" korrekt ergänzen, wird diese Klasse als "Metaclass" bezeichnet, da alle ihre Instanzen Metaklassen sind.
Die Frage ergibt sich sofort, von welcher Klasse die Klasse "Metaclass" eine Instanz ist. Tatsächlich muss laut der SMALLTALK-Philosophie, nach der Klassen Objekte und jedes Objekt Instanz einer Klasse ist, auch die "Metaclass" eine Instanz einer Klasse sein. Um diese Hierarchie nicht ins Unendliche fortsetzen zu müssen, wurde in SMALLTALK zu einem einfachen Trick gegriffen: Die Klasse "Metaclass" von "Metaclass" wird selbst nur als einfache Metaklasse betrachtet (obwohl sie eigentlich eine Meta-Meta-Metaklasse ist). Genau wie alle anderen Metaklassen ist sie eine Instanz von "Metaclass". Für "Metaclass" gilt daher: Metaclass ist eine Instanz von Metaclass.
Das folgende Diagramm veranschaulicht die Zusammenhänge. Beachten Sie, dass alle Objekte außerhalb der Ebene 0 gleichzeitig Klassen und Instanzen sind. Der gestrichelte Pfeil stellt die "Ist-eine-Instanz-von"-Beziehung dar (in UML-Notation).
Die aufmerksame Leserin wird sofort bemerken, dass dieser Kunstgriff, die Hierarchie zu beenden, die Interpretation von Klassen als Mengen von Objekten und deren Instanzen als Elemente dieser Mengen im Sinne von Abschnitt 7.3 verhindert. Andernfalls wäre die Menge von Objekten, die zu "Metaclass" gehört, indirekt ein Element von sich selbst, was nicht möglich ist. Dies hat jedoch keine praktischen Auswirkungen.
In SMALLTALK haben wir es also mit einem mehrstufigen Zusammenspiel von Klassen und Instanzen zu tun. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht.
Die Klassen der Ebene 1 sind selbst Objekte und daher Instanzen von Klassen, die auf Ebene 2 stehen. Die Klassen der Ebene 2, die Metaklassen, definieren die Klassen auf Ebene 1. Da es nicht sinnvoll ist, mehrere Instanzen derselben Klasse der Ebene 1 zu haben, die alle über dieselbe Definition verfügen, hat jede Metaklasse genau eine Instanz. Es besteht also eine 1-zu-1-Beziehung zwischen Metaklassen und ihren Instanzen, den Klassen der Ebene 1, die die Objekte der Anwendung beschreiben.
Auf Ebene 3 erhalten alle Metaklassen eine gemeinsame Klasse, von der sie Instanzen sind, nämlich die Klasse "Metaclass". Beachten Sie, dass hier wieder eine 1: n-Beziehung vorliegt. Anders als auf Ebene 2, auf der verschiedene Konzepte jeweils eine eigene Klasse haben, wird auf Ebene 3 die Vielfalt auf genau eine Klasse reduziert. Diese Klasse hat dann wieder genau eine Metaklasse.

Frage: Warum ist es nicht notwendig, dass jede Metaklasse in SMALLTALK ihre eigene Meta-Metaklasse hat?
Antwort: Es ist nicht notwendig, dass jede Metaklasse in SMALLTALK ihre eigene Meta-Metaklasse hat, da es in der Praxis ausreicht, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind.

Frage: Wie wird die Klasse "Metaclass" in SMALLTALK bezeichnet und warum?
Antwort: Die Klasse "Metaclass" wird in SMALLTALK als "Metaclass" bezeichnet, weil alle ihre Instanzen Metaklassen sind. Dies folgt der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz "<eine Instanz> ist ein <Klassenname>" korrekt ergänzen.

Frage: Was ist die Beziehung zwischen der Klasse "Metaclass" und ihrer eigenen Meta-Metaklasse?
Antwort: Die Klasse "Metaclass" von "Metaclass" wird selbst als einfache Metaklasse betrachtet, obwohl sie eigentlich eine Meta-Meta-Metaklasse ist. Genau wie alle anderen Metaklassen ist sie eine Instanz von "Metaclass". Daher gilt für "Metaclass": Metaclass ist eine Instanz von Metaclass.

Frage: Welche Ebenen gibt es in SMALLTALK im Zusammenhang mit Klassen und Instanzen?
Antwort: In SMALLTALK gibt es mehrere Ebenen im Zusammenhang mit Klassen und Instanzen: Ebene 0: Konkrete Objekte, die nicht instanziierbar sind und Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Ebene 1: Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Ebene 2: Metaklassen, die die Klassen auf Ebene 1 definieren. Jede Metaklasse hat genau eine Instanz. Ebene 3: Die Klasse "Metaclass", von der alle Metaklassen Instanzen sind.

Frage: Was repräsentieren die Klassen der Ebene 1 und was repräsentieren die Metaklassen der Ebene 2?
Antwort: Die Klassen der Ebene 1 repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. Die Metaklassen der Ebene 2 definieren die Klassen auf Ebene 1, wobei jede Metaklasse genau eine Instanz auf Ebene 1 hat.