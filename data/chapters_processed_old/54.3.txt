54.3 Verhaltensbasiertes Subtyping

Die Regeln des Subtypings aus Kapitel 26 und die damit verbundene Regelung der Zuweisungskompatibilität bezogen sich lediglich auf die Elemente einer Typdeklaration und somit auf rein statische Informationen. Um nun auch das Verhalten der Objekte eines Typs zu berücksichtigen, greift man auf eine Idee aus der formalen Programmverifikation zurück, nämlich die Überführung von Vorbedingungen in Nachbedingungen, ähnlich wie in (54.1).
Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methodenausführung, verletzt werden).
Damit meinen wir, dass für eine Implementierung von m in der zugehörigen Klasse von T, die auf einem Empfängerobjekt vom Typ T (einer Instanz der entsprechenden Klasse) aufgerufen wird, die Nachbedingung aus der Vorbedingung folgt. Wir müssen diesen Beweis jedoch nicht führen, da unser Interesse hier nicht auf der Korrektheit der Implementierungen an sich liegt, sondern vielmehr daran, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird und es durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Mehr dazu in Abschnitt 54.5.
Uns interessiert, ob eine umfassende Substituierung möglich ist. Konkret: Wir möchten eine verhaltensbasierte Subtypenrelation betrachten, das heißt, wir möchten die Bedingungen verstehen, die potenzielle Subtypen erfüllen müssen, damit sie die Spezifikation des Supertyps erfüllen und als verhaltenskonform betrachtet werden können. Dabei handelt es sich um eine Subtypenbeziehung, wie sie in Kapitel 26 beschrieben wird. Dies ist dann der Fall, wenn die obige Implikation auch für Objekte des potenziellen Subtypen S gilt.
Man spricht dann von einem Behavior Subtyping, was am besten als verhaltensbasiertes Subtyping wiedergegeben wird.
Wir müssen also sicherstellen, dass (6.3) erfüllt ist. Bei der Spezifikation der Methoden des (potenziellen Sub-)Typs S werden wir zunächst nicht auf die Vor- und Nachbedingungen von T zurückgreifen, sondern unsere eigenen definieren. Dies ist jedoch im Allgemeinen nicht der Fall. Die Frage lautet also: Wie müssen 𝑝𝑟𝑒𝑚S, 𝑝𝑟𝑒𝑚T, 𝑝𝑜𝑠𝑡𝑚S und 𝑝𝑜𝑠𝑡𝑚T miteinander in Beziehung stehen, damit Objekte vom Typ S die Anforderungen für Objekte vom Typ T erfüllen? Formal ausgedrückt: Was müssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), dem Verhalten von m in T angewandt auf Objekte aus S, folgt?
Leider reicht es nicht aus, diese Frage zu beantworten. Aufgrund des weit verbreiteten Aliasings in der objektorientierten Programmierung kann ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel. Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht also nicht aus. Man kann bereits erahnen, dass diese Angelegenheit komplex wird.

Frage: Welche Idee aus der formalen Programmverifikation wird verwendet, um das Verhalten von Objekten in der Subtypenbeziehung zu berücksichtigen?
Antwort: Die Idee aus der formalen Programmverifikation besteht darin, Vorbedingungen in Nachbedingungen zu überführen, um das Verhalten von Objekten eines Typs zu berücksichtigen. Dies wird verwendet, um sicherzustellen, dass die Implementierung eines Typs korrekt ist und dass aus Vorbedingungen die entsprechenden Nachbedingungen folgen.

Frage: Was bedeutet "verhaltensbasiertes Subtyping" oder "Behavior Subtyping"?
Antwort: "Verhaltensbasiertes Subtyping" oder "Behavior Subtyping" bezieht sich auf eine Subtypenbeziehung, bei der die Bedingungen erfüllt sein müssen, damit die Spezifikation des Subtyps die des Supertyps erfüllt und als verhaltenskonform betrachtet werden kann. Dies bedeutet, dass das Verhalten der Objekte des Subtyps mit dem Verhalten des Supertyps übereinstimmen muss.

Frage: Warum kann es zu Problemen kommen, wenn Objekte vom Typ S von einem Klienten als Typ T betrachtet werden?
Antwort: Es können Probleme auftreten, wenn Objekte vom Typ S von einem Klienten als Typ T betrachtet werden, da dies zu Aliasen führen kann, bei denen das Objekt von verschiedenen Klienten unterschiedliche Typen hat. Dies kann dazu führen, dass Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und kann für Benutzer, die das Objekt als T betrachten, nicht akzeptabel sein.

Frage: Warum reicht eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit nicht aus?
Antwort: Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht nicht aus, da Aliasings in der objektorientierten Programmierung dazu führen kann, dass ein Objekt vom Typ S von verschiedenen Klienten unterschiedliche Typen hat und Methodenaufrufe auf dem Objekt Zustandsänderungen verursachen können, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Daher muss eine umfassendere Betrachtung erfolgen, die die Auswirkungen des Verhaltens auf den Zustand und die Spezifikation des Typs berücksichtigt.