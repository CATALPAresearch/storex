41 Arrays

In JAVA ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden. Anders als z. B. in PASCAL können aber über den Array-Typkonstruktor keine neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration.
In JAVA sind zwei Variablen vereinbart, wovon die erste ein Array von Fließkommazahlen zum Typ hat und die zweite ein Array von Objekten. Die alternative Schreibweise ist ebenfalls gebräuchlich. Anders als z. B. in PASCAL wird die Größe des Arrays in der Deklaration nicht festgelegt — dies geschieht erst bei der Initialisierung.
In JAVA ist es möglich, Arrays bei ihrer Deklaration zu initialisieren. Man beachte die Ähnlichkeit zu literalen Arrays in SMALLTALK (Abschnitt 1.2); allerdings müssen die Elemente der Arrays in JAVA nicht selbst Literale sein, sondern dürfen auch andere Ausdrücke sein. Die Größe des Arrays (in diesem Fall 2) wird bei der Initialisierung automatisch festgelegt; ansonsten muss dies bei der Erzeugung des Arrays mittels eines Konstruktors explizit geschehen.
Alle Elemente des Arrays enthalten danach jedoch null (JAVAs Äquivalent von SMALLTALKs nil). JAVA-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.
Beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimensionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays in JAVA auch gar nicht um mehrdimensionale Arrays, sondern um Arrays von Arrays).
Interessanterweise haben in JAVA Array-Variablen immer und unabhängig vom Basistyp Referenzsemantik. Bei der Zuweisung an die Variable f oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer darauf. Dies hat vermutlich den Hintergrund, dass Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Warum auch immer, im Ergebnis kann f an eine Variable vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit auch nicht damit zuweisungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn sie wie Klassen und Interfaces Typen bilden, außer ihrem Basistyp (also beispielsweise float oder Object) keine weiteren Definitionselemente anzugeben erlauben; insbesondere kann man für einen Array-Typen keine weiteren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die (Pseudo-)Variable length definiert, deren Inhalt die Größe des Arrays (Anzahl Elemente) angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.
Die bemerkte mangelnde Zuweisungskompatibilität von Object[] und float[] wirft natürlich sofort die Frage auf, ob denn auch die Zuweisung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] unzulässig ist. Wir hatten ja in Abschnitt 29.3 von Kurseinheit 3 am Beispiel zweier Instanzen eines parametrischen Typs bemerkt, dass dies zu einem nicht ganz offensichtlichen Problem führt, das sich analog auf Arrays übertragen lässt. Die Überraschung folgt hier auf den Fuß: Die Zuweisung ist in JAVA zulässig.
Warum aber geht man dieses Risiko ein und überträgt die Zuweisungskompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man anschließend schreibend (wie in Zeile 1046) auf das Array zugreift und dann noch mit dem falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen). Da man diese Bedingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein Laufzeittest durchgeführt. Ein klassischer Kompromiss, der diesmal zugunsten der Flexibilität beim Programmieren ausging.
Warum aber will man Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs und damit Zuweisungen wie die in Zeile 1045 unbedingt haben? Die Antwort ist einfach: weil es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern lediglich nach oben beschränken wollen. So gibt es beispielsweise in JAVA den Interfacetyp Comparable, der wie folgt definiert ist:
Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.

Frage: Was ermöglicht JAVA in Bezug auf Arrays in Bezug auf Wert- und Referenztypen?
Antwort: In JAVA ist es möglich, sowohl Arrays von primitiven (Wert-)Typen als auch von Referenztypen zu erstellen.

Frage: Wie erfolgt die Deklaration von Arrays in JAVA?
Antwort: Die Deklaration von Arrays in JAVA erfolgt implizit in Variablendeklarationen, wobei die Größe des Arrays nicht in der Deklaration festgelegt wird.

Frage: Wie können Arrays in JAVA initialisiert werden?
Antwort: Arrays können in JAVA bei ihrer Deklaration initialisiert werden. Dabei wird die Größe des Arrays automatisch festgelegt.

Frage: Welche Besonderheiten gibt es bei mehrdimensionalen Arrays in JAVA?
Antwort: In JAVA können mehrdimensionale Arrays geschachtelt werden, wobei die Größen der Dimensionen nicht für jedes Element der ersten Dimension gleich sein müssen.

Frage: Wie funktioniert die Zuweisung von Array-Variablen in JAVA?
Antwort: In JAVA haben Array-Variablen Referenzsemantik, und bei der Zuweisung wird lediglich ein Verweis auf das Array übergeben. Die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[] ist zulässig.

Frage: Warum gestattet JAVA die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[]?
Antwort: Diese Zuweisungskompatibilität ermöglicht eine flexiblere Programmierung, insbesondere in Situationen, in denen der statische Typ der Array-Elemente nicht genau festgelegt ist, aber nach oben beschränkt werden soll, wie im Beispiel mit dem Interface Comparable und der Methode sort. Dieser Kompromiss zwischen statischer und dynamischer Typprüfung bietet Flexibilität beim Programmieren.