54.1 Der Begriff der Substituierbarkeit
Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs
da auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn das gutgeht,
also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen ,
spricht man von der Substituierbarkeit der Objekte des Typen auf der linken Seite der
Zuweisung durch die des Typen auf der rechten.
Nun ist die Frage, ob eine Zuweis ung gutgeht, eine, die man gern automatisch, am besten
durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der
Programmierung zu einem eigenständigen geworden, der zunächst unabhängig von der
(an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der
Begriff der Substituierbarkeit soll daher zunächst einmal genauer untersucht werden.
In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein
Objekt ein anderes nur dann substituieren, wenn sich das auf den Pro-
grammablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Ob-
jekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben
Klasse85 sein), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand
wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack
gerade leer ist , ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar:
Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall
scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus War-
tungsgründen substituiert werden müsste n), gibt es wohl kaum einen Grund für eine Sub-
stituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend
eng gefasst en Substituierbarkeitsbegriff.
Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zu-
stand der Objekte unabhängig sein. Das hat den Vorteil, dass man die
Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs - (oder Entwurfs -
)Zeit verlagern kann. Auf di eser Ebene ist aber zumindest das Verhalten aller Objekte einer
Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegensei-
tige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.
Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte
nicht derselben Klasse angehören und wenn man eine gewisse Abwei-
chung im Verhalten von zu substituierenden Objekten zu lässt. So könnte
man sich bei spielsweise vorstellen, dass ein substituierendes Objekt funk-
tional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen
Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen.
Diese sog. nichtfunktionalen Anforderungen , die normalerweise von den funktionalen ge-
trennt dargestellt werden, sind aber in Wirklichkeit gar nicht immer hundertprozentig davon
zu trennen und es ist durchaus vorstellbar, dass ein Programm, das von einem funktionie-
renden nur in nicht -funktionalen Eigenschaften abweich t, nicht funktioniert (beispielsweise
weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu
Abbrüchen durch Time outs o. ä. führt).
Ein klassisches Beispiel für die gegenseitige Austauschbarkeit fun ktional
äquivalenter, aber verschiedener Typen ist die plattformunabhängige
GUI-Program mierung. So basiert beispielsweise die GUI -Programmierung von und mit E-
CLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also
Fenster , Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenhei-
ten angepassten Implementierungen dieser GUI -Elemente. Es ist also sinnvoll, für jeden Typ
85 Solange Typdefinitionen nur Syntax beschreiben, ist das Verhalten der Objekte durch ihren Typ
nicht festgelegt. Selbst bei einer abstrakten Spezifikatio n des Verhaltens (z. B. durch einen abstrakten
Datentyp) wird aber in der Regel nur funktionales Verhalten beschrieben und keine nichtfunktionalen
Aspekte wie beispielsweise Zeitverhalten. Auch aus nichtfunktionalen Anforderungen kann sich aber
eine mangel nde Substituierbarkeit ergeben (s. u.). strengste Auslegung
des Begriffs de r
Substituierbarkeit
Loslösung vom
Zustand der Objek te
Substituierbarkeit be i
funktional
äquivalentem
Verhalten
Beispiel GUI -
Programmierung
von GUI -Element eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die
Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte die-
ser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs)
funktional äquivalent, können sich aber in Aussehen und ggf. auch Detailverh alten (gegen-
über dem Bediener) unterscheiden. Diese Unterschiede sind jedoch gewollt und die Substi-
tuierbarkeit bleibt davon unberührt.
Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs
von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Ver-
halten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie bei-
spielsweise an einen Editor, der eine Funktion „rückgängig machen“ hat,
die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen,
und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind
in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gi bt, der
erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinn-
voll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion „ausführen“ auch
noch eine „Rückgängigmachen“ haben, die, für jeden Typ von Aktion versc hieden, das je-
weils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbe-
stand der Ausführ - und Rückgängigmachbarkeit angeht, gegeneinander austauschbar und
die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Type n Aktion , ob-
wohl ihr konkretes Verhalten, also das, was jeweils mit „ausführen“ und „rückgängig ma-
chen“ verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Sub-
stituierbarkeit sind in diesem Fall also eher gering.
Im allgemeinen als nicht gegeneinander austauschbar angesehen wird je-
doch Verhalten, bei dem eine Funktion, die in dem auszutauschenden
Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre
beispielsweise eine Aktion, für die „rückgängig machen“ nicht definiert
ist (z. B. Speichern ), kein Subtyp von Aktion , da Objekte dieses Typs nicht überall da
auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es aus-
reicht, die Funktion „rückgängig machen“ in Speichern leer zu implementieren, also bei-
spielsweise nichts passieren zu lassen oder eine Meldung „rückgängig Machen leider nicht
möglich“ auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde
immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rück-
gängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit
strenggenommen n icht gegen andere Objekte vom Typ Aktion austauschbar.
