7.2 Klassendefinitionen
Eine Klassendefinition liefer t die Intension einer Klasse. Sie besteht in
SMALLTALK zunächst aus der Angabe eines nicht anderweitig verwende-
ten, durch ein Symbol repräsentierten Klassennamens sowie de r Angabe der die Objekte
der Klasse beschreibenden Instanzvariablen und Methodendefinitionen . Anders als in vielen
anderen objektorientierten Programmiersprachen erfolgt in SMALLTALK die Klassendefinition
nicht in einer Datei (was hätte eine Datei auch mit den Konzepten einer Programmierspra-
che zu tun?), sondern durch Eintragungen in eine dafür vorgesehene Datenstruktur (ge-
nauer: durch Erzeugung eines die Klasse beschreibenden Objekts). Es gibt also auch insbe-
sondere keine Syntax für eine Klassendefinition, sondern nur ein Schema. Ein solches , wenn
auch noch unvollständiges, Schema ist das folgende: Allgemeinbegriff vs.
Familienähnlich keit
Zweckmäßigkeit des
Klassenbegriffs
Schema einer
Klassendefinition
Klasse  <Klassenname>
benannte Instanzvariablen  <Liste von Instanzvariablennamen>
indizierte Instanzvariablen  <ja/nein>
atomar  <ja/nein>
Instanzmethoden
<Liste von Methodendefinitionen>
Alle Instanzen einer Klasse verfügen somit über den gleichen Satz von Instanzvariablen, aber
nicht denselben, was soviel bedeutet wie dass jede Instanz der Klasse (jedes Objekt, das zur
Extension der Klasse gehört) diese Variablen individuell belegen kann. Im Gegensatz dazu
verstehen alle Instanzen einer Klasse nicht nur dieselben Nachrichten, sie verwenden auch
dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren. Instanzen einer
Klasse können sich also nur insoweit in ihrem Verhalten unters cheiden, wie sich die Metho-
dendefinitionen auf die Werte der Instanzvariablen beziehen, wie also das in den Methoden
spezifizierte Verhalten vom Inhalt der Instanzvariablen abhängt. Insbesondere ist es nicht
vorgesehen, dass verschiedene Instanzen einer Klasse über verschiedene Definitionen einer
Methode (genauer: über verschiedene Definitionen von zu der Nachricht passenden Metho-
den) verfügen. Das unterscheidet die klassenbasierte von der prototypenbasierten Form der
objektorientierten Programmierung.
Die beiden Einträge „indizierte Instanzvariablen“ und „atomar“ stehen übrigens dafür, ob
eine Instanz der Klasse indizierte Instanzvariablen haben soll (klar) und falls ja, ob diese Va-
riablen dann eine binäre Repräsentation (ja) oder Referenzen (nein) enthalte n. Mit Hilfe von
indizierten Instanzvariablen, die binäre Repräsentationen enthalten, werden z. B. Zahlen,
Strings, aber auch Bitmaps wie Fensterinhalte , der Cursor oder Fonts intern dargestellt. Da
man als Programmiererin solche Klassen in der R egel nicht selbst anlegt, werde ich den
Eintrag „atomar“ zukünftig unter den Tisch fallen lassen.
Eine Klasse ( das Objekt, das die Klassen repräsentiert, nicht ihr Name)
wird in SMALLTALK nach ihrer Erzeugung übrigens durch eine globale Pseu-
dovariable repräsentiert, deren Name der Name der Klasse ist. Da die Variable global ist,
muss sie (und damit auch der Name der Klasse) immer mit einem Großbuchstaben beginnen
(s. Abschnitt 1.5.2 in Kurseinheit 1). Die Variable wird automatisch mit der Klassendefinition
eingeführt (vereinbart ); ihr „Wert“, die Klasse, auf die sie verweist, ist das Objekt, das ihr
bei der Anlage der Klasse zugewiesen wird. Da Klassennamen globale Variablen sind, da sie
insbesondere absolut global sind und nicht nur in Bezug auf irgendeine Programmeinheit
(wie e twa eine Methodendefinition), sind sie von überall her zugreifbar. Außerdem wird
jede neue Klasse in eine Art Systemwörterbuch namens „ Smalltalk “ (repräsentiert von der
globalen Variable Smalltalk ; s. Selbsttestaufgabe 1.2) eingetragen und ihr Name (als Sym-
bol) in die Symboltabelle SymbolTable . Repräsentation von
Klassen im System
Selbsttestaufgabe 7.1
Vergewissern Sie sich, dass die Klasse Class in Smalltalk enthalten ist und das Symbol #Class
in SymbolTable (nur SMALLTALK EXPRESS ). Enthält Smalltalk auch andere Objekte als Klassen?
Mittels einer solchen Klassendefinition ist man nun in der Lage, das SMALL-
TALK-System um neue, eigene Klassen zu erweitern. Ein Beispiel für eine
solche neue Klasse gibt die folgende (wie gesagt noch unvollständige)
Klassendefinition, die auf einfache Weise einen Stapelspeicher ( Stack ) implementiert, der
seine Elemente in indizierten Instanzvariablen und den Stapelzeiger ( Stack pointer ) in einer
benannten hält:
Klasse  Stack
benannte Instanzvariablen  stackpointer
indizierte Instanzvariablen  ja
Instanzmethoden
279 push: anElement
280  "legt neues Element auf Stapel"
281  stackpointer := stackpointer + 1.
282  self at: stackpointer put: anElement
283 pop
284  "entfernt oberstes Element vom Stapel"
285  stackpointer := stackpointer – 1
286 top
287  "liefert oberstes Element des Stapels"
288  ^ self at: stackpointer
Nur zur Wiederholung: Die Pseudovariable self in den Zeilen 282 und 288 steht jeweils
für das Objekt, das die die Methode auslösende Nachricht erhalten hat (da s Empfängerob-
jekt): Sie ist notwendig, da der Zugriff auf die indizierten Instanzvariablen in SMALLTALK im-
mer über die Methoden at: und at:put: erfolgt, deren Aufruf (als Nachrichtenausdruck)
stets einen Empfänger benötigt. Anders als z. B. in JAVA (wo this die Rolle von self ein-
nimmt) wird bei fehlendem Empfänger innerhalb einer Methode nicht einfach das Empfän-
gerobjekt angenommen, sondern ein Syntaxfehler gemeldet.
Bei genauem Hinsehen bemerkt man, dass die obige Implementierung
eines Stacks einen Schönheitsfehler besitzt: Während die Manipulation
der benannten Instanzvariable stackpointer , deren Wert ja von den
Methoden von Stack aktualisiert wird, durch andere Objekte noch verhindert werden
kann, ist dies für di e indizierten Instanzvariablen eines Stack -Objekts nicht der Fall. Eine
Benutzerin eines solchen Objekts kann stattdessen mittels at: und at:put: jederzeit auf
jedes beliebige Element des Stacks zugreifen, und zwar unabhängig davon, ob dies gerade Erweiterung von
SMALLTALK um eine
Beispielklasse
Repräsentation des
Stack -Inhalts
verbergen
oben auf dem Stack liegt. Eine Instanz der Klasse Stack verbirgt also nicht wie in Kursein-
heit 1, Abschnitt 4.3.4 gefordert die Repräsentation ihres Zustands, der Stack -Elemente. Um
dies zu bewirken, muss man anstelle d er indizierten Instanzvariablen eine benannte verwen-
den, die selbst ein Objekt mit indizierten Instanzvariablen hält (ein Zwischenobjekt ; s. Ab-
schnitt 2.2), und die Speicherung der Elemente des Stacks diesem zweiten Objekt übertra-
gen. Die Implementierung sähe dann wie folgt aus:
Klasse  Stack
benannte Instanzvariablen  stackcontent stackpointer
indizierte Instanzvariablen  nein
Instanzmethoden
289 push: anElement
290  "legt neues Element auf Stapel"
291  stackpointer := stackpointer + 1.
292  stackcontent at: stackpointer put: anElement
293 pop
294  "entfernt oberstes Element vom Stapel"
295  stackpointer := stackpointer – 1
296 top
297  "liefert oberstes Element des Stapels"
298  ^ stackcontent at: stackpointer
Auf die Variable stackcontent kann von anderen Objekten nicht direkt zugegriffen wer-
den — sie ist verborgen (und nur noch indirekt, über push: , pop und top manipulier - bzw.
lesbar). Das bedeutet jedoch nicht, dass auf das von stackcontent benannte (Zwischen -
)Objekt nicht zugegriffen w erden kann — aufgrund der oben dargestellten Klassendefini-
tion ist nämlich noch unklar, wo das Objekt, das den Stack -Inhalt fasst, herkommt, so dass
nicht ausgeschlossen werden kann, dass bereits Aliase existieren (s. Abschnitt 1.8). Eine
Möglichkeit, dies auszuschließen, ist, das Stack -Objekt sein Zwischenobjekt selbst erzeugen
zu lassen. Dem wenden wir uns als nächstes zu.
