20.1 Induktiver Aufbau von Typen und Semantik
Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen
gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht
von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean : Alle seine Ope-
rationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergeb-
nis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren
Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst
beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte ex-
terne Formalismen abzubil den. Im Beispiel von Boolean ist dies natürlich die boolesche
Algebra . Jede, die die boolesche Algebra kenn t und akzeptiert, wird auch den Typ Boolean
sofort verstehen und akzeptieren (so er denn den Erwartungen entsprechend definiert ist).
Entsprechend lässt sich ein Typ Fraction mit den Operatio nen +, –, * und / definieren,
der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man
dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-
gleichsoperationen wie =, >, < etc. hinzufügen, ohne in Interpretationsprobleme zu laufen.
Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition
rekursiv auf solche Typen zurückgeführt werden können, kann man „induktiv über deren
Aufbau“ eine B edeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeu-
tung eine denotationale Semantik .
Eine andere, für die praktische Prog rammierung relevantere Möglichkeit
ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten
oder realen, Hauptsache wohlspezifizierten) Maschine abzubilden. Die Abbildung für Basis-
typen wie Rational oder Boolean ist in der Programmiersprache b zw. deren Compiler
gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann sie dies
hingegen nicht sein; deren Bedeutung kann aber vom Compiler, wiede rum „induktiv über
deren Aufbau“, aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, ab-
geleitet werden. Man nennt dies dann auch eine operationale Semantik .
Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf
solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein
vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK
bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht „hart
verdrahtet“, sondern auf dynamisches Binden abgewälzt wird, so sind dafür aber mindes-
tens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und
Float (nicht jedoch Fraction !) sind „fest verdrahtet“, inklusive der Vergleichsrelationen
(die ja die Wahrheitswerte zum Ergebnis haben).
Wenn Sie Kurs 01661 („Datenstrukturen“) bereits belegt haben oder
ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von
Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen.
Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrie-
ben, de ren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei
wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Pro-
tokoll ei nes STRONGTALK -Typs:
1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte kei-
nen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die
Operationen ausgeführt werden, nich t ihren Zustand wechseln. Statt dessen geben
Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also
gewissermaßen alle unveränderlich (vgl. Kurseinheit 1, Abschnitt 4.3.5 ). denotationale
Semantik
operationale
Semantik
Zusammenhang mit
abstrakten
Datentypen
2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen
in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar
vom T yp des Datentyps selbst. Dieses Argument entspricht in der objektorientierten
Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self .
Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Pro-
grammiersprache mit einer Semantik zu versehen.
