37 Ausdrücke
Ausdrücke sind in JAVA
 Literale,
 Variablen,
 die spezielle Variable this ,
 Operatoranwendungen,
 Feldzugriffe der Form a.x, wobei a für den Besitzer des Feldes (ein Objekt oder eine
Klasse) und x für das Feld (die Instanz - bzw. Klassenvariable) steht ( a kann auch
durch super ersetzt werden),
 Methodenaufrufe der Form a.m(…) , wobei a für den Empfänger des Aufrufs steht
oder für super , m für die Methode und … für die tatsächlich en Parameter (die wie-
derum Ausdrücke sind),
 Array -Zugriffe der Form a[i] , wobei a für das Array und i für einen Index steht
(eine ganze, positive Zahl; bei mehrdimensionalen Arrays können entsprechend wei-
tere Indizes in eckigen Klammer n angegeben werden),
 Klasseninstanziierungen der Form new <Klassenname> (<Parameter >)
 Array -Instanziierungen der Form new <Basistypname> [<n>] , wobei
<Basistypname> für den Typ der Elemente steht (also z. B. int bei einem Array
von Integern) und < n> für ei nen Ausdruck, dessen Auswertung eine ganze, positive
Zahl liefert (es können auch mehrere Dimensionen angegeben werden),
 Konditionalausdrücke der Form <Boolescher Ausdruck> ? <Ausdruck 1> :
<Ausdruck 2> , wobei in Abhängigkeit davon, ob <Boolescher Ausdruck > zu
wahr oder zu falsch auswertet, entweder <Ausdruck 1> oder <Ausdruck 2>
ausgewertet wird und das Ergebnis des Gesamtausdrucks liefert,
 Cast-Ausdrücke der Form (<Typname>) <Ausdruck> , wobei <Typname> für das
Ziel des Casts steht und <Ausdruck> für den Ausdruck, dessen Ergebnis den mit
<Typname> bezeichneten Typ annehmen soll , sowie Ausdrücke
 Lambda -Ausdrücke der Form (<Parameterdeklarationen>) -> <Rumpf> ,
wobei <Parameterdeklarationen> den formalen Parameterdeklarationen einer
Methode entspricht und <Rumpf> entweder eine einzelne Anweisung oder ein
Block von Anweisungen, entsprechend einem Methodenrumpf (inkl. der geschweif-
ten Klammern) ist. Falls nur ein Parameter deklariert wird, können die runden Klam-
mern auch weggelassen werden.
Wie man sieht, können in JAVA Ausdrücke rekursiv aus anderen aufgebaut werden: Metho-
denausdrücke beinhalten einen Ausdruck, der für den Empfänger steht sowie möglicher-
weise weitere, die für die Parameter des Methodenaufrufs („der Nachricht“) stehen, Array -
Zugriffe und -Instanzi ierungen beinhalten Ausdrücke zur Bestimmung des Indexes bzw. der
Größe, etc. Dabei müssen die Ausdrücke alle korrekt typisiert sein in dem Sinne, dass der
Typ jedes Ergebnisses eines inneren Ausdrucks mit dem der Stelle des äußeren, an der er
eingesetzt w ird, zuweisungskompatibel sein muss .
Genau wie in SMALLTALK , aber anders als in einigen anderen objektorien-
tierten Programmiersprachen (z. B. C++, C#) gibt es in JAVA nur Call by
value und kein Call by reference ; Methoden, die einem tatsächlich en Pa-
rameter einen anderen Wert zuweisen (wie z. B. eine Methode, die den Inhalt zweier Vari-
ablen tauscht), sind daher in JAVA nicht möglich.60 Dies stellt eine erhebliche Einschränkung
dar.
Die Lambda -Ausdrücke von JAVA, die mit Version 8 eingeführt wurden,
ersetzen die bis dahin geübte Praxis, Funktionen über anonyme innere
Klassen, die ein Interface (s. Abschnitt 40) mit nur einer Methode implementieren, in Ob-
jekte zu verpacken. Geblieben ist die Tatsache, dass Lambda -Ausdrücke den Typ eines In-
terfaces haben, der allerdings nicht direkt angegeben, sondern inferiert wird , und dass die
Funktionen, die die Lambda -Ausdrücke darstellen, über das Interface einen Namen erhalten .
„Anonyme“ Funktionen oder Blöcke wie in SMALLTALK können in JAVA über v ordefinierte
Interfaces erstellt werden: So liefert
ein Objekt vom (Interface -)Typ Function , der wie folgt deklariert ist (zur Bedeutung von
<T, R> s. Kapitel 43):
Demnach heißt die Funktion des Funktionsobjekts „apply“; der Ausdruck f.apply(2) lie-
fert entsprechend 4. Hierbei entspricht apply(.) dem aus SMALLTALK bekannten value:
(s. Abschnitt 4.4 in Kurseinheit 1).
Referenzsemantik hab en: Auch sie können nicht so deklariert werden, dass ihnen anstelle der Refe-
renz eine Referenz auf eine Referenz übergeben wird (s. dazu auch Abschnitt 4.3.2 ). Parameterübergabe
Ähnlich wie i n SMALLTALK Blöcke können Lambda -Ausdrücke in JAVA Kon-
text einfangen und mitnehmen (vgl. Abschnitt 4.4.1 in Kurseinheit 1). Allerdings müssen
die freien (lokalen) Variablen, die aus dem Kontext eingefangen werden können, final
deklariert sein (oder zumindest final deklariert sein können, also ihren Wert nicht mehr
ändern) und ein Rückspringen aus dem Home context mittels return aus dem Lambda -
Ausdruck ist nicht vorgesehen.
Abgesehen von der Typisierung sind die wesentlichen Unterschiede zu
SMALLTALK s Ausdrücken ( Abschnitt 4.1 in Kurseinheit 1) die folgenden:
 In JAVA gibt es auf Objekten d irekte Feldzugriffe ( a.x).
 In JAVA gibt es keine indizierten Instanzvariablen — diese werden durch Arrays als
eigenständige Objekte ersetzt. Array -Objekte können über keine benannten In-
stanzvariablen verfügen.
 In JAVA wird zwischen Operatoranwendungen ( +, – etc.), Methodenaufrufen, dem
Aufruf von Konstruktoren und Arrayzugriffen unterschieden — in SMALLTALK gibt es
nur Methodenaufrufe.
