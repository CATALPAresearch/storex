20 Typdefinitionen und deren Verwendung
Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraus set-
zung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (also beispiels-
weise der Verwendung von Nicht -Zahlen in arithmetischen Ausdrücken), muss bekannt sein,
welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von
SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden w erden können, schnell
gefasst : Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein
Protokoll (s. Abschnitt 4.3.8 in Kurseinheit 1). Ein solches Protokoll definiert einen Typ: Er
umfasst die Menge der Objekte, die über das Protokoll verfügen.
Wenn man nun eine Variable mit einem solchen Protokoll als Typ typisiert und das Pro-
gramm typkorrekt ist, dann ist garantiert, dass jede Methode, die im Protokoll enthalten ist
und die auf der Variable aufgerufen wird, auc h für den Inhalt der Variable, das referenzierte
Objekt, definiert ist. Typfehler, also Fehler der Sorte „ does not understand “ (s. Abschnitt
4.3.2 in Kurseinheit 1), treten dann nicht mehr auf.
Nun kommen in Protokollen aber selbst Variablen vor, nämlich die forma-
len Parameter der Meth oden, die das Protokoll ausmachen. Außerdem ist
eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Ob-
jekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle
definieren also nicht nur Typen , sie verwenden auch selbst welche, nämlich indem sie die
Typen der Ein- und Ausgabe objekte spezifizieren. Ein einfaches Beispiel für eine Typdefini-
tion, die selbst Typen verwendet, ist die folgende:
844 name ^ <String>
845 name: einName <String> ^ <Self>
846 alter ^ <Integer>
847 alter: einAlter <Integer> ^ <Self>
Wie schon bei einer temporären Variable, stehen die Typannotationen von formalen Para-
metern in STRONGT ALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht
allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kenn-
zeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer
Methode wird durch ein vorangestelltes Dach ( ^) gekennzeichnet und folgt auf den letzten
Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Method e
ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zu-
rück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann
der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo -
Typvariable (entsprechend der Pseudovariable self , deren Typ sie darstellt).
Falls Sie sich wundern, dass obige Zeilen kein Schlüsselwort zur Einleitung
der Typdefinition beinhalten: STRONGTALK ist, genau wie SMALLTALK , ein
interaktives, browser -gestütztes System, in dem Typen in Formulare eingetragen und nicht
in Textdateien spezifiziert werden. Gleichwohl f ällt auf, dass innerhalb der Typdefinition in Typen als Teile von
Typdefinitionen
Schema für
Typdefinitionen
den spitzen Klammern (also da, wo Typen stehen sollen) keine Typdefinition auftauchen,
sondern Namen. Und tatsächlich wird in STRONGTALK jeder Typ benannt (in seiner Typdefi-
nition mit einem Namen versehen). Im folgenden werden Typen, ähnlich wie Klassen, in
tabellarischer Form notiert. Der Typ Person etwa mit obigem Protokoll liest sich dann wie
folgt:
Typ Person
Protokoll
848 name ^ <String>
849 name: einName <String> ^ <Self>
850 alter ^ <Integer>
851 alter: einAlter <Integer> ^ <Self>
Selbsttestaufgabe 20.1
Definieren Sie den Typ Boolean gemäß obigem Schema!
In STRONGTALK ist die Protokollbildung der einzige sog. Typkonstruktor ,
d. h., das einzige Sprachkonstrukt, mit dem man neue Typen definieren kann. Andere Pro-
grammiersprachen sehen ein reichhaltigeres Angebot vor: In PASCAL beispiel sweise gibt es
die Typkonstruktoren record , array of , set of , file of , Zeiger auf ( ^) sowie Aufzäh-
lungen ( enumerations ) und Teilbereiche ( ranges ). In C++ gibt es u. a. class und struct
(entsprechend record in PASCAL ), JAVA, C# und EIFFEL bieten auch jeweil s verschiedene
Typkonstruktoren an. Für eine puristische Sprache wie SMALLTALK bzw. STRONGTALK reicht
jedoch einer vollkommen aus.
Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen,
deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden
müsste . Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine
Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der
Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das
wirft natürlich die Frage auf, wie man T ypen unter zwangsläufiger Selbstbezüglichkeit über-
haupt eine Bedeutung beimessen kann.
