4.6.2 Wiederholung
Etwas weiter ausholen müssen wir für die Implementierung von Wiederholungen (Schlei-
fen): Da das Abbruchkriterium von Schlei fen immer wieder (bei jedem Schleifendurchlauf)
ausgewertet werden muss , kann nicht einfach einmal eine Nachricht an (eine Variable mit
Inhalt) true oder false gesendet werden. Vielmehr muss die Auswertung des Abbruch-
kriteriums selbst in einem Block stattf inden, der bei jedem Schleifendurchlauf neuerlich aus-
gewertet wird. Aber auch das ist kein Problem: Der Nachrichtenempfänger ist einfach ein
Block, dessen Auswertung entweder true oder false zurückliefert; der Parameter der
Nachricht ist dann der Block, de r den Schleifenrumpf darstellt, wie in:
212 [ x < 5 ] whileTrue: [ x := x + 1 ]
whileTrue: ist dazu als Methode für Blöcke wie folgt implementiert (beachten Sie, dass
Sie den Empfänger, einen Block, in der Methodendefinition nicht direkt sehen; er wird durch
self repräsentiert und ist nicht mit dem Parameter aBlock , ebenfalls ein Block, zu ver-
wechseln):
213 whileTrue: aBlock
214 self value
215  ifTrue: [
216  aBlock value.
217  self whileTrue: aBlock].
218 ^ nil
Wie man sieht, wird hier die Schleife durch eine sog. Endrekursion simu-
liert: whileTrue: ruft whileTrue: am Ende selbst wieder auf. Wegen
der Performanz (oder möglicher Beschränkungen der Anzahl der Schlei-
fendurchläufe durch die Größe des Aufrufstacks) braucht man sich dabei keine Sorgen zu
machen: Da hinter dem rekursiven Aufruf nichts mehr passiert (desweg en ja Endrekursion),
kann dieser vom Compiler in eine echte Schleife übersetzt werden. Für die Implementierung
von whileFalse: (mit entsprechender Semantik) braucht übrigens nur das ifTrue: aus
Zeile 215 durch ifFalse: ersetzt und der rekursive Aufruf entsprechend angepasst zu
werden.
Für die ebenfalls aus anderen Sprachen bekannten For -Schleifen hat SMALLTALK eine andere
elegante Lösung parat, auf die wir im nä chsten Abschnitt eingehen werden.
