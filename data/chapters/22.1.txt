22.1 Strukturäquivalenz
Um strukturelle Typäquivalenz festzustellen, werden die Definitionen der beteiligten Typen
rekursiv expandiert , was sovie l heißt wie dass in einer Typdefinition vorkommende Namen
anderer Typen durch ihre Struktur ersetzt werden. Nimmt man beispielsweise die Typdefi-
nitionen
Typ Person
Protokoll
870 sitz ^ <Wohnung>
871 sitz: einWohnsitz <Wohnung> ^ <Self>
Typ Wohnung
Protokoll
872 straße ^ <String>
873 straße: einStraße <String> ^ <Self>
874 ort ^ <String>
875 ort: einOrt <String> ^ <Self>
Typ Firma
Protokoll
876 sitz ^ <Büro>
877 sitz: einFirmensitz <Büro> ^ <Self>
Typ Büro Unterscheidung von
nominaler und
struktureller
Typäquivalenz
formale
Eigenschaften der
Typäquivalenz
Protokoll
878 straße ^ <String>
879 straße: einStraße <String> ^ <Self>
880 ort ^ <String>
881 ort: einOrt <String> ^ <Self>
dann sind die Typen Person und Firma sowie Wohnung und Büro jeweils strukturäquiva-
lent, aber nicht namensäquivalent. Bei der Strukturäquivalenz haben Namen also lediglich
die Funktion der abkü rzenden Schreibweise, bei der Namensäquivalenz hingegen auch eine
von der Struktur unabhängige Bedeutung. Namensäquivalenz impliziert Strukturäquivalenz,
aber nicht umgekehrt; Namensäquivalenz ist somit das stärkere Konzept.
Strukturäquivalenz als Bedingung der Zuweisungskompatibilität reicht
aus, um Typfehler , also logische und Laufzeitfehler, die auf der Annahme
einer nicht vorliegenden Eigenschaft (Methode) bei einem Wert einer Variable basieren, zu
verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfän-
gerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.
So kann z. B. bei erf olgreicher Typprüfung (und daher vorliegender Typkorrektheit) ohne
Kenntnis der konkreten Inhalte der Variablen sichergestellt werden, dass bei Vorliegen der
Deklaration p <Person> der Ausdruck
882 p sitz straße: 'Heimatstraße'
keine Typfehler produziert, und gleichzeitig der Ausdruck
883 p sitz: 'zuhause'
schon zur Übersetzungszeit als fehlerhaft zurückgewiesen wird, da er zu einer Variablen-
fehlbelegung (die in SMALLTALK noch problemlos möglich gewesen wäre) führt. Man be-
achte, das letztere sogar zu einer Speicher schutzverletzung führen könnte, wenn die Vari-
able p — wie in vielen Sprachen mit Typsystem — Wertsemantik hätte, nämlich dann, wenn
der übergebene String größer ist als der zur Aufnahme der Wohnung vorgesehene Spei-
cherplatz.
Strukturäquivalenz ist eine rein syntaktische Bedingung. Insbesondere
können bei geforderter Strukturäquivalenz Typen zufällig zuweisungskompatibel sein, die
inhaltlich überhaupt nichts miteinander zu tun haben. Dadurch können Objekte, die eigent-
lich getre nnten Typen (disjunkten Wertebereichen) angehören, über Kreuz und über die
Typgrenzen hinweg zugewiesen werden. Semantische Fehler sind also im mer noch möglich.
Man trifft daher in Sprachen mit Strukturäquivalenz gelegentlich die Praxis an, jedem Typ
eine für ihn charakteristische Methode exklusiv zuzuordnen, so dass er mit keinem anderen
mehr strukturäquivalent ist. Diese Technik nennt man Type branding . Bedeutung der
Strukturäquivalen z
Type branding
