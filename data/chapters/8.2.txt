8.2 Initialisierung
Konstruktoren sind in SMALLTALK also Klassenmethoden, die neue Instanzen der jeweiligen
Klasse zurückliefern. Dabei haben zunächst alle Instanzvariabl en nach der Erzeugung einer
Instanz den Wert nil. Sollen diese Instanzvariablen mit sinnvollen Anfangswerten belegt
werden, müssen ihnen diese explizit zugewiesen werden. Man spricht dann von einer Initi-
alisierung der Instanz.
Nun sollen nicht immer alle Instanzen einer Klasse gleich initialisiert werden. Es ist daher
möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu defi-
nieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die
Klasse Time sind mit
310 midnight
311 ^ self seconds: 0
312 noon
313 ^ self seconds: (SecondsInDay / 2)
gegeben, die jeweils die Klassenmethode (den Konstruktor) seconds: auf Time (vertreten
durch self ) aufrufen, die wiederum mittels basicNew eine Instanz von Time erzeugt und
anschließend initialisiert:
314 seconds: seconds
315 ^ self basicNew ticks: (Duration seconds: seconds) ticks
Dabei ist ticks: eine Instanzmethode der Klasse Time , die auf der (mit basicNew ) frisch
erzeugten Instanz aufgerufen wird und diese initialisiert:
316 ticks: anArray
317  "ticks is an Array: { days. seconds. nanoSeconds }"
318 seconds := anArray at: 2.
319 nanos := anArray at: 3
Parameter der Initialisierung ist hierbei (Duration seconds: seconds) ticks , wobei
Duration eine Klasse und seconds: ein Konstruktor dieser Klasse ist.
Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar
sind, kann auch eine Klassenmethode wie new nicht auf sie zugreifen. Die I nitialisierung
muss daher von Instanzmethoden wie ticks: vorgenommen werden, die jedoch nicht der
Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen wer-
den können. Das ist immer dann ein Problem, wenn auch Instanzvariab len initialisiert wer-
den müssen, deren Existenz nach außen verborgen werden soll (s. Abschnitt 4.3.4 ) und die
deswegen nicht direkt über Zugriffsmethoden gesetzt werden können sollen. Aus diesem
Grund sehen new und new: standardmäßig den Aufruf der Methode initialize vor (s.
Zeilen 307 und 309 oben ), in der alle Initialisierungen vorgenommen werden kö nnen, ohne
dass etwas über den Aufbau der Instanzen nach außen verraten würde. In anderen Spra-
chen wie beispielsweise C++, JAVA oder C# sind Konstruktoren daher auch keine Klassen-
methoden, sondern haben eine Art Zwitterstatus: Sie werden auf einer Klasse a ufgerufen,
werden aber wie Instanzmethoden auf der neuen Instanz ausgeführt und können somit
auch auf die Instanzvariablen der neu erzeugten Instanz zu greifen. Man beachte jedoch,
dass die Instanzmethode ticks: kein Implementationsgeheimnis preisgibt: Dass Objekte
der Klasse Time die Zeit in Sekunden und Nanosekunden speichern ist an der Methode
ticks: nicht zu erkennen.
Vor diesem Hintergrund können wir das Beispiel der zweiten Implemen-
tierung von Stack aus Abschnitt 7.2 wieder aufgreifen und die noch fe h-
lende Initialisierung der Variablen stackcontent und stackcounter nachliefern:
Klasse  Stack
Klassenmethoden
320 new
321   "liefert neue, gebrauchsfertige Instanz von Stack"
322  ^ self basicNew initialize
benannte Instanzvariablen  stackcontent stackpointer
indizierte Instanzvariablen  nein
Instanzmethoden
323 initialize
324  "setzt Anfangswerte"
325  stackcontent := Array new: 100.
326  stackpointer := 0 Initialisierung von
Stacks
327  ^ self "kann entfallen"
328 push: anElement
329  "legt neues Element auf Stapel"
330  stackpointer = stackcontent size
331  ifTrue: [self error: 'Stack leider voll']
332  ifFalse: [ stackpointer := stackpointer + 1.
333    stackcontent at: stackpointer put: anElement]
334 pop
335  "entfernt oberstes Element vom Stapel"
336  stackpointer = 0
337  ifTrue: [self error: 'Stack leider leer']
338  ifFalse: [ stackpointer := stackpointer – 1]
339 top
340  "liefert oberstes Element des Stapels"
341  stackpointer = 0
342  ifTrue: [self error: 'Stack leider leer']
343  ifFalse: [^ stackcontent at: stackpointer]
Man beachte, dass das Zwischenobjekt eine Instanz der Kla sse Array ist, die hier (in Zeile
325) nicht wie noch in Kurseinheit 1 notwendig durch ein Literal, sondern durch eine expli-
zite, programmatische Instanziierung (mittels new: ) erzeugt wurde.
Alternativ zu obiger Konstruktion kann die Initi alisierung von Instanzvari-
ablen auch zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt werden. Man
spricht dann von einer Lazy initialization (lazy oder faul deswegen, weil man die Initiali-
sierung solange hinausschiebt, wie irgend möglich). Dazu muss jedoch vor jedem lesenden
Zugriff auf die (faul initialisierte) Instanzvariable geprüft werden, ob der Wert der Variable
immer noch nil ist — falls ja, muss er durch den gewünschten Anfangswert (der sonst in
der Standardinitialisierungsmethode zu finden wäre) ersetzt werden. Um nicht jeden lesen-
den Zugriff auf die Variable im Programm mit einer entsprechenden Abfrage versehen zu
müssen, empfiehlt es sich bei Verwendung von Lazy initialization , alle, also auch klassenin-
terne, Zugriffe auf Instanzvariablen über einen entsprechenden Getter durchzuführen, der
den Inhalt der Variable vor seiner Preisgabe prüft und ggf. erst setzt. Statt
344 push: anElement
345  "legt neues Element auf Stapel"
346 stackpointer isNil ifTrue: [stackpointer := 0].
347 stackcontent isNil ifTrue: [stackcontent := Array new: 100].
348 stackpointer = stackcontent size
349  ifTrue: …
350 pop
351  "entfernt oberstes Element vom Stapel"
352 stackpointer isNil ifTrue: [stackpointer := 0].
353 stackpointer = 0
354  ifTrue: …
355 top
356  "liefert oberstes Element des Stapels" Lazy initialization
357 stackpointer isNil ifTrue: [stackpointer := 0].
358 stackpointer = 0
359  ifTrue: …
wo bei jeder Verwendung ggf. faul initialisiert wird, würde man also
360 stackpointer
361  "lazy: liefert den ggf. zuvor initialisierten Stack pointer "
362 stackpointer isNil ifTrue: [stackpointer := 0].
363 ^ stackpointer
364 stackcontent
365  "lazy: liefert den ggf. zuvor initialisierten Stack content"
366 stackcontent isNil ifTrue: [stackcontent := Array new: 100].
367 ^ stackcontent
368 push: anElement
369  "legt neues Element auf Stapel"
370 self stackpointer = self stackcontent size
371  ifTrue: …
372 pop
373  "entfernt oberstes Element vom Stapel"
374 self stackpointer = 0
375  ifTrue: …
376 top
377  "liefert oberstes Element des Stapels"
378 self stackpointer = 0
379  ifTrue: …
schreiben (man beachte das self vor stackpointer und stackcontent — hier wird
jeweils ein Getter aufgerufen).
Wie man sieht, ist die Programmiererin bei der Lazy initialization über-
haupt nicht faul —sie muss sogar einiges mehr an Code schreiben, als bei
einer Standardinitialisierung notwendig wäre. Das laufende Programm
spart sich jedoch den Preis der Initialisierung, wenn diese nie notwendig wird, wenn also im
Programmablauf der Wert der zu initialisierenden V ariable nie oder erst nach einer anderen
Zuweisung abgefragt wird (was im Beispiel vom Stack freilich nicht der Fall ist). Sie lohnt
sich also immer dann, wenn die Initialisierung aufwendig und die Abfrage des Anfangswer-
tes selten ist. Ein weiterer Vorteil der Lazy initialization ist, dass die Initialisierung nie verges-
sen werden kann; dies ist insbesondere dann wertvoll, wenn die Initialisierung nicht wie
oben beschrieben vom Konstruktor selbst, sondern von einer separaten Methode durchge-
führt wird und den Benutzerinnen der entsprechenden Klasse vielleicht nicht klar ist, dass
sie nach dem Konstruktor auch noch die Initialisierungsmethode aufrufen müssen. Kon-
struktoren, die wie in Zeilen 307 und 309 oben ) implementiert wurden, suchen das zu ver-
hindern, indem sie die Initialisierungsme thode selbst aufrufen; manchmal kann der Kon-
struktor doch nur schlecht geändert werden (s. z. B. Abschnitt 10.3) und man wird auch
nicht verhindern können, dass, anstelle von new, basicNew direkt und ohne initialize
aufgerufen wird. Vor- und Nachteile
einer Lazy
initialization
Selbsttestaufgabe 8.1
Begründen Sie, warum eine Kapselung der Lazy initialization durch eine Zugriffsmethode dem Sinn
der Standardinitialisierung per initialize möglicherweise entgegensteht.
Nachdem nun hinlänglich klar geworden sein sollte, welche Möglichkeiten
es zur Initialisierung von Instanzvariablen gibt, bleibt noch die Frage nach
der Initialisierung von Klassenvariablen. Klassenvariablen werden nämlich, genau wie In-
stanzvariablen, standardmäßig zu nil initialisiert und soll eine Klass envariable einen ande-
ren Anfangswert haben (z. B. weil es sich dabei um eine Konstante handelt, die für alle
Instanzen der Klasse eine Rolle spielt), dann muss ihr dieser Wert explizit zugewiesen wer-
den. Da Klassen ja Instanzen ihrer Metaklassen sind, dies e Metaklassen aber automatisch
mit der Erzeugung der Klassen angelegt werden und das Klassendefinitionsschema keine
Möglichkeit vorsieht, einen Konstruktor für die Metaklasse vorzugeben, muss eine spezielle
Klassenmethode (häufig ebenfalls „initialize“ gen annt) für die Initialisierung der Klassenva-
riablen vorgesehen werden. Diese ist dann nach Anlegen der Klasse einmalig aufzurufen.
Da das aber leicht vergessen werden kann, ist Lazy init ialization für Klassenvariablen eine
sinnvolle Alternative. Allerdings stellt sich hier wieder das Problem des direkten Zugriffs auf
die (Klassen -)Variable (aus dem Kontext der Klasse selbst und ihrer In stanzen), der in SMALL-
TALK nicht unterbunden werden kann (vgl. Selbsttestaufgabe 8.1).
Selbsttestaufgabe 8.2
Schreiben Sie eine Methode new, die dafür sorgt, dass alle mit ihr erzeugten Instanzen in einer Klas-
senvariable MeineInstanzen gespeichert werden.
