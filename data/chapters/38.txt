38 Anweisungen, Blöcke und Kontrollstrukturen
Genau wie in SMALLTALK werden in JAVA Ausdrücke im Rahmen der Ausführung von Anw ei-
sungen ausgewertet. Anders als in SMALLTALK gibt es in JAVA jedoch eine Vielzahl von Schlüs-
selwörtern, die Anweisungen einleiten. Dennoch ist es auch in JAVA möglich, bestimmte
Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden A usdruck
durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisun-
gen, Methodenaufrufe und Klasseninstanziierungen (s. Kapitel 37) direkt zu Anweisungen.
Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK , das
Semikolon in JAVA kein Trennzeichen, sondern Teil der Anweisung ist.
Nahezu alle Anweisungen finden sich in JAVA-Programmen innerhalb von Methoden.61 Blö-
cke sind in JAVA lediglich (in geschweifte Klammern eingefasste ) Abschnitte des Quelltextes ,
die die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbe-
reich für darin enthaltene Variablendeklarationen darstellen . Blöcke wie in SMALLTALK kenn t
JAVA erst seit Version 8, als Lambda -Ausdrücke .
Es sind also Variablendeklarationen, Methodenaufrufe (inkl. der Kon -
struk toraufrufe) und Zuweisungen Anweisungen. Alle anderen Anwei-
sungen werden durch Schlüsselwörter eingeleitet und realisieren allesamt Kontrollstruktu-
ren, die den Kontroll fluss eines Programms dazu bringen, von der normalen, sequentiellen
Ausführung abzuweichen. Im einzelnen sind dies
 die If -Anweisung der Form if (<Boolescher Ausdruck>) <Statement> , bei
der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck>
zu true auswertet;
 die If -else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement
1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird,
wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst;
 die Switch -Anweisung der Form
switch (<Ausdruck>) {
case <Literal 1> : <Anweisungsliste 1>
case <Literal 2> : <Anweisungsliste 2>
…
default: <Anweisungsliste>
}
wobei <Ausdruck> sowie <Literal 1>, <Literal 2> etc. alle vom Typ char ,
byte , short , int (bzw. einem der dazugehörigen Wrapper -Typen) , String oder
von einem Aufzählungstyp sein müs sen und <Anweisungsliste 1> etc. für Fol-
gen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen
werden können (aber nicht müssen) ;
 die While -Anweisung der Form while (<Boolescher Ausdruck>)
<Statement> , die im wesentlichen der If -Anwe isung entspricht mit dem Unter-
schied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis
<Ausdruck> zu false auswertet;
 die Do -Anweisung der Form do <Statement> while (<Boolescher
Ausdruck>) , die im wesentlichen dem While -Statement ent spricht mit dem Unter-
schied, dass <Ausdruck> immer erst nach Ausführung von <Statement> ausge-
wertet wird (man beachte, dass Statement kein Block sein muss; das das Statement
abschließende Semikolon wirkt dann etwas deplaziert (so wie das vor else beim If -
Statement) ;
 die For -Anweisung in der Form
for (<Initialisierungsausdruck>; <Boolescher Ausdruck>;
<Veränderungsausdruck>) <Statement>62
Gleichwohl k önnen in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke
erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen
sind Erbe von C.
die <Statement> solange ausführt, bis der Boolesche Ausdruck zu true auswertet
(auf die schier unendlichen Mögl ichkeiten, was sich alles in
<Initialisierungsausdruck> und <Veränderungsausdruck> unterbringen
lässt, gehen wir hier nicht ein; traditionell wird im Initialisierungsausdruck jedoch ein
Anfangswert für eine Laufvariable63 gesetzt, der dann im Veränderungsau sdruck
modifiziert, nicht selten hochgezählt, wird);
 die (erweiterte) For-Anweisung in der Form for (<Variable> : <Ausdruck>)
<Statement> , die <Statement> für alle Werte, die <Ausdruck> liefert, einmal
ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable (wobei
<Ausdruck> zu diesem Zweck entweder vom Typ eines Arrays sein oder das Inter-
face Iterable implementieren muss , was soviel bedeutet wie dass das Objekt, zu
dem <Ausdruck> auswertet, die Methoden hasNext() und next() anbieten
muss );
 die B reak-Anweisung der Form break; bzw. break <Label>; , die innerhalb von
Schleifen oder Switch -Statements dazu führt, dass diese sofort verlassen werden,
wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem
äußeren Switch -Statement vorangestellt wurde;
 die Continue -Anweisung der Form continue; bzw. continue <Label>; , die
innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch
<Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr
ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, wei-
tergemacht wird (Continue -Anweisungen außerhalb von Schleifen bzw. mit einer
Nicht -Schleife als Label sind ein Syntaxfehler);
 die Return -Anweisung der Form return; bzw. return <Ausdruck> ;, die be-
wirkt, dass die umschließende Methode sofort beendet und ggf. der Wert der Aus-
wertung von <Ausdruck> zurückgegeben wird ( return; darf auch in einem Kon-
struktor vorkommen);
 die Synchronized -Anweisung der Form synchronized (<Ausdruck>) <Block> ,
die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausge-
führt wird, wenn das mit dem Objekt, zu dem <Ausdruck> auswertet, verbundene
Lock dies zu lässt (s. Abschnitt 47.3);
 die Try -Anweisung der Form
try <Try -Block>
catch (<formaler Parameter 1>) <Catch -Block 1>
catch (<formaler Parameter 2>) <Catch -Block 2>
…
finally <Finally -Block>
ment, einschließlich des enthaltenen Statements <Statement> , beschränkt.
wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass
sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen
catch (<formalerParameter1>) <Catch -Block1> usw. für verschiedene Ar-
ten von Laufzeitfehlern verschiedene Behandlung sblöcke angegeben werden kön-
nen und wobei finally <Finally -Block> einen Block zu spezifizieren erlaubt,
der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt (oder abge-
brochen) wurden (kann auch weggelassen werden);
 die Throw -Anweisung der Form throw <Exception>; , die das Programm eine
Exception werfen lässt;
 die Assert -Anweisung der Form assert <Ausdruck 1>; oder assert
<Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Aus-
druck und <Ausdruck 2> von beliebigem Typ außer dem von void sein muss , mit
der Bedeutung, dass wenn <Ausdruck 1> zu false auswertet, dass dann das
Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wobei ggf.
das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird.
Außerdem ist die lee re Anweisung, bestehend aus einem einzelnen Semikolon, eine Anwei-
sung.
Bemerkungen:
 Das Weglassen von break; am Ende einer Liste von Anweisungen in einem Case -
Zweig der Switch -Anweisung wird als Fall through bezeichnet und bewirkt, dass mit
den Anweisungen des nächsten Case -Zweigs fortgefahren wird. Dies ermöglicht,
mehrere Fälle zusammenzuführen, ist aber eines der fehlerträchtigsten Konstrukte
C-artiger Sprachen.
 Die Assert -Anweisung kann Seiteneffekte haben, also z. B. die Werte von Variablen
aus umgebenden Blöcken oder von Instanzvariablen ändern. Wenn der Ablauf des
Programms von diesen Werten abhängt, macht es einen Unterschied, ob ein Pro-
gramm mit oder ohne Prüfung der Assertions ausgeführt wird. Das ist ein starkes
Stück.
 Assert -Anweisungen sind ein erster zarter Versuch, in JAVA auch noch andere Inva-
rianten als die Typinvarianten un terzubringen. Dabei findet die Überprüfung dieser,
mittels assert eingebrachten Invarianten im Gegensatz zum Großteil der Typprü-
fung erst zur Laufzeit statt, indem nämlich die entsprechenden Statements ausge-
führt werden. Dabei beziehen sich die Bedingungen , die die Invarianten formulieren,
häufig auf Methoden des Programms, für die die Invarianten angegeben werden
sollen. Da diese Methoden aber auch den Zustand des Programms ändern können,
kann man einer Zusicherung mit assert nicht ansehen, ob sie seiten effektfrei ist.
Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden nicht als An-
weisungen formuliert, sondern als Quellcodeannotationen, und stellen zudem si-
cher, dass alle Zugriffe auf Programmelemente, die zur Laufzeit notwendig sind, den
Zustand des Programms nicht verändern (mehr zu diesem Thema im Kurs 01853
sowie in Abschnitt 52.6 von Kurseinheit 5).
