29.4 Beschränkter parametrischer Polymorphismus
Obiges Beispiel hat gezeigt, dass die einfache Form des parametrischen Polymorphismus für
Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich ist: Da die
Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den
Typ implementierenden Klassen) keine Aussagen über den Typ machen. Außerhalb, bei der
Verwendung (Instanziierung) der Typdefinition, geht das s chon, da hier die Typvariable
durch einen Typ ersetzt ist.
Was man also gern hätte, ist, dass die Typvariable innerhalb der mit ihr
parametrisierten Typdefinition selbst wertbeschränkt ist, und zwar derart,
dass man bei den als Werte zulässigen Typen ein bestimmtes, benötigtes Protokoll voraus-
setzen kann. Die tatsächlich en Typparameter sind dann nicht mehr beliebig zu wählen, son-
dern nur noch aus solchen Typen, die die Einschränkungen erfüllen. Eine Möglichkeit, das
zu erzielen, wäre, Metatypen einzuführen, deren Wertebereiche Typen mit durch die Me-
tatypen vorgegebenen Eigenschaften sind. Diese Möglichkeit wird jedoch in der Praxis nicht
genutzt.
Stattdessen verwendet man eine Art der Beschränkung des Wertebe-
reichs von Typvariablen, die auf Subtyping beruht. Wenn man nämlich
erzwingen kann, dass ein tatsächlich er Typparameter (also der Wert der Typvariable) Subtyp
eines bestimmten Typs ist, der die benötigten Eigenschaften (Methoden) umfasst , dann ist
damit alles erreicht, was man benötigt: Aufgrund der Regeln des Subtyping hat jeder solche
Typ die Eigenschaften des Supertyps (s. Kapitel 26).
Ein solchermaßen durch einen Supertyp beschränkte parametrische
Typdefinition ist die folgende:
Typ MyCollection
Typvariablen  E < Number
Der Rest der Definition geht wie oben. Der Ausdruck E < Number im Abschnitt „Typvari-
ablen“ ist Deklaration und Beschränkung zugleich; die Beschränkung ist aber wie gesagt
keine Typisierung wie in normalen Variablendeklarationen. Sie drückt vielmehr aus, dass die
Typen, die als Werte für E eingesetzt werden dürfen, Su btypen von Number sein müssen.
Die Deklaration aus Zeile 951 wird damit unzulässig und führt zu einem entsprechenden
Typfehler während der statischen Typprüfung ; die Deklaration
962 | liste <MyCollection[Integer]> | wertbeschränkte
Typvariablen
Supertypen als
Schranken
Beispiel
ist hingegen OK.
