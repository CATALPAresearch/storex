29.5 Rekursiv beschränkter parametrischer Polymorphismus
Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Ein Beispiel für
einen rekursiven Typ hatten Sie oben sc hon kennengelernt: Der (zur Klasse Person gehö-
rende) Typ Person hat Methoden, die Person als Parameter - bzw. Rückgabetypen haben.
Rekursive Typen sind ein wichtiges Instrument der Programmierung: Ohne sie wären dyna-
mische Strukturen wie beispielsweise verz eigerte Listen oder Bäume kaum möglich. Rekur-
sive Typen machen aber auch bestimmte Probleme — so ist beispielsweise die strukturelle
Äquivalenz zweier rekursiver Typen nicht so leicht festzustellen, da die dazu notwendige
Expansion rekursiver Typen (also das Einsetzen der Struktur für jeden darin vorkommenden
Typnamen; vgl. Abschnitt 22.1) unendlich große Definitionen ergibt.
Es ergibt sich nun ein weiteres Problem, wenn man in einer parametri-
schen Typdefinition den Typ eines Methodenarguments (eines formalen
Parameters einer Methode) variabel halten möchte, dieser Typ aber aus-
gerechnet der definierte ist (eine binäre Methode ; vgl. Fußnote 21 in Ka-
pitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das
Objekt, das gleich sein soll, vom selben Typ sein muss wie das, mit dem man Gleichheit
feststellen möchte. Für den Typ Object schreibt man dazu einfach
Typ Object
Protokoll
963 = einObjekt <Object> ^ <Boolean>
964 …
für den Typ Number
Typ Number
Protokoll
965 = eineZahl <Number> ^ <Boolean>
966 …
usw. Nun ist aber Number ein Subtyp von Object , so dass man die Deklaration von =
eigentlich aus Object übernehmen könnte — wenn der Typ des Parameter s automatisch
so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre
man vielleicht versucht, den Gleichheitstest in Object einfach als = einObject <Self>
^ <Boolean> zu deklarieren, aber das würde, wenn die Pseudo -Typvariable Self beim
Subtyping jeweils den Subtyp annehmen soll, zu einer kovarianten Redefinition mit den parametrische
polymorphe
Definition binärer
Methoden
bereits bekannten Problemen führen.55 Auch hier bietet parametrischer Polym orphismus
eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.
Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvari-
able T. Nun kann man schlecht
Typ T
Typvariablen  T
Protokoll
967 = einT <T> ^ <Boolean>
schreiben, da der Typ dann keinen Namen hätte und somit auch nicht verwendbar (referen-
zierbar) wäre. Was man aber sehr wohl machen kann, ist, einen allgemeinen parametrischen
Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und de r den Parametertyp
des Tests variabel hält, wie in
Typ Equatable
Typvariablen  T
Protokoll
968 = einT <T> ^ <Boolean>
Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht pa-
rametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man
den zu definierenden Typ gleichzeitig als tatsächlich en Typparameter einsetzt. So l iefert z. B.
Typ Integer
Supertyp Equatable[Integer]
eine Methode mit der Signatur = einT <Integer> ^ <Boolean> im Protokoll von
Integer . Allerdings kann man so nicht erzwingen, dass bei der Definition des Typs
Integer oben genau Integer als tatsächlich er Typparameter eingesetzt wird; es hätte
auch jeder andere Typ, z. B. String , sein können — der Gleichheitstest wäre dann mit =
einT <String> ^ <Boolean> falsch deklariert.
Genau diese Beschränkung des tatsächlich en Typparameters kann man nun m it einer stilis-
tischen Figur erreichen, die vermutlich manch einer von Ihnen erhebliche Kopfschmerzen
bereiten wird (zumindest macht sie das mir immer wieder aufs neue): Man beschränkt den
formalen Typparameter T von Equatable auf einen Subtyp von Equatable[T] , wobei
das Vorkommen von T in Equatable[T] eine Verwendung der gerade erst eingeführten
Typvariable T darstellt.
55 Genau das macht übrigens auch EIFFELs like Current (s. Abschnitt 52.5.2 ). Lösung durch
Rekursion
Typ Equatable
Typvariablen  T < Equatable[T]
Protokoll
969 = einT <T> ^ <Boolean>
verlangt also im obigen Beispiel der Typdefinition von Integer als Subtyp einer Instanziie-
rung der parametrischen Definition von Equatable , dass der tatsächlich e Typparameter
Integer ein Subtyp von Equatable[In teger] sein muss . Genau das sagt aber die obi ge
Typdefinition von Integer aus! Stünde dort Equatable[String] oder irgend etwas an-
deres als Typschranke, wäre dies nicht mehr der Fall (s. Abschnitt 29.3) und die Definition
von Integer verursachte einen statisch feststellbaren Typfehler .
Wenn Sie hier ein Verständnisproblem haben, trösten Sie sich — es dauert
eine Weile, bis man es verstanden hat, und noch länger, bis solche Fi gu-
ren zum aktiven Repertoire gehören. Gleichwohl sollten Sie sich damit befassen: Das JAVA-
Collections -Framework in der Version von JAVA 5 ist voll solcher Typdefinitionen, nicht , weil
sie schön sind, sondern weil man sie braucht, um das Framework typsiche r zu machen, ohne
seine Flexibilität zu opfern. Auch Sie werden, wenn Sie objektorientiert programmieren,
über kurz oder lang solche Konstrukte von sich geben müssen.
