36.4 Überschreiben, Überladen und dynamisches Binden
Nun hat die Subklasse die Möglichkeit, neue Member hinzu zufügen und
bereits bestehende zu redefinieren. In JAVA ist die Möglichkeit der Redefinition auf die Mög-
lichkeit des Überschreibens eingeschränkt, was soviel heißt wie dass eine Methode mit der
gleichen Signatur (bestehend aus Methodenname und formalen Par ametertypen) noch ein-
mal definiert werden kann, und zwar mit geänderter Implementierung. Auch darf die Me-
thode den Rückgabetyp kovariant, also nach unten, abändern (vgl. dazu die Diskussion in
Kurseinheit 3, Abschnitt 26.3). Dass die überschreibende Methode über die Einhaltung der
Typinvarianten, die mit ihren (geerbten) Parametern verbun den sind, hinaus nur etwas tut,
das mit der überschriebenen Methode kompatibel ist, dass sie also nicht mit dem erwarteten
Verhalten bricht, kann durch die Sprachdefinition JAVAs nicht erzwungen werden — hier ist
die Programmiererin in der Verantwortung (vgl. dazu auch die Abschnitt e 52.6 in Kursein-
heit 5 und 54.1 in Kurseinheit 6).
Nun kann man in JAVA auch Methoden mit gleichem Namen, aber ver-
schiedenen Parametertypen in derselben oder einer Subk lasse haben. Diese Methoden
nennt man dann überladen . Es ist wichtig, zu verinnerlichen, dass in JAVA Überladen und
Überschreiben zwei grundverschiedene Dinge sind, obwohl man in beiden Fällen nichts wei-
ter tut als eine Methode mit bereits vorhandenem Namen noch einmal zu definieren: Beim
Überladen wird eine neue Methode eingeführt, beim Überschreiben wir d eine bereits be-
stehende redefiniert. Diese Unterscheidung spielt beim dynamischen Binden eine entschei-
dende Rolle.
Um das dynamische Binden JAVAs genau zu verstehen (und damit das
Verhalten eines Programms vorhersagen zu können), muss man sich den Bindealgorithmus
vor Augen halten. Dieser geht wie folgt vor. Überschreiben
Überladen
dynamisches Binden
Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methoden-
deklaration gebunden, und zwar an genau die, die die folgenden Bedingungen erfüllt:
1. Sie hat den gleichen Namen und die gleiche Anzahl Parameter59 wie die aufgeru-
fene Methode.
2. Sie ist in der Klasse, die zu dem deklarierten Typ des Ausdrucks gehört, der das
Empfängerobjekt liefert (nicht selten einfach eine Variable), deklariert oder wird von
einer ihr er Superklassen geerbt.
3. Die deklarierten Parametertypen des Aufrufs (die deklarierten tatsächlich en Parame-
tertypen) sind jeweils Subtypen der deklarierten Parametertypen der Methodende-
klaration (der deklarierten formalen Parametertypen).
4. Es gibt keine ande re Methode, die die gleichen Voraussetzungen erfüllt, deren de-
klarierte formale Parametertypen aber gleich weit entfernt oder näher an den Typen
des Aufrufs sind (Entfernung hier gemessen als die Anzahl der Subtypen, die dazwi-
schen liegen).
Damit ist dann die oberste (Wurzel) einer Menge von Methoden gefunden, die möglicher-
weise in Subklassen überschrieben wird und an eine von denen der Methodenaufruf dann
dynamisch gebunden wird. Man beachte, dass die überschreibenden Methoden dieselbe
Signa tur haben müssen wie die überschriebene; diese Methoden bilden eine Art Familie,
von der eine zur Bindung herausgesucht wird.
Zur Laufzeit wird dann nur noch der tatsächliche Typ des Empfängerobjekts (die Klasse, von
der es eine Instanz ist) bestimmt. Dies er muss , aufgrund der Regeln der Zuweisungskompa-
tibilität, ein Subtyp des deklarierten Typs des Ausdrucks sein, der das Empfängerobjekt lie-
fert. Mit diesem tatsächlich en (auch dynamisch genannten) Typ wird dann aus der zuvor
bestimmten Menge von in Frage k ommenden überschriebenen Methoden die ausgesucht,
die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Kette der
Superklassen die nächste ist.
Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach obi-
gem Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit
von der aufgerufenen entfernt sind, dann meldet der Compiler einen sog. Method ambi-
guous error , der bedeuten soll, dass die aufgerufene Methode durch den Aufruf nicht ein-
deutig bestimmt ist. Man beachte, dass der Fehler durch Methodenaufrufe, nicht durch
Methodendeklarationen verursacht wird; wenn man den problematischen Aufruf entfernt,
gibt es auch keinen Fehler mehr. Der einfachste Fall eines solchen Fehlers ergibt sich durch
den Aufruf
1009 System.out.println( null)
59 Diese Bedingung ist bei Methoden mit variabler Parameterzahl aufgeweicht. Method ambiguous
bei dem unklar ist, ob println(null) an die Implementierung von println(String) ,
println( Object) oder von println(char[]) gebunden werden soll.
Man beachte, dass in Sprachen, in denen das dynamische Binden neben dem Typ des Emp-
fängers auch die Typen der tatsächlich en Parameter berücksichtigt (das sog. Multi -dispatch ),
der Unterschied zwischen Überladen und Überschreiben dahinschmilzt. In JAVA muss hinge-
gen das dynamische Binden anhand der Parametertyp en genau wie in SMALLTALK über Dou-
ble dispatch (s. Abschnitt 12.3 in Kurseinheit 1) simuliert werden.
