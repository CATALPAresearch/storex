10.3 Abstrakte Klassen
Die Genera Aristoteles’ sind allesamt abstrakt — es gibt keine Säugetiere, die nicht Mensch
oder Hund oder Katze oder was Konkretes auch immer wären. Übertragen auf die obje kt-
orientierte Programmierung hieße das: Generalisierungen, also Klassen, die aus Generalisie-
rungen hervorgegangen sind, haben selbst keine Instanzen, sind also insbesondere nicht
instanziierbar .
In der objektorientierten Programmierung nennt man nicht instanziier-
bare Klassen abstrakt . Der Grund für die mangelnde Instanziierbarkeit
duen) untereinander fortpflanzungsfähige Nachkommen zeugen können, sinnvoll, doch unterliegen
derart angelegte Artendefinitionen dem erdgeschichtlichen Wandel, wie sich schon daraus ableiten
lässt, dass alles Leben aus den ersten Einzellern entstanden ist. Natürlichkeit der
ist jedoch häufig kein konzeptueller (wie beispielsweise, dass es sich bei einer Klasse um
eine Generalisierung handelt und sie daher nicht instanziierbar sein sollte), sondern ein rein
technischer: Abstrakten Klassen fehlen in der Regel Angaben, die das Verhalten ihrer In-
stanzen vollständig spezifiziert und diese somit brauchbar machen würden, so dass Instan-
zen dieser Klassen, wenn es sie denn geben würde, unvollständig definiert wären und z u
Laufzeitfehlern führen würden. Diese fehlenden Eigenschaften werden erst in den Klassen
geliefert, die von den abstrakten erben (s. nächstes Kapitel ), wobei die Idee ist, dass sich die
Eigenschaften von Klasse zu Klasse unterscheiden. Klassen, die nicht abstrakt sind, die also
eigene Instanzen haben können, nennt man konkret .
Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse
Collection . Sie ist (in Auszügen) wie folgt definiert:
Klasse Collection
benannte Instanzvariablen
indizierte Instanzvariablen nein
Instanzmethoden
Man erkennt schon am Fehlen von Instanzvariablen, dass es mit der Implementierung von
Collection nicht weit her sein kann — Instanzen wären schlicht zustandslos, weswegen
sie kaum zu gebrauchen wären. Besonders deutlich wird die Abstraktheit jedoch an der
Implementation der Methode add: : Hier wird, anstatt et was Entsprechendes zu tun, die
Methode implementedBySubclass37 aufgerufen, die eine Fehlermeldung ausgibt. Jede,
die mit einer direkten Instanz von Collection arbeiten würde und die Methode add:
(oder addAll: ; auf die Bedeutung von self im Kontext von abstrakten Klassen und Ver-
erbung gehen wir gleich und später dann in Abschnitt 12.1, „Nachrichten an self “, noch
einmal ein) darauf aufrufen wollte, würde enttäuscht.
Allerdings erst zur Laufzeit. Viele andere Sprachen verlangen daher, dass
man abstrakte Klassen mit einem Schlüsselwort, z. B. abstract , mar-
kiert, und verbieten dann (per Compiler), die Klasse zu instanziieren. Das geht in SMALLTALK
jedoch nicht, da Klassen auch Objekte sind und daher in Variablen gespeichert werden kön-
nen, den en man dann einfach new schicken kann, ohne dass der Compiler wissen könnte,
welches Objekt die Variable nun gerade bezeichnet .
Selbsttestaufgabe 10.1
Probieren Sie es gleich aus, d. h., weisen Si e eine Klasse einer Variable zu und schicken sie dem durch
die Variable bezeichnetem Objekt die Methode new!
Nun erfolgt der Hinweis, dass man eine abstrakte Klasse instanziiert hat,
in SMALLTALK nicht nur erst zur Laufzeit, sondern auch da er st zum spä-
testmöglichen Zeitpunkt, nämlich wenn man eine nicht implementierte Methode aufzuru-
fen versucht. Was man tun könnte, um zu verhindern, dass Instanzen einer abstrakten
Klasse überhaupt erzeugt werden , ist, die Konstruktoren, insbesondere new und new: , ent-
sprechend zu überschreiben (vgl. Abschnitt 8.2).38 Allerdings verhindert man damit zu-
nächst auch die Instan ziierung der Klassen, die von Collection erben, die natürlich nicht
alle abstrakt sein sollen. Diese müsste n dann new und new: wieder neu einführen, was aber
kaum zumutbar ist, zumal new und new: primitive Methoden (s. Abschnitt 4.3.7 ) aufrufen.
(Vgl. hierzu auch die Grenzen der Verwendung von super in Abschnitt 12.2.)
Man könnte in SMALLTALK die Methode add: in der Klasse Collection natürlich auch ganz
weglassen.39 Ein Aufruf von add: auf einer Instanz von Collection oder einer ihrer Sub-
klassen würde dann zum Aufruf von doesNotUnderstand und der Ausgabe einer ent-
sprechenden Fehlermeldung führen. Allerdings wäre diese Fehlermeldung für die Program-
miererin weniger aufschlu ssreich: Sie wüsste nicht, ob sie einfach nur einen falschen Me-
thodennamen verwendet hat ( ihr Fehler) oder ob die Programmiererin einer Subklasse von
Collection vergessen hat, die Methode add: zu implementieren (jemand anderes Feh-
ler). Eine Methode wie add: in Collection vorzusehen, die auf ein Versäumnis hinweist,
so es denn eines gibt (es könnte ja auch sein, dass man versehentlich eine Instanz von
Collection erzeugt hat und darauf add: ausführt, obwohl add: für alle erbenden Klas-
sen implementiert ist — das erlaubt dann die Fehlermeldung nicht zu unterscheiden) ist
schon sinnvoll. Die Laufzeitfehlermeldung von SMALLTALK ersetzten also gewissermaßen die
Compiler -Fehlermeldungen anderer Sprachen. Die entspreche nden Grundlagen werden
Ihnen in Kurseinheit 3 begegnen.
auch vorhanden ist, selbst wenn sie auf self aufgerufen wird (und damit schon klar ist, welche
Klassen die Methode eigentlich haben müssten). In anderen Sprachen ist das anders. Verhinderung der
Man mag sich fragen, warum es eine abstrakte Klasse wie Collection überhaupt gibt,
wenn sie doch keine Instanzen haben soll.40 Bereits das obige Beispiel gibt eine erste Ant-
wort: Weil es auch in abstrakte n Klassen Methoden gibt, die voll ausimplementiert sind
(z. B. addAll: ) und die dann in den Subklassen, auf die sie vererbt werden, nicht wieder-
holt werden müssen. Tatsächlich ist alles, was eine erbende Klasse tun muss , um in den
Genuss einer funktioniere nden Methode addAll: zu kommen, eine Implementierung von
add: zu liefern. Die abstrakte Klasse faktorisiert also die Gemeinsamkeiten mehrerer Klas-
sen heraus und markiert gleichzeitig, was ihre erbenden Klassen noch nachtragen müssen:
Alle Methoden, die von anderen Methoden der Klasse aufgerufen werden (wie eben add:
von addAll: ), die aber (z. B. mangels Instanzvariablen wie im Fall von Collection ) in der
Klasse noch nicht implementiert werden können, deren Aufruf auf Instanzen der abstrakten
Klassen somit e inen entsprechenden Fehler liefern würde.
Der Aufruf einer abstrakten, d. h. in der Klasse nicht implementierten Me-
thode aus der Klasse selbst heraus wie in Zeile 430 (mit self als Empfänger) ist ein gängiges
Muster der objektorientierten Programmierung. Man nennt es auch offene Rekursion
(engl. open recursion ), da der Aufruf auf dem Objekt selbst erfolgt (also gewissermaßen
rekursiv ist), aber an der aufrufenden Stelle noch nicht klar (offen) ist, welche (erbende)
Klasse die Implementierung liefert. Dieses Muster, auf das wi r in Abschnitt 12.1 im Rahmen
des dynamischen Bindens noch einmal zurückkommen werden, lässt sich auch einsetzen,
um das oben beschriebene Dilemma von Quadrat und Rechteck aufzulösen:
Klasse Rechteck
benannte Instanzvariablen
Instanzmethoden
Die Definitionen von Quadrat und Rechteck fallen dann knapp aus und kommen ohne
inhaltliche Veränderungen daher (lediglich die noch nicht implementierten Methoden müs-
sen nachgeliefert werden):
Klasse Quadrat
außen vor. offene Rekursion
beerbte Klasse Rechteck
benannte Instanzvariablen laenge
Instanzmethoden
Klasse NichtQuadratischesRechteck
beerbte Klasse Rechteck
benannte Instanzvariablen laenge breite
Instanzmethoden
Es sollte klar sein, dass alle Methoden nur für Quadrate und Rechtecke definiert sind.
Man beachte, dass dieses Beispiel auch die Kriterien von Generalisierung und Spezialisierung
erfüllt: Die Menge der Quadrate und die der nicht quadratischen Rechtecke is t in der Menge
der Rechtecke enthalten und die Definition der beiden stellt jeweils eine Erweiterung letz-
terer dar. Ein Überschreiben oder sogar Löschen wird nicht nötig (sieht man mal vom Über-
schreiben der „nicht implementierten“ Methoden ab).
