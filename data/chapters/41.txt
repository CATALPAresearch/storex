41 Arrays
In JAVA ist es möglich, sowohl von primitiven (Wert -)Typen als auch von Referenztypen Ar-
rays zu bilden. Anders als z. B. in PASCAL können aber über den Array -Typkonstruktor keine
neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variab-
lendeklaration.
1035 float[] f;
1036 Object[] o;
vereinbart in JAVA zwei Variablen, wovon die erste ein Array von Fließkommazahlen zum
Typ hat und die zweite ein Array von Objekten. Die alternative Schreibweise
1037 float f[];
1038 Object o[];
ist auch gebräuchlich. Anders als z. B. in PASCAL wird die Größe des Arrays in der Deklaration
nicht festgelegt — dies geschieht erst bei der Initialisie rung.
In JAVA ist es möglich, Arrays bei ihrer Deklaration zu initialisieren:
1039 float f[] = {1.0, 3.142};
Man beachte die Ähnlichkeit zu literalen Arrays SMALLTALK s (Abschnitt 1.2); allerdings müs-
sen die Elemente der Arrays in JAVA nicht selbst Literale sein, sondern dürfen auch andere
Ausdrücke sein. Die Größe des Arrays (in diesem Fall 2) wird bei der Initialisierung automa-
tisch mit festgelegt; ansonsten muss dies bei der Erzeugung des Arrays mittels eines Kon-
struktors explizit geschehen:
1040 Object[] o = new Object[2]; Default -Methoden
private Methoden
Array -Initialisierung
Alle Elemente des Arrays enthalten danach jedoch null (JAVAs äquivalent von SMALLTALK s
nil). JAVA-Arrays sind übrigens 0 -basiert, was soviel heißt wie dass das erste Element den
Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.)
Array -Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen um-
fassen:
1041 int integers[][] = { {1, 2}, null, {238} }
beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der
Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimen-
sionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen
nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged
oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays
in JAVA auch gar nicht um mehrdimensionale Arrays , sondern um Arrays von Arrays).
Interessanterweise haben in JAVA Array -Variablen immer und unabhängig
vom Basistyp Referenzsemantik . Bei der Zuweisung an die Variable f
oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer
darauf. Dies hat vermutlich den Hintergrund, dass Array -Kopieroperationen sehr teuer sind
und zudem selten ben ötigt werden. Warum auch immer, im Ergebnis kann f an eine Vari-
able vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ
Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit
auch nicht damit zuwei sungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn
sie wie Klassen und Interfaces Typen bilden, die automatisch Subtypen von Object sind,
außer ihrem Basistyp (also beispielsweise float oder Object ) keine weiteren Definitions-
elemente anzugeben erlauben; insbesondere kann man für einen Array -Typen keine weite-
ren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die
(Pseudo -)Variable length definiert, deren Inhalt die Grö ße des Arrays (Anzahl Elemente)
angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein
Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.
Die bemerkte mange lnde Zuweisungskompatibilität von Object[] und
float[] wirft natürlich sofort die Frage auf, ob denn auch die Zuwei-
sung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit
automatisch ein Subtyp von Object , an eine Variable vom Typ Object[] unzulässig ist.
Wir hatten ja in Abschnitt 29.3 von Kurseinheit 3 am Beispiel zweier Instanzen eines para-
metrischen Typs bemerkt, dass dies zu einem nicht ganz offensichtlichen Problem führt, das
sich analog auf Arrays übertragen lässt. Die Überraschung folgt hier auf den Fuß: Die Zu-
weisung ist in JAVA zulässig.
Am besten lässt sich dies an einem Beispiel erläutern. Man kann tatsächlich in JAVA bei
Vorliegen der Deklarationen
1042 class Hund extends Tier {}
1043 Tier[] tiere; Referenzsemantik
von Array -Variablen
Typkonformität und
Subtyping von
Arrays in JAVA
1044 Hund[] hunde;
die Zuweisung
1045 tiere = hunde
durchführen. Die anschließende Zuweisung
1046 tiere[1] = new Tier()
führt dann in JAVA allerdings prompt zu einem Laufzeit typfehler (eine sog.
Array store exception ), denn tiere ist ja lediglich ein Alias auf ein Array
mit Hunden, so dass die Zuweisung ein Tier anstelle eines Hundes an Arrayposition 1 setzt
und das A rray hunde , das ja per Deklaration nur Hunde zu enthalten verspricht, damit nicht
mehr typkorrekt ist. Würde man die Zuweisung aus Zeile 1046 zulassen, dann wü rde in der
Folge die scheinbar korrekte Zuweisung
1047 Hund hund = hunde[1]
bei der hund ein Tier (das aus Zeile 1046 ) zugewiesen wird, die Typinvariante von hund
verletzen, was ein Compiler aber beim besten Willen nicht mehr erkennen kann (und eine
Programmiererin übrigens auch kaum).
Warum aber geht man dieses Risiko ein und überträgt die Zuweisungs-
kompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal
kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung , die (auf Basis
mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet
hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfeh-
lers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme
verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass
dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass
die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man an-
schließend schreibend (wie in Zeile 1046 ) auf das Array zugreift und dann noch mit dem
falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen).
Da man diese Be dingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein
Laufzeittest durchgeführt. Ein klassischer Kompromiss , der diesmal zugunsten der Flexibilität
beim Programmieren ausging.
Warum aber will man Zuweisungskompatibilität zwischen Arrays nicht
gleichen Typs und damit Zuweisungen wie die in Zeile 1045 unbedingt
haben? Die Antwort ist einfach: weil es Pro zeduren gibt, die den (stati-
schen) Typ der Array -Elemente nicht genau festlegen, sondern lediglich nach oben be-
schränken wollen. So gibt es beispielsweise in JAVA den Interfacetyp Comparable , der wie
folgt definiert ist:
1048 interface Comparable {
1049 int compareTo(Object o); Laufzeit typfehler bei
Arrays
Typprüfung als
Kompromiss
Grund für das
Subtyping bei Arrays
in JAVA
1050 }
Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich
des Empfänger - mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur
sort(Comparable[] ) kann dann Arrays beliebiger Elementtypen zum Sortieren anneh-
men, solange diese nur Comparable implementieren und damit Auskunft über ihre relative
Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht
ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typ fehler von der Art der
Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservative res
statisches Typsystem hätte ihre Verwendung jedoc h nicht zugelassen. Der eingegangene
Kompromiss zwischen statischer und dynamischer Typprüfung ist also durchaus vertretbar.
