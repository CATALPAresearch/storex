55 Das Fragile -base -class -Problem
Unter dem Fragile -base -class -Problem versteht man eine ganze Familie von Problemen,
die in unmittelbarem Zusammenhang mit der Vererbung stehen. Dabei ist der Name inso-
fern etwas irreführend, als nicht unbedingt die Basisklassen , also die Superklassen (vgl. Ab-
schnitt 11.1), die „anfälligen “ oder „zerbrechlichen “ sind, sondern eher die Klassen, die
von ihnen erben. Ein einfaches Beispiel soll erläutern, worum es geht.
Wir nehmen an, wir hätten eine Klass e TapeArchive geschrieben, die Videobänder archi-
viert. Da es sich nicht um eine Mickey -Maus -Anwendung auf dem heimischen Desktop han-
delt, sondern um ein kommerzielles System, erfolgt die Datenhaltung in einer Datenbank.
Die folgende SMALLTALK -Klassendefinition gibt einen kleinen Ausschnitt des Systems wieder.
Klasse  TapeArchive
benannte Instanzvariablen  database
Klassenmethoden
1510 new
1511  ^ super new initialize
Instanzmethoden
1512 initialize
1513  database := Database new: 'tape archive'
1514 addTape: aTape
1515  database beginTransaction.
1516  database add: aTape.
1517  database endTransaction
1518 addAllTapes: aCollection
1519  aCollection do: [ :aTape | self addTape: aTape ]
Nun ist es in der objektorientierten Programmierung üblich, dass man solche Klassen wie-
derverwend et, indem man davon neue Klassen ableitet. Wenn beispielsweise eine Kundin-
nenanforderung kommt, nach der mit jeder Archivierung eine Nachricht verschickt werden
muss , die das anzeigt, und wenn diese neue Anforderung nicht für alle Kundinnen der Soft-
ware gleichermaßen interessant ist, dann schreibt man eine Subklasse, die das geänderte
Verhalten bereitstellt:
Klasse  NotifyingTapeArchive
benannte Instanzvariablen  listener
Superklasse  TapeArchive
Klassenmethoden
1520 new: aListener
1521  ^ super new initialize: aListener
Instanzmethoden
1522 initialize: aListener
1523  listener := aListener
1524 addTape: aTape
1525  super addTape: aTape.
1526  listener notify: aTape
Das Schöne an der Objektorientierung ist dabei, dass man nu r die Unter-
schiede (Differentia ) spezifizieren muss — der Rest wird einfach geerbt.
So genügt es im gegebenen Fall, die Initialisierung (nicht so interessant) und die Methode
addTape: anzupassen. Das Verhalten von addAllTapes: kann unverändert bleiben, da
dies die (dynamisch gebundene) Methode addTape: aufruft und somit auch das von
NotifyingTapeArchive geforderte Verhalten, nämlich die Notifikation aller archivierten
Bänder, garantiert. Ein ganz ähnliches Beispiel (anhand der Klasse Collection ) war Ihnen
in Kurseinheit 2, Abschnitt 10.3 schon einmal begegnet; es handelt sich auch hier um einen
Fall von offener Rekursion , die erst durch dynamisches Binden (Kapitel 12) aufgelöst wird.
Aufrufe dieser Art sind das Herz vieler objektorientierter (Anwendungs -)Frameworks und
auch diverser Entwurfsmuster.
Oder auch nicht. Das Problem ist nämlich, dass man der Klasse
TapeArchive weder ansieht, was sie garantiert, noch, wovon die Korrektheit ihrer Sub-
klassen abhängt. Wenn in der Folge z. B. eine anderere Kundin nörgelt, das Hinzufügen von
großen Mengen von Bändern dauere zu lange, wenn man das wiederholte Aufrufen von
addTape: aus addAllTapes: und die dadurch bedingte wiederholte Ausführung von
beginTrans action und endTransaction als Ursa che ausmacht und wenn man dann
in Erwägung zieht, nicht nur die nörgelnde Kundin in ihrer Version, sondern alle Kundinnen
mit der optimierten Implementierung
Klasse  TapeArchive
Instanzmethoden
1527 …
1528 addAllTapes: aCollection offene Rekursion
zum Dritten
Vorsicht Falle
1529  database beginTransaction.
1530  aCollection do: [ :aTape | database add: aTape ].
1531  database endTransaction
zu beglücken, was spräche dagegen?
Selbsttestaufgabe 55.1
Bevor Sie weiterlesen, antworten Sie: Was spräche dagegen?
Vermutlich nur die wenigsten unter Ihnen werden sofort sagen können, was dagegen
spricht, denn in der Klasse TapeArchive scheint nach wie vor alles in bester Ordnung zu
sein. Was man nämlich nicht sehen kann, ist, dass die Korrektheit der Methode
addAllTapes: davon abhängt, dass sie addTape: aufruft — zwar nicht für die Klasse
TapeArch ive selbst, dafür aber für ihre Subklasse NotifyingTapeArchive . Hier werden
jetzt nämlich nur noch für einzeln archivierte Bänder Benachrichtigungen verschickt.
Hand aufs Herz: Hätten Sie den Fehler vorhergesagt? Wenn nicht, dann liegt das vermutlich
daran, dass Sie der Täuschung erlegen sind, addAllTapes: in TapeArchive würde die
benachbarte Methode addTape: aufrufen, und wenn man nur den Beitrag von addTape:
in addAllTapes: verlagert und dafür addTape: nicht mehr aufruft, dann wäre das eine
semantikerhaltende Umstrukturierung (ein sog. Refactoring ; s. Kurs 01853). Tatsächlich be-
raubt aber genau dies die Subklassen der Möglichkeit, eigenes Verhalten an genau dieser
Stelle — dem Aufruf von addTape: — einzubringen, und wenn eine solche Beraubung im
Nachhinein erfolgt, kann sie eben den Code „zerbrechen“.
Das Schlimme an diesem Problem ist, dass man noch nicht einmal genau
weiß, wem man die Schuld geben soll — TapeArchive , weil es einen Vertrag bricht, den
es gar nicht paraphiert hat (oder weil es keine Rück sicht auf Subklassen nimmt, die es gar
nicht kennt), oder NotifyingTapeArchive , weil es sich grundlos darauf ver lässt, dass die
geerbten Methoden dauerhaft die eigenen (in diesem Fall das geerbte addAllTapes: das
eigene addTape: ) aufrufen? Wenn noch nicht einmal die Schuld feststeht — wie kann man
das Problem verhindern?
Es gibt zahlreiche Varianten des Fragile -base-class-Problems, die hier nicht alle aufgeführt
werden sollen. Zugrunde liegt ihnen immer dasselbe: Zwischen einer Klasse und ihren Sub-
klassen bestehen durch die Vererbung von Eigenschaften starke Abhängigkeiten, die —
wenn überhaupt — nur unvollständig dokumentiert sind. Zwar könnte man annehmen,
dass von allem, was vererbt wird, eine Abhängig keit ausgeht, die man bei Änderungen
pauschal berücksichtigen muss , aber dies würde die Möglichkeiten, in Superklassen etwas
zu ändern, so stark einschränken, dass das ganze Konzept ad absurdum geführt würde. Es
bleibt also nicht viel mehr, als beim Einsatz von Vererbung große Vorsicht walten zu lassen
oder sie ganz zu verbieten.
Schuldfrage
Das folgende , im Kontext des Component Object Models (COM) getätigte Zitat aus dem
Hause MICROSOFT fasst es schön zusammen:
Implementation inheritance —the ability of one component to "subclass" or in-
herit some of its functionality from another component —is a very useful tech-
nology for building applications. Implementation inheritance, however, can c re-
ate many problems in a distributed, evolving object system.
The problem with implementation inheritance is that the “contract” or relation-
ship between components in an implementation hierarchy is not clearly defined;
it is implicit and ambiguous. When th e parent or child component changes its
behavior unexpectedly, the behavior of related components may become un-
defined. This is not a problem when the implementation hierarchy is under the
control of a defined group of programmers who can make updates to a ll com-
ponents simultaneously. But it is precisely this ability to control and change a
set of related components simultaneously that differentiates an application,
even a complex application, from a true distributed object system. So while im-
plementation i nheritance can be a very good thing for building applications, it
is not appropriate for a system object model that defines an architecture for
component software.
In a system built of components provided by a variety of vendors, it is critical
that a given component provider be able to revise, update, and distribute (or
redistribute) his product without breaking existing code in the field that is using
the previous revision or revisions of his component. In order to achieve this,
it is necessary that the actual interface on the component used by such
clients be crystal clear to both parties. Otherwise, how can the component
provider be sure to maintain that interface and thus not break the existing cli-
ents?
Auf die objektorientierte Programmierung übertragen ist das Problem also, dass der Vertrag
zwischen den Klassen einer Vererbungshierarchie nicht klar definiert ist. Wenn die Super -
oder Subklasse ihr Verhalten uner wartet verändert, kann daraus undefiniertes Verhalten
verwandter Klassen resultieren. Tatsächlich war die Vererbung von Implementierung aus der
Spezifikation von MICROSOFT s Component Object Model (COM) verbannt; stattdessen setzte
man voll auf die Vererbung von Interfaces (was wir als Subtyping bezeichnen würden). In-
zwischen (mit dem .NET -Framework) ist diese harte Haltung wieder aufgegeben worden,
was wohl auch da ran liegt, dass hier Komponenten Klassen sind; es bleiben jedoch die in
Kapitel 50 (im Kontext von C#) erwähnten Vorbehalte gegenüber dem dynamischen Binden.
Nun liegt ja zunächst nahe, bei der Vererbung das zu tun, was man bei
Abhängigkeiten immer macht : Schnittstellen einzuführen. Im Gegensatz zu der Schnitt-
stelle, die einem Klient einer Klasse angeboten wird (der diese Schnittstelle nutzt, indem er
Vererbungsinterface
seine Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der
Klasse zugreifen kann), handelt es sich bei der Schnittstelle zwischen einer Klasse und ihren
Subklassen jedoch um eine etwas anders geartete: Hier gibt es lediglich zwei Variablen self
(bzw. this ) und super , die allerdings keine Abhängigkeit von anderen Objekten ausdrü-
cken und die zudem nicht explizit typisiert sind. Die damit verbundene Schnittstelle, also die
Menge der Eigenschaften, auf die man über diese Variable zugreifen kann, und wo man
diese Eigenschaften dann findet (also wo sie definiert sind), muss man sich sel bst zusam-
mensuchen. Mit Information hiding und dem Verbergen von Implementationsgeheimnissen
hat das freilich nichts zu tun. Was man vielmehr bräuchte, wäre ein explizites Vererbungs-
interface .
Einige erste, zarte Ansätze zur Einführung von expliziten Vererbungsin-
terfaces hatten Sie bereits gesehen: Die Verwendung des Zugriffsmodifi-
zierers protected in JAVA, C# und C++ sowie die explizite Deklaration von Überschreib-
barkeit und Überschreibung mittels virtual und override in C# (und C++). Im obigen
Beispiel würde die Deklaration von addTape: als nicht überschreibbar (und somit als nicht
dynamisch, sondern statisch gebunden) verhindern, dass NotifyingTap eArchive diese
Methode abändert und sich zugleich darauf ver lässt, dass die geerbte Methode
addAllTapes: die überschreibende Version von addTape: aufruft (sie könnte sie aber
immerhin noch neu einführen, aber diese neue Version würde beim Binden in
addAllTapes: nicht berücksichtigt). NotifyingTapeArchive müsste dann wohl oder
übel beide Methoden neu implementieren und könnte bei der Gelegenheit selbst dafür
Sorge tragen, dass addAllTapes: den Fehler nicht macht. Allerdings würde dadurch auch
bei eine m direkten Aufruf von addTape: von außerhalb auf einer Variable vom Typ
TapeArchive , die eine Instanz vom Typ NotifyingTapeArchive hält, die überschrei-
bende Implementierung unberücksichtigt bleiben (da ja keine dynamische Bindung mehr
stattfindet). Im Gege nsatz dazu würde die Verwendung von virtual bei addTape: in
TapeArchive der Programmiererin einen Hinweis darauf geben, dass die Methode in Sub-
klassen für diese relevante Modi fikationen enthalten kann, so dass man Aufrufe dieser Me-
thode nicht einfach, wie im obigen Beispiel geschehen, kürzen kann .
Wenn es um die Sicht - und Zugreifbarkeit von Elementen geht, scheint
der Zugriffsmodif izierer protected zunächst auf gleicher Ebene mit
public und friend zwischen zwei (nicht über Vererbung in Beziehung stehenden) Klassen
zu stehen: die protected deklarierten Elemente einer Klasse sind wie bei einem dedizierten
Export (s. Abschnitt 52.2) auch in ihren Subklassen sicht - und verwendbar. Was allerdings
nicht so klar ist, ist, dass überschreibende, als protected deklarierte Methoden auch für
den Code der Superklasse zugreifbar s ind: eine protected Methode einer Subklasse kann
— über das dynamische Binden auf self bzw. this — aus der Superklasse heraus aufge-
rufen werden, ohne dass die Subklasse irgendeinen Hinweis darauf enthält. Anders als bei
der Zugreifbar machung mit public oder friend bei nicht über Vererbung in Beziehung
stehenden Klassen kann die Zugreifbar keit also in beide Richtungen gehen, und zwar ab-
hängig davon, ob die Methode überschrieben wird oder nicht: Wird sie überschrieben, kann
die überschreibende (in der Subklas se) von der Superklasse aus aufgerufen werden und die protected , virtual
und override
Bidirektionalität des
Protected -Interfaces
überschriebene (in der Superklasse) von der Subklasse (über super ) — wird sie nicht über-
schrieben, kann die Methode der Superklasse aus der Subklasse heraus aufgerufen werden.
Es bleibt also ein höchs t verworrener Eindruck. Dies ist um so bedauerlicher, als BJARNE
STROUSTRUP selbst kommentierte:
One of my concerns about protected is exactly that it makes it too easy to use
a common base the wa y one might sloppily have used global data. … In retro-
spect, I think that protected is a case where “good arguments” and fashion
overcame my better judgement and my rules of thumb for accepting new fea-
tures.
Bei der Definition von JAVA fand das offenbar kein Gehör. Und so bleiben die Schlüsselwör-
ter protected , virtual und override nicht viel mehr als Zeichen des Bewusst seins,
dass es das Fragile -base-class-Problem gibt.
