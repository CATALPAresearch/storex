51.2 Klassen
C++ ist insofern objektorientiert, als es neben den aus C übernommen Strukturen (structs)
auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern
(Instanzvariablen) au ch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s.
Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwor t static in einer Klasse eingeführt.
Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwen-
det werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt
nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALL-
77 Sie kennen vielleicht auch den Witz, nach dem C von Amerikanern mit dem Ziel entw ickelt wurde,
es den Russen zuzuspielen, um deren Informatik um Jahrzehnte zurückzuwerfen, und dass die Ent-
wicklung der Sprache erst als abgeschlossen erachtet wurde, nachdem sich for(;P(" \n"),
R--;P("|")) for(e=C;e --;P("_"+(*u++/8)%2)) P("| "+(*u/4)%2); übersetzen ließ.
Klassen haben
Wertsemantik
TALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz -, son-
dern Wertsemantik . Entsprechend müssen die Werte solcher Variablen, die „Objekte“, nicht
erst mit new angelegt werden — der für ein „Objekt“ benötigte Speicherplatz wird, genau
wie bei den Records PASCAL s oder bei den Structs von C, bei der Deklaration reserviert. Dabei
steht „Objekt“ hier deswegen in Anführungsstrichen, weil diese „Objekte“ eigentlich keine
Objekte sind, sondern Werte; insbesondere haben sie keine Identität und bei Zuweisungen
an andere V ariablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch
keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom
Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem
New-Opera tor instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Kon-
struktor für die Klasse A als gegeben voraussetzt, so aus:
1365 A* a = new A();
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine
Pointervariable ha ndelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder
C#.
Zur Dereferenzierung einer solchen Pointer -(Objekt -)Variable bei gleichzeitigem Zugriff auf
ein Element (Feld oder Methode) der Instanz schreibt man in C++
1366 a->x
bzw.
1367 a->f(x)
wobei x ein Feld und f(.) eine Methode der Klasse A sein soll. Dies ist äquivalent zu
(*a).x bzw. (*a).f(x) . Besondere Obacht ist bei Zuweisungen geboten, da man sich
hier genau überlegen muss , ob man Pointer oder die Werte, auf die die Pointer zeigen,
zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen ,
die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst
ein Call by value , das heißt, es wird eine Kopie des Inhalts des tatsächli-
chen Parameters de m formalen Parameter zugewiesen. Im Falle von Pointer -Variablen wie
dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das
Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK ,
wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-
variable handelt — es ist einfach immer so. Hantieren mit
Pointern
Komplikation bei
impliziten
Zuweisungen
Will man nun davon abweichend ein Call by reference haben, dann gibt es zum einen die
Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Ko-
pie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und
diesen übergibt:
1368 A* a, b;
1369 swap(&a,&b);
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf
Zeiger aufnehmen können, also etwa wie in
1370 void swap(A** a,A** b) {
1371  A* tmp=*a;
1372  *a=*b;
1373  *b=tmp;
1374 }
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren und einfach
1375 void swap(A* &a, A* &b) {
1376  A* tmp=a;
1377  a=b;
1378  b=tmp;
1379 }
zu schreiben, wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & aus-
kommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.
