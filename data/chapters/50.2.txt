50.2 Gemeinsamk eiten mit und kleinere Unterschiede zu JAVA
C# unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und
Kontrollstrukturen angeht, nicht großartig von JAVA. Es ist in C# allerdings möglich, Opera-
toren (also z. B. +, –, == etc., abe r nicht new, ( ), ||, &&, =) zu überladen. C# besitzt dafür
das Schlüsselwort operator , das in einer Operatordefinition (die ansonsten so aussieht wie
eine Methodendefinition) vorangestellt wird:
1258 static Matrix operator +(Matrix m1, Matrix m2) {…}
Außerdem ist es in C# Konvention, Methodennamen mit einem Groß-
buchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für
viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C#,
Call by reference nach dem Vorbild PASCAL s (also ohne explizite Pointer; s. o.) zu erlauben
und damit Funktionen wie das Vertauschen von Va riableninhalten (die Meth ode swap ) si-
cher zu programmieren:
1259 public static void Swap(ref int x, ref int y) {
1260 int temp = x;
1261 x = y;
1262 y = temp;
1263 }
Allerdings muss ref — anders als in PASCAL var — auch an der Aufrufstelle verwendet
werden. Formale Parameter können auch mit out modifiz iert werden (wobei für die Auf-
rufstelle dasselbe gilt wie für ref):
1264 public static void Aenderbar( out String s) {
1265 s = "auch der tatsächlich e Parameter ist geändert!"
1266 }
Der Unterschied ist der, dass bei Verwendung von ref die Variable, die den tatsächlich en
Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekom-
men haben) muss , während dies bei out nicht der Fall ist. Dafür muss bei out der formale
Parameter in der Methode einen Wert zugewiesen bekommen. Dass ref und out in C#
anders als var in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil,
dass die Programmiererin weiß, dass ihre die tatsächlich en Parameter liefernden Variablen
nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer
Zuweisung in beide Richtungen (hin und zurück) aus. Call by reference
Selbsttestaufgabe 50.1
Überlegen Sie, welche Konsequenzen sich aus der Verwendung von ref bzw. out im Kontext des
Subtyping ergeben.
Sowohl ref als auch out ermöglichen, dass eine Methode mehr als einen Rückgabewert
hat. Da diese Mögli chkeit in JAVA und SMALLTALK fehlt, findet man in diesen Sprachen häufig
Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu
verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine
ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt
52.7).
Nun verdient C# im Kontext von Methodenaufrufen nicht nur lobende
Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C# keine
Throws -Klauseln in Methodendeklarationen gibt — die aus JAVA be-
kannte Unterscheidung von Checked exceptions und Unchecked excepti-
ons (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions.
Das bedeut et, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzu-
denken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie
weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen
werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass
bei einer stark geschichteten Architektur (beispielsweis e beim Einsatz von Middleware) das
Wissen um Exceptions auf der ganzen Wegstrecke von der Exception -Quelle bis zum Excep-
tion handler vorhanden sein muss , obwohl die mittleren Schichten naturgemäß an Art und
Auftreten von Ausnahmen keinerlei Interesse haben. Das mit JAVA Version 1.4 eingeführte
sog. Exception chaining erlaubt, eine Checked exception in einer Unchecked exception zu
verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut
zu werfen). Das sog. Exception tunneling bietet ebenfalls Abhilfe.
Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Un-
terschied bei Methoden erg ibt sich im Zusammenhang mit dem Über-
schreiben: Während in JAVA alle Methoden im Prinzip überschrieben wer-
den können (es sei denn, ihre Definition trägt den Zusatz final ), so dass der Compiler
zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C#, der Tra-
dition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu dekla-
rieren, und zwar mit dem Schlüsselwort virtual . Entsprechend muss eine überschreibende
Methode mit dem Schlüsselwort override deklariert werden. Soll hingegen eine Methode
gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie über-
schreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts
new bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanz-
gründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern
auch gewichtige programmiertechnische : Man markiert alle Stellen im Programm, an dene n
das sog. Fragile -base-class-Problem (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. keine Deklaration
von Exceptions als
Ergebnis eines
Methodenaufrufs
Deklaration von
Überschreibung und
dynamischem Binden
Einige Sprachkonstrukte verwenden in C# andere Schlüsselwörter als
JAVA, so lock anstatt synchronized sowie foreach anstatt for für
die zweite Form von For -Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer
Bedeutung leicht von denen JAVAs ab: So sind auch Strings als Basis einer Switch -Anweisung
zugelassen (in JAVA erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anwei-
sung enthält, muss mit einer expliziten Kontroll flussanweisung ( break , goto , return oder
throw ) abgeschlossen werden. Außerdem hat C# eine Goto -Anweisung, mit der man je-
doch nicht in Blöcke hinein springen k ann. All dies hat allerdings nichts mit Objektorientie-
rung zu tun.
