16 Parallelität: aktive und passive Objekte
Die objektorientierte Weltsicht, die auch in diesem Kurs propagiert wird (nämlich die von
den Objekten, die einander Nachrichten schicken und die auf den Empfang von Nachrichten
reagieren, indem sie ihren Zustand ändern und weitere Nachrichten verschicken), legt nahe,
dass Objekte aktiv sind, will sagen, dass sie über einen ei genen Rechen prozess verfügen.
Doch schon in Abschnitt 4.3.2 wurde klar, dass es damit in der Realität nicht weit her ist: Es
werden in der Praxis keine Nachrichten verschickt, sondern lediglich Methoden aufgerufen.
Abgesehen vom dynamischen Binden dieser Methoden unterscheidet sich damit das Aus-
führungsmodell der objektorientierte n Programmierung nicht von dem der prozeduralen
Programmierung (à la PASCAL ); insbesondere sind alle Objekte passiv (was soviel bedeutet,
wie dass sie nur aktiv sind, solange sie gerade eine Methode ausführen).
Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen,
der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann
nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation
aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Metho-
denaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf
entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektori-
entierte Programmierung in der Praxis auf passive.
Gleichwohl ist auch in der objektorientierten Programmierung Parallelver-
arbeitung möglich. Nur kommt sie (zumindest in SMALLTALK , aber auch z. B. in JAVA) nicht
in Form von aktiven Objekten daher, sondern in Form von parallelen Prozessen. Jeder dieser
Prozess e führt zu einer Zeit eine Methode aus; er besucht zwar mit dem Methodenaufruf
die Empfängerobjekte, diese bleiben jedoch selbst passiv (haben also kein Eigenleben). Streams auf Dateien
Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neue n Prozess
zu starten: Man schickt einfach einem Block die Nachricht fork . fork
entspricht im wesentlichen value , nur dass der Block dadurch in einem eigenen, unabhän-
gigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von fork auch nicht
darau f, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zu-
rückliefert; tatsächlich liefert sie auch nicht (wie value ) das Ergebnis des Blocks zurück,
sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann g eht
dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des
Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte
ändert.
Soll ein (paralleler) Prozess nicht sof ort starten, so braucht man ein Ob-
jekt, das diesen Prozess repräsentiert und dem man dann zu einem spä-
teren Zeitpunkt die Nachricht resume schicken kann, die den Prozess startet. Ein solches
Objekt erhält man, indem man dem Block newProcess schickt. Tatsäc hlich ist fork wie
folgt implementiert:
Um einen parametrisierten Block (also einen Block mit Parametern) als Prozess zu starten,
verwendet man statt newProcess newProcessWith: mit einem Array als Parameter, das
die tatsächlich en Parameter des Blocks enthält.
Mit den Nachrichten suspend und terminate kann man den Prozess
dann temporär anhalten bzw. beenden. Angehaltene Prozesse können
später mit resume wieder gestartet werden, beendete nicht.
Die Synchronisation von parallelen Prozessen erfolgt in SMALLTALK zu-
nächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen
dazu über zwei Methoden, wait und signal , und e ine Instanzvariable,
die für jedes Empfangen von signal um 1 erhöht und für jedes Empfangen von wait um
mit dem Objekt!) schlafen gelegt (mittels suspend ). Andernfalls läuft er weiter. Erhält der
Semaphor die Nachricht signal und es gibt noch Prozesse, die schlafen (erkennbar an
einem Zähler kleiner 1), dann kann ein Prozess , der an dem Semaphor wartet, aufgeweckt
werden (mittels resume ) und weitermachen.
Die Synchronisation mittels Semaphoren ist recht elementar und von ak-
tiven Objekten noch weit entfernt. Deutlich näher rückt man mit der
Klasse SharedQueue , deren Instanzen anstelle von Signalen (die ja ein-
fach nur gezählt werden) Objekte aufnehmen und die eine Synchronisa-
tion über next und nextPut: erlauben. Das Protokoll sieht wie folgt aus:
Wenn man nun eine solche Shared queue einem Objekt zuordnet und von anderen Objek-
ten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Me-
thode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das
Objekt mit einem Prozess , der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann
hat man tatsächlich „ aktive Objekte , die einander Nachrichten schicken“.
