12 Dynamisches Binden

Wie bereits in den Abschnitten 4.3.2 und 4.5.2 in Kurseinheit 1 angerissen, verbirgt sich hinter dem Nachrichtenversand ein dynamisch gebundener Methodenaufruf. Dabei ist die Auswahl der Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt abhängig. In Abschnitt 11.2 hatten wir bereits angedeutet, wie in Superklassen definierte Methoden für ihre Subklassen zugreifbar sind; hier schauen wir uns nun etwas genauer an, wie die dynamische Bindung von Methodenaufrufen vonstatten geht.
Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Dies kann man auch selbst tun: Es gibt dafür in der Klasse Behavior eine Instanzmethode oder so ähnlich (je nach System), die somit allen Klassen (als Klassenmethode) zur Verfügung steht. (Behavior ist ja eine Superklasse von Class, die wiederum Superklasse aller Metaklassen ist, von denen jede Klasse eine Instanz ist, so dass alle Klassen die Methode includesSelector: verstehen.)
Wird die Methode gefunden, dann wird sie ausgeführt. Wird sie nicht gefunden, wird zunächst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum bereits erwähnten Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument.
Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Methode einer Superklasse des Empfängerobjekts ausgeführt wird, das Objekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilierung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden — handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch Instanz seiner Klasse ist. Die gerade ausgeführte Methode betrachtet es lediglich wie ein Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die Bedeutung der Pseudovariable super, wie wir noch sehen werden.
Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, aus Effizienzgründen direkt in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im Wesentlichen äquivalent zu der der Methode canUnderstand:, die genau wie includesSelector: in der Klasse Behavior definiert ist.
Man beachte übrigens, wie wenig Aufwand es ist, aus dem klassenbasierten Methoden-Lookup einen objektbasierten zu machen: Man muss dazu lediglich jedem einzelnen Objekt sein eigenes Methodenwörterbuch zur Verfügung stellen. Wenn man zusätzlich noch Objekte von Objekten anstelle von Klassen von Klassen erben lässt, dann hat man schon die prototypenbasierte Form der objektorientierten Programmierung. Der Unterschied ist also technisch nicht besonders groß — konzeptuell hingegen schon, denn mit den Klassen entfielen auch die sonst so nützlichen Begriffe von Generalisierung und Spezialisierung (von der Generalisierung von Objekten zu sprechen erscheint wenig sinnvoll).
Eines der immer wieder vorgetragenen Hauptargumente gegen den Einsatz von SMALLTALK in der kommerziellen Programmierung ist der Umstand, dass das dynamische Binden wirklich vollkommen dynamisch ist: Dass einem Objekt eine Nachricht geschickt wird, die es nicht versteht, tritt immer erst zur Laufzeit zutage (s. Verhältnis von Abschnitt 10.3 und 11.3).41 In den statisch typgeprüften Sprachen, die wir in den nächsten Kurseinheiten kennenlernen werden, ist das charakteristischerweise nicht so. Dem kann man entgegenhalten, dass die heutigen (auch) statisch typgeprüften Programmiersprachen wie JAVA, C# oder C++ sämtliche nicht ohne dynamische Typumwandlungen auskommen, die ebenfalls zu Laufzeitfehlern führen können. Tatsächlich ist es sowohl in SMALLTALK als auch in JAVA und C# (in C++ nur mit Einschränkungen; s. Abschnitt 51.5) nicht nur möglich, sondern sogar geboten, Laufzeitfehler da, wo möglich, zu vermeiden, indem man vor einem Methodenaufruf explizit prüft, ob ein Objekt die gewünschte Methode auch hat — in SMALLTALK mittels canUnderstand:, in JAVA et al. mittels eines entsprechenden Typtests vor einem Downcast. Die größere Flexibilität, die die objektorientierte Programmierung durch das dynamische Binden bietet, hat eben den Preis, dass bestimmte Laufzeitprüfungen durchgeführt werden müssen. Statische Typprüfung kann das Risiko von Typfehlern verringern, aber nicht ausschließen — gleichzeitig schränkt es die Flexibilität beim Programmieren ein, ein Umstand, der so manchen, der schon einmal größere Programme in SMALLTALK geschrieben hat, an der Verwendung typgeprüfter Sprachen stört.

Frage: Was versteht man unter dynamischem Binden von Methodenaufrufen in SMALLTALK?
Antwort: Beim dynamischen Binden von Methodenaufrufen in SMALLTALK hängt die Auswahl der auszuführenden Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt ab. Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zuerst überprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Wenn die Methode gefunden wird, wird sie ausgeführt. Andernfalls wird in der direkten Superklasse der Klasse des Objekts gesucht, und so weiter, bis die Methode gefunden wird oder ein Laufzeitfehler auftritt.

Frage: Wie funktioniert die Suche nach einer Methode in SMALLTALK?
Antwort: Bei der Suche nach einer Methode wird zunächst im Methodenwörterbuch der Klasse des Empfängers nachgeschlagen. Wenn die Methode dort nicht gefunden wird, wird in der direkten Superklasse der Klasse des Objekts gesucht, und dieser Prozess setzt sich fort, bis die Methode gefunden wird oder bis zur Klasse "Object". Sobald die Methode gefunden wird, wird sie ausgeführt. Falls die Methode auch in "Object" nicht gefunden wird, wird die Nachricht "doesNotUnderstand:" an den ursprünglichen Empfänger mit der ursprünglichen Nachricht als Argument gesendet.

Frage: Warum bleibt das Empfängerobjekt bei der Ausführung einer Methode aus einer Superklasse dasselbe?
Antwort: Obwohl bei der Ausführung einer Methode aus einer Superklasse die Methode in einer Superklasse kompiliert wurde, bleibt das Objekt, auf dem sie ausgeführt wird, dasselbe Empfängerobjekt. Dies bedeutet, dass das Objekt immer noch Instanz seiner ursprünglichen Klasse ist. Die Methode betrachtet es jedoch wie ein Objekt der Klasse, in der sie selbst definiert ist. Dies ermöglicht den Zugriff auf die Instanzvariablen, die für die Objekte dieser Klasse zugreifbar sind.

Frage: Was ist der Unterschied zwischen dynamischer und statischer Typisierung in Bezug auf das dynamische Binden?
Antwort: In der dynamischen Bindung, wie sie in SMALLTALK verwendet wird, erfolgt die Auswahl der Methode zur Laufzeit und hängt von der Art des Empfängerobjekts ab. In der statischen Typisierung, wie sie in statisch typgeprüften Sprachen wie JAVA, C# und C++ verwendet wird, erfolgt die Typüberprüfung zur Übersetzungszeit und nicht zur Laufzeit. Statisch typisierte Sprachen erfordern in der Regel, dass der Programmierer den Datentyp der Objekte und deren Methoden im Voraus festlegt, während dynamisch typisierte Sprachen mehr Flexibilität bieten, da die Typüberprüfung erst zur Laufzeit erfolgt. Allerdings erhöht die dynamische Bindung das Risiko von Laufzeitfehlern, die in statisch typisierten Sprachen vermieden werden können, indem explizite Typüberprüfungen durchgeführt werden.