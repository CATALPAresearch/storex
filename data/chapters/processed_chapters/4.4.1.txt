4.4.1 Home Context und Closure

Da Blöcke Objekte sind, denen Variablen zugewiesen werden können, können sie auch an andere Methoden übergeben werden. Werden sie dort (mittels value) ausgewertet, findet die Ausführung in einem anderen Kontext statt. In diesem Kontext sind die "freien" Variablen des Blocks (also diejenigen, die nicht selbst als lokale Variablen deklariert wurden; x und y in Zeile 175) nicht zugreifbar. Der Block nimmt deshalb seinen Kontext mit (oder, genauer gesagt, der Kontext ist im Block enthalten). Den Kontext, in dem ein Block definiert wurde (in dem das ihn repräsentierende Objekt erzeugt wurde), nennt man seinen Home Context. Die Auswertung eines Blocks erfolgt stets in seinem Home Context, auch dann, wenn ihm value in einem anderen Kontext gesendet wurde.
Dass ein Block aus seinem Home Context herausgelöst und in einem anderen gespeichert werden kann, beinhaltet das Problem, dass die lokalen Variablen des Home Contexts schon verschwunden sein können, wenn der Block ausgewertet wird. Die durch den Block "eingefangenen" lokalen Variablen (einschließlich der formalen Parameter) müssen daher unabhängig von der Ausführung der Methoden, die sie definieren, weiterleben. Die Umsetzung von Blöcken durch den SMALLTALK-Compiler ist alles andere als trivial, und verschiedene SMALLTALK-Systeme unterscheiden sich darin teilweise erheblich voneinander, was sich (leider) auch in unterschiedlichem Verhalten äußert.
Die Blöcke in SMALLTALK werden in anderen Sprachen übrigens als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können. Dabei unterscheiden sich die Sprachen erheblich darin, was alles in eine Closure einbezogen werden kann. Zum Beispiel können die lokalen Namen (Variablen) auf Konstanten eingeschränkt werden, um zu verhindern, dass temporäre Variablen weiterleben müssen, nur weil sie in einer Closure enthalten sind.

Frage: Was ist der Home Context eines Blocks in SMALLTALK?
Antwort: Der Home Context eines Blocks in SMALLTALK ist der Kontext, in dem der Block definiert wurde oder genauer gesagt, in dem das ihn repräsentierende Objekt erzeugt wurde. Dieser Kontext enthält Informationen über die lokalen Variablen und formalen Parameter, die der Block "einfängt". Die Ausführung eines Blocks erfolgt immer in seinem Home Context, selbst wenn der Block in einem anderen Kontext ausgewertet wird.

Frage: Was sind "freie" Variablen in Bezug auf Blöcke in SMALLTALK?
Antwort: "Freie" Variablen in Bezug auf Blöcke in SMALLTALK sind Variablen, die im Block verwendet werden, aber nicht im Block selbst deklariert wurden. Das bedeutet, dass diese Variablen aus dem Home Context des Blocks stammen und vom Block "eingefangen" wurden. Diese freien Variablen können im Kontext, in dem der Block ausgewertet wird, nicht direkt zugegriffen werden.

Frage: Warum müssen die durch einen Block "eingefangenen" lokalen Variablen weiterleben, unabhängig von der Ausführung der Methoden, die sie definieren?
Antwort: Die durch einen Block "eingefangenen" lokalen Variablen müssen weiterleben, da der Block in einem anderen Kontext ausgewertet werden kann, in dem die ursprünglichen lokalen Variablen möglicherweise nicht mehr existieren. Um sicherzustellen, dass der Block korrekt funktioniert, müssen die im Block verwendeten Variablen weiterhin zugänglich sein, auch wenn der ursprüngliche Kontext, in dem sie definiert wurden, nicht mehr existiert.

Frage: Wie werden Blöcke in anderen Programmiersprachen oft genannt, und wofür werden sie verwendet?
Antwort: Blöcke in SMALLTALK werden in anderen Programmiersprachen oft als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, die anonyme Funktionen repräsentieren und als Objekte oder Werte behandelt werden können. Closures erlauben es, Funktionen aus ihrem Kontext herauszulösen und in andere Kontexte zu übertragen. Die Verwendung und das Verhalten von Closures können sich jedoch zwischen verschiedenen Programmiersprachen erheblich unterscheiden.