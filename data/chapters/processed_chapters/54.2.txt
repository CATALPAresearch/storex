54.2 Subtyping und das Prinzip der Substituierbarkeit

Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit immer dann fraglich ist, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies soll nun etwas genauer beleuchtet werden.
In Java ist die Klasse Stack als Subklasse der Klasse Vector definiert, wobei Vector kein Vektor im mathematischen Sinne ist, sondern eher ein dynamisches Array, das in seiner Größe wachsen kann. Dies führt jedoch dazu, dass an Stellen im Programm, an denen eine indizierte Sammlung von Objekten mit wahlfreiem Zugriff erwartet wird (also ein Objekt vom Typ Vector), ein Objekt vom Typ Stack auftauchen kann. Obwohl Stack intern möglicherweise auf einem dynamischen Array ähnlich Vector aufbaut (und daher von Vector erbt), muss es an seiner öffentlich zugänglichen Schnittstelle die Funktionen für den wahlfreien Zugriff unterdrücken. In Java ist dies jedoch nicht möglich. Sollte das Programm also, in Erwartung einer indizierten Sammlung, auf ein Element zugreifen und stattdessen einen Stack vorfinden, kann das Programm nicht fortgesetzt werden, es sei denn, es findet vor dem Zugriff eine entsprechende Prüfung (und möglicherweise eine Verzweigung zu alternativen Verfahren) statt. Eine solche Prüfung muss jedoch zur Laufzeit erfolgen, und wenn sie vergessen wird (nicht implementiert), kann dies zu einem schwerwiegenden Programmierfehler führen. Solche Fehler lassen sich einfach vermeiden, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.
Eine schwächere Variante, die jedoch ähnlich katastrophale Folgen haben kann und deren Vorliegen nur schwer festzustellen ist, tritt auf, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht. Dies ist beispielsweise bei den beiden Typen Set (Menge) und Bag (Multimenge) der Fall. Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist. Die Funktionen "Hinzufügen eines Elements", "Entfernen eines Elements" sowie die Angabe der Größe und der Test auf das Vorhandensein eines Elements werden von Set genauso unterstützt wie von Bag. Der einzige Unterschied scheint zu sein, dass das Hinzufügen eines bereits vorhandenen Elements in der Menge von Set keine Veränderung bewirkt.
Bei genauerer Betrachtung ergibt sich jedoch das Problem, dass Set durch seine Eigenheit mehrere charakteristische Eigenschaften von Multimengen verletzt. Zum Beispiel gilt für Sets nicht wie für Bags, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden; doppelte Einfügungen werden von Set einfach ignoriert. Ein Programm, das auf die Eigenschaften von Bags setzt und stattdessen mit einem Set arbeiten muss, funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.
Umgekehrt würde, wenn man Bag als Subtyp von Set annähme, die für Set charakteristische Eigenschaft verletzt, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden.
Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des jeweils anderen implizieren, und dass sie sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen wie "Für alle Objekte vom Typ X gilt..." bilden, wobei die Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird. Dies entspricht jedoch genau der Definition des Subtypings aus Kurseinheit 3, Abschnitt 26.1. Tatsächlich ist es mehr oder weniger eine Frage der Interpretation, ob die in Kapitel 26 genannten syntaktischen Bedingungen, insbesondere die Ko- und Kontravarianz, für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen.
In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren in Form der Prüfung der Typkonformität immer nur angenähert. Tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen werden, wenn mangelnde Typkonformität vorliegt. Dennoch werden entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet jedoch Typkonformität nicht automatisch auch Substituierbarkeit. Dazu ist auch eine Betrachtung des Verhaltens notwendig.

Frage: Warum ist die Substituierbarkeit fraglich, wenn keine Typerweiterung vorliegt?
Antwort: Die Substituierbarkeit ist fraglich, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies führt zu Problemen, wenn Objekte eines Subtyps an Stellen verwendet werden, an denen Objekte des Supertyps erwartet werden.

Frage: Warum kann die Unterdrückung von Eigenschaften bei abgeleiteten Typen in Java problematisch sein?
Antwort: In Java ist die Unterdrückung von Eigenschaften bei abgeleiteten Typen problematisch, da sie dazu führen kann, dass an Stellen im Programm, an denen ein Objekt des Supertyps erwartet wird, ein Objekt des Subtyps auftaucht. Dies kann zu schwerwiegenden Programmierfehlern führen, da die erwarteten Funktionen des Supertyps möglicherweise nicht verfügbar sind.

Frage: Welches Beispiel wird gegeben, um das Problem der Substituierbarkeit zwischen den Typen Set (Menge) und Bag (Multimenge) zu erklären?
Antwort: Das Beispiel betrifft die Substituierbarkeit zwischen den Typen Set (Menge) und Bag (Multimenge). Wenn Set als Subtyp von Bag angesehen wird, gibt es Probleme, da Sets einige charakteristische Eigenschaften von Multimengen verletzen, wie die Größenänderung nach dem Hinzufügen eines Elements. Wenn Bag als Subtyp von Set angesehen wird, wird die charakteristische Eigenschaft verletzt, dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist.

Frage: Warum können keine korrekten Aussagen wie "Für alle Objekte vom Typ X gilt..." gebildet werden, wenn X (Bag oder Set) als Subtyp von Y (dem jeweils anderen Typ) betrachtet wird?
Antwort: Es können keine korrekten Aussagen wie "Für alle Objekte vom Typ X gilt..." gebildet werden, wenn X (Bag oder Set) als Subtyp von Y (dem jeweils anderen Typ) betrachtet wird, da die charakteristischen Eigenschaften der beiden Typen im Widerspruch zueinander stehen. Dies entspricht nicht der Definition des Subtypings, da die Bedingungen der Ko- und Kontravarianz nicht erfüllt sind.

Frage: Warum reicht die Typkonformität allein nicht aus, um Substituierbarkeit sicherzustellen?
Antwort: Die Typkonformität allein reicht nicht aus, um Substituierbarkeit sicherzustellen, da auch das Verhalten der Objekte betrachtet werden muss. Typkonformität bedeutet nicht automatisch Substituierbarkeit. Substituierbarkeit erfordert eine Betrachtung des Verhaltens der Objekte.

Frage: Wie wird die Prüfung der Substituierbarkeit in der Praxis durchgeführt?
Antwort: In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren, insbesondere die Prüfung der Typkonformität, angenähert. Dabei wird jedoch betont, dass nicht einmal eine Substituierbarkeit ausgeschlossen werden kann, wenn mangelnde Typkonformität vorliegt. Substituierbarkeit erfordert auch eine Betrachtung des Verhaltens der Objekte.