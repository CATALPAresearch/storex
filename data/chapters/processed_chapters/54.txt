54 Das Problem der Substituierbarkeit

In Kapitel 26 sind wir bereits ausführlich auf den Begriff des Subtypings eingegangen. Subtyping sollte die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen, dh. erlauben, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Dies führt nun zu dem Problem, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat.82 Gemäß den Regeln gängiger objektorientierter Programmiersprachen zur Zuweisungskompatibilität wissen wir lediglich, dass es sich beim Typ des Empfängerobjekts e um einen Subtyp von T handeln muss83, jedoch wissen wir nicht genau, um welchen Subtyp es sich handelt. In einer statischen, lokalen Betrachtung84, also bei mangelnder Kenntnis des Typs des von e bezeichneten Objekts sowie aller infrage kommenden Subtypen von T, befinden wir uns in einem Zustand völliger Unsicherheit. Da die Erweiterung um Subklassen bzw. Subtypen jedoch eine der Errungenschaften der objektorientierten Programmierung ist, handelt es sich hierbei um ein echtes Problem.
Das Problem lässt sich als ein Problem der formalen Programmverifikation ausdrücken: Wie kann bewiesen werden, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts gebunden werden können? Es handelt sich um die Beziehung P {e m} Q (54.1), bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse darüber, was der Methodenaufruf tatsächlich bewirkt oder vielmehr, welchen Effekt er hat. Dafür ist die Kenntnis der Implementierung der Methode erforderlich. Andererseits ist es wichtig für die Pflege und Weiterentwicklung eines Programms zu wissen, unter welchen Bedingungen die Methoden einer neu eingeführten Klasse in das bestehende Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert. Die Bedingungen müssen bekannt sein, um sicherzustellen, dass die neue Implementierung sich in den Kanon der bereits bestehenden einordnet und kein unerwartetes Verhalten hervorruft. Nur wenn diese Zusicherungen in Form von (54.1) für alle Aufrufe erfüllt sind, ist das Funktionieren des Programms nicht gefährdet. Andernfalls könnte es beeinträchtigt sein. Daher müssen die Bedingungen bekannt sein.
Die Frage, wie der Effekt aller Implementierungen von m für Subtypen von T (einschließlich T selbst) erfasst werden kann, steht im Raum. Eine naive Antwort auf diese Frage würde vorschlagen, dass man sich alle diese Implementierungen ansieht und auf dieser Grundlage eine Fallunterscheidung präsentiert: Wenn das Objekt e vom Typ T ist, dann hat m den und den Effekt, wenn es von Subtyp T1 ist, dann hat m den und den Effekt, usw. Die Zusammenfassung dieser Fallunterscheidungen würde dann alle Effekte logisch mit einem Oder verknüpfen. Diese Möglichkeit hat jedoch den Nachteil der Unhandlichkeit und berücksichtigt nicht vorhandene Implementierungen nicht. Was man stattdessen möchte, ist die Gewissheit, dass eine lokale, "modulare" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte. Genau das soll der Begriff der Substituierbarkeit ermöglichen.

Frage: Was ist das Problem, das im Zusammenhang mit Subtyping und dynamischem Methodenaufruf auftritt?
Antwort: Das Problem besteht darin, dass aufgrund des dynamischen Bindens von Methodenaufrufen nicht vorhergesagt werden kann, welchen Effekt ein Aufruf der Methode in einem bestimmten Programmfragment haben wird, selbst wenn der Typ des Empfängerobjekts bekannt ist. Es ist schwer zu bestimmen, welcher Subtyp des Typs des Empfängerobjekts tatsächlich betroffen ist.

Frage: Wie kann das Problem des dynamischen Bindens und der Unsicherheit bei Methodenaufrufen in Bezug auf Subtyping ausgedrückt werden?
Antwort: Das Problem kann als ein Problem der formalen Programmverifikation ausgedrückt werden. Es geht darum, wie bewiesen werden kann, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts korrekt gebunden werden können. Dies erfordert genaue Kenntnisse darüber, welchen Effekt der Methodenaufruf hat, was die Kenntnis der Implementierung der Methode erfordert.

Frage: Warum ist es wichtig zu wissen, wie Methoden einer neu eingeführten Klasse in ein bestehendes Programm integriert werden können?
Antwort: Es ist wichtig zu wissen, wie Methoden einer neu eingeführten Klasse in ein bestehendes Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert und keine unerwarteten Verhaltensänderungen auftreten. Dies ist notwendig, um sicherzustellen, dass die neuen Implementierungen sich nahtlos in das bestehende Programm einfügen und die Programmfunktionalität nicht gefährden.

Frage: Wie kann das Problem der Substituierbarkeit dazu beitragen, das Problem des dynamischen Bindens und der Unsicherheit bei Methodenaufrufen zu lösen?
Antwort: Das Konzept der Substituierbarkeit zielt darauf ab, sicherzustellen, dass eine lokale, "modulare" Betrachtung ausreicht, um zu verstehen, welchen Effekt ein Methodenaufruf haben wird, ohne eine umfassende Analyse des gesamten Programms durchführen zu müssen. Substituierbarkeit soll sicherstellen, dass die Bedingungen, unter denen die Methodenaufrufe korrekt sind, bekannt sind, und dass die Implementierungen von Methoden für Subtypen eines bestimmten Typs korrekt verwendet werden können.