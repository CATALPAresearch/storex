43.2 Parametrische Typen und Subtyping: Wildcards

Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode "sort" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von "ArrayList<E>" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ "ArrayList<Integer>" und "ArrayList<String>".
Aber wie wir bereits gesehen haben, sind "ArrayList<Integer>" und "ArrayList<String>" trotz der Tatsache, dass "Integer" und "String" Subtypen von "Comparable" sind, nicht zuweisungskompatibel mit "ArrayList<Comparable>". Was also tun?
In JAVA wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: "List<?>" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ "List<?>" ein Supertyp aller Instanziierungen von "List<T>" - beispielsweise sind "List<Integer>" und "List<String>" mit "List<?>" zuweisungskompatibel.
Das Fragezeichen nicht durch "Integer" ersetzt wird; die anschließende Zuweisung ist also möglich.
Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C# existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).
List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie "List<?>" und "ArrayList<?>", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt.
Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen.
Da nicht sichergestellt werden kann, dass "list" tatsächlich auf ein Objekt vom Typ "List<Integer>" verweist. Die einzige gültige Zuweisung an Elemente von "list" ist die von "null". Umgekehrt kann beim Lesen der Elemente aus "list" kein anderer Typ als "Object" angenommen werden, da "list" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.
Wir kennen bereits das Konzept der Beschränkung von Typparametern aus Abschnitt 29.4. Dieses Konzept kann auch auf Typ-Wildcards angewendet werden.
Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.
"List<? super Integer>" ist also ein spezieller Supertyp von allen Instanzen von "List<E>", deren tatsächlicher Typparameter (also der für "E" eingesetzte Typ) ein Supertyp von "Integer" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.
Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit "extends" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also "Integer" ein Subtyp von "Number" ist, dann ist auch "List<? extends Integer>" ein Subtyp von "List<? extends Number>". Umgekehrt gilt für mit "super" nach unten beschränkte Typen, dass "List<? super Integer>" ein Supertyp von "List<? super Number>" ist. Man sagt auch, das Subtyping mit "extends" beschränkter Wildcard-Typen sei kovariant und das mit "super" beschränkter Wildcard-Typen kontravariant.
Dies ermöglicht es, eine Liste von Zahlen oder eine Liste von Untertypen von "Number" zu übergeben und die Summe der Zahlen zu berechnen, unabhängig von ihrem konkreten Typ.

Frage: Warum wurden Typ-Wildcards (Wildcard-Typen) in Java eingeführt?
Antwort: Typ-Wildcards wurden eingeführt, um eine flexiblere Form der Zuweisungskompatibilität für generische Typen zu ermöglichen, insbesondere bei der Verwendung von Collections mit unterschiedlichen Typparametern.

Frage: Was ist das Symbol für eine Typ-Wildcard in Java?
Antwort: Das Symbol für eine Typ-Wildcard in Java ist das Fragezeichen (?).

Frage: Was bedeutet es, wenn ein Typ mit einer Typ-Wildcard (z. B. List<?>) deklariert wird?
Antwort: Wenn ein Typ mit einer Typ-Wildcard deklariert wird, bedeutet dies, dass die Variable dieses Typs Objekte beliebigen, aber unbekannten Typparameters akzeptieren kann. Es ist eine abstrakte Deklaration.

Frage: Was ist die Verwendung von "extends" und "super" in Verbindung mit Typ-Wildcards?
Antwort: "extends" wird verwendet, um eine obere Schranke für Typ-Wildcards anzugeben, während "super" verwendet wird, um eine untere Schranke anzugeben. Mit "extends" beschränkte Wildcard-Typen sind kovariant, und mit "super" beschränkte Wildcard-Typen sind kontravariant.

Frage: Welche Einschränkung gibt es bei der Verwendung von "super" beschränkten Typ-Wildcards?
Antwort: Bei "super" beschränkten Typ-Wildcards ist der Zugriff auf Elemente in der Regel auf schreibende Zugriffe beschränkt, und lesende Zugriffe haben immer den Typ "Object".

Frage: Wie können Typ-Wildcards in Java zur Verbesserung der Typsicherheit verwendet werden?
Antwort: Typ-Wildcards können verwendet werden, um sicherzustellen, dass Zuweisungen und Zugriffe auf generische Typen zur Übersetzungszeit statisch typsicher sind, ohne dass es zu Laufzeitfehlern kommt. Dies erhöht die Typsicherheit von Java-Programmen.

Frage: Warum sind "ArrayList<Integer>" und "ArrayList<String>" trotz "Integer" und "String" als Subtypen von "Comparable" nicht zuweisungskompatibel mit "ArrayList<Comparable>"?
Antwort  "ArrayList<Integer>" und "ArrayList<String>" sind nicht zuweisungskompatibel mit "ArrayList<Comparable>", weil generische Typen in Java keine kovariante Zuweisung von Subtypen erlauben. Dies wurde durch die Einführung von Typ-Wildcards gelöst.

Frage: Welche Art von Subtyping wird bei "extends" beschränkten Wildcard-Typen verwendet?
Antwort: "extends" beschränkte Wildcard-Typen verwenden kovariantes Subtyping.

Frage: Welche Art von Subtyping wird bei "super" beschränkten Wildcard-Typen verwendet?
Antwort: "super" beschränkte Wildcard-Typen verwenden kontravariantes Subtyping.

Frage: Wie können Typ-Wildcards in Java dazu verwendet werden, eine Liste von Zahlen oder Untertypen von "Number" zu verarbeiten?
Antwort: Typ-Wildcards können verwendet werden, um eine Methode wie "sum(List<? extends Number> list)" zu erstellen, die eine Liste von Zahlen oder Untertypen von "Number" akzeptiert und die Summe der Zahlen berechnet, unabhängig von ihrem konkreten Typ.