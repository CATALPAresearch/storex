38 Anweisungen, Blöcke und Kontrollstrukturen

Genau wie in SMALLTALK werden in JAVA Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Anders als in SMALLTALK gibt es in JAVA jedoch eine Vielzahl von Schlüsselwörtern, die Anweisungen einleiten. Dennoch ist es auch in JAVA möglich, bestimmte Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden Ausdruck durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen (siehe Kapitel 37) direkt zu Anweisungen. Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK, das Semikolon in JAVA kein Trennzeichen ist, sondern Teil der Anweisung.
Nahezu alle Anweisungen finden sich in JAVA-Programmen innerhalb von Methoden. Blöcke sind in JAVA lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt JAVA erst seit Version 8, mit der Einführung der Lambda-Ausdrücke.
Es sind also Variablendeklarationen, Methodenaufrufe (inklusive der Konstruktoraufrufe) und Zuweisungen Anweisungen. Alle anderen Anweisungen werden durch Schlüsselwörter eingeleitet und realisieren Kontrollstrukturen, die den Kontrollfluss eines Programms dazu bringen, von der normalen, sequentiellen Ausführung abzuweichen. Im Einzelnen sind dies:
die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet;
die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst;
die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen);
die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet;
die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement);
die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C.
die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss;
die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde;
die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler);
die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen);
die Synchronized-Anweisung der Form synchronized (<Ausdruck>) <Block>, die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem <Ausdruck> ausgewertet wird, verbundene Lock dies zulässt (siehe Abschnitt 47.3);
die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden);
die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt;
die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.
Bemerkungen: Das Weglassen von break; am Ende einer Liste von Anweisungen in einem Case-Zweig der Switch-Anweisung wird als "Fall durch" bezeichnet und bewirkt, dass mit den Anweisungen des nächsten Case-Zweigs fortgefahren wird. Dies ermöglicht das Zusammenführen mehrerer Fälle, ist jedoch eines der fehlerträchtigsten Konstrukte C-artiger Sprachen.
Die Assert-Anweisung kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen. Wenn der Ablauf des Programms von diesen Werten abhängt, macht es einen Unterschied, ob ein Programm mit oder ohne Prüfung der Assertions ausgeführt wird. Das ist ein starkes Stück.
Assert-Anweisungen sind ein erster zarter Versuch, in JAVA auch noch andere Invarianten als die Typinvarianten unterzubringen. Dabei findet die Überprüfung dieser mittels assert eingebrachten Invarianten im Gegensatz zum Großteil der Typprüfung erst zur Laufzeit statt, indem die entsprechenden Statements ausgeführt werden. Dabei beziehen sich die Bedingungen, die die Invarianten formulieren, häufig auf Methoden des Programms, für die die Invarianten angegeben werden sollen. Da diese Methoden aber auch den Zustand des Programms ändern können, kann man einer Zusicherung mit assert nicht ansehen, ob sie seiteneffektfrei ist. Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden nicht als Anweisungen formuliert, sondern als Quellcodeannotationen und stellen zudem sicher, dass alle Zugriffe auf Programmelemente, die zur Laufzeit notwendig sind, den Zustand des Programms nicht verändern.

Frage: Welche Arten von Anweisungen gibt es in JAVA?
Antwort: In JAVA gibt es verschiedene Arten von Anweisungen, darunter Variablendeklarationen, Wertzuweisungen, Methodenaufrufe, Klasseninstanziierungen und Kontrollstrukturen wie If-Anweisungen, Schleifen, Switch-Anweisungen, Try-Anweisungen und mehr.

Frage: Wie können Ausdrücke zu Anweisungen in JAVA gemacht werden?
Antwort: In JAVA können Ausdrücke zu Anweisungen gemacht werden, indem sie einfach durch ein Semikolon abgeschlossen werden. Dies gilt insbesondere für Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen.

Frage: Welche Arten von Schleifen werden in JAVA unterstützt?
Antwort: JAVA unterstützt While-Schleifen, Do-Schleifen, For-Schleifen und die erweiterte For-Schleife. Dabei wird While-Schleife verwendet, um Anweisungen solange auszuführen, wie eine Bedingung wahr ist. Do-Schleife ist ähnlich, aber die Bedingung wird erst nach der Ausführung überprüft. For-Schleifen ermöglichen die explizite Initialisierung, Bedingung und Veränderung der Schleifenvariable. Die erweiterte For-Schleife iteriert über die Elemente eines Arrays oder Objekts, das Iterable implementiert.

Frage: Was bewirkt die Break-Anweisung in JAVA?
Antwort: Die Break-Anweisung in JAVA bewirkt, dass eine Schleife oder ein Switch-Statement sofort verlassen wird. Sie kann optional mit einem Label versehen werden, um eine äußere Schleife oder ein äußeres Switch-Statement zu verlassen.

Frage: Was ist der Zweck der Assert-Anweisung in JAVA?
Antwort: Die Assert-Anweisung in JAVA dient dazu, bestimmte Bedingungen im Programm zu überprüfen. Wenn die Bedingung zu false ausgewertet wird, wird das Programm mit einer entsprechenden Fehlermeldung abgebrochen. Die Assert-Anweisung kann auch ein optionales Ergebnis liefern, das in der Fehlermeldung angezeigt wird. Sie eignet sich zur Überprüfung von Invarianten zur Laufzeit.