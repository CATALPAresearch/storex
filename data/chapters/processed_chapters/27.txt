27 Typumwandlungen

Zuweisungskompatibilität unter Subtyping erlaubt also die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps. Für die statische Typprüfung ergibt sich daraus kein Problem, weil sichergestellt ist, dass die Subtypen alle Eigenschaften ihrer Supertypen erhalten, so dass keine Typfehler auftreten können. Für die Programmiererin ergibt sich aber manchmal das Problem, dass sie ein Objekt, auf das eine Variable eines Supertyps verweist, wie ein Objekt seines tatsächlichen Typs verwenden möchte, in der Regel, weil sie eine Methode darauf aufrufen möchte, die der Supertyp nicht hat. Genau diesen Methodenaufruf würde die Typprüfung aber zurückweisen.
Für diesen Zweck gibt es die Möglichkeit der Typumwandlung (engl. type cast). Eine Typumwandlung ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen konvertiert wird. Mit dem Objekt, für das der Ausdruck steht, passiert dabei gar nichts — es wird lediglich der Compiler (bzw. der Type Checker) davon überzeugt, dass der Ausdruck den bei der Umwandlung angegebenen Typ hat. Sollte sich zur Laufzeit herausstellen, dass das nicht der Fall ist, kann ein Laufzeittypsystem — soweit vorhanden — dies bei seiner dynamischen Typprüfung bemerken und ggf. einen entsprechenden Fehler melden (vgl. die Anmerkungen dazu in Kapitel 18).
Typumwandlungen können grundsätzlich in verschiedene Richtungen erfolgen: zu Supertypen, zu Subtypen oder zu solchen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Man spricht entsprechend von Upcast, Downcast oder Crosscast. Upcasts sind immer typsicher, Downcasts und Crosscasts nicht. Downcasts sind relativ häufig; sie kommen vor allem dort vor, wo kein parametrischer Polymorphismus (Kapitel 29) zur Verfügung steht oder wo ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten; in der interfacebasierten Programmierung (s. Abschnitt 28.2) stehen sie für einen Rollenwechsel eines Objekts.
Nun sind Typumwandlungen entweder überflüssig oder unsicher. Man sollte daher versuchen, auf sie zu verzichten. Wo unverzichtbar, sollten Typumwandlungen mit einem Typtest abgesichert werden. Dabei wird zur Laufzeit geprüft, ob das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat. Ist das nicht der Fall, sollten die Teile des Programms, die den bei der Typumwandlung genannten Typ voraussetzen, nicht ausgeführt werden. Sie werden in späteren Kapiteln zu den einzelnen Programmiersprachen noch Beispiele für diese Praxis zu sehen bekommen.

Frage: Was erlaubt die Zuweisungskompatibilität unter Subtyping?
Antwort: Die Zuweisungskompatibilität unter Subtyping erlaubt die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps.

Frage: Warum kann es für die Programmiererin problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden?
Antwort: Es kann problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden, da der Supertyp möglicherweise nicht alle Methoden und Eigenschaften des tatsächlichen Typs enthält, die die Programmiererin verwenden möchte.

Frage: Was ist eine Typumwandlung?
Antwort: Eine Typumwandlung (type cast) ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen Typ konvertiert wird. Dies geschieht, um dem Compiler oder Type Checker mitzuteilen, dass der Ausdruck den angegebenen Typ hat, auch wenn dies nicht automatisch sichergestellt ist.

Frage: Welche Richtungen von Typumwandlungen gibt es?
Antwort: Typumwandlungen können in verschiedene Richtungen erfolgen: zu Supertypen (Upcast), zu Subtypen (Downcast) oder zu Typen, die weder Supertyp noch Subtyp des Ausgangstyps sind (Crosscast).

Frage: Warum sind Upcasts immer typsicher, während Downcasts und Crosscasts unsicher sein können?
Antwort: Upcasts sind immer typsicher, da sie von einem spezielleren Typ zu einem allgemeineren Typ erfolgen. Downcasts und Crosscasts können unsicher sein, da sie von einem allgemeineren Typ zu einem spezielleren oder nicht verwandten Typ erfolgen, was dazu führen kann, dass der Ausdruck zur Laufzeit nicht den erwarteten Typ hat.

Frage: Warum sollte man versuchen, Typumwandlungen zu vermeiden?
Antwort: Typumwandlungen sollten vermieden werden, da sie potenziell unsicher sind und die Programmlogik komplexer machen können. Wenn Typumwandlungen unvermeidbar sind, sollten sie mit einem Typtest abgesichert werden, um sicherzustellen, dass das Objekt zur Laufzeit den gewünschten Typ hat.