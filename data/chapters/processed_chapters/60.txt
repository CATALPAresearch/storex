60 Das Problem der mangelnden Eignung

Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die "gute" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort "Fehlanpassung" ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.
Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger (Delegates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug feiert).

Frage: Warum sind nicht alle Aufgaben gleichermaßen zur Lösung per objektorientierter Programmierung geeignet?
Antwort: Nicht alle Aufgaben sind gleichermaßen zur Lösung per objektorientierter Programmierung geeignet, da einige Aufgaben besser mit anderen Programmierparadigmen wie funktionale oder logische Programmiersprachen gelöst werden können. Auch Batch- und Scripting-Probleme, die einen imperativ-prozeduralen Charakter haben, eignen sich möglicherweise nicht optimal für die objektorientierte Programmierung.

Frage: Warum ist die gute objektorientierte Programmierung bei Problemen mit einem hohen algorithmischen Anteil und einfachen Datenstrukturen möglicherweise weniger geeignet?
Antwort: Die gute objektorientierte Programmierung erfordert, den Code auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Bei Problemen mit einfachen Datenstrukturen und einem hohen algorithmischen Anteil müssen größere Probleme jedoch in der Regel auf durch verschiedene Klassen definierte Daten zugreifen. Dies kann dazu führen, dass der Code durch seine Datenbindung regelrecht zerfleddert wird.

Frage: Warum ist die objektorientierte Programmierung möglicherweise nicht ideal für Programme, in denen es hauptsächlich um Abläufe geht?
Antwort: In Programmen, in denen es hauptsächlich um Abläufe geht, möchte man oft, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten, was die objektorientierte Programmierung weniger ideal macht.

Frage: Warum ist die Wahl einer geeigneten Programmiersprache in der Praxis oft ein Abwägungsproblem?
Antwort: Die Wahl einer geeigneten Programmiersprache ist oft ein Abwägungsproblem, da verschiedene Programmiersprachen unterschiedliche Vor- und Nachteile haben. Bei der objektorientierten Programmierung kann die Organisation der Funktionen auf der Strecke bleiben, während bei der prozeduralen Programmierung die Daten häufig in unüberschaubarer Weise hin- und hergeschickt werden oder global sind.

Frage: Warum eignen sich Programmiersprachen, die eine Mischung mehrerer Paradigmen erlauben, weniger für Anfängerinnen?
Antwort: Programmiersprachen, die eine Mischung mehrerer Paradigmen erlauben, können Anfängerinnen aufgrund ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen überfordern, wie man ein einzelnes Problem lösen kann.

Frage: Warum wird bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung oft von einem Impedanzmismatch gesprochen?
Antwort: Bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung besteht häufig ein Impedanzmismatch, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Die beiden Ansätze verwenden unterschiedliche Mittel zur Darstellung von Beziehungen und Datenstrukturen.

Frage: Warum muss man bei der Verarbeitung von relationalen Daten durch objektorientierte Programme oft Prinzipien der relationalen Welt anpassen?
Antwort: Bei der Verarbeitung von relationalen Daten durch objektorientierte Programme muss man sich an die Prinzipien der relationalen Welt anpassen, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Dies erfordert häufig, einen Teil dessen, was Objektorientierung ausmacht, aufzugeben.

Frage: Warum ist die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung?
Antwort: Die GUI-Programmierung ist nicht unbedingt ein Heimspiel für die objektorientierte Programmierung, da die Instanzen einer Klasse alle Methoden teilen und es nicht möglich ist, für verschiedene GUI-Elemente derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Dies kann zu Problemen führen, insbesondere wenn es um das gemeinsame Verhalten von GUI-Elementen geht.

Frage: Welche Variante der objektorientierten Programmierung scheint besser für die GUI-Programmierung geeignet zu sein?
Antwort: Die prototypenbasierte Variante der objektorientierten Programmierung, wie sie in JAVASCRIPT verwendet wird, scheint besser für die GUI-Programmierung geeignet zu sein.