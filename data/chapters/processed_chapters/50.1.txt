50.1 Das Programmiermodell von C#

Das Programmiermodell von C# unterscheidet sich zunächst nicht wesentlich von dem von JAVA: Auch in C# ist der Code auf Klassen verteilt, die einzeln übersetzt werden können. Klassen werden in Dateien gespeichert, jedoch ist das Verhältnis von Klasse zu Datei lockerer als in JAVA (u. a. können Klassen anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden). Allerdings sind der Bytecode und die dazu passende virtuelle Maschine nicht speziell für C# entworfen, sondern für alle sog. .NET-Sprachen. So heißt denn auch die Sprache des Bytecode Common Intermediate Language (CIL); sie gilt als (gerade noch) menschenlesbar.
Anders als bei JAVA waren bei C# Flexibilität und Performanz von Anfang an kritische Gesichtspunkte des Sprachentwurfs. Für C# war daher von Anfang an und ausschließlich die sog. Just-in-time-(JIT-)Kompilierung vorgesehen, die den CIL-Code unmittelbar vor der Ausführung (und nur, wenn er überhaupt ausgeführt wird) in Maschinencode der Maschine, auf der er gerade läuft, übersetzt. Die Einheiten der JIT-Kompilierung gehen dabei hinunter bis zu einzelnen Methoden. Eine vollständige Kompilierung von CIL in nativen Maschinencode vor der Ausführung ist ebenfalls möglich.
Eine andere Eigenschaft von JAVA, mit der die Programmiererinnen von MICROSOFT offenbar nicht unter allen Umständen leben konnten, ist die Garbage Collection. In C# hat man daher die Möglichkeit, den Speicherplatz für Objekte, die mit "new" erzeugt wurden, selbst wieder freizugeben. Doch wehe derjenige, der das vergisst: Speicherlecks sind die unmittelbare Folge. Noch schlimmer sind aber Speicherfreigaben von Objekten, auf die noch Referenzen existieren: Diese zeigen dann ins Leere oder, wenn der Speicher wieder belegt wird, auf oder mitten hinein in ein anderes Objekt. Eine Katastrophe. Aber damit nicht genug: Das mit SMALLTALK und JAVA abgeschaffte Hantieren mit Pointern wurde in C# auch wiedereingeführt, wohl weil man in der systemnahen Programmierung (und bei Aufrufen in das hauseigene Betriebssystem) nicht darauf verzichten konnte. Allerdings sind beide Rückschritte — explizite Speicherverwaltung und das Hantieren mit Pointern — in sog. unsichere Bereiche verbannt. Dazu gibt es in C# einen Modifikator "unsafe", der solche Bereiche einleitet:
Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger-auf-Typ handelt; vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch überladen wurde. Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.

Frage: Wie unterscheidet sich das Programmiermodell von C# von dem von JAVA?
Antwort: Das Programmiermodell von C# weist zunächst einige Ähnlichkeiten mit dem von JAVA auf, da es ebenfalls auf Klassen basiert und der Code in einzelnen Klassen organisiert ist. Die Klassen in C# können jedoch in lockererem Verhältnis zu Dateien stehen, und Klassen können anders benannt werden als ihre Dateien. Ein wesentlicher Unterschied besteht darin, dass der Bytecode von C# und die zugehörige virtuelle Maschine, Common Intermediate Language (CIL) genannt, für alle .NET-Sprachen entwickelt wurden und nicht exklusiv für C#. Die CIL gilt als menschenlesbar.

Frage: Was ist die Just-in-time-(JIT-)Kompilierung in C# und wie unterscheidet sie sich von JAVA?
Antwort: In C# ist die Just-in-time-(JIT-)Kompilierung die Standardmethode zur Übersetzung des CIL-Codes in Maschinencode. Dieser Vorgang erfolgt unmittelbar vor der Ausführung und nur dann, wenn der Code tatsächlich ausgeführt wird. Im Gegensatz dazu verwendet JAVA normalerweise den Ahead-of-time-(AOT-)Kompilierungsansatz, bei dem der Bytecode vor der Ausführung in nativen Maschinencode übersetzt wird. Die JIT-Kompilierung in C# ermöglicht eine feinere Granularität, da sie bis auf die Ebene einzelner Methoden herabgeht.

Frage: Welche Unterschiede gibt es in Bezug auf die Garbage Collection zwischen C# und JAVA?
Antwort: In C# haben Entwickler die Möglichkeit, den Speicherplatz für Objekte, die mit "new" erstellt wurden, manuell freizugeben. Dies kann jedoch zu Speicherlecks führen, wenn Entwickler vergessen, den Speicher freizugeben, oder zu Problemen, wenn auf freigegebene Objekte weiterhin Referenzen vorhanden sind. Im Gegensatz dazu verwendet JAVA normalerweise eine automatische Garbage Collection, bei der nicht mehr benötigte Objekte automatisch erkannt und freigegeben werden.

Frage: Warum wurde in C# das Hantieren mit Pointern wieder eingeführt, und wie werden unsichere Bereiche behandelt?
Antwort: In C# wurde das Hantieren mit Pointern in unsichere Bereiche verbannt, weil es in systemnahen Programmierungen und beim Zugriff auf das Betriebssystem notwendig ist. Der Modifikator "unsafe" kennzeichnet solche unsicheren Bereiche und wird verwendet, um den Einsatz von Pointern zu ermöglichen. In unsicheren Bereichen können Zeiger auf Typen deklariert werden, und die Dereferenzierung eines Zeigers erfolgt mit einem Stern (*). Dies ermöglicht das Hantieren mit Pointern in einem begrenzten und kontrollierten Umfeld.