8.2 Initialisierung

In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert "nil". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet.
Es ist jedoch nicht immer erforderlich, alle Instanzen einer Klasse auf die gleiche Weise zu initialisieren. Daher ist es möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu definieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die Klasse "Time" sind unten gegeben, wobei beide die Klassenmethode "seconds:" auf "Time" aufrufen (repräsentiert durch "self"), die wiederum mit "basicNew" eine Instanz von "Time" erzeugt und anschließend initialisiert.
Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar sind, kann auch eine Klassenmethode wie "new" nicht auf sie zugreifen. Die Initialisierung muss daher von Instanzmethoden wie "ticks:" durchgeführt werden, die jedoch nicht ausschließlich der Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen werden können. Dies kann problematisch sein, wenn Instanzvariablen initialisiert werden müssen, deren Existenz nach außen verborgen werden soll (siehe Abschnitt 4.3.4). Aus diesem Grund sehen "new" und "new:" standardmäßig den Aufruf der Methode "initialize" vor (siehe Zeilen 307 und 309 oben), in der alle Initialisierungen vorgenommen werden können, ohne dass etwas über den Aufbau der Instanzen nach außen verraten würde.
In anderen Sprachen wie C++, JAVA oder C# sind Konstruktoren daher auch keine Klassenmethoden, sondern haben eine Art Zwitterstatus: Sie werden auf einer Klasse aufgerufen, aber sie werden wie Instanzmethoden auf der neuen Instanz ausgeführt und können somit auf die Instanzvariablen der neu erzeugten Instanz zugreifen. Beachten Sie jedoch, dass die Methode "ticks:" keine Informationen über die Implementierung der Instanzvariablen der Klasse "Time" preisgibt.
Alternativ zur obigen Konstruktion kann die Initialisierung von Instanzvariablen auch zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt werden. Dies wird als "Lazy initialization" bezeichnet, da die Initialisierung solange wie möglich verschoben wird. Bei der Verwendung von Lazy initialization muss jedoch vor jedem lesebasierten Zugriff auf die (faul initialisierte) Instanzvariable überprüft werden, ob ihr Wert immer noch "nil" ist. Wenn dies der Fall ist, muss er durch den gewünschten Anfangswert ersetzt werden, der normalerweise in der Standardinitialisierungsmethode zu finden wäre. Um das Hinzufügen von Abfragen bei jedem lesebasierten Zugriff auf die Variable im Programm zu vermeiden, empfiehlt es sich, bei der Verwendung von Lazy initialization alle Zugriffe auf Instanzvariablen, einschließlich interner Klassenzugriffe, über entsprechende Getter-Methoden durchzuführen. Diese Getter-Methoden prüfen den Inhalt der Variable, bevor sie ihn zurückgeben, und setzen ihn gegebenenfalls. Die Lazy initialization erfordert zusätzlichen Code, der bei einer Standardinitialisierung nicht erforderlich wäre. Das laufende Programm spart jedoch den Preis der Initialisierung, wenn diese nie notwendig wird, d.h., wenn der Wert der zu initialisierenden Variable im Programmablauf nie oder erst nach einer anderen Zuweisung abgefragt wird. Lazy initialization lohnt sich daher immer dann, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Ein weiterer Vorteil der Lazy initialization besteht darin, dass die Initialisierung nie vergessen werden kann. Dies ist insbesondere dann wertvoll, wenn die Initialisierung nicht wie oben beschrieben vom Konstruktor selbst, sondern von einer separaten Methode durchgeführt wird und die Benutzer der entsprechenden Klasse möglicherweise nicht klar ist, dass sie nach dem Konstruktor auch noch die Initialisierungsmethode aufrufen müssen. Konstruktoren, die wie in Zeilen 307 und 309 oben implementiert wurden, versuchen dies zu verhindern, indem sie die Initialisierungsmethode selbst aufrufen. Manchmal kann der Konstruktor jedoch nicht einfach geändert werden (siehe Abschnitt 10.3), und es wird nicht verhindert, dass "basicNew" direkt und ohne "initialize" aufgerufen wird.

Frage: Was sind Konstruktoren in SMALLTALK und was ist ihre Aufgabe?
Antwort: In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse erstellen und zurückliefern. Ihre Aufgabe ist es, neue Objekte zu erzeugen.

Frage: Wie werden Instanzvariablen in SMALLTALK standardmäßig initialisiert, nachdem eine Instanz erzeugt wurde?
Antwort: Nach der Erzeugung einer Instanz in SMALLTALK haben alle Instanzvariablen standardmäßig den Wert "nil". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden, normalerweise durch Aufrufen der Methode "initialize".

Frage: Warum ist es möglich, in SMALLTALK mehrere alternative Konstruktoren (Klassenmethoden) für eine Klasse zu definieren?
Antwort: Es ist möglich, mehrere alternative Konstruktoren für eine Klasse in SMALLTALK zu definieren, da nicht immer alle Instanzen einer Klasse auf die gleiche Weise initialisiert werden müssen. Dies ermöglicht es, verschiedene Initialisierungsmethoden für verschiedene Anwendungsfälle anzubieten.

Frage: Warum wird in SMALLTALK die Methode "initialize" standardmäßig von den Konstruktoren "new" und "new:" aufgerufen?
Antwort: In SMALLTALK wird die Methode "initialize" standardmäßig von den Konstruktoren "new" und "new:" aufgerufen, um die Initialisierung der Instanzvariablen vorzunehmen. Dies erlaubt es, alle Initialisierungen in einer zentralen Methode durchzuführen, ohne dass etwas über den Aufbau der Instanzen nach außen verraten wird.

Frage: Was ist "Lazy initialization" und wann kann es sinnvoll sein?
Antwort: "Lazy initialization" ist eine Technik, bei der die Initialisierung von Instanzvariablen zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt wird. Dies kann sinnvoll sein, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Die Initialisierung wird verschoben, um den Preis der Initialisierung im Programmablauf zu sparen, wenn sie nie notwendig wird.