58 Das Problem der mangelnden Kapselung

Als man mit der objektorientierten Programmierung begann, war man glücklich, weil man glaubte, mit dem Konzept der Klassen eine natürliche Form der Kapselung (engl. encapsulation) gefunden zu haben, die zudem noch mit der hochangesehenen Theorie der abstrakten Datentypen in Einklang steht (zumindest einigermaßen): Klassen ergeben sich auf natürliche Weise aus der Anwendungsdomäne (als Repräsentanten von Allgemeinbegriffen; siehe Kurseinheit 1, Kapitel 7), und Daten sowie Implementierungsdetails lassen sich hinter der Klassenschnittstelle (dem Protokoll der Objekte) verbergen.
Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls gefeierte Vererbung die Kapselung von Klassen auf unangenehme Weise aufbrach: Wie in Kapitel 55 bemerkt, erzeugt die Vererbung starke Abhängigkeiten (auch zwischen den Implementierungsdetails!) von Klassen und ihren Subklassen. Diese Abhängigkeiten explizit zu machen kann zwar vor Programmierfehlern schützen, sie kann aber die Abhängigkeiten nicht beseitigen, sondern lediglich dokumentieren. Die Abhängigkeiten zu beschränken bedeutet wiederum, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das nun einmal: Alles hat seinen Preis.
Sehr viel dramatischer (und sehr viel weniger in aller Munde) ist jedoch ein ganz anderes Problem, das die gesamten bisherigen Bemühungen der Objektorientierung um Kapselung aushebeln kann: das Aliasing-Problem. Wenn nämlich ein Objekt, das durch ein anderes Objekt gekapselt wird, indem das andere es in einer seiner Instanzvariablen hält, einen (weiteren) Alias besitzt, der nicht selbst dem kapselnden Objekt gehört, dann nützt es nichts, wenn diese Instanzvariable von außen unzugreifbar ist91 — sie wird nämlich gar nicht gebraucht, um auf das gekapselte Objekt zuzugreifen. Man bedient sich einfach des Aliases.
In SMALLTALK wird das Problem in folgendem Beispiel klar: Hier soll ein neues Objekt der Klasse A erzeugt werden und die Erzeugungszeit in einer entsprechenden Instanzvariable des Objekts festgehalten werden. Die Variable "jetzt" hält aber einen Alias auf das Objekt, das diese Zeit repräsentiert; ändert man dieses Zeitobjekt (wie in Zeile 1534), dann betrifft dies auch die Erzeugungszeit des Objekts "a".92 Nun könnte man meinen, es genügte, man ersparte sich einfach den (offensichtlichen) Alias "jetzt" und schriebe stattdessen:
Woher weiß man aber, dass die Methode "now" in der Klasse "Time" nicht einen Alias auf jedes neu erzeugte Objekt anlegt (beispielsweise weil "Time" Buch darüber führt, welche Instanzen es von ihr gibt) und diesen Alias nicht herausgibt oder selbst verwendet, um die Objekte zu manipulieren? Auch die alternative scheinbare Lösung, "Erzeugungsdatum" funktioniert aus gleichem Grunde nicht zuverlässig, denn auch "copy" kann sich (heimlich) Aliase anlegen.
Ein anderes Beispiel, bei dem Aliase fehlerhaft eingesetzt werden, ist das folgende. Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Das ist hier aber gar nicht der Punkt. Umgehung der
Sie haben zwei Klassen, "Ampel" und "Leuchte", und bauen Ihre Objekte. Wenn Sie nun einem Fußgänger per "grünes Licht" geben wollen, gehen leider mit der einen gleich alle vier grünen Leuchten an. War das in Ihrem Sinn?
Man nennt Objekte, die die Implementierung eines Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen, "Repräsentationsobjekte". Die Leuchten des obigen Beispiels sind allesamt Repräsentationsobjekte; sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen. Insbesondere gibt es in obigem Beispiel keine Verwendung einer Leuchte losgelöst von einer Ampel. Dies muss aber nicht für alle Leuchten der Fall sein — es ist durchaus denkbar, dass Leuchtenobjekte in anderen oder sogar im selben Programm auch ein unabhängiges Leben (außerhalb von Ampeln) führen. Aber selbst das ist gar nicht notwendig — im gegebenen Beispiel wäre es auch denkbar, dass mit Leuchten noch einiges gemacht wird, bevor sie in eine Ampel eingebaut werden, so dass man das Aliasing-Problem weder pauschal an die Klasse "Leuchte" noch an deren Verwendung als Lieferant für Repräsentationsobjekte knüpfen kann.
Wenn Aliase also schlecht sind, könnte man sie ja auch einfach verbieten. Tatsächlich bieten einige Programmiersprachen wie C#, C++ und EIFFEL die Möglichkeit, Klassen als Werttypen zu definieren, sodass bei Zuweisungen nicht automatisch Aliase entstehen. Aber durch eine derart einfache Lösung schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein, wie das folgende Beispiel zeigt:
Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.
Nachdem das Problem nun hinreichend klar geworden sein sollte, was kann man dagegen tun? Zunächst einmal muss noch einmal klargestellt werden, dass die Deklaration von Instanzvariablen als von außen unzugreifbar (private) lediglich Namen verbirgt — man kann über die Schnittstelle des Objekts nicht herausfinden, wie es intern aufgebaut ist. Dieser Namensschutz (engl. name protection) ist das, was man landläufig (mit dem Wissen vom Aliasing-Problem) mit Geheimnisprinzip (engl. information hiding) verbindet: Es verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, so dass diese problemlos geändert (z. B. umbenannt oder entfernt) werden können.
Das Geheimnisprinzip vermag jedoch nicht zu verhindern, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen. Dies kann z. B. immer dann der Fall sein (und ist vom Objekt, das sein Implementationsgeheimnis wahren will, kaum zu verhindern), wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt (genau so, wie das in den obigen Beispielen in den Zeilen 1533, 1535 und 1540 der Fall war). Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter, aber das wäre dann vom „verbergenden“ Objekt selbst zu verantworten (und zu verhindern gewesen).
Sobald also die Möglichkeit des Aliasing besteht, ist eine echte Kapselung über das Geheimnisprinzip allein nicht mehr zu gewährleisten. Man muss also das Aliasing irgendwie kontrollieren. Die Frage ist nur: Wie?
Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5 genannten Programmiersprachen ist das jedoch nur in C#, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per "struct" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.
Vor diesem Hintergrund scheint der in Abschnitt 52.5.2 dargelegte Umgang EIFFELs mit Referenz- und Wertvariablen ziemlich schlau ausgedacht zu sein. Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei. Dumm ist nur, wenn man innerhalb der Kapsel Aliase auf Wertobjekte braucht. Weitergehende Mechanismen zur Aliaskontrolle in objektorientierten Programmiersprachen befinden sich derzeit alle noch in der Vorschlags- und Erprobungsphase und sollen hier deswegen nicht weiter behandelt werden.

Frage: Was war die anfängliche Erwartung in Bezug auf Kapselung in der objektorientierten Programmierung, und warum?
Antwort: Anfangs glaubte man, dass die objektorientierte Programmierung durch das Konzept der Klassen eine natürliche Form der Kapselung gefunden hatte. Dies wurde auch mit der Theorie der abstrakten Datentypen in Einklang gebracht. Klassen sollten natürliche Repräsentanten von Allgemeinbegriffen sein, und Daten sowie Implementierungsdetails sollten hinter der Klassenschnittstelle verborgen werden.

Frage: Welche Enttäuschung trat auf, die die Kapselung von Klassen beeinflusste?
Antwort: Die Enttäuschung trat auf, als man feststellte, dass die Vererbung in der objektorientierten Programmierung die Kapselung von Klassen auf unangenehme Weise beeinträchtigte. Vererbung führte zu starken Abhängigkeiten zwischen Klassen und ihren Subklassen, einschließlich der Implementierungsdetails. Diese Abhängigkeiten konnten dokumentiert, aber nicht beseitigt werden, und sie führten dazu, dass Teile der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufgegeben werden mussten.

Frage: Was ist das Aliasing-Problem, und warum stellt es eine Herausforderung für die Kapselung dar?
Antwort: Das Aliasing-Problem tritt auf, wenn ein Objekt, das von einem anderen Objekt gekapselt wird, auch einen Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dies bedeutet, dass von außen auf das gekapselte Objekt zugegriffen werden kann, indem man den Alias verwendet. Dies stellt eine Herausforderung für die Kapselung dar, da es die Geheimhaltung der Implementierung durchbrechen kann.

Frage: Warum können private Instanzvariablen allein das Aliasing-Problem nicht lösen?
Antwort: Private Instanzvariablen können allein das Aliasing-Problem nicht lösen, da sie lediglich Namen verbergen und nicht verhindern können, dass Repräsentationsobjekte (Implementierungsdetails) Aliasen ausgesetzt sind.

Frage: Warum kann das Verbot von Aliasing in einigen Programmiersprachen nicht immer eine geeignete Lösung sein?
Antwort: Das Verbot von Aliasing in einigen Programmiersprachen kann nicht immer eine geeignete Lösung sein, da es zahlreiche Anwendungsfälle gibt, in denen die Verwendung von Aliasing notwendig oder sinnvoll ist. Zum Beispiel können bestimmte Datenstrukturen oder Container von Natur aus Aliase erfordern, um effizient zu arbeiten.

Frage: Welche Möglichkeiten zur Kontrolle von Aliasing werden in objektorientierten Programmiersprachen diskutiert?
Antwort: Es gibt verschiedene Ansätze zur Kontrolle von Aliasing in objektorientierten Programmiersprachen. Ein Ansatz besteht darin, die Teil-Ganzes-Beziehung zwischen Repräsentationsobjekten und dem Objekt zu definieren, sodass die Teile dem Ganzen gehören und nicht gleichzeitig Teile anderer Objekte sein können. Ein anderer Ansatz ist die Verwendung von Wertobjekten, die keine Referenzen auf andere Objekte zulassen. Ein dritter Ansatz besteht darin, Mechanismen zur Aliaskontrolle in die Programmiersprache zu integrieren, wobei viele dieser Mechanismen noch in der Entwicklung sind.