16 Parallelität: aktive und passive Objekte

Die objektorientierte Weltsicht, die auch in diesem Kurs propagiert wird (nämlich die von den Objekten, die einander Nachrichten schicken und die auf den Empfang von Nachrichten reagieren, indem sie ihren Zustand ändern und weitere Nachrichten verschicken), legt nahe, dass Objekte aktiv sind, will sagen, dass sie über einen eigenen Rechenprozess verfügen. Doch schon in Abschnitt 4.3.2 wurde klar, dass es damit in der Realität nicht weit her ist: Es werden in der Praxis keine Nachrichten verschickt, sondern lediglich Methoden aufgerufen. Abgesehen vom dynamischen Binden dieser Methoden unterscheidet sich damit das Ausführungsmodell der objektorientierten Programmierung nicht von dem der prozeduralen Programmierung (à la PASCAL); insbesondere sind alle Objekte passiv (was soviel bedeutet, wie dass sie nur aktiv sind, solange sie gerade eine Methode ausführen).
Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.
Gleichwohl ist auch in der objektorientierten Programmierung Parallelverarbeitung möglich. Nur kommt sie (zumindest in SMALLTALK, aber auch z. B. in JAVA) nicht in Form von aktiven Objekten daher, sondern in Form von parallelen Prozessen. Jeder dieser Prozesse führt zu einer Zeit eine Methode aus; er besucht zwar mit dem Methodenaufruf die Empfängerobjekte, diese bleiben jedoch selbst passiv (haben also kein Eigenleben).
Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neuen Prozess zu starten: Man schickt einfach einem Block die Nachricht "fork". "fork" entspricht im Wesentlichen "value", nur dass der Block dadurch in einem eigenen, unabhängigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von "fork" auch nicht darauf, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zurückliefert; tatsächlich liefert sie auch nicht (wie "value") das Ergebnis des Blocks zurück, sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann geht dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert.
Soll ein (paralleler) Prozess nicht sofort starten, so braucht man ein Objekt, das diesen Prozess repräsentiert und dem man dann zu einem späteren Zeitpunkt die Nachricht "resume" schicken kann, die den Prozess startet. Ein solches Objekt erhält man, indem man dem Block "newProcess" schickt. Tatsächlich ist "fork" wie folgt implementiert:
Um einen parametrisierten Block (also einen Block mit Parametern) als Prozess zu starten, verwendet man statt "newProcess" "newProcessWith:" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält.
Mit den Nachrichten "suspend" und "terminate" kann man den Prozess dann temporär anhalten bzw. beenden. Angehaltene Prozesse können später mit "resume" wieder gestartet werden, beendete nicht.
Die Synchronisation von parallelen Prozessen erfolgt in SMALLTALK zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen dazu über zwei Methoden, "wait" und "signal", und eine Instanzvariable, die für jedes Empfangen von "signal" um 1 erhöht und für jedes Empfangen von "wait" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt (mittels "suspend"). Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht "signal" und es gibt noch Prozesse, die schlafen (erkennbar an einem Zähler kleiner als 1), dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden (mittels "resume") und weitermachen.
Die Synchronisation mittels Semaphoren ist recht elementar und von aktiven Objekten noch weit entfernt. Deutlich näher rückt man mit der Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gezählt werden) Objekte aufnehmen und die eine Synchronisation über "next" und "nextPut:" erlauben. Das Protokoll sieht wie folgt aus:
Wenn man nun eine solche SharedQueue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann hat man tatsächlich „aktive Objekte, die einander Nachrichten schicken“.

Frage: Was ist der grundlegende Unterschied zwischen aktiven und passiven Objekten in der objektorientierten Programmierung?
Antwort: Aktive Objekte sind Objekte, die über einen eigenen Rechenprozess verfügen und Nachrichten asynchron empfangen und verarbeiten können. Passive Objekte hingegen sind Objekte, die nur aktiv sind, solange sie gerade eine Methode ausführen. In der Praxis werden jedoch passive Objekte verwendet, da aktive Objekte sehr aufwendig wären.

Frage: Wie wird Parallelverarbeitung in SMALLTALK implementiert, und warum werden keine aktiven Objekte verwendet?
Antwort: In SMALLTALK wird Parallelverarbeitung nicht in Form von aktiven Objekten, sondern in Form von parallelen Prozessen implementiert. Jeder dieser Prozesse führt zu einem Zeitpunkt eine Methode aus, wobei die Empfängerobjekte selbst passiv bleiben. Dies liegt daran, dass aktive Objekte, die asynchron Nachrichten verarbeiten, in der Praxis sehr aufwendig wären.

Frage: Wie startet man in SMALLTALK einen neuen Prozess?
Antwort: In SMALLTALK kann man einen neuen Prozess starten, indem man einem Block die Nachricht "fork" sendet. Dies führt dazu, dass der Block in einem eigenen, unabhängigen Prozess ausgeführt wird.

Frage: Welche Methode wird verwendet, um einen parametrisierten Block als Prozess zu starten?
Antwort: Um einen parametrisierten Block als Prozess zu starten, verwendet man die Methode "newProcessWith:" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält.

Frage: Wie erfolgt die Synchronisation von parallelen Prozessen in SMALLTALK?
Antwort: Die Synchronisation von parallelen Prozessen in SMALLTALK erfolgt zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen über Methoden wie "wait" und "signal", um die Ausführung von Prozessen zu steuern. Semaphore-Objekte zählen die Anzahl der Signale und können Prozesse in den Schlaf versetzen oder aufwecken, abhängig von ihrem aktuellen Zustand. Die Synchronisation kann auch über die Klasse SharedQueue erfolgen, die Objekte aufnimmt und Synchronisation über "next" und "nextPut:" ermöglicht.