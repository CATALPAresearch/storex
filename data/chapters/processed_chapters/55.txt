55 Das Fragile Base-Class-Problem

Das Fragile Base-Class-Problem bezieht sich auf eine ganze Familie von Problemen, die eng mit der Vererbung zusammenhängen. Der Name ist insofern etwas irreführend, als nicht unbedingt die Basisklassen, also die Superklassen (siehe Abschnitt 11.1), als "anfällig" oder "zerbrechlich" gelten, sondern eher die Klassen, die von ihnen erben. Ein einfaches Beispiel soll verdeutlichen, um was es geht.
Angenommen, wir haben eine Klasse namens TapeArchive geschrieben, die Videobänder archiviert. Da es sich nicht um eine einfache Desktop-Anwendung handelt, sondern um ein kommerzielles System, erfolgt die Datenhaltung in einer Datenbank. Die folgende SMALLTALK-Klassendefinition gibt einen kleinen Einblick in das System:
In der objektorientierten Programmierung ist es üblich, solche Klassen wiederzuverwenden, indem man von ihnen neue Klassen ableitet. Wenn beispielsweise eine Anforderung von Kunden besteht, bei jeder Archivierung eine Nachricht zu senden, und diese Anforderung nicht für alle Kunden der Software gleichermaßen interessant ist, dann schreibt man eine Subklasse, die dieses geänderte Verhalten bereitstellt.
Das Schöne an der Objektorientierung ist dabei, dass man nur die Unterschiede (Differentia) spezifizieren muss, der Rest wird einfach geerbt. Im gegebenen Fall genügt es, die Initialisierung und die Methode addTape: anzupassen. Das Verhalten von addAllTapes: kann unverändert bleiben, da es die (dynamisch gebundene) Methode addTape: aufruft und somit auch das von NotifyingTapeArchive geforderte Verhalten, nämlich die Benachrichtigung aller archivierten Bänder, garantiert.
Das Problem ist jedoch, dass man der Klasse TapeArchive nicht ansieht, was sie garantiert oder wovon die Korrektheit ihrer Subklassen abhängt. Wenn später eine andere Kundin bemängelt, dass das Hinzufügen großer Mengen von Bändern zu lange dauert, und das wiederholte Aufrufen von addTape: aus addAllTapes: als Ursache identifiziert, könnte sie vorschlagen, nicht nur die nörgelnde Kundin, sondern alle Kundinnen mit der optimierten Implementierung von TapeArchive zu beglücken. Das klingt verlockend, aber hier liegt bereits das Problem.
Vermutlich können die meisten von Ihnen nicht sofort sagen, was dagegen spricht, denn in der Klasse TapeArchive scheint alles in Ordnung zu sein. Der Fehler liegt darin, dass die Korrektheit der Methode addAllTapes: davon abhängt, dass sie addTape: aufruft - nicht unbedingt für die Klasse TapeArchive selbst, aber für ihre Subklasse NotifyingTapeArchive. Hier werden nun nur noch für einzeln archivierte Bänder Benachrichtigungen verschickt. Hätten Sie diesen Fehler vorhergesehen? Wahrscheinlich nicht, da die Täuschung darin besteht, dass addAllTapes: in TapeArchive die Methode addTape: der benachbarten Methode aufruft. Wenn Sie den Aufruf von addTape: in addAllTapes: entfernen und nur den Beitrag von addTape: in addAllTapes: verlagern, wäre dies eine semantikerhaltende Umstrukturierung (ein sogenanntes Refactoring). Allerdings beraubt dies die Subklassen der Möglichkeit, eigenes Verhalten genau an dieser Stelle, dem Aufruf von addTape:, einzubringen. Wenn diese Beraubung im Nachhinein erfolgt, kann sie den Code "zerbrechen".
Das Problem ist, dass nicht einmal klar ist, wem die Schuld zuzuweisen ist - TapeArchive, weil es einen Vertrag bricht, den es nicht abgeschlossen hat (oder weil es keine Rücksicht auf Subklassen nimmt, die es nicht kennt), oder NotifyingTapeArchive, weil es sich grundlos darauf verlässt, dass die geerbten Methoden dauerhaft die eigenen Methoden aufrufen? Wenn die Schuld nicht einmal feststeht, wie kann man das Problem verhindern?
Es gibt zahlreiche Varianten des Fragile Base-Class-Problems, die hier nicht alle aufgeführt werden sollen. Ihnen allen ist gemeinsam, dass zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, die nur unvollständig dokumentiert sind. Es könnte angenommen werden, dass von allem, was vererbt wird, eine Abhängigkeit ausgeht, die bei Änderungen berücksichtigt werden muss. Dies würde jedoch die Möglichkeiten, in Superklassen Änderungen vorzunehmen, so stark einschränken, dass das gesamte Konzept ad absurdum geführt würde. Es bleibt daher wenig mehr, als bei der Verwendung von Vererbung äußerst vorsichtig zu sein oder sie gänzlich zu verbieten.
Die Vererbung von Implementierung - die Fähigkeit, eine Komponente von einer anderen Komponente abzuleiten oder Teile ihrer Funktionalität zu erben - ist eine sehr nützliche Technologie zum Erstellen von Anwendungen. Die Vererbung von Implementierung kann jedoch viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen.
Das Problem bei der Vererbung von Implementierung besteht darin, dass der "Vertrag" oder die Beziehung zwischen Komponenten in einer Implementierungshierarchie nicht klar definiert ist. Sie ist implizit und mehrdeutig. Wenn die Eltern- oder Kindkomponente unerwartet ihr Verhalten ändert, kann dies zu undefiniertem Verhalten verwandter Komponenten führen. Dies ist kein Problem, wenn die Implementierungshierarchie von einer definierten Gruppe von Programmierern kontrolliert wird, die Updates an allen Komponenten gleichzeitig vornehmen können. Genau diese Fähigkeit zur Kontrolle und Änderung einer Gruppe von verwandten Komponenten unterscheidet jedoch eine Anwendung, selbst eine komplexe Anwendung, von einem echten verteilten Objektsystem. Daher kann die Implementierungsvererbung zwar sehr nützlich sein, um Anwendungen zu erstellen, ist jedoch nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert.
In einem System, das aus Komponenten verschiedener Anbieter besteht, ist es entscheidend, dass ein bestimmter Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet. Um dies zu erreichen, muss die tatsächliche Schnittstelle auf der von solchen Clients verwendeten Komponente für beide Parteien kristallklar sein. Andernfalls, wie kann der Komponentenanbieter sicherstellen, dass er diese Schnittstelle beibehält und somit die bestehenden Clients nicht stört?
Übertragen auf die objektorientierte Programmierung besteht das Problem darin, dass der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen. Die Vererbung von Implementierung wurde aus der Spezifikation von Microsofts Component Object Model (COM) verbannt und durch die Vererbung von Schnittstellen (was als Subtyping bezeichnet wird) ersetzt. Trotzdem bleiben Vorbehalte gegenüber dem dynamischen Binden bestehen.
Es liegt nahe, in Bezug auf die Vererbung das zu tun, was man bei Abhängigkeiten immer tut: Schnittstellen einführen. Im Gegensatz zu der Schnittstelle, die einem Client einer Klasse angeboten wird (der diese Schnittstelle nutzt, indem er seine Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann), handelt es sich bei der Schnittstelle zwischen einer Klasse und ihren Subklassen jedoch um eine etwas anders geartete. Hier gibt es lediglich zwei Variablen, self (oder this) und super, die jedoch keine Abhängigkeit von anderen Objekten ausdrücken und nicht explizit typisiert sind. Die damit verbundene Schnittstelle, also die Menge der Eigenschaften, auf die man über diese Variable zugreifen kann, und wo man diese Eigenschaften findet (also wo sie definiert sind), muss man selbst zusammensuchen. Dies hat nichts mit Information Hiding und dem Verbergen von Implementationsdetails zu tun. Was stattdessen benötigt wird, ist ein explizites Vererbungsinterface.
Einige erste Ansätze zur Einführung expliziter Vererbungsinterfaces wurden bereits gesehen, wie die Verwendung des Zugriffsmodifikators protected in Java, C# und C++ sowie die explizite Deklaration von Überschreibbarkeit und Überschreibung mittels virtual und override in C# (und C++). Im obigen Beispiel würde die Deklaration von addTape: als nicht überschreibbar (und somit als statisch gebunden, nicht dynamisch gebunden) verhindern, dass NotifyingTapeArchive diese Methode ändert und sich darauf verlässt, dass die geerbte Methode addAllTapes: die überschreibende Version von addTape: aufruft (obwohl sie sie immer noch neu einführen könnte, würde diese neue Version bei der Bindung in addAllTapes: nicht berücksichtigt). NotifyingTapeArchive müsste dann beide Methoden neu implementieren und sicherstellen, dass addAllTapes: keinen Fehler macht. Dies hätte jedoch zur Folge, dass bei einem direkten Aufruf von addTape: von außerhalb auf einer Variable vom Typ TapeArchive, die eine Instanz vom Typ NotifyingTapeArchive hält, die überschreibende Implementierung ignoriert wird (da keine dynamische Bindung mehr stattfindet). Im Gegensatz dazu würde die Verwendung von virtual bei addTape: in TapeArchive darauf hinweisen, dass die Methode in Subklassen relevante Modifikationen enthalten kann, so dass Aufrufe dieser Methode nicht einfach gekürzt werden können, wie im obigen Beispiel geschehen.
Bei der Definition von Java wurde dies jedoch nicht berücksichtigt. Der Zugriffsmodifikator protected, virtual und override sind mehr als Symbole für das Bewusstsein, dass es das Fragile Base-Class-Problem gibt.

Frage: Was ist das Fragile Base-Class-Problem, und warum ist der Name etwas irreführend?
Antwort: Das Fragile Base-Class-Problem bezieht sich auf eine Gruppe von Problemen in der Vererbung von Klassen. Der Name ist etwas irreführend, da nicht unbedingt die Basisklassen, sondern eher die abgeleiteten Klassen als "anfällig" oder "zerbrechlich" gelten.

Frage: Können Sie ein einfaches Beispiel für das Fragile Base-Class-Problem geben?
Antwort: Ja, nehmen wir an, es gibt eine Klasse namens "TapeArchive," die Videobänder archiviert. Später wird eine Subklasse namens "NotifyingTapeArchive" erstellt, die Nachrichten sendet, wenn Bänder archiviert werden. Das Problem besteht darin, dass Änderungen in der Basisklasse "TapeArchive" sich unerwartet auf die Subklasse "NotifyingTapeArchive" auswirken können.

Frage: Warum ist es schwierig, das Fragile Base-Class-Problem zu erkennen?
Antwort: Es ist schwer zu erkennen, da die Basisklasse "TapeArchive" auf den ersten Blick korrekt erscheint. Das Problem besteht darin, dass die Subklasse "NotifyingTapeArchive" von bestimmtem Verhalten der Basisklasse abhängt, ohne dass dies in der Basisklasse explizit dokumentiert ist.

Frage: Wie kann man das Fragile Base-Class-Problem verhindern?
Antwort: Eine Möglichkeit zur Vermeidung des Problems besteht darin, explizite Schnittstellen oder Vererbungsinterfaces einzuführen, die genau definieren, welche Eigenschaften und Methoden von Subklassen erwartet werden. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie "virtual" und "override," um die Überschreibbarkeit und das Verhalten von Methoden in der Vererbungshierarchie zu steuern.

Frage: Welche Herausforderungen ergeben sich aus dem Fragile Base-Class-Problem in verteilten Objektsystemen?
Antwort: In verteilten Objektsystemen wird das Problem komplexer, da Änderungen an einer Komponente unerwartete Auswirkungen auf verwandte Komponenten haben können. Die Schnittstellen und Beziehungen zwischen Komponenten müssen klar und stabil sein, um unerwartetes Verhalten zu verhindern. Das Problem wird noch schwerwiegender, wenn verschiedene Anbieter Komponenten entwickeln, da Änderungen an einer Komponente die Funktionalität anderer Komponenten beeinträchtigen könnten.

Frage: Welche Ansätze wurden in der objektorientierten Programmierung zur Bewältigung des Fragile Base-Class-Problems vorgeschlagen?
Antwort: Ein Ansatz besteht darin, explizite Vererbungsinterfaces einzuführen, um die Beziehungen zwischen Klassen in einer Vererbungshierarchie klarer zu definieren. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie "protected," "virtual" und "override," um die Überschreibbarkeit von Methoden zu steuern und das Verhalten in Subklassen zu dokumentieren. Jedoch gibt es keine universelle Lösung für das Problem.