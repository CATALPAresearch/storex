12.3 Double dispatch
Ihnen ist vielleicht aufg efallen, dass im oben beschriebenen Verfahren zum Auffinden der
auszuführenden Methode nur das Empfängerobjekt, jedoch nicht die Parameterobjekte be-
rücksichtigt wurden. Das erscheint zunächst natürlich. Manchmal hängt jedoch die Auswahl
einer geeigneten Me thode auch davon ab.
Typische Fälle, in denen auch die tatsächlich en Parameter eine Rolle bei
der Methodenauswahl spielen, sind arithmetische Operatoren wie +, –, *
und /. Diese sind nämlich sowohl für Ganzzahlen als auch für Brüche und
Gleitkommazahlen definiert, wobei die Implementierung einer Operation Bedeutung von
super ist
unabhängig von der
Klasse des
Empf ängers
wenn Parameter -
objekte über
Methodenauswahl
entscheiden sollen
davon abhängt, welcher Art die Operanden sind. Nehmen wir beispielsweise an, es gäbe
zwei primitive Methoden für die Ad dition, und zwar eine effiziente für die Integer -Addition
(IAdd ) und eine weniger effiziente für die Float -Addition (FAdd ), und man möchte Additi-
onen für beliebige Kombinationen von Summanden möglichst effizient durchführen kön-
nen. Dann kommt man vielleich t auf die folgende Tabelle von Zuordnungen:
Während die Unterscheidung nach Empfängerobjekten vom dynami-
schen Binden und damit dem Laufzeitsystem vorgenommen wird, bleibt
die Frage, wie man die Unterscheidung nach den Parameterobjekten vor-
nimmt: Zumindest die Implementation der Addition in der Klass e
Integer muss ja danach unterscheiden, ob der Parameter auch ein Inte-
ger oder vielleicht ein Float ist. Anstatt nun diese Fallunterscheidung (mittels entsprechender
Methoden isInteger bzw. isFloat ) explizit zu machen, kann man sich eines einfachen
Tricks bedienen: Man ruft im Rumpf einer Methode dieselbe Methode einfach noch einmal
auf und vertauscht dabei Empfänger ( self ) und Parameter. Damit es dabei nicht zu unend-
lichen Rekursionen kommt, kodiert man die Klasse des Empfängers im Nachrichtenselektor
der neu aufgerufenen Methode42, also z. B. plusFloat: anstelle von nur plus: . Das Er-
gebnis sieht dann wie folgt aus:
Klasse  Integer
Instanzmethoden
468 plus: aNumber
469  ^ aNumber plusInteger: self
470 plusInteger: anInteger
471  <primitive: IAdd>
Klasse  Float
Instanzmethoden
472 plus: aNumber
473  ^ <primitive: FAdd>
474 plusInteger: anInteger
475  ^ self plus : anInteger
42 In Sprach en wie JAVA, in denen das Double dispatch auch gebräuchlich ist, ist das nicht notwendig,
da es in ihnen zur Differenzierung von gleichnamigen Methoden da s sog. Überladen gibt. Umsetzung durch
erneuten
Methodenaufruf mit
vertauschten
Empfänger - und
Parameterobjekten  Parameter
+ Integer Float Empfänger
Integer IAdd FAdd
Float FAdd FAdd
Diese Technik, nämlich eine Methode gleicher Bedeutung unter Vertauschung von Sender
und Empfänger aufzurufen, nennt man Double dispatch , und zwar, weil die dynamische
Bindung (auch Method oder Message dispatching genannt) zweimal, und zwar unmittelbar
hintereinander, erfolgt. Etwas ähnliches haben Sie bei der Implementierung von + in
Integer in Abschnitt 4.3.7 (Kurseinheit 1, Zeile 154) schon gesehen. Die Technik des Dou-
ble dispatch wurde übrigens von DAN INGALLS am Beispiel von SMALLTALK erstmals beschrie-
ben; sie findet auch in anderen Sprachen mit Single dispatch (wie JAVA und C#) verbreitet
Anwendung. Double dispatch wird in Sprachen, bei denen bei der (dynamischen) Metho-
denauswahl von Haus aus die Parametertypen mit berücksichtigt werden (die sog. Multi -
dispatch -Sprachen ), naturgemäß nicht benötigt.
