52.5.2 Statische Komponente
Wie auch in JAVA definiert in EIFFEL jede unparametrisierte Klasse einen Typ und jede para-
metrisierte Klasse eine (generische) Menge von Typen. Alle Variablen (inkl. Methoden81 und
deren Parameter) müssen einen Typ haben. Zuweisungskompatibilität ist an nominale Typ-
konformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung
genannt) einhergeht — ganz wie in JAVA. Anders als in JAVA ist es jedoch zulässig, Instanzva-
riablen und Funktionsparameter wie im obigen Beispiel kovariant zu rede finieren — von
kontravarianter Redefinition will MEYER nichts wissen (eine Begründung sollten Sie mittler-
weile selbst zur Verfügung haben). Das bedeutet allerdings mangelnde Substituierbarkeit
und bereitet EIFFEL erwartungsgemäß einige nichttriviale Probleme.
Zunächst einmal wollen wir uns das Typs ystem EIFFELs noch etwas ge-
nauer ansehen. Es basiert, wie in der objek torientierten Programmierung
üblich, auf dem Begriff der Typkonformität ( Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ
U typkonform zu einem Typ T
 wenn U und T gleich sind,
 wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich,
im Falle von parametrischer Erzeugung von U und T, jeder tatsächlich e Typparameter
von U konform ist zum entsprechenden tatsächlich en Typparameter von T oder
 wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist
(U ist eine indirekte Erweiterung von T).
Außerdem gibt es in EIFFEL noch einen Typkon struktor like <ein Ausdruck> (s. u.),
dessen erzeugter Typ typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der
kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der
Basistyp konform, keiner seiner Subtyp en.
Dazu zunächst ein paar Beispiele. Bei
1429 class B inherit A …
1430 a : A
1431 b : B
ist
1432 a := b
OK,
1433 b := a
81 Mit dem Typ einer Methode ist hier der Rückgabetyp gemeint. Bedingungen der
Typkonformität
hingegen nicht. Im Falle der Vererbung bei parametrischem Polymorphismus wie in
1434 class GSub[B] inherit class GSuper[B]
1435 x : GSub[integer]
1436 y : GSuper[integer]
ist wieder
1437 y := x
zuweisungskompatibel, die umgekehrte Zuweisung jedoch nicht. Beschränkter parametri-
scher Polymorphismus wird in EIFFEL übrigens wie folgt notiert:
1438 class SortedList[G -> Comparable]
EIFFEL benutzt also eckige Klammern und -> anstelle von spitzen Klammern und extends
in JAVA.
In EIFFEL wird übrigens anders als in C# nicht pro Typkonstruktor zwischen
Wert - und Referenztyp unterschieden — zu jedem kann es (ähnlich wie
in C++) beid e Formen geben. Dazu gibt es in EIFFEL die Möglichkeit, bei
einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik, also ein Objekt an-
stelle einer Referenz auf ein Objekt zum Inhalt haben sollen (s. Kurseinheit 1, Abschnitt 1.5).
Dies ist manchmal für alle Variablen eines Typs sinnvoll (z. B. bei Zahlen und Wahrheitswer-
ten), manchmal aber auch nur für manche. Und so gibt es in EIFFEL einen Typkonstruktor
expanded , der, in Variablendeklaration wie in
1439 x : expanded C
eingesetzt, einer einzelnen Variable eine Wertsemantik gibt, und der in Klassendefinitionen
wie in
1440 expanded class C …
verwendet allen Variablen des entsprechenden Typs (der entsprechenden Typen im Falle
einer generischen Typdefinition) automatisch Wertsemantik gibt. EIFFELs Typkonstruktor
expanded entspricht also gewissermaßen einer Umkehrung des in PASCAL -artigen Sprachen
verwendeten Typkonstruktors ^ (Zeiger auf): Wenn expanded nicht verwendet wird, han-
delt es sich um einen Zeigertypen.
Die Unterscheidung von Wert - und Referenzty pen einer Klasse hat in EIF-
FEL einen starken konzeptuellen Hintergrund: Sie unterstützt die bereits in
Abschnitt 2.3 diskutierte Komposition und ihre Abgrenzung a ls eine be-
sondere Beziehung zwischen Objekten, nämlich der, die das Enthalten-
sein von Objekten in anderen ausdrückt (vgl. dazu auch Kapitel 59 in
Kurseinheit 6). Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer Typkonstruktoren für
Referenz - und
Wertsemantik
Hintergrund des
gleichzeitigen
Angebots von Wert -
und
Referenzsemantik
entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nir-
gends ent halten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise
Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variab-
len) zu haben. Dieses Feature ist nicht in C# (zumindest nicht im Safe mode) zu haben, de nn
dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen,
und schon gar nicht in SMALLTALK oder JAVA — in C++ (und im Unsafe mode von C#) kann
man es simulieren, zahlt dafür aber den Preis, mit expliziten Pointern hantie ren zu müssen,
was nach landläufiger Auffassung ein ziemlich hoher ist.
Nun stand bereits in Kurseinheit 1, Abschnitt 1.6 zu lesen, dass bei der
Zuweisung zwischen zwei Variablen mit Wertsemantik der W ert der einen
Variable in die andere Variable kopiert wird, während bei der Zuweisung
zwischen zwei Variablen mit Referenzsemantik lediglich der Zeiger ko-
piert wird. Dies ist auch in EIFFEL so. Bei der Zuweisung einer Variable mit Referenzsemantik
an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn
die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte — stattdes-
sen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: es werden die Attri-
bute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable ko-
piert). Im umgekehrten Fall, also wenn eine Variable mit Wertsemantik an eine Variable mit
Referenzsemantik zugewiesen wird, könnte man annehmen, dass ein Zei ger auf den Wert
erzeugt und zugewiesen wird; dies würde aber bedeuten, dass dadurch ein Alias auf einen
Wert entstünde, was nicht der Semantik der Komposition ( Aggregation ; s. Abschnitt 2.3 in
Kurseinheit 1) entspräche. Was stattdessen passiert, ist, dass ein Klon des Objekts erzeugt
wird und eine Referenz auf diesen Klon übergeben wird. Dies ist eine äußerst sinnvolle Fest-
legung.
Verankerte Typdeklarationen haben in EIFFEL die Form
1441 x : like y
wobei y ein bereits typisiertes Programmelement (also z. B. eine Instanzvariable) ist. Eine
solche Verankerung bewirkt, dass sich der Typ von x automatisch mit dem von y verändert.
Dies hat zunächst noch nichts mit Kovarianz zu tun, wie das folgende Beispiel zeig t.
Anstatt in EIFFEL
1442 class A
1443 feature
1444  f : X
1445  setF(v : X)
1446  getF() : X
1447 end
1448 …
1449 end
1450 class B
1451 inherit A
1452 redefine f Zuweisungen
zwischen Variablen
unterschiedlicher
Semantik
verankerte Typen
1453 feature
1454  f : Y
1455  setF(v : Y)
1456  getF() : Y
1457 end
1458 …
1459 end
zu schreiben, d. h., bei Veränderung des Typs der Instanzvariable f von X zu Y alle Parame-
tertypen, die davon berührt sind, mit zu verändern, reicht es aus,
1460 class A
1461 feature
1462  f : X
1463  setF(v : like f)
1464  getF() : like f
1465 end
1466 …
1467 end
1468 class B
1469 inherit A
1470 redefine f
1471 feature
1472  f : Y
1473 end
1474 …
1475 end
zu schreiben. Da die Typen der Parameter von setF und getF alle per Deklaration dieselben
sind wie der Typ von f, muss in der Definition von B textuell nichts anderes stehen. Da nun
aber in EIFFEL die Redefinition von Instanzvariablen per Definition immer kovariant sein muss ,
muss Y ein Subtyp von X sein. Der Rückgabetyp von getF und der Parametertyp von setF
ändern sich damit automatisch ebenfalls kovariant.
Ein besonderer Fall von verankerten Typen ergibt sich bei rekursiv en Ty-
pen, also Typen, deren Definition den definierten Typ selbst referenziert:
In diesem Fall schreibt man in EIFFEL anstelle der Typreferenz bei der Deklaration einer Vari-
able vom zu definierenden Typ like Current . Bei einem entsprechend deklarierten Fel d
ändert sich der Typ bei der Vererbung also immer automatisch zum erbenden Typ hin ab,
also immer mit dem Typ und damit kovariant. Für das Beispiel der zu trennenden Skifahre-
rinnen (Zeilen 1391 –1425 ) ergibt sich damit
1476 class SKIER feature
1477 roommate: like Current;
1478 share (other: like Current) is
1479  …
1480  do
1481  roommate := other
1482  end
1483 …
1484 end -- class SKIER Verankerung bei
rekursiven Typen
Die beiden erbenden Klassen GIRL und BOY müssen dann nichts mehr redefinieren.
Wir können nun zur Lösung des Pro blems der Kovarianz in EIFFEL kom-
men. Die obige Konstruktion
1485 s1 : SKIER; b1 : BOY; g1 : GIRL
1486 s1 := b1;
1487 s1.share(g1)
(hier unverändert wiederholt) wird dann vom Type checker zur Übersetzungszeit zurückge-
wiesen, da g1 nicht vom Typ like s1 ist, was aber laut Typkonformitätsregeln von EIFFEL
notwendig wäre . Leider ist das nur ein Teilerfolg.
Es ist nämlich andersherum like s1 mit dem Typ von s1 konform . Und so wird es möglich,
dass bei zusätzlicher Deklaration von
1488 g2 : like s1
(wobei der Typ von s1 ja SKIER ist)
1489 s1 := g1; g2 := s1
und anschließend
1490 s1 := b1
doch wieder
1491 s1.share(g2)
zulässig ist und damit ein Mädchen einem Jungen ins Zimmer gesteckt wird.
Die erste und einfachste Möglichkeit, dies zu verhindern, w äre, die Zu-
weisungskompatibilität für Variablen mit verankerten Typen und Typan-
kern einzuschränken und unter ihnen nur noch Typäquivalenz zu akzeptieren. Es wären
dann nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit
solchen, die ihn als Anker benutzen, erlaubt; insbesondere wäre eine Zuweisung wie s1 :=
g1 (die ja notwendig war, um ein Objekt vom Typ GIRL so zu „verpacken“, dass es an g2
mit seinem verankerten Typ like s1 zugewiesen werden kann) damit nicht mehr möglich.
Alle anderen Zuweisungen wären natürlich weiter zugelassen; dies hätte jedoch zur Konse-
quenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein
Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem w äre
es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker
zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Ob-
jekte unterschiedlichen Typs haben dürfen, genutzt werden soll. Lösung des Problems
der Kovarianz
Lösungs -
möglichkeiten
Die zweite Möglichkeit wäre, eine Typinferenz für das gesamte Programm durchzuführen,
um die möglichen Zuweisungen an Variablen zu sammeln. Dazu sind insbesondere alle Me-
thodenaufrufe anzus ehen (Zuweisungen an Instanzvariablen sind in EIFFEL nur innerhalb ei-
ner Klasse erlaubt) und diese können je nach Konfiguration des endgültigen Systems sehr
unterschiedlich ausfallen. Eine solche Typinferenz ist aber in den meisten Fällen unrealistisch.
Die dritte Möglichkeit ist die, alle dynamisch gebundenen Aufrufe von Methoden, deren
Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“)
ändern (die von MEYER so genannten CAT -Calls, wobei CAT für „ Change Availability or
Type“ steht), zu verbieten. Ein Aufruf von share auf s1 wie oben ist damit verboten, weil
share in BOY und GIRL kovariant redefiniert wird. Auf einer Variable vom Typ GIRL oder
BOY wäre er hingegen zulässig, solange sichergestellt ist, dass diese Variable k einen Wert
von einem Subtyp von GIRL bzw. BOY zugewiesen bekommen kann. Das ist möglich, wenn
kein solcher Subtyp existiert oder wenn keine Zuweisung an die Variable existiert, bei der
die rechte Seite ein Subtyp der Variable ist. Das erste ist lokal nicht nachzuweisen, das zweite
hingegen schon, jedoch nur für explizite Zuweisungen (inkl. der Instanziierung, die in EIFFEL
auf einer Variable durchgeführt wird und ihr au tomatisch einen Wert gibt). Für die Zuwei-
sung an formale Parameter kann dies jedoch nicht lokal nachgewiesen werden, weil im
Gegensatz zu expliziten Zuweisungen an Variablen die Methodenaufrufe von überall her
erfolgen können.
Wie Sie sehen, sind die Bedin gungen ziemlich restriktiv, und man kommt nicht umhin, das
Typsystem von EIFFEL als etwas eigenartig zu empfinden. Wie es sich in der Praxis auswirkt,
ist mir leider nicht bekannt; MEYER behauptet, dass die Probleme praktisch keine Rolle spie-
len. Ich möcht e hinzufügen, dass falls doch, die durchschnittliche Programmiererin kaum
verstehen wird, was denn nun genau das Problem ist und was sie tun kann, es zu umgehen.
