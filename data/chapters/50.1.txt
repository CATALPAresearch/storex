50.1 Das Programmiermodell von C#
Das Programmiermodell von C# unterscheidet sich zunächst nicht wesentlich von dem JA-
VAs: Auch in C# ist der Code auf Klassen verteilt, die einzeln übersetzt werden können.
Klassen werden in Dateien gespeichert, jedoch ist das Verhältnis von Klasse zu Datei lockerer
als in JAVA (u. a. können Klassen anders heißen als ihre Dateien und sogar auf mehrere
Dateien aufgeteilt werden). Allerdings sind der Bytecode und die dazu passende virtuelle
Maschine nicht speziell für C# entworfen, sondern für alle sog. .NET -Sprachen. So heißt
denn auch die Sprache des Bytecode Common Intermediate Language (CIL); sie gilt als (ge-
rade noch) menschenlesbar.
Anders als bei JAVA waren bei C# Flexibilität und Performanz von Anbe-
ginn kritische Gesichtspunkte des Sprachentwurfs. Für C# war daher von
Anfang an und ausschließlich die sog. Just-in-time-(JIT-)Kompilierung vorgesehen, die den
CIL-Code unmittelbar vor der Ausführung (und nur, wenn er überhaupt ausgeführt wird) in
Maschinencode der Maschine, auf der er gerade läuft, übersetzt. Die Einheiten der JIT -Kom-
pilierung gehen dabei hinunter bis zu einzelnen Methoden. Eine vollständige Kompilierung
von CIL - in nat iven Maschinencode vor der Ausführung ist ebenfalls möglich.
Eine andere Eigenschaft JAVAs, mit der die Programmiererinnen MICRO-
SOFTs offenbar nicht unter allen Umständen leben konnten, ist die
Garbage collection . In C# hat man daher die Möglichkeit, den Speicherplatz für Objekte,
die m it new erzeugt wurden, selbst wieder freizugeben. Doch wehe der, die das vergisst :
Speicherlecks sind die unmittelbare Folge. Noch schlimmer sind aber Speicherfreigaben von
Objekten, auf die noch Referenzen existieren: Die zeigen dann ins Leere oder, wenn der
Speicher wieder belegt wird, auf oder mitten hinein in ein anderes Objekt. Eine Katastrophe.
Aber damit nicht genug: Das mit SMALLTALK und JAVA abgeschaffte Han-
tieren mit Po intern wurde in C# auch wiedereingeführt, wohl weil man in der systemnahen
Programmierung (und bei Aufrufen in das hauseigene Betriebssystem) nicht darauf verzich-
ten konnte. Allerdings sind beide Rückschritte — explizite Speicherverwaltung und das Han-
tieren mit Pointern — in sog. unsichere Bereiche verbannt. Dazu gibt es in C# einen Modi-
fizierer unsafe , der solche Bereiche einleitet:
1253 public static unsafe void Swap(int* x, int* y) {
1254 int temp = *x;
1255 *x = *y;
1256 *y = temp;
1257 }
keine Interpretation
von CIL -Code
programmgesteuerte
Speicherverwaltung
explizite Pointer
Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger -auf-Typ handelt ;
vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den
Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei
bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch über-
laden wurde.
Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.
