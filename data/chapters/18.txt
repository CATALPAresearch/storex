18 Hintergrund
Sie kennen vielleicht aus anderen Programm iersprachen, dass Variablen und anderen Pro-
grammelementen bei ihrer Deklaration ( Kapitel 19) ein Typ zugeordnet wird. Dieser Typ
schränkt die möglichen Werte der deklarierten Elemente ein. So lassen sich beispielsweise
in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zei-
chenketten speichern.
Typ ist ein primitiver Begriff, vergleichbar etwa mit dem Begriff der
Menge in der Mengentheorie. Ein Typ hat eine Intension und eine Extension , wobei erstere
der Definition des Typs entspricht, letztere seinem Wertebereich, also der Menge der Ele-
mente (Objekte), die zu dem Typ g ehören (man sagt auch, „die den Typ haben“ oder „die
von dem Typ sind“). Häufig hat ein Typ auch einen Namen, den Typbezeichner. Typen sind
die Grundlage von Typsystemen.
Ihnen fällt wahrscheinlich sofort die Ähnlichkeit zum Konstrukt der
Klasse, wie es in der letzten Kurseinheit eingeführt wurde, auf. Tatsäch-
lich gibt es hier auch einen Zusammenhang. Um Sie aber nicht gleich in für diese Kurseinheit
eher schädliche Denkmuster verfallen zu lassen, soll dieser Zusammenhang zun ächst zu-
rückgestellt werden. Eine Aufklärung erfolgt dann in Kapitel 28.
Ein Typsystem umfasst Typausdrücke, Objekt - oder Wertausdrücke, Re-
geln, die Wertausdrücken Typen zuordnen, und Regeln, die von Wertausdrücken einzuhal-
ten sind (zusammen die Typregeln ). Wertausdrücke (bzw. schlicht Ausdrücke, wenn es
nicht um die Abgrenzung von Typausdrücken geht) kennen Sie schon: In SMALLTALK sind es
die in Kurseinheit 1, Kapitel 4.1 aufgeführten. Mit den anderen Konzepten werden Sie in
den nachfolgenden Kapitel n vertraut gem acht, allerdings in weniger formaler Form, als Sie
das nach dieser Definition vielleicht befürchten.
Warum aber typisiert man Variablen und andere Programmelemente?
Dafür gibt es mindestens vier gute Gründe:
1. Typisierung regelt das Speicher -Layout.
2. Typisierung erlaubt die effizientere Ausführung eines Programms. Typ
3. Typisierung erhöht die Lesbarkeit eines Programms.
4. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Pro-
gramm.
Zu 1.: Der Comp iler kann anhand des Typs einer Variable bestimmen, wie
viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss . Dies ist jedoch natur-
gemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Pro-
grammierung, insbeso ndere für Sprachen wie SMALLTALK (in denen Referenzsemantik vor-
herrscht), von untergeordneter Bedeutung.
Zu 2.: Wenn man weiß, dass die Werte einer Variable immer vom selben
Typ sind, also alle demselben Wertebereich entstammen, dan n lassen sich
bestimmte Optimierungen durchführen. Wenn man z. B. aufgrund der Deklaration einer
Variable x für gegeben annehmen kann, dass x nur ganze Zahlen enthält, dann kann der
Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkre-
ment -Anweisung des Prozessors verwenden. Kennt der Compiler den Typ von x hingegen
nicht, dann muss das Programm vor der Ausführung der Addition erst prüfen, von welchem
Typ der Wert von x ist — handelt es sich um e ine Fließkommazahl, so muss es zu der ent-
sprechenden Operation verzweigen, handelt es sich womöglich um gar keine Zahl, dann
muss es einen Laufzeitfehler signalisieren oder sich etwas anderes einfallen lassen. Dem
kann man entgegenhalten, dass im Falle der objektorientierten Programmierung selbst bei
einer Typisierung aller Variablen gelegentlich noch Laufzeittests durchgeführt (oder andern-
falls schwere Programmfehler in Kauf genommen) werden müssen, und dass sich die zur
Optimierung benötigte Information a uch anders als über explizite Typisierung von Variablen
(nämlich z. B. über die sog. Typinferenz , also die Ausnutzung impliziter Typinformation) ge-
winnen lässt.
Zu 3.: In der Vergangenheit hatten Variablen eher kurze, wenig selbster-
klärende Namen (vgl. dazu auch Kapitel 62 in Kurseinheit 7). Es ist dann sinnvoll, wenigstens
an der Stelle der ersten Erwähnung der Variablen (in der Regel deren Deklaration ) einen
Hinweis darauf zu haben, wofür (für welche Menge von Objekten) die Variable steht. Dies
kann über einen Kommentar erfolgen, aber auch durch die Assoziation mit einem Typen,
die aussagt, welcher Art die Werte der Variable sein müssen. Doch nicht nur Vari ablen -,
auch Methodennamen können für sich genommen wenig aussagekräftig sein und durch
die Verknüpfung mit Typen aussagekräftiger gemacht werden: Eine Deklaration der Me-
thode next etwa, die ListElement als Typ des Ein - und Ausgabeparameters deklariert,
legt nahe, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurücklie-
fert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre
Implementation nicht kennt, schon über ihren Zweck spekulieren. Dem mag man freilich
entgegenhalten, dass man stattdessen ja auch selbsterklärende Namen für Variablen und
Methoden vergeben könnte (mehr dazu in Kurseinheit 7, Kapitel 62). Speicher -Layout
Es bleibt aber in jedem Fall Punkt 4, das Aufdecken von logischen Fehlern
in einem Programm. Ohne externes Wissen, was ein Programm tun soll,
verlangt das Finden von Fehlern jedoch ein gewisses Maß an Redundanz ,
also die mehrfache Lieferung gleicher Information, im Programm, denn
nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen
logischen Programmierfehler hinweisen. Die Verknüpfung von deklarierten Elementen mit
Typen erlaubt aber genau die Angabe solcher redundanter Information. Die Schaffung die-
ser Redundanz verlangt jedoch vermehrte Denk - und Schreibarbeit und ist zudem auch
noch, im Falle eines fehlerfr eien Programms, überflüssig. Dem kann man allerdings entgeg-
nen, dass kaum eine Programmiererin auf Anhieb korrekte Programme schreibt, und wenn
eine Typisierung Fehler zu fin den in der Lage ist und somit nicht minder aufwendige Tests
ersetzt, dann ist das natürlich gut .
Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der
heute üblichen Typsysteme ist übrigens die dadurch entstehende Modu-
larisierung von Programmen , nämlich wenn ein Typ zugleich eine Schnittstelle oder ein In-
terface ausdrückt. Mehr dazu jedoch erst später (in Abschnitt 28.2).
Die der Fehlerentdeckung mittels Typsystemen zugrundeliegende These
ist, dass ein guter Teil logischer Programmierfehler bereits frühzeitig daran erkannt werden
kann, dass eine Variable einen Wert hat, den sie eigentlich niemals haben dürfte. So zeugt
beispielsweise von einem Fehler, wenn einer Variable, die für Zahlen gedacht war, eine Zei-
chenkette zugewiesen wird. Wenn dann nämlich einem Ausdruck mit einer arithmetischen
Operation, die Zahlen als Operanden verlangt, eine solchermaßen fehlbelegte Variable zu-
geführt wird, kann dieser nicht ausgewertet werden. Ohne Typprüfung würde dieser Fehler
erst zur Laufzeit, also wenn der Ausdruck tatsächlich ausgewertet werden soll, in Erschei-
nung treten und hätte dann in aller Regel einen Programmabbruch zur Folge. Man nennt
einen solchen Programmierfehler einen Typfehler .
Währe nd ein Programmabbruch wenigstens noch eine erkennbare Reak-
tion auf einen Programmierfehler darstellt, ist es fast noch schlimmer,
wenn ein logischer Fehler ohne solche bleibt. So kann es beispielsweise vorkommen, dass
man einer Variable, deren Inhalt eine Strecke darstellen soll, eine andere zuweist, deren
Inhalt eine Zeit repräsentiert. Mit beiden ließe sich gleich rechnen (dieselben Rechenopera-
tionen durchführen), aber das Ergebnis wäre vermutlich falsch. Merken muss man das aller-
dings selbst, denn das P rogramm läuft einfach weiter.
Man kann Variablenfehlbelegungen dieser Art verhindern, indem man
Variablen mit expliziten Typinvarianten versie ht, die die Menge ihrer zu-
lässigen Werte beschränken, und dann darüber wacht, dass diese Invarianten immer einge-
halten werden. Eine besonders einfache Möglichkeit, solche Invarianten zu spezifizieren,
erlauben sog. Typannotationen , also die Verbindung einer Variable mit einem Typ, wobei
der Typ eine Menge von Werten festlegt, die die Variable ausschließlich haben darf. In typi-automatisches
sierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Vari-
ablendeklaration ; in nicht oder nur optional typisierten Sprachen kann sie auch (für einzelne
oder alle Variablen) hergeleitet (i nferiert ; die Typinferenz ) werden und ist dann implizit.
Ein Programm, in dem alle Variablenbelegungen immer alle Typinvarian-
ten erfüllen, heißt typkorrekt . In einer Sprache, die durch ihr Typsystem
Typkorrektheit festzustellen erlaubt, nennt man die logischen Fehler, die sich in unzulässigen
Wertzuweisungen ausdrücken, auch semantische Fehler (und zwar, weil der Inhalt eines
Programmelements nicht seiner intendierten Bedeutung entspricht). Dabei ist die Semantik
des Programmelements im Programm zweimal, auf redundante , aber unterschiedliche Art,
spezifiziert: in Form seines Typs und in Form seiner tatsächlichen Verwendung (festgelegt
durch Zuweisung en und Methodenaufrufe). Lässt sich aus beiden ein Widerspruch ableiten,
muss eine von beiden falsch gewesen sein.
Der einzige Weg, eine mit der Typisierung einer Variable ausgedrückte
Invariante zu verletz en, also Typ inkorrektheit herzustellen, ist per Wert-
zuweisung an die Variable. Ein Typsystem muss also lediglich alle Wert-
zuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu ga-
rantieren. Dazu zählen allerdings auch die implizi ten Zuweisungen bei Methodenaufrufen
(s. Abschnitt 4.3.2 ), die, auch wegen des dynamischen Bindens, nicht immer alle offensicht-
lich sind. Im folgenden heißen Zuwe isungen und Methodenaufrufe, die nicht zu typinkor-
rekten Programmen führen können, zulässig .
Nun kann man sich vorstellen, dass es für einen Compiler selbst in einfa-
chen Fällen nicht leicht ist, festzustellen, ob eine Wertzuweisung eine In-
variante verletzt und somit zu einem typinkorrekten Programm führt. So ist das folgende
STRONGTALK -Programmfra gment
das zunächst eine temporäre Variable i mit dem Typ Integer (in STRONGTALK wird die
Typannotation hinter der Variable in spitzen Klammern angeführt) deklariert und ihr dann,
in einer Folge von Anweisungen, zunächst 0 und dann 1 (beides Werte vom Typ Integer )
zuweist, zwar typkorrekt im Sinne obiger Definition, aber um das zu erschließen, muss man
schon wissen, dass die Bedingung in Zeile 835 immer erfüllt ist, der False -Zweig, der zu einer
Verletzung der Invariante von i (nämlich dass die Werte immer vom Typ Integer sein
müssen und somit nicht vom Typ String sein dürfen) führen würde, also nie ausgeführt
wird. Im gegebenen Fall ist das zwar offensichtlich (und bereits von einer recht einfachen Typkorrektheit ;
Programmanalyse feststellbar), aber es lassen sich auch Fälle konstruieren, in denen eine
automatische Programmanalyse streiken muss .47
Was man jedoch immer tun kann, um Typkorrektheit zu gewährleisten,
ist, dass man zur Laufzeit vor einer Variablenzuweisung prüft, ob der zu-
zuweisende Wert den von der Variable geforderten Typ hat. Diese sog. dynamische
Typprüfung (engl. dynamic type checking ) hat jedoch den entscheidenden Nachteil, dass
sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes
machen kann als einen Fehler zu signalisieren (der dann günstigenfalls durch eine dafür
vorgesehene Fehlerbehandlungsmethode aufgefangen wird, der aber in der Praxis häufig
nur zu einem Programmabbruch führt). Man kann jedoch argumentieren, dass auch letzte-
res immer noch besser ist, als mit falschen Werten weiterzuarbeiten und damit entweder
einen Progr ammabbruch an einer anderen Stelle, die nicht mehr so leicht mit der fehlerhaf-
ten Wertzuweisung in Zusammenhang zu bringen ist48, in Kauf zu nehmen oder gar einen
logischen Fehler, der überhaupt nicht erkannt wird.
Man beachte übrige ns, dass nach diesem Kriterium SMALLTALK — entge-
gen häufig zu lesenden Behauptungen — keine dynamische Typprüfung
durchführt, da Typfehler erst im letztmöglichen Moment offenbar werden, nämlich wenn
auf einer Variable eine Methode aufgerufen werden soll, d ie für das Objekt, auf das die
Variable verweist, gar nicht definiert ist.49 Um das zu verhindern, findet man in SMALLTALK -
Code gelegentlich Figuren wie
(SMALLTALK EXPRESS entnommen). Dies entspricht natürlich genau einer dynamischen Typprü-
fung, nur dass hier Typ durch Klasse er setzt wurde und die Prüfung eben nicht automatisch
durch ein Laufzeittypsystem erfolgt, sondern ausprogrammiert werden muss .
Regel auf pathologischen Programmkonstruktionen, die man in der Praxis kaum vorfinden wird, b a-
sieren.
einem Variablenwert null tatsächlich etwas gemacht werden soll, was unter Umständen erst a m
Ende einer langen Zuweisungskette der Fall ist.
mically typed ) bezeichnet. Das aber ist Unsinn, denn eine Typisierung findet in SMALLTALK gar nicht,
auch nicht zur Laufzeit, statt. Außerdem ist mit dynamischer Typisierung in der Regel dynamische
Typprüfung gemeint. Was ein dynamischer Typ sein soll, ist auch gar nicht klar. dynamische
Sehr viel nützlicher als die dynamische Typprüfung ist die statische
Typprüfung, bei der, trotz aller theoreti schen Hindernisse, die Typkorrektheit zur Überset-
zungszeit gewährleistet werden soll. Die Typprüfung ist damit Aufgabe des Compilers und
nicht, wie im Fall der dynamischen Typprüfung, Aufgabe des Laufzeitsystems oder gar der
Programmiererin . Wie wir schon gesehen haben, bedeutet dies nicht weniger, als einen
Beweis zu führen, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt
wird. In der Praxis bedeute t dies aber, dass eine rein statische Typprüfung immer auch Pro-
gramme zurückweist, die nützlich, sinnvoll und typkorrekt sind (s. obiges Beispiel der Zeilen
Zwar kann man versuchen, möglichst wenige typkorrekte Programme durch die sta tische
Typprüfung zurückzuweisen, aber wie man sich leicht vorstellen kann, wird mit steigender
Genauigkeit das dazu notwendige Typsystem immer aufwendiger und schwieriger zu be-
nutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken
soll (so dass man bei auftretenden Typfehlern erst einmal prüfen muss , ob die Ursache tat-
sächlich in einem fehlerhaften Programm oder vielleicht nur in fehlerhaften Typannotatio-
nen liegt).
So ist die Suche nach einem guten Typsystem immer die Suche nach ei-
nem guten Kompromiss . Die meisten heut e in der Praxis verwendeten
Typsysteme basieren auf einem solchen: einer statischen Komponente,
die möglichst viele Fehler findet, ohne dabei die Programmiererin allzu sehr einzuschränken,
und einer dynamischen Komponente, die den Rest erledigt. Eine erwähnenswerte Aus-
nahme davon macht C++: hier wird, zugunsten von Performanz (Speicherplatz und Ge-
schwindigkeit), auf eine dynamische Komponente der Typprüfung vollständig v erzichtet. Da
die statische Typprüfung von C++ aber nicht alles abdeckt, sind C++ -Programme auch nicht
automatisch typkorrekt. Mehr dazu in Abschnitt 51.5.
