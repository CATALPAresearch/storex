51.5 Das Typsystem von C++
Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit star-
ker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst
wenig Laufzeit -Overhead zu erzielen. Dazu gibt es eigentlich nur einen Kommentar:
51.5.1 Statische Komponente
Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierte Er-
weiterung der Sprache C st ark auf Rückwärtskompatibilität geachtet. Und so findet sich
auch das Typsystem Cs vollständig in C++ wieder. Es gibt also primitive Datentypen wie
int, bool etc. und auch die Typkonstruktoren struct (entsprechend dem record
PASCAL s) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau
wie die durch Klassen definierten, Typen mit Wertsemantik. Es lassen sich aber auch, genau
wie in C, Zeigertypen darauf definieren.
Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor disku-
tierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen ab-
geleitet werden. Die S yntax von C++ sieht (analog zur mehrfachen Interface -Implementie-
rung bei C#) dazu vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen
Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten, wie in
Mehrfachvererbung
Klassenhierarchie More computing sins are committed in the name of efficiency (without
necessarily achieving it) than for any ot her single reaso n —
including blind stupidity.
W.A. Wulf
Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse
abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte
Superklasse). C++ kennt dafür keine Interfaces wie JAVA oder C#; sie müssen durch rein
abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Su-
pertypen eines Typs diese lbe Eigenschaft anders spezifizieren — der Subtyp hat dann einen
Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.
Obwohl die Zuweisungskompatibilität in C++ wie in JAVA über die Typ-
konformität an die Typerweiterun g gebunden ist und somit einer Variable eines Typs auch
Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C#) Me-
thoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt
immer die Methode aufger ufen wird, die in der Klasse definiert ist, deren Typ die Variable
(und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also
ignoriert, es sei denn, die betreffende Methode wurde mit virtual79 deklariert.
Bei virtuellen Methoden wird hingegen wie in JAVA zur Laufzeit geprüft, welchen Typs das
Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem
Zweck hält das Laufzeitsystem eine sog. Virtual function table , in der die zum Objekt pas-
sende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer
(sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängel t
hatte) und soll daher nur wenn unbedingt notwendig durchgeführt werden. Folge ist, dass
virtual (vor allem von SMALLTALK - und JAVA-Programmiererinnen ) gelegentlich vergessen
wird und Programme dann nicht wie erwartet funktionieren, oder dass die nachträgliche
Erweiterung einer Klasse, auf die eine Programmiererin selbst k einen Einfluss hat, um Sub-
klassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht
aufgerufen werden können. In JAVA hat man deswegen bewusst davon Abstand genommen
(und über lässt die Performanzsteigerung einem optimierenden Compiler); in C# hat man
diese Entscheidung nicht nachvollzogen (s. Abschnitt 50.2).
In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name
schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen
erzeugt werden können. Im Gegensatz zu JAVA (und genau wie z. B. in ADA) werden aus
Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expan-
diert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer T emplate)
ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus
wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typpa-
rameter darin durch tatsächlich e Typen ersetzt, das ganze dann mit einem n euen Namen
versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro -Mechanismus
angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.
werden. dynamisches Binden
Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt
nämlich Typumwandlungen (Type casts ; s. Kapitel 27). Ausdrücke der Form
überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ
<Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leid er vollkommen
ignoriert, welchen Typs das Objekt tatsächlich ist, und ob dieser Typ zuweisungskompatibel
mit <Typ> ist. Anders als in JAVA oder C# wird die Zulässigkeit dieser Typumwandlung auch
nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einm al überprüft werden (s. Ab-
