52.2 Klassen als Module
Klassen sind in EIFFEL vor allem ein Mittel zur Datenkapselung („Information hiding “); alle
Instanzvariablen oder F elder, in EIFFEL Attribute (engl. attributes ) genannt, sind privat (wes-
wegen man für sie auch keine Zugriffsmodifikatoren angeben kann). Um dennoch von au-
ßen darauf zugreifen zu können, benötigt man in EIFFEL (wie in SMALLTALK ) zwingend Zu-
griffsmethoden, d ie allerdings (wie die Properties in C#) an der Aufrufstelle syntaktisch die
Form von Variablen annehmen:
ruft also eine Funktion (einen Setter ) mit dem Parameter y auf,
ruft eine auf, die einen (mit y zuweisungskompatiblen) Wert liefert (einen Getter ). Funktion
der Zugriffsmethoden ist es üblicherweise, eine entsprechende Instanzvariable zu setzen
bzw. zu lesen; sie können aber auch etwas ganz anderes tun (vgl. dazu auch das Beispiel in
Abschnitt 50.3.1 ). Insbesondere wird es dadurch möglich, den Z ugriff auf Instanzvariablen
mit Vor - und Nachbedingungen (s. Abschnitt 52.6) zu versehen. Auch bleibt der Program-
miererin so die Freiheit, etwas, das wie eine Instanzvariable aussieht, n ach außen anzubie-
ten, ohne sich (dauerhaft) darauf festzulegen, dass es sich dabei auch tatsächlich um eine
Instanzvariable handelt (die sog. Repräsentationsunabhängigkeit ). Aber das hatten wir ja
schon bei C# gesehen. Indexer gibt es in EIFFEL übrigens auch.
Die Methoden einer Klasse heißen in EIFFEL Routinen (routines ) und wer-
den logisch in zwei Gruppen unterteilt: Abfragen (queries ) und Befehle
(commands ). Abfragen geben über den Zustand von Objekten Auskunft, Befehle verändern
ihn. Es ist in EIFFEL schlechter Stil (aber wird durch die Sprachdefinition nicht verhindert),
dass eine Abfrage Seiteneffekte hat, also den Zustand des abgefragten Objekts (des Em p-
fängers) oder eines anderen verändert.
Attribute (Instanzvariablen) und Routinen (Methoden) heißen in EIFFEL zusammen Features
(entsprechend den Members in von C++ abgeleiteten Sprachen); sie sind in EIFFEL die einzi-
gen Elemente einer Klassendefinition . Insbesondere ist es in EIFFEL nicht möglich, Klassende-
finitionen zu schachteln (es gibt also keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++: Wenn
nichts weiter vermerkt wird, ist jedes Featu re öffentlich zugänglich. Da Attribute jedoch nur
über Zugriffsmethoden zugänglich sind, ist der Zustand (im Sinne der Belegung von In-
stanzvariablen; s. Kurseinheit 1, Kapitel 3) eines Objekts automatisch gekapselt: Man
braucht ja schließlich keine Zugriffsmethoden zu spezifizieren und wenn man es doch tut,
dann doch sich er nur, weil die entsprechenden Abfragen und Befehle Teil der Schnittstelle
und kein Geheimnis sind. Routinen, Abfragen
und Befehle
Zugreifbar keitsregeln
Nun wäre die Definition einer Schnittstelle (der Export von Features) in EIFFEL so aber reichlich
unspezifisch — alle Klienten einer Klasse hätten (übrigen s genau wie in SMALLTALK ) das glei-
che Bild von ihr. Das ist für größere Projekte kaum sinnvoll. Anstatt aber Zugreifbar keit an
Pakete zu binden (wie in JAVA und C#) oder an Freunde ( Friends , wie in C++), bietet EIFFEL
die Möglichkeit, einzelne Features dediziert zu veröffentlichen (zu exportieren), also unter
Nennung der Klassen, die sie sehen können solle n. (Dies schließt die Nennung der leeren
Menge ein, was dann bedeutet, dass keine andere Klasse diese Features sehen kann, also
private in anderen Sprachen entspricht). Diese Klassen müssen dann umgekehrt die Fea-
tures, die ihnen angeboten werden, nicht exp lizit importieren — das Wissen ob und der
explizite Ausdruck der Abhängigkeit ist also in EIFFEL genau invers zu dem der anderen Spra-
chen. Dabei entspricht der dedizierte Export EIFFELs in etwa dem qualifizierten Export JAVAs,
wir er dort allerdings nur für Module und nicht für Klassen definiert ist.
