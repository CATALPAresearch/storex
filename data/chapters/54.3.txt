54.3 Verhaltensbasiertes Subtyping
Die Regeln des Subtyping aus Kapitel 26 und die damit verbundene Regelung der Zuw ei-
sungskompatibilität bezogen sich ja lediglich auf die Elemente einer Typdeklaration und da-
mit auf rein statische Information. Um nun auch das Verhalten der Objekte eines Typs ein-
zufangen, greift man auf eine Idee der formalen Programmverifikation zurück: der der Über-
führung der Vorbedingungen in Nachbedingungen nach der Art von (54.1). Ins Objektori-
entierte übertragen heißt das, dass ein Typ dann korrekt (implementiert) ist, wenn für je de
Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedin-
gung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methoden-
ausführung verletzt werden). Wir schreiben dazu für eine Methode m und einen Typ T
𝑝𝑟𝑒𝑚𝑇(𝑠𝑒𝑙𝑓:𝑇)⇒𝑝𝑜𝑠𝑡𝑚𝑇(𝑠𝑒𝑙𝑓:𝑇) (54.2)
und meinen damit, dass für eine Implementierung von m in der zu T gehörenden Klasse, die
auf einem Empfängerobjekt vom Typ T (einer Instanz der entspreche nden Klasse) aufgeru-
fen wird, die Nachbedingung aus der Vorbedingung folgt. Diesen Beweis müssen wir aber
zum Glück nicht führen — wir sind hier nicht an der Korrektheit von Implementierungen an
sich interessiert, sondern vielmehr daran, ob sich eine (korr ekte) Implementierung durch
eine andere (ebenfalls korrekte, aber eben andere, auch in Bezug auf ihre Spezifikation)
auch vom Verwendungskontext abhängig ist — wenn beispielsweise mit einem Objekt gar nichts
gemacht wird, kann es auch durch ein anderes ersetzt werden, selbst w enn die entsprechenden
Typen nicht konform sind. Mehr dazu in Abschnitt 54.5. keine umfassende
ersetzen lässt. Konkret: Wir sind an einer verhaltensbasierten Subtypenrelation interessiert,
also an den Bedingungen, die potentielle S ubtypen einhalten müssen, damit sie die Spezifi-
kation des Supertyps erfüllen, so dass man sie als verhaltenskonform betrachten kann und
eine Subtypenbeziehung wie in Kapitel 26 beschrieben gegeben ist. Das ist immer dann der
Fall, wenn obige Implikation auch für Objekte des potentiellen Subtypen S gilt, also wenn
𝑝𝑟𝑒𝑚𝑇(𝑠𝑒𝑙𝑓:S)⇒𝑝𝑜𝑠𝑡𝑚𝑇(𝑠𝑒𝑙𝑓:S) (54.3)
Man spricht dann von einem Behavioural subtyping , das zu deutsch am besten als ver-
haltensbasiertes Subtyping87 wiedergegeben wird.
Es gilt also, (6.3) sicherzustellen. Bei der Spezifikation der Methoden des (potentiellen Sub -)
Typs S wird man aber zunächst nicht auf die Vor - und Nachbedingungen von T zurückgrei-
fen, sondern eigene angeben, so dass für alle Methoden m von S
𝑝𝑟𝑒𝑚S(𝑠𝑒𝑙𝑓:S)⇒𝑝𝑜𝑠𝑡𝑚S(𝑠𝑒𝑙𝑓:S) (54.4)
als Ausdruck der Korrektheit gilt. (54.3) folgt daraus unmittelbar, wenn
𝑝𝑟𝑒𝑚S≡𝑝𝑟𝑒𝑚T und 𝑝𝑜𝑠𝑡𝑚S≡𝑝𝑜𝑠𝑡𝑚T
für alle m in T ist, aber das wird ja wie gesagt im allgemeinen nicht der Fall sein. Die Frage
ist vielmehr: Wie müssen 𝑝𝑟𝑒𝑚S, 𝑝𝑟𝑒𝑚T, 𝑝𝑜𝑠𝑡𝑚S und 𝑝𝑜𝑠𝑡𝑚T miteinander im Verhältnis stehen,
damit Objekte vom Typ S die Anforderungen für Objekte vom Typ T erfüllen? Formal: Was
müssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), das Verhalten
von m in T angewandt auf Objekte aus S, folgt?
Leider ist es mit der Beantwortung dieser Frage aber noch nicht genug.
Aufgrund des in der objektorientierten Programmierung weit verbreiteten
Aliasing kann ein Objekt vom Typ S, das von einem Klienten wie ein Ob-
jekt vom Typ T betrachtet wir d, von einem weiteren Klienten wie ein Objekt vom Typ S
(oder wie von einem anderen Supertypen als T) betrachtet werden. Dadurch können dann
auch Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen des Objekts
verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (deren Vor -
und Nachbedingungen) abgedeckt sind, ja die ein Verhalten bewirken, das mit dem von T
nicht kompatibel und das für Benutzer innen des Objekts, die es als ein T ansehen, nicht
akzeptabel ist . Eine methodenweise Betrachtung von Bedingungen für die Substituierbar-
keit reicht also nicht aus. Man ahnt bereits, dass die Angelegenheit komplex wird.
