60 Das Problem der mangelnden Eignung
Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gern dem Hammer-
prinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle
Objekte genannt, zur hierarchischen Strukturierung eines Programms verwendet. mangelnde
hierarchische (De -)
Kom ponierbarkeit
von Klassen
Komponenten in
objektorientierte n
Programmier -
sprachen
To a woman with a hammer, everything looks like a nail.
Aufgaben sind aber gleichermaßen zur Lösung per objektorientierter Programmierung ge-
schaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische
Programmiersprachen weit besser geeignet; aber auch viele Batch - und Scripting -Probleme
(in denen lediglich vorhandene Programme mit den richtigen Daten versorg t und angesto-
ßen werden müssen) haben eher imperativ -prozeduralen den n objektorientierten Charak-
ter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Prob-
leme, die einen hohen algorithmischen Anteil und vergleichsweise simple Datenstrukturen
verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapi-
tel 56 erwähnt, verlangt die „gute“ objektorientierte Programmierung, den Code (die Funk-
tionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet.
Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen
müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor
allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszufüh-
ren sind, in einem Stück festgehalten wird ( Lokalitätsprinzip !) und nicht auf zig Klassen auf-
geteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an
der Str uktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist,
liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer
mit einem Abwägungsproblem zu tun. Wenn man sich für di e objektorientierte Program-
mierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man
sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachzu-
vollziehende Weise hin - und hergeschickt oder sind global, was auch kein Idealzustand ist.
Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein .
Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängeri nnen mit ihrer
großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie
man ein einzelnes Problem lösen kann , überfordern . C++ ist ein gutes Beispiel dafür. Funktion ü ber Daten
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in
Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entwor-
fenes Datenbankschema, genau wie ein gut entworfen es Klassenmodell, eine Strukturie-
rung der Anwendungsdomäne wider , doch tun es beide mit ganz untersc hiedlichen Mitteln:
Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver
Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme
zeigerbasiert. Beziehungen werden in relationalen Datenbanke n über die Verwendung glei-
cher Werte in Schlüsseln und Fremdschlüsseln sowie über Join -Operationen hergestellt, in
objektorientierten Programm über Referenzen und deren Dereferenzierung (Navigation ).
Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch, gibt
es in relationalen Datenbanken gar nicht .94 Sollen also relationale Daten durch objektorien-
tierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt
anpassen und damit ein Gutteil dessen, was Objektorientierung ausmacht, aufgeben, wes-
wegen man hier auch häufig von einem Impedance mismatch spricht (das entsprechende
deutsche Wort „Fehlanpassung“ ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine
objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der ge-
wöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz - und Syn-
chronisationszwecken (bei Mehr benutzer innensystemen ) in der Datenbank abgelegt. Die
Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei
heute meisten s durch ein sog. Persistenzlayer erreicht — das Programm selbst muss sich um
die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier
die Frage stel len, warum man einer relationalen Datenbank den Vorzug vor einer objektori-
entierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale
Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorien-
tierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind
die Daten häufig der eigentliche Wert eines Softwaresystems .
Zuletzt, und beinahe paradoxerweise, ist auch die GUI -Programmierung
nicht unbedingt ein Heimspiel für die objektorientierte Programmierung.
Zwar kann man für die verschiedenen Arten von GUI -Elementen noch ganz gut Klassen
angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten
Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss : Zwei
Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des ange-
zeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt wer-
den. Da sich die Instan zen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für
verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode an-
zugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über
einen Bloc k, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klas-
sen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den
tierte Anleihen. Ich bin mir jedoch nicht sicher, ob diese jemals in der Praxis angekommen sind. objekt -relationaler
Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger
(Dele gates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte
Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 be-
merkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug
feiert) .
