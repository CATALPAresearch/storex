45 Programmieren mit Interfaces
Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem
Interface veröffentlichten noch weitere öffentliche ( public deklarierte)
Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces ei-
ner Klasse un terschiedliche Methodenmengen zur Verfügung stellen können. Da auf einer Interfaces bieten
klientenspezifische
Sichten
Variable, die mit einem Interfacetyp deklarierte wurde, aber immer nur die Methoden auf-
gerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgrei-
chen P rüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass
auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten kön-
nen), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt
gewährt werden. So kann beispielsweise ein Ein - und Ausgabestrom als Klasse zwei Inter-
faces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält
und das andere nur die zum Schreiben:
1130 interface ReadStream<T> {
1131 T read();
1132 }
1133 interface WriteStream<T> {
1134 void write(T object);
1135 }
1136 class IOStream<T> implements ReadStream<T>, WriteStream<T> {…}
Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils
entweder nur lesend oder nur schreibend auf einen Ein -/Ausgabestrom
zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom
verweist, zum Typ hat:
1137 class WillNurLesen {
1138 ReadStream<String> eingabe = new IOStream<String>();
1139 void tueEtwas() {
1140  eingabe.read(); // OK
1141  eingabe.write("man kann’s ja mal versuchen!"); // Syntaxfehler
1142 }
1143 }
1144 class WillNurSchreiben {
1145 WriteStream<String> ausgabe = new IOStream<String>();
1146 void tueEtwas() {
1147  eingabe.write("so ist’s recht"); // OK
1148  eingabe.read(); // Syntaxfehler
1149 }
1150 }
Umgangen werden kann diese Zugriffsbeschränkung über Interfaces in
JAVA immer dann , wenn die Klasse, von dem das verwendete Objekt eine
Instanz ist, ebenfalls als Typ zur Verfügung steht — man kann in Variab-
lendeklarationen dann genauso gut die Klasse als Typ verwenden . So könnte man sowohl
in WillNurLesen die Variable eingabe als auch in WillNurSchreiben die Variable
ausgabe mit dem Typ IOStream deklarieren, hätte damit jedoch keine synta ktische Un-
terstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr.
C# geht hier einen Schritt weiter und ermöglicht Klassendefinitionen zumindest, ihre Me-Beschränkung des
Zugriffs
die Verwe ndung von
Interfaces in JAVA ist
freiwillig
thoden ausschließlich über Interfacetypen zugänglich zu machen (s. Kurseinheit 5, Ab-
schnitt 50.4.2 ). Seit JAVA 8 kann man allerdings in In terfaces auch statische Methoden de-
finieren, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern
und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff
mehr auf die Klassen, die deswegen als package local deklariert und die somit vollständig
hinter dem Interface als Schnittstelle verborgen werden können.
Interfaces dienen aber nicht nur der Beschränkung des Zugriffs wie im
obigen Beispiel — sie dienen auch der besseren Austauschbarkeit von
Klassen. Und das bringt uns zurück zum eingangs Kapitel 43 benutzten Beispiel (Zeile 1051
ff.): Dadurch, dass die Variable liste mit dem Typ List (ein Interface) und nicht
ArrayList (eine Klasse) deklariert wurde, können ihr auch Instanzen anderer Klassen als
ArrayList zugewiesen werden, solange sie nur dasselbe Interface implementieren. Das
Interface als Typ der Variable verlangt lediglich, dass alle in ihm versammelten Methoden
von d en Objekten, auf die die Variable per Typsystem verweisen darf, auch angeboten wer-
den, und das wird dadurch sichergestellt, dass der Typ der rechten Seite aller Zuweisungen
zur Variablen konform zum Typ der linken Seite sein muss . Die Zuweisungskompatibili tät ist
in JAVA also an die Typkonformität gebunden, und zwar an die nominale.
Eine weitere, vergleichsweise häufig verwendete Möglichkeit des Einsat-
zes von Interfaces ist die als sog. Tagging oder Marker interfaces . Ein
Tagging oder Marker interface hat in der Regel keine eigenen Methodendeklarationen, son-
dern dient lediglich der Filterung von Variablenwerten .
1151 interface Markiert {}
wäre ein solches Interface. Da in JAVA die vom Compiler statisch geprüfte Zuweisungskom-
patibilität ja Namenskonformität verlangt, kann die Typisierung einer Variable mit dem In-
terface Markiert erzwingen, dass dieser Variable nur Instanzen solcher Klassen zugewi e-
sen werden, die das Interface Markiert zu implementieren deklarieren. Da das Interface
aber keine Auflagen macht (keine Methodendeklarationen vorgibt, die von der Klasse mit
Definitionen versehen werden müssen), ist die Implementierung des Interfaces für die Klasse
zunächst ohne Konsequenzen. Die durch das Interface erfolgte Markierung der Klassen
(bzw. deren Instanzen) kann jedoch zur Übersetzungszeit vom Compiler (s. o.) und zur Lauf-
zeit durch einen Typtest (s. Abschnitt 44.2) überprüft werden.
Ein konkretes Beispiel für ein Marker interface in JAVA ist das Interface
Serializable, mit dessen Implementierung eine Klasse deklariert, dass
ihre Instanzen serialisiert werden können. Die Serialisierung wird aber nicht von der Klasse
selbst vorgenommen, sondern von einer anderen; die Klasse muss also zu ihrer Serialisierung
nichts weiter beitragen. Seit JAVA 5 würde man allerdings solche Marke r-Interfaces eher
durch Metadaten (auch Annotationen genannt; s. Abschnitt 47.4) ersetzen, so wie das in
C# schon länger gehandhabt wird (s. Abschnitt 50.4 in Kurseinheit 5). Interfaces erhöhen
Austauschbarkeit
Tagging oder Marker
interfaces
Beispiel
Serializable
JAVAs Interface -als-Typ-Konzept ist ziemlich interessant und vielleicht so-
gar der größte einzelne Beitrag JAVAs zur objektorientierten Programmierung. In der P ro-
grammierp raxis scheint es jedoch , sieht man einmal von großen Frameworks ab, nur lang-
sam anzukommen . Das mag zum einen an der schlechten Verkaufsstrategie liegen („Ersatz
für Mehrfachvererbung“ — jede Anfängerin merkt nach fünf Minuten, dass das nicht
stimm t), zum anderen aber auch an der Vergrößerung des Programmumfangs, die der pa-
rallele n Definition von Klassen und Interfaces geschuldet ist (die auch den Wartungsauf-
wand erhöhen kann, obwohl ja Interfaces eigentlich die Wartung vereinfachen sollen) . Für
so manche Programmiererin scheinen die Möglichkeiten, die Schnittst elle einer Klasse mit-
tels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, völlig auszureichen.
Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Kli-
enten sowie eine (häufig vorschnelle) Festlegung v on Variablen auf Instanzen einer Klasse.
Mehr zur sog. interfacebasierten Programmierung finden Sie im Kurs 01853 .
