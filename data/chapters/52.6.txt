52.6 Zusicherungen in EIFFEL: Vorbedingungen, Nachbedingungen
und Klasseninvarianten
Praktisch ein Alleinstellungsmerkmal EIFFELs ist die Integration von Zusicherungen in Form
von Vor - und Nachbedingungen bei Methodenaufrufen. Bei der Behandlung JAVAs war uns
ja schon die Assert -Anweisung begegnet, die es erlaubte, Zusicherungen zur Laufzeit aus-
zuwerten und das Programm ggf., bei einer Verletzung, abzubrechen. Da es sich aber um
eine Anweisung handelte, gab es keine von der Sprachdefinition vorgeseh enen Orte, an
denen solche Zusicherungen auftreten sollten — sie an passenden Stellen einzustreuen war
ganz der Programmiererin überlassen. In EIFFEL ist das anders.
EIFFELs Syntax zur Definition einer Methode sieht zwei Schlüsselwörter,
require und ensure , vor, von denen das erste vor der Definition der
Implementierung der Methode (dem Methodenrumpf), das zweite da-
nach auftreten k ann. Beiden Schlüsselwörtern folgen können Boolesche
Ausdrücke, die allesamt zu „wahr“ auswerten müssen. Die Idee hinter eine r Require -Klausel
ist, dass, damit die betreffende Methode richtig funktionieren kann, die darin ausgedrück-
ten Bedingungen erfüllt sein müssen. So ist es beispielsweise sinnvoll, für die Methode pop
der Klasse STACK zu verlangen, dass der betreffende Stack, auf dem die Methode aufge ru-
fen wird, nicht leer ist. Die Idee hinter einer Ensure -Klausel ist, dass eine Methode, deren
Require -Klausel erfüllt war, im Gegenzug garantieren muss , dass sie die in der Ensure -Klau-
sel ausgedrückten Bedingungen erfüllt. Im Beispiel des Stacks wäre das beispielsweise, dass
nach einem push das übergebene Element auch tatsächlich oben auf dem Stapel liegt, die
Methode top also beispielsweise das soeben auf den Stapel gelegte Element liefert. Um
ihre Bedingungen zu formulieren, dürfen die Ausdrücke in beide n Klauseln auf Abfragen
(queries) der Klasse zurückgreifen. Diese sollten dazu aber tunlichst nebeneffektfrei sein,
zum einen, weil die Ensure -Klausel sonst nicht garantieren kann, dass eine geprüfte Bedin-
gung auch nach ihrer vollständigen Abarbeitung imme r noch wahr ist (man bedenke nur,
was wäre, wenn die Ensure -Klausel zu push die Methode pop aufrufen würde!), zum an-
deren aber auch, weil auch in EIFFEL (wie in JAVA) die Überprüfung der Zusicherungen zur
Laufzeit abgestellt werden kann (weswegen dann das Programm mit Überprüfung der Zu-
sicherungen eine andere Semantik hätte als ohne; vgl. die Anmerkungen zu JAVAs Assert -
Anweisung in Kurseinheit 4, Kapitel 38).
Neben der Möglichkeit, Vor - und Nachbedingungen zu formulieren, gibt
es in EIFFEL noch die Möglichkeit, sog. Klasseninvarianten (Schlüsselwort
invariant ) zu deklarieren. Klasseninvarianten müssen jederzeit zwischen zwei Methoden-
aufrufen gelten; man kann sich vorstellen, dass sie jeder Vor - und Nachbedingung per Kon-
junktion hinzugefügt werden. Auf die etwas subtilen Probleme, die das Aliasing in Z usam-
menhang mit Zusicherungen schafft, wollen wir an dieser Stelle nicht eingehen; Kurs 01853
befasst sich ausführlicher damit.
Zusicherungen werden i n EIFFEL von Klassen auf ihre Subklassen vererbt.
Wenn dabei eine Methode redefiniert wird, dann dürfen auch Vor - und Vor- und
Nachbedingungen:
requires und
ensures
Klasseninvarianten:
invariant
Zusicherungen und
Vererbung
Nachbedingung angepasst werden. Allerdings gilt hier, dass die Vorbedingung nur aufge-
weicht, die Nachbedingung nur verschärft werden darf. Die Sprachdefinition EIFFELs stellt
die Einhaltung dieser Bedingung automatisch sicher, indem die Vorbedingung einer redefi-
nierten Methode mit der geerbten Vorbedingung implizit disjunktiv und die redefinierte
Nachbedingung mit der geerbten implizit konju nktiv verknüpft wird. Mehr zu diesem Thema
können Sie ebenfalls Kurs 01853 entnehmen.
Selbsttestaufgabe 52.1
Begründen Sie die eben geschilderten Verknüpfungen von geerbten und redefinierten Zusic herun-
gen. Können Sie einen Zusammenhang zu der Veränderung von Parametertypen beim Subtyping
herstellen? Fällt Ihnen etwas auf?
