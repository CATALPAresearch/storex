46.1 Externe Iterat ion
Bei :n-Beziehungen müssen ja häufig mehrere Elemente der gleichen Behandlung unterzo-
gen werden oder es werden aus der Menge der Elemente einige gesucht. Sind die Elemente
in einem Array gespeichert, so kann man in JAVA dazu etwas der Form
1152 for (int i = 0; i < a.length; i = i + 1) {… a[i] …}
schreiben. Verwendet man aber Collections, die nicht indiziert sind (es gibt auch in JAVA so
Collections wie Bäume oder verkettete Listen), ist die obige Form der Iteration nicht einsetz-
bar. Stattdessen gibt es i n JAVA die beiden Interfaces Enumeration (total veraltet) und
Iterator (etwas neuer), die eine einheitliche Iteration über Collections mittels sog. Itera-
toren erlauben. Jede Collection -Klasse, die Iterator implementiert, bietet dazu eine Me-
thode iterator() an, die ein solches Iteratorobjekt (vom Typ Iterator ) zurückliefert.
Mit der Methode next() erhält man von diesem Objekt zunächst das erste und in der Folge
74 Zur Erinnerung: In SMALLTALK sind Arrays spezielle Collections, mit eigenen Methoden. Ausblick
alle weiteren Objekte der Coll ection; mit der Methode hasNext() fragt man ab, ob die
Collection noch weitere Objekte enthält. Eine typische Iteration über eine Collection sah in
JAVA also wie folgt aus:
1153 for (Iterator i = aCollection.iterator(); i.hasNext();)
1154 {… i.next() …}
Alternativ (und in der Praxis nicht seltener, obwohl eine Anweisung mehr) findet man auch
1155 Iterator i = aCollection.iterator();
1156 while (i.hasNext()) {… i.next() …}
In manchen Programmen findet man allerdings auch heute noch die vor JAVA 2 einzig mög-
liche Variante
1157 Enumeration e = aCollection.elements();
1158 while (e.hasMoreElements()) {… e.nextElement() …}
bzw. das Äquivalent mit der For -Schleife.
Die Wahl der unnötig langen Bezeichner lässt vermuten, dass man die
Häufigkeit solcher Konstruktionen in der Programmierpraxis unterschätzt hatte. Dieser Feh-
ler wurde mit JAVA 5 korrigiert, so dass man seither stattdessen
1159 for (Element e : aCollection) {… e …}
schreiben kann (wobei Element hier für den Elementtyp v on aCollection steht). Voraus-
setzung ist allerdings, dass die Klasse von aCollection das Interface Iterable imple-
mentiert, das wiederum verspricht, dass die Instanzen die Methode Iterator
iterator() anbieten und damit einen Iterator zurückliefern, der dann von der For -Anwei-
sung zur Produktion der Elemente ausgenutzt werden kann ; es handelt sich bei dieser Ver-
sion der For -Schleife also lediglich um „syntaktischen Zucker“ . Man beachte, dass dabei
eine weitere Verquickung von Sprachdefinition und Klassenbiblio thek (API ; speziell der In-
terface Iterator ) stattgefunden hat, die nicht schön ist.
