21 Zuweisungskompatibilität
Die Typisierung von Variablen (und anderen Programmelementen — wenn im nachfolgen-
den nur von Variablen die Rede ist, dann sind letztere meistens mit gemeint) soll also be-
wirken, dass in einem Programm jede Variable nur die Werte haben kann, für die sie (di e
Variable) vorgesehen ist (die Einhaltung der Typinvariante ). Voraussetzung dafür ist zum
einen, dass jeder Variable ein Typ zugeordnet ist, zum anderen, dass auch jedes Objekt
sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Ersteres
geschieht in sogenannten Variablendeklarationen, letzteres ergibt sich aus den zu einem
Typsystem gehörenden Regeln zur Zuordnung eines Typs zu Ausdrücken , nämlich
 bei Literalen aus de r Art des Literals, dessen Typ dem Compiler bekannt ist,
 bei der Instanziierung aus dem noch zu klärenden Zusammenhang von der instan-
ziierten Klasse mit den Typen eines Programms sowie
 bei Nachrichtenausdrücken aus der Deklaration der dazugehörigen Methode , die ja
(genau wie eine Variablendeklaration) angeben muss , welchen Typs die Objekte
sind, die sie liefert.
Es bleibt die Frage nach den ebenfalls zu einem Typsystem gehörenden
Typregeln, die von Ausdrücken einzuhalten sind , nämlich wie die Typkor-
rektheit bzw. andernfalls die Verletzung einer Typinvariante genau fest-
gestellt wird. Es ist ja bereits klar, dass es dazu ausreicht, die Wertzuweisungen in einem
Programm zu überprüfen. Diese Überprüfung findet in der Regel in Form der Feststellung
der sog. Zuweisungskompatibilität statt. Die Sprachregelung ist hier leider nicht ganz ein-
heitlich, aber im folgenden gehen wir davon aus, dass alle typisierten Sprachen den Begriff
der Zuweisungskompatibilität kennen und sich lediglich in ihren Definitionen der Regeln,
die für das Bestehen einer Zuweisungskompatibilität eingehalten werden müssen, unter-
scheiden. Vor allem darum wird es in den nächsten Kapiteln gehen.
Angenommen, zwei temporäre Variablen anzahl und erfolgre ich seien wie folgt de-
klariert:
862 | anzahl <Integer> erfolgreich <Boolean> |
Dann sind, unter der Annahme, dass 12 vom Typ Integer ist und true vom Typ Boolean ,
die Zuweisungen
863 anzahl := 12
864 erfolgreich := true
zulässig (da sie keine Typinvariante verletzen),
865 anzahl := false
866 erfolgreich := 12 Feststellung der
Zuweisungs kompati-
bilität
hingegen nicht. Ist eine Zuweisung zulässig, dann spricht man auch von einer Zuweisungs-
kompatibilität der beteiligten Typen. Die für das Programmieren relevante Implikation ist
allerdings die umgekehrte: Wenn zwei Typen zuweisungskompatibel sind, dann gilt, dass
eine entsprechende Zuweisung zulässig ist, also zu keiner Verletzung einer Typinvariante
führt. Wie Sie noch sehen werden, verlangt Zuweisungskompatibilität keineswegs identi-
sche Typen; daraus ergibt sich aber eine sprachliche Uneindeutigkeit, d ie zunächst behoben
werden muss .
Dem Satz „ a ist zuweisungskompatibel mit b“ kann man nicht eindeutig
entnehmen, ob nun a b zugewiesen werden kann oder b a. Dass beides
geht, ist nur dann der Fall, wenn die beteiligten Typen ä quivalent in einem noch zu bestim-
menden Sinne sind, was aber, wie schon gesagt, nicht unbedingt der Fall sein muss . Im
folgenden soll daher die Richtung der erlaubten Zuweisung so gelesen werden, dass beim
Satz „a ist zuweisungskompatibel mit b“ die Zuweis ung b := a zulässig ist. Die umge-
kehrte Richtung, a := b , kann ebenfalls zulässig sein; dies wird durch den Satz jedoch
nicht ausgesagt. Zuweisungskompatibilität ist übrigens (in der Regel) eine transitive Eigen-
schaft: Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c, dann
ist auch a zuweisungskompatibel mit c.
Auch bei impliziten Zuweisungen wie der Parameterübergabe von Me-
thodenaufrufen (den dabei stattfindenden Zuweisungen der tatsäch li-
chen an die formalen Parameter; s. Abschnitt 4.3.2 ) impliziert Zuwei-
sungskompatibilität Typkorrektheit. Außerdem kann eine Methode, wenn sie Werte zurück-
gibt, ja selbst in rechten Seiten von Zuweisungen auftreten; der Typ dieser Werte muss dann
mit der Variable auf der linken Seite zuweisungskompatibel se in. So sind bei Vorliegen der
Deklarationen
867 m: p <E> ^ <A>
868 | e <E> a <A> |
sowohl die explizite als auch die impliziten Zuweisungen in
869 a := self m: e
zulässig; den Methodenaufruf kann man im übertragenen Sinne als zulässig bezeichnen.
