50.4.3 Generizität in C#
Genau wie in JAVA entspricht in C# zunächst jeder Klasse und jedem Interface ein Typ. Mit
der Version 2.0 ist C# aber ebenfalls generisch geworden. Genauer gesagt erlaubt C# so-
wohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von
Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus:
die für unbeschränkte untersc heidet sich nicht von der JAVAs. Parametrisch definierte Klas-
sen und Interfaces spezifizieren jeweils eine (potentiell unendliche) Menge von Typen, die
durch Einsetzen konkreter ( tatsächlich er) Typparameter in die Typvariablen entstehen. C#
erlaubt zudem ( genau wie JAVA; s. Abschnitt 43.5 in Kurseinheit 4), den tatsächlich en
Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler
aus den Typen der Argumente erschließen kann ( Typinferenz ).
Auch wenn sich die Generics von C# auf den ersten Blick nicht groß von
denen JAVAs zu unterscheiden scheinen, so verbirgt sich hinter der Ober-
fläche doch ein a nderer Mechanismus. Während JAVA die Typparameter
grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type
erasure ), instanziiert C# im Fall von Wertt yp-Parametern (also int, float etc., aber auch
die per struct definierten Typen ) jede generische Klasse für jeden verwendeten Typ ein-
mal, erzeugt also alternative Implementierungen (sog. Typexpansion ). Dies hat den Vorteil,
dass diese Implementierungen ohne Boxing /Unboxing auskommen und vom JIT -Compiler
per Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird
der Code jedoch (wie in JAVA) nur einmal erzeugt. Gleichwohl bleibt die generische Typin-
formation in C# auch zur Laufzeit erhalten und kan n per Reflection abgefragt werden.
Genau wie in JAVA gibt es in C# beim Subtyping von Containern (wie z. B. Collections ) ein
Varianzproblem: Collection<A> und Collection<B> sind auch d ann nicht zuweisungs-
kompatibel, wen A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch
Zuweisungskompatibilität herzustellen, sieht C# keine spezielle Annotation der Benutzung mangelnde
Überschreibbarkeit
expliziter Interface -
eines Typs wie in JAVA vor, sondern eine Annotation der Definition des Typs76: Dem ko - bzw.
kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die
Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen V erwe ndungen des Typs
die gleichen. Übrigens : Für Arrays in C# gilt dasselbe wie in JAVA: Sie sind kovaria nt, das
Schreiben in ein Array kann aber zu einem Laufzeittypfehler führen, der in C# „Array Type-
Mismatch Exception “ heißt.
