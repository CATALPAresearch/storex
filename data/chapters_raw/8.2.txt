8.2 Initialisierung
Konstruktoren sind in SMALLTALK also Klassenmethoden, die neue Instanzen der jeweiligen
Klasse zurückliefern. Dabei haben zunächst alle Instanzvariabl en nach der Erzeugung einer
Instanz den Wert nil. Sollen diese Instanzvariablen mit sinnvollen Anfangswerten belegt
werden, müssen ihnen diese explizit zugewiesen werden. Man spricht dann von einer Initi-
alisierung der Instanz.
Nun sollen nicht immer alle Instanzen einer Klasse gleich initialisiert werden. Es ist daher
möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu defi-
nieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die
Klasse Time sind mit
gegeben, die jeweils die Klassenmethode (den Konstruktor) seconds: auf Time (vertreten
durch self ) aufrufen, die wiederum mittels basicNew eine Instanz von Time erzeugt und
anschließend initialisiert:
Dabei ist ticks: eine Instanzmethode der Klasse Time , die auf der (mit basicNew ) frisch
erzeugten Instanz aufgerufen wird und diese initialisiert:
Parameter der Initialisierung ist hierbei (Duration seconds: seconds) ticks , wobei
Duration eine Klasse und seconds: ein Konstruktor dieser Klasse ist.
Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar
sind, kann auch eine Klassenmethode wie new nicht auf sie zugreifen. Die I nitialisierung
muss daher von Instanzmethoden wie ticks: vorgenommen werden, die jedoch nicht der
Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen wer-
den können. Das ist immer dann ein Problem, wenn auch Instanzvariab len initialisiert wer-
den müssen, deren Existenz nach außen verborgen werden soll (s. Abschnitt 4.3.4 ) und die
deswegen nicht direkt über Zugriffsmethoden gesetzt werden können sollen. Aus diesem
Grund sehen new und new: standardmäßig den Aufruf der Methode initialize vor (s.
Zeilen 307 und 309 oben ), in der alle Initialisierungen vorgenommen werden kö nnen, ohne
dass etwas über den Aufbau der Instanzen nach außen verraten würde. In anderen Spra-
chen wie beispielsweise C++, JAVA oder C# sind Konstruktoren daher auch keine Klassen-
methoden, sondern haben eine Art Zwitterstatus: Sie werden auf einer Klasse a ufgerufen,
werden aber wie Instanzmethoden auf der neuen Instanz ausgeführt und können somit
auch auf die Instanzvariablen der neu erzeugten Instanz zu greifen. Man beachte jedoch,
dass die Instanzmethode ticks: kein Implementationsgeheimnis preisgibt: Dass Objekte
der Klasse Time die Zeit in Sekunden und Nanosekunden speichern ist an der Methode
ticks: nicht zu erkennen.
Vor diesem Hintergrund können wir das Beispiel der zweiten Implemen-
tierung von Stack aus Abschnitt 7.2 wieder aufgreifen und die noch fe h-
lende Initialisierung der Variablen stackcontent und stackcounter nachliefern:
Klasse Stack
Klassenmethoden
benannte Instanzvariablen stackcontent stackpointer
indizierte Instanzvariablen nein
Instanzmethoden
Man beachte, dass das Zwischenobjekt eine Instanz der Kla sse Array ist, die hier (in Zeile
325) nicht wie noch in Kurseinheit 1 notwendig durch ein Literal, sondern durch eine expli-
zite, programmatische Instanziierung (mittels new: ) erzeugt wurde.
Alternativ zu obiger Konstruktion kann die Initi alisierung von Instanzvari-
ablen auch zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt werden. Man
spricht dann von einer Lazy initialization (lazy oder faul deswegen, weil man die Initiali-
sierung solange hinausschiebt, wie irgend möglich). Dazu muss jedoch vor jedem lesenden
Zugriff auf die (faul initialisierte) Instanzvariable geprüft werden, ob der Wert der Variable
immer noch nil ist — falls ja, muss er durch den gewünschten Anfangswert (der sonst in
der Standardinitialisierungsmethode zu finden wäre) ersetzt werden. Um nicht jeden lesen-
den Zugriff auf die Variable im Programm mit einer entsprechenden Abfrage versehen zu
müssen, empfiehlt es sich bei Verwendung von Lazy initialization , alle, also auch klassenin-
terne, Zugriffe auf Instanzvariablen über einen entsprechenden Getter durchzuführen, der
den Inhalt der Variable vor seiner Preisgabe prüft und ggf. erst setzt. Statt
wo bei jeder Verwendung ggf. faul initialisiert wird, würde man also
schreiben (man beachte das self vor stackpointer und stackcontent — hier wird
jeweils ein Getter aufgerufen).
Wie man sieht, ist die Programmiererin bei der Lazy initialization über-
haupt nicht faul —sie muss sogar einiges mehr an Code schreiben, als bei
einer Standardinitialisierung notwendig wäre. Das laufende Programm
spart sich jedoch den Preis der Initialisierung, wenn diese nie notwendig wird, wenn also im
Programmablauf der Wert der zu initialisierenden V ariable nie oder erst nach einer anderen
Zuweisung abgefragt wird (was im Beispiel vom Stack freilich nicht der Fall ist). Sie lohnt
sich also immer dann, wenn die Initialisierung aufwendig und die Abfrage des Anfangswer-
tes selten ist. Ein weiterer Vorteil der Lazy initialization ist, dass die Initialisierung nie verges-
sen werden kann; dies ist insbesondere dann wertvoll, wenn die Initialisierung nicht wie
oben beschrieben vom Konstruktor selbst, sondern von einer separaten Methode durchge-
führt wird und den Benutzerinnen der entsprechenden Klasse vielleicht nicht klar ist, dass
sie nach dem Konstruktor auch noch die Initialisierungsmethode aufrufen müssen. Kon-
struktoren, die wie in Zeilen 307 und 309 oben ) implementiert wurden, suchen das zu ver-
hindern, indem sie die Initialisierungsme thode selbst aufrufen; manchmal kann der Kon-
struktor doch nur schlecht geändert werden (s. z. B. Abschnitt 10.3) und man wird auch
nicht verhindern können, dass, anstelle von new, basicNew direkt und ohne initialize
aufgerufen wird. Vor- und Nachteile
Selbsttestaufgabe 8.1
Begründen Sie, warum eine Kapselung der Lazy initialization durch eine Zugriffsmethode dem Sinn
der Standardinitialisierung per initialize möglicherweise entgegensteht.
Nachdem nun hinlänglich klar geworden sein sollte, welche Möglichkeiten
es zur Initialisierung von Instanzvariablen gibt, bleibt noch die Frage nach
der Initialisierung von Klassenvariablen. Klassenvariablen werden nämlich, genau wie In-
stanzvariablen, standardmäßig zu nil initialisiert und soll eine Klass envariable einen ande-
ren Anfangswert haben (z. B. weil es sich dabei um eine Konstante handelt, die für alle
Instanzen der Klasse eine Rolle spielt), dann muss ihr dieser Wert explizit zugewiesen wer-
den. Da Klassen ja Instanzen ihrer Metaklassen sind, dies e Metaklassen aber automatisch
mit der Erzeugung der Klassen angelegt werden und das Klassendefinitionsschema keine
Möglichkeit vorsieht, einen Konstruktor für die Metaklasse vorzugeben, muss eine spezielle
Klassenmethode (häufig ebenfalls „initialize“ gen annt) für die Initialisierung der Klassenva-
riablen vorgesehen werden. Diese ist dann nach Anlegen der Klasse einmalig aufzurufen.
Da das aber leicht vergessen werden kann, ist Lazy init ialization für Klassenvariablen eine
sinnvolle Alternative. Allerdings stellt sich hier wieder das Problem des direkten Zugriffs auf
die (Klassen -)Variable (aus dem Kontext der Klasse selbst und ihrer In stanzen), der in SMALL-
TALK nicht unterbunden werden kann (vgl. Selbsttestaufgabe 8.1).
Selbsttestaufgabe 8.2
Schreiben Sie eine Methode new, die dafür sorgt, dass alle mit ihr erzeugten Instanzen in einer Klas-
senvariable MeineInstanzen gespeichert werden.
