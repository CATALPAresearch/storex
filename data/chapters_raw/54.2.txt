54.2 Subtyping und das Prinzip der Substituierbarkeit
Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit
immer dann fraglich ist, wenn keine Typerweiterung vorliegt, wenn man es sogar insbeson-
dere mit einer Typeinschränkung zu tun hat. Dies soll nun etwas genauer beleuchtet wer-
den. Substituierbarkeit bei
In JAVA ist die Klasse Stack als Subklasse der Klasse Vector (die keinen
Vektor im mathematischen Sinne, sondern eher ein dynamisches, also in
seiner Größe wachsen könnendes Array repräsentiert) definiert. Das führt jedoch dazu, dass
an Stellen im Programm, an denen eine indizierte Sammlung von Objekten mit wahlfreiem
Zugriff (eben ein Objekt vom Typ Vector ) erwartet wird, ein Objekt vom Typ Stack auf-
tauchen kann, dessen interne Repräsentation zwar auf einem dynamischen Array á la
Vector aufbauen mag (und der deswegen davon erbt), der aber an seiner öffentlich zu-
gängigen Schnittstelle die Funktionen für den wahlfreien Zugriff unterdrücken muss (was in
JAVA allerdings nicht geht). Sollte nämlich das Programm, in Erwartung einer indizier ten
Sammlung, auf ein Element darin zugreifen wollen und anstelle dieser einen Stack vorfin-
den, kann das Programm nicht fortgesetzt werden, es sei denn, es findet vor dem Zugriff
eine entsprechende Prüfung (und ggf. eine Verzweigung zu alternativen Verfahr ensweisen)
statt. Eine solche Prüfung muss jedoch zur Laufzeit stattfinden; wird sie vergessen (nicht
implementiert) und es taucht an dieser Stelle ein Stack auf, dann hat man es mit einem
waschechten Programmierfehler zu tun. Immerhin lassen sich solche F ehler einfach vermei-
den, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.
Eine schwächere Variante, die aber ähnlich katastrophale Folgen haben
kann und deren Vorliegen nur schwer festzustellen ist, st ellt der Fall dar,
dass eine Funktion in einem Subtyp so abgeändert wird, dass sie dem (vom Supertypen)
erwarteten Verhalten widerspricht. Dies ist beispielsweise bei den beiden Typen Set
(Menge) und Bag (Multimenge) der Fall. Wenn man nämlich Set als Subt yp von Bag an-
nimmt, so könnte man das durchaus als eine Typeinschränkung begreifen, und zwar eine,
in der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den
Wertebereich {0, 1}) beschränkt ist. Die Funktionen „Hinzufügen eines Ele ments“, „Entfer-
nen eines Elements“ sowie die Angabe der Größe und der Test auf Enthaltensein eines
Elements werden von Set genau wie von Bag unterstützt; der einzige Unterschied scheint
zu sein, dass das Hinzufügen eines Elements, das in der Menge schon en thalten ist, diese
nicht verändert.
Bei genauerem Hinsehen ergibt sich aber das Problem, dass Set durch seine Eigenheit meh-
rere charakteristische Eigenschaften von Multimengen verletzt. So gilt für Sets beispiels-
weise nicht wie für Bags, dass jedes Hinzufü gen eines Elements die Größe um 1 anwachsen
lässt. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzu-
gefügt wurden; alle doppelten Einfügungen werden von Set einfach unterschlagen. Ein
Programm, das auf die Eigenschaften von Ba gs setzt und stattdessen mit einem Set arbeiten
muss , funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.
Umgekehrt würde, wenn man Bag als Subtyp von Set annehmen würde, die für Set cha-
rakteristische Eigenschaft, nämlich dass nach dem Entfernen eines Elements dieses nicht
mehr darin enthalten ist, verletzt. Programme, die darauf bauen, dass diese Eigenschaft
garantiert wird und die anstelle einer Menge eine Multimenge bekommen, funktionieren
nicht mehr korrekt. Je nach eingenommenem Standpunkt st ellt dies einen Typfehler dar. Stack als Subklasse
Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell
zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des
jeweils anderen implizieren, dass sie genauer im Widerspruch zueinander stehen. Deswegen
lassen sich keine korrekten Sätze wie „für alle Objekte vom Typ X gilt, …“ bilden, wobei die
Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y, der Subtyp
von X sein soll, einschließen soll. Dies entspricht jedoch genau der Definition des Subtypings
aus Kurseinheit 3, Abschnitt 26.1; tatsächlich ist es mehr oder weniger eine Frage der Aus-
legung, ob für den Tatbestand d es Subtypings die in Kapitel 26 genannten syntaktischen
Bedingungen, insbesondere die Ko - und Kontravarianz, ausreichen oder ob strengere Be-
dingungen der Substitui erbarkeit eingehalten werden müssen.
In der Praxis wird die Prüfung der Substituierbarkeit durch Type -checking -
Verfahren in Form der Prüfung der Typkonformität immer nur angenä-
hert; tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen
werden, wenn mangelnde Typkonformität vorliegt.86 Gleichwohl werden
entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet aber Typkonformität
nicht automatisch auch Substituierbarkeit — dazu ist auch eine Betrachtung des Verhaltens
notwendig.
