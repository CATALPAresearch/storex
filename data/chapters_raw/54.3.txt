54.3 Verhaltensbasiertes Subtyping
Die Regeln des Subtyping aus Kapitel 26 und die damit verbundene Regelung der Zuw ei-
sungskompatibilitÃ¤t bezogen sich ja lediglich auf die Elemente einer Typdeklaration und da-
mit auf rein statische Information. Um nun auch das Verhalten der Objekte eines Typs ein-
zufangen, greift man auf eine Idee der formalen Programmverifikation zurÃ¼ck: der der Ãœber-
fÃ¼hrung der Vorbedingungen in Nachbedingungen nach der Art von (54.1). Ins Objektori-
entierte Ã¼bertragen heiÃŸt das, dass ein Typ dann korrekt (implementiert) ist, wenn fÃ¼r je de
Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedin-
gung folgt (und dass die Invarianten des Typs hÃ¶chstens temporÃ¤r, wÃ¤hrend der Methoden-
ausfÃ¼hrung verletzt werden). Wir schreiben dazu fÃ¼r eine Methode m und einen Typ T
ğ‘ğ‘Ÿğ‘’ğ‘šğ‘‡(ğ‘ ğ‘’ğ‘™ğ‘“:ğ‘‡)â‡’ğ‘ğ‘œğ‘ ğ‘¡ğ‘šğ‘‡(ğ‘ ğ‘’ğ‘™ğ‘“:ğ‘‡) (54.2)
und meinen damit, dass fÃ¼r eine Implementierung von m in der zu T gehÃ¶renden Klasse, die
auf einem EmpfÃ¤ngerobjekt vom Typ T (einer Instanz der entspreche nden Klasse) aufgeru-
fen wird, die Nachbedingung aus der Vorbedingung folgt. Diesen Beweis mÃ¼ssen wir aber
zum GlÃ¼ck nicht fÃ¼hren â€” wir sind hier nicht an der Korrektheit von Implementierungen an
sich interessiert, sondern vielmehr daran, ob sich eine (korr ekte) Implementierung durch
eine andere (ebenfalls korrekte, aber eben andere, auch in Bezug auf ihre Spezifikation)
auch vom Verwendungskontext abhÃ¤ngig ist â€” wenn beispielsweise mit einem Objekt gar nichts
gemacht wird, kann es auch durch ein anderes ersetzt werden, selbst w enn die entsprechenden
Typen nicht konform sind. Mehr dazu in Abschnitt 54.5. keine umfassende
ersetzen lÃ¤sst. Konkret: Wir sind an einer verhaltensbasierten Subtypenrelation interessiert,
also an den Bedingungen, die potentielle S ubtypen einhalten mÃ¼ssen, damit sie die Spezifi-
kation des Supertyps erfÃ¼llen, so dass man sie als verhaltenskonform betrachten kann und
eine Subtypenbeziehung wie in Kapitel 26 beschrieben gegeben ist. Das ist immer dann der
Fall, wenn obige Implikation auch fÃ¼r Objekte des potentiellen Subtypen S gilt, also wenn
ğ‘ğ‘Ÿğ‘’ğ‘šğ‘‡(ğ‘ ğ‘’ğ‘™ğ‘“:S)â‡’ğ‘ğ‘œğ‘ ğ‘¡ğ‘šğ‘‡(ğ‘ ğ‘’ğ‘™ğ‘“:S) (54.3)
Man spricht dann von einem Behavioural subtyping , das zu deutsch am besten als ver-
haltensbasiertes Subtyping87 wiedergegeben wird.
Es gilt also, (6.3) sicherzustellen. Bei der Spezifikation der Methoden des (potentiellen Sub -)
Typs S wird man aber zunÃ¤chst nicht auf die Vor - und Nachbedingungen von T zurÃ¼ckgrei-
fen, sondern eigene angeben, so dass fÃ¼r alle Methoden m von S
ğ‘ğ‘Ÿğ‘’ğ‘šS(ğ‘ ğ‘’ğ‘™ğ‘“:S)â‡’ğ‘ğ‘œğ‘ ğ‘¡ğ‘šS(ğ‘ ğ‘’ğ‘™ğ‘“:S) (54.4)
als Ausdruck der Korrektheit gilt. (54.3) folgt daraus unmittelbar, wenn
ğ‘ğ‘Ÿğ‘’ğ‘šSâ‰¡ğ‘ğ‘Ÿğ‘’ğ‘šT und ğ‘ğ‘œğ‘ ğ‘¡ğ‘šSâ‰¡ğ‘ğ‘œğ‘ ğ‘¡ğ‘šT
fÃ¼r alle m in T ist, aber das wird ja wie gesagt im allgemeinen nicht der Fall sein. Die Frage
ist vielmehr: Wie mÃ¼ssen ğ‘ğ‘Ÿğ‘’ğ‘šS, ğ‘ğ‘Ÿğ‘’ğ‘šT, ğ‘ğ‘œğ‘ ğ‘¡ğ‘šS und ğ‘ğ‘œğ‘ ğ‘¡ğ‘šT miteinander im VerhÃ¤ltnis stehen,
damit Objekte vom Typ S die Anforderungen fÃ¼r Objekte vom Typ T erfÃ¼llen? Formal: Was
mÃ¼ssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), das Verhalten
von m in T angewandt auf Objekte aus S, folgt?
Leider ist es mit der Beantwortung dieser Frage aber noch nicht genug.
Aufgrund des in der objektorientierten Programmierung weit verbreiteten
Aliasing kann ein Objekt vom Typ S, das von einem Klienten wie ein Ob-
jekt vom Typ T betrachtet wir d, von einem weiteren Klienten wie ein Objekt vom Typ S
(oder wie von einem anderen Supertypen als T) betrachtet werden. Dadurch kÃ¶nnen dann
auch Methoden auf dem Objekt aufgerufen werden, die ZustandsÃ¤nderungen des Objekts
verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (deren Vor -
und Nachbedingungen) abgedeckt sind, ja die ein Verhalten bewirken, das mit dem von T
nicht kompatibel und das fÃ¼r Benutzer innen des Objekts, die es als ein T ansehen, nicht
akzeptabel ist . Eine methodenweise Betrachtung von Bedingungen fÃ¼r die Substituierbar-
keit reicht also nicht aus. Man ahnt bereits, dass die Angelegenheit komplex wird.
