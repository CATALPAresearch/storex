54.4 Das Liskov -Substitutionsprinzip
In Sac hen verhaltensbasiertes Subtyping am meisten Bekanntheit erlangt haben die Arbei-
ten von Barbara Liskov und Jeannette Wing. TatsÃ¤chlich ist das sog. Liskov -Substitutions-
prinzip (Liskov substitution principle , LSP) eines der am hÃ¤ufigsten zum Thema Subtyping
angefÃ¼hrten, weswegen es auch hier behandelt werden soll. Ohne den Beitrag der beiden
schmÃ¤lern zu wollen, ist dies durch die Sache jedoch nicht gerechtfertigt â€” anderen, frÃ¼he-
ren Arbeiten gebÃ¼hrt mindestens gleicher Ruhm und auÃŸerdem ist, wie Sie noch sehen
werden, das LSP zu streng gefasst , weswegen es nÃ¼tzliche, fÃ¼r die Praxis relevante FÃ¤lle des
verhaltensbasierten Subtyping ausschlieÃŸt.
Historischer Hintergrund des Liskov -Substitutionsprinzips war die Suche
nach einer hinreichenden Bedingung fÃ¼r die Subtypenrelation zwischen zwei Typen. Wir
hatten ja in Kapitel 26 (Kurseinheit 3) festgestellt, dass es bei den meisten Programmier-
sprachen ausreicht, dass ein Typ B deklariert, Subtyp eines Typs A zu sein, damit Zuwei-
sungskompatibilitÃ¤t von B nach A festgestellt werden kann.88 Dazu war es allerdings not-
wendig, dass die Eigenschaften von A auf B Ã¼bertragen (vererbt) und dass dabei die Regeln
von den ko - bzw. kontravarianten Redefi nitionen von Parametertypen eingehalten werden.
Dies wird im allgemeinen durch die Sprachdefinition und durch den Compiler sichergestellt.
Das verhaltensbezogene Subtyping geht nun Ã¼ber die auf die Kontrolle
der Parametertypen beschrÃ¤nkte, syntaktische Subtypenbeziehung hin-
aus, indem es â€” nach Liskov und Wing â€” fordert, dass sich Objekte eines Subtyps und
seines Supertyps gleich verhalten sollen, und zwar insoweit irgend jemand oder irgendein
Programm dies feststellen kann. Diese Forderung kulminiert in der Regel
Subtype Requirement: Let ï¦(x) be a property provable about objects x of type
T. Then ï¦ (y) should be true for objects y of type S where S is a subtype of T.
Eine deutsche Paraphrase dessen fanden Sie bereits in Abschnitt 26.1.
Diese Definition ist gleich in mehrfacher Hinsicht problematisch.
1. Da sie die Subtypenbeziehung definiert, ist da von auszugehen, dass x exakt vom
Typ T ist und y exakt vom Typ S. Es sind also insbesondere x und y keine Objekte
von Subtypen von T bzw. S. Damit ist die Definition nicht auf abstrakte Typen und
Interfaces ausdehnbar.
2. Damit zusammenhÃ¤ngend ist die Aussage losgelÃ¶st von jedem konkreten Gebrauch
der Objekte. Wie in Abschnitt 54.5 noch genauer dargestellt werden wird, kann
bilitÃ¤t besteht; der Compiler leitet die ZuweisungskompatibilitÃ¤t aus dem Bestehen einer Subtypen-
beziehung (z. B. extends oder implements in JAVA) ab.
eine Substituierbarkeit in einem gegebenen Kontext sehr wohl bestehen, auch wenn
die Typen nach obiger Definition nicht substituierbar sind. Man wÃ¼rde die Anforde-
rungen in einem solchen Fall in einem Interfacetypen festhalten, der nur die im Kon-
text benÃ¶tigten Eigenschaften spezifiziert. Dieser Typ hat dann aber (gemÃ¤ÃŸ Punkt
1) keine Objekte x.
3. Die Aussage ist implizit allquantifiziert Ã¼ber ï¦, d. h., sie soll fÃ¼r alle mÃ¶glichen Eigen-
schaften (PrÃ¤dikate) ï¦ gelten. Das bedeutet wiederum, dass alle Eigenschaften von
T auch fÃ¼r S gelten â€” die Objekte von S mÃ¼ssen sich also, sieht man einmal von
zusÃ¤tz lichem Verhalten ab, exakt gleich verhalten. Das aber stellt die Idee des Sub-
typing weitgehend infrage: Wenn ein Objekt sich von dem, das es ersetzen soll ,
Ã¼berhaupt nicht unterscheidet, wozu brauche ich es denn dann Ã¼berhaupt?
Zu Punkt 3 ist abschwÃ¤chend zu sagen, dass hier vermutlich Verhalten des Programms in-
sofern unverÃ¤ndert sein soll, als es immer noch seinen Zweck erfÃ¼llt, d. h., seiner Spezifika-
tion genÃ¼gt. Das ist jed och etwas anderes, als in dem Prinzip ausgedrÃ¼ckt wird.
Eine Subtypenrelation zwischen S und T, die das obige Subtype require-
ment erfÃ¼llt, definieren Liskov und Wing zunÃ¤chst wie folgt:
1. Ãœberschreibende Methoden in S erhalten das Verhalten der Ã¼berschriebenen Me-
thoden in T. Dazu gehÃ¶rt:
a. Kontravarianz der Argumenttypen der Ã¼berschreibenden Methode
b. Kovarianz des Ergebnistyps der Ã¼berschreibenden Methode
c. Kovarianz der Ausnahmen der Ã¼berschreibenden Methode (die Typen der ge-
worfenen Exceptions sind entweder Subtypen von den Typen der Exceptions der
Ã¼berschriebenen Methode oder die Exceptions werden gar nicht geworfen; kei-
nesfalls kommen Exceptions hinzu)
d. Vorbedingungen der Ã¼berschriebenen Methode implizieren Vorbedingungen
der Ã¼berschreibenden: ğ‘ğ‘Ÿğ‘’ğ‘šğ‘‡(ğ‘ ğ‘’ğ‘™ğ‘“:S)â‡’ğ‘ğ‘Ÿğ‘’ğ‘šS(ğ‘ ğ‘’ğ‘™ğ‘“:S)
e. Nachbedingungen der Ã¼berschriebenen Methode werden von Nachbedingun-
gen der Ã¼berschreibenden Methode impliziert, also gilt hier: ğ‘ğ‘œğ‘ ğ‘¡ğ‘šğ‘†(ğ‘ ğ‘’ğ‘™ğ‘“:S)â‡’
ğ‘ğ‘œğ‘ ğ‘¡ğ‘šğ‘‡(ğ‘ ğ‘’ğ‘™ğ‘“:S)
2. Die Invarianten von S implizieren die von T.
Man beachte, dass die (auch semantisch genannten) Regeln 1.d und 1.e die (auch syntak-
tisch genannten) Regeln 1.a â€“ 1.c implizieren: In typlosen Sprachen wie SMALLTALK beispiels-
weise wÃ¼rde man die entsprechenden Anforderungen an die Parameterobjekte mittels Vor -
und Nachbedingungen formulieren und die Menge der geworfenen Exceptions wÃ¤re Teil
der Nachbedingungen.
Man kann sich die Wirksamkeit der Bedingungen wie folgt erklÃ¤ren: Subtypenrelation
Aus den obigen Regeln der Subtyp relation und aus der Korrektheit der Ã¼berschreibenden
Methode in S folgt die gewÃ¼nschte Substituierbarkeit.
Es bleibt jedoch noch das eingangs beschriebene, mit dem Aliasing und
der damit verbundenen MÃ¶glichkeit des zu sÃ¤tzlichen Methodenaufrufs assoziierte Problem
bestehen. DafÃ¼r identifizieren Liskov und Wing zwei LÃ¶sungen:
Die erste sagt aus, dass das Verhalten eines Subtyps immer dann mit dem
des Supertyps konform ist, wenn alles zusÃ¤tzliche Verhalten des Subtyps durch Verhalten
des Supertyps simuliert werden kann, wenn es also fÃ¼r jede zusÃ¤tzliche Methode eine Kom-
bination von Methodenaufrufen des Supertyps (bzw. deren Ã¼berschriebenen, verhaltens-
konformen Varianten) gibt, die den Effekt der zusÃ¤tzlichen Methode hat und die der Klient
des Objekts auch selbst (oder ein anderer Klient, der aber das Objekt durch denselben Typ
sieht) durchfÃ¼hren kÃ¶nn te. Diese Bedingung ist jedoch ziemlich hart, da sie im Grunde aus-
sagt, dass ein Subtyp lediglich Makros hinzufÃ¼gen darf. Auf der anderen Seite ist ihre Ein-
haltung, wenn auch nicht automatisch, so jedoch zumindest anschaulich relativ einfach
nachzuweisen ( was fÃ¼r die Praxis eminent wichtig ist).
Die zweite LÃ¶sung ist denn auch weniger einschrÃ¤nkend, dafÃ¼r aber in
der Praxis kaum nachzuweisen: Sie verlangt von jedem Typ zusÃ¤tzlich zur
Verhaltensspezifikation der Methoden (Ã¼be r die Ã¼blichen Vor - und Nachbedingungen) die
Einhaltung von Verlaufseigenschaften , die die mÃ¶glichen Zustandswechsel der Objekte des
Typs betreffen und die wir deswegen Zustandswechselinvaria nten nennen. Dazu wÃ¤re
eine Art endlicher Automatenspezifikation, also eine Spezifikation der Menge der mÃ¶glichen
ZustÃ¤nde und ZustandsÃ¼bergÃ¤nge, notwendig. Das Problem dabei ist jedoch, dass die Zu-
stÃ¤nde eines Objekt s nicht abstrakt (z. B. in Form einer AufzÃ¤hlung von Zustandsnamen)
existieren, sondern sich in der Belegung von Instanzvariablen manifestieren, so dass sich der
Zustandsraum kombinatorisch (abzÃ¼glich der funktionalen AbhÃ¤ngigkeiten der Attribute)
ergibt. Um dem aus dem Weg zu gehen, werden bei den historischen Zustandswechseln
lediglich zwei beliebige, zeitlich nicht notwendig unmittelbar aufeinander folgende Zu-
stÃ¤nde betrachtet und fÃ¼r diese eine Bedingung formuliert, die eingehalten werden muss .
Man beac hte, dass die Einhaltung der ersten Bedingung die zweite impliziert: Wenn alle
Methoden des Supertyps die historischen Invarianten einhalten und wenn eine Methode das Aliasing -Problem
Verhaltenssimulation
Zustands wechsel in-
varianten Korrektheit
Substituierbarkeit
Kontravarianz
Kovarianz
ğ‘ğ‘œğ‘ ğ‘¡ğ‘šS(ğ‘ ğ‘’ğ‘™ğ‘“:S)â‡’ğ‘ğ‘œğ‘ ğ‘¡ğ‘šT(ğ‘ ğ‘’ğ‘™ğ‘“:S)
ğ‘ğ‘Ÿğ‘’ğ‘šS(ğ‘ ğ‘’ğ‘™ğ‘“:S)â‡’ğ‘ğ‘œğ‘ ğ‘¡ğ‘šS(ğ‘ ğ‘’ğ‘™ğ‘“:S) ğ‘ğ‘Ÿğ‘’ğ‘šğ‘‡(ğ‘ ğ‘’ğ‘™ğ‘“:S)â‡’ğ‘ğ‘Ÿğ‘’ğ‘šS(ğ‘ ğ‘’ğ‘™ğ‘“:S) ğ‘ğ‘Ÿğ‘’ğ‘šğ‘‡(ğ‘ ğ‘’ğ‘™ğ‘“:S)â‡’ğ‘ğ‘œğ‘ ğ‘¡ğ‘šğ‘‡(ğ‘ ğ‘’ğ‘™ğ‘“:S)
des Subtyps sich als Kombination von Methoden des Supertyps darstellen lÃ¤sst, dann hÃ¤lt
auch diese die historischen Invarianten ein.
So gut das Liskov -Substitutionsprinzip auch begrÃ¼ndet sein mag, es er-
weist sich fÃ¼r die Praxis als zu streng. So kÃ¶nnte man beispielsweise in einem Typ T eine
Methode echo: i <Integer> ^Integer definieren, die den Eingabeparameter gleich
wieder ausgibt (die sog. IdentitÃ¤t oder IdentitÃ¤tsfunktion) . In einem Subtyp S kÃ¶nnte man
dann die Methode so Ã¼berschreiben, dass sie beliebige Objekte entgegennimmt und gleich
wieder zurÃ¼ckgibt: echo: i <Object> ^ Object . Die Methode ist damit zwar in ihrem
Eingabeparameter kontravariant, aber in ihrem Ausgabeparameter nicht kovariant, und er-
fÃ¼llt somit die Bedingung des LSP nicht. Gleichwohl kann echo: auf einem Objekt vom Typ
S Ã¼berall da aufgerufen werden, wo es auch auf einem Objekt von Typ T aufgerufen werden
kann, denn es kommt so niemals dazu, dass die Regel der Kovarianz des Ausgabeparame-
ters verletzt wird. Wir haben es beim LSP also mit einer TypprÃ¼fung zu tun, die gÃ¼ltige
Programme zurÃ¼ckweist. DafÃ¼r, dass die Einhaltung des LSP fÃ¼r den allgemeinen Fall gar
nicht automatisch Ã¼berprÃ¼ft werden kann, ein ziemlich hoher Preis.
