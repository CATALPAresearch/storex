12 Dynamisches Binden
Wie bereits in den Abschnitten 4.3.2 und 4.5.2 in Kurseinheit 1 angerissen, verbirgt sich
hinter dem Nachrichtenversand ein dynamisch gebundener Methodenaufruf. Dabei ist die
Auswahl der Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfänge-
robjekt abhängig. In Abschnitt 11.2 hatten wir bereits angedeutet, wie in Superklassen de-
finierte Methoden für ihre Subklassen zugreifbar sind; hier schauen wir uns nun etwas ge-
nauer an, wie die dynamische Bindung von Methodena ufrufen vonstatten geht.
Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird
zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehö-
renden Methodenwörterbuch enthalten ist. Dies kan n man auch selbst
tun: Es gibt dafür in der Klasse Behavior eine Instanzmethode
oder so ähnlich (je nach System), die somit allen Klassen (als Klassenmethode) zur Verfügung
steht. (Behavior ist ja eine Superklasse von Class , die wiederum Superklasse aller Me-
taklassen ist, einer derer jede Klasse eine Instanz ist, so dass alle Klassen die Methode
includesSelector: verstehen.)
Wird die Methode gefunden, dann wird sie ausgeführt. Wird sie nicht gefunden, wird zu-
nächst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren
direkter Superklasse usw. bis zur Klasse Object . Sobald die Methode gefunden wird , wird
sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum bereits
(in den Abschnitten 4.3.2 und 11.3) erwähnten Versenden der Nachricht
doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, proble-
matischen Nachricht als Argument. Ablauf eines
Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Me-
thode einer Superklasse des Empfängerobjekts ausgeführt wird, das Ob-
jekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die
Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilie-
rung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die In-
stanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind.
Instanzvariablen, die erst in der Klasse des Objekts hinzug ekommen sind, sind für die Me-
thode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden —
handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch
Instanz seiner Klasse ist. Die gerade ausgeführte Meth ode betrachtet es lediglich wie ein
Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die
Bedeutung der Pseudovariable super , wie wir noch sehen werden.
Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, a us Effizienzgründen direkt
in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im wesentlichen
äquivalent zu der der Methode canUnderstand: , die genau wie includesSelector:
in der Klasse Behavior definiert ist:
Man beachte übrigens, wie wenig Aufwand es ist, aus dem klassenba-
sierten Methoden -Lookup einen objektbasierten zu machen: Man muss
dazu lediglich jedem einzelnen Objekt sein eigenes Methodenwörterbuch
zur Verfügung stellen. Wenn man zusätzlich noch Objekte von Objekten
anstatt Klassen von Klassen erben lässt, dann hat man schon die prototy-
penbasierte Form der objektorientierten Programmierung. Der Unterschied ist also technisch
nicht besonders groß — konzeptuell hingegen schon, denn mit den Klassen entfielen auch
die sonst so nützlichen Begriffe von General isierung und Spezialisierung (von der Generali-
sierung von Objekten zu sprechen erscheint wenig sinnvoll).
Selbsttestaufgabe 12.1
Schreiben Sie eine Klasse PrototypicalObject und ändern Sie darin d ie Methoden perform ,
perform: etc. so ab, dass zunächst in einem jedem Objekt eigenen Methodenwörterbuch nach-
geschlagen wird, ob es eine passende Methode für das Empfängerobjekt gibt. Was fehlt noch, damit
Ihr SMALLTALK zu einem echten Hybriden (klassenbas ierte plus prototypenbasierte Form der Objekto-
rientierung) wird?
Eines der immer wieder vorgetragenen Hauptargumente gegen den Ein-
satz von SMALLTALK in der kommerziellen Programmierung ist der Um-
stand, dass das dynamische Binden wirklich vollkommen dynamisch ist: Dass einem Objekt
eine Nachricht geschickt wird, die es nicht versteht, tritt immer erst zur Laufzeit zutage (s. Verhältnis von
Abschnitt 10.3 und 11.3).41 In den statisch typgeprüften Sprachen, die wir in den nächsten
Kurseinheiten kennenler nen werden, ist das charakteristischerweise nicht so. Dem kann
man entgegenhalten, dass die heutigen (auch) statisch typgeprüften Programmiersprachen
wie JAVA, C# oder C++ sämtliche nicht ohne dynamische Typumwandlungen auskommen,
die ebenfalls zu Laufzeitfehlern führen können. Tatsächlich ist es sowohl in SMALLTALK als
auch in JAVA und C# (in C++ nur mit Einschränkungen; s. Abschnitt 51.5) nicht nur möglich,
sondern sogar geboten, Laufzeitfehler da, wo möglich, zu vermeiden, indem man vor einem
Methodenaufruf explizit prüft, ob ein Objekt die gewünschte Methode auch hat — in SMALL-
TALK mittels canUnderstand: , in JAVA et al. mittels eines entsprechenden Typtests vor ei-
nem Down cast . Die größere Flexibilität, die die objektorientierte Pro grammierung durch
das dynamische Binden bietet, hat eben den Preis, dass bestimmte Laufzeitprüfungen
durchgeführt werden müssen. Statische Typprüfung kann das Risiko von Typfehlern verrin-
gern, aber nicht ausschließen — gleichzeitig schränkt es die Flexibil ität beim Programmieren
ein, ein Umstand, der so manchen, der schon einmal größere Programme in SMALLTALK ge-
schrieben hat, an der Verwendung typgeprüfter Sprachen stört.
