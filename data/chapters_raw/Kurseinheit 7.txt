Kurseinheit 7: Objek torientierter Stil
Egal, wie formal sie auch sind: Programmiersprachen sind Sprachen und erlauben einer Au-
torin damit, sich auf eine persönliche Art und Weise auszudrücke n. Dabei bestimmt die
Ausdrucksweise nicht den Inhalt des Programms (seine Funktion), sondern seine Qualität,
also z. B. wie effizient ein gegebenes Problem damit gelöst wird oder wie verständlich die
Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat etwas
mit Schreibstil zu tun; neben ihr spielen aber auch noch andere Parameter in Stilfragen eine
Rolle, so z. B. Mode und Ästhetik (Eleganz).
So hat es fraglos in den letzten Jahrzehnten eine Wandlung in Stilfragen
gegeben, und zwar weg vom mathematisch -pregnanten hin zum prosa-
isch-verbosen Stil. Das folgende Beispiel soll davon einen Eindruck geben:
1556 PROGRAMM marriage(input,output);
1557 {Problem der stabilen Heirat}
1558 CONST n = 8;
1559 TYPE man = 1 .. n; woman = 1 .. n; rank = 1 .. n;
1560
1561 VAR m: man; w: woman; r: rank;
1562 wmr: array [man, rank] OF woman;
1563 mwr: ARRAY [woman, rank] OF man;
1564 rmw: ARRAY [man, woman] OF ra nk;
1565
1566 rwm: ARRAY [woman, man] OF rank;
1567 x: ARRAY [man] OF woman;
1568 y: ARRAY [woman] OF man;
1569 single: ARRAY [woman] OF BOOLEAN;
1570
1571 PROCEDURE print;
1572 VAR m: man; rm, rw: INTEGER;
1573 BEGIN rm := 0; rw := 0;
1574 FOR m := 1 TO n DO
1575 BEGIN write(x[m]:4);
1576 rm := rm + rmw[m,x[m]]; rw := rw + rwm[x[m],m]
1577 END ;
1578 writeln(rm:8, rw:4)
1579 END {print) ;
1580 mathema tisch -
pregnanter vs.
prosaisch -verboser
Stil There does not now, nor will there eve r, exist a programming language
in which it is the least b it hard to write bad programs .
1581 PROCEDURE try(m: man);
1582 VAR r: rank; w: woman;
1583
1584 FUNCTION stable: BOOLEAN;
1585 VAR pm: man; pw: women;
1586 i, lim: rank; s: BOOLEAN;
1587 BEGIN s := TRUE; i := 1;
1588 WHILE (i < r) AND s DO
1589 BEGIN pw := wmr[m,i] ; i := i+1;
1590 IF NOT single[pw] THEN
1591 s := rwm[pw,m] > rwm[pw,y[pw]]
1592 END ;
1593 i := 1; lim := rwm[w,m];
1594 WHILE (i < lim) AND s DO
1595 BEGIN pm := mwr[w,i] ; i := i+1;
1596 IF pm < m THEN s := rmw[pm,w] > rmw[pm,x[pm]]
1597 END ;
1598 stable := s
1599 END {stable} ;
1600
1601 BEGIN {try}
1602 FOR r := 1 to n DO
1603 begin w := wmr[m,r];
1604 IF single[w] THEN
1605 IF stable THEN
1606 BEGIN x[m] := w; y[w] := m; single[w] := FALSE;
1607 IF m < n THEN try(succ(m)) ELSE print;
1608 single[w] := TRUE
1609 END
1610 END
1611
1612 END {try);
1613 BEGIN
1614 FOR m := 1 TO n DO
1615 FOR r := 1 TO n DO
1616 BEGIN read(wmr[m,r]) ; rmw[m,wmr[m, r]] := r
1617 END;
1618 FOR w := 1 TO n DO
1619 FOR r := 1 TO n DO
1620 BEGIN read(mwr[w,r]); rwm[w,mwr[w,r]] := r
1621 END;
1622 FOR w := 1 TO n DO single[w] := TRUE;
1623 try(1)
1624 END .
Es hand elt sich dabei um ein PASCAL -Programm zur Lösung des Problems der stabilen Heirat,
wie es in dem Klassiker „Algorithmen und Datenstrukturen“ von NIKLAUS WIRTH nachzulesen
ist. Eine mir leider entfallene Quelle soll übrigens gesagt haben, eine Untersuchung habe
hervorgebracht, dass ein bedeutender Anteil aller Variablen in Programmen „i“ heiße. Nun
wurden in obigem Beispiel die Variablen nicht „i“, sondern „r“, „m“, „w“ usw. genannt,
aber das gr undlegende Problem bleibt das gleiche: Man muss sich schon ziemlich in das
Programm bzw. den dazugehörenden Text vertiefen, um zu erfassen, wofür die Variablen
stehen.
Real programmers can write Fortran in any language.
Heute ist es üblich, Bezeichner (Namen für Module, Typen, Variablen, Pro-
zeduren und Funktionen) in einem Programm so zu wählen, dass Kom-
mentare bzgl. der Bedeutung des jeweiligen Programmelements unnötig sind, da sie nicht
viel mehr ausdrücken können, als es der Bezeichner in seinem jeweiligen Kontext ohnehin
tut. Dies geht sogar so weit, dass Leute wie Kent Beck (Mitinitiator und Verf echter des sog.
Extreme Programming , SMALLTALK -Veteran) meinen, ein gut geschriebenes objektorientier-
tes Programm bräuchte gar keine Kommentare. Dem möchte ich entgegenhalten, dass
manchmal die Lösung eines Problems in seiner verständlichsten Form um viele s uneleganter
ist als eine, die mit einer gewissen Raffinesse daherkommt, sich dafür aber nicht jeder un-
mittelbar erschließt. In solchen Fällen ist die Versuchung groß, sich für die geistreichere Va-
riante zu entscheiden und sie, für diejenigen Leserinnen , die einer nicht auf Anhieb folgen
können, mit einem erklärenden Kommentar zu versehen. Nicht zuletzt sind es ja gerade die
alles andere als offensichtlichen Algorithmen, die ihren Autorinnen zu Berühmthei t verhol-
fen haben, und wer würde nicht gern hier und da eine eigene Marke setzen. Kryptische
Namen zu verwenden ist jedoch niemals ein Zeichen von Genialität.
Wir kommen also gleich zur Stilregel Nummer 1 der objektorientierten Programmierung.
