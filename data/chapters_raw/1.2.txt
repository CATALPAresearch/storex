1.2 Literale
Ein Literal (von lat. littera, der Buchstabe ) ist eine in der Syntax der Programmiersprache
ausgedrückte Repräsentation eines Objektes. Literale sind somit textuelle Spezifikationen
von Objekten: Wenn der Compiler ein Literal übersetzt, erzeugt er daraus — bei der Über-
setzung! — das entsprechende Objekt im Speicher . Dies steht im Gegensatz zu objekter-
zeugend en Anweisungen eines Programms, denn diese werden erst zur Laufzeit des Pro-
gramms ausgeführt. Da wir uns mit der programmgesteuerten Erzeugung von Objekten
aber erst in der nächsten Kurs einheit systematisch befassen, müssen wir hier zunächst mit
Objekten mit l iteraler Repräsentation vorlieb nehmen. Wohlgemerkt: Literale repräsentieren
Objekte, es sind nicht selbst welche.
Die einfachsten Literale repräsentieren Zeichen (gen auer: Zeichenob-
jekte). Um die literale Repräsentation eine s Zeichens von anderen Vorkommen von Zeichen
in einem Programm zu unterscheiden, wird ihnen in SMALLTALK ein $ -Zeichen vorangestellt.
So bezeichnet das Literal
das Zeicheno bjekt „a“ 4. Dieses Objekt ist atomar , d. h., es ist nicht aus anderen Objekten
zusammengesetzt. Zeichen sind in anderen Programmiersprachen — auch objektorientier-
ten — übrigens typische rweise Werte.
Eine andere Art von Literalen, die atomare Objekte repräsentieren, sind
die für Zahlen:
ist z. B. ein Literal, das das Objekt „1“ bezeichnet ;
ist ebenfalls ein Zahlliteral. Zahlliterale bezeichnen ebenfalls atomare (nich t zusammenge-
setzte) Objekte; sie sind in anderen Programmiersprachen typischerweise ebenfalls Werte
(nicht jedoch sehr große Zahlen mit beliebiger Genauigkeit — die werden auch in anderen
objektorientierten Sprachen durch Objekte repräsentiert).
Die in anderen Programmiersprachen vorzufindenden Literale (oder, je
nach Sprache, Schlüsselwörter ) true , false und nil (oder null ), die
genau wie Zeichen - und Zahl literale atomare Objekte repräsentieren, sind in SMALLTALK nicht
in einem Programm) zu benennen. Gemeint ist damit immer die Repräsentation des Objekts im Spei-
cher. Um ein Literal, also die Repräsentation eines Objekts in einem Programm, zu benennen, setze
ich es in diesem Kurstext in der Schriftart für (Programm -)Code. Zeichenliterale
Zahlliterale
Literale v s. (Pseudo -)
Literale, sondern Pseudo variablen (s. Abschnitt 1.7). Der Grund dafür scheint eher pragma-
tischer Natur zu sein : SMALLTALK kennt keine Sch lüsselwörter und indem man true , false
und nil als (Pseudo -) Variablen auffasst, müssen sie vom Compiler syntaktisch nicht von
Variablen (s. Abschnitt 1.5) unterschieden werden . So oder stehen sie für jeweils ein ent-
sprechendes Objekt ( die in anderen Sprachen wiederum Werte sind).
Wenn es atomare Objekte gibt, dann muss es auch zusammengesetzte
geben. So können beispielsweise Zeichen zu Zeichenketten , den s ogenannten Strings ,
zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann aber selbst wieder
durch ein Literal bezeichnet werden; so steht in SMALLTALK
für ein String -Objekt „Smalltalk“. Dieses Objekt ist selbst aus Objekten, nämlich den von
den Zeichenliteralen $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentierten Zeichenobjek-
ten, zusammengesetzt. Was Zusammensetzung von Objekten heißt und wie sie funktio-
niert, darauf gehe ich in den Abschnitten 2.1 und 2.3 noch genauer ein.
Es repräsentieren also String -Literale zusammengesetzte Objekte. Daraus ergibt sich die
Frage, ob zwei gleiche String -Literale dasselbe Objekt im Speicher repräsentieren. Dies ist
nicht grundsätzlich so , wie wir noch sehen werden .
Um durch syntakti sch gleiche Zeichenketten stets dasselbe Objekt zu be-
zeichnen, bietet SMALLTALK sog. Symbole als weitere Art von Objekten mit literaler Reprä-
sentation. So ist
die literale Repräsen tation eines Objekts . Es bezeichnet bei jedem Vorkommen im Programm
dasselbe Symbolobjekt „Smalltalk“ (nicht zu verwechseln mit dem obigen String -Objekt).
Symbole dürfen, anders als Strings, nicht alle Zeichen enthalten (so z. B. keine Leerzeichen).
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die
Erzeugung eines solchen Objekts durch den Compiler technisch auf-
wendiger als beispielsweise die anhand eines String -Literals . Der Compiler muss nämlich vor
dem Erzeugen erst prüfen, ob das Literal schon einmal irgendwo vorkam . Ist das der Fall,
erzeugt er kein neues Objekt, sondern verwendet statt dessen das bereits vorhandene. Das
setzt natürlich eine entsprechende Verwaltung aller Symbolliterale und dazugehörig en Ob-
jekte durch den Compiler voraus.5 Wie man sich leicht vorstellen kann, wäre diese Vorge-
hensweise für die universell und in großer Anzahl verwendeten String s sehr zeit aufwendig.
SymbolTable . String -Literale
Gleichwohler versuchen manche SMALLTALK -Compiler, gleiche Literale, die zusammen kom-
piliert werden, auf dasselbe Objekt abzubilden. Das führt manchmal, durch das sog. Aliasing
(s. Abschnitt 1.8), zu unerwarteten Ergebnissen bei der Verwendung dieser Literale .
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array -Lite-
rale. Die von ihnen repräsentierten Objekte sind genau wie Strings zusammengesetzt, be-
stehen aber im Gegensatz dazu nicht nur aus Zeichen, sondern aus einer Folge beliebiger,
wieder durch Literale repräsenti erter Objekte. Ein Array -Literal wird in SMALLTALK vom # -
Zeichen und einer öffnenden Klammer angeführt, der durch Leerzeichen getrennte Literale
folgen; es wird durch eine schließende Klammer abgeschlossen.
ist ein solches Array -Literal,
ein anderes. Array -Literale können ineinander geschachtelt sein; das # -Zeichen entfällt je-
doch bei allen inneren Arrays . In
beispielsweise ist das String -Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes
Array -Literal, das aus Zeichenliteralen besteht, ersetzt.
Für Array -Literale gilt ansonsten das Gleiche wie für String -Literale: Dass zw ei syntaktisch
gleich sind heiß t nicht, dass sie dasselbe Objekt erzeugen (oder, richtiger, dass aus ihnen
nur ein Objekt erzeugt wird).
