69 Klassenhierarchie
Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Ka-
piteln dieser Kurse inheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von
allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher
als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht — sie ist
fast immer willkürlich. Im folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt
werden, dass ich persönlich eher nicht als Stilfrage einstufen würde, dass aber dennoch
häufiger in diesem Zusammenhang genannt wird.
Wie bereits in Kurseinheit 6 und (teilweise auch schon in Kurseinheit 2, Abschnitt 10.1) be-
merkt, ist die Vererbung Aushängeschild und Problemkind der objektorientierten Program-
mierung zugleich. Es verwundert daher nicht, dass sich eine ganze Menge von Program-
mierrichtlinien mit genau diesem Thema beschäftigen. Die meines Erachtens gewichtigste
aller Regeln zu diesem Thema ist jedoch:
Für JAVA lässt sich diese Regel auch als „deklariere jede Klasse entweder als abstrakt oder
als final“ formulieren. Der Grund dafür, dass nur die Blätter der Klassenhierarchie instanzi-
ierbar sein sollen, ist einfach: Wenn man mit der Funktionalität einer Klasse (bzw. genauer
und in diesem Fall wichtig, der Funktionalität der Instanzen einer Klasse) nicht zufrieden ist,
will man die Implemen tierung der Klasse ändern. Als Programmiererin möchte man diese
Änderung unabhängig von der Frage, ob davon auch andere Klassen betroffen sind, durch-
führen können. Deswegen wird man d ie Änderungen auch nur an der Klasse selbst und
nicht etwa an einer ihrer Superklassen durchführen. Betrifft der Änderungswunsch eine ge-
erbte Methode, so überschreibt man diese in der betreffenden Klasse nach seinen Vorstel-
lungen. Nur wenn eine eingehende Analyse der Superklasse und all ihrer Subklassen ergibt,
dass die gewünschte Änderung für alle sinnvoll ist und den Erwartungen der Klienten ent-
spricht, kann man darüber nachdenken, die Änderung in der Superklasse durchzuführen.
Wenn nun aber die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat,
dann ist man der Freiheit beraubt, nur für sich zu entscheiden — von jeder Änderung, die
man durchführt, muss man fürchten, dass sie sich auf andere Klassen ausbreitet und den
Vertrag dieser Klassen mit ihren Klienten bricht. (Siehe auch das Fragile -base-class-Problem
in Kapitel 55). Etwas subtiler, aber genau dasselbe Problem, ereilt die Designerin von Klas-
senbibliotheken, wenn sie beschließt, das Verhalten einer Klasse zu ändern: Selbst wenn sie
sich sicher ist, dass dies innerhalb der Bibliothek keine anderen als die gewünschten Aus-
wirkungen hat, so kann sie doch nicht sicher sein, dass irgend eine Verwenderin ihrer Bibli-
othek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung
erfährt, mit der sie nicht leben kann.
Nun ist aber, wie gerade erst ( Kapitel 66) erwähnt, einer der wichtigsten Gedanken der
Objektorientierung, existierenden Code, vor allem Bibliotheksklassen, per Vererbung wie-
derzuverwenden. Wenn die Biblioth eksdesignerin aber alle relevanten Klassen (das sind üb-
licherweise gerade die konkreten, also die instanziierbaren) final deklariert hat, dann ist das
nicht möglich. Eine einfache Konvention erlaubt jedoch, diese Beschränkung zu umgehen:
In der Biblioth ek wird einfach die Klasse, von der geerbt werden soll, als abstrakt deklariert
und per Vererbung eine Subklasse davon abgeleitet, die zunächs t keine Änderungen (Dif-
ferentia ) hinzufügt, dafür aber konkret (also instanziierbar) und auch final ist. Sollte die Bib-
liotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen
Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Biblio-
thek mit den Änderung en beglücken möchte, die Änderungen in der abstrakten Superklasse
durchführen. MMaacchhee aallllee SSuuppeerrkkllaasssseenn aabbssttrraakktt..
