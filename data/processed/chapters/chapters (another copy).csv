paragraph
"52.2 Klassen als Module
Klassen sind in EIFFEL vor allem ein Mittel zur Datenkapselung („Information hiding “); alle
Instanzvariablen oder F elder, in EIFFEL Attribute (engl. attributes ) genannt, sind privat (wes-
wegen man für sie auch keine Zugriffsmodifikatoren angeben kann). Um dennoch von au-
ßen darauf zugreifen zu können, benötigt man in EIFFEL (wie in SMALLTALK ) zwingend Zu-
griffsmethoden, d ie allerdings (wie die Properties in C#) an der Aufrufstelle syntaktisch die
Form von Variablen annehmen:
ruft also eine Funktion (einen Setter ) mit dem Parameter y auf,
ruft eine auf, die einen (mit y zuweisungskompatiblen) Wert liefert (einen Getter ). Funktion
der Zugriffsmethoden ist es üblicherweise, eine entsprechende Instanzvariable zu setzen
bzw. zu lesen; sie können aber auch etwas ganz anderes tun (vgl. dazu auch das Beispiel in
Abschnitt 50.3.1 ). Insbesondere wird es dadurch möglich, den Z ugriff auf Instanzvariablen
mit Vor - und Nachbedingungen (s. Abschnitt 52.6) zu versehen. Auch bleibt der Program-
miererin so die Freiheit, etwas, das wie eine Instanzvariable aussieht, n ach außen anzubie-
ten, ohne sich (dauerhaft) darauf festzulegen, dass es sich dabei auch tatsächlich um eine
Instanzvariable handelt (die sog. Repräsentationsunabhängigkeit ). Aber das hatten wir ja
schon bei C# gesehen. Indexer gibt es in EIFFEL übrigens auch.
Die Methoden einer Klasse heißen in EIFFEL Routinen (routines ) und wer-
den logisch in zwei Gruppen unterteilt: Abfragen (queries ) und Befehle
(commands ). Abfragen geben über den Zustand von Objekten Auskunft, Befehle verändern
ihn. Es ist in EIFFEL schlechter Stil (aber wird durch die Sprachdefinition nicht verhindert),
dass eine Abfrage Seiteneffekte hat, also den Zustand des abgefragten Objekts (des Em p-
fängers) oder eines anderen verändert.
Attribute (Instanzvariablen) und Routinen (Methoden) heißen in EIFFEL zusammen Features
(entsprechend den Members in von C++ abgeleiteten Sprachen); sie sind in EIFFEL die einzi-
gen Elemente einer Klassendefinition . Insbesondere ist es in EIFFEL nicht möglich, Klassende-
finitionen zu schachteln (es gibt also keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++: Wenn
nichts weiter vermerkt wird, ist jedes Featu re öffentlich zugänglich. Da Attribute jedoch nur
über Zugriffsmethoden zugänglich sind, ist der Zustand (im Sinne der Belegung von In-
stanzvariablen; s. Kurseinheit 1, Kapitel 3) eines Objekts automatisch gekapselt: Man
braucht ja schließlich keine Zugriffsmethoden zu spezifizieren und wenn man es doch tut,
dann doch sich er nur, weil die entsprechenden Abfragen und Befehle Teil der Schnittstelle
und kein Geheimnis sind. Routinen, Abfragen
und Befehle
Zugreifbar keitsregeln
Nun wäre die Definition einer Schnittstelle (der Export von Features) in EIFFEL so aber reichlich
unspezifisch — alle Klienten einer Klasse hätten (übrigen s genau wie in SMALLTALK ) das glei-
che Bild von ihr. Das ist für größere Projekte kaum sinnvoll. Anstatt aber Zugreifbar keit an
Pakete zu binden (wie in JAVA und C#) oder an Freunde ( Friends , wie in C++), bietet EIFFEL
die Möglichkeit, einzelne Features dediziert zu veröffentlichen (zu exportieren), also unter
Nennung der Klassen, die sie sehen können solle n. (Dies schließt die Nennung der leeren
Menge ein, was dann bedeutet, dass keine andere Klasse diese Features sehen kann, also
private in anderen Sprachen entspricht). Diese Klassen müssen dann umgekehrt die Fea-
tures, die ihnen angeboten werden, nicht exp lizit importieren — das Wissen ob und der
explizite Ausdruck der Abhängigkeit ist also in EIFFEL genau invers zu dem der anderen Spra-
chen. Dabei entspricht der dedizierte Export EIFFELs in etwa dem qualifizierten Export JAVAs,
wir er dort allerdings nur für Module und nicht für Klassen definiert ist.
"
"23 Typerweiterung
Wie bereits in Kapitel 21 angedeutet, verlangt die Zuweisungskompatibilität nicht unbe-
dingt T ypäquivalenz. Tatsächlich reicht es ja, bei einer rein strukturellen (syntaktischen) Be-
trachtung, voll aus, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge
der Methoden) des Typs der linken Seite enthält, um in der Folge Typfehler z u vermeiden.
Anders ausgedrückt: Der Typ auf der rechten Seite einer Zuweisung darf eine Erweiterung
dessen auf der linken Seite um zusätzliche Methoden sein.
Die sog. Typerweiterung (engl. type extension ; extension hier im Sinne
von Erweiterung und nicht im Sinne der Ausdehnung als Gegenstück zur
Intension; vgl. Abschnitt 7.1 in Kurseinheit 2), wie sie z. B. in den Pro-
grammiersprachen MODULA -3 und OBERON (beides Nachfolger von PASCAL ) Verwendung fin-
det, sieht genau dies vor. Eine Typerweiterung des obigen Typs Büro um ein Länderkenn-
zeichen sieht dann beispielsweise wie folgt aus:
Typ InternationalesBür o
erweiterter Typ Büro
Protokoll
Der erweiternde Typ, hier InternationalesBüro , wird also relativ zu einem bereits be-
stehenden, dem erweiterten Typ (hier Büro ), definiert. Die Methodendeklarationen des er-
weiterten Typs werden dabei gewissermaßen an den erweiternden Typ vererbt ; dieser
braucht sie also nicht noch einmal zu wiederholen.
Wie man nun leicht einsieht, können Variablen, deren deklarierter Typ
Büro ist, auch Objekte vom Typ InternationalesBüro enthalten,
ohne dass dies zu Typfehlern führt, da alle Method en, die für Büro vor-
gesehen sind, auch in InternationalesBüro vorkommen.50 Das Umgekehrte ist jedoch
nicht der Fall: Wenn man einer Variable vom Typ InternationalesBüro ein Objekt vom
Typ Büro zuweisen könnte, dann hätte man immer dann ein Problem, wenn man über
diese Variable auf dessen Methoden zu Länderkennzeichen zugreifen wollte, weil diese
einen Pointer belegten Speicherplatzes ist immer gleich. Bei Variablen mit Wertsemantik hingegen
muss der Wert eines erweiterten Typen erst auf einen des Basistypen projiziert werden, d. h., die
Inhalte eventueller zusätzl icher Felder müssen unter den Tisch fallen, da für sie im für die Variable
reservierten Speicher kein Platz ist. Solange in den Typdefinitionen aber gar keine Felder vorkommen,
ist der Typ einer Variable auch nicht für die Berechnung des zur Aufnahme eines Objekts des Typs
benötigten Speichers geeignet. Das ist z. B. in STRONGTALK der Fall — und auch gut so, denn Felder
zählen nach vorherrschender Meinung zur Implementation und sind, genau wie bei abstrakten Da-
tentypen, nicht Bestandteil einer Typdefinition . Vererbung der
schlichtweg für das Objekt nicht definiert sind. Die Zuweisungskompatibilität unter Typer-
weiterung regelt der Begriff der Typkonformität.
"
"1.5.1 Inhalt
Das bezeichnete Objekt wird manchmal auch „Wert“ oder „Inhalt“ der
Variable genannt (und die Variable selbst Platzhalter des Objekts). Beson-
ders die Verwendung von „Inhalt“ ist aber gefährlich , da sie nahelegt, ein
Objekt könne zu einem Zeitpunkt nur von gen au einer Variable bezeichnet werden, so wie
ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können
aber mehrere Variablen gleichzeitig ein und dasselbe Objekt bezeichnen — die Variablen
haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (ge-
nauer: a uf die Speicherstellen, an denen die Objekte abgelegt sind; s. o.) zum Inhalt. Man
spricht deswegen auch von einer Verweis - oder Referenzsemantik von Variablen, im Ge-
gensatz zur Wertsemantik , bei der das bezeichnete Obj ekt tatsächlich auch Inhalt der Va-
riable ist.
Aus technischer Sicht entspricht einer Variable eine Stelle im Speicher.
Allerdings steht an dieser Stelle bei Variablen mit Verweissemantik nicht
das Objekt, das sie bezeichne n, sondern lediglich ein Verweis auf die Speicherstelle, an der
das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus tech-
nischer Sicht um Pointervariable n, wie man sie auch aus nicht objektorientierten Program-
miersprachen wie PASCAL oder C kennt.
Var 1 Var 2Var 3
Objekt 1 Objekt 3
ObjektspeicherVariablenspeicherVar 4
Objekt 2
Verweis - und Wertsemantik von Variablen unterscheiden sich fundamen-
tal: Unter Wertsemant ik können, solange jedes Objekt seine eigene Iden-
tität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird
aber nur den wenigsten Programmierproblemen gerecht. Da zudem die
Verweissemantik eine n wesentlich speicher - und recheneffizientere n Umgang mit Objekten
erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicher-
platz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Vari-
able vorsehen muss , ist sie in der objektorientierten Programmierung vorherrschend. In ma-
chen Sprachen , die neben Objekten auch Werte kennen, haben Variablen, die Objekte auf-
nehmen, stets Verweissemantik und Variablen, die Werte aufnehmen, stets Wertsemantik
(z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin , für jede Vari-
able getrennt festzulegen, ob sie Wert - oder Verweissemantik haben soll (so z. B. C++ und
EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsen-
tation klein ist (die also wenig Speicherplatz belegt), die Forderung nach
der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert - und
Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient.
Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der
jeweiligen Identität verbundenen Stelle im Speicher die internen Re präsentationen zu hin-
terlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis
mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird ? Das Gleiche gilt auch
für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK -Implementationen hat man dieses Problem so
gelöst, dass Variablen, die Zeichen, kleine Zahlen und die Booleschen
Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit aber
tatsächlich an mehrere n Stellen im Speicher gespeichert werden, was einen Widerspruch
zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verlo-
ren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer
Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an
die Stelle der Identität treten kann. Der P reis für diese Flexibilität ist allerdings, dass man den
Variablen nicht mehr fix Wert - oder Verweissemantik zuordnen kann — diese hängt viel-
mehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde
man Wert - bzw. Verweissema ntik eher als eine Eigenschaft des Objekts denn der d er Vari-
able ansehen; das ist jedoch ziemlich SMALLTALK -spezifisch.
ObjektspeicherObjekt 1 Objekt 3VariablenspeicherVar 1
Ob 2Var 2Var 3 Var 4
"
"8.1 Konstruktoren
Mit Hilfe von Metaklassen lassen sich nun in SMALLTALK auf natürliche Art und Weise sog.
Konstruktoren definieren. Ein Konstruktor ist eine Methode, die, auf einer Klasse aufge-
rufen, eine neue Instanz dieser Klasse zurückgibt (es handelt sich also aus Sicht der Instanz en
der Klasse um eine Klassenmethode). Wir haben bereits zwei Konstruktoren von SMALLTALK
tisch deklarierte Variablen und Method en aus JAVA etc.; diese entsprechen im wesentlichen den Klas-
senvariablen und -methoden SMALLTALK s (auch wenn in JAVA et al. Klassen keine Instanzen von Me-
taklassen sind). Beispiel
kennengelernt: Sie werden über die Selektoren new (für Objekte ohne indizierte Instanzva-
riablen) und new: (für Objekte mit indizierte n Instanzvariablen) aufgerufen.
Da Klassen selbst Objekte sind, sind new und new: Instanzmethoden der Klassen. Sie sind
in Squeak als
implementiert. Dabei sind basicNew und basicNew: eben falls Instanzmethoden der
Klasse, deren Implementierung allerdings primitiv ist (s. Abschnitt 4.3.7 in Kurseinheit 1).
Sie geben eine neue Instanz (ein neues Objekt) der Klasse, auf der sie aufgerufen wurden,
zurück. Da durch basicNew und basicNew: alle Instanzvariablen der erzeugten Objekte
den Wert nil zugewiesen bekommen, wird auf den neuen Objekten, bevor sie (mittels ^)
zurückgegeben werden, noch die Methode initialize aufgerufen, die eine Instanzme-
thode des neuen Objekts ist und die die Instanzvariablen je nach Klasse , in der die Methode
definiert ist , anders belegt.
"
"8 Metaklassen
Da in SMALLTALK auch eine Klasse ein Objekt ist, kann die Klasse selbst, genau wie alle an-
deren Objekte, Instanzvariablen und -methoden haben. Aber wo werden diese definiert?
Der Analogie der Objekte , die Instanzen der Klasse sind, folgend müsste das in der jeweili-
gen Kl asse der Klasse, also der Klasse, von der die Klasse (als Objekt) eine Instanz ist, erfol-
gen. Und so ist es tatsächlich auch. Beispiel
Zunächst könnte man annehmen, dass alle Klassen Instanzen einer spezi-
ellen Klasse, nennen wir s ie Class , sind. Jede Klasse hätte dann (als In-
stanz dieser Klasse) die Instanzvariablen und Methoden, die in Class definiert sind. Insbe-
sondere hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden. Dies scheint
zunächst auch sinnvoll, denn be i den Klassen handelt es sich ja um Objekte derselben Art,
nämlich einheitlich um Klassen.
Es stellt s ich dann die Frage, welche die Instanzvariablen und Methoden, die alle Klassen
gleichermaßen charakterisieren, sein könnten. Es könnte z. B. jede Klasse e ine Instanzvari-
able haben, die alle von der Klasse instanziierten Objekte enthält, sowie eine weitere, die
diese Objekte zählt.31 Eine typische Methode jeder Klasse wäre z. B. new, die eine neue
Instanz dieser Klasse zurückgibt. Was aber, wenn man weitere E igenschaften (Instanzvari-
ablen oder Methoden) für eine Klasse haben möchte, die diese nicht mit allen anderen teilt?
Was, wenn man eine Methode wie z. B. new für eine Klasse anders definieren will als für
andere? Im Fall von new z. B. ist es denkbar, dass man sie für bestimmte Klassen so um-
schreiben möchte, dass die Instanzvariablen der neu erzeugten Instanzen bestimmte Start-
werte zugewiesen bekommen (so wie die eine oder andere es vielleicht von den Kon-
struktoren von C++, JAVA oder C# schon kennt und wie es beim Beispiel mit Stack oben
natürlich gewesen wäre).
Tatsächlich hat die Programmierpraxis gezeigt, dass es günstig ist, wenn
jede Klasse (als Inst anz) ihre eigenen Instanzvariablen und Methoden be-
sitzt und wenn die Programmiererin diese jeweils frei bestimmen kann,
ohne dabei gleichzeitig an andere Klassen denken zu müssen. Um dies zu ermöglichen,
muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Metho-
den nur für sie angelegt werden können. Und gena u das ist in SMALLTALK der Fall.32
Zu jeder Klasse des SMALLTALK -Systems gehört nämlich genau eine Klasse,
von der erstere (und nur diese) eine Instanz ist. Diese zweite Klasse wird
Metaklasse der ersten genannt. Da eine 1:1 -Beziehung zwischen Klas-
sen und ihren Metaklassen besteht, ist es nicht sinnvoll, ihre Benennung den Progra mmie-
rerinnen zu überlassen; sie wird in SMALLTALK stets durch den Ausdruck <Klassenname>
class , also beispielsweise Stack class , bezeichnet. Daraus folgt bereits, dass die Pro-
grammiererin die Metaklasse nicht selbst anlegen muss (denn dabei müsste sie ja auch einen
Namen vergeben) — sie wird vielmehr automatisch mit angelegt, wenn die Programmiererin
eine neue Klasse definiert.
Im Prinzip ist die Definition einer Metaklasse genauso aufgebaut wie die
einer normalen Klasse: Sie besteht aus der Angabe einer Menge von be-
vor der Veröffentlichung von SMALLTALK -80 verlassen hatte, ist selbst einer der gr ößten Kritiker dieser
Festlegung. Tatsächlich ist sie, wie Sie noch merken werden, nicht immer ganz leicht zu durchblicken. Klassen als Instanzen
nannten Instanzvariablen und einer Menge von Instanzmethodendefinitionen. Lediglich in-
dizierte Instanzvariablen sind nicht vorgesehen und der Klassenname kann wie gesagt nicht
frei angegeben werden. Dem Schema aus Abschnitt 7.2 folgend sähe eine Metaklassende-
finition wie folgt aus:
Klasse <Klassenname> class
benannte Instanzvariablen <Liste von Instanzvariablennamen>
Instanzmethoden
<Liste von Methodendefinitionen>
Im konkreten Fall der zweiten Implementierung von Stack oben fände man beispielsweise
die folgenden Einträge:
Klasse Stack class
benannte Instanzvariablen
Instanzmethoden
Für die Implementierung der Methode new fehlt uns noch etwas; sie wird im nächsten Ab-
schnitt nachgeliefert. Hier ist wichtig, dass Sie verstehen, dass new eine Instanzmethode der
Metaklasse Stack class ist und damit das Verhalten der Klasse Stack bestimmt und
nicht ihrer Objekte.
Aufgrund der bestehenden 1:1 -Beziehung zwischen Klassen und Me-
taklassen werden diese in SMALLTALK nicht getrennt voneinander defi-
niert, sondern in einem gemeinsamen Schema. Jede Klassendefinition
verfügt demnach neben den Abschnitten zur Deklaration der Instanzvari-
ablen und zur Definition der Methoden auch noch über zwei Abschnitte für die entspre-
chenden Angabe n zur ihrer Metaklasse, die Angabe der sog. Klassenvariablen und -me-
thoden : Es s ind dies die Variablen bzw. Methoden, die den Klassen als Instanzen ihrer Me-
taklassen zugeordnet sind. Das Schema
Klasse <Klassenname>
Klassenvariablen <Liste von Klassenvariablennamen>
Klassenmethoden
<Liste von Methodendefinitionen>
benannte Instanzvariablen <Liste von Instanzvariablennamen>
indizierte Instanzvariablen <ja/nein>
Instanzmethoden Schema einer
<Liste von Methodendefinitionen>
besorgt also nicht nur die Definition der genannten Klasse, sondern gleichzeitig auch die
ihrer Metaklasse; es ersetzt damit die zwei zuvor präsentierten getrennten Schemata. Klas-
senvariablen sind übrigens relativ zu den Instanzen der Klassen global; sie b eginnen deswe-
gen mit einem Großbuchstaben. Klassenmethoden schreibt man jedoch wie Instanzmetho-
den klein. Beachten Sie, dass Klassenvariablen nur einmal pro Klasse angelegt werden —
sie sind also für alle Instanzen einer Klasse dieselben.33
Ein Beispiel für eine Klassenvariable ist Dependents Fields in der Klasse
Object (zu ihrer Verwendung s. Abschnitt 14.3), eins für eine Klassenmethode ist pi in der
Klasse Float :
Sie retourniert (den Inhalt der) Klassenvariable Pi und ist, da sie eine Klassenmethode ist,
allen Instanzen der Klasse Float zugeordnet. Dazu, wie der Wert in Pi hineinkommt , s.
Abschnitt 8.2.
Wir sehen also, dass die Bezeichnungen Klassenvariable bzw. -methode
und Instanzvariable bzw. -methode eigentlich nur relative Bedeutung haben, da es sich in
beiden Fällen um Variablen und Methoden handelt, die Objekten zugeordnet sind. Da man
von Instanzen einer Klasse a us aber auch häufiger auf die Variablen und Methoden ihrer
Klassen zugreift, ist es guter Brauch (und vermeidet umständliche Formulierungen), stets die
langen Bezeichnungen zu führen. Zudem gibt es neben Instanz - und Klassenvariablen ja
auch noch andere Va riablentypen ( formale Parameter und temporäre Variablen ), so dass die
Verwendung von „Variable“ allein meist mehrdeutig wäre. Lediglich bei Methoden hat es
sich eingebürgert, anstelle von Instanzm ethoden nur von Methoden zu sprechen. Wenn der
Kontext nichts anderes nahelegt, können Sie dann immer davon ausgehen, dass Instanzme-
thoden gemeint sind.
"
"62.1 Verwendung von Abkürzungen
Abkürzungen sind nicht grundsätzlich zu vermeiden — im Gegenteil, wenn sie etabliert sind
und man davon ausgehen darf, dass eine Leserin des Programms sie kennt, ist ihre Verwen-
dung (aus oben angeführten Gründen gegen zu lange Namen) sogar angezeigt. Auf haus-
gemachte Abkürzungen, deren Bedeutung man nur selbst kennt, s ollte man hingegen ver-
zichten.
Bei der Programmierung mit JAVA und anderen typisierten objektorien-
tierten Programmiersprachen begegnet man häufig dem Phänomen, dass
Typen und Variablen gleich heißen, s ich nur in der Groß - bzw. Kleinschrei-
bung ihres Anfangsbuchstabens unterscheiden. Ein typisches Beispiel dafür ist das folgende:
In diesen Fällen, wenn es keinen besseren Namen für die Variable gibt, ist es vollkommen
legitim, eine Abkürzung für den Variablennamen zu wählen, insbesondere dann, wenn die
Sichtbarkeit der Variable auf die unmittelbare Umgebung der Deklaration beschränkt ist:
oder
sind also leg itim. Sobald dies jedoch nicht der Fall ist (typischerweise schon bei der Deklara-
tion von Instanzvariablen), sollte der lange Name bevorzugt werden. Dies gilt auch für den
Fall, dass der Typ der Variable aus dem Kontext abgeleitet werden kann und deswegen nicht
mehr angegeben wird ( Typinferenz ).
"
"10 Vererbung und abstrakte Klassen
Generalisierung und Spezialisierung wie oben dargestellt sind eher theoretisch motivierte
Konzepte. In der Programmierung geht man jedoch häufig, wie im obigen Beispiel von Pin-
guinen schon anged eutet, an praktischen Gesichtspunkten orientiert vor. So haben denn
auch nicht Generalisierung und Spezialisierung die Entwicklung objektorientierter Program-
miersprachen geprägt, sondern abstrakte Klassen und Vererbung . Diese pragmatische Ori-
entierung ist jedoch nicht ohne Probleme und so werden uns die Überlegungen zu Genera-
lisierung und Spezialisierung spätestens in Kurseinheit 3 wieder begegnen.
"
"40 Interfaces
Modul und Interface sind eigentlich ein Begriffspaar — das eine lässt sich nur mithilfe des
anderen definieren. Die Interfaces in JAVA sind jedoch durchaus eigenständige Konstrukte,
die inzwischen weit über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle
zu definieren, hinausgehen. Auch wenn JAVAs Interfaces Vorgänger haben , betrachte ich
sie doch als einen von JAVAs wichtigsten Beiträgen für die Entwicklung objektorientierter
Programmiersprachen.
zwischen Klassen jenseits derer öffentlichen und privaten Schnittstellen (s. Abschnitt 51.3 in Kursein-
heit 5).
"
"15 Ein- und Ausgabeströme
Ein- und Ausgabeströme spielen in der konventionellen (objektorientierten) Programmie-
rung eine wichtige Rolle, da über sie Eingaben in und Ausgaben aus dem System erfolgen,
und zwar sowohl von/zu der Benutzerin als auch vom/zum Dateisystem. Nun ist SMALLTALK
aber als fensterbasiertes, grafisches System konzipiert, das der zeilenorientierten und text-
basierten Ein - und Ausgabe der damals vorherrschenden Programme eine Alternativ e ge-
genüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien
nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden. Da ist es nur
konsequent, dass die Ein - und Ausgabe über Streams wenig Gewicht hat.
In SMALLTALK haben Streams somit zunächst auch eine andere Aufgabe:
Sie erlauben eine Form des Zugriffs auf Collections , die das Collection -
Protokoll nicht bieten kann, nämlich
 den sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen
(bei den Iteratoren wird immer in einem Schritt, oder in einer Anweisung, über die
ganze C ollection iteriert) sowie
 den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Col-
lection durch mehrere andere Objekte.
Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die
zu liefern ist die F unktion von Streams.
Streams werden zunächst immer auf einer Collection erzeugt, deren In-
halt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenme-
thode on:, die als Parameter eine Collection erhält. Das Basis protokoll auf Instanzebene
enthält die folgenden Methoden:
Für frei positionierbare Streams kommt noch das Protokoll zur Änderung des Zeigers hinzu:
Für peek ist die freie Positionierbarkeit notwendig, weil man dazu erst das nächste Element
anspringen und dann wieder einen Schritt zurückgehen muss .
Da ein Stream (wie eine Collection) eine Menge von Objekten repräsen-
tiert, möchte man darüber (genau wie über eine Collection) iterieren kön-
nen. Kein Problem:
Außerdem wird nat ürlich zwischen (nur) lesbaren und schreibbaren Streams unterschieden.
Erst eine weitere Kategorie von Streams operiert nicht auf Collections,
sondern auf externen Daten. Dazu gehören insbesondere die File streams . In SMALLTALK -80
wurde mit den Klassen FileDirectory , File und FilePage (die selbst keine Streams
sind) ein eigenes Dateisystem geschaffen; die meisten heute gebräuchlichen Implementie-
rungen nehmen jedoch eine Abbildung auf das Betriebssystem vor, für das sie geschrieben
wurden . Man erkennt hier noch sehr schön, welche Funktion SMALLTALK ursprünglich zuge-
dacht war: die der einzigen Software auf einem Computer.
Besonders in SQUEAK gibt es noch zahllose weitere Streams, so u. a. für Multimedia -Aufga-
ben; insgesamt unterscheiden sic h die verschiedenen SMALLTALK -Dialekte bei der Handha-
bung von Streams zum Teil erheblich, weswegen wir hier auch nicht weiter darauf einge-
hen.
"
"20 Typdefinitionen und deren Verwendung
Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraus set-
zung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (also beispiels-
weise der Verwendung von Nicht -Zahlen in arithmetischen Ausdrücken), muss bekannt sein,
welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von
SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden w erden können, schnell
gefasst : Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein
Protokoll (s. Abschnitt 4.3.8 in Kurseinheit 1). Ein solches Protokoll definiert einen Typ: Er
umfasst die Menge der Objekte, die über das Protokoll verfügen.
Wenn man nun eine Variable mit einem solchen Protokoll als Typ typisiert und das Pro-
gramm typkorrekt ist, dann ist garantiert, dass jede Methode, die im Protokoll enthalten ist
und die auf der Variable aufgerufen wird, auc h für den Inhalt der Variable, das referenzierte
Objekt, definiert ist. Typfehler, also Fehler der Sorte „ does not understand “ (s. Abschnitt
4.3.2 in Kurseinheit 1), treten dann nicht mehr auf.
Nun kommen in Protokollen aber selbst Variablen vor, nämlich die forma-
len Parameter der Meth oden, die das Protokoll ausmachen. Außerdem ist
eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Ob-
jekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle
definieren also nicht nur Typen , sie verwenden auch selbst welche, nämlich indem sie die
Typen der Ein- und Ausgabe objekte spezifizieren. Ein einfaches Beispiel für eine Typdefini-
tion, die selbst Typen verwendet, ist die folgende:
Wie schon bei einer temporären Variable, stehen die Typannotationen von formalen Para-
metern in STRONGT ALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht
allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kenn-
zeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer
Methode wird durch ein vorangestelltes Dach ( ^) gekennzeichnet und folgt auf den letzten
Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Method e
ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zu-
rück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann
der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo -
Typvariable (entsprechend der Pseudovariable self , deren Typ sie darstellt).
Falls Sie sich wundern, dass obige Zeilen kein Schlüsselwort zur Einleitung
der Typdefinition beinhalten: STRONGTALK ist, genau wie SMALLTALK , ein
interaktives, browser -gestütztes System, in dem Typen in Formulare eingetragen und nicht
in Textdateien spezifiziert werden. Gleichwohl f ällt auf, dass innerhalb der Typdefinition in Typen als Teile von
den spitzen Klammern (also da, wo Typen stehen sollen) keine Typdefinition auftauchen,
sondern Namen. Und tatsächlich wird in STRONGTALK jeder Typ benannt (in seiner Typdefi-
nition mit einem Namen versehen). Im folgenden werden Typen, ähnlich wie Klassen, in
tabellarischer Form notiert. Der Typ Person etwa mit obigem Protokoll liest sich dann wie
folgt:
Typ Person
Protokoll
Selbsttestaufgabe 20.1
Definieren Sie den Typ Boolean gemäß obigem Schema!
In STRONGTALK ist die Protokollbildung der einzige sog. Typkonstruktor ,
d. h., das einzige Sprachkonstrukt, mit dem man neue Typen definieren kann. Andere Pro-
grammiersprachen sehen ein reichhaltigeres Angebot vor: In PASCAL beispiel sweise gibt es
die Typkonstruktoren record , array of , set of , file of , Zeiger auf ( ^) sowie Aufzäh-
lungen ( enumerations ) und Teilbereiche ( ranges ). In C++ gibt es u. a. class und struct
(entsprechend record in PASCAL ), JAVA, C# und EIFFEL bieten auch jeweil s verschiedene
Typkonstruktoren an. Für eine puristische Sprache wie SMALLTALK bzw. STRONGTALK reicht
jedoch einer vollkommen aus.
Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen,
deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden
müsste . Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine
Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der
Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das
wirft natürlich die Frage auf, wie man T ypen unter zwangsläufiger Selbstbezüglichkeit über-
haupt eine Bedeutung beimessen kann.
"
"52.5.3 Die dynamische Komponente
Bei allen Bemühungen, für EIFFEL ein möglichst „wasserdichtes“ Typsystem vorzulegen und
dabei so viel wie möglich zur Übersetzungszeit zu erledigen, bleibt e s natürlich auch in EIF-
FEL-Programmen nicht aus, dass man in einen Container (eine Variable oder eine Collection)
Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein
Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man
die dazu notwendige Fallunterscheidung dem dynamischen Binden (einem dynamisch ge-
bundenen Methodenau fruf) überlassen wollen; manchmal ist es einfach einfacher (und bes-
ser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode ent-
sprechend verzweigt.
Solche Typtests werden in EIFFEL von einem sog. Zuweisungsversuch (engl.
assignment attempt ) übernommen, der bei mangelnder (dynamisch fest-
gestellter) Zuweisungskompatibilität einfach void (das Äquivalent von nil in SMALL TALK
und null in JAVA) zuweist:
ergibt nie einen Typfehler, sondern führt höchstens dazu, dass a void zugewiesen wird. Es
bleibt dann die Aufgabe der Programmiererin , a nach der Zuweisung zu kontrollieren. Es
entspricht dies direkt dem as aus C#, dem dynamic_cast<T>(x) aus C++ sowie dem
JAVA-Konstrukt
oder auch kryptischer
wobei A der Typ von a sei (man beachte das ärgerliche, aber in C -artigen Sprachen notwen-
dige Semikolon vor dem Else). Explizite Type casts gibt es in EIFFEL nicht; sie können also
auch keine Laufzeitfehler verursachen. Der Zuweisungsversuch erfüllt aber weitgehend die
Funktion einer Typumwandlung, denn er ist nur erfolgreich, wenn die rechte Seite zuwei-
sungskompatibel mit der linken ist, was per Definition nur dann der Fall ist, wenn die rechte
Seite ein Objekt eines Subtyps (einschließlich Gleichheit) der linken Seite ha t. Es wird hier
allerdings die Typumwandlung immer mit einer Zuweisung verbunden; man braucht also
u. U. eine temporäre Variable, die man sich sonst hätte sparen können. Dass der Zuwei-
sungsversuch in EIFFEL anders als der Down cast in JAVA keinen Laufzeitf ehler verursachen
kann, ist wenig tröstlich, denn der Wert void in einer Variable kann es natürlich schon; in
Wirklichkeit wird hier lediglich ein Type cast error gegen eine Null pointer exception ge-
tauscht.
Die Typumwandlung w ird in EIFFEL aber auch noch für etwas anderes ge-
braucht, nämlich für das Binden von Aufrufen kovariant redefinierter Me-
thoden. Da EIFFEL ja, wie oben beschrieben, polymorphe CAT -Calls verbieten muss , diese
aber gleichwohl notwendig sein können, hat man nur die Möglichkeit, die dynamische Bin-
dung programmatisch zu emulieren. Und dafür braucht man Zuweisungsversuche, wie fol-
gendes Beispiel zeigt:
Nun ja. emulierte
"
"60 Das Problem der mangelnden Eignung
Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gern dem Hammer-
prinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle
Objekte genannt, zur hierarchischen Strukturierung eines Programms verwendet. mangelnde
hierarchische (De -)
Kom ponierbarkeit
von Klassen
Komponenten in
objektorientierte n
Programmier -
sprachen
To a woman with a hammer, everything looks like a nail.
Aufgaben sind aber gleichermaßen zur Lösung per objektorientierter Programmierung ge-
schaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische
Programmiersprachen weit besser geeignet; aber auch viele Batch - und Scripting -Probleme
(in denen lediglich vorhandene Programme mit den richtigen Daten versorg t und angesto-
ßen werden müssen) haben eher imperativ -prozeduralen den n objektorientierten Charak-
ter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Prob-
leme, die einen hohen algorithmischen Anteil und vergleichsweise simple Datenstrukturen
verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapi-
tel 56 erwähnt, verlangt die „gute“ objektorientierte Programmierung, den Code (die Funk-
tionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet.
Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen
müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor
allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszufüh-
ren sind, in einem Stück festgehalten wird ( Lokalitätsprinzip !) und nicht auf zig Klassen auf-
geteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an
der Str uktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist,
liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer
mit einem Abwägungsproblem zu tun. Wenn man sich für di e objektorientierte Program-
mierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man
sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachzu-
vollziehende Weise hin - und hergeschickt oder sind global, was auch kein Idealzustand ist.
Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein .
Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängeri nnen mit ihrer
großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie
man ein einzelnes Problem lösen kann , überfordern . C++ ist ein gutes Beispiel dafür. Funktion ü ber Daten
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in
Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entwor-
fenes Datenbankschema, genau wie ein gut entworfen es Klassenmodell, eine Strukturie-
rung der Anwendungsdomäne wider , doch tun es beide mit ganz untersc hiedlichen Mitteln:
Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver
Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme
zeigerbasiert. Beziehungen werden in relationalen Datenbanke n über die Verwendung glei-
cher Werte in Schlüsseln und Fremdschlüsseln sowie über Join -Operationen hergestellt, in
objektorientierten Programm über Referenzen und deren Dereferenzierung (Navigation ).
Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch, gibt
es in relationalen Datenbanken gar nicht .94 Sollen also relationale Daten durch objektorien-
tierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt
anpassen und damit ein Gutteil dessen, was Objektorientierung ausmacht, aufgeben, wes-
wegen man hier auch häufig von einem Impedance mismatch spricht (das entsprechende
deutsche Wort „Fehlanpassung“ ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine
objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der ge-
wöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz - und Syn-
chronisationszwecken (bei Mehr benutzer innensystemen ) in der Datenbank abgelegt. Die
Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei
heute meisten s durch ein sog. Persistenzlayer erreicht — das Programm selbst muss sich um
die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier
die Frage stel len, warum man einer relationalen Datenbank den Vorzug vor einer objektori-
entierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale
Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorien-
tierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind
die Daten häufig der eigentliche Wert eines Softwaresystems .
Zuletzt, und beinahe paradoxerweise, ist auch die GUI -Programmierung
nicht unbedingt ein Heimspiel für die objektorientierte Programmierung.
Zwar kann man für die verschiedenen Arten von GUI -Elementen noch ganz gut Klassen
angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten
Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss : Zwei
Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des ange-
zeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt wer-
den. Da sich die Instan zen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für
verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode an-
zugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über
einen Bloc k, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klas-
sen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den
tierte Anleihen. Ich bin mir jedoch nicht sicher, ob diese jemals in der Praxis angekommen sind. objekt -relationaler
Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger
(Dele gates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte
Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 be-
merkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug
feiert) .
"
"19 Deklaration, Definition und Verwendung von Pro-
grammelementen
Programme bestehen aus Schlüsselwörtern und -zeichen sowie aus Pro-
grammelementen, deren Namen, die sogenannten Bezeichner, frei vergeben werden kön-
nen. Viele Programmiersprachen verla ngen, dass man diese Programmelemente vor der ers-
ten Verwendung vereinbart oder deklariert. Durch eine solche Deklaration gibt man dem
Compiler den Bezeichner bekannt; er kann ihn in der Folge wiedererkennen und mit der
Deklaration in Verbindung bringen.
Bei der Definition wird dem Bezeichner das zugeordnet, wofür er steht.
Im Falle einer Varia ble ist das eine bestimmte Stelle im Speicher, die ge-
nügend Platz bietet, um den Wert der Variable aufzunehmen. Im Falle einer Methode sind
es die Anweisungen, die durch die Methode zusammen gefasst werden. Nicht selten (aber
immer abhängig von der Programm iersprache) erfolgen Deklaration und Definition in einem statische Typprüfung
Ausdruck. In solchen Fällen spricht man von Deklaration beziehungsweise Definition des
Programmelementes in Abhängigkeit davon, was man gerade meint. Bei Variablen ist die
Definition in der Regel implizit und aus der Deklaration ableitbar (der Speicherplatz wird
vom Compiler automatisch zugewiesen), so dass man hier häufig Deklaration meint, selbst
wenn man Definition sagt. Bei Methoden hingegen ist die Unterscheidung essentiell: I n ihrer
Deklaration wird ihre Signatur , das ist ihr Name (in SMALLTALK der Nachrichtenselektor) und
die Lister der formalen Parameter , bekanntgegeben , in ihrer Definition wird der Signatur
der Methodenrumpf, also die Folge der mit der Methode verbundenen und bei einem Auf-
ruf auszuführenden Anweisungen, zugeordnet. Von der Definition einer Variable zu unter-
scheiden ist übrigens ihre Initialisierung , bei der ihr (der dafür vorgesehenen Speicherstelle)
ein Anfangswert zugewiesen wird; in manchen Kontexten (insbesondere im Kontext der
Programmanalyse) ist mit Variablendefinition aber auch die Zuweisung eines Werts an eine
Variable ganz all gemein gemeint.
Deklaration und Definition dienen letztlich nur einem: der Verwendung.
Die Verwendung eines Programmelements äußert sich darin, dass sein
Name, der Bezeichner, im Programmtext angeführt oder referenziert
wird. An der Stelle der Verwendung steht eine Variable für den Wert, den sie hat (bzw.,
wenn sie auf der linken Seite einer Zuweisung auftaucht, haben soll). Der Bezeichner einer
Methode steht hingegen meistens für ihren Aufruf (in manchen Sprachen durch ein Schlüs-
selwort eingeleitet), selt ener auch für einen Zeiger auf die Implementierung.
Variablendeklarationen haben Sie in SMALLTALK bislang an zwei Stellen
gesehen: als forma le Parameter in Methodendeklarationen und als tem-
poräre , lokale Variablen in Methodenrümpfen . Im Beispiel
stecken die Deklarationen von a und b als formaler Parameter und von c als temporäre
Variable. Weitere Formen der Deklaration werden Sie im Verlauf dieses Kurstextes noch zu
Gesicht bekommen.
In untypisier ten Sprachen werden Variablen ohne Angabe eines Typs (wie
z. B. in SMALLTALK ) oder gar nicht (etliche Skriptsprachen und z. B. BASIC)
deklariert. Letzteres hat den erheblichen Nachteil, dass Variablen durch
ihre erste Verwendung quasi implizit deklariert ( und damit angelegt) wer-
den, was bei Schreibfehlern dazu führt, dass man plötzlich zwei Variablen anstatt einer hat,
wobei die eine mit der anderen nichts zu tun hat. Eine solche Einladung zu Programmier-
fehlern sollten Sie als diejenige, die die Entscheidun g für die Auswahl einer Sprache zu tref-
fen hat, stets ablehnen. Deklaration und
"
"44.2 Typtests
Laufzeitfehler der obigen Art vermeidet man in JAVA mit Hilfe sogenannter Typtests, die
man vor einer Typumwand lung durchführt. Das dazugehörige Schlüsselwort heißt
instanceof :
bilden die typsichere Variante der Typumwandlung. Es bleibt allerdings an der Programmie-
rerin hängen, zu sagen, was passieren soll, wenn der Wert von o nicht den geforderten Typ
(hier String ) hat.
"
"20.2 Verwendung definierter Typen
Definierte Typen können in Programmen verwendet werden, in STRONGTALK bei der Dekla-
ration von (anderen) Typen, von Variablen, von Blöcken und von Methoden. Man spricht
dann von einer Typisierung der deklarierten Programmelemente. Die Verwendung in
Typdefinitionen haben Sie ja oben bereits kennengelernt, die Verwendung in Methoden
verläuft analog. Variablen (Instanzvariablen, tem poräre Variablen etc.) werden in STRONG-
TALK genau wie formale Parameter (die ja auch Variablen sind) typannotiert, nämlich durch
Hintanstellung eines in spitzen Klammern eingeschlossenen Typnamens. Bei Blöcken taucht
der Rückgabetyp im selben Segment wie die formalen Parameter auf, also vor dem Sep ara-
tor |. Die vollständig typannotierte Klasse Stack aus Abschnitt 8.2 sieht in STRONGTALK
beispielsweise so aus:
Klasse Stack
benannte Instanzvariablen stackcontent <Array>
stackpointer <Integer>
indizierte Instanzvariablen nein
Instanzmethoden
Ein Beispiel für einen typisierten Block finden Sie in Abschnitt 29.3, Codezeile 950.
"
"29.3 Parametrischer Polymorphismus und Inklusionspolymorphie
Nun war di e Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch
schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymor-
phie (Subtyping). So würde es zunächst ausreichen, wenn Collection wie folgt definiert
wäre:
Typ Collection
Protokoll
An die Stelle der Typvariable E tritt also der (konkrete) Typ Object . Da in
STRONGTALK alle Typen Subtypen von Object sind, kann man jedes belie-
bige Objekt in einer solchen Collection speichern. In der Klasse Person , die Collection
verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter)
deklariert. Das obige Prog rammfragment (Zeilen 936–940) könnte dann auch beinahe so
bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt ein en Typfehler, da das Er-
gebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine
Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object
nach Person , ein Down cast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon
abhängig, was wirklich in der Collection drinsteckt, und das ka nn der Compiler nicht (oder
nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet
also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphis-
mus behebt.
Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel.
Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer
Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu
speichern. Solche heterogenen Collections kommen aber in der Praxis im-
mer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von
Collections nicht auf Inklusionspolymorphie verzichten wird. Zum anderen wird die erhöhte
Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumin-
dest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit
einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer
geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft.
Dies verlangt nach Erklärung.
Stellen Sie sich einen Collection -Typ MyCollection vor, dessen Werte solche Collections
sein sollen, deren Elemente sortiert und summiert werden können. Dieser Typ sei ein Subtyp
von Collection und verfüge weiterhin über entsprechende Metho den sortieren und
summieren :
Typ MyCollection
Typvariablen E
Supertyp Collection[E]
Protokoll
Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection , dass auf den Ele-
menten eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit
auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Me-
thode summieren , dass sich aus den Elementen einer solchen Colle ction ein Wert aggre-
gieren lässt, der vom Typ Number oder einem Subtyp davon ist. Man kann daraus schließen, Notwendigkeit von
dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müs-
sen, die einen solchen Wert zurückliefern. Und so würde auch ei ne Implementierung der
Methode summieren in etwa wie folgt aussehen:
Das aber verlangt, dass der Elementtyp von MyCollection Number oder ein Subtyp davon
sein muss , da sonst die Zuweisung an den formalen Blockparameter element nicht zulässig
wäre. Insbesondere würde das Codefragment
zu einem Typfehler führen, weil in Zeile 950 einer Variable vom Typ Number ein Objekt vom
Typ String zugewiesen wird. Nun kann aber die Definition des parametrischen Typs
MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition
durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren
Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefini-
tion, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.
Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicher-
heit, dass alle Typen, die für E eingesetzt werden können, bestimmte Ei-
genschaften haben, im gegebenen Beispiel, dass sie sortierbar und ad-
dierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, son-
dern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable statt-
findet, nämlich bei der Verwendung (der Instanziierung ) der parametrischen Typdefinition
in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Poly-
morphismus, der im n ächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem
anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.
Unter den Typdefinitionen
Protokoll
und den Variablendeklarationen
ist die Zuweisung
sicher zulässig. Nun könnte man annehmen, dasselbe sei auch für
der Fall. Dahinter verbirgt sich aber die Frage, ob G[B] ein Subtyp von G[A] ist, ob sich also
die Subtypenbeziehung von B zu A auf entsprechende Typinstanzen vom selben parametri-
schen Typ überträgt. Intuitiv scheint dies der Fall, zumal beispielsweise
oder
aufgrund der Subtypenbeziehung von B zu A kein Probl em darstellen sollte (aus Sicht der
Typprüfung entspricht dies ja den Verhältnissen der Zuweisung aus Zeile 957). Nun ist aber
nach den Regeln der statischen T ypprüfung auch
erlaubt. Da ga aber nach der Zuweisung aus Zeile 958 lediglich ein Alias
für das von gb bezeichnete Objekt ist, ga also auf ein Objekt vom Typ
G[B] verweist und dieser als Parametertyp von x: nur B zulässt, handelt
es sich bei obigem Methodenaufruf um eine Typverletzung . Der Fehler
liegt jedoch nicht im Methodenaufruf, der in der Tat typkorrekt ist, son-
dern vielmehr in der Zuweisung aus Zeile 958: G[B] ist eben kein Subtyp
von G[A] , nur weil B ein Subtyp von A ist (man beachte die Parallelität zu dem in Kapitel 25
beschrieb enen Problem). Dieser Trugschluss ist einer der häufigsten Anfängerinnenfehler .
Selbsttestaufgabe 29.1
Prüfen Sie nach demselben Schema wie oben, ob G[A] ein Subtyp von G[B] sein darf.
Merken Sie sich also unbedingt, dass parametrischer Polymorphismus die Subtypenbezie-
hung seiner tatsächlich en Typparameter nicht auf die durch Instanziierung erzeugten Typen Subtypenbeziehung
überträgt. Dies wird auch in Abschnitt 29.5 noch eine besondere Rolle spielen. Vor diesem
Hintergrund beinahe paradox erscheint, dass sich Subtyping jedoch dazu einsetzen lässt,
das oben beschriebene Problem mit der „inneren Typsic herheit“ von parametrisch definier-
ten Typen zu lösen.
"
"2 Beziehungen
Kein Objekt ist eine Insel. Ganz im Gegenteil: Damit Objekte eine Bedeutun g haben, müssen
sie mit anderen in Beziehung stehen. Das Objekt „1“ beispielsweise ist ohne Bedeutung,
solange es nicht eine bestimmte Eigenschaft eines anderen Objekts beschreibt, wie z. B. die
Hausnummer eines Hauses oder die Anzahl der Elemente eines Ar rays. Tatsächlich werden
die meisten Objekte eines Systems erst durch ihre Beziehungen zu anderen zu etwas Nütz-
lichem . Ein Objekt, das beispielsweise eine Person repräsentiert, macht den String „Hans
Mustermann“ zum Namen der Person, sobald er mit der Pers on in entsprechender Bezie-
hung steht; umgekehrt wird für die Benutzerin des Systems die Person erst über den Namen
identifizierbar.
Tatsächlich wir d, wie bereits eingangs dieser Kurseinheit erwähnt, in der
objektorientierten Programmierung sämtliche Information als ein Ge-
flecht von Objekten dargestellt. Dieses Geflecht ka nn
1. navigiert werden, um von einem Datum (Stück Information) zu einem anderen zu
kommen, oder auch
2. manipuliert werden, um die repräsentierte Information zu verändern.
Das Datenmodell der objektorientierten Programmierung ähnelt damit stark dem Netzwerk-
modell , das ebenfalls ein navigierendes ist, das vor einigen Jahrzehnten einmal die Grund-
lage große r Datenbankmanagementsysteme war, das aber schnell vom relationalen Daten-
modell verdrängt wurde und das erst heute, im Zuge der Einführung von objektorientie rten
Datenbanken, wieder an (theoretischer) Bedeutung gewinnt. Information als
Objekt 1
Objekt 2Objekt 3
Objekt 4
In der objektorientierten Programmierung werden Beziehungen zwischen
Objekten über Verweise hergestellt, durch deren Verfolgung man von ei-
nem Objekt zum nächsten gelangen, eben „navigieren“ kann. Das Besondere dieser Ver-
knüpfung ist, dass sie stets gericht et ist: Dass man von einem Objekt zum nächsten navigie-
ren kann, heißt nicht, dass man auch wieder zurückkommt. Dazu ist dann ein Zeiger in
Gegenrichtung nötig.
Nun enthalten ja Variablen ebenfalls Verweise. Wer also Zugriff auf die Variable hat, hat
damit auch Zugriff auf das referenzierte Objekt — und ist somit mit dem Objekt verknüpft.
Was noch fehlt, ist, dass Variablen Objekten so zugeordnet werden, dass nur noch die Ob-
jekte Zugriff darauf haben, und schon kann man auf einfache Weise Beziehungen ausdrü-
cken.
"
"39.2 Abhängigkeiten zwischen Modulen
Die Aufteilung eines Programms auf Module dient vor allem dem Zweck der unabhängigen
Entwicklung der Programmteile. Damit dies erreicht wird, muss die Abhängigkeit der Mo-
dule möglichst gering ausfallen. Dabei bedeutet Abhängigkeit in der Regel Änderungsab-
hängigkeit : Wenn sich in einem Teil etwas ändert, muss sich auch im davon abhängigen
Teil etwas ändern . Sie ergibt sich regelmäßig aus einer Benutzt -Beziehung; in der objektori-
entierten Programmierung kommt jedoch noch die Vererbungsabhängigkeit hinzu . Mo-
dule, die vollkommen unabhängig voneinander sind, sind ein Indikator dafür, dass man
nicht ein Programm entwickelt, sondern mehrere — wo keine Abhängigkeiten bestehen,
da gibt es auch kein Zusammenspiel.
Abhängigkeit ist eine gerichtete Beziehung: Dass A von B abhängt heißt
nicht, dass auch B von A abhängt. Und so manifestieren sich auch in den
Aufruf auf mehr als nur dem Empfängerobjekt gedispatcht wird; vgl. dazu auch Abschnitt 12.3 in
Kurseinheit 1). Vor- und Nachteile
Klassen als Modulen der JAVA-Programmierung die zwei Richtungen von Abhängigkeit in
zwei verschiedenen Formen:
1. Dass eine Klasse von (der Schnittstelle) einer anderen abhängt, erkennt man an der
Tatsache, dass auf Objekte der anderen Klasse zugegriffen wird, was man wiede-
rum daran erkennt, dass Variablen des dazugehörigen Typs deklariert werden so-
wie, soweit sich die an dere Klasse in einem anderen Paket befindet, die Klasse oder
gleich das ganze Paket importiert wird.
2. Dass eine Klasse manche Teile ihrer Member anderen zur Benutzung anbietet und
diese damit von ihr abhängig werden können, erkennt man an der Verwendung
von anderen Zugriffsmodifikatoren als private sowie an der Implementierung von
Interfaces.
In JAVA sind zirkuläre Abhängigkeiten zunächst erlaubt. Insbesondere
dürfen sich zwei Klassen (genauer: Compilation units ) wechselseitig im-
portieren. In der Softwareentwicklung ist dies jedoch ve rpönt, schon weil durch eine wech-
selseitige Abhängigkeit eine enge Kopplung dokumentiert wird, die zwischen Modulen
grundsätzlich nicht bestehen sollte. Für JAVA-Module (s. u.) sind zirkuläre Abhängigkeiten
denn auch verboten. Wenn Sie einmal in die Verlegenheit kommen sollten, selbst JAVA-
Module zu definieren, werden Sie feststellen, dass dieses Verbot eine sehr sorgfältige Pla-
nung der Modularisierung erzwingt (was für sich genommen schon einen Wert darstellt).
Vererbungsabhängigkeiten zwischen Klassen, die in JAVA durch Verwendung des Zug riffs-
modifikators protected und der Annotation @Override zumindest angedeutet werden
(mehr dazu in Kurseinheit 6, Kapitel 55), sind naturgemäß nicht zirkulär; bei der Aufweitung
der Abhängigkeit von Klassen auf Pakete können jedoch auch zirkuläre Abhängigkeiten
entstehen .
"
"44.1 Type casts
Wie bereits in Kapitel 27 von Kurseinheit 3 erläutert, versteht man unter einem Type cast
(einer Typumwandlung ) den Vorgang, bei dem einem Pr ogramme lement ein anderer Typ
aufgezwungen wird als der, mit dem es deklariert wurde. Type casts werden also insbeson-
dere auf Variablen und auf Methodenausdrücke angewendet, und zwar immer dann, wenn
man diese einer Variable zuweisen will, zu der keine Zuw eisungskompatibilität besteht, oder
wenn man darauf eine Methode aufrufen (oder ein Feld zugreifen) will, das der deklarierte
Typ nicht anbietet. So führt z. B.
zu zwei Typfehlern: einem, weil o vom Typ Object ist, der keine Methode substring
kennt, obwohl das Objekt, auf das o verweist, diese Methode sehr wohl kennt, und einem,
weil Object nicht zuweisungskompatibel mit String ist. Zwei Type casts lösen das Prob-
lem:
Wie schon in Kapitel 27, so unterscheiden wir auch hier in Abhängigkeit
davon, wie die beteiligten Typen, der Ausgangstyp und der Zieltyp eines
Type casts , miteinander in Beziehung stehen, drei Arten von Typumwandlu ngen :
 Up casts : der Zieltyp ist ein Supertyp des Ausgangstyps
 Down casts : der Zieltyp ist ei n Subtyp des Ausgangstyps
 Cross casts : Zieltyp und Ausgangstyp stehen in keiner Subtypenbeziehung zueinan-
der, stehen also gewissermaßen nebeneinander.
Bei obigem Beispi el handelt es sich um (die bei weitem häufigsten) Down casts .
Wie man sich leicht vor Augen hält, ist ein Up cast auch in JAVA immer sicher , da jedes
Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der
Up cast auch immer w eggelassen werden kann); Down und Cross casts sind jedoch nur
erfolgreich , wenn das Objekt , zu dem der typumgewandelte Ausdruck auswertet, tatsäch-
lich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht
garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in JAVA
sog. Class cast exception ) führen.
Mit der Einführung von Generics ergeben sich ein paar Probleme mit im-
pliziten Typumwandlungen. Das nachfolgende Beispiel ist jedoch nur für Interessierte; ins-
besondere auf sog. Raw types und das damit zusammenhängende Konzept der Type era-
sure wird in diesem Kurs nämlich nicht eingegangen. drei Arten von Type
Bei Vorliegen der folgenden parametrisierten Klassendefinition
und folgender Variablendeklarationen und Initialisierungen
ergeben die Zuweisungen
bei der letzten einen Laufzeitfehler vom Typ Class cast exception .
"
"30 Parametrischer Polymorphismus und das Kovari-
anzproblem
In gewisser Weise hat man es beim rekursiv beschränkten parametrischen Polymorphismus
wie oben vorgestellt mit einem Fall von kovarianter Redefinition zu tun: Der Parametertyp
der Methode = ändert sich mit dem Empfängertyp. Allerdings ergibt sich daraus, anders als
bei der Verwendung von Self als Typvariable , kein Widerspruch zur Kontravarianzregel des
Subtyping, denn Integer wird dadurch unmittelbar ja lediglich zu einem Sub typ von
Equatable[In teger] und nicht etwa von Equatable[Object] . Tatsächlich sind
Equatable[Integer] und Equatable[Object] ja zwei vollkommen verschiedene Ty-
pen (mit disjunkten Wertebereichen) und Equatable[T] ist gar kein Typ (so dass man
auch keine Va riable mit ihm deklarieren kann), so dass keinerlei Zuweisungskompatibilität
und damit auch kein Problem mit Typkorrektheit besteht.
Trotzdem stellt sich die Frage, ob sich das in Abschnitt 26.3 angesprochene allgemeine
Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Metho-
den mittels parametrischen Polymorphismus nicht irgendwie lösen lässt. Die Antwort ist un-
befriedigend: nur zum Teil.
So kann man, um das Beispiel von Dokumenten und Druckern aus Abschnitt 26.3 wieder
aufzugreifen, einen parametrischen Typ Dokument wie folgt definieren: ein paar Worte zum
Typ Dokument
Typvariablen T < Drucker
Protokoll
Die Deklaration von Zeichnung mit Typparameter T als Subtyp von Dokument vorausge-
setzt, lassen sich die folgenden Variablendeklarationen bilden:
Weiterhin die Deklarationen von Plotter und Zeilendrucker als Subtypen von
Drucker vorausgesetzt wäre ein Methodenaufruf
typkorrekt,
hingegen nicht. Allerdings ist die Ass oziation von Zeichnung mit Plotter , die Kovarianz,
in keiner Typdefinition festgehalten, sondern lediglich in der Deklaration von z. Es hindert
einen insbesondere nichts daran, dieselbe oder eine andere Variable als vom Typ
Zeichnung[Zeilendrucker] zu dekl arieren. Man beachte, dass es anders als im obigen
Beispiel von Equatable , wo ja der Typparameter auf den definierten Typ selbst einge-
schränkt wurde, hier keine Möglichkeit gibt, einen bestimmten Wert für einen Typparame-
ter vorzuschreiben.
Was man allerdin gs tun könnte, ist, Zeichnung als Subtyp von Dokument[Plotter] zu
definieren. Dies hat jedoch den Nachteil, dass Zeichnung damit kein Subtyp mehr von
Dokument und, wie auch zuvor schon Zeichnung [Plotter] kein Subtyp von
Dokument[Drucker] ist (s. Abschnitt 29.3), wodurch die Zuweisungskompatibilität mit
entsprechend deklarierten Variablen verlorengeht. Kovariante Redefinition bei gleichzeitiger
Inklusionspolymorphie lässt sich auch mittels parametrischer Typen nicht hinbekommen.
"
"26.4 Inklusionspolymorphie
Ein von Christopher Strachey, einem der Urväter der Programmierung als wissenschaftliche
Disziplin, eingeführter Begriff ist der der Polymorphie . Polymorphie bedeutet allgemein
Vielgestaltigkeit und wird vor allem in der Biologie verwendet. In der Programmierung steht
er für verschiedene Dinge, die jedoch alle mit Typen zu tun haben.
Unter Inklusionspolymorphie , auch Subtypp olymorphie genannt , vers teht man im we-
sentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, können
Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert).
Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus (engl. para-
metric polymorphism , s. Kapitel 29) gebräuchlich; sonst redet man eher von Subtyping.
Das Interessante an der Inklusionspolymorphie ist, dass sich der Wertebe-
reich von Typen dadurch auf unvorhergesehene Umfänge aufweiten
lässt. Dies ist insbesondere für die Weiterentwicklung und Wiederverwen-
dung von Programmen interessant, bei der einfach neue Typen hinzugefügt, die anstelle
bereits existierend er eingesetzt werden können, ohne dass dazu am Programm sonst etwas
geändert werden müsste . Die Regeln einer strengen Typprüfung werden durch Inklusions-
polymorphie aufgelockert, ohne an Typsicherheit zu verlieren.
Insgesamt krankt die Definition des Subtyping und der Inklusionspolymor-
phie in der objektorientierten Programmierung jedoch daran, dass nicht
klar definiert ist, was alles zu verlangen ist, damit ein Objekt eines Typs tatsächlich auch da
auftauchen kann, w o ein Objekt eines anderen Typen erwartet wird. Zwar gibt die Regel
von Ko - und Kontravarianz eine klare Bedingung vor, aber wie Sie schon gesehen haben,
ist diese Bedingung aus praktischen Gründen nicht unumstritten. Dazu kommt, dass die
Regel einerseits gar nicht ausreicht, um Ersetzbarkeit zu garantieren, und andererseits zu
streng ist (s. Kurseinheit 6, Kapitel 54). Da Ersetzbarkeit aber der Definition des Subtypen-
begriffs zugrunde liegt , bleibt das ganze schwammig. In dieser Kurseinheit habe ich mich,
den meisten gängigen objektorientierten Programmiersprachen folgend, darauf zurückge-
zogen, zu garantieren, dass keine Typfehler, also Fehler der Art, dass eine bestimmte, ge-
forderte Eigenschaft (Methode) bei einem Objekt nicht vorhanden ist, auftreten können;
alles weitere wird dann in Kapitel 54 behandelt.
"
"28.3 Gründe für die Trennung von Typen und Klassen
Nun mögen S ie sich vielleicht fragen, warum Typen und Klassen über so viele Seiten als
getrennte Begriffe dargestellt wurden, nur um am Ende zum Schluss zu kommen, dass eine
Klassendefinition in der Regel auch als Typdefinition herhält. Nun, erstens ist das nicht in
allen Sprachen der Fall und zweitens ist es selbst in den Sprachen, in denen es der Fall zu
sein scheint, nicht immer so (s. Fußnote 54). So handelt es sich eher u m die Symbiose zweier
verschiedener Konzepte, die unterschiedlichen Zwecken dienen, deren strukturelle Ähnlich-
keit sich aber durch eine syntaktische Zusammenlegung ausnutzen lässt:
1. Klassen dienen der Angabe von Implementierungen und damit als Container von
ausführbarem Code;
2. Typen dienen der Formulierung von Invarianten, die für Variablenbelegungen gelten
müssen und deren Verletzung auf einen (logischen oder semantischen) Program-
mierfehler hinweist. absolute
Da beide im wesentlichen über die gleichen Elemente verfüg en, lässt sich die Definition
beider in einem Sprachkonstrukt zusammenfassen.
Der Unterschied der beiden Konzepte Klasse und Typ manifestiert sich
auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typin-
formation beeinflusst die Ausführung eines laufenden Programms insofern, als sie ein Pro-
gramm bei Verletzung einer Invariante abbrechen lässt (durch einen dynamischen Typtest)
und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninforma-
tion beeinflusst die Ausführung des laufenden Programms insofern, als sie Grundlage des
dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt
werden kann. In Sprachen, in denen jede Klasse einen Typ definiert, ist diese Unterschei-
dung jedoch nicht immer klar getroffen und wird deswegen von Programmiererinnen auch
nicht unbedingt wahrgenommen.
"
"26.1 Der Begriff des Subtyps
Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall da auftauchen dür-
fen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei
nicht für eine besond ere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung
zwischen zwei Typen, nämlich der Subtypenbeziehung . Die Gegenrolle heißt Supertyp .
Man beachte, dass diese Definition von Subtypen Zuweisungskompatibi-
lität impliziert: Wenn die Objekte eines Subtypen überall da auftauchen
dürfen, wo Objekte seines Supertypen erwartet werden, dann dürfen sie auch Werte von
jemand bei einer Zeichnung auf ihre Zeilen zugreifen will. Außerdem müsste bei erster Annahme der
allgemeinste Typ, von dem alle anderen abgeleitet sind ( Object in STRONGTALK ), immer alle Attribute
deklarieren, die einem jemals in den Sinn kämen, und das wäre nun wirklich unpraktisch. Problemquelle
Variablen sein, die mit dem Supertypen annotiert (auf Werte des Supertypen beschränkt)
sind. Ein Subtyp ist also mit seinem Supertyp per Definition zuweisungskompatibel. Es steckt
in dieser Defini tion aber eine gewisse Zirkularität (Subtyp als Voraussetzung und Ergebnis
der Zuweisungskompatibilität), die eine Einfachheit der Zusammenhänge vortäuscht, die es
in Wirklichkeit nicht gibt; die eigentliche Frage, was nämlich erfüllt sein muss , damit ein
Objekt eines Typen tatsächlich da erscheinen darf, wo ein Objekt eines anderen Typen er-
wartet wird, bleibt unberücksichtigt. Eine Befassung mit dieser Frage erfolgt hier aber nur
insoweit, wie dies heutige Typsysteme auch tatsächlich tun; eine genauere Bet rachtung er-
folgt dann erst in Kurseinheit 6, Kapitel 54.
Ein Subtyp kann selbst wieder Subtypen haben usw.; man spricht dann
auch von einer Subtypen - oder einfach nur von einer Typhierarchie . In einer solchen Hie-
rarchie kann man direkte von indirekten Subtypen unterscheiden: Zwischen einem Typ
und seinem direkten Subtyp liegt kein weiterer Typ in der Typhierarchie, bei einem indirek-
ten Subtyp hingegen schon. Die Subtypenbeziehung ist transit iv und reflexiv; insbesondere
ist also jeder Typ ein Subtyp von sich selbst (das folgt schon aus obiger Definition des Begriffs
Subtyp). Die Frage der Symmetrieeigenschaft muss noch bis zum nächsten Abschnitt zu-
rückgestellt werden.
Je nach verwendetem Typsystem kann ein Typ auch mehrere direkte Su-
pertypen haben. Die sich daraus ergebende Struktur ist dann aber keine
Hierarchie mehr (im strengen Sinne; man spricht aber dennoch häufig von einer solchen,
manchmal auch von einer Mehrfachhierarchie ), sondern nur noch ein gerichteter azykli-
scher Graph (engl. directed acyclic graph , kurz DAG). Alle obengenannten Eigenschaften
der Subtypenbeziehung best ehen jedoch weiter fort.
Wenn Subtypen, ähnlich wie bei der Typerweiterung oder -einschrän -
kung, auf Basis von bereits bestehenden definiert werden, spricht man
auch vom (nominalen) Subtyping (s. u.). Eine solche Subtypendefinition erfolgt dann im-
mer unter Angabe des oder der direkten Supertypen, und relativ dazu. Dabei verlangt die
obige Definition von einem Subtypen einen bestimmten Zusammenhang zwischen den De-
finitionen (Intensionen) von Sub - und Supertyp: Die Ergänzungen oder Änderungen, die
eine Subtypendefinition relativ zu der ihres oder ihrer Supertypen vornimmt, müssen ge-
währleisten, dass die Werte (Objekte) des Subtyps überall da auftauchen dürfen, wo ein
Wert des Supertyps verlangt wird . Dies lässt sich durch folgende einfache Regel ausdrücken:
Es darf also insbesondere keine Bedingung, die ein Supertyp an seine Obje kte stellt, durch
einen Subtyp aufgehoben oder relativiert werden. Logisch gesprochen heißt das, dass die
Bedingungen ( die Intension) des Subtyps die des Supertyps impliziert. Daraus folgt, dass die Subtyphierarchie
mehrere direkte
Supertyp en
Begriff des
Subtyping
WWeennnn eeiinn TTyypp YY eeiinn SSuubbttyypp eeiinneess TTyyppss XX iisstt,, ddaannnn mmüüsssseenn aallllee BBeeddiinngguunnggeenn,, ddiiee ffüürr OObb--
jjeekkttee ddeess TTyyppss XX eerrffüülllltt ssiinndd,, aauucchh ffüürr OObbjjeekkttee ddeess TTyyppss YY eerrffüülllltt sseeiinn..
Typerweiterung als Basis einer Subtypendefinition infrage kommt (da die Intension des Su-
pertypen unverändert übernommen und lediglich ergänzt wird), die Typeinschränkung hin-
gegen zunächst einmal nicht. Dennoch wäre die Typeinschränkung vom Subtyping auszu-
schließen eine unnötige Einschränkung, wie Sie gleich noch sehen werden.
Wenn man die eingangs dieses Kapitel s gemachten Bemerkungen zur
Typkorrektheit auf das Subtyping und die damit implizierte Zuweisungs-
kompatibilität überträgt, dann ergibt sich für die Extensionen von Supertypen und Subty-
pen, dass die Subtypenbeziehung als eine Teilmengenbeziehung gedeutet we rden muss :
Die Extension eines Subtyps ist in den Extensionen all seiner (direkten und indirekten) Su-
pertypen enthalten. Umgekehrt umfasst die Extension eines Supertyps die Extensionen all
seiner Subtypen. Es ergibt sich, dass nur wenn die Extensionen alle r direkten Subtypen eines
Typs paarweise disjunkt sind, man es mit einer echten Typhierarchie zu tun hat, in der jeder
Typ nur genau einen direkten Supertyp hat. Ist die Extension eines Supertyps genau gleich
der Vereinigung der Extensionen seiner Subtypen , hat der Supertyp keine eigenen Werte,
also keine Werte, die nicht zugleich Wert eines seiner Subtypen sind. Diese Bedingung ent-
spricht der Idee von der Generalisierung aus Abschnitt 9.1 und im übrigen gute objektori-
entierter Praxis (s. Kapitel 69).
"
"26.2 Strukturelles und nominales Subtyping
Beim Subtyping unterscheidet man wie bei der Typäquivalenz und -konformität zwischen
nominalem und strukturellem Subtyping. Nominales Subtyping liegt v or, wenn ein Subtyp
aus einem namentlich erwähnten Supertyp abgeleitet sein muss , um als sein Subtyp zu gel-
ten. Strukturelles Subtyping liegt vor, wenn ein Typ lediglich die obige Definition von Subtyp
erfüllen muss , um als solcher zu gelten. Nominales Sub typing impliziert strukturelles; analog
zur Typkonformität macht das nominale Subtyping die Subtypenbeziehung antisymmet-
risch, das strukturelle hingegen nicht.
"
"31 Grenzen der Typisierung
Wie Sie sehen, ist das Problem der kovarianten Redefinition ziemlich hartnäckig. Man muss
aber gar nicht so weit gehen, um an die praktischen Grenzen der Typisierung zu gelangen:
Bereits der Ausdruck
beinhaltet einen Typfehler, wenn nicht sichergestellt ist, dass x nicht 0 enthält. Nun könnte
man einen Typ NotZero definieren und x als von diesem Typ deklarieren, womit der obige
Ausdruck kein Problem mehr wäre; mit den hier vorgestellten Mitteln der statischen Typprü-
fung wäre dann aber schon die einfache Zuweisung
nicht mehr auf Zulässigkeit prüfbar. Selbst wenn es Typsy steme gibt, die das können56, so
sind diese kaum praxistauglich.
"
"4.1.4 Reihenfolge der Auswertung von geschachtelten Ausdrücken
Da Ausdrücke andere Ausdrücke enthalten können, stellt sich die Frage nach der Reihen-
folge der Auswertung von geschachtelten Ausdrücken. Diese wird, wie in anderen Sprachen
auch, implizit über Präzedenzen und explizit über Klammern geregelt.
Bei der doppelten Zuweisung in Zeile 38 oben ist zunächst vielleicht nicht klar, welche der
beiden Zuweisungen zuerst ausgewertet (ausgeführt) werden soll: y := x oder x := 1.
Wenn man jedoch weiß, dass es sich bei y := x := 1 um einen geschachtelten Ausdruck
handelt und jeder (Teil-)Ausdruck für ein Objekt steht, dann muss der zweite Ausdruck zu-
erst ausgewertet und durch das Ergebnis, „1“, ersetzt werden, denn andernfalls wäre die
„1“ dem Ergebnis von y := x zuzuweisen, was aber nach Abschnitt 4.1.3 keine Variable,
sondern ein Objekt ist. Zeile 38 weist also zuerst x und dann y das Objekt „1“ zu — die
Auswertung erfolgt von rechts nach links.
Das ist allerdings ein Sonderfall. Grundsätzlich werden in SMALLTALK näm-
lich alle Ausdrücke von links nach rechts ausgewertet. Dabei habe n aller-
dings unäre Ausdrücke Vorrang vor binären und diese wiederum Vorrang vor Schlüsselwort-
nachrichten, so dass nur bei gleichrangigen Ausdrücken die Auswertung von links nach
rechts erfolgt. So wird beispielsweise in
zunächst die Nachricht „ +“ an das Objekt, auf das x verweist, mit Argument 1 geschickt
und an das Ergebnis die Nachricht „<“ mit y als Parameter. Umgekehrt wird bei
zunächst der Vergleich angestellt und an das Ergebnis, eines der beiden Objekte „true“ und
„false“, die Nachricht „ –“ mit Argument 1 geschickt. Jedoch wird der Wahrheitswert (das
Wahrheitsobjekt) die Nachricht nicht verstehen und entsprechend mit einer Meldung wie
„Nachricht nicht verstanden“ reagieren. Um die Präzedenz zu ändern, kann man einfach
Klammern s etzen:
hat das gewünschte Ergebnis. Individuelle Operatorpräzedenzen (wie z. B. Punktrechnung
vor Strichrechnung) kennt SMALLTALK nicht.
Bei mehrstelligen Nachrichten mit Schlüsselwörtern werden alle Sc hlüs-
selwörter eines Ausdrucks als zu einer Nachricht gehörig interpretiert, es
sei denn, es wurden Klammern gesetzt. Der Ausdruck
wird also als eine Nachricht interpretie rt; falls
gemeint gewesen sein sollte, müssen eben die Klammern entsprechend gesetzt werden.
(Man beachte, dass im geklammerten Ausdruck erstesArgument Empfä nger der Nach-
richt nachdemDuDasGetanHast: mit zweitesArgument als Parameter ist. Das Ergebnis
der Auswertung dieses Ausdrucks ist dann Parameter der Nachricht tueDiesMitDem: an
einEmpfänger .)
"
"4.1.1 Zuweisungsausdrücke
Zuweisungsausdrücke hatten Sie schon in Abschnitt 1.6 kennengelernt. Sie verlangen auf
der linken Seite eine Variable und auf der rechten einen Ausdruck:
etwa ist ein Zuweisungsausdruck. Wie bereits erwähnt, bewirken Zuwei-
sungen als einzige Ausdrücke den Zustandswechsel von Objekten. So be-
wirkt etwa
wobei name eine Instanzvariable sein soll, die Änderung des Zustandes des Objektes, zu
dem die Instanzvariable gehört.
Da eine Zuweisung selbst ein Ausdruck ist, kann sie auf der rechten Seite einer anderen
Zuweisung erscheinen:
ist also ein legaler Ausdruck (zu seiner Auswertung kommen wir später, wenn wir — in
Abschnitt 4.1.4 — über die Reihenfolge der Auswertung geschachtelter Ausdrücke spre-
chen).
"
"40.1 Interfaces als Schnittstellen
Die öffentliche Schnittstelle einer Klasse in JAVA ist die Menge ihrer Instanzvariablen
und -methoden (in JAVA zusammen auch Member genannt ), die public deklariert sind.
Nun gibt es in JAVA die Möglichkeit, eine öffentliche Schnittstelle als eigenständiges Kon-
strukt zu de klarieren, das von dem der Klasse unabhängig ist, das aber genauso wie eine
Klasse einen Typ definiert. Es geschieht dies mit Hilfe des Schlüsselwortes interface :
Anders als bei Klassen entspricht hier das Fehlen eines Zugriffsmodifikators der Zugreifbar-
keit public — alles andere scheint für eine Schnittstelle auch unsinnig. Folgende weitere
syntaktischen Unterschiede der Interfacedeklaration in den Zeilen 1029 –1032 zur Klas-
sendefinition der Zeilen 986–991 fallen auf:
 die Verwendung des Schlüsselwortes interface anstelle von class (klar),
 das Fehlen von Felddeklara tionen und
 der Umstand, dass der Methodendeklaration keine Implementierung mehr folgt,
sondern lediglich das abschließende Semikolon.
Das Schlüsselwort abstract , das eine Klasse für eine solche Methodendeklaration anfüh-
ren müsste , wird in Interfaces automa tisch angenommen; Interfaces liefern zunächst erwar-
tungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begrün-
dung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen De-
klaration und Implementierung (Definition ; s. Kapitel 19 in Kurseinheit 3) unterschieden
werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch fü r eine
Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes),
wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da
ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter
und Setter) ersetzt werden kann.
Eine Klasse kann nun angeben, dass sie ein Interface implementiert. Sie
tut das unter Verwendung des Schlüsselwortes implements :
Damit verpflichtet sich die Klasse, alle im Interface angekündigten Methoden zu implemen-
tieren und öffentlich anzubieten.67 Dabei kann eine Klasse mehrere Interfaces gleichzeitig
implementieren (die entsprechenden Namen werden einfach, durch Kommata getrenn t,
überlassen; in diesem Fall muss die Methode aber zumindest als abstrakt deklariert werden. Interface -
aneinandergehängt); zugleich ist die Angabe der implementierten Interfaces eine nominale
Typkonformitätsdeklaration , d. h., Instanzen d er Klasse sind mit allen Variablen jedes der
genannten Interfaces zuweisungskompatibel.
Es definieren also die Interfaces von JAVA genau wie Klassen Typen und
können daher genauso wie Klassen in Variablendeklarationen verwendet
werden:
ist eine solche Deklaration. Der Type checker garantiert dann, dass auf der Variable mit
Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface
mit Namen „Interfacename“ deklarier t sind, selbst wenn das Objekt, das die Variable be-
nennt, mehr anbietet. S o ist es möglich, dass Methoden und Felder einer Instanz vor ande-
ren Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert ein-
fach die Variablen , die auf di e Instanz verweisen , mit dem Interface als Typ. Eine genauere
Betrachtung der Bedeutung der Verwendung von Interfaces erfolgt in Kapitel 45.
Es kann also eine Klasse in JAVA zwar nur direkte Subklasse genau einer
anderen Klasse sein, dafür aber mehrere Interfaces gleichzeitig implemen-
tieren. Diese mögliche „Mehrfachimplementierung“ von Interfaces wurde häufig als Ersatz
für d ie in JAVA fehlende Möglichkeit der Mehrfachvererbung angepriesen — das aber war
Unsinn, denn bei der Implementierung eines Interfaces wurde nichts vererbt (sieht man mal
von der sog. Interfacevererbung ab, die aber auch keine wirkliche Vererbung ist, denn auch
die Deklarationen werden nicht automatisch von einem Interface auf seine implementieren-
den Klassen übertragen, sondern müssen dort wiederholt werden ). Vielmehr hat man es mit
einer Art Mehrfach -Subtyping zu tun, das aber auch ganz nett ist, wie die Überlegungen in
Kapitel 45 zeigen werden.
"
"11.3 Löschen von Methoden
Wie be reits in Abschnitt 10.3 erwähnt, wird die Programmiererin, die eine abst rakte, weil
unvollständige, Klasse instanziiert, irgendwann damit bestraft, dass das Versenden einer
Nachricht an die entsprechende Instanz zu einer Fehlermeldung führt, die ihr (per
subclassResponsibility oder implementedBySubclass , die, genau wie
doesNotUnderstand: , in der Klasse Object definiert ist) anzeigt, dass die Methode (erst)
in einer Subklasse implementiert werden sollte. Dummerweise bekommt die Programmie-
rerin diesen Hinweis erst zur Laufzeit des Programms zu Gesicht, also dann, wenn es schon
zu spät ist (es sei denn, man testet gerade). Man erkennt hieran sehr schön den interaktiven
Geist des SMALLTALK -Systems, insbesondere die Philosophie, nach der Programmieren nichts die Klasse Object
weiter ist als das iterative Zurechtbiegen und Erweitern eines bereits bestehenden, funktio-
nierenden Systems. Man muss eine Weile damit gespielt haben, um diesem Charme zu er-
liegen.
Selbsttestaufgabe 11.1 (für JAVA-Fans)
Überschreiben Sie die Methode doesNotUnderstand: so, dass man beim Versenden einer Nach-
richt an nil eine Meldung „ Null pointer exception “ erhält. Achtu ng: Speichern Sie vorher unbedingt
Ihr Image und stellen Sie es nach der Bearbeitung der Aufgabe wieder her!
Wenn man sich erst einmal damit abgefunden hat, dass man als Program-
miererin Methoden schreibt, die ausschließlich dem Zweck dienen, sich
selbst oder eine Kollegin auf Programmierfehler hinzuweisen, dann erscheint einem eine
weitere SMALLTALK -Konvention geradezu als elegant, nämlich die, geerbte Methoden durch
überschreiben auszulöschen . Tatsächlich ist genau hierfür eine weitere Methode in der
Klasse Object mit Name n „shouldNotImplement“ vorgesehen, die zu einer entsprechen-
den Fehlermeldung führt. Eine Klasse, die also eine geerbte Methode löschen möchte, über-
schreibt diese einfach mit
im Rumpf. Bevor Sie jetzt als disziplinierte Programmiererin den Stab über SMALLTALK bre-
chen, erlauben Sie noch den Hinweis, dass der Wunsch, geerbte Methoden zu löschen,
direkte Folge der vorrangigen Orienti erung an Vererbung ist, die bereits oben kritisiert
wurde: Wäre die Superklasse auf Grundlage des Prinzips der Generalisierung ausgewählt
worden, käme man gar nicht in die Verlegenheit, Methoden löschen zu wollen, denn alles,
was für die Generalisierung si nnvoll ist, ist grundsätzlich auch für ihre Spezialisierungen
sinnvoll, oder die Generalisierung ist keine Generalisierung. Außerdem haben Sie auch in
Sprachen mit starker Typprüfung, in denen das Löschen von Methoden nicht möglich ist,
als Programmiererin immer die Freiheit, eine Methode so zu überschreiben, dass sie garan-
tiert nichts tut, was mit der Idee der Klasse, von der sie ererbt ist, in Einklang zu bringen
wäre. Auch hier wäre n Laufzeitfehler die unvermeidbare Folge. Mehr dazu im Kurseinheit 3;
hier sei nur soviel bemerkt wie, dass wenn man sich bei der Organisation seiner Klassenhie-
rarchie auf das P rinzip der Generalisierung stützt, dass man dann auch nicht in die Verle-
genheit kommt, Methoden löschen zu wollen.
"
"26 Subtyping und Inklusionspolymorphie
Die Einführung von Typäquivalenz und Typkonformität bezog sich bislang lediglich auf das
Verhältnis der Typdefinitionen, also der Intensionen der Typen. Die Frage des Zusammen-
hangs der Wertebereiche der Typen, also der Extensionen, ist dabei unberücksichti gt geblie-
ben. Wenn aber die obige Definition von Typkorrektheit weiter Bestand haben soll, dann
müssen die Werte zuweisungskompatibler Typen zum Wertebereich des Typen, an den zu-
gewiesen werden soll, gehören.
Zur Erinnerung: Typannotationen stellen Invarianten dar, die die möglichen Werte einer Va-
riable beschr änken. Diese Invarianten dürfen durch Zuweisungen nicht verletzt werden.
Wenn man aber nun Zuweisungen von einem anderen Typen zu lässt, dann wird die Typ-
korrektheit nur dann nicht verletzt, wenn der Wertebereich des anderen Typen (seine Ex-
tension) in dem d essen, dem zugewiesen wird, enthalten (inkludiert) ist. Mit anderen Wor-
ten: Damit eine Zuweisung a := b , bei der sich die Typen von a und b unterscheiden,
zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von
a sein.
Im Fall der Typerweiterung ist dies nicht automatisch der Fall. So handelt
es beispielsweise bei der Extension des Typs
Typ DreiDPunkt
erweiterter Typ ZweiDPunkt
Protokoll
als Erweiterung von
Typ ZweiDPunkt
Protokoll
nicht unbedingt um eine Teilmenge der Extension von ZweiDPunkt , denn es ist z. B. nicht
klar, was das Ergebnis der Addition eines dreidimensionalen zu einem zweidimensionalen
Punkt sein könnte — geometrisch ist die Addition zweier Punkte unterschiedlicher Dimen-
sionen jedenfalls nicht definiert. mangelnde Teilmen-
Selbsttestaufgabe 26.1
Versuchen Sie, das Beispiel mit ZweiDPunkt und DreiDPunkt so zu retten, dass sowohl Typer-
weiterung als auch Inklusion von Extensionen darin vorkommt. Evtl. finden Sie in Kapitel 9 von Kurs-
einheit 2 nützliche Hinweise.
Das Phänomen der mangelnden Extensionsinklusion bei Typerweiterung
lässt sich darauf zurückführen, dass dem erweiterten Typ ( im Beispiel
Dokument ) eigene, d. h. nicht einer seiner Erweiterungen entstammende
Werte (Objekte) zuges tanden werden. Wäre die Extension eines erweiterten Typs als die
Vereinigung der Extensionen seiner Subtypen (hier Text und Zeichnung ) definiert, gäbe
es dieses Problem nicht. Dies ist ein sehr guter Grund dafür, dass Supertypen — genau wie
Generalisierungen ( Kurseinheit 2, Kapitel 9) — keine eigenen Objekte haben sollten (vgl. a.
Abschnitt 26.1 und Kurseinheit 7, Kapitel 69).
Auch nicht selbstverständlich ist die Teilmengenbeziehung bei der Typein-
schränkung: Durch das Weglassen von Eigensch aften (Methoden) wird
die Extension, also die Menge de r Werte (Objekte), die darunter fallen,
eher größer denn kleiner — je weniger spezifisch die Menge der geforderten Eigenschaften
ist, desto mehr Objekte fallen darunter. Die sich daraus ergebende Teilmen genbeziehung
wäre also eher die umgekehrte (die Extension des einschränkenden Typen enthält die des
eingeschränkten). Etwas anders sieht es aus, wenn durch Typeinschränkung ( Redefinition )
die Ein - oder Rückgabetypen von Methoden beschränkt werden: Die Menge der Zeichnun-
gen ist eine Teilmenge der Menge der Dokumente, auch weil sich Zeichnungen eben nur
auf Plottern ausgeben lassen. Die Zuweisungskompatibilität von Zeichnung mit Dokument
wäre also, was die Inklusion der Extensionen angeht, kein Problem.
Man könnte nun die Typerweiterung unter oben gemachter Einschrän-
kung und die zweite Form der Typeinschränk ung als in dieselbe Richtung
zielende Maßnahmen ansehen: Beide schränken Extensionen ein. Das
lässt sich wie folgt erklären: Wenn man einer Menge von Objekten, die
durch eine Anzahl Attribute alle gleichermaßen charakterisiert werden, weitere Attribute
beimisst, dann schränkt man diese Menge ein, wenn die hinzugefügten Attribute nicht alle
Objekte der Menge charakterisieren. Wenn man beispielsweise wie oben geschehen die
Attributmenge des Typs Dokument um die Methode zeilen ^ <Collection> erweitert,
dann fa llen die Zeichnungen aus der durch Dokument beschriebenen Menge von Objekten
heraus, weil sie keine Zeilen haben. Alternativ könnte man auch sagen, dass Dokumente
grundsätzlich über Zeilen verfügen können, diese aber bei Zeichnungen immer in der Anzahl
erscheint das weniger natürlich.51 Man beachte die Parallelität zum Begriff der Spezialisie-
rung (Abschnitt 9.2 in Kurseinheit 2): Der durch Typerweiterung oder -einschränkung aus
Dokument hervorgegangene Typ Zeichnung ist spezieller als seine Vorlage.
Nun ergibt sich aber gemäß obigem Beispiel (Zeilen 900–902) ein Sach-
verhalt, der trotz aller Harmonie von Typerweiterung und -einschränkung
nicht weniger als den Verlust der Zuweisungskompatibilität bedeutet.
Dieser resultiert jedoch bei genauerer Be trachtung nicht daraus, dass Zeichnungen keine
Dokumente wären, sondern aus der mit der Typkorrektheit verbundenen, impliziten All-
quantifiziertheit von Typinvarianten: Eine Methodendeklaration
im Protokoll eines Ty ps Dokument wird nämlich interpretiert als „ druckenAuf: ist definiert
für alle Empfängerobjekte vom Typ Dokument und Parameterobjekte vom Typ Drucker “,
was aber in dieser Allgemeinheit sachlich falsch ist.
Typsysteme mit Typinvarianten der hier vorgestellten Art sind nicht in der
Lage, andere als implizit allquantifizierte Aussagen über Wertebereiche zu treffen. Dies ist
gewissermaßen der Preis der Einfachheit. Abhilfe schaffen neuere Typsysteme wie die Idee
von den Dependent types , wie sie beispielsweise in SCALA zum Einsatz kommen : Hier man
sich die Parametertypen von Methoden als Funktionen des Typs, zu dem die Methode ge-
hört, vorstellen. Der Parametertyp von druckenAuf: aus obigem Beispiel wäre dann, in
Abhängigkeit davon, ob die Methode auf einem Objekt vom Typ Dokument oder
Zeichnung aufgerufen wird, Drucker oder Plotter . Wie man sich leicht vorstellen kann,
ist die statische Prüfung solcher Bedingungen (Invar ianten) aber nicht so einfach.
Die Vereinigung von Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität
und der daraus folgenden Typkorrektheit bietet der Begriff des Subtyps.
"
"52.5.2 Statische Komponente
Wie auch in JAVA definiert in EIFFEL jede unparametrisierte Klasse einen Typ und jede para-
metrisierte Klasse eine (generische) Menge von Typen. Alle Variablen (inkl. Methoden81 und
deren Parameter) müssen einen Typ haben. Zuweisungskompatibilität ist an nominale Typ-
konformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung
genannt) einhergeht — ganz wie in JAVA. Anders als in JAVA ist es jedoch zulässig, Instanzva-
riablen und Funktionsparameter wie im obigen Beispiel kovariant zu rede finieren — von
kontravarianter Redefinition will MEYER nichts wissen (eine Begründung sollten Sie mittler-
weile selbst zur Verfügung haben). Das bedeutet allerdings mangelnde Substituierbarkeit
und bereitet EIFFEL erwartungsgemäß einige nichttriviale Probleme.
Zunächst einmal wollen wir uns das Typs ystem EIFFELs noch etwas ge-
nauer ansehen. Es basiert, wie in der objek torientierten Programmierung
üblich, auf dem Begriff der Typkonformität ( Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ
U typkonform zu einem Typ T
 wenn U und T gleich sind,
 wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich,
im Falle von parametrischer Erzeugung von U und T, jeder tatsächlich e Typparameter
von U konform ist zum entsprechenden tatsächlich en Typparameter von T oder
 wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist
(U ist eine indirekte Erweiterung von T).
Außerdem gibt es in EIFFEL noch einen Typkon struktor like <ein Ausdruck> (s. u.),
dessen erzeugter Typ typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der
kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der
Basistyp konform, keiner seiner Subtyp en.
Dazu zunächst ein paar Beispiele. Bei
ist
OK,
hingegen nicht. Im Falle der Vererbung bei parametrischem Polymorphismus wie in
ist wieder
zuweisungskompatibel, die umgekehrte Zuweisung jedoch nicht. Beschränkter parametri-
scher Polymorphismus wird in EIFFEL übrigens wie folgt notiert:
EIFFEL benutzt also eckige Klammern und -> anstelle von spitzen Klammern und extends
in JAVA.
In EIFFEL wird übrigens anders als in C# nicht pro Typkonstruktor zwischen
Wert - und Referenztyp unterschieden — zu jedem kann es (ähnlich wie
in C++) beid e Formen geben. Dazu gibt es in EIFFEL die Möglichkeit, bei
einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik, also ein Objekt an-
stelle einer Referenz auf ein Objekt zum Inhalt haben sollen (s. Kurseinheit 1, Abschnitt 1.5).
Dies ist manchmal für alle Variablen eines Typs sinnvoll (z. B. bei Zahlen und Wahrheitswer-
ten), manchmal aber auch nur für manche. Und so gibt es in EIFFEL einen Typkonstruktor
expanded , der, in Variablendeklaration wie in
eingesetzt, einer einzelnen Variable eine Wertsemantik gibt, und der in Klassendefinitionen
wie in
verwendet allen Variablen des entsprechenden Typs (der entsprechenden Typen im Falle
einer generischen Typdefinition) automatisch Wertsemantik gibt. EIFFELs Typkonstruktor
expanded entspricht also gewissermaßen einer Umkehrung des in PASCAL -artigen Sprachen
verwendeten Typkonstruktors ^ (Zeiger auf): Wenn expanded nicht verwendet wird, han-
delt es sich um einen Zeigertypen.
Die Unterscheidung von Wert - und Referenzty pen einer Klasse hat in EIF-
FEL einen starken konzeptuellen Hintergrund: Sie unterstützt die bereits in
Abschnitt 2.3 diskutierte Komposition und ihre Abgrenzung a ls eine be-
sondere Beziehung zwischen Objekten, nämlich der, die das Enthalten-
sein von Objekten in anderen ausdrückt (vgl. dazu auch Kapitel 59 in
Kurseinheit 6). Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer Typkonstruktoren für
entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nir-
gends ent halten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise
Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variab-
len) zu haben. Dieses Feature ist nicht in C# (zumindest nicht im Safe mode) zu haben, de nn
dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen,
und schon gar nicht in SMALLTALK oder JAVA — in C++ (und im Unsafe mode von C#) kann
man es simulieren, zahlt dafür aber den Preis, mit expliziten Pointern hantie ren zu müssen,
was nach landläufiger Auffassung ein ziemlich hoher ist.
Nun stand bereits in Kurseinheit 1, Abschnitt 1.6 zu lesen, dass bei der
Zuweisung zwischen zwei Variablen mit Wertsemantik der W ert der einen
Variable in die andere Variable kopiert wird, während bei der Zuweisung
zwischen zwei Variablen mit Referenzsemantik lediglich der Zeiger ko-
piert wird. Dies ist auch in EIFFEL so. Bei der Zuweisung einer Variable mit Referenzsemantik
an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn
die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte — stattdes-
sen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: es werden die Attri-
bute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable ko-
piert). Im umgekehrten Fall, also wenn eine Variable mit Wertsemantik an eine Variable mit
Referenzsemantik zugewiesen wird, könnte man annehmen, dass ein Zei ger auf den Wert
erzeugt und zugewiesen wird; dies würde aber bedeuten, dass dadurch ein Alias auf einen
Wert entstünde, was nicht der Semantik der Komposition ( Aggregation ; s. Abschnitt 2.3 in
Kurseinheit 1) entspräche. Was stattdessen passiert, ist, dass ein Klon des Objekts erzeugt
wird und eine Referenz auf diesen Klon übergeben wird. Dies ist eine äußerst sinnvolle Fest-
legung.
Verankerte Typdeklarationen haben in EIFFEL die Form
wobei y ein bereits typisiertes Programmelement (also z. B. eine Instanzvariable) ist. Eine
solche Verankerung bewirkt, dass sich der Typ von x automatisch mit dem von y verändert.
Dies hat zunächst noch nichts mit Kovarianz zu tun, wie das folgende Beispiel zeig t.
Anstatt in EIFFEL
zu schreiben, d. h., bei Veränderung des Typs der Instanzvariable f von X zu Y alle Parame-
tertypen, die davon berührt sind, mit zu verändern, reicht es aus,
zu schreiben. Da die Typen der Parameter von setF und getF alle per Deklaration dieselben
sind wie der Typ von f, muss in der Definition von B textuell nichts anderes stehen. Da nun
aber in EIFFEL die Redefinition von Instanzvariablen per Definition immer kovariant sein muss ,
muss Y ein Subtyp von X sein. Der Rückgabetyp von getF und der Parametertyp von setF
ändern sich damit automatisch ebenfalls kovariant.
Ein besonderer Fall von verankerten Typen ergibt sich bei rekursiv en Ty-
pen, also Typen, deren Definition den definierten Typ selbst referenziert:
In diesem Fall schreibt man in EIFFEL anstelle der Typreferenz bei der Deklaration einer Vari-
able vom zu definierenden Typ like Current . Bei einem entsprechend deklarierten Fel d
ändert sich der Typ bei der Vererbung also immer automatisch zum erbenden Typ hin ab,
also immer mit dem Typ und damit kovariant. Für das Beispiel der zu trennenden Skifahre-
rinnen (Zeilen 1391 –1425 ) ergibt sich damit
Die beiden erbenden Klassen GIRL und BOY müssen dann nichts mehr redefinieren.
Wir können nun zur Lösung des Pro blems der Kovarianz in EIFFEL kom-
men. Die obige Konstruktion
(hier unverändert wiederholt) wird dann vom Type checker zur Übersetzungszeit zurückge-
wiesen, da g1 nicht vom Typ like s1 ist, was aber laut Typkonformitätsregeln von EIFFEL
notwendig wäre . Leider ist das nur ein Teilerfolg.
Es ist nämlich andersherum like s1 mit dem Typ von s1 konform . Und so wird es möglich,
dass bei zusätzlicher Deklaration von
(wobei der Typ von s1 ja SKIER ist)
und anschließend
doch wieder
zulässig ist und damit ein Mädchen einem Jungen ins Zimmer gesteckt wird.
Die erste und einfachste Möglichkeit, dies zu verhindern, w äre, die Zu-
weisungskompatibilität für Variablen mit verankerten Typen und Typan-
kern einzuschränken und unter ihnen nur noch Typäquivalenz zu akzeptieren. Es wären
dann nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit
solchen, die ihn als Anker benutzen, erlaubt; insbesondere wäre eine Zuweisung wie s1 :=
g1 (die ja notwendig war, um ein Objekt vom Typ GIRL so zu „verpacken“, dass es an g2
mit seinem verankerten Typ like s1 zugewiesen werden kann) damit nicht mehr möglich.
Alle anderen Zuweisungen wären natürlich weiter zugelassen; dies hätte jedoch zur Konse-
quenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein
Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem w äre
es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker
zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Ob-
jekte unterschiedlichen Typs haben dürfen, genutzt werden soll. Lösung des Problems
Die zweite Möglichkeit wäre, eine Typinferenz für das gesamte Programm durchzuführen,
um die möglichen Zuweisungen an Variablen zu sammeln. Dazu sind insbesondere alle Me-
thodenaufrufe anzus ehen (Zuweisungen an Instanzvariablen sind in EIFFEL nur innerhalb ei-
ner Klasse erlaubt) und diese können je nach Konfiguration des endgültigen Systems sehr
unterschiedlich ausfallen. Eine solche Typinferenz ist aber in den meisten Fällen unrealistisch.
Die dritte Möglichkeit ist die, alle dynamisch gebundenen Aufrufe von Methoden, deren
Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“)
ändern (die von MEYER so genannten CAT -Calls, wobei CAT für „ Change Availability or
Type“ steht), zu verbieten. Ein Aufruf von share auf s1 wie oben ist damit verboten, weil
share in BOY und GIRL kovariant redefiniert wird. Auf einer Variable vom Typ GIRL oder
BOY wäre er hingegen zulässig, solange sichergestellt ist, dass diese Variable k einen Wert
von einem Subtyp von GIRL bzw. BOY zugewiesen bekommen kann. Das ist möglich, wenn
kein solcher Subtyp existiert oder wenn keine Zuweisung an die Variable existiert, bei der
die rechte Seite ein Subtyp der Variable ist. Das erste ist lokal nicht nachzuweisen, das zweite
hingegen schon, jedoch nur für explizite Zuweisungen (inkl. der Instanziierung, die in EIFFEL
auf einer Variable durchgeführt wird und ihr au tomatisch einen Wert gibt). Für die Zuwei-
sung an formale Parameter kann dies jedoch nicht lokal nachgewiesen werden, weil im
Gegensatz zu expliziten Zuweisungen an Variablen die Methodenaufrufe von überall her
erfolgen können.
Wie Sie sehen, sind die Bedin gungen ziemlich restriktiv, und man kommt nicht umhin, das
Typsystem von EIFFEL als etwas eigenartig zu empfinden. Wie es sich in der Praxis auswirkt,
ist mir leider nicht bekannt; MEYER behauptet, dass die Probleme praktisch keine Rolle spie-
len. Ich möcht e hinzufügen, dass falls doch, die durchschnittliche Programmiererin kaum
verstehen wird, was denn nun genau das Problem ist und was sie tun kann, es zu umgehen.
"
"4.1.2 Nachrichtenausdrücke
Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform
der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark
an die der engl ischen Sprache angelehnt ist: Sie verlangt ein Subjekt (den Empfänger der
Nachricht), ein Prädikat (die Nachricht ) sowie eine optionale Liste von Objekten als Prädi-
katsergänzungen (die P arameter der Nachricht). Dabei wird auf die in anderen Sprachen
übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und
Klammern zum Umschließen der Parameterliste verzichtet; stattdessen verwendet man bei Zustandswechsel von
zwei oder mehr Paramet ern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nach-
richtenteile, die den Parametern vorangestellt werden. Die allgemeine Syntax lautet also
für parameterlose Nachrichten,
für Nachrichten mit einem Parameter,
für Nachrichten mit zwei Parametern usw., wobei hier die in spitzen Klammern stehenden
Namen metasyntaktische Variablen , also Platzhalter für Namen in einem konkreten Pro-
gramm, sind und die Nachrichten(teile), die Parameter nach sich ziehen, immer mit einem
Doppelpunkt enden müssen.
drückt beispielsweise den Versand einer parameterlosen Nachricht tueEtwas an das Ob-
jekt, auf das die Variable einObjekt verweist, aus.16 Ein etwas konkreteres Beispiel hierfür
ist der Ausdruck
mit dem dem Objekt #abc die Nachricht printStri ng gesendet wird.
Soll einer Nachricht ein Parameter angehängt werden, so tut das
wobei einemParameter hier auch eine Variable ist (es könnte auch ein anderer Ausdruck
dort stehen; s. u.). Ein konkretes Beispiel hierfü r ist
Ein zweiter Parameter wird durch einen weiteren Nachrichtenbestandteil wie in
hinzugefügt und alle weiteren entsprechend, also etwa
men durch sog. Binnenmajuskeln (eingefüg te Großbuchstaben) und nicht durch den Unterstrich
kenntlich zu machen.
wobei sich die Nachrichtenteile wie oben ruhig wiederholen dürfen. Es ist
also insbesondere nicht so, dass die Reihenfolge der Nachrichtenteile beliebig umgestellt
werden dürfte, oh ne dass sich dadurch die Bedeutung der Nachricht änderte. Tatsächlich
ist die an das Objekt geschickte Nachricht, der sog. Nachrichtenselektor (engl. message
selector ), immer ein Symbol, das aus der Konkatenation (Aneinanderfügung) aller seiner
Teile, also im Beispiel der Zeile 48 oben #tueEtwasMit:und: besteht. Die Namen der
Nachrichtenteile sind frei wählbar, beginnen jedoch per Konvention mit einem Kleinbuch-
staben.
Parameterlose Nachrichten w ie beispielsweise tueEtwas in Zeile 44
nennt man in SMALLTALK übrigens unär (unary messages ): Obwohl sie
keine expliziten Argumente haben, heißen sie trotzdem unär, weil der Empfänger das erste,
implizite Argument ist. So nehmen denn auch sog. binäre Nachrichten17 nur einen Para-
meter, was aber zwei Argumenten, nämlich dem Empfänger und einem weiteren Argu-
ment, entspricht:
beispielsweise drückt aus, dass die Nachricht „+“ mit Argument „2“ an das Objekt „1“
gesendet werden soll.
In SMALLTALK sind binä re Nachrichten eine syntaktische Besonderheit: Sie bestehen nämlich
aus einem oder mehreren nicht alphanumerischen, nicht reservierten Zeichen (die Liste der
reservierten Zeichen finden Sie in Kapitel 5 am Ende diese r Kurseinheit ). Alle anderen Nach-
richten, die neben dem Empfänger noch mindestens ein Argument erfordern, werden in
SMALLTALK dagegen Schlüsselwortnachrichten (keyword messages ) genannt, so z. B.
tueEtwasMit: in Zeile 46 und tueEtwasMit:und: in Zeile 48. Dies ist jedoch etwas ver-
wirrend, da sie keine Schlüsselwörter im landläufigen Sinne (von denen SMALLTALK ja gar
keine hat) enthalten und da natürlich auch die unären Nachrichten „Schlüsselwörter“ ver-
wenden.
Ein Nachrichtenausdruck besteht also aus einem Empfängerobjekt, einem
Nachrichtenselektor sowie einer Anzahl von Argumentausdrücken, die
die Teile des Nachrichtenselekt ors sperren (dazwischen stehen).18 Der Ausdruck als ganzes
gleichen Typ haben
Parameter zu übergeben; in den allermeisten Fällen handelt es sich dabei um einen Anfängerinnen-Nachrichtenselektor
steht für ein Objekt, nämlich das Ergebnis der Auswertung der Nachricht durch den Emp-
fänger. Der Nachrichtensender wird dem Empfänger übrigens nicht mitgeteilt (es sei denn,
er wird explizit als Par ameter übergeben) — das System weiß automatisch, wohin die Ant-
wort auf die Nachricht zurückgeliefert werden soll (nämlich genau an die Stelle, an der der
Nachrichtenversand steht). Mehr dazu gleich, wenn es um die Auswertung von Nachrich-
tenausdrücken geht (Abschnitt 4.1.3 ).
Da ein Nachrichtenausdruck für ein Objekt steht, kann er selbst Teil eines
Nachrichtenausdrucks sein, also f ür den Empfänger der Nachricht oder
einen ihrer Parameter stehen. Es ist dann allerdings u. U. notwendig, den so geschachtelten
Nachrichtenausdruck zu klammern, da er sonst nicht richtig erkannt werden kann:
beispielsweise schiebt das Objekt auf den Stack, das Resultat der Nachricht arg:arg: ge-
sandt an das oberste Objekt des Stacks mit seinem zweiten und dritten als Parameter ist.
(Zu den genauen Regeln zur Reihenfolg e der Auswertungen siehe Abschnitt 4.1.4 .)
Nicht selten möchte man eine Serie von Ausdrücken an dasselbe Empfän-
gerobjekt senden. SMALLTALK sieht dafür mit der Kaskadierung eine nette
syntaktische Abkürzung vor, die es erlaubt, bei einer Sequenz von Nach-
richten an dasselbe Objekt dieses nicht immer wiederholen zu müssen. So sorgt beispiels-
weise
anstelle des wesentlich wortreicheren
dafür, dass die Objekte „1“, „+“ und „2“ nacheinander als Parameter der Nachricht show:
an das von der globalen Variable Transcript benannte Objekt, eine Art Systemkonsole,
gesendet werden. (Auf die Bedeutung des „.“ kommen wir in Kapitel 4.2 zu sprechen.) Das
Beispiel ist übrigens nicht b esonders zwingend, da man in SMALLTALK genauso gut auch
hätte
fehler , bei dem durchscheint, dass die Programmiererin (die vermutlich noch in Kategorien der pro-
zeduralen Programmierung denkt) nicht verstanden hat, dass jede Nachricht einen Empfänger hat,
ein Nachrichtenausdruck diesen also schon beinhaltet. geschachtelte Nach-
schreiben können (wobei , ein binärer Nachrichtenselektor ist, der für die Konkatenation
steht). cr ist übrigens eine (unäre) Nachricht, die für einen Wagenrücklauf ( carriage return )
auf dem Transcript sorgt.
Man kann sich aber durch Verwendung der Kaskadierung häufig die Ein-
führung einer temporären Variablen (s. Abschnitt 4.3) ersparen, und zwar
immer dann, wenn anstelle einer Variabl e als Empfänger ( Transcript
in obigem Beispiel) ein Ausdruck steht, der das Empfängerobjekt liefert und der nur einmal
ausgewertet werden soll. Anstelle von
kann man also
schreiben, wenn man eineVariable hernach nicht mehr benötigt. SMALLTALK unterstützt
also von Haus aus sog. Fluent APIs .
"
"51.3 Friends
Ein interessantes Konzept von C++, das einen direkten Bezug zur objektorientierten Pro-
grammierung hat, ist das Friends -Konzept. In der Praxis kommt es häufig vor, dass ein be-
stimmtes Teilproblem nicht von einer Klasse allein, sondern nur durch das Zusammen spiel
mehrerer Klassen gelöst werden kann. Während diese Klassen untereinander eng kooperie-
ren müssen und deswegen (relativ) intime Kenntnis voneinander benötigen (will sagen, auf
Elemente zugreifen können müssen, die anderen Klassen verborgen bleiben soll ten), gilt das
für andere Klassen nicht unbedingt. Die Schnittstelle solcher kooperierenden Klassen sollte
also nicht absolut, sondern relativ zu anderen Klassen definierbar sein.
In JAVA hatte man dazu bis zur Version 8 nur die Möglichk eit, die besag-
ten Klassen in ein Paket zu verfrachten und die fraglichen Elemente mit paketweitem Zugriff
(also ohne Zugriffsmodifizierer) zu deklarieren (Abschnitt 39.1 in Kurseinheit 4). Das hat
jedoch den Nachteil, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen
enthaltenen Klasse haben; wenn es eine Klasse gibt , die eine ansonsten unsichtbare Eigen-
schaft x einer Klasse A sehen und eine andere, die eine Eigenschaft y derselben Klasse sehen
soll, dann gibt es keine Aufteilung der Klassen auf Pakete, die genau dieses gestattet. Was
man stattdessen gern hätte, ist e in dedizierter Export von Elementen einer Klasse, also ein dedizierter Export
zur Verfügung Stellen von Elementen an genau benannte Klassen. Dies bietet, in etwas
gröberer Form, das Friends -Konzept von C++: Die Definition
bewirkt, dass (Instanzen von) B und (von) C auf alle private deklarierten Elemente von
(Instanzen von) A zugreifen können (jedoch weder umgekehrt von A auf B und C noch B
und C gegenseitig ). Ein spezifischer, dedizierter Export von einzelnen Membern an be-
stimmte Klassen ist in C++ nicht möglich; diesen gibt es dafür in EIFFEL (s. Abschnitt 52.2).
Mit JAVAs Modulen und dem dedizierten ( qualifiziert genannten) Export wird das Friend -
Konzept auf Ebene der Pakete zumindest angenähert.
"
"8.4 Erzeugung von Klassen in SMALLTALK
Da Instanz en, für die es keine literale Repräsentation gibt, in SMALLTALK grundsätzlich über
Konstruktoren erzeugt werden und jede Klasse Instanz ihrer Metaklasse ist, kann man sich
fragen, wie in SMALLTALK eigentlich Klassen erzeugt werden. Die Tatsache, dass es einen
Browser mit einer entsprechenden Funktion gibt, reicht als Erklärung hierfür nicht aus. An-
dererseits kann es auch keine Lösung sein, einfach new o. ä. an die Metaklasse der Klasse
zu senden, da diese ja zunächst noch gar nicht existiert. Es stellt sich hier tatsächlich die
sprichwörtliche Frage nach der Henne und dem Ei, genauer, wer von beiden zuerst existie-
ren muss .
Dieses Dilemma wird von SMALLTALK intern gelöst. Eine Klasse wird i n
SMALLTALK nämlich erzeugt, indem man einer anderen Klasse eine ent-
sprechende Nachricht schickt. Der Protokolleintrag der dazugehörigen
Methode (je nach System in der Klasse Class oder Behavior zu finden)
für Klassen ohne indizierte Instanzvariablen sieht in SQUEAK wie folgt aus:
poolDictionaries: s category: cat
ist. Verwendung der
Durch Ausführung dieser Methode wird eine neue Klasse und zugleich ihre Metaklasse an-
gelegt. Dabei kann man dem Kommentar entnehmen , dass die neue Klasse Subklasse des
Empfängers (einer Klasse) werden soll. Was das heißt, wird Gegenstand von Kapitel 11 sein.
Hier wenden wir uns lieber der Frage zu, von welchen Klassen die miterzeugten Metaklassen
Instanzen sind.
"
"35.1 Literale
In JAVA gibt es Literale für Zahlen, Zeichen und S trings. Für Arrays gibt es, da sie nicht aus
Literalen zusammengesetzt sein müssen, etwas ähnliches, nämlich die sog. Array -Initialisie-
rer; sie werden in Kapitel 41 behandelt. Ob true und false bzw. null in JAVA Literale Deployment
oder Schlüsselwörter sind, hängt vom Standpunkt ab: Die meisten Syntaxeditoren behan-
deln sie wie Schlüs selwörter, gemäß Sprachdefinition handelt es sich aber um Literale, die
die beiden Booleschen Wahrheitswerte „wahr“ und „falsch“ bzw. den Wert des Nulltypen
(UndefinedObject in SMALLTALK , in JAVA unbenannt) repräsentieren.
Zahlenliterale in JAVA können eine Vielzahl von Formen annehmen. Für
drei besondere Werte im Fließkommabereich stehen allerdings keine Literale, sondern nur
Konstanten zur Verfügung: Es sind dies NaN (für das englische Not a Number ) sowie
POSITIVE_INFINITY und NEGATIVE_INFINITY . Zeichenliterale werden in JAVA durch
einfache Anführungsstriche eingeschlossen, String -Literale durch doppelte. Beide können
Escape -Sequenzen zur Darstellung von Sonderzeichen enthalten.
Anders als in SMALLTALK sind in JAVA Klassen keine Objekte. Dennoch
muss man in Programmen gelegentlich Klassen als Werte angeben. Das geht dann nicht
(wie in SMALLTALK ) per Angabe des Klassennamens (der dort ja zugleich als Pseudovariable
definiert war), sondern mittels eines sog. Klassenliterals . Dies besteht aus dem Namen der
Klasse, gefolgt von .class , also beispielsweise
Der Typ eines solchen Klassenliterals ist Class<T> , also im obigen Beispiel
Class<Object> . Da in JAVA-Programmen Klassennamen auch direkt vorkommen dürfen,
so z. B. als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie instanceof
(s. Abschnitt 35.4), sind Klassenliterale eher selten anzutreffen (die ganze Unterscheidung
von Klassennamen und Klassenliteralen in JAVA ist m. E. alles andere als glücklich).
"
"35.4 Operationen und Methoden
Einhergehend mit der T rennung zwischen primitiven und Referenztypen
gibt es in JAVA auch eine Trennung zwischen Operationen und Methoden:
Auf den primitiven Typen sind mit der Sprachdefinition bestimmte Ope-
rationen (wie die mathematischen und die Booleschen) fest vorgegeben; alle anderen Ope-
rationen müssen als Methoden in Klassen definiert werden. Da primitive Typen aber keine
Klassen sind, gibt es z. B. für mathematische Funktionen eine spezielle Klasse Math , in der
Funktionen wie sin(.) als Klassenmethoden hinterlegt sind. Umgekehrt ist es den Klas-
sendefinitionen nicht erlaubt, Operatoren (wie die binären Methoden in SMALLTALK ; s. Ab-
schnitt 4.1.2 in Kurseinheit 1) zu definieren. Die Trennung von primitiven und Referenztypen
ist also konsequent durchgezogen58, was JAVAs Charakter als Programmiersprache anfangs
tenation (Aneinanderfügung). Strings sind aber sowieso ein Sonderfall in JAVA. Außerdem sind Iden-
titätstests ( == und !=) und Zuweisung ( =) Operatoren, die für alle Typen definiert sind. Wert - und
wesentlich geprägt und was ihr bei manchen den Ruf einer hybriden Programmiersprache
(halb objektorientiert, halb imperativ) eingebracht hat. Aus meiner Sicht ist die Unterschei-
dung zwischen Objekten und Werten, w ie sie in JAVA vorgenommen wurde, aber sinnvoll :
Werte haben weder Identität noch Zustand, was also macht sie zu Objekten?
Die Methoden JAVAs kann man in Prozeduren und Funktionen aufteilen ,
wobei der einzige Unterschied ist, dass Prozeduren nichts zurückgeben
und deswegen void anstelle des Rückgabetyp s deklarieren. Es ist d ies eine der vielen Erb-
schaften von der Programmiersprache C.
Ein Operator, der speziell für Referenztypen zur Verfügung steht, is t der
Typtest instanceof : Er erlaubt es zu prüfen, ob ein Objekt Element (In-
stanz) eines Typs ist. Dabei wird nicht zwischen direkten und indirekten Instanzen unter-
schieden: x instanceof Object wertet also immer zu true aus, egal, für welches Objekt
x steht. Mehr zur Bedeutung des Typtests in Kapitel 44.
"
"4.3.1 Zuordnung von Methoden zu Objekten
Methoden sind immer Objekten, den sogenannten Empfängerobjekten, zugeordnet. Wir
wollen uns in dieser Kurseinheit noch nicht darauf festlegen, wie diese Zuordnung erfolgt;
Sie dürfen jedoch davon ausgehen, dass jedes Objekt über einen Katalog von Methoden
verfügt und damit auf die entsprechenden Nachrichten reagieren kann. Diesen Katalog
nennt man auch das Protokoll eines Objekts (s. Abschnitt 4.3.8 ).
Die Zuordnung von Methoden zu Objekten erlaubt, dass die Methoden
auf die Instanzvariablen des jeweiligen Objekts zugreifen können. Da der
Zustand eines Objekts durch die Belegung seiner Instanzvariablen repräsentiert wird (s. Ka-
pitel 3) und weil in den Methoden das Verhalten eines Objektes spezifiziert ist, ergibt sich,
dass das Verhalten vom Zustand des Objekts abhängen (durch Berücksichtigung seiner In-
stanzvariablen) und es ihn gleichzeiti g beeinflussen (durch Zuweisungen an die Instanzvari-
ablen) kann. Da Instanzvariablen lokale Variablen sind (lokal zum besitzenden Objekt), sind
Methoden sogar die einzige Stelle, an der der Zustand von Objekten geändert werden kann.
Mehr dazu in Abschnitt 4.3.4 .
Neben den formalen Parametern der Methode und den Instanzvariablen
des Empfängerobjekts ist im Rumpf jeder Methode eine weitere Variable
zugreifbar, die den Namen „ self“ trägt. Diese Variable, di e wie die formalen Parameter eine
Pseudovariable ist, verweist immer auf das Empfängerobjekt der Nachricht, also auf das
Objekt, dessen Instanzvariablen ger ade zugreifbar sind. Sie wird immer dann benötigt,
wenn eine Nachricht aus einer Methode heraus (also per darin enthaltener Anweisung) an
das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. self
ist also gewissermaßen der implizite erste Parameter einer Methode. Methoden als
"
"9.2 Spezialisierung
Ähnlich wie bei der Klassifikation kann man das Prinzip der Generalisie rung umkehren. Man
redet dann von der Spezialisierung . Während die Generalisierung Eigenschaften weg lässt
oder generalisiert (Abstraktion), fügt die Spezialisierung Eigenscha ften hinzu oder speziali-
siert bereits vorhandene. Man kann also von jeder Klasse sagen, dass sie eine Spezialisierung
ihrer Generalisierungen ist (so sie denn welche hat).
Dass eine Generalisierung bereits über Spezial isierungen verfügt, hindert
eine nicht daran, neue hinzuzufügen. So ist es beispielsweise im obigen
Beispiel von Zweibeiner denkbar, dass man im Nachhinein noch Menschenaffe als Spe-
zialisierung ergänzt. Als Differentia käme z. B. eine Methode hangeln in Frage, die Mensch
und Vogel fehlt. Sie zu ergänzen stellt überhaupt kein Problem dar — ja es ist sogar eine
der größten Errungenschaften der objektorientierte n Programmierung, dass solche Pro-
grammerweiter ungen modular, also ohne andere Teile des Programms zu betreffen, immer
möglich sind. Mehr dazu in Kapitel 26 in Kurseinheit 3.
Leider ist es in der Programmierpraxis nicht immer ganz so einfach. Viel-
mehr findet man häufig Klassen (bzw. Instanzen) vor, die ungefähr das
tun, was man möchte, und denen man nur noch ein wenig hinzufügen
möchte. Man möchte dann von einer Klasse speziali sieren, die selbst keine Generalisierung
im obigen Sinne ist. Um beim obigen Beispiel mit Menschen und Vögeln zu bleiben, könnte
man beispielsweise auf den Gedanken kommen, Pinguine als Spezialisierung von Vögeln
einzuführen:
Universum
Zweibeiner
MenschVogel
Pinguin
Es ist nun fraglich, ob dam it auch Vogel zu einer Generalisierung von Pinguin wird. Die
Tatsache, dass Vogel eigene, direkte Instanzen hat, spricht schon einmal dagegen (auch
wenn der Begri ff der Generalisierung landläufig nicht so streng gefasst wird). Weiterhin
kann man sich fragen, was man von der Intension von Pinguin weglassen müsste , um zur
Intension von Vogel zu gelangen. Dies könnte z. B. schwimmeNach: sein. Spätestens dann
fällt einer jedoch auf, dass Pinguine gar nicht fliegen können, also die Intension von Vogel
die Methode fliegeNach: gar nicht enthalten dürfte, wenn Vogel eine Generalisierung
von Pinguin sein sollte. Dieses Problem, das in der Praxis ständig vorkommt, lässt sich auf
elegante Weise dadurch lösen, dass man eine Klasse NichtPinguin parallel zu Pinguin Spezialisierung von
spezialisiert und alle Eigenschaften, die andere Vögel von Pinguinen unterscheidet (wie z. B.
fliegeAn: ), dort hineinpackt.
Universum
Zweibeiner
MenschVogel
Pinguin
Nicht -
Pinguin
Ähnlich wie bei der Generalisierung ist es bei der Spezialisierung auch
möglich, dies ohne das Hinzufügen von Eigenschaften zu bewerkstelli-
gen, nämlich durch das Einschrän ken von Eigenschaften. So kann man
z. B. bei der Spezialisierung von Säugetier zu Zweibeiner den Wertebereich der In-
stanzvariable anzahlBeine von {2, 4} (also entweder zwei oder vier) auf { 2} (also nur noch
zwei) eingeschränkt werden. Die sprachlichen Mög lichkeiten, dies auf Klassendefinitionse-
bene auszudrücken, sind allerdings in SMALLTALK (wie bereits im Zusammenhang mit der
Generalisierung erwähnt) nicht gegeben; sie kommen erst mit der Typisierung von Variablen
(Kapitel 18 in Kurseinheit 3). Die Einschränkung des Wertebereichs per Spezialisierung ist
aber in jedem Fall zu unterscheiden von der Instanziierung, im Zuge derer (ggf. über eine
Initialisierung ) einer Instanzvariable eines Objekts ein Element aus dem Wertebereich (wie
z. B. 2) zugewiesen wird. Dass im Fall von Zweibeiner dafür dann nur noch ein Element
als Wert in Frage ko mmt, spielt dabei keine Rolle.
Vollkommen unvereinbar mit der Spezialisierung ist übrigens, Instanzva-
riablen oder Methoden wegzunehmen. Dies folgt schon daraus, dass die
Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen
entstanden sein könnte. Die Richtung von Spezialisierung und Generalisierung würde zu-
dem, wenn nach Belieben in beide Richtungen hinzugefügt und wegegenommen werde n
dürfte, ebenfalls beliebig. Spezialisierung ohne
Hinzufügen von
Eigenschaften
Spezialisierung darf
nichts wegnehmen IInn ddeerr oobbjjeekkttoorriieennttiieerrtteenn PPrrooggrraammmmiieerruunngg IInnssttaannzziiiieerruunngg mmiitt SSppeezziiaalliissiieerruunngg zzuu vveerr--
wweecchhsseellnn iisstt ggeennaauu ssoo ssttrrääfflliicchh wwiiee iinn ddeerr MMaatthheemmaattiikk EElleemmeennttsseeiinn (()) mmiitt EEnntthhaalltteennsseeiinn
(())..
"
"35.5 Zuweisungskompatibilität
In JAVA ist die Typkonformität und damit die Zuweisungskompatibilität unter Referenztypen
an Subtyping gebunden: Damit Ausdrücke von einem Typ Variablen eines anderen zuge-
wiesen werden können, müssen die Typen entweder gleich sein oder es muss eine Subtyp-
beziehung zwischen den beiden bestehen. In den meisten Fällen muss die Subtyp beziehung
explizit deklariert werden; JAVA setzt also auf nominale Typkonformität . Dies hat den in
Abschnitt 22.2 von Kurseinheit 3 beschriebenen Vorteil der Filterfunktion, aber auch den
Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen, was insbesondere bei
verteilten Anwendungen, deren Teile nicht von vornherein füreinander entworfen waren
(Web Services beispielsweise), von Nachteil ist. Weiterhin verlangt das Subtyping JAVAs, dass
die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht abgeändert
werden — JAVA verlangt also Novarianz . Damit wird zumindest eine statisch -semantische
Substituierbarkeit von Objekten der Subtypen gegen die ihrer Supertypen sichergestellt (vgl.
Abschnitt 26.3 und Kapitel 54 in Kurseinheit 6). Allerdings kann der Rückgabetyp von Me-
thoden kovariant redefiniert werden; mehr dazu in Abschnitt 36.4.
Im Gegensatz zu ihren Vorläufern SMALLTALK und C++ ist JAVA eine Spra-
che mit einem strengen Typsystem. Das heißt insbesondere, dass in JAVA
alle Typfehler entweder schon während der Übersetzung vom Compiler oder aber während
der Ausführung vom Laufzeitsyst em, dann aber schon zum frühest möglichen Zeitpunkt,
nämlich bei einer Wertzuweisung (bei der ja die Verletzung einer Typinvariante entsteht),
abgefangen werden. In einem Fall kann man jedoch der Meinung sein, dass die Typinvari-
anten JAVAs zu lax gefasst sind, also Zuweisungen gestattet werden, von denen man nicht
ausschließen kann, dass sie in der Folge zu einem Typfehler führen. Mehr dazu in Kapitel 41. Void -Methoden als
"
"4.3.2 Methodenaufruf und dynamisches Binden
Wenn das Versenden von Nachrichten bislang als die Übergabe eines entsprechenden Nach-
richtenobjekts an den Empfänger dargestellt wurde, so ist das nicht ganz richtig: Vielmehr
wird ein Nachrichtenausdruck auch in SMALLTALK aus Effizienzgründen vom Compiler in ei-
nen schnöden Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der proze-
duralen Programmierung (also z. B. PASCAL oder C) vergleichbar ist. So führt beispielsweise
der Ausdruck
zum Aufruf der Methode +, wie sie für das Objekt „1“ (und alle Zahlen) definiert wurde.
Dennoch wird, wohl aus didaktischen Gründen, das Mysterium vom N achrichtenversand in
der objektorientierten Literatur weiter gepflegt. Es gibt aber auch einen kleinen, feinen Un-
terschied zum gewöhnlichen Prozeduraufruf.
Die Entscheidung, welche Methode in Reaktion auf einen Nachrichten-
versand aufgerufen und abgearbeitet wird, hängt nicht von dem Nach-
richtenselektor allein ab, sondern auch von dem Objekt, an das die Nachricht geschickt wird.
Es ist nämlich durchaus üblich, dass verschiedene Objekte mit gleichen Methodensignaturen
untersc hiedliche Methodenimplementierungen verbinden; so implementieren beispiels-
weise Zahlen und Symbole die Methode printString jeweils anders und selbst
führt zum Aufruf einer anderen Methode als 1 + 2 ,
dagegen nicht.
Aus der Abhängigkeit des Methodenaufrufs vom Empfängerobjekt folgt,
dass nicht immer schon zur Übersetzungszeit entschieden werden kann, welche Methoden-
implementierung bei einem Methodenaufruf ausgewählt werden muss . Wenn nämlich das
Empfängerobjekt dur ch eine Variable benannt oder von einem Ausdruck geliefert wird,
kann die Zuordnung einer Methodendefinition zu einem Nachrichtenausdruck erst zum Zeit-
punkt der Auswertung des Nachrichtenausdrucks und damit erst zur Laufzeit erfolgen. Man
nennt diesen Vorg ang dynamisches Binden (im Gegensatz zum statischen Binden , bei
dem ein Aufruf schon zur Übersetzungszeit an eine Implementierung gebunden wird); es
handelt sich dabei um eine von den nur zwei primitiven Kontrollstrukturen SMALLTALK s (s.
Abschnitt 4.5.2 ).
Das dynamische Binden ist eine der charakteristischen Eigenschaften der
objektorientierten Programmi erung. Sie wird auch als Polymorphismus Abhängigkeit vom
oder Polymorphie22 bezeichnet. Auf die Details des dynamischen Bindens können wir erst
in der nächsten Kurseinheit (Kapitel 12) zu sprechen kommen und auf Polymorphie erst in
Kapit el 26, da uns hier noch zu viel fehlt. Wir vermerken aber schon jetzt, dass es sich dabei
um eine versteckte Fallunterscheidung handelt: Ein und derselbe Methodenaufruf kann fall-
weise unterschiedliche Methoden aufrufen (bzw. deren Ausführung veranlassen). Auf diese
Eigenschaft kommen wir schon in den Abschnit ten 4.5 und 4.6 zurück.
Steht einmal fest, welche (Implementierung einer) Methode aufgerufen
wird, erfolgt als nächstes die Versorgung der formalen Parameter mit Ob-
jekten . Zu diesem Zweck findet mit dem Aufruf eine implizite Zuwei-
sung (also eine ohne Vorkommen des Zuweisungsoperators im Pro-
grammtext) der tatsächlich en Parameter des Aufrufs an die formalen Parameter der Me-
thode statt. Tatsächlich e Parameter sind dabei die Objekte, die an der Methodenaufrufstelle
als Argumente an den Positionen der formalen Parameter der aufgerufenen Methode ste-
hen. M anchmal werden auch die Variablen, die an den entsprechenden Stellen beim Me-
thodenaufruf stehen, als tatsächlich e Parameter bezeichnet, aber erstens müssen dort nicht
unbedingt Variablen, sondern können beliebige Ausdrücke stehen und zweitens können
diese Variablen selbst formale Parameter sein, nämlich die der Methode, die den Metho-
denaufruf enthält. So ist in der Methodendefinition
a der formale Parameter von m:. Der tatsächlich e Parameter von m: ist ein Objekt, das beim
Aufruf von m: gena nnt wird (hier nicht zu sehen). Dieses Objekt ist dann auch tatsächlich er
Parameter des Aufrufs von n:, da dieser von a, dem formalen Parameter von m:, geliefert
wird.
Je nach Sichtweise erfolgt bei Ausführung der Return -Anweisung eine
weitere implizite Zuweisung, nämlich die des Objekts, zu dem der Aus-
druck der Return -Anweisung auswertet, an die „Variable“ Methodenname (der ja an der
Stelle des Methodenaufrufs ähnlich w ie eine Variable für ein Objekt steht). Dies ist vor allem
im Zusammenhang mit der Typprüfung, die es jedoch in SMALLTALK nicht gibt (s. Kursein-
heit 3), eine wichtige Vorstellung. An der Aufrufstelle selbst steht dann häufig noch eine
explizite Zuweisung , nämlich wenn das Ergebnis des Aufrufs (das Rückgabeobjekt) einer
Variable zugewiesen werden soll.
Selbsttestaufgabe 4.1
Benennen Sie die expliziten und impliziten Zuweisungen für
Im Gebrauch scheint sich anzudeuten, dass man von Inklusionspolymorphie und von parametrischem
Polymorphismus spricht, aber einen Grund dafür kann ich nicht erkennen. implizite
mit der Methode
In Abschnitt 1.5 waren wir auf den Unterschied zwischen Wertsemantik
und Verweissemantik eingegangen. Damit verwandt (und ähnlich be-
nannt) ist die Unterscheidung von Call by reference und Call by value beim Methoden-
aufruf: Beim Call by value wird dem formalen Parameter der tatsächlich e Parameter als Wert
zugewiesen, beim Call by reference hingegen nur eine Referenz. Diese Referenz ist jedoch
nicht, wie man vielleicht glauben könnte, eine auf den tatsächlich en Parameter als Objekt,
sondern eine auf den tatsächlich en Parameter als Variable (s. o.), der dazu aber eben auch
eine Variable sein muss . Dies hat zur Folge, dass Zuweisungen zum formalen Parameter in
der Methode unter Call by reference auch die Variable, die den tatsächlich en Parameter
darstellt, betreffen — die beiden sind gewissermaßen eins. Mit Call by reference ist es also
möglich, dass eine Methode auch übe r ihre tatsächlich en Parameter, wenn sie denn Variab-
len sind, Objekte zurückgibt — sie werden damit zu Ein - und Ausgabeparametern der Me-
thode. Bei Call by value bleibt die Zuweisung an die formalen Parameter jedoch ohne Be-
deutung für die tatsächlich en — sie sind also reine Eingabeparameter.
Nun werden Sie vielleicht einwenden, dass in SMALLTALK formale Parame-
ter Pseudovariablen sind und deswegen gar keine Zuweisung an sie er-
laubt i st (außer der impliziten Zuweisung beim Aufruf). Das ist richtig.
Tatsächlich gibt es in SMALLTALK ein Call by reference auch gar nicht (in
JAVA übrigens auch nicht). Gleichzeitig haben aber in SMALLTALK Variablen
grundsätzlich Referenzsemantik, so dass bei der Zuweisung der tatsächlich en an die forma-
len Parameter keine Objekte, sondern lediglich Verweise an diese übergeben werden. Wenn
man da nn innerhalb der Methode etwas an diesen Objekten ändert (ihren Zustand), dann
betrifft das immer die tatsächlich en Parameterobjekte und somit auch den „Inhalt“ der tat-
sächlich en Parametervariablen (wenn es denn Variablen und keine anderen Ausdrücke sind
und wenn sie wirklich ein Objekt zum Inhalt hätten; vgl. Abschnitt 1.5): Es sind schließlich
dieselben Objekte. Insbesondere erhalten die Methoden also keine Kopien dieser Objekte,
sondern lediglich Kopien der Referenzen. Um den Inhalt von tatsächlich en Parametervariab-
len zu ändern (also sie auf andere Objekte zeigen zu lassen), bräuchte man auch in SMALL-
TALK (und JAVA) Call by reference , was es dort aber nicht gibt. Es stellt dies eine echte Be-
schränkung der Programmierung dar; sie wurde denn auch in C# aufgehoben.
Bleibt noch die Frage, was passiert, wenn ein Methodenaufruf ins Leere
läuft. Da in SMALLTALK Ausdrücke beliebige Objekt e liefern können, kann
der Compiler für einen Nachrichtenausdruck nicht garantieren, dass das
Empfängerobjekt auch über eine entsprechende Methode verfügt. Da der Nachrichtenaus-
druck in einen dynamisch gebundenen Methodenaufruf übersetzt wird, dessen Ausfü hrung
direkt von der virtuellen Maschine SMALLTALK s Call by reference und
vorgenommen wird, ist die Frage, wie das Programm sinnvoll mit einem solchen Laufzeit-
fehler umgehen soll. Tatsächlich passiert in etwa folgendes: Die virtuelle Maschine macht
aus dem Methodenaufruf einen Nachrichtenselektor (und zwar den, aus dem er bei der
Übersetzung hervorgegangen ist) und sendet diesen als Parameter an eine vorgegebene
Methode doesNotUnderstand: des ursprünglichen Empfängers. Diese reagiert typischer-
weise mit einer der Ausgabe einer Fe hlermeldung <Objekt> does not understand:
<Nachrichtenselektor> ; sie kann aber geändert werden, um anders als standardmäßig
vorgesehen auf den Fehler zu reagieren.
"
"55 Das Fragile -base -class -Problem
Unter dem Fragile -base -class -Problem versteht man eine ganze Familie von Problemen,
die in unmittelbarem Zusammenhang mit der Vererbung stehen. Dabei ist der Name inso-
fern etwas irreführend, als nicht unbedingt die Basisklassen , also die Superklassen (vgl. Ab-
schnitt 11.1), die „anfälligen “ oder „zerbrechlichen “ sind, sondern eher die Klassen, die
von ihnen erben. Ein einfaches Beispiel soll erläutern, worum es geht.
Wir nehmen an, wir hätten eine Klass e TapeArchive geschrieben, die Videobänder archi-
viert. Da es sich nicht um eine Mickey -Maus -Anwendung auf dem heimischen Desktop han-
delt, sondern um ein kommerzielles System, erfolgt die Datenhaltung in einer Datenbank.
Die folgende SMALLTALK -Klassendefinition gibt einen kleinen Ausschnitt des Systems wieder.
Klasse TapeArchive
benannte Instanzvariablen database
Klassenmethoden
Instanzmethoden
Nun ist es in der objektorientierten Programmierung üblich, dass man solche Klassen wie-
derverwend et, indem man davon neue Klassen ableitet. Wenn beispielsweise eine Kundin-
nenanforderung kommt, nach der mit jeder Archivierung eine Nachricht verschickt werden
muss , die das anzeigt, und wenn diese neue Anforderung nicht für alle Kundinnen der Soft-
ware gleichermaßen interessant ist, dann schreibt man eine Subklasse, die das geänderte
Verhalten bereitstellt:
Klasse NotifyingTapeArchive
benannte Instanzvariablen listener
Superklasse TapeArchive
Klassenmethoden
Instanzmethoden
Das Schöne an der Objektorientierung ist dabei, dass man nu r die Unter-
schiede (Differentia ) spezifizieren muss — der Rest wird einfach geerbt.
So genügt es im gegebenen Fall, die Initialisierung (nicht so interessant) und die Methode
addTape: anzupassen. Das Verhalten von addAllTapes: kann unverändert bleiben, da
dies die (dynamisch gebundene) Methode addTape: aufruft und somit auch das von
NotifyingTapeArchive geforderte Verhalten, nämlich die Notifikation aller archivierten
Bänder, garantiert. Ein ganz ähnliches Beispiel (anhand der Klasse Collection ) war Ihnen
in Kurseinheit 2, Abschnitt 10.3 schon einmal begegnet; es handelt sich auch hier um einen
Fall von offener Rekursion , die erst durch dynamisches Binden (Kapitel 12) aufgelöst wird.
Aufrufe dieser Art sind das Herz vieler objektorientierter (Anwendungs -)Frameworks und
auch diverser Entwurfsmuster.
Oder auch nicht. Das Problem ist nämlich, dass man der Klasse
TapeArchive weder ansieht, was sie garantiert, noch, wovon die Korrektheit ihrer Sub-
klassen abhängt. Wenn in der Folge z. B. eine anderere Kundin nörgelt, das Hinzufügen von
großen Mengen von Bändern dauere zu lange, wenn man das wiederholte Aufrufen von
addTape: aus addAllTapes: und die dadurch bedingte wiederholte Ausführung von
beginTrans action und endTransaction als Ursa che ausmacht und wenn man dann
in Erwägung zieht, nicht nur die nörgelnde Kundin in ihrer Version, sondern alle Kundinnen
mit der optimierten Implementierung
Klasse TapeArchive
Instanzmethoden
zu beglücken, was spräche dagegen?
Selbsttestaufgabe 55.1
Bevor Sie weiterlesen, antworten Sie: Was spräche dagegen?
Vermutlich nur die wenigsten unter Ihnen werden sofort sagen können, was dagegen
spricht, denn in der Klasse TapeArchive scheint nach wie vor alles in bester Ordnung zu
sein. Was man nämlich nicht sehen kann, ist, dass die Korrektheit der Methode
addAllTapes: davon abhängt, dass sie addTape: aufruft — zwar nicht für die Klasse
TapeArch ive selbst, dafür aber für ihre Subklasse NotifyingTapeArchive . Hier werden
jetzt nämlich nur noch für einzeln archivierte Bänder Benachrichtigungen verschickt.
Hand aufs Herz: Hätten Sie den Fehler vorhergesagt? Wenn nicht, dann liegt das vermutlich
daran, dass Sie der Täuschung erlegen sind, addAllTapes: in TapeArchive würde die
benachbarte Methode addTape: aufrufen, und wenn man nur den Beitrag von addTape:
in addAllTapes: verlagert und dafür addTape: nicht mehr aufruft, dann wäre das eine
semantikerhaltende Umstrukturierung (ein sog. Refactoring ; s. Kurs 01853). Tatsächlich be-
raubt aber genau dies die Subklassen der Möglichkeit, eigenes Verhalten an genau dieser
Stelle — dem Aufruf von addTape: — einzubringen, und wenn eine solche Beraubung im
Nachhinein erfolgt, kann sie eben den Code „zerbrechen“.
Das Schlimme an diesem Problem ist, dass man noch nicht einmal genau
weiß, wem man die Schuld geben soll — TapeArchive , weil es einen Vertrag bricht, den
es gar nicht paraphiert hat (oder weil es keine Rück sicht auf Subklassen nimmt, die es gar
nicht kennt), oder NotifyingTapeArchive , weil es sich grundlos darauf ver lässt, dass die
geerbten Methoden dauerhaft die eigenen (in diesem Fall das geerbte addAllTapes: das
eigene addTape: ) aufrufen? Wenn noch nicht einmal die Schuld feststeht — wie kann man
das Problem verhindern?
Es gibt zahlreiche Varianten des Fragile -base-class-Problems, die hier nicht alle aufgeführt
werden sollen. Zugrunde liegt ihnen immer dasselbe: Zwischen einer Klasse und ihren Sub-
klassen bestehen durch die Vererbung von Eigenschaften starke Abhängigkeiten, die —
wenn überhaupt — nur unvollständig dokumentiert sind. Zwar könnte man annehmen,
dass von allem, was vererbt wird, eine Abhängig keit ausgeht, die man bei Änderungen
pauschal berücksichtigen muss , aber dies würde die Möglichkeiten, in Superklassen etwas
zu ändern, so stark einschränken, dass das ganze Konzept ad absurdum geführt würde. Es
bleibt also nicht viel mehr, als beim Einsatz von Vererbung große Vorsicht walten zu lassen
oder sie ganz zu verbieten.
Das folgende , im Kontext des Component Object Models (COM) getätigte Zitat aus dem
Hause MICROSOFT fasst es schön zusammen:
Implementation inheritance —the ability of one component to ""subclass"" or in-
herit some of its functionality from another component —is a very useful tech-
nology for building applications. Implementation inheritance, however, can c re-
ate many problems in a distributed, evolving object system.
The problem with implementation inheritance is that the “contract” or relation-
ship between components in an implementation hierarchy is not clearly defined;
it is implicit and ambiguous. When th e parent or child component changes its
behavior unexpectedly, the behavior of related components may become un-
defined. This is not a problem when the implementation hierarchy is under the
control of a defined group of programmers who can make updates to a ll com-
ponents simultaneously. But it is precisely this ability to control and change a
set of related components simultaneously that differentiates an application,
even a complex application, from a true distributed object system. So while im-
plementation i nheritance can be a very good thing for building applications, it
is not appropriate for a system object model that defines an architecture for
component software.
In a system built of components provided by a variety of vendors, it is critical
that a given component provider be able to revise, update, and distribute (or
redistribute) his product without breaking existing code in the field that is using
the previous revision or revisions of his component. In order to achieve this,
it is necessary that the actual interface on the component used by such
clients be crystal clear to both parties. Otherwise, how can the component
provider be sure to maintain that interface and thus not break the existing cli-
ents?
Auf die objektorientierte Programmierung übertragen ist das Problem also, dass der Vertrag
zwischen den Klassen einer Vererbungshierarchie nicht klar definiert ist. Wenn die Super -
oder Subklasse ihr Verhalten uner wartet verändert, kann daraus undefiniertes Verhalten
verwandter Klassen resultieren. Tatsächlich war die Vererbung von Implementierung aus der
Spezifikation von MICROSOFT s Component Object Model (COM) verbannt; stattdessen setzte
man voll auf die Vererbung von Interfaces (was wir als Subtyping bezeichnen würden). In-
zwischen (mit dem .NET -Framework) ist diese harte Haltung wieder aufgegeben worden,
was wohl auch da ran liegt, dass hier Komponenten Klassen sind; es bleiben jedoch die in
Kapitel 50 (im Kontext von C#) erwähnten Vorbehalte gegenüber dem dynamischen Binden.
Nun liegt ja zunächst nahe, bei der Vererbung das zu tun, was man bei
Abhängigkeiten immer macht : Schnittstellen einzuführen. Im Gegensatz zu der Schnitt-
stelle, die einem Klient einer Klasse angeboten wird (der diese Schnittstelle nutzt, indem er
seine Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der
Klasse zugreifen kann), handelt es sich bei der Schnittstelle zwischen einer Klasse und ihren
Subklassen jedoch um eine etwas anders geartete: Hier gibt es lediglich zwei Variablen self
(bzw. this ) und super , die allerdings keine Abhängigkeit von anderen Objekten ausdrü-
cken und die zudem nicht explizit typisiert sind. Die damit verbundene Schnittstelle, also die
Menge der Eigenschaften, auf die man über diese Variable zugreifen kann, und wo man
diese Eigenschaften dann findet (also wo sie definiert sind), muss man sich sel bst zusam-
mensuchen. Mit Information hiding und dem Verbergen von Implementationsgeheimnissen
hat das freilich nichts zu tun. Was man vielmehr bräuchte, wäre ein explizites Vererbungs-
interface .
Einige erste, zarte Ansätze zur Einführung von expliziten Vererbungsin-
terfaces hatten Sie bereits gesehen: Die Verwendung des Zugriffsmodifi-
zierers protected in JAVA, C# und C++ sowie die explizite Deklaration von Überschreib-
barkeit und Überschreibung mittels virtual und override in C# (und C++). Im obigen
Beispiel würde die Deklaration von addTape: als nicht überschreibbar (und somit als nicht
dynamisch, sondern statisch gebunden) verhindern, dass NotifyingTap eArchive diese
Methode abändert und sich zugleich darauf ver lässt, dass die geerbte Methode
addAllTapes: die überschreibende Version von addTape: aufruft (sie könnte sie aber
immerhin noch neu einführen, aber diese neue Version würde beim Binden in
addAllTapes: nicht berücksichtigt). NotifyingTapeArchive müsste dann wohl oder
übel beide Methoden neu implementieren und könnte bei der Gelegenheit selbst dafür
Sorge tragen, dass addAllTapes: den Fehler nicht macht. Allerdings würde dadurch auch
bei eine m direkten Aufruf von addTape: von außerhalb auf einer Variable vom Typ
TapeArchive , die eine Instanz vom Typ NotifyingTapeArchive hält, die überschrei-
bende Implementierung unberücksichtigt bleiben (da ja keine dynamische Bindung mehr
stattfindet). Im Gege nsatz dazu würde die Verwendung von virtual bei addTape: in
TapeArchive der Programmiererin einen Hinweis darauf geben, dass die Methode in Sub-
klassen für diese relevante Modi fikationen enthalten kann, so dass man Aufrufe dieser Me-
thode nicht einfach, wie im obigen Beispiel geschehen, kürzen kann .
Wenn es um die Sicht - und Zugreifbarkeit von Elementen geht, scheint
der Zugriffsmodif izierer protected zunächst auf gleicher Ebene mit
public und friend zwischen zwei (nicht über Vererbung in Beziehung stehenden) Klassen
zu stehen: die protected deklarierten Elemente einer Klasse sind wie bei einem dedizierten
Export (s. Abschnitt 52.2) auch in ihren Subklassen sicht - und verwendbar. Was allerdings
nicht so klar ist, ist, dass überschreibende, als protected deklarierte Methoden auch für
den Code der Superklasse zugreifbar s ind: eine protected Methode einer Subklasse kann
— über das dynamische Binden auf self bzw. this — aus der Superklasse heraus aufge-
rufen werden, ohne dass die Subklasse irgendeinen Hinweis darauf enthält. Anders als bei
der Zugreifbar machung mit public oder friend bei nicht über Vererbung in Beziehung
stehenden Klassen kann die Zugreifbar keit also in beide Richtungen gehen, und zwar ab-
hängig davon, ob die Methode überschrieben wird oder nicht: Wird sie überschrieben, kann
die überschreibende (in der Subklas se) von der Superklasse aus aufgerufen werden und die protected , virtual
überschriebene (in der Superklasse) von der Subklasse (über super ) — wird sie nicht über-
schrieben, kann die Methode der Superklasse aus der Subklasse heraus aufgerufen werden.
Es bleibt also ein höchs t verworrener Eindruck. Dies ist um so bedauerlicher, als BJARNE
STROUSTRUP selbst kommentierte:
One of my concerns about protected is exactly that it makes it too easy to use
a common base the wa y one might sloppily have used global data. … In retro-
spect, I think that protected is a case where “good arguments” and fashion
overcame my better judgement and my rules of thumb for accepting new fea-
tures.
Bei der Definition von JAVA fand das offenbar kein Gehör. Und so bleiben die Schlüsselwör-
ter protected , virtual und override nicht viel mehr als Zeichen des Bewusst seins,
dass es das Fragile -base-class-Problem gibt.
"
"68.3 Ein Beispiel
Ein konkretes Beispiel für die Verletzung des Law of Demeter ist die folgende alternative
Implementierung der Methode auswerten in der Klasse Klausel (Zeilen 1650 –1652 ):
Hier wird (in Zeilen 1672 und 1673 ) zunächst atom an l (ein Literal, das dem Empfänger
der Methode, einer Klausel, bekannt ist) geschickt und dann an das Ergebnis, ein Atom, die
Nachricht wert . Diese Verkettung ist ein Verstoß gegen das Gesetz Demeters. Di e Muster-
lösung
enthält diesen Verstoß nicht. Dafür aber andere.
Selbsttestaufgabe 68.1
Versuchen Sie, bevor Sie wei terlesen, weitere Verstöße gegen das Gesetz Demeters in dem Beispiel
zu finden.
Der erste Verstoß ergibt sich aus der Umsetzung der : n-Beziehung zwischen Klausel und
Literalen über Zwischenobjekte. Eine Klausel kennt genaugenommen nicht ihre Literale di-
rekt, sondern das Zwischenobjekt, in diesem Fall eine Instanz der Klasse Set. So stellt bereits
der Aufruf von atom bzw. auswerten auf der Variable l eine Verletzung des Law of De-
meter dar. Etwas deutlicher sieht man das, wenn man anstelle einer Menge und de s Itera-
tors detect: ein Array und eine Zählschleife verwendet:
Bei der Verwendung von Collections als Zwischenobjekte muss man also immer eine Aus-
nahme von Demeters Gesetz machen.
Der zweite Verstoß findet sich in Zeile 1672 : atom wert not ist ein verketteter Ausdruck
derselben Qualität wie l atom wert (selbe Zeile). Die Lösung wäre hier, der Klasse Atom
eine Methode not zu spendieren, die den negierten Wert zurückliefert, aber warum das
besserer Stil sein soll, ist kaum noch zu begründen. Auch wenn dieses Problem in JAVA und
Co. nicht existiert (da hier die logische Negation keine Nachric ht/Methode, sondern ein pri-
mitiver Operator eines primitiven Datentyps ist), so zeigt es doch die Grenzen des Law of
Demeter auf. So ist das Gesetz auch nicht allgemein anerkannt, sondern umstritten; den-
noch sollte man es verinnerlichen und sich bei Ketten ausdrücken stets fragen, ob nicht eine
Verlagerung einer hinteren Methode in eines der Objekte auf der Strecke sinnvoll wäre.
"
"54.1 Der Begriff der Substituierbarkeit
Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs
da auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn das gutgeht,
also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen ,
spricht man von der Substituierbarkeit der Objekte des Typen auf der linken Seite der
Zuweisung durch die des Typen auf der rechten.
Nun ist die Frage, ob eine Zuweis ung gutgeht, eine, die man gern automatisch, am besten
durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der
Programmierung zu einem eigenständigen geworden, der zunächst unabhängig von der
(an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der
Begriff der Substituierbarkeit soll daher zunächst einmal genauer untersucht werden.
In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein
Objekt ein anderes nur dann substituieren, wenn sich das auf den Pro-
grammablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Ob-
jekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben
Klasse85 sein), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand
wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack
gerade leer ist , ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar:
Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall
scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus War-
tungsgründen substituiert werden müsste n), gibt es wohl kaum einen Grund für eine Sub-
stituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend
eng gefasst en Substituierbarkeitsbegriff.
Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zu-
stand der Objekte unabhängig sein. Das hat den Vorteil, dass man die
Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs - (oder Entwurfs -
)Zeit verlagern kann. Auf di eser Ebene ist aber zumindest das Verhalten aller Objekte einer
Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegensei-
tige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.
Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte
nicht derselben Klasse angehören und wenn man eine gewisse Abwei-
chung im Verhalten von zu substituierenden Objekten zu lässt. So könnte
man sich bei spielsweise vorstellen, dass ein substituierendes Objekt funk-
tional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen
Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen.
Diese sog. nichtfunktionalen Anforderungen , die normalerweise von den funktionalen ge-
trennt dargestellt werden, sind aber in Wirklichkeit gar nicht immer hundertprozentig davon
zu trennen und es ist durchaus vorstellbar, dass ein Programm, das von einem funktionie-
renden nur in nicht -funktionalen Eigenschaften abweich t, nicht funktioniert (beispielsweise
weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu
Abbrüchen durch Time outs o. ä. führt).
Ein klassisches Beispiel für die gegenseitige Austauschbarkeit fun ktional
äquivalenter, aber verschiedener Typen ist die plattformunabhängige
GUI-Program mierung. So basiert beispielsweise die GUI -Programmierung von und mit E-
CLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also
Fenster , Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenhei-
ten angepassten Implementierungen dieser GUI -Elemente. Es ist also sinnvoll, für jeden Typ
nicht festgelegt. Selbst bei einer abstrakten Spezifikatio n des Verhaltens (z. B. durch einen abstrakten
Datentyp) wird aber in der Regel nur funktionales Verhalten beschrieben und keine nichtfunktionalen
Aspekte wie beispielsweise Zeitverhalten. Auch aus nichtfunktionalen Anforderungen kann sich aber
eine mangel nde Substituierbarkeit ergeben (s. u.). strengste Auslegung
des Begriffs de r
Substituierbarkeit
Loslösung vom
Zustand der Objek te
Substituierbarkeit be i
von GUI -Element eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die
Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte die-
ser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs)
funktional äquivalent, können sich aber in Aussehen und ggf. auch Detailverh alten (gegen-
über dem Bediener) unterscheiden. Diese Unterschiede sind jedoch gewollt und die Substi-
tuierbarkeit bleibt davon unberührt.
Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs
von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Ver-
halten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie bei-
spielsweise an einen Editor, der eine Funktion „rückgängig machen“ hat,
die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen,
und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind
in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gi bt, der
erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinn-
voll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion „ausführen“ auch
noch eine „Rückgängigmachen“ haben, die, für jeden Typ von Aktion versc hieden, das je-
weils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbe-
stand der Ausführ - und Rückgängigmachbarkeit angeht, gegeneinander austauschbar und
die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Type n Aktion , ob-
wohl ihr konkretes Verhalten, also das, was jeweils mit „ausführen“ und „rückgängig ma-
chen“ verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Sub-
stituierbarkeit sind in diesem Fall also eher gering.
Im allgemeinen als nicht gegeneinander austauschbar angesehen wird je-
doch Verhalten, bei dem eine Funktion, die in dem auszutauschenden
Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre
beispielsweise eine Aktion, für die „rückgängig machen“ nicht definiert
ist (z. B. Speichern ), kein Subtyp von Aktion , da Objekte dieses Typs nicht überall da
auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es aus-
reicht, die Funktion „rückgängig machen“ in Speichern leer zu implementieren, also bei-
spielsweise nichts passieren zu lassen oder eine Meldung „rückgängig Machen leider nicht
möglich“ auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde
immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rück-
gängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit
strenggenommen n icht gegen andere Objekte vom Typ Aktion austauschbar.
"
"46.2 Interne Iteration
Von SMALLTALK kennen Sie ja schon die Möglichkeit, Iterationen als Methoden der Collec-
tion-Klassen zu definieren (die interne Iteration ; s. Abschnitt 4.6.4 in Kurseinheit 1 und Ka-
pitel 13 in Kurseinheit 2). Mit Version 8 wurden nun auch in JAVA (anonyme) Funktionen
(die sog. Lambda -Ausdrücke ) eingeführt, die interne Iterationen à la SMALLTALK erlauben .
Allerdings wurden für die Implementierung der Methoden forEach , filter , map und
reduce (entsprechend SMALLTALK s do, select , collect und inject ) ein eigenes Frame-
work geschaffen: die sog. Streams . For-each -Schleife
Streams sind ein mit JAVA 8 neu einge führtes Konstrukt, da s eine Daten-
verarbeitung in Pipelines ganz ähnlich wie die Collections in SMALLTALK erlaubt: Das Ergebnis
einer Operation wie filter oder map, auf einem Stream ausgeführt, ist wieder ein Stream,
auf dem weitere Operationen dieser Art ausgeführt werden können (das Pipelining ). Das
besondere an Streams ist, dass sie keine Datenspeicher wie Collections sind, sondern interne
Iteratoren : Jeder Stream für sich hält zu einem Zeitpunkt immer genau ein Element einer
potentiell unendlichen Folge vo n Elementen. Dabei dienen Streams entweder abgeschlos-
sene Datenspeicher wie Collections und Files oder offene Datenlieferanten wie die Tastatur
oder Datengeneratoren (wie beispielsweise ein Zufallszahlengenerator oder eine Vorschrift
zur Berechnung einer Fibonacci -Folge) als Quelle. Ein Ergebnis liefert eine Stream -Pipeline
(die auch aus nur einem Element bestehen kann) immer erst durch einen sog. Abschluss,
also eine Methode wie reduce oder collect , die ein anderes Ergebnis als einen Stream
liefert (eine C ollection im Falle von collect ).
Das Stream -Framework von JAVA ermöglicht für viele Pipelines eine besonders effiziente
Ausführung. So muss jedes Element einer Datenquelle in der Regel nur einmal angefragt
werden und die interne Speicherung von Zwischene rgebnissen wird automatisch gering ge-
halten. Insbesondere wird gegenüber einer naiven Implementierung von Pipelines, die eine
Iteration je Element der Pipeline benötigt, in vielen Fällen nur eine Iteration gebraucht (die
sog. Stream fusion) . Zudem kann durch Wahl des Streams (und nicht der Operationen) be-
stimmt werden, ob die Verarbeitung der Pipeline parallel oder sequentiell erfolgt. Gleich-
wohl ist die Performanz von JAVA-Pipelines nicht leicht vorh erzusagen und eine gewinnbrin-
gende Verwendung setzt sicherlich einiges an Erfahrung und Kenntnis der Implementierung
voraus.
"
"8.6 Praktische Bedeutung der Metaklassen für die Programmierung
Dadurch, dass i n SMALLTALK Klassen Instanzen von Metaklassen sind, die
selbst Instanzen einer weiteren Klasse und diese alle zusammen Objekte
sind, ist jedes SMALLTALK -Programm, ja das ganze SMALLTALK -System,
nichts weiter als ein Objektgeflecht (sieht man einmal von den primitiven Methoden ab).
SMALLTALK ist damit nicht nur ein Programmiersystem, sondern auch ein Metaprogram-
miersystem in der Tradition funktionaler und logischer Programmiersprachen wie LISP und
PROLOG . In der imperativen und objektorientierten Prog rammiersprachenlandschaft sucht
diese Mächtigkeit bis heute ihresgleichen.
Für Sie als Programmiererin , die nicht gleich eine neue Sprache erschaffen will, sind Ebene
oder es vielleicht sogar selbst verändern wollen. Wenn Sie z. B. erreichen wollen, dass beim
Anlegen einer neuen Klasse für alle benannten Instanzvariablen dieser Klasse automatisch
Zugriffsmethoden wie in Abschnitt 4.3.4 definiert werden, dann ist dies leicht möglich, in-
dem Sie an entsprechender Stelle (z. B. in der Klasse Class bzw. Behavior , die auf der
Ebene der Metaklassen steht und die für das Anlegen ne uer Klassen zuständig ist) eine neue
Methode zur Klassendefinition einfügen, die die bereits existierenden um die automatische
Erzeugung der Zugriffsmethoden ergänzt.
Selbsttestaufgabe 8.3
Ergänze n Sie die Klasse Class um eine Methode zur Anlage neuer Klassen, die für ausgewählte
Instanzvariablen automatisch Zugriffsmethoden (Accessoren; einen Setter und einen Getter) zum
Methodenkatalog hinzufügt. Teilen sie dazu die bei einer Klassendefinition an gegebene Liste der
Instanzvariablen in zwei auf, von denen die eine ohne, die andere mit Accessoren angelegt wird.
Im Programmieralltag werden Sie das aber nicht tun. Vielmehr beschränkt
sich Ihre Tätigkeit da auf das Anlegen und Ändern einfacher Klassen, also solcher, deren
Instanzen selbst keine Klassen sind. Die dazu notwendigen Metaklassen erzeugt SMALLTALK
automatisch selbst — im Klassenbrowser erscheinen sie nur über die Unterscheidung zwi-
schen Instanz - und Klassenvariablen bzw. -methoden.
"
"50.3.2 Indexer
Indexer übertragen gewissermaßen das Konzept der indizierten Instan zvariablen von
SMALLTALK auf C#: Jede Instanz einer Klasse, für die ein Indexer definiert ist, hat eine Menge
von (scheinbar unbenannten) Instanzvariablen, die über einen Index zugegriffen werden
können. Allerdings muss die indizierte Instanzvariable klass enintern durch eine normale, be-
nannte Instanzvariable (Feld) repräsentiert werden; Indexer ähneln Properties insofern, als
der Zugriff über einen Index mittels entsprechender Get - und Set -Abbildungen auf einen
Zugriff auf eine benannte Instanzvariable über setzt wird. Das folgende Beispiel illustriert den
Vorgang:
Dabei wird this als Schlüsselwort missbraucht , um anzudeuten, dass bei Zugriffen auf die
indizierte Instanzvariable kein Name einer Instanzvariable (eines Feldes), sondern lediglich
der Name des Objekts, zu dem sie gehört, steht:
HatScheinbarEineIndizierteInstanzv ariable(2);
Nun darf der Indexer in C# überladen werden, so dass ein Objekt mehrere indizierte In-
stanzvariablen haben kann, wobei der Zugriff (aufgrund des fehlenden Namens) einzig über
den Typ des Indexes differenziert erfolge n kann. Durch das Überladen ist es wiederum mög-
lich, nicht eine, sondern mehrere indizierte Instanzvariablen zu simulieren, was jedoch der
Beschränkung unterliegt, dass der Elementtyp (der Rückgabetyp beim Überladen) gleich
bleiben muss . Und schließlich muss ein Indexer auf keine interne (benannte) Instanzvariable
zugreifen — alle Inhalte können, genau wie bei Properties, auch berechnet werden.
"
"35.2 Gleichheit und Identi tät
In JAVA wird genau wie in SMALLTALK zwischen Gleichheit und Identität von Objekten unter-
schieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) (wobei (.)
hier für einen nicht näher spezifizierten Parameter steht), die Identität mittel s == (bzw. !=
für das Negat) geprüft. equals(.) wird von der Klasse Object (in JAVA genau wie in
SMALLTALK die Superklasse aller Klassen) geerbt und sollte in den Subklassen der jeweiligen
Bedeutung von Gleichheit entsprechend überschrieben werden. Die Ver wechselung von
equals(.) und == ist auch in JAVA ein ziemlich häufiger Programmierfehler (vgl. Ab-
schnitt 1.4 in Kurseinheit 1). Das Gleichheitszeichen = steht in JAVA übrigens (genau wie in
C, C++ und C#) für die Wertzuweisung , was ich persönlich für eine der großen Tragödien
der Informatik halte .
"
"21 Zuweisungskompatibilität
Die Typisierung von Variablen (und anderen Programmelementen — wenn im nachfolgen-
den nur von Variablen die Rede ist, dann sind letztere meistens mit gemeint) soll also be-
wirken, dass in einem Programm jede Variable nur die Werte haben kann, für die sie (di e
Variable) vorgesehen ist (die Einhaltung der Typinvariante ). Voraussetzung dafür ist zum
einen, dass jeder Variable ein Typ zugeordnet ist, zum anderen, dass auch jedes Objekt
sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Ersteres
geschieht in sogenannten Variablendeklarationen, letzteres ergibt sich aus den zu einem
Typsystem gehörenden Regeln zur Zuordnung eines Typs zu Ausdrücken , nämlich
 bei Literalen aus de r Art des Literals, dessen Typ dem Compiler bekannt ist,
 bei der Instanziierung aus dem noch zu klärenden Zusammenhang von der instan-
ziierten Klasse mit den Typen eines Programms sowie
 bei Nachrichtenausdrücken aus der Deklaration der dazugehörigen Methode , die ja
(genau wie eine Variablendeklaration) angeben muss , welchen Typs die Objekte
sind, die sie liefert.
Es bleibt die Frage nach den ebenfalls zu einem Typsystem gehörenden
Typregeln, die von Ausdrücken einzuhalten sind , nämlich wie die Typkor-
rektheit bzw. andernfalls die Verletzung einer Typinvariante genau fest-
gestellt wird. Es ist ja bereits klar, dass es dazu ausreicht, die Wertzuweisungen in einem
Programm zu überprüfen. Diese Überprüfung findet in der Regel in Form der Feststellung
der sog. Zuweisungskompatibilität statt. Die Sprachregelung ist hier leider nicht ganz ein-
heitlich, aber im folgenden gehen wir davon aus, dass alle typisierten Sprachen den Begriff
der Zuweisungskompatibilität kennen und sich lediglich in ihren Definitionen der Regeln,
die für das Bestehen einer Zuweisungskompatibilität eingehalten werden müssen, unter-
scheiden. Vor allem darum wird es in den nächsten Kapiteln gehen.
Angenommen, zwei temporäre Variablen anzahl und erfolgre ich seien wie folgt de-
klariert:
Dann sind, unter der Annahme, dass 12 vom Typ Integer ist und true vom Typ Boolean ,
die Zuweisungen
zulässig (da sie keine Typinvariante verletzen),
hingegen nicht. Ist eine Zuweisung zulässig, dann spricht man auch von einer Zuweisungs-
kompatibilität der beteiligten Typen. Die für das Programmieren relevante Implikation ist
allerdings die umgekehrte: Wenn zwei Typen zuweisungskompatibel sind, dann gilt, dass
eine entsprechende Zuweisung zulässig ist, also zu keiner Verletzung einer Typinvariante
führt. Wie Sie noch sehen werden, verlangt Zuweisungskompatibilität keineswegs identi-
sche Typen; daraus ergibt sich aber eine sprachliche Uneindeutigkeit, d ie zunächst behoben
werden muss .
Dem Satz „ a ist zuweisungskompatibel mit b“ kann man nicht eindeutig
entnehmen, ob nun a b zugewiesen werden kann oder b a. Dass beides
geht, ist nur dann der Fall, wenn die beteiligten Typen ä quivalent in einem noch zu bestim-
menden Sinne sind, was aber, wie schon gesagt, nicht unbedingt der Fall sein muss . Im
folgenden soll daher die Richtung der erlaubten Zuweisung so gelesen werden, dass beim
Satz „a ist zuweisungskompatibel mit b“ die Zuweis ung b := a zulässig ist. Die umge-
kehrte Richtung, a := b , kann ebenfalls zulässig sein; dies wird durch den Satz jedoch
nicht ausgesagt. Zuweisungskompatibilität ist übrigens (in der Regel) eine transitive Eigen-
schaft: Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c, dann
ist auch a zuweisungskompatibel mit c.
Auch bei impliziten Zuweisungen wie der Parameterübergabe von Me-
thodenaufrufen (den dabei stattfindenden Zuweisungen der tatsäch li-
chen an die formalen Parameter; s. Abschnitt 4.3.2 ) impliziert Zuwei-
sungskompatibilität Typkorrektheit. Außerdem kann eine Methode, wenn sie Werte zurück-
gibt, ja selbst in rechten Seiten von Zuweisungen auftreten; der Typ dieser Werte muss dann
mit der Variable auf der linken Seite zuweisungskompatibel se in. So sind bei Vorliegen der
Deklarationen
sowohl die explizite als auch die impliziten Zuweisungen in
zulässig; den Methodenaufruf kann man im übertragenen Sinne als zulässig bezeichnen.
"
"7 Klassen
Sprachphilosophisch gesehen ist eine Klasse ein Allgemeinbegriff wie etwa Person , Haus
oder Dokument . Diese Allgemeinbegriffe stehen in der Rege l für eine ganze Menge von
Objekten, also etwa alle Personen, Häuser oder Dokumente. Gleichwohl ist die Klasse selbst
immer ein Singular — sie ist nämlich selbst ein Objekt, das unter den Allgemeinbegriff Klasse
fällt. Diese Sprachregelung wird auch in der objektorientierten Programmierung eingehalten
(obwohl sie natürlich nicht, da Computer unsere Sprache nicht kennen, überprüft werden
kann und deswegen Abweichungen immer wieder vorkommen): Alle Klassennamen sind
Singulare.
der Platz zugedacht, den dann später JAVA einnehmen sollte. SELF war zwar für die Entwicklung der
Java Virtual Machine ein wichtiger Ideenlieferant, ist jedoch außerhalb dieser Kreise kein Erfolg be-
schieden gewesen. Der Erfolg von JAVASCRIPT zeigt aber, dass das Konzept der prototypenbasierten
Programmierung zumindest kein Irrweg war. klassen - vs.
Mit jedem Allgemeinbegriff verbinden wir eine ganze Reihe von Eigen-
schaften , die für ihn charakteristisch sind, die wir aber nicht dem Begriff
selbst, s ondern den Objekten, die darunter fallen, zuordnen. Mit Person
etwa ist Name verbunden sowie Geburtstag und ggf. weitere Attribute, aber auch bestimm-
tes, für Personen charakteristisches Verhalten . Das gleiche gilt für Haus , Dokument und alle
anderen Allgemeinbegriffe. Existenz und Adäquatheit von Allgemeinbegriffen sind Thema
großer philosophischer Diskurse wie etwa dem sog. Universalienstreit und stehen hier nicht
zur Debatte. Wichtig ist, dass mit ihnen stets Sätze wie „<ein Individuum> ist ein <ein All-
gemeinbegriff>“ gebildet werden können, also etwa „Peter ist eine Person“. Mit solchen
Sätzen verbindet sich nämlich die Übertragung aller Eigenschaften, die mit einem Allge-
meinbegriff verbunden sind (s. o.), auf das Individuum. So hat Peter, wenn er eine Person
ist und Person wie oben definiert wurde, eben auch einen Namen und einen Geburtstag .
"
"52.5.1 Ein motivierendes Beispiel
MEYERs klassisches Beispiel für die Motivation kovarianter Redefinition und verankerter Ty-
pen à la EIFFEL soll Ihnen hier nicht vorenthalten werden — es wird immer wieder zitiert und
ist, abgesehen davon, dass es zu Bemerkungen abseits der Informatik einlädt, i ntuitiv gut
verständlich. Das Beispiel beginnt wie folgt:
Die Idee ist, dass jugendliche Skifahrerinnen sich zu zweit ein Zimmer teilen. Wie Sie viel-
leicht schon selbst bemerkt haben, ist der durch die Klasse Skier definierte Typ rekursiv:
Seine Instanzvariable roommate ist selbst vom Typ Skier . Somit wird z. B. der folgende
Aufruf von share möglich (typkorrekt):
Nun ist das Beispiel so noch unvollständig. Es ergibt sich nämlich aus der Sache, dass die
jungen Skifahrerinnen nach Geschlechtern getrennt untergebracht werden sollen. Dazu
kann man in EIFFEL (dank erlaubter kovarianter Redefinition) einfach schreiben:
sowie entsprechend für Jungen
Zwei Dinge fallen auf: Zum einen unterscheiden sich die beiden Subklassen lediglich darin,
dass sie roommate einen anderen Typ zuordnen und dies in der Folge auch für den Para-
meter von share tun (müssen), zum anderen sind, wie bei Kovarianz üblich, bei den Vari-
ablendeklarationen
die nachfolgenden Anweisungen nach den Regeln der Zuweisungskompatibilität zulässig:
Beim Funktionsaufruf von share wird nun aber, dank dynamischer Bindung, g1 (und damit
ein Objekt vom Typ GIRL ) an roommate in BOY und damit an eine Variable vom Typ BOY
zugewiesen. Schon ist das Programm nicht mehr typkorrekt.
Naturgemäß kommt i n EIFFEL dem Versuch der Reparatur des durch obi-
ges Beispiel angedeuteten Verlusts der Typkorrektheit eine besondere Be-
deutung zu. Hier sei nur noch schnell (und ohne etwas von der Lösung vorwegzunehmen)
erwähnt, dass der eigentliche Fehler in der implizit angenommenen Allquantifizier ung einer
Deklaration wie SKIER.share(SKIER) (oder, mathematisch ausgedrückt, share : SKIER 
SKIER ) liegt: Wie schon in Kurseinheit 3, Kapitel 26 erwähnt, bedeutet eine solche Deklara-
tion eben nicht , dass alle Skifahrerinnen (beiden Geschlechts) ihr Zimmer mit allen Skifah-
rerinnen (wieder beiden Geschlechts) teilen können. Das ist aber auch schon unabhängig
von den möglichen Geschlechtern (Subklassen) nicht der Fall: Wenn eine Skifahrerin bei-
spielsweise (vorüb ergehend) ansteckend erkrankt ist, kann sie höchstens mit anderen Kran-
ken das Zimmer teilen. Eine Klassifikation nach Kranken und Gesunden entzieht sich aber,
da sie nicht dauerhaft ist, den Möglichkeiten d er statischen Typisierung (zumindest den of-
fensichtlichen). Ursache des Verlusts
"
"3 Zustand
Wie bereits in Abschnitt 1.3 beschrieben , kann man zwischen veränderlichen und unverän-
derlichen Objekten unterscheiden. Veränderungen veränderlicher Objekte erfolgen über die
Zeit und die Objekte wechseln dabei ihren Zustand ; unveränderliche Objekte dagegen h a-
ben keinen Zustand.14 Was aber macht den Zustand eines Objektes aus?
Der Zustand eines Objektes ist die Summe der Belegungen seiner In-
stanzvariablen . Insofern Instanzvariablen Beziehungen ausdrücken, wird
der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit
anderen Objekten definiert. Zudem folgt, dass die einzige Möglichkeit, den Zustand eines
Objekts zu ändern, der über die Zuweisung von Instanzvariablen , gleichbedeutend mit der
Änderung seiner Beziehun gen, ist.
"
"43.3 Beschränkter paramet rischer Polymorphismus in JAVA
Wie bereits in Kurseinheit 3, Abschnitt 29.4 erwähnt, kauft man sich mit einfachem para-
metrischem Polymorphismus außerhalb der Typdefinition Typsicherheit zum Preis der man-
gelnden Typsicherheit innerhalb: Solange man keine Aussagen über den konkreten Typ, der
für einen Typparameter eingesetzt wird, machen kann, kann man bei der Implementierung
einer Klasse, die den parametrischen Typ definiert, auch keine Eigenschaften der Objekte,
die von dem (unbekannten) Typ sein sollen, voraussetzen. Was man vielmehr braucht, ist
beschränkter parametrischer Polymorphismus. Natürlich gibt es den auch in JAVA.
Wenn man beispielsweise die parametrische Definition sortierter Listen, SortedList<E> ,
auf Elementtypen einschränken will, die Subtypen von Comparable sind (damit die in
Comparable definierte Methode compareTo(.) zur Verfügung steht), dann schreibt man
in JAVA
Die möglichen Werte der Typvariable E werden dadurch auf Typen eingeschränkt, die
Comparable (direkt oder indirekt) erweitern. Die Implementierung der Methode zum Ein-
fügen und Entfernen von Elementen in sortierten Listen kann also davon ausgehen, dass
alle Objekte, die in einer solchen Liste ges peichert sind, die Nachricht compareTo(.) ver-
stehen, die vom Interface Comparable vorgeschrieben wird. Man beachte, dass dadurch
keine neue Subtypenrelation zwischen irgendwelchen Typen hergestellt wird — es werden
lediglich die Möglichkeiten, konkrete Typ en (z. B. in Variablendeklarationen) zu bilden, ein-
geschränkt. Eine Variablendeklaration
wobei String ein Subtyp von Comparable ist, ist also möglich, eine wie
hingegen nicht. Dennoch ist SortedList<Strin g>, wie bereits in Abschnitt 29.3 be-
merkt , kein Subtyp von SortedList<Comparable> .
Selbsttestaufgabe 43.4 (nur für JAVA-Programmiererinnen )
Probieren Sie aus, ob zwei Instanzen generischer Typen (also z. B. ArrayList<Object> und
ArrayList<String> als Instanzen von ArrayList<E> ) in JAVA zur Laufzeit denselben oder ver-
schiedene Typen haben. Verwenden Sie dazu die Methode getClass() auf Objekten, die Sie von
diesen Typen erzeugt haben.
"
"43.4 Rekursiv beschränkter parametrischer Polymorphismus
Wenn Ihnen das noch nicht kompliziert genug ist , geht es noch weiter: Es ist nämlich
Comparable selbst ein Typ, der von einer Parametrisierbarkeit profitieren würde. In einem
ersten Ansatz würde man verlangen, dass von zwei vergleichbaren Elementen beide vom
selben Typ sein müssen. Dies könnte man durc h die Deklaration von
(tatsächliche Definition von Comparable in JAVA) sowie
erreichen. Man beachte die Parallelität zu STRONGTALK (Abschnitt 29.5).
Bei genauerer Betrachtung des Beispiels stellt sich allerdings heraus, dass
die Bedingung, dass die zu vergleichenden Elemente für eine Sortierung
alle vom selben Typ sein müssen, zu hart ist. Vielmehr würde es ja ausreichen, wenn die
Objekte der sortierten Liste unter anderem mit den Objekten desselben Typs vergleichbar
wären — sie könnten mit Objekten von noch mehr Typen vergle ichbar sein. Die Bedingung
muss also lauten, dass der Parametertyp von Comparable mindestens E umfassen muss , er
kann aber auch allgemeiner, z. B. Object (für einen Vergleich beliebiger Objekte, wie auch
immer der erfolgen soll), sein. Genau dies wird durc h
ausgedrückt, wobei das Typ -Wildcard wieder für einen beliebigen Typen, der die nachfol-
gende Bedingung erfüllt, steht. Im gegebenen Fall muss es sich bei dem für das Wildcard
einzusetzenden Typ um ei nen (direkten oder indirekten) Supertypen von E handeln (wobei
E ja selbst eine Typvariable ist, die erst bei einer Variablendeklaration an einen konkreten
Typ gebunden wird). So ist
zulässig, wenn String wie in
oder in
deklariert ist. Wildcards in
"
"46 Interne und externe Iteration über Collections
Genau wie in der SMALLTALK -Programmierung kommt man in der JAVA-Program mierung
häufig in die Verlegenheit, : n-Beziehungen umsetzen zu müssen. Wie in SMALLTALK ge-
schieht dies auch in JAVA mit Hilfe von Zwischenobjekten . Anders als in SMALLTALK wird hier
aber zwischen zwei Arten von Zwischenobjekten grundsätzlich unterschieden: den Arrays
und den Collections.74 Da JAVA-Arrays in ihrer Funktionalität beschränkt sind (s. Kapitel 41:
keine eigene n Methoden zur Unterstützung des Zugriffs, kein dynamisches Wachstum, dazu
die etwas verkorkste Situation beim Subtyping), werden Arrays vornehmlich dort eingesetzt,
wo es um Effizienz (geringer Speicherverbrauch und schneller Zugriff) geht.
"
"25 Typeinschränkung
Typerweiterung ist nicht die einzige Möglichkeit, auf der Basis eines bereits bestehenden
einen neuen, verwandten Typen zu erzeugen; Typeinschränkung ist eine andere.
Eine erste, offensichtliche Form der Typeinschränkung liegt dann vor,
wenn ein Typ auf Basis eines anderen unter Entfernen von Eigenschaften
(Methoden) definiert wird (das Beispiel vom Pinguin als einem Vogel, der
nicht fliegen kann, kennen Sie ja bereits aus Kurseinheit 1, Abschnitt 9.2; das Beispiel vom
Quadrat als einem Rechteck, das nur eine Kantenlänge braucht, ist ein anderes). Diese Form
der Typeinschränkung stellt zumindest auf Ebene der Typdefinition (der Intensionen) die
Umkehrung der Typerweiterung dar. Es liegt auf der Hand, dass diese Form der Typein-
schränkung nicht zur Zuweisungskompatibilität führt; dies folgt schon aus der fehlenden
Symmetrie der Typkonformität. Sie soll hier d eswegen keine weitere Berücksichtigung fin-
den, auch wenn es Sprachen gibt, die sie erlauben (z. B. EIFFEL).
Eine unter dem Gesichtspunkt der Zuweisungskompatibilität interessan-
tere Form der Typeinschränkung besteht da rin, die verwendeten Typen
einer Typdefinition durch andere, speziellere zu ersetzen (ohne hier schon zu sagen, was
„spezieller“ im Zusammenhang mit Typen bedeutet). Diese Form der Typeinschränkung
ergibt sich auf natürliche Weise, wenn man sich den Zusamm enhang von Extensionen von
definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht.
Das Ganze soll an einem Beispiel verdeutlicht werden. Man denke sich einen Typ Dokument
wie folgt definiert: Konformität bei
Typ Dokument
Protokoll
Für die Dauer eines Ausdrucks wird durch die Methode druckenAuf: ein konkretes Doku-
ment einem konkreten Drucker zugeordnet. Mengentheoretisch betrachtet ist diese Zuord-
nung eine Relation zwischen zwei Mengen:
Empf änger
(Dokument)Parameter
(Drucker)
Nun gibt es verschiedene Arten von Dokumenten und Druckern: Man kann z. B. bei Doku-
menten zwischen Texten und Diagrammen unterscheiden und bei Druckern zwischen Zei-
lendruckern und Plottern. Die Extensionen entsprechender Typen sind dann jeweils Teilmen-
gen der Extensionen von Dokument und Drucker .
Weiterhin ergibt es sich aus der Natur der Sache, dass man Diagramm e nur auf Plottern
drucken sollte und Texte nur auf Zeilendruckern. Dies geht konform zur obigen Betrachtung
eines Methodenaufrufs als Relation: Wenn man die Menge einer Stelle einer Relation wie
der obigen auf eine Teilmenge einschränkt, dann schränkt sic h dadurch in der Regel auch
die Menge der anderen Stelle auf eine Teilmenge ein:
Empf änger Parameter
Die andere Menge kann auch gleich bleiben; größer wird sie jedoch nie.
Es ergibt sich daraus die folgende Definition eines Typs Zeichnung als Typeinschränkung
Typ Zeichnung
eingeschränkter Typ Dokument
Protokoll
Man beachte, dass die Methode druckenAuf: nicht hinzugefügt wurde
— sie ersetzt vielmehr die von Dokument übernommene. So unterscheidet sich die Methode
von der ursprünglichen auch nur in der Typannotation des formalen Parameters. Man
spricht in diesem Zusammenh ang von einer Redefinition der Methode (an den ebenfalls
dafür verwendeten Begriff des Überschreibens sind je nach Programmiersprache andere Be-
dingungen geknüpft). Die Methoden name und name: werden übrigens, genau wie bei der
Typerweiterung, bei der Typeinschränkung übernommen, solange nichts anderes ausgesagt
wird.
Man mag sich fragen, warum bei der Typerweiterung in Kapitel 23 keine
zwei Formen analog zur Typeinschränkung eingeführt wurden. Di e Ty-
perweiterung würde damit zur vollständigen Umkehrung der Typein-
schränkung wie hier beschrieben. Wie Sie noch sehen werden, ist das Ziel nicht die Schaf-
fung zweier Komplementäre, sondern die Vereinigung beider zu einer Beziehung zwischen
Typen — dazu mü ssen sie aber in dieselbe und nicht in gegensätzliche Richtungen gehen.
Außerdem ist eine Erweiterung des Wertebereichs bei Einschränkung des Definitionsbe-
reichs nicht durch den Begriff der Relation wie oben erklärbar; eine wichtige Analogie zur
Realität, die durch Typen zwecks semantischer Prüfung nachgebildet werden soll, ginge da-
mit verloren.
Nun ergibt sich aber bei der Typeinschränkung auch ohne Löschen das
Problem, dass sie die Zuweisungskompatibilität, d ie ja für die Typerweite-
rung noch per Typkonformität geregelt werden konnte, aushebelt: Wenn
man bei den obigen Typdefinitionen und den Deklarationen
zunächst
zuweist und dann weiter
aufruft, dann wäre, Typkonformität von Zeichnung und Dokument bzw.
Zeilendrucker und Drucker vorausgesetzt, die Typprüfung zwar erfolgreich (denn
druckenAuf: verlangt für Dokument Drucker als Argumenttyp), aber zur Laufzeit soll
nun eine Zeichnung auf einem Zeilendrucker gedruckt werden, was gemäß der obigen De-
finition von Zeichnung nicht vorgesehen ist. Eine der beiden Zuweisungen, die explizite in Redefinition
Zeile 901 oder die implizite (die Parameterübergabe) in Zeile 902, ist also nicht zulässig. Da
gegen di e Typkonformität von Zeilendrucker und Drucker nichts spricht (für beide Ty-
pen sind im Beispiel ja gar keine Definitionen angegeben), bleibt nur, dass Zeichnung nicht
typkonform zu Dokument ist, wobei der Grund hierfür in der Einschränkung des Parame-
tertyp s von druckenAuf: bei der Redefinition zu suchen ist.
Wesentlich für diese Betrachtungsweise, und damit das geschilderte
Problem, ist übrigens, dass nach der Zuweisung von Zeile 901 d und z
auf dasselbe Objekt, nämlich eine Zeichnung, verweisen. d ist also ein Alias für z (s. Kurs-
einheit 1, Abschnitt 1.8). Unter Wertsemantik , bei der bei der Zuweisung eine Kopie erstellt
wird, hätte man hingegen überlegen müssen, wie man ein Objekt vom Typ Zeichnung in
einer Variable vom Typ Dokument speichern kann; je nach interner Repräsentation der Ob-
jekte (die ja durch den Typ nicht festgelegt ist), ist dafür nämlich gar nicht genug Platz.
Gleichzeitig mit der Kopie könnte dann eine Typkonvertierung erfolgen, bei der aus der
Zeichnung ein Dokument gemacht würde (was auch immer das heißen mag). Dieses Doku-
ment müsste dann, per obiger Typdefinition, auch auf einem Zeilendrucker druckbar sein.
Es ist allerdings schwer vorstellbar, wie dies umzusetzen ist, wenn das entsprechende Objekt
nicht einmal mehr weiß, dass es eine Zeichnung ist, geschweige denn, wie se ine interne
Repräsentation aussieht. In der Praxis der objektorientierten Programmierung ist daher auch
nur die Referenzsemantik in Fragen der Zuweisungskompatibilität interessant.
Man beachte übrigens, dass sich bei der Ausgabe a us Methoden (der
Rückgabe von Werten) unter Typeinschränkungen kein analoges Problem
ergibt: Wenn beispielsweise einem Dokument ein Drucker dauerhaft zugeordnet wird und
dieser Drucker mittels einer Methode drucker abgefragt werden kann, dann hat die Ein-
schränkung des Rückgabetyps von drucker von Dokument auf Plotter keine negativen
Auswirkungen auf die Zuweisungskompatibilität:
ist völlig in Ordnung, solange nur Plotter zuweisungskompatibel mit Drucker ist. Die
unterschiedliche Zulässigkeit von Typeinschränkungen bei Ein - und Ausgabe wird in Ab-
schnitt 26.3 noch genauer beleuchtet.
Was die Freiheit von Typfehlern angeht, kann man das Löschen von Ei-
genschaften (Methoden) übrigens auch als einen Spezialfall der Typein-
schränkung der obigen, zweiten Form auffassen, nämlich einer, in der der Wertebereich auf
die leere Menge eingeschränkt wird. So wäre beispi elsweise druckenAuf: mit einem Pa-
rametertyp ohne Elemente gar nicht mehr aufrufbar (da es kein typkorrektes Parameterob-
jekt gäbe), was einer Löschung gleichkäme. Aliasing und
"
"36.4 Überschreiben, Überladen und dynamisches Binden
Nun hat die Subklasse die Möglichkeit, neue Member hinzu zufügen und
bereits bestehende zu redefinieren. In JAVA ist die Möglichkeit der Redefinition auf die Mög-
lichkeit des Überschreibens eingeschränkt, was soviel heißt wie dass eine Methode mit der
gleichen Signatur (bestehend aus Methodenname und formalen Par ametertypen) noch ein-
mal definiert werden kann, und zwar mit geänderter Implementierung. Auch darf die Me-
thode den Rückgabetyp kovariant, also nach unten, abändern (vgl. dazu die Diskussion in
Kurseinheit 3, Abschnitt 26.3). Dass die überschreibende Methode über die Einhaltung der
Typinvarianten, die mit ihren (geerbten) Parametern verbun den sind, hinaus nur etwas tut,
das mit der überschriebenen Methode kompatibel ist, dass sie also nicht mit dem erwarteten
Verhalten bricht, kann durch die Sprachdefinition JAVAs nicht erzwungen werden — hier ist
die Programmiererin in der Verantwortung (vgl. dazu auch die Abschnitt e 52.6 in Kursein-
heit 5 und 54.1 in Kurseinheit 6).
Nun kann man in JAVA auch Methoden mit gleichem Namen, aber ver-
schiedenen Parametertypen in derselben oder einer Subk lasse haben. Diese Methoden
nennt man dann überladen . Es ist wichtig, zu verinnerlichen, dass in JAVA Überladen und
Überschreiben zwei grundverschiedene Dinge sind, obwohl man in beiden Fällen nichts wei-
ter tut als eine Methode mit bereits vorhandenem Namen noch einmal zu definieren: Beim
Überladen wird eine neue Methode eingeführt, beim Überschreiben wir d eine bereits be-
stehende redefiniert. Diese Unterscheidung spielt beim dynamischen Binden eine entschei-
dende Rolle.
Um das dynamische Binden JAVAs genau zu verstehen (und damit das
Verhalten eines Programms vorhersagen zu können), muss man sich den Bindealgorithmus
vor Augen halten. Dieser geht wie folgt vor. Überschreiben
Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methoden-
deklaration gebunden, und zwar an genau die, die die folgenden Bedingungen erfüllt:
1. Sie hat den gleichen Namen und die gleiche Anzahl Parameter59 wie die aufgeru-
fene Methode.
2. Sie ist in der Klasse, die zu dem deklarierten Typ des Ausdrucks gehört, der das
Empfängerobjekt liefert (nicht selten einfach eine Variable), deklariert oder wird von
einer ihr er Superklassen geerbt.
3. Die deklarierten Parametertypen des Aufrufs (die deklarierten tatsächlich en Parame-
tertypen) sind jeweils Subtypen der deklarierten Parametertypen der Methodende-
klaration (der deklarierten formalen Parametertypen).
4. Es gibt keine ande re Methode, die die gleichen Voraussetzungen erfüllt, deren de-
klarierte formale Parametertypen aber gleich weit entfernt oder näher an den Typen
des Aufrufs sind (Entfernung hier gemessen als die Anzahl der Subtypen, die dazwi-
schen liegen).
Damit ist dann die oberste (Wurzel) einer Menge von Methoden gefunden, die möglicher-
weise in Subklassen überschrieben wird und an eine von denen der Methodenaufruf dann
dynamisch gebunden wird. Man beachte, dass die überschreibenden Methoden dieselbe
Signa tur haben müssen wie die überschriebene; diese Methoden bilden eine Art Familie,
von der eine zur Bindung herausgesucht wird.
Zur Laufzeit wird dann nur noch der tatsächliche Typ des Empfängerobjekts (die Klasse, von
der es eine Instanz ist) bestimmt. Dies er muss , aufgrund der Regeln der Zuweisungskompa-
tibilität, ein Subtyp des deklarierten Typs des Ausdrucks sein, der das Empfängerobjekt lie-
fert. Mit diesem tatsächlich en (auch dynamisch genannten) Typ wird dann aus der zuvor
bestimmten Menge von in Frage k ommenden überschriebenen Methoden die ausgesucht,
die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Kette der
Superklassen die nächste ist.
Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach obi-
gem Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit
von der aufgerufenen entfernt sind, dann meldet der Compiler einen sog. Method ambi-
guous error , der bedeuten soll, dass die aufgerufene Methode durch den Aufruf nicht ein-
deutig bestimmt ist. Man beachte, dass der Fehler durch Methodenaufrufe, nicht durch
Methodendeklarationen verursacht wird; wenn man den problematischen Aufruf entfernt,
gibt es auch keinen Fehler mehr. Der einfachste Fall eines solchen Fehlers ergibt sich durch
den Aufruf
bei dem unklar ist, ob println(null) an die Implementierung von println(String) ,
println( Object) oder von println(char[]) gebunden werden soll.
Man beachte, dass in Sprachen, in denen das dynamische Binden neben dem Typ des Emp-
fängers auch die Typen der tatsächlich en Parameter berücksichtigt (das sog. Multi -dispatch ),
der Unterschied zwischen Überladen und Überschreiben dahinschmilzt. In JAVA muss hinge-
gen das dynamische Binden anhand der Parametertyp en genau wie in SMALLTALK über Dou-
ble dispatch (s. Abschnitt 12.3 in Kurseinheit 1) simuliert werden.
"
"50.1 Das Programmiermodell von C#
Das Programmiermodell von C# unterscheidet sich zunächst nicht wesentlich von dem JA-
VAs: Auch in C# ist der Code auf Klassen verteilt, die einzeln übersetzt werden können.
Klassen werden in Dateien gespeichert, jedoch ist das Verhältnis von Klasse zu Datei lockerer
als in JAVA (u. a. können Klassen anders heißen als ihre Dateien und sogar auf mehrere
Dateien aufgeteilt werden). Allerdings sind der Bytecode und die dazu passende virtuelle
Maschine nicht speziell für C# entworfen, sondern für alle sog. .NET -Sprachen. So heißt
denn auch die Sprache des Bytecode Common Intermediate Language (CIL); sie gilt als (ge-
rade noch) menschenlesbar.
Anders als bei JAVA waren bei C# Flexibilität und Performanz von Anbe-
ginn kritische Gesichtspunkte des Sprachentwurfs. Für C# war daher von
Anfang an und ausschließlich die sog. Just-in-time-(JIT-)Kompilierung vorgesehen, die den
CIL-Code unmittelbar vor der Ausführung (und nur, wenn er überhaupt ausgeführt wird) in
Maschinencode der Maschine, auf der er gerade läuft, übersetzt. Die Einheiten der JIT -Kom-
pilierung gehen dabei hinunter bis zu einzelnen Methoden. Eine vollständige Kompilierung
von CIL - in nat iven Maschinencode vor der Ausführung ist ebenfalls möglich.
Eine andere Eigenschaft JAVAs, mit der die Programmiererinnen MICRO-
SOFTs offenbar nicht unter allen Umständen leben konnten, ist die
Garbage collection . In C# hat man daher die Möglichkeit, den Speicherplatz für Objekte,
die m it new erzeugt wurden, selbst wieder freizugeben. Doch wehe der, die das vergisst :
Speicherlecks sind die unmittelbare Folge. Noch schlimmer sind aber Speicherfreigaben von
Objekten, auf die noch Referenzen existieren: Die zeigen dann ins Leere oder, wenn der
Speicher wieder belegt wird, auf oder mitten hinein in ein anderes Objekt. Eine Katastrophe.
Aber damit nicht genug: Das mit SMALLTALK und JAVA abgeschaffte Han-
tieren mit Po intern wurde in C# auch wiedereingeführt, wohl weil man in der systemnahen
Programmierung (und bei Aufrufen in das hauseigene Betriebssystem) nicht darauf verzich-
ten konnte. Allerdings sind beide Rückschritte — explizite Speicherverwaltung und das Han-
tieren mit Pointern — in sog. unsichere Bereiche verbannt. Dazu gibt es in C# einen Modi-
fizierer unsafe , der solche Bereiche einleitet:
Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger -auf-Typ handelt ;
vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den
Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei
bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch über-
laden wurde.
Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.
"
"13 Programmieren mit Collections
In Kapitel 2 von Kurseinheit 1 waren wir bereits auf : n-Beziehungen eingegangen , die lo-
gisch gleichberechtigt neben :1 -Beziehungen stehen, die aber in der Umsetzung besonderer
Mechanismen bedürfen. Als Basis der Umsetzung hatten Sie bereits Zwischenobjekte ken-
nengelernt, die über ihre indizierten Instanzvariablen solche Beziehungen — wenn auch nur
indirekt — herstellen können. Tatsächlich könnte man, wenn man sich der Häufigkeit des
Vorkommens von : n-Beziehungen in der Programmierung bewusst ist, vermuten, dass indi-
zierte Instanzvariablen speziell für diesen Zweck eingeführt wurden. A uf den ersten Blick
bedauerlich ist nur, dass dafür eben diese Zwischenobjekte notwendig sind.
Es ergibt sich aus diesem Umstand aber auch ein entscheidender Vorteil.
Da auch diese Zwischenobjekte Instanzen von Klassen sein müs sen, ist es
möglich, verschiedene Arten von : n-Beziehungen zu definieren und diese jeweils mit Ver-
halten zu versehen, das speziell auf die Art der Beziehung bezogen ist. So ist es beispiels-
weise möglich, : n-Beziehungen zu definieren, deren Elemente (die in Beziehung stehenden
Objekte) jeweils nur einmal darin vorkommen dürfen (mengenwertige Beziehungen) oder
nach einem bestimmten Kriterium sortiert sind. Auch können Operationen wie das Hinzu-
fügen oder Entfer nen von Objekten zu einer Beziehung, die bei :1 -Beziehungen über die
Zuweisung zu einer Instanzvariable erfolgen (das Entfernen durch Zuweisung von nil), be-
liebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu
erhalten.
Besonders attraktiv ist jedoch die in SMALLTALK bestehende Möglichkeit,
eigene Kontrollstrukturen für : n-Beziehungen zu spezifizieren. Die bereits
vorhandenen durften Sie ja schon in Abschnitt 4.6.4 kennenlernen; hier
kommt hinzu, dass die Standarditeratoren je nach Art der Beziehung unterschiedliche Ei-
genschaften haben. Außerdem ist es natürlich möglich, mit eigenen Arten von Beziehungen
auch spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren.
Doch zunächst zur Pflege von solchen Beziehungen.
"
"66 Der Bibliotheksgedanke
Ein Großteil des Erfolgs der objektorientierten Programmierung hängt an der Verfügbarkeit
und der systematischen Verwendung von Bibliotheken. In SMALLTALK ist das selbstverständ-
lich, da hier Sprache und Bibliothek praktisch nicht zu trennen sind. Aber auch in JAVA ist
ein Teil der Sprachdefinition in bestimmte, spezielle Klassen wie Object , Thread und
Throwable verlagert (vgl. Kapitel 47). Auch kommt praktisch kein JAVA-Programm ohne Verwendung von
Zusicherungen
anstelle von
Kommentaren We should forget about small inefficiencies, say about 97% of the time:
premature optimi zation is the root of all evil.
die Verwendung bestimmter Bibliotheksklassen aus — man denke nur an die allgegenwär-
tige Verwendung des Collection -Frameworks, ohne das Programmiererinnen zur ständigen
Abfassung ewig gleichen Codes verdammt wären.
Zum objektorientierten Programmierstil gehört es, eine Lösung eines kon-
kreten Problems möglichst umfassend aus existierenden, idealerweise
verbreiteten und bewährten Bibliotheken zusammenzuklauben. Jede
nicht selbst geschriebene Programmzeile ist ein Gewin n, jede Implementierung einer noch
so kleinen Funktion, die es bereits in irgendeiner Bibliothek gibt, ist ein Verlust. Dabei sind
die Vorteile der Verwendung von Bibliotheken mannigfaltig: In der Regel können Sie vo-
raussetzen, dass die Implementierungen k orrekt sind (und Probleme und Sonderfälle be-
rücksichtigen, an die Sie im Traum nicht gedacht hätten), die Wartung und Anpassung
übernehmen andere für Sie und nicht zuletzt dürfen Sie bei weit verbreiteten Bibliotheken
voraussetzen, dass deren Funktionalitä t auch anderen Programmiererinnen bekannt ist, so
dass die Verwendung einer Bibliotheksklasse keiner weiteren Erklärung bedarf. Ihr eigener
Beitrag wird dadurch klein und überscha ubar, was man Ihnen in keinem Fall als Faulheit
oder Arbeitsverweigerung auslegen sollte95, sondern als wahre Größe: Sie kennen das Werk
anderer, Sie wissen es zu schätzen und zu nutzen.
"
"14.3 Kommunikation mit mehreren: Multicasting
Neben vielen anderen Neuerungen wird SMALLTALK auch das Model -View -Controler-Ent-
wurfsmuster (MVC -Pattern ) zugeschrieben, das sich heute noch (auch in Web -Anwendun-
gen) großer Beliebtheit erfreut. Beim MVC -Pattern gibt es verschiedene (An -)Sichten auf ein
logisches Modell, und da Änderungen im Modell potentiell alle Sichten betreffen, muss jede
Änderung alle Sichten darüber unterrichten. Es ist also eine Eins -zu-viele-Kommunikation
erforderlich, die nicht durch den norm alen Nachrichtenversand abgedeckt wird.
Das folgende Protokoll setzt diese Form der Kommunikation in SMALLTALK um; es ist voll-
ständig in SMALLTALK implementiert und sollte Ihnen inzwischen kein Problem mehr berei-
ten. Beachten Sie, dass Object keine Lazy initialization seiner Klassenvariable Dependents
vorsieht; die Methode initDependents muss daher bei Erzeugung einer neuen Klasse
jeweils einm al aufgerufen werden. wachsende Objekte
Klasse Object
Klassenvariablen Dependents …
Klassenmethoden
benannte Instanzvariablen
indizierte Instanzvariablen nein
Instanzmethoden
"
"4.5.2 Dynamisch gebundener Methodenaufruf
Wie bereits in Abschnitt 4.3.2 erläutert, verbirgt sich hinter dem Nachrichtenversand in
SMALLTALK der Methodenaufruf. Wann immer ein Objekt eine Nachricht an ein Empfänge-
robjekt verschickt, wechselt der Kontroll fluss damit zum Empfängerobjekt, genauer zu der
Methode des Empfängerobjek ts, das zur Reaktion auf die Nachricht vorgesehen ist. Nach
der Abarbeitung der Methode kehrt der Kontroll fluss an das sendende Objekt (genauer: zu
der Methode, aus der die Nachricht versandt wurde) zurück und setzt seine Arbeit dort fort.
Bei der Rückkehr wird auch das Ergebnis der Methode, (eine Referenz auf) ein Objekt, ge-
liefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt
hat, eingesetzt wird. Der genaue Mechanismus des dynamischen Bindens in SMALLTALK wird
in Kapite l 12 von Kurseinheit 2 untersucht.
"
"22.1 Strukturäquivalenz
Um strukturelle Typäquivalenz festzustellen, werden die Definitionen der beteiligten Typen
rekursiv expandiert , was sovie l heißt wie dass in einer Typdefinition vorkommende Namen
anderer Typen durch ihre Struktur ersetzt werden. Nimmt man beispielsweise die Typdefi-
nitionen
Typ Person
Protokoll
Typ Wohnung
Protokoll
Typ Firma
Protokoll
Typ Büro Unterscheidung von
Protokoll
dann sind die Typen Person und Firma sowie Wohnung und Büro jeweils strukturäquiva-
lent, aber nicht namensäquivalent. Bei der Strukturäquivalenz haben Namen also lediglich
die Funktion der abkü rzenden Schreibweise, bei der Namensäquivalenz hingegen auch eine
von der Struktur unabhängige Bedeutung. Namensäquivalenz impliziert Strukturäquivalenz,
aber nicht umgekehrt; Namensäquivalenz ist somit das stärkere Konzept.
Strukturäquivalenz als Bedingung der Zuweisungskompatibilität reicht
aus, um Typfehler , also logische und Laufzeitfehler, die auf der Annahme
einer nicht vorliegenden Eigenschaft (Methode) bei einem Wert einer Variable basieren, zu
verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfän-
gerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.
So kann z. B. bei erf olgreicher Typprüfung (und daher vorliegender Typkorrektheit) ohne
Kenntnis der konkreten Inhalte der Variablen sichergestellt werden, dass bei Vorliegen der
Deklaration p <Person> der Ausdruck
keine Typfehler produziert, und gleichzeitig der Ausdruck
schon zur Übersetzungszeit als fehlerhaft zurückgewiesen wird, da er zu einer Variablen-
fehlbelegung (die in SMALLTALK noch problemlos möglich gewesen wäre) führt. Man be-
achte, das letztere sogar zu einer Speicher schutzverletzung führen könnte, wenn die Vari-
able p — wie in vielen Sprachen mit Typsystem — Wertsemantik hätte, nämlich dann, wenn
der übergebene String größer ist als der zur Aufnahme der Wohnung vorgesehene Spei-
cherplatz.
Strukturäquivalenz ist eine rein syntaktische Bedingung. Insbesondere
können bei geforderter Strukturäquivalenz Typen zufällig zuweisungskompatibel sein, die
inhaltlich überhaupt nichts miteinander zu tun haben. Dadurch können Objekte, die eigent-
lich getre nnten Typen (disjunkten Wertebereichen) angehören, über Kreuz und über die
Typgrenzen hinweg zugewiesen werden. Semantische Fehler sind also im mer noch möglich.
Man trifft daher in Sprachen mit Strukturäquivalenz gelegentlich die Praxis an, jedem Typ
eine für ihn charakteristische Methode exklusiv zuzuordnen, so dass er mit keinem anderen
mehr strukturäquivalent ist. Diese Technik nennt man Type branding . Bedeutung der
"
"4.3 Methoden
Die Auswertung von Nachrichtenausdrücken, also von Nachrichten, die an Objekte ver-
schickt werden, erfolgt mit Hilfe sog. Methoden . Was ein Objekt in Reaktion auf den Erhalt
einer entsprechenden Nachricht tun soll, wird durch eine Methodendefinition beschrei-
ben. Eine Methodendefi nition besteht dazu aus einem Methodenkopf , der in SMALLTALK
auch als Message pattern , allgemein (und im folgenden) aber eher als Methodensignatur
bezeichnet wird, einer optionalen Liste von lokalen Variablen und einem Methodenrumpf .
Letzterer enthält die Anweisungen , die die Methode ausmachen, die also zur Auswertung
eines Nachrichtenausdrucks ausgeführt werden. Es ist üblich, jede Methodendefinition mit
einem in doppelte Anführungsstriche gesetzten Kommentar zu versehen, der beschreibt,
was diese Methode macht.
Die Methodensignatur besteht aus dem Namen der Methode und der
Liste ihrer formalen Parameter . Formale Parameter sind lokale Variab-
len, denen beim Aufruf der Methode (s. Abschnitt 4.3.2 ) automatisch ein
Wert, der sog. tatsächlich e Parameter20, zugewiesen wird und deren Sichtbarkeit auf die
Methode, in deren Methodensignatur sie vorkommen, beschränkt ist. Wie alle lokalen Va-
riablen müssen sie mit einem Kleinbuchstaben beginnen. Außerdem sind sie temporäre Va-
riablen , was soviel heißt wie dass sie nur für die Dauer der Ausführu ng der Methode exis-
tieren. Damit sind auch die Aliase, die durch formale Parameter gebildet werden können,
immer temporär. In SMALLTALK sind formale Parameter zudem Pseudovariablen (s. Abschnitt
1.7), d. h., es kann ihnen innerhalb der Methode, für die sie sichtbar sind, nichts zugewiesen
werden. Syntaktisch unters cheidet sich SMALLTALK von den meisten anderen Programmier-
sprachen auch bei der Methodendefinition dadurch, dass die formalen Parameter nicht
rameter “ ins Deutsche übersetzt, was oft als falsch verhöhnt wird, aber die Sache trotzdem trifft,
zumindest, wenn man die zeitliche Dimension, die mit der Programmausführung einhergeht, in Be-
tracht zieht: Es gibt nämlich in der Regel viele tatsächliche Parameter zu einem Methodenaufruf, von
denen — zu jede m Zeitpunkt — höchstens einer der aktuelle ist. formal e und
durch Kommata getrennt in einer in Klammern eingeschlossenen Liste hinter dem Metho-
dennamen stehen, sondern jeder für sich von einem Nachrichtenbestandteil eingeleitet
wird.
Eine Methodendefinition folgt also dem Schema
(in spitzen Klammern wieder metasyntaktische Variablen , also Platzhalter für entsprechende
Programmelemente). Eine einfache Methode wäre etwa
oder, wer es generischer mag,
Die Methodensignatur als Teil einer Methodendefinition wird im folgenden immer fett her-
vorgehoben.
Die Methoden signatur dient der Auswahl der zu einer Nachricht passenden Methode; sie
ist das Gegenstück zum Nachrichtenselektor aus Abschnitt 4.1.2 , anhand dessen die Aus-
wahl der zu einem Nachrichtenausdruck passenden Methode durchgeführt wird. Anders als
ein Nachrichtenausdruck nennt eine Methodensignatur aber kein Empfängerobjekt und die
offenen Stellen eines Nachrichtenselektors werden ausschli eßlich durch Variablen, eben die
formalen Parameter , und nicht durch beliebige Ausdrücke besetzt. Typische Methodensig-
naturen sind z. B.
für Methoden ohne Parameter,
für binäre Methoden21 (mit einInteger als formalem Parameter) und
folge als Name verwenden. In der Literatur wird er häufig anders gebraucht: Der Empfänger und der
Parameter einer binären Methode haben denselben Typ (vgl. Fußnote 17 und Abschnitt 29.5). Schema der
für alle anderen Methoden mit einem oder mehreren Parametern (in diesem Fall mit nur
einem formalen Parameter, einStrom ). Die Methodensignaturen „passen“ übrigens je-
weils zu den entsprechenden Nachrichtenausdrücken aus den Zeilen 68, 69 und 70. Wenn
der Nachrichtenselektor aus mehreren Teilen besteht, werden diese (entsprechend den Bei-
spielen in den Zeilen 48 ff.) einfach angehängt.
Wie bereits erwähnt, besteht der Methodenrumpf aus einer Folge von
Anweisungen, Ausdrücken, die jeweils durch einen Punkt getrennt sind.
Wenn die Anweisungen nichts anderes vorsehen, wird die Ausführung
einer Methode nac h Abarbeitung der letzten Anweisung explizit mit der
Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Been-
digungen und Rückgabe eines anderen Objekts als des Empfängers ist die Return -Anwei-
sung (Abschnitt 4.2) vorgesehen.
Eine Return -Anweisung darf an beliebigen Stellen innerhalb der Methode
auftreten. Die Abarbeitung der Methode kann demnach auch vor Errei-
chen der textuell letzten Anweisung beendet werden. Die Return -Anweisung beein flusst
also den Kontroll fluss des Programms. Wichtig ist, dass eine Methode immer ein Objekt
zurückgibt; ein Nachrichtenausdruck (oder Methodenaufruf ; s Abschnitt 4.3.2 ) steht als
Ausdruck also immer für ein Objekt. Prozeduren im Sinne PASCAL s oder Void -Methoden im
Sinne von C, JAVA usw. gibt es in SMALLTALK nicht (vgl. a. Abschnitt 4.1.3 ).
Sollte eine Methode zur Durchführung ihrer Berechnungen temporäre
Variablen benötigen, so müssen diese zu Beginn der Methode (nach der Methodensign atur
und vor der ersten Anweisung) deklariert werden. Die Werte dieser Variablen, die standard-
mäßig mit nil initialisiert werden, sind außerhalb der Methode nicht sichtbar; die Variablen
werden insbesondere nach Abarbeitung der Methode vom System wieder en tfernt. Sie kön-
nen sich also auch zwischen zwei Ausführungen einer Methode nichts merken.
Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischener-
gebnissen einen Namen geben :
Umgekehrt können temporäre Variablen, die nur einmal verwendet werden, eingespart
werden, indem man kaskadierte Nachrichtenausdrücke (Abschnitt 4.1.2 ) verwendet . Rückkehr von eine r
Methoden sind die Einheiten des Programms, in denen Sie als Program-
miererin Ihre Anwe isungen unterbringen. Sie werden nach der Eingabe
(und bei jeder Änderung) mit dem „Speichern“ kompiliert („Speichern“ deswegen in An-
führungsstrichen, weil Methoden nicht in Dateien gespeichert werden, sondern in einer Da-
tenstruktur SMALLTALK s, und zwar in Form von Objekten ). Tatsächlich besteht der Löwenan-
teil eines jeden SMALLTALK -Programms, ja des gesamten SMALLTALK -Systems, aus Methoden-
definitionen. Die Methodendefinitionen entsprechen im wesentlichen der Definition von
Funktionen (oder, mit obiger Einschränkung, Prozeduren) in anderen Sprachen; jedoch ist
es in SMALLTALK nicht möglich (und in der objektorientierten Programmierung allgemein
nicht üblich), Methoden zu schachteln, also eine Methode innerhalb einer anderen zu de-
klarier en. Außerdem gibt es in SMALLTALK keine „Hauptmethode“ wie etwa die Main -Me-
thoden in der C -Sprachfamilie. Sie müssen dem SMALLTALK -System schon sagen, welche
Methode Sie ausgeführt haben wollen, z. B. indem Sie einen entsprechenden Ausdruck ein-
geben und au swerten lassen.
"
"11 Superklasse n und Subklassen
Wenn Sie sich schon vor diesem Kurs mit der objektorientierten Programmierung befasst
haben, dann fragen Sie sich vielleicht, warum die Begriffe der Super - und Subklasse bislang
nicht fielen. Das liegt daran, dass diese in verschiedenen Pr ogrammiersprachen verschiedene
Bedeutungen haben, während die Begriffe der Generalisierung und Spezialisierung sowie
die der Vererbung und der abstrakten Klassen recht einheitlich interpretiert werden.
Die Subklassenbeziehung ist, genau wie Generalisierung, Spezialisie-
rung und Vererbung, eine Beziehung zwischen Klassen. Die beiden Enden
der Beziehung vergeben die Rollen Superklasse bzw. Subklasse ; die Präfixe legen nahe,
dass die Subklassenbeziehung eine Klassenhierarchie aufbaut, in der die Superklassen
über den Subklassen stehen. Außerdem ist die Subklassenbeziehung transitiv: Wenn A eine
Subklasse von B ist und B eine von C, dann ist A auch eine Subklas se von C. Analoges gilt
natürlich auch für Superklassen. Man spricht übrigens von einer direkten Subklasse bzw. Eigenschaften der
von einer direkten Superklasse , wenn es keine weitere Klasse gibt, die in der Subklassen-
beziehung dazwischen steht. Die Subklassenbeziehung ist (anders als die Subtypenbezie-
hung; vgl. Kapitel 26) nicht reflexiv (irreflexiv) — eine Klasse kann also keine Subklasse von
sich selbst sein.
"
"4.4.3 Parametrisierte Blöcke
Die Blöcke von SMALLTALK können auch als anonyme Funktionen aufgefasst werden, wobei
alle bisherigen parameterlos waren: Der Bezug zu ihrer Umwelt wurde ausschließlich über
den Home context hergestellt. Es aber auch möglich , Blöcke mit Parametern zu versehen, Laufzeitfehler bei
die bei ihrer Auswertung an Objekte aus dem Kontext der Auswertung gebunden werden
können. Den obige n Swap -Block könnte man also auch wie folgt definieren wollen :
wobei die jeweils von einem Doppelpunkt eingeleiteten und vom Rest des Blocks durch
einen senkrechten Strich abgetrennten Variablen x und y die formalen Pa rameter des Blocks
sind und das — analog zu einer Methode — in Strichen eingeschlossene temp eine lokale
Variable ist. Der Variable swap wie oben zugewiesen kann der Block mittels
ausgewert et werden , wenn a und b Variablen aus dem Kontext der Auswertung sind.
Selbsttestaufgabe 4.2
(a) Versuchen Sie, durch Überlegen oder Ausprobieren herauszufinden, ob die Auswertung des
Blocks swap aus Zeile 193 seinen (mutmaßlichen) Zweck erfüll t, also beispielsweise in Zeile 194 den
Wert der Variablen a und b tauscht.
(b) Wie sieht das beim Parameterlosen swap aus Zeile 176 (in einem geeigneten Kontext) aus ?
(c) Be gründen Sie, warum es sinnvoll ist, die explizite Zuweisung an die formalen Parameter eines
Blocks (im obigen Beispiel x und y) innerhalb des Blocks zu verbieten.
"
"70 Fazit
Die Quintessenz der Bedeutung von Stil lässt sich kaum besser wiedergeben als durch ei n
weiteres Zitat von BERTRAND MEYER:
Good software is good in the large and in the small, in its highlevel architec-
ture and in its low -level details. True, quality in the details does not guarantee
quality of the whole; but sloppiness in the details usually indicates that some-
thing more serio us is wrong too. … A serious engineering process requires
doing everything right: the grandiose and the mundane.
So you should not neglect the relevance of such seemingly humble details as
text layout and choice of names. True, it may seem surprising to mo ve on …
from … formal specifications … to whether a semicolon should be preceded
by a space …. The explanation is simply that both issues deserve our care, in
the same way that when you write quality O -O software both the design and
the realization will re quire your attention.
Das Kapitel „A sense of style“ aus BERTRAND MEYERs Buch empfehle ich jeder, die glaubt,
Stil sei eine persö nliche Angelegenheit und ansonsten nicht so wichtig. Über MEYERs kon-
krete Vorgaben mag man streiten, über die prinzipielle Würdigung der Wichtigkeit von Stil
hingegen nicht.
Wer JAVA programmiert, die mag sich die JAVA Coding Standards des Software Engineering
Institutes der Carnegie -Mellon -Universität zu Gemüte führen. Man kann sich wundern, was
an der Verwendung einer Programmiersprache alles regul ierungsfähig ist (und fragen, wa-
rum man die eine oder andere Regel nicht in die Definition der Sprache gepackt hat). Le-
senswert ist auch der Eintrag zum Thema „Programmierstil “ in der deutsch sprachig en Wi-
kipedia.
"
"37 Ausdrücke
Ausdrücke sind in JAVA
 Literale,
 Variablen,
 die spezielle Variable this ,
 Operatoranwendungen,
 Feldzugriffe der Form a.x, wobei a für den Besitzer des Feldes (ein Objekt oder eine
Klasse) und x für das Feld (die Instanz - bzw. Klassenvariable) steht ( a kann auch
durch super ersetzt werden),
 Methodenaufrufe der Form a.m(…) , wobei a für den Empfänger des Aufrufs steht
oder für super , m für die Methode und … für die tatsächlich en Parameter (die wie-
derum Ausdrücke sind),
 Array -Zugriffe der Form a[i] , wobei a für das Array und i für einen Index steht
(eine ganze, positive Zahl; bei mehrdimensionalen Arrays können entsprechend wei-
tere Indizes in eckigen Klammer n angegeben werden),
 Klasseninstanziierungen der Form new <Klassenname> (<Parameter >)
 Array -Instanziierungen der Form new <Basistypname> [<n>] , wobei
<Basistypname> für den Typ der Elemente steht (also z. B. int bei einem Array
von Integern) und < n> für ei nen Ausdruck, dessen Auswertung eine ganze, positive
Zahl liefert (es können auch mehrere Dimensionen angegeben werden),
 Konditionalausdrücke der Form <Boolescher Ausdruck> ? <Ausdruck 1> :
<Ausdruck 2> , wobei in Abhängigkeit davon, ob <Boolescher Ausdruck > zu
wahr oder zu falsch auswertet, entweder <Ausdruck 1> oder <Ausdruck 2>
ausgewertet wird und das Ergebnis des Gesamtausdrucks liefert,
 Cast-Ausdrücke der Form (<Typname>) <Ausdruck> , wobei <Typname> für das
Ziel des Casts steht und <Ausdruck> für den Ausdruck, dessen Ergebnis den mit
<Typname> bezeichneten Typ annehmen soll , sowie Ausdrücke
 Lambda -Ausdrücke der Form (<Parameterdeklarationen>) -> <Rumpf> ,
wobei <Parameterdeklarationen> den formalen Parameterdeklarationen einer
Methode entspricht und <Rumpf> entweder eine einzelne Anweisung oder ein
Block von Anweisungen, entsprechend einem Methodenrumpf (inkl. der geschweif-
ten Klammern) ist. Falls nur ein Parameter deklariert wird, können die runden Klam-
mern auch weggelassen werden.
Wie man sieht, können in JAVA Ausdrücke rekursiv aus anderen aufgebaut werden: Metho-
denausdrücke beinhalten einen Ausdruck, der für den Empfänger steht sowie möglicher-
weise weitere, die für die Parameter des Methodenaufrufs („der Nachricht“) stehen, Array -
Zugriffe und -Instanzi ierungen beinhalten Ausdrücke zur Bestimmung des Indexes bzw. der
Größe, etc. Dabei müssen die Ausdrücke alle korrekt typisiert sein in dem Sinne, dass der
Typ jedes Ergebnisses eines inneren Ausdrucks mit dem der Stelle des äußeren, an der er
eingesetzt w ird, zuweisungskompatibel sein muss .
Genau wie in SMALLTALK , aber anders als in einigen anderen objektorien-
tierten Programmiersprachen (z. B. C++, C#) gibt es in JAVA nur Call by
value und kein Call by reference ; Methoden, die einem tatsächlich en Pa-
rameter einen anderen Wert zuweisen (wie z. B. eine Methode, die den Inhalt zweier Vari-
ablen tauscht), sind daher in JAVA nicht möglich.60 Dies stellt eine erhebliche Einschränkung
dar.
Die Lambda -Ausdrücke von JAVA, die mit Version 8 eingeführt wurden,
ersetzen die bis dahin geübte Praxis, Funktionen über anonyme innere
Klassen, die ein Interface (s. Abschnitt 40) mit nur einer Methode implementieren, in Ob-
jekte zu verpacken. Geblieben ist die Tatsache, dass Lambda -Ausdrücke den Typ eines In-
terfaces haben, der allerdings nicht direkt angegeben, sondern inferiert wird , und dass die
Funktionen, die die Lambda -Ausdrücke darstellen, über das Interface einen Namen erhalten .
„Anonyme“ Funktionen oder Blöcke wie in SMALLTALK können in JAVA über v ordefinierte
Interfaces erstellt werden: So liefert
ein Objekt vom (Interface -)Typ Function , der wie folgt deklariert ist (zur Bedeutung von
<T, R> s. Kapitel 43):
Demnach heißt die Funktion des Funktionsobjekts „apply“; der Ausdruck f.apply(2) lie-
fert entsprechend 4. Hierbei entspricht apply(.) dem aus SMALLTALK bekannten value:
(s. Abschnitt 4.4 in Kurseinheit 1).
Referenzsemantik hab en: Auch sie können nicht so deklariert werden, dass ihnen anstelle der Refe-
renz eine Referenz auf eine Referenz übergeben wird (s. dazu auch Abschnitt 4.3.2 ). Parameterübergabe
Ähnlich wie i n SMALLTALK Blöcke können Lambda -Ausdrücke in JAVA Kon-
text einfangen und mitnehmen (vgl. Abschnitt 4.4.1 in Kurseinheit 1). Allerdings müssen
die freien (lokalen) Variablen, die aus dem Kontext eingefangen werden können, final
deklariert sein (oder zumindest final deklariert sein können, also ihren Wert nicht mehr
ändern) und ein Rückspringen aus dem Home context mittels return aus dem Lambda -
Ausdruck ist nicht vorgesehen.
Abgesehen von der Typisierung sind die wesentlichen Unterschiede zu
SMALLTALK s Ausdrücken ( Abschnitt 4.1 in Kurseinheit 1) die folgenden:
 In JAVA gibt es auf Objekten d irekte Feldzugriffe ( a.x).
 In JAVA gibt es keine indizierten Instanzvariablen — diese werden durch Arrays als
eigenständige Objekte ersetzt. Array -Objekte können über keine benannten In-
stanzvariablen verfügen.
 In JAVA wird zwischen Operatoranwendungen ( +, – etc.), Methodenaufrufen, dem
Aufruf von Konstruktoren und Arrayzugriffen unterschieden — in SMALLTALK gibt es
nur Methodenaufrufe.
"
"4.5 Kontrollstrukturen
Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, aus
denen seine Ausführung besteht. Anders als in anderen Programmiersprachen gibt es in
SMALLTALK nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebunde-
nen Methodenaufruf; alle anderen, inklusive der Verzweigung und der W iederholung
(Schleife) , müssen durch diese simuliert werden. Dies ist möglich, weil SMALLTALK Blöcke hat
und weil in SMALLTALK (so wie in allen anderen objektorientierten Programmiersprachen) der
Methodenaufruf variabler ausfällt als der gewöhnliche Prozedur - oder Funktionsaufruf, wie
Sie ihn vielleicht von Sprachen wie PASCAL oder C her kennen: Er enthält, wie bereits in
Abschni tt 4.3.2 angedeutet, eine versteckte Fallunterscheidung in Form des dynamischen
Bindens .
"
"65 Deklarativer Stil
Einhergehend mit kurzen Methoden und sprechenden Bezeichnern ist ein deklarativer Pro-
grammierstil für die objektorientierte Programmierung typisch: Die Ausdrucksform bemüht
sich mehr um das Was als um das Wie. Der Effizienzgedanke ist dabei sekundär — mögliche
Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben,
wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung
zu ineffizient ist.
Da die objek torientierte Programmierung aber ihrem Wesen nach eher imperativ als dekla-
rativ ist, wird sich das Deklarative im wesentlichen auf den Aufruf von Methoden beschrän-
ken, die nach dem benannt sind, was sie tun. So ist es in der objektorientierten Program-
mieru ng durchaus üblich, einzelne Schleifen, in denen beispielsweise ein Element gesucht
wird, aus einem Methodenrumpf in eine eigene Methode zu verbannen und durch einen
entsprechenden Methodenaufruf zu ersetzen. Das Programm liest sich also nur deklarativ
und ist es nicht wirklich — es handelt sich ja auch nur um einen Stil.
Ein Beispiel für einen deklarativen Programmierstil geben die folgenden Gegenüberstellun-
gen (Atome und Literale sind hier Konzepte aus der Aussagenlogik):
(deklarativ) in einer Klasse Literal mit Instanzvariable atom anstelle von
(imperativ) oder
(deklarativ) in einer Klasse Klausel mit Instanzvariable literale anstelle von
(imperativ). Es dauert eine Weile, bis man sich das Imperative abgewöhnt hat, aber es lohnt
sich.
Für beide Alternativen der Methode auswerten in Klasse Klausel gibt es übrigens eine
Shortcut -Variante (die so heißt, weil die Iteration ggf. vorzeitig abgebrochen wird):
bzw.
aber solange man sich nicht sicher ist, dass eine (vermeintliche) Abkürzung funktional äqui-
valent ist (also dasselbe Ergebnis liefert), sollte man von solchen Optimi erungen die Finger
lassen. (Es könnte beispielsweise sein, dass auswerten für Literale einen Seiteneffekt hat;
in diesem Fall wären die optimierten Versionen nicht mehr äquivalent! )
Ein anderes Zeichen eines deklarativen Programmierstils ist die Verwen-
dung von Zusicherungen (Vor - und Nachbedingungen, Invarianten) an-
stelle von Kommentaren. Anstatt also umständlich zu formulieren
schreibt man besser
wenn es die Sprache zu lässt. Damit schlägt man zwei Fliegen mit einer Klappe: Man kann
die Zusicherungen zur Laufzeitverifikation einsetzen und man zeigt dem Aufrufer der Me-
thode, wie er selbst prüfen ka nn, ob die Vorbedingung eingehalten ist.
"
"1.4 Gleichheit und Identität von Objekten
Wie oben schon zur Unterscheidung von String - und Symbolliteralen angedeutet, w ird
durch das Vorkommen des gleiche n Literal s an mehreren Stellen eines Programms nicht
notwendigerweise dasselbe , also identische, Objekt repräsentiert — es kann auch sein, dass
die erzeugten Objekte nur gleich sind . Das wirft natürlich sofort die Frage a uf, was der
Unterschied zwischen Gleichheit und Identität bei Objekten ist, und wie überhaupt Objekte
unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in
der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung . Gleichheit
wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern
alle true . Aber auch
liefert true : Obwohl die beiden Zah lliterale verschieden sind (und für verschiedene, also
zwei, Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, so
dass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier
Objekte) wird in SMALLTALK durch == getestet. So liefern
erwartungsgemäß true ,
kann hingegen zu false auswerten — zwei syntaktisch gleiche String -Literale können also
zwei Objekte mit verschiedener Identität repräsentieren . Dies ist zumindest dann sinnvoll, Gleichheit von
wenn die durch die String -Literale erzeugten Objekte unabhängig voneinander änderbar
sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens : Phrasen wie
„zwei identische Objekte“ sind strenggenommen Unsinn , denn es handelt sich bei vorlie-
gender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt . Die Frage
nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder
Variablen ) repräsentiert werden . Mehr dazu in Abschnitt 1.5.
Selbsttestaufgabe 1.1
Prüfen Sie in einem oder mehreren Ihnen zur Verfügung stehenden SMALLTALK -Systemen für verschie-
dene gleiche Literale, ob die repräsentierten Objekte identisch sind. Beschränken Sie sich dabei nicht
nur auf die Beispiele der Zeilen 10–16. Was fällt Ihnen auf?
Während man sich unter der Identität einer Person oder eines Dokuments
leicht etwa s vorstellen kann, scheint der Begriff der Identität für manch
andere Objekte merkwürdig. Was hat man sich beispielsweise unter der
Identität der Zahl „1“ vorzustellen? Und wenn „1“ tatsächlich ein Objekt mit Identität ist,
was macht dieses Objekt zur Eins ? Oder ist die 1 vielleicht die Identität des Objekts „1“,
sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man
versucht sein, die Identität zweie r Objekte mit der Gleichheit ihrer Erschei-
nungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche
Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen,
warum man mehrere „1“ mit unterschiedlicher Identität in einem System haben sollte. Tat-
sächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch auf-
grund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz an-
ders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich
auch nur vorübergehend gleichen, müssen aber selbst während dieser (vorübergehenden)
Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderent-
wickeln können und man dann nicht mehr wüss te, welches welches war. Da dies aber für
unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, wa-
rum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderli-
ches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern
aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine
Zusammenlegung gleicher Objek te zu einem, immer erst überprüft wer-
den, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen
würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben.
Aber warum sind dann gleiche Zahlen manc hmal identisch, manchmal nicht? Die Antwort
ist noch technischer : Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun
und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte
eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe Ist es immer sinnvoll,
und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind —
für den Rest (mit Ausnahme der Symbole!) gilt das nicht. Konzeptuelle Gründe für die Son-
derbehandlung gibt es nicht.
Zusammenfassend merken Sie sich am besten folgendes:
Die Missachtung dieses Merksatzes ist eine der häufigsten Fehlerquellen der objektorientier-
ten Programmierung. Besonders beim Vergleichen von Strings ist die Verwendung des Tests
auf Identität anstelle des Tests auf Glei chheit ein häufiger logischer Programmierfehler. Des-
wegen noch einmal ganz deutlich:
Verwenden Sie also grundsätzlich den Test auf Gleichheit ( =), nicht auf Identität ( ==), es sei
denn, Sie wollen prüfen, ob Sie es mit einem oder mit zwei Objekten zu tun haben.
"
"43.6 Generische Variablen
Schließlich is t es in JAVA auch noch möglich, Variablen generisch zu deklarieren, also ohne
dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließen-
den Methode oder Klasse eingeführt worden wäre. Allerdings geht das, da eine Variable
anders als eine Klasse oder Methoden keinen neuen Sichtbarkeitsbereich definiert, nur mit
anonymen Typvariablen, also Wildcards. Man beachte jedoch, dass eine solche Variablen-
deklaration, genau wie eine generische Methodendefinition, keinen neuen Typ einführt (s.
Fußnote 72); vielmehr handelt es sich mit dem durch ein Typ -Wildcard als tatsächlich em
Parameter eingesetzten Typ selbst um einen konkreten Typ. Der per
deklarierten Variable liste können also Listen beliebigen Elementtyps zugewiesen werden,
einfach weil List<?> (unter den in Abschnitt 43.2 genannten Einschränkungen) Supertyp
aller Instanziierungen von List<T> ist.
"
"13.2.2 Sortierte Collections
Eine weitere nützliche Collection -Klasse wird durch SortedCollection implementiert. Es
handelt sich dabei um eine Subklasse von OrderedCollection , bei der die Reihenfolge
der Elemente nicht von außen, also durch die Angabe eines Indexes oder die Reihenfolge
der Einfügung, festgelegt wird, sondern von innen, genauer durch eine Qualität der einge-
fügten Objekte. Zwischenobjekte der Klasse SortedCollection setzt man ein, wenn man
die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge stehen wissen
möchte, wie z. B. die Kinder einer Person in der Namensfolge, und zwar unabhängig davon,
in welcher Reihenfolge sie der Collection hinzu gefügt wurden. Voraussetzung dafür, dass
die Elemente einer SortedCollection sortiert werden können, ist, dass sie sich verglei-
chen lassen, dass also die (binäre) Methode <= (für kleiner gleich) darauf definiert ist. So
liefert beispielsweise
thode hat. Dies ist beim Forwarding (oder eben der „Delegation“) der klassenbasierten objektorien-
tierten Programmierung nicht der Fall: self in der Methode at:put: der Klasse Dictionary
bezieht sich nie auf ein Ob jekt der Klasse Bag. Dictionaries als
universelle
Datenstruktur
Vorsicht Falle!
mit #(1 2 3) das gewünschte Ergebnis.45
Wenn die Elemente, die in eine sortierte Collection eingefügt werden sol-
len, keine Größen sind, also insbesondere den Vergleich <= nicht implementieren, dann ist
es immer noch mögl ich, für eine neue Instanz einer SortedCollection einen sog. Sor-
tierblock zu spezifizieren, der zwei formale Parameter hat und dessen Auswertung z urück-
liefert, ob der erste tatsächlich e Parameter kleiner oder gleich dem zweiten ist. Tatsächlich
wird, falls man bei der Erzeugung keinen Sortierblock angibt, ein Standardsortierblock an-
genommen:
Klasse SortedCollection
Superklasse OrderedCollection
Klassenmethoden
benannte Instanzvariablen sortBlock
indizierte Instanzvariablen nein
Instanzmethoden
eine Menge von Objekten aus einer Collection in eine andere übertragen werden kann, wobei die
Eigenschaften der Ziel -Collection berücksichtigt werden, so z. B. asSet , das doppelte Elemente ent-
fernt. Sie sind allesamt (und analog zu asBag und asOrderedCollection oben) in Collection
implementiert. Besonders interessant sind natürlich Konvertierungen in Collections, die stärkere Be-
dingungen stellen, also z. B. eben asSet und asSortedCollection . Sortierblöcke
Vorsicht Falle!
Man beachte jedoch, dass eine nach trägliche Änderung der Attribut werte, die zum Ver-
gleich der Objekte für die Sortierung herangezogen wurden, keine auto matische Änderung
der Reihenfolge bewirkt, selbst wenn dies eigentlich notwendig würde.
"
"54.4 Das Liskov -Substitutionsprinzip
In Sac hen verhaltensbasiertes Subtyping am meisten Bekanntheit erlangt haben die Arbei-
ten von Barbara Liskov und Jeannette Wing. Tatsächlich ist das sog. Liskov -Substitutions-
prinzip (Liskov substitution principle , LSP) eines der am häufigsten zum Thema Subtyping
angeführten, weswegen es auch hier behandelt werden soll. Ohne den Beitrag der beiden
schmälern zu wollen, ist dies durch die Sache jedoch nicht gerechtfertigt — anderen, frühe-
ren Arbeiten gebührt mindestens gleicher Ruhm und außerdem ist, wie Sie noch sehen
werden, das LSP zu streng gefasst , weswegen es nützliche, für die Praxis relevante Fälle des
verhaltensbasierten Subtyping ausschließt.
Historischer Hintergrund des Liskov -Substitutionsprinzips war die Suche
nach einer hinreichenden Bedingung für die Subtypenrelation zwischen zwei Typen. Wir
hatten ja in Kapitel 26 (Kurseinheit 3) festgestellt, dass es bei den meisten Programmier-
sprachen ausreicht, dass ein Typ B deklariert, Subtyp eines Typs A zu sein, damit Zuwei-
sungskompatibilität von B nach A festgestellt werden kann.88 Dazu war es allerdings not-
wendig, dass die Eigenschaften von A auf B übertragen (vererbt) und dass dabei die Regeln
von den ko - bzw. kontravarianten Redefi nitionen von Parametertypen eingehalten werden.
Dies wird im allgemeinen durch die Sprachdefinition und durch den Compiler sichergestellt.
Das verhaltensbezogene Subtyping geht nun über die auf die Kontrolle
der Parametertypen beschränkte, syntaktische Subtypenbeziehung hin-
aus, indem es — nach Liskov und Wing — fordert, dass sich Objekte eines Subtyps und
seines Supertyps gleich verhalten sollen, und zwar insoweit irgend jemand oder irgendein
Programm dies feststellen kann. Diese Forderung kulminiert in der Regel
Subtype Requirement: Let (x) be a property provable about objects x of type
T. Then  (y) should be true for objects y of type S where S is a subtype of T.
Eine deutsche Paraphrase dessen fanden Sie bereits in Abschnitt 26.1.
Diese Definition ist gleich in mehrfacher Hinsicht problematisch.
1. Da sie die Subtypenbeziehung definiert, ist da von auszugehen, dass x exakt vom
Typ T ist und y exakt vom Typ S. Es sind also insbesondere x und y keine Objekte
von Subtypen von T bzw. S. Damit ist die Definition nicht auf abstrakte Typen und
Interfaces ausdehnbar.
2. Damit zusammenhängend ist die Aussage losgelöst von jedem konkreten Gebrauch
der Objekte. Wie in Abschnitt 54.5 noch genauer dargestellt werden wird, kann
bilität besteht; der Compiler leitet die Zuweisungskompatibilität aus dem Bestehen einer Subtypen-
beziehung (z. B. extends oder implements in JAVA) ab.
eine Substituierbarkeit in einem gegebenen Kontext sehr wohl bestehen, auch wenn
die Typen nach obiger Definition nicht substituierbar sind. Man würde die Anforde-
rungen in einem solchen Fall in einem Interfacetypen festhalten, der nur die im Kon-
text benötigten Eigenschaften spezifiziert. Dieser Typ hat dann aber (gemäß Punkt
1) keine Objekte x.
3. Die Aussage ist implizit allquantifiziert über , d. h., sie soll für alle möglichen Eigen-
schaften (Prädikate)  gelten. Das bedeutet wiederum, dass alle Eigenschaften von
T auch für S gelten — die Objekte von S müssen sich also, sieht man einmal von
zusätz lichem Verhalten ab, exakt gleich verhalten. Das aber stellt die Idee des Sub-
typing weitgehend infrage: Wenn ein Objekt sich von dem, das es ersetzen soll ,
überhaupt nicht unterscheidet, wozu brauche ich es denn dann überhaupt?
Zu Punkt 3 ist abschwächend zu sagen, dass hier vermutlich Verhalten des Programms in-
sofern unverändert sein soll, als es immer noch seinen Zweck erfüllt, d. h., seiner Spezifika-
tion genügt. Das ist jed och etwas anderes, als in dem Prinzip ausgedrückt wird.
Eine Subtypenrelation zwischen S und T, die das obige Subtype require-
ment erfüllt, definieren Liskov und Wing zunächst wie folgt:
1. Überschreibende Methoden in S erhalten das Verhalten der überschriebenen Me-
thoden in T. Dazu gehört:
a. Kontravarianz der Argumenttypen der überschreibenden Methode
b. Kovarianz des Ergebnistyps der überschreibenden Methode
c. Kovarianz der Ausnahmen der überschreibenden Methode (die Typen der ge-
worfenen Exceptions sind entweder Subtypen von den Typen der Exceptions der
überschriebenen Methode oder die Exceptions werden gar nicht geworfen; kei-
nesfalls kommen Exceptions hinzu)
d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen
der überschreibenden: 𝑝𝑟𝑒𝑚𝑇(𝑠𝑒𝑙𝑓:S)⇒𝑝𝑟𝑒𝑚S(𝑠𝑒𝑙𝑓:S)
e. Nachbedingungen der überschriebenen Methode werden von Nachbedingun-
gen der überschreibenden Methode impliziert, also gilt hier: 𝑝𝑜𝑠𝑡𝑚𝑆(𝑠𝑒𝑙𝑓:S)⇒
𝑝𝑜𝑠𝑡𝑚𝑇(𝑠𝑒𝑙𝑓:S)
2. Die Invarianten von S implizieren die von T.
Man beachte, dass die (auch semantisch genannten) Regeln 1.d und 1.e die (auch syntak-
tisch genannten) Regeln 1.a – 1.c implizieren: In typlosen Sprachen wie SMALLTALK beispiels-
weise würde man die entsprechenden Anforderungen an die Parameterobjekte mittels Vor -
und Nachbedingungen formulieren und die Menge der geworfenen Exceptions wäre Teil
der Nachbedingungen.
Man kann sich die Wirksamkeit der Bedingungen wie folgt erklären: Subtypenrelation
Aus den obigen Regeln der Subtyp relation und aus der Korrektheit der überschreibenden
Methode in S folgt die gewünschte Substituierbarkeit.
Es bleibt jedoch noch das eingangs beschriebene, mit dem Aliasing und
der damit verbundenen Möglichkeit des zu sätzlichen Methodenaufrufs assoziierte Problem
bestehen. Dafür identifizieren Liskov und Wing zwei Lösungen:
Die erste sagt aus, dass das Verhalten eines Subtyps immer dann mit dem
des Supertyps konform ist, wenn alles zusätzliche Verhalten des Subtyps durch Verhalten
des Supertyps simuliert werden kann, wenn es also für jede zusätzliche Methode eine Kom-
bination von Methodenaufrufen des Supertyps (bzw. deren überschriebenen, verhaltens-
konformen Varianten) gibt, die den Effekt der zusätzlichen Methode hat und die der Klient
des Objekts auch selbst (oder ein anderer Klient, der aber das Objekt durch denselben Typ
sieht) durchführen könn te. Diese Bedingung ist jedoch ziemlich hart, da sie im Grunde aus-
sagt, dass ein Subtyp lediglich Makros hinzufügen darf. Auf der anderen Seite ist ihre Ein-
haltung, wenn auch nicht automatisch, so jedoch zumindest anschaulich relativ einfach
nachzuweisen ( was für die Praxis eminent wichtig ist).
Die zweite Lösung ist denn auch weniger einschränkend, dafür aber in
der Praxis kaum nachzuweisen: Sie verlangt von jedem Typ zusätzlich zur
Verhaltensspezifikation der Methoden (übe r die üblichen Vor - und Nachbedingungen) die
Einhaltung von Verlaufseigenschaften , die die möglichen Zustandswechsel der Objekte des
Typs betreffen und die wir deswegen Zustandswechselinvaria nten nennen. Dazu wäre
eine Art endlicher Automatenspezifikation, also eine Spezifikation der Menge der möglichen
Zustände und Zustandsübergänge, notwendig. Das Problem dabei ist jedoch, dass die Zu-
stände eines Objekt s nicht abstrakt (z. B. in Form einer Aufzählung von Zustandsnamen)
existieren, sondern sich in der Belegung von Instanzvariablen manifestieren, so dass sich der
Zustandsraum kombinatorisch (abzüglich der funktionalen Abhängigkeiten der Attribute)
ergibt. Um dem aus dem Weg zu gehen, werden bei den historischen Zustandswechseln
lediglich zwei beliebige, zeitlich nicht notwendig unmittelbar aufeinander folgende Zu-
stände betrachtet und für diese eine Bedingung formuliert, die eingehalten werden muss .
Man beac hte, dass die Einhaltung der ersten Bedingung die zweite impliziert: Wenn alle
Methoden des Supertyps die historischen Invarianten einhalten und wenn eine Methode das Aliasing -Problem
Verhaltenssimulation
Zustands wechsel in-
varianten Korrektheit
Substituierbarkeit
Kontravarianz
Kovarianz
𝑝𝑜𝑠𝑡𝑚S(𝑠𝑒𝑙𝑓:S)⇒𝑝𝑜𝑠𝑡𝑚T(𝑠𝑒𝑙𝑓:S)
𝑝𝑟𝑒𝑚S(𝑠𝑒𝑙𝑓:S)⇒𝑝𝑜𝑠𝑡𝑚S(𝑠𝑒𝑙𝑓:S) 𝑝𝑟𝑒𝑚𝑇(𝑠𝑒𝑙𝑓:S)⇒𝑝𝑟𝑒𝑚S(𝑠𝑒𝑙𝑓:S) 𝑝𝑟𝑒𝑚𝑇(𝑠𝑒𝑙𝑓:S)⇒𝑝𝑜𝑠𝑡𝑚𝑇(𝑠𝑒𝑙𝑓:S)
des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, dann hält
auch diese die historischen Invarianten ein.
So gut das Liskov -Substitutionsprinzip auch begründet sein mag, es er-
weist sich für die Praxis als zu streng. So könnte man beispielsweise in einem Typ T eine
Methode echo: i <Integer> ^Integer definieren, die den Eingabeparameter gleich
wieder ausgibt (die sog. Identität oder Identitätsfunktion) . In einem Subtyp S könnte man
dann die Methode so überschreiben, dass sie beliebige Objekte entgegennimmt und gleich
wieder zurückgibt: echo: i <Object> ^ Object . Die Methode ist damit zwar in ihrem
Eingabeparameter kontravariant, aber in ihrem Ausgabeparameter nicht kovariant, und er-
füllt somit die Bedingung des LSP nicht. Gleichwohl kann echo: auf einem Objekt vom Typ
S überall da aufgerufen werden, wo es auch auf einem Objekt von Typ T aufgerufen werden
kann, denn es kommt so niemals dazu, dass die Regel der Kovarianz des Ausgabeparame-
ters verletzt wird. Wir haben es beim LSP also mit einer Typprüfung zu tun, die gültige
Programme zurückweist. Dafür, dass die Einhaltung des LSP für den allgemeinen Fall gar
nicht automatisch überprüft werden kann, ein ziemlich hoher Preis.
"
"4.1 Ausdrücke
In einem objektorientierten Programm können Objekte nicht nur durch Literale (Ab-
schnitt 1.2) und Variablen (Abschnitt 1.5) repräsentier t werden, sondern auch durch Aus-
drücke . Tatsächlich sind Literale und Variablen primitive Ausdrücke , also solche, die nicht
aus anderen zusammengesetzt sind. Damit mit den Objekten aber etwas geschehen und
ein Programm somit etwas tun kann, brauchen wir noch andere Ausdrücke, namentlich
Zuweisungsausdrücke und Nachrichtenausdrücke . Auch sie stehen jeweils für ein Objek t
und können deswegen überall da auftreten, wo Objekte verlangt werden. Sie können ins-
besondere auch geschachtelt werden.
"
"46.1 Externe Iterat ion
Bei :n-Beziehungen müssen ja häufig mehrere Elemente der gleichen Behandlung unterzo-
gen werden oder es werden aus der Menge der Elemente einige gesucht. Sind die Elemente
in einem Array gespeichert, so kann man in JAVA dazu etwas der Form
schreiben. Verwendet man aber Collections, die nicht indiziert sind (es gibt auch in JAVA so
Collections wie Bäume oder verkettete Listen), ist die obige Form der Iteration nicht einsetz-
bar. Stattdessen gibt es i n JAVA die beiden Interfaces Enumeration (total veraltet) und
Iterator (etwas neuer), die eine einheitliche Iteration über Collections mittels sog. Itera-
toren erlauben. Jede Collection -Klasse, die Iterator implementiert, bietet dazu eine Me-
thode iterator() an, die ein solches Iteratorobjekt (vom Typ Iterator ) zurückliefert.
Mit der Methode next() erhält man von diesem Objekt zunächst das erste und in der Folge
alle weiteren Objekte der Coll ection; mit der Methode hasNext() fragt man ab, ob die
Collection noch weitere Objekte enthält. Eine typische Iteration über eine Collection sah in
JAVA also wie folgt aus:
Alternativ (und in der Praxis nicht seltener, obwohl eine Anweisung mehr) findet man auch
In manchen Programmen findet man allerdings auch heute noch die vor JAVA 2 einzig mög-
liche Variante
bzw. das Äquivalent mit der For -Schleife.
Die Wahl der unnötig langen Bezeichner lässt vermuten, dass man die
Häufigkeit solcher Konstruktionen in der Programmierpraxis unterschätzt hatte. Dieser Feh-
ler wurde mit JAVA 5 korrigiert, so dass man seither stattdessen
schreiben kann (wobei Element hier für den Elementtyp v on aCollection steht). Voraus-
setzung ist allerdings, dass die Klasse von aCollection das Interface Iterable imple-
mentiert, das wiederum verspricht, dass die Instanzen die Methode Iterator
iterator() anbieten und damit einen Iterator zurückliefern, der dann von der For -Anwei-
sung zur Produktion der Elemente ausgenutzt werden kann ; es handelt sich bei dieser Ver-
sion der For -Schleife also lediglich um „syntaktischen Zucker“ . Man beachte, dass dabei
eine weitere Verquickung von Sprachdefinition und Klassenbiblio thek (API ; speziell der In-
terface Iterator ) stattgefunden hat, die nicht schön ist.
"
"52.7 Tupel anstelle von Klassen
Ein relativ neues Feature von EIFFEL sind die sog. Tupe l. Tupel erlauben es, ohne großen
Aufwand mehrere Objekte zu einem zu gruppieren. Insbesondere ist dafür keine Definition
einer Klasse notwendig. Tupel sind also vor allem da interessant, wo strukturierte Daten
vorkommen, ohne dass man der Struktur eine eigenständige Bedeutung beimessen würde.
Dies ist am prominentesten bei Methoden der Fall, die mehrere anstatt eines Wertes zu-
rückgeben sollen.
Tupeltypen werden deklariert, indem man für jede Stelle einen Typ angibt; konkrete Werte
eines Tu pels werden in eckigen Klammern notiert:
ist ein Tupelausdruck. Die Stellen eines Tupels können auch mit Namen versehen werden:
ist ein solches Tupel, bei dem die Stellen „a“, „b“ und „c“ heißen. Da Tupeltypen unbe-
nannt sind, erfolgt die Zuordnung eines Tupels zu einem Tupeltyp (die ja normalerweise bei
Instanziierung erfolgt) aufgrund eines Abgleichs der vorgefundenen mit den deklarierten
Stellentypen (sowie ggf. der Namen der Stellen).
"
"50 C#
C# ist MICROSOFT s Antwort auf JAVA. Oberflächlich betrachtet JAVA recht ähnlich, enthält C#
doch einige zusätzliche Merkmale von C++, aber auch solche von MICROSOFT s Haussprache
VISUAL BASIC. Dabei ist die Entwicklung von C# wohl weniger der Versuch, mit der MICROSOFT
eigenen Marktmacht einen proprietären Standard durchzudrücken (was bei Programmier-
sprachen meines Wissens bislang auch noch nie gelungen wäre), sondern vielmehr dem
Umstand geschuldet, dass JAVA keine volle Kontrolle über Rechner und Betriebssystem bie-
tet und somit nicht für jede kommerzielle Softwareentwicklung geeignet ist. Zwar war auch A language that doesn't affect the w ay you think about programming,
is not worth knowing.
SUN bemüht, bekannte Schwächen zu beheben, aber man gibt sich dabei doch recht
schwerfällig. Und so war, bei dem nicht zu übersehenden Erfolg JAVAs in der Softwareent-
wicklerinnengemeinde , die Abspaltung einer eigenen, JAVA-artigen, aber eben doch in
wichtigen Punkten verschiedenen Sprache eigentlich nur folgerichtig.
"
"10.3 Abstrakte Klassen
Die Genera Aristoteles’ sind allesamt abstrakt — es gibt keine Säugetiere, die nicht Mensch
oder Hund oder Katze oder was Konkretes auch immer wären. Übertragen auf die obje kt-
orientierte Programmierung hieße das: Generalisierungen, also Klassen, die aus Generalisie-
rungen hervorgegangen sind, haben selbst keine Instanzen, sind also insbesondere nicht
instanziierbar .
In der objektorientierten Programmierung nennt man nicht instanziier-
bare Klassen abstrakt . Der Grund für die mangelnde Instanziierbarkeit
duen) untereinander fortpflanzungsfähige Nachkommen zeugen können, sinnvoll, doch unterliegen
derart angelegte Artendefinitionen dem erdgeschichtlichen Wandel, wie sich schon daraus ableiten
lässt, dass alles Leben aus den ersten Einzellern entstanden ist. Natürlichkeit der
ist jedoch häufig kein konzeptueller (wie beispielsweise, dass es sich bei einer Klasse um
eine Generalisierung handelt und sie daher nicht instanziierbar sein sollte), sondern ein rein
technischer: Abstrakten Klassen fehlen in der Regel Angaben, die das Verhalten ihrer In-
stanzen vollständig spezifiziert und diese somit brauchbar machen würden, so dass Instan-
zen dieser Klassen, wenn es sie denn geben würde, unvollständig definiert wären und z u
Laufzeitfehlern führen würden. Diese fehlenden Eigenschaften werden erst in den Klassen
geliefert, die von den abstrakten erben (s. nächstes Kapitel ), wobei die Idee ist, dass sich die
Eigenschaften von Klasse zu Klasse unterscheiden. Klassen, die nicht abstrakt sind, die also
eigene Instanzen haben können, nennt man konkret .
Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse
Collection . Sie ist (in Auszügen) wie folgt definiert:
Klasse Collection
benannte Instanzvariablen
indizierte Instanzvariablen nein
Instanzmethoden
Man erkennt schon am Fehlen von Instanzvariablen, dass es mit der Implementierung von
Collection nicht weit her sein kann — Instanzen wären schlicht zustandslos, weswegen
sie kaum zu gebrauchen wären. Besonders deutlich wird die Abstraktheit jedoch an der
Implementation der Methode add: : Hier wird, anstatt et was Entsprechendes zu tun, die
Methode implementedBySubclass37 aufgerufen, die eine Fehlermeldung ausgibt. Jede,
die mit einer direkten Instanz von Collection arbeiten würde und die Methode add:
(oder addAll: ; auf die Bedeutung von self im Kontext von abstrakten Klassen und Ver-
erbung gehen wir gleich und später dann in Abschnitt 12.1, „Nachrichten an self “, noch
einmal ein) darauf aufrufen wollte, würde enttäuscht.
Allerdings erst zur Laufzeit. Viele andere Sprachen verlangen daher, dass
man abstrakte Klassen mit einem Schlüsselwort, z. B. abstract , mar-
kiert, und verbieten dann (per Compiler), die Klasse zu instanziieren. Das geht in SMALLTALK
jedoch nicht, da Klassen auch Objekte sind und daher in Variablen gespeichert werden kön-
nen, den en man dann einfach new schicken kann, ohne dass der Compiler wissen könnte,
welches Objekt die Variable nun gerade bezeichnet .
Selbsttestaufgabe 10.1
Probieren Sie es gleich aus, d. h., weisen Si e eine Klasse einer Variable zu und schicken sie dem durch
die Variable bezeichnetem Objekt die Methode new!
Nun erfolgt der Hinweis, dass man eine abstrakte Klasse instanziiert hat,
in SMALLTALK nicht nur erst zur Laufzeit, sondern auch da er st zum spä-
testmöglichen Zeitpunkt, nämlich wenn man eine nicht implementierte Methode aufzuru-
fen versucht. Was man tun könnte, um zu verhindern, dass Instanzen einer abstrakten
Klasse überhaupt erzeugt werden , ist, die Konstruktoren, insbesondere new und new: , ent-
sprechend zu überschreiben (vgl. Abschnitt 8.2).38 Allerdings verhindert man damit zu-
nächst auch die Instan ziierung der Klassen, die von Collection erben, die natürlich nicht
alle abstrakt sein sollen. Diese müsste n dann new und new: wieder neu einführen, was aber
kaum zumutbar ist, zumal new und new: primitive Methoden (s. Abschnitt 4.3.7 ) aufrufen.
(Vgl. hierzu auch die Grenzen der Verwendung von super in Abschnitt 12.2.)
Man könnte in SMALLTALK die Methode add: in der Klasse Collection natürlich auch ganz
weglassen.39 Ein Aufruf von add: auf einer Instanz von Collection oder einer ihrer Sub-
klassen würde dann zum Aufruf von doesNotUnderstand und der Ausgabe einer ent-
sprechenden Fehlermeldung führen. Allerdings wäre diese Fehlermeldung für die Program-
miererin weniger aufschlu ssreich: Sie wüsste nicht, ob sie einfach nur einen falschen Me-
thodennamen verwendet hat ( ihr Fehler) oder ob die Programmiererin einer Subklasse von
Collection vergessen hat, die Methode add: zu implementieren (jemand anderes Feh-
ler). Eine Methode wie add: in Collection vorzusehen, die auf ein Versäumnis hinweist,
so es denn eines gibt (es könnte ja auch sein, dass man versehentlich eine Instanz von
Collection erzeugt hat und darauf add: ausführt, obwohl add: für alle erbenden Klas-
sen implementiert ist — das erlaubt dann die Fehlermeldung nicht zu unterscheiden) ist
schon sinnvoll. Die Laufzeitfehlermeldung von SMALLTALK ersetzten also gewissermaßen die
Compiler -Fehlermeldungen anderer Sprachen. Die entspreche nden Grundlagen werden
Ihnen in Kurseinheit 3 begegnen.
auch vorhanden ist, selbst wenn sie auf self aufgerufen wird (und damit schon klar ist, welche
Klassen die Methode eigentlich haben müssten). In anderen Sprachen ist das anders. Verhinderung der
Man mag sich fragen, warum es eine abstrakte Klasse wie Collection überhaupt gibt,
wenn sie doch keine Instanzen haben soll.40 Bereits das obige Beispiel gibt eine erste Ant-
wort: Weil es auch in abstrakte n Klassen Methoden gibt, die voll ausimplementiert sind
(z. B. addAll: ) und die dann in den Subklassen, auf die sie vererbt werden, nicht wieder-
holt werden müssen. Tatsächlich ist alles, was eine erbende Klasse tun muss , um in den
Genuss einer funktioniere nden Methode addAll: zu kommen, eine Implementierung von
add: zu liefern. Die abstrakte Klasse faktorisiert also die Gemeinsamkeiten mehrerer Klas-
sen heraus und markiert gleichzeitig, was ihre erbenden Klassen noch nachtragen müssen:
Alle Methoden, die von anderen Methoden der Klasse aufgerufen werden (wie eben add:
von addAll: ), die aber (z. B. mangels Instanzvariablen wie im Fall von Collection ) in der
Klasse noch nicht implementiert werden können, deren Aufruf auf Instanzen der abstrakten
Klassen somit e inen entsprechenden Fehler liefern würde.
Der Aufruf einer abstrakten, d. h. in der Klasse nicht implementierten Me-
thode aus der Klasse selbst heraus wie in Zeile 430 (mit self als Empfänger) ist ein gängiges
Muster der objektorientierten Programmierung. Man nennt es auch offene Rekursion
(engl. open recursion ), da der Aufruf auf dem Objekt selbst erfolgt (also gewissermaßen
rekursiv ist), aber an der aufrufenden Stelle noch nicht klar (offen) ist, welche (erbende)
Klasse die Implementierung liefert. Dieses Muster, auf das wi r in Abschnitt 12.1 im Rahmen
des dynamischen Bindens noch einmal zurückkommen werden, lässt sich auch einsetzen,
um das oben beschriebene Dilemma von Quadrat und Rechteck aufzulösen:
Klasse Rechteck
benannte Instanzvariablen
Instanzmethoden
Die Definitionen von Quadrat und Rechteck fallen dann knapp aus und kommen ohne
inhaltliche Veränderungen daher (lediglich die noch nicht implementierten Methoden müs-
sen nachgeliefert werden):
Klasse Quadrat
außen vor. offene Rekursion
beerbte Klasse Rechteck
benannte Instanzvariablen laenge
Instanzmethoden
Klasse NichtQuadratischesRechteck
beerbte Klasse Rechteck
benannte Instanzvariablen laenge breite
Instanzmethoden
Es sollte klar sein, dass alle Methoden nur für Quadrate und Rechtecke definiert sind.
Man beachte, dass dieses Beispiel auch die Kriterien von Generalisierung und Spezialisierung
erfüllt: Die Menge der Quadrate und die der nicht quadratischen Rechtecke is t in der Menge
der Rechtecke enthalten und die Definition der beiden stellt jeweils eine Erweiterung letz-
terer dar. Ein Überschreiben oder sogar Löschen wird nicht nötig (sieht man mal vom Über-
schreiben der „nicht implementierten“ Methoden ab).
"
"26.3 Kovarianz und Kontravarianz bei Methodenaufrufen
Dass Typerweiterung als Basis des Subtyping kei ne technischen Probleme bereitet, sollte
hinreichend klargeworden sein: Typfehler sind damit ausgeschossen und es bleibt lediglich
das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps
sind (wie im Beispiel von zwei - und dr eidimensionalen Punkten). Es bleibt noch die Frage,
ob und falls ja in welchem Umfang Typeinschränkung im Rahmen des Subtyping erlaubt ist.
Diese Frage soll an einem Beispiel beantwortet werden.
Angenommen, es ist ein Typ A wie folgt definiert:
Typ A
Protokoll Subtypen - als Teil -
Zuweisungen der Art
wobei a eine Variable vom Typ A sei (für ein Objekt vom Typ A steht), sind nach den Regeln
des Subtyping dann zulässig, wenn die Variable x mit einem Supertyp und z mit einem
Subtyp von Y (jeweils einschließlich des Typs Y selbst) deklariert ist.
Nun sei weiterhin der Typ B wie folgt als Subtyp von A abgeleitet:
Typ B
Supertyp A
Protokoll
Die Methode m: wird also in B redefiniert . Die Frage ist nun, in welchem Verhältnis die dabei
verwendeten Typen X und Z zu Y stehen müssen, damit die Zuweisung aus Zeile 915 wei-
terhin zulässig ist, selbst wenn die Variable a auf ein Objekt vom Typ B verweist. Mit anderen
Worten: Welche Bedingungen sind an die Parametertypen bei der Redefinition zu stellen,
damit eine Zuweisung eines Objekts vom Typ B an eine Variable vom Typ A in der Folge zu
keiner Verletzung einer (anderen) Typinvariante führt? Solche Folgefehler waren ja bereits
in Kapitel 25 thematisiert worden.
Die Antwort lässt sich systematisch herleiten, indem man sich die zu Zeile
z dem formalen Parameter von m:, y, zugewiesen. Wenn y nun in B einen anderen Typ als
Y bekommen soll, dann darf es sich dabei nur um einen handeln, der mehr Werte zu lässt
— würde er weniger Werte zulas sen, könnte es sein, dass er die Zuweisung von z aus-
schließt, wodurch Zeile 915 zu einem Typfehler (einem typinkorrekten Programm) führen
würde. Der Typ des fo rmalen Parameters y von m: in B, Z, muss also ein Supertyp dessen
in A, Y, sein. Zuletzt, d. h., nach erfolgter Auswertung des Methodenaufrufs, wird dann das
Ergebnis x zugewiesen. Wenn nun der Rückgabewert von m: in B, X, einen anderen Typ als
in A, Y, bekommen soll, dann kann dies aufgrund der geforderten Zuweisungskompatibilität
nur um einen Typen handeln, der weniger Werte zu lässt, da ja sonst die Zuweisung an x zu
einem Typfehler führen könnte. Es kommt also als Rückgabetyp für m: in B nur ein Subtyp
von dem in A, Y, infrage. Es ergibt sich also, dass sich bei einer Redefinition einer Methode
die Eingabeparametertypen einer Funktion nur „nach oben“ (also zu einem Supertypen hin),
die Ausgabeparameter hingegen nur „na ch unten“ (hin zu einem Subtyp ) verändern dürfen,
wenn die Typkorrektheit eines Programms nicht verletzt werden soll. analytische
Nun ändern sich aber bei der Redefinition nicht nur die Parametertypen
(Ein- und Aus - bzw. Rückgabe), sondern auch der Typ des Empfängers.
Dieser ändert sich bei der Redefinition aber immer nach unten (da der
redefinierende Typ ja als Subtyp vom redefinierten abgeleitet wird). Es
folgt also, dass die Eingabeparameter zum Empfängertyp gegenläufi g va-
riieren müssen, der Ausgabeparameter hingegen gleichgerichtet. Man
spricht im ersten Fall daher von einer Kontravarianz , im zweiten von einer Kovarianz , und
sagt:
Man spricht im Kontext von Subtyping auch von Typkonformität des Subtypen mit dem
Supertypen .
Nun enthält die Idee von der Gegenläufigkeit der Veränderung von Para-
meter - und Ergebnistypen beim Redefinieren einen kleinen Schönheits-
fehler: We nn es sich nämlich bei der Eingabe in eine Funktion und bei
ihrer Ausgabe um dasselbe Objekt handelt, kann diesem nicht einmal (bei der Eingabe) ein
Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden, denn der Subtyp
verlangt ja mehr Eigensc haften, als der Supertyp garantiert. Wenn also z. B. ein Typ A wie
Typ A
Protokoll
definiert ist und x das Objekt zurückgeben soll, das mit x: geliefert wurde, dann kann ein
Subtyp B die beiden Methoden schlecht so redefinieren, dass x: Objekte eines Supertypen
von X entgegennimmt, während gleichzeitig x Objekte eines Subtyp s zurückliefert. Da das
Umgekehrte freilich auch nicht geht, bleibt nichts anderes, als die Unveränderlichkeit d er
Parametertypen, auch als Invarianz oder besser (da das dazu passende Adjektiv „invariant“
in seiner Bedeutung schon belegt ist) als Novarianz bezeichnet, zu verlangen.
Obige analytischen Überlegungen führen also, mit der eben gemachten
Einschränkung, zur Regel von den kontravarianten Parameter - und den
kovarianten Rückgabetypredefinitionen. Es gibt aber noch einen zweiten
Ansatz zur Klärung der Frage nach der richtigen Varianz der Parametertypen redef inierter
Funktionen, die diese Betrachtung deutlich in Frage stellen. Dazu soll (wie schon in Kapitel
25) die Interpretation von Methoden als Relationen bzw., da hier der Rückgabetyp mit be-Änderung im
Verhältnis zur
Änderung des
Empfängertyps:
Kovarianz und
Kontravarianz
Problem bei Identität
von Ein - und
Ausgabeparametern
Problem des
mangelnden
Realismus WWeennnn ddiiee EEiinnggaabbeeppaarraammeetteerr eeiinneerr rreeddeeffiinniieerrtteenn MMeetthhooddee kkoonnttrraavvaarriiaanntt uunndd ddiiee AAuussggaa--
bbeeppaarraammeetteerr kkoovvaarriiaanntt rreeddeeffiinniieerrtt wweerrddeenn,, ddaannnn bblleeiibbtt ZZuuwweeiissuunnggsskkoommppaattiibbiilliittäätt ddeess
rreeddeeffiinniieerreennddeenn TTyyppeenn mmiitt ddeemm rreeddeeffiinniieerrtteenn eerrhhaalltteenn..
rücksichtigt wird, als Funktionen oder Abbildungen herhalten. Der hier zweistellige Defini-
tionsbereich (Empfängertyp plus Parametertyp) der Funktion steht dabei stellvertretend für
beliebige Stellenzahl, also für Methoden mit bel iebig vielen Parametern. Der Wertebereich
ist hingegen immer einstellig, da eine Methode stets nur einen Wert zurückgibt.
Wertebereich
Definitionsbereich
Wenn man nun die Anzahl der Empfängerobjekte einschränkt (was ja beim Übergang zu
einem Subtypen geschieht), dann schrumpft damit ni cht nur der Wertebereich der Funktion
(wie in Kapitel 25 schon illustriert), sondern auch die Menge der möglichen Eingabewerte
(der zweite und alle weiteren Defin itionsbereiche), die mit der bereits eingeschränkten
Menge der Empfänger gemeinsam auftreten können. Es verhalten sich also nicht nur die
Ergebnis -, sondern auch die Parametertypen kovariant.
Dieses Ergebnis ist gewissermaßen frustrierend, da es die soeben hergeleitete Kontravari-
anzregel für Parametertypen infrage stellt: Was programmiertechnisch möglich und sinnvoll
erscheint, hat in der Realität (der Interpretation oder Semantik) keine Bedeutung. Auf der
anderen Seite erklärt es aber, warum kontravariante Parameterredefinitionen in der Pro-
grammierpraxis nicht benötigt werden.52 Kovarianz für Parametertypen zuzulassen, so sinn-
voll es auch zu sein scheint, erlaubt jedoch typinkorrekte Programme; Sie werden im Kontext
der Programmiersprache EIFFEL (Kurseinheit 5, Abschnitt 52.5) noch ausführlicher auf das
Problem und eine mögliche Lösung hingewiesen.
"
"4.3.4 Verbergen der Repräsentation des Zustands hinter Methoden
In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar (und
damit auch zugreifbar).23 Genauer sind seine Methoden die einzigen Stellen im ganzen
Programm, an denen auf die Instanzvariablen des Objekts , dem die Methoden zugeordnet
sind, direkt zugegriffen werden kann. Die Struktur des Objekts bleibt somit verborgen (das
Implementationsgeheimnis ) und sein Zustand wird gekapselt (s. Abschnitt 3.2 sowie unten
für ein praktisches Beispiel ).
Um die Belegung der Instanzvariablen und damit den Zustand eines Ob-
jektes auszulesen oder verändern zu können, sind also Methoden not-
wendig. Um beispielsweise den Wert einer Instanzvariable mit Namen a auszulesen, muss
das Objekt eine Methode vorsehen, die den Wert von a zurückgibt. Diese (parameterlose)
Methode wird in SMALLTALK üblicherweise wie folgt notiert:
Sie entspricht im wesentlichem einem auch in JAVA gebräuchlichen sog. Getter einer an-
sonsten nicht zugreifbaren Variable. Die Namensgleichheit von Methode und Variable soll
dabei nicht darüber hinwegtäuschen, dass es sich bei beiden um verschiedene Dinge han-
delt — Methode und Variable könnten genauso gut verschieden benannt werden.
Um den Wert von a zu setzen, definiert man üblicherweise die folgende, auch Setter ge-
nannte Methode:
Getter und Setter werden zusammen auch als Zugriffsmethoden (oder Accessoren ; engl.
accessor methods ) bezeichnet.
Die obigen Zugriffsmethoden werden aufgerufen, indem man dem Objekt, zu dem die In-
stanzvariable a gehört, die Nachricht a (zum Lesen) bzw. a: mit einem Objekt als Parameter
(zum Schreiben) schickt. Das Empfängerobjekt antwortet darauf im ersten Fall mit Rü ckgabe
von a und im zweiten Fall mit Rückgabe von sich selbst. Man beachte, dass bei der Rückgabe
keine Kopie, sondern der Inhalt der Variable (bzw. ein Verweis darauf) zurückgegeben wird.
Nach Auswertung des Ausdrucks
ansehen. Auf der anderen Seite schützt die mangelnde Sichtbarkeit von Instanzvariablen ja nicht vor
dem Zugriff auf Objekte, auf die sie verweisen (wegen des möglichen Aliasing ), so dass man sich an
dieser Stelle nicht versteigen sollte. Zugriffsmethoden,
verweisen also b und die Instanzvariable a von einObjekt (genauer: dem von einObjekt
bezeichneten Objekt) auf dasselbe Objekt, genauso wie nach Auswertung von
Bei beiden ist hinterher b ein Alias auf a, was de facto die Kapselung des Zustandes von
einObjekt durchbricht.
Es soll nochmals darauf hingewiesen werden, dass im ersten Ausdruck a eine Nachricht
darstellt und keinesfalls der Name der Instanzvariable des Objekts ist. Insbesondere handelt
es sich bei dem (Teil -)Ausdruck einObjekt a mitnichten um das Äqui valent zu dem aus
JAVA bekannten einObjekt.a , sondern vielmehr dem von einObjekt.getA() (wobei
man die Methode getA() in JAVA per Konvention natürlich genauso gut nur a() nennen
könnte). Ein direkter Zugriff auf die Instanzvariable von außen wie in JAVA ist in SMALLTALK
nicht möglich. Man kann also den Zugriff auf eine Instanzvariable verhindern, indem man
einfach keine Zugriffsmethoden dafür vorsieht; man kann ihn auf Nur-Lesen oder Nur-
Schreiben beschränken, indem man nur die jeweilige Zugriffsmethode zur Verfügung stellt.
Man beachte schließlich, dass anders al s benannte Instanzvariablen indi-
zierte Instanzvariablen auch von dem Objekt, zu dem sie gehören, nicht
direkt, sondern nur über die beiden vordefinierten Nachrichten at: und
at:put: gelesen und geschrieben werden können:
liefert den Wert de r Instanzvariable mit dem Index i,
setzt ihn. Es ist in SMALLTALK also nicht möglich, indizierte Instanzvariablen eines Objekts (im
Gegensatz zu benannten) durch Nicht -Deklaration von Zugriffsmethoden zu verbergen (vor
Zugriff zu schützen). Zugleich folgt aus der festen Vorgabe der beiden Zugriffsmethoden,
dass jedes Ob jekt nur genau eine (unbenannte) Menge von indizierten Instanzvariablen ha-
ben kann.
Die ausschließliche Abfrage und Änderung des Zustandes von Objekten
über Methoden hat den Vorteil, dass man sich n icht festlegt, wie man
den Zustand eines Objekts tatsächlich codiert. So kann man beispiels-
weise einem Punktobjekt Methoden zum Setzen und Abfragen sowohl
von kartesischen als auch von polaren Koordinaten zuordnen, muss aber nur Instanzvariab-
len für eine A rt von Koordinaten vorsehen und kann die anderen jeweils berechnen:
Man könnte die Koordinaten natürlich genauso gut in polarer Form spei-
chern und die kartesischen berechnen — für die Benutzerin dieser Ob-
jekte spielt das keine Rolle. Man betrachtet die Art und Weise, wie ein
Objekt seinen Zustand codiert, als sein Implementationsgeheimnis und die Menge der Me-
thodensignaturen, die den Zugriff auf das Objekt (seinen Zustand) erlauben (das Protokoll ),
als sein Interface . Mehr dazu in Abschnitt 4.3.8 .
"
"47.4 Metaprogrammierung
Obwohl in JAVA längst nicht alles ein Objekt ist, gibt es doch die Möglichkeit, auf die Ele-
mente eines Programms zuzugreifen. Dafür ist das sog. Reflection API zuständig, in dem für
jede Art von Programmelement eine Klasse existiert, deren Instanzen entsprechende Pro-
grammelemente repräsentieren. (So gibt es dort eine Klasse Method , eine Klasse Field
etc.) Eine genauere Betrachtung dieser API würde an dieser Stelle jedoch zu weit führen; sie
wird im Kurs 01853 („Moderne Programmiertechniken und -methoden“) ausführlicher be-
handelt.
Eine andere Form der Metaprogrammierun g, die sog. Annotationen ,
haben zunächst nichts mit Objektorientierung zu tun — es werden damit lediglich Program-
melementen im Quelltext Daten, sog. Metadaten, zugeordnet. Diese können dann während
der Übersetzung und/oder während der Ausführung des Programms abgefragt werden und
so den jeweiligen Prozess beeinflussen oder sogar steuern. In JAVA 5 wurden Annotationen
als eine spezielle Art von Interfaces eingeführt, die jedoch keine Met hoden, sondern nur
Felder (!) deklarieren. Annotation sind ebenfalls Gegenstand des Kurses 01853.
"
"50.5 Ausblick
C# ist nicht nur Nachahmer JAVAs, sondern war auch Pionier für Sprach-
erweiterungen, die es inzwischen auch in JAVA gibt: So gab es in C# von Anfang an sog.
Attributes, die in JAVA in der Version 5 als Annotationen (was in jedem Fall der bessere Name
ist) Einzug gehalten haben. C# hatte auch schon ab der Version 3.0 Lambda -Ausdrücke (ein
Element funktionaler Programmiersprachen , in SMALLTALK — in Form von Blöcken — schon
immer vorhanden und ein Grundelement der Sprache); JAVA ist erst mit Version 8 nachge-
zogen . Die Gefahr ist jedoch, dass sich die beiden Sprachen gegenseitig totrüsten — irgend-
wann wird jemand auf die Idee kommen, aus den besten Eigenschaften beider eine neue
Sprache zu destillieren (KOTLIN mag hier ein erstes Beispiel sein) . Vielleicht wird bei der Ge-
legenheit ja auch endlich mit dem C -Erbe aufgeräumt und die fürchterliche Syntax entsorgt.
"
"Kurseinheit 4: JAVA
Da die meisten unter Ihnen vermutlich nie in die Verlegenheit kommen werden, beruflich in
SMALLTALK zu programmieren, wenden wir uns in dieser und der nächsten Kurseinheit an-
deren objektorientierten Programmiersprachen zu. Am meisten Raum nimmt dabei JAVA
ein, zum ein en, weil es immer noch die am weitesten verbreitete objektorientierte Program-
miersprache ist, zum anderen, weil es in der Darstellung viele Parallelen zu SMALLTALK zu
ziehen erlaubt und damit eine gute Brücke zu weiteren Programmiersprachen schlägt. Unter
theoretischen (und damit auch akademischen) Gesichtspunkten nimmt JAVA allerdings keine
besondere Stellung ein und für seinen Erfolg war vermutlich eher das Internet (JAVA spielte
vormals die Rolle, die heute JAVASCRIPT spielt) als ein besonders genialer Sprachentwurf ver-
antwortlich.
Aus der Distanz betrachtet ist JAVA eine Mischung aus SMALLTALK und
C++. Von C++ wurden weite Teile der Syntax und der statischen Typprü-
fung übernommen sowie der eher klassisch prozedurale Charakter (Methodenaufrufe an-
stelle von Nachrichtenversand), von SMALLTALK die weitgehende Objektorientierung (es gibt
keinen Code außerhalb von Klassen), die Einfachvererbung sowie die Garbage collection
(um nur die wichtigsten zu nennen). Wenn man allerdings genauer wissen will, was JAVA ist
und warum es so ist, wie es ist, dann muss man einen Blick in seine Geschichte werfen.
Interessierten empfehle ich unbedingt, „The Long Strange Trip to Java “ von PATRICK NAUG-
HTON zu lesen; danach wird Ihnen vermutlich so einiges klar.
"
"51.6 Der ganze Rest
C++ ist eine sehr komplexe Sprache. Sie zu lernen dauert Jahre, selbst bei täglichem Um-
gang mit ihr; sie zu lehren erscheint fast aussichtslos. Selbst wenn man die zahlreichen Kon-
strukte der Sprache der Reihe nach durchginge, so ergibt sich die eigentliche Komplexität
erst aus deren kombinierter Verwendung, und die Zahl der Möglichkeiten ist den Gesetzen
der Kombinatorik folgend hoch. Entsprechend groß ist a uch die Zahl der Idiome (Wendun-
gen), die es für C++ gibt . Auch wenn längst nicht alle Beiträge zur Komplexität von C++ in
Zusammenhang mit der Objektorientierung stehen, so ist es doch schwierig, sie davon zu
trennen. Deshalb soll es an dieser Stelle auch genug damit sein.
"
"10.1 Vererbung
Unter Vererbung versteht man in der objektorientierten Programmierung die Übertragung
der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere.
Vererbung dient vor allem der Wiederverwendung von Code und damit der Ökonomie in
der Softwa reentwicklung.
Wenn man das Prinzip von Generalisierung und Spezialisierung vor Au-
gen hat, dann ist die Vererbung eigentlich nur noch ein Mechanismus,
der Definitionen von einer Klasse auf eine andere übert rägt. So wird jede
benannte Instanzvariable, die in einer Generalisierung deklariert ist, nicht nur für Instanzen
dieser Generalisierung (so sie denn welche hat) angelegt, sondern auch für die Instanzen all
ihrer Spezialisierungen. Analog stehen Methoden, die in einer Generalisierung definiert wer-
den, auch ihren Spezialisierungen zur Verfügung, und zwar beinahe so, als wären sie in den
Spezialisierungen definiert.
Spezialisierung und Vererbung scheinen also Hand in Hand zu gehen. Doch ist dies nur
solange d er Fall, wie man von der Spezialisierung ausgeht und die Vererbung als ökonomi-
sches Abfallprodukt erhält. In der Praxis lässt man sich doch leider häufig von vordergrün-
digen Gewinnerwartungen leiten und folgt der (vermeintlichen) Ökonomie der Vererbung,
ohne dabei auf die Prinzipien von Generalisierung und Spezialisierung einzugehen. Obiges
Beispiel von Pinguinen und Vögeln hatte schon gezeigt, zu welchen Komplikationen eine
unbedachte Spezialisierung führen kann; nachfolgendes soll zeigen, zu was eine Fixi erung
auf Ausnutzung der Vererbung führt.
Ein Klasse Quadrat sei etwa wie folgt definiert:
Klasse Quadrat
benannte Instanzvariablen laenge
Instanzmethoden
Nun möchte man eine zweite Klasse Rechteck definieren und dabei aus-
nutzen, dass man so eine ähnliche Klasse, nämlich Quadrat , schon hat.
Aus Quadrat übernehmen lässt sich nämlich die Instanzvariable laenge .
(Das Beispiel wurde absichtlich einfach gewählt, auch wenn es dadurch wenig überzeugend
wirkt; das Pr oblem sollte aber trotzdem klar werden.)
Klasse Rechteck
beerbte Klasse Quadrat
benannte Instanzvariablen breite
Instanzmethoden
Was die Instanzvariablen angeht, so braucht Rechteck die Instanzvari-
able laenge nicht neu zu definieren, sondern muss lediglich breite hin-
zufügen. Allerdings können die Methoden zur Berechnungen von F läche und Umfang nicht
mitgeerbt werden, obwohl Quadrate und Rechtecke die Eigenschaft, über solche Merkmale
zu verfügen, teilen. Die entsprechenden Methoden müssen also in Rechteck neu definiert
werden. Man nennt das Überschreiben , weil die neuen Methoden mit den alten genau
dies tun. Die Möglichkeit des Überschreibens ist häufig Voraussetzung dafür, dass man Ver-
erbung überhaupt sinnvoll einsetzen kann.
Wenn man nun glaubt, man hätte gleichzeitig mit der Vererbung auch
eine Spezialisierungs - bzw. Generalisierungsbeziehung geschaffen, weit
gefehlt: Die Menge der Quadrate enthält die Menge der Rechtecke nicht,
was ja eine charakteristische Begleiterscheinung der Ge neralisierung gewesen wäre. Dass
die Intension von Rechteck umfangreicher ist als die von Quadrat (sie enthält eine Instanzva-
riable mehr), ist eine Täuschung: Ein Quadrat hat, genau wie ein Rechteck, vier Seiten, nur
ist die Bedingung für diese vier Seiten in Quadraten die, dass sie alle gleich lang sind, so
dass man sich drei Instanzvariablen sparen kann; für Rechtecke sind nur jeweils zwei Seiten
gleich lang, so dass man sich nur zwei Instanzvariablen spart. Die Intension für Quadrate ist
aber trotzdem re striktiver als die für Rechtecke (sie enthält eine zusätzliche Bedingung), so
dass der inverse Zusammenhang von Intension und Extension auch für Quadrate und Recht-
ecke gilt : je größer die Intension, desto kleiner die Extension (und umgekehrt) .
Das Problem mit der Vererbung ist nun, dass sie auf die oberflächliche
Wiederverwendung von Elementen einer Klassendefinition ausgerichtet Vererbung zur
Ausnutzung von
Ähnlichkeiten
Überschreiben von
Geerbtem
Vererbung ohne
Generalisierung/
Spezialisierung
Oberflächlic hkeit der
ist. Sie lässt dabei insbesondere den Zusammenhang der Extensionen der beteiligten Klas-
sen, der f ür Generalisierung/Spezialisierung wesentlich ist, außer acht. Diese Ignoranz hat
aber weitreichende Konsequenzen, die wir in Kapitel 26 von Kurseinheit 3 noch kennenler-
nen werden.
Man hätte nun auch umgekehrt verfahren und dabei das Prinzip von Ge-
neralisierung und Spezialisierung hochhalten können, indem man
Quadrat von Rechteck erben lässt (wenn man akzeptiert, dass die Generalisierung
Rechteck eigene Instanzen hat). Der Nachteil d ieses Entwurfs wäre jedoch, dass dann auch
Quadrat zwei Instanzvariablen für Seitenlängen hätte, obwohl ja eine ausgereicht hätte.
Auf der anderen Seite hätte man die Methoden für Fläche und Umfang nicht überschreiben
müssen, denn wenn laenge und breite gleich sind, unterscheiden sich die beiden obigen
Implementierungen von flaeche und umfang im Ergebnis nicht. Man muss nur sicherstel-
len, dass in Instanzen von Quadrat laenge und breite tatsächlich immer gleiche Werte
haben.
Nun kann ma n aber auch auf die Idee kommen, die zu viel geerbte In-
stanzvariable breite einfach wieder zu löschen. Tatsächlich ist dies vom
Standpunkt der Vererbung aus kein Problem: Genauso, wie man Teile der Definition über-
schreiben kann, kann man sie auch löschen. Im konkreten Fall der Klasse Quadrat , die von
Rechteck erbt, müsste man mit dem Löschen von breite aber auch die Methoden
flaeche und umfang überschreiben. (Das Löschen von Methoden wäre auch möglich,
wird hier aber nicht gebraucht.)
Was bleibt, ist ein Eindruck von Beliebigkeit bei der Vererbungsrichtung,
die für Generalisierung/Spezialisierung nicht existiert. In gewisser Weise
spiegeln Generalisierung/Spezialisierung und Vererbung auch zwei verschiedene Weltsich-
ten wider: Generalisi erung/Spezialisierung steht für die Ordnung eines Systems von Klassen
mit Blick von außen und für das Ganze (die sog. Client -Schnittstelle ), Vererbung für die
Pragma tik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwen-
dung (die Vererbungsschnittstelle ). Vererbung stellt eine Art genetischen Zusammenh ang
zwischen Klassen dar, der deren Entstehung aus Vorhandenem widerspiegelt, Generalisie-
rung/Spe zialisierung eher eine abstrakte Ordnung. Vererbung bringt Komplexität in ein Sys-
tem, Generalisierung/Spezialisierung versucht, sie durch Strukturierung zu reduzieren. Wie
Sie gesehen haben, führen beide Sichten nicht automatisch zum selben Ergebnis; sie zu
vereinen ist die hohe Kunst des objektorientierten Entwurfs.
"
"12.1 Nachrichten an self
In SMALLTALK muss das Empfängerobjekt eines Nachrichtenversands immer explizit gemacht
werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. So kann
also insbesondere self nicht (wie beispielsweise this in JAVA) weggelassen werden, wenn
ein Objek t eine Nachricht an sich selbst schicken möchte. Wie bereits in Abschnitt 4.3.1
erwähnt, bezeichnet die Pseudovariable self immer den Empfänger der Nachricht, also
dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt,
gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind. (Die einzige Aus-
nahme hiervon bilden Blöcke, in denen self sich auf den Empfänger des Home context
bezieht; s. Abschnitt 4.4.1 in Kurseinheit 1).
Dabei ist allerdings zu beachten, dass die Klasse des durch self bezeich-
neten Objekts nicht unbedingt dieselbe sein muss , in der die gerade aus-
geführte Methode (in der auch das self steht) definiert ist, denn das kann ja, aufgrund
von Vererbung, durchaus eine Superklasse sein. Das hat eine fundamentale Auswirkung:
Die zu einer an self geschickten Nachricht passende Metho de ist nicht automatisch die,
die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefun-
den werden, nämlich dann, wenn die aufrufende Methode selbst erst im Rahmen der Suche
in der Kette der Superklassen gefunden wurde. Ko nkret bedeutet diese (bereits in Abschnitt
10.3 im Kontext abstrakter Klassen beschriebene) sog. offene Rekursion , dass das Ergebnis
des Ausdrucks
zuerst für SMALLTALK entwickelt worden — in SMALLTALK ist Testen die einzige Möglichkeit, Fehler in
einem Programm vor seiner Auslieferung zu finden. offene Rekursion
bei vorliegenden Klassendefinitionen
Klasse Super
Instanzmethoden
sowie
Klasse Sub
Superklasse Super
Instanzmethoden
davon abhängt, von welcher Klasse das Empfängerobjekt fremder eine Instanz ist. So lie-
fert
„ich bin super“,
hingegen „ich bin leider nur sub“. Man beachte, dass Vererbung tatsächlich eine Kopieren -
und-einfügen -Semantik hat, wie in Abschnitt 11.2 bereits nahegelegt: Wenn man die Im-
plementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das-
selbe Ergebnis erzielt.
Während offene Rekursion im gegebenen Beispiel durchaus erwünscht
ist und ihr Effekt wohl auch den Erwartungen der Programmiererin ent-
spricht, ergeben sich doch immer wieder Konstellationen, in denen man unangenehm über-
rascht wird. Das Problem ist unter dem Namen Fragile -base-class-Problem bekann tgewor-
den; es wird in Kapitel 55 (Kurseinheit 6) ausführlicher behandelt. Fragile -base -class -
"
"2.2 Unterscheidung von :1 - und : n-Beziehungen
In der Daten - und Softwaremodellierung werden Beziehungen (oder Relationen) häufig mit
sog. Kardinalitäten versehen. (Manchmal, besonders im Kontext der Softwaremodellierung
mit der Unified Modeling Language UML werden diese auch Multiplizitäten genannt.) Sie
geben an, mit wie vielen anderen Objekten ein Objekt gleichzeitig in derselben Beziehung
stehen kann. Beispielsweise kann eine Person zu mehreren anderen Personen in einer Ver-
wandtschaftsbeziehung stehen. Häufig sind die möglichen Kard inalitäten auf ein Intervall
beschränkt; sie werden dann durch eben dieses Intervall beschrieben.
Von den theoretisch unendlich vielen möglichen Intervallen, die die Kardinalität beschrän-
ken können, sind vor allem drei interessant: [0..1] , [1..1] und [0..). Dabei ist [1..1], also
dass ein Objekt immer mit genau einem in Beziehung stehen muss, technisch nur schwer
umzusetzen, so dass [1..1] hier nicht weiter betrachtet wird11; die untere Schranke 0, die
den beiden verbleibenden Intervallen gemeinsam ist und die ausdrückt, dass ein Objekt auch
mit gar keinem anderen in der Beziehung stehen kann, muss da her nicht erwähnt werden .
Im Fall von [0..1] sprechen wir also von Zu-eins-Beziehungen (im folgenden mit :1-Bezie-
hung notiert), im Fall von [0..) von Zu-n-Beziehungen (:n-Beziehungen ), wobei n hier
andeuten soll, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.12
Objekt nil (null in anderen Sprachen) ausgedrückt. Nach und nach kommen in verschiedenen
objektorientierten Programmiersprachen die sog. Not -null-Annotationen auf, die sicherstellen sollen,
dass eine Variable nie den Wert null hat.
nalitäten auch für die Gegenrichtung angeben. Da wir es in der objektorientierten Programmierung Begrenzung der
Die Beziehung eines Objekts zu einem anderen wird auf natürliche Weise
durch eine benannte Instanzvariable ausgedrückt, wobei die Instanzvariable den Namen der
Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten
Objektes i n der Beziehung trägt. So zeigt die Instanzvariable arbeitgeber beispielsweise
auf das Objekt, das in der Beziehung Anstellung aus Sicht des Arbeitnehmerobjekts die Rolle
des Arbeitgebers spielt. Hat auch das Arbeitgeberobjekt einen Verweis auf das Arbe itneh-
merobjekt (die Rückrichtung), so wird die entsprechende Variable sinnvollerweise nach der
Gegenrolle arbeitnehmer genannt. Steht ein Arbeitnehmerobjekt zur Zeit in keinem An-
stellungsverhältnis, ist seine Instanzvariable arbeitgeber leer, was in SMALLTALK durch den
Verweis auf das Objekt nil ausgedrückt wird.13
Beziehungen sind nicht von Natur aus auf ein Gegenüber eingeschränkt:
Ein Objekt kann, und wird häuf ig, in derselben Beziehung zu mehreren andern stehen. Ge-
nau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von
einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine
eigene (jeweils and ers) benannte Instanzvariable vorsehen zu müssen. Die „Namen“ der
Gegenüber sind einfach Indizes: 1, 2, 3 usw.
Es ergibt sich nun aber das Problem, dass bei durch indizierte Instanzva-
riablen eines Objekts realisierten : n-Beziehungen nicht zwischen verschie-
denen solchen Beziehungen desselben Objekts unterschieden werden kann — die indizier-
ten Instanzvariablen sind ja nicht benannt. Deswegen werden : n-Beziehungen in der ob-
jektorientierten Programmierpraxis praktisch immer ü ber Zwischenobjekte realisiert, deren
Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren
anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die : n-Beziehung ggf.
mit weiteren Attributen (z. B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sor-
tierung o. ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte
untergebracht werden. Das Originalo bjekt, das die : n-Beziehung eigentlich haben sollte,
steht dann stattdessen in einer von einer benannten Instanzvariable hergestellten :1 -Bezie-
hung zu dem Zwischenobjekt, das die : n-Beziehung herstellt.
aber nicht mit (ungerichteten, d. h. bidirektionalen) Relationen, sondern mit Verweisen (Zeigern) zu
tun haben, entfällt die Rückrichtung.
sie heute selbst als einen (seinen) „ billion dollar mistake “ bezeichnet. :1-Beziehungen
Objekt 1 Objekt 2:1-Beziehung
Objekt 1 ZwischenobjektObjekt 2.1
Objekt 2. n…:n-Beziehungbenannte Instanzvariable
benannte Instanzvariableindizierte Instanzvariable
Wie wir noch sehen we rden, erlaubt der Umstand, dass :n-Beziehungen
über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, die
Beziehung en beliebig auszugestalten. So kann beispielsweise eine (Sortier -)Reihenfolge vor-
gegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referen-
ziert werden (z. B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren
wie z. B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines
Schlüssels können auf diese Weise realisi ert werden. Da in SMALLTALK Objekte auch eigene
Kontrollstrukturen (wie z. B. spezielle Schleifen) anbieten können, sind der Ausgestaltung
von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt.
Da :n-Beziehungen häufig vorkommen, ist ihre Handhab ung von ent-
scheidender Bedeutung für die Ausdrucksstärke der verwendeten Pro-
grammiersprache und die Produktivität der Programmierung insgesamt.
Wie sich schon in Abschnitt 4.6.4 zeigen wird, erlaubt die Ausgestaltung
von Zwischenobjekten in SMALLTALK Möglichkeiten , die bis heute Vorbild-
charakter für andere objektorientierte Programmiersprachen haben.
"
"43.2 Parametrische Typen und Subtyping: Wildcards
Nun ist es aber für generische Typen genau wie für Arrays durchaus sinnvoll, eine liberalere
Form von Zuweisungskompatibilität zuzulassen, z. B. um Objekte verschiedener Instanzen70
eines parametrisierten Ty ps bei einem Methodenaufruf demselben formalen Parameter zu-
zuweisen. So möchte man eben auch für generische Collections eine Methode sort mit
einem Parameter, der eine zu sortierende Liste o. ä. enthalten soll, definieren und diese
dann mit Objekten versch iedener Instanzen von ArrayList<E> (wie in Zeile 1052 ff. defi-
niert) aufrufen können, also z. B. mit Objekten vom ArrayList<Integer> und
ArrayList<String> . Intuitiv möchte man dazu zunächst
schreiben, aber wie wir schon gesehen haben, sind , obwohl Integer und String Subty-
pen von Comparable sind, ArrayList<Integer> und ArrayList<String> nicht zu-
weisungskompatibel mit ArrayList<Comparable> .
Was also tun? In JAVA hat man dafür das Konzept der Typ -Wildcards (zu
deutsch vielleicht Typ -Joker oder -Platzhalter) eingeführt, die bei der In-
stanziierung eines generischen Typs den Platz des tatsächl ichen Typparameters einnehmen
können und dort zunächst für einen beliebigen Typ stehen. Das Symbol für das Typ -
Wildcard ist das Fragezeichen: List<?> ist also ein Typ, mit dem Variablen (inkl. forma le
Parameter) deklariert werden können. Per Definition ist dieser Typ, List<?> , Supertyp aller
Instanziierungen von List<T> — List<Integer> beispielsweise und List<String>
sind mit List<?> zuweisungskompatibel. Man beachte, dass bei einer Deklaration und an-
schließenden Zuweisung
das Fragezeichen nicht durch Integer ersetzt wird; die anschließende Zuweisung
ist also möglich.71
einer (anderen) Deklaration hergestellt wird. Man nennt dies daher auch Use-site variance , im Ge-
gensatz zur Declaration -site variance , wie man sie beispielsweise in C# vorfindet (s. Abschnitt 50.4.3
in Kurseinheit 5). Wildcards ersetzen
List<?> ist gena u ein Typ; das Fragezeichen selbst ist jedoch keiner (und
ist auch keine Typvariable). Mit Typ -Wildcards parametrisierte Typen wie List<?> und auch
ArrayList<?> , im folgenden Wildcard -Typen genannt, sind abstrakt in dem Sinne, dass
es keine direkten Instanzen von ihnen gibt:
ist also illegal.
Nun kann man mittels Typ -Wildcards natürlich nicht die oben geschilderten Probleme im
Zusammenhang mit dem Aliasing aushebel n. Es ist also insbesondere nicht möglich, nach
Deklaration und Zuweisung von Zeile 1067
zu schreiben, da ja nicht sichergestellt werden kann, dass Liste tatsächlich auf ein Objekt
vom Typ List<Integer> verweist. Tatsächlich ist die einzige gültige Zuweisung an Ele-
mente von liste die von null . Umgekehrt kann beim Lesen der Elemente aus liste kein
anderer Typ als Object angenommen werden, da ja liste Listen mit beliebigem Element-
typ zugewiesen werden dürfen. Das aber ist unbefriedigend.
Nun kennen Sie aus Abschnitt 29.4 bereits das Konzept der Beschränkung
von Typparametern. Dieses lässt sich auch auf Typ -Wildcards übertragen.
Wenn man also sicherstellen will, dass die Elemente einer Liste eines un-
bekannten Elementtyps mindestens vom Typ Number sind, schreibt man in der Deklaration
der entsprechenden Variable, hier wieder liste , einfach
Es sind damit nur noch Zuweisungen von Listenobjekten an liste gestattet, deren Ele-
menttyp den Typ Number oder einen Subtyp davon (z. B. Integer ) hat:
ist also legal,
hingegen nicht. Das erlaubt einer lesende Zugriffe der Form
wobei Number auch durch einen beliebigen Supertyp von Number ersetzt werden dürfte,
jedoch durch keinen Subtyp. Das Einfügen von Elementen in liste bleibt jedoch weiter
nicht gestattet, da nicht bekannt ist, welchen Typs die Elemen te mindestens sein müssen. Wildcard -Typen
Selbsttestaufgabe 43.1
Überprüfen Sie die letzte Aussage, indem Sie versuchen, ein Gegenbeispiel zu finden.
Per extends beschränkte Typ -Wildcards erlauben also eine spezielle Art
des Subtypings, nämlich eine, bei der Zuweisungen von Objekten eines
Subtyps ganz normal an Variablen eines Supertyps erlaubt sind, aber in der Folge schrei-
bende Zugriffe auf Variablen, die mit de m Typparameter als Typ deklariert sind, verboten
(lesende Zugriffe sind hingegen erlaubt). Die Situation unterscheidet sich von der bei den
Arrays ( Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Überset-
zungszeit durchgeführt wird. Es ist damit sichergestellt, dass es niemals zu einem Laufzeit-
fehler entsprechend der Array store exception kommt; ein entsprechender dynamischer Typ-
test kann damit entfallen. Wie allgemein üblich werden damit auch Verwendungen ausge-
schlossen, die eigentlich legal wären; so ist z. B.
nicht zulässig, obwohl hier eigentlich kein Problem vorliegt.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schrei-
benden Zugriff erlaubende Art des Subtyp ing möglich ist. Die Antwort ist
einfach: ja. Man muss dazu nur die Beschränkung des Typ -Wildcards um-
kehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da
Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compi ler, dass er Ele-
mente jedes beliebigen Subtyps der Schranke zuweisen darf. Für eine Deklaration
beispielsweise, bei der super Integer die untere Schranke für tatsächlich e Typparameter
bei einer Zuweisung angibt, ist
und in der Folge sogar
erlaubt, denn Listen mit Elementtyp Number (oder einem beliebigen anderen Supertyp von
Integer ) können, aufgrund des Subtypings der Elementtypen, problemlos Integer zuge-
wiesen werden. Der lesende Z ugriff auf Elemente von liste hat jedoch immer den Typ
Object zum Ergebnis, so dass
bei obiger Deklaration von liste nicht erlaubt ist: Der Elementtyp dürfte ja auch ein Su-
pertyp von Integer sein, so dass die Zuweisung zu i ungültig wäre. List<? super
Integer> ist also spezieller Supertyp von allen Instanzen von List<E> , deren tatsächlich er
Typparameter (also der für E eingesetzte Typ) ein Supertyp von Integer ist. Der Supertyp
ist speziell, weil zwar eine Zuweisungskompatib ilität gegeben ist, der Zugriff auf die Ele-
menttypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden be-
schränkt ist.
Selbsttestaufgabe 43.2
Überlegen Sie, ob es möglich u nd sinnvoll ist, für einen Typparameter ein Typ -Wildcard mit oberer
und unterer Schranke anzugeben.
Durch die mögliche Beschränkung von Typ -Wildcards entsteht für jeden
generischen Typ eine (potentiell unendlich große) Menge von Typen, so
dass man sich fragen kann, ob diese Ty pen in einer bestimmten Subtyp beziehung zueinan-
der stehen. Dies ist tatsächlich der Fall: Für mit extends nach oben beschränkte Wildcard -
Typen gilt, dass wenn die Schranken Subtypen sind, dann auch die Wildcard -Typen Subty-
pen sind. Wenn also Integer ein Subtyp von Number ist, dann ist auch List<? extends
Integer> ein Subtyp von List<? extends Number> . Umgekehrt gilt für mit super nach
unten beschränkte Typen, dass List<? super Integer> ein Supertyp von List<?
super Number> ist. Man sagt auch, das Subtyping mit extends beschränkter Wildcard -
Typen sei kovariant (da das Subtyping der Wildcard -Typen sich am Subtyping der Schran-
ken orientiert) und das mit super beschränkter Wildcard -Typen kontravariant (aus ent-
sprechendem Grund).
Selbsttestaufgabe 43.3
Überlegen Sie sich, ob ArrayList<? extends Integer> ein Subtyp von List<? extends
Number> ist.
Ein typisches Beispiel für die Verwendung von Wildcard -Typen ist das fol-
gende:
"
"14.4 Selbstdarstellung
Wir hatten bereits ausgenutzt, dass alle Objekte SMALLTALK s eine (mehr oder weniger aus-
sagekräftige) String -Repräsentation besitzen: Die Methode
gibt eine Darstellung des Objekts als String zurück. Dies ist für Ausgaben auf dem Transcript
interessant, aber auch für die Inspektion von Objekten und für das Debugging, bei denen
sich die Objekte unter Verwendung dieser Methode der Betrachterin präsentieren.
Die Methode inspect
startet auf dem Empfänger einen Inspektor und gibt den Empfänger zurück. Dies ist nütz-
lich, wenn man ein Zwischenergebnis eines Ausdrucks inspizieren möchte, ohne den Aus-
druck dazu in zwei aufteilen zu wollen — man fügt einfach inspect an der Stelle des
Ausdrucks, an der das zu inspizierende Objekt gewonnen wurde, ein.
Die Methode
erlaubt, ein Objekt so auf einen Ausgabestrom (s. u.) zu schreiben, dass es daraus rekon-
struiert werden kann. Dabei wird keine binäre, sondern eine textuelle Repräsentation ver-
wendet. So schreibt beispielsweise SQUEAK bei Auswertung von Time noon storeOn:
aStream die Zeichenfolge '12:00 pm' asTime auf den durch aStream bezeichneten
Ausgabestrom und (Interval from: 1 to: 5) die Zeichenfolge '(1 to: 5)' . Inspektion
"
"1.6 Zuweisung
Damit eine Variable ein Objekt bezeichnet, muss ihr dieses durch eine sog. Zuweisung , in
anderen Kontexten auch Wertzuweisung genannt, zugeordnet werden. Ursprünglich
wurde als Zuweisungsoperator das Symb ol „“ gewählt; wegen der mangelnden Verfüg-
barkeit auf Tastaturen wurde es jedoch in den meisten SMALLTALK -Implementierungen durch
das aus ALGOL und PASCAL bekannte := ( englisch als „ becomes “ gelesen) ersetzt.7 Die
Variable lieblingszahl bezeichnet also i n Folge der Zuweisung
ein Objekt „2“ (in der Zuweisung repräsentiert durch das Literal 2). Nach einer Zuweisung
= für die Zuweisung steht, darf als eine der Tragödien in der Geschichte der Programmiersprachen
angesehen werden. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Ver-
wechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind. lokale und globale
bezeichnen x und y das gleiche Objekt (genau welches ist hier nicht er-
sichtlich); ob sie auch dasselbe bezeichnen, hängt von der Semantik der
Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten
Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable x erst eine Zahl und
dann einen String zuzuweis en. Auch Array -Literale können jeder beliebigen Variable zuge-
wiesen werden.
Man beachte weiterhin, dass die Zuweisung (anders als der Test auf
Gleichheit = oder Identität ==) nicht kommutativ ist: x := y hat nur dann
dieselbe Bedeutung wie y := x , wenn x und y schon vor der jeweiligen Zuweisung den-
selben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen
wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite
einer Zuweisung .
Nach den drei Zuweisungen
bezeichnen x und y beide die „3“. Wäre die letzte Z uweisung hingegen y := x gewesen,
bezeichneten x und y beide „5“.
Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie
der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben
der expliziten Zuw eisung durch den Zuweisungsoperator kommt auch eine implizite (bei
Methodena ufrufen ) vor; diese wird jedoch erst in Abschnitt 4.3.2 behandelt.
Der oben geschilderte Unterschied zwischen Wert - und Verweissemantik
von Variablen hat für die Zuweisung erhebliche Konsequenzen: Bei einer
Zuweisung unter Wertsemantik muss , da die Variable das Objekt zum In-
halt hat (also in der Variable gespeichert ist) und ein Objekt nicht in zwei Variablen gespei-
chert sein kann, eine Kopie angefertigt werden. Das hat zur Folge, dass die beiden Variablen
x und y nach der Zuweisung aus Zeile 21 nicht dasselbe (also identische) Objekt bezeichnen
(was ja unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), so dass z. B.
Änderungen am in x gespeicherten Objekt das in y gespeicherte Objekt nicht betreffen. Bei
einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite ko-
piert und in der Variablen auf der linken gespeichert. Wenn die Variablen auf der linken und
der rechten Seite unterschiedliche Sem antiken haben, dann liegt entweder eine unzulässige
Zuweisung (s. Kapitel 18) vor oder es muss , je nach Art der Variable auf der linken Seite,
eine Kopie eines Objektes oder ein Verweis auf ein Objekt angefertigt werden (s. dazu auch
Abschnitt 52.5.2 in Kurseinheit 5). keine
Selbsttestaufgabe 1.3
Finden Sie (durch Experimentieren) heraus, welche Objekte Ihres SMALLTALK -Systems per Wertseman-
tik gespeichert werden. Nutzen Sie dabei aus, das SMALLTALK vor der Erzeugung eines Objekts mit
Ausnahme von Symbolen nicht prüft, ob das Objekt schon vorhanden ist.
Hinweis: Verwenden Sie den Identitätstest ( ==).
"
"4.3.6 Konstante Methoden
In SMALLTALK gibt es keine fre i bezeichenbaren Konstanten24, sondern nur Literale (s. Ab-
schnitt 1.2). Da verschiedene Vorkommen gleicher Literale aber (außer bei Symbolen) ver-
schiedene Objekte erzeugen, sind Literale nicht für alle Zwecke ausreichend. Es gibt dafür
einen Trick, mit dem man dasselbe Literal mehrfach verwenden kann, nämlich durch eine
sog. konstante Methode .
ist eine solche konstante Methode. An ihr ist nichts wei ter konstant, als dass sie immer
dasselbe Objekt zurückgibt. Der Trick besteht nämlich darin, dass das zum Literal 3.142
gehörende Zahlobjekt nur einmal, nämlich zur Übersetzungszeit der Methode, erzeugt wird
und die Ausführung der Methode immer auf dieses und damit dasselbe Objekt zurückgreift.
Nun gibt es leider zwei Probleme. Das erste ist of fensichtlich, dass bei
einer erneuten Übersetzung der Methode auch ein neues Objekt erzeugt
wird, das dann mit früher zurückgegebenen nicht mehr identisch ist (von den bereits be-
kannten Ausnahmen abgesehen) . Das ist immer dann ein Problem, wenn das früher zurück-
gegebene Objekt in Variablen gespeichert wurde und nun mit dem neuen auf Identität ver-
glichen werden soll.25 Das sollte man also tunlichst unterlassen.
Das zweite Problem ist noch etwas subtiler: Bei der konstanten Methode
eines Objekts o und nach Auswertung der Anweisungen
enthält b an erster Stelle ebenfalls eine 0! Die vermeintlich konstante Methode ist also alles
andere als konstant!! Interessanterweise ist das Ergebni s dieses Experiments genau konvers
ablen auffassen, denen nu r einmal (bei der Initialisierung) ein Wert zugewiesen wird. Die Definition
von Konstanten erfordert dann aber ein Schlüsselwort, um sie von anderen Variablen zu unterschei-
den.
Programm danach neu gestartet werden muss — das Programm läuft vielmehr weiter und alle Ob-
jekte mit ihren Variablenbelegungen bleiben erhalten. Probleme konstanter
zum ersten Problem: Die Identität der von der konstanten Methode zurückgegebenen Ob-
jekte bleibt erhalten, ihre Erscheinung ändert sich aber (beim ersten Problem blieb die Er-
scheinung gleich, aber die Identität änderte sic h).
Zumindest das zweite Problem lässt sich eindämmen, indem man auf Sprachebene durch
Literale erzeugte Objekte als unveränderlich annimmt und Änderungen der Art von Zeile
eigentliche Erkenntnis ist aber, dass die Referenzsemantik von Variablen und das damit ver-
bundene Aliasing von Objekten zu höchst subtilen Problemen führe n kann, derer man sich
immer gewahr sein sollte.
"
"62.2.2 Grammatikalisch -inhaltliche (semantische) Namenskonventionen
Überaus angemessen, wenn auch nicht immer in letzter Konsequenz ein-
zuhalten, ist, die verschiedenen Wortarten einer natürlichen Sprache für v erschiedene Arten
von Programmelementen zu verwenden. So legt beispielsweise der in Kurseinheit 1, Kapitel
für Klassennamen Substantive verwendet. Tatsächlich ist es eine vielzitierte objektorientierte
Technik, in der Analysephase eines Projekts alle Substantive der Spezifikation zu extrahieren,
um auf der Basis der so gewonnenen Liste die Menge der Klasse n eines Systems zu identi-
fizieren.
Methoden, die eine Aktion implementieren ( Befehle in EIFFEL, s. Kursein-
heit 5, Abschnitt 52.2), wird man aufgrund ihres prädikativen Charakters mit Verben be-
nennen, wobei es eine Stilfrage ist, ob ma n die Infinitiv - oder die Imperativform (im Engli-
schen übrigens kein Unterschied in der Erscheinungsform) bevorzugt. Persönlich fühle ich
mich hier an keine Regel gebunden außer an die, dass Ausdrücke durch meine Namenwahl
möglichst lesbar werden. So kling t
(Infinitivform) in meinen Ohren besser als
(Imperativform),
(Imperativform) klingt dagegen besser als
(Infinitivform). Man könnte natürlich der imperativen Form ein Reflexivpronomen hinzufü-
gen wie etwa in
aber das ist eher unüblich (obwohl nicht ohne Charme!). Verbergänzungen wie Präpositio-
nen verwendet man in SMALLTALK dauernd (schon um mehrere Parameter voneinander ab-
zusetzen); in Sprachen wie JAVA fügt man einem allgemeinen (und häufig überladenen)
Verb dann gelegentlich noch ein Substantiv als Objekt des Prädikats hinzu, wie in
Gerade dieses Beispiel ist jedoch nicht unumstritten, da „Element“ hier gewisserma ßen re-
dundant ist — wenn es mehrere Methoden namens „add“ gibt, kann man sie auch mittels
ihrer Parametertypen unterscheiden (also überladen ). So heißt die entsprechende Me thode
im JDK heute auch nur noch add(.) .
Keine Verben, sondern Adjektive (oder Kopula plus Prädikatsnomen) verwendet man hin-
gegen für Methoden, die eine Abfrage darstellen (Queries; s. Abschnitt 52.2), wie etwa
bzw.
oder
Für Instanzvariablen verwendet man unterschiedliche Wortarten, und
zwar abhängig davon, ob eine Instanzvariable ein Attribut oder eine Beziehung repräsen-
tiert. Wenn es sich um ein Attribut handelt, das eine mehrwertige Qualität ausdrückt (wie
Größe, Farbe etc.), dann wird man den Namen der Qualität verwenden und damit ein Sub-
stantiv ( ggf. in Kleinschreibung). Wenn es sich um ei n zweiwertiges (Boolesches) Attribut Instanzvariablen
handelt, dann nimmt man das entsprechende Adjektiv (wie etwa leer ), ein Gerundivum
(z. B. laufend ) oder ein Partizip (wie etwa geloest ). Für Instanzvariablen, die Beziehun-
gen ausdrücken, nimmt man gerne den Namen der Ge genrolle, also beispielsweise mutter
in einer Kind -Mutter -Beziehung. Bei : n-Beziehungen nehme ich persönlich gern den Plural,
also z. B. kinder (statt kind ) für die umgekehrte Richtung.
Interfaces sind zwar wie Klassen Typen, aber bezeichnen keine Allgemein-
begriffe, sondern eher Rollen , die die Objekte, die konkrete Ausprägun gen der Allgemein-
begriffe sind, spielen können. Rollen werden aber, genau wie Allgemeinbegriffe, häufig
durch Substantive bezeichnet: „ Mutter “ ist ein Beispiel hierfür. Andere Rollen, insbesondere
die, die mit Parametern von Methoden verbunden sind, werden häufig durch Adjektive be-
zeichnet: Druckbar beispielsweise könnte der Parametertyp einer Methode drucken sein,
den das zu druckende Objekt h aben muss . Tatsächlich enden viele der gebräuchlichen In-
terfacenamen im Englischen auf „able“ oder „ible“, so z. B. bei Serializable .
Eine ganz interessante Option ergibt sich übrigens für Programmiererin-
nen, deren Muttersprache nicht Englisch ist: Man hat hier die Möglich-
keit, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zu-
sätzliche Form der Differenzierung einzuset zen. Ich persönlich verwende dann gerne für
Begrifflichkeiten aus der Anwendungsdomäne (also dem Gegenstandsbereich, mit dem sich
das Programm befasst ) deutsche Bezeichner und für solche aus der technischen Umsetzung
(Hilfsklassen etc.) englische. Alternat iv kann man natürlich auch alle selbst beigesteuerten
Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frame-
works zusammengeklaubten zu unterscheiden.
"
"47.1 Object
Die Klasse Object gibt die Eigenschaften vor, die allen Objekten, einschließlich Array -Ob-
jekten, gemeinsam sind. Darunter sind keine Felder (Instanzvariablen), aber elf Methoden.
Es sind dies :
 Object clone() zum Erzeugen von Kopien (vergleichbar SMALLTALK s copy )
 boolean equals(Object) zum Test auf Gleichheit anstelle von Identität (ent-
sprechend SMALLTALK s =)
 String toString() , die eine String -Repräsentation des Objekts zurückgibt (ent-
sprechend SMALLTALK s printString )
 Class<? extends Object> getClass() mit dem offensichtlichen Zweck (ent-
sprechend SMALLTALK s class )
 int hashcode() für die Speicherung von Objekten in Hash -Tabellen (entspre-
chend SMALLTALK s hash )
 void finalize() , die vom Garbage coll ector aufgerufen wird, wenn das Objekt
aus dem Speicher entfernt wird (es können damit externe Ressourcen, die mit dem
Objekt verbunden sind, freigegeben werden, also z. B. Dateien geschlossen)
 void notify() und void notifyAll() zur Benachrichtigung von Th reads, die
am Monitor des Objekt warten
 void wait() in drei Versionen, um den ausführenden Thread zum Warten zu
bringen, entweder bis dem Objekt ein Notify gesendet wird oder ein anderes Ereig-
nis eintritt.
In JAVA ist jeder Typ Subtyp von dem von Object . Das gilt auch für Interfaces. Man beachte
aber, dass Interfaces ansonsten nicht von Klassen ableiten können.
"
"51 C++
C# als Vorreiter
With syntax so chaotic that even compilers have to guess at it, C++ code had
better be reusable, because no one will ever want to reverse -engineer it. The
programming language’s “ feature ” — being a superset of C — is a fundamental
bug. With numerous large projects being written in already obsolete dialects,
C++ is arguably an “instant legacy ” language.
Über C++ ist viel geschrieben worden , nicht alles davon positiv im Tenor. Dabei wird jedoch
häufig vergessen, dass eine der harten Nebenbedingungen des Entwurfs von C++, die voll-
ständige Rückwärtskompatibilität mit C, ein derart schweres Handicap darstellt, dass nahezu
jede Kritik an C++ als unfair gelten muss .77 Natürlich kann man in C++ komplett unlesbare
Programme schreiben, aber das gilt schon deswegen, weil man in C komplett unlesbare
Programme schreiben kann. Man kann aber auch C+ + mit einer neuen Syntax versehen
(mittels seines Präprozessors, der übrigens Turing -äquivalent ist, also die Ausdrucksstärke
einer vollwertigen Programmiersprache besitzt) und dann darin komplett lesbare Pro-
gramme schreiben. Wenn man denn will.
"
"10.2 Vererbung in prototypenbasierten Sprachen
In der klassenbasierten Form der objektorientierte n Programmierung ist die Vererbung an
Klassen gebunden: Selbst wenn sich die Definitionen eigentlich auf die Instanzen der Klas-
sen beziehen, so ist es doch die Klasse, die Teile ihrer Definition (Intension) von anderen
erbt. Im Gegensatz dazu ist die Verer bung in prototypenbasierten objektorientierten Pro-Umkehrung der
grammiersprachen, in denen es ja keine Klassen gibt, vollständig zwischen Objekten defi-
niert: Jedes Objekt gibt eines oder mehrere andere an, deren Eigenschaften und Verhalten
es übernimmt. Dabei kann es ge erbte Teile der Definition überschreiben und auch löschen.
Auf den ersten Blick scheint es so, als sei dies sogar der natürlichere Weg
der Vererbung: Schließlich findet in der Natur Vererbung ja auch aus-
schlie ßlich zwischen Individuen statt, ja genaugenommen gibt es so et-
was wie biologische Klassen (Arten etc.) in der Natur überhaupt nicht36, denn es differen-
zieren sich ständig einzelne „Arten“ zu neuen und es ist nicht ausgeschlossen, dass einmal
ausdifferenzie rte Arten irgendwann wieder verschmelzen. Abgesehen davon ist , wie bereits
in Kapitel 7 erwähnt, die reale Existenz von Allgemeinbegriffen strittig (der Universalien-
streit ).
Man kann dem freilich entgegenhalten, dass man als Programmiererin ja
auch keine einzelnen Objekte, sondern Klassen entwirft, die damit die
eigentliche „Schöpfung “ der objektorientierten Weltsicht abgeben. Auch
sind objektorientierte Programme nicht für die Ewigkei t gemacht, sondern unterliegen der
ständigen Anpassung, eben der Evolution, und somit sind auch Klassendefinitionen im stän-
digen Wandel. Eine Übertragung der Vererbung auf Klassen ist also nicht vollkommen un-
natürlich.
Nicht zuletzt muss man auch erkennen, dass viele Anwendungsdomänen,
für die programmiert wird, aus massenhaft gleichen Objekten bestehen,
die durch den klassenbasierten Ansatz besser abgedeckt werden als
durch den prototypenbasierten (vgl. die entsprec henden Kommentare zur Klassifikation in
Abschnitt 7.1). Und so macht denn auch die Vererbung unter Instanzen das Nachvollziehen
(und Debuggen) eines Programms eher noch schwieriger als die Vererbung unter Klassen
ohnehin schon (s. Kapitel 56 in Kurseinheit 6).
"
"2.4 Attribute
Logisch kann man Instanzvariablen in zwei Kategorien aufteilen: solche, die Eigenschaften
eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten re-
präsentieren. Typische Eigenschaften sind beispielsweise die Farbe von etwas od er der
Name; sie grenzen sich von Beziehungen inhaltlich dadurch ab, dass das bezogene Objekt
isoliert betrachtet seine Bedeutung verliert. So ist das Objekt rot allein nichts weiter als eine
Farbe — erst als Attribut eines Objekts (wie z. B. „Apfel“) beko mmt es eine Bedeutung. Das
gleiche gilt für „Schmidtchen“ oder „1“. Dazu kommt, dass Attributwerte wie die vorge-
nannten in der Regel selbst keine Attribute haben oder Beziehungen mit anderen Objekten keine
eingehen. Man beachte jedoch, dass dieses Unterscheidung skriterium nicht absolut, son-
dern relativ zur jeweils betrachteten Domäne ist: Wenn es z. B. um Farben geht, ist „rot“
ein Objekt, das für sich genommen schon eine Bedeutung hat und das mit anderen Objek-
ten vollwertige Beziehungen eingeht, so z. B. mit „gr ün“ als seinem Komplementärkontrast.
Wenn wir eben von Attributwerten sprachen, so ist das nicht ganz zufäl-
lig: Nicht selten haben Variablen, die Attri bute repräsentieren, zumindest
logisch eine Wertsemantik, d. h., sie halten (oder verweisen auf, je nach Implementierung
der Sprache) eigene Kopien eines Objekts. Ein typisches Beispiel hierfür hatten Sie in Ab-
schnitt 1.8 bereits kennengelernt: So ist es sinnvoll, dass die Änderung des Namens (ge-
nauer: des Namensobjekts) bei einer Person nicht gleichzeitig andere Personen, die den glei-
chen (nicht denselben!) Namen h aben, betrifft. Eine ähnliche Überlegung spielt im Zusam-
menhang mit der Betrachtung des Zustandes eines Objekts eine Rolle.
"
"4.6.2 Wiederholung
Etwas weiter ausholen müssen wir für die Implementierung von Wiederholungen (Schlei-
fen): Da das Abbruchkriterium von Schlei fen immer wieder (bei jedem Schleifendurchlauf)
ausgewertet werden muss , kann nicht einfach einmal eine Nachricht an (eine Variable mit
Inhalt) true oder false gesendet werden. Vielmehr muss die Auswertung des Abbruch-
kriteriums selbst in einem Block stattf inden, der bei jedem Schleifendurchlauf neuerlich aus-
gewertet wird. Aber auch das ist kein Problem: Der Nachrichtenempfänger ist einfach ein
Block, dessen Auswertung entweder true oder false zurückliefert; der Parameter der
Nachricht ist dann der Block, de r den Schleifenrumpf darstellt, wie in:
whileTrue: ist dazu als Methode für Blöcke wie folgt implementiert (beachten Sie, dass
Sie den Empfänger, einen Block, in der Methodendefinition nicht direkt sehen; er wird durch
self repräsentiert und ist nicht mit dem Parameter aBlock , ebenfalls ein Block, zu ver-
wechseln):
Wie man sieht, wird hier die Schleife durch eine sog. Endrekursion simu-
liert: whileTrue: ruft whileTrue: am Ende selbst wieder auf. Wegen
der Performanz (oder möglicher Beschränkungen der Anzahl der Schlei-
fendurchläufe durch die Größe des Aufrufstacks) braucht man sich dabei keine Sorgen zu
machen: Da hinter dem rekursiven Aufruf nichts mehr passiert (desweg en ja Endrekursion),
kann dieser vom Compiler in eine echte Schleife übersetzt werden. Für die Implementierung
von whileFalse: (mit entsprechender Semantik) braucht übrigens nur das ifTrue: aus
Zeile 215 durch ifFalse: ersetzt und der rekursive Aufruf entsprechend angepasst zu
werden.
Für die ebenfalls aus anderen Sprachen bekannten For -Schleifen hat SMALLTALK eine andere
elegante Lösung parat, auf die wir im nä chsten Abschnitt eingehen werden.
"
"5 Zusammenfassung der SMALLTALK -Syntax
Sicher ist Ihnen aufgefallen, dass uns bislang keine Schlüsselwörter in SMALLTALK begegnet
sind (bis auf die sog. Schlüsselwortnachrichten , die aber frei wählbar und deswegen eben
gerade keine Schlüsselwörter sind; vgl. Abschnitt 4.1.2 ). Der Grund hierfür ist einfach: Es
gibt keine Schlüssel wörter , lediglich ein paar Symbole mit spezieller Bedeutung . Es sind dies:
Symbol Bedeutung/Verwendung
:= Zuweisung
. Trennzeichen zwischen zwei Anweisungen sowie
Dezimalpunkt für Gleitkommazahlen
; Trennzeichen zum Kaskadieren von Nachrichten
: Markierung von Parametern in Nachrichten und Blöcken
( ) Klammerung von Ausdrücken zur Festschreibung der Reihenfolge der Auswertung
[ ] Bildung von Blöcken
| Trennzeichen zwischen den Parametern eines Blocks und seinen Anweisungen Kumulation
Symbol Bedeutung/Verwendung
| | Deklaration von temporären Variablen in Methoden (und Blöcken)
"" "" Markierung von Kommentaren
' ' Markierung von String -Literalen
$ Markierung von Zeichenliteralen
# Markierung von Symbol - und Array -Literalen
^ Rückgabe -Operator (Return)
Das ist alles! Die reservierten Namen true , false , nil, self und super sind die von
Pseudovariablen ; alle aus anderen Sprachen bekannten Schlüsselwörter sind als Methoden
in SMALLTALK selbst definiert.
"
"13.2 :n-Beziehungen mit besonderen Eigenschaften
Die Klasse Collec tion ist wie gesagt abstrakt. SMALLTALK sieht nun eine ganze Hierarchie von
spezielleren, instanziierbaren (konkreten) Collection -Klassen vor, die für die unterschied-
lichsten Zwecke eingesetzt werden können. Darunter sind so offensichtliche wie Set (für
ungeordnete Collections, in denen jedes Element höchstens einmal vorkommen darf , also
Mengen ) und Bag (für solche, in denen die letzte Einschränkung aufgehoben ist). Set und
Bag haben (neben der mangelnden Ordnung ihrer Elemente) gemein, dass die Elemente in
beiden nicht über einen Index zugreifbar sind. Im Gegensatz dazu stehen geordnete Coll-
ections (Klasse SequenceableCollection oder IndexedCollection , je nach System),
in denen das i-te Element eindeutig bestimmt ist und die entsprechend die Methoden at:
und at:put: implementieren (genaugenommen überschreiben, denn diese Methoden sind
ja für alle Objekte, die über indizierte Instanzvariablen verfügen, schon definiert, und wer-
den lediglich für ungeordnete Collections wieder gelöscht). Aber auch ungeordnete Co llec-
tions (in denen keine Reihenfolge festgelegt ist) können indiziert sein: In Objekten der Klasse
Dictionary wird jedes Element unter einem Schlüssel, der selbst wieder ein Objekt sein
kann, gespeichert. Die dazugehörigen Methoden heißen wiederum at: und at:put: , er-
lauben aber Objekte anderer Klassen als Integer als Indizes.
"
"4.6.4 Iterieren über : n-Beziehungen
Bei :1 -Beziehungen schickt man häufig dem von der betreffenden Variable referenzierten
Objekt eine Nachricht. Der Ausdruck
beispielsweise besagt, dass das Objekt, mit dem der Besitzer der Variable freund über diese
Variable in :1-Beziehung steht, die Nachricht einladen erhalten soll. Wenn man dasselbe
mit :n-Beziehungen machen möchte, so erreicht die Nachricht — bei gleicher Vorgehens-
weise — nicht die logisch in Beziehung stehenden Objekte, sondern das die Beziehung
selbst reprä sentierende Zwischenobjekt (das ja Wert der Variable ist), das mit dieser Nach-
richt jedoch nichts anfangen kann. Um die Nachricht stattdessen an alle durch das Zwi-
schenobjekt referenzierten Objekte zu senden, schickt man dem Zwischenobjekt die Nach-
richt do: aBlock , wobei aBlock ein mit einem Parameter parametrisierter Block ist, der
für jedes Element des Arrays genau einmal (mit dem Element als tatsächlich em Parameter)
aufgerufen wird. Wenn also z. B. die Instanzvariable freunde heißt und eine : n-Beziehung
ausdrückt, dann schreibt man statt Zeile 239
Man kann sich fragen, warum die SMALLTALK -Syntax nicht erlaubt, die Nachricht doch direkt
an das Zwischenobjekt zu schicken, das die : n-Beziehung repräsentiert (also im gegebenen
Beispiel freunde einladen ), und di es dann intern so umsetzt, dass die Nachricht an alle
Objekte geschickt wird. Der einfache Grund dafür wird gleich offenbar: Weil man häufig
die Nachricht gar nicht an alle Objekte schicken will, sondern nur an ausgewählte, und weil
dazu dann noch weitere Angaben notwendig sind, so dass im allgemeinen Fall nichts ge-
wonnen wäre.
Auf Basis von do: lassen sich nun zahlreiche weitere natürliche und äu-
ßerst praktische Kontrollstrukturen erzeugen. So ist wie im obigen Bei-
spiel recht häufig eine Nachricht gar nicht an alle Elemente einer : n-Beziehung zu senden, Implementierung der
sondern nur an solche, die bestimmte Kriterien erfüllen. Dazu ist es möglich, die Beziehung
quasi im Vorübergehen einzuschränken und den Block dann nur auf der Einschrän kung
auszuführen:
do: [ :freund | freund einladen]
Dabei ist die Methode select: wie folgt implementiert:
Zeile 244 müssen Sie hier noch nicht verstehen; der Rest sollte Ihnen aber inzwischen klar
sein. answer ist eine temporäre Variable , die nur innerhalb der Methode Gültigkeit hat; ihr
werden in der Do -Schleife mittels add: (einer Methode mit offensichtlicher Funktion) alle
die Elemente des Empfängers hinzugefügt, für die der Par ameterblock aBlock zu true
auswertet.
Auf ähnlich einfache Weise lassen sich nahezu beliebig weitere Kontrollstrukturen realisie-
ren. Zu select: komplementär ist beispielsweise die Methode reject: , die aus einer : n-
Beziehung alle die Elemente entfernt, die eine genannte Bedingung nicht erfüllen:
Kaum zu glauben, dass mit so we nig Aufwand der Verwendung eine neue Kontrollstruktur
hinzugefügt werden kann.
Eine weitere praktische Methode , die eine Sammlung von Objekten zurückgibt, über die
dann (mittels do:) iteriert werden kann, ist collect: ; sie sammelt all die Elemente, die die
Auswertung des ihr als Parameter übergebenen Blocks auf den Elementen der ursprüngli-
chen Sammlung zurückliefe rt, und ist wie folgt implementiert:
Aber auch einzelne Elemente einer Beziehung lassen sich bestimmen: detect: mit einem
Block aBlock als Parameter aufgerufen liefert z. B. aus einer Sammlung von Elementen das
erste Element zurück, auf dem aBlock ausgewertet den Wahrheitswert true ergibt (wobei
bei Fehlen eines solchen Elements ein Fehler geliefert wird). Das erlaubt z. B. den A usdruck
zu formulieren, der besagt, dass man sich mit dem ersten engen Freund, und nur mit dem,
trifft. Für die Praxis wichtiger ist die Variante detect: aBlock ifNone:
exceptionBlock , die detect: aBlock um einen (parameterlosen) Block ergänzt, des-
sen Wert bei Fehlen eines geeigneten Elements zurückgegeben wird.
Selbsttestaufgabe 4.5
Versuchen Sie, eine Implementierung der Methode detect: aBlock selbst zu entwerfen.
Eine ganze Klasse von immer wiederkehrenden Anweisungssequenzen zu
ersetzen erlaubt schließlich die Methode inject:into: : Es ergänzt die Funktionsweise
von do: darum, das Ergebnis der Auswertung eines Blocks in einem Iterationsschritt als
ersten Parameter in die Auswertung des nächsten Schritts einzuspeisen. So lässt sich bei-
spielsweise das öde Akkumulieren von Eigenschaften (inkl. der gern vergessenen Initialis ie-
rung des Akkumulators) elegant wie folgt ausdrücken:
So einfach kann Programmieren sein!
Für Interessierte: Methoden wie do:, collect: , select: und inject: sind allesamt (al s
Funktionen höherer Ordnung) aus der funktionalen Programmierung bekannt . In die ob-
jektorientierte Programmierung mit Sprachen wie JAVA oder C# haben sie jedoch erst sehr
spät E inzug gehalten.
"
"2.3 Teil-Ganzes -Beziehungen
Eine Sonderrolle unter den Beziehungen nimmt die sog. Teil-Ganzes -Beziehung , je nach
Kontext und Jargon auch Komposition oder Aggregation genannt, ein. Teil -Ganzes -Bezie-
hungen bestimmen ganz wesentlich unsere Weltsicht: A lles, was wir anfassen oder betrach-
ten können, ist aus kleineren Teilen zusammengesetzt, die selbst wieder Zusammensetzun-
gen (Aggregate, Komposita) sind bis hinunter zu den Elementar -, d. h., unteilbaren Baustei-
nen. Vorteile von
Nun ist der Begriff der Teil -Ganzes -Beziehung leider nicht so klar definiert,
wie es auf den ersten Blick scheint. Tatsächlich bestehen, je nach Art der
Zusammensetzung, zum Teil völlig unterschiedliche Wechselwirkungen
zwischen dem G anzen und seinen Teilen. Zudem gibt es neben der phy-
sischen Teil -Ganzes -Beziehung auch eine logische: So ist z. B. der Deutsche Bundestag aus
einer Anzahl von Abgeordneten zusammengesetzt und jede Familie aus ihren Mitgliedern.
Tatsächlich gibt es so viele Varianten der Teil -Ganzes -Beziehung, dass der (philosophische)
Diskurs darüber ganze Regale füllt und zu einer eigenen Disziplin geführt hat (der sog.
Mereologie ). Verständlicherweise kann dem eine Programmiersprache nicht folgen und für
jede dieser Beziehungen ein eigenes Sprachkonstrukt anbieten.
Stattdessen bieten die meisten (objektorientierten) Programmiersprachen
aber leider überhaupt kein Sprachkonstrukt an, das speziell für die Teil -
Ganzes -Beziehung gedacht wäre. Gleichwohl kann man die Unterscheidung zwischen In-
stanzvariablen mit Referenz - und Wertsemantik, falls vorhanden, dazu nutzen, um z umin-
dest eine spezielle Form der Teil -Ganzes -Beziehung abzubilden: Da bei Wertsemantik mit
der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner In-
stanzvariablen dienen, aus dem Speicher entfernt werden, kann man hier tatsäc hlich von
der Umsetzung einer bestimmten Form von Teil -Ganzes -Beziehung sprechen, nämlich einer
solchen, bei der die Existenz der Teile von der Existenz des Ganzen abhängt (in der UML
auch Komposition genannt). Für andere Formen, wie z. B. die Bildung einer Gruppe von
Objekten als Objekt mit eigener Identität (einem Verein beispielsweise), ist dieses Modell
aber nicht geeignet, da sonst mit Auflösung der Gruppe auch die Gruppenmitglie der ver-
schwinden müsste n. Für die SMALLTALK -Programmiererin sind diese Überlegungen aber so-
wieso kein Thema, denn sie hat die Wahl erst gar nicht.
Mit der Teil -Ganzes -Beziehung auf Programmebene werden wir uns in Kurseinheit 6 (ge-
nauer: Kapitel 58 und 59) noch ausführlicher beschäftigen. Hier sei nur schon soviel gesagt,
dass die Möglichkeit des (rekursiven) Aufbaus eines Software -Systems aus Teilen, die jeweils
ihren inneren Aufbau (ihre Kom position) kapseln , also insbesondere die Nichtexistenz von
Aliasen auf ihre Teile garantieren, genau das ist, was der objektorientierten Programmierung
im wesentlichen bis h eute fehlt.
"
"12 Dynamisches Binden
Wie bereits in den Abschnitten 4.3.2 und 4.5.2 in Kurseinheit 1 angerissen, verbirgt sich
hinter dem Nachrichtenversand ein dynamisch gebundener Methodenaufruf. Dabei ist die
Auswahl der Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfänge-
robjekt abhängig. In Abschnitt 11.2 hatten wir bereits angedeutet, wie in Superklassen de-
finierte Methoden für ihre Subklassen zugreifbar sind; hier schauen wir uns nun etwas ge-
nauer an, wie die dynamische Bindung von Methodena ufrufen vonstatten geht.
Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird
zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehö-
renden Methodenwörterbuch enthalten ist. Dies kan n man auch selbst
tun: Es gibt dafür in der Klasse Behavior eine Instanzmethode
oder so ähnlich (je nach System), die somit allen Klassen (als Klassenmethode) zur Verfügung
steht. (Behavior ist ja eine Superklasse von Class , die wiederum Superklasse aller Me-
taklassen ist, einer derer jede Klasse eine Instanz ist, so dass alle Klassen die Methode
includesSelector: verstehen.)
Wird die Methode gefunden, dann wird sie ausgeführt. Wird sie nicht gefunden, wird zu-
nächst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren
direkter Superklasse usw. bis zur Klasse Object . Sobald die Methode gefunden wird , wird
sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum bereits
(in den Abschnitten 4.3.2 und 11.3) erwähnten Versenden der Nachricht
doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, proble-
matischen Nachricht als Argument. Ablauf eines
Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Me-
thode einer Superklasse des Empfängerobjekts ausgeführt wird, das Ob-
jekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die
Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilie-
rung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die In-
stanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind.
Instanzvariablen, die erst in der Klasse des Objekts hinzug ekommen sind, sind für die Me-
thode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden —
handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch
Instanz seiner Klasse ist. Die gerade ausgeführte Meth ode betrachtet es lediglich wie ein
Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die
Bedeutung der Pseudovariable super , wie wir noch sehen werden.
Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, a us Effizienzgründen direkt
in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im wesentlichen
äquivalent zu der der Methode canUnderstand: , die genau wie includesSelector:
in der Klasse Behavior definiert ist:
Man beachte übrigens, wie wenig Aufwand es ist, aus dem klassenba-
sierten Methoden -Lookup einen objektbasierten zu machen: Man muss
dazu lediglich jedem einzelnen Objekt sein eigenes Methodenwörterbuch
zur Verfügung stellen. Wenn man zusätzlich noch Objekte von Objekten
anstatt Klassen von Klassen erben lässt, dann hat man schon die prototy-
penbasierte Form der objektorientierten Programmierung. Der Unterschied ist also technisch
nicht besonders groß — konzeptuell hingegen schon, denn mit den Klassen entfielen auch
die sonst so nützlichen Begriffe von General isierung und Spezialisierung (von der Generali-
sierung von Objekten zu sprechen erscheint wenig sinnvoll).
Selbsttestaufgabe 12.1
Schreiben Sie eine Klasse PrototypicalObject und ändern Sie darin d ie Methoden perform ,
perform: etc. so ab, dass zunächst in einem jedem Objekt eigenen Methodenwörterbuch nach-
geschlagen wird, ob es eine passende Methode für das Empfängerobjekt gibt. Was fehlt noch, damit
Ihr SMALLTALK zu einem echten Hybriden (klassenbas ierte plus prototypenbasierte Form der Objekto-
rientierung) wird?
Eines der immer wieder vorgetragenen Hauptargumente gegen den Ein-
satz von SMALLTALK in der kommerziellen Programmierung ist der Um-
stand, dass das dynamische Binden wirklich vollkommen dynamisch ist: Dass einem Objekt
eine Nachricht geschickt wird, die es nicht versteht, tritt immer erst zur Laufzeit zutage (s. Verhältnis von
Abschnitt 10.3 und 11.3).41 In den statisch typgeprüften Sprachen, die wir in den nächsten
Kurseinheiten kennenler nen werden, ist das charakteristischerweise nicht so. Dem kann
man entgegenhalten, dass die heutigen (auch) statisch typgeprüften Programmiersprachen
wie JAVA, C# oder C++ sämtliche nicht ohne dynamische Typumwandlungen auskommen,
die ebenfalls zu Laufzeitfehlern führen können. Tatsächlich ist es sowohl in SMALLTALK als
auch in JAVA und C# (in C++ nur mit Einschränkungen; s. Abschnitt 51.5) nicht nur möglich,
sondern sogar geboten, Laufzeitfehler da, wo möglich, zu vermeiden, indem man vor einem
Methodenaufruf explizit prüft, ob ein Objekt die gewünschte Methode auch hat — in SMALL-
TALK mittels canUnderstand: , in JAVA et al. mittels eines entsprechenden Typtests vor ei-
nem Down cast . Die größere Flexibilität, die die objektorientierte Pro grammierung durch
das dynamische Binden bietet, hat eben den Preis, dass bestimmte Laufzeitprüfungen
durchgeführt werden müssen. Statische Typprüfung kann das Risiko von Typfehlern verrin-
gern, aber nicht ausschließen — gleichzeitig schränkt es die Flexibil ität beim Programmieren
ein, ein Umstand, der so manchen, der schon einmal größere Programme in SMALLTALK ge-
schrieben hat, an der Verwendung typgeprüfter Sprachen stört.
"
"54.3 Verhaltensbasiertes Subtyping
Die Regeln des Subtyping aus Kapitel 26 und die damit verbundene Regelung der Zuw ei-
sungskompatibilität bezogen sich ja lediglich auf die Elemente einer Typdeklaration und da-
mit auf rein statische Information. Um nun auch das Verhalten der Objekte eines Typs ein-
zufangen, greift man auf eine Idee der formalen Programmverifikation zurück: der der Über-
führung der Vorbedingungen in Nachbedingungen nach der Art von (54.1). Ins Objektori-
entierte übertragen heißt das, dass ein Typ dann korrekt (implementiert) ist, wenn für je de
Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedin-
gung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methoden-
ausführung verletzt werden). Wir schreiben dazu für eine Methode m und einen Typ T
𝑝𝑟𝑒𝑚𝑇(𝑠𝑒𝑙𝑓:𝑇)⇒𝑝𝑜𝑠𝑡𝑚𝑇(𝑠𝑒𝑙𝑓:𝑇) (54.2)
und meinen damit, dass für eine Implementierung von m in der zu T gehörenden Klasse, die
auf einem Empfängerobjekt vom Typ T (einer Instanz der entspreche nden Klasse) aufgeru-
fen wird, die Nachbedingung aus der Vorbedingung folgt. Diesen Beweis müssen wir aber
zum Glück nicht führen — wir sind hier nicht an der Korrektheit von Implementierungen an
sich interessiert, sondern vielmehr daran, ob sich eine (korr ekte) Implementierung durch
eine andere (ebenfalls korrekte, aber eben andere, auch in Bezug auf ihre Spezifikation)
auch vom Verwendungskontext abhängig ist — wenn beispielsweise mit einem Objekt gar nichts
gemacht wird, kann es auch durch ein anderes ersetzt werden, selbst w enn die entsprechenden
Typen nicht konform sind. Mehr dazu in Abschnitt 54.5. keine umfassende
ersetzen lässt. Konkret: Wir sind an einer verhaltensbasierten Subtypenrelation interessiert,
also an den Bedingungen, die potentielle S ubtypen einhalten müssen, damit sie die Spezifi-
kation des Supertyps erfüllen, so dass man sie als verhaltenskonform betrachten kann und
eine Subtypenbeziehung wie in Kapitel 26 beschrieben gegeben ist. Das ist immer dann der
Fall, wenn obige Implikation auch für Objekte des potentiellen Subtypen S gilt, also wenn
𝑝𝑟𝑒𝑚𝑇(𝑠𝑒𝑙𝑓:S)⇒𝑝𝑜𝑠𝑡𝑚𝑇(𝑠𝑒𝑙𝑓:S) (54.3)
Man spricht dann von einem Behavioural subtyping , das zu deutsch am besten als ver-
haltensbasiertes Subtyping87 wiedergegeben wird.
Es gilt also, (6.3) sicherzustellen. Bei der Spezifikation der Methoden des (potentiellen Sub -)
Typs S wird man aber zunächst nicht auf die Vor - und Nachbedingungen von T zurückgrei-
fen, sondern eigene angeben, so dass für alle Methoden m von S
𝑝𝑟𝑒𝑚S(𝑠𝑒𝑙𝑓:S)⇒𝑝𝑜𝑠𝑡𝑚S(𝑠𝑒𝑙𝑓:S) (54.4)
als Ausdruck der Korrektheit gilt. (54.3) folgt daraus unmittelbar, wenn
𝑝𝑟𝑒𝑚S≡𝑝𝑟𝑒𝑚T und 𝑝𝑜𝑠𝑡𝑚S≡𝑝𝑜𝑠𝑡𝑚T
für alle m in T ist, aber das wird ja wie gesagt im allgemeinen nicht der Fall sein. Die Frage
ist vielmehr: Wie müssen 𝑝𝑟𝑒𝑚S, 𝑝𝑟𝑒𝑚T, 𝑝𝑜𝑠𝑡𝑚S und 𝑝𝑜𝑠𝑡𝑚T miteinander im Verhältnis stehen,
damit Objekte vom Typ S die Anforderungen für Objekte vom Typ T erfüllen? Formal: Was
müssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), das Verhalten
von m in T angewandt auf Objekte aus S, folgt?
Leider ist es mit der Beantwortung dieser Frage aber noch nicht genug.
Aufgrund des in der objektorientierten Programmierung weit verbreiteten
Aliasing kann ein Objekt vom Typ S, das von einem Klienten wie ein Ob-
jekt vom Typ T betrachtet wir d, von einem weiteren Klienten wie ein Objekt vom Typ S
(oder wie von einem anderen Supertypen als T) betrachtet werden. Dadurch können dann
auch Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen des Objekts
verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (deren Vor -
und Nachbedingungen) abgedeckt sind, ja die ein Verhalten bewirken, das mit dem von T
nicht kompatibel und das für Benutzer innen des Objekts, die es als ein T ansehen, nicht
akzeptabel ist . Eine methodenweise Betrachtung von Bedingungen für die Substituierbar-
keit reicht also nicht aus. Man ahnt bereits, dass die Angelegenheit komplex wird.
"
"68.1 Bedeutung
Das Gesetz Demeters besagt nicht mehr, als dass Nachrichten nur an Objekte versendet
werden dürfen, die der Sender selbst kennt oder erzeugt. Dabei ist Kennen ganz im Sinne
von Kurseinheit 1 zu verstehen: Ein Objekt kennt ein anderes, wenn es in direkter Beziehung
dazu steht, wenn es also auf eine Variable direkt (also ohne den Umw eg über ein anderes
Objekt) Zugriff hat, die das andere Objekt benennt. Es kennt das andere Objekt dauerhaft
(oder zumindest für eine längere Dauer), wenn es sich bei der Variable um eine Instanzvari-
able handelt, und temporär, wenn es sich bei der Variable um den formalen Parameter einer
Methode handelt (wobei die Dauer des Kennens dann auf die Dauer der Abarbeitung der
Methode beschränkt ist, es sei denn, der formale Parameter wird einer Instanzvariable zu-
gewiesen). Temporäre (lokale) Variablen werden beim Gesetz Demeters nicht mitgezählt.
Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an
Objekte gesendet (Methoden auf Objekten aufgerufen) werden, die
selbst nur als Ergebnis eines Nachrichtena usdrucks (Methodenaufrufs)
vorliegen. Dies ist in der Regel bei Kettenaufrufen der Fall (s. u.), kann aber auch über eine
zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen.
Sinn und Zweck des Gesetzes Demeters ist, die Kopplung und damit die
Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wird das Gesetz Demeters ver-
letzt, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen ange-
passt werden m üssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen
(sondern eben nur in einer mittelbaren, die nach dem Gesetz vermieden werden soll).
Das Gesetz Demeters wird oft (und leicht verkürzt) in folgender Phrase zusammen gefasst :
Bezogen auf SMALLTALK heißt das, dass Methodenaufrufe zwar geschachtelt, aber nicht ver-
kettet erfolgen dürfen:
ist also erlaubt, wenn a eine Ins tanzvariable oder ein formaler Parameter ist, ebenso
wenn für b dasselbe gilt, nicht jedoch
oder
Man beachte, dass Demeters Gesetz faktisch eine neue, kontextabhängige Zugreif barkeits-
regel einführt: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das
Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt , auf die es aber nicht
zugreifen darf .
"
"52.8 Fazit
Zum Thema objektorie ntierte Programmiersprachen ist viel geschrieben worden. Eines der
beeindruckendsten Werke ist sicher das Buch „Object -Oriented Software Construction “ von
BERTRAND MEYER: Auch wenn er darin letzten Endes versucht, der Leserin EIFFEL zu verkaufen,
und selbst wenn er in Sachen Typsystem einen gewissen Starrsinn an den Tag legt, so steckt
das Buch doch voller zeitloser Weisheiten, die sich allesamt in der — seiner — Sprache EIFFEL
widerfinden. Eine unbedingte Leseempfehlung!
"
"40.2 Interfaces als abstr akte Klassen
Wenn ich im vorangegangenen Absatz das Präteritum bemüht habe, dann liegt das daran,
dass Interfaces in JAVA seit Version 8 einen Bedeutungswandel erfahren haben. Der ur-
sprüngliche Anlass hierfür ergibt sich aus der Evolution von Software, gen auer aus der Er-
weiterung von Interfaces im Laufe der Zeit um zusätzliche Methoden und der Tatsache, dass
solche Erweiterungen ein Nachführen der Klassen, die die Interfaces implementieren, zwin-
gend erfordern. Insbesondere bei sog. Black -box-Frameworks, der en Interfaces dazu ge-
dacht sind, von Anwendungsklassen implementiert zu werden, deren Entwicklung in den
Händen Dritter liegt, ist dies ein erhebliches Problem. Dasselbe Problem hätte man nicht,
wenn man statt der Interfaces abstrakte Klassen nehmen würde — dann könnte man näm-
lich die zusätzlichen Methoden mit einer Default -Implementierung versehen, die von den
„implementierenden“ Klassen geerbt würde, sofern diese Klassen keine eigenen Implemen-
tierungen angeben. Interfaces in Varia -
Genau das wurde in JAVA 8 auch für Interfaces eingeführt: Ein Interface
kann die Implementierung einer Methode vorgeben, die dann an implementierende Klassen
(oder per extends abgeleitete Interfaces) vererbt wird. Dafür hat JAVA ein neues Schlüssel-
wort spendiert bekommen: default . Allerdings haben Interfaces immer noch keine In-
stanzvariablen und entsprechend können Default -Methoden allenfalls auf abstrakte Get-
ter und Setter zugreifen.
Mit JAVA 9 schließlich wurde — letztlich nur konsequent — erlaubt, in
Interfaces auch private Methoden zu definieren. Da diese ausschließlich aus dem Interface
selbst heraus zugreifbar sind, dienen sie ausschließlich der Verbesserung der Lesbarkeit von
Default -Methoden, indem man zusammenhängende Teile aus ihnen he rauslöst und in pri-
vate Methoden verlegt.
"
"68 Das Gesetz Demeters (Law of Demeter)
Eine der klassischen Arbeiten zum Thema objektorientierter Programmierstil ist die zum sog.
Law of Demeter von Lieberherr, Holland und Riel . DEMETER ist ein CASE -Werkzeug, das
selbst kaum weiter Verbreitung gefunden hat und das wohl heute weitgehend unbekannt
wäre, wenn nicht eben dieses Gesetz Demeters es zu einiger Bekanntheit gebracht hätte .
"
"68.2 Automatische Überprüfung
Man kann sich fragen, ob sich die Einhaltung des Law of Demeter so wie die Einhaltung der
Zugreifbarkeitsregeln automatisch überprüfen lässt. Dabei gibt es aber ein Problem: Das
Gesetz ist nämlich oben in Termini von Objekten, nicht von Variablen oder Typen formuliert.
Eine Überprüfung würde also die Auswertung von konkreten Zuweisungen und damit des
dynamischen Programmflusses erfordern, die aber mechanisch extrem aufwendig bis gar Ziel des Gesetzes
DDaass GGeesseettzz DDeemmeetteerrss:: SSpprriicchh nniicchhtt mmiitt FFrreemmddeenn..
nicht durchzuführen ist. Statt dessen prüfen automatische Checker des Law of Demeter zu-
meist lediglich die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur
auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters
(wenn der Aufruf aus einer M ethode heraus erfolgt, was meistens der Fall ist) haben. Daraus
folgt, dass eine solche Prüfung in SMALLTALK nicht möglich ist (da Ausdrücke nicht typisiert
sind).
Was aber tun, wenn man die Funktion von Ausdrücken wie oben haben und zugleich De-
meters Gese tz folgen möchte? Die Antwort ist einfach: Man erweitert das Protokoll der
Klasse des ersten Nachrichtenempfängers um die Methode(n), die man nicht verkettet auf-
rufen darf, also beispielsweise die Klasse des von a benannten Objekts um die Methode
doY. Da a das Ergebnis von doX, nennen wir es b, irgendwo herhaben muss (sonst könnte
es es ja nicht zurückgeben), kann auch a die Methode doY aufrufen und das Ergebnis zu-
rückgeben. Die Implementierung von doY würde dann durch ^ b doY abgeschlossen.
Komplizierter w ird die Sache jedoch, wenn die Verkettung länger ist, wenn also der zu ver-
meidende Ausdruck a doX doY doZ heißen würde, denn dann müsste auch noch doZ zur
Klasse von a hinzugefügt und mit entsprechenden Implementierungen versehen werden.
Man ahnt schon, wo zu das führt: zu einem Wachstum des Protokolls von a.
"
"50.4.4 Die dynamische Komponente
C# soll genau wie JAVA und anders als C++ eine typsichere Sprache sein, also eine strikte
Typprüfung durchführen. Da aber (ebenfalls genau wie in JAVA) nicht alles zur Übersetzungs-
zeit geschehen kann, hat auch das Typsystem von C# eine Laufzeitkomponente.
Um einen Ausdruck einer Typumwandlung zu unterziehen, bietet C# ge-
nau wie JAVA und C++ Casts an. Auch die Syntax unterscheidet sich nicht:
bewirkt, dass der Ausdruck a den Typ T aufgedrückt bekommt. Ist dies nicht möglich, weil
der tatsächliche Typ des Objektes, auf das a verweist, kein Subtyp von T ist oder weil keine
entsprechende Typumwandlung definiert ist (einschl. Boxing/Unboxing), wird dies mit ei-
nem Laufzeitfehler quittiert. Casts sind also typsicher (in dem Sinne, dass keiner Variable ein
Wert zugewiesen wird, den sie nicht haben darf), aber nicht sicher (sie können zu Ausnah-
mesituationen und, im Falle einer Nichtbehandlung, zu Programmabbrüchen führen).
Um Casts sicher zu machen, bietet C# den Operator is an. Er entspri cht
im wesentlichen dem instanceof von JAVA und gibt für einen Ausdruck
der Art
wobei a für einen beliebigen Ausdruck und T für einen Typ steht, zurück, ob das Ergebnis
der Auswertung von a mit einer Variable vom Typ T zuweisungskompatibel ist. Dabe i wird
sowohl das Subtyping als auch das implizite (Auto -)Boxing berücksichtigt. Programmfrag-
mente der Art
sind also sicher. Parallel zum Operator is gibt es noch einen weiteren as, der die typsichere
Zuweisung erlaubt:
wobei a wieder für einen beliebigen Ausdruck und T für einen Typ steht, verursacht nie
einen Laufzeitfehler, weil bei mangelnder Zuweisungskompatibilität einfach null (das mit
allen Variablen zuweisungskompatibel ist) eingesetzt wird. Das obige Programmfragment
(Zeilen 1356 –1359 ) ist demnach mit dem folgen den fast äquivalent:
"
"12.3 Double dispatch
Ihnen ist vielleicht aufg efallen, dass im oben beschriebenen Verfahren zum Auffinden der
auszuführenden Methode nur das Empfängerobjekt, jedoch nicht die Parameterobjekte be-
rücksichtigt wurden. Das erscheint zunächst natürlich. Manchmal hängt jedoch die Auswahl
einer geeigneten Me thode auch davon ab.
Typische Fälle, in denen auch die tatsächlich en Parameter eine Rolle bei
der Methodenauswahl spielen, sind arithmetische Operatoren wie +, –, *
und /. Diese sind nämlich sowohl für Ganzzahlen als auch für Brüche und
Gleitkommazahlen definiert, wobei die Implementierung einer Operation Bedeutung von
davon abhängt, welcher Art die Operanden sind. Nehmen wir beispielsweise an, es gäbe
zwei primitive Methoden für die Ad dition, und zwar eine effiziente für die Integer -Addition
(IAdd ) und eine weniger effiziente für die Float -Addition (FAdd ), und man möchte Additi-
onen für beliebige Kombinationen von Summanden möglichst effizient durchführen kön-
nen. Dann kommt man vielleich t auf die folgende Tabelle von Zuordnungen:
Während die Unterscheidung nach Empfängerobjekten vom dynami-
schen Binden und damit dem Laufzeitsystem vorgenommen wird, bleibt
die Frage, wie man die Unterscheidung nach den Parameterobjekten vor-
nimmt: Zumindest die Implementation der Addition in der Klass e
Integer muss ja danach unterscheiden, ob der Parameter auch ein Inte-
ger oder vielleicht ein Float ist. Anstatt nun diese Fallunterscheidung (mittels entsprechender
Methoden isInteger bzw. isFloat ) explizit zu machen, kann man sich eines einfachen
Tricks bedienen: Man ruft im Rumpf einer Methode dieselbe Methode einfach noch einmal
auf und vertauscht dabei Empfänger ( self ) und Parameter. Damit es dabei nicht zu unend-
lichen Rekursionen kommt, kodiert man die Klasse des Empfängers im Nachrichtenselektor
der neu aufgerufenen Methode42, also z. B. plusFloat: anstelle von nur plus: . Das Er-
gebnis sieht dann wie folgt aus:
Klasse Integer
Instanzmethoden
Klasse Float
Instanzmethoden
da es in ihnen zur Differenzierung von gleichnamigen Methoden da s sog. Überladen gibt. Umsetzung durch
erneuten
Methodenaufruf mit
vertauschten
Empfänger - und
Parameterobjekten Parameter
+ Integer Float Empfänger
Diese Technik, nämlich eine Methode gleicher Bedeutung unter Vertauschung von Sender
und Empfänger aufzurufen, nennt man Double dispatch , und zwar, weil die dynamische
Bindung (auch Method oder Message dispatching genannt) zweimal, und zwar unmittelbar
hintereinander, erfolgt. Etwas ähnliches haben Sie bei der Implementierung von + in
Integer in Abschnitt 4.3.7 (Kurseinheit 1, Zeile 154) schon gesehen. Die Technik des Dou-
ble dispatch wurde übrigens von DAN INGALLS am Beispiel von SMALLTALK erstmals beschrie-
ben; sie findet auch in anderen Sprachen mit Single dispatch (wie JAVA und C#) verbreitet
Anwendung. Double dispatch wird in Sprachen, bei denen bei der (dynamischen) Metho-
denauswahl von Haus aus die Parametertypen mit berücksichtigt werden (die sog. Multi -
dispatch -Sprachen ), naturgemäß nicht benötigt.
"
"1.10 Zusammenfassung
Objekte können also über textuelle Repräsentationen, die sog. Literale , in ein Programm
eingeführt und Variablen zugewiesen werden. Dabei speichern die Variablen die Objekte in
aller Regel nicht, sondern benennen sie lediglich. Technisch gesehen enthalten die Variablen
dann Verweise (Referenzen, Zeiger, Pointer) auf die Objekte, die selbst durch Stellen im
Speicher repräsentiert werden (sog. Referenzsemantik ). Wenn mehrere Variablen dasselbe
Objekt bezeichnen, spricht man von einem Aliasing . Aliasing erlaubt über die gemeinsame
Nutzung vo n Objekten eine außerordentlich speicher - und recheneffiziente Informations-
verarbeitung. Gleichzeitig stellt es aber eine der größten Fehlerquellen der objektorientier-
ten Programmierung dar, da im allgemeinen nicht bekannt ist, ob und wie viele Aliase auf
ein Objekt existieren. Ein besonderes Problem liegt vor, wenn sich die Programmiererin nicht
bewuss t ist, dass sie (nur) mit Aliasen hantiert, und sich dann wundert, wenn sich an ent-
fernten Orten plötzlich die (vermeintlichen, denn eigentlich sind es ja gar keine) Inhalte von
Variablen ändern.
"
"11.5 Dominanz der Vererbung
SMALLTALK stammt aus einer Zeit, in der man mit der objektorientierten Programmierung
noch relativ wenig praktische Erfahrung gesammelt hatte. Damals war man der Ansicht,
einer der Hauptvorteile der objektorientierten Programmierung sei die Wiederverwendung
von Code durch Vererbung. Nun hat die Vererbung, wie in Abschnitt 10.1 dargelegt, durch-Konflikt mit
aus etwas mit der auf Generalisieru ng bzw. Spezialisierung beruhenden Abstraktionshierar-
chie zu tun: Der allgemeinere Begriff (die Superklasse) überträgt (vererbt) alle seine Eigen-
schaften auf die spezielleren Begriffe (Subklassen), der speziellere erbt sie von den allgemei-
neren. Dies liegt in der Natur der Sache. Problematisch wird es jedoch, sobald man den
kausalen Zusammenhang umkehren und von einer möglichen Vererbung auf eine Genera-
lisierung/Spezialisierung schließen will: Nur weil eine Klasse (zufällig) Eigenschaften einer
anderen gebr auchen könnte, heißt das noch lange nicht, dass die erbende Klasse auch eine
Spezialisierung der vererbenden ist. Ein klassisches Beispiel hierzu hatten wir mit der Ablei-
tung der Klasse Rechteck von der Klasse Quadrat bereits kennengelernt; den unange-
nehme n Folgen solch vererbungsorientierter Vorgehensweisen werden wir in der nächsten
Kurseinheit noch begegnen.
"
"52.3 Anweisungen
Anweisungen sind in EIFFEL die Zuweisung, der Methodenaufruf , der Konstruktoraufruf (der
Umgang mit Ko nstruktoren in EIFFEL unterscheidet sich erheblich von dem in SMALLTALK und
auch von dem in JAVA/C#/C++; es wird hier jedoch nicht weiter darauf eingegangen) sowie
die üblichen Kontrollstrukturen zur Verzweigung und der Wiederholung. EIFFEL hält sich da-
bei strikt an die Regeln der strukturierten Programmierung — jede Kontrollstruktur hat also
genau einen Eingang und einen Ausgang . Das ist in der Praxis natürlich richtig lästig, führt
zu ärgerlich langen Programmen und dürfte mit ein Grund für die mangeln de Akzeptanz
EIFFELs unter professionellen Programmiererinnen sein. Davon unbeschadet bietet EIFFEL ein
Exception handling , das sich angenehm von dem in JAVA/C#/C++ unterscheidet (es erlaubt
insbesondere ein Retry, also ein Wiederholen eines fehlgeschlagenen Versuchs, das in an-
deren Sprachen durch Codiermuster realisiert werden muss); auf Details von EIFFELs Excep-
tion handling wird hier jedoch nicht eingegangen, da es nur bedingt etwas mit Objektori-
entierung zu tun hat.
In EIFFEL ist, genau wie in PASCAL , das Semikolon Trennzeichen und nicht Teil einer Anwei-
sung; darüber hinaus ka nn es am Ende einer Zeile auch weggelassen werden. Kleine EIFFEL-
Programme wirken daher, und aufgrund des Verzichts auf Blöcke außerhalb von Kontroll-
strukturen — es gibt weder {…} noch begin … end —, optisch aufgeräumt; große Pro-
gramme wirken jedoch schnel l aufgebläht.
"
"1.2 Literale
Ein Literal (von lat. littera, der Buchstabe ) ist eine in der Syntax der Programmiersprache
ausgedrückte Repräsentation eines Objektes. Literale sind somit textuelle Spezifikationen
von Objekten: Wenn der Compiler ein Literal übersetzt, erzeugt er daraus — bei der Über-
setzung! — das entsprechende Objekt im Speicher . Dies steht im Gegensatz zu objekter-
zeugend en Anweisungen eines Programms, denn diese werden erst zur Laufzeit des Pro-
gramms ausgeführt. Da wir uns mit der programmgesteuerten Erzeugung von Objekten
aber erst in der nächsten Kurs einheit systematisch befassen, müssen wir hier zunächst mit
Objekten mit l iteraler Repräsentation vorlieb nehmen. Wohlgemerkt: Literale repräsentieren
Objekte, es sind nicht selbst welche.
Die einfachsten Literale repräsentieren Zeichen (gen auer: Zeichenob-
jekte). Um die literale Repräsentation eine s Zeichens von anderen Vorkommen von Zeichen
in einem Programm zu unterscheiden, wird ihnen in SMALLTALK ein $ -Zeichen vorangestellt.
So bezeichnet das Literal
das Zeicheno bjekt „a“ 4. Dieses Objekt ist atomar , d. h., es ist nicht aus anderen Objekten
zusammengesetzt. Zeichen sind in anderen Programmiersprachen — auch objektorientier-
ten — übrigens typische rweise Werte.
Eine andere Art von Literalen, die atomare Objekte repräsentieren, sind
die für Zahlen:
ist z. B. ein Literal, das das Objekt „1“ bezeichnet ;
ist ebenfalls ein Zahlliteral. Zahlliterale bezeichnen ebenfalls atomare (nich t zusammenge-
setzte) Objekte; sie sind in anderen Programmiersprachen typischerweise ebenfalls Werte
(nicht jedoch sehr große Zahlen mit beliebiger Genauigkeit — die werden auch in anderen
objektorientierten Sprachen durch Objekte repräsentiert).
Die in anderen Programmiersprachen vorzufindenden Literale (oder, je
nach Sprache, Schlüsselwörter ) true , false und nil (oder null ), die
genau wie Zeichen - und Zahl literale atomare Objekte repräsentieren, sind in SMALLTALK nicht
in einem Programm) zu benennen. Gemeint ist damit immer die Repräsentation des Objekts im Spei-
cher. Um ein Literal, also die Repräsentation eines Objekts in einem Programm, zu benennen, setze
ich es in diesem Kurstext in der Schriftart für (Programm -)Code. Zeichenliterale
Zahlliterale
Literale v s. (Pseudo -)
Literale, sondern Pseudo variablen (s. Abschnitt 1.7). Der Grund dafür scheint eher pragma-
tischer Natur zu sein : SMALLTALK kennt keine Sch lüsselwörter und indem man true , false
und nil als (Pseudo -) Variablen auffasst, müssen sie vom Compiler syntaktisch nicht von
Variablen (s. Abschnitt 1.5) unterschieden werden . So oder stehen sie für jeweils ein ent-
sprechendes Objekt ( die in anderen Sprachen wiederum Werte sind).
Wenn es atomare Objekte gibt, dann muss es auch zusammengesetzte
geben. So können beispielsweise Zeichen zu Zeichenketten , den s ogenannten Strings ,
zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann aber selbst wieder
durch ein Literal bezeichnet werden; so steht in SMALLTALK
für ein String -Objekt „Smalltalk“. Dieses Objekt ist selbst aus Objekten, nämlich den von
den Zeichenliteralen $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentierten Zeichenobjek-
ten, zusammengesetzt. Was Zusammensetzung von Objekten heißt und wie sie funktio-
niert, darauf gehe ich in den Abschnitten 2.1 und 2.3 noch genauer ein.
Es repräsentieren also String -Literale zusammengesetzte Objekte. Daraus ergibt sich die
Frage, ob zwei gleiche String -Literale dasselbe Objekt im Speicher repräsentieren. Dies ist
nicht grundsätzlich so , wie wir noch sehen werden .
Um durch syntakti sch gleiche Zeichenketten stets dasselbe Objekt zu be-
zeichnen, bietet SMALLTALK sog. Symbole als weitere Art von Objekten mit literaler Reprä-
sentation. So ist
die literale Repräsen tation eines Objekts . Es bezeichnet bei jedem Vorkommen im Programm
dasselbe Symbolobjekt „Smalltalk“ (nicht zu verwechseln mit dem obigen String -Objekt).
Symbole dürfen, anders als Strings, nicht alle Zeichen enthalten (so z. B. keine Leerzeichen).
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die
Erzeugung eines solchen Objekts durch den Compiler technisch auf-
wendiger als beispielsweise die anhand eines String -Literals . Der Compiler muss nämlich vor
dem Erzeugen erst prüfen, ob das Literal schon einmal irgendwo vorkam . Ist das der Fall,
erzeugt er kein neues Objekt, sondern verwendet statt dessen das bereits vorhandene. Das
setzt natürlich eine entsprechende Verwaltung aller Symbolliterale und dazugehörig en Ob-
jekte durch den Compiler voraus.5 Wie man sich leicht vorstellen kann, wäre diese Vorge-
hensweise für die universell und in großer Anzahl verwendeten String s sehr zeit aufwendig.
SymbolTable . String -Literale
Gleichwohler versuchen manche SMALLTALK -Compiler, gleiche Literale, die zusammen kom-
piliert werden, auf dasselbe Objekt abzubilden. Das führt manchmal, durch das sog. Aliasing
(s. Abschnitt 1.8), zu unerwarteten Ergebnissen bei der Verwendung dieser Literale .
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array -Lite-
rale. Die von ihnen repräsentierten Objekte sind genau wie Strings zusammengesetzt, be-
stehen aber im Gegensatz dazu nicht nur aus Zeichen, sondern aus einer Folge beliebiger,
wieder durch Literale repräsenti erter Objekte. Ein Array -Literal wird in SMALLTALK vom # -
Zeichen und einer öffnenden Klammer angeführt, der durch Leerzeichen getrennte Literale
folgen; es wird durch eine schließende Klammer abgeschlossen.
ist ein solches Array -Literal,
ein anderes. Array -Literale können ineinander geschachtelt sein; das # -Zeichen entfällt je-
doch bei allen inneren Arrays . In
beispielsweise ist das String -Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes
Array -Literal, das aus Zeichenliteralen besteht, ersetzt.
Für Array -Literale gilt ansonsten das Gleiche wie für String -Literale: Dass zw ei syntaktisch
gleich sind heiß t nicht, dass sie dasselbe Objekt erzeugen (oder, richtiger, dass aus ihnen
nur ein Objekt erzeugt wird).
"
"59 Das Problem der mangelnden Skalierbarkeit
Zwar besteht jed es laufende objektorientierte Programm aus einer Menge von Objekten,
jede Spezifikation eines solchen Programms besteht aber bei den heute gebräuchlichen klas-
senbasierten objektorientierten Programmiersprachen aus einer Menge von Klassen. Die
strukturbilde nde Einheit der objektorientierten Programmierung auf Programmebene ist da-
her die Klasse. Größere Einheiten sind innerhalb der gängigsten objektorientierten Program-
miersprachen nicht vorgesehen: JAVAs Packages und ähnliche Konstrukte sind allenfalls Na-
mens räume und Einheiten der Auslieferung — der Status eines Sprachkonstrukts vergleich-
bar mit Klasse oder Methode kommt ihnen kaum zu.
Nun sind Klassen relativ feingranulare Gebilde. Zwar hindert einen nichts
daran, große Klassen (mit Hunderten von Attributen und Methoden) zu
schreiben, aber dies gilt nicht nur als schlechter Stil, es spiegelt auch die Anwendungsdo-
mäne in aller Regel nicht angemessen wieder. Dort sind nämlich alle großen (komplexen)
Dinge aus einfacheren zusammengesetzt , die, wenn sie selbst eine gewisse Komplexität
haben, selbst wieder aus kleineren zusammengesetzt sind usw. Dasselbe gilt auch für die die Lösung in EIFFEL
Artefakte anderer Ingenieursdisziplinen: Baupläne sind in Komponenten und Unterkompo-
nenten bzw. Systeme und Untersysteme strukturiert. Da wünscht man sich natürlich ana-
loge Möglichkeiten in der objektorientierten Programmierung.
Nun ist es zwar möglich, Objekte mit Hilfe der Teil -Ganzes -Beziehung re-
kursiv aufzubaue n (und im oben diskutierten Rahmen auch zu kapseln,
also Teile vollständig hinter Ganzen zu verbergen), aber für Klassen gilt
das nicht. Zwar ist es hier möglich, über sog. innere Klassen (in JAVA) Klas-
sen zu strukturieren, aber allein schon die Tatsache, wie relativ wenig davon Gebrauch ge-
macht wird, zeigt, dass es sich dabei um keinen besonders nützlichen Mechanismus han-
delt.93 Tatsächlich ist es nämlich — wie schon in Kapitel 58 angesprochen — so, dass Ob-
jekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind (und schon gar nicht
immer der gleichen Kl assen), sondern vielmehr einzelne Exemplare (Instanzen) Teil sein und
vielleicht sogar selbst Teile haben können. Man kann also die hierarchische Struktur objekt-
orientierter Systeme genauso wenig auf Klassenebene vorschreiben, wie man den Aufbau
einer Masc hine anhand lediglich der Typen ihrer Teile (Schrauben etc.) beschreiben könnte
(ohne festzulegen, wo jede einzelne Instanz genau hingehörte). Was man vielmehr
bräuchte, sind Komponenten als zusätzliches, von Klassen und Objekten verschiedenes
Programmiersprachenkonstrukt.
Leider ist es mit der Einführung von Komponenten in objektorientierte
Programmiersprachen bislang noch nicht be sonders weit. Das merkt man
schon daran, dass keine weit verbreitete objektorientierte Programmier-
sprache das Schlüsselwort component verwendet, ja nicht einmal reser-
viert. Statt dessen lässt man die Programmiererinnen alles in Form von Klassen definieren
und Komponenten immer zur Laufzeit, per Aggregation von Objekten, zusammenbauen.
So schwache Konzepte wie Pakete (JAVA) oder Assemblies (C#) können dabei k eineswegs
einen Komponentenbegriff ersetzen, da sie lediglich Klassen gruppieren (und dabei auch
noch ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedenen Typs lie-
fern kann). Es ist meine persönliche Vermutung, dass an dieser Front in d en nächsten Jahren
noch der größte Fortschritt erzielt werden kann.
"
"4.1.3 Auswertung von Ausdrücken
Ausdrücke allein sind nur syntaktische Figuren — um das Objekt zu liefern, für das sie ste-
hen, müssen sie ausgewertet werden. Es ist die Auswertung, bei der ein Programm tatsäch-
lich „etwas tut“.
Das Elementarste, das ein Programm tun kann, ist die Auswertung einer
Zuweisung wie beispielsweise y := x . Diese Auswertung führt dazu,
dass die Variable y nach der Zuweisun g auf dasselbe Objekt verweist wie
vorher schon x. Dabei steht der gesamte Ausdruck y := x für (eine Referenz auf) das
Objekt, auf das x (und nach seiner Auswertung auch y) verweist. Die Zuweisung dieses
Objektes an y ist gewissermaßen nur ein Seiteneffekt der Auswertung des Ausdrucks.19
Man beachte, dass es sich beim Zuweisungsoperator := nicht u m einen (binären) Nachrich-
tenselektor handelt: Es wird hier nämlich keine Nachricht an ein Objekt geschickt, sondern
der Inhalt einer Variable manipuliert. Die Zuweisung ist tatsächlich eines der wenigen Primi-
tive SMALLTALK s, also eine der Operationen, die nicht in sich selbst programmiert, sondern
fest „verdrahteter“ Teil der Sprache sind (vgl. Abschnitt 1.6).
aber dieses Wort ist genauso unnötig, wenn Nebenwirkung das ist, was gemeint ist. Als strittig würde
ich schon eher ansehen, ob man hier überhaupt von einer Nebenwirkung sprechen sollte, denn der
sich einstellende Effekt ist ja das vornehmliche Ziel ein er Zuweisung, so dass man eher von Wirkung
(oder Effekt) sprechen sollte. Für mich ist Seiteneffekt Jargon, bei dem jede weiß, was gemeint ist. Kaskadierung
Nachrichtenausdr ücke werden ausgewertet, in dem die Nachricht (das
Prädikat des Satzes) an das Empfängerobjekt (das Subjekt) mit den Para-
metern (den Prädikatsergänzungen) gesendet wird und das Empfänge-
robjekt als Ergebnis der Nachricht ein Objekt zurückliefert. Wie das Em pfängerobjekt das
Ergebnisobjekt bestimmt, darauf kommen wir noch; hier ist nur wichtig, dass der Nachrich-
tenausdruck im Zuge der Auswertung gewissermaßen durch das Objekt, für das er steht,
ersetzt wird. Man kann sich das genauso vorstellen wie die Auswer tung einer (mathemati-
schen) Funktion f, deren Funktions anwendung f(x) auf ein Objekt x ebenfalls für den Funk-
tionswert steht.
Eine häufig gebrauchte, von allen Objekten verstandene unäre Nachricht
ist printString , in Reaktion auf die das Empfängerobjekt eine textuelle Repräsentation
von sich zurückgibt:
liefert den String '12' , die Auswertung von Zeile 45 den String 'abc' . Der bereits in
Zeile 53 angeführte binäre Nachrichtena usdruck
liefert wie erhofft das Objekt „3“. Bei der Auswertung des Schlüsselwortau sdrucks
bei dem als Seiteneffekt die Zahl „12“ in ihrer textuellen Repräsentation, also als String
'12' auf dem Ausgabestrom, auf den die Variable Transcript verweist, ausgegeben
wird, wird das Empfängerobjekt „12“ zurückgeliefert.
Es ist in SMALLTALK , anders als z. B. bei als void deklarierten Methoden in
JAVA oder C# , nicht möglich, in Reaktion auf einen Nachrichtenversand
nichts zurückzugegeben. Dies könnte man in Zeile 70 als sinnvoll erach-
ten, da man hier eigentlich nur an dem (Seiten -) Effekt , der Ausgabe von
„12“ auf dem Transcript, interessiert ist. Wenn die zu einer Nachricht gehörend e Methode
keinen sinnvollen Rückgabewert hat, wird standardmäßig immer das Empfängerobjekt zu-
rückgegeben ; auch das dient, da man Nachrichtenausdrücke so stets verketten kann, einem
Fluent API . Sollte es für das Rückgabeobjekt im Kontext der Nachricht (des Nachrichtenver-
sands) keine Verwendung geben, es also nicht einer Variable zugewiesen oder sonst wie
Teil eines anderen Ausdrucks sein, verfällt es einfach. Da der Rückgabewert aber tech nisch
nur eine Referenz auf das Objekt ist, bleibt die Existenz des Objektes davon zunächst unbe-
rührt. Nur wenn es sonst keine anderen Referenzen auf das Objekt gibt, etwa weil es extra
für die Rückgabe erzeugt wurde, wird das Objekt bei der nächsten Speicherbereinigung
entfernt. Auswertung von
Da die Auswertung eines Nachrichtenausdrucks zur Abarbeitung der An-
weisungen des Rumpfs einer Methode führt, nennt man ihn auch Metho-
denaufruf . Warum dies e Bezeichnung legitim ist, wird jedoch erst in Ab-
schnitt 4.3 klar.
Zusammenfassend wird also
 ein Literal zu dem Objekt ausgewertet, das es repräs entiert,
 eine Variable zu dem Objekt, das sie benennt,
 eine Zuweisung zu dem Objekt, zu dem der Ausdruck auf der rechten Seite der
Zuweisung ausgewertet wird,
 ein Nachrichtenausdruck zu dem Objekt, das als Antwort auf die Nachricht zurück-
gegeben wird, sowi e
 ein kaskadierter Nachrichtenausdruck zu dem Objekt, zu dem sein letzter Nachrich-
tenausdruck ausgewertet wird.
"
"42 Aufzählungstypen
Bis JAVA 1.4 waren class , interface und [] (Array) die einzigen Typkonstruktoren; mit
JAVA 1.5 ist auch noch enum für Aufzählungstypen hinzugekommen, wobei diese unter die
Klassentypen fallen: Neben der Angabe der Elemente der Aufzählung kann man auch noch
Felder und Methoden angeben, die auf ihnen definiert sind. Damit werden die Elemente
einer Aufzählung gewissermaß en zu konstanten, also zu lebenslang gültigen, Namen für
Objekte einer Klasse, die den Aufzählungstyp repräsentiert.
"
"4.4.2 Continuation
Das Konzept des Home context eines Blocks geht aber noch weiter: Es gehören nicht nur
die sichtbaren Variablen aus dem Kontext der Definition des Blocks dazu, sondern auch der
sog. Call stack , also der Speicher, in dem die Rücksprungadressen von Methodenaufrufen Blöcke in anderen
abgelegt werden. Entsprechend bedeutet eine Return -Anweisung innerhalb eines Blocks bei
seiner Auswertung auch stets die sofortige Rückkehr in den den Block definierenden Home
context (der Methode) und nicht in den Kontext (in der Methode), in dem (in der) der Block,
durch Senden von value , ausgewertet wird. Das nachfolgende Beispiel zeigt das:
Der Aufruf der Methode homeContext gibt „home“, aber nicht auch noch „other“ auf
der Konsole aus. Man nennt dieses Konzept, das ebenfalls aus der Welt der funktionale n
Programmierung stammt, auch Continuation . Continuations spielen bei der Implementie-
rung von Kontrollstrukturen in SMALLTALK eine entscheiden de Rolle (s. Kapitel 4.6).
Das Prinzip der Continuation gilt übrigens auch für geschachtelte Blöcke:
liefert true , nicht false . Return -Anweisung verlässt auch alle umschließenden Blöcke, und
zwar sofort. Dies liegt daran, dass explizite Return -Anweisungen aus Blöcken immer dahin
zurückkehren, von wo die Definition des Blocks angestoßen wurde.
Continuations können zu Laufzeitfehlern führen, nämlich wenn durch sie
von einer Methode zurückgekehrt werden soll, die bereits beendet
wurde. Wenn beispielsweise das Objekt o über die Methode
verfügt, dann führt
zu einem Laufzeitfehler, da die Auswertung des von merkwuerdig mit ihrer Beendigung
zurückgegebenen Blocks merkwuerdig noch einmal beenden müsste , was aber nicht geht.
Return -Anweisungen in Blöcken sind u. a. deswegen ein umstrittenes Konzept. Für SMALL-
TALK sind sie aber unverzichtbar, da mit ihnen fast alle Kontrollstrukturen implementiert
werden (s. Kapitel 4.6).
"
"51.2 Klassen
C++ ist insofern objektorientiert, als es neben den aus C übernommen Strukturen (structs)
auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern
(Instanzvariablen) au ch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s.
Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwor t static in einer Klasse eingeführt.
Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwen-
det werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt
nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALL-
es den Russen zuzuspielen, um deren Informatik um Jahrzehnte zurückzuwerfen, und dass die Ent-
wicklung der Sprache erst als abgeschlossen erachtet wurde, nachdem sich for(;P("" \n""),
R--;P(""|"")) for(e=C;e --;P(""_""+(*u++/8)%2)) P(""| ""+(*u/4)%2); übersetzen ließ.
TALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz -, son-
dern Wertsemantik . Entsprechend müssen die Werte solcher Variablen, die „Objekte“, nicht
erst mit new angelegt werden — der für ein „Objekt“ benötigte Speicherplatz wird, genau
wie bei den Records PASCAL s oder bei den Structs von C, bei der Deklaration reserviert. Dabei
steht „Objekt“ hier deswegen in Anführungsstrichen, weil diese „Objekte“ eigentlich keine
Objekte sind, sondern Werte; insbesondere haben sie keine Identität und bei Zuweisungen
an andere V ariablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch
keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom
Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem
New-Opera tor instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Kon-
struktor für die Klasse A als gegeben voraussetzt, so aus:
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine
Pointervariable ha ndelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder
C#.
Zur Dereferenzierung einer solchen Pointer -(Objekt -)Variable bei gleichzeitigem Zugriff auf
ein Element (Feld oder Methode) der Instanz schreibt man in C++
bzw.
wobei x ein Feld und f(.) eine Methode der Klasse A sein soll. Dies ist äquivalent zu
(*a).x bzw. (*a).f(x) . Besondere Obacht ist bei Zuweisungen geboten, da man sich
hier genau überlegen muss , ob man Pointer oder die Werte, auf die die Pointer zeigen,
zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen ,
die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst
ein Call by value , das heißt, es wird eine Kopie des Inhalts des tatsächli-
chen Parameters de m formalen Parameter zugewiesen. Im Falle von Pointer -Variablen wie
dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das
Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK ,
wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-
variable handelt — es ist einfach immer so. Hantieren mit
Will man nun davon abweichend ein Call by reference haben, dann gibt es zum einen die
Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Ko-
pie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und
diesen übergibt:
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf
Zeiger aufnehmen können, also etwa wie in
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren und einfach
zu schreiben, wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & aus-
kommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.
"
"29.2 Collections als Standardanwendungsfall für parametrischen Polymorphismus
Eine wichtige Gruppe von Klassen, die Sie in den letzten beiden Kurseinheiten kennenge-
lernt haben, sind die sog. Collection -Klassen. Auch diese bilden jeweils einen Typ, so dass
Variablen, die auf eine Collection verweisen, mit diesem Typ deklariert werden können.
Nun dienen Collections ja u. a. dem Zweck, : n-Beziehungen zwischen ei-
nem Objekt und mehreren anderen zu ermöglichen, indem si e dafür Zwischenobjekte zur
Verfügung stellen (s. Kurseinheit 2, Kapitel 13). Und so bilden die mit den Collection -Klassen
assoziierten Typen auch nur die Typen für die Zwischenobjekte. Was man jedoch eigentlich
bei der Deklaration von n-wertigen Attributen angeben (deklarieren) möchte, ist der Typ der
in Beziehung stehenden Ob jekte.
Wenn das Attribut beispielsweise kinder heißt und man damit eine Per-
son mit einer Menge anderer Objekte vom Typ Person , den Kindern, in
Beziehung setzen möchte, dann nutzt es nichts, wenn man kinder vom
Typ Person deklariert — es könnte dann höchstens eine Person enthalten und nicht meh-
rere. Was man vielmehr gern hätte, wäre etwas, das dem Array -Typkonstruktor array
[<Bereich>] of <Elementtyp> (spitze Klammern hier wieder als Begrenzer von meta-
syntaktischen V ariablen) von PASCAL gleicht: Im gegebenen Beispiel würde man gern dekla-
rieren, dass kinder den Typ Collection of Person haben soll. Genau das tut
Klasse Person
benannte Instanzvariablen kinder <Collection[Person]>
Instanzmethoden
Passend dazu ist es möglich, Collection in STRONGTALK als parametri-
schen Typ wie folgt zu definieren:
Typ Collection
Typvariablen E
Protokoll
Das Programmfragment
ist demnach typkorrekt (und weist p zwei Kinder und ein Enkelkind zu).
Ein anderes Beispiel für eine parametrische Definition einer Collection ist Dictionary : Hier
sollte nicht nur der Element -, sondern auch der Schlüsseltyp variabel gehalten werden. Eine
entsprechende parametrische Typdefinition, diesmal mit zwei Typparametern, kann wi e
folgt aussehen:
Typ Dictionary
Typvariablen S E
Supertyp Collection[E]
Protokoll
Dabei ist der parametrische Typ Dictionary ein Subtyp des ebenfalls parametrischen Typs
Collection . Man beachte, dass der Typparameter E hier bereits in der Supertypdeklara-
tion verwendet wird. Ein Dictionary, in dem Integer auf beliebige Objekte abgebildet wer-
den, erhält man dann durch die Instanz iierung Dictionary[Integer, Object] . Es ist
mit einer Variable vom Typ Collection[Object] zuweisungskompatibel . Auf die Einzel-
heiten des Subtypings bei parametrischen Typen wird in Kapitel 30 eingegangen.
"
"52.1 Das Programmiermodell EIFFELs
EIFFEL ist, wie alle anderen hier behandelten Sprachen mit Ausnahme von C++, eine rein
objektorientierte Programmiersprache in dem Sinne, dass der gesamte Code innerhalb von
Klassen angesiedelt ist. Klassen können (mit der in Abschnitt 52.5 gemachten Einschrän-
kung) getrennt übersetzt werden. Dabei basiert die Ausführung von EIFFEL nicht auf einer
virtuellen Maschine, sondern erfolgt direkt auf der Zielmaschine; allerdings gibt es inzwi-
schen auch ein EIFFEL für .NET, das, wie alle .NET -Sprachen, zunächst in CIL und dann in
Maschinencode übersetzt wird. Die Sprache sieht aufgrund ihrer Schlichtheit keine speziel-
len Konstrukte vor, die der Programmiererin erlauben, zwischen performanten und weniger
performanten Implementierungen auszuwählen — mögliche Performanzgewinne werden
ganz einem optimierenden Compile r überlassen. EIFFEL verwendet Garbage collection zur
Speicherfreigabe. akademische
"
"3.1 Eingrenzung
Eine etwas eingeschränktere Sicht vom Zustand eines Objektes bezieht
nur seine Attributwerte ein. Dies setzt jedoch voraus , dass überhaupt for-
mal zwischen Attributen und Beziehungen unterschieden werden kann. In Ermangelung
spezieller Schlüsselwörter könnte dies, wie bereits oben diskutiert, allenfalls über die Unter-
scheidung von Variablen mit Wert - und solchen mit Referenzse mantik erfolgen. Dies ist
Möglichkeit der Veränderung kaum einen Sinn hat, sprechen wir auch ni cht vom Zustand unverän-
derlicher Objekte wie z. B. „1“. Manche SMALLTALK -Dialekte sehen jedoch eine Instanzvariable
immutable vor, die die Veränderlichkeit von Objekten festlegt und die, so ihr Wert denn geändert
werden kann, die (Un -)Veränderlichkeit selbst zu einem Teil des Zustandes von Objekten macht. Attribute mit
jedoch schon in Sprachen, die der Programmiererin eine entsprechende Entscheidung an-
bieten, nicht automatisch der Fall (z. B. JAVA, da hier Strings zwar unveränderlich sind und
somit eigentlich zu den Werten zählen, aber dennoch Referenzsemantik haben); in SMALL-
TALK schließlich ist, da alle Instanzvariablen Referenzen enthalten können, diese Einschrän-
kung überhaupt nicht anwendbar.
Man könnte nun die obige Aussage, dass Zustandsänderungen eines Ob-
jekts ausschließlich über Zuweisungen an seine Instanzvariablen erfolgen
können, anzweifeln und fragen, ob sich der Zustand eines Objektes auch dann ändert, wenn
sich der Zustand eines Objektes, auf das es (per Instanzvariable) verweist, ändert? Zunächst
würde man diese Frage mit nein beantworten, denn sonst würde ja, da Objekte in der Regel
stark miteinander verflochten sind, die Änderung des Zustandes eines Objektes fast immer
zu einer wahren Kettenreaktion führen: Der Zustand aller Objekte, die direkt oder indirekt
— also über dritte — darauf verweisen, würde sich mit ändern. Diese Definition von Zustand
würde jedoch kaum unserem Weltbild entsprechen: Die Än derung Ihres Familienstandes
beispielsweise würde kaum etwas an meinem Zustand ändern, obwohl Sie meine Kurstexte
geschickt bekommen, ich also in einer (direkten oder indirekten) Beziehung zu Ihnen stehe.
Wie aber ist es, wenn ich meinen Namen ändere? Ände rt sich dann mein Zustand?
Während man diese Frage sicher mit ja beantworten wird, ist doch mein
Name als String ein eigenständiges Objekt, das seinen Zustand wechselt, wenn ich, wie im
Beispiel von Abschnitt 1.8 geschehen, einzelne Buchstaben in ihm austausche oder ergänze.
Nach obiger Auffassung ändert sich mein Zustand (als Besitzer des Namens) dadurch nicht,
denn es bleibt ja dasselbe (per Ide ntität) String -Objekt, das meinen Namen hält — es hat
lediglich seinen Zustand gewechselt. Etwas anderes wäre es hingegen, wenn ich das String -
Objekt, das meinen Namen repräsentiert, gegen ein anderes austausche: Dann verweist die
entsprechende Instanzvari able auf ein anderes Objekt und mein Zustand hat sich sicher ge-
ändert. Gleichwohl würde man dasselbe auch von der Namensänderung per String -Mani-
pulation erwarten, nur technisch lässt sich dieser Sonderfall nicht begründen! Wie Sie sehen,
ist das objektorie ntierte Denkmodell nicht ganz ohne Tücken, und Programmierfehler schlei-
chen sich an Stellen ein, die so simpel aussehen, dass man dort nie einen Fehler vermuten
würde. Vielleicht auch deswegen ist es sinnvoll, wenn Strings, wie von einigen SMALLTALK -
Dialek ten (und übrigens auch von JAVA) vorgesehen, immer unveränderlich ( immutable )
sind.
Auch wenn es nicht sinnvoll ist, für ein allgemeines Objektgeflecht den
Zustandsbegriff auf mehrere Objekte auszudehnen, so ist dies für Kom-
position en, also aus Teilen zusammengesetzten Ganzen (vgl. Abschnitt 2.3), durchaus an-
gemessen: Wenn z. B. ein Dokument aus mehreren Seiten besteht, die wiederum jeweils
aus Zeilen und Spalten bestehen, dann ändert die Änderung einer Zeile auch den Zustand
des gesamten Dokuments. Dies wird weiter unten noch eine Rolle spielen, vor allem im
Zusammenhang mit Aliasing: Wenn man nämlich davon ausgeht, dass Zustandsänderunge n
eines Objekts stets Sache des Objekts selbst sind, dann dürfen keine externen Aliase auf
seine Teile existieren, denn sonst könnte ihm eine Zustandsänderung von außen quasi un-
tergejubelt werden . Man sollte den Zustand also k apseln. Reichweite von
"
"9 Generalisierung und Spezialisierung
Es gibt in SMALLTALK also eine Hierarchie, die auf dem Konzept der Klassifikation aufbaut.
Aufgrund praktischer Überlegungen ist diese Hierarchie beschränkt; sie ist mit der Sprach-
definition festgelegt und stellt gewissermaßen einen Teil derselben dar. Konzeptionell ist
diese Hierarchie eine Abstraktionshierarchie : Von den konkreten Objekten der Ebene 0 geht
es über die Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Kon-
zepte auf Ebene 2 hin zur Fassung von Definitionen allgemein auf Ebene 3. Mit jeder Stufe
mit Ausnahme der mittleren wird die Zahl der Objekte, die unter die darin angesiedelten
Konzepte fallen, drastisch reduziert: von Ebene 0 auf Ebene 1 von theoretisch unendlich
vielen Objekten einer Anwendung zur Zahl der Anwendungsklassen, von Ebene 2 auf Ebene
bewegen Sie sich jedoch vor allem auf Ebene 1: Sie definieren Anwendungsklassen, von
denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Dire kt nutzen
Sie also nur eine Abstraktionsstufe für die Programmierung.
"
"54.5 Relativität der Substituierbarkeit
Nun kann man argumentieren, dass Substituierbarkeit im Einzelfall von der jeweiligen Ver-
wendung der Typen abhängt (vgl. Fußnote 86). So kann man im Beispiel von Set und Bag
gar nicht sagen, dass grundsätzlich das eine nicht das andere substituieren kann, denn es
kann durchaus Verwendungen des einen oder anderen Typen geben, in denen der jeweils
andere durchaus als Ersatz infrage kommt. Das Vorliegen einer echten Substituierbarkeit ist
also nicht auf Basis der beteiligten Typen allein entscheidbar, sondern hängt auch von deren
Verwendung ab. Das wiederum bedeutet (auch vor dem Hintergrund des oben gesagten
zur funktionalen Äquivalenz), dass es so etwas wie eine absolute (d. h., von jeder möglichen
Verwendung losgelöste) Substituierbarkeit eigentlich nicht gibt.
Wie kann man diesem Umstand abhelfen? Nun, indem man neben der
Sicht der Programmiererin , die die Typen liefert und die sich um deren Substituierbarkeit
(und die davon abhängige Subtypenbeziehung) sorgt, auch noch die Sicht der Programmie-
rerin, die die Typen zu einem konkreten Zweck einsetzen will, einbezieht. Nur diese Pro-
grammiererin weiß nämlich, was sie sich genau von einem Typen (genauer: von den Objek-
ten eines Typs) erwartet, und nur diese kann beurteilen, welche Typen zu ihrem Zweck ge-
geneinander austauschbar sind.
Wie aber drückt die Programmiererin ihre Erwartung aus? Die Antwort ist
verblüffend einfach: Indem sie selbst einen Typ definiert, dessen Definition die — und eb en
nur die — Eigenschaften umfasst , die sie verlangt. Ein Typ, der genau diese Erwartung und
nicht mehr ausdrückt, spezifiziert gewissermaßen eine Rolle, die die Objekte im Kontext der
Verwendung zu spielen haben. In der Regel wird dieser Typ nur einen Teil der Eigenschaften
umfassen, die allgemeine Typen wie Set oder Bag spezifizieren; im Gegenzug ist damit
aber auch die Auswahl der Typen, deren Objekte für ihre Zwecke infrage kommen, größer. LSP ist zu restriktiv
Die einzige Voraussetzung dafür, dass Objekte die ihnen durch ihren Typ aus Klientinnen-
sicht zugewiesene Rolle auch spielen können, ist, dass sie dazu typkonform sind.
Diese zweiseitige Sicht auf Typen, nämlich die der Nutzerin und die der Anbieterin , beginnt
sich erst langsam durchzusetzen. Die Programmiersprache JAVA und in der Folge auch C#
bieten immerhin ein Interface -als-Typ-Konzept (s. Kapitel 40 in Kurseinheit 4und Abschnitt
50.4.2 in Kurseinheit 5) an, mit dem es möglich ist, in einem Programm partielle Sichten auf
Typen zu spezifizieren. Allerdings wird in der Programmierpraxis die Möglichkeit dieser bei-
den Sprachen kaum dazu genutzt, Benutzerinnen ihre eigenen Anforderungen als Typen
definieren zu lassen. Vielleicht handhaben Sie es ja zukünftig anders.
"
"39.3 Die Module von JAVA 9
Als JAVA entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren
Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen
eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht
private deklariert ist, ist zugreifbar), nach außen sind jedoch nur public deklarierte Pro-
grammelemente sichtbar.
Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf meh-
rere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten beste-
hen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall zirkuläre
ist), dann sind hierfür public Deklarationen erforderlich, die die so deklarierten Program-
melemente jedoch für alle gleichermaßen sichtbar machen.66 Ein Programm kann also keine
andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.
Diese unbefriedigende Situation wurde von der JAVA-Community aufgegriffen, die mit der
Open Services Gateway Initiative (OSGi ) einen Standard etablierte, der die Zusammenfas-
sung von JAVA-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation erlaubte.
Dieser Standard ist u. a. Grundlage von Eclipse, das nicht nur eine JAVA-IDE, sondern im
Kern ein Framework für die Entwicklung beliebig komplexer JAVA-Programme (sog. Rich
Clients) ist.
Mit JAVA 9 wurde dann JAVA ein eigenes, über K lassen und Paketen stehendes Mo dulkon-
zept verpasst. Ein Modul ist demnach eine Menge von Paketen, die, über eine Moduldekla-
ration, eine gemeinsame Schnittstelle spezifiziere n. Eine Moduldeklaration besteht aus ei-
nem (eindeutigen) Namen des Moduls, einer Deklaration der angebotenen Schnittstelle ( bis-
lang über public Deklarationen hergestellt ) und einer Deklaration der benötigten Schnitt-
stelle ( bislang ausschließlich über import Direktiven deklariert ). Neben den allgemeinen
Export tritt der sog. qualifizierte Export , wie er auch in EIFFEL vorgesehen ist: Er nennt die
Module, an die exportiert wird, namentlich und erlaubt so einen „privaten“ Austausch zwi-
schen bestimmten Modulen (die somit ihre eigenen, oder privaten, Schnittstellen haben).
Das besondere an der Moduldefinition von JAVA ist, dass die Einhaltung der damit einher-
gehenden Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit
erzwungen wird. A ußerdem kontrolliert sie auch den reflektiven Zugriff auf Programmele-
mente, der bislang gar nicht unterbunden werden konnte. JAVA-Programme werden
dadurch erheblich si cherer.
"
"2.1 Instanzvariablen
Jedem Objekt kann eine Menge von lokalen Variablen zugeordnet werden. Aus Gründen,
auf die wir noch zu sprechen kommen, heißen die se Variablen Instanzvariablen ; sie wer-
den aber manchmal auch Felder oder Attribute (zu Attributen s. Abschnitt 2.4) genannt. Die
Instanzvariablen eines Objekts sind in gewisser Weise in seinem Bes itz: Sie sind für andere
Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das
jeweils besitzende Objekt eingeschränkt.9 Außerdem ist die Existenz dieser Variablen an die
Existenz (oder Lebensdauer; s. Abschnitt 1.9) des besitzenden Objekts gebunden.
Instanzvariablen bestimmen den Aufbau, oder die Struktur , zusammen-
gesetzter Objekt e (die manchmal deswegen auch strukturierte Objekte
genannt werden) — atomare Objekte haben keine Instanzvariablen. Jede
Instanzvariable eines Objekts belegt dabei einen Teil des Speichers aus seiner Repräsentation
indem sie öffentlich zugängliche Instanzvariablen erlauben und selbst für private nicht verhindern,
dass ein anderes Objekt der gleichen Klasse darauf zugreift. Etwas anderes ist es jed och auch in
SMALLTALK mit den Objekten, auf die die Variablen verweisen: Aufgrund möglicher Aliase kann der
Zugriff nicht so leicht einem einzigen Objekt vorbehalten werden. Richtung von
(s. Abschnitte 1.1 und 1.5). Da Instanzvariablen in der Regel Verweise enthalten und Ver-
weise immer den gleiche n Platz belegen , ist die Größe eines Objekts (der zu seiner Speiche-
rung benötigte Platz) mit der Anzahl seiner Instanzvariablen festgelegt.
In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: be-
nannte und indizierte . Jede benannte Instanzvariable b enennt (oder
verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die
Dauer, die die Variable auf das Objekt verweist, auch zum Namen des
Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer
benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.
Indizierte Instanzvariablen haben keine Namen, sondern werden über ei-
nen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Da-
mit ist der Index gewiss ermaßen der Name der Instanzvariable. Der Index muss eine natür-
liche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition
i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i ver-
weist) zu erh alten, schreibt man
Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig: Tatsächlich speichern Ar-
ray-Objekt e ihre Elemente in indizierten Instanzvariablen. So liefert beispielsweise
das Zeichenobjekt „b“. Um den Wer t einer indizierten Instanzvariable an derselben Index-
position zu setzen, schreibt man z. B.
(aber nur, wenn Ihr SMALLTALK die Änderung der Zusammensetzung für literale Arrays zu-
lässt). Das resultierende Array -Objekt hat die literale Repräsentation #($a 'toll!' $c) .
Indizierte Instanzvariablen sind kein Unikat von SMALLTALK : So bieten bei-
spielsweise C# und VISUAL BASIC sog. Indexer , die im wesentlichen indi-
zierten Instanzvariablen entsprechen (s. Abschnitt 50.3.2 in Kursein-
heit 5). Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine
Variable Item , deren Elem ente über Indizierung des Objekts, dem sie zugeordnet ist, ange-
sprochen werden können.
chen (s. Abschnitt 50.3.2 in Kurseinheit 5). Manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA)
verfügen über eine Variable Item , deren Elemente über <objekt>.Item(n) , aber auch direkt
über <objekt>(n) angesprochen werden können. Unterscheidung von
Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix. Damit ist
auch die Größe eines Objekts mit indizier ten Instanzvariablen fest; insbe-
sondere können Array -Objekt e nicht wachsen (und wenn doch, dann nur
über den in Abschnitt 1.1 erwähnten Trick mit dem Wechsel der Identität). Es müssen aber
nicht alle indizierten Instanzvariablen belegt sein; die „leeren“ enthalten dann nil (s. u.).
Es bleibt noch die Frage, wie Objekte in SMALLTALK in den Besitz von In-
stanzvariablen gelangen. Um das zu erklären, müsste an dieser Stelle auf
das Konzept der Klasse vorgegriffen werden, was aber aus didaktischen
Gründen unterbleiben soll. Gel ernte PASCAL -Programmiererinnen können sich die Instanzva-
riablen aber wie die Felder eines Records vorstellen (oder C -Programmiererinnen wie die
eines Structs), die in der Record -Definition festgelegt werden und die für jede Variable vom
Typ dieses Records zur Verfügung stehen. Für alle anderen mag es reichen, sich vorzustellen,
jedes Objekt verfüge automati sch über zwei spezielle Variablen, die die Namen und die
zugewiesenen Objekte aller seiner Instanzvariablen verwalten. Wie so etwas gehen kann,
wird in der nächsten Kurseinheit klarwerden.
"
"12.2 Das Einbeziehen überschriebener Methoden: Nachrichten an
super
Nicht selten will eine überschreibende Methode die überschriebene nicht komplett ersetzen,
sondern lediglich modifizieren. Dies ist z. B. regelmäßig bei den als Konstruktoren fungie-
renden Klassenmethoden new und new: der Fall: Selbst wenn sie überschrieben werden,
müssen sie doch das grundlege nde Verhalten beibehalten, also neue Instanzen der Klasse
zurückgeben. Dies geschieht am sinnvollsten, indem aus der überschreibenden Methode
die überschriebene Definition aufgerufen und um die gewünschten zusätzlichen Ausdrücke
ergänzt wird. Nur leider is t diese nicht mehr sichtbar — sie wurde ja gerade überschrieben.
Für diesen Zweck verfügt SMALLTALK über eine weitere Pseudovariable, „super“ genannt.
Die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition be-
wirkt, dass mit der Such e nach der zur Nachricht passenden, „aufgerufenen“ Methoden-
definition in der (direkten) Superklasse der Klasse, in der sich der aufrufende Ausdruck (die
aufrufende Methode) befindet, begonnen wird.
Man beachte, dass die Suche anders als bei self unabhängig von der
Klasse des Objekts ist, für das super steht: Obwohl super genau wie
self als Objekt stets den aktuellen Nachrichtenempfänger bezeichnet,
bewirkt super immer eine von der Klasse des k onkreten Empfängerob-
jekts losgelöste Suche, die eben mit der Superklasse der Klasse, in der
super verwendet wird, beginnt und nicht etwa mit der Superklasse der Klasse, von der das
(durch super bezeichnete) Empfängerobjekt eine direkte Instanz ist.
Selbstt estaufgabe 12.2
Probieren Sie aus, was passiert, wenn Sie in der Klasse Sub von oben folgende Methode hinzufügen:
"
"41 Arrays
In JAVA ist es möglich, sowohl von primitiven (Wert -)Typen als auch von Referenztypen Ar-
rays zu bilden. Anders als z. B. in PASCAL können aber über den Array -Typkonstruktor keine
neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variab-
lendeklaration.
vereinbart in JAVA zwei Variablen, wovon die erste ein Array von Fließkommazahlen zum
Typ hat und die zweite ein Array von Objekten. Die alternative Schreibweise
ist auch gebräuchlich. Anders als z. B. in PASCAL wird die Größe des Arrays in der Deklaration
nicht festgelegt — dies geschieht erst bei der Initialisie rung.
In JAVA ist es möglich, Arrays bei ihrer Deklaration zu initialisieren:
Man beachte die Ähnlichkeit zu literalen Arrays SMALLTALK s (Abschnitt 1.2); allerdings müs-
sen die Elemente der Arrays in JAVA nicht selbst Literale sein, sondern dürfen auch andere
Ausdrücke sein. Die Größe des Arrays (in diesem Fall 2) wird bei der Initialisierung automa-
tisch mit festgelegt; ansonsten muss dies bei der Erzeugung des Arrays mittels eines Kon-
struktors explizit geschehen:
private Methoden
Array -Initialisierung
Alle Elemente des Arrays enthalten danach jedoch null (JAVAs äquivalent von SMALLTALK s
nil). JAVA-Arrays sind übrigens 0 -basiert, was soviel heißt wie dass das erste Element den
Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.)
Array -Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen um-
fassen:
beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der
Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimen-
sionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen
nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged
oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays
in JAVA auch gar nicht um mehrdimensionale Arrays , sondern um Arrays von Arrays).
Interessanterweise haben in JAVA Array -Variablen immer und unabhängig
vom Basistyp Referenzsemantik . Bei der Zuweisung an die Variable f
oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer
darauf. Dies hat vermutlich den Hintergrund, dass Array -Kopieroperationen sehr teuer sind
und zudem selten ben ötigt werden. Warum auch immer, im Ergebnis kann f an eine Vari-
able vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ
Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit
auch nicht damit zuwei sungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn
sie wie Klassen und Interfaces Typen bilden, die automatisch Subtypen von Object sind,
außer ihrem Basistyp (also beispielsweise float oder Object ) keine weiteren Definitions-
elemente anzugeben erlauben; insbesondere kann man für einen Array -Typen keine weite-
ren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die
(Pseudo -)Variable length definiert, deren Inhalt die Grö ße des Arrays (Anzahl Elemente)
angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein
Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.
Die bemerkte mange lnde Zuweisungskompatibilität von Object[] und
float[] wirft natürlich sofort die Frage auf, ob denn auch die Zuwei-
sung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit
automatisch ein Subtyp von Object , an eine Variable vom Typ Object[] unzulässig ist.
Wir hatten ja in Abschnitt 29.3 von Kurseinheit 3 am Beispiel zweier Instanzen eines para-
metrischen Typs bemerkt, dass dies zu einem nicht ganz offensichtlichen Problem führt, das
sich analog auf Arrays übertragen lässt. Die Überraschung folgt hier auf den Fuß: Die Zu-
weisung ist in JAVA zulässig.
Am besten lässt sich dies an einem Beispiel erläutern. Man kann tatsächlich in JAVA bei
Vorliegen der Deklarationen
die Zuweisung
durchführen. Die anschließende Zuweisung
führt dann in JAVA allerdings prompt zu einem Laufzeit typfehler (eine sog.
Array store exception ), denn tiere ist ja lediglich ein Alias auf ein Array
mit Hunden, so dass die Zuweisung ein Tier anstelle eines Hundes an Arrayposition 1 setzt
und das A rray hunde , das ja per Deklaration nur Hunde zu enthalten verspricht, damit nicht
mehr typkorrekt ist. Würde man die Zuweisung aus Zeile 1046 zulassen, dann wü rde in der
Folge die scheinbar korrekte Zuweisung
bei der hund ein Tier (das aus Zeile 1046 ) zugewiesen wird, die Typinvariante von hund
verletzen, was ein Compiler aber beim besten Willen nicht mehr erkennen kann (und eine
Programmiererin übrigens auch kaum).
Warum aber geht man dieses Risiko ein und überträgt die Zuweisungs-
kompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal
kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung , die (auf Basis
mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet
hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfeh-
lers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme
verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass
dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass
die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man an-
schließend schreibend (wie in Zeile 1046 ) auf das Array zugreift und dann noch mit dem
falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen).
Da man diese Be dingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein
Laufzeittest durchgeführt. Ein klassischer Kompromiss , der diesmal zugunsten der Flexibilität
beim Programmieren ausging.
Warum aber will man Zuweisungskompatibilität zwischen Arrays nicht
gleichen Typs und damit Zuweisungen wie die in Zeile 1045 unbedingt
haben? Die Antwort ist einfach: weil es Pro zeduren gibt, die den (stati-
schen) Typ der Array -Elemente nicht genau festlegen, sondern lediglich nach oben be-
schränken wollen. So gibt es beispielsweise in JAVA den Interfacetyp Comparable , der wie
folgt definiert ist:
Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich
des Empfänger - mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur
sort(Comparable[] ) kann dann Arrays beliebiger Elementtypen zum Sortieren anneh-
men, solange diese nur Comparable implementieren und damit Auskunft über ihre relative
Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht
ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typ fehler von der Art der
Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservative res
statisches Typsystem hätte ihre Verwendung jedoc h nicht zugelassen. Der eingegangene
Kompromiss zwischen statischer und dynamischer Typprüfung ist also durchaus vertretbar.
"
"50.3 Zusätzliche Ingredienzien von Klassendefinitionen in C#
Für die Programmierpraxis recht nützlich sind die in C# vorgesehenen zusätzlichen Elemente
einer Klassendefinition. Es sind dies Prop erties, Indexer und Events.
"
"50.4.1 Die Typhierarchie von C#
In C# sind genau wie in JAVA alle Variablen typisiert. Anders als in JAVA wird dabei jedoch
zunächst nic ht zwischen Wert - (primitiven) und Referenztypen unterschieden: Alle Typen,
auch die primitiven, gelten als von Object (genauer: System.Object ) abgeleitet. Da lohnt
es sich, auf die Typhierarchie etwas genauer einzugehen.
Genaugenommen i st die Typhierarchie von C# gar nicht die Typhierarchie
von C#, sondern die von .NET: Sie ist nämlich für alle .NET -Sprachen die-
selbe. Das liegt daran, dass .NET für alle seine Sprachen ein gemeinsames Typsystem vor-
sieht, nämlich das Common Type System (CTS). Das CTS sorgt dafür, dass Typen, die in einer
Sprache definiert wurden, auch in einer anderen Sprache verwendet werden können, und
zwar ganz so, als seien sie in der anderen Sprache selbst definiert worden. Wie man sich
leicht vorstellen kann, sind dafür einige Konventionen notwendig.
Das erste Merkmal des CTS ist, dass alle Typen in einer Hierarchie unter-
gebracht sind. Die aus JAVA bekannte Ausgrenzung der primitiven Typen
gibt es also nicht. Tatsächlich sind die primitiven Typen als eine von mehreren Arten von Multicasting auf
Werttypen in der Hierarchie angesiedelt. Eine weitere wichtige Form von Werttypen sind die
(aus PASCAL bekannten und inzwis chen auch in JAVA, dort aber als Referenztypen angekom-
menen) Aufzählungstypen, deren Elemente (Werte) von der Programmiererin selbst ange-
geben werden können (im Gegensatz zu denen der primitiven Typen, deren Werte mit der
Sprachdefinition vorgegeben sind):
Aus Werttypen können, genau wie in PASCAL oder C, mittels des Typkon-
struktors struct (dem C -Äquivalent von PASCAL s record ) neue Wertty-
pen erzeugt werden, die sogar Methoden und Konstruktoren haben können, die aber keine
Klassen sind (und insbesondere keine Typerweiterung und somit auch keine Vererbung er-
lauben):
Man erspart sich durch das Weglassen der Typerweiterung die Projektion bei Zuweisungen,
also das Fallenlassen von Feldern, die ein erweiterter Typ hinzugefügt hat und für die im für
die Zielvariable reservierten Speicher kein Platz ist (vgl. Kapitel 23 in Kurseinheit 2, insbe-
sondere Fußnote 50). Der Typkonstruktor „Array von“ ( []) führt in C# jedoch, genau wie
in JAVA, zu einem Referenztypen.
Bei den Referenztypen wird dann das zweite wichtige Unterscheidungs-
merkmal sichtbar: Neben Klassen, Interfaces und Arrays gibt es auch noch
sog. Delegates , das sind im wesentlichen (Zeiger auf) an ein Objekt ge-
bundene, einzelne Methoden. Delegates ersetzen die aus anderen Sprachen bekannten
Funktionspointer; sie konnten in JAVA bis Version 8 nur recht umständlich über Interfaces
und anonyme innere Klassen emuliert werden, an deren Stelle he ute freilich die Lambda -
Ausdrücke JAVAs treten können (s. Kapitel 37 in Kurseinheit 4). Delegates sind für verschie-
dene Problemstellungen (z. B. Listener -Mechanismen) sehr nützlich.
Zuletzt gibt es in C# auch noch sog. Attribut -Typen ( Attributes ); sie ent-
sprec hen im wesentlichen den Annotationen , die es seit der Version 5 auch in JAVA gibt.
Annotationen haben aber mit objektorientierter Programmierung nicht unmittelbar etwas
zu tun und sind daher nicht Gegenstand dieses Kurses (s. a. Abschnitt 47.4 in Kurseinheit 4).
Es sei nur soviel erwähnt, dass in C# ein Attribut namens Serializable das gleichnamige
Marker -Interface JAVAs ersetzt (vgl. Kapitel 45 in Kurseinheit 4).
Es ergibt sich die folgende grobe Einteilung der Typen von C#: Werttypkonstruktion
Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Ein-
teilung der verschiedenen Arten von Typen in C#. Die Klassenhierarchie ist wesentlich kom-
plexer und vereinheitlicht zudem, wie ja bereits gesagt, das Typsystem von C# (wie auch
das CT S), indem alle Typen von System.Object ableiten. Die Klassenhierarchie im Name-
space System fängt dann auch ungefähr so an (Subklassen sind eingerückt):
Wie Ihnen sicher aufgefallen ist, sind einige der Arten von Typen aus der obigen Liste jeweils
durch eine spezielle Klasse ( Array , Delegate , Attribute ) vertreten. Man kann dies als
Hinweis darauf verstehen, dass tatsächlich alle Arten von Typen integriert sind und es keine
grundsätzlichen Barrieren zwischen ihnen gibt. In C# haben übrigens alle Klas sen außer
System.Object ganz wie in JAVA genau eine Superklasse; sie können aber (auch wie in
JAVA) beliebig viele Interfac es implementieren. Die Tatsache , dass Werttypen als Subtypen
eines Referenztypen (nämlich Object ) deklariert sind, verrät außerdem, dass C# über Auto
boxing und unboxing verfügt.
"
"1 Objekte
In rein objektorientierten Programmiersprachen sind sämtliche Daten, die ein Programm
verarbeiten kann, in Form von Objekten im Speicher abgelegt. Der Reiz dieses Merkmals der
objektorientierten Programmierung ist, dass unser Weltbild, zumindest in weiten Tei len, auf
einem ähnlichen Modell basiert: Die Welt besteht aus Objekten , die miteinander in Bezie-
hung stehen . Dabei ist der Objektbegriff nicht auf das rein Materielle beschränkt: Nach all-
gemeinem Verständnis sind Personen ebenso Objekte wie Dokumente, Zahlen oder Zeichen. Statik vs. Dynamik
Bei der Übertragung von realen (d. h., aus einer Anwendungsdomäne
stammenden) Sachverhalten in ein objektorientiertes Programm ergibt
sich das Problem, dass die Übertragung, aufgrund der Homogenität der Objektorientierung
(alles ist ein Objekt) , gewisse fundamentale Unterschiedlichkeiten der Kategorien unserer
Begriffswelt ignoriert: Zahlen beispielsweise sind im Gegensatz zu Dingen Objekte ohne
Identität, Zustand oder Lebensdauer (sie werden daher auch h äufig als Werte bezeichnet) ;
Mengen nicht weiter abgrenzbar er Elemente wie z. B. 1 Liter Was ser sind gar keine Objekte
im eigentlichen Sinn (auch sie haben keine Identität) usw. Gleichwohl kommen sie alle in
objektorientierten Programmen vor und werden dort — zumindest der reinen Lehre nach
— durch Objekte repräsentiert. Der Ansatz , alles trotz evidenter ontologischer Untersch iede
programmiersprachlich über einen Kamm zu scheren, führt hier und da zu gewissen Inkon-
sistenzen im ansonsten klaren, ja puristischen objektorientierten Weltbild, mit denen wir
leben müssen, wenn wir objektorientiert programmieren wollen (vgl. dazu auch Kapitel 60
in Kurseinheit 6). Es ist dies der Preis des auch „Ockhams Rasiermesser “ genannten Spar-
samkeitsprinzips , das auch für die objektorientierte Programmierung Leitlinie ist .
1.1 Was ist ein Objekt?
Wie bereits erwähnt sind Objekte im Speicher abgelegte Daten. Dabei ist jedes Objekt an
genau einer Stelle im Speicher abgelegt: Es wird damit durch seine Speicherstelle eindeutig
identifiziert . Aufgrund dieser eindeuti gen Identifizierbar keit spricht man auch von der Iden-
tität eines Objekts ; sie kann aus tech nischer Sicht mit der Speicherstelle, an der das Objekt
abgelegt ist, gleichgesetzt werden. Da keine zwei Objekte an derselben Stelle abgelegt wer-
den können, haben auch keine zwei Objekte dieselbe Identität.
Objekte sind grundsätzlich von Werten zu unterscheiden. Werte werden
auch im Speicher abgelegt, haben aber keine Identität. Es folgt, dass derselbe Wert an ver-
schiedenen Stellen im Speicher vorkommen kann. Viele objektorientierte Programmierspra-
chen (wie etwa JAVA oder C#) unters cheiden ganz offen zwischen Werten und Objekten;
SMALLTALK tut dies nur hinter den Kulissen und folgt ansonsten seinem Motto „ alles ist ein
Objekt “.
Die Menge des Speichers, den ein Objekt belegt, ist aus technischen
Gründen kon stant. Objekte können somit weder wachsen noch schrump-
fen. Sollte dies trotzdem notwendig sein, bleibt nur, ein neues Objekt zu erzeugen, das an
die Stelle (nicht die Speicherstelle!) des anderen tritt. Das neue Objekt hat jedoch eine an-
dere Identität, so dass alle Stellen im Programm, die sich auf das alte Objekt beziehen, ent-
sprechend angepasst werden müssen. Wie das geht, wird in Kurseinheit 2, Abschnitt 14.2
erläutert. verschiedene Arten
"
"51.5.2 Dynamische Komponente
Die Beschreibung der dynamischen Typprüfung in C++ fällt knapp aus: Es gibt keine.
Nun wissen aber manche Objekte in C++ zumindest im Prinzip, von welcher Klasse sie In-
stanz sind, und zwar ganz einfach deswegen, weil sie einen Zeiger in die Sprungtabelle ihrer
virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer
Klasse dieselbe ist, steht sie gewissermaßen für die Klasse. Und so wurde sc hließlich C++
doch noch eine Bibliotheksfunktion spendiert, die es erlaubt, für Objekte mit dynamisch
gebundenen Methoden herauszufinden, Instanzen welcher Klassen sie sind.80 Diese Infor-
mation ist unter dem Namen Runtime Type Information (RTTI) bekannt.
Konkret kann die RTTI folgendermaßen ausgenutzt werden. Es gibt zu-
nächst eine Funktion typeid , die man auf einer Referenz aufrufen kann.
Da die Funktion auf Klassennamen überladen ist und zudem eine Struktur zurückliefert, auf
der == als Gleichheitstest definiert ist, lässt sich der Typ eines Objekts z. B. durch
für andere Objekte auch nicht sonderlich interessant ist. Typumwandlungen
prüfen (wobe i x für eine Variable und T für eine Klasse stehen soll). Eine andere nützliche
Funktion, die die RTTI ausnutzt, ist dynamic_cast<T>(x) ; sie nimmt zwei Parameter, ei-
nen Typ (T) und ein Objekt ( x), und liefert das Objekt mit dem Typ zurück, wenn die RTTI
dies als typkorrekt erkennt, oder 0 sonst. In JAVA übersetzt hieße das:
wobei der Ausdruck <A> ? <B> : <C> je nachdem, ob <A> zu wahr oder falsch auswertet,
entweder das Ergebnis der Auswertung von <B> oder von <C> zurückliefe rt (s. Kapitel 37
in Kurseinheit 4). dynamic_cast<T>(x) entspricht im wesentlichen x as T in C# (Ab-
schnitt 50.4.4 ).
Selbsttestaufgabe 51.1
Schlagen Sie ein Verfahren vor, wie man mit Bordmitteln von C++ für Instanzen aller Klassen (und
ohne Verwendung von typeid ) herausfinden kann, Instanzen welcher Klasse sie sind.
"
"13.3 Collections für andere Zwecke
Nicht alle Collecti ons dienen der Umsetzung von : n-Beziehungen. Ein gutes Beispiel gibt die
Klasse Interval .
Bei Instanzen der Klasse Interval handelt es sich um endliche arithme-
tische Folgen, also um beschränkte Folgen von Zahlen, die alle denselben
Abstand zueinander haben. Die Elemente einer solchen Collection müssen deswegen nicht
gespeichert, sondern können berechnet werden. Die Spezifikati on eines Intervalls umfasst
seinen Anfangs - und seinen Endwert sowie die Schrittweite, die auch negativ sein darf.
erzeugt ein Intervall, das die Zahlen 5, 3 und 1 enthält. Intervalle dienen vor allem dem
Zweck, sog. For -Schleifen zu emulieren (s. Abschnitt 4.6.3 in Kurseinheit 1):
etwa bewirkt, dass dem Laufparameter i nacheinander die Werte 5, 3 und 1 zugewiesen
werden. Die zweiparametrige Form
nimmt hingegen eine Standardschrittweite von 1 an. Für noch mehr Komfort ist in der Klasse
Number eine Methode to:by: vorgesehen, die ein entsprechendes Intervall zurückliefert:
erlaubt, statt Zeile 544
zu schreiben. Um der geschätzten Programmiererin auch noch die Klammern zu ersparen,
wurde gleich noch die Methode to:by:do: hinzugefügt, die daraus
zu machen erlaubt. (Man beachte, dass hier der Iterator in der Klasse Number und nicht in
einer Collection wie Interval definiert wurde.) Wie man sieht, ist es in SMALLTALK möglich,
ohne großen Aufwand neue Ausdrucksformen hinzuzufügen, ohne dazu (wie in den meis-
ten anderen Sprachen notwendig) die Syntax ändern zu müssen.
Selbsttestaufgabe 13.1
Sie finden folgendes Codefragment vor:
Kritisieren Sie es!
Zu guter Letzt sind auch die Klassen String und Symbol Collections,
und zwar genauer geordnete Collections fester Größe (wie Arrays), deren
Inhalt jedoch auf Zeichen (Instanzen der Klasse Character ) beschränkt ist. Strings sehen
neben der Möglich keit des Vergleichs (mittels der Operatoren <, <=, >, >=) auch noch ein
Pattern matching (Methode match: aString ) sowie spezielle Operatoren zur Behandlung
von Groß -/Kleinschreibung und eine Konversion in Literale vor. (Die Klasse Symbol ist übri-
gens eine Subklasse der Klasse String ; sie erbt damit alle Methoden von String .) Auf die
Möglichkeiten der literalen Repräsentation von Strings und Symbolen wurde bereits in Kurs-
einheit 1, Abschnitt 1.2, eingegangen.
Selbsttestaufgabe 13.2
Überlegen Sie sich, wie Sie das Case - (oder Switch -)Statement in SMALLTALK simulieren würden, und
gehen Sie auf die Einschränkungen ein, die Sie dazu machen müssen.
"
"8.2 Initialisierung
Konstruktoren sind in SMALLTALK also Klassenmethoden, die neue Instanzen der jeweiligen
Klasse zurückliefern. Dabei haben zunächst alle Instanzvariabl en nach der Erzeugung einer
Instanz den Wert nil. Sollen diese Instanzvariablen mit sinnvollen Anfangswerten belegt
werden, müssen ihnen diese explizit zugewiesen werden. Man spricht dann von einer Initi-
alisierung der Instanz.
Nun sollen nicht immer alle Instanzen einer Klasse gleich initialisiert werden. Es ist daher
möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu defi-
nieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die
Klasse Time sind mit
gegeben, die jeweils die Klassenmethode (den Konstruktor) seconds: auf Time (vertreten
durch self ) aufrufen, die wiederum mittels basicNew eine Instanz von Time erzeugt und
anschließend initialisiert:
Dabei ist ticks: eine Instanzmethode der Klasse Time , die auf der (mit basicNew ) frisch
erzeugten Instanz aufgerufen wird und diese initialisiert:
Parameter der Initialisierung ist hierbei (Duration seconds: seconds) ticks , wobei
Duration eine Klasse und seconds: ein Konstruktor dieser Klasse ist.
Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar
sind, kann auch eine Klassenmethode wie new nicht auf sie zugreifen. Die I nitialisierung
muss daher von Instanzmethoden wie ticks: vorgenommen werden, die jedoch nicht der
Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen wer-
den können. Das ist immer dann ein Problem, wenn auch Instanzvariab len initialisiert wer-
den müssen, deren Existenz nach außen verborgen werden soll (s. Abschnitt 4.3.4 ) und die
deswegen nicht direkt über Zugriffsmethoden gesetzt werden können sollen. Aus diesem
Grund sehen new und new: standardmäßig den Aufruf der Methode initialize vor (s.
Zeilen 307 und 309 oben ), in der alle Initialisierungen vorgenommen werden kö nnen, ohne
dass etwas über den Aufbau der Instanzen nach außen verraten würde. In anderen Spra-
chen wie beispielsweise C++, JAVA oder C# sind Konstruktoren daher auch keine Klassen-
methoden, sondern haben eine Art Zwitterstatus: Sie werden auf einer Klasse a ufgerufen,
werden aber wie Instanzmethoden auf der neuen Instanz ausgeführt und können somit
auch auf die Instanzvariablen der neu erzeugten Instanz zu greifen. Man beachte jedoch,
dass die Instanzmethode ticks: kein Implementationsgeheimnis preisgibt: Dass Objekte
der Klasse Time die Zeit in Sekunden und Nanosekunden speichern ist an der Methode
ticks: nicht zu erkennen.
Vor diesem Hintergrund können wir das Beispiel der zweiten Implemen-
tierung von Stack aus Abschnitt 7.2 wieder aufgreifen und die noch fe h-
lende Initialisierung der Variablen stackcontent und stackcounter nachliefern:
Klasse Stack
Klassenmethoden
benannte Instanzvariablen stackcontent stackpointer
indizierte Instanzvariablen nein
Instanzmethoden
Man beachte, dass das Zwischenobjekt eine Instanz der Kla sse Array ist, die hier (in Zeile
325) nicht wie noch in Kurseinheit 1 notwendig durch ein Literal, sondern durch eine expli-
zite, programmatische Instanziierung (mittels new: ) erzeugt wurde.
Alternativ zu obiger Konstruktion kann die Initi alisierung von Instanzvari-
ablen auch zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt werden. Man
spricht dann von einer Lazy initialization (lazy oder faul deswegen, weil man die Initiali-
sierung solange hinausschiebt, wie irgend möglich). Dazu muss jedoch vor jedem lesenden
Zugriff auf die (faul initialisierte) Instanzvariable geprüft werden, ob der Wert der Variable
immer noch nil ist — falls ja, muss er durch den gewünschten Anfangswert (der sonst in
der Standardinitialisierungsmethode zu finden wäre) ersetzt werden. Um nicht jeden lesen-
den Zugriff auf die Variable im Programm mit einer entsprechenden Abfrage versehen zu
müssen, empfiehlt es sich bei Verwendung von Lazy initialization , alle, also auch klassenin-
terne, Zugriffe auf Instanzvariablen über einen entsprechenden Getter durchzuführen, der
den Inhalt der Variable vor seiner Preisgabe prüft und ggf. erst setzt. Statt
wo bei jeder Verwendung ggf. faul initialisiert wird, würde man also
schreiben (man beachte das self vor stackpointer und stackcontent — hier wird
jeweils ein Getter aufgerufen).
Wie man sieht, ist die Programmiererin bei der Lazy initialization über-
haupt nicht faul —sie muss sogar einiges mehr an Code schreiben, als bei
einer Standardinitialisierung notwendig wäre. Das laufende Programm
spart sich jedoch den Preis der Initialisierung, wenn diese nie notwendig wird, wenn also im
Programmablauf der Wert der zu initialisierenden V ariable nie oder erst nach einer anderen
Zuweisung abgefragt wird (was im Beispiel vom Stack freilich nicht der Fall ist). Sie lohnt
sich also immer dann, wenn die Initialisierung aufwendig und die Abfrage des Anfangswer-
tes selten ist. Ein weiterer Vorteil der Lazy initialization ist, dass die Initialisierung nie verges-
sen werden kann; dies ist insbesondere dann wertvoll, wenn die Initialisierung nicht wie
oben beschrieben vom Konstruktor selbst, sondern von einer separaten Methode durchge-
führt wird und den Benutzerinnen der entsprechenden Klasse vielleicht nicht klar ist, dass
sie nach dem Konstruktor auch noch die Initialisierungsmethode aufrufen müssen. Kon-
struktoren, die wie in Zeilen 307 und 309 oben ) implementiert wurden, suchen das zu ver-
hindern, indem sie die Initialisierungsme thode selbst aufrufen; manchmal kann der Kon-
struktor doch nur schlecht geändert werden (s. z. B. Abschnitt 10.3) und man wird auch
nicht verhindern können, dass, anstelle von new, basicNew direkt und ohne initialize
aufgerufen wird. Vor- und Nachteile
Selbsttestaufgabe 8.1
Begründen Sie, warum eine Kapselung der Lazy initialization durch eine Zugriffsmethode dem Sinn
der Standardinitialisierung per initialize möglicherweise entgegensteht.
Nachdem nun hinlänglich klar geworden sein sollte, welche Möglichkeiten
es zur Initialisierung von Instanzvariablen gibt, bleibt noch die Frage nach
der Initialisierung von Klassenvariablen. Klassenvariablen werden nämlich, genau wie In-
stanzvariablen, standardmäßig zu nil initialisiert und soll eine Klass envariable einen ande-
ren Anfangswert haben (z. B. weil es sich dabei um eine Konstante handelt, die für alle
Instanzen der Klasse eine Rolle spielt), dann muss ihr dieser Wert explizit zugewiesen wer-
den. Da Klassen ja Instanzen ihrer Metaklassen sind, dies e Metaklassen aber automatisch
mit der Erzeugung der Klassen angelegt werden und das Klassendefinitionsschema keine
Möglichkeit vorsieht, einen Konstruktor für die Metaklasse vorzugeben, muss eine spezielle
Klassenmethode (häufig ebenfalls „initialize“ gen annt) für die Initialisierung der Klassenva-
riablen vorgesehen werden. Diese ist dann nach Anlegen der Klasse einmalig aufzurufen.
Da das aber leicht vergessen werden kann, ist Lazy init ialization für Klassenvariablen eine
sinnvolle Alternative. Allerdings stellt sich hier wieder das Problem des direkten Zugriffs auf
die (Klassen -)Variable (aus dem Kontext der Klasse selbst und ihrer In stanzen), der in SMALL-
TALK nicht unterbunden werden kann (vgl. Selbsttestaufgabe 8.1).
Selbsttestaufgabe 8.2
Schreiben Sie eine Methode new, die dafür sorgt, dass alle mit ihr erzeugten Instanzen in einer Klas-
senvariable MeineInstanzen gespeichert werden.
"
"51.1 Das Progra mmiermodell von C++
Das Programmiermodell von C++ ist ein klassisches: Programme werden als Menge von
Quellcode -Dateien geschrieben, die in auf einer Zielmaschine direkt ausführbaren Maschi-
nencode übersetzt werden. Getrennte Übersetzung von Programmteilen ist dank sog. Hea-
der files , die die Schnittstellen der Teile enthalten, möglich. Getrennt übersetzte Programm-
teile müssen vor der Ausführung gebunden werden; dynamisches (Nach -)Laden von Funk-
tionen ist möglich, muss aber explizit (programmgesteuert) erfolg en.
C++ ist als objektorientierter Nachfolger von C konzipiert und soll so einen stufenlosen
Übergang von der prozeduralen zur objektorientierten Programmierung ermöglichen. Dies
wird insbesondere für die Migration von Altsystemen hin zur Objektorientierun g als nützlich
erachtet. Entsprechend zielt C++ auf die gleiche Klasse von Anwendungen wie C ab: ma-
schinennahe Programmierung wie die von Betriebs - oder eingebetteten Systemen. Extreme
Speicher - und Recheneffizienz sind dabei häufig oberste Kriterien.
"
"28 Der Zusammenhang von Typen und Klassen
Wenn in dieser Kurseinheit bislang ausschließlich von Typen die Rede war und Klassen dabei
ignoriert wurden, so hat das gute Gründe: Während eine Klasse die Implementierung ihrer
Objekte festlegt, ist eine Typdefinition vollkommen frei von Implementierungsaspekten.
Zwar können auch abstrakte Klassen (Kurseinheit 2, Abschnitt 10.3) ausschließlich aus Me-
thodendekla rationen bestehen, also ohne jeden Implementierungsanteil daherkommen,
aber auch ihr Zweck ist in der Regel, zumindest eine partielle Implementierung vorzugeben,
die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können:
Schließlich drückt die Klassenhierarchie ja eine „genetische“ Verwandtschaft aus (s. Ab-
schnitt 10.1 und Kapitel 11). Eine Typprüfung soll aber ohne Ansehen der Implementierung
stattfinden; sie baut daher auf abstrakte Spezifikationen, eben auf Typen.
Es sind also Typen abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen
einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten ange-Arten von
ben. Im Gegensatz dazu sind Klassen Konstrukte, die Objekte als Instanzen zu bilden erlau-
ben und mit Implementierung versehen. Da Objekte aber auch den Wertebereich von Typen
ausmachen, stellt sich natürlich die Frage, welcher Art der Zusammenhang zwischen Typen
und Klassen ist.
Diese Frage soll anhand der schematischen Klassendefinitionen aus Kurseinheit 2, Abschnitt
7.2 beantwortet werden. In SMALLTALK ist diese ja stets von der Form53
Klasse <Klasse 1>
Superklasse <Klasse 2>
benannte Instanzvariablen <Instanzvariable 1>, …
Instanzmethoden
Es fällt zunächst auf, dass bestimmte Elemente einer Klassendefinit ion
auch in einer Typdefinition auftauchen. Im einzelnen sind dies
 ein (eindeutiger) Name,
 ein zweiter Name, von dessen dazugehöriger Definition abgeleitet wird sowie
 eine Men ge von Methodennamen, jeweils mit einer Anzahl formaler Parameter.
Nun werden in SMALLTALK s Klassendefinitionen anders als bei den Typdefinitionen STRONG-
TALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine
Typen. Stattdess en findet man aber in SMALLTALK -Programmen manchmal Namen wie „aSt-
ring“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable
Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK
hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier
sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Ka-
pitel 20). Man beachte, dass in STRONGTALK , anders als z. B. in JAVA oder C++, Instanzvari-
ablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).
Nun dient ja ein Typsystem in der objektorientierten Programmierung vor allem der Sicher-
stellung des Umstands, dass alle von einem Objekt aufgrund des deklarierten Typs der Va-
riable, die es benennt, erwarteten Eigenschaften (Methoden) bei di esem Objekt auch vor-
handen sind. Dies ist aber immer dann der Fall, wenn sich die Elemente der Typdefinition in
der Klassendefinition des Objekts wiederfinden, die Klassendefinition also mit der Typdefi-
nition gewissermaßen strukturell konform ist, so dass die Zuweisung einer Instanz der Klasse
an eine Variable des Typs die Anforderungen der Zuweisungskompatibilität erfüllt. Um einen
sondern Klassen (als Instanzen ihrer Metaklassen) charakterisieren. Vergleich von
Compiler diese Zuweisungskompatibilität auf einfachere Weise als die Prüfung der Struktur-
konformität, die ja eine rekursive Expansion der Typdefinitionen erfordert, feststellen zu las-
sen, gibt es zwei Möglichkeiten (bei beiden handelt es sich gewissermaßen um Varianten
einer Namenskonformität):
1. jede Klasse sagt explizit, mit welchen Typen sie konform ist, oder
2. jede Klasse spezifiziert i mplizit selbst einen Typ.
Im ersten Fall müsste der Compiler noch prüfen, ob eine Klasse tatsächlich auch über alle
Eigenschaften der von ihr genannten Typen verfügt; im zweiten Fall ist das automatisch der
Fall, da der Typ ja gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von
den allermeisten typisierten, objektorientierten Programmiersprachen bevorzugt, doch auch
die erste kommt in populären Sprachen vor: So kann beispielsweise in JAVA und C# jede
Klasse angeben, mit Variablen welcher In terface -Typen ihre Instanzen zuweisungskompati-
bel sein sollen (s. Kurseinheit 4, Kapitel 40 und Kurseinheit 5, Abschnitt 50.4.2 ). Auch
STRONGTALK stellt beide Möglichkeiten zur Verfügung .
"
"14.2 Reinkarnation von Objekten
Eine der vielleicht interessantesten Methoden SMALLTALK s ist die Methode become: :
Sie bewirkt, dass das Empfängerobjekt die Identität des Parameterobjekts annimmt bzw. sie
mit ihm tauscht (je nach Dialekt). Das hat u. a. zur Folge, dass alle Variablen, die vor der
Ausführung der Methode den Empfänger benannten (genauer: auf das Empfängerobjekt
verwiesen) , danach den Parameter benennen (auf ihn verweisen) .
Eine mögliche Anwendung ist das Wachsen von Objekten : Wenn einem
Objekt der ihm zur Verfügung gestellte Speicherplatz nicht mehr ausreicht, muss es „um-
ziehen“, d. h., seine Repräsentation im Speicher muss an eine andere Stelle kopiert werden.
Da aber alle Referenzen auf das Objekt noch auf die alte Stelle verweisen, legt man am
besten die neue Stelle als entsprechend groß dimensioniertes Objekt an (beispielsweise m it-
tels new: ) und lässt dann das alte Objekt zum neuen werden. So könnte man beispielsweise
eine Methode grow in der Klasse ArrayedCollection wie folgt definieren :
Eine andere mögliche Anwendung von become: ist die Durchführung
eines sog. Rollback, wenn also, nachdem an einem Objekt (oder Objekt-
geflecht) eine Menge von Änderungen durchgeführt worden sind, der ursprüngliche Zu-
stand wiederhergestellt werden soll. Man legt dann einfach vor den Änderungen eine ( tiefe)
Kopie des Objekts (der Wurzel des Objektgeflechts) an und ersetzt beim Rollback das ur-
sprüngliche (und inzwischen geänderte) Objekt(geflecht) mittels become: durch die Kopie.
"
"11.4 Subklassenhierarchie und Vererbung unter Metaklassen
Vererbung ist nicht auf die Klassen der Ebene 1 beschränkt — es können in SMALLTALK viel-
mehr auch Metaklassen, die ja ebenfalls Klassen sind (s. Kapitel 8), voneinander erben. Da
Metaklassen aber bei der Erzeugung von Klassen automatisch angelegt werden (und auch
keine eigenen Namen haben), hat die Programmiererin auch keinen direkten Einfluss auf
die Vererbungshierarchie der Metaklassen. Vielmehr wird diese automatis ch parallel zur Ver-
erbungshierarchie der Klassen, die Instanzen der Metaklassen sind, angelegt. Dies hat zur Löschen durch
Folge, dass in SMALLTALK neben den Instanzvariablen und -methoden auch die Klassenvari-
ablen und -methoden von einer Klasse auf ihre Subklassen vere rbt werden.
Da in SMALLTALK jede Klasse direkte oder indirekte Subklasse von Object
ist und die Subklassenhierarchie der Metaklassen parallel zu der ihrer Klas-
sen angelegt ist, erbt jede Metaklasse in SMALLTALK automatisch von
Object class , der Metaklasse von Object . Was läge also näher, als die Klassenmetho-
den, die allen Klassen zur Verfügung stehen sollen — darunter auch die beiden Standard-
konstruktoren new und new: — in Object (genauer: als Instanzmethoden von Object
class ) zu definieren?
Nun gibt es ja schon, wie bereits in Fußnote 29 oben erwähnt, in SMALLTALK zwei Arten von
Objekten, nämlich solche, die instanziierbar sind (also Klassen) und solche, die es nicht sind.
Darüber hinaus gibt es auch noch eine Unterscheidung zwischen Klassen, die Metaklassen
sind, und solchen, die es nicht sind — bei allen Gemeinsa mkeiten von Klassen und Me-
taklassen muss man z. B. von Klassen neue Subklassen bilden können, von Metaklassen
jedoch nicht. Diese Unterscheidungen müssen schließlich irgendwo getroffen werden. Und
so kommt es, dass Object class nicht die Wurzel der Vererbu ngshierarchie der Metaklas-
sen ist (kann sie sowieso nicht, denn auch sie muss eine Subklasse von Object sein!), son-
dern selbst von einer für diesen Zweck vorgesehenen Klasse erbt. Aus demselben Grund,
aus dem die Klasse Object „Object “ und die Klasse Metaclass „Metaclass “ heißt, heißt
diese Klasse „Class“: Es gilt nämlich für jede Instanz dieser Klasse, dass sie eine Klasse ist.
Man beachte übrigens, dass Class , auch wenn sie die Superklasse aller Metaklassen ist,
selbst keine Metaklasse ist, denn sonst müsste Class ja als Superklasse von Object class
und wegen der parallelen Vererbungshierarchie von Metaklassen und Klassen die (Meta -
)Klasse einer Klasse sein, die Superklasse von Object ist. Ist sie aber nicht. Außerdem ist,
wie man sich leicht überzeugen ka nn, die Klasse von Class die Klasse Class class und
erst Class class eine Metaklasse. Zugegebenermaßen etwas kompliziert.
Selbsttestaufgabe 11.2
Finden Sie für das SMALLTALK -System Ihrer Wahl hera us, wie die Zusammenhänge der Klassen
Object , Class und Metaclass sowie derer jeweiligen Metaklassen Object class , Class
class und Metaclass class sind. Benutzen Sie dazu die Methoden allSuperclasses ,
allSubclasses und isKindOf: . (Um zu testen, ob ein Objekt in einer Aufzählung, wie sie von
allSuperclasses und allSubclasses zurückgeliefert wird, enthalten ist, können sie die
Methode includes: verwenden.)
Die Klasse Class steht in der Vererbung shierarchie SMALLTALK s neben der
Klasse Metaclass . Gemeinsam erben sie von der Klasse Behavior (in
SMALLTALK -80 und direkten Derivaten indirekt, über die Klasse ClassDescription ), in der
endlich, neben vielen anderen Methoden, new und new: definiert sind. Man beachte, dass
diese Methoden als Instanzmethoden deklariert sind; da sie aber in der Vererbungshierar-
chie SMALLTALK s von den Metaklassen der Klassen geerbt werden (z. B. Object class ), Ursprung von
stehen sie in den Klassen als Klassenmethoden zur Verfügung. new und new: werden also
in der Praxis immer an Klassen geschickt.
ObjectObject class ClassMetaclass
Behavior
new und new:
als Instanzmethoden
new und new:
als Klassenmethoden
Nun ist es in SMALLTALK so, dass auch alle Metaklassen (Ebene 2) und die
Klasse Metaclass (Ebene 3) Subklassen von Object sein müssen. Dabei
komm t es natürlich zu einem fröhlichen Ebenenmix, der nur sehr schwer
nachzuvollziehen ist. Wenn Ihnen das Probleme bereitet, brauchen Sie sich keine Sorgen zu
machen, denn Sie haben einen guten Grund: Legt man nämlich wie schon in den Abschnit-
ten 7.3 und 9.1 eine mengentheoretische Interpretation von Klassen als Mengen ihrer I n-
stanzen und von Superklassen als Obermengen der Mengen, für die ihre Subklassen stehen,
zugrunde, dann ergibt sich, da Object class , die Metaklasse von Object , auch eine
Subklasse von Object sein muss , dass die Menge von Object in sich selbst enthalten sein
müsste , was aber aus theoretischen Gründen nicht möglich ist. Schon daran erkennt man,
dass beim Entwurf von SMALLTALK der pragmatische Gesichtspunkt der Vererbung im Vor-
dergrund stand und nicht etwa der konzeptuelle der Gene ralisierung.
ObjectObject class
ClassClass classMetaclass
BehaviorBehavior classMetaclass class
"
"69 Klassenhierarchie
Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Ka-
piteln dieser Kurse inheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von
allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher
als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht — sie ist
fast immer willkürlich. Im folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt
werden, dass ich persönlich eher nicht als Stilfrage einstufen würde, dass aber dennoch
häufiger in diesem Zusammenhang genannt wird.
Wie bereits in Kurseinheit 6 und (teilweise auch schon in Kurseinheit 2, Abschnitt 10.1) be-
merkt, ist die Vererbung Aushängeschild und Problemkind der objektorientierten Program-
mierung zugleich. Es verwundert daher nicht, dass sich eine ganze Menge von Program-
mierrichtlinien mit genau diesem Thema beschäftigen. Die meines Erachtens gewichtigste
aller Regeln zu diesem Thema ist jedoch:
Für JAVA lässt sich diese Regel auch als „deklariere jede Klasse entweder als abstrakt oder
als final“ formulieren. Der Grund dafür, dass nur die Blätter der Klassenhierarchie instanzi-
ierbar sein sollen, ist einfach: Wenn man mit der Funktionalität einer Klasse (bzw. genauer
und in diesem Fall wichtig, der Funktionalität der Instanzen einer Klasse) nicht zufrieden ist,
will man die Implemen tierung der Klasse ändern. Als Programmiererin möchte man diese
Änderung unabhängig von der Frage, ob davon auch andere Klassen betroffen sind, durch-
führen können. Deswegen wird man d ie Änderungen auch nur an der Klasse selbst und
nicht etwa an einer ihrer Superklassen durchführen. Betrifft der Änderungswunsch eine ge-
erbte Methode, so überschreibt man diese in der betreffenden Klasse nach seinen Vorstel-
lungen. Nur wenn eine eingehende Analyse der Superklasse und all ihrer Subklassen ergibt,
dass die gewünschte Änderung für alle sinnvoll ist und den Erwartungen der Klienten ent-
spricht, kann man darüber nachdenken, die Änderung in der Superklasse durchzuführen.
Wenn nun aber die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat,
dann ist man der Freiheit beraubt, nur für sich zu entscheiden — von jeder Änderung, die
man durchführt, muss man fürchten, dass sie sich auf andere Klassen ausbreitet und den
Vertrag dieser Klassen mit ihren Klienten bricht. (Siehe auch das Fragile -base-class-Problem
in Kapitel 55). Etwas subtiler, aber genau dasselbe Problem, ereilt die Designerin von Klas-
senbibliotheken, wenn sie beschließt, das Verhalten einer Klasse zu ändern: Selbst wenn sie
sich sicher ist, dass dies innerhalb der Bibliothek keine anderen als die gewünschten Aus-
wirkungen hat, so kann sie doch nicht sicher sein, dass irgend eine Verwenderin ihrer Bibli-
othek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung
erfährt, mit der sie nicht leben kann.
Nun ist aber, wie gerade erst ( Kapitel 66) erwähnt, einer der wichtigsten Gedanken der
Objektorientierung, existierenden Code, vor allem Bibliotheksklassen, per Vererbung wie-
derzuverwenden. Wenn die Biblioth eksdesignerin aber alle relevanten Klassen (das sind üb-
licherweise gerade die konkreten, also die instanziierbaren) final deklariert hat, dann ist das
nicht möglich. Eine einfache Konvention erlaubt jedoch, diese Beschränkung zu umgehen:
In der Biblioth ek wird einfach die Klasse, von der geerbt werden soll, als abstrakt deklariert
und per Vererbung eine Subklasse davon abgeleitet, die zunächs t keine Änderungen (Dif-
ferentia ) hinzufügt, dafür aber konkret (also instanziierbar) und auch final ist. Sollte die Bib-
liotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen
Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Biblio-
thek mit den Änderung en beglücken möchte, die Änderungen in der abstrakten Superklasse
durchführen. MMaacchhee aallllee SSuuppeerrkkllaasssseenn aabbssttrraakktt..
"
"35 Objekte und Typen
JAVA-Programme sind objektorientierte Programme — zur Laufzeit bestehen sie aus einer
Menge interagierender Objekte. Dabei ist JAVA stark typisiert: Jedes Objekt gehört zum Wer-
tebereich eines oder mehrerer Typen. Anders als in SMALLTALK gibt es in JAVA neben Objek-
ten auch Werte wie Zahlen, Zeichen und Wahrheitswerte, die keine Objekte sind.
In JAVA werden zunächst sechs Arten von Typen unterschieden: primitive
Typen , Klassentypen , Interfacetypen , Array -Typen, Aufzählungstypen
und Annotationstypen . Von Klassen - und Interfacetypen gibt es seit JAVA 5 auch paramet-
risierte Varianten, die denen STRONGTALK s stark ähneln (die JAVA-Generics stammen teilweise
von Autoren STRONGTALK s). Die primitiven Typen sind mit der Sprachdefinition festgelegt; es
sind dies byte , short , int, long , float , double , boolean und char . Sie unterscheiden
sich nicht sonderlich von denen gängiger, statisch typgeprüfter prozeduraler Sprachen. Alle
anderen Typen werden durch Typkonstruktion mittels entsprechender Sprachkonstrukte in
JAVA selbst definiert. Ein Teil dieser Typen ist jedoch mit der Sprachdefinition fest vorgege-
ben: So sieht JAVA für jeden primitiven Typ einen im wesentlichen gleichnamigen (mit Aus-
nahme von int und char bis auf Großschreibung) Referenztyp vor, dessen Werte jeweils
einen Wert eines entsp rechenden primitiven Typs aufnehmen können. Diese Typen, na-
mentlich Byte , Short , Integer , Long , Float , Double , Boolean und Character ,
nennt man deswegen Wrapper -Typen (sie wickeln gew issermaßen einen Wert eines primi-
tiven Typs ein). Weitere Typen, die die JAVA-Sprach definition voraussetzt, sind Object ,
String , Throwable , Error , Exception , RuntimeException und Thread . Diese wer-
den an entsprechenden Stellen unten weiter erläutert.
Genau wie in SMALLTALK müssen auch in JAVA die Objekte irgendwo herkommen. Neben
der Instanziierung von Klassen, wie Sie sie auch schon von SMALLTALK her kennen, gibt es
dafür auch in JAVA Literale.
"
"1.8 Aliasing
Wenn Variablen keine Objekte enthalten, sondern lediglich auf sie verweisen, wenn sie also
Verweissemantik haben, ist es möglich, dass mehrere Variablen gleichzeitig dasselbe Objekt
benennen. Das nennt man Aliasing . Das Aliasing ist eines der wichtigsten Phänomene der
objektorientierten Programmierung; zugleich ist es leider nur wenig als solches bekannt.
Versuchen Sie trotzdem, es sich stets bewusst zu machen — es wird Sie vor manch böser
Überraschung bewahren.
Aliase , also weitere Namen für ein bereits benanntes Objekt, entstehen
immer bei der Zuweisung. Daz u ist es notwendig, dass die Variable auf
der linken Seite Verweissemantik hat. Da in SMALLTALK die Semantik von Variablen nicht mit
der Variablendeklaration (s. Kapitel 19) festgelegt wird, sondern von der Art eines Objekts
abhängt, ist nicht immer klar, bei welcher Zuweisung ein Alias entsteht. Dabei kann beides,
die fälschliche Annahme von Verweissemantik bei tatsächlicher Wertsemantik und die
ren Bedeutung wir noch ausführlich ein gehen werden. Bis dahin kann die Leserin davon ausgehen,
dass true und false für die Booleschen Werte „wahr“ und „falsch“ stehen und nil für ein spe-
zielles Objekt, das meistens „kein Objekt“ repräsentieren soll. Entstehung von
fälschliche Annahm e von Wertsemantik bei tatsächlicher Verweissemantik, zu erheblichen
(und schwer zu findenden) Programmierfehlern führen.
Nach den beiden Zuweisungen
hat das eine Objekt, das der Compiler für #Smalltalk erzeugt, zwei Namen, nämlich x
und y.
Das Aliasing ist zunächst erwünscht: Da jedes Objekt nur einmal im Spei-
cher hinterlegt werden muss , ermöglicht es die extrem effiziente Infor-
mationsverarbeitung (es ist weder ein Kopieren notw endig, wenn ein Objekt weitergereicht
werden soll, noch müssen die Änderungen an den verschiedenen Kopien zusammengeführt
werden, die notwendig sind, wenn die Kopien immer noch dasselbe logische Objekt be-
zeichnen sollen). Doch diese Effizienz hat ihren Pre is.
Dass die Veränderung des durch eine Variable bezeichneten Objekts zu-
gleich die Veränderung der durch all seine Aliase bezeichneten Objekte
(die ja alle dieselben sind) bewirkt, kann nämlich unerwünscht, ja ein Programmierfehler
sein. So könnte man beispielswei se bei den beiden Zuweisungen
lediglich bezwecken wollen, dass Peter und Paul a zunächst gleich heißen, z. B. weil sie Ge-
schwister sind. Bei einer späteren Promotion Paulas fügt sie die Zeichen $D, $r und $. in
den ihren Nachnamen repräsentierenden String ein, ändert also das entsprechende Objekt.
Man hat nun sicher nicht beabsichtigt, dass das auch petersNachname betrifft, aber wenn
die Änderung an einer weit entfernten Stelle im Programm erfolgt, ist die Identität der von
petersNachname und paulasNachname benannten Objekte nicht mehr offensichtlich.
Tatsächlich hat man es dann mit einem recht subtilen und schwer zu findenden Program-
mierfehler zu tun. Deswegen (und aufgrund etwas überzeugenderer Bei spiele, die zu ver-
wenden aber noch mehr Vorbereitung bedarf ) sind in einigen SMALLTALK -Systemen alle auf
Basis literaler Repräsentationen erzeugten Objekte als unveränderlich markiert (wenn Sie es
nicht schon, wie beispielsweise Zahlen, von Haus aus sind), so dass Programmierfehler dieser
Art vermieden werden. Sollte wie im obigen Beispiel eine Zuweisung mit Wertsemantik be-
nötigt werden, so schreibt man statt Zeile 28 in SMALLTALK einfach
Dabei sorgt das hintangestellte copy dafür, dass von dem Objekt, das durch
petersNachname bezeichnet wird, eine Kopie angefertigt wird, also ein neues Objekt, das
dem alten gleicht (mehr zur Syntax und dazu, wofür copy steht, folgt unten). Nicht nötig
wird das Kopieren, wenn ich die Änderung durch die Zuweisung eines neuen Objekts be-
werkstellige, wie das beispielsweise in Beispiel
oder gar
der Fall ist (wobei das Komma hier für die String -Konkatenation steht) .
Fehler dieser Art sind häufig die Folge dessen, dass sich eine Programmiererin der aliasbil-
denden Wirkung der Zuweisung nicht bewusst war. Das ist insbesondere bei den Program-
miererinnen der Fall, die nicht mit der objektorientierten Programmierung großgeworden
sind, die insbesondere bei einer Zuweisung y := x das Kopieren des Inhalts der Variablen
auf der rechten Seite ( x) vermuten. Tatsächlich muss man in anderen Sprachen (wi e bei-
spielsweise PASCAL oder C) eine Variable explizit als Pointervariable deklarieren, um einen
Alias bilden zu können. In SMALLTALK , genau wie in JAVA und C#, ist Aliasing jedoch der
Regelfall und Kopie die Ausnahme. Wer das nicht verinnerlicht hat, schreibt höchstens zu-
fällig korrekte Programme.
"
"56 Das Problem der schlechten Tracebarkeit
Spätestens mit der Verfügba rkeit sog. Hochsprachen und den gleichzeitig immer größer
werdenden Programmen kam die Frage auf, was „gute Programmierung“ ausmacht. Eines
der Hauptprobleme schlechter Programmierung war schnell identifiziert: die große Diskre-
panz zwischen statischem, lin earem Programmtext und dynamischem, stark verzweigen-
dem und sich wiederholendem Programmablauf. Eine gute Programmiererin hatte ihre Pro-
gramme so zu schreiben, dass Programmtext und Programmablauf einander möglichst ähn-
lich waren, dass genauer die (statische) Struktur des Programms möglichst viele Rück-
schlüsse über seinen (dynamischen) Ablauf erlaubte. Man wollte also von den Programmie-
rerinnen Klartext.
Ebenso schnell wie das Problem wurde sein e Hauptverursacher in ausge-
macht: die Goto -Anweisung. Sie e rlaubt Sprünge von beliebigen Stellen
eines Programms an beliebige andere Stellen des Programms und durchbricht dabei auf
brutale Art und Weise das ungemein nützliche Lokalitätsprinzip von Programmen: Dinge,
die zusammengehören, stehen im Programmtext beieinander. So, und nur so, ist bei Inspek-
tion des Programmtextes unmittelbar klar, wie man an eine Stelle im Programm gelangt ist
und, mindestens ebenso wichtig, wie eine Va riable ihren Wert bekommen hat.
Zur Veranschaulichung soll die nachfolgende Abbildung dienen, die einen
Programmtext als eine Folge von Anweisungen stilisiert. Anweisungen
sind durch Kreise dargestellt, die (textuelle) Folge der Anweisungen im Programmtext durch
die kleinen Pfeile. Ohne besondere, den Kontroll fluss beeinflussende Anweisungen ent-
spricht die (dynamische) Reihenfolge der Ausführung der (statischen) Folge der Anweisun-
gen im Programmtext. Bei Betrachtung des stärker
umrandeten, mittleren Kreises (der entsprechenden Anweisung), z. B. während einer De-
bug-Sitzung, ist daher aus dem unmittelbaren Kontext heraus (der Ellipse; Lokalitätsprinzip!)
klar, welche Anweisung davor ausgeführt wurde und welche als nächstes drankommt. Alles
ist in bester Ordnung.
Handelt es sich nun bei einer der Anweisungen um ein Goto, dann ist die
Sachlage längst nicht mehr so klar. Man hat vielmehr die folgenden Fälle zu unterscheiden:
1. Die betrachtete Anweisung ist selbst ein Goto:
GoTo
In diesem Fall ist zwar klar, woher der Programm fluss kommt, und auch, wohin er
geht, letzteres aber nur mit einer gewissen Einschränkung — das Ziel ist nicht der
Nachbar im Programmtext, sondern befindet sich außerhalb des gewählten Kontex-
tes. Nun kann man den Kontext natürlich so wählen, dass er das Ziel enthält, und
kurze Sprünge sind vielleicht auch so innerhalb des betrachteten Kontextes; allge-
mein gilt aber, dass jede gewählte Lokalität durch einen Sprung verletzt werden
kann. Immerhin lässt sich aber das Ziel des Sprungs aus dem Kontext erkennen und
der Kontext entsprechend wechseln.
2. Die betrachtete Anweisung ist Ziel eines Gotos:
GoTo
Hier ist das Sachverhalt schon schwieriger. Der Programm fluss scheint bei Betrach-
tung des Kontextes genau wie im ersten Beispiel zu verlaufen. Wenn man den Kon-
text allerdings vergrößert, lernt man, dass die dynamische Vorgänger in der betrach-
teten Anweisung auch ein anderer sein kann. Der Kontext selbst gibt aber keinen
Hinweis darauf; zwar kann das Vorhandensein ein es Sprunglabels einen Hinweis
darauf geben, dass die so markierte Anweisung Ziel eines Gotos sein kann, sie muss
es aber nicht; in Sprachen wie BASIC beispielsweise (damals noch weit verbreitet), in
denen Zeilennummern gültige Sprungziele sind, muss jede A nweisung als mit einem
Label versehen betrachtet werden und kann somit Sprungziel von irgendwoher sein. Probleme des Goto
Außerdem kann eine Anweisung von verschiedenen Gotos angesprungen werden,
so dass unklar bleibt, welches die (zeitliche) Vorgängeranweisung war.89
3. Die be trachtete Anweisung ist unmittelbare Nachfolgerin eines Gotos:
GoTo
Hier ist zwar aus dem Kontext ersichtlich, dass die statische Vorgänger in nicht die
dynamische sein kann, ansonsten kann man aber nur mutmaßen, dass es sich viel-
leicht um toten Code handeln k önnte (also um Code, der niemals ausgeführt wird).
Es kann nämlich die Anweisung Sprungziel von Gotos außerhalb des Kontexts (wie
in allen anderen Fällen auch) sein.
Fazit: Die Verwendung von Goto -Anweisungen verursacht ein hohes Maß
an Nichtwissen bei der Interpretation von Quelltext. Speziell beim Debug-
ging von Programmen ist der Blick in den Quelltext des Programms so nur sehr bedingt von
Nutzen. Von daher, so der allgemeine Konsens, ist die Benutzung von Gotos zu vermeiden.
Wenn man also kein Goto benutzen darf, wie steuert man dann den Ab-
lauf von Programmen? Die sog. strukturierte Programmierung sieht
dafür neben der Sequenz von Anweisungen (ausgedrückt durch die un-
mittelbare Nachbarschaft im Programmtext) die Verzweigung, die Wiederholung und den
Unterprogrammaufruf vor. Von diesen behalten die ersten beiden das Lokalitätsprinz ip bei,
solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife, die damit
ausgedrückt wird, ausdehnt. Für den Unterprogrammaufruf gilt das jedoch n icht mehr:
Schon weil ein Unterprogramm in der Regel von mehreren Stellen eines Programms aus
aufgerufen werden kann und weil diese Stellen nicht automatisch denselben Kontext ha-
ben, wird hier das Lokalitätsprinzip durchbrochen. Dies ist aber unvermeidlich und man
tröstet sich damit, dass ein Unterprogramm, genauer eine Prozedur oder eine Funktion,
immer genau an die Stelle zurückkehrt, von der es aufgerufen wurde. Es ergibt sich also
anschaulich die folgende Situation:
GoSub
Return
Unterprogramm
Gotos eigentlich gar nicht. Vermeidung von
Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten
Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger
um die Return -Anweisung des aufgerufenen Unterprogramms handeln
muss . Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterpro-
gramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächlich e Parameter über-
geben wurden, und wenn zudem das Unterprogramm bekannte Vor - und Nachbedingun-
gen ei nhält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen
manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verur-
sacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein groß er
Nutzen gegenüber:
1. Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anwei-
sungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche
Aufrufkontexte gibt (das sog. Inlining , das manche Compiler aus Optimierungsgrün-
den durchführen).
Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie ge-
trennt untersuchen und verstehen kann.
Besonders der zweite Punkt ist wichtig: Aus Sicht der Programmiererin sollte es nämlich
reichen, zu wissen, was ein Unterprogramm tut, um es korrekt benutzen zu können. Sie
muss also insbesondere nicht in das Unterprogramm hineinschauen, also seine Anweisun-
gen inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umge-
kehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall
aufgerufen wird — es reicht dann, zu wissen, mit welchen Parametern es versorgt wird,
und die sind ihr per formale Paramete rdeklaration bekannt. (Voraussetzung dieser Argu-
mentation ist jedoch, dass es keine globalen Variablen gibt, die eine gegenseitige Beeinflus-
sung von Aufrufstelle und Unterprogramm an den tatsächlich en und formalen Parametern
vorbei erlauben. Diese globalen Variablen sind jedoch mindestens so sehr verpönt wie das
Goto.)
Bei der objektorientierten Programmierung hat man es zunächst mit einer
leicht veränderten Situation zu tun. Hier sind nämlich nicht allein das Ver-
meiden von doppeltem Code sowie die stufenweise Verfeinerung Krite-
rien für die Aufteilung in Unterprogramme, sondern auch die Disziplin,
jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert. Typische objektorien-
tierte Programme teilen daher die Implementierung größerer Funktionen nicht nur in klei-
nere auf, sondern verteilen diese auch noch über vi ele Klassen. Auch wenn es sich dabei Abwägung bei
stets nur um Unterprogrammaufrufe handelt, die allen obengenannten Anforderungen ge-
nügen, so erfolgen die zum Programmverstehen notwendigen Kontextwechsel doch in so
kurzer Folge, dass man schnell den Überblick darüber verliert.90
Nun ergibt sich aber mit der Einführung von dynamisch gebundenen Un-
terprogrammaufrufen, wie sie ja für die objektorientierte Programmie-
rung prägend sind, das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich
ist, wohin der Sprung geht: Wie bereits in Kurseinheit 1, Abschnitt 4.3.2 bemerkt, verbindet
das dynamische Binden den Unterprogrammaufruf mit der Verzweigung. Anschaulich be-
trachtet findet man im Quelltext die folgende Situation vor:
Return ReturnGoSub
Implementierung 1 Implementierung 2
Es ist an der Stelle der betrachte ten Anweisung nicht klar, von woher der in der Anweisung
zuvor angestoßene Unterprogrammaufruf zurückkehrt — es könnte von jeder Implemen-
tierung der im Gosub genannten Methode sein. Um das Sprungziel und damit die Return -
Anweisung, die unmittelbarer Vorgän ger war, zu identifizieren, muss man die Klasse des
Empfängerobjekts kennen, also die Klasse des Werts der Variable, auf der die Methode
aufgerufen wurde. Die ist aber in der Regel nur auf Basis einer vollständigen Programmana-
lyse bestimmbar, die sich nich t lokal durchführen lässt. Das Lokalitätsprinzip wird also durch
das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein.
Dieser Umstand hat dazu geführt, dass das dynamische Binden vo n Skep-
tikerinnen und Gegnerinnen der objektorientierten Programmierung
schon als eine Art Goto der 90er Jahre betrachtet wurde. Dieser Vergleich
ist jedoch nicht ganz fair, weil, genau wie beim statisch gebundenen Unterprogrammaufruf,
die Aufruferin ja gar nicht wissen muss , welche genauen Anweisungen als Antwort darauf
Im Single -step-Modus der IDE springt der Programmzähler wild zwischen den verschiedenen Metho-
den und deren Klassen hin und her und häufig ist es schon nach kurzer Zeit kaum mehr möglich, zu
rekonstruieren, wie man an die Stelle gekommen ist, an der man sich gerade befindet. Viele Pro-
grammiererinnen ertappen sich dann dabei, dass sie, wie in der Steinzeit der Programmierung, Print -
Anweisungen in ihre Programme ein bauen, die den Programmablauf in nicht -flüchtiger Form fest-
halten. Zahlreiche Frameworks bieten darüber hinaus Tracing - oder Logging -Funktionen, mit denen
es mit vergleichsweise wenig Aufwand möglich ist, den Programmablauf aufzuzeichnen und zu re-
konstruie ren. Aus der Betrachtung des Programmtexts ist dies nämlich meistens unmöglich. dynamisches Binden
ausgeführt werden müssen — es reicht, zu wissen, welchen Vertrag die a ufgerufene Me-
thode (das aufgerufene Unterprogramm) erfüllt. Dies sollte nach den Regeln des Subtyping
(Abschnitt 54.2) stets unabhängig vom v ertragerfüllenden Objekt sein.
Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder
kennen Sie ein Pr ogramm, in dem für jede dynamisch gebundene Methode Vor - und Nach-
bedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr
wohl interessant sein, was denn nun gen au in der aufgerufenen Methode passiert ist, z. B.
weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In die-
sen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen
Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle
man scha uen muss . Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor
dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen
oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen
Problemen.
Es ist wohl unbestritten, dass objektorientierte Programme schwerer zu
tracen und zu debuggen sind als prozedurale. Wie schon bei den statisch gebundenen Un-
terprogrammaufrufen (die ja ebenfalls ein Problem darstellen können) ist die Frage jedo ch,
ob das, was man durch das dynamische Binden hinzugewinnt , den Preis aufwiegt. Während
diese Frage jede für sich selbst entscheiden muss , so scheint die Antwort für viele Program-
miererinnen — weit mehr als eine Generation nach dem Aufkommen der Objektorientie-
rung und damit vor dem Hintergrund genügend praktischer Erfahrung — überwiegend po-
sitiv zu sein. M an darf aber auch die Neinsagerinnen nicht als Ewiggestrige abstempeln —
sie mögen gute Gründe haben.
"
"schnitt 51.5.2 ) — wenn sie falsch war, dann hat man halt nicht richtig programmiert. So
steht denn auch zu lesen:
Explicit type conversi on is best avoided. Using a cast suppresses the type
checking provided by the compiler and will therefore lead to surprises unless
the programmer was right.
Margaret A. Ellis und Bjarne Stroustrup
Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine
der großen Errungenschaften JAVAs gefeiert werden, dass es Type casts wenigstens zur Lauf-
zeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur
dynamischen Seite des Typsystems von C++.
"
"Kurseinheit 7: Objek torientierter Stil
Egal, wie formal sie auch sind: Programmiersprachen sind Sprachen und erlauben einer Au-
torin damit, sich auf eine persönliche Art und Weise auszudrücke n. Dabei bestimmt die
Ausdrucksweise nicht den Inhalt des Programms (seine Funktion), sondern seine Qualität,
also z. B. wie effizient ein gegebenes Problem damit gelöst wird oder wie verständlich die
Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat etwas
mit Schreibstil zu tun; neben ihr spielen aber auch noch andere Parameter in Stilfragen eine
Rolle, so z. B. Mode und Ästhetik (Eleganz).
So hat es fraglos in den letzten Jahrzehnten eine Wandlung in Stilfragen
gegeben, und zwar weg vom mathematisch -pregnanten hin zum prosa-
isch-verbosen Stil. Das folgende Beispiel soll davon einen Eindruck geben:
1556 PROGRAMM marriage(input,output);
1557 {Problem der stabilen Heirat}
1558 CONST n = 8;
1559 TYPE man = 1 .. n; woman = 1 .. n; rank = 1 .. n;
1560
1561 VAR m: man; w: woman; r: rank;
1562 wmr: array [man, rank] OF woman;
1563 mwr: ARRAY [woman, rank] OF man;
1564 rmw: ARRAY [man, woman] OF ra nk;
1565
1566 rwm: ARRAY [woman, man] OF rank;
1567 x: ARRAY [man] OF woman;
1568 y: ARRAY [woman] OF man;
1569 single: ARRAY [woman] OF BOOLEAN;
1570
1571 PROCEDURE print;
1572 VAR m: man; rm, rw: INTEGER;
1573 BEGIN rm := 0; rw := 0;
1574 FOR m := 1 TO n DO
1575 BEGIN write(x[m]:4);
1576 rm := rm + rmw[m,x[m]]; rw := rw + rwm[x[m],m]
1577 END ;
1578 writeln(rm:8, rw:4)
1579 END {print) ;
1580 mathema tisch -
pregnanter vs.
prosaisch -verboser
Stil There does not now, nor will there eve r, exist a programming language
in which it is the least b it hard to write bad programs .
1581 PROCEDURE try(m: man);
1582 VAR r: rank; w: woman;
1583
1584 FUNCTION stable: BOOLEAN;
1585 VAR pm: man; pw: women;
1586 i, lim: rank; s: BOOLEAN;
1587 BEGIN s := TRUE; i := 1;
1588 WHILE (i < r) AND s DO
1589 BEGIN pw := wmr[m,i] ; i := i+1;
1590 IF NOT single[pw] THEN
1591 s := rwm[pw,m] > rwm[pw,y[pw]]
1592 END ;
1593 i := 1; lim := rwm[w,m];
1594 WHILE (i < lim) AND s DO
1595 BEGIN pm := mwr[w,i] ; i := i+1;
1596 IF pm < m THEN s := rmw[pm,w] > rmw[pm,x[pm]]
1597 END ;
1598 stable := s
1599 END {stable} ;
1600
1601 BEGIN {try}
1602 FOR r := 1 to n DO
1603 begin w := wmr[m,r];
1604 IF single[w] THEN
1605 IF stable THEN
1606 BEGIN x[m] := w; y[w] := m; single[w] := FALSE;
1607 IF m < n THEN try(succ(m)) ELSE print;
1608 single[w] := TRUE
1609 END
1610 END
1611
1612 END {try);
1613 BEGIN
1614 FOR m := 1 TO n DO
1615 FOR r := 1 TO n DO
1616 BEGIN read(wmr[m,r]) ; rmw[m,wmr[m, r]] := r
1617 END;
1618 FOR w := 1 TO n DO
1619 FOR r := 1 TO n DO
1620 BEGIN read(mwr[w,r]); rwm[w,mwr[w,r]] := r
1621 END;
1622 FOR w := 1 TO n DO single[w] := TRUE;
1623 try(1)
1624 END .
Es hand elt sich dabei um ein PASCAL -Programm zur Lösung des Problems der stabilen Heirat,
wie es in dem Klassiker „Algorithmen und Datenstrukturen“ von NIKLAUS WIRTH nachzulesen
ist. Eine mir leider entfallene Quelle soll übrigens gesagt haben, eine Untersuchung habe
hervorgebracht, dass ein bedeutender Anteil aller Variablen in Programmen „i“ heiße. Nun
wurden in obigem Beispiel die Variablen nicht „i“, sondern „r“, „m“, „w“ usw. genannt,
aber das gr undlegende Problem bleibt das gleiche: Man muss sich schon ziemlich in das
Programm bzw. den dazugehörenden Text vertiefen, um zu erfassen, wofür die Variablen
stehen.
Real programmers can write Fortran in any language.
Heute ist es üblich, Bezeichner (Namen für Module, Typen, Variablen, Pro-
zeduren und Funktionen) in einem Programm so zu wählen, dass Kom-
mentare bzgl. der Bedeutung des jeweiligen Programmelements unnötig sind, da sie nicht
viel mehr ausdrücken können, als es der Bezeichner in seinem jeweiligen Kontext ohnehin
tut. Dies geht sogar so weit, dass Leute wie Kent Beck (Mitinitiator und Verf echter des sog.
Extreme Programming , SMALLTALK -Veteran) meinen, ein gut geschriebenes objektorientier-
tes Programm bräuchte gar keine Kommentare. Dem möchte ich entgegenhalten, dass
manchmal die Lösung eines Problems in seiner verständlichsten Form um viele s uneleganter
ist als eine, die mit einer gewissen Raffinesse daherkommt, sich dafür aber nicht jeder un-
mittelbar erschließt. In solchen Fällen ist die Versuchung groß, sich für die geistreichere Va-
riante zu entscheiden und sie, für diejenigen Leserinnen , die einer nicht auf Anhieb folgen
können, mit einem erklärenden Kommentar zu versehen. Nicht zuletzt sind es ja gerade die
alles andere als offensichtlichen Algorithmen, die ihren Autorinnen zu Berühmthei t verhol-
fen haben, und wer würde nicht gern hier und da eine eigene Marke setzen. Kryptische
Namen zu verwenden ist jedoch niemals ein Zeichen von Genialität.
Wir kommen also gleich zur Stilregel Nummer 1 der objektorientierten Programmierung.
"
"50.3.3 Ereignisse (Events)
Viele Applikationen, insbesondere solche mit GUI, benötigen neben der direkten Kommu-
nikation z wischen Objekten, die sich kennen (die ja durch Nachrichtenaustausch bzw., je
nach Diktion, durch Methodenaufrufe bewerkstelligt wird), auch eine Kommunikation mit
unbekannten. Die Problematik hatten wir im Kontext von SMALLTALK bereits besprochen
(Abschni tt 14.3 in Kurseinheit 1).
Nun kommt dieses Problem so häufig vor, dass man sich bei MICROSOFT
dafür entschieden hat, es zumindest teilweise von der Ebene der Pro-
grammierung (wo es in Form eines sog. Patterns abgehandelt wird; mehr dazu in Kurs
01853) auf die Ebene der Programmiersprache zu heben (in SMALLTALK , wo diese Unter-
scheidung nicht so ausgeprägt ist , war das Problem ja mitte ls einer Implementierung der
benötigen Mechanismen in der Klasse Object , von der alle anderen erben, gelöst worden).
Es wurde zu diesem Zweck das Konstrukt des Events (Ereignisses) eingeführt, ü ber das sog.
Event handler aktiviert werden können. Dabei sind die Event handler in Abschnitt 50.4.1
skizzierte sog. Delegates . Leider ist die mit Deklaration und Registrierung von Event handlern
sowie der Verbreitung von Ereignissen verbundene Syntax von C# nach Ansicht des Autors
dieses Textes komplett unleserlich geraten, so dass hier auf eine weitergehende Befassung
mit dem Thema verzichtet wird.
"
"4.2 Anweisungen
Anweisungen spezifizieren die Schritte, in denen ein Programm ausgeführt wird. In SMALL-
TALK sind alle Ausdrücke, die nicht Bestandteil von anderen Ausdrücken sind, Anweisungen.
Während ihnen in JAVA und C# dazu noch ein Semikolon hintangestellt werden muss, ist
Vergleichbares in SMALLTALK nicht nötig.
Folgen von Anweisungen werden in SMALLTALK durch einen Punkt ge-
trennt. Dabei handelt es sich (genau wie in PASCAL oder EIFFEL) um ein
Trennzeichen und nicht (wie in den von C abgeleiteten Sprachen wie JAVA oder C# ) um
einen Teil der A nweisung selbst. Der Punkt am Ende einer Anweisung darf also fehlen, wenn
keine weitere Anweisung folgt. Ansonsten entspricht die Wahl des Punktes dem Vorsatz
SMALLTALK s, der natürlichen Sprache möglichst ähnlich zu sein. So ist auch die Wahl des
Semikolon s zur Kaskadierung von Nachrichtenausdrücken zu sehen. mehrstellige
Die einzige andere Form der Anweisung in SMALLTALK ist die Return -Anweisung . Auf sie
werden wir im Zusammenhang mit Methoden im nächsten Kapitel noch ausführlicher zu
sprechen kommen. Sie besteht in SMALLTALK aus dem Sonderzeichen ^ (ursprünglich , je-
doch genau wie  auf den meisten Tastaturen nicht verfügbar), gefolgt von einem Aus-
druck. Die Return -Anweisung „retourniert“ das Objekt, zu dem dieser Ausdruck auswertet.
Da alle anderen Anweisungen Ausdrücke sind, die zu einem Objekt auswerten, brauchen
Methoden (Abschnitt 4.3) und Blöcke (Abschnitt 4.4) in SMALLTALK keine Return -Anweisun-
gen, um ein Objekt zurückzuliefern; sie liefern dann das Objekt, zu dem die letzte Anwei-
sung auswertet.
"
"4.3.5 Operationen auf zustandslosen (unveränderlichen) Objekten
Auf unveränderlichen Objekten ausgeführte Methoden oder Operationen können deren
Zustand naturgemäß nicht ändern. So ändert beispielsweise die Addition von Zahlen nichts
an ihren Operanden, sondern liefert als Ergebnis ein anderes Objekt. Derartige Methode n
(oder Operationen) sind also klassische Funktionen: Sie berechnen anhand eines oder meh-
rerer Argumente (wovon eines das Empfängerobjekt ist) ein Ergebnis, und das ohne Seiten-
effekte wie die Zustandsänderungen der Argumente.
Bei anderen Objekten wie z. B. den Punktobjekten des Abschnitts 4.3.4 ist es hingegen
fraglich, ob Operationen wie di e Addition den Zustand des Empfänger s verändern oder ein
neues Objekt zurückgeben sollen: Bei einer Veränderung des Empfängers würde die Addi-
tion dann eher einer Translation gleichkommen (weswegen die entsprechende Methode
auch so genannt werden sollte). Um jedoch zu zeigen, wie man neue Obje kte erzeugen und
zurückgeben kann, fehlt uns hier noch einiges; wir kommen erst in Abschnitt 7.3 darauf
zurück. Implementations -
"
"36.1 Klassendefinitionen
Eine einfache Klassendefinition sieht in JAVA wie folgt aus:
Die geschweiften Klammern sind in JAVA (wie auch in C und allen syntaktisch davon abge-
leiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüssel-
wörtern begin und end von PASCAL. Die spitzen Klammern kennzeichnen auch hier wieder
metasyntaktische Variablen (also Platzhalter für richtige Namen). Klassen und Dateien
Die obige Klassendefinition teilt sich in die Angabe von Instanzvariablen ,
die in JAVA Felder genannt werden, und Instanzm ethoden , die in JAVA
Beide werden, der Tradition von C++ folgend, zusammenfassend auch als Member be-
zeichnet, wobei sich Member (das englische Wort für ein Element einer Menge) a uf die
Klassendefinition (oder Intension ; vgl. Abschnitt 7.2 in Kurseinheit 1) bezieht . Kon-
struktoren zählen nicht zu den Membern; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in JAVA auch
geschachtelte sowie sog. innere Klassendefinitionen besitzen. Diese Klassendefinitionen
gelten dann ebenfalls als Member der umschließenden Klasse. Sie sind vor allem dann sinn-
voll, wenn man ausdrücken will, dass die Existenz der inneren Klasse ohne die der äußeren
sinnlos wäre. So ist es beispielsweise üblich, wenn man verzeigerten Listen implementiert,
die Klasse der Listenelemente, deren Instanzen neben dem eigentlichen Inhalt auch noch
einen oder mehrere Zeiger aufnehmen müssen, innerhalb der Klasse der Liste zu definieren,
denn diese Listenelemente wird man kaum außerhalb einer Liste verwenden (und ihre Klasse
auch gar nicht kennen) wollen. Innere Klassen werden zudem immer im Kontext von Instan-
zen ihrer äußeren Klasse(n) instanziiert; Instanzen innerer Klassen liegen somit „innerhalb“
von Instanzen ihrer äu ßeren Klasse(n), auf die sie mit einem Outer this genannten Kon-
strukt zugreifen können.
Member können auch mit dem Zusatz static deklariert werden. Dabei
bedeutet static für so deklarierte Felder und Methoden, dass sie sich
nicht auf Objekte beziehen (die ja dynamische Gebilde sind), sondern auf die Klasse selbst,
in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden . Da in JAVA
im Gegensatz zu SMALLTALK Klassen se lbst keine Objekte, sondern während der Pro-
grammausführung dauerhaft existierende, unveränderliche Gebilde sind, die nicht in Vari-
ablen gespeichert werden können, werden als static deklarierte Member auch nicht dy-
namisch gebunden .
Achtung: Man könnte im Fall von static deklarierten Feldern meinen,
dass diese dadurch zu Konstanten würden; das ist aber nicht der Fall.
Dazu dient in JAVA das Schlüsselwort final , das für Variablen aussagt, dass ihnen genau
einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu brauchte man im schlüssel-
wortlosen SMALLTALK für Konstanten noch konstante Methoden (Abschnitt 4.3.6 ). Auf Me-
thoden angewandt bedeutet final , dass diese nicht in Subklassen überschrieben werden
dürfen; mehr dazu im nächsten Abschnitt.
"
"50.4.3 Generizität in C#
Genau wie in JAVA entspricht in C# zunächst jeder Klasse und jedem Interface ein Typ. Mit
der Version 2.0 ist C# aber ebenfalls generisch geworden. Genauer gesagt erlaubt C# so-
wohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von
Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus:
die für unbeschränkte untersc heidet sich nicht von der JAVAs. Parametrisch definierte Klas-
sen und Interfaces spezifizieren jeweils eine (potentiell unendliche) Menge von Typen, die
durch Einsetzen konkreter ( tatsächlich er) Typparameter in die Typvariablen entstehen. C#
erlaubt zudem ( genau wie JAVA; s. Abschnitt 43.5 in Kurseinheit 4), den tatsächlich en
Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler
aus den Typen der Argumente erschließen kann ( Typinferenz ).
Auch wenn sich die Generics von C# auf den ersten Blick nicht groß von
denen JAVAs zu unterscheiden scheinen, so verbirgt sich hinter der Ober-
fläche doch ein a nderer Mechanismus. Während JAVA die Typparameter
grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type
erasure ), instanziiert C# im Fall von Wertt yp-Parametern (also int, float etc., aber auch
die per struct definierten Typen ) jede generische Klasse für jeden verwendeten Typ ein-
mal, erzeugt also alternative Implementierungen (sog. Typexpansion ). Dies hat den Vorteil,
dass diese Implementierungen ohne Boxing /Unboxing auskommen und vom JIT -Compiler
per Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird
der Code jedoch (wie in JAVA) nur einmal erzeugt. Gleichwohl bleibt die generische Typin-
formation in C# auch zur Laufzeit erhalten und kan n per Reflection abgefragt werden.
Genau wie in JAVA gibt es in C# beim Subtyping von Containern (wie z. B. Collections ) ein
Varianzproblem: Collection<A> und Collection<B> sind auch d ann nicht zuweisungs-
kompatibel, wen A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch
Zuweisungskompatibilität herzustellen, sieht C# keine spezielle Annotation der Benutzung mangelnde
Überschreibbarkeit
expliziter Interface -
eines Typs wie in JAVA vor, sondern eine Annotation der Definition des Typs76: Dem ko - bzw.
kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die
Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen V erwe ndungen des Typs
die gleichen. Übrigens : Für Arrays in C# gilt dasselbe wie in JAVA: Sie sind kovaria nt, das
Schreiben in ein Array kann aber zu einem Laufzeittypfehler führen, der in C# „Array Type-
Mismatch Exception “ heißt.
"
"1.5 Variablen
Weil Literale immer die gleichen Objekte repräsentieren, reichen sie zum Programmieren
nicht aus. Was man vielmehr auch noch benötigt, sind Namen , die zu verschiedenen Zeit-
punkten verschiedene Objekte bezeichnen können6, die sog. Variablen .
Genau wie ein Literal steht eine Variable in einem Programm für ein Ob-
jekt. Anders als bei Literalen wird aus einer Variable jedoch kein Objekt e rzeugt: Sie ist le-
diglich ein Name für ein bereits existierendes Objekt. Dazu kommt, dass eine Variable zu
unterschiedlichen Zeitpunkten für unterschiedliche Objekte stehen kann (deswegen der
Name „Variable“!). Es können zudem Variablen mit unterschiedlich en Namen für dasselbe
Objekt stehen, das damit gewissermaßen verschiedene Namen hat (die sog. Aliase ; s. Ab-
schnitt 1.8). Wir werden daher im folgenden davon sprechen, dass Variablen Objekte be-
nennen oder bezeichnen .
in der objektorientierten, steht ein Name immer für dasselbe Objekt. Quintessenz
Variable vs. Literal ZZwweeii OObbjjeekkttee kköönnnneenn zzwwaarr gglleeiicchh,, aabbeerr nniiee ddaasssseellbbee sseeiinn,, ooddeerr eess ssiinndd nniicchhtt zzwweeii OObb--
jjeekkttee,, ssoonnddeerrnn eeiinnss!! „„DDaass gglleeiicchhee““ uunndd „„ddaasssseellbbee““ ssiinndd aauucchh iinn ddeerr oobbjjeekkttoorriieennttiieerrtteenn PPrrooggrraammmmiieerruunngg nniicchhtt
ddaass gglleeiicchhee ((uunndd sscchhoonn ggaarr nniicchhtt ddaasssseellbbee))!!
"
"14 Verhalten für alle Objekte
In der Klasse Object ist das Protokoll definiert, das allen Obj ekten gemein ist, d. h., für das
alle Klassen Methodendefinitionen haben, und zwar entweder eigene oder geerbte.
Object gibt zu diesem Zweck Standardimplementierungen vor, die von den meisten Ob-
jekten direkt übernommen werden können (und nur von den wenigs ten überschrieben wer-
den müssen). Dazu zählen z. B. die bereits mehrfach erwähnten isNil und notNil (die
nur von UndefinedObject überschrieben werden) sowie zahlreiche weitere Typtests
(isInteger , isFloat usw.). Daneben gibt es auch noch eine ganze Reihe a nderer Me-
thoden, die zu kennen es sich lohnt.
"
"3.2 Kapselung
Die Unterscheidung von lokalen und globalen Variablen aus Ab-
schnitt 1.5.2 dient u. a. dem Verbergen von Geheimnissen (das sog. Ge-
heimnisprinzip engl. auch Information hiding genannt) , genauer von Implementati-
onsgeheimnissen . So ist es fast immer sinnvoll, die Struktur zusammengesetzter Objekte
vor den sie benutzenden Objekten zu verbergen, damit man diese Stru ktur später ändern
kann, ohne dass die benutzenden (abhängigen) Objekte davon betroffen wären. Derartige
Änderungsabhängigkeiten werden verhindert, wenn die Variablen von außen gar nicht zug-
reifbar sind, was für lokale Variablen, die ja von außen unsichtba r sind, automatisch der Fall
ist.
Vom Geheimnisprinzip abzugrenzen ist der Begriff der Kapselung , den
man mit der objektorientierten Programmierung verbindet: Ein Objekt soll
seinen Zustand kapseln, so dass dieser nur von ihm selbst geändert werden kann. Ander s
als beim Information hiding geht es bei der Kapselung also nicht um Änderungen des Auf-
baus von Objekten, sondern um Änderungen ihres Zustandes . Leider lässt sich die Kapse-
lung nicht mit denselben Mitteln wie das Geheimnisprinzip umsetzen: Aufgrund des Ali-
asing kann ein Objekt, dessen einer Name (beispielsweise aufgrund des Geheimnisprinzips)
unsichtbar ist, über einen anderen zugreifbar sein, oh ne dass der erste Name etwas dagegen
machen könnte. Über lokale Instanzvariablen kann ein Objekt also verbergen, welche Ob-
jekte es kennt; es kann aber nicht verhindern, dass andere Objekte diese Objekte auch ken-
nen und, ohne sein Wissen, manipulieren. Es i st somit wegen der etwaigen Existenz von
Aliasen nicht möglich, dass ein Objekt seinen inneren Aufbau vor der Außenwelt abkapselt ,
es sein denn, es hat ganz spezielle Vork ehrungen dafür getroffen. Da diese Vorkehrungen
(derzeit noch) in keine gängige objektorientierte Programmiersprache eingebaut sind15,
sondern explizit programmiert werden müssen, werden wir uns hier (in dieser Kurseinheit)
nicht weiter damit beschäftigen; eine weitergehende Betrachtung erfolgt in Kapitel 58 von
Kurseinheit 6).
"
"27 Typumwandlungen
Zuweisungskompatibilität unter Subtyping erlaubt also die Zuweisung von Objekten eines
Subtyps an Variablen eines Supertyps. Für die statische Typprüfung ergibt sich dara us kein
Problem, weil sichergestellt ist, dass die Subtypen alle Eigenschaften ihrer Supertypen erhal-
ten, so dass keine Typfehler auftreten können. Für die Programmiererin ergibt sich aber
manchmal das Problem, dass sie ein Objekt, auf das eine Variable eines Supertyps verweist,
wie ein Objekt seines tatsächlichen Typs verwenden möchte, in der Regel, weil sie eine Me-
thode darauf aufrufen möchte, die der Supertyp nicht hat. Genau diesen Methodenaufruf
würde die Typprüfung aber zurückweisen. Attraktivität der
Für diesen Zweck gibt es die Möglichkeit der Typumwandlung (engl. type cast ). Eine Ty-
pumwandlung ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Va-
riable oder eines Methodenaufrufs) in einen vorgegebenen konvertiert wird. Mit dem Ob-
jekt, für das der Ausdruck steht, passiert dabei gar nichts — es wird lediglich der Compiler
(bzw. der Type checker) davon überzeugt, dass der Ausdruck den bei der Umwandlung
angegebenen Typ hat. Sollte sich zur Laufzeit herausstellen, dass das nicht der Fall ist, k ann
ein Laufzeittypsystem — soweit vorhanden — dies bei seiner dynamischen Typprüfung be-
merken und ggf. einen entsprechenden Fehler melden (vgl. die Anmerkungen daz u in Ka-
pitel 18).
Typumwandlungen können grundsätzlich in verschiedene Richtungen er-
folgen: zu Supertypen, zu Subtypen oder zu solchen, die weder Super -
noch Subtyp des Ausgangstyps sind. Man spricht entsprechend von Up cast , Down cast
oder Cross cast . Up casts sind immer typsicher, Down casts und Cross casts nicht. Down
casts sind relativ häufig; sie kommen vor allem dort vor, wo kein parametrischer Polymor-
phismus ( Kapitel 29) zur Verfügung steht oder wo ein Objekt seinem tatsächlic hen Typ ent-
sprechend behandelt werden soll . Cross casts sind eher selten; in der interfacebasierten
Programmierung (s. Abschnitt 28.2) stehen sie für einen Rollenwechsel eines Objekts .
Nun sind Typumwandlungen entweder überflüssig oder unsicher. Man
sollte daher versuchen, auf sie zu verzichten. Wo unverzichtbar, sollten
Typumwandlungen mit einem Typtest abgesichert werden. Dabei wird zur Laufzeit geprüft,
ob das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat.
Ist das nicht der Fall, sollten die Teile des Programms, die den bei der Typumwandlung ge-
nannten Typ voraussetzen, nicht ausgeführt werden. Sie werden in späteren Kapiteln zu
den einzelnen Programmiersprachen noch Beispiele für diese Praxis zu sehen bekommen.
"
"13.2.1 Dictionaries
Dictionaries repräsentieren sog. qualifizierte Beziehungen, das sind solche, bei denen jedes
Element der Beziehung durch einen Qualifizierer eindeutig bestimmt wird. Der Qualifizierer
heißt auch Schlüssel (engl. key; vergleichbar mit dem Primärschlüssel relationaler Datenban-
ken), das qualifizierte Element der Beziehung nennt man auch Wert (engl. value ). Ein Ele-
ment einer qualifizierten Beziehung besteht also gewissermaßen aus einer Assoziation eines
Schlüssels mit einem Wert. Der Clou an der Implementierung von Diction aries ist, dass man
Werte unter ihren Schlüsseln extrem schnell (im Idealfall ohne jede Suche) auffinden kann.
Das wird heute fast immer über sog. Hashing erreicht. Weitere nützliche
Die Klasse Dictionary hat für die Programmi erung besondere Bedeu-
tung: Sie realisiert sog. Assoziativspeicher, also Speicher, bei dem auf eine
Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch
Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK -System selbst häufig
verwendet. So werden z. B. Methoden in Dictionaries hinterlegt (wobei der Nachrichten-
selektor die Rolle des Schlüssels spielt und als Wertobjekt die kompilierte Methode gespei-
chert ist). Aber auch andere Arten von Collections lassen sich mit Hilfe von Dictionaries sehr
einfach realisieren: So kann man die Klasse Bag beispielsweise wie folgt implementieren:
Klasse Bag
Superklasse Collection
Klassenmethoden
benannte Instanzvariablen elements
indizierte Instanzvariablen nein
Instanzmethoden
Dabei wird einfach die Anzahl der Vorkommen eines Elements (repräsentiert durch den for-
malen Parameter anObject ) der Bag, solange diese nicht Null ist, in einem Dictionary unter
dem Element als Schlüssel gespeichert.
Man beachte hierbei, dass Bag die Klasse Dictionary nutzt, ohne von
ihr zu erben. Stattdessen hält sich jede Instanz von Bag eine Instanz von Dictionary als
Sklavin, die für sie den Dienst verrichtet. Man spricht hier auch von einer Delegation44; da
gation sprechen würde. Die Delegation übernimmt nämlich in den prototypenbasierten objektorien-
tierten Programmiersprachen tatsächlich die Funktion der Vererbung, wobei insbesondere die Pseu-
dovariable self in den delegierten Methoden die gleiche Bedeutung wie bei einer geerbten Me-Klasse Dictionary
die Delegation auf Instanzebene stattfindet und zudem dynamisch (also nachdem eine In-
stanz erzeugt wurde) eingerichtet werden kann und da sie zudem von Fragen der Genera-
lisierung/Spezia lisierung völlig befreit ist, erfreut sie sich in der objektorientierten Program-
mierung großer Beliebtheit.
Je länger Sie in SMALLTALK programmieren, desto häufiger werden Sie
feststellen, dass Sie durch Verwendun g eines Dictionaries Ihren Code
deutlich vereinfachen können. Tatsächlich erlauben es Dictionaries (bzw.
der von ihnen realisierte Assoziativspeicher ), Assoziationsketten, die Grundlage vieler
menschlicher Denkprozesse sind, direkt in einem Programm nachzubilden. Fragen Sie sich
also, wann immer Sie es mit einer Menge von Objekten zu tun haben, wie Sie auf die Ele-
mente der Menge zugreifen wollen; wenn dies über einen Schlüssel erfolgt, dann ist
Dictionary die Klasse Ihrer Wahl.
Es darf übrigens der Schlüssel eines in einem Dictionary gespeicherten
Objekts ruhig ein Attribut (der Inhalt einer Instanzvariable) des Objekts sein; dies kommt
sogar recht häufig vor. Beispielsweise wird man Personen in einem Dictionary unter ihrem
Nachnamen oder einer Ausweisnummer speichern. Allerdings sollte dieses Attribut dann
unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch un ter
dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden
wird.
"
"39.1 Klassen und Pakete als Module
Klassen haben in JAVA mehrere Fun ktionen: Neben der offensichtlichen, der Vorlage für die
Erzeugung von Objekten, liefern sie auch noch Typen eines Programms und dienen der
Modularisierung.
Pakete hingegen dienen der Sammlung von Klassen und sind zugleich Namensräume für sie
(keine zwei K lassen innerhalb eines Pakets dürfen gleich heißen). Außerdem gelten für Klas-
sen innerhalb eine Pakets laxere gegenseitige Zugriffsbeschränkungen als für Klassen aus
verschiedenen Paketen. Zwar können Pakete hierarchisch organisiert sein, aber diese Orga-
nisation hat keine Bedeutung. Insbesondere erlauben Pakete keinen privilegierten Zugriff
auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen kön-
nen, bedarf es expliziter Import -Deklarationen unter Nennung der jeweiligen Paketna men.
Die Zugreifbarkeit von Klassen oder Typen und den Elementen ihrer D e-
finition (den Membern) wird in JAVA durch sog. Zugriffsmodifikatoren
(engl. access modifiers ) eingeschränkt .64 Es sind dies private , protected , public sowie
das sog. Package local , für das es kein Schlüsselwort gibt und das in Klassen bei Fehlen eines
der drei anderen angenommen wird (bei Interfaces wird public angenommen) . Innerhalb
der Klasse selbst sind alle Elemente seiner Definition zugreifbar , innerhalb ihrer Subklassen
die, die public oder protected deklariert wurden, innerhalb der Klassen desselben Pa-
kets alle, die public , protected oder ohne Zugriffsmodifikator dek lariert wurden, und in
anderen Paketen nur noch die, die public deklariert wurden. Faktisch werden Typdefiniti-
onen somit relativ: Was ein Typ anbietet, hängt nicht nur vom Typ selbst ab, sondern auch
davon, wo er verwendet wird. Konzeptionell hat die mit e inem Typ gemeinsam deklarierte
Zugriffsbeschränkung jedoch nichts mit dem Typ zu tun, sondern ist vielmehr die Schnitt-
stellenspezifikation eines Moduls , wobei das Modul die Klasse ist.
Auf die Bedeutung von Klassen als Module gehen ich in Kapitel 59 von
Kurseinheit 6 noch genauer ein. Hier schauen wir uns noch kurz die kon-
kreten Auswirkungen der Zugreifbar keitsbeschränkungen an:
net. Sichtbarkeit bezieht sich in JAVA aber auf lexikalische Scopes; sie wird durch Hiding, Shadowing
und Obscuring eingeschränkt (und kann dann bisweilen über Qualifizierer wiederhergestellt werden). Zugriffs -
modifikatoren
Beispiel für Zugriffs -
Auf einer per A a deklarierten Variable sind abhängig davon, innerhalb welcher Klasse die
Deklaration steht, die folgenden Elemente zugreifbar (ergeben die folgenden Ausdrücke
keine Typfehler):
 in Klasse A selbst: alle
 in Klasse B: a.i, a.j, a.k, a.m() , a.n() und a.o()
 in Klasse C: a.i und a.m()
 in Klasse D: a.i, a.j, a.m() und a.n()
Die Verquickung von Typ und Zugriffsbeschränkung (Schnittstelle) ist
etabliert und kommt auch in anderen Sprachen vor (z. B. EIFFEL, C# und
C++). Sie hat den Vorteil der sprachlichen Knappheit (Typ - und Schnitt-
stellendeklaration in einem) und den Nachteil, dass die Zugriffbeschrän-
kungen nur sehr grob eingestellt werden können — insbesondere ist es nicht möglich, dass
sich zwei (inhaltlich eng zusammengehörende) Klassen gegenseitig einen freieren Zugriff
gestatten als allen anderen, es sei denn, man packt diese beiden in ein Paket.65 Außerdem
hat sie den Nachteil, dass zwei unterschiedliche Konzepte der Programmierung zusammen-
gewo rfen und dadurch von Programmiererinnen u. U. nicht mehr als unterschiedlich wahr-
genommen werden. JAVA-Compiler unterscheiden aber immerhin zwischen Typ fehlern und
Zugriffsfehlern (z. B. „is undefined “ vs. „ is not visible “ in ECLIPSE , wobei letzteres freilich „ is
not accessible “ hätte heißen müssen) .
"
"63 Formatierungskonventionen
Neben den reinen Namenskonventionen einigt man sich h äufig auch auf Formatierungs-
konventionen (zusammen mit Namenskonventionen und anderen Richtlinien englisch als
coding conventions , deutsch oft auch, und etwas zu allgemein , als Programmierstil bezeich-
net). Diese regeln so Dinge wie Einrückungen und an welchen Stellen Zeilenumbrüche, Leer-
zeilen und Leerzeichen einzufügen sind. Sie dienen damit ebenfalls der besseren Lesbarkeit.
Formatierungskonventionen sind aber nicht nur eine Richtschnur für die
Einzelne, die sich vielleicht unsicher ist, ob bzw. wo sie ein Leerzeichen
einfüg en soll — sie vermeiden auch den Effekt, dass jede Programmiere-
rin im Team ihre eigenen Vorlieben pflegt, was in der S pitze dazu führt, Interfaces
gezielter Einsatz der
Muttersprache
Formatierungskon-
ventionen zur Ver-
meidung unprodukti-
ver Anpassungen White space contributes as much to the effect produced by a software text as
silence to the effect of a musical piece.
dass wenn eine Programmiererin den Code einer anderen anfasst , sie zunächst einmal damit
beginnt, diesen so zu formatieren, dass er ihren Lesegewohnheiten entspricht. Die ur-
sprüngliche Autorin reagiert natürlich empört und wird nichts anderes tun, als dies bei
nächster Gelegenheit wieder rückgängig zu machen, sprich zu ihren eigenen Vorlieben zu-
rückzukehren. Dies ist alle s andere als produktiv.
Ein wirksames Gegenmittel gegen solch Energieverschwendung sind au-
tomatische Codeformatierer, die auf Knopfdruck bestimmte Codierungs-
konventionen umsetzen. Wo immer verfügbar, sollte man sich zur Angewoh nheit machen,
diese auch einzusetzen, selbst wenn man allein arbeitet, schon um sich mit der Entwicklung
des persönlichen Programmierstils nicht zu weit von dem, was allgemein üblich ist, zu ent-
fernen. Die Programmierung ist nicht geeignet, Individualität zum Ausdruck zu bringen, ge-
schweige denn, sie voll auszuleben.
"
"11.2 Mechanismus der Vererbung von Superklassen auf Subklassen
Es stellt sich die Frage, wie der Mechanismus der Vererbung genau umgesetzt wird. Eine
Möglichkeit wäre z. B., die Definition einer Superklasse per Kopieren und Einfüg en auf ihre
Subklassen zu übertragen. Das wäre zwar möglich und würde auch die Semantik der Ver-
erbung korrekt wiedergeben, würde aber das (technische) Problem mit sich bringen, dass
bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müss-
ten.
Eine weitere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch je eine Instanz
aller ihrer Superklassen mit zu erzeugen und diese Instanzen zu einer z u vereinen. Diese
Umsetzung der Vererbung steht jedoch mit dem Konzept der Identität von Objekten in
Konflikt: Ein Objekt einer Subklasse hätte auf einmal mehrere Identitäten, und zwar eine für
sich selbst und eine pro Superklasse, von der sie erbt. Auch d as wäre problematisch .
Stattdessen wird die Vererbung in SMALLTALK und vielen anderen objekt-
orientierten Programmiersprachen als ein Aufteilen der Klassendefinitio-
nen realisiert: Vereinbarungen, die in einer Kla sse getroffen wurden, gel-
ten automatisch auch für alle Subklassen, es sei denn, diese spezifizieren etwas anderes.
Dabei werden die Vereinbarungen nicht übertragen (wie per Kopieren und Einfügen), son-
dern einfach nur mitbenutzt.
"
"29.1 Einfacher parametrischer Polymorphismus
Ein einfaches Beispiel für eine generische Typdefinition in STRONGTALK ist das folgende:
Typ A
Typvariablen T
Protokoll
T ist dabei eine Typvariable. Beim Vorkommen von T im Abschnitt „Typvariablen“ handelt
es sich um ihre Deklaration (Vereinbarung); beim Vorkommen im Abschnitt „Protokoll“ um
ihre Verwendung.
Das für den Tatbestand der Parametrisierung wichtige an dieser Typdefinition ist, dass x:
anstelle des Parameter - und x anstelle des Rückgabetyps T nennt, wobei T eben kein Typ,
sondern eine Typvariable ist. Für Typvariablen verwendet man traditionell einzelne Groß-
buchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen
tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die
Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer
schrieben vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen. formale und
noch eine Variable und der Typ Integer wäre innerhalb der Typdefinition nicht mehr sicht-
bar.
Wenn man nun den Typ A verwenden, also z. B. eine temporäre Variable
vom Typ A deklarieren möchte, muss man sich festlegen, welchen Wert
die Typvariable T in der Typdefinition un d damit welchen Typ die Rückgabe von x und die
Eingabe von x: haben sollen. Soll T beispielsweise den Wert Integer bekommen, dann
schreibt man
und instanziiert dabei den parametrischen Typen. Integer ist dabei der tatsächlich e
Typparameter (eine Typkonstante, wenn man so will), der in STRONGTALK in eckige Klammern
gesetzt wird. Er wird für diese Verw endung des parametrischen Typs (und nur für diese) in
den formalen Typparameter (die Typvariable) eingesetzt. Der Typ von a, A[Integer] , wird
damit zu
Typ A[Integer]
Protokoll
definiert, wobei hier A[Integer] der (generische) Name des Typen ist. Diese Typdefinition
wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der
parametrischen Typdefinition mit einem konkreten Typen. Es sind dann bei obiger Deklara-
tion von a die Methodenaufrufe
zulässig,
hingegen nicht. Für letztere wäre eine Typdeklaration
notwendig gewesen, die natürlich auch möglich ist.
Ein und dieselbe parametrische Typdefinition kann in einem Programm
beliebig oft verwendet werden, selbst in derselben Deklaration:
gibt a, b und c jeweils verschiedene Typen, die jedoch a lle Instanzen der parametrischen
Definition von A sind. Dennoch sind a, b und c wechselseitig nicht zuweisungskompatibel;
sie haben tatsächlich verschiedene Typen. a ist jedoch mit d wie in
deklariert zuweisungskompatibel und umgekehrt, da beide denselben Typen haben.
"
"4.3.3 Methoden als Parameter
Nun wurde eingangs die ses Kapitel s vom Mysterium des Nachrichtenver-
sands gesprochen. Tatsächlich ist aber zumindest in SMALLTALK seine Re-
alisierung in Form von Methodenaufrufen nur ein Zugeständnis an die
Ausführungseffizienz. Und so sind denn auch in SMALLTALK Nachrichten (ode r vielmehr
Nachrichtenselektoren) auch Objekte — schließlich soll dort ja alles ein Objekt sein. Um
tatsächlich als Nachrichtenobjekt an ein Objekt verschickt zu werden, muss man sich aber
einer speziellen Methode (genauer: eines speziellen Methodenaufrufs ), perform: , bedie-
nen, der es erlaubt, einem Empfängerobjekt eine Nachricht als Objekt (wenn auch nur als
Parameter von perform: ) zu senden. Das Empfängerobjekt reagiert darauf mit der Abar-
beitung der zur Nachricht passenden Methode ganz so, als hätte es d irekt einen entspre-
chenden Methodenaufruf erhalten. So wertet zum Beispiel
genau wie
zu true aus. Der Nachrichtenselektor ist immer ein Symbol ( #isNil im gegebenen Beispiel)
und darf beim „Versand“ mittels perform: , anders als beim direkten Aufruf, auch in einer
Variable gespeichert sein. Bei binären und höherstelligen Nachrichten braucht man zusätz-
lich noch die Argumente (Parameter) zum Nachrichtenselektor; sie können durch Erweite-
rung von perform: zu perform:with: , perform:wi th:with: usw. angehängt wer-
den. So ist dann beispielsweise der Ausdruck
äquivalent zu 1 + 2 . … und es gibt ihn
"
"29 Generische Typen oder parametrischer Polymor-
phismus
Typen beschränken die Wertebereiche von Variablen und Methoden. Inklusionspolymorphie
lockert diese Beschränkung insofern, als dadurch Wertebereiche von Typen um die von Sub-
typen erweitert werden können, selbst wenn diese Subtypen zum Zeitpunkt der Typdefi ni-
tion noch gar nicht bekannt waren (Abschnitt 26.4). Nun ist Inklusionspolymorphie nicht
die einzige Möglichkeit, den Wertebereich eines Typs variabel zu halten, ohne die statische
Typprüfung aufgeben zu müssen. Eine andere ist, einen Typ mit einem oder mehreren an-
deren zu parametrisieren.
Eine parametrisch e Typdefinition unterscheidet sich von einer norma-
len dadurch, dass in der Typdefinition verwendete, andere Typen nicht
genannt (referenziert) werden müssen, sondern durch Platzhalter, die
Typparameter, vertreten werd en können. Diese Platzhalter sind Variablen, deren Wert im-
plizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch
Typvariablen . Diese Typvariablen werden erst bei der Verwendung eines parametrisierten
Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ,
belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung
des parametrischen Typs ; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem
deklarierten Programmelement zugeordnet wird. Insbesondere hat ein pa rametrischer Typ,
bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich. Dieser Umstand ist
bei der Betrachtung von Zuweisungskompatibilität unter parametrischem Polymor phismus
wichtig.
Die Idee des parametrischen Polymorphismus ist, aus einer Typdefini-
tion durch Parametrisierung viele zu machen. Eine parametrische Typdefinition steht also
nicht für einen Typ, sondern für (theoretisch) beliebig viele — sie erlaubt es gewissermaßen, Unterschiede zur
Typen nach Bedarf zu generieren.54 Wohl deswegen bezeichnet man parametrische Typen
(Typdefinitionen) auch als generische Typen (Typdefinitionen) oder kurz als Generics . Wie
eben schon erwähnt, wird der Wertebereich bei einer solchen Typgeneration jeweils mitge-
neriert.
Es erfolgt also die Zuweisung eines Typs zu einer Typvariable bei der Ver-
wendung eines parametrisch defi nierten Typs in einer Deklaration, bei-
spielsweise der Deklaration einer Variable oder des Rückgabewerts einer
Methode. Oberflächlich betrachtet entspricht diese Verwendung in etwa dem Aufruf einer
(ja auch an einer anderen Stelle definierten) Methode oder besser (und schon aufgrund der
Verwendung des Begriffs Instanziierung) eines Konstruktors; deswegen nennt man die Typ-
variablen, die in parametrischen Typdefinitionen vorkommen, auch formale Typpar ame-
ter und die konkreten Typen, die bei der Verwendung des Typen in Deklarationen in die
formalen Parameter eingesetzt werden, auch tatsächlich e Typparameter . Trotz dieser
Analogie zu Methoden - bzw. Konstruktoraufrufen muss man sich immer vor Augen halten,
dass die Verwendung eines parametrisch definierten Typs bereits zur Übersetzungszeit zu
einer Zuweisung an die Typvariab len führt, man es also keineswegs mit etwas Dynamischem
zu tun hat. Insbesondere müssen Typen keine Objekte sein, um Typvariablen zugewiesen
werden zu können.
"
"29.5 Rekursiv beschränkter parametrischer Polymorphismus
Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Ein Beispiel für
einen rekursiven Typ hatten Sie oben sc hon kennengelernt: Der (zur Klasse Person gehö-
rende) Typ Person hat Methoden, die Person als Parameter - bzw. Rückgabetypen haben.
Rekursive Typen sind ein wichtiges Instrument der Programmierung: Ohne sie wären dyna-
mische Strukturen wie beispielsweise verz eigerte Listen oder Bäume kaum möglich. Rekur-
sive Typen machen aber auch bestimmte Probleme — so ist beispielsweise die strukturelle
Äquivalenz zweier rekursiver Typen nicht so leicht festzustellen, da die dazu notwendige
Expansion rekursiver Typen (also das Einsetzen der Struktur für jeden darin vorkommenden
Typnamen; vgl. Abschnitt 22.1) unendlich große Definitionen ergibt.
Es ergibt sich nun ein weiteres Problem, wenn man in einer parametri-
schen Typdefinition den Typ eines Methodenarguments (eines formalen
Parameters einer Methode) variabel halten möchte, dieser Typ aber aus-
gerechnet der definierte ist (eine binäre Methode ; vgl. Fußnote 21 in Ka-
pitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das
Objekt, das gleich sein soll, vom selben Typ sein muss wie das, mit dem man Gleichheit
feststellen möchte. Für den Typ Object schreibt man dazu einfach
Typ Object
Protokoll
für den Typ Number
Typ Number
Protokoll
usw. Nun ist aber Number ein Subtyp von Object , so dass man die Deklaration von =
eigentlich aus Object übernehmen könnte — wenn der Typ des Parameter s automatisch
so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre
man vielleicht versucht, den Gleichheitstest in Object einfach als = einObject <Self>
^ <Boolean> zu deklarieren, aber das würde, wenn die Pseudo -Typvariable Self beim
Subtyping jeweils den Subtyp annehmen soll, zu einer kovarianten Redefinition mit den parametrische
bereits bekannten Problemen führen.55 Auch hier bietet parametrischer Polym orphismus
eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.
Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvari-
able T. Nun kann man schlecht
Typ T
Typvariablen T
Protokoll
schreiben, da der Typ dann keinen Namen hätte und somit auch nicht verwendbar (referen-
zierbar) wäre. Was man aber sehr wohl machen kann, ist, einen allgemeinen parametrischen
Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und de r den Parametertyp
des Tests variabel hält, wie in
Typ Equatable
Typvariablen T
Protokoll
Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht pa-
rametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man
den zu definierenden Typ gleichzeitig als tatsächlich en Typparameter einsetzt. So l iefert z. B.
Typ Integer
Supertyp Equatable[Integer]
eine Methode mit der Signatur = einT <Integer> ^ <Boolean> im Protokoll von
Integer . Allerdings kann man so nicht erzwingen, dass bei der Definition des Typs
Integer oben genau Integer als tatsächlich er Typparameter eingesetzt wird; es hätte
auch jeder andere Typ, z. B. String , sein können — der Gleichheitstest wäre dann mit =
einT <String> ^ <Boolean> falsch deklariert.
Genau diese Beschränkung des tatsächlich en Typparameters kann man nun m it einer stilis-
tischen Figur erreichen, die vermutlich manch einer von Ihnen erhebliche Kopfschmerzen
bereiten wird (zumindest macht sie das mir immer wieder aufs neue): Man beschränkt den
formalen Typparameter T von Equatable auf einen Subtyp von Equatable[T] , wobei
das Vorkommen von T in Equatable[T] eine Verwendung der gerade erst eingeführten
Typvariable T darstellt.
Typ Equatable
Typvariablen T < Equatable[T]
Protokoll
verlangt also im obigen Beispiel der Typdefinition von Integer als Subtyp einer Instanziie-
rung der parametrischen Definition von Equatable , dass der tatsächlich e Typparameter
Integer ein Subtyp von Equatable[In teger] sein muss . Genau das sagt aber die obi ge
Typdefinition von Integer aus! Stünde dort Equatable[String] oder irgend etwas an-
deres als Typschranke, wäre dies nicht mehr der Fall (s. Abschnitt 29.3) und die Definition
von Integer verursachte einen statisch feststellbaren Typfehler .
Wenn Sie hier ein Verständnisproblem haben, trösten Sie sich — es dauert
eine Weile, bis man es verstanden hat, und noch länger, bis solche Fi gu-
ren zum aktiven Repertoire gehören. Gleichwohl sollten Sie sich damit befassen: Das JAVA-
Collections -Framework in der Version von JAVA 5 ist voll solcher Typdefinitionen, nicht , weil
sie schön sind, sondern weil man sie braucht, um das Framework typsiche r zu machen, ohne
seine Flexibilität zu opfern. Auch Sie werden, wenn Sie objektorientiert programmieren,
über kurz oder lang solche Konstrukte von sich geben müssen.
"
"4 Verhalten
Wenn Objekte ihren Zustand kapseln, ist es ausschließlich ihr Verhalten, welches ihn ändert,
welches also die Zustandsänderungen eines Objekts herbeiführt. Umgekehrt hängt das Ver-
halten eines Objekts in der Regel von seinem Zustand ab. Wie aber wird das Verhalten eines
Objekts beschrieben? Bevor wir uns dieser Frage zuwenden, müssen wir erst wir zunächst
den Begriff des Ausdrucks klären.
"
"18 Hintergrund
Sie kennen vielleicht aus anderen Programm iersprachen, dass Variablen und anderen Pro-
grammelementen bei ihrer Deklaration ( Kapitel 19) ein Typ zugeordnet wird. Dieser Typ
schränkt die möglichen Werte der deklarierten Elemente ein. So lassen sich beispielsweise
in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zei-
chenketten speichern.
Typ ist ein primitiver Begriff, vergleichbar etwa mit dem Begriff der
Menge in der Mengentheorie. Ein Typ hat eine Intension und eine Extension , wobei erstere
der Definition des Typs entspricht, letztere seinem Wertebereich, also der Menge der Ele-
mente (Objekte), die zu dem Typ g ehören (man sagt auch, „die den Typ haben“ oder „die
von dem Typ sind“). Häufig hat ein Typ auch einen Namen, den Typbezeichner. Typen sind
die Grundlage von Typsystemen.
Ihnen fällt wahrscheinlich sofort die Ähnlichkeit zum Konstrukt der
Klasse, wie es in der letzten Kurseinheit eingeführt wurde, auf. Tatsäch-
lich gibt es hier auch einen Zusammenhang. Um Sie aber nicht gleich in für diese Kurseinheit
eher schädliche Denkmuster verfallen zu lassen, soll dieser Zusammenhang zun ächst zu-
rückgestellt werden. Eine Aufklärung erfolgt dann in Kapitel 28.
Ein Typsystem umfasst Typausdrücke, Objekt - oder Wertausdrücke, Re-
geln, die Wertausdrücken Typen zuordnen, und Regeln, die von Wertausdrücken einzuhal-
ten sind (zusammen die Typregeln ). Wertausdrücke (bzw. schlicht Ausdrücke, wenn es
nicht um die Abgrenzung von Typausdrücken geht) kennen Sie schon: In SMALLTALK sind es
die in Kurseinheit 1, Kapitel 4.1 aufgeführten. Mit den anderen Konzepten werden Sie in
den nachfolgenden Kapitel n vertraut gem acht, allerdings in weniger formaler Form, als Sie
das nach dieser Definition vielleicht befürchten.
Warum aber typisiert man Variablen und andere Programmelemente?
Dafür gibt es mindestens vier gute Gründe:
1. Typisierung regelt das Speicher -Layout.
2. Typisierung erlaubt die effizientere Ausführung eines Programms. Typ
3. Typisierung erhöht die Lesbarkeit eines Programms.
4. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Pro-
gramm.
Zu 1.: Der Comp iler kann anhand des Typs einer Variable bestimmen, wie
viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss . Dies ist jedoch natur-
gemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Pro-
grammierung, insbeso ndere für Sprachen wie SMALLTALK (in denen Referenzsemantik vor-
herrscht), von untergeordneter Bedeutung.
Zu 2.: Wenn man weiß, dass die Werte einer Variable immer vom selben
Typ sind, also alle demselben Wertebereich entstammen, dan n lassen sich
bestimmte Optimierungen durchführen. Wenn man z. B. aufgrund der Deklaration einer
Variable x für gegeben annehmen kann, dass x nur ganze Zahlen enthält, dann kann der
Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkre-
ment -Anweisung des Prozessors verwenden. Kennt der Compiler den Typ von x hingegen
nicht, dann muss das Programm vor der Ausführung der Addition erst prüfen, von welchem
Typ der Wert von x ist — handelt es sich um e ine Fließkommazahl, so muss es zu der ent-
sprechenden Operation verzweigen, handelt es sich womöglich um gar keine Zahl, dann
muss es einen Laufzeitfehler signalisieren oder sich etwas anderes einfallen lassen. Dem
kann man entgegenhalten, dass im Falle der objektorientierten Programmierung selbst bei
einer Typisierung aller Variablen gelegentlich noch Laufzeittests durchgeführt (oder andern-
falls schwere Programmfehler in Kauf genommen) werden müssen, und dass sich die zur
Optimierung benötigte Information a uch anders als über explizite Typisierung von Variablen
(nämlich z. B. über die sog. Typinferenz , also die Ausnutzung impliziter Typinformation) ge-
winnen lässt.
Zu 3.: In der Vergangenheit hatten Variablen eher kurze, wenig selbster-
klärende Namen (vgl. dazu auch Kapitel 62 in Kurseinheit 7). Es ist dann sinnvoll, wenigstens
an der Stelle der ersten Erwähnung der Variablen (in der Regel deren Deklaration ) einen
Hinweis darauf zu haben, wofür (für welche Menge von Objekten) die Variable steht. Dies
kann über einen Kommentar erfolgen, aber auch durch die Assoziation mit einem Typen,
die aussagt, welcher Art die Werte der Variable sein müssen. Doch nicht nur Vari ablen -,
auch Methodennamen können für sich genommen wenig aussagekräftig sein und durch
die Verknüpfung mit Typen aussagekräftiger gemacht werden: Eine Deklaration der Me-
thode next etwa, die ListElement als Typ des Ein - und Ausgabeparameters deklariert,
legt nahe, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurücklie-
fert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre
Implementation nicht kennt, schon über ihren Zweck spekulieren. Dem mag man freilich
entgegenhalten, dass man stattdessen ja auch selbsterklärende Namen für Variablen und
Methoden vergeben könnte (mehr dazu in Kurseinheit 7, Kapitel 62). Speicher -Layout
Es bleibt aber in jedem Fall Punkt 4, das Aufdecken von logischen Fehlern
in einem Programm. Ohne externes Wissen, was ein Programm tun soll,
verlangt das Finden von Fehlern jedoch ein gewisses Maß an Redundanz ,
also die mehrfache Lieferung gleicher Information, im Programm, denn
nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen
logischen Programmierfehler hinweisen. Die Verknüpfung von deklarierten Elementen mit
Typen erlaubt aber genau die Angabe solcher redundanter Information. Die Schaffung die-
ser Redundanz verlangt jedoch vermehrte Denk - und Schreibarbeit und ist zudem auch
noch, im Falle eines fehlerfr eien Programms, überflüssig. Dem kann man allerdings entgeg-
nen, dass kaum eine Programmiererin auf Anhieb korrekte Programme schreibt, und wenn
eine Typisierung Fehler zu fin den in der Lage ist und somit nicht minder aufwendige Tests
ersetzt, dann ist das natürlich gut .
Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der
heute üblichen Typsysteme ist übrigens die dadurch entstehende Modu-
larisierung von Programmen , nämlich wenn ein Typ zugleich eine Schnittstelle oder ein In-
terface ausdrückt. Mehr dazu jedoch erst später (in Abschnitt 28.2).
Die der Fehlerentdeckung mittels Typsystemen zugrundeliegende These
ist, dass ein guter Teil logischer Programmierfehler bereits frühzeitig daran erkannt werden
kann, dass eine Variable einen Wert hat, den sie eigentlich niemals haben dürfte. So zeugt
beispielsweise von einem Fehler, wenn einer Variable, die für Zahlen gedacht war, eine Zei-
chenkette zugewiesen wird. Wenn dann nämlich einem Ausdruck mit einer arithmetischen
Operation, die Zahlen als Operanden verlangt, eine solchermaßen fehlbelegte Variable zu-
geführt wird, kann dieser nicht ausgewertet werden. Ohne Typprüfung würde dieser Fehler
erst zur Laufzeit, also wenn der Ausdruck tatsächlich ausgewertet werden soll, in Erschei-
nung treten und hätte dann in aller Regel einen Programmabbruch zur Folge. Man nennt
einen solchen Programmierfehler einen Typfehler .
Währe nd ein Programmabbruch wenigstens noch eine erkennbare Reak-
tion auf einen Programmierfehler darstellt, ist es fast noch schlimmer,
wenn ein logischer Fehler ohne solche bleibt. So kann es beispielsweise vorkommen, dass
man einer Variable, deren Inhalt eine Strecke darstellen soll, eine andere zuweist, deren
Inhalt eine Zeit repräsentiert. Mit beiden ließe sich gleich rechnen (dieselben Rechenopera-
tionen durchführen), aber das Ergebnis wäre vermutlich falsch. Merken muss man das aller-
dings selbst, denn das P rogramm läuft einfach weiter.
Man kann Variablenfehlbelegungen dieser Art verhindern, indem man
Variablen mit expliziten Typinvarianten versie ht, die die Menge ihrer zu-
lässigen Werte beschränken, und dann darüber wacht, dass diese Invarianten immer einge-
halten werden. Eine besonders einfache Möglichkeit, solche Invarianten zu spezifizieren,
erlauben sog. Typannotationen , also die Verbindung einer Variable mit einem Typ, wobei
der Typ eine Menge von Werten festlegt, die die Variable ausschließlich haben darf. In typi-automatisches
sierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Vari-
ablendeklaration ; in nicht oder nur optional typisierten Sprachen kann sie auch (für einzelne
oder alle Variablen) hergeleitet (i nferiert ; die Typinferenz ) werden und ist dann implizit.
Ein Programm, in dem alle Variablenbelegungen immer alle Typinvarian-
ten erfüllen, heißt typkorrekt . In einer Sprache, die durch ihr Typsystem
Typkorrektheit festzustellen erlaubt, nennt man die logischen Fehler, die sich in unzulässigen
Wertzuweisungen ausdrücken, auch semantische Fehler (und zwar, weil der Inhalt eines
Programmelements nicht seiner intendierten Bedeutung entspricht). Dabei ist die Semantik
des Programmelements im Programm zweimal, auf redundante , aber unterschiedliche Art,
spezifiziert: in Form seines Typs und in Form seiner tatsächlichen Verwendung (festgelegt
durch Zuweisung en und Methodenaufrufe). Lässt sich aus beiden ein Widerspruch ableiten,
muss eine von beiden falsch gewesen sein.
Der einzige Weg, eine mit der Typisierung einer Variable ausgedrückte
Invariante zu verletz en, also Typ inkorrektheit herzustellen, ist per Wert-
zuweisung an die Variable. Ein Typsystem muss also lediglich alle Wert-
zuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu ga-
rantieren. Dazu zählen allerdings auch die implizi ten Zuweisungen bei Methodenaufrufen
(s. Abschnitt 4.3.2 ), die, auch wegen des dynamischen Bindens, nicht immer alle offensicht-
lich sind. Im folgenden heißen Zuwe isungen und Methodenaufrufe, die nicht zu typinkor-
rekten Programmen führen können, zulässig .
Nun kann man sich vorstellen, dass es für einen Compiler selbst in einfa-
chen Fällen nicht leicht ist, festzustellen, ob eine Wertzuweisung eine In-
variante verletzt und somit zu einem typinkorrekten Programm führt. So ist das folgende
STRONGTALK -Programmfra gment
das zunächst eine temporäre Variable i mit dem Typ Integer (in STRONGTALK wird die
Typannotation hinter der Variable in spitzen Klammern angeführt) deklariert und ihr dann,
in einer Folge von Anweisungen, zunächst 0 und dann 1 (beides Werte vom Typ Integer )
zuweist, zwar typkorrekt im Sinne obiger Definition, aber um das zu erschließen, muss man
schon wissen, dass die Bedingung in Zeile 835 immer erfüllt ist, der False -Zweig, der zu einer
Verletzung der Invariante von i (nämlich dass die Werte immer vom Typ Integer sein
müssen und somit nicht vom Typ String sein dürfen) führen würde, also nie ausgeführt
wird. Im gegebenen Fall ist das zwar offensichtlich (und bereits von einer recht einfachen Typkorrektheit ;
Programmanalyse feststellbar), aber es lassen sich auch Fälle konstruieren, in denen eine
automatische Programmanalyse streiken muss .47
Was man jedoch immer tun kann, um Typkorrektheit zu gewährleisten,
ist, dass man zur Laufzeit vor einer Variablenzuweisung prüft, ob der zu-
zuweisende Wert den von der Variable geforderten Typ hat. Diese sog. dynamische
Typprüfung (engl. dynamic type checking ) hat jedoch den entscheidenden Nachteil, dass
sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes
machen kann als einen Fehler zu signalisieren (der dann günstigenfalls durch eine dafür
vorgesehene Fehlerbehandlungsmethode aufgefangen wird, der aber in der Praxis häufig
nur zu einem Programmabbruch führt). Man kann jedoch argumentieren, dass auch letzte-
res immer noch besser ist, als mit falschen Werten weiterzuarbeiten und damit entweder
einen Progr ammabbruch an einer anderen Stelle, die nicht mehr so leicht mit der fehlerhaf-
ten Wertzuweisung in Zusammenhang zu bringen ist48, in Kauf zu nehmen oder gar einen
logischen Fehler, der überhaupt nicht erkannt wird.
Man beachte übrige ns, dass nach diesem Kriterium SMALLTALK — entge-
gen häufig zu lesenden Behauptungen — keine dynamische Typprüfung
durchführt, da Typfehler erst im letztmöglichen Moment offenbar werden, nämlich wenn
auf einer Variable eine Methode aufgerufen werden soll, d ie für das Objekt, auf das die
Variable verweist, gar nicht definiert ist.49 Um das zu verhindern, findet man in SMALLTALK -
Code gelegentlich Figuren wie
(SMALLTALK EXPRESS entnommen). Dies entspricht natürlich genau einer dynamischen Typprü-
fung, nur dass hier Typ durch Klasse er setzt wurde und die Prüfung eben nicht automatisch
durch ein Laufzeittypsystem erfolgt, sondern ausprogrammiert werden muss .
Regel auf pathologischen Programmkonstruktionen, die man in der Praxis kaum vorfinden wird, b a-
sieren.
einem Variablenwert null tatsächlich etwas gemacht werden soll, was unter Umständen erst a m
Ende einer langen Zuweisungskette der Fall ist.
mically typed ) bezeichnet. Das aber ist Unsinn, denn eine Typisierung findet in SMALLTALK gar nicht,
auch nicht zur Laufzeit, statt. Außerdem ist mit dynamischer Typisierung in der Regel dynamische
Typprüfung gemeint. Was ein dynamischer Typ sein soll, ist auch gar nicht klar. dynamische
Sehr viel nützlicher als die dynamische Typprüfung ist die statische
Typprüfung, bei der, trotz aller theoreti schen Hindernisse, die Typkorrektheit zur Überset-
zungszeit gewährleistet werden soll. Die Typprüfung ist damit Aufgabe des Compilers und
nicht, wie im Fall der dynamischen Typprüfung, Aufgabe des Laufzeitsystems oder gar der
Programmiererin . Wie wir schon gesehen haben, bedeutet dies nicht weniger, als einen
Beweis zu führen, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt
wird. In der Praxis bedeute t dies aber, dass eine rein statische Typprüfung immer auch Pro-
gramme zurückweist, die nützlich, sinnvoll und typkorrekt sind (s. obiges Beispiel der Zeilen
Zwar kann man versuchen, möglichst wenige typkorrekte Programme durch die sta tische
Typprüfung zurückzuweisen, aber wie man sich leicht vorstellen kann, wird mit steigender
Genauigkeit das dazu notwendige Typsystem immer aufwendiger und schwieriger zu be-
nutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken
soll (so dass man bei auftretenden Typfehlern erst einmal prüfen muss , ob die Ursache tat-
sächlich in einem fehlerhaften Programm oder vielleicht nur in fehlerhaften Typannotatio-
nen liegt).
So ist die Suche nach einem guten Typsystem immer die Suche nach ei-
nem guten Kompromiss . Die meisten heut e in der Praxis verwendeten
Typsysteme basieren auf einem solchen: einer statischen Komponente,
die möglichst viele Fehler findet, ohne dabei die Programmiererin allzu sehr einzuschränken,
und einer dynamischen Komponente, die den Rest erledigt. Eine erwähnenswerte Aus-
nahme davon macht C++: hier wird, zugunsten von Performanz (Speicherplatz und Ge-
schwindigkeit), auf eine dynamische Komponente der Typprüfung vollständig v erzichtet. Da
die statische Typprüfung von C++ aber nicht alles abdeckt, sind C++ -Programme auch nicht
automatisch typkorrekt. Mehr dazu in Abschnitt 51.5.
"
"Kurseinheit 6: Probleme der objektorientierten
Programmierung
In den vorangegangenen Kurseinheiten wurde bereits an verschiedenen Stellen auf Prob-
leme der objektorientierten Programmierung hingewiesen. Diese sollen nun in dieser Kurs-
einheit z usammen gefasst dargestellt werden.
"
"1.9 Lebenslauf von Objekten
In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit sei-
ner Entsorgung durch eine Speicherbereinigung, die sog. Garbage collection . Garbage
collection ist ein Mechanismus, der Objekte aus dem Speicher entfernt, wenn diese nicht
mehr zugreifbar sind. Da in SMALLTALK auf Objekte nach ihrer Erzeugung ausschließlich über
Variablen (Namen) zugegriffen werden kann, kann ein solches Objekt genau dann entfernt
werden, wenn keine Variable mehr auf es verweist. Es kann entfernt werd en, muss aber
nicht; aus Sicht der Programmiererin ist es ausreichend, dass das Objekt nicht mehr be-
kannt/benannt ist — es kann somit nicht mehr aufgefunden und durch eine Zu weisung
einer Variable zugewiesen werden. Bei der Implementierung von Garbage -collection -Algo-
rithmen besteht denn auch erhebliche Freiheit.
Wenn Peter und Michaela heiraten, dann schlägt sich dies u. a. in der
Zuweisung
nieder. Wenn 'Müller' keine Aliase (wie beispielsweise paulasNachname ) hatte, kann
es nach der Zuweisung aus dem Speicher entfernt werden — es wäre selbst bei Bedarf nicht
mehr auffindbar.
Von der automatischen Speicherbereinigung ausgenommen sind be-
stimmte Objekte mit eindeutiger literaler Repräsentation (wie z. B. kleine
Zahlen, Zeichen und Symbole). Im Falle von Zahlen und Zeichen liegt das jedoch weniger an
der Natur dieser Objekte selbs t als vielmehr an der Tatsache, dass diese in der Regel nicht
als Objekte im Speicher angelegt werden (so dass Variablen darauf verweisen könnten), Beispiel
sondern dass sie selbst, als Werte (und anstelle von Zeigern), in Variablen gespeichert wer-
den ( Abschnitt 1.5.1 ). Sie werden „entfernt “, indem einer Variable ein neuer Wert zuge-
wiesen wird. Symbole werden schon deswegen nicht aus dem Speicher entfernt, weil sie in
einer Symboltabelle abgelegt (und somit immer mindestens einmal referenziert ; s. Fußnote
5) werden.
Der M ut zur Verabschiedung von der expliziten Speicherfreigabe war eine
der wichtigsten Entscheidungen beim Entwurf SMALLTALK s. Man hat ein-
fach anerkannt, dass die genaue Buchführung darüber, auf welche Ob-
jekte noch zugegriffen wird, zu schwierig ist, um die Ve rantwortung da-
für Anwendungsprogrammiererinnen zu überlassen. Wer das Problem nicht unmittelbar
einsichtig ist, die halte sich vor Augen, dass
 der Ort der Erzeugung eines Objektes und seine erste Zuweisung zu einer Variable
im Programm möglicherweise weit entfernt sind von der Stelle, an der dieser Vari-
able ein anderes Objekt zugewiesen wird, dass
 es möglicherweise viele solcher Stellen gibt, von denen mal die eine, mal die andere
zuerst erreicht wird, und dass
 in der Zwischenzeit beliebig viele Aliase auf das Objekt angelegt w orden sein kön-
nen, die alle mit berücksichtigt werden müssen, um zu entscheiden, ob das Objekt
noch in Verwendung ist.
Eine vorzeitige Entfernung aus dem Speicher hingegen führt dazu, dass Variablen ins Nichts
zeigen (eine häufige Quelle von Progr ammabstürzen) oder dass, bei einer Wiederverwen-
dung des Speichers, die Variable plötzlich auf ein anderes Objekt verweist, das ihr aber nie
explizit zugewiesen wurde — ein quasi zufälliges Programmverhalten, das mit hoher Wahr-
scheinlichkeit zu schweren Pro grammfehlern führen würde. Ein anderes Beispiel entsteht,
wenn in einer Verzweigung eines Programms entweder ein neues oder ein bereits vorhan-
denes Objekt einer Variable zugewiesen wird. Woher weiß man bei der weitere n Benutzung
dieser Variable, ob das Obj ekt schon vorher existierte und vielleicht schon andere Variablen
auf es verweisen, oder ob es gerade erst neu erzeugt wurde und damit noch unbenutzt ist?
Wer ist für die Entsorgung des Objekts verantwortlich? All diese Betrachtungen kann man
sich in Gegen wart der Garbage collection ersparen.
Im objektorientierten Jargon spricht man übrigens häufig auch vom Le-
benszyklu s („life cycle “) eines Objekts. Genaugenommen ist dies aber
irreführend, denn das Wort „Zyklus“ verspricht, dass das Leben nach seinem Ende wieder
neu beginnt. Gerade dies ist aber, wie eben erläutert, nicht der Fall: Objekte werden nicht
recycelt, sondern höchstens der Speicherplatz, den sie belegen. warum automatische
"
"48 Ein abschließendes Beispiel
Um Ihnen eine grobe Vorstellung davon zu geben, wie JAVA-Programme aussehen, finden
Sie nachfolgend den Quellcode für ein Programm, das ein einfaches Ratespiel umsetzt . Das
Programm besteht aus vier Klassen, nämlich der Klasse Ratespiel , die im wesentlichen
die Startmethode nebst Initialisierung der Datenst ruktur enthält, sowie den Klassen Knoten ,
Tier und Merkmal . Das Interface Frage dient der gemeinsamen Abstraktion von Tier Möglichkeiten zur
und Merkmal und verlangt von den beiden Klassen lediglich, dass sie eine Methode
stellen() implementieren und auf den Aufruf derselbe n einen Wahrheitswert (die Ant-
wort auf die gestellte Frage) zurückliefern. Die Methoden der Klasse KeyboardInput die-
nen der Interaktion mit der Benutzerin über die Konsole, deren Möglichkeiten in JAVA (wie
in SMALLTALK ) von Haus aus nur schwach ausgeprägt sind. System.out bezeichnet denn
auch den Ausgabestrom , der mit der Konsole ver bunden ist, und die Methode println(.)
gibt etwas darauf aus.
Die Klassen Tier und Merkmal sind beide recht klein und unterscheiden sich nur wenig.
Beide speichern pro Instanz einen String, einmal in der Instanzvariable name , einmal in der
Instanzvariable frage . Diese Strings werden jeweils bei der Erzeugung der Objekte per Kon-
struktoraufruf üb ergeben (so z. B. in Zeile 1179 ) und in der Folge nicht mehr geändert (die
Instanzvariablen sind private deklariert und es gibt außer dem Konstruktor keine Met ho-
den der Klassen, die schreibend darauf zugreifen, also die Instanzvariable auf der linken
Seite einer Zuweisung stehen haben). Beim Stellen der Frage fügt Tier noch etwas Text zu
dem Inhalt von name hinzu, so dass sich eine vollständige Frage ergibt; für Merkmale muss
die Frage so eingegeben werden, wie sie hinterher gestellt wird.
Das Gros der Anwendungslogik steckt in der Klasse Knoten . Ihre Instanzen stellen die Kno-
ten eines binären Baums, von denen der eine Nachfolger den Ja -, der andere den Nein -
Zweig beinhaltet. Zudem muss jeder Knoten eine Frage haben; dass die entsprechende
Instanzvariable frage heißt und vom Typ Frage ist, drückt aus, dass mit jedem Knoten
entweder eine Tier - oder eine Merkmalsfrage verbunden ist. Dass nur die Blätter eines
Baums Tierfragen beinhalten dürfen, wird durch die Variablendeklarationen nicht ausge-
drückt; das steckt in der nachfolgenden Programmlogik, der Implementierung der Methode
fragen() .
Die Methode fragen() enthält eine Unterscheidung von vier Fällen, die sich aus d er Be-
antwortung der zu dem Knoten gehörenden Frage (ja oder nein) und dem Umstand, ob es
sich um einen Blattknoten handelt (was man daran sehen kann, dass ja bzw. nein den
Wert null haben) ergeben. Die Schachtelung der insgesamt drei If -else-Anweisungen is t
Standard und hat mit Objektorientierung nichts zu tun. Objektorientiert ist dagegen die
Fallunterscheidung, die sich hinter dem Aufruf frage.stellen() (Zeile 1201 ) verbirgt: Da
frage eine Instanz der Klasse Tier oder Merkmal benennen kann, die beiden Klassen die
Methode stellen() aber jede für sich implementieren, wird hier eine Fallunterscheidung
per dynamischem Binden getroffen. Man beachte, dass die Unte rscheidung, ob ein Knoten
Blattknoten ist, ebenfalls per dynamisches Binden getroffen werden könnte; ihre Program-
miererin hat sich aber im Rahmen ihrer kreativen Freiheit dagegen entschieden.
Vielleicht ist Ihnen aufgefallen, dass außer den Konstruktoren keine der Methoden einen
Parameter hat. Es ist dies ein Zeichen für ein gelungenes objektorientiertes Design. Für Pro-
grammiererinnen , die aus der imperativen Programmierung kommen, ist dies gewöhnungs-
bedürftig — intuitiv denkt man zunächst, dass die Methoden statt dessen wohl auf globale
Variablen z ugreifen werden, weswegen man spontan die Nase rümpfen möchte. Das ist
aber nicht der Fall: Alle Methoden greifen ausschließlich auf Instanzvariablen zu. Diese gibt
es aber in der imperativen Programmierung nicht.
"
"7.2 Klassendefinitionen
Eine Klassendefinition liefer t die Intension einer Klasse. Sie besteht in
SMALLTALK zunächst aus der Angabe eines nicht anderweitig verwende-
ten, durch ein Symbol repräsentierten Klassennamens sowie de r Angabe der die Objekte
der Klasse beschreibenden Instanzvariablen und Methodendefinitionen . Anders als in vielen
anderen objektorientierten Programmiersprachen erfolgt in SMALLTALK die Klassendefinition
nicht in einer Datei (was hätte eine Datei auch mit den Konzepten einer Programmierspra-
che zu tun?), sondern durch Eintragungen in eine dafür vorgesehene Datenstruktur (ge-
nauer: durch Erzeugung eines die Klasse beschreibenden Objekts). Es gibt also auch insbe-
sondere keine Syntax für eine Klassendefinition, sondern nur ein Schema. Ein solches , wenn
auch noch unvollständiges, Schema ist das folgende: Allgemeinbegriff vs.
Klasse <Klassenname>
benannte Instanzvariablen <Liste von Instanzvariablennamen>
indizierte Instanzvariablen <ja/nein>
atomar <ja/nein>
Instanzmethoden
<Liste von Methodendefinitionen>
Alle Instanzen einer Klasse verfügen somit über den gleichen Satz von Instanzvariablen, aber
nicht denselben, was soviel bedeutet wie dass jede Instanz der Klasse (jedes Objekt, das zur
Extension der Klasse gehört) diese Variablen individuell belegen kann. Im Gegensatz dazu
verstehen alle Instanzen einer Klasse nicht nur dieselben Nachrichten, sie verwenden auch
dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren. Instanzen einer
Klasse können sich also nur insoweit in ihrem Verhalten unters cheiden, wie sich die Metho-
dendefinitionen auf die Werte der Instanzvariablen beziehen, wie also das in den Methoden
spezifizierte Verhalten vom Inhalt der Instanzvariablen abhängt. Insbesondere ist es nicht
vorgesehen, dass verschiedene Instanzen einer Klasse über verschiedene Definitionen einer
Methode (genauer: über verschiedene Definitionen von zu der Nachricht passenden Metho-
den) verfügen. Das unterscheidet die klassenbasierte von der prototypenbasierten Form der
objektorientierten Programmierung.
Die beiden Einträge „indizierte Instanzvariablen“ und „atomar“ stehen übrigens dafür, ob
eine Instanz der Klasse indizierte Instanzvariablen haben soll (klar) und falls ja, ob diese Va-
riablen dann eine binäre Repräsentation (ja) oder Referenzen (nein) enthalte n. Mit Hilfe von
indizierten Instanzvariablen, die binäre Repräsentationen enthalten, werden z. B. Zahlen,
Strings, aber auch Bitmaps wie Fensterinhalte , der Cursor oder Fonts intern dargestellt. Da
man als Programmiererin solche Klassen in der R egel nicht selbst anlegt, werde ich den
Eintrag „atomar“ zukünftig unter den Tisch fallen lassen.
Eine Klasse ( das Objekt, das die Klassen repräsentiert, nicht ihr Name)
wird in SMALLTALK nach ihrer Erzeugung übrigens durch eine globale Pseu-
dovariable repräsentiert, deren Name der Name der Klasse ist. Da die Variable global ist,
muss sie (und damit auch der Name der Klasse) immer mit einem Großbuchstaben beginnen
(s. Abschnitt 1.5.2 in Kurseinheit 1). Die Variable wird automatisch mit der Klassendefinition
eingeführt (vereinbart ); ihr „Wert“, die Klasse, auf die sie verweist, ist das Objekt, das ihr
bei der Anlage der Klasse zugewiesen wird. Da Klassennamen globale Variablen sind, da sie
insbesondere absolut global sind und nicht nur in Bezug auf irgendeine Programmeinheit
(wie e twa eine Methodendefinition), sind sie von überall her zugreifbar. Außerdem wird
jede neue Klasse in eine Art Systemwörterbuch namens „ Smalltalk “ (repräsentiert von der
globalen Variable Smalltalk ; s. Selbsttestaufgabe 1.2) eingetragen und ihr Name (als Sym-
bol) in die Symboltabelle SymbolTable . Repräsentation von
Selbsttestaufgabe 7.1
Vergewissern Sie sich, dass die Klasse Class in Smalltalk enthalten ist und das Symbol #Class
in SymbolTable (nur SMALLTALK EXPRESS ). Enthält Smalltalk auch andere Objekte als Klassen?
Mittels einer solchen Klassendefinition ist man nun in der Lage, das SMALL-
TALK-System um neue, eigene Klassen zu erweitern. Ein Beispiel für eine
solche neue Klasse gibt die folgende (wie gesagt noch unvollständige)
Klassendefinition, die auf einfache Weise einen Stapelspeicher ( Stack ) implementiert, der
seine Elemente in indizierten Instanzvariablen und den Stapelzeiger ( Stack pointer ) in einer
benannten hält:
Klasse Stack
benannte Instanzvariablen stackpointer
indizierte Instanzvariablen ja
Instanzmethoden
Nur zur Wiederholung: Die Pseudovariable self in den Zeilen 282 und 288 steht jeweils
für das Objekt, das die die Methode auslösende Nachricht erhalten hat (da s Empfängerob-
jekt): Sie ist notwendig, da der Zugriff auf die indizierten Instanzvariablen in SMALLTALK im-
mer über die Methoden at: und at:put: erfolgt, deren Aufruf (als Nachrichtenausdruck)
stets einen Empfänger benötigt. Anders als z. B. in JAVA (wo this die Rolle von self ein-
nimmt) wird bei fehlendem Empfänger innerhalb einer Methode nicht einfach das Empfän-
gerobjekt angenommen, sondern ein Syntaxfehler gemeldet.
Bei genauem Hinsehen bemerkt man, dass die obige Implementierung
eines Stacks einen Schönheitsfehler besitzt: Während die Manipulation
der benannten Instanzvariable stackpointer , deren Wert ja von den
Methoden von Stack aktualisiert wird, durch andere Objekte noch verhindert werden
kann, ist dies für di e indizierten Instanzvariablen eines Stack -Objekts nicht der Fall. Eine
Benutzerin eines solchen Objekts kann stattdessen mittels at: und at:put: jederzeit auf
jedes beliebige Element des Stacks zugreifen, und zwar unabhängig davon, ob dies gerade Erweiterung von
oben auf dem Stack liegt. Eine Instanz der Klasse Stack verbirgt also nicht wie in Kursein-
heit 1, Abschnitt 4.3.4 gefordert die Repräsentation ihres Zustands, der Stack -Elemente. Um
dies zu bewirken, muss man anstelle d er indizierten Instanzvariablen eine benannte verwen-
den, die selbst ein Objekt mit indizierten Instanzvariablen hält (ein Zwischenobjekt ; s. Ab-
schnitt 2.2), und die Speicherung der Elemente des Stacks diesem zweiten Objekt übertra-
gen. Die Implementierung sähe dann wie folgt aus:
Klasse Stack
benannte Instanzvariablen stackcontent stackpointer
indizierte Instanzvariablen nein
Instanzmethoden
Auf die Variable stackcontent kann von anderen Objekten nicht direkt zugegriffen wer-
den — sie ist verborgen (und nur noch indirekt, über push: , pop und top manipulier - bzw.
lesbar). Das bedeutet jedoch nicht, dass auf das von stackcontent benannte (Zwischen -
)Objekt nicht zugegriffen w erden kann — aufgrund der oben dargestellten Klassendefini-
tion ist nämlich noch unklar, wo das Objekt, das den Stack -Inhalt fasst, herkommt, so dass
nicht ausgeschlossen werden kann, dass bereits Aliase existieren (s. Abschnitt 1.8). Eine
Möglichkeit, dies auszuschließen, ist, das Stack -Objekt sein Zwischenobjekt selbst erzeugen
zu lassen. Dem wenden wir uns als nächstes zu.
"
"16 Parallelität: aktive und passive Objekte
Die objektorientierte Weltsicht, die auch in diesem Kurs propagiert wird (nämlich die von
den Objekten, die einander Nachrichten schicken und die auf den Empfang von Nachrichten
reagieren, indem sie ihren Zustand ändern und weitere Nachrichten verschicken), legt nahe,
dass Objekte aktiv sind, will sagen, dass sie über einen ei genen Rechen prozess verfügen.
Doch schon in Abschnitt 4.3.2 wurde klar, dass es damit in der Realität nicht weit her ist: Es
werden in der Praxis keine Nachrichten verschickt, sondern lediglich Methoden aufgerufen.
Abgesehen vom dynamischen Binden dieser Methoden unterscheidet sich damit das Aus-
führungsmodell der objektorientierte n Programmierung nicht von dem der prozeduralen
Programmierung (à la PASCAL ); insbesondere sind alle Objekte passiv (was soviel bedeutet,
wie dass sie nur aktiv sind, solange sie gerade eine Methode ausführen).
Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen,
der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann
nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation
aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Metho-
denaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf
entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektori-
entierte Programmierung in der Praxis auf passive.
Gleichwohl ist auch in der objektorientierten Programmierung Parallelver-
arbeitung möglich. Nur kommt sie (zumindest in SMALLTALK , aber auch z. B. in JAVA) nicht
in Form von aktiven Objekten daher, sondern in Form von parallelen Prozessen. Jeder dieser
Prozess e führt zu einer Zeit eine Methode aus; er besucht zwar mit dem Methodenaufruf
die Empfängerobjekte, diese bleiben jedoch selbst passiv (haben also kein Eigenleben). Streams auf Dateien
Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neue n Prozess
zu starten: Man schickt einfach einem Block die Nachricht fork . fork
entspricht im wesentlichen value , nur dass der Block dadurch in einem eigenen, unabhän-
gigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von fork auch nicht
darau f, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zu-
rückliefert; tatsächlich liefert sie auch nicht (wie value ) das Ergebnis des Blocks zurück,
sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann g eht
dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des
Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte
ändert.
Soll ein (paralleler) Prozess nicht sof ort starten, so braucht man ein Ob-
jekt, das diesen Prozess repräsentiert und dem man dann zu einem spä-
teren Zeitpunkt die Nachricht resume schicken kann, die den Prozess startet. Ein solches
Objekt erhält man, indem man dem Block newProcess schickt. Tatsäc hlich ist fork wie
folgt implementiert:
Um einen parametrisierten Block (also einen Block mit Parametern) als Prozess zu starten,
verwendet man statt newProcess newProcessWith: mit einem Array als Parameter, das
die tatsächlich en Parameter des Blocks enthält.
Mit den Nachrichten suspend und terminate kann man den Prozess
dann temporär anhalten bzw. beenden. Angehaltene Prozesse können
später mit resume wieder gestartet werden, beendete nicht.
Die Synchronisation von parallelen Prozessen erfolgt in SMALLTALK zu-
nächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen
dazu über zwei Methoden, wait und signal , und e ine Instanzvariable,
die für jedes Empfangen von signal um 1 erhöht und für jedes Empfangen von wait um
mit dem Objekt!) schlafen gelegt (mittels suspend ). Andernfalls läuft er weiter. Erhält der
Semaphor die Nachricht signal und es gibt noch Prozesse, die schlafen (erkennbar an
einem Zähler kleiner 1), dann kann ein Prozess , der an dem Semaphor wartet, aufgeweckt
werden (mittels resume ) und weitermachen.
Die Synchronisation mittels Semaphoren ist recht elementar und von ak-
tiven Objekten noch weit entfernt. Deutlich näher rückt man mit der
Klasse SharedQueue , deren Instanzen anstelle von Signalen (die ja ein-
fach nur gezählt werden) Objekte aufnehmen und die eine Synchronisa-
tion über next und nextPut: erlauben. Das Protokoll sieht wie folgt aus:
Wenn man nun eine solche Shared queue einem Objekt zuordnet und von anderen Objek-
ten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Me-
thode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das
Objekt mit einem Prozess , der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann
hat man tatsächlich „ aktive Objekte , die einander Nachrichten schicken“.
"
"52 EIFFEL
EIFFEL nimmt unter den hier behandelten Sprachen eine Sonderstellung ein. Es soll näm lich
mehrere Dinge auf einmal sein:
 eine Sprache für objektorientierte Analyse und Design,
 eine Sprache für kommerzielle Programmierung und
 eine akademische Lehrsprache.
Das herausragende Merkmal, das EIFFEL zu dieser Multifunktion qualifiziert, ist die Integra-
tion von Zusicherungen (die Formulierung von Vorbedingungen, Nachbedingungen und
Klasseninvarianten) , die, als Verträge zwischen
dienstanbietenden und dienstnehmenden Klassen interpretiert, erlauben, das Was einer
Software zumindest teilweise unabhängig vom Wie zu spezifizieren. Die Typsysteme, die Sie
in den vorangegangenen Kapiteln kennengelernt haben und von denen auch EIFFEL eines
besitzt, erlauben zwar auch schon, Zusicherungen auszudrü cken, aber die sind jeweils auf
die möglichen Werte einer Variable bezogen und bleiben dabei sowohl voneinander als
auch von der Zeit unabhängig. EIFFEL erlaubt darüber hinaus, nahezu beliebige Bedingungen
für Variablen - und Rückgabewerte von Methoden ausz udrücken, die sowohl auf andere
Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können.
EIFFEL tritt in vielerlei Hinsicht in die Fußstapfen von PASCAL : Es ist nicht
nur syntaktisch ähnlich, sondern ist auch um Sparsamkeit , Klarheit und
Orthogonalität der Konzepte bemüht. Viele Dinge sind in EIFFEL ein klein bisschen anders als
in anderen Sprachen, weswegen man meinen könnte, es sei aus Prinzip anders; d ie meisten
Abweichungen sind aber wohlbegründet und vermitteln mitunter eine angenehm andere
Perspektive auf vertraute Dinge. So ist es eigentlich nur folgerichtig, dass der Erschaffer von
EIFFEL, BERTRAND MEYER, Nachfolger von NIKLAUS WIRTH auf dessen Leh rstuhl an der ETH Zü-
rich wurde.
Es ist mir nicht ganz klar, warum EIFFEL kein größerer Erfolg beschieden ist — es mag zum
einen an der über Jahre absolut unzureichenden Implementierung der Werkzeuge liegen
(insbesondere des Compilers — es wurde anfangs noch nach C übersetzt; man male sich
aus, welche Freude man als Programmiererin beim Debuggen hatte) und zum anderen an
der Natur BERTRAND MEYERs, der sich mit seiner Kompromisslosigkeit nicht nur Freundinnen
gemacht hat. Eine Rolle spielt sicher auch das unmögliche, aber trotzdem angestrebte Spa-
gat zwischen kommerzieller Einsetzbarkeit und akademischer Eignung — viele Program-
mierweisen, die in der Praxis üblich sind und auf die kaum eine Entwicklerin verzichten will,
sind akademisch verpönt. Das Typsystem EIFFELs schließlich trägt, wie Sie sich in Abschnitt
52.5 selbst vergewissern können, auch nicht unbedingt zur Akzeptanz bei. Auf der ander en
Seite hat EIFFEL neben SMALLTALK noch am ehesten das Format, die Art, wie man über das
Programmieren denkt, zu beeinflussen.
"
"4.6.1 Verzweigung
Die einfache Verzweigung wird in SMALLTALK durch das Versenden eine Nachricht, die die
bedingt auszuführenden Anweisungen in Form eines Blocks als Parameter enthält, an einen
Wahrheitswert realisiert:
beispielsweise gibt genau dann die Meldung „x > 5“ auf der Konsole aus, wenn x > 5 zu
true auswertet.
Um zu verstehen, wie das funktioniert, sehen wir uns zunächst die Implementierung der
Verzweigung mittels ifTrue: an. Sie wird durch eine Methode ifTrue: aB lock reali-
siert, die als Parameter aBlock , also ein e Folge von Anweisungen , erhält, das sie, der Be-
deutung von If entsprechend, entweder ausführt oder eben nicht ausführt. Diese Methode
ist für die beiden Objekte true und false (genauer: für die beiden Objekte, die die Pseu-
dovariablen true und false benennen; siehe Abschnitt 1.7) jeweils unterschiedlich imple-
mentiert:
für true und
für false . Wenn also der Empfänger der Nachricht ifTrue: aBlock das Objekt true
ist, dann bewirkt die Auswertung, dass der Block aBlock ausgeführt wird; ist das Objekt
hingegen false , wird aBlock nicht ausgef ührt, was genau der Bedeutung der Nachricht
entspricht. So hat
genau den erwarteten Effekt. Aufgrund der Continuation bei Blöcken (s. Abschnitt 4.4.2 )
ist es möglich, aus einer Methode mittels ifTrue: bedingt zurückzukehren:
liefert true zurück, da durch die Auswertung des Blocks [^ true] per value in Zeile 197
nicht der Block, sondern die Methode returnEarly , beendet wird. W ie man sieht, hat das
zunächst etwas eigenwillig anmutende Konzept der Continuation in Kombination mit Re-
turn eine erhebliche programmierpraktische Relevanz.
Aus Symmetriegründen wird auch die Methode ifFalse: aBlock angeboten, die wie
folgt implementiert ist:
für true sowie
für false . Eigentlich viel zu banal, um es hinzuschreiben, aber da es nur ein einziges Mal
gemacht werden muss und dabei so etwas Fundamentales wie die Verzweigung realisiert,
kann man sich auch daran freuen.
Falls Sie dies dennoch für einen Budenzauber halten, dann haben Sie zu-
mindest nicht völlig unrecht: Die Verzweigu ng ist nä mlich gar nicht wirk-
lich aus dem Sprach kern verschwunden, sie ist nur an einer Stelle ver-
steckt , an der Sie sie vielleicht nicht vermuten: an der Stelle der Auswahl der Methode, die
in Reaktion auf den Empfang einer Nachricht ausgeführt wird (also beim dynamischen Bin-
den).
Selbsttestaufgabe 4.3
Überlegen Sie, wie Sie das aus anderen Sprachen bekannte If -then-else-Konstrukt in SMALLTALK rea-
lisieren würden und schreiben Sie die entsprechenden Methodendefinitionen auf.
Nach demselben Prinzip wie die einfache Fallunterscheidung vermeidet SMALLTALK übrigens
auch solche, die das Auftreten von nil betreffen. So ist zum Beispiel die Methode isNil
für nil als
und für alle anderen Objekte als
implementiert.
Selbsttestaufgabe 4.4
Überlegen Sie, wie Sie die logischen Operatoren and: , or: und not für true und false imple-
mentieren würden!
"
"45 Programmieren mit Interfaces
Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem
Interface veröffentlichten noch weitere öffentliche ( public deklarierte)
Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces ei-
ner Klasse un terschiedliche Methodenmengen zur Verfügung stellen können. Da auf einer Interfaces bieten
Variable, die mit einem Interfacetyp deklarierte wurde, aber immer nur die Methoden auf-
gerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgrei-
chen P rüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass
auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten kön-
nen), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt
gewährt werden. So kann beispielsweise ein Ein - und Ausgabestrom als Klasse zwei Inter-
faces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält
und das andere nur die zum Schreiben:
Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils
entweder nur lesend oder nur schreibend auf einen Ein -/Ausgabestrom
zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom
verweist, zum Typ hat:
Umgangen werden kann diese Zugriffsbeschränkung über Interfaces in
JAVA immer dann , wenn die Klasse, von dem das verwendete Objekt eine
Instanz ist, ebenfalls als Typ zur Verfügung steht — man kann in Variab-
lendeklarationen dann genauso gut die Klasse als Typ verwenden . So könnte man sowohl
in WillNurLesen die Variable eingabe als auch in WillNurSchreiben die Variable
ausgabe mit dem Typ IOStream deklarieren, hätte damit jedoch keine synta ktische Un-
terstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr.
C# geht hier einen Schritt weiter und ermöglicht Klassendefinitionen zumindest, ihre Me-Beschränkung des
Zugriffs
die Verwe ndung von
Interfaces in JAVA ist
thoden ausschließlich über Interfacetypen zugänglich zu machen (s. Kurseinheit 5, Ab-
schnitt 50.4.2 ). Seit JAVA 8 kann man allerdings in In terfaces auch statische Methoden de-
finieren, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern
und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff
mehr auf die Klassen, die deswegen als package local deklariert und die somit vollständig
hinter dem Interface als Schnittstelle verborgen werden können.
Interfaces dienen aber nicht nur der Beschränkung des Zugriffs wie im
obigen Beispiel — sie dienen auch der besseren Austauschbarkeit von
Klassen. Und das bringt uns zurück zum eingangs Kapitel 43 benutzten Beispiel (Zeile 1051
ff.): Dadurch, dass die Variable liste mit dem Typ List (ein Interface) und nicht
ArrayList (eine Klasse) deklariert wurde, können ihr auch Instanzen anderer Klassen als
ArrayList zugewiesen werden, solange sie nur dasselbe Interface implementieren. Das
Interface als Typ der Variable verlangt lediglich, dass alle in ihm versammelten Methoden
von d en Objekten, auf die die Variable per Typsystem verweisen darf, auch angeboten wer-
den, und das wird dadurch sichergestellt, dass der Typ der rechten Seite aller Zuweisungen
zur Variablen konform zum Typ der linken Seite sein muss . Die Zuweisungskompatibili tät ist
in JAVA also an die Typkonformität gebunden, und zwar an die nominale.
Eine weitere, vergleichsweise häufig verwendete Möglichkeit des Einsat-
zes von Interfaces ist die als sog. Tagging oder Marker interfaces . Ein
Tagging oder Marker interface hat in der Regel keine eigenen Methodendeklarationen, son-
dern dient lediglich der Filterung von Variablenwerten .
wäre ein solches Interface. Da in JAVA die vom Compiler statisch geprüfte Zuweisungskom-
patibilität ja Namenskonformität verlangt, kann die Typisierung einer Variable mit dem In-
terface Markiert erzwingen, dass dieser Variable nur Instanzen solcher Klassen zugewi e-
sen werden, die das Interface Markiert zu implementieren deklarieren. Da das Interface
aber keine Auflagen macht (keine Methodendeklarationen vorgibt, die von der Klasse mit
Definitionen versehen werden müssen), ist die Implementierung des Interfaces für die Klasse
zunächst ohne Konsequenzen. Die durch das Interface erfolgte Markierung der Klassen
(bzw. deren Instanzen) kann jedoch zur Übersetzungszeit vom Compiler (s. o.) und zur Lauf-
zeit durch einen Typtest (s. Abschnitt 44.2) überprüft werden.
Ein konkretes Beispiel für ein Marker interface in JAVA ist das Interface
Serializable, mit dessen Implementierung eine Klasse deklariert, dass
ihre Instanzen serialisiert werden können. Die Serialisierung wird aber nicht von der Klasse
selbst vorgenommen, sondern von einer anderen; die Klasse muss also zu ihrer Serialisierung
nichts weiter beitragen. Seit JAVA 5 würde man allerdings solche Marke r-Interfaces eher
durch Metadaten (auch Annotationen genannt; s. Abschnitt 47.4) ersetzen, so wie das in
C# schon länger gehandhabt wird (s. Abschnitt 50.4 in Kurseinheit 5). Interfaces erhöhen
JAVAs Interface -als-Typ-Konzept ist ziemlich interessant und vielleicht so-
gar der größte einzelne Beitrag JAVAs zur objektorientierten Programmierung. In der P ro-
grammierp raxis scheint es jedoch , sieht man einmal von großen Frameworks ab, nur lang-
sam anzukommen . Das mag zum einen an der schlechten Verkaufsstrategie liegen („Ersatz
für Mehrfachvererbung“ — jede Anfängerin merkt nach fünf Minuten, dass das nicht
stimm t), zum anderen aber auch an der Vergrößerung des Programmumfangs, die der pa-
rallele n Definition von Klassen und Interfaces geschuldet ist (die auch den Wartungsauf-
wand erhöhen kann, obwohl ja Interfaces eigentlich die Wartung vereinfachen sollen) . Für
so manche Programmiererin scheinen die Möglichkeiten, die Schnittst elle einer Klasse mit-
tels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, völlig auszureichen.
Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Kli-
enten sowie eine (häufig vorschnelle) Festlegung v on Variablen auf Instanzen einer Klasse.
Mehr zur sog. interfacebasierten Programmierung finden Sie im Kurs 01853 .
"
"67 Ausgewogene Verteilung
Ein weiteres Kennzeichen der objektorientierte n Programmierung ist, dass Klassen nicht ins
Uferlose wachsen. Wenn der Methodenumfang einer Klasse immer weiter ansteigt, wird
die erfahrene objektorientierte Programmiererin bald den Verdacht schöpfen, dass es sich
bei der Klasse in Wirklichkeit nicht um eine, sondern um mehr ere handelt. Dafür gibt es
zwei Erklärungen:
1. Die Klasse steht nicht für eine Abstraktion der Anwendungsdomäne, sondern für
mehrere. In diesem Fall sollte die Aufteilung der Klasse in mehrere — eine für jede
Abstraktion — leicht fallen: Man ordnet zunächst die Daten den Abstraktionen (All-
gemeinbegriffen) zu und lässt dann die Methoden den Daten folgen.
2. Die Klasse steht zwar für eine Abstraktion der Anwendungsdomäne, aber dies auf
einem höheren Abstraktionsniveau als das der Implementierung, die Sie gerade b e-
trachten. Dafür gibt es wiederum mindestens zwei mögliche Erklärungen:
in Bibliotheken umzusehen, bevor sie mit der Entwicklung eigener Ideen beginnt. so wenig wie
a. Die Abstraktion ist eine Generalisierung (s. Kurseinheit 1, Abschnitt 9.1) und
Sie haben all deren Spezialisierungen in einer Klasse zusammen gefasst . In
diesem Fall müssen Sie lediglich die unterschiedlichen Spezialisierungen
identifizieren und die jew eils darauf bezogenen (dafür charakteristischen)
Daten und Funktionen in neu zu schaffenden Subklassen verlagern. Ledig-
lich das allen Fällen gemeinsame Protokoll verbleibt dann in der (idealerweise
abstrakten) neuen Superklasse. Ein guter Indikator für die sen Fall ist das wie-
derholte Vorkommen gleicher Fallunterscheidungen , insbesondere dann,
wenn diese Fallunterscheidungen die Art der Objekte betreffen ( vgl. dazu
auch das sog. Replace -conditional -with-polymorphism -Refactoring).
b. Die Abstraktion ist eine Aggregation (oder Komposition , s. Kurseinheit 1,
Abschnitt 2.3), also eine Zusammensetzung eines Ganzen aus mehreren Tei-
len. In diesem Fall müssen Sie die Teile als logische Einheiten identifizieren
und dafür neue Klassen formulieren. Für den Fall, dass diese neuen Klassen
außerhalb der Abstraktion keine Bedeutung haben, können Sie in Erwägung
ziehen, sie als innere Klassen zu deklarieren (wenn Ihre Programmiersprache
das erlaubt), um so den Namensraum nicht zu überfrachten und die von
anderen wahrgenommene Zahl der Klassen nicht unnötig zu vergrößern.
"
"4.4 Blöcke
Wir kommen nun zu einer der wicht igsten Ausprägungen von SMALLTALK s Alles -ist-ein-Ob-
jekt-Motto: den Blöcken . Genau wie eine Methode ist ein Einteilun g in
Block eine abgegrenzte Sequenz , oder Folge, von Anweisungen. Anders als eine Methode
ist ein Block jedoch nicht benannt ; er kann aber benannt werden, indem er einer Variable
zugewiesen wird.
Um auszudrücken, dass eine Sequenz von Ausd rücken ein Block ist, wird
die Sequenz mit eckigen Klammern markiert. So ist
die Definition eines Blocks , der aus der Deklaration der Variable temp und
drei Zuweisungen besteht . Die Variablen x und y seien dabei a ußerhalb des Blocks , im Kon-
text des Blocks , deklariert. Dabei ist der Kontext des Blocks die Methode, in der er definiert
wurde.27
Bei der Ausführung des obigen Blocks wird ein neues Blockobjekt er-
zeugt. Mittels
wird der Block einer Variable swap zugewiesen. Die Anweisungen, die den Block ausma-
chen, werden dabei nicht ausgeführt, selb st dann nicht, wenn der Block (wie in Zeile 175)
isoliert steht und ausgeführt wird (das dabei erzeugte Objekt bleibt namenlos und wird von
der Speicherbereini gung wieder entfernt).
Um die Anweisungen, die einen Block ausmachen, zur Ausführung zu
bringen, muss man ihn auswerten. Dazu schickt man ihm die Nachricht
value . Der Ausdruck
bewirkt, dass die Variablen x und y aus dem Kontext des Blocks ihren Wert tauschen. Das
Objekt, zu dem swap value auswertet, ist das Objekt, zu dem die letzte Anweisung aus-
wertet (s. Abschnitt 4.2; im obigen Beispiel also der Inhalt von temp , der derselbe ist wie
der von x aus dem Kontext).
Rückgabewert der Methode value ist zunächst immer das Objekt, zu
dem der letzte Ausdruck eines Blocks auswertet , im obigen Beispiel das durch temp be-
nannte Objekt.
"
"4.6.3 Iteration
Wenn Sie If und While schon kennen, kennen Sie sicher auch For. Die klassische Form der
For-Schleife verwendet eine Zählvariable, einen Anfangswert, ein Inkrement (das auch ne-
gativ, also ein Dekrement sein kann) sowie einen Endwert. Solche For -Schleifen gibt es in
SMALLTALK auch:
beispielsweise gibt auf dem Transcript die Folge „531“ aus.
Wir schauen uns den Ausdruck aus Zeile 219 einmal genauer an. Dem
Objekt 5 wird offenbar eine Nachricht to:by:do: gesendet, wobei 5 der Startwert, der
Parameter zu to:, 1, der Endwert, der zu by:, –2, das Inkrement u nd der zu do: ein Block
ist. Der Block stellt offenbar, ähnlich wie bei der Realisierung der While -Schleife in SMALL-
TALK, den Schleifenrumpf dar; er hat einen Parameter i, der anscheinend als Zählvariable
fungiert. Tatsächlich wird die Methode to:by:do: in SMALLTALK EXPRESS wie folgt imple-
mentiert:
Hier interessiert uns aber vor allem eine Form der Iteration, die nicht einer einfachen Zähl-
schleife e ntspricht, sondern über eine Menge von beliebigen Objekten geht. Solche Mengen
sind uns ja schon begegnet, wenn auch nur in Gestalt von literalen Arrays.
Anders als in vielen anderen Sprachen kann man in SMALLTALK über die
Elemente eines Arrays direkt, also ohne die Verwendung einer Zählschleife, deren Laufvari-
able als Index in das Array dient, iterieren. So hat die Auswertung des Ausdrucks
exakt das gleiche Ergeb nis wie die des Ausdrucks aus Zeile 219, nämlich die Ausgabe von
„531“ auf dem Transcript. i ist aber diesmal keine Zählvariable, da hier nichts gezählt wird;
es ist vielmehr eine Laufvariable, der der Reihe nach die Elemente des literalen Arrays #(5
funktioniert genauso. do: ersetzt also ganz offensichtlich das aus man-
chen anderen Sprachen (seit der Version 5.0 auch aus JAVA) bekannte For -each-Konstrukt.
Wie wir gleich sehen werden, ist die Iteration, also das Fortschalten der Elemente und die
Überprü fung der Abbruchbedingung, in der Collection, über die iteriert wird, implementiert,
weswegen man das Verfahren auch interne Iteration nennt (in Abgrenzung von der her-
kömm lichen, externen Iteration , bei der die Laufvariable selbst gesetzt und abgefragt
werden muss ). Zählschleife
Die Implementier ung der Kontrollstruktur erfolgt wiederum selbst in
SMALLTALK und ist ziemlich einfach:
Dabei ist to:do: für Ganzahlen analog zu obigem to:by:do implementiert. Die Zählvari-
able index des Blocks von Zeile 238 läuft so von 1 bis zur Anzahl der indizierten Instanzva-
riablen des Empfängers von do: (im obigen Beispiel ein Array) , die über den Auf ruf von
size auf dem Empfänger (repräsentiert durch self ) abgefragt wird. Der Inhalt der indi-
zierten Instanzvariable n des Empfängers wird dann der Reihe nach als Parameter mittels
value: an den Block aBlock zur Auswertung geschickt.
"
"64 Kurze Methoden
Wer sich den Quellcode objektorientierter Programme ansieht, der wird auffallen, dass die
Methoden im Mittel ziemlich kurz sind. Wie bereits in Kurseinheit 6, Kapitel 56 erwähnt, ist
dies Folge des Umstandes, dass in der objektorientierten Programmierung die Funktionalität
auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Sobald ei ne
Funktion verschiedenartige Daten manipuliert (also Objekte, die Instanzen verschiedener
Klassen sind), ist es wahrscheinlich, dass diese Funktion nicht zur Gänze in einer Methode
implementiert wird.
Was hier zunächst wie eine unmittelbare Folge des objektorientierten Pa-
radigmas erscheint, hat sich zu einem objektorientierten Stil weiterentwi-
ckelt: Eine typische objektorientierte Programmiererin scheut sich nicht,
Methoden zu schreiben, die nur aus einer Zeile bestehen (oder die nur eine Anweisung,
wenn auch mit geschachtelten Ausdrücken, enthalten) — im Gegenteil, sie fühlt sich sogar
gut dabei, denn was sie da gerade produziert, gilt als objektorientierter Stil. So ist es sogar
üblich, Teile einer Methode in eine neue auszulag ern (das Extract -method -Refactoring, das
einige vielleicht aus ECLIPSE und ähnlichen Entwicklungsumgebungen kennen), auch wenn
dieser Teil (zunächst) ausschließlich von seiner ursprünglichen Position aus aufgerufen wird,
wenn es nur der besseren Lesbarkeit dient (also insbesondere Wiederverwendung keine
Rolle spielt). Ein po sitiver Begleiteffekt dieser starken Zergliederung von Funktionalität ist
die hohe Dichte an Bezeichnern in objektorientierten Programmen: Da jede Teilfunktion, die
in eine Methode ausgelagert wird, einen eigenen, eindeutigen (bis auf Überladen/Über-
schreib en) Namen haben muss , wird die Programmiererin dazu gezwungen, sich ständig (in
Form der Namenwahl für Bezeichner) dazu zu äußern, was sie gerade macht. automatische
"
"4.5.1 Sequenz
Die Sequenz als Kontrollstruktur besagt lediglich, dass textuell aufeinanderfolgende Anwei-
sungen ein es Programms (einer Methode) auch zeitlich nacheinander ausgeführt werden.
Die zeitliche Sequenz aufeinander folgender Anweisungen kann lediglich durch andere Kon-
trollstrukturen (in SMALLTALK nur durch den Methodenaufruf; s. u.) unterbrochen werden.
Dies g ilt auch für parallele Ausführung , die man sich wie die gleichzeitige Abarbeitung
zweier sequentieller Programme auf denselben Objekten vorstellen kann (s. Kapitel 16).
"
"43.1 Einfache parametrische Typdefinitionen
So, wie auch unparametrisierte (nicht generische) Typen in JAVA nicht aus eigenständigen
Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces
einhergehen, so werden auch parametrische (generische) Typen nicht separat definiert, son-
dern sind das Produkt parametrischer Klassen - bzw. Interfacedefinitionen. Da aber die for-
malen Typparameter einer Klassen - bzw. Interfacedefinition durch verschiedene Typen er-
setzt werden können, wird die alte 1:1 -Beziehung zwischen Klassen und Typen aufgebro-
chen: Jede Klasse, deren Definition einen Typparameter enthält, steht tats ächlich für eine
ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbe-
sondere führt die „Instanziierung“68 einer parametrisch definierten Klasse mit einem tat-
sächlich en Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Des-
wegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle
Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen
den Typparameter als Typ verwenden und sich insofern unterschei den.
Die klassische Anwendung generischer Typen findet man bei Collections:
Genauso, wie man in JAVA Arrays über einen bestimmten Elementtyp bil-
den kann, will man auch andere Arten von Collections über Elementtypen haben. Zu dies em
Zweck verfügt JAVA ähnlich wie SMALLTALK über eine ganze Reihe von Collection -Klassen
wie z. B. Sets (für Mengen) oder Maps (die JAVA-Variante von SMALLTALK s Dictionaries). Nun
sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefin ition JAVAs, son-
dern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine
Verwendung gedachte Klassen. Da es vor JAVA 5 keine Möglichkeit gab, bei der Deklaration
einer Variable mit einer Collection als Typ anzugeben, wel chen Typ die Elemente der Coll-
ection haben sollen, wurde implizit davon ausgegangen, dass diese vom Typ Object sind.
So hatte z. B. die Klasse ArrayList ein (privates) Feld elementData vom Typ Object[] ,
in dem die Elemente gespeichert wurden. Da Object Supertyp aller Referenztypen in JAVA
ist, konnten auch Instanzen aller Referenztypen in elementData und somit in Instanzen
von ArrayList gespeichert werden.
Dank der generischen Typen ist es aber möglich, bei der Deklaration einer Variable vom Typ
einer C ollection — in Analogie zur Deklaration einer Variable vom Typ eines Arrays über
einen Elementtyp — den Elementtyp mit anzugeben. Um beispielsweise eine Liste von Inte-
gern zu deklarieren und zu initialisieren , muss man lediglich
schreiben.69 Die Klassendefinition von ArrayList ist dazu wie folgt parametrisiert:
aus einem Metatyp erzeugt
die Klasse ArrayList , von der ihr In halt eine Instanz ist. Dies hat den Vorteil, dass die Instanz auch
gegen solche anderer Klassen ausgetauscht werden kann, solange diese nur ebenfalls den Typ List
implementieren. Sie sollten sich zur Angewohnheit machen, immer den allgemeinsten verfügbaren
Typ zu verwenden, solange Sie nicht eine speziellere Filterfunktion beabsichtigen. Anwendungsfall
Dabei ist das in spitzen Klammern stehende E der (formale) Typparameter der Definition von
ArrayList . Die bereits in Abschnitt 29.1 erwähnte Konvention, einzelne Großbuchstaben
für Typparameter zu wählen, wurde auch in JAVA übernommen, ganz einfach, um Typpara-
meter von Klassen - und Variablennamen im Programmtext besser un terscheiden zu können.
So steht E üblicherweise für den Elementtyp von Containern, wie es die Collections sind.
Durch die Sprachdefinition erzwungen wird das jedoch nicht.
Die Zuweisung von Zeile 1051 ist übrigens nur gültig, wenn der (para-
metrisierte) Typ ArrayList<Integer> Subtyp von List<Integer>
ist. Dies wird, in JAVA-Syntax, durch die Deklaration
(nominales Subtyping) sichergestellt. Man beachte, dass die Variable E hier eine logische
Bedingung ausdrückt, nämlich die, dass ein bei der Verwendung von ArrayList<E> an-
gegebener tatsächlich er Typparameter auch in die Definition von List<E> eingesetzt wer-
den muss .
Der Compiler weiß nun aufgrund der Ersetzung des formalen Parameters
E mit dem tatsächlich en Parameter Integer in Zeile 1051 , dass die Ele-
mente der Variable liste alle vom Typ Integer sind und dass eine Zuweisung der Form
typkorrekt ist. Um das zu überprüfen, muss er nämlich nur den Wert d es Typparameters in
der Deklaration von liste , Integer , in die Variable E der Implementierung von get ein-
setzen. Er kann dann feststellen, dass der Rückgabetyp des Ausdrucks mit der Variable zu-
weisungskompatibel ist. Man beachte, dass ohne Typparameter in Zeile 1064 eine Typum-
wandlung von Object auf Integer (Down cast ) notwendig wäre, die aber zu einem Lauf-
zeitfehler führen kann (s. Abschnitt 44.1). Die Einführung von Generics erhöht hingegen die
Typsicherheit statisch, also zur Übersetzungszeit. Ein fundamentaler Gewinn.
Nun wissen Sie ja bereits aus der Schilderung aus Kapitel 41, dass List<Integer> nicht
unbedingt ein Subtyp von List<Object> sein sollte, selbst wenn Integer ein Subtyp von
Object ist. Und so führt in JAVA bei generischen Typen anders als bei Arrays sc hon die
Zuweisung
(bei Beibehaltung obiger Deklaration von liste ) zu einem statischen Typfehler, der schon
während der Übersetzung gemeldet wird Man hat den oben diskutierten Kompromiss of-
fenbar nicht weiter fortführen wol len.
"
"47.2 Exception handling
Wie Sie schon bei den Anweisungen in Kapitel 38 gesehen haben, sieht JAVA ein sog. Excep-
tion handling vor. Beim Exception handling handelt es sich um eine Möglichkeit, bei der
Spezifikation des Kontrollflusses eines Programms zunächst mögl iche Ausnahmesituationen
und deren Behandlung unberücksichtigt zu lassen und so zu tun, als würde immer alles
gutgehen. Da das normalerweise auch der Fall sein sollte, erlaubt es sowohl der Auto rin als
auch der Leserin eines Programms, bei seiner hauptsächlichen Funktion zu bleiben, ganz
nach dem Motto „zu den Ausnahmen kommen wir später!“
Die möglichen Ausnahmesituationen eines Programms werden in JAVA in
Klassen ein geteilt , deren Instanzen jeweils eine konkrete Ausnahmesitu-
ation während des Programmablaufs repräsentieren. Wenn also beispielsweise in einem
Programm auf ein Element eines Arrays zugegriffen Exception -Klassen
und Try -catch -Blöcke
werden soll, dessen Index außerhalb der Grenzen des Arrays liegt, dann erzeugt die JVM,
die über die Einhaltung der Array -Grenzen wacht, eine Instanz der Klasse
ArrayIndexOutOfBoundsException und wirft diese. Dabei bedeutet das Werfen einer
Exception (genauer: einer Instanz einer Exception -Klasse), dass der Programmablauf an der
gegenwärtigen Stelle abgebrochen und an der nächsten Stelle fortgesetzt wird, die angibt,
den zum Typ (zur Klasse) der Exception -Instanz passenden Exception handler zu haben.
Dazu ist es notwendig, die Codestrecke, in der die Exception auftreten kann, mit einer Try -
catch -Klammer zu versehen, also mit einem Konstrukt der Form
wobei der Typ der geworfenen Exception idealerweise in einer de r Catch -Klauseln vor-
kommt. Ist dies nicht der Fall, gilt die Exception als durch die Try -catch -Klammer nicht be-
handelt und es wird die nächste umschließende Klammer gesucht (wobei mit nächste die
vorherige im Programmablauf gemeint ist). Wird auf diese Wei se keine passende Klausel
gefunden, wird das Programm mit einer entsprechenden Fehlermeldung („Exception in
thread …“) abgebrochen.
Ausnahmesituationen können aber nicht nur durch die JVM, sondern
auch durch das Programm selbst entdeckt und gemeldet (entsprechende Exceptions gewor-
fen) werden. Dazu dient die schon erwähnte Throw -Anweisung, die mittels einer Instanzi-
ierung der Exception -Klasse eine entsprechende Ausnahme wirft. So verlagert beispiels-
weise
den Test von der virtuellen Maschine ins Programm.
Try-catch -Anweisungen stehen wie fast alle Anweisungen in JAVA im
Rumpf von Methoden. Wenn eine Methode eine bestimmte Exception wirft, ohne sie selbst
zu fangen (also wenn die Throw -Anweisung nicht lokal von einer Try -catch -Anweisung um-
schlossen wird, die eine Catch -Klausel mit dem entsprechenden Typ enthält), dann verlangt
die JAVA-Sprachdefinition zunächst, dass die Methode dies deklariert, dass sie also bekannt-
gibt, dass sie u. U. eine Exception des genannten Typs werfen wird. Dies geschieht mittels
einer Throws -Klausel und sieht dann wie folgt aus:
Eine Methode, die diese Methode aufruft, muss also den Aufruf entweder mit einer Try -
catch -Anweisung klammern, die die geforderte Catch -Klausel enthält, oder selbst deklarie-
ren, die Exception zu werfen. Dies e Praxis führt zwar zu erheblicher Schreibarbeit, stellt aber
letztlich die einzige Möglichkeit dar, zu erzwingen, dass sich die Programmiererinnen der
möglichen Ausnahmesituationen, die auftreten können, bewusst sind, ohne die Spezifika-
tion des Kontrollflusses dadurch über Gebühr zu belasten. Jede, die schon einmal in C die
Aufrufe von B etriebssystemroutinen durch Abfrage der Return -Codes abzusichern versucht
hat, weiß, wovon ich spreche. Man nennt Exceptions, die ein Abfangen innerhalb einer
Methode oder eine Deklaration im Methodenkopf verlangen, Checked exceptions .
Nun gibt es aber Exceptions, die so gut wie überall auftreten können. Das prominenteste
Beispiel ist vielleicht die Out of memory exception , die auftritt, wenn eine Speicheranforde-
rung des Pr ogramms von der JVM nicht bedient werden kann. In der Praxis häufiger, wenn
auch durch das Programm selbst vermeidbar, ist die Null pointer exception , die immer auf-
tritt, wenn ein Ausdruck, auf dem ein Feld oder eine Methode zugegriffen werden soll, zu
null ausgewertet wird (vgl. Selbsttestaufgabe 11.1). In dieselbe Kategorie fällt auch die
Array index out of bounds exception , die sich natürlich durch vorsichtige Prog rammierung
vermeiden ließe, die aber in der Praxis trotzdem immer wieder vorkommt. In all diesen Fällen
wäre es außerordentlich mühsam, wenn man alle Anweisungen, bei denen die jeweilige
Exception auftreten könnte, mit einer entsprechenden Try -catch -Anweis ung absichern
müsste .
Deswegen gibt es in JAVA Exceptions, bei denen das nicht nötig ist, die
sogenannten Unchecked exceptions . Man könnte meinen, dass ob eine
Exception checked oder unchecked ist, von Fall zu Fall (von Auftreten zu Auftreten) von der
Programmiererin , die sie wirft, zu unterschei den wäre — dies ist aber nicht so. Statt dessen
sind alle Exceptions, die von der Klasse RuntimeException abgeleitet sind, per Definition
unchecked . RuntimeException ist selbst Subklasse der Klasse Exception , die wiederum
Subklasse von Throwable ist. Throwable ist die Superklasse aller Klassen, die in einer
Throw -Anweisung und in Catch -Zweigen bzw. Throws -Klauseln vorkommen dürfen. Mit
RuntimeException wird also ein Zweig der Exception -Klassenhierarchie eingeleitet, des-
sen Elemente alle unchecked sind.
Neben Exception ist auch Error Subklasse von Throwable . Errors je-
doch nicht gefangen werden , sondern zu einem sofortigen Programmabbruch führen. Die
Konstruktion
wobei die Auslassungszeichen für die Formulierung einer Invariante stehen, hat man früher
zur Emulation der inzwischen vorhandenen Assert -Anweisung verwendet; auch heute sollte
man Errors eigentlich nur während der Testphase eines Programms einsetzen. Gena u wie
Exceptions der Sorte RuntimeException sind Errors unchecked . Unchecked
"
"43.5 Generische Methoden
Außer in Typdefinitionen können Typvariablen (formale Typparameter) auch in Methoden-
definition eingeführt (deklariert) werden. In diesem Fall ist die Sichtbarkeit der Typparameter
auf die jeweilige Methode beschränkt.72 Es lassen sich damit variable Über - und Rückgabe-
parametertypen für eine Methode deklarieren.73 Die Belegung der Typparameter mit kon-
kreten Typen als Werten erfolgt dann bei der Bindung ein es Methodenaufrufs zur Überset-
zungszeit. Der tatsächlich e Typparameter muss dabei nicht angegeben werden, wenn er
sich aus dem Kontext eindeutig ergibt (sog. Typinferenz ).
So hande lt es sich beispielsweise bei der Deklaration
wobei T nicht zugleich Typparameter der die Methodendefinition enthaltenden Klasse sein
darf, um die Deklaration einer Methode, die ein Array eines beliebigen Typs, hier durch T
repräsentiert, in eine Liste mit Elementen desselben Typs konvertiert.
Beim Aufruf e iner parametrischen Methode muss der tatsächlich e Typparameter angegeben
werden. Allerdings erlaubt der Java -Compiler, diesen wegzulassen, wenn er sich aus dem
Aufruf erschließen lässt (die oben erwähnte Typinferenz). Bei obiger Methodendeklaration
ist das z. B. beim Aufruf
oder
der Fall: Hier wird der Typ Integer beziehungsweise String aus dem Typ des tatsächli-
chen Parameters abgeleitet. Dies ist jedoch nicht immer möglich; e in Aufruf wie
macht den tatsächlich en Typparameter dann explizit.
Selbsttestaufgabe 43.5
Erläutern Sie, welchen Nachteil die konventionelle Definition von toList(.) mit der Signatur
sendefinitionen kein e neuen Typen erzeugt werden.
Kurseinheit 3, Kapitel 30.
hat.
Der (formale) Typparameter einer generischen Methode kann zu nächst
an jeden beliebigen Typ gebunden werden. Genau wie bei generischen
Klassen reduziert dies jedoch entweder die Verwendbarkeit oder die Typ-
sicherheit der mit dem Parameter übergebenen Objekte, da deren Typ
innerhalb der Methode unbekannt ist. Es ist a lso, wieder genau wie bei generischen Klassen,
möglich, den Typparameter mit extends zu beschränken.
Nicht selten wird der Typparameter (nicht die mit ihm deklarierten Para-
meter!) innerhalb der Methode nicht mehr verwendet. Eine V ariable, die
nur einmal vorkommt, kann man aber auch weg - oder zumindest unbenannt lassen. Und
so ist es in diesen Fällen gute Praxis, anstelle des Typparameters ein (entsprechend be-
schränktes) Typ -Wildcard zu verwenden.
"
"4.4.1 Home context und Closure
Da Blöcke Objekte sind, die Variablen zugwiesen werden können, können sie auch an an-
dere Methoden übergeben werden. Werden sie dort (mittels value) ausgewertet, dann
Zweck in (temporäre) Methoden übersetzt, die keinem Objekt (oder nil) zugeordnet sind. Definition von
findet die Auswertung in einem anderen Kontext statt. In diesem sind die „freien“ Variablen
des Blocks (also die, die nicht selbst als lokale Variablen deklariert wurden; x und y in Zeile
175) aber gar nicht zugreifbar. Der Block nimmt deswegen seinen Kontext mit (oder, richti-
ger, der Ko ntext ist im Block mit eingeschlossen). Der Kontext, in dem ein Block definiert
wurde ( in dem das ihn repräs entierende Objekt erzeugt wurde) , nennt man seinen Home
context . Die Auswertung eines Blocks erfolgt stets in seinem Home context, insbesondere
auch dann, wenn ihm value in einem anderen Kontext gesendet wurde.
Das folgende Beispiel zweier Methoden soll den Sachverhalt erläutern:
gibt auf dem Transcript 2 aus, obwohl im Kontext von otherContext: die Variable x einen
Block und nicht 2 zum Wert hat. Die (Werte der) Pseudovariablen self und super zählen
übrigens auch zum Home context ; dies ist vor allem im Zusammenhang mit dem dynami-
schen Binden ( Kapitel 12 in Kurseinheit 2) interessant.
Dass ein Block aus seinem Home c ontext herausgelöst und in einem anderen gespeichert
werden kann beinhaltet das Problem, dass die lokale Variablen des Home conte xts schon
verschwunden sein können, wenn der Block ausgewertet wird. Die durch den Block „ein-
gefangenen“ lokalen Variablen (inkl. formale Parameter) müssen daher unabhängig von der
Ausführung der Methoden, die sie definieren, weiterleben. Die Umsetzu ng von Blöcken
durch den SMALLTALK -Compiler ist alles andere als trivial und verschiedene SMALLTALK -Sys-
teme unterscheiden sich darin zum Teil erheblich voneinander, was sich (leider) auch in un-
terschiedlichem Verhalten äußert.
Die Blöc ke SMALLTALK s heißen in anderen Sprachen übrigens (lexikalische)
Closures ; sie werden für die sog. Lambda -Ausdrücke , also (anonyme)
Funktionen, die selbst Objekte oder Werte sind und die deswegen aus ihrem Kontext her-
ausgelöst und in andere verschoben werden können, gebraucht . Dabei unterscheiden sich
die Sprachen zum Teil erheblich darin, was alles in eine Clos ure einbezogen werden kann;
so können die lokalen Namen (Variablen) beispielsweise auf Konstanten eingeschränkt wer-
den, um zu vermeiden , dass temporäre Variablen weiterleben müssen, weil sie in einer Clo-
sure entha lten sind.
"
"35.3 Variablen und Zuweisungen
JAVA ist eine stark typisierte Sprache: Alle Ausdrücke haben einen Typ. Das gilt auch für
Variablen, deren Typ bei ihrer Deklaration an gegeben werden muss . Syntax
In JAVA gibt es Variablen mit Referenz - und mit Wertsemantik . Welche
Semantik eine Variable hat, richtet sich nach ihrem Typ. Typen, die zu
Variablen mit Wertsemantik führen, sind die oben genannten primitiven , namentlich byte ,
short , int, long , float , double , boolean und char . Variablen, die mit einem anderen
Typ deklariert werden, haben Referenzsemantik.
Variablen werden in JAVA genau wie in SMALLTALK explizit per Zuwei-
sungsoperator = und implizit per Methodenaufruf Werte zugewiesen. Der
Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, der der
anderen Typen immer eine Referenz auf ein Objekt.
Es gibt in JAVA genau wie in SMALLTALK keine Möglichkeit, Pointervariablen explizit zu de-
klarieren; es gibt also insbesondere beim Methodenaufruf (und den damit verbundenen
impliziten Zuweisungen) auch in JAVA kein Call by reference , sondern nur ein Call by value .
Daran ändert auch nichts, dass Variablen, die mit Referenztypen deklari ert sind, Referenz-
semantik haben — bei den impliziten Zuweisungen eines Methodenaufrufs wird den for-
malen Parametern immer eine Kopie des Zeigers übergeben. Siehe dazu auch die Bemer-
kungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.
Seit JAVA 5 können Werte primitiven Typs an Variablen der entsprechen-
den Wrapper -Typen direkt zugewiesen werden und umgekehrt; dies
nennt man Auto boxing bzw. Auto unboxing . Dabei können allerdings, genau wie bei
der Handhabung bestimmter Werte als Objekte in SMALLTALK (s. Abschnitt 1.4 in Kursein-
heit 1), unerwartete Phänomene auftreten : Zwei Objekte, die den gleichen Wert repräsen-
tieren, sind zwar immer gleich, müssen aber nicht identisch sein. Man muss also auch in
JAVA genau überlegen, ob man die Equals -Methode oder den Test auf Identität (==) ver-
wendet; liegt man daneben, handelt man sich schwer zu findende Programmierfehler ein.
"
"29.4 Beschränkter parametrischer Polymorphismus
Obiges Beispiel hat gezeigt, dass die einfache Form des parametrischen Polymorphismus für
Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich ist: Da die
Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den
Typ implementierenden Klassen) keine Aussagen über den Typ machen. Außerhalb, bei der
Verwendung (Instanziierung) der Typdefinition, geht das s chon, da hier die Typvariable
durch einen Typ ersetzt ist.
Was man also gern hätte, ist, dass die Typvariable innerhalb der mit ihr
parametrisierten Typdefinition selbst wertbeschränkt ist, und zwar derart,
dass man bei den als Werte zulässigen Typen ein bestimmtes, benötigtes Protokoll voraus-
setzen kann. Die tatsächlich en Typparameter sind dann nicht mehr beliebig zu wählen, son-
dern nur noch aus solchen Typen, die die Einschränkungen erfüllen. Eine Möglichkeit, das
zu erzielen, wäre, Metatypen einzuführen, deren Wertebereiche Typen mit durch die Me-
tatypen vorgegebenen Eigenschaften sind. Diese Möglichkeit wird jedoch in der Praxis nicht
genutzt.
Stattdessen verwendet man eine Art der Beschränkung des Wertebe-
reichs von Typvariablen, die auf Subtyping beruht. Wenn man nämlich
erzwingen kann, dass ein tatsächlich er Typparameter (also der Wert der Typvariable) Subtyp
eines bestimmten Typs ist, der die benötigten Eigenschaften (Methoden) umfasst , dann ist
damit alles erreicht, was man benötigt: Aufgrund der Regeln des Subtyping hat jeder solche
Typ die Eigenschaften des Supertyps (s. Kapitel 26).
Ein solchermaßen durch einen Supertyp beschränkte parametrische
Typdefinition ist die folgende:
Typ MyCollection
Typvariablen E < Number
Der Rest der Definition geht wie oben. Der Ausdruck E < Number im Abschnitt „Typvari-
ablen“ ist Deklaration und Beschränkung zugleich; die Beschränkung ist aber wie gesagt
keine Typisierung wie in normalen Variablendeklarationen. Sie drückt vielmehr aus, dass die
Typen, die als Werte für E eingesetzt werden dürfen, Su btypen von Number sein müssen.
Die Deklaration aus Zeile 951 wird damit unzulässig und führt zu einem entsprechenden
Typfehler während der statischen Typprüfung ; die Deklaration
ist hingegen OK.
"
"8.5 Die Metaklassenleiter SMALLTALK s
Es müssen nach der SMALLTALK -Philosophie auch Metaklassen (als Objekte) Instanzen von
Klassen sein. Da es aber nicht mehr sinnvoll erscheint, jeder Metaklasse eigene Instanzvari-
ablen und Methoden zu geben, ist es nicht notwendig, dass jede Metaklasse (als Klasse)
ihre eigene Meta -Metaklasse (als Metaklasse der Klasse) hat. Vielmehr reicht es für die Praxis
aus, eine gemeinsame Meta -Metaklasse, von der alle Metaklassen Instanzen sind, vorzuse-
hen. SMALLTALK s Benennungspraxis, nach der jede Klasse so heißt, dass ihre Instanzen als
Subjek t den Satz „<eine Instanz> ist ein <Klassenname>“ korrekt ergänzen, folgend heißt
diese Klasse Metaclass (da eben alle ihre Instanzen Metaklassen sind).
Es ergibt sich sofort die Frage, von welcher Klasse die Klasse Metaclass
eine Instanz ist — tatsächlich muss ja nach der Philosophie SMALLTALK s,
nach der Klassen Objekte und jedes Objekt Instanz einer Klasse ist, auch Metaclass Instanz
einer Klasse sein. Um dieses Spiel nicht bis ins Unendliche fortsetzen zu müssen, hat man in
SMALLTALK zu einem einfachen Trick gegriffen: Man betrachtet die Klasse von Metaclass ,
also Metaclass class , selbst nur als einfache Metaklasse (obwohl sie ja eigentlich eine
Meta -Meta -Metaklasse ist), die, genau wie alle anderen Metaklassen, Instanz von
Metaclass sein muss . Es gilt also für Metaclass
Nachfolgendes Diagramm veranschaulicht die Zusammenhänge. Man beachte, dass alle Ob-
jekte bis auf die der Ebene 0 gleichzeitig Klassen und Instanzen sind. Der gestrichelte Pfeil
bezeichnet übrigens die Ist -eine-Instanz -von-Beziehung (in UML -Notation). Metaklasse der
Metaclass
Die theoretisch am bitionierte Leserin wird sofort bemerken, dass der
Kunstgriff der Terminierung der Ist -eine-Instanz -von-Beziehung es verbie-
tet, Klassen als Mengen von Objekten und deren Instanzen als Elemente
dieser Mengen im Sinne von Abschnitt 7.3 zu interpretieren: Sonst wäre nämlich die zu
Metaclass gehörende Menge von Objekten indirekt ein Element von sich selbst, was
schlechterdings unmöglich ist. Außer einem etwas faden Beigeschma ck hat das jedoch
keine praktischen Auswirkungen.
Wir haben es also in SMALLTALK mit einem mehrstufigen Zusammenspiel
von Klassen und Instanzen zu tun. Auf der untersten Stufe, der Ebene 0,
stehen kon krete Objekte, die nicht instanziierbar sind. Diese Objekte re-
präsentieren in der Regel Dinge aus dem Anwendungsbereich eines Programms, also zum
Beispiel konkrete Personen, Dokumente, Adressen etc. Eine Stufe darüber, auf Ebene 1,
stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte lie-
fern und anhand derer die Objekte der Ebene 0 (per Instanziierung) erzeugt werden. Diese
Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit; sie repräsentieren die
Konzepte o der Allgemeinbegriffe des Anwendungsbereichs. Zu jeder Klasse der Ebene 1
werden im Laufe des Programms in der Regel mehrere Objekte der Ebene 0 erzeugt — es
besteht also eine 1: n-Beziehung zwischen ihnen.
Nun sind auch die Klassen der Ebene 1 Objekte und damit selbst Instanzen von Klassen, die
eine Stufe höher, also auf Ebene 2 stehen. Die Klassen der Ebene 2, die Metaklassen, geben
die Definition der Klassen vor. Da es nicht sinnvoll ist, von Klassen der Ebene 1 mehrere
Exemplare zu haben, die, analog zu den Objekten der Ebene 0, alle über die gleiche Defini-
tion verfügen, hat jede Metaklasse genau eine Instanz. Es besteht also eine 1:1 -Beziehung
zwischen Metaklassen und ihren Instanzen, den Klassen der Ebene 1, die die Objekte der
Anwendung beschreiben.
Auf Ebene 3 bekommen alle Metaklassen eine gemeinsame Klasse spendiert, von der sie
eine Instanz sind, nämlich die Klasse Metaclass . Man beachte, dass hier wieder eine 1: n-
Beziehung vorliegt. Anders als auf Ebene 2, auf der man für die unterschiedlichen Konz epte Verlust der mengen-
einer Anwendung jeweils eine Klasse vorfindet, hat man hier, auf Ebene 3, die Vielfalt auf
genau eine Klasse verdichtet. Diese hat dann wieder genau eine Metaklasse.
Das nachfolgende Diagramm zeigt noch einmal die Reduktion durch die ersten vier Stu fen.
Eine ähnliche Verdichtung über vier Ebenen findet man übrigens auch beim Information
Resource Dictionary System (IRDS) der ISO .
Objekt Klasse Metaklasse Meta-Metaklasse
* 1 1 1 * 1
"
"51.5 Das Typsystem von C++
Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit star-
ker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst
wenig Laufzeit -Overhead zu erzielen. Dazu gibt es eigentlich nur einen Kommentar:
51.5.1 Statische Komponente
Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierte Er-
weiterung der Sprache C st ark auf Rückwärtskompatibilität geachtet. Und so findet sich
auch das Typsystem Cs vollständig in C++ wieder. Es gibt also primitive Datentypen wie
int, bool etc. und auch die Typkonstruktoren struct (entsprechend dem record
PASCAL s) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau
wie die durch Klassen definierten, Typen mit Wertsemantik. Es lassen sich aber auch, genau
wie in C, Zeigertypen darauf definieren.
Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor disku-
tierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen ab-
geleitet werden. Die S yntax von C++ sieht (analog zur mehrfachen Interface -Implementie-
rung bei C#) dazu vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen
Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten, wie in
Mehrfachvererbung
Klassenhierarchie More computing sins are committed in the name of efficiency (without
necessarily achieving it) than for any ot her single reaso n —
including blind stupidity.
W.A. Wulf
Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse
abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte
Superklasse). C++ kennt dafür keine Interfaces wie JAVA oder C#; sie müssen durch rein
abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Su-
pertypen eines Typs diese lbe Eigenschaft anders spezifizieren — der Subtyp hat dann einen
Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.
Obwohl die Zuweisungskompatibilität in C++ wie in JAVA über die Typ-
konformität an die Typerweiterun g gebunden ist und somit einer Variable eines Typs auch
Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C#) Me-
thoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt
immer die Methode aufger ufen wird, die in der Klasse definiert ist, deren Typ die Variable
(und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also
ignoriert, es sei denn, die betreffende Methode wurde mit virtual79 deklariert.
Bei virtuellen Methoden wird hingegen wie in JAVA zur Laufzeit geprüft, welchen Typs das
Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem
Zweck hält das Laufzeitsystem eine sog. Virtual function table , in der die zum Objekt pas-
sende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer
(sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängel t
hatte) und soll daher nur wenn unbedingt notwendig durchgeführt werden. Folge ist, dass
virtual (vor allem von SMALLTALK - und JAVA-Programmiererinnen ) gelegentlich vergessen
wird und Programme dann nicht wie erwartet funktionieren, oder dass die nachträgliche
Erweiterung einer Klasse, auf die eine Programmiererin selbst k einen Einfluss hat, um Sub-
klassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht
aufgerufen werden können. In JAVA hat man deswegen bewusst davon Abstand genommen
(und über lässt die Performanzsteigerung einem optimierenden Compiler); in C# hat man
diese Entscheidung nicht nachvollzogen (s. Abschnitt 50.2).
In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name
schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen
erzeugt werden können. Im Gegensatz zu JAVA (und genau wie z. B. in ADA) werden aus
Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expan-
diert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer T emplate)
ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus
wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typpa-
rameter darin durch tatsächlich e Typen ersetzt, das ganze dann mit einem n euen Namen
versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro -Mechanismus
angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.
werden. dynamisches Binden
Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt
nämlich Typumwandlungen (Type casts ; s. Kapitel 27). Ausdrücke der Form
überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ
<Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leid er vollkommen
ignoriert, welchen Typs das Objekt tatsächlich ist, und ob dieser Typ zuweisungskompatibel
mit <Typ> ist. Anders als in JAVA oder C# wird die Zulässigkeit dieser Typumwandlung auch
nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einm al überprüft werden (s. Ab-
"
"52.6 Zusicherungen in EIFFEL: Vorbedingungen, Nachbedingungen und Klasseninvarianten
Praktisch ein Alleinstellungsmerkmal EIFFELs ist die Integration von Zusicherungen in Form
von Vor - und Nachbedingungen bei Methodenaufrufen. Bei der Behandlung JAVAs war uns
ja schon die Assert -Anweisung begegnet, die es erlaubte, Zusicherungen zur Laufzeit aus-
zuwerten und das Programm ggf., bei einer Verletzung, abzubrechen. Da es sich aber um
eine Anweisung handelte, gab es keine von der Sprachdefinition vorgeseh enen Orte, an
denen solche Zusicherungen auftreten sollten — sie an passenden Stellen einzustreuen war
ganz der Programmiererin überlassen. In EIFFEL ist das anders.
EIFFELs Syntax zur Definition einer Methode sieht zwei Schlüsselwörter,
require und ensure , vor, von denen das erste vor der Definition der
Implementierung der Methode (dem Methodenrumpf), das zweite da-
nach auftreten k ann. Beiden Schlüsselwörtern folgen können Boolesche
Ausdrücke, die allesamt zu „wahr“ auswerten müssen. Die Idee hinter eine r Require -Klausel
ist, dass, damit die betreffende Methode richtig funktionieren kann, die darin ausgedrück-
ten Bedingungen erfüllt sein müssen. So ist es beispielsweise sinnvoll, für die Methode pop
der Klasse STACK zu verlangen, dass der betreffende Stack, auf dem die Methode aufge ru-
fen wird, nicht leer ist. Die Idee hinter einer Ensure -Klausel ist, dass eine Methode, deren
Require -Klausel erfüllt war, im Gegenzug garantieren muss , dass sie die in der Ensure -Klau-
sel ausgedrückten Bedingungen erfüllt. Im Beispiel des Stacks wäre das beispielsweise, dass
nach einem push das übergebene Element auch tatsächlich oben auf dem Stapel liegt, die
Methode top also beispielsweise das soeben auf den Stapel gelegte Element liefert. Um
ihre Bedingungen zu formulieren, dürfen die Ausdrücke in beide n Klauseln auf Abfragen
(queries) der Klasse zurückgreifen. Diese sollten dazu aber tunlichst nebeneffektfrei sein,
zum einen, weil die Ensure -Klausel sonst nicht garantieren kann, dass eine geprüfte Bedin-
gung auch nach ihrer vollständigen Abarbeitung imme r noch wahr ist (man bedenke nur,
was wäre, wenn die Ensure -Klausel zu push die Methode pop aufrufen würde!), zum an-
deren aber auch, weil auch in EIFFEL (wie in JAVA) die Überprüfung der Zusicherungen zur
Laufzeit abgestellt werden kann (weswegen dann das Programm mit Überprüfung der Zu-
sicherungen eine andere Semantik hätte als ohne; vgl. die Anmerkungen zu JAVAs Assert -
Anweisung in Kurseinheit 4, Kapitel 38).
Neben der Möglichkeit, Vor - und Nachbedingungen zu formulieren, gibt
es in EIFFEL noch die Möglichkeit, sog. Klasseninvarianten (Schlüsselwort
invariant ) zu deklarieren. Klasseninvarianten müssen jederzeit zwischen zwei Methoden-
aufrufen gelten; man kann sich vorstellen, dass sie jeder Vor - und Nachbedingung per Kon-
junktion hinzugefügt werden. Auf die etwas subtilen Probleme, die das Aliasing in Z usam-
menhang mit Zusicherungen schafft, wollen wir an dieser Stelle nicht eingehen; Kurs 01853
befasst sich ausführlicher damit.
Zusicherungen werden i n EIFFEL von Klassen auf ihre Subklassen vererbt.
Wenn dabei eine Methode redefiniert wird, dann dürfen auch Vor - und Vor- und
Nachbedingung angepasst werden. Allerdings gilt hier, dass die Vorbedingung nur aufge-
weicht, die Nachbedingung nur verschärft werden darf. Die Sprachdefinition EIFFELs stellt
die Einhaltung dieser Bedingung automatisch sicher, indem die Vorbedingung einer redefi-
nierten Methode mit der geerbten Vorbedingung implizit disjunktiv und die redefinierte
Nachbedingung mit der geerbten implizit konju nktiv verknüpft wird. Mehr zu diesem Thema
können Sie ebenfalls Kurs 01853 entnehmen.
Selbsttestaufgabe 52.1
Begründen Sie die eben geschilderten Verknüpfungen von geerbten und redefinierten Zusic herun-
gen. Können Sie einen Zusammenhang zu der Veränderung von Parametertypen beim Subtyping
herstellen? Fällt Ihnen etwas auf?
"
"13.2.3 Arrays
Nicht zuletzt werden auch ganz banale Arrays häufig verwendet, insbesondere wegen der
(bereits in Abschnitt 1.2 vorgestellten) Möglichkeit der einfachen literalen Definition . So
kann man ohne viel Aufwand über die Elemente einer beliebigen, ad hoc spezifizierten Auf-
zählung iterieren:
beispielsweise weist dem Laufparameter des Blocks, element , nacheinander die Elemente
des literalen Arrays zu.
Der wesentliche Nachteil von Arrays ist, dass ihre Größe beschränkt ist.
Benötigt man eine geordn ete Collection, die beliebig wachsen kann, der
also am Anfang, am Ende oder an einer beliebigen Position dazwischen Elemente hinzuge-
fügt werden können, dann kann man auf Instanzen der Klasse OrderedCollection zu-
rückgreifen. Diese eignen sich aufgrund des a ngebotenen Methodensatzes, ihres Protokolls ,
speziell für die Implementierung von Stapeln ( Stacks ) und Puffern ( Queues ).
"
"50.2 Gemeinsamk eiten mit und kleinere Unterschiede zu JAVA
C# unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und
Kontrollstrukturen angeht, nicht großartig von JAVA. Es ist in C# allerdings möglich, Opera-
toren (also z. B. +, –, == etc., abe r nicht new, ( ), ||, &&, =) zu überladen. C# besitzt dafür
das Schlüsselwort operator , das in einer Operatordefinition (die ansonsten so aussieht wie
eine Methodendefinition) vorangestellt wird:
Außerdem ist es in C# Konvention, Methodennamen mit einem Groß-
buchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für
viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C#,
Call by reference nach dem Vorbild PASCAL s (also ohne explizite Pointer; s. o.) zu erlauben
und damit Funktionen wie das Vertauschen von Va riableninhalten (die Meth ode swap ) si-
cher zu programmieren:
Allerdings muss ref — anders als in PASCAL var — auch an der Aufrufstelle verwendet
werden. Formale Parameter können auch mit out modifiz iert werden (wobei für die Auf-
rufstelle dasselbe gilt wie für ref):
Der Unterschied ist der, dass bei Verwendung von ref die Variable, die den tatsächlich en
Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekom-
men haben) muss , während dies bei out nicht der Fall ist. Dafür muss bei out der formale
Parameter in der Methode einen Wert zugewiesen bekommen. Dass ref und out in C#
anders als var in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil,
dass die Programmiererin weiß, dass ihre die tatsächlich en Parameter liefernden Variablen
nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer
Zuweisung in beide Richtungen (hin und zurück) aus. Call by reference
Selbsttestaufgabe 50.1
Überlegen Sie, welche Konsequenzen sich aus der Verwendung von ref bzw. out im Kontext des
Subtyping ergeben.
Sowohl ref als auch out ermöglichen, dass eine Methode mehr als einen Rückgabewert
hat. Da diese Mögli chkeit in JAVA und SMALLTALK fehlt, findet man in diesen Sprachen häufig
Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu
verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine
ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt
52.7).
Nun verdient C# im Kontext von Methodenaufrufen nicht nur lobende
Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C# keine
Throws -Klauseln in Methodendeklarationen gibt — die aus JAVA be-
kannte Unterscheidung von Checked exceptions und Unchecked excepti-
ons (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions.
Das bedeut et, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzu-
denken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie
weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen
werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass
bei einer stark geschichteten Architektur (beispielsweis e beim Einsatz von Middleware) das
Wissen um Exceptions auf der ganzen Wegstrecke von der Exception -Quelle bis zum Excep-
tion handler vorhanden sein muss , obwohl die mittleren Schichten naturgemäß an Art und
Auftreten von Ausnahmen keinerlei Interesse haben. Das mit JAVA Version 1.4 eingeführte
sog. Exception chaining erlaubt, eine Checked exception in einer Unchecked exception zu
verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut
zu werfen). Das sog. Exception tunneling bietet ebenfalls Abhilfe.
Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Un-
terschied bei Methoden erg ibt sich im Zusammenhang mit dem Über-
schreiben: Während in JAVA alle Methoden im Prinzip überschrieben wer-
den können (es sei denn, ihre Definition trägt den Zusatz final ), so dass der Compiler
zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C#, der Tra-
dition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu dekla-
rieren, und zwar mit dem Schlüsselwort virtual . Entsprechend muss eine überschreibende
Methode mit dem Schlüsselwort override deklariert werden. Soll hingegen eine Methode
gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie über-
schreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts
new bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanz-
gründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern
auch gewichtige programmiertechnische : Man markiert alle Stellen im Programm, an dene n
das sog. Fragile -base-class-Problem (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. keine Deklaration
Einige Sprachkonstrukte verwenden in C# andere Schlüsselwörter als
JAVA, so lock anstatt synchronized sowie foreach anstatt for für
die zweite Form von For -Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer
Bedeutung leicht von denen JAVAs ab: So sind auch Strings als Basis einer Switch -Anweisung
zugelassen (in JAVA erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anwei-
sung enthält, muss mit einer expliziten Kontroll flussanweisung ( break , goto , return oder
throw ) abgeschlossen werden. Außerdem hat C# eine Goto -Anweisung, mit der man je-
doch nicht in Blöcke hinein springen k ann. All dies hat allerdings nichts mit Objektorientie-
rung zu tun.
"
"54.2 Subtyping und das Prinzip der Substituierbarkeit
Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit
immer dann fraglich ist, wenn keine Typerweiterung vorliegt, wenn man es sogar insbeson-
dere mit einer Typeinschränkung zu tun hat. Dies soll nun etwas genauer beleuchtet wer-
den. Substituierbarkeit bei
In JAVA ist die Klasse Stack als Subklasse der Klasse Vector (die keinen
Vektor im mathematischen Sinne, sondern eher ein dynamisches, also in
seiner Größe wachsen könnendes Array repräsentiert) definiert. Das führt jedoch dazu, dass
an Stellen im Programm, an denen eine indizierte Sammlung von Objekten mit wahlfreiem
Zugriff (eben ein Objekt vom Typ Vector ) erwartet wird, ein Objekt vom Typ Stack auf-
tauchen kann, dessen interne Repräsentation zwar auf einem dynamischen Array á la
Vector aufbauen mag (und der deswegen davon erbt), der aber an seiner öffentlich zu-
gängigen Schnittstelle die Funktionen für den wahlfreien Zugriff unterdrücken muss (was in
JAVA allerdings nicht geht). Sollte nämlich das Programm, in Erwartung einer indizier ten
Sammlung, auf ein Element darin zugreifen wollen und anstelle dieser einen Stack vorfin-
den, kann das Programm nicht fortgesetzt werden, es sei denn, es findet vor dem Zugriff
eine entsprechende Prüfung (und ggf. eine Verzweigung zu alternativen Verfahr ensweisen)
statt. Eine solche Prüfung muss jedoch zur Laufzeit stattfinden; wird sie vergessen (nicht
implementiert) und es taucht an dieser Stelle ein Stack auf, dann hat man es mit einem
waschechten Programmierfehler zu tun. Immerhin lassen sich solche F ehler einfach vermei-
den, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.
Eine schwächere Variante, die aber ähnlich katastrophale Folgen haben
kann und deren Vorliegen nur schwer festzustellen ist, st ellt der Fall dar,
dass eine Funktion in einem Subtyp so abgeändert wird, dass sie dem (vom Supertypen)
erwarteten Verhalten widerspricht. Dies ist beispielsweise bei den beiden Typen Set
(Menge) und Bag (Multimenge) der Fall. Wenn man nämlich Set als Subt yp von Bag an-
nimmt, so könnte man das durchaus als eine Typeinschränkung begreifen, und zwar eine,
in der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den
Wertebereich {0, 1}) beschränkt ist. Die Funktionen „Hinzufügen eines Ele ments“, „Entfer-
nen eines Elements“ sowie die Angabe der Größe und der Test auf Enthaltensein eines
Elements werden von Set genau wie von Bag unterstützt; der einzige Unterschied scheint
zu sein, dass das Hinzufügen eines Elements, das in der Menge schon en thalten ist, diese
nicht verändert.
Bei genauerem Hinsehen ergibt sich aber das Problem, dass Set durch seine Eigenheit meh-
rere charakteristische Eigenschaften von Multimengen verletzt. So gilt für Sets beispiels-
weise nicht wie für Bags, dass jedes Hinzufü gen eines Elements die Größe um 1 anwachsen
lässt. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzu-
gefügt wurden; alle doppelten Einfügungen werden von Set einfach unterschlagen. Ein
Programm, das auf die Eigenschaften von Ba gs setzt und stattdessen mit einem Set arbeiten
muss , funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.
Umgekehrt würde, wenn man Bag als Subtyp von Set annehmen würde, die für Set cha-
rakteristische Eigenschaft, nämlich dass nach dem Entfernen eines Elements dieses nicht
mehr darin enthalten ist, verletzt. Programme, die darauf bauen, dass diese Eigenschaft
garantiert wird und die anstelle einer Menge eine Multimenge bekommen, funktionieren
nicht mehr korrekt. Je nach eingenommenem Standpunkt st ellt dies einen Typfehler dar. Stack als Subklasse
Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell
zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des
jeweils anderen implizieren, dass sie genauer im Widerspruch zueinander stehen. Deswegen
lassen sich keine korrekten Sätze wie „für alle Objekte vom Typ X gilt, …“ bilden, wobei die
Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y, der Subtyp
von X sein soll, einschließen soll. Dies entspricht jedoch genau der Definition des Subtypings
aus Kurseinheit 3, Abschnitt 26.1; tatsächlich ist es mehr oder weniger eine Frage der Aus-
legung, ob für den Tatbestand d es Subtypings die in Kapitel 26 genannten syntaktischen
Bedingungen, insbesondere die Ko - und Kontravarianz, ausreichen oder ob strengere Be-
dingungen der Substitui erbarkeit eingehalten werden müssen.
In der Praxis wird die Prüfung der Substituierbarkeit durch Type -checking -
Verfahren in Form der Prüfung der Typkonformität immer nur angenä-
hert; tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen
werden, wenn mangelnde Typkonformität vorliegt.86 Gleichwohl werden
entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet aber Typkonformität
nicht automatisch auch Substituierbarkeit — dazu ist auch eine Betrachtung des Verhaltens
notwendig.
"
"7.3 Instanziierung
Klassendefinitionen bilden also eine Art Vorlage für Objekte. Um nun von einer solchen
Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die De-
finition (Intension) festgelegt si nd, zu erzeugen, muss man sie instanziieren . Die Instanzi-
ierung ist ein Vorgang, bei dem ein neues Objekt entsteht — sie ist gewissermaßen die
Umkehrung der Klassifikation , also des Übergangs vom Individuum zu seiner Klasse (wobei
die Klassifikation, anders als die Instanziierung, in der Programmierung kein Vorgan g ist).
Vom erzeugten Objekt sagt man dann, es sei Instanz dieser Klasse . Tatsächlich spricht man
in SMALLTALK , da ja auch Klassen Objekte sind, häufig von Instanzen anstelle von Objekten,
wenn keine Klassen gemeint sind. Wie wir schon im nächsten Kapitel sehen werden, sind
in SMALLTALK jedoch auch Klassen Instanzen. So gesehen
handelt es sich bei den Begriffen Instanz und Klasse also eher um Rollen von Objekten, die
im Verhältnis der Instanz iierung zueinander stehen. Die Begriffsbildung der objektorientier-
ten Programmierung ist an dieser Stelle aber leider nicht besonders gelungen.29
In SMALLTALK ist jedes Objekt Instanz genau einer Klasse. (Genaugenom-
men ist es direkte Instanz genau einer Klasse, aber zum Unterschied zu
indirekten Instanzen kommen wir erst in Abschnitt 9.1.) Dabei weiß jedes Objekt , von wel-
cher Klasse es eine Instanz ist; diese Information lässt sich dem Objekt durch Senden der
Nachr icht class entlocken; der entsprechende Ausdruck liefert das Objekt, das die Klas se
repräsentiert, zurück .
Mit der Instanziierung wird der Extension einer Klasse ein neues Element
hinzugefügt. Das Elementsein auf Mengenebene entspricht also in etwa
dem Instanzsein auf programmiersprachlicher Ebene (in UML wie im obigen Diagramm
durch einen gestrichelten Pfeil angedeutet). Wir werden noch öfter auf diese mengentheo-
retische Interpretation zurückkommen.
Die Objekte, die wir in Kurseinheit 1 kennengelernt haben, wurden sämt-
lich durch Literale repräsentiert; diese Objekte sind, da sie vom Compiler
erzeugt werden, aus Sicht des Programms „schon da“, wenn es ausgeführt wird.30 Mittels
Instanziierung und Klassen hat man nun die Möglichkeit, neue — und neuartige — Objekte
programmatisch, also per Pr ogrammausführung, zu erzeugen. Dies geschieht standardmä-
ßig, indem man der Klasse, von der man eine Instanz haben möchte, die Nachricht new (für
Klassen ohne indizierte Instanzvariablen) oder new: (für Klassen mit indizierten Instanzvari-
ablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entspre-
chende primitive Methode des SMALLTALK -Systems; s. Abschnitt 4.3.7 ) im Speicher angelegt
und seine Instanzvariablen werden alle mit nil initialisiert. Der Parameter der Nachricht
von Objekten, nämlich solche, die instanziierbar sind, und solche, die es nicht sind. Instanziierbare
Objekte sind immer (auch) Klassen; für solche, die es nicht sind, gibt es leider keine spezielle Bezeich-
nung. Man könnte sie jedoch, wie wir in Abschnitt 8.5 sehen werden, Ebene -0-Objekte nennen.
kennen muss, damit er ihnen die Literale (anhand ihrer Syntax) zuordnen kann, um die richtigen
Objekte (Objekte der richtigen Klassen) zu erzeugen. Da Klassen (zumindest in SMALLTALK -80 und
allen davon abgeleiteten Dialekten) keine Schnittstelle zum Compiler haben, ist es auch nicht mög-
lich, für selbst definierte Klassen eigene literale Objektrepräsentationen zu kreieren.
Klasse
InstanzObjekte kennen ihre
new: muss immer eine natürliche Zahl sein und legt die Anzahl der indizierten Instanzva ri-
ablen fest, über die ein Objekt verfügt. Hat ein Objekt (per Klassendefinition; s. Ab-
schnitt 7.2) keine indizierten Instanzvariablen, führt new: zu einem Laufzeitfehler.
Einen neuen Stack mit Platz für 100 Elemente erhält man, indem man,
bei obiger erster Klassendefinition von Stack , den Ausdruck
auswertet. Dabei ist Stack wie gesagt eine Pseudovariable, die den Klassennamen trägt,
die auf das Objekt verweist, das die Klasse repräsentiert, und der ihr Wert beim Anlegen der
Klasse vom System zugewiesen wurde. In der zweiten Form der Implementierung wäre eben
dieser Ausdruck verboten: Stattdessen dürfte der Ausdruck dann nur noch
heißen. Dass der Stack dann trotzdem 100 Elemente halten kann, muss in diesem Fall bei
der Instanziierung des Zwischenobjekts, auf das die Variable stackcontent verweist, mit-
tels eines entsp rechenden New -Ausdrucks angegeben werden. Diese Instanziierung hatten
wir jedoch oben unterschlagen; wo und wie sie durchgeführt wird, wird Gegenstand des
nächsten Kapitel s sein, wenn es um Konstruktoren und Initialisierung geht.
Eine Alternative zum Instanziieren ist übrigens das Klonen . Beim Klonen
wird ein neues Objekt auf der Basis eines bereits existierenden erzeugt.
Der Klon stellt also eine Kopie dar. Beim Klonvorgang ist festzulegen, wie
weit (tief) das Kopieren gehen soll, also ob nur das Objekt oder auch seine Attributobjekte
und die, zu denen es in Beziehung steht (auf die die Instanzvariablen verweisen; s. Kapitel 2
in Kurseinheit 1) kopiert werden sollen. Während in prototypenbasierten objektorientierten
Programmiersprachen, die das Konzept der Klasse ja nicht kennen, Klonen die einzige Mög-
lichkeit ist, neue Objekte zu erstellen, müssen bei Programmiersprachen mit Klassen, in de-
nen jedes Objekt Instanz einer Klasse sein muss , Klone in der Regel durch Instanz iierung
und Übertragung der Inhalte der Instanzvariablen erzeugt werden. Da wir hier aber die klas-
senbasierte Linie verfolgen und auf klassenlose objektorientierte Programmiersprachen nur
eingehen, wo dies interessant erscheint, werden wir das Klonen, das in klassenbasierten
objektorientierten Programmiersprachen eine untergeordnete Rolle spielt, erst in Abschnitt
14.1 vertiefen.
"
"8.3 Factory -Methoden
Da in SMALLTALK Konstruktoren ganz normale Klassenmethoden sind, sind sie an keine be-
sonderen Konventionen gebunden. Sie müssen also insbesondere nicht ein neues Objekt
genau der Klasse, der sie angehören, zurückgeben. Dies nutzen die sog. Factory -Methoden
aus.
Eine Factory -Methode ist eine Methode, die wie ein Konstruktor eine
neue Instanz liefert, die aber die Klasse der Instanz von anderen Faktore n
als nur der Klasse, zu der die Methode gehört, abhängig macht. Zum Bei-
spiel könnte eine Klasse Number eine (Klassen -)Methode fromString: vorsehen, die an-
hand eines zu analysierenden Strings entweder eine Instanz der Klasse Integer oder eine Initialisierung von
der Klasse Float zurückgibt. Die Implementierung solcher Factory -Methoden ist in SMALL-
TALK leicht möglich; sie unterscheiden sich formal auch überhaupt nicht von Konstruktoren
— es sind einfach alles Klassenmethoden.34
Folgende Klassenmethode der Klasse Number (für beli ebige Zahlen) ist eine Factory -Me-
thode:
Klasse Number
Klassenmethoden
Wenn der Parameter aString einen Dezimalpunkt enthält, wird eine neue Fließkommazahl
zurückgegeben (mittels der Methode asFloat , die, in der Klasse String implementiert,
eine Instanz der Klasse Float zurückliefert), sonst eine Ganzzahl.
"
"22 Typäquivalenz
Es stellt sich nun die Frage, wann ein Typ mit einem anderen zuweisungskompatibel ist.
Offensichtlich ist dies der Fall, wenn die Typen dieselben (i dentisch) sind. Wie bereits oben
erwähnt, ist dies aber keine notwendige Voraussetzung für die Zuweisungskompatibilität.
Es ist nämlich zumindest auch möglich, dass sich zwei verschiedene Typdefinitionen bis auf
ihre Namen gleichen, dass also z. B. in STRONGTALK die die Typdefinitionen ausmachenden Sprachgebrauch ;
Mengen der Methodensignaturen gleich sind. Man spricht in diesen Fällen von einer
Typäquivalenz .
Von der Typäquivalenz gibt es zwei Arten: die nominale (sich auf den
Namen beziehende) Typäquivalenz, auch Namensäquivalenz genannt,
und die strukturelle Typäquivalenz, auch als Strukturäquivalenz be-
zeichnet. Während die nominale Typäquivalenz verlangt, dass zwei De-
klarationen (beispielsweise von Variablen) dieselben Typen anführen, damit Zuweisungs-
kompatibilität vorlieg t, kommt es bei der strukturellen Typäquivalenz lediglich darauf an,
dass die Typen paarweise gleich definiert sind (also die gleichen Eigenschaften von ihren
Werten verlangen), die Typen sich also in ihrer Struktur, aber nicht unbedingt in ihren Na-
men gle ichen.
Typäquivalenz ist eine symmetrische Eigenschaft: Wenn ein Typ A (nomi-
nal oder strukturell) äquivalent zu einem Typ B ist, dann ist B genauso
äquivalent zu A. Die Reflexivität der Typäquivalenz, also dass jeder Typ
äquivalent zu sich selbst ist, ergibt sich von selbst. Außerdem ist Typäquivalenz transitiv:
Wenn A (nominal oder strukturell) äquivalent zu B ist und B in der gleichen Art äquivalent
zu C, dann ist auch A äquivalent zu C (und, aufgrund der Symm etrie, C äquivalent zu A).
"
"47 Spezielle Klassen
Grundsätzlich sollte eine Klassenbibliothek mit den Mitteln der Sprache programmiert, an-
sonsten aber von der Spra chdefinition unabhängig und damit austauschbar sein. Dies gilt
natürlich genauso für die Prozeduren in imperativen Sprachen: Auch diese sollten nicht Teil
der Sprache, sondern lediglich darin geschrieben werden. Nun hat man sich aber schon bei
den edelsten imperativen Sprachen nicht daran gehalten (in PASCAL beispielsweise sind read
und write Bestandteil der Sprache und der Compiler weiß, dass ihnen — als einzigen Pro-
zeduren — beliebig viele Parameter übergeben werden dürfen, wobei jeder einzelne Para-
meter in seinem Typ nicht festgelegt ist); bei den objektorientierten tut man es erst recht
nicht. So sind in JAVA einige Klassen mit der Sprache fest vorgegeben und können nicht
beliebig ersetzt werden. Streams
"
"11.1 Bedeutung der Subklassenbeziehung
Die Bedeutung der Subklassenbeziehung variiert von Sprache zu Sprache. Wie Sie sich viel-
leicht schon gedacht haben, kann man die Subklassenbeziehung mit der Spezialisierungs-
beziehung gleichsetzen oder auch mit der Vererbung; es sind aber auch noch andere D efi-
nitionen möglich. Tatsächlich wird die hier als Subklassenbeziehung eingeführte Beziehung
zwischen Klassen auch gar nicht immer so genannt; entsprechend heißen dann die Rollen
auch nicht Sub - und Superklasse, sondern z. B. abgeleitete Klassen und Basisklassen . Im
Englischen sind hierfür neben Derived class und Base class auch die Begriffe Child class bzw.
Parent class in Gebrauch.
In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbezie-
hung gleichgesetzt. Eine Subklasse erbt demnach alle Instan zvariablen
und Methoden ihrer Superklasse. Dass sie darüber hinaus auch noch ihre Klassenvariablen
und -methoden erbt, ist nicht selbstverständlich; dies wird in Abschnitt 11.4 noch genauer
beleuchtet. Wichtig ist hier, festzuhalten, dass durch eine existierende Subklassenbeziehung
zwischen zwei Klassen nicht ausgedrückt wird, dass die Subklasse eine Spezialisierung der
Superklasse ist oder gar die Superklasse eine Generalisierung der Subklasse. Dies sicherzu-
stellen obliegt der Verantwortung der Programmiererin .
Jede neue Klasse, die in einem SMALLT ALK-System angelegt wird, muss
direkte Subklasse genau einer Klasse sein — es ist deshalb notwendig,
dass beim Erzeugen einer neuen Klasse die Superklasse mit angegeben
wird. Da wie bereits mehrfach erwähnt die SMALLTALK -Programmierung nicht dateibasiert
ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der An-
gabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise extends , das
die Subklassenbeziehung ausdrückt: Man legt vielmehr eine neue Klasse an, indem man
ihrer Superklasse eine entsprechende Nachricht schickt. Eine dazugehörige Methode hatten
Sie bereits in Abschnitt 8.4 gesehen.
Damit eine Subklassenbeziehung zwischen zwei Klassen zulässig ist, müs-
sen deren Definitionen bestimmte Bedingungen einhalten. In SMALLTALK
gilt dabei für neue, benannte Instanz - und Klassenvariablen, dass sie nicht
dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Su-
perklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse
solche hat, sie auch die Subklasse haben muss . Methodendefinitionen hingegen, die die-
selbe Methodensignatur verwenden, überschreiben einfach die geerb ten Methoden. Ent-
sprechende Regeln sind in anderen Programmiersprachen zum Teil erheblich komplexer. Subklassenbeziehung
Da die Subklassenbeziehung auch in SMALLTALK nicht reflexiv ist, muss es
mindestens eine Klasse geben, die keine Subklasse ist (und ents prechend keine Superklasse
hat). Es ist die Klasse Object , die oberste aller Superklassen. In ihr sind die Definitionen
angelegt, die den Instanzen aller Klassen zugute kommen sollen (also z. B. die Methode
printString ). Diese Methoden werden per Vererbung a uf alle anderen Klassen übertra-
gen, wodurch sie deren Instanzen zur Verfügung stehen. Eine ganze Reihe nützlicher Me-
thoden, die in Object definiert sind, werden wir in Kapitel 14 kennenlernen.
"
"62.2.1 Mechanische (syntaktische) Namenskonventionen
Eine gängige Namenskonvention ist beispielsweise, Namen von Interfacetypen mit einem
großen „I“ beginnen zu lassen. Andere Namenskonventionen verlangen, dass Bezeichner,
die für ein Objekt oder einen Wert ste hen (also Variablen und Funktionsnamen) den Typ
dieses Objekts oder Werts widerspiegeln — die sog. ungarische Notation , von der es aller-
dings verschiedene Auslegungen gibt . Nach einer, eher dümmlichen, Auslegung müssen
beispielsweise alle Variablen, die Strings bezeichnen, mit „str“ beginnen (eine Information,
die Compiler und IDE aber ohnehin bereithalt en und die deswegen nicht noch den Namen
belasten muss) . Nach einer sinnvolleren Auslegung sollten Variablen namen um die Verwen-
dung ihres so bezeichneten Inhalts ergänzt werden, also die Funktion des durch sie bezeich-
neten Objekts oder Werts innerhalb des Kontextes, in dem die Variable gültig ist, angeben.
Diese kontextbezogene Funktion kann in der objektorientierten Programmierung jedoch
auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration
der Variable ausgedrückt (u nd somit auch vom Compiler überprüft) werden.
"
"54 Das Problem der Substituierbarkeit
In Kapitel 26 sind wir ja schon ausführlicher auf den Begriff des Subtypings eingegangen.
Das Subtyping sollte Zuweisungskompatibilität zwischen verschiedenen Typen gestatten,
also erlauben, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Super-
typs, zugewiesen werden. Das führt nun zu dem Problem, dass man — aufgrund des dyna-
mischen Bindens von Methodenaufrufen — bei Vorliegen des Programmfragments
selbst bei Kenntnis des Typs T nicht sagen kann, welchen Effekt der Aufruf von Methode m
in Zeile 1509 hat.82 Nach den Regeln gängiger objektorientierter Programmiersprachen zur
Zuweisungskom patibilität weiß man lediglich, dass es sich beim Typ des Empfängerobjekts
e um einen Subtyp von T handeln muss83 — man weiß aber nicht, um welchen. Bei stati-
scher, lokaler Betrachtung84, also bei mangelnder Kenntnis des Typs des von e bezeichneten
Objekts s owie aller infrage kommenden Subtypen von T, tappt man hier vollkommen im
Dunkeln. Da die Erweiterung um Subklassen bzw. Subtypen aber gerade eine der Errungen-
schaften der objektorientierten Programmierung ist, hat man es dabei mit einem echten
Problem zu tun.
Das Problem lässt sich als ein Problem der formalen Programmverifikation ausdrücken: Wie
lässt sich
denaufrufe nur unter Berücksichtigung des Empfängerobjekts gebunden werden.
P {e m} Q (54.1)
also dass bei Vorliegen der Bedingung P vor Ausführung des Methodenaufrufs e m nach
dessen Ausführung die Bedingung Q eingehalten wird, beweisen? Ein solcher Beweis ver-
langt immerhin genaue Kenntnis davon, was der Methodenaufruf tut, oder vielmehr, wel-
chen Effekt dieses Tun hat. Dazu muss man aber die Implementierung der Methode ken nen.
Umgekehrt ist es für die Pflege und Weiterentwicklung eines Programms wichtig zu wissen,
welchen Bedingungen die Methoden einer in ein Programm neu eingeführten Klasse genü-
gen müssen, damit das Programm auch hinterher noch funktioniert. Wenn die neue Imple-
mentierung sich in den Kanon der bereits bestehenden einordnet, ohne ein unerwartetes
Verhalten einzubringen, wenn sie also für alle Aufrufe gemachte Zusicherungen der Form
von (54.1) einhält, dann ist das Funktionieren nicht gefährdet — andernfalls hingegen
schon. Nur um das zu garantieren, müssen die Bedingungen bekannt sein.
Es stellt sich also die Frage, wie man den Effekt aller Implementierungen von m für Subtypen
von T (einschl ießlich T selbst) fassen kann. Eine naive Beantwortung der Frage würde vor-
schlagen, dass man sic h alle diese Implementierungen ansieht und auf dieser Basis eine
Fallunterscheidung präsentiert: Wenn das Objekt e vom Typ T ist, dann hat m den und den
Effekt, wenn es von Subtyp T1 ist, dann hat m den und den Effekt usw. Die Zusammenfas-
sung dieser Fallunterscheidungen würde dann alle Effekte mit logisch Oder verknüpfen.
Diese Möglichkeit hat jedoch neben ihrer unnötigen Sperrigkeit den Nachteil, dass dabei
noch gar nicht vorhandene Implementierungen unberücksichtig t bleiben müssen. Was man
stattdessen möchte, ist die Gewissheit , dass eine lokale, „modulare“ Betrachtung ausrei cht
und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss , um zu
entschlüsseln, was ein Methodenaufruf bewirken könnte. Genau dies soll der Begriff der
Substituierbarkeit bringen.
"
"4.3.8 Protokoll
In SMALLTALK ist das Interface eines Objekts die Menge der Nachrichten, die es versteht.
Dieses Interface wird in Form der sog. Protokollbeschreibung o. kurz des Protok olls spe-
zifiziert, die aus den Methodensignaturen und den Kommentaren der zu den Nachrichten
passenden Methoden besteht und der die Implementation , also die Liste der Meth oden-
rümpfe , gegenübersteht. Letztere sind, zusammen mit den Instanzvariablen, das Imple-
mentationsgeheimnis eines Objekts, das hin ter seiner Protokollbeschreibung (dem Inter-
face) verborgen wird. Die Kommentare dürfen übrigens, wie in den meisten anderen Spra-
chen auch, als (schwacher) Ersatz für eine formale Spezifikation des Verhaltens, das in einer
Methode implementiert wird, angese hen werden (vgl. dazu Abschnitt 52.6 in Kursein-
heit 5).
Um die Programmierung zu erleichtern, wird in den meisten SMALLTALK -
Systemen das Protokoll von Objekten in sog. Nachrichtenkategorien
eingeteilt, die jeweils einen Namen tragen, der die in der Kategorie ent-
haltenen Namen zusammenfasst . Da jede Methode in genau eine Nachrichtenkategorie fal-
len muss , stellen diese eine Partitionierung des Interfaces eines Objekts dar. Unter den Ka-
tegorien sind solche, die das Wort „private“ enthalten; deren Methoden sollten dann nicht
„von außerhalb“, also nur vom Objekt selbst (über self ) aufgerufen werden. Dies wird
jedoch nicht vom Compiler erzwungen. Nachrichtenkategorien haben auch sonst keinerlei
die Programmausführung betreffende Bedeutung, sondern dienen lediglich der besseren
Lesbarkeit.
Wie Sie in der nächsten Kurseinheit lernen werden, werden Protokolle in SMALLTALK nicht
auf Objektebene, sondern auf Klassenebene spezifiziert. In STRONGTALK , einer Erweiterung
von SMALLTALK um ein (optionales) Typsystem, werden Protokolle dann zu Typen erhoben
(s. Kurseinheit 3, Kapitel 20). Da Protokolle nur Methoden enthalten, sind sie den Interfaces
JAVAs sehr ähnlich. Tatsächlich werden Protokolle in STRONGTALK auch manchmal Interfaces
genannt .
"
"50.3.1 Properties
Properties sind gewissermaßen die Umkehrung von Zugriffsmethoden ( Settern und Get-
tern; s. Abschnitt 4.3.4 in Kurseinheit 1): Anstatt auf ein Feld eines Objektes über Methoden
(lesend und schreibend) zuzugreifen, ruft man Methoden über das auf, was syntaktisch wie
ein Feldzugriff aussieht. Dies erlaubt einer , (lesende und schreibende) Feldzugriffe mit Ne-
beneffekten zu versehen (wie z. B. einer dynamischen Typprüfung bei schreibendem Zugriff,
wenn man kovariante Redefinition imitieren will). Konkret: Anstatt des (auch in JAVA übli-
chen)
kann man in C# alternativ
schreiben. Dabei sind get und set Schlüsselwörter von C# und value ist eine spezielle
Variable (vergleichbar mit this ), die den Eingabewert eines Setters hält. Um einem Punkt
seine Koordinaten zuzuweisen bzw. darauf zuzugreifen, kann man dann die Properties X,
Y, Winkel und Radius wie Felder verwenden:
Keine große Sache, aber es macht den Code auf Aufruferinnenseite knapper und besser
lesbar. Den Getter oder den Setter kann m an wahlweise auch weglassen; auf diese Weise
lassen sich Felder mit Nur -lese- bzw. Nur -schreib -Zugriff simulieren.
"
"13.1 Pflegen von : n-Beziehungen
Um : n-Beziehungen zu pflegen, also um Objekte zu einer Beziehung hinzuzufügen und
wieder zu entfernen, sieht SMALLTALK standardmäßig die Methoden add: und remove:
vor, die beide jeweils das Argumentobjekt zurückliefern. Beide sind in der abstrakten Klasse
Collection definiert, die Wurzel einer Hierarchie von Klassen , den Collection -Klassen , ist,
die allesamt der Verwirklichung von : n-Beziehungen dienen. Unsere Zwischenobjekte, die
diese Beziehungen repräsentieren, sind also alle indir ekte Instanzen von Collection .
Die Methoden add: und remove: bleiben zunächst (in Collection )
abstrakt:
Da sie von der tatsächlichen Realisierung einer Collection abhängen, können sie erst in den
entsprechenden Subklassen (durch Überschreiben ) realisiert werden.
Beim Entfernen eines Objektes aus einer Collection43 mittels remove:
gibt es zwei Sonderfälle zu berücksichtigen: Das Objekt ist nicht vorhan-
den oder das Obje kt ist mehrfach vorhanden. Im ersten Fall wird ein Fehler gemeldet, wäh-
rend im zweiten nur ein Vorkommen des Objekts aus der Collection entfernt wird (das erste,
wie auch immer die Reihenfolge festgelegt ist). Da es immer vorkommen kann, dass ein zu
entfer nendes Objekt gar nicht vorhanden ist, und ein entsprechender vorheriger Test auf
Vorhandensein (s. u.) wieder so eine stereotype Handlung ist, bietet SMALLTALK eine Variante
von remove: , die einem genau das erspart: remove: anObject ifAbsent:
anExceptionB lock . Sollte das zu entfernende Objekt fehlen, wird stattdessen
anExceptionBlock ausgeführt und dessen Ergebnis zurückgeliefert. Will man, dass beim
Versuch, ein nicht vorhandenes Objekt zu entfernen, nichts passiert, so gibt man einfach
den leeren Block [] für anExceptionBlock an. Sollen mehrere Objekte auf einmal einer
Beziehung hinzugefügt bzw. daraus entfernt werden, so stehen hierfür die Methoden
addAll: aCollection bzw. removeAll: aCollection zur Verfügung, die jeweils
eine Collection als Parameter er warten.
wusstsein, dass es sich bei den entsprechenden Instanzen p rinzipiell um eigenständige Objekte han-
delt, die hier lediglich die Funktion eines Zwischenobjektes haben, also dem Zweck der Realisierung
der Beziehungen dienen. Methoden add: und
Subklassen von Collection müssen also die Methoden add: und
remove:ifAbsent: überschreiben. Dabei offenbart sich gleich ein Cha-
rakterzug SMALLTALK s: Da seine Klassenhierarchie keine Generalisierungs-
hierarchie ist, kommt es vor, dass Subklassen die Methoden add: ,
remove: und remove:ifAbsent: löschen. Während beispielsweise in der Klasse
OrderedCollection add: und remove:ifAbsent: mit
überschrieben werden, werden sie in der Klasse FixedSizeCollection , die ebenfalls
eine Subklasse vo n Collection ist, gelöscht :
Die Methoden add: und remove: werden durch die Methoden
addAll: und removeAll: komplettiert; die Implementierung von
addAll: können Sie den Zeilen 427–431 oben (Abschnitt 10.3) entnehmen, removeAll:
verläuft im Prinzip analog (warum SMALLTALK EXPRESS hier eine Kopie zurückgibt, weiß ich
nicht). Die Methode addAll: wird dazu benutzt, eine Collection in eine andere zu konver-
tieren:
Dabei ist addAll: nur einmal, nämlich in Collection , definiert. Man beachte, dass dabei
ein Objekt nicht seine Klasse wechselt, sondern lediglich der Inhalt einer Collection in eine
neue übertragen wird. Diese Übertragung ist immer dann sinnvoll, wenn die Klasse der
neuen Collection Eigenschaften hat, die man gern nutzen möchte. Ein Be ispiel hierfür finden
Sie in Zeile 525 unten . Die Nachricht yourself (von Object geerbt) liefert übrigens ihren
Empfänger zurück ; sie wird am Ende von kaskadierten Nachrichtenausdrücken in Return -
Anweisungen verwendet, um den Empfänger zurückzuliefern .
Zum Pflegen seiner Beziehungen ist es manchmal vorteilhaft, zu wissen,
mit wie vielen Objekten m an in Beziehung steht und mit welchen. Die
Klasse Collection sieht dafür die Methoden size , isEmpty und
notEmpty , includes: sowie occurencesOf: vor, die jeweils die na-
hegelegte Bedeutung haben.
"
"9.1 Generalisierung
Nun entspricht, wie eingangs (in Abschnitt 7.1) erwähnt, die Klassifikation sprachlich der
Ist-ein-Abstraktionsbeziehung zwischen Individuen und ihren Klassen: „Peter ist ein
Mensch“, „ SMALLTALK ist eine Programmiersprache“ usw. sind alles Beispiele für eine Art
der Abstr aktion, bei der man von einem Individuum zu seinem Allgemeinbegriff übergeht.
Es gibt aber noch eine zweite Form der Ist -ein-Abstraktion, die sich von der ersten funda-
mental unterscheidet, die aber ebenfalls eine charakteristische Rolle in der objektorient ier-
ten Programmierung spielt: die Generalisierung . Sprachlich offenbart sich diese in Sätzen
wie „ein Mensch ist ein Säugetier“, „ein Säugetier ist ein Lebewesen“ oder „eine Program-
miersprache ist ein Werkzeug“. Der Unterschied zur ersten Form der Abstraktion liegt dabei
offensichtlich darin, dass hier zwei Allgemeinbegriffe und nicht ein Individuum und ein All-
gemeinbegriff miteinander ins Verhältnis gesetzt werden. Ein weiter er, etwas subtilerer,
aber sehr wesentlicher Unterschied ist der, dass die Klassifikation nicht transitiv ist, die Ge-
neralisierung hingegen schon. So folgt aus „ein Mensch ist ein Säugetier“ und „ein Säuge-
tier ist ein Lebewesen“ wohl „ein Mensch ist ein Le bewesen“, aber aus „Peter ist ein
Mensch“ und „Mensch ist eine Art“ nicht „Peter ist eine Art“.
Selbsttestaufgabe 9.1
Ordnen Sie der nachfolgenden Sequenz von Ist -ein-Sätzen die jeweilige Form der Abstraktion zu:
1. Clyde ist ein Elefant.
2. Elefant ist ein Säugetier.
3. Säugetier ist ein Wirbeltier.
4. Wirbeltier ist ein Stamm.
5. Stamm ist ein Taxon.
6. Elefant ist eine Spezies.
7. Spezies ist ein Taxon.
Bilden Sie alle daraus ableitbaren Ist -ein-Sätze und bestimmen Sie die längste Ableitung.
Beim Vorgang der Generalisierung werden mehrere Klassen, deren Defi-
nitionen inhaltlich verwandt sind, zusammen gefasst , wobei das Ergebnis
der Generalisierung , ebenfalls Generalisieru ng genannt, eine Klasse ist,
die nur diejenigen Elemente der Definitionen der generalisierten Klassen enthält, die allen
gemeinsam sind. So lässt sich beispielsweise aus den beiden ähnlichen, aber nicht gleichen
Klassen Mensch
Klasse Mensch
benannte Instanzvariablen linkesBein rechtesBein aufenthaltsort verstand
indizierte Instanzvariablen nein
Instanzmethoden
und Vogel
Klasse Vogel
benannte Instanzvariablen linkesBein rechtesBein aufenthaltsort flügel
indizierte Instanzvariablen nein
Instanzmethoden
per Vorgang Generalisierung die Klasse Zweibeiner
Klasse Zweibeiner
benannte Instanzvariablen linkesBein rechtesBein aufenthaltsort
indizierte Instanzvariablen nein Vorgang und
Instanzmethoden
herausfaktorisieren, deren Definition, als Ergebnis der Generalisierung der Klassen Mensch
und Vogel , genau die gemeinsamen Eigenschaften (Instanzvariablen und Methoden) ent-
hält.
Da die Eigenschaften, die einer Generalisierung als Klasse zugeordnet
sind, per Definition automatisch auch für alle Klassen, von denen die Ge-
neralisierung abstrahiert, gelten (denn das war ja die Bedingung für die Konstruktion der
Generalisierung), brauch en diese die Eigenschaften nicht zu wiederholen, sondern stattdes-
sen nur noch ihre Generalisierung anzugeben. Diese Klassen müssen dann nur noch die
Unterschiede, die sie von Zweibeiner sowie von einander unterscheiden, definieren:
Klasse Mensch
Generali sierung Zweibeiner
benannte Instanzvariablen verstand
indizierte Instanzvariablen nein
Instanzmethoden
bzw.
Klasse Vogel
Generalisierung Zweibeiner
benannte Instanzvariablen flügel
indizierte Instanzvariablen nein
Instanzmethoden
Diese zweite Form der Abstraktion, die Generalisierung, ist also genau wie die Klassifikation
Bestandteil der klassenbasierten objektorientierten Programmierung. Anders als bei der
Klassifikation ist bei der Generalisierung aber die Höhe der Abstraktionshi erarchie nicht
durch praktische Überlegungen beschränkt, sondern kann von der Programmiererin nach
Belieben angelegt werden. Sprachphilosophisch sind Generalisierungen näm lich genau wie
Klassen Allgemeinbegriffe ; sie sind nur noch allgemeiner. Generalisierungen können somit
selbst Generalisierungen haben un d so weiter; wie sich das für eine Abstraktionshierarchie
gehört, werden die Definitionen, die Intensionen , dabei immer knapper. Gleichzeitig wä chst Ökonomie der
jedoch die Extension (das bereits in Abschnitt 7.1 erwähnte Prinzip vom inversen Zusam-
menhang der beiden).
Abgeschaut ist das Prinzip der Generalisierung übrigens von Aristoteles ’
Prinzip von Genus et differentia , der gemeinsamen Abstammung und den
Unterschieden: Das Genus ist die nächst allgemeinere K ategorie, unter die die Objekte der
zu generalisierenden Klassen (der Spezies) a uch fallen, und die Differentia sind die Kriterien,
nach denen sich die Objekte aufgrund ihrer Natur, wie sie in den verschiedenen Klassende-
finitionen festgelegt (und nicht etwa durch spezielle Werte von Instanzvariablen bestimmt)
ist, unterscheiden. So haben eben die Klassen Mensch und Vogel das gemeinsame Genus
Zweibeiner als (biologisch nic ht ganz korrekte) Generalisierung: In ihr ist festgelegt, dass alle
Exemplare von Zweibeinern (und damit auch von Menschen und Vögeln) ein linkes und ein
rechtes Bein sowie einen Aufenthaltsort haben . Die Unterschiede (Differentia ) sind dann in
den jeweili gen Klassen herausgearbeitet. Man beachte, dass Genera keine eigenen Indivi-
duen haben, also keine Individuen, die nicht Individuen einer ihrer Spezies wären. So gibt
es keine Zweibeiner, die nicht entweder Mensch oder Vogel wäre n.35
Genau wie die Klassifikation hat das Ordnungsprinzip der Generalisierung
eine einfache mengentheoretische Interpretation. Demnach enthält die
Menge der Instanzen einer Generalisierung alle Instanzen der Klassen, von denen sie eine
Generalisierung ist. Wenn also Mensch und Vogel Ausgangsklassen einer Generalisierung
Zweibeiner sind, dann ist die Menge der Instanzen, die Zweibeiner repräsentiert (für
die Zweibeiner den Allgemeinbegriff abgibt) eine Obermenge der Vereinigung der Menge
der Instanzen von Mensch und Vogel . Die Menge der Instanzen von Zweibeiner ist eine
echte Obermenge, wenn Zweibeiner auch noch eigene Instanzen hat (also Instanzen, die
nicht Instanzen von Mensch und Vogel sind; im Kontext der Instanziierung würde man von
direkten Instanzen sprechen; s. Abschnitt 7.3); sonst ist sie nur eine unechte Obermenge
(also genau gleich der Vereinigung). Die nachfolgende Grafik zeigt den Zusammenhang
(wobei die schwarzen Punkte die Instanzen und die Ellipsen die Klassen darstellen sollen).
Gute Praxis (und hier angedeutet) ist, wenn Generalisierungen keine eigenen, direkten In-
stanzen haben, also Genera im obigen Sinne sind. Dies ist in der objektorientierten Praxis
aber (leider) längst nicht immer selbstverständlich, wie sich im nächsten Kapitel noch zeigen
wird (vgl. dazu auch Kapitel 69 in Kurseinheit 7).
Universum
Zweibeiner
Mensch Vogel
Die mengentheoretische Interpretation von Generalisierung als Obermengenbildung legt
nahe, dass Instanzen von Mensch und Vogel (als Elemente der entsprechenden Extensio-
nen) auch Instanzen von Zweibeiner sind. Wenn man das so sehen will, dann sollte man
aber zur notwendigen Unterscheidung von indirekten Instanzen (anstelle von direkten
Instanzen ; s. Abschnitt 7.3) sprechen.
Bei der Generalisierung können also Eigenschaften, die verschiedene,
aber ähnliche Klassen unterscheiden, weggelassen („wegabstrahiert“)
werden. Das Weglassen ist aber nicht die einzig mögliche Form der Ge-
neralisierung: Es können auch Eigenschafte n generalisiert werden, wobei dann der Begriff
der Generalisierung rekursiv zur Anwendung kommt. Dabei versteht man unter der Gene-
ralisierung von Attributen (oder allgemeiner von Instanzvariablen; s. Abschnitt 2.4), dass ihr
Wertebereich von einem spezielleren (kleineren) zu einem allgemeineren (größeren) aufge-
weitet wird. So würde beispielsweise das Attribut aufenthaltsort , das mit (Instanzen
der) Klasse Mensch assoziiert ist, beim Übergang zur Generalisierung Zweibeiner von
Punkten auf der Erdoberfläche zu Punkten einschließlich des Luftraums darüber generali-
siert, so dass es auch den Wertebereich für Vögel abdeckt. In SMALLTALK gibt es aber keine
Möglichkeit, Attributen per Deklaration Wertebereiche zuzuordnen; wie Sie noch sehen
werden, erlauben zudem aus gutem Grund die wenigsten Programmiersprachen, die die
Möglichkeit der Wertebeschränkung von Variablen vorsehen, Attributwertebereiche bei der
Generalisierun g ebenfalls zu generalisieren (die sog. kovariante Redefinition ; s. dazu auch
die Kapitel 25 und Abschnitt 26.3 in Kurseinheit 3).
Auch wenn bislang so getan wurde, also sei die Generalisierung etwas in
der Natur des betrachteten Gegenstandes liegendes, so gibt es in der Pra-
xis jedoch oftmals verschiedene Gesichtspunkte, nach denen man Gene-
ralisierungen durchführen kann. So ist z. B. die Generalisierung von Vogel bzw. Mensch
zu Zweibeiner nicht die einzig mögliche (und sicher nicht die einzig sinnvolle). Es könnte
also durchaus sein, dass man mehrere, voneinander unabhängige Generalisierungshierar-
chien konstruieren möchte, in denen durchaus dieselben Klassen auftauchen. In der Praxis
verliert man dadurch jedoch die strikte Hierarchieform der Generalisierung (da sich mehrere
Hierarchien überlagern), es sei denn, man erlaubt, verschiedene Arten der Genera lisierung
voneinander zu unterscheiden. Beides bringt jedoch einiges an Komplikationen mit sich, so
dass wir hier auf „Mehrfachgeneralisierungen“ nicht eingehen werden. Generalisierung ohne
"
"36.2 Subklassenbeziehung
Es ist in JAVA wie in SMALLTALK vorgesehen , dass alle Klassen außer Object von bereits
existierenden ab leiten. JAVA verwendet dazu das Schlüsselwor t extends :
Methoden
innere Klassen
Klassenvariablen und
-methoden in JAVA
„statisch“ heißt nicht
Es wird dadurch das Bestehen einer Subklassenbeziehung zwischen B und A deklariert. Die
Verwendung von extends legt bereits nahe, dass es sich dabei zugleich um eine Typerwei-
terung handelt, aus der (gemäß Kapitel 23) Zuweisungskompatibilität folgt; tatsächlich ist
das auch so.
Durch Angabe einer Extends -Klausel gibt eine Klasse an, von welcher anderen Klasse sie die
nicht static deklarierten Member erbt. Da die erbende Klasse, auch in JAVA Subklasse
genannt, die geerbten Methoden nur invariant überschreiben darf (und geerbte Felder in
ihrer Sichtbarkeit nicht reduziert werden dürfen; s. Abschnitt 39.1), ist ihr Typ automatisch
Subtyp des Typs der Klasse, von der sie erbt.
Genau wie in SMALLTALK gibt es in JAVA abstrakte Klassen . Anders als
SMALLTALK spendiert JAVA jedoch ein Schlüsselwort abstract , mit dem man eine Klasse als
abstrakt und damit als nicht instanziierbar deklarieren kann. Man schreibt dazu einfach
Das bedeutet, dass von einer solchen Klasse keine Instanzen mehr gebildet werden dürfen
(vgl. Abschnitt 10.3). Dabei ist dieses Verbot, dessen Beachtung vom Compiler überprüft
wird, vollkommen unabhängig davon, ob von der Klasse Instanzen gebildet werden könnten
— selbst wenn alles, was man für das Funktionieren der Instanzen benötigt, in der Klasse
vorhanden is t (einschließlich Konstruktoren) , darf sie nicht instanziiert werden. Sehr viel
häufiger ist aber der Fall, dass der Klasse die Implementierung von einer oder mehreren (bis
hin zu allen) benötigten Methoden fehlt; diese Methoden werden dann in der Klasse l edig-
lich deklariert, und zwar ebenfalls mit dem Schlüsselwort abstract :
Man gibt dann hinter der Methodensignatur (also dem Namen und den Parametern) keine
Implementierung (in geschweiften Kl ammern) an, sondern lediglich ein abschließendes Se-
mikolon. Im Gegensatz dazu muss te ja in SMALLTALK eine abstrakte Methode durch einen
Aufruf von implementedBySubclass o. ä. gekennzeichnet (s. Abschnitt 10.3 in Kursein-
heit 2) werden.
Die Aufforderung, eine abstrakte Methode in einer Subklasse z u imple-
mentieren, gibt es in JAVA auch, allerdings nicht per Laufzeitfehler auf
Programmaus führungsebene, sondern auf Compilerebene. Wenn man nämlich von einer
abstrakten Klasse (per extends ) ableitet, dann muss die abgeleitete Klasse entweder selbst
als abstrakt deklariert sein oder man muss alle abstrakten Methoden der Klasse, von der sie
ableitet, mit Implementierungen versehen. Tut man das nicht, erhält man vom Compiler
eine entsprechende Aufforderung.
Komplementär zur Abstract -Deklaration gibt es in JAVA auch die Möglich-
keit, zu verhindern, dass von einer Klasse abgeleitet wird: Man schreibt
dazu anstelle von abstract einfach final . Dasselbe gilt für einzelne Methoden, deren
Übersch reiben in einer Subklasse man durch eine Final -Deklaration verhindern kann. Eine abstrakte Klassen
einfache, goldene Regel der objektorientierten Programmierung ist übrigens, dass man alle
Klassen entweder als abstrakt oder als final deklarieren sollte; dies setzt das Prinz ip der abs-
trakten Generalisierungen durch und vermeidet die Probleme von nur von Vererbung ge-
triebenen Klassenhierarchien ( Kapitel 9 in Kurseinheit 2 und 69 in Kurseinheit 6).
"
"7.1 Klassifikation
Durch die Zuordnung von Individuen oder Objekten zu Allgemeinbegriffen oder Klassen
findet eine Klassifikation statt. Diese Klassifikation erlaubt e ine Ordnung oder Strukturie-
rung der Anwendungsdomäne, indem bestimmte Aussagen nur noch für die Klassen ge-
troffen werden müssen und nicht mehr für jedes einzelne Objekt. Anstatt also wie in der
vorangegangenen Kurseinheit Instanzvariablen und Methoden dire kt Objekten zuzuordnen,
verbindet man sie mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigen-
schaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die
einzelnen Objekte, die zu der Klasse gehören, beschre iben.
In diesem Zusammenhang ist es sinnvoll, die Unterscheidung von Exten-
sion und Intension eines Begriffs ins Spiel zu bringen. Unter der Exten-
sion (Ausdehnung oder Erstreckung) eines (Allgemein -)Begriffs versteht
man die Menge der Objekte, die darunterfallen. Im Fall von Person etwa ist das die Menge
aller Personen, im Fall von Dokument die Menge aller Dokumente. Die Intension (nicht zu
verwechseln mit Intention!) eines (Allgemein -)Begriffs hingegen ist die Summe der Merk-
male, die den Begriff ausmachen und die die Objekte, die darunter fallen, charakterisieren.
Sie ist gewissermaßen das Auswahlprädikat oder die charakteristisch e Funktion, die zu ei-
nem beliebigen Element entscheidet, ob es unter den Begriff fällt. Schon Aristoteles fiel auf,
dass Intension und Extension in einem inver sen Größenverhältnis zueinander stehen: Mit
wachsender Intension schrumpft die Extension und umgek ehrt. Dies ist freilich nicht weiter
verwunderlich: Je umfangreicher die Charakterisierung einer Menge von Objekten ist, d. h.,
je strenger die Bedingungen sind, die ein Objekt erfüllen muss , um dazuzugehören, desto
weniger Objekte erfüllen diese Bedingung en und desto kleiner ist entsprechend die Menge.
Wir werden in Kapitel 9 noch einmal darauf zurückkommen. Charakterisierung
Allgemeinbeg riffe sind die Vorbilder für Klassen in der objektorientierten
Programmierung. Interessanterweise bildet eine wichtige philosophische
Abweichung vom Glauben an die Adäquatheit von Allgemeinbegriffen, die Idee der Fami-
lienähnlichkeiten , wie sie von Ludwig Wittgenstein in seiner späten Philosophie entworfen
wurde, die Grundlage für die schon erwähnte Alternative zu den Klassen, nämlich die Pro-
totypen . Die Idee Wittgensteins, wie auch der prototypenbasierten Programmierung, ist,
dass ein Allgemeinbegriff (eine Klasse) niemals eine adäquate Beschreibung aller Individuen
(Objekte) sein kann, die man mit dem Begriff verbindet. Wittgenstei n verwendet dafür das
Beispiel vom Spiel: Auch wenn es Spiele gibt, die einander stark ähneln, so ist der Begriff
vom Spiel doch nicht so scharf gefasst , dass es eine Grenze gäbe, innerhalb derer etwas ein
Spiel wie alle anderen, außerhalb derer es aber kein Spiel mehr ist. Vielmehr gibt es, nach
Wittgenstein, mehr oder weniger „spielhafte“ Spiele, also p rototypische Spiele und solche,
die diesen mehr oder weniger gleichen.
Zwar gibt es Anwendungsdomänen, in denen Wittgensteins Familienähn-
lichkeiten die Sachlage besser beschreiben als die traditionellen Allge-
meinbegriffe (man denke z. B. an Musik, in der es zwar Töne und Noten gibt, aber dennoch
zwei Töne selten genau gleich klingen sollen und die Notenzeichen entsprechend vielfältig
variieren) , aber insgesamt sind die üblichen Anwendungen doch eher der Natur, dass es von
einigen wenigen Sorten eine große Menge von Objekten gibt, die alle mehr oder weniger
gleich zu behandeln sind. Und so vereinfachen Allgemeinbegriffe, oder Klassen, unsere
Weltsicht ganz erheblich und damit auch die Programme, die wir schreiben, um unsere
Weltsicht zu reflektieren.
Nachdem wir uns also auf Klassen festgelegt haben, können wir nun endlich zur Lüftung
des Geheimnisses kommen, wo in einem SMALLTALK -Programm die Instanzvariablen und
Methoden, die Objekte ihr eigen nennen, vereinbart (deklari ert) und im Falle der Methoden
auch definiert (mit Inhalt versehen) werden: in Klassen.
"
"22.2 Namensäquivalenz
Nun können Typen neben ihrer formalen Funktion, Fehler zu vermeiden,
noch eine inhaltliche, nämlich eine Filterfunktion ausfüllen. Diese setzt
allerdings voraus, dass dem Typ auch eine Bedeutung, die über seine
bloße Struktur (seine Syntax) hinausgeht, beigemessen werden kann. Dies geschieht heute
vor allem durch die Benennung des Typs, die dann, gepaart mit Namensäquivalenz als Be-
dingung der Zuweisungskompatibilität, verlangt, dass einer Variable nur Werte gleicher Be-
deutung zugewiesen werden können. Eine Zuweisung einer Wohnung an ein Büro oder
umgekehrt ist dann, trotz im obigen Beispiel strukturell gleich definierter Typen und deswe-
gen ausbleibenden Typfehlern, aufgrund fehlender Namensgleichheit ausgeschlossen, was
auch sinnvoll ist, da es sich dabei mit einer gewissen Wahrschein lichkeit um einen logischen
Programmierfehler handelt, der auf mechanische Art sonst kaum zu entdecken wäre. Die
Filterfunktion der geforderten Namensäquivalenz drückt also eher eine Absicht der Pro-
grammiererin aus denn eine technische Notwendigkeit. Die Bedeutung gerade dieser Funk-
tion sollte man jedoch nicht unterschätzen — nur wenige Möglichkeiten, Fehler in einem
Programm aufzudecken bzw. zu vermeiden, sind so einfach zu h aben.
Ein der Typprüfung per Namensäquivalenz ähnliches Prinzip kommt übri-
gens in der Physik zur Anwendung: Bei ihren Berechnungen führen Physikerinnen stets eine
Art Typprüfung durch, indem sie nicht nur mit den Beträgen der physikalisc hen Größen,
sondern auch mit deren Einheiten rechnen. Wenn Physikerinnen also beispielsweise eine
Geschwindigkeit berechnen und bei der Behandlung der Einheiten etwas anderes als m/s
herauskommt, dann steckt im Rechenvorgang ein Fehler — das Ergebnis hat n icht den rich-
tigen Typ (die richtige Einheit) und ist deswegen mit hoher Wahrscheinlichkeit falsch.
Namensäquivalenz hat aber auch einen entscheidenden Nachteil: Sie
setzt voraus, dass getrennt voneinander entwickelte Programm e zumin-
dest an ihren Schnittstellen (also da, wo Objekte ausgetauscht werden) dieselben Typen
verwenden. Dies kann für die Interoperabilität von getrennt voneinander entwickelten Pro-
grammen (wie z. B. Web services) ein echtes Hindernis sein.
Strukturelle Typäquivalenz bietet mehr Flexibilität als nominale: Sie er-
laubt Äquivalenz von Typen, bei deren Definition man vom jeweils ande-
ren nichts wusste . Die erhöhte Flexibilität hat jedoch ihren Preis: Zufällige strukturelle Über-
einstimmun gen können zu einer Äquivalenz führen, die nicht der intendierten Semantik
entspricht. Type branding führt in solchen Fällen eine Namensäquivalenz durch die Hin tertür
ein, mit dem Vorteil, dass diese optional ist. inhaltliche
Filterfunktion der
Typprüfung
Rechnen mit Größen
Nachteil der
Namensäquivalenz
strukturell vs .
"
"44 Dynamische Typprüfung in JAVA
Wie Sie gesehen haben, hat das Typsystem JAVAs eine starke statische Komponente. Gleich-
wohl können nicht alle Typprüfungen zur Übersetzungszeit durchgeführt werden. Während
man die dynamischen Typprüfungen bei Arrays (Kapitel 41) noch durch die Einführung von
Wildcards hätte vermeiden können, gilt das nicht für die gelegentlich notwendigen Typum-
wandlung en (Type casts; zumindest nicht für alle ). Beschränkung der
"
"43 Generische Typen
Analog zu der Einführung von parametrisierten Typen in Kapitel 29 von Kurseinheit 3 abs-
trahieren die generischen Typen JAVAs von Typen, indem sie die Referenzierung eines oder
mehrerer Typen innerhalb einer Typdefinition durch Typvariablen zu ersetzen erlauben. An-
ders als in STRONG TALK stehen die Typvariablen in JAVA jedoch nicht in eckigen, sondern in
spitzen Klammern. Da es dadurch zu Verwechselungen mit metasyntaktischen Variablen
kommen kann, werden wir in diesem Kapitel keine mehr verwenden.
"
"34 Das Programmiermodell JAVAs
JAVA ist in vielerlei Hinsicht (und vor allem im Vergleich zu SMALLTALK ) eine konventionelle
Programmiersprache. Programme werden als Quelltext in sog. Compilation units gespei-
chert, die gewöhnlich Dateien sind und die — jede für sich — immer als Ganzes übersetzt
werden .57 Das Ergebnis der Übersetzung ist jedoch kein direkt ausführbarer Maschinen-
code, sondern ein sog. Bytecode , der von einer virtuellen Maschine, der Java Virtual Machine
(JVM), interpretiert we rden muss . Das sonst übliche Linken der einzelnen Klassen (genauer:
des zu den Klassen gehörenden Bytecodes, die sog. Class files ) wird dabei durch das Class
Ausnahme und sah — wie Smalltalk — die Speicherung von Klassen in einem Image vor. Eclipse hat
übrigens bis heute eine Java Browsing Perspective, die d em System Browser von Smalltalk ähnelt.
loading der JVM ersetzt. Vorteile des ganzen sind eine größere Flexibilität bei der Entwick-
lung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit:
JAVA-Programme können, soweit sie nicht von bestimmten Eigenheiten der Betriebssysteme
abhängen (man denke z. B. an die unterschiedliche Handhabung von Groß -/Klein schrei -
bung — JAVA ist case sensitive, Windows nicht! ), auf jedem Rechner und Betriebssystem
laufen, für die es eine JVM gibt.
Während JAVA als Programmiersprache anfangs noch recht klein und
überschaubar war (zumindest im Vergleich zu C++, einem ihrer Haupt-
konkurrenten), so ist die Sprachdefinition heute ein Moloch . Mit dem wachsenden Nutzer-
innenkreis sind auch die Anforderungen an die Sprache gewachsen, und mit dem JAVA
Community Process wurde aktiven Entwicklerinnen die Möglichkeit eingeräumt, Vorsch läge
zur Spracherweiterung zu machen. Dabei ist jedoch — aufgrund der mittlerweile riesigen
Menge an Software, die in JAVA geschrieben ist — stets auf Rückwärtskompatibilität zu
achten, so dass revolutionäre Verbesserungen kaum möglich sind; stattdessen wird hinzu-
gefügt. Das unterliegende Programmiermodell ist so immer dasselbe geblieben — und wird
es wohl auch immer bleiben.
Die grundlegenden Werkzeuge der JAVA-Programmierung sind neben
dem Editor der JAVA-Compiler javac , die JVM, die JAVA-Klassenbiblio-
thek (das sog. Application Programming Interface , API) und natürlich die
Dokumentation (API -Dokumentation und Sprachdefinition). Gerade für die JAVA-Program-
mierung gibt es jedoch zahlreiche integrierte Entwicklungsumgebungen (IDEs) und es ist
niemandem zu raten, diese Werkzeuge links liegen zu lassen — die einmal einen Teil ihrer
wertvollen Lebenszeit mit dem richtigen Setzen des sog. Class path verbracht hat, wissen ,
wovon ich rede. Auf der anderen Seite sind diese IDEs sehr komplex und erschlagen gerade
Anfängerinnen mit ihrem Funktionsumfang. Das ist auch der Grund, warum in diesem Kurs
keine JAVA-Installation von Ihnen verlangt wird — wer es aber wissen und wer mit JAVA
experimentieren möchte, die will ich keinesfalls davon abhalten.
Um ein JAVA-Programm, bestehend aus einer Menge von Class files, aus-
zuführen, muss man eine Klasse ange ben, die eine Startmethode besitzt.
Diese Startmethode heißt immer gleich; ihre Signatur hat die leicht zu merkende und immer
wieder gern eingetippte Form
Dabei ist main der Name der Methode; was die anderen Elemente bedeuten, werden Sie
im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann ein-
fach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter, beispielsweise mit
Klassen werden in JAVA wie in SMALLTALK per Konvention immer großgeschrieben. rückwärtskompatible
Ein letztes, wichtiges Merkmal des Programmiermodells von JAVA ist die
Art des Deployment, also wie in JAVA programmierte Anwendungen in die Anwendung
gehen. Während früher alle namhaften Web -Browser ( per Plug -in) den Start von in Websei-
ten eingebetteten JAVA-Anwendungen erlaubten , bleibt heute praktisch nur noch die Ver-
teilung per sog. JAVA Archive (einer .jar -Datei). Zu deren Ausführung ist jedoch eine Instal-
lation der JVM vonnöten.
"
"36 Klassen
JAVA ist (wie SMALLTALK und alle in der nächsten Kurseinheit behandelten Sprachen) klassen -
und nicht prototypenbasiert; man programmiert also, i ndem man Klassendefinitionen an-
gibt. Wie bereits in Kapitel 34 erwähnt gibt es in JAVA keine Anweisungen außerhalb von
Klassen (sieht man einmal von Import -Anweis ungen ab) .
Wie dort ebenfalls bereits erwähnt gibt es in JAVA einen relativ engen
Zusammenhang zwischen Klassen und Dateien: Jede Datei enthält die Definition einer
Klasse, die den Dateinamen (ohne Erweiterung) als Namen trägt. Eine Dat ei (oder Compila-
tion unit ) kann auch mehrere Klassen enthalten, die dann natürlich anders heißen — unter
ihnen darf jedoch keine als public deklariert werden. Schon weil die meisten integrierten
Entwicklungsumgebungen für JAVA heute auf Dateibasis arbeiten und Dateien die Basis von
vielen Versionsverwaltungssystemen sind , ist es jedoch wenig gebräuchlich, mehrere Klas-
sen in einer Datei zu def inieren (es sei denn, es handelt sich um innere Klassen ; s. u.).
Nun hatten wir ja bereits in Kurseinheit 3, Kapitel 28, gesagt, dass Klassen
und Typen zunächst zwei verschiedene Konzepte sind, dass aber eine Typdefinition aus einer
Klassendefinition abgeleitet werden kann. Genau so verhält es sich in JAVA: Jede Klasse
definiert ihren eigenen Typ. Genauer: Jede Klasse spezifiziert einen Typ, der genauso heißt
wie die Klasse und der als Eigenschaften die Felddefinitionen und die Methodendeklaratio-
nen der Klasse enthält. Eine Deklaration
ist also eine gültige Variablendeklaration in JAVA. Man beachte, dass, anders als in STRONG-
TALK, in JAVA der Typ bei Deklarationen ohne sp itze Klammern vorangestellt wird. Es folgt
dies der Tradition von C und C++. Die spitzen Klammern in Zeile 985 kennzeichnen hier
lediglich wieder metasyntaktische Variablen .
"
"1.5.2 Sichtbarkeit
Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit
automatisch auch auf das Objek t zugreifen, das die Variable bezeichnet. Tatsächlich sind
alle Objekte, für die es keine ein deutige literale Repräsentation (wie sie Zeichen, manche
Zahlen und Symbole haben ) gibt, nach ihrer Erzeugung nur noch über Variablen zugreifbar.
Die einzige Ausna hme bilden hier die sog. konstanten Methoden , die jedoch erst in Ab-
schnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Ob-
jekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es
den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen . Kurzgefasst ist
die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden
kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei
bezieht sich die Sichtbarkeit immer auf einen Abs chnitt von Programmcode: Wenn eine
Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablen-
namens in diesem Abschnitt einer ihrer Verwendungen. Wertsemantik bei
Die einzelnen Programmiersprachen unterscheiden sich zum Teil deutlich
in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen
sog. globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu
verstehen: lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt be-
schränkt, um den es gerade geht ( sowie ggf. auf dessen Unterabschnitte), globale Variablen
sind auch außerhalb davon (insbesondere in Überabschnitten) sichtbar. Variablen, die über-
all sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine
Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist,
sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem über-
geordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens
immer globale Variablen gleichen Namens ; man spricht dann auch von Hiding .
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben be-
ginnen. Smalltalk und Transcript sind zwei prominente Beispiele
für globale Variablen. Lokale Variablen beginnen hingegen mit einem
Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen
davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln SMALLTALK s fehlt uns
noch einiges; wir werden daher erst in den folgen den Abschnitten darauf eingehen; wir
können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal
und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).
Selbsttestaufgabe 1.2
Versuchen Sie, durch Experimentieren herauszufinde n, was in der Variable Smalltalk zu finden
ist.
"
"Kurseinheit 1: Grundkonzepte der objektorientierten
Programmierung
Ein laufendes objektorientiertes Programm muss man sich als eine Menge interagierender
Objekte vorstellen. Damit die Objekte interagieren können, müssen sie verbunden sein ; sie
bilden dazu ein Geflecht, das neben Objekten aus Beziehungen zwi schen diesen besteht.
Das Geflecht verändert sich dynamisch infolge der Interaktion zwischen Objekten; es unter-
liegt aber gewissen, durch das Programm vorgegebenen statischen Strukturen.
Die Unterscheidung zwischen Statik und Dynamik ist eine klassische der
Programmierung. Während Programme traditionell statische Gebilde sind, die auf Papier
oder in einem Nur -lese-Speicher festgehalten werden können, ist ihre Ausführung immer
etwas Dynamisches. Wenn aber Programme selbst als Daten auf gefasst werden, dann ver-
wischt die Grenze zwischen Statik und Dynamik : Programme werden veränderlich. Insbe-
sondere, wenn Programme sich selbst verändern können, ist die Unterscheidung zwischen
Statik und Dynamik nur noch bedingt nützlich.
Alternativ zu Statik und Dynamik kann man auch zwischen Struktur und
Verhalten unterscheiden, wobei mit Struktur das oben erwähnte Objekt-
geflecht und mit Verhalten die (Spezifikation der) Folge seiner Veränderungen gemeint ist.
Diese Unterscheidun g liegt der Gliederung des Rests dieser Kurseinheit zugrunde: von Ob-
jekten (Kapitel 1) und Beziehungen zwischen diesen (Kapitel 2) geht es über den Z ustand
als Bindeglied ( Kapitel 3) zu den Elementen der Verhaltensbeschreibung (Kapitel 4).
"
"58 Das Problem der mangelnden Kapselung
Als man mit der objektorientierten Programmierung begann, war man glücklich, weil man
glaubte, mit dem Klassenbegriff eine natürliche Art der Kapselung (engl. encapsulation )
gefunden zu haben, die zudem noch mit der hochangesehenen Theorie der abstrakten Da-
tentypen in Einklang steht (zumindest einigermaßen): Klassen ergeben sich auf natürliche
Weise aus der Anwendung sdomäne (als Repräsentanten von Allgemeinbegriffen ; s. Kurs-
einheit 1, Kapitel 7) und Daten sowie Implementierungsdetails lassen sich hinter der Klas-
senschnittstelle (dem Protokoll der Objekte) verbergen.
Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls
gefeierte Vererb ung die Kapselung von Klassen auf unangenehme Weise
aufbrach: Wie in Kapitel 55 bemerkt, erzeugt die Vererbung starke Ab-
hängigkeiten (auch zwischen den Implementie rungsdetails!) von Klassen und ihren Subklas-
sen. Diese Abhängigkeiten explizit zu machen vermag zwar vor Programmierfehlern zu Strukturierung nach
mehreren Kriterien
viele A nsätze —
(noch) keine Lösung
starke
Abhängigkeiten
durch Vererbung
Everything should be made as simple as possible — but no simpler .
schützen, sie kann aber die Abhängigkeiten nicht beseitigen — sie dokumentiert sie ledig-
lich. Die Abhängigkeiten zu beschränken b edeutet wiederum, einen Teil der Ausdrucks-
stärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das
nun einmal : Alles hat seinen Preis.
Sehr viel dramatischer (und sehr viel weniger in all er Munde ) ist jedoch
ein ganz anderes Problem, das das gesamte bisherige Bemühen der Ob-
jektorientierung um Kapselung auszuhebeln in der Lage ist: das Aliasing -
Problem . Wenn nämlich ein Objekt, das durch ein anderes Objekt gekapselt wird, indem
das andere es in einer seiner Instanzvariablen hält, einen (weiteren) Alias besitzt, der nicht
selbst dem kapselnden Objekt gehört , dann nützt es nichts, wenn diese Instanzvariable von
außen unzugreifbar ist91 — sie wird nämlich gar nicht gebraucht, um auf das gekapselte
Objekt zuzugreifen. Man bedient sich einfach des Aliases.
In SMALLTALK wird das Problem in folgendem einfachen Codefragment klar:
Hier soll ein neues Objekt der Klasse A erzeugt werden und die Erzeugungszeit in einer
entsprechenden Instanzvariable des Objekts fes tgehalten werden. Die Variable jetzt hält
aber einen Alias auf das Objekt, das diese Zeit repräsentiert; ändert man dieses Zeitobjekt
(wie in Zeile 1534 ), dann betrifft dies auch die Erzeugungszeit des Objekts a.92 Nun könnte
man meinen, es genügte, man ersparte sich einfach den (offensichtlichen) Alias jetzt und
schrie be statt dessen
Woher weiß man aber, dass die Methode now in der Klasse Time nicht einen Alias auf jedes
neu erzeugte Objekt anlegt (beispielsweise weil Time Buch darüber führt, welche Instanzen
es von ihr gibt) und diesen Alias nicht herausgibt oder selbst verwendet, um die Objekte zu
manipulieren? Auch die alt ernative scheinbare Lösung,
Erzeugungsdatum""
funktioniert aus gleichem Grunde nicht zuverlässig, denn auch copy kann sich (heimlich)
Aliase anlegen.
Ein anderes Beispiel, bei dem Aliase fehlerhaft ein gesetzt werden, ist das folgende. Ange-
nommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren.
änderbar sein soll. Das ist hier aber gar nicht der Punkt. Umgehung der
Sie haben zwei Klassen, Ampel und Leuchte , und bauen Ihre Objekte durch folgenden
Code zusammen:
Wenn Sie nun einem Fußgänger per
grünes Licht geben wollen, gehen leider mit der einen gleich alle vier grünen Leuchten an.
War das in Ihrem Sinn?
Man nennt Objekte, die die Implementieru ng eines Objektes ausmachen
und die hinter der Schnittstelle des Objektes verborgen werden sollen,
Repräsentationsobjekte . Die Leuchten des obigen Beispiels sind a llesamt Repräsentati-
onsobjekte; sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie
ausmachen. Insbesondere gibt es in obigem Beispiel keine Verwendung einer Leuchte los-
gelöst von einer Ampel. Dies muss aber nicht für alle Leucht en der Fall sein — es ist durchaus
denkbar, dass Leuchtenobjekte in anderen oder sogar im selben Programm auch ein unab-
hängiges Leben (außerhalb von Ampeln) führen. Aber selbst das ist gar nicht notwendig —
im gegebenen Beispiel wäre es auch denkbar, dass mit Leuchten noch einiges gemacht wird,
bevor sie in eine Ampel eingebaut werden, so dass man das Aliasing -Problem weder an die
Klasse Leuchte pauschal noch an deren Verwendung als Lieferant für Repräsentationsob-
jekte knüpfen kann.
Wenn Aliase also schlecht sind, dann könnte man sie ja auch einfach ver-
bieten. Tatsächlich bieten ja Programmiersprachen wie C#, C++ und EIF-
FEL die Möglichkeit an, Klassen als Werttypen zu definieren, so dass bei Zuweisungen nicht
automatisch Aliase ent stehen. Aber durch eine derart einfache Lösung beschneidet man
sich selbst nur wieder zahlreicher Möglichkeiten, wie das folgende Beispiel zeigt:
Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wi e einer Coll-
ection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespei-
chert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man
braucht also die Möglichkeit, fallweise zu unterscheid en, ob ein Obje kt Aliase haben darf.
Das obige Beispiel stellt insofern kein großes Problem dar, als der fehler-
hafte Umgang mit dem Aliasing durch unerw artetes Programmverhalten
auffä llt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten ( das Geheim-
nisprinzip ) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also
mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwen-
dungen der Fall, bei denen Daten g eschützt werden müssen oder Funktionen nur durch
autorisierte Benutzerinnen ausgeführt werden dürfen. Gibt es dann Aliase von außen auf
diese Objekte als geheime Daten - oder Funktionsträger, dann ist die Spezifikation nicht er-
füllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.
Nachdem das Problem nun hinreichend klar geworden sein sollte, was
kann man dagegen tun? Zunächst einmal muss noch einmal klargestellt
werden, dass die Deklaration von Instanzvariablen als von außen un zu-
greifbar (private ) lediglich Namen verbirgt — man kan n über die
Schnittstelle des Objekts nicht herausfinden, wie es intern aufgebaut ist.
Dieser Namensschutz (engl. name protection ) ist das, was man landläufig (mit dem Wissen
vom Aliasing -Problem) mit Geheimnisprinzip (engl. information hiding ) verbindet: Es
verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, so
dass diese problemlos geändert (z. B. umbenannt oder entfernt) werden können.
Das Geheimnisprinzip vermag jedoch nicht zu verhindern, dass die Reprä-
sentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen. Dies
kann z. B. immer dann der Fall sein (und ist vom Objekt, das sein Implementationsgeheimnis
wahren will, kaum zu verhindern), wenn ein Objekt seine Repräsentationsob jekte bei seiner
Erzeugung von außen geliefert bekommt (genau so, wie das in den obigen Beispielen in
den Zeilen 1533 , 1535 und 1540 der Fall war). Eine weitere Möglichkeit, die Kapselung zu
durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, bei-
spielsweise durch einen Getter, aber das wäre dann vom „verbergenden“ Objekt selbst zu
verantworten (und zu verhindern gewesen).
Sobald also die Möglichkeit des Aliasing besteht, ist eine echte Kapse lung über das Geheim-
nisprinzip allein nicht mehr zur gewährleisten. Man muss also das Aliasing irgendwie kon-
trollieren. Die Frage ist nur: Wie?
Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann
das Bestreben nach Kapselu ng als Ausdruck des Bestehens einer Teil-Ganzes -Beziehung
zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausma-
chen, verstehen. Die T eile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht
zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von ande-Geheimnisprinzip als
Teil der Spezifikation
ren Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhin-
dern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmier-
sprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5
genannten Programmiersprachen ist das jedoch nur in C#, und da auch nur im Safe mode,
möglich, nämlich wenn die „Klasse“ der Teil -Objekte per struct definiert wurde. Abgese-
hen von diese r Einschränkung ist eine solche Vorgehensweise nur selten ohne uner-
wünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser
„Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwen-
dungsdomäne in der Reg el nicht korrekt abbildet.
Vor diesem Hintergrund scheint der in Abschnitt 52.5.2 dargelegte Um-
gang EIFFELs mit Referenz - und Wertvariablen z iemlich schlau ausgedacht zu sein. Zwar er-
laubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass
ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvari-
able an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts er-
zeugt und zugewiesen, so dass kein Alias in die Repräsentation hinein entstehen kann. Um-
gekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine
Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch
kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind
aliasfrei. Dumm ist nur, wenn man innerhalb der Kapsel Aliase auf Wertobjekte braucht.
Weitergehende Mecha nismen zur Aliaskontrolle in objektorientierten Programmiersprachen
befinden sich derzeit alle noch in der Vorschlags - und Erprobungsphase und sollen hier des-
wegen nicht weiter behandelt werden.
"
"4.3.7 Primitive Methoden
Zwar ist SMALLTALK über weite Teile in sich selbst definiert (was sich darin äußert, dass prak-
tisch die gesamte Sprachdefinition in Form von Methoden hinterlegt und damit für die Pro-
grammiererin nicht nur sichtbar, sondern auch änderbar ist), aber für einige primitive Ope-
rationen greift es doch auf native Implementierungen zurück. Dazu zählt z.B. die Addition
(+) für kleine Integer oder auch der Zugriff auf indizierte Variablen mittels at: und
at:put: . Die entsprechenden Methoden sind in SQUEAK wie folgt implementiert:
Array -Objekte werden erst zur Laufzeit und dann immer wieder neu erzeugt, so dass sich keine Aliase
ergeben.
Dabei stehen die in spitzen Klammern stehenden Ausdrücke jeweils für Aufrufe von primi-
tiven Methoden, die, da man sie als Programmiererin nicht selbst verwenden soll, nur durch-
nummeriert wurden. Die Anweisungen nach den Aufrufen der primitiven Methoden wer-
den nur ausgeführt, wenn die primitive Methode nicht erfolgreich war. Das beding t, dass
aus einer primitiven Methode mittels Return direkt zurückgesprungen werden kann, und
zwar dorthin, wo die Methode +, at: bzw. at:put: aufgerufen wurde. Dieses Verhalten,
das einigermaßen ungewöhnlich erscheint, wird uns im Kontext von Blöcken (Absc hnitt 4.4)
wieder begegnen.
"
"57 Das Problem der eindimensionalen Strukturierung
Klassen sind die Module der objektorie ntierten Programmierung. Die Menge der Module
und damit das Programm werden durch die Vererbungshierarchie weiter strukturiert. Dazu
parallel (und weitgehend, bis auf die Vererbung von Beziehungen unabhängig) gibt es noch
eine Struktur, die durch das Beste hen von Beziehungen zwischen Klassen (genauer: das
Bestehen der Möglichkeit von Beziehungen zwischen Objekten der Klassen ; s. Kapitel 2 in
Kurseinheit 1) geprägt ist — diese ist aber nicht hierarchisch und insgesamt eher unorgani-
siert, weswegen sie nicht zur systematischen Programmorganisation taugt. Außerdem be-
steht ein gewisser Konflikt zwischen der Hierarchie der Subklassenbeziehung und den Be-
ziehungen zwischen Objekten: Wenn man einen Teilbaum der Vererbungshierarchie her-
auslöst, trennt man damit praktisch immer Beziehungen zwischen Mitgliedern des Teil-
baums und anderen auf. Die Klassen hierarchie stellt also insbesondere keine Form der hie-
rarchischen Modularisierung dar. Fazit
Insbesondere bei größ eren Programmen kann leicht das Verlangen auf-
kommen, ein Programm nach mehreren Kriterien gleichzeitig zu struktu-
rieren. Dies kann beispielsweise verschiedene Vererbungshierarchien betreffen — so, wie
man in der Biologie eine Taxonomie der Arten nach Herku nft (Genetik) und nach Merkma-
len erstellen kann und, da beide ihren Nutzen haben, man weder auf die eine noch auf die
andere ohne Not verzichten möchte, so kann man ein Programm beispielsweise unter dem
Gesichtspunkt der Vererbung von Funktionalität und vo n Daten alternativ strukturieren wol-
len. Voraussetzung hierfür ist allerdings, dass die verschiedenen Darstellungen getrennt von-
einander gepflegt werden und dass durch sie weder Inkonsistenzen im Code noch unge-
wollte Interferenzen entstehen können.
Ein Nachteil der objektorientierten Programmierung (wie auch aller ande-
ren heute bekannten Programmierparadigmen) ist sicherlich, dass die
sog. Trennung der Belange , besser bekannt als die Separation of concerns , nur unzu-
reichend unterstützt wird. Ansätze wie das Subject - oder Aspect -oriented programming
wurden zwar hoch gehandelt, sind aber dennoch nicht im Mainstream angekommen. Die
Gründe dafür mögen vielfältig sein aber letztlich ist es wohl immer illusorisch, zu verspre-
chen, man könne die essentielle Komplexität, die einem Problem innewohn t, durch pro-
grammiersprachliche Mittel beseitigen. Insbesondere die getrennte Spezifikation eines Sys-
tems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der
Sichten: Wie so oft muss das Ganze mehr sein als die Summe seiner Te ile, um seinen Zweck
zu erfüllen . Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Arte-
fakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht,
soll sich schämen.
"
"36.3 Konstruktoren
Objekte, für die es keine literale Repräsentation gibt, müssen in JAVA (wie in SMALLTALK )
explizit, als Instanzen von Klassen, erzeugt werden. Dazu gibt es in JAVA eine spezielle Ka-
tegorie von Methoden, Konstruktoren genannt, die, anders als in SMALLTALK , keine Klassen-
methoden sind, sondern zwischen Klassen - und Instanzmethoden stehen. Dabei sind Kon-
struktoren wie I nstanzmethoden, weil in ihrem Rumpf auf alle Felder und Methoden der
neu erzeugten Instanz zugegriffen werden kann (und zwar genau so, als sei der Konstruktor
eine Instanzmethode, die auf der neu erzeugten Instanz aufgerufen würde). Konstruktoren
können al so all die Anweisungen enthalten, für die in SMALLTALK noch eine spezielle Me-
thode initialize notwendig war (vgl. Abschnitt 8.2 in Kurseinheit 2). Konstruktoren
sind aber auch wie Klassenmethoden, weil sie eben nicht auf einer Instanz aufgerufen wer-
den, sondern auf der Klasse. Allerdings sieht JAVA dafür keine spezielle Klassenm ethode new
o. ä. vor, sondern verwendet den Klassennamen selbst wie einen Methodennamen. Wenn
man also, von SMALLTALK kommend, etwas der Form
erwarten würde, findet man in JAVA stattdessen
Wie man sieht, erlauben Konstruktordefinitionen in JAVA anders als (andere ) Methoden
keine Angabe eines Rückgabetypen — da die erzeugte Instanz immer eine der Klasse ist, in
der der Konstruktor definiert ist, steht der Typ fest. Die Angabe des Rückgabetyps in Zeile
Wenn man keinen Konstruktor definiert, nimmt JAVA stets den (implizi-
ten) Standardkonstruktor an, der parameterlos ist und der nichts weiter
tut, als eine n eue Instanz der Klasse zu liefern. Außerdem werden Kon-
struktoren nicht vererbt; stattdessen wird der Standardkonstruktor einer Klasse beim Erzeu-Standardkonstruktor
gen einer Instanz von einer ihrer Subklassen automatisch mit aufgerufen. Um dieses Verhal-
ten zu überschreiben, k ann man aus einem Konstruktor heraus einen beliebigen Konstruk-
tor der Superklasse mittels super aufrufen; darin wiederum aufgerufene Methoden werden
dann dynamisch gebunden, was dazu führen kann, dass von diesen Methoden auf noch
nicht ini tialisierte Variablen zurückgeg riffen wird. Tatsächlich ist der ganze Komplex Kon-
struktoren und Initialisierung von Variablen in JAVA recht komplex , was, da Instanziierung
und Initialisierung fundamentale und für jedes Programm unverzichtbare Vorgänge sind,
nicht gera de für JAVA als Anfängerinnensprache spricht.
Konstruktionen zur Objekterzeugung mit Klassenmethoden wie oben (Zeile 998) sind in
JAVA übrigens auch möglich; allerdings muss eine solche Klassenmethode dann in ihrem
Rumpf einen Konstruktor wie in Zeile 1006 aufrufen. Man spricht dann von der Klassenme-
thode auch als einer Factory -Methode (vgl. Abschnitt 8.3 in Kurseinheit 2); sie kann auch
Instanzen anderen Typs als des deklarierten zurückgeben.
"
"50.4.2 Interfacetypen in C#
Zwar hat C# das Interface -als-Typ-Konzept von JAVA übernommen, doch hat man hier seine
Rolle deutlich gestärkt. So ist es in C# möglich, dass von verschiedenen Interfaces „ge-
erbte“, gleiche Methodendeklarationen in einer Klasse getrennt voneinander implementiert
werden können. Dies geschieht mit sog. expliziten Interfaceimplementierungen , wie im Klassenhierarchie Werttypen Referenztypen Attribute
 primitive Typen
 Aufzählungstypen
 Strukturtypen (Records)  Klassen
folgenden Beispiel dargestellt (man beachte, dass in C# der Doppelpunkt die Schlüsselwör-
ter extends und implements ersetzt75):
Der Nutzen der expliziten Interfaceimplementierung in den Zeilen 1346 –
gibTelefonnummer() unterschiedlich reagiert , und zwar abhä ngig davon, über welches
Interface es angesprochen wird . Der Typ der Variable (oder des Ausdrucks), die als Empfän-
ger fungiert, gibt also gewissermaßen die Rolle (hier: Angestellte bzw. Privatperson )
vor, in der das Objekt angesprochen wird. Es ist weder vorgesehen noch möglich, dass man
an der Aufrufstelle etwas wie x.Angestellte .gibTelefonnummer() schreibt (wobei x
das Objekt bezeichne) ; vielmehr steht dort einfach nur x.gibTelefonnummer() . Falls üb-
rigens die Methodendeklaration Telefonnummer gibTelefonnummer() von einem ge-
meinsamen Superinterface von Angestellte und Privatperson , z. B. Erreichbar , ge-
erbt würde, wäre das Programm ungültig; es muss nämlich immer der tatsächlich deklarie-
rende Typ als Qualifizierer angegeben werden.
Wenn im obigen Beispiel für die beiden expliziten Interfaceimplementie-
rungen von gibTelefonnummer() nicht wie in JAVA verlangt der Zu-
griffsmodifikator public angegeben wurde, dann geschah das nicht ohne Grund: Es ist in
C# nämlich möglich, Methoden nicht public zu deklarieren und trotzdem, per Inter-
faceimpl ementierung, von außen zugreifbar zu haben . Allerdings ist dies an die explizite
Interfaceimplementierung gebunden. Die sog. implizite Int erfaceimplementierung , also
trachtung einer Klasse manchmal nicht sagen kann, welcher der aufgelisteten Supertypen Interface
und welcher Superklasse ist, wird eine Namenskonvention entgegengehalten: Im Common Type Sys-
tem von .NET sollten alle Interfacenamen mit einem „I“ beginnen. D as steht in der Tradition der bei
MICROSOFT weithin gebrauchten und nach dem früheren Mitarbeiter CHARLES SIMONYI so genannten
ungarischen Notation . explizite Interface -
die, die Sie von JAVA her kennen, ist in C# natürlich auch vorgesehen ; dort müssen Metho-
den jedoch immer (wie auch in JAVA) public deklariert werden.
Explizite Interfaceimplementierungen können nicht überschrieben wer-
den (dürfen also auch nicht virtual deklariert sein). Eine Klasse, die von
einer mit expliziten Interfaceimplementierungen erbt, erbt diese also,
ohne dass sie diese überschreiben könnte — es sei denn, sie „reimple-
mentiert“ das Interface, d. h., sie deklariert selbst, es zu implementieren. Man beachte aber,
dass diese erneute explizite Implementierung keine Überschreibung darstellt: insbesondere
findet bei Aufruf der explizit implementierten Methode kein dynamisches Binden statt.
"
"1.7 Pseudovariablen
Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, so sieht SMALL-
TALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit
Name n true , false und nil zu nennen, die auf Objekte entsprechender Bedeutung ver-
weisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen
Zeiten auf verschiedene O bjekte verweisen), jedoch erhalten sie ihren Wert vom System;
auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies
sind z. B. die Variablen mit Namen self und super sowie alle formalen Parameter von
Methoden (s. Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (s. Kurseinheit 2)
Variable n, denen man als Programmiererin nichts explizit zuweisen kann. All diese Variablen
werden in SMALLTALK einheitlich Pseudovariabl en genannt.
"
"38 Anweisungen, Blöcke und Kontrollstrukturen
Genau wie in SMALLTALK werden in JAVA Ausdrücke im Rahmen der Ausführung von Anw ei-
sungen ausgewertet. Anders als in SMALLTALK gibt es in JAVA jedoch eine Vielzahl von Schlüs-
selwörtern, die Anweisungen einleiten. Dennoch ist es auch in JAVA möglich, bestimmte
Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden A usdruck
durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisun-
gen, Methodenaufrufe und Klasseninstanziierungen (s. Kapitel 37) direkt zu Anweisungen.
Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK , das
Semikolon in JAVA kein Trennzeichen, sondern Teil der Anweisung ist.
Nahezu alle Anweisungen finden sich in JAVA-Programmen innerhalb von Methoden.61 Blö-
cke sind in JAVA lediglich (in geschweifte Klammern eingefasste ) Abschnitte des Quelltextes ,
die die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbe-
reich für darin enthaltene Variablendeklarationen darstellen . Blöcke wie in SMALLTALK kenn t
JAVA erst seit Version 8, als Lambda -Ausdrücke .
Es sind also Variablendeklarationen, Methodenaufrufe (inkl. der Kon -
struk toraufrufe) und Zuweisungen Anweisungen. Alle anderen Anwei-
sungen werden durch Schlüsselwörter eingeleitet und realisieren allesamt Kontrollstruktu-
ren, die den Kontroll fluss eines Programms dazu bringen, von der normalen, sequentiellen
Ausführung abzuweichen. Im einzelnen sind dies
 die If -Anweisung der Form if (<Boolescher Ausdruck>) <Statement> , bei
der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck>
zu true auswertet;
 die If -else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement
1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird,
wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst;
 die Switch -Anweisung der Form
switch (<Ausdruck>) {
case <Literal 1> : <Anweisungsliste 1>
case <Literal 2> : <Anweisungsliste 2>
…
default: <Anweisungsliste>
}
wobei <Ausdruck> sowie <Literal 1>, <Literal 2> etc. alle vom Typ char ,
byte , short , int (bzw. einem der dazugehörigen Wrapper -Typen) , String oder
von einem Aufzählungstyp sein müs sen und <Anweisungsliste 1> etc. für Fol-
gen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen
werden können (aber nicht müssen) ;
 die While -Anweisung der Form while (<Boolescher Ausdruck>)
<Statement> , die im wesentlichen der If -Anwe isung entspricht mit dem Unter-
schied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis
<Ausdruck> zu false auswertet;
 die Do -Anweisung der Form do <Statement> while (<Boolescher
Ausdruck>) , die im wesentlichen dem While -Statement ent spricht mit dem Unter-
schied, dass <Ausdruck> immer erst nach Ausführung von <Statement> ausge-
wertet wird (man beachte, dass Statement kein Block sein muss; das das Statement
abschließende Semikolon wirkt dann etwas deplaziert (so wie das vor else beim If -
Statement) ;
 die For -Anweisung in der Form
for (<Initialisierungsausdruck>; <Boolescher Ausdruck>;
<Veränderungsausdruck>) <Statement>62
Gleichwohl k önnen in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke
erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen
sind Erbe von C.
die <Statement> solange ausführt, bis der Boolesche Ausdruck zu true auswertet
(auf die schier unendlichen Mögl ichkeiten, was sich alles in
<Initialisierungsausdruck> und <Veränderungsausdruck> unterbringen
lässt, gehen wir hier nicht ein; traditionell wird im Initialisierungsausdruck jedoch ein
Anfangswert für eine Laufvariable63 gesetzt, der dann im Veränderungsau sdruck
modifiziert, nicht selten hochgezählt, wird);
 die (erweiterte) For-Anweisung in der Form for (<Variable> : <Ausdruck>)
<Statement> , die <Statement> für alle Werte, die <Ausdruck> liefert, einmal
ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable (wobei
<Ausdruck> zu diesem Zweck entweder vom Typ eines Arrays sein oder das Inter-
face Iterable implementieren muss , was soviel bedeutet wie dass das Objekt, zu
dem <Ausdruck> auswertet, die Methoden hasNext() und next() anbieten
muss );
 die B reak-Anweisung der Form break; bzw. break <Label>; , die innerhalb von
Schleifen oder Switch -Statements dazu führt, dass diese sofort verlassen werden,
wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem
äußeren Switch -Statement vorangestellt wurde;
 die Continue -Anweisung der Form continue; bzw. continue <Label>; , die
innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch
<Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr
ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, wei-
tergemacht wird (Continue -Anweisungen außerhalb von Schleifen bzw. mit einer
Nicht -Schleife als Label sind ein Syntaxfehler);
 die Return -Anweisung der Form return; bzw. return <Ausdruck> ;, die be-
wirkt, dass die umschließende Methode sofort beendet und ggf. der Wert der Aus-
wertung von <Ausdruck> zurückgegeben wird ( return; darf auch in einem Kon-
struktor vorkommen);
 die Synchronized -Anweisung der Form synchronized (<Ausdruck>) <Block> ,
die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausge-
führt wird, wenn das mit dem Objekt, zu dem <Ausdruck> auswertet, verbundene
Lock dies zu lässt (s. Abschnitt 47.3);
 die Try -Anweisung der Form
try <Try -Block>
catch (<formaler Parameter 1>) <Catch -Block 1>
catch (<formaler Parameter 2>) <Catch -Block 2>
…
finally <Finally -Block>
ment, einschließlich des enthaltenen Statements <Statement> , beschränkt.
wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass
sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen
catch (<formalerParameter1>) <Catch -Block1> usw. für verschiedene Ar-
ten von Laufzeitfehlern verschiedene Behandlung sblöcke angegeben werden kön-
nen und wobei finally <Finally -Block> einen Block zu spezifizieren erlaubt,
der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt (oder abge-
brochen) wurden (kann auch weggelassen werden);
 die Throw -Anweisung der Form throw <Exception>; , die das Programm eine
Exception werfen lässt;
 die Assert -Anweisung der Form assert <Ausdruck 1>; oder assert
<Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Aus-
druck und <Ausdruck 2> von beliebigem Typ außer dem von void sein muss , mit
der Bedeutung, dass wenn <Ausdruck 1> zu false auswertet, dass dann das
Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wobei ggf.
das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird.
Außerdem ist die lee re Anweisung, bestehend aus einem einzelnen Semikolon, eine Anwei-
sung.
Bemerkungen:
 Das Weglassen von break; am Ende einer Liste von Anweisungen in einem Case -
Zweig der Switch -Anweisung wird als Fall through bezeichnet und bewirkt, dass mit
den Anweisungen des nächsten Case -Zweigs fortgefahren wird. Dies ermöglicht,
mehrere Fälle zusammenzuführen, ist aber eines der fehlerträchtigsten Konstrukte
C-artiger Sprachen.
 Die Assert -Anweisung kann Seiteneffekte haben, also z. B. die Werte von Variablen
aus umgebenden Blöcken oder von Instanzvariablen ändern. Wenn der Ablauf des
Programms von diesen Werten abhängt, macht es einen Unterschied, ob ein Pro-
gramm mit oder ohne Prüfung der Assertions ausgeführt wird. Das ist ein starkes
Stück.
 Assert -Anweisungen sind ein erster zarter Versuch, in JAVA auch noch andere Inva-
rianten als die Typinvarianten un terzubringen. Dabei findet die Überprüfung dieser,
mittels assert eingebrachten Invarianten im Gegensatz zum Großteil der Typprü-
fung erst zur Laufzeit statt, indem nämlich die entsprechenden Statements ausge-
führt werden. Dabei beziehen sich die Bedingungen , die die Invarianten formulieren,
häufig auf Methoden des Programms, für die die Invarianten angegeben werden
sollen. Da diese Methoden aber auch den Zustand des Programms ändern können,
kann man einer Zusicherung mit assert nicht ansehen, ob sie seiten effektfrei ist.
Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden nicht als An-
weisungen formuliert, sondern als Quellcodeannotationen, und stellen zudem si-
cher, dass alle Zugriffe auf Programmelemente, die zur Laufzeit notwendig sind, den
Zustand des Programms nicht verändern (mehr zu diesem Thema im Kurs 01853
sowie in Abschnitt 52.6 von Kurseinheit 5).
"
"28.1 Subklassen und Subtypen
Man könnte nun versucht sein, den Zusammenhang von Klassen und Typen auch unter
Vererbung bzw. Subtyping beizubehalten und damit zu erwarten, dass eine Instanz einer
Subklasse einer Klasse dem Wertebereich des zur Superklasse gehörenden Typs angehört.
Das ist jedoch dann nicht der Fall, wenn in der Subklasse Änderungen vorgenommen wer-
den, die eine Typkonformität vom zur Subklasse gehörendem zum zur Superklasse gehö-
renden Typ aufheben, also z. B. Methoden gelöscht oder inkompatibel redefiniert werden.
Die meisten objektorientierten Programmiersprachen verbieten das jedoch, so dass sich die
Subklassenbeziehung tatsächlich auf eine parallele Subtypenbez iehung übertragen lässt.
"
"24 Typkonformität
Einen Typ, d essen Definition alle deklarierten Elemente der Definition eines anderen Typen
enthält, nennt man mit dem anderen typkonform . So ist InternationalesBüro im obi-
gen Beispiel mit Büro typkonform. Typkonformität ist in vielen Sprachen eine notwendige
und hinreichende Voraussetzung für die Zuweisungskompatibilität : Es darf dann ein Objekt
vom Typ InternationalesBüro einer Variable vom Typ Büro zugewiesen werden.
Typkonformität ist aber reflexiv, d. h., jeder Typ ist konform zu sich selbst.
Sie ist weiterhin transitiv: Wenn A typkonform zu B ist und B typkonform
zu C, dann ist auch A typkonform zu C. Wie man sich leicht denken kann,
ist die Typkonformität jedoch im Gegensatz zur Typäquivalenz nicht symmetrisch: Aus de r
Tatsache, dass ein Typ B typkonform zu einem Typ A ist, folgt nicht, dass auch A typkonform
zu B ist. Vielmehr ist dies mit einer kleinen Ausnahme sogar zwingend nicht der Fall: Typ-
konformität ist meistens antisymmetrisch, was soviel heißt wie dass wenn B zu A und A zu
B typkonform ist, dass dann A und B identisch sein müssen.
Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei
Varianten, nämlich eine strukturelle Typkonformität und eine namens-
gebundene ( nominale ) Typkonformität . Zur strukturellen Typkonfor-
mität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er
konform sein soll, enthält: Der Typ mit der Definition
Typ InternationaleWohnung
Protokoll
ist also zum Typ Büro strukturell konform. Für die nominale Konformität muss zusätzlich
und explizit die Erweiterung eines (oder Ableitung von einem) anderen Typ angegeben wer-
den: die Definition von InternationalesBüro aus Kapitel 23 ist also mit Büro nicht nur
strukturell, sondern auch nominal konform. Da bei der Erweiterung alle Elemente des Typs,
der erweitert wird, beim erweiternden erhalten bleiben, folgt die Konformität aus der Er-
weiterung. formale
Nun ist die Teilmengenbeziehung reflexiv, was auf die Typerweiterung
übertragen bedeutet, dass ein Typ eine Erweiterung eines anderen sein
kann, ohne tatsächlich etwas hinzuzufügen. So ist beispielsweise gemäß
folgender Typdefinition
Typ NationalesBür o
erweiterter Typ Büro
Protokoll
NationalesBüro eine Erweiterung von Büro und mit den Variablendeklarationen
die Zuweisung
bei geforderter nominaler und struktureller Typkonformität zulässig. Die umgekehrte Zu-
weisung ist
ist jedoch bei geforderter nominaler Typkonformität nicht zulässig, da Büro eben nicht no-
minal konform ist zu NationalesBüro ; strukturell ist es es hingegen schon.
Typäquivalenz implizi ert übrigens, jeweils für die nominale und die struk-
turelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch
immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar
ist ein Typ, der angibt, einen anderen zu erweitern, ohne jed och etwas hinzuzufügen, zu
dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzuge-
fügt wird, ist es mit der Äquivalenz sowieso vorbei.
Genau wie bei der Typäquivalenz hat die nominale Typkonformität zu-
sätzlich zur Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von
Typfehlern (die ja auch bei einer strukturellen Typkonformität schon gegeben wäre) eine
Filterfunktion : Es sind nur Objekte von solchen Typen Variablen zuweisbar, für die das die
Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorge-
sehen hat. Auf diese Filterfunktion werden wir später im Zusammenhang mit sog. Tagging
oder Marker interfaces (in Kurseinheit 4, Kapitel 45) noch zurückkommen.
Da die Typkonformität bei Nennung des Typen, von dem ein neuer per
Erweiterung abgeleitet wird, über den Vorgang der Erweiterung automa-
tisch gegeben ist (und so keine aufwendigen, fallweisen Konformitäts-
tests durchgeführt werden müssen), setzen die meisten gebräuchlichen, typisierten Pro-
grammiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompa-Spezialfall
tibilität. Interessanterweise wurde STRONGTALK , das ursprünglich ein auf struktureller Kon-
formität beruhendes Typsystem (inkl. Type branding ) hatte, inzwischen auf nominale Typ-
konformität umgestellt. Als Begründung wurde angeführt, dass ein strukturelles Typsystem,
insbesondere eines, bei dem Typen ni cht explizit benannt werden, es der Programmiererin
nicht erlaubt, ihre Absicht (intendierte Semantik, die obengenannte Filterfunktion) auszu-
drücken, was Programme schwerer zu lesen und zu debuggen macht, und dass die Fehler-
meldungen, die eine strukturelle Typprüfung produziert, sich oft nicht auf die eigentliche
Fehlerquelle beziehen und sehr schwer zu verstehen sind [ STRONGTALK 2.0].
Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übri-
gens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auf-
treten (s. Abschnitt 4.3.2 ), eine wichtige Rolle. So muss bei dem Au sdruck
der Typ von e eine Erweiterung des in m für den Parameter geforderten Typ sein und der
Rückgabetyp von m eine Erweiterung des Typs von a.
"
"47.3 Multi -threading
Ähnlich wie SMALLTALK erlaubt auch JAVA, parallele Ausführungsstränge zu programmieren.
Diese heißen in JAVA jedoch nicht Prozesse, sondern Threads . Threads sind im Gegensatz zu
den Prozessen eines Betriebssystems leichtgewichtig, was soviel heißen soll wie dass sich
Threads die getrennte Allokierung von Ressourcen (wie Hauptspeicher) sparen, und alle a uf
denselben Ressourcen operieren. Es können also mehrere Threads innerhalb eines Prozesses
laufen. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst
realisiert werden müssen; bei Prozessen sind sie über die Inter -Prozess -Kommunikation des
Betriebssystems geregelt. (Bei den Prozessen SMALLTALK s handelt es sich also auch eher um
Threads als um Prozesse im eben beschriebenen Sinn.)
In JAVA wird ein neuer Thread gestartet, indem man eine neue Insta nz der
Klasse Thread erzeugt und auf ihr die Methode start() aufruft.
startet also einen neuen Thread. Bleibt die Frage, was dieser Thread tut.
Die Klasse Thread besitzt dafür eine Methode run() , die von start() aufgerufen wird.
Diese Methode ist jedoch leer , so dass der Thread gleich wieder beendet wird. Damit ein
neuer Thread etwas Sinnvolles tut, gibt es zwei Möglichkeiten:
1. Man definiert eine neue Subklasse von Thread und überschreibt darin die Methode
run() so, dass sie das Gewüns chte tut oder zumindest anstößt.
2. Man lässt eine Klasse das Interface Runnable implementieren, implementiert dann
in der Klasse die vom Interface geforderte Methode run() , erzeugt von dieser
Klasse eine Instanz i und startet deren Methode run() mittels (new
Thread(i)).start() (start() ruft dann run() auf i auf).
Auch im zweiten Fall wird eine Instanz der Klasse Thread erzeugt, die den neuen Thread
repräsentiert. Man beachte jedoch, dass diese Instanz nicht selbst der Thread ist — der
Thread ist, wie gesagt, ein paralleler Ausführungsstrang der JVM, der, genau wie der Aus-
führungsstrang, mit dem das Programm startet, nicht an ein Objekt gebunden ist, sondern
mit dem Kontroll fluss zwischen den Empfängerobjekten hin - und herwechselt. Aktive Ob-
jekte, also Objekte, die ihren eigenen Ausführungsstrang haben und auch behalten (s. Ka-
pitel 16), müssen in JAVA genau wie in SMALLTALK simuliert werden. Jeder Thread hat aber
ein Thread -Objekt, das ihn repräsentiert; es kann mit Thread.currentThread() erfragt
werden. Mit ihm sind so spezifische Daten wie der Name des Threads, seine Priorität etc.
gespeichert.
Die Threads JAVAs benötigen also eine explizite Synchronisation. Ähnlich
wie die Prozesse SMALLTALK s funktioniert dies mit Semaphoren, die hier
allerdings Monitore genannt werden. Jeder Monitor ist mit einem Objekt verbunden (und
jedes Objekt mit einem Monitor); wenn ein Thread einen Monitor eines Objektes sperrt
(„lockt“), dann kann kein anderer Thread den Monitor sperren, bevor die Sperre durch den
ersten Thread wieder aufgehoben wird.
Es gibt zwei Möglichkeiten, die Synchronisation von Threads zu erzwin-
gen. Die eine erfolgt mittels der Synchronized -Anweisung, die Sie oben
schon kurz kennengelernt haben: Die Anweisungen eines Blocks können
nur ausgeführt werden, wenn sie nicht gerade von einem anderen Thread ausgeführt wer-
den. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre durchgeführt
wird, wird explizit mit der Synchronized -Anweisung angegeben (häufig ist es this , also das
Objekt, in dessen Kontext sich der Block be findet).
Die zweite Möglichkeit ist, eine ganze Methode mit synchronized zu deklarieren. Wenn
es sich dabei um eine Instanzmethode handelt, wird die Sperre auf dem Objekt, auf dem
die Methode aufgerufen wurde, erwirkt; handelt es sich dagegen um eine Klass enmethode
(also um eine, die static deklariert wurde), dann geht die Sperre auf das Objekt, das die
Klasse repräsentiert. Felder lassen sich übrigens nicht synchronized deklarieren
"
"39 Module
Ein Modul ist eine Einheit von Programmelementen, die (bzw. deren Funktion) von außen
(also z. B. von anderen Modulen) nur über die Schnittstelle des Moduls zugäng lich sind.
Damit behält ein Modul einen Teil seiner Implementation für sich — es hütet quasi ein Im-
plementationsgeheimnis . Der Teil, den es (über seine Schnittstelle) nach außen trägt, gilt
gemeinhin als öffentlich. Die „Öffentlichkeit“ kann dabei durchaus beschränkt sein (s. dazu
auch Abschnitt 52.2 in Kurseinheit 5).
Ein wesentlicher Grund, zwischen öffentlichen und nicht öffentlichen —
privaten — Teilen eines Moduls zu unterscheiden, ist, dass die Program-
miererinnen eines Moduls Hoheit darüber behalten wollen, wie sie das
Modul programmieren. Indem sie sich auf eine Schnittstelle festlegen und alles andere hin-
ter der Schnittstelle verbergen, ist es ihnen möglich, jederzeit die verborgenen Teile zu än-
dern, ohne dass irgendeine andere davon in Kenntnis gesetzt werden muss — weil die pri-
vaten Teile von außen unsichtbar sind, hängt auch niemand davon ab, und insofern ist auch
niemand davon be troffen, wenn an einem Modul eine Änderung durchgeführt wird, die die
Schnittstellen unberührt lässt.
In JAVA wurden bis Version 8 Module durch Klassen und Pakete (engl. packages ) mehr oder
weniger gut simuliert. Mit JAVA 9 wurde schließlich — nach langer Vorbereitungszeit — ein
Modulbegriff eingeführt, der diesen auch Namen verdient.
"
"52.5 Das Typsystem EIFFELs
EIFFEL besitzt ein einheitliches Typsystem (keine separa ten Referenz - und Werttypen) und
unterscheidet auch nicht (wie JAVA) zwischen eingebauten Operatoren und programmiere-
rinnendefinierten Methoden: Die Operation + auf Integern beispielsweise ist (wie in SMALL-
TALK) nichts weiter als eine syntaktische Variante einer Methode plus definiert in einer
Klasse INTEGER mit gleichem Parametertyp ( EIFFEL verwendet per Konvention für Klassen
und Typen vollständige Großschreibung; allerdings ist EIFFEL — wie PASCAL — nicht case
sensitive ). Die Einheitlichkeit des Typsystems von EIFFEL geht dabei über die von C# insofern
hinaus, als es keine an bestimmte Typkonstruktoren gebundene Unterscheidung von Wert -
und Referenztypen gibt; gleichzeitig unterscheidet es sich aber von dem SMALLTALK s (das
sich ja zumindest dem Anschein nach vollständig auf Referenztypen festgelegt hat) insofern,
als es auch Werttypen zu lässt. Mehr dazu gleich.
Zu den prominentesten Eigenschaften des Typsystems von EIFFEL zählen
 Mehrfachvererbung,
 Generizität (genauer: beschränkter parametrischer Polymorphismus; s. Ab-
schnitt 29.4 in Kurseinheit 3),
 das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von
Methoden; s. dazu auch Abschnitt 11.3 in Kurseinheit 1) sowie
 kovariante Redefinition, unterstützt durch sog. verankerte Typen (engl . anchored
types ; so gut wie ein Alleinstellungsmerkmal EIFFELs). Überladen und
In gewisser Weise kann man das Unterdrücken von Methoden eines Typs in seinen Subtypen
in EIFFEL als ein Spezialfall der kovarianten Redefinition ansehen, nämlich einen, in dem die
Menge der möglichen Parameterobjekte auf die leere Menge eingeschränkt wird, so dass
es keinen gültigen Aufruf gibt (vgl. Kapitel in Kurseinheit 3). Auch sind die Probleme, die
kovari ante Redefinition und Unterdrückung verursachen, ähnlich. Deshalb beschränken wir
uns bei der Motivation (der Erklärung, warum EIFFEL über diese Eigenschaften verfügt), auf
ein Beispiel für kovariante Redefinition.
"
"32 Fazit
Typsysteme sind immer noch Gegenstand aktiver Forschung. Während die prozeduralen
und objektorientierten Programmiersprachen eher pragmatisch an das Thema herangehen,
sind auf dem Gebiet der funktionalen Programmiersprachen ausgefeilte Theorien entwickelt
worden, die nach und nach auf andere Programmiersprachen übertragen werden. Die meis-
ten der heute in Gebrauch befindlichen objektorientierten Programmiersprachen sind hin-
gegen nicht die Quintessenz umfangreicher theoretischer Überlegungen, sondern vielmehr
das Produkt von Ideen, Experimenten und einer ganzen Men ge praktischer Zwänge.
So ist denn die Darstellung von Typsystemen in dieser Kurseinheit eher dazu gedacht, an
einen gewissen Konsens bei der Typisierung objektorientierter Programmiersprachen heran-
zuführen denn das Thema theoretisch aufzubereiten. Eine gute, nicht allzu theorielastige
Einführung in Typsysteme für die objektorientierte Programmierung ist das Buch „Object -
Oriented Type Systems “ von JENS PALSBERG und MICHAEL SCHWARTZBACH ; es is t recht dünn
und dabei noch einigermaßen angenehm zu lesen. Sehr viel weitergehend ist das Buch „ Ty-
pes and Programming Languages “ von BENJAMIN PIERCE, das einen Standard darstellt .
"
"52.4 Vererbung und Überladen
EIFFEL erlaubt Mehrfachvererbung. Es gestattet zudem sowohl das Überschreiben (in EIFFEL
Redefinition genannt) als auch das Löschen von Methoden. Auf der Haben -Seite steht dabei,
dass zu Beginn einer Klassendefinition deklariert werden muss , welche Methoden in der
Klasse überschrieben (welche „Features redefiniert“) werden. Natürlich gibt es in EIFFEL auch
abstrakte Klassen ; das dazugehörige Schlüsselwort heißt jedoch deferred anstatt
abstract , ansonsten ist aber alles wie in JAVA (richtiger: in JAVA ist alles wie in EIFFEL —
EIFFEL ist ca. zehn Jahre älter als JAVA).
BERTRAND MEYER ist ein bek ennender Gegner des Überladens. Es ist in EIF-
FEL daher nicht erlaubt, dass eine Klasse zwei Methoden besitzt, die gleich
heißen. Gleichwohl ist es erlaubt, dass verschiedene Klassen gleichnamige
Methoden besitzen — nur dann dürfen diese Klassen nicht in Ve rerbungsbeziehung zuei-
nander stehen, es sei denn, die Methoden besitzen gleiche oder kovariant redefinierte Pa-
rametertypen , denn dann sind die Methoden nicht überladen, sondern werden überschrie-
ben (was dann allerdings durch eine Redefine -Deklaration anzuzeigen ist). Nun kann man
aber nicht erzwingen, dass zwei Klassen, von denen man erben möchte, keine gleichnami-
gen Methoden verwenden. Anstatt auf das Erben zu verzichten, ist e s in EIFFEL deswegen
möglich, geerbte Features umzubenennen. Es gibt zu diesem Zweck eine Rename -Klausel,
die es erlaubt, zwei geerbte Features gleichen Namens mit unterschiedlichen Benennungen
nebeneinander stehen zu lassen. Man beachte, dass das dynamisc he Binden davon unbe-
rührt bleibt: Über den Typ der Klasse, von der ein umbenanntes Feature geerbt wurde, an-
gesprochen hört das Feature weiterhin auf seinen ursprünglichen Namen.
"
"51.4 Mehrfachvererbung
Getreu sein em Motto, alle Freiheit in die Hand der Programmiererin zu legen und ihr nicht
mit einer gouvernantenhaften Du -kannst -das-bestimmt -nicht -Attitüde zu begegnen, bietet
C++ (im Gegensatz zu SMALLTALK , JAVA und C#) uneingeschränkte Mehrfachvererbung .
Das kann aus verschiedenen Gründen sinnvoll erscheinen:
Eine Klasse, die von mehreren, vollständig abstrakten (also mit keinerlei Implemen-
tierung versehenen) Klassen erbt, implementiert damit faktisch mehrere Interfaces.
Der einzige Nachteil ist, dass die Programmiererin nicht in Mitteln der Sprache aus-
drücken kann, ob eine abstrakte Klasse die Funktion eines Interfaces oder die einer
Generalisierung (von der man Implementierung erben kann ; vgl. Abschnitt 9.1) ha-
ben soll — dazu sind dann schon Namenskonventionen notwendig.
 Nicht selten ergibt sich aus der Aufgabenstellung, dass eine Klasse Eigenschaften
von mehreren anderen gebrauchen könnte. In S prachen mit Einfachvererbung muss
man sich dann für eine Klasse als Superklasse entscheiden und den Beitrag der an-
deren Klassen wiederholen, also erneut implementieren oder per Delegation bzw.
Forwarding einbinden.78 Mehrfachvererbung erlaubt im Gegensatz dazu, sich alles
zusammenzuerben, was man benötigt.
Da das Erben jedoch nicht se lektiv (in dem Sinne, dass man sich aussuchen könnte, was
man von einer Klasse erbt) erfolgt und das Löschen von geerbten Membern in C++ nicht
möglich ist, fühlt man sich häufig bemüßigt , die Klassen, von denen man erbt, in viele kleine
stanzen der anderen Klassen bei und delegiert die Funktionen, die die Hauptklasse nicht erben kann,
an die beigeordneten Instanzen. Das ist dann je doch jedes mal auszuprogrammieren und daher ziem-
lich lästig.
aufzusplitten un d nur die zu beerben, deren Eigenschaften man braucht, um sich von un-
nötigem Ballast freizuhalten .
Mehrfachvererbung ist etwas, das sich Programmiere rinnen gerne wün-
schen. Sie bringt jedoch einige praktische Probleme mit sich, unter ande-
rem die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene
Definitionen desselben Elements (Feld oder Methode) erbt. Da die Klasse sich dann für eine
der beiden Definitionen entscheiden muss , geht die der anderen verloren. Dies kann, insbe-
sondere im Zusammenhang mit dynamischem Binden und offener Rekursion , zu unerwar-
tetem Verhalten führen. Darüber hinaus führt die Mehrfachvererbung noch zu zahlreichen
weiteren Problemen, die hier nich t weiter ausgeführt werden sollen.
"
"4.6 Abgeleitete Kontrollstrukturen
Wenn Sie schon in anderen Programmiersprachen wie z. B. PASCAL , C oder JAVA program-
miert haben, dann kennen Sie s icher Schlüsselwörter wie if, else , for und while . Diese
Schlüsselwörter stehen für Kontrollstrukturen, feste Bestandteile der Sprache, die für die
Steuerung des Ablaufs eines Programms durch die Programmiererin vorgesehen s ind. Man
hat sich irgendwann einmal (im Zuge der Diskussion zur sog. strukturierten Programmie-
rung) darauf festgelegt, dass jede Programmiersprache über die Kontrollstrukturen Se-
quenz, Verzweigung, Wiederholung (Iteration ) und Aufruf verfügen sollte. Während die
einfache Sequenz von Anweisungen während der Ausführung durch die lineare Folge der
Anweisungen im Programmtext vorgegeben ist, sind für alle Abweichungen vom linearen
Kontroll fluss, also für Verzweigung, Wiederholung und Aufruf, spezielle Flusssteuerungs-
konstrukte vorgesehen. Das Goto gehört übrigens nicht dazu; es gilt seit dem Aufkommen
der strukturierten Programmierung als verpönt.
In SMALLTALK hat man die durch die Syntax der Sprache vorgesehenen
Kontrollstrukturen auf die Sequenz und den Aufruf, letzteres ausgedrückt
durch das Versenden einer Nachricht an ein Objekt, beschränkt. Alle anderen Kontrollstruk-
turen müssen mit den Mitteln der Sprache simuliert werden. Was zunächst wie eine erheb-
liche Einschränkung aussehen mag, erweist sich in der Praxi s als gewichtiger Vorteil: Die
Programmiererin kann nämlich selbst, wenn ihr danach ist, neue Kontrollstrukturen einfüh-
ren.
"
"Kurseinheit 2: Systematik der objektorientierten
Programmierung
In der vorangegangenen Kurseinheit haben Sie die Grun dkonzepte der objektorientierten
Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor
allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon
abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten.
Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation
gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden.
Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Pro-
grammierung nicht grundsätzlich festgelegt . Eine gewisse Anerkennung
und Verbreitung erfahren haben aber drei verschiedene Ansätze:
1. der Konstruktoransatz, bei dem der Aufbau eines Objekts in e iner Methode be-
schrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Me-
thoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschie-
den aufgebaute Objekte;
2. der Prototypenansatz, bei dem ein schon existierendes Objekt sam t seiner Instanzva-
riablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzva-
riablen und Methoden ergänzt werden oder geklonte können abgeändert oder ent-
fernt werden; und
3. der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die
entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt
werden.
Den Konstruktoransatz findet man in Sprachen wi e EMERALD , den Prototypenansatz in Spra-
chen wie SELF oder JAVASCRIPT und den Klassenansatz in Sprachen wie SMALLTALK , C++, EIF-
FEL, JAVA, C#, SCALA und vielen anderen mehr .
Aus verschiedenen Gründen hat s ich die dritte Variante, die klassenbasierte Form der
Objektorientierung (wobei die Klassen die erwähnten Vorlagen sind) gegenüber der zwei-
ten, der prototypenbasierten Form der Objektorientierung weitgehend durchgesetzt.
Die erste Variante findet im Zuge einer gewi ssen Ernüchterung bzgl. der objektorientierten
Programmierung zunehmend Anhänger, und zwar da, wo Objekte und dynamisches Binden
(s. Abschnitt 12) im Kontext traditioneller imperativer Programmierung angeboten werden
sollen. Sie liegt damit aber außerhalb des Gegenstands dieses Kurstextes. Alternativen der
Die Dominanz der klassenbasierten Form der objektorientierten Program-
mierung liegt vermutlich zum einen daran, dass Klassen ein klassisches,
in anderen Disziplinen wie der Mathematik oder der Biologie fest etab-
liertes Ordnungskonzept darstellen, mit dessen Hilfe sich auch objektori-
entierte Programme gut strukturieren lassen, und zum anderen daran, dass Klassen sich als
(Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften
anderer, nicht objektorientierter, dafür aber typisierter Sprachen (also Sprachen, bei denen
alle Variablen und Funktionen bei der Deklaration einen Typ zugeordnet bekommen und
der Variableninhalt immer vom deklarierten Typ sein muss ) übernehmen kann (der Gegen-
stand von Kurseinheit 3). Die prototypenbasierte Form der Objektorientierung hat hingegen
den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler ein-
zelne Objekte an ihren jeweiligen Zweck anpassen kann, z. B. indem sie eine Methodende-
finition nur für ein einziges Objekt abzuändern erlaubt. Letzteres ist z. B. bei der Program-
mierung von grafischen Bedienoberflächen, bei der das Drücken verschiedener Butt ons je-
weils verschiedene Ereignisse auslöst (Methoden aufruft), sehr praktisch. Nicht umsonst ist
JAVASCRIPT als Programmiersprache für interaktive Webseiten so erfolgreich.
Auch wenn es gute Gründe für die prototypenbasierte Form der objektorientierten Pr ogram-
mierung gibt (und sich deswegen jedes Werk zum Thema objektorientierte Programmierung
— so wie auch das Ihnen vorliegende — gemüßigt fühlt, darauf hinzuweisen, dass es sie
gibt), werden ich mich im folgenden vornehmlich Klassen als strukturbildenden K onzepten
der objektorientierten Programmierung zuwenden und nur hier und da Prototypen kurz die
Referenz erweisen.28
"
"50.4 Das Typsystem von C#
Auch wenn es in großen Teilen recht ähnlich ausfällt, so weicht das Typsystem von C# von
dem JAVAs gleich in mehreren wesentlichen Punkten ab:
 der Art der Unterscheidung von Wert - und Referenztypen,
 den angebotenen Typkonstruktoren für Wert - und Referenztypen und
 dem Umgang mit Interfaces als Typen.
Darüber hinaus hat C# noch eine ganze Reihe w eiterer Verbesserungen, die man mit dem
Typsystem in Verbindung bringen kann; auf sie wird hier aber nur am Rande eingegangen.
"
"62 Namenwahl
Gegen die Verwendung langer, sprechender Bezeichner kann man einwenden, dass der
Programmtext dadurch übermäßig lang wird. Anweisungen, die sonst in eine Zeil e gepasst
hätten, müssen u. U. mehrfach umgebrochen werden, was die Lesbarkeit nicht gerade er-
höht. Auch hört man hier und da, dass lange Namen für die Programmiererin zusätzliche
Schreibarbeit bedeuten. Letzteres Argument kann man jedoch kaum gelten lassen, da die
meisten Entwicklungsumgebungen über eine automatische Vervollständigungsfunktion ver-
fügen, die einem das Tippen abnimmt (und damit auch Tippfehler aufdeckt od er vermeidet).
Das erste Argument ist schon schwieriger zu entkräften: Natürlich sind prägnante Namen
geschwätzigen vorzuziehen und auch in der Programmierung liegt die Würze in der Kürze
— insbesondere sind lange Namen, die sich nur geringfügig unterschei den (und das auch
noch wenig offensichtlich), zu vermeiden. Als Faustregel ist ein Name dann gut gewählt,
wenn man alle Ausdrücke, in denen er vorkommt, schnell verstehen kann (und nicht nur,
aufgrund falscher Assoziationen und Vermutungen, zu verstehen gl aubt). Eine sorgfältige
Programmiererin wird sich also häufiger dabei beobachten, wie sie über eine n passenden
Namen für ein Programmelement länger nachsinnt. Diese Zeit ist jedoch gut investiert. Namen als Ersatz für
Kommentare
IImmmmeerr sspprreecchheennddee NNaammeenn vveerrwweennddeenn..
"
"62.2 Namenskonventionen
Häufig findet man in einzelnen Projekten und nicht selten in ganzen Firmen Namenskon-
ventionen vor, an die sich alle hal ten sollten. Namenskonventionen erleichtern nicht nur die
Bezeichnerwahl (indem die Programmiererin sich an bestimmte Regeln halten kann, wird
ihre schöpferische Freiheit eingeschränkt, was man durchaus auch als Entlastung empfinden
kann), sie erleichtern auch das Lesen, weil die Leserin , die die Konventionen kennt, d ie Be-
deutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter ent-
schlüsseln kann und sie sich somit schneller zurechtfindet. Allerdings ist es dazu notwendig,
dass die Namenskonventionen genau festgeschrieben sind und dass sich alle darauf einigen
— wenn nämlich jede ihre individuelle Auslegung der Regel hat, dann kann eine (vermeint-
liche) Namenskonventionen mehr Verwirrung stiften als nutzen. Abkürzungen bei
It would be a mistake to protest against the rules … on the grounds that they
limit developer creativity. A consistent style favors rather than hampers creativ-
ity by channeling it to where it matters. A large part of the effort of producing
software is spent reading existing software and making others read what is
being written. Individual vagaries benefit no one; common conventions help
everyone.
Bertrand Meyer
"
"20.1 Induktiver Aufbau von Typen und Semantik
Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen
gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht
von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean : Alle seine Ope-
rationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergeb-
nis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren
Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst
beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte ex-
terne Formalismen abzubil den. Im Beispiel von Boolean ist dies natürlich die boolesche
Algebra . Jede, die die boolesche Algebra kenn t und akzeptiert, wird auch den Typ Boolean
sofort verstehen und akzeptieren (so er denn den Erwartungen entsprechend definiert ist).
Entsprechend lässt sich ein Typ Fraction mit den Operatio nen +, –, * und / definieren,
der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man
dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-
gleichsoperationen wie =, >, < etc. hinzufügen, ohne in Interpretationsprobleme zu laufen.
Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition
rekursiv auf solche Typen zurückgeführt werden können, kann man „induktiv über deren
Aufbau“ eine B edeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeu-
tung eine denotationale Semantik .
Eine andere, für die praktische Prog rammierung relevantere Möglichkeit
ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten
oder realen, Hauptsache wohlspezifizierten) Maschine abzubilden. Die Abbildung für Basis-
typen wie Rational oder Boolean ist in der Programmiersprache b zw. deren Compiler
gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann sie dies
hingegen nicht sein; deren Bedeutung kann aber vom Compiler, wiede rum „induktiv über
deren Aufbau“, aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, ab-
geleitet werden. Man nennt dies dann auch eine operationale Semantik .
Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf
solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein
vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK
bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht „hart
verdrahtet“, sondern auf dynamisches Binden abgewälzt wird, so sind dafür aber mindes-
tens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und
Float (nicht jedoch Fraction !) sind „fest verdrahtet“, inklusive der Vergleichsrelationen
(die ja die Wahrheitswerte zum Ergebnis haben).
Wenn Sie Kurs 01661 („Datenstrukturen“) bereits belegt haben oder
ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von
Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen.
Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrie-
ben, de ren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei
wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Pro-
tokoll ei nes STRONGTALK -Typs:
1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte kei-
nen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die
Operationen ausgeführt werden, nich t ihren Zustand wechseln. Statt dessen geben
Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also
gewissermaßen alle unveränderlich (vgl. Kurseinheit 1, Abschnitt 4.3.5 ). denotationale
2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen
in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar
vom T yp des Datentyps selbst. Dieses Argument entspricht in der objektorientierten
Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self .
Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Pro-
grammiersprache mit einer Semantik zu versehen.
"
"Kurseinheit 3: Typen in der objektorientierten
Programmierung
The purpose of a type system is to prevent the occurrence of execution errors
during the running of a program. The accuracy of this informal statement de-
pends on the rather subtle issue of what constitutes an execut ion error. Even
when that is settled, the type soundness of a programming language (the ab-
sence of certain execution errors in all program runs) is a non -trivial property.
A fair amount of careful analysis is required to avoid false and embarrassing
claims of type soundness; as a consequence, the classification, description,
and study of type systems has emerged as a formal discipline.
Luca Cardelli
Im Geg ensatz zu SMALLTALK sind die meisten objektorientierten Programmiersprachen typi-
siert, was soviel heißt wie dass Programmelementen bei ihrer Deklaration (s. Kapitel 19)
Typen zugeordnet werden. Dabei schränkt ein Typ die Menge der Objekte, für die ein Pro-
grammelement stehen kann, und die Menge der Dinge, die damit gemacht werden können,
ein. Meistens sind die Regeln zur Verwendung von Typen fester Bestandteil der Sp rache —
wenn Sie eine solche Sprache neu lernen, dann würden Sie gar nicht auf die Idee kommen,
Typsystem und übrige Sprachdefinition voneinander getrennt zu betrachten. Dennoch sind
Typen für das Funktionieren eines Programms prinzipiell verzichtbar46 und es lohnt sich
durchaus, das Typsystem einer Sprache von ihrem Rest zu lösen, beispielsweise weil man es
austauschen oder verbessern will. Dies um so mehr, als heute gängige Typsysteme entweder
ziemlich schwach oder ziemlich kompliziert sind.
So führt dies e Kurseinheit Typsysteme am Beispiel von STRONGTALK , einer SMALLTALK -Erwei-
terung um ein optionales Typsystem , ein. Sie geht dabei langsam und inkrementell vor. Wer
das zu öde erscheint, die sei gewarnt: Es wird noch kompliziert genug und nicht jede Leserin
wird alles, was sie in diesem Kurs über Typsysteme liest, auf Anhieb verstehen. Auch wäre
46 Wenn man auf Möglichkeiten wie das Überladen von Methoden verzichten kann; Laufzeittypin-
formation , wie man sie z. B. für das dynamische Binden oder für die Garbage collection benötigt,
kann durch Laufzeitklasseninformation (was nicht dasselbe ist!) ersetzt werden ; s. Abschnitt 28.3.
die Alternative, diese Kurseinheit am Beispiel einer bekannteren Sprache mit verpflichten-
dem Typsystem hochzuziehen, stets mit dem Nachtei l belastet, dieses konkrete Typsystem
als quasi vom Himmel gefallen darstellen zu müssen — wenn Sie dann später eine andere
Sprache kennenlernen, hätten Sie vermut lich Schwierigkeiten, das Gelernte abzustreifen
und sich mit den neuen Verhältnissen zurechtz ufinden. Ziel dieser Kurseinheit ist aber, dass
Sie Typsysteme als das verstehen, was sie sind: eine Möglichkeit zur Spezifikation redundan-
ter Information, die die Qualität von Programmen erhöhen soll.
"
"Kurseinheit 5: Andere objektorientierte
Programmiersprachen
Während der obige Leitspruch aus akademischer Sicht sicher richtig ist, können sich Prakti-
kerinnen (und solche, die es werden wollen) diese Einstellung nicht leisten. Stattdessen muss
man die Sprachen kennen, für die es einen Markt gibt. Und so zeichnen sich die in dieser
Kurseinheit behandelten Sprachen mit Ausnahme von EIFFEL weniger durch revolutionäre
Konzepte oder neuartige Sichtweisen aus, sondern vielmehr dadurch, dass sie in de r Praxis
weite Verwendung finden. Gleichwohl mag die eine oder andere Eigenheit der einen oder
anderen Sprache der Leserin Anlass geben, ihre bisherigen Denkweisen zu überprüfen.
Ziel dieser Kurseinheit ist es übrigens nicht, Sie zu Programmiererinnen in einer der (oder
gar allen) in dieser Kurseinheit behandelten Sprachen C#, C++ und EIFFEL zu machen. Ziel
ist vielmehr, Ihnen eine erste Übersicht und ein Verständnis dieser Sprachen zu vermitteln.
Sie sollen einen Eindruck davon bekommen, auf was Sie sich einlassen, wenn Sie sich ent-
scheiden, in einer der genannten Sprachen Software zu entwickeln. Dazu gehört nicht, jedes
Konstrukt jeder dieser Sprachen zu kennen oder auch nur einmal gesehen zu haben, son-
dern vielmehr eine Vorstellung davon, was jeweils deren charakteristische Eigenschaften,
was die Stärken und was d ie Schwächen jeder einzelnen Sprache sind. Je nachdem, wie sich
die einzelnen Sprachen von bereits besprochenen unterscheiden, fällt die folgende Darstel-
lung kürzer oder länger aus.
"
"1.3 Änderbarkeit von Objekten
Während atomare Objekte grundsätzlich nicht änderbar sind (welchen Si nn hätte es bei-
spielsweise, aus einer „1“ eine „2“ zu machen oder aus einem „a“ ein „b“?), so gilt das
für zusammengesetzte zunächst nicht: Es ist leicht vorstellbar (und auch grundsätzlich sinn-
voll), in einem Array -Objekt eine Komponente durch ein e andere zu ersetzen. Die Frage ist
allerdings, ob dies auch für Array -Objekte gilt, die aus Literalen erzeugt wurden: Soll es
erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array -Literal #(1 2 3)
hervorgegangen ist, durch ein Programm abgeändert wird , so dass es nicht mehr seiner
(ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache
und wird zumindest für String -und Array -Literale von unterschiedlichen SMALLTALK -Dialek-
ten unterschiedlich gehandhabt . Objekte, die aus Symbolliteralen hervorgegangen sind,
sollten dagegen nie änderbar sein. Array -Literale
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch änderbar. Es ist dies
Voraussetzung dafür, dass Objekte einen Zustand haben können (s. Kapitel 3), was wiede-
rum die objektorientierte Programmierung zu einer Form der imperativen Programmierung
macht . Durch die Zunahme funktionaler Einflüsse auf die objektorientierte Programmierung
findet man jedoch auch zunehmend Sprachen, die unveränderliche Objekte anbieten (so
z. B. SCALA).
"
"14.1 Kopieren von Objekten
In Abschnitt 7.3 hatten wir ja die Instanziierung als den hauptsächlichen Weg kennenge-
lernt, w ie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation
gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Ko-
pierens hingewiesen. Darauf wollen wir nun wieder zurückkommen.
Die einfachste Form des Kopierens eines Objekts erzeugt ein Objekt glei-
cher Klasse mit gleichen Variablenbelegungen. Dazu gibt es in SMALLTALK die Methode
Diese Meth ode liefert eine neue Instanz der Klasse des Empfängers, die in denselben Bezie-
hungen zu denselben anderen Objekten steht wie das Original. Insbesondere werden die
Objekte, die die Instanzvariablen des Originals benennen, nicht selbst kopiert. Deswegen
nennt man die Kopie flach . Sie erfolgt einfach durch Zuweisung aller Instanzvariablen des
Originals an die Instanzvariablen des neuen Objekts, das damit zur Kopie wird. Die Imple-
mentierung in SMALLTALK EXPRESS ist die folgende:
isVariable unterscheidet dabei zwischen Klassen mit indizierten Instanzvariablen und sol-
chen ohne; isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objek-
ten und atomaren .
Nun ist eine flache Kopie aber häufig nicht genug. Es gibt daher noch
eine zweite Methode
Wie der Name nahele gt, unterscheidet sich die Methode deepCopy von shallowCopy
darin, dass auch die in Beziehung stehenden (durch die Instanzvariablen benannten) Objekte
kopiert werden. Statt einzelner Objekte wird also ein Objektgeflecht kopiert — die Kopie ist
tief. Es muss dazu an die beiden tatsächlich en Parameter von put: (Zeilen 566 und 570)
lediglich eine Nachricht zum Kopieren der Parameter angehängt werden. Dabei ist jedoch flaches Kopieren
Vorsicht geboten: Wenn es sich dabei ebenfalls um ein tiefes Kopieren handelt, dann kann
der Kopiervorgang leicht in eine Endlosrekursion geraten.
Selbsttestaufgabe 14.1
Überlegen Sie, wie Sie ei n rekursives tiefes Kopieren technisch in den Griff bekommen können.
Nun ist die Festlegung, ob die Kopien ihrer Instanzen tiefe oder flache
sein sollen, gelegentlich ein Charakteristikum der Klasse selbst. Jede
Klasse erbt deswegen von Object eine Methode copy , die standardmäßig (also in Object )
einfach shallowCopy aufruft (warum es nicht deepCopy aufruft, sollte klar sein) und die
die erbende Klasse entsprechend ihren eigenen Konditionen überschreiben kann. Es ist so
möglic h, die Kopiertiefe von Objektstrukturen selbst zu bestimmen, indem man copy für
manche Klassen deepCopy aufrufen lässt und das tiefe Kopieren durch Instanzen termi-
niert, deren Klassen shallowCopy aufrufen lassen.
Manchmal darf bei Kopier - oder Konvertiero perationen kein Objekt des
gleichen Typs zurückgegeben werden. In diesen Fällen sollte statt self
class (Zeile 554) self speci es aufgerufen werden:
Die Methode species war uns schon einmal begegnet, und zwar in Kurseinheit 1, Ab-
schnitt 4.6.4 , Zeile 244. Sie gibt standardmäßig die Klasse des Empfängerobjekts zurück
und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist
z. B. bei der Methode collect: , ausgeführt auf einer Instanz von Interval , sinnvoll, da
collect: hier kein Intervall zurückgeben kann. So kann beispielsweise die von
zurückgegebene Collection von Strings nicht als Intervall dargest ellt werden . Entsprechend
ist in der Klasse Interval die Methode species als
implementiert.
"
"28.2 Typen als Schnittstellenspezifikationen von Klassen
Eine Klasse liefert eine Implementierung. Nach gängigen Prinzipien nicht nur der objektori-
entierten Programmierung sind Implementierungen aber hinter Schnittstellen (oder Inter-
faces ) zu verbergen: Nur die Elemente einer Klassendefinition, die für Benutzerinnen einer
Klasse zu Verwendung gedacht sind, sollen durch die Schnittstelle nach außen getragen
werden — der Rest soll verborgen bleiben (das sog. Geheimnisprinzip ).
In Programmiersprachen wie JAVA, C++ etc. gibt es spezielle Schlüssel-
wörter, die einem Element einer Klassendefinition (beispiels weise einer
Methode) vorangestellt seine Zugreif barkeit festlegen. Diese sog. Zu-
griffsmodifikatoren (engl. access modifier ) legen gemeinsam mit der Klassendefinition, die
ihre vollständige Implementierung beinhaltet, auch die Schnittstelle der Klasse fest. Je nach
Sprache ist diese Schnittstelle für alle Benutzeri nnen der Klasse gleich oder unterscheidet
sich nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse. Im Zugriffsmodifikato-
ren; absolute und
relative Schnittstelle
ersten Fall könnte man von einer absoluten Schnittstelle sprechen; um sie zu spezifizieren,
reicht es, zwischen sichtbar un d unsichtbar zu unterscheiden. Im zweiten Fall ist die Schnitt-
stelle relativ.
Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirk-
lich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. S ie
besteht nämlich nur aus Deklarationen von Methoden . Die gemachte Ein-
schränkung ist notwendig, weil manche Sprachen, so z. B. JAVA und C++, die Instanzvari-
ablen ihrer Objekte in die Schnittstelle der Klassen aufzunehmen erlauben. Mit den In-
stanzvariab len wird aber die Repräsentation der Objekte nach außen sichtbar, was dem
Gedanken des Geheimnisprinzips widerspricht.
Wenn man nun eine Variable mit einem solchen die Schnittstelle reprä-
sentierenden Typ deklariert und eine Typprüfung erfolgreich durchge-
führt hat, dann ist sichergestellt, dass über diese Variable nur auf die Ele-
mente einer Klasse zugegriffen wird, die auch Bestandteil des Interfaces der Klasse sind.
Wenn jede Instanz dieser Klasse ausschließlich über typisierte Variablen ansprechbar ist, ist
damit die Wahrung des Geheimnisprinzips garantiert. Typen dienen damit einem weiteren
Zweck, den man zunächst einmal nicht mit ihnen assoziieren würde, nämlich der Wahrung
des Implementationsgeheimnisses/Einhaltung der Schnittstellen durch den Compiler.
Dieser überaus nützliche Zusammenhang zwischen Klassen, ihren Schnittstellen und Typen
wurde erst relativ spät, nämli ch mit der Programmiersprache JAVA und ihrem Interface -als-
Typ-Konzept , so weiterentwickelt, dass eine Klasse verschiedene Schnittstellen anbieten
kann, die alle zugleich Typen der Klasse (gen auer: Supertypen des der Klasse entsprechen-
den Typs) sind. Die damit ermöglichte interfacebasierte Programmierung , die in Kurs 01853
ausführlich behandelt wird, betrachte ich persönlich als den wichtigsten Beitrag JAVAs zur
Disziplin der objektorientierten Programmierung (s. a. Kurseinheit 4, Kapitel 45).
"
