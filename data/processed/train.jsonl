{"question": "Warum sind identische Objekte immer gleich, gleiche Objekte aber nicht identisch?", "paragraph": "Objekte sind Stellen im Speicher, an denen die Daten, die ein Objekt ausmachen, hinterlegt sind. Die Identit\u00e4t eines Objekts ist mit der Speicherstelle gleichzusetzen. Das erkl\u00e4rt auf technische Weise, warum identische Objekte immer gleich, gleiche Objekte aber nicht identisch sind und warum die Ver\u00e4nderung (der Eigenschaften) eines Objekts seine Identit\u00e4t nicht ber\u00fchrt.", "answer": "Die Identit\u00e4t eines Objekts ist mit der Speicherstelle gleichzusetzen", "sentence": "Die Identit\u00e4t eines Objekts ist mit der Speicherstelle gleichzusetzen. Das erkl\u00e4rt auf technische Weise, warum identische Objekte immer gleich, gleiche Objekte aber nicht identisch sind", "paragraph_sentence": "Objekte sind Stellen im Speicher, an denen die Daten, die ein Objekt ausmachen, hinterlegt sind. <hl> Die Identit\u00e4t eines Objekts ist mit der Speicherstelle gleichzusetzen. Das erkl\u00e4rt auf technische Weise, warum identische Objekte immer gleich, gleiche Objekte aber nicht identisch sind <hl> und warum die Ver\u00e4nderung (der Eigenschaften) eines Objekts seine Identit\u00e4t nicht ber\u00fchrt.", "paragraph_answer": "Objekte sind Stellen im Speicher, an denen die Daten, die ein Objekt ausmachen, hinterlegt sind. <hl> Die Identit\u00e4t eines Objekts ist mit der Speicherstelle gleichzusetzen <hl>. Das erkl\u00e4rt auf technische Weise, warum identische Objekte immer gleich, gleiche Objekte aber nicht identisch sind und warum die Ver\u00e4nderung (der Eigenschaften) eines Objekts seine Identit\u00e4t nicht ber\u00fchrt.", "sentence_answer": "<hl> Die Identit\u00e4t eines Objekts ist mit der Speicherstelle gleichzusetzen <hl>. Das erkl\u00e4rt auf technische Weise, warum identische Objekte immer gleich, gleiche Objekte aber nicht identisch sind"}
{"question": "Welchen Sinn hat es, den Programmierenden zu erlauben f\u00fcr jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll? ", "paragraph": "Unter Wertsemantik k\u00f6nnen, solange jedes Objekt seine eigene Identit\u00e4t hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird f\u00fcr die objektorientierte Programmierung eher als Nachteil angesehen. Manche Programmiersprachen erlauben der Programmiererin, f\u00fcr jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll. Auf diesem Weg kann man Aliase vermeiden. Dies sollte man dann tun, wenn man verhindern m\u00f6chte, dass die Ver\u00e4nderung des durch eine Variable bezeichneten Objekts zugleich die Ver\u00e4nderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt. \nBei einer Zuweisung unter Wertsemantik muss, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist) und ein Objekt nicht in zwei Variablen gespeichert sein kann, eine Kopie angefertigt werden.", "answer": "Aliase vermeiden", "sentence": "Manche Programmiersprachen erlauben der Programmiererin, f\u00fcr jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll. Auf diesem Weg kann man Aliase vermeiden. Dies sollte man dann tun, wenn man verhindern m\u00f6chte, dass die Ver\u00e4nderung des durch eine Variable bezeichneten Objekts zugleich die Ver\u00e4nderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt.", "paragraph_sentence": "Unter Wertsemantik k\u00f6nnen, solange jedes Objekt seine eigene Identit\u00e4t hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird f\u00fcr die objektorientierte Programmierung eher als Nachteil angesehen. <hl> Manche Programmiersprachen erlauben der Programmiererin, f\u00fcr jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll. Auf diesem Weg kann man Aliase vermeiden. Dies sollte man dann tun, wenn man verhindern m\u00f6chte, dass die Ver\u00e4nderung des durch eine Variable bezeichneten Objekts zugleich die Ver\u00e4nderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt. <hl> Bei einer Zuweisung unter Wertsemantik muss, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist) und ein Objekt nicht in zwei Variablen gespeichert sein kann, eine Kopie angefertigt werden.", "paragraph_answer": "Unter Wertsemantik k\u00f6nnen, solange jedes Objekt seine eigene Identit\u00e4t hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird f\u00fcr die objektorientierte Programmierung eher als Nachteil angesehen. Manche Programmiersprachen erlauben der Programmiererin, f\u00fcr jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll. Auf diesem Weg kann man <hl> Aliase vermeiden <hl>. Dies sollte man dann tun, wenn man verhindern m\u00f6chte, dass die Ver\u00e4nderung des durch eine Variable bezeichneten Objekts zugleich die Ver\u00e4nderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt. Bei einer Zuweisung unter Wertsemantik muss, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist) und ein Objekt nicht in zwei Variablen gespeichert sein kann, eine Kopie angefertigt werden.", "sentence_answer": "Manche Programmiersprachen erlauben der Programmiererin, f\u00fcr jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll. Auf diesem Weg kann man <hl> Aliase vermeiden <hl>. Dies sollte man dann tun, wenn man verhindern m\u00f6chte, dass die Ver\u00e4nderung des durch eine Variable bezeichneten Objekts zugleich die Ver\u00e4nderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt."}
{"question": "Was sind Instanzvariablen?", "paragraph": "Jedem Objekt kann eine Menge von lokalen Variablen zugeordnet werden, die Instanzvariablen. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: In SMALLTALK sind sie f\u00fcr andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschr\u00e4nkt. ", "answer": "Jedem Objekt kann eine Menge von lokalen Variablen zugeordnet werden", "sentence": "Jedem Objekt kann eine Menge von lokalen Variablen zugeordnet werden, die Instanzvariablen.", "paragraph_sentence": "<hl> Jedem Objekt kann eine Menge von lokalen Variablen zugeordnet werden, die Instanzvariablen. <hl> Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: In SMALLTALK sind sie f\u00fcr andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschr\u00e4nkt. ", "paragraph_answer": "<hl> Jedem Objekt kann eine Menge von lokalen Variablen zugeordnet werden <hl>, die Instanzvariablen. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: In SMALLTALK sind sie f\u00fcr andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschr\u00e4nkt. ", "sentence_answer": "<hl> Jedem Objekt kann eine Menge von lokalen Variablen zugeordnet werden <hl>, die Instanzvariablen."}
{"question": "Wie gelangen in SMALLTALK Objekte in den Besitz von Instanzvariablen?", "paragraph": "Man verbindet die Instanzvariablen mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse geh\u00f6ren, beschreiben. \nKlassendefinitionen bilden also eine Art Vorlage f\u00fcr Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht. \nMittels Instanziierung und Klassen hat man nun die M\u00f6glichkeit, neue - und neuartige - Objekte programmatisch, also per Programmausf\u00fchrung, zu erzeugen. Dies geschieht standardm\u00e4\u00dfig, indem man der Klasse, von der man eine Instanz haben m\u00f6chte, die Nachricht new (f\u00fcr Klassen ohne indizierte Instanzvariablen) oder new: (f\u00fcr Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert.", "answer": "Instanziierung", "sentence": "Man verbindet die Instanzvariablen mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse geh\u00f6ren, beschreiben. \nKlassendefinitionen bilden also eine Art Vorlage f\u00fcr Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht. \nMittels Instanziierung und Klassen hat man nun die M\u00f6glichkeit, neue - und neuartige - Objekte programmatisch, also per Programmausf\u00fchrung, zu erzeugen.", "paragraph_sentence": "<hl> Man verbindet die Instanzvariablen mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse geh\u00f6ren, beschreiben. Klassendefinitionen bilden also eine Art Vorlage f\u00fcr Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht. Mittels Instanziierung und Klassen hat man nun die M\u00f6glichkeit, neue - und neuartige - Objekte programmatisch, also per Programmausf\u00fchrung, zu erzeugen. <hl> Dies geschieht standardm\u00e4\u00dfig, indem man der Klasse, von der man eine Instanz haben m\u00f6chte, die Nachricht new (f\u00fcr Klassen ohne indizierte Instanzvariablen) oder new: (f\u00fcr Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert.", "paragraph_answer": "Man verbindet die Instanzvariablen mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse geh\u00f6ren, beschreiben. Klassendefinitionen bilden also eine Art Vorlage f\u00fcr Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die <hl> Instanziierung <hl> ist ein Vorgang, bei dem ein neues Objekt entsteht. Mittels Instanziierung und Klassen hat man nun die M\u00f6glichkeit, neue - und neuartige - Objekte programmatisch, also per Programmausf\u00fchrung, zu erzeugen. Dies geschieht standardm\u00e4\u00dfig, indem man der Klasse, von der man eine Instanz haben m\u00f6chte, die Nachricht new (f\u00fcr Klassen ohne indizierte Instanzvariablen) oder new: (f\u00fcr Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert.", "sentence_answer": "Man verbindet die Instanzvariablen mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse geh\u00f6ren, beschreiben. Klassendefinitionen bilden also eine Art Vorlage f\u00fcr Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die <hl> Instanziierung <hl> ist ein Vorgang, bei dem ein neues Objekt entsteht. Mittels Instanziierung und Klassen hat man nun die M\u00f6glichkeit, neue - und neuartige - Objekte programmatisch, also per Programmausf\u00fchrung, zu erzeugen."}
{"question": "Wie werden Beziehungen eines Objekts zu einem anderen in SMALLTALK realisiert?", "paragraph": "Die Beziehung eines Objekts zu einem anderen wird auf nat\u00fcrliche Weise durch eine benannte Instanzvariable ausgedr\u00fcckt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung tr\u00e4gt. Ein Objekt kann, und wird h\u00e4ufig, in derselben Beziehung zu mehreren andern stehen. Genau daf\u00fcr sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne f\u00fcr jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu m\u00fcssen. Die Namen der Gegen\u00fcber sind einfach Indizes: 1, 2, 3 usw. ", "answer": "durch eine benannte Instanzvariable", "sentence": "Die Beziehung eines Objekts zu einem anderen wird auf nat\u00fcrliche Weise durch eine benannte Instanzvariable ausgedr\u00fcckt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung tr\u00e4gt.", "paragraph_sentence": "<hl> Die Beziehung eines Objekts zu einem anderen wird auf nat\u00fcrliche Weise durch eine benannte Instanzvariable ausgedr\u00fcckt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung tr\u00e4gt. <hl> Ein Objekt kann, und wird h\u00e4ufig, in derselben Beziehung zu mehreren andern stehen. Genau daf\u00fcr sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne f\u00fcr jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu m\u00fcssen. Die Namen der Gegen\u00fcber sind einfach Indizes: 1, 2, 3 usw. ", "paragraph_answer": "Die Beziehung eines Objekts zu einem anderen wird auf nat\u00fcrliche Weise <hl> durch eine benannte Instanzvariable <hl> ausgedr\u00fcckt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung tr\u00e4gt. Ein Objekt kann, und wird h\u00e4ufig, in derselben Beziehung zu mehreren andern stehen. Genau daf\u00fcr sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne f\u00fcr jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu m\u00fcssen. Die Namen der Gegen\u00fcber sind einfach Indizes: 1, 2, 3 usw. ", "sentence_answer": "Die Beziehung eines Objekts zu einem anderen wird auf nat\u00fcrliche Weise <hl> durch eine benannte Instanzvariable <hl> ausgedr\u00fcckt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung tr\u00e4gt."}
{"question": "Wie werden Beziehungen eines Objekts zu mehreren anderen in SMALLTALK realisiert?", "paragraph": "Die Beziehung eines Objekts zu einem anderen wird auf nat\u00fcrliche Weise durch eine benannte Instanzvariable ausgedr\u00fcckt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung tr\u00e4gt. Ein Objekt kann, und wird h\u00e4ufig, in derselben Beziehung zu mehreren andern stehen. Genau daf\u00fcr sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne f\u00fcr jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu m\u00fcssen. Die Namen der Gegen\u00fcber sind einfach Indizes: 1, 2, 3 usw. ", "answer": "indizierten Instanzvariablen", "sentence": "Ein Objekt kann, und wird h\u00e4ufig, in derselben Beziehung zu mehreren andern stehen. Genau daf\u00fcr sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne f\u00fcr jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu m\u00fcssen.", "paragraph_sentence": "Die Beziehung eines Objekts zu einem anderen wird auf nat\u00fcrliche Weise durch eine benannte Instanzvariable ausgedr\u00fcckt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung tr\u00e4gt. <hl> Ein Objekt kann, und wird h\u00e4ufig, in derselben Beziehung zu mehreren andern stehen. Genau daf\u00fcr sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne f\u00fcr jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu m\u00fcssen. <hl> Die Namen der Gegen\u00fcber sind einfach Indizes: 1, 2, 3 usw. ", "paragraph_answer": "Die Beziehung eines Objekts zu einem anderen wird auf nat\u00fcrliche Weise durch eine benannte Instanzvariable ausgedr\u00fcckt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung tr\u00e4gt. Ein Objekt kann, und wird h\u00e4ufig, in derselben Beziehung zu mehreren andern stehen. Genau daf\u00fcr sind aber die <hl> indizierten Instanzvariablen <hl> wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne f\u00fcr jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu m\u00fcssen. Die Namen der Gegen\u00fcber sind einfach Indizes: 1, 2, 3 usw. ", "sentence_answer": "Ein Objekt kann, und wird h\u00e4ufig, in derselben Beziehung zu mehreren andern stehen. Genau daf\u00fcr sind aber die <hl> indizierten Instanzvariablen <hl> wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne f\u00fcr jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu m\u00fcssen."}
{"question": "Wie kann man die Komposition in objektorientierten Programmiersprachen umsetzen?", "paragraph": "Die meisten (objektorientierten) Programmiersprachen bieten leider \u00fcberhaupt kein Sprachkonstrukt an, das speziell f\u00fcr die Teil-Ganzes-Beziehung gedacht w\u00e4re. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden: Da bei Wertsemantik mit der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt werden, kann man hier tats\u00e4chlich von der Umsetzung einer bestimmten Form von Teil- Ganzes-Beziehung sprechen, n\u00e4mlich einer solchen, bei der die Existenz der Teile von der Existenz des Ganzen abh\u00e4ngt (in der UML auch Komposition genannt). ", "answer": "leider \u00fcberhaupt kein Sprachkonstrukt", "sentence": "Die meisten (objektorientierten) Programmiersprachen bieten leider \u00fcberhaupt kein Sprachkonstrukt an, das speziell f\u00fcr die Teil-Ganzes-Beziehung gedacht w\u00e4re. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden", "paragraph_sentence": "<hl> Die meisten (objektorientierten) Programmiersprachen bieten leider \u00fcberhaupt kein Sprachkonstrukt an, das speziell f\u00fcr die Teil-Ganzes-Beziehung gedacht w\u00e4re. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden <hl>: Da bei Wertsemantik mit der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt werden, kann man hier tats\u00e4chlich von der Umsetzung einer bestimmten Form von Teil- Ganzes-Beziehung sprechen, n\u00e4mlich einer solchen, bei der die Existenz der Teile von der Existenz des Ganzen abh\u00e4ngt (in der UML auch Komposition genannt). ", "paragraph_answer": "Die meisten (objektorientierten) Programmiersprachen bieten <hl> leider \u00fcberhaupt kein Sprachkonstrukt <hl> an, das speziell f\u00fcr die Teil-Ganzes-Beziehung gedacht w\u00e4re. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden: Da bei Wertsemantik mit der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt werden, kann man hier tats\u00e4chlich von der Umsetzung einer bestimmten Form von Teil- Ganzes-Beziehung sprechen, n\u00e4mlich einer solchen, bei der die Existenz der Teile von der Existenz des Ganzen abh\u00e4ngt (in der UML auch Komposition genannt). ", "sentence_answer": "Die meisten (objektorientierten) Programmiersprachen bieten <hl> leider \u00fcberhaupt kein Sprachkonstrukt <hl> an, das speziell f\u00fcr die Teil-Ganzes-Beziehung gedacht w\u00e4re. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden"}
{"question": "Was macht den Zustand eines Objektes aus?", "paragraph": "Der Zustand eines Objektes ist die Summe der Belegungen seiner Instanzvariablen - er wird ausschlie\u00dflich durch die Verkn\u00fcpfung mit anderen Objekten definiert. Es folgt, dass die einzige M\u00f6glichkeit, den Zustand eines Objekts zu \u00e4ndern, der \u00fcber die Zuweisung von Instanzvariablen ist. ", "answer": "Summe der Belegungen seiner Instanzvariablen", "sentence": "Der Zustand eines Objektes ist die Summe der Belegungen seiner Instanzvariablen - er wird ausschlie\u00dflich durch die Verkn\u00fcpfung mit anderen Objekten definiert.", "paragraph_sentence": "<hl> Der Zustand eines Objektes ist die Summe der Belegungen seiner Instanzvariablen - er wird ausschlie\u00dflich durch die Verkn\u00fcpfung mit anderen Objekten definiert. <hl> Es folgt, dass die einzige M\u00f6glichkeit, den Zustand eines Objekts zu \u00e4ndern, der \u00fcber die Zuweisung von Instanzvariablen ist. ", "paragraph_answer": "Der Zustand eines Objektes ist die <hl> Summe der Belegungen seiner Instanzvariablen <hl> - er wird ausschlie\u00dflich durch die Verkn\u00fcpfung mit anderen Objekten definiert. Es folgt, dass die einzige M\u00f6glichkeit, den Zustand eines Objekts zu \u00e4ndern, der \u00fcber die Zuweisung von Instanzvariablen ist. ", "sentence_answer": "Der Zustand eines Objektes ist die <hl> Summe der Belegungen seiner Instanzvariablen <hl> - er wird ausschlie\u00dflich durch die Verkn\u00fcpfung mit anderen Objekten definiert."}
{"question": "Wie Ver\u00e4ndert man den Zustand eines Objektes?", "paragraph": "Der Zustand eines Objektes ist die Summe der Belegungen seiner Instanzvariablen - er wird ausschlie\u00dflich durch die Verkn\u00fcpfung mit anderen Objekten definiert. Es folgt, dass die einzige M\u00f6glichkeit, den Zustand eines Objekts zu \u00e4ndern, der \u00fcber die Zuweisung von Instanzvariablen ist. ", "answer": "\u00fcber die Zuweisung von Instanzvariablen ", "sentence": "Es folgt, dass die einzige M\u00f6glichkeit, den Zustand eines Objekts zu \u00e4ndern, der \u00fcber die Zuweisung von Instanzvariablen ist.", "paragraph_sentence": "Der Zustand eines Objektes ist die Summe der Belegungen seiner Instanzvariablen - er wird ausschlie\u00dflich durch die Verkn\u00fcpfung mit anderen Objekten definiert. <hl> Es folgt, dass die einzige M\u00f6glichkeit, den Zustand eines Objekts zu \u00e4ndern, der \u00fcber die Zuweisung von Instanzvariablen ist. <hl> ", "paragraph_answer": "Der Zustand eines Objektes ist die Summe der Belegungen seiner Instanzvariablen - er wird ausschlie\u00dflich durch die Verkn\u00fcpfung mit anderen Objekten definiert. Es folgt, dass die einzige M\u00f6glichkeit, den Zustand eines Objekts zu \u00e4ndern, der <hl> \u00fcber die Zuweisung von Instanzvariablen <hl>ist. ", "sentence_answer": "Es folgt, dass die einzige M\u00f6glichkeit, den Zustand eines Objekts zu \u00e4ndern, der <hl> \u00fcber die Zuweisung von Instanzvariablen <hl>ist."}
{"question": "Welche beiden Formen von Ausdr\u00fccken sind wichtige Ausdrucksformen f\u00fcr die objektorientierte Programmierung?", "paragraph": "Die Zuweisungen und die Nachrichtenausdr\u00fccke sind wichtig. \nZuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten. \nDie Nachrichtenausdr\u00fccke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern. \nNachrichtenausdr\u00fccke werden ausgewertet, in dem die Nachricht an das Empf\u00e4ngerobjekt mit den Parametern gesendet und das Empf\u00e4ngerobjekt als Ergebnis der Nachricht ein Objekt zur\u00fcckliefert.", "answer": "Die Zuweisungen und die Nachrichtenausdr\u00fccke", "sentence": "Die Zuweisungen und die Nachrichtenausdr\u00fccke sind wichtig.", "paragraph_sentence": "<hl> Die Zuweisungen und die Nachrichtenausdr\u00fccke sind wichtig. <hl> Zuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten. Die Nachrichtenausdr\u00fccke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern. Nachrichtenausdr\u00fccke werden ausgewertet, in dem die Nachricht an das Empf\u00e4ngerobjekt mit den Parametern gesendet und das Empf\u00e4ngerobjekt als Ergebnis der Nachricht ein Objekt zur\u00fcckliefert.", "paragraph_answer": "<hl> Die Zuweisungen und die Nachrichtenausdr\u00fccke <hl> sind wichtig. Zuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten. Die Nachrichtenausdr\u00fccke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern. Nachrichtenausdr\u00fccke werden ausgewertet, in dem die Nachricht an das Empf\u00e4ngerobjekt mit den Parametern gesendet und das Empf\u00e4ngerobjekt als Ergebnis der Nachricht ein Objekt zur\u00fcckliefert.", "sentence_answer": "<hl> Die Zuweisungen und die Nachrichtenausdr\u00fccke <hl> sind wichtig."}
{"question": "Warum sind  Zuweisungen wichtige Ausdrucksformen?", "paragraph": "Die Zuweisungen und die Nachrichtenausdr\u00fccke sind wichtig. \nZuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten. \nDie Nachrichtenausdr\u00fccke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern. \nNachrichtenausdr\u00fccke werden ausgewertet, in dem die Nachricht an das Empf\u00e4ngerobjekt mit den Parametern gesendet und das Empf\u00e4ngerobjekt als Ergebnis der Nachricht ein Objekt zur\u00fcckliefert.", "answer": "Zuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten", "sentence": "Zuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten.", "paragraph_sentence": "Die Zuweisungen und die Nachrichtenausdr\u00fccke sind wichtig. <hl> Zuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten. <hl> Die Nachrichtenausdr\u00fccke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern. Nachrichtenausdr\u00fccke werden ausgewertet, in dem die Nachricht an das Empf\u00e4ngerobjekt mit den Parametern gesendet und das Empf\u00e4ngerobjekt als Ergebnis der Nachricht ein Objekt zur\u00fcckliefert.", "paragraph_answer": "Die Zuweisungen und die Nachrichtenausdr\u00fccke sind wichtig. <hl> Zuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten <hl>. Die Nachrichtenausdr\u00fccke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern. Nachrichtenausdr\u00fccke werden ausgewertet, in dem die Nachricht an das Empf\u00e4ngerobjekt mit den Parametern gesendet und das Empf\u00e4ngerobjekt als Ergebnis der Nachricht ein Objekt zur\u00fcckliefert.", "sentence_answer": "<hl> Zuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten <hl>."}
{"question": "Warum sind  Nachrichtenausdr\u00fccke wichtige Ausdrucksformen?", "paragraph": "Die Zuweisungen und die Nachrichtenausdr\u00fccke sind wichtig. \nZuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten. \nDie Nachrichtenausdr\u00fccke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern. \nNachrichtenausdr\u00fccke werden ausgewertet, in dem die Nachricht an das Empf\u00e4ngerobjekt mit den Parametern gesendet und das Empf\u00e4ngerobjekt als Ergebnis der Nachricht ein Objekt zur\u00fcckliefert.", "answer": "Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern", "sentence": "Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern.", "paragraph_sentence": "Die Zuweisungen und die Nachrichtenausdr\u00fccke sind wichtig. Zuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten. Die Nachrichtenausdr\u00fccke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: <hl> Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern. <hl> Nachrichtenausdr\u00fccke werden ausgewertet, in dem die Nachricht an das Empf\u00e4ngerobjekt mit den Parametern gesendet und das Empf\u00e4ngerobjekt als Ergebnis der Nachricht ein Objekt zur\u00fcckliefert.", "paragraph_answer": "Die Zuweisungen und die Nachrichtenausdr\u00fccke sind wichtig. Zuweisungen bewirken als einzige Ausdr\u00fccke den Zustandswechsel von Objekten. Die Nachrichtenausdr\u00fccke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt <hl> Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern <hl>. Nachrichtenausdr\u00fccke werden ausgewertet, in dem die Nachricht an das Empf\u00e4ngerobjekt mit den Parametern gesendet und das Empf\u00e4ngerobjekt als Ergebnis der Nachricht ein Objekt zur\u00fcckliefert.", "sentence_answer": "Es gibt <hl> Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand \u00e4ndern <hl>."}
{"question": "Was beschreiben Methodendefinitionen? ", "paragraph": "Methodendefinitionen beschreiben, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll. ", "answer": "was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll", "sentence": "Methodendefinitionen beschreiben, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll.", "paragraph_sentence": "<hl> Methodendefinitionen beschreiben, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll. <hl> ", "paragraph_answer": "Methodendefinitionen beschreiben, <hl> was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll <hl>. ", "sentence_answer": "Methodendefinitionen beschreiben, <hl> was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll <hl>."}
{"question": "Wie funktioniert das Versenden von Nachrichten in SMALLTALK? ", "paragraph": "Aus Effzienzgr\u00fcnden wird in SMALLTALK ein Nachrichtenausdruck in einen Methodenaufruf \u00fcbersetzt. Wann immer ein Objekt eine Nachricht an ein Empf\u00e4ngerobjekt verschickt, wechselt der Kontrollfluss damit zum Empf\u00e4ngerobjekt, genauer zu der Methode des Empf\u00e4ngerobjekts, das zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung der Methode kehrt der Kontrollfluss an das sendende Objekt (genauer: zu der Methode, aus der die Nachricht versandt wurde) zur\u00fcck und setzt seine Arbeit dort fort. Bei der R\u00fcckkehr wird auch das Ergebnis der Methode, (eine Referenz auf) ein Objekt, geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. \nEs gibt aber auch die Variante mittels perform:.In SMALLTALK sind auch Nachrichten Objekte. Um tats\u00e4chlich als Nachrichtenobjekt an ein Objekt verschickt zu werden, muss man sich eines speziellen Methodenaufrufs, perform:, bedienen, der es erlaubt, einem Empf\u00e4ngerobjekt eine Nachricht als Objekt (wenn auch nur als Parameter von perform:) zu senden. Das Empf\u00e4ngerobjekt reagiert darauf mit der Abarbeitung der zur Nachricht passenden Methode ganz so, als h\u00e4tte es direkt einen entsprechenden Methodenaufruf erhalten.", "answer": "ein Nachrichtenausdruck in einen Methodenaufruf \u00fcbersetzt", "sentence": "Aus Effzienzgr\u00fcnden wird in SMALLTALK ein Nachrichtenausdruck in einen Methodenaufruf \u00fcbersetzt. Wann immer ein Objekt eine Nachricht an ein Empf\u00e4ngerobjekt verschickt, wechselt der Kontrollfluss damit zum Empf\u00e4ngerobjekt, genauer zu der Methode des Empf\u00e4ngerobjekts, das zur Reaktion auf die Nachricht vorgesehen ist.", "paragraph_sentence": "<hl> Aus Effzienzgr\u00fcnden wird in SMALLTALK ein Nachrichtenausdruck in einen Methodenaufruf \u00fcbersetzt. Wann immer ein Objekt eine Nachricht an ein Empf\u00e4ngerobjekt verschickt, wechselt der Kontrollfluss damit zum Empf\u00e4ngerobjekt, genauer zu der Methode des Empf\u00e4ngerobjekts, das zur Reaktion auf die Nachricht vorgesehen ist. <hl> Nach der Abarbeitung der Methode kehrt der Kontrollfluss an das sendende Objekt (genauer: zu der Methode, aus der die Nachricht versandt wurde) zur\u00fcck und setzt seine Arbeit dort fort. Bei der R\u00fcckkehr wird auch das Ergebnis der Methode, (eine Referenz auf) ein Objekt, geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Es gibt aber auch die Variante mittels perform:.In SMALLTALK sind auch Nachrichten Objekte. Um tats\u00e4chlich als Nachrichtenobjekt an ein Objekt verschickt zu werden, muss man sich eines speziellen Methodenaufrufs, perform:, bedienen, der es erlaubt, einem Empf\u00e4ngerobjekt eine Nachricht als Objekt (wenn auch nur als Parameter von perform:) zu senden. Das Empf\u00e4ngerobjekt reagiert darauf mit der Abarbeitung der zur Nachricht passenden Methode ganz so, als h\u00e4tte es direkt einen entsprechenden Methodenaufruf erhalten.", "paragraph_answer": "Aus Effzienzgr\u00fcnden wird in SMALLTALK <hl> ein Nachrichtenausdruck in einen Methodenaufruf \u00fcbersetzt <hl>. Wann immer ein Objekt eine Nachricht an ein Empf\u00e4ngerobjekt verschickt, wechselt der Kontrollfluss damit zum Empf\u00e4ngerobjekt, genauer zu der Methode des Empf\u00e4ngerobjekts, das zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung der Methode kehrt der Kontrollfluss an das sendende Objekt (genauer: zu der Methode, aus der die Nachricht versandt wurde) zur\u00fcck und setzt seine Arbeit dort fort. Bei der R\u00fcckkehr wird auch das Ergebnis der Methode, (eine Referenz auf) ein Objekt, geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Es gibt aber auch die Variante mittels perform:.In SMALLTALK sind auch Nachrichten Objekte. Um tats\u00e4chlich als Nachrichtenobjekt an ein Objekt verschickt zu werden, muss man sich eines speziellen Methodenaufrufs, perform:, bedienen, der es erlaubt, einem Empf\u00e4ngerobjekt eine Nachricht als Objekt (wenn auch nur als Parameter von perform:) zu senden. Das Empf\u00e4ngerobjekt reagiert darauf mit der Abarbeitung der zur Nachricht passenden Methode ganz so, als h\u00e4tte es direkt einen entsprechenden Methodenaufruf erhalten.", "sentence_answer": "Aus Effzienzgr\u00fcnden wird in SMALLTALK <hl> ein Nachrichtenausdruck in einen Methodenaufruf \u00fcbersetzt <hl>. Wann immer ein Objekt eine Nachricht an ein Empf\u00e4ngerobjekt verschickt, wechselt der Kontrollfluss damit zum Empf\u00e4ngerobjekt, genauer zu der Methode des Empf\u00e4ngerobjekts, das zur Reaktion auf die Nachricht vorgesehen ist."}
{"question": "Was ist der Unterschied von Methodenaufrufen in der objektorientierten Programmierung zum gew\u00f6hnlichen Prozeduraufruf", "paragraph": "Methodenaufrufe in der objektorientierten Programmierung werden oft mit Funktionsaufrufen in der prozeduralen Programmierung verglichen. Der Unterschied besteht in der Abh\u00e4ngigkeit vom Empf\u00e4ngerobjekt: Die Entscheidung, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, h\u00e4ngt nicht von dem Nachrichtenselektor allein ab, sondern auch von dem Objekt, an das die Nachricht geschickt wird. Es ist n\u00e4mlich durchaus \u00fcblich, dass verschiedene Objekte mit gleichen Methodensignaturen unterschiedliche Methodenimplementierungen verbinden; so implementieren beispielsweise Zahlen und Symbole die Methode printString jeweils anders. \nAus der Abh\u00e4ngigkeit des Methodenaufrufs vom Empf\u00e4ngerobjekt folgt, dass nicht immer schon zur \u00fcbersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgew\u00e4hlt werden muss. Wenn n\u00e4mlich das Empf\u00e4ngerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird, kann die Zuordnung einer Methodendefinition zu einem Nachrichtenausdruck erst zum Zeitpunkt der Auswertung des Nachrichtenausdrucks und damit erst zur Laufzeit erfolgen (dynamisches Binden).", "answer": "Abh\u00e4ngigkeit vom Empf\u00e4ngerobjekt", "sentence": "Der Unterschied besteht in der Abh\u00e4ngigkeit vom Empf\u00e4ngerobjekt: Die Entscheidung, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, h\u00e4ngt nicht von dem Nachrichtenselektor allein ab, sondern auch von dem Objekt, an das die Nachricht geschickt wird.", "paragraph_sentence": "Methodenaufrufe in der objektorientierten Programmierung werden oft mit Funktionsaufrufen in der prozeduralen Programmierung verglichen. <hl> Der Unterschied besteht in der Abh\u00e4ngigkeit vom Empf\u00e4ngerobjekt: Die Entscheidung, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, h\u00e4ngt nicht von dem Nachrichtenselektor allein ab, sondern auch von dem Objekt, an das die Nachricht geschickt wird. <hl> Es ist n\u00e4mlich durchaus \u00fcblich, dass verschiedene Objekte mit gleichen Methodensignaturen unterschiedliche Methodenimplementierungen verbinden; so implementieren beispielsweise Zahlen und Symbole die Methode printString jeweils anders. Aus der Abh\u00e4ngigkeit des Methodenaufrufs vom Empf\u00e4ngerobjekt folgt, dass nicht immer schon zur \u00fcbersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgew\u00e4hlt werden muss. Wenn n\u00e4mlich das Empf\u00e4ngerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird, kann die Zuordnung einer Methodendefinition zu einem Nachrichtenausdruck erst zum Zeitpunkt der Auswertung des Nachrichtenausdrucks und damit erst zur Laufzeit erfolgen (dynamisches Binden).", "paragraph_answer": "Methodenaufrufe in der objektorientierten Programmierung werden oft mit Funktionsaufrufen in der prozeduralen Programmierung verglichen. Der Unterschied besteht in der <hl> Abh\u00e4ngigkeit vom Empf\u00e4ngerobjekt <hl>: Die Entscheidung, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, h\u00e4ngt nicht von dem Nachrichtenselektor allein ab, sondern auch von dem Objekt, an das die Nachricht geschickt wird. Es ist n\u00e4mlich durchaus \u00fcblich, dass verschiedene Objekte mit gleichen Methodensignaturen unterschiedliche Methodenimplementierungen verbinden; so implementieren beispielsweise Zahlen und Symbole die Methode printString jeweils anders. Aus der Abh\u00e4ngigkeit des Methodenaufrufs vom Empf\u00e4ngerobjekt folgt, dass nicht immer schon zur \u00fcbersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgew\u00e4hlt werden muss. Wenn n\u00e4mlich das Empf\u00e4ngerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird, kann die Zuordnung einer Methodendefinition zu einem Nachrichtenausdruck erst zum Zeitpunkt der Auswertung des Nachrichtenausdrucks und damit erst zur Laufzeit erfolgen (dynamisches Binden).", "sentence_answer": "Der Unterschied besteht in der <hl> Abh\u00e4ngigkeit vom Empf\u00e4ngerobjekt <hl>: Die Entscheidung, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, h\u00e4ngt nicht von dem Nachrichtenselektor allein ab, sondern auch von dem Objekt, an das die Nachricht geschickt wird."}
{"question": "Was unterscheidet die klassenbasierte von der prototypenbasierten Form der objektorientierten Programmierung?", "paragraph": "Es ist bei der klassenbasierten Form nicht vorgesehen, dass verschiedene Instanzen einer Klasse \u00fcber verschiedene Definitionen einer Methode (genauer: \u00fcber verschiedene Definitionen von zu der Nachricht passenden Methoden) verf\u00fcgen. \nDie prototypenbasierte Form der Objektorientierung kann sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen, z.B. indem sie eine Methodendefinition nur f\u00fcr ein einziges Objekt abzu\u00e4ndern erlaubt. Letzteres ist z.B. bei der Programmierung von grafschen Bedienoberfl\u00e4chen, bei der das Dr\u00fccken verschiedener Buttons jeweils verschiedene Ereignisse ausl\u00f6st (Methoden aufruft), sehr praktisch. ", "answer": "verschiedene Instanzen einer Klasse \u00fcber verschiedene Definitionen einer Methode", "sentence": "Es ist bei der klassenbasierten Form nicht vorgesehen, dass verschiedene Instanzen einer Klasse \u00fcber verschiedene Definitionen einer Methode (genauer: \u00fcber verschiedene Definitionen von zu der Nachricht passenden Methoden) verf\u00fcgen.", "paragraph_sentence": "<hl> Es ist bei der klassenbasierten Form nicht vorgesehen, dass verschiedene Instanzen einer Klasse \u00fcber verschiedene Definitionen einer Methode (genauer: \u00fcber verschiedene Definitionen von zu der Nachricht passenden Methoden) verf\u00fcgen. <hl> Die prototypenbasierte Form der Objektorientierung kann sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen, z.B. indem sie eine Methodendefinition nur f\u00fcr ein einziges Objekt abzu\u00e4ndern erlaubt. Letzteres ist z.B. bei der Programmierung von grafschen Bedienoberfl\u00e4chen, bei der das Dr\u00fccken verschiedener Buttons jeweils verschiedene Ereignisse ausl\u00f6st (Methoden aufruft), sehr praktisch. ", "paragraph_answer": "Es ist bei der klassenbasierten Form nicht vorgesehen, dass <hl> verschiedene Instanzen einer Klasse \u00fcber verschiedene Definitionen einer Methode <hl> (genauer: \u00fcber verschiedene Definitionen von zu der Nachricht passenden Methoden) verf\u00fcgen. Die prototypenbasierte Form der Objektorientierung kann sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen, z.B. indem sie eine Methodendefinition nur f\u00fcr ein einziges Objekt abzu\u00e4ndern erlaubt. Letzteres ist z.B. bei der Programmierung von grafschen Bedienoberfl\u00e4chen, bei der das Dr\u00fccken verschiedener Buttons jeweils verschiedene Ereignisse ausl\u00f6st (Methoden aufruft), sehr praktisch. ", "sentence_answer": "Es ist bei der klassenbasierten Form nicht vorgesehen, dass <hl> verschiedene Instanzen einer Klasse \u00fcber verschiedene Definitionen einer Methode <hl> (genauer: \u00fcber verschiedene Definitionen von zu der Nachricht passenden Methoden) verf\u00fcgen."}
{"question": "Warum ist es sinnvoll, dass zu jeder Klasse des SMALLTALK-Systems genau eine Metaklasse geh\u00f6rt?", "paragraph": "Die Programmierpraxis hat gezeigt, dass es g\u00fcnstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu m\u00fcssen. Um dies zu erm\u00f6glichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur f\u00fcr sie angelegt werden k\u00f6nnen. Und genau das ist in SMALLTALK der Fall. \nZu jeder Klasse des SMALLTALK-Systems geh\u00f6rt n\u00e4mlich genau eine Klasse, von der erstere (und nur diese) eine Instanz ist. Diese zweite Klasse wird Metaklasse der ersten genannt.", "answer": "g\u00fcnstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann", "sentence": "Die Programmierpraxis hat gezeigt, dass es g\u00fcnstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu m\u00fcssen.", "paragraph_sentence": "<hl> Die Programmierpraxis hat gezeigt, dass es g\u00fcnstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu m\u00fcssen. <hl> Um dies zu erm\u00f6glichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur f\u00fcr sie angelegt werden k\u00f6nnen. Und genau das ist in SMALLTALK der Fall. Zu jeder Klasse des SMALLTALK-Systems geh\u00f6rt n\u00e4mlich genau eine Klasse, von der erstere (und nur diese) eine Instanz ist. Diese zweite Klasse wird Metaklasse der ersten genannt.", "paragraph_answer": "Die Programmierpraxis hat gezeigt, dass es <hl> g\u00fcnstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann <hl>, ohne dabei gleichzeitig an andere Klassen denken zu m\u00fcssen. Um dies zu erm\u00f6glichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur f\u00fcr sie angelegt werden k\u00f6nnen. Und genau das ist in SMALLTALK der Fall. Zu jeder Klasse des SMALLTALK-Systems geh\u00f6rt n\u00e4mlich genau eine Klasse, von der erstere (und nur diese) eine Instanz ist. Diese zweite Klasse wird Metaklasse der ersten genannt.", "sentence_answer": "Die Programmierpraxis hat gezeigt, dass es <hl> g\u00fcnstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann <hl>, ohne dabei gleichzeitig an andere Klassen denken zu m\u00fcssen."}
{"question": "Was ist ein Konstruktor?", "paragraph": "Ein Konstruktor ist eine Methode, die, auf einer Klasse aufgerufen, eine neue Instanz dieser Klasse zur\u00fcckgibt (es handelt sich also aus Sicht der erzeugten Instanz um eine Klassenmethode). ", "answer": "eine Methode, die, auf einer Klasse aufgerufen, eine neue Instanz dieser Klasse zur\u00fcckgibt", "sentence": "Ein Konstruktor ist eine Methode, die, auf einer Klasse aufgerufen, eine neue Instanz dieser Klasse zur\u00fcckgibt (es handelt sich also aus Sicht der erzeugten Instanz um eine Klassenmethode). ", "paragraph_sentence": "<hl> Ein Konstruktor ist eine Methode, die, auf einer Klasse aufgerufen, eine neue Instanz dieser Klasse zur\u00fcckgibt (es handelt sich also aus Sicht der erzeugten Instanz um eine Klassenmethode). <hl>", "paragraph_answer": "Ein Konstruktor ist <hl> eine Methode, die, auf einer Klasse aufgerufen, eine neue Instanz dieser Klasse zur\u00fcckgibt <hl> (es handelt sich also aus Sicht der erzeugten Instanz um eine Klassenmethode). ", "sentence_answer": "Ein Konstruktor ist <hl> eine Methode, die, auf einer Klasse aufgerufen, eine neue Instanz dieser Klasse zur\u00fcckgibt <hl> (es handelt sich also aus Sicht der erzeugten Instanz um eine Klassenmethode). "}
{"question": "Was sind Factory-Methoden?", "paragraph": "Eine Factory-Methode ist eine Methode, die wie ein Konstruktor eine neue Instanz liefert, die aber die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode geh\u00f6rt, abh\u00e4ngig macht. Zum Beispiel k\u00f6nnte eine Klasse Number eine (Klassen-)Methode fromString: vorsehen, die anhand eines zu analysierenden Strings entweder eine Instanz der Klasse Integer oder eine der Klasse Float zur\u00fcckgibt. \nDa in SMALLTALK Konstruktoren ganz normale Klassenmethoden sind, sind sie an keine besonderen Konventionen gebunden. Sie m\u00fcssen also insbesondere nicht ein neues Objekt genau der Klasse, der sie angeh\u00f6ren, zur\u00fcckgeben. Die Factory-Methoden sind dann solche Klassenmethoden. ", "answer": "eine Methode, die wie ein Konstruktor eine neue Instanz liefert, die aber die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode geh\u00f6rt, abh\u00e4ngig macht", "sentence": "Eine Factory-Methode ist eine Methode, die wie ein Konstruktor eine neue Instanz liefert, die aber die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode geh\u00f6rt, abh\u00e4ngig macht.", "paragraph_sentence": "<hl> Eine Factory-Methode ist eine Methode, die wie ein Konstruktor eine neue Instanz liefert, die aber die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode geh\u00f6rt, abh\u00e4ngig macht. <hl> Zum Beispiel k\u00f6nnte eine Klasse Number eine (Klassen-)Methode fromString: vorsehen, die anhand eines zu analysierenden Strings entweder eine Instanz der Klasse Integer oder eine der Klasse Float zur\u00fcckgibt. Da in SMALLTALK Konstruktoren ganz normale Klassenmethoden sind, sind sie an keine besonderen Konventionen gebunden. Sie m\u00fcssen also insbesondere nicht ein neues Objekt genau der Klasse, der sie angeh\u00f6ren, zur\u00fcckgeben. Die Factory-Methoden sind dann solche Klassenmethoden. ", "paragraph_answer": "Eine Factory-Methode ist <hl> eine Methode, die wie ein Konstruktor eine neue Instanz liefert, die aber die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode geh\u00f6rt, abh\u00e4ngig macht <hl>. Zum Beispiel k\u00f6nnte eine Klasse Number eine (Klassen-)Methode fromString: vorsehen, die anhand eines zu analysierenden Strings entweder eine Instanz der Klasse Integer oder eine der Klasse Float zur\u00fcckgibt. Da in SMALLTALK Konstruktoren ganz normale Klassenmethoden sind, sind sie an keine besonderen Konventionen gebunden. Sie m\u00fcssen also insbesondere nicht ein neues Objekt genau der Klasse, der sie angeh\u00f6ren, zur\u00fcckgeben. Die Factory-Methoden sind dann solche Klassenmethoden. ", "sentence_answer": "Eine Factory-Methode ist <hl> eine Methode, die wie ein Konstruktor eine neue Instanz liefert, die aber die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode geh\u00f6rt, abh\u00e4ngig macht <hl>."}
{"question": "Was geschieht bei der Generalisierung/Spezialisierung?", "paragraph": "W\u00e4hrend die Generalisierung Eigenschaften wegl\u00e4sst oder generalisiert (Abstraktion), f\u00fcgt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene.", "answer": "die Generalisierung Eigenschaften wegl\u00e4sst oder generalisiert (Abstraktion), f\u00fcgt die Spezialisierung Eigenschaften hinzu oder spezialisiert", "sentence": "W\u00e4hrend die Generalisierung Eigenschaften wegl\u00e4sst oder generalisiert (Abstraktion), f\u00fcgt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene.", "paragraph_sentence": "<hl> W\u00e4hrend die Generalisierung Eigenschaften wegl\u00e4sst oder generalisiert (Abstraktion), f\u00fcgt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene. <hl>", "paragraph_answer": "W\u00e4hrend <hl> die Generalisierung Eigenschaften wegl\u00e4sst oder generalisiert (Abstraktion), f\u00fcgt die Spezialisierung Eigenschaften hinzu oder spezialisiert <hl> bereits vorhandene.", "sentence_answer": "W\u00e4hrend <hl> die Generalisierung Eigenschaften wegl\u00e4sst oder generalisiert (Abstraktion), f\u00fcgt die Spezialisierung Eigenschaften hinzu oder spezialisiert <hl> bereits vorhandene."}
{"question": "Was versteht man in der objektorientierten Programmierung unter Vererbung?", "paragraph": "Unter Vererbung versteht man in der objektorientierten Programmierung die \u00fcbertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere. Vererbung dient vor allem der Wiederverwendung von Code und damit der \u00f6konomie in der Softwareentwicklung.", "answer": "die \u00fcbertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere", "sentence": "Unter Vererbung versteht man in der objektorientierten Programmierung die \u00fcbertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere.", "paragraph_sentence": "<hl> Unter Vererbung versteht man in der objektorientierten Programmierung die \u00fcbertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere. <hl> Vererbung dient vor allem der Wiederverwendung von Code und damit der \u00f6konomie in der Softwareentwicklung.", "paragraph_answer": "Unter Vererbung versteht man in der objektorientierten Programmierung <hl> die \u00fcbertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere <hl>. Vererbung dient vor allem der Wiederverwendung von Code und damit der \u00f6konomie in der Softwareentwicklung.", "sentence_answer": "Unter Vererbung versteht man in der objektorientierten Programmierung <hl> die \u00fcbertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere <hl>."}
{"question": "Wie h\u00e4ngen Generalisierung/Spezialisierung und Vererbung zusammen?", "paragraph": "Wenn man das Prinzip von Generalisierung und Spezialisierung vor Augen hat, dann ist die Vererbung eigentlich nur noch ein Mechanismus, der Definitionen von einer Klasse auf eine andere \u00fcbertr\u00e4gt. So wird jede benannte Instanzvariable, die in einer Generalisierung deklariert ist, nicht nur f\u00fcr Instanzen dieser Generalisierung (so sie denn welche hat) angelegt, sondern auch f\u00fcr die Instanzen all ihrer Spezialisierungen. Analog stehen Methoden, die in einer Generalisierung definiert werden, auch ihren Spezialisierungen zur Verf\u00fcgung, und zwar beinahe so, als w\u00e4ren sie in den Spezialisierungen definiert. Verwendet man Vererbung zur Ausnutzung von \u00e4hnlichkeiten, so ist nicht sichergestellt, dass auch eine Spezialisierungs- bzw. Generalisierungsbeziehung besteht.", "answer": "Vererbung zur Ausnutzung von \u00e4hnlichkeiten, so ist nicht sichergestellt, dass auch eine Spezialisierungs- bzw. Generalisierungsbeziehung besteht", "sentence": "Verwendet man Vererbung zur Ausnutzung von \u00e4hnlichkeiten, so ist nicht sichergestellt, dass auch eine Spezialisierungs- bzw. Generalisierungsbeziehung besteht.", "paragraph_sentence": "Wenn man das Prinzip von Generalisierung und Spezialisierung vor Augen hat, dann ist die Vererbung eigentlich nur noch ein Mechanismus, der Definitionen von einer Klasse auf eine andere \u00fcbertr\u00e4gt. So wird jede benannte Instanzvariable, die in einer Generalisierung deklariert ist, nicht nur f\u00fcr Instanzen dieser Generalisierung (so sie denn welche hat) angelegt, sondern auch f\u00fcr die Instanzen all ihrer Spezialisierungen. Analog stehen Methoden, die in einer Generalisierung definiert werden, auch ihren Spezialisierungen zur Verf\u00fcgung, und zwar beinahe so, als w\u00e4ren sie in den Spezialisierungen definiert. <hl> Verwendet man Vererbung zur Ausnutzung von \u00e4hnlichkeiten, so ist nicht sichergestellt, dass auch eine Spezialisierungs- bzw. Generalisierungsbeziehung besteht. <hl>", "paragraph_answer": "Wenn man das Prinzip von Generalisierung und Spezialisierung vor Augen hat, dann ist die Vererbung eigentlich nur noch ein Mechanismus, der Definitionen von einer Klasse auf eine andere \u00fcbertr\u00e4gt. So wird jede benannte Instanzvariable, die in einer Generalisierung deklariert ist, nicht nur f\u00fcr Instanzen dieser Generalisierung (so sie denn welche hat) angelegt, sondern auch f\u00fcr die Instanzen all ihrer Spezialisierungen. Analog stehen Methoden, die in einer Generalisierung definiert werden, auch ihren Spezialisierungen zur Verf\u00fcgung, und zwar beinahe so, als w\u00e4ren sie in den Spezialisierungen definiert. Verwendet man <hl> Vererbung zur Ausnutzung von \u00e4hnlichkeiten, so ist nicht sichergestellt, dass auch eine Spezialisierungs- bzw. Generalisierungsbeziehung besteht <hl>.", "sentence_answer": "Verwendet man <hl> Vererbung zur Ausnutzung von \u00e4hnlichkeiten, so ist nicht sichergestellt, dass auch eine Spezialisierungs- bzw. Generalisierungsbeziehung besteht <hl>."}
{"question": "Was versteht man unter offener Rekursion?", "paragraph": "Der Aufruf einer abstrakten, d. h. in der Klasse nicht implementierten Methode aus der Klasse selbst heraus ist ein g\u00e4ngiges Muster der objektorientierten Programmierung. Man nennt es auch offene Rekursion, da der Aufruf auf dem Objekt selbst erfolgt (also gewisserma\u00dfen rekursiv ist), aber an der aufrufenden Stelle noch nicht klar (offen) ist, welche (erbende) Klasse die Implementierung liefert.", "answer": "Aufruf auf dem Objekt selbst", "sentence": "Man nennt es auch offene Rekursion, da der Aufruf auf dem Objekt selbst erfolgt (also gewisserma\u00dfen rekursiv ist), aber an der aufrufenden Stelle noch nicht klar (offen) ist, welche (erbende) Klasse die Implementierung liefert.", "paragraph_sentence": "Der Aufruf einer abstrakten, d. h. in der Klasse nicht implementierten Methode aus der Klasse selbst heraus ist ein g\u00e4ngiges Muster der objektorientierten Programmierung. <hl> Man nennt es auch offene Rekursion, da der Aufruf auf dem Objekt selbst erfolgt (also gewisserma\u00dfen rekursiv ist), aber an der aufrufenden Stelle noch nicht klar (offen) ist, welche (erbende) Klasse die Implementierung liefert. <hl>", "paragraph_answer": "Der Aufruf einer abstrakten, d. h. in der Klasse nicht implementierten Methode aus der Klasse selbst heraus ist ein g\u00e4ngiges Muster der objektorientierten Programmierung. Man nennt es auch offene Rekursion, da der <hl> Aufruf auf dem Objekt selbst <hl> erfolgt (also gewisserma\u00dfen rekursiv ist), aber an der aufrufenden Stelle noch nicht klar (offen) ist, welche (erbende) Klasse die Implementierung liefert.", "sentence_answer": "Man nennt es auch offene Rekursion, da der <hl> Aufruf auf dem Objekt selbst <hl> erfolgt (also gewisserma\u00dfen rekursiv ist), aber an der aufrufenden Stelle noch nicht klar (offen) ist, welche (erbende) Klasse die Implementierung liefert."}
{"question": "Wie geht (in SMALLTALK) das dynamische Binden von Methodenaufrufen vonstatten?", "paragraph": "Wenn eine Methode auf einem Empf\u00e4ngerobjekt aufgerufen wird, wird zun\u00e4chst gepr\u00fcft, ob die Methode im zur Klasse des Empf\u00e4ngers geh\u00f6renden Methodenw\u00f6rterbuch enthalten ist. Wird die Methode gefunden, dann wird sie ausgef\u00fchrt. Wird sie nicht gefunden, wird zun\u00e4chst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgef\u00fchrt. Wird die Methode auch in Object nicht gefunden, kommt es zum Versenden der Nachricht doesNotUnderstand: an den urspr\u00fcnglichen Empf\u00e4nger mit der urspr\u00fcnglichen, problematischen Nachricht als Argument.", "answer": "Sobald die Methode gefunden wird, wird sie ausgef\u00fchrt", "sentence": "Wenn eine Methode auf einem Empf\u00e4ngerobjekt aufgerufen wird, wird zun\u00e4chst gepr\u00fcft, ob die Methode im zur Klasse des Empf\u00e4ngers geh\u00f6renden Methodenw\u00f6rterbuch enthalten ist. Wird die Methode gefunden, dann wird sie ausgef\u00fchrt. Wird sie nicht gefunden, wird zun\u00e4chst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgef\u00fchrt.", "paragraph_sentence": "<hl> Wenn eine Methode auf einem Empf\u00e4ngerobjekt aufgerufen wird, wird zun\u00e4chst gepr\u00fcft, ob die Methode im zur Klasse des Empf\u00e4ngers geh\u00f6renden Methodenw\u00f6rterbuch enthalten ist. Wird die Methode gefunden, dann wird sie ausgef\u00fchrt. Wird sie nicht gefunden, wird zun\u00e4chst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgef\u00fchrt. <hl> Wird die Methode auch in Object nicht gefunden, kommt es zum Versenden der Nachricht doesNotUnderstand: an den urspr\u00fcnglichen Empf\u00e4nger mit der urspr\u00fcnglichen, problematischen Nachricht als Argument.", "paragraph_answer": "Wenn eine Methode auf einem Empf\u00e4ngerobjekt aufgerufen wird, wird zun\u00e4chst gepr\u00fcft, ob die Methode im zur Klasse des Empf\u00e4ngers geh\u00f6renden Methodenw\u00f6rterbuch enthalten ist. Wird die Methode gefunden, dann wird sie ausgef\u00fchrt. Wird sie nicht gefunden, wird zun\u00e4chst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. <hl> Sobald die Methode gefunden wird, wird sie ausgef\u00fchrt <hl>. Wird die Methode auch in Object nicht gefunden, kommt es zum Versenden der Nachricht doesNotUnderstand: an den urspr\u00fcnglichen Empf\u00e4nger mit der urspr\u00fcnglichen, problematischen Nachricht als Argument.", "sentence_answer": "Wenn eine Methode auf einem Empf\u00e4ngerobjekt aufgerufen wird, wird zun\u00e4chst gepr\u00fcft, ob die Methode im zur Klasse des Empf\u00e4ngers geh\u00f6renden Methodenw\u00f6rterbuch enthalten ist. Wird die Methode gefunden, dann wird sie ausgef\u00fchrt. Wird sie nicht gefunden, wird zun\u00e4chst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. <hl> Sobald die Methode gefunden wird, wird sie ausgef\u00fchrt <hl>."}
{"question": "Was versteht man unter aktiven Objekten?", "paragraph": "Unter aktiven Objekten w\u00fcrde man sich vorstellen, dass sie \u00fcber einen Prozess verf\u00fcgen, der nur die eigenen Methoden ausf\u00fchrt. Erh\u00e4lt ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte w\u00fcrde n\u00e4mlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspr\u00e4che). Aktive Objekte w\u00e4ren aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.", "answer": "dass sie \u00fcber einen Prozess verf\u00fcgen, der nur die eigenen Methoden ausf\u00fchrt", "sentence": "Unter aktiven Objekten w\u00fcrde man sich vorstellen, dass sie \u00fcber einen Prozess verf\u00fcgen, der nur die eigenen Methoden ausf\u00fchrt.", "paragraph_sentence": "<hl> Unter aktiven Objekten w\u00fcrde man sich vorstellen, dass sie \u00fcber einen Prozess verf\u00fcgen, der nur die eigenen Methoden ausf\u00fchrt. <hl> Erh\u00e4lt ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte w\u00fcrde n\u00e4mlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspr\u00e4che). Aktive Objekte w\u00e4ren aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.", "paragraph_answer": "Unter aktiven Objekten w\u00fcrde man sich vorstellen, <hl> dass sie \u00fcber einen Prozess verf\u00fcgen, der nur die eigenen Methoden ausf\u00fchrt <hl>. Erh\u00e4lt ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte w\u00fcrde n\u00e4mlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspr\u00e4che). Aktive Objekte w\u00e4ren aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.", "sentence_answer": "Unter aktiven Objekten w\u00fcrde man sich vorstellen, <hl> dass sie \u00fcber einen Prozess verf\u00fcgen, der nur die eigenen Methoden ausf\u00fchrt <hl>."}
{"question": "Wie kann man parallele Prozesse synchronisieren?", "paragraph": "Man synchronisiert parallele Prozesse mittels geteilter Warteschlangen: Man verwendet die Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gez\u00e4hlt werden) Objekte aufnehmen und die eine Synchronisation \u00fcber next und nextPut: erlauben. Wenn man nun eine solche Shared queue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife l\u00e4uft, diese Queue auslesen l\u00e4sst, dann hat man tats\u00e4chlich \"aktive Objekte, die einander Nachrichten schicken\".", "answer": "mittels geteilter Warteschlangen", "sentence": "Man synchronisiert parallele Prozesse mittels geteilter Warteschlangen:", "paragraph_sentence": "<hl> Man synchronisiert parallele Prozesse mittels geteilter Warteschlangen: <hl> Man verwendet die Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gez\u00e4hlt werden) Objekte aufnehmen und die eine Synchronisation \u00fcber next und nextPut: erlauben. Wenn man nun eine solche Shared queue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife l\u00e4uft, diese Queue auslesen l\u00e4sst, dann hat man tats\u00e4chlich \"aktive Objekte, die einander Nachrichten schicken\".", "paragraph_answer": "Man synchronisiert parallele Prozesse <hl> mittels geteilter Warteschlangen <hl>: Man verwendet die Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gez\u00e4hlt werden) Objekte aufnehmen und die eine Synchronisation \u00fcber next und nextPut: erlauben. Wenn man nun eine solche Shared queue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife l\u00e4uft, diese Queue auslesen l\u00e4sst, dann hat man tats\u00e4chlich \"aktive Objekte, die einander Nachrichten schicken\".", "sentence_answer": "Man synchronisiert parallele Prozesse <hl> mittels geteilter Warteschlangen <hl>:"}
{"question": "Was sind Typen?", "paragraph": "Typen sind abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschr\u00e4nken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben.", "answer": "abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschr\u00e4nken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben.", "sentence": "Typen sind abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschr\u00e4nken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben.", "paragraph_sentence": "<hl> Typen sind abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschr\u00e4nken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. <hl>", "paragraph_answer": "Typen sind <hl> abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschr\u00e4nken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. <hl>", "sentence_answer": "Typen sind <hl> abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschr\u00e4nken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. <hl>"}
{"question": "Warum typisiert man Variablen und Programmelemente?", "paragraph": "Typisierung regelt das Speicher-Layout. \nTypisierung erlaubt die effizientere Ausf\u00fchrung eines Programms. \nTypisierung erh\u00f6ht die Lesbarkeit eines Programms. \nTypisierung erm\u00f6glicht das automatische Finden von logischen Fehlern in einem Programm. \nDurch das Typsystem entsteht eine Modularisierung des Programms, wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdr\u00fcckt. Typen dienen damit der Wahrung des Implementationsgeheimnisses / Einhaltung der Schnittstellen durch den Compiler. \nDer Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er f\u00fcr die Aufnahme eines Wertes reservieren muss. Dies ist jedoch naturgem\u00e4\u00df nur f\u00fcr Variablen mit Wertsemantik relevant und daher f\u00fcr die objektorientierte Programmierung, insbesondere f\u00fcr Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung. ", "answer": "regelt das Speicher-Layout. \nTypisierung erlaubt die effizientere Ausf\u00fchrung eines Programms. \nTypisierung erh\u00f6ht die Lesbarkeit eines Programms. \nTypisierung erm\u00f6glicht das automatische Finden von logischen Fehlern in einem Programm. \nDurch das Typsystem entsteht eine Modularisierung des Programms, wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdr\u00fcckt. Typen dienen damit der Wahrung des Implementationsgeheimnisses / Einhaltung der Schnittstellen durch den Compiler. \nDer Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er f\u00fcr die Aufnahme eines Wertes reservieren muss", "sentence": "Typisierung regelt das Speicher-Layout. \nTypisierung erlaubt die effizientere Ausf\u00fchrung eines Programms. \nTypisierung erh\u00f6ht die Lesbarkeit eines Programms. \nTypisierung erm\u00f6glicht das automatische Finden von logischen Fehlern in einem Programm. \nDurch das Typsystem entsteht eine Modularisierung des Programms, wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdr\u00fcckt. Typen dienen damit der Wahrung des Implementationsgeheimnisses / Einhaltung der Schnittstellen durch den Compiler. \nDer Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er f\u00fcr die Aufnahme eines Wertes reservieren muss.", "paragraph_sentence": "<hl> Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausf\u00fchrung eines Programms. Typisierung erh\u00f6ht die Lesbarkeit eines Programms. Typisierung erm\u00f6glicht das automatische Finden von logischen Fehlern in einem Programm. Durch das Typsystem entsteht eine Modularisierung des Programms, wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdr\u00fcckt. Typen dienen damit der Wahrung des Implementationsgeheimnisses / Einhaltung der Schnittstellen durch den Compiler. Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er f\u00fcr die Aufnahme eines Wertes reservieren muss. <hl> Dies ist jedoch naturgem\u00e4\u00df nur f\u00fcr Variablen mit Wertsemantik relevant und daher f\u00fcr die objektorientierte Programmierung, insbesondere f\u00fcr Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung. ", "paragraph_answer": "Typisierung <hl> regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausf\u00fchrung eines Programms. Typisierung erh\u00f6ht die Lesbarkeit eines Programms. Typisierung erm\u00f6glicht das automatische Finden von logischen Fehlern in einem Programm. Durch das Typsystem entsteht eine Modularisierung des Programms, wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdr\u00fcckt. Typen dienen damit der Wahrung des Implementationsgeheimnisses / Einhaltung der Schnittstellen durch den Compiler. Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er f\u00fcr die Aufnahme eines Wertes reservieren muss <hl>. Dies ist jedoch naturgem\u00e4\u00df nur f\u00fcr Variablen mit Wertsemantik relevant und daher f\u00fcr die objektorientierte Programmierung, insbesondere f\u00fcr Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung. ", "sentence_answer": "Typisierung <hl> regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausf\u00fchrung eines Programms. Typisierung erh\u00f6ht die Lesbarkeit eines Programms. Typisierung erm\u00f6glicht das automatische Finden von logischen Fehlern in einem Programm. Durch das Typsystem entsteht eine Modularisierung des Programms, wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdr\u00fcckt. Typen dienen damit der Wahrung des Implementationsgeheimnisses / Einhaltung der Schnittstellen durch den Compiler. Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er f\u00fcr die Aufnahme eines Wertes reservieren muss <hl>."}
{"question": "Was muss ein Typsystem \u00fcberpr\u00fcfen, um in einem Programm Freiheit von semantischen Fehlern zu garantieren?", "paragraph": "Ein Typsystem muss lediglich alle Wertzuweisungen in einem Programm \u00fcberpr\u00fcfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu z\u00e4hlen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen, die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind.", "answer": "alle Wertzuweisungen in einem Programm", "sentence": "Ein Typsystem muss lediglich alle Wertzuweisungen in einem Programm \u00fcberpr\u00fcfen, um Freiheit von semantischen Fehlern zu garantieren.", "paragraph_sentence": "<hl> Ein Typsystem muss lediglich alle Wertzuweisungen in einem Programm \u00fcberpr\u00fcfen, um Freiheit von semantischen Fehlern zu garantieren. <hl> Dazu z\u00e4hlen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen, die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind.", "paragraph_answer": "Ein Typsystem muss lediglich <hl> alle Wertzuweisungen in einem Programm <hl> \u00fcberpr\u00fcfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu z\u00e4hlen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen, die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind.", "sentence_answer": "Ein Typsystem muss lediglich <hl> alle Wertzuweisungen in einem Programm <hl> \u00fcberpr\u00fcfen, um Freiheit von semantischen Fehlern zu garantieren."}
{"question": "Was versteht man unter dynamischer Typpr\u00fcfung?", "paragraph": "Bei der dynamischen Typpr\u00fcfung pr\u00fcft man zur Laufzeit vor einer Variablenzuweisung, ob der zuzuweisende Wert den von der Variable geforderten Typ hat.", "answer": "pr\u00fcft man zur Laufzeit vor einer Variablenzuweisung, ob der zuzuweisende Wert den von der Variable geforderten Typ hat", "sentence": "Bei der dynamischen Typpr\u00fcfung pr\u00fcft man zur Laufzeit vor einer Variablenzuweisung, ob der zuzuweisende Wert den von der Variable geforderten Typ hat.", "paragraph_sentence": "<hl> Bei der dynamischen Typpr\u00fcfung pr\u00fcft man zur Laufzeit vor einer Variablenzuweisung, ob der zuzuweisende Wert den von der Variable geforderten Typ hat. <hl>", "paragraph_answer": "Bei der dynamischen Typpr\u00fcfung <hl> pr\u00fcft man zur Laufzeit vor einer Variablenzuweisung, ob der zuzuweisende Wert den von der Variable geforderten Typ hat <hl>.", "sentence_answer": "Bei der dynamischen Typpr\u00fcfung <hl> pr\u00fcft man zur Laufzeit vor einer Variablenzuweisung, ob der zuzuweisende Wert den von der Variable geforderten Typ hat <hl>."}
{"question": "F\u00fchrt SMALLTALK dynamische Typpr\u00fcfung durch?", "paragraph": "SMALLTALK f\u00fchrt keine dynamische Typpr\u00fcfung durchf\u00fchrt, da Typfehler erst im letztm\u00f6glichen Moment offenbar werden, n\u00e4mlich wenn auf einer Variable eine Methode aufgerufen werden soll, die f\u00fcr das Objekt, auf das die Variable verweist, gar nicht definiert ist.", "answer": "keine dynamische Typpr\u00fcfung", "sentence": "SMALLTALK f\u00fchrt keine dynamische Typpr\u00fcfung durchf\u00fchrt, da Typfehler erst im letztm\u00f6glichen Moment offenbar werden, n\u00e4mlich wenn auf einer Variable eine Methode aufgerufen werden soll, die f\u00fcr das Objekt, auf das die Variable verweist, gar nicht definiert ist.", "paragraph_sentence": "<hl> SMALLTALK f\u00fchrt keine dynamische Typpr\u00fcfung durchf\u00fchrt, da Typfehler erst im letztm\u00f6glichen Moment offenbar werden, n\u00e4mlich wenn auf einer Variable eine Methode aufgerufen werden soll, die f\u00fcr das Objekt, auf das die Variable verweist, gar nicht definiert ist. <hl>", "paragraph_answer": "SMALLTALK f\u00fchrt <hl> keine dynamische Typpr\u00fcfung <hl> durchf\u00fchrt, da Typfehler erst im letztm\u00f6glichen Moment offenbar werden, n\u00e4mlich wenn auf einer Variable eine Methode aufgerufen werden soll, die f\u00fcr das Objekt, auf das die Variable verweist, gar nicht definiert ist.", "sentence_answer": "SMALLTALK f\u00fchrt <hl> keine dynamische Typpr\u00fcfung <hl> durchf\u00fchrt, da Typfehler erst im letztm\u00f6glichen Moment offenbar werden, n\u00e4mlich wenn auf einer Variable eine Methode aufgerufen werden soll, die f\u00fcr das Objekt, auf das die Variable verweist, gar nicht definiert ist."}
{"question": "Was versteht man unter statischer Typpr\u00fcfung?", "paragraph": "Bei der statischen Typpr\u00fcfung soll die Typkorrektheit zur \u00fcbersetzungszeit gew\u00e4hrleistet werden. Die Typpr\u00fcfung ist Aufgabe des Compilers. Nachteil der rein statischen Typpr\u00fcfung ist, dass sie auch Programme zur\u00fcckweist, die n\u00fctzlich, sinnvoll und typkorrekt sind.", "answer": "soll die Typkorrektheit zur \u00fcbersetzungszeit gew\u00e4hrleistet werden", "sentence": "Bei der statischen Typpr\u00fcfung soll die Typkorrektheit zur \u00fcbersetzungszeit gew\u00e4hrleistet werden. Die Typpr\u00fcfung ist Aufgabe des Compilers.", "paragraph_sentence": "<hl> Bei der statischen Typpr\u00fcfung soll die Typkorrektheit zur \u00fcbersetzungszeit gew\u00e4hrleistet werden. Die Typpr\u00fcfung ist Aufgabe des Compilers. <hl> Nachteil der rein statischen Typpr\u00fcfung ist, dass sie auch Programme zur\u00fcckweist, die n\u00fctzlich, sinnvoll und typkorrekt sind.", "paragraph_answer": "Bei der statischen Typpr\u00fcfung <hl> soll die Typkorrektheit zur \u00fcbersetzungszeit gew\u00e4hrleistet werden <hl>. Die Typpr\u00fcfung ist Aufgabe des Compilers. Nachteil der rein statischen Typpr\u00fcfung ist, dass sie auch Programme zur\u00fcckweist, die n\u00fctzlich, sinnvoll und typkorrekt sind.", "sentence_answer": "Bei der statischen Typpr\u00fcfung <hl> soll die Typkorrektheit zur \u00fcbersetzungszeit gew\u00e4hrleistet werden <hl>. Die Typpr\u00fcfung ist Aufgabe des Compilers."}
{"question": "Was versteht man unter statischer Typpr\u00fcfung?", "paragraph": "Bei der statischen Typpr\u00fcfung soll die Typkorrektheit zur \u00fcbersetzungszeit gew\u00e4hrleistet werden. Die Typpr\u00fcfung ist Aufgabe des Compilers. Nachteil der rein statischen Typpr\u00fcfung ist, dass sie auch Programme zur\u00fcckweist, die n\u00fctzlich, sinnvoll und typkorrekt sind.", "answer": "auch Programme zur\u00fcckweist, die n\u00fctzlich, sinnvoll und typkorrekt sind", "sentence": "Nachteil der rein statischen Typpr\u00fcfung ist, dass sie auch Programme zur\u00fcckweist, die n\u00fctzlich, sinnvoll und typkorrekt sind.", "paragraph_sentence": "Bei der statischen Typpr\u00fcfung soll die Typkorrektheit zur \u00fcbersetzungszeit gew\u00e4hrleistet werden. Die Typpr\u00fcfung ist Aufgabe des Compilers. <hl> Nachteil der rein statischen Typpr\u00fcfung ist, dass sie auch Programme zur\u00fcckweist, die n\u00fctzlich, sinnvoll und typkorrekt sind. <hl>", "paragraph_answer": "Bei der statischen Typpr\u00fcfung soll die Typkorrektheit zur \u00fcbersetzungszeit gew\u00e4hrleistet werden. Die Typpr\u00fcfung ist Aufgabe des Compilers. Nachteil der rein statischen Typpr\u00fcfung ist, dass sie <hl> auch Programme zur\u00fcckweist, die n\u00fctzlich, sinnvoll und typkorrekt sind <hl>.", "sentence_answer": "Nachteil der rein statischen Typpr\u00fcfung ist, dass sie <hl> auch Programme zur\u00fcckweist, die n\u00fctzlich, sinnvoll und typkorrekt sind <hl>."}
{"question": "Was ist ein Suptyp?", "paragraph": "Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte \u00fcberall da auftauchen d\u00fcrfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht f\u00fcr eine besondere Art von Typ, sondern vielmehr f\u00fcr eine Rolle in einer Beziehung zwischen zwei Typen, n\u00e4mlich der Subtypenbeziehung. Die Gegenrolle hei\u00dft Supertyp. \nEin Subtyp ist also mit seinem Supertyp per Definition zuweisungskompatibel. \nEs gilt die folgende Regel: \"Wenn ein Typ Y ein Subtyp eines Typs X ist, dann m\u00fcssen alle Bedingungen, die f\u00fcr Objekte des Typs X erf\u00fcllt sind, auch f\u00fcr Objekte des Typs Y erf\u00fcllt sein.\"", "answer": "ein Typ definiert, dessen Werte oder Objekte \u00fcberall da auftauchen d\u00fcrfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird", "sentence": "Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte \u00fcberall da auftauchen d\u00fcrfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird.", "paragraph_sentence": "<hl> Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte \u00fcberall da auftauchen d\u00fcrfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. <hl> Subtyp steht dabei nicht f\u00fcr eine besondere Art von Typ, sondern vielmehr f\u00fcr eine Rolle in einer Beziehung zwischen zwei Typen, n\u00e4mlich der Subtypenbeziehung. Die Gegenrolle hei\u00dft Supertyp. Ein Subtyp ist also mit seinem Supertyp per Definition zuweisungskompatibel. Es gilt die folgende Regel: \"Wenn ein Typ Y ein Subtyp eines Typs X ist, dann m\u00fcssen alle Bedingungen, die f\u00fcr Objekte des Typs X erf\u00fcllt sind, auch f\u00fcr Objekte des Typs Y erf\u00fcllt sein.\"", "paragraph_answer": "Ein Subtyp ist als <hl> ein Typ definiert, dessen Werte oder Objekte \u00fcberall da auftauchen d\u00fcrfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird <hl>. Subtyp steht dabei nicht f\u00fcr eine besondere Art von Typ, sondern vielmehr f\u00fcr eine Rolle in einer Beziehung zwischen zwei Typen, n\u00e4mlich der Subtypenbeziehung. Die Gegenrolle hei\u00dft Supertyp. Ein Subtyp ist also mit seinem Supertyp per Definition zuweisungskompatibel. Es gilt die folgende Regel: \"Wenn ein Typ Y ein Subtyp eines Typs X ist, dann m\u00fcssen alle Bedingungen, die f\u00fcr Objekte des Typs X erf\u00fcllt sind, auch f\u00fcr Objekte des Typs Y erf\u00fcllt sein.\"", "sentence_answer": "Ein Subtyp ist als <hl> ein Typ definiert, dessen Werte oder Objekte \u00fcberall da auftauchen d\u00fcrfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird <hl>."}
{"question": "Wann verzichtet man auf die statische Typpr\u00fcfung zugunsten einer dynamischen Typpr\u00fcfung?", "paragraph": "In Java ist das Array Loewe[ ] Subtyp des Katzen-Array Katze[ ], wenn  Loewe Subtyp von Katze ist. Man hat hier auf die statische Typpr\u00fcfung zugunsten einer dynamischen Typpr\u00fcfung mit m\u00f6glicher Meldung eines Laufzeitfehlers verzichtet. Dies tut man immer dann, wenn die statische Typpr\u00fcfung Programme verhindert, die man gern schreiben m\u00f6chte und die auch korrekt sein k\u00f6nnen, ohne dass dies jedoch vom Compiler garantiert werden k\u00f6nnte. Beispiele daf\u00fcr sind Programme, die Prozeduren verwenden, die auf einer Menge von Objekten durchgef\u00fchrt werden k\u00f6nnen sollen, die aber nicht verlangen, dass die Elemente alle vom gleichen Typ sind, sondern statt dessen gestatten, dass auch Elemente von Subtypen darunter vorkommen.", "answer": "immer dann, wenn die statische Typpr\u00fcfung Programme verhindert, die man gern schreiben m\u00f6chte und die auch korrekt sein k\u00f6nnen", "sentence": "Man hat hier auf die statische Typpr\u00fcfung zugunsten einer dynamischen Typpr\u00fcfung mit m\u00f6glicher Meldung eines Laufzeitfehlers verzichtet. Dies tut man immer dann, wenn die statische Typpr\u00fcfung Programme verhindert, die man gern schreiben m\u00f6chte und die auch korrekt sein k\u00f6nnen, ohne dass dies jedoch vom Compiler garantiert werden k\u00f6nnte.", "paragraph_sentence": "In Java ist das Array Loewe[ ] Subtyp des Katzen-Array Katze[ ], wenn Loewe Subtyp von Katze ist. <hl> Man hat hier auf die statische Typpr\u00fcfung zugunsten einer dynamischen Typpr\u00fcfung mit m\u00f6glicher Meldung eines Laufzeitfehlers verzichtet. Dies tut man immer dann, wenn die statische Typpr\u00fcfung Programme verhindert, die man gern schreiben m\u00f6chte und die auch korrekt sein k\u00f6nnen, ohne dass dies jedoch vom Compiler garantiert werden k\u00f6nnte. <hl> Beispiele daf\u00fcr sind Programme, die Prozeduren verwenden, die auf einer Menge von Objekten durchgef\u00fchrt werden k\u00f6nnen sollen, die aber nicht verlangen, dass die Elemente alle vom gleichen Typ sind, sondern statt dessen gestatten, dass auch Elemente von Subtypen darunter vorkommen.", "paragraph_answer": "In Java ist das Array Loewe[ ] Subtyp des Katzen-Array Katze[ ], wenn Loewe Subtyp von Katze ist. Man hat hier auf die statische Typpr\u00fcfung zugunsten einer dynamischen Typpr\u00fcfung mit m\u00f6glicher Meldung eines Laufzeitfehlers verzichtet. Dies tut man <hl> immer dann, wenn die statische Typpr\u00fcfung Programme verhindert, die man gern schreiben m\u00f6chte und die auch korrekt sein k\u00f6nnen <hl>, ohne dass dies jedoch vom Compiler garantiert werden k\u00f6nnte. Beispiele daf\u00fcr sind Programme, die Prozeduren verwenden, die auf einer Menge von Objekten durchgef\u00fchrt werden k\u00f6nnen sollen, die aber nicht verlangen, dass die Elemente alle vom gleichen Typ sind, sondern statt dessen gestatten, dass auch Elemente von Subtypen darunter vorkommen.", "sentence_answer": "Man hat hier auf die statische Typpr\u00fcfung zugunsten einer dynamischen Typpr\u00fcfung mit m\u00f6glicher Meldung eines Laufzeitfehlers verzichtet. Dies tut man <hl> immer dann, wenn die statische Typpr\u00fcfung Programme verhindert, die man gern schreiben m\u00f6chte und die auch korrekt sein k\u00f6nnen <hl>, ohne dass dies jedoch vom Compiler garantiert werden k\u00f6nnte."}
{"question": "Was versteht man unter Inklusionspolymorphie?", "paragraph": "Unter Inklusionspolymorphie versteht man im Wesentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, k\u00f6nnen Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert). Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus gebr\u00e4uchlich; sonst redet man eher von Subtyping. ", "answer": "dasselbe wie unter Subtyping", "sentence": "Unter Inklusionspolymorphie versteht man im Wesentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, k\u00f6nnen Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert).", "paragraph_sentence": "<hl> Unter Inklusionspolymorphie versteht man im Wesentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, k\u00f6nnen Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert). <hl> Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus gebr\u00e4uchlich; sonst redet man eher von Subtyping. ", "paragraph_answer": "Unter Inklusionspolymorphie versteht man im Wesentlichen <hl> dasselbe wie unter Subtyping <hl>: Wo Objekte eines Typs erwartet werden, k\u00f6nnen Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert). Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus gebr\u00e4uchlich; sonst redet man eher von Subtyping. ", "sentence_answer": "Unter Inklusionspolymorphie versteht man im Wesentlichen <hl> dasselbe wie unter Subtyping <hl>: Wo Objekte eines Typs erwartet werden, k\u00f6nnen Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert)."}
{"question": "Warum h\u00e4lt eine Klassendefinition in der Regel sinnvollerweise auch als Typdefinition her?", "paragraph": "Klassen dienen der Angabe von Implementierungen und damit als Container von ausf\u00fchrbarem Code; Typen dienen der Formulierung von Invarianten, die f\u00fcr Variablenbelegungen gelten m\u00fcssen und deren Verletzung auf einen (logischen oder semantischen) Programmierfehler hinweist. Da beide im Wesentlichen \u00fcber die gleichen Elemente verf\u00fcgen, l\u00e4sst sich die Definition beider in einem Sprachkonstrukt zusammenfassen. \nDer Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausf\u00fchrung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen l\u00e4\u00dft (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausf\u00fchrung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann.", "answer": "Da beide im Wesentlichen \u00fcber die gleichen Elemente verf\u00fcgen", "sentence": "Da beide im Wesentlichen \u00fcber die gleichen Elemente verf\u00fcgen, l\u00e4sst sich die Definition beider in einem Sprachkonstrukt zusammenfassen.", "paragraph_sentence": "Klassen dienen der Angabe von Implementierungen und damit als Container von ausf\u00fchrbarem Code; Typen dienen der Formulierung von Invarianten, die f\u00fcr Variablenbelegungen gelten m\u00fcssen und deren Verletzung auf einen (logischen oder semantischen) Programmierfehler hinweist. <hl> Da beide im Wesentlichen \u00fcber die gleichen Elemente verf\u00fcgen, l\u00e4sst sich die Definition beider in einem Sprachkonstrukt zusammenfassen. <hl> Der Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausf\u00fchrung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen l\u00e4\u00dft (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausf\u00fchrung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann.", "paragraph_answer": "Klassen dienen der Angabe von Implementierungen und damit als Container von ausf\u00fchrbarem Code; Typen dienen der Formulierung von Invarianten, die f\u00fcr Variablenbelegungen gelten m\u00fcssen und deren Verletzung auf einen (logischen oder semantischen) Programmierfehler hinweist. <hl> Da beide im Wesentlichen \u00fcber die gleichen Elemente verf\u00fcgen <hl>, l\u00e4sst sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausf\u00fchrung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen l\u00e4\u00dft (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausf\u00fchrung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann.", "sentence_answer": "<hl> Da beide im Wesentlichen \u00fcber die gleichen Elemente verf\u00fcgen <hl>, l\u00e4sst sich die Definition beider in einem Sprachkonstrukt zusammenfassen."}
{"question": "Wo manifestiert sich der Unterschied der beiden Konzepte Klasse und Typ?", "paragraph": "Klassen dienen der Angabe von Implementierungen und damit als Container von ausf\u00fchrbarem Code; Typen dienen der Formulierung von Invarianten, die f\u00fcr Variablenbelegungen gelten m\u00fcssen und deren Verletzung auf einen (logischen oder semantischen) Programmierfehler hinweist. Da beide im Wesentlichen \u00fcber die gleichen Elemente verf\u00fcgen, l\u00e4sst sich die Definition beider in einem Sprachkonstrukt zusammenfassen. \nDer Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausf\u00fchrung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen l\u00e4\u00dft (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausf\u00fchrung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann.", "answer": "welche Rolle sie zur Laufzeit eines Programms spielen", "sentence": "Der Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausf\u00fchrung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen l\u00e4\u00dft (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausf\u00fchrung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann.", "paragraph_sentence": "Klassen dienen der Angabe von Implementierungen und damit als Container von ausf\u00fchrbarem Code; Typen dienen der Formulierung von Invarianten, die f\u00fcr Variablenbelegungen gelten m\u00fcssen und deren Verletzung auf einen (logischen oder semantischen) Programmierfehler hinweist. Da beide im Wesentlichen \u00fcber die gleichen Elemente verf\u00fcgen, l\u00e4sst sich die Definition beider in einem Sprachkonstrukt zusammenfassen. <hl> Der Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausf\u00fchrung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen l\u00e4\u00dft (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausf\u00fchrung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann. <hl>", "paragraph_answer": "Klassen dienen der Angabe von Implementierungen und damit als Container von ausf\u00fchrbarem Code; Typen dienen der Formulierung von Invarianten, die f\u00fcr Variablenbelegungen gelten m\u00fcssen und deren Verletzung auf einen (logischen oder semantischen) Programmierfehler hinweist. Da beide im Wesentlichen \u00fcber die gleichen Elemente verf\u00fcgen, l\u00e4sst sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, <hl> welche Rolle sie zur Laufzeit eines Programms spielen <hl>: Typinformation beeinflusst die Ausf\u00fchrung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen l\u00e4\u00dft (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausf\u00fchrung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann.", "sentence_answer": "Der Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, <hl> welche Rolle sie zur Laufzeit eines Programms spielen <hl>: Typinformation beeinflusst die Ausf\u00fchrung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen l\u00e4\u00dft (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausf\u00fchrung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann."}
{"question": "Was versteht man unter Instanziierung des parametrischen Typs?", "paragraph": "Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden m\u00fcssen, sondern durch Platzhalter, die Typparameter, vertreten werden k\u00f6nnen. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschr\u00e4nkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich.", "answer": "Wertzuweisung an eine Typvariable", "sentence": "Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird.", "paragraph_sentence": "Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden m\u00fcssen, sondern durch Platzhalter, die Typparameter, vertreten werden k\u00f6nnen. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschr\u00e4nkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. <hl> Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. <hl> Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich.", "paragraph_answer": "Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden m\u00fcssen, sondern durch Platzhalter, die Typparameter, vertreten werden k\u00f6nnen. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschr\u00e4nkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser <hl> Wertzuweisung an eine Typvariable <hl> von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich.", "sentence_answer": "Man spricht bei dieser <hl> Wertzuweisung an eine Typvariable <hl> von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird."}
{"question": "Zu welchem Zeitpunkt f\u00fchrt die Verwendung eines parametrisch definierten Typs zu einer Zuweisung an die Typvariable?", "paragraph": "Die Verwendung eines parametrisch definierten Typs f\u00fchrt bereits zur \u00fcbersetzungszeit zu einer Zuweisung an die Typvariablen.", "answer": "zur \u00fcbersetzungszeit", "sentence": "Die Verwendung eines parametrisch definierten Typs f\u00fchrt bereits zur \u00fcbersetzungszeit zu einer Zuweisung an die Typvariablen.", "paragraph_sentence": "<hl> Die Verwendung eines parametrisch definierten Typs f\u00fchrt bereits zur \u00fcbersetzungszeit zu einer Zuweisung an die Typvariablen. <hl>", "paragraph_answer": "Die Verwendung eines parametrisch definierten Typs f\u00fchrt bereits <hl> zur \u00fcbersetzungszeit <hl> zu einer Zuweisung an die Typvariablen.", "sentence_answer": "Die Verwendung eines parametrisch definierten Typs f\u00fchrt bereits <hl> zur \u00fcbersetzungszeit <hl> zu einer Zuweisung an die Typvariablen."}
{"question": "Welche Klassen sind ein Standardanwendungsfall f\u00fcr parametrischen Polymorphismus?", "paragraph": "Dies sind Collections mit Typvariablen E und Dictionary mit den Typvariablen S und E.", "answer": "Collections", "sentence": "Dies sind Collections mit Typvariablen E und Dictionary mit den Typvariablen S und E.", "paragraph_sentence": "<hl> Dies sind Collections mit Typvariablen E und Dictionary mit den Typvariablen S und E. <hl>", "paragraph_answer": "Dies sind <hl> Collections <hl> mit Typvariablen E und Dictionary mit den Typvariablen S und E.", "sentence_answer": "Dies sind <hl> Collections <hl> mit Typvariablen E und Dictionary mit den Typvariablen S und E."}
{"question": "Warum ben\u00f6tigt man den einfachen parametrischen Polymorphismus?", "paragraph": "Zur Vermeidung einer Sicherheitsl\u00fccke in der statischen Typpr\u00fcfung: Collections sind das typische Beispiel f\u00fcr die Verwendung des parametrschen Polymorphismus. Man k\u00f6nnte die Collections aber auch als Collections von Object definieren. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. Wenn ein solches Objekt von einem Subtyp von Object ist, muss man eine Typumwandlung durchf\u00fchren, wenn man spezielle Subtypeigenschaften dieses Objektes nutzen will. Die Zul\u00e4ssigkeit dieses Down cast ist aber davon abh\u00e4ngig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die L\u00f6sung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitsl\u00fccke in der statischen Typpr\u00fcfung, die der parametrische Polymorphismus behebt.", "answer": "Vermeidung einer Sicherheitsl\u00fccke in der statischen Typpr\u00fcfung", "sentence": "Zur Vermeidung einer Sicherheitsl\u00fccke in der statischen Typpr\u00fcfung:", "paragraph_sentence": "<hl> Zur Vermeidung einer Sicherheitsl\u00fccke in der statischen Typpr\u00fcfung: <hl> Collections sind das typische Beispiel f\u00fcr die Verwendung des parametrschen Polymorphismus. Man k\u00f6nnte die Collections aber auch als Collections von Object definieren. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. Wenn ein solches Objekt von einem Subtyp von Object ist, muss man eine Typumwandlung durchf\u00fchren, wenn man spezielle Subtypeigenschaften dieses Objektes nutzen will. Die Zul\u00e4ssigkeit dieses Down cast ist aber davon abh\u00e4ngig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die L\u00f6sung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitsl\u00fccke in der statischen Typpr\u00fcfung, die der parametrische Polymorphismus behebt.", "paragraph_answer": "Zur <hl> Vermeidung einer Sicherheitsl\u00fccke in der statischen Typpr\u00fcfung <hl>: Collections sind das typische Beispiel f\u00fcr die Verwendung des parametrschen Polymorphismus. Man k\u00f6nnte die Collections aber auch als Collections von Object definieren. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. Wenn ein solches Objekt von einem Subtyp von Object ist, muss man eine Typumwandlung durchf\u00fchren, wenn man spezielle Subtypeigenschaften dieses Objektes nutzen will. Die Zul\u00e4ssigkeit dieses Down cast ist aber davon abh\u00e4ngig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die L\u00f6sung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitsl\u00fccke in der statischen Typpr\u00fcfung, die der parametrische Polymorphismus behebt.", "sentence_answer": "Zur <hl> Vermeidung einer Sicherheitsl\u00fccke in der statischen Typpr\u00fcfung <hl>:"}
{"question": "Welche Unzul\u00e4nglichkeiten hat der einfache parametrische Polymorphismus?", "paragraph": "Auch beim einfachen parametrischen Polymorphismus kann man nicht vollst\u00e4ndig auf Typumwandlungen verzichten, weil eine Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ speichern kann. \nZum anderen wird die erh\u00f6hte Typsicherheit bei der Verwendung von parametrisch definierten Typen mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft s. den Beispieltyp MyCollection, dessen Werte solche Collections sein sollen, deren Elemente sortiert und nummeriert werden k\u00f6nnen. Dieser Typ sei ein Subtyp von Collection und verf\u00fcge weiterhin \u00fcber entsprechende Methoden sortieren und summieren. Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht f\u00fcr alle Typen und somit auch nicht f\u00fcr alle m\u00f6glichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren l\u00e4\u00dft, der vom Typ Number oder einem Subtypen davon ist. Man kann daraus schlie\u00dfen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen m\u00fcssen, die einen solchen Wert zur\u00fcckliefern. \nNun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgef\u00fchrt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erh\u00f6hte Typsicherheit au\u00dferhalb der Typdefinition, n\u00e4mlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.", "answer": "die erh\u00f6hte Typsicherheit au\u00dferhalb der Typdefinition, n\u00e4mlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft", "sentence": "Es wird also die erh\u00f6hte Typsicherheit au\u00dferhalb der Typdefinition, n\u00e4mlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft", "paragraph_sentence": "Auch beim einfachen parametrischen Polymorphismus kann man nicht vollst\u00e4ndig auf Typumwandlungen verzichten, weil eine Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ speichern kann. Zum anderen wird die erh\u00f6hte Typsicherheit bei der Verwendung von parametrisch definierten Typen mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft s. den Beispieltyp MyCollection, dessen Werte solche Collections sein sollen, deren Elemente sortiert und nummeriert werden k\u00f6nnen. Dieser Typ sei ein Subtyp von Collection und verf\u00fcge weiterhin \u00fcber entsprechende Methoden sortieren und summieren. Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht f\u00fcr alle Typen und somit auch nicht f\u00fcr alle m\u00f6glichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren l\u00e4\u00dft, der vom Typ Number oder einem Subtypen davon ist. Man kann daraus schlie\u00dfen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen m\u00fcssen, die einen solchen Wert zur\u00fcckliefern. Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgef\u00fchrt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. <hl> Es wird also die erh\u00f6hte Typsicherheit au\u00dferhalb der Typdefinition, n\u00e4mlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft <hl>.", "paragraph_answer": "Auch beim einfachen parametrischen Polymorphismus kann man nicht vollst\u00e4ndig auf Typumwandlungen verzichten, weil eine Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ speichern kann. Zum anderen wird die erh\u00f6hte Typsicherheit bei der Verwendung von parametrisch definierten Typen mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft s. den Beispieltyp MyCollection, dessen Werte solche Collections sein sollen, deren Elemente sortiert und nummeriert werden k\u00f6nnen. Dieser Typ sei ein Subtyp von Collection und verf\u00fcge weiterhin \u00fcber entsprechende Methoden sortieren und summieren. Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht f\u00fcr alle Typen und somit auch nicht f\u00fcr alle m\u00f6glichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren l\u00e4\u00dft, der vom Typ Number oder einem Subtypen davon ist. Man kann daraus schlie\u00dfen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen m\u00fcssen, die einen solchen Wert zur\u00fcckliefern. Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgef\u00fchrt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also <hl> die erh\u00f6hte Typsicherheit au\u00dferhalb der Typdefinition, n\u00e4mlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft <hl>.", "sentence_answer": "Es wird also <hl> die erh\u00f6hte Typsicherheit au\u00dferhalb der Typdefinition, n\u00e4mlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft <hl>"}
{"question": "Wozu ben\u00f6tigt man den beschr\u00e4nkten parametrischen Polymorphismus?", "paragraph": "Da die Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den Typ implementierenden Klassen) keine Aussagen \u00fcber den Typ machen. Au\u00dferhalb, bei der Verwendung (Instanziierung) der Typdefinition, geht das schon, da hier die Typvariable durch einen Typ ersetzt ist. \nWas man also gern h\u00e4tte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschr\u00e4nkt ist, und zwar derart, dass man bei den als Werte zul\u00e4ssigen Typen ein bestimmtes, ben\u00f6tigtes Protokoll voraussetzen kann. Die aktuellen Typparameter sind dann nicht mehr beliebig zu w\u00e4hlen, sondern nur noch aus solchen Typen, die die Einschr\u00e4nkungen erf\u00fcllen. Um dies zu erreichen, w\u00e4hlt man Supertypen als Schranken.", "answer": "dass man bei den als Werte zul\u00e4ssigen Typen ein bestimmtes, ben\u00f6tigtes Protokoll voraussetzen kann", "sentence": "Was man also gern h\u00e4tte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschr\u00e4nkt ist, und zwar derart, dass man bei den als Werte zul\u00e4ssigen Typen ein bestimmtes, ben\u00f6tigtes Protokoll voraussetzen kann.", "paragraph_sentence": "Da die Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den Typ implementierenden Klassen) keine Aussagen \u00fcber den Typ machen. Au\u00dferhalb, bei der Verwendung (Instanziierung) der Typdefinition, geht das schon, da hier die Typvariable durch einen Typ ersetzt ist. <hl> Was man also gern h\u00e4tte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschr\u00e4nkt ist, und zwar derart, dass man bei den als Werte zul\u00e4ssigen Typen ein bestimmtes, ben\u00f6tigtes Protokoll voraussetzen kann. <hl> Die aktuellen Typparameter sind dann nicht mehr beliebig zu w\u00e4hlen, sondern nur noch aus solchen Typen, die die Einschr\u00e4nkungen erf\u00fcllen. Um dies zu erreichen, w\u00e4hlt man Supertypen als Schranken.", "paragraph_answer": "Da die Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den Typ implementierenden Klassen) keine Aussagen \u00fcber den Typ machen. Au\u00dferhalb, bei der Verwendung (Instanziierung) der Typdefinition, geht das schon, da hier die Typvariable durch einen Typ ersetzt ist. Was man also gern h\u00e4tte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschr\u00e4nkt ist, und zwar derart, <hl> dass man bei den als Werte zul\u00e4ssigen Typen ein bestimmtes, ben\u00f6tigtes Protokoll voraussetzen kann <hl>. Die aktuellen Typparameter sind dann nicht mehr beliebig zu w\u00e4hlen, sondern nur noch aus solchen Typen, die die Einschr\u00e4nkungen erf\u00fcllen. Um dies zu erreichen, w\u00e4hlt man Supertypen als Schranken.", "sentence_answer": "Was man also gern h\u00e4tte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschr\u00e4nkt ist, und zwar derart, <hl> dass man bei den als Werte zul\u00e4ssigen Typen ein bestimmtes, ben\u00f6tigtes Protokoll voraussetzen kann <hl>."}
{"question": "Was ist der Unterschied zwischen \u00fcberschreiben und \u00fcberladen?", "paragraph": "\u00fcberschreiben bedeutet, dass eine Methode mit der gleichen Signatur (bestehend aus Methodenname und formalen Parametertypen) noch einmal definiert werden kann, und zwar mit ge\u00e4nderter Implementierung. Auch darf die Methode den R\u00fcckgabetyp kovariant, also nach unten, ab\u00e4ndern. \nNun kann man in JAVA auch Methoden mit gleichem Namen, aber verschiedenen Parametertypen in derselben oder einer Subklasse haben. Diese Methoden nennt man dann \u00fcberladen. \nIn JAVA sind \u00fcberladen und \u00fcberschreiben zwei grundverschiedene Dinge, obwohl man in beiden F\u00e4llen nichts weiter tut als eine Methode mit bereits vorhandenem Namen noch einmal zu definieren: Beim \u00fcberladen wird eine neue Methode eingef\u00fchrt, beim \u00fcberschreiben wird eine bereits bestehende redefiniert.", "answer": "Beim \u00fcberladen wird eine neue Methode eingef\u00fchrt, beim \u00fcberschreiben wird eine bereits bestehende redefiniert", "sentence": "Beim \u00fcberladen wird eine neue Methode eingef\u00fchrt, beim \u00fcberschreiben wird eine bereits bestehende redefiniert.", "paragraph_sentence": "\u00fcberschreiben bedeutet, dass eine Methode mit der gleichen Signatur (bestehend aus Methodenname und formalen Parametertypen) noch einmal definiert werden kann, und zwar mit ge\u00e4nderter Implementierung. Auch darf die Methode den R\u00fcckgabetyp kovariant, also nach unten, ab\u00e4ndern. Nun kann man in JAVA auch Methoden mit gleichem Namen, aber verschiedenen Parametertypen in derselben oder einer Subklasse haben. Diese Methoden nennt man dann \u00fcberladen. In JAVA sind \u00fcberladen und \u00fcberschreiben zwei grundverschiedene Dinge, obwohl man in beiden F\u00e4llen nichts weiter tut als eine Methode mit bereits vorhandenem Namen noch einmal zu definieren: <hl> Beim \u00fcberladen wird eine neue Methode eingef\u00fchrt, beim \u00fcberschreiben wird eine bereits bestehende redefiniert. <hl>", "paragraph_answer": "\u00fcberschreiben bedeutet, dass eine Methode mit der gleichen Signatur (bestehend aus Methodenname und formalen Parametertypen) noch einmal definiert werden kann, und zwar mit ge\u00e4nderter Implementierung. Auch darf die Methode den R\u00fcckgabetyp kovariant, also nach unten, ab\u00e4ndern. Nun kann man in JAVA auch Methoden mit gleichem Namen, aber verschiedenen Parametertypen in derselben oder einer Subklasse haben. Diese Methoden nennt man dann \u00fcberladen. In JAVA sind \u00fcberladen und \u00fcberschreiben zwei grundverschiedene Dinge, obwohl man in beiden F\u00e4llen nichts weiter tut als eine Methode mit bereits vorhandenem Namen noch einmal zu definieren: <hl> Beim \u00fcberladen wird eine neue Methode eingef\u00fchrt, beim \u00fcberschreiben wird eine bereits bestehende redefiniert <hl>.", "sentence_answer": "<hl> Beim \u00fcberladen wird eine neue Methode eingef\u00fchrt, beim \u00fcberschreiben wird eine bereits bestehende redefiniert <hl>."}
{"question": "Wie kann die Regel \"Wenn ein Typ Y ein Subtyp eines Typs X ist, dann m\u00fcssen alle Bedingungen, die f\u00fcr Objekte des Typs X erf\u00fcllt sind, auch f\u00fcr Objekte des Typs Y erf\u00fcllt sein\" \u00fcberpr\u00fcft werden?", "paragraph": "Das Liskov-Substitutionsprinzip lautet: \u00fcberschreibende Methoden in S erhalten das Verhalten der \u00fcberschriebenen Methoden in T. Dazu geh\u00f6rt die Kontravarianz der Argumenttypen der \u00fcberschreibenden Methode, die Kovarianz des Ergebnistyps der \u00fcberschreibenden Methode, die Kovarianz der Ausnahmen der \u00fcberschreibenden Methode (die Typen der geworfenen Exceptions sind entweder Subtypen von den Typen der Exceptions der \u00fcberschriebenen Methode oder die Exceptions werden gar nicht geworfen; keinesfalls kommen Exceptions hinzu), die Vorbedingungen der \u00fcberschriebenen Methode implizieren Vorbedingungen der \u00fcberschreibenden und die Nachbedingungen der \u00fcberschriebenen Methode werden von Nachbedingungen der \u00fcberschreibenden Methode impliziert. Das Liskov-Substitutionsprinzip lautet weiter: Die Invarianten von S implizieren die von T.", "answer": "Liskov-Substitutionsprinzip", "sentence": "Das Liskov-Substitutionsprinzip lautet: \u00fcberschreibende Methoden in S erhalten das Verhalten der \u00fcberschriebenen Methoden in T. Dazu geh\u00f6rt die Kontravarianz der Argumenttypen der \u00fcberschreibenden Methode, die Kovarianz des Ergebnistyps der \u00fcberschreibenden Methode, die Kovarianz der Ausnahmen der \u00fcberschreibenden Methode (die Typen der geworfenen Exceptions sind entweder Subtypen von den Typen der Exceptions der \u00fcberschriebenen Methode oder die Exceptions werden gar nicht geworfen; keinesfalls kommen Exceptions hinzu), die Vorbedingungen der \u00fcberschriebenen Methode implizieren Vorbedingungen der \u00fcberschreibenden und die Nachbedingungen der \u00fcberschriebenen Methode werden von Nachbedingungen der \u00fcberschreibenden Methode impliziert. Das Liskov-Substitutionsprinzip lautet weiter: Die Invarianten von S implizieren die von T.", "paragraph_sentence": "<hl> Das Liskov-Substitutionsprinzip lautet: \u00fcberschreibende Methoden in S erhalten das Verhalten der \u00fcberschriebenen Methoden in T. Dazu geh\u00f6rt die Kontravarianz der Argumenttypen der \u00fcberschreibenden Methode, die Kovarianz des Ergebnistyps der \u00fcberschreibenden Methode, die Kovarianz der Ausnahmen der \u00fcberschreibenden Methode (die Typen der geworfenen Exceptions sind entweder Subtypen von den Typen der Exceptions der \u00fcberschriebenen Methode oder die Exceptions werden gar nicht geworfen; keinesfalls kommen Exceptions hinzu), die Vorbedingungen der \u00fcberschriebenen Methode implizieren Vorbedingungen der \u00fcberschreibenden und die Nachbedingungen der \u00fcberschriebenen Methode werden von Nachbedingungen der \u00fcberschreibenden Methode impliziert. Das Liskov-Substitutionsprinzip lautet weiter: Die Invarianten von S implizieren die von T. <hl>", "paragraph_answer": "Das <hl> Liskov-Substitutionsprinzip <hl> lautet: \u00fcberschreibende Methoden in S erhalten das Verhalten der \u00fcberschriebenen Methoden in T. Dazu geh\u00f6rt die Kontravarianz der Argumenttypen der \u00fcberschreibenden Methode, die Kovarianz des Ergebnistyps der \u00fcberschreibenden Methode, die Kovarianz der Ausnahmen der \u00fcberschreibenden Methode (die Typen der geworfenen Exceptions sind entweder Subtypen von den Typen der Exceptions der \u00fcberschriebenen Methode oder die Exceptions werden gar nicht geworfen; keinesfalls kommen Exceptions hinzu), die Vorbedingungen der \u00fcberschriebenen Methode implizieren Vorbedingungen der \u00fcberschreibenden und die Nachbedingungen der \u00fcberschriebenen Methode werden von Nachbedingungen der \u00fcberschreibenden Methode impliziert. Das Liskov-Substitutionsprinzip lautet weiter: Die Invarianten von S implizieren die von T.", "sentence_answer": "Das <hl> Liskov-Substitutionsprinzip <hl> lautet: \u00fcberschreibende Methoden in S erhalten das Verhalten der \u00fcberschriebenen Methoden in T. Dazu geh\u00f6rt die Kontravarianz der Argumenttypen der \u00fcberschreibenden Methode, die Kovarianz des Ergebnistyps der \u00fcberschreibenden Methode, die Kovarianz der Ausnahmen der \u00fcberschreibenden Methode (die Typen der geworfenen Exceptions sind entweder Subtypen von den Typen der Exceptions der \u00fcberschriebenen Methode oder die Exceptions werden gar nicht geworfen; keinesfalls kommen Exceptions hinzu), die Vorbedingungen der \u00fcberschriebenen Methode implizieren Vorbedingungen der \u00fcberschreibenden und die Nachbedingungen der \u00fcberschriebenen Methode werden von Nachbedingungen der \u00fcberschreibenden Methode impliziert. Das Liskov-Substitutionsprinzip lautet weiter: Die Invarianten von S implizieren die von T."}
{"question": "Was unternimmt C#, um das Fragile-base-class-Problem zu vermeiden?", "paragraph": "In C# sind dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schl\u00fcsselwort virtual. Entsprechend muss eine \u00fcberschreibende Methode mit dem Schl\u00fcsselwort override deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingef\u00fchrt (und nicht anstelle der, die sie \u00fcberschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schl\u00fcsselworts new bekanntzugeben. Dadurch markiert man alle Stellen im Programm, an denen das sog. Fragile-base-class-Problem auftreten kann.", "answer": "markiert man alle Stellen im Programm", "sentence": "Dadurch markiert man alle Stellen im Programm, an denen das sog. Fragile-base-class-Problem auftreten kann.", "paragraph_sentence": "In C# sind dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schl\u00fcsselwort virtual. Entsprechend muss eine \u00fcberschreibende Methode mit dem Schl\u00fcsselwort override deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingef\u00fchrt (und nicht anstelle der, die sie \u00fcberschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schl\u00fcsselworts new bekanntzugeben. <hl> Dadurch markiert man alle Stellen im Programm, an denen das sog. Fragile-base-class-Problem auftreten kann. <hl>", "paragraph_answer": "In C# sind dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schl\u00fcsselwort virtual. Entsprechend muss eine \u00fcberschreibende Methode mit dem Schl\u00fcsselwort override deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingef\u00fchrt (und nicht anstelle der, die sie \u00fcberschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schl\u00fcsselworts new bekanntzugeben. Dadurch <hl> markiert man alle Stellen im Programm <hl>, an denen das sog. Fragile-base-class-Problem auftreten kann.", "sentence_answer": "Dadurch <hl> markiert man alle Stellen im Programm <hl>, an denen das sog. Fragile-base-class-Problem auftreten kann."}
{"question": "Wie kann ein Objekt verbergen, welche Objekte es kennt?", "paragraph": "Es kann dies \u00fcber lokale Instanzvariablen tun.", "answer": "\u00fcber lokale Instanzvariablen", "sentence": "Es kann dies \u00fcber lokale Instanzvariablen tun.", "paragraph_sentence": "<hl> Es kann dies \u00fcber lokale Instanzvariablen tun. <hl>", "paragraph_answer": "Es kann dies <hl> \u00fcber lokale Instanzvariablen <hl> tun.", "sentence_answer": "Es kann dies <hl> \u00fcber lokale Instanzvariablen <hl> tun."}
{"question": "Welchen Schutz bietet die mangelnde Sichtbarkeit von Variablen vor unerw\u00fcnschtem Zugriff auf Objekte?", "paragraph": "Aufgrund des Aliasing kann ein Objekt, dessen einer Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, \u00fcber einen anderen zugreifbar sein, ohne dass der erste Name etwas dagegen machen k\u00f6nnte. \u00fcber lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt; es kann aber nicht verhindern, dass andere Objekte diese Objekte schon kennen und, ohne sein Wissen, manipulieren. Es ist somit wegen der etwaigen Existenz von Aliasen nicht m\u00f6glich, dass ein Objekt seinen inneren Aufbau vor der Au\u00dfenwelt abkapselt, es sein denn, es hat ganz spezielle Vorkehrungen daf\u00fcr getroffen.", "answer": "verbergen, welche Objekte es kennt; es kann aber nicht verhindern, dass andere Objekte diese Objekte schon kennen", "sentence": "\u00fcber lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt; es kann aber nicht verhindern, dass andere Objekte diese Objekte schon kennen und, ohne sein Wissen, manipulieren.", "paragraph_sentence": "Aufgrund des Aliasing kann ein Objekt, dessen einer Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, \u00fcber einen anderen zugreifbar sein, ohne dass der erste Name etwas dagegen machen k\u00f6nnte. <hl> \u00fcber lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt; es kann aber nicht verhindern, dass andere Objekte diese Objekte schon kennen und, ohne sein Wissen, manipulieren. <hl> Es ist somit wegen der etwaigen Existenz von Aliasen nicht m\u00f6glich, dass ein Objekt seinen inneren Aufbau vor der Au\u00dfenwelt abkapselt, es sein denn, es hat ganz spezielle Vorkehrungen daf\u00fcr getroffen.", "paragraph_answer": "Aufgrund des Aliasing kann ein Objekt, dessen einer Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, \u00fcber einen anderen zugreifbar sein, ohne dass der erste Name etwas dagegen machen k\u00f6nnte. \u00fcber lokale Instanzvariablen kann ein Objekt also <hl> verbergen, welche Objekte es kennt; es kann aber nicht verhindern, dass andere Objekte diese Objekte schon kennen <hl> und, ohne sein Wissen, manipulieren. Es ist somit wegen der etwaigen Existenz von Aliasen nicht m\u00f6glich, dass ein Objekt seinen inneren Aufbau vor der Au\u00dfenwelt abkapselt, es sein denn, es hat ganz spezielle Vorkehrungen daf\u00fcr getroffen.", "sentence_answer": "\u00fcber lokale Instanzvariablen kann ein Objekt also <hl> verbergen, welche Objekte es kennt; es kann aber nicht verhindern, dass andere Objekte diese Objekte schon kennen <hl> und, ohne sein Wissen, manipulieren."}
{"question": "Welchen einen starken konzeptuellen Hintergrund hat die Unterscheidung von Wert- und Referenztypen einer Klasse in EIFFEL?", "paragraph": "Die Unterscheidung von Wert- und Referenztypen einer Klasse unterst\u00fctzt die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten, n\u00e4mlich der, die das Enthaltensein von Objekten in anderen ausdr\u00fcckt. Nun ist es in der Realit\u00e4t so, dass nicht alle Instanzen einer Klasse immer entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (\u00fcber expanded Variablen) und freie Objekte (\u00fcber normale Variablen) zu haben.", "answer": "es erlaubt, von einer Klasse fallweise Komponentenobjekte (\u00fcber expanded Variablen) und freie Objekte (\u00fcber normale Variablen) zu haben", "sentence": "Nun ist es in der Realit\u00e4t so, dass nicht alle Instanzen einer Klasse immer entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (\u00fcber expanded Variablen) und freie Objekte (\u00fcber normale Variablen) zu haben.", "paragraph_sentence": "Die Unterscheidung von Wert- und Referenztypen einer Klasse unterst\u00fctzt die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten, n\u00e4mlich der, die das Enthaltensein von Objekten in anderen ausdr\u00fcckt. <hl> Nun ist es in der Realit\u00e4t so, dass nicht alle Instanzen einer Klasse immer entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (\u00fcber expanded Variablen) und freie Objekte (\u00fcber normale Variablen) zu haben. <hl>", "paragraph_answer": "Die Unterscheidung von Wert- und Referenztypen einer Klasse unterst\u00fctzt die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten, n\u00e4mlich der, die das Enthaltensein von Objekten in anderen ausdr\u00fcckt. Nun ist es in der Realit\u00e4t so, dass nicht alle Instanzen einer Klasse immer entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem <hl> es erlaubt, von einer Klasse fallweise Komponentenobjekte (\u00fcber expanded Variablen) und freie Objekte (\u00fcber normale Variablen) zu haben <hl>.", "sentence_answer": "Nun ist es in der Realit\u00e4t so, dass nicht alle Instanzen einer Klasse immer entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem <hl> es erlaubt, von einer Klasse fallweise Komponentenobjekte (\u00fcber expanded Variablen) und freie Objekte (\u00fcber normale Variablen) zu haben <hl>."}
{"question": "Wie funktionieren in EIFFEL Zuweisungen zwischen Variablen, die unterschiedliche Semantik haben?", "paragraph": "Bei der Zuweisung zwischen zwei Variablen mit Wertsemantik wird der Wert der einen Variable in die andere Variable kopiert. \nBei der Zuweisung zwischen zwei Variablen mit Referenzsemantik wird lediglich der Zeiger kopiert. \nBei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz f\u00fcr einen Zeiger, sondern f\u00fcr die Attributwerte - statt dessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: es werden die Attribute des Objekts in den f\u00fcr die Attribute des Werts reservierten Speicher der Variable kopiert). \nWenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt und eine Referenz auf diesen Klon \u00fcbergeben.", "answer": "zwischen zwei Variablen mit Wertsemantik wird der Wert der einen Variable in die andere Variable kopiert. \nBei der Zuweisung zwischen zwei Variablen mit Referenzsemantik wird lediglich der Zeiger kopiert. \nBei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz f\u00fcr einen Zeiger, sondern f\u00fcr die Attributwerte - statt dessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: es werden die Attribute des Objekts in den f\u00fcr die Attribute des Werts reservierten Speicher der Variable kopiert). \nWenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt und eine Referenz auf diesen Klon \u00fcbergeben", "sentence": "Bei der Zuweisung zwischen zwei Variablen mit Wertsemantik wird der Wert der einen Variable in die andere Variable kopiert. \nBei der Zuweisung zwischen zwei Variablen mit Referenzsemantik wird lediglich der Zeiger kopiert. \nBei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz f\u00fcr einen Zeiger, sondern f\u00fcr die Attributwerte - statt dessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: es werden die Attribute des Objekts in den f\u00fcr die Attribute des Werts reservierten Speicher der Variable kopiert). \nWenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt und eine Referenz auf diesen Klon \u00fcbergeben.", "paragraph_sentence": "<hl> Bei der Zuweisung zwischen zwei Variablen mit Wertsemantik wird der Wert der einen Variable in die andere Variable kopiert. Bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik wird lediglich der Zeiger kopiert. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz f\u00fcr einen Zeiger, sondern f\u00fcr die Attributwerte - statt dessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: es werden die Attribute des Objekts in den f\u00fcr die Attribute des Werts reservierten Speicher der Variable kopiert). Wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt und eine Referenz auf diesen Klon \u00fcbergeben. <hl>", "paragraph_answer": "Bei der Zuweisung <hl> zwischen zwei Variablen mit Wertsemantik wird der Wert der einen Variable in die andere Variable kopiert. Bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik wird lediglich der Zeiger kopiert. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz f\u00fcr einen Zeiger, sondern f\u00fcr die Attributwerte - statt dessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: es werden die Attribute des Objekts in den f\u00fcr die Attribute des Werts reservierten Speicher der Variable kopiert). Wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt und eine Referenz auf diesen Klon \u00fcbergeben <hl>.", "sentence_answer": "Bei der Zuweisung <hl> zwischen zwei Variablen mit Wertsemantik wird der Wert der einen Variable in die andere Variable kopiert. Bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik wird lediglich der Zeiger kopiert. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz f\u00fcr einen Zeiger, sondern f\u00fcr die Attributwerte - statt dessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: es werden die Attribute des Objekts in den f\u00fcr die Attribute des Werts reservierten Speicher der Variable kopiert). Wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt und eine Referenz auf diesen Klon \u00fcbergeben <hl>."}
{"question": "Was sind Repr\u00e4sentationsobjekte?", "paragraph": "Dies sind Objekte, die die Implementierung eines Objektes ausmachen und die hinter der Schnittstelle des Objektes verborgen werden sollen.", "answer": "Objekte, die die Implementierung eines Objektes ausmachen und die hinter der Schnittstelle des Objektes verborgen werden sollen", "sentence": "Dies sind Objekte, die die Implementierung eines Objektes ausmachen und die hinter der Schnittstelle des Objektes verborgen werden sollen.", "paragraph_sentence": "<hl> Dies sind Objekte, die die Implementierung eines Objektes ausmachen und die hinter der Schnittstelle des Objektes verborgen werden sollen. <hl>", "paragraph_answer": "Dies sind <hl> Objekte, die die Implementierung eines Objektes ausmachen und die hinter der Schnittstelle des Objektes verborgen werden sollen <hl>.", "sentence_answer": "Dies sind <hl> Objekte, die die Implementierung eines Objektes ausmachen und die hinter der Schnittstelle des Objektes verborgen werden sollen <hl>."}
{"question": "Welchen L\u00f6sungsansatz gibt es f\u00fcr das Problem der mangelnden Kapselung?", "paragraph": "Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes- Beziehung zwischen den Repr\u00e4sentationsobjekten und dem Objekt, dessen Repr\u00e4sentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen geh\u00f6ren in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein k\u00f6nnen, und dar\u00fcber hinaus auch nicht von anderen Objekten referenziert werden k\u00f6nnen. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt.", "answer": "aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt", "sentence": "Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt.", "paragraph_sentence": "Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes- Beziehung zwischen den Repr\u00e4sentationsobjekten und dem Objekt, dessen Repr\u00e4sentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen geh\u00f6ren in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein k\u00f6nnen, und dar\u00fcber hinaus auch nicht von anderen Objekten referenziert werden k\u00f6nnen. <hl> Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. <hl>", "paragraph_answer": "Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes- Beziehung zwischen den Repr\u00e4sentationsobjekten und dem Objekt, dessen Repr\u00e4sentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen geh\u00f6ren in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein k\u00f6nnen, und dar\u00fcber hinaus auch nicht von anderen Objekten referenziert werden k\u00f6nnen. Letzteres kann man auf einfache Weise verhindern, wenn man <hl> aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt <hl>.", "sentence_answer": "Letzteres kann man auf einfache Weise verhindern, wenn man <hl> aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt <hl>."}
{"question": "Wie versucht C#, das Problem der mangelnden Kaspelung zu l\u00f6sen?", "paragraph": "In C# kann man die \"Klasse\" der Teil-Objekte per struct definieren. (Aus Werttypen k\u00f6nnen, genau wie in PASCAL oder C, mittels des Typkonstruktors struct (dem C-\u00e4quivalent von PASCALs record) neue Werttypen erzeugt werden, die sogar Methoden und Konstruktoren haben k\u00f6nnen, die aber keine Klassen sind (und insbesondere keine Typerweiterung und somit auch keine Vererbung erlauben)) ", "answer": "Teil-Objekte per struct definieren", "sentence": "In C# kann man die \"Klasse\" der Teil-Objekte per struct definieren.", "paragraph_sentence": "<hl> In C# kann man die \"Klasse\" der Teil-Objekte per struct definieren. <hl> (Aus Werttypen k\u00f6nnen, genau wie in PASCAL oder C, mittels des Typkonstruktors struct (dem C-\u00e4quivalent von PASCALs record) neue Werttypen erzeugt werden, die sogar Methoden und Konstruktoren haben k\u00f6nnen, die aber keine Klassen sind (und insbesondere keine Typerweiterung und somit auch keine Vererbung erlauben)) ", "paragraph_answer": "In C# kann man die \"Klasse\" der <hl> Teil-Objekte per struct definieren <hl>. (Aus Werttypen k\u00f6nnen, genau wie in PASCAL oder C, mittels des Typkonstruktors struct (dem C-\u00e4quivalent von PASCALs record) neue Werttypen erzeugt werden, die sogar Methoden und Konstruktoren haben k\u00f6nnen, die aber keine Klassen sind (und insbesondere keine Typerweiterung und somit auch keine Vererbung erlauben)) ", "sentence_answer": "In C# kann man die \"Klasse\" der <hl> Teil-Objekte per struct definieren <hl>."}
{"question": "Welche L\u00f6sung bietet EIFFEL f\u00fcr das Problem der mangelnden Kapselung an?", "paragraph": "Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repr\u00e4sentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, so dass kein Alias in die Repr\u00e4sentation hinein entstehen kann. \nUmgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repr\u00e4sentationsobjekte sind aliasfrei.", "answer": "bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen", "sentence": "Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repr\u00e4sentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, so dass kein Alias in die Repr\u00e4sentation hinein entstehen kann.", "paragraph_sentence": "<hl> Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repr\u00e4sentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, so dass kein Alias in die Repr\u00e4sentation hinein entstehen kann. <hl> Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repr\u00e4sentationsobjekte sind aliasfrei.", "paragraph_answer": "Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repr\u00e4sentationsobjekt einen Alias besitzt), aber <hl> bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen <hl>, so dass kein Alias in die Repr\u00e4sentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repr\u00e4sentationsobjekte sind aliasfrei.", "sentence_answer": "Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repr\u00e4sentationsobjekt einen Alias besitzt), aber <hl> bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen <hl>, so dass kein Alias in die Repr\u00e4sentation hinein entstehen kann."}
{"question": "Wozu ben\u00f6tigt man Zwischenobjekte?", "paragraph": "Bei durch indizierte Instanzvariablen eines Objekts realisierten :n-Beziehungen kann nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden - die indizierten Instanzvariablen sind ja nicht benannt. \nDeswegen werden :n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer \u00fcber Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei k\u00f6nnen diese Zwischenobjekte die :n-Beziehung ggf. mit weiteren Attributen (z.B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o.\u00e4.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. \nDas Originalobjekt, das die :n- Beziehung eigentlich haben sollte, steht dann statt dessen in einer von einer benannten Instanzvariable hergestellten :1-Beziehung zu dem Zwischenobjekt, das die :n-Beziehung herstellt.", "answer": ":n-Beziehungen", "sentence": "Bei durch indizierte Instanzvariablen eines Objekts realisierten :n-Beziehungen kann nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden - die indizierten Instanzvariablen sind ja nicht benannt. \nDeswegen werden :n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer \u00fcber Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen.", "paragraph_sentence": "<hl> Bei durch indizierte Instanzvariablen eines Objekts realisierten :n-Beziehungen kann nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden - die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden :n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer \u00fcber Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. <hl> Dabei k\u00f6nnen diese Zwischenobjekte die :n-Beziehung ggf. mit weiteren Attributen (z.B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o.\u00e4.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die :n- Beziehung eigentlich haben sollte, steht dann statt dessen in einer von einer benannten Instanzvariable hergestellten :1-Beziehung zu dem Zwischenobjekt, das die :n-Beziehung herstellt.", "paragraph_answer": "Bei durch indizierte Instanzvariablen eines Objekts realisierten <hl> :n-Beziehungen <hl> kann nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden - die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden :n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer \u00fcber Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei k\u00f6nnen diese Zwischenobjekte die :n-Beziehung ggf. mit weiteren Attributen (z.B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o.\u00e4.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die :n- Beziehung eigentlich haben sollte, steht dann statt dessen in einer von einer benannten Instanzvariable hergestellten :1-Beziehung zu dem Zwischenobjekt, das die :n-Beziehung herstellt.", "sentence_answer": "Bei durch indizierte Instanzvariablen eines Objekts realisierten <hl> :n-Beziehungen <hl> kann nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden - die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden :n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer \u00fcber Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen."}
{"question": "Was sind die Vorteile von Zwischenobjekten?", "paragraph": "Der Umstand, dass :n-Beziehungen \u00fcber Zwischenobjekte realisiert werden, die vollwertige Objekte sind, erlaubt, die Beziehung beliebig auszugestalten. \nSo kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z.B. das oberste Element auf einem Stack). \nAuch besondere Zugriffsverfahren wie z.B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schl\u00fcssels k\u00f6nnen auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z.B. spezielle Schleifen) anbieten k\u00f6nnen, sind der Ausgestaltung von Beziehungen \u00fcber Zwischenobjekte praktisch keine Grenzen gesetzt.", "answer": "die Beziehung beliebig auszugestalten", "sentence": "Der Umstand, dass :n-Beziehungen \u00fcber Zwischenobjekte realisiert werden, die vollwertige Objekte sind, erlaubt, die Beziehung beliebig auszugestalten.", "paragraph_sentence": "<hl> Der Umstand, dass :n-Beziehungen \u00fcber Zwischenobjekte realisiert werden, die vollwertige Objekte sind, erlaubt, die Beziehung beliebig auszugestalten. <hl> So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z.B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z.B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schl\u00fcssels k\u00f6nnen auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z.B. spezielle Schleifen) anbieten k\u00f6nnen, sind der Ausgestaltung von Beziehungen \u00fcber Zwischenobjekte praktisch keine Grenzen gesetzt.", "paragraph_answer": "Der Umstand, dass :n-Beziehungen \u00fcber Zwischenobjekte realisiert werden, die vollwertige Objekte sind, erlaubt, <hl> die Beziehung beliebig auszugestalten <hl>. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z.B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z.B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schl\u00fcssels k\u00f6nnen auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z.B. spezielle Schleifen) anbieten k\u00f6nnen, sind der Ausgestaltung von Beziehungen \u00fcber Zwischenobjekte praktisch keine Grenzen gesetzt.", "sentence_answer": "Der Umstand, dass :n-Beziehungen \u00fcber Zwischenobjekte realisiert werden, die vollwertige Objekte sind, erlaubt, <hl> die Beziehung beliebig auszugestalten <hl>."}
{"question": "Was ist ein Nachteil von Zwischenobjekten, wenn man an guten objektorientierten Stil denkt?", "paragraph": "Mit Zwischenobjekten wird das Gesetz Demeters verletzt.", "answer": "das Gesetz Demeters verletzt", "sentence": "Mit Zwischenobjekten wird das Gesetz Demeters verletzt.", "paragraph_sentence": "<hl> Mit Zwischenobjekten wird das Gesetz Demeters verletzt. <hl>", "paragraph_answer": "Mit Zwischenobjekten wird <hl> das Gesetz Demeters verletzt <hl>.", "sentence_answer": "Mit Zwischenobjekten wird <hl> das Gesetz Demeters verletzt <hl>."}
{"question": "Was sind zwei verschiedene Arten, auf die man neue Objekte erzeugen kann?", "paragraph": "Per Instanziierung, verbunden mit der klassenbasierten objektorientierten Programmierung. \nPer Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung.", "answer": "Per Instanziierung, verbunden mit der klassenbasierten objektorientierten Programmierung. \nPer Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung", "sentence": "Per Instanziierung, verbunden mit der klassenbasierten objektorientierten Programmierung. \nPer Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung.", "paragraph_sentence": "<hl> Per Instanziierung, verbunden mit der klassenbasierten objektorientierten Programmierung. Per Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung. <hl>", "paragraph_answer": "<hl> Per Instanziierung, verbunden mit der klassenbasierten objektorientierten Programmierung. Per Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung <hl>.", "sentence_answer": "<hl> Per Instanziierung, verbunden mit der klassenbasierten objektorientierten Programmierung. Per Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung <hl>."}
{"question": "Was sind verschiedene Arten von Beziehungen?", "paragraph": "Beziehungen zwischen Klassen, das ist im wesentlichen die Subklassen- oder Vererbungsbeziehung. \nBeziehungen zwischen Klassen und Instanzen, das ist im wesentlichen die Instanziierungs- oder Klassikationsbeziehung \nBeziehungen zwischen Instanzen (oder Objekten), das sind im wesentlichen beliebige Assoziationen (wie Mutter-Tochter) und bestimmte spezielle wie Komposition oder Aggregation.", "answer": "Beziehungen zwischen Klassen, das ist im wesentlichen die Subklassen- oder Vererbungsbeziehung. \nBeziehungen zwischen Klassen und Instanzen, das ist im wesentlichen die Instanziierungs- oder Klassikationsbeziehung \nBeziehungen zwischen Instanzen (oder Objekten), das sind im wesentlichen beliebige Assoziationen (wie Mutter-Tochter) und bestimmte spezielle wie Komposition oder Aggregation", "sentence": "Beziehungen zwischen Klassen, das ist im wesentlichen die Subklassen- oder Vererbungsbeziehung. \nBeziehungen zwischen Klassen und Instanzen, das ist im wesentlichen die Instanziierungs- oder Klassikationsbeziehung \nBeziehungen zwischen Instanzen (oder Objekten), das sind im wesentlichen beliebige Assoziationen (wie Mutter-Tochter) und bestimmte spezielle wie Komposition oder Aggregation", "paragraph_sentence": "<hl> Beziehungen zwischen Klassen, das ist im wesentlichen die Subklassen- oder Vererbungsbeziehung. Beziehungen zwischen Klassen und Instanzen, das ist im wesentlichen die Instanziierungs- oder Klassikationsbeziehung Beziehungen zwischen Instanzen (oder Objekten), das sind im wesentlichen beliebige Assoziationen (wie Mutter-Tochter) und bestimmte spezielle wie Komposition oder Aggregation <hl>.", "paragraph_answer": "<hl> Beziehungen zwischen Klassen, das ist im wesentlichen die Subklassen- oder Vererbungsbeziehung. Beziehungen zwischen Klassen und Instanzen, das ist im wesentlichen die Instanziierungs- oder Klassikationsbeziehung Beziehungen zwischen Instanzen (oder Objekten), das sind im wesentlichen beliebige Assoziationen (wie Mutter-Tochter) und bestimmte spezielle wie Komposition oder Aggregation <hl>.", "sentence_answer": "<hl> Beziehungen zwischen Klassen, das ist im wesentlichen die Subklassen- oder Vererbungsbeziehung. Beziehungen zwischen Klassen und Instanzen, das ist im wesentlichen die Instanziierungs- oder Klassikationsbeziehung Beziehungen zwischen Instanzen (oder Objekten), das sind im wesentlichen beliebige Assoziationen (wie Mutter-Tochter) und bestimmte spezielle wie Komposition oder Aggregation <hl>"}
{"question": "In welchem Fall ist die Reservierung von an die Objektgr\u00f6\u00dfe angepasstem Speicherplatz f\u00fcr Variablen unn\u00f6tig?", "paragraph": "Die Reservierung von an die Objektgr\u00f6\u00dfe angepasstem Speicherplatz f\u00fcr Variablen ist im Fall der in der objektorientierten Programmierung dominierenden Referenzsemantik unn\u00f6tig - in Variablen werden nur Referenzen gespeichert, die immer gleich gro\u00df sind.", "answer": " im Fall der in der objektorientierten Programmierung dominierenden Referenzsemantik", "sentence": "Die Reservierung von an die Objektgr\u00f6\u00dfe angepasstem Speicherplatz f\u00fcr Variablen ist im Fall der in der objektorientierten Programmierung dominierenden Referenzsemantik unn\u00f6tig - in Variablen werden nur Referenzen gespeichert, die immer gleich gro\u00df sind.", "paragraph_sentence": "<hl> Die Reservierung von an die Objektgr\u00f6\u00dfe angepasstem Speicherplatz f\u00fcr Variablen ist im Fall der in der objektorientierten Programmierung dominierenden Referenzsemantik unn\u00f6tig - in Variablen werden nur Referenzen gespeichert, die immer gleich gro\u00df sind. <hl>", "paragraph_answer": "Die Reservierung von an die Objektgr\u00f6\u00dfe angepasstem Speicherplatz f\u00fcr Variablen ist<hl> im Fall der in der objektorientierten Programmierung dominierenden Referenzsemantik <hl> unn\u00f6tig - in Variablen werden nur Referenzen gespeichert, die immer gleich gro\u00df sind.", "sentence_answer": "Die Reservierung von an die Objektgr\u00f6\u00dfe angepasstem Speicherplatz f\u00fcr Variablen ist<hl> im Fall der in der objektorientierten Programmierung dominierenden Referenzsemantik <hl> unn\u00f6tig - in Variablen werden nur Referenzen gespeichert, die immer gleich gro\u00df sind."}
{"question": "Wozu braucht man beschr\u00e4nkten parametrischen Polymorphismus?", "paragraph": "Um Bedingungen auszudr\u00fccken, die der tats\u00e4chliche Typparameter, also der f\u00fcr die Typvariable eingesetzte Typ, einhalten muss. Die Bedingung wird dabei durch die Angabe eines Typs genannt, der Supertyp des tats\u00e4chlichen Typparameters sein muss (eine obere Schranke). Dadurch wird garantiert, dass der tats\u00e4chliche Typparameter alle in der Schranke vereinten Eigenschaften besitzt.", "answer": "Bedingungen auszudr\u00fccken, die der tats\u00e4chliche Typparameter, also der f\u00fcr die Typvariable eingesetzte Typ, einhalten muss", "sentence": "Um Bedingungen auszudr\u00fccken, die der tats\u00e4chliche Typparameter, also der f\u00fcr die Typvariable eingesetzte Typ, einhalten muss.", "paragraph_sentence": "<hl> Um Bedingungen auszudr\u00fccken, die der tats\u00e4chliche Typparameter, also der f\u00fcr die Typvariable eingesetzte Typ, einhalten muss. <hl> Die Bedingung wird dabei durch die Angabe eines Typs genannt, der Supertyp des tats\u00e4chlichen Typparameters sein muss (eine obere Schranke). Dadurch wird garantiert, dass der tats\u00e4chliche Typparameter alle in der Schranke vereinten Eigenschaften besitzt.", "paragraph_answer": "Um <hl> Bedingungen auszudr\u00fccken, die der tats\u00e4chliche Typparameter, also der f\u00fcr die Typvariable eingesetzte Typ, einhalten muss <hl>. Die Bedingung wird dabei durch die Angabe eines Typs genannt, der Supertyp des tats\u00e4chlichen Typparameters sein muss (eine obere Schranke). Dadurch wird garantiert, dass der tats\u00e4chliche Typparameter alle in der Schranke vereinten Eigenschaften besitzt.", "sentence_answer": "Um <hl> Bedingungen auszudr\u00fccken, die der tats\u00e4chliche Typparameter, also der f\u00fcr die Typvariable eingesetzte Typ, einhalten muss <hl>."}
{"question": "Was sind die Nachteile des Subtyping Eiffels!", "paragraph": "Eiffel erlaubt Kovarianz bei Parametertypen und Feldern, was die Substituierbarkeit einschr\u00e4nkt und im Gegensatz zur Vererbung der Vorbedingungen steht, die zu einer Kontravarianz (schw\u00e4chere Vorbedingungen der in Subtypen \u00fcberschriebenen Methoden) f\u00fchrt.", "answer": "Substituierbarkeit einschr\u00e4nkt und im Gegensatz zur Vererbung der Vorbedingungen steht", "sentence": "Eiffel erlaubt Kovarianz bei Parametertypen und Feldern, was die Substituierbarkeit einschr\u00e4nkt und im Gegensatz zur Vererbung der Vorbedingungen steht, die zu einer Kontravarianz (schw\u00e4chere Vorbedingungen der in Subtypen \u00fcberschriebenen Methoden) f\u00fchrt.", "paragraph_sentence": "<hl> Eiffel erlaubt Kovarianz bei Parametertypen und Feldern, was die Substituierbarkeit einschr\u00e4nkt und im Gegensatz zur Vererbung der Vorbedingungen steht, die zu einer Kontravarianz (schw\u00e4chere Vorbedingungen der in Subtypen \u00fcberschriebenen Methoden) f\u00fchrt. <hl>", "paragraph_answer": "Eiffel erlaubt Kovarianz bei Parametertypen und Feldern, was die <hl> Substituierbarkeit einschr\u00e4nkt und im Gegensatz zur Vererbung der Vorbedingungen steht <hl>, die zu einer Kontravarianz (schw\u00e4chere Vorbedingungen der in Subtypen \u00fcberschriebenen Methoden) f\u00fchrt.", "sentence_answer": "Eiffel erlaubt Kovarianz bei Parametertypen und Feldern, was die <hl> Substituierbarkeit einschr\u00e4nkt und im Gegensatz zur Vererbung der Vorbedingungen steht <hl>, die zu einer Kontravarianz (schw\u00e4chere Vorbedingungen der in Subtypen \u00fcberschriebenen Methoden) f\u00fchrt."}
{"question": "Wie lautet das Gesetz Demeters?", "paragraph": "Sprich nicht mit Fremden - jedes Objekt soll nur auf Objekte zugreifen, die es selbst kennt, auf die also seine eigenen Instanzvariablen (oder die Parameter seiner Methoden) verweisen. Insbesondere sog. Kettenaufrufe sind nach dem Gesetz Demeters nicht erlaubt. Das Gesetz hat jedoch enge praktische Grenzen.", "answer": "Sprich nicht mit Fremden", "sentence": "Sprich nicht mit Fremden - jedes Objekt soll nur auf Objekte zugreifen, die es selbst kennt, auf die also seine eigenen Instanzvariablen (oder die Parameter seiner Methoden) verweisen.", "paragraph_sentence": "<hl> Sprich nicht mit Fremden - jedes Objekt soll nur auf Objekte zugreifen, die es selbst kennt, auf die also seine eigenen Instanzvariablen (oder die Parameter seiner Methoden) verweisen. <hl> Insbesondere sog. Kettenaufrufe sind nach dem Gesetz Demeters nicht erlaubt. Das Gesetz hat jedoch enge praktische Grenzen.", "paragraph_answer": "<hl> Sprich nicht mit Fremden <hl> - jedes Objekt soll nur auf Objekte zugreifen, die es selbst kennt, auf die also seine eigenen Instanzvariablen (oder die Parameter seiner Methoden) verweisen. Insbesondere sog. Kettenaufrufe sind nach dem Gesetz Demeters nicht erlaubt. Das Gesetz hat jedoch enge praktische Grenzen.", "sentence_answer": "<hl> Sprich nicht mit Fremden <hl> - jedes Objekt soll nur auf Objekte zugreifen, die es selbst kennt, auf die also seine eigenen Instanzvariablen (oder die Parameter seiner Methoden) verweisen."}