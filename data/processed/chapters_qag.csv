paragraph,answer-question
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.","<answer> Zugriffsmethoden in EIFFEL sind Methoden, die verwendet werden, um auf private Instanzvariablen (Attribute) zuzugreifen. Sie dienen dazu, den Zugriff auf diese Variablen zu kontrollieren und bieten die Möglichkeit, Vor- und Nachbedingungen festzulegen. <answer> <question> Was sind Zugriffsmethoden in EIFFEL und wofür werden sie verwendet? <question>"
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.","<answer> Zugriffsmethoden in EIFFEL sehen syntaktisch aus wie Variablen, können jedoch Funktionen (Setter) oder Funktionen (Getter) sein. Sie können verwendet werden, um Werte zu setzen oder zu lesen. <answer> <question> Wie werden Zugriffsmethoden in EIFFEL syntaktisch dargestellt? <question>"
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.","<answer> Neben dem Lesen und Setzen von Instanzvariablen können Zugriffsmethoden in EIFFEL auch andere Aufgaben erfüllen, wie das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen. <answer> <question> Welche Aufgaben können Zugriffsmethoden in EIFFEL erfüllen? <question>"
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.","<answer> In EIFFEL werden Methoden einer Klasse als ""Abfragen"" (queries) und ""Befehle"" (commands) logisch unterteilt. Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. <answer> <question> Wie werden in EIFFEL Abfragen und Befehle logisch unterteilt? <question>"
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.","<answer> In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als ""Features"" bezeichnet. Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. <answer> <question> Was sind Features in EIFFEL und wie werden sie zusammengefasst? <question>"
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.","<answer> Nein, es gibt in EIFFEL keine Zugriffsmodifikatoren wie in JAVA oder C++. Alle Features sind standardmäßig öffentlich zugänglich. <answer> <question> Gibt es in EIFFEL Zugriffsmodifikatoren wie in JAVA oder C++? <question>"
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.","<answer> In EIFFEL wird der Zugriff auf Features durch die gezielte Veröffentlichung (Export) von Features gesteuert. Klassen, die auf diese Features zugreifen sollen, werden explizit genannt. <answer> <question> Wie wird der Zugriff auf Features in EIFFEL kontrolliert? <question>"
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.","<answer> Die Definition einer Schnittstelle in EIFFEL ist recht unspezifisch. Alle Klienten einer Klasse haben standardmäßig das gleiche Bild von ihr. Statt den Zugriff an Pakete oder Freunde zu binden, bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (exportieren). <answer> <question> Was ist das Besondere an der Definition einer Schnittstelle in EIFFEL? <question>"
"Wie bereits in Kapitel 21 angedeutet, verlangt die Zuweisungskompatibilität nicht unbedingt Typäquivalenz. Tatsächlich reicht es aus, bei einer rein strukturellen (syntaktischen) Betrachtung, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält, um in der Folge Typfehler zu vermeiden. Anders ausgedrückt: Der Typ auf der rechten Seite einer Zuweisung darf eine Erweiterung dessen auf der linken Seite um zusätzliche Methoden sein.
Die sogenannte Typerweiterung (engl. type extension; ""extension"" hier im Sinne von Erweiterung und nicht im Sinne der Ausdehnung als Gegenstück zur Intension; vgl. Abschnitt 7.1 in Kurseinheit 2), wie sie z. B. in den Programmiersprachen MODULA-3 und OBERON (beides Nachfolger von PASCAL) Verwendung findet, sieht genau dies vor.
Der erweiternde Typ, hier InternationalesBüro, wird also relativ zu einem bereits bestehenden, dem erweiterten Typ (hier Büro), definiert. Die Methodendeklarationen des erweiterten Typs werden dabei gewissermaßen an den erweiternden Typ vererbt; dieser braucht sie also nicht noch einmal zu wiederholen.
Wie man nun leicht einsieht, können Variablen, deren deklarierter Typ Büro ist, auch Objekte vom Typ InternationalesBüro enthalten, ohne dass dies zu Typfehlern führt, da alle Methoden, die für Büro vorgesehen sind, auch in InternationalesBüro vorkommen. Das Umgekehrte ist jedoch nicht der Fall: Wenn man einer Variable vom Typ InternationalesBüro ein Objekt vom Typ Büro zuweisen könnte, dann hätte man immer dann ein Problem, wenn man über diese Variable auf dessen Methoden zum Länderkennzeichen zugreifen wollte, weil diese schlichtweg für das Objekt nicht definiert sind. Die Zuweisungskompatibilität unter Typerweiterung regelt der Begriff der Typkonformität.","<answer> Um Typfehler bei Zuweisungen zu vermeiden, ist es ausreichend, dass der Typ auf der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs auf der linken Seite enthält. <answer> <question> Welche Anforderungen müssen erfüllt sein, um Typfehler bei Zuweisungen zu vermeiden? <question>"
"Wie bereits in Kapitel 21 angedeutet, verlangt die Zuweisungskompatibilität nicht unbedingt Typäquivalenz. Tatsächlich reicht es aus, bei einer rein strukturellen (syntaktischen) Betrachtung, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält, um in der Folge Typfehler zu vermeiden. Anders ausgedrückt: Der Typ auf der rechten Seite einer Zuweisung darf eine Erweiterung dessen auf der linken Seite um zusätzliche Methoden sein.
Die sogenannte Typerweiterung (engl. type extension; ""extension"" hier im Sinne von Erweiterung und nicht im Sinne der Ausdehnung als Gegenstück zur Intension; vgl. Abschnitt 7.1 in Kurseinheit 2), wie sie z. B. in den Programmiersprachen MODULA-3 und OBERON (beides Nachfolger von PASCAL) Verwendung findet, sieht genau dies vor.
Der erweiternde Typ, hier InternationalesBüro, wird also relativ zu einem bereits bestehenden, dem erweiterten Typ (hier Büro), definiert. Die Methodendeklarationen des erweiterten Typs werden dabei gewissermaßen an den erweiternden Typ vererbt; dieser braucht sie also nicht noch einmal zu wiederholen.
Wie man nun leicht einsieht, können Variablen, deren deklarierter Typ Büro ist, auch Objekte vom Typ InternationalesBüro enthalten, ohne dass dies zu Typfehlern führt, da alle Methoden, die für Büro vorgesehen sind, auch in InternationalesBüro vorkommen. Das Umgekehrte ist jedoch nicht der Fall: Wenn man einer Variable vom Typ InternationalesBüro ein Objekt vom Typ Büro zuweisen könnte, dann hätte man immer dann ein Problem, wenn man über diese Variable auf dessen Methoden zum Länderkennzeichen zugreifen wollte, weil diese schlichtweg für das Objekt nicht definiert sind. Die Zuweisungskompatibilität unter Typerweiterung regelt der Begriff der Typkonformität.","<answer> Typerweiterung (englisch: type extension) erlaubt, dass der Typ auf der rechten Seite einer Zuweisung eine Erweiterung des Typs auf der linken Seite um zusätzliche Methoden ist. Sie wird in Programmiersprachen wie MODULA-3 und OBERON verwendet. <answer> <question> Was ist Typerweiterung, und in welchen Programmiersprachen wird sie verwendet? <question>"
"Wie bereits in Kapitel 21 angedeutet, verlangt die Zuweisungskompatibilität nicht unbedingt Typäquivalenz. Tatsächlich reicht es aus, bei einer rein strukturellen (syntaktischen) Betrachtung, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält, um in der Folge Typfehler zu vermeiden. Anders ausgedrückt: Der Typ auf der rechten Seite einer Zuweisung darf eine Erweiterung dessen auf der linken Seite um zusätzliche Methoden sein.
Die sogenannte Typerweiterung (engl. type extension; ""extension"" hier im Sinne von Erweiterung und nicht im Sinne der Ausdehnung als Gegenstück zur Intension; vgl. Abschnitt 7.1 in Kurseinheit 2), wie sie z. B. in den Programmiersprachen MODULA-3 und OBERON (beides Nachfolger von PASCAL) Verwendung findet, sieht genau dies vor.
Der erweiternde Typ, hier InternationalesBüro, wird also relativ zu einem bereits bestehenden, dem erweiterten Typ (hier Büro), definiert. Die Methodendeklarationen des erweiterten Typs werden dabei gewissermaßen an den erweiternden Typ vererbt; dieser braucht sie also nicht noch einmal zu wiederholen.
Wie man nun leicht einsieht, können Variablen, deren deklarierter Typ Büro ist, auch Objekte vom Typ InternationalesBüro enthalten, ohne dass dies zu Typfehlern führt, da alle Methoden, die für Büro vorgesehen sind, auch in InternationalesBüro vorkommen. Das Umgekehrte ist jedoch nicht der Fall: Wenn man einer Variable vom Typ InternationalesBüro ein Objekt vom Typ Büro zuweisen könnte, dann hätte man immer dann ein Problem, wenn man über diese Variable auf dessen Methoden zum Länderkennzeichen zugreifen wollte, weil diese schlichtweg für das Objekt nicht definiert sind. Die Zuweisungskompatibilität unter Typerweiterung regelt der Begriff der Typkonformität.","<answer> Typerweiterung definiert einen neuen Typ relativ zu einem bereits bestehenden, dem erweiterten Typ. Die Methodendeklarationen des erweiterten Typs werden an den erweiternden Typ vererbt, sodass sie nicht erneut deklariert werden müssen. <answer> <question> Wie wird Typerweiterung in Bezug auf bereits existierende Typen definiert? <question>"
"Wie bereits in Kapitel 21 angedeutet, verlangt die Zuweisungskompatibilität nicht unbedingt Typäquivalenz. Tatsächlich reicht es aus, bei einer rein strukturellen (syntaktischen) Betrachtung, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält, um in der Folge Typfehler zu vermeiden. Anders ausgedrückt: Der Typ auf der rechten Seite einer Zuweisung darf eine Erweiterung dessen auf der linken Seite um zusätzliche Methoden sein.
Die sogenannte Typerweiterung (engl. type extension; ""extension"" hier im Sinne von Erweiterung und nicht im Sinne der Ausdehnung als Gegenstück zur Intension; vgl. Abschnitt 7.1 in Kurseinheit 2), wie sie z. B. in den Programmiersprachen MODULA-3 und OBERON (beides Nachfolger von PASCAL) Verwendung findet, sieht genau dies vor.
Der erweiternde Typ, hier InternationalesBüro, wird also relativ zu einem bereits bestehenden, dem erweiterten Typ (hier Büro), definiert. Die Methodendeklarationen des erweiterten Typs werden dabei gewissermaßen an den erweiternden Typ vererbt; dieser braucht sie also nicht noch einmal zu wiederholen.
Wie man nun leicht einsieht, können Variablen, deren deklarierter Typ Büro ist, auch Objekte vom Typ InternationalesBüro enthalten, ohne dass dies zu Typfehlern führt, da alle Methoden, die für Büro vorgesehen sind, auch in InternationalesBüro vorkommen. Das Umgekehrte ist jedoch nicht der Fall: Wenn man einer Variable vom Typ InternationalesBüro ein Objekt vom Typ Büro zuweisen könnte, dann hätte man immer dann ein Problem, wenn man über diese Variable auf dessen Methoden zum Länderkennzeichen zugreifen wollte, weil diese schlichtweg für das Objekt nicht definiert sind. Die Zuweisungskompatibilität unter Typerweiterung regelt der Begriff der Typkonformität.","<answer> Typkonformität regelt die Zuweisungskompatibilität unter Typerweiterung. Es bedeutet, dass Variablen, deren deklarierter Typ ein erweiterter Typ ist, auch Objekte des ursprünglichen Typs enthalten können, ohne zu Typfehlern zu führen. Die umgekehrte Zuweisung, bei der ein Objekt des ursprünglichen Typs einer Variable mit dem erweiterten Typ zugewiesen wird, kann jedoch Probleme verursachen, wenn auf Methoden des erweiterten Typs zugegriffen wird, die für das Objekt nicht definiert sind. <answer> <question> Was bedeutet Typkonformität in Bezug auf Typerweiterung? <question>"
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.","<answer> Der ""Inhalt"" eines Objekts oder einer Variable bezieht sich auf das Objekt, das von der Variable bezeichnet wird. <answer> <question> Was wird mit ""Inhalt"" eines Objekts oder einer Variable gemeint? <question>"
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.","<answer> Variablen mit Verweissemantik haben Verweise (auch Referenzen oder Pointer genannt) auf Objekte, anstatt den Inhalt selbst zu speichern. <answer> <question> Welche Semantik wird verwendet, wenn Variablen Verweise auf Objekte haben? <question>"
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.","<answer> Unter Wertsemantik können zwei Variablen niemals dasselbe Objekt bezeichnen, während Verweissemantik erlaubt, dass mehrere Variablen auf dasselbe Objekt verweisen. <answer> <question> Wie unterscheiden sich Verweissemantik und Wertsemantik von Variablen? <question>"
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.","<answer> Verweissemantik wird in der objektorientierten Programmierung häufig verwendet, da sie einen effizienteren Umgang mit Objekten ermöglicht und unterschiedliche Objekte unterschiedlich viel Speicherplatz belegen. <answer> <question> Warum wird in der objektorientierten Programmierung in der Regel Verweissemantik verwendet? <question>"
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.","<answer> In einigen objektorientierten Sprachen wie C++ und EIFFEL können Programmierer festlegen, ob Variablen Wert- oder Verweissemantik haben sollen. <answer> <question> In welchen objektorientierten Programmiersprachen können Programmierer festlegen, ob Variablen Wert- oder Verweissemantik haben sollen? <question>"
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.","<answer> In den meisten SMALLTALK-Implementationen haben diese Variablen Wertsemantik, um Speicherplatz zu sparen, obwohl der Begriff der Identität für diese Objekte verloren geht. Die mehrfache Existenz identischer Objekte im Speicher hat in der Regel keine große Bedeutung, da Gleichheit an die Stelle der Identität treten kann. <answer> <question> Warum haben in den meisten SMALLTALK-Implementationen Variablen, die Zeichen, kleine Zahlen und boolesche Werte bezeichnen, Wertsemantik? <question>"
"Mithilfe von Metaklassen lassen sich in SMALLTALK auf natürliche Art und Weise sogenannte Konstruktoren definieren. Ein Konstruktor ist eine Methode, die, wenn sie auf einer Klasse aufgerufen wird, eine neue Instanz dieser Klasse zurückgibt (es handelt sich also aus Sicht der Instanzen der Klasse um eine Klassenmethode). Wir haben bereits zwei Konstruktoren in SMALLTALK kennengelernt: Sie werden über die Selektoren ""new"" (für Objekte ohne indizierte Instanzvariablen) und ""new:"" (für Objekte mit indizierten Instanzvariablen) aufgerufen.
Da Klassen selbst Objekte sind, sind ""new"" und ""new:"" Instanzmethoden der Klassen. Dabei sind ""basicNew"" und ""basicNew:"" ebenfalls Instanzmethoden der Klasse, deren Implementierung allerdings primitiv ist (siehe Abschnitt 4.3.7 in Kurseinheit 1). Sie geben eine neue Instanz (ein neues Objekt) der Klasse, auf der sie aufgerufen wurden, zurück. Da durch ""basicNew"" und ""basicNew:"" alle Instanzvariablen der erzeugten Objekte den Wert ""nil"" zugewiesen bekommen, wird auf den neuen Objekten vor ihrer Rückgabe die Methode ""initialize"" aufgerufen. ""Initialize"" ist eine Instanzmethode des neuen Objekts, die die Instanzvariablen je nach Klasse, in der die Methode definiert ist, anders belegt.","<answer> In SMALLTALK sind Konstruktoren Methoden, die, wenn sie auf einer Klasse aufgerufen werden, eine neue Instanz dieser Klasse erstellen und zurückgeben. Sie sind Klassenmethoden, die dazu dienen, neue Objekte zu erzeugen. <answer> <question> Was sind Konstruktoren in SMALLTALK? <question>"
"Mithilfe von Metaklassen lassen sich in SMALLTALK auf natürliche Art und Weise sogenannte Konstruktoren definieren. Ein Konstruktor ist eine Methode, die, wenn sie auf einer Klasse aufgerufen wird, eine neue Instanz dieser Klasse zurückgibt (es handelt sich also aus Sicht der Instanzen der Klasse um eine Klassenmethode). Wir haben bereits zwei Konstruktoren in SMALLTALK kennengelernt: Sie werden über die Selektoren ""new"" (für Objekte ohne indizierte Instanzvariablen) und ""new:"" (für Objekte mit indizierten Instanzvariablen) aufgerufen.
Da Klassen selbst Objekte sind, sind ""new"" und ""new:"" Instanzmethoden der Klassen. Dabei sind ""basicNew"" und ""basicNew:"" ebenfalls Instanzmethoden der Klasse, deren Implementierung allerdings primitiv ist (siehe Abschnitt 4.3.7 in Kurseinheit 1). Sie geben eine neue Instanz (ein neues Objekt) der Klasse, auf der sie aufgerufen wurden, zurück. Da durch ""basicNew"" und ""basicNew:"" alle Instanzvariablen der erzeugten Objekte den Wert ""nil"" zugewiesen bekommen, wird auf den neuen Objekten vor ihrer Rückgabe die Methode ""initialize"" aufgerufen. ""Initialize"" ist eine Instanzmethode des neuen Objekts, die die Instanzvariablen je nach Klasse, in der die Methode definiert ist, anders belegt.","<answer> Die Methoden ""basicNew"" und ""basicNew:"" sind Instanzmethoden der Klasse, die eine neue Instanz (ein neues Objekt) der Klasse erstellen und zurückgeben. Sie weisen allen Instanzvariablen der erzeugten Objekte den Wert ""nil"" zu. Bevor die Objekte zurückgegeben werden, wird die Methode ""initialize"" auf ihnen aufgerufen, um die Instanzvariablen je nach Klasse anders zu belegen. <answer> <question> Was bewirken die Methoden ""basicNew"" und ""basicNew:"" in den Konstruktoren? <question>"
"Da in SMALLTALK auch eine Klasse ein Objekt ist, kann die Klasse selbst, genau wie alle anderen Objekte, Instanzvariablen und -methoden haben. Aber wo werden diese definiert? Der Analogie der Objekte, die Instanzen der Klasse sind, folgend müsste das in der jeweiligen Klasse der Klasse, also der Klasse, von der die Klasse (als Objekt) eine Instanz ist, erfolgen. Und so ist es tatsächlich auch.
Zunächst könnte man annehmen, dass alle Klassen Instanzen einer speziellen Klasse, nennen wir sie ""Class"", sind. Jede Klasse hätte dann (als Instanz dieser Klasse) die Instanzvariablen und Methoden, die in ""Class"" definiert sind. Insbesondere hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden. Dies scheint zunächst auch sinnvoll, denn bei den Klassen handelt es sich ja um Objekte derselben Art, nämlich einheitlich um Klassen.
Es stellt sich dann die Frage, welche Instanzvariablen und Methoden alle Klassen gleichermaßen charakterisieren könnten. Es könnte z. B. jede Klasse eine Instanzvariable haben, die alle von der Klasse instanziierten Objekte enthält, sowie eine weitere, die diese Objekte zählt. Eine typische Methode jeder Klasse wäre z. B. ""new"", die eine neue Instanz dieser Klasse zurückgibt. Was aber, wenn man weitere Eigenschaften (Instanzvariablen oder Methoden) für eine Klasse haben möchte, die diese nicht mit allen anderen teilt? Was, wenn man eine Methode wie z. B. ""new"" für eine Klasse anders definieren will als für andere? Im Fall von ""new"" z. B. ist es denkbar, dass man sie für bestimmte Klassen so umschreiben möchte, dass die Instanzvariablen der neu erzeugten Instanzen bestimmte Startwerte zugewiesen bekommen (so wie es beim Beispiel mit ""Stack"" oben der Fall wäre).
Tatsächlich hat die Programmierpraxis gezeigt, dass es günstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu müssen. Um dies zu ermöglichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können. Und genau das ist in SMALLTALK der Fall.
Zu jeder Klasse des SMALLTALK-Systems gehört nämlich genau eine Klasse, von der erstere (und nur diese) eine Instanz ist. Diese zweite Klasse wird Metaklasse der ersten genannt. Da eine 1:1-Beziehung zwischen Klassen und ihren Metaklassen besteht, ist es nicht sinnvoll, ihre Benennung den Programmiererinnen zu überlassen; sie wird in SMALLTALK stets durch den Ausdruck ""<Klassenname> class"", also beispielsweise ""Stack class"", bezeichnet. Daraus folgt bereits, dass die Programmiererin die Metaklasse nicht selbst anlegen muss (denn dabei müsste sie ja auch einen Namen vergeben) — sie wird vielmehr automatisch mit angelegt, wenn die Programmiererin eine neue Klasse definiert.
Im Prinzip ist die Definition einer Metaklasse genauso aufgebaut wie die einer normalen Klasse: Sie besteht aus der Angabe einer Menge von benannten Instanzvariablen und einer Menge von Instanzmethodendefinitionen. Lediglich indizierte Instanzvariablen sind nicht vorgesehen, und der Klassenname kann wie gesagt nicht frei angegeben werden.
Für die Implementierung der Methode ""new"" fehlt uns noch etwas; sie wird im nächsten Abschnitt nachgeliefert. Hier ist wichtig, dass Sie verstehen, dass ""new"" eine Instanzmethode der Metaklasse ""Stack class"" ist und damit das Verhalten der Klasse ""Stack"" bestimmt und nicht ihrer Objekte.
Aufgrund der bestehenden 1:1-Beziehung zwischen Klassen und Metaklassen werden diese in SMALLTALK nicht getrennt voneinander definiert, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt demnach neben den Abschnitten zur Deklaration der Instanzvariablen und zur Definition der Methoden auch noch über zwei Abschnitte für die entsprechenden Angaben zur ihrer Metaklasse, die Angabe der sogenannten Klassenvariablen und -methoden: Es sind dies die Variablen bzw. Methoden, die den Klassen als Instanzen ihrer Metaklassen zugeordnet sind.
Klassenvariablen sind übrigens relativ zu den Instanzen der Klassen global; sie beginnen deswegen mit einem Großbuchstaben. Klassenmethoden schreibt man jedoch wie Instanzmethoden klein. Beachten Sie, dass Klassenvariablen nur einmal pro Klasse angelegt werden — sie sind also für alle Instanzen einer Klasse dieselben.
Ein Beispiel für eine Klassenvariable ist ""Dependents Fields"" in der Klasse ""Object"" (zu ihrer Verwendung s. Abschnitt 14.3), eins für eine Klassenmethode ist ""pi"" in der Klasse ""Float"":
Sie retourniert (den Inhalt der) Klassenvariable ""Pi"" und ist, da sie eine Klassenmethode ist, allen Instanzen der Klasse ""Float"" zugeordnet. Dazu, wie der Wert in ""Pi"" hineinkommt, s. Abschnitt 8.2.
Wir sehen also, dass die Bezeichnungen Klassenvariable bzw. -methode und Instanzvariable bzw. -methode eigentlich nur relative Bedeutung haben, da es sich in beiden Fällen um Variablen und Methoden handelt, die Objekten zugeordnet sind. Da man von Instanzen einer Klasse aus aber auch häufiger auf die Variablen und Methoden ihrer Klassen zugreift, ist es guter Brauch (und vermeidet umständliche Formulierungen), stets die längeren Bezeichnungen zu führen. Zudem gibt es neben Instanz- und Klassenvariablen ja auch noch andere Variabletypen (formale Parameter und temporäre Variablen), so dass die Verwendung von „Variable“ allein meist mehrdeutig wäre. Lediglich bei Methoden hat es sich eingebürgert, anstelle von Instanzmethoden nur von Methoden zu sprechen. Wenn der Kontext nichts anderes nahelegt, können Sie dann immer davon ausgehen, dass Instanzmethoden gemeint sind.","<answer> Klassen in SMALLTALK benötigen ihre eigenen Metaklassen, damit sie ihre eigenen Instanzvariablen und Methoden definieren können, ohne die Definitionen anderer Klassen zu beeinflussen. Dies ermöglicht eine hohe Flexibilität und erlaubt es den Programmierern, das Verhalten von Klassen individuell anzupassen. <answer> <question> Warum benötigen Klassen in SMALLTALK ihre eigenen Metaklassen? <question>"
"Da in SMALLTALK auch eine Klasse ein Objekt ist, kann die Klasse selbst, genau wie alle anderen Objekte, Instanzvariablen und -methoden haben. Aber wo werden diese definiert? Der Analogie der Objekte, die Instanzen der Klasse sind, folgend müsste das in der jeweiligen Klasse der Klasse, also der Klasse, von der die Klasse (als Objekt) eine Instanz ist, erfolgen. Und so ist es tatsächlich auch.
Zunächst könnte man annehmen, dass alle Klassen Instanzen einer speziellen Klasse, nennen wir sie ""Class"", sind. Jede Klasse hätte dann (als Instanz dieser Klasse) die Instanzvariablen und Methoden, die in ""Class"" definiert sind. Insbesondere hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden. Dies scheint zunächst auch sinnvoll, denn bei den Klassen handelt es sich ja um Objekte derselben Art, nämlich einheitlich um Klassen.
Es stellt sich dann die Frage, welche Instanzvariablen und Methoden alle Klassen gleichermaßen charakterisieren könnten. Es könnte z. B. jede Klasse eine Instanzvariable haben, die alle von der Klasse instanziierten Objekte enthält, sowie eine weitere, die diese Objekte zählt. Eine typische Methode jeder Klasse wäre z. B. ""new"", die eine neue Instanz dieser Klasse zurückgibt. Was aber, wenn man weitere Eigenschaften (Instanzvariablen oder Methoden) für eine Klasse haben möchte, die diese nicht mit allen anderen teilt? Was, wenn man eine Methode wie z. B. ""new"" für eine Klasse anders definieren will als für andere? Im Fall von ""new"" z. B. ist es denkbar, dass man sie für bestimmte Klassen so umschreiben möchte, dass die Instanzvariablen der neu erzeugten Instanzen bestimmte Startwerte zugewiesen bekommen (so wie es beim Beispiel mit ""Stack"" oben der Fall wäre).
Tatsächlich hat die Programmierpraxis gezeigt, dass es günstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu müssen. Um dies zu ermöglichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können. Und genau das ist in SMALLTALK der Fall.
Zu jeder Klasse des SMALLTALK-Systems gehört nämlich genau eine Klasse, von der erstere (und nur diese) eine Instanz ist. Diese zweite Klasse wird Metaklasse der ersten genannt. Da eine 1:1-Beziehung zwischen Klassen und ihren Metaklassen besteht, ist es nicht sinnvoll, ihre Benennung den Programmiererinnen zu überlassen; sie wird in SMALLTALK stets durch den Ausdruck ""<Klassenname> class"", also beispielsweise ""Stack class"", bezeichnet. Daraus folgt bereits, dass die Programmiererin die Metaklasse nicht selbst anlegen muss (denn dabei müsste sie ja auch einen Namen vergeben) — sie wird vielmehr automatisch mit angelegt, wenn die Programmiererin eine neue Klasse definiert.
Im Prinzip ist die Definition einer Metaklasse genauso aufgebaut wie die einer normalen Klasse: Sie besteht aus der Angabe einer Menge von benannten Instanzvariablen und einer Menge von Instanzmethodendefinitionen. Lediglich indizierte Instanzvariablen sind nicht vorgesehen, und der Klassenname kann wie gesagt nicht frei angegeben werden.
Für die Implementierung der Methode ""new"" fehlt uns noch etwas; sie wird im nächsten Abschnitt nachgeliefert. Hier ist wichtig, dass Sie verstehen, dass ""new"" eine Instanzmethode der Metaklasse ""Stack class"" ist und damit das Verhalten der Klasse ""Stack"" bestimmt und nicht ihrer Objekte.
Aufgrund der bestehenden 1:1-Beziehung zwischen Klassen und Metaklassen werden diese in SMALLTALK nicht getrennt voneinander definiert, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt demnach neben den Abschnitten zur Deklaration der Instanzvariablen und zur Definition der Methoden auch noch über zwei Abschnitte für die entsprechenden Angaben zur ihrer Metaklasse, die Angabe der sogenannten Klassenvariablen und -methoden: Es sind dies die Variablen bzw. Methoden, die den Klassen als Instanzen ihrer Metaklassen zugeordnet sind.
Klassenvariablen sind übrigens relativ zu den Instanzen der Klassen global; sie beginnen deswegen mit einem Großbuchstaben. Klassenmethoden schreibt man jedoch wie Instanzmethoden klein. Beachten Sie, dass Klassenvariablen nur einmal pro Klasse angelegt werden — sie sind also für alle Instanzen einer Klasse dieselben.
Ein Beispiel für eine Klassenvariable ist ""Dependents Fields"" in der Klasse ""Object"" (zu ihrer Verwendung s. Abschnitt 14.3), eins für eine Klassenmethode ist ""pi"" in der Klasse ""Float"":
Sie retourniert (den Inhalt der) Klassenvariable ""Pi"" und ist, da sie eine Klassenmethode ist, allen Instanzen der Klasse ""Float"" zugeordnet. Dazu, wie der Wert in ""Pi"" hineinkommt, s. Abschnitt 8.2.
Wir sehen also, dass die Bezeichnungen Klassenvariable bzw. -methode und Instanzvariable bzw. -methode eigentlich nur relative Bedeutung haben, da es sich in beiden Fällen um Variablen und Methoden handelt, die Objekten zugeordnet sind. Da man von Instanzen einer Klasse aus aber auch häufiger auf die Variablen und Methoden ihrer Klassen zugreift, ist es guter Brauch (und vermeidet umständliche Formulierungen), stets die längeren Bezeichnungen zu führen. Zudem gibt es neben Instanz- und Klassenvariablen ja auch noch andere Variabletypen (formale Parameter und temporäre Variablen), so dass die Verwendung von „Variable“ allein meist mehrdeutig wäre. Lediglich bei Methoden hat es sich eingebürgert, anstelle von Instanzmethoden nur von Methoden zu sprechen. Wenn der Kontext nichts anderes nahelegt, können Sie dann immer davon ausgehen, dass Instanzmethoden gemeint sind.","<answer> In SMALLTALK werden Metaklassen automatisch erstellt, wenn eine neue Klasse definiert wird. Jede Klasse hat automatisch ihre eigene Metaklasse, die die Definitionen von Instanzvariablen und Methoden für diese Klasse enthält. <answer> <question> Wie werden Metaklassen in SMALLTALK erstellt? <question>"
"Da in SMALLTALK auch eine Klasse ein Objekt ist, kann die Klasse selbst, genau wie alle anderen Objekte, Instanzvariablen und -methoden haben. Aber wo werden diese definiert? Der Analogie der Objekte, die Instanzen der Klasse sind, folgend müsste das in der jeweiligen Klasse der Klasse, also der Klasse, von der die Klasse (als Objekt) eine Instanz ist, erfolgen. Und so ist es tatsächlich auch.
Zunächst könnte man annehmen, dass alle Klassen Instanzen einer speziellen Klasse, nennen wir sie ""Class"", sind. Jede Klasse hätte dann (als Instanz dieser Klasse) die Instanzvariablen und Methoden, die in ""Class"" definiert sind. Insbesondere hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden. Dies scheint zunächst auch sinnvoll, denn bei den Klassen handelt es sich ja um Objekte derselben Art, nämlich einheitlich um Klassen.
Es stellt sich dann die Frage, welche Instanzvariablen und Methoden alle Klassen gleichermaßen charakterisieren könnten. Es könnte z. B. jede Klasse eine Instanzvariable haben, die alle von der Klasse instanziierten Objekte enthält, sowie eine weitere, die diese Objekte zählt. Eine typische Methode jeder Klasse wäre z. B. ""new"", die eine neue Instanz dieser Klasse zurückgibt. Was aber, wenn man weitere Eigenschaften (Instanzvariablen oder Methoden) für eine Klasse haben möchte, die diese nicht mit allen anderen teilt? Was, wenn man eine Methode wie z. B. ""new"" für eine Klasse anders definieren will als für andere? Im Fall von ""new"" z. B. ist es denkbar, dass man sie für bestimmte Klassen so umschreiben möchte, dass die Instanzvariablen der neu erzeugten Instanzen bestimmte Startwerte zugewiesen bekommen (so wie es beim Beispiel mit ""Stack"" oben der Fall wäre).
Tatsächlich hat die Programmierpraxis gezeigt, dass es günstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu müssen. Um dies zu ermöglichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können. Und genau das ist in SMALLTALK der Fall.
Zu jeder Klasse des SMALLTALK-Systems gehört nämlich genau eine Klasse, von der erstere (und nur diese) eine Instanz ist. Diese zweite Klasse wird Metaklasse der ersten genannt. Da eine 1:1-Beziehung zwischen Klassen und ihren Metaklassen besteht, ist es nicht sinnvoll, ihre Benennung den Programmiererinnen zu überlassen; sie wird in SMALLTALK stets durch den Ausdruck ""<Klassenname> class"", also beispielsweise ""Stack class"", bezeichnet. Daraus folgt bereits, dass die Programmiererin die Metaklasse nicht selbst anlegen muss (denn dabei müsste sie ja auch einen Namen vergeben) — sie wird vielmehr automatisch mit angelegt, wenn die Programmiererin eine neue Klasse definiert.
Im Prinzip ist die Definition einer Metaklasse genauso aufgebaut wie die einer normalen Klasse: Sie besteht aus der Angabe einer Menge von benannten Instanzvariablen und einer Menge von Instanzmethodendefinitionen. Lediglich indizierte Instanzvariablen sind nicht vorgesehen, und der Klassenname kann wie gesagt nicht frei angegeben werden.
Für die Implementierung der Methode ""new"" fehlt uns noch etwas; sie wird im nächsten Abschnitt nachgeliefert. Hier ist wichtig, dass Sie verstehen, dass ""new"" eine Instanzmethode der Metaklasse ""Stack class"" ist und damit das Verhalten der Klasse ""Stack"" bestimmt und nicht ihrer Objekte.
Aufgrund der bestehenden 1:1-Beziehung zwischen Klassen und Metaklassen werden diese in SMALLTALK nicht getrennt voneinander definiert, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt demnach neben den Abschnitten zur Deklaration der Instanzvariablen und zur Definition der Methoden auch noch über zwei Abschnitte für die entsprechenden Angaben zur ihrer Metaklasse, die Angabe der sogenannten Klassenvariablen und -methoden: Es sind dies die Variablen bzw. Methoden, die den Klassen als Instanzen ihrer Metaklassen zugeordnet sind.
Klassenvariablen sind übrigens relativ zu den Instanzen der Klassen global; sie beginnen deswegen mit einem Großbuchstaben. Klassenmethoden schreibt man jedoch wie Instanzmethoden klein. Beachten Sie, dass Klassenvariablen nur einmal pro Klasse angelegt werden — sie sind also für alle Instanzen einer Klasse dieselben.
Ein Beispiel für eine Klassenvariable ist ""Dependents Fields"" in der Klasse ""Object"" (zu ihrer Verwendung s. Abschnitt 14.3), eins für eine Klassenmethode ist ""pi"" in der Klasse ""Float"":
Sie retourniert (den Inhalt der) Klassenvariable ""Pi"" und ist, da sie eine Klassenmethode ist, allen Instanzen der Klasse ""Float"" zugeordnet. Dazu, wie der Wert in ""Pi"" hineinkommt, s. Abschnitt 8.2.
Wir sehen also, dass die Bezeichnungen Klassenvariable bzw. -methode und Instanzvariable bzw. -methode eigentlich nur relative Bedeutung haben, da es sich in beiden Fällen um Variablen und Methoden handelt, die Objekten zugeordnet sind. Da man von Instanzen einer Klasse aus aber auch häufiger auf die Variablen und Methoden ihrer Klassen zugreift, ist es guter Brauch (und vermeidet umständliche Formulierungen), stets die längeren Bezeichnungen zu führen. Zudem gibt es neben Instanz- und Klassenvariablen ja auch noch andere Variabletypen (formale Parameter und temporäre Variablen), so dass die Verwendung von „Variable“ allein meist mehrdeutig wäre. Lediglich bei Methoden hat es sich eingebürgert, anstelle von Instanzmethoden nur von Methoden zu sprechen. Wenn der Kontext nichts anderes nahelegt, können Sie dann immer davon ausgehen, dass Instanzmethoden gemeint sind.","<answer> In einer Metaklasse können Informationen wie Instanzvariablen und Methoden für die zugehörige Klasse definiert werden. Dies ermöglicht es, das Verhalten und die Eigenschaften der Klasse individuell anzupassen. <answer> <question> Welche Informationen können in einer Metaklasse definiert werden? <question>"
"Da in SMALLTALK auch eine Klasse ein Objekt ist, kann die Klasse selbst, genau wie alle anderen Objekte, Instanzvariablen und -methoden haben. Aber wo werden diese definiert? Der Analogie der Objekte, die Instanzen der Klasse sind, folgend müsste das in der jeweiligen Klasse der Klasse, also der Klasse, von der die Klasse (als Objekt) eine Instanz ist, erfolgen. Und so ist es tatsächlich auch.
Zunächst könnte man annehmen, dass alle Klassen Instanzen einer speziellen Klasse, nennen wir sie ""Class"", sind. Jede Klasse hätte dann (als Instanz dieser Klasse) die Instanzvariablen und Methoden, die in ""Class"" definiert sind. Insbesondere hätte jede Klasse dieselbe Menge von Instanzvariablen und Methoden. Dies scheint zunächst auch sinnvoll, denn bei den Klassen handelt es sich ja um Objekte derselben Art, nämlich einheitlich um Klassen.
Es stellt sich dann die Frage, welche Instanzvariablen und Methoden alle Klassen gleichermaßen charakterisieren könnten. Es könnte z. B. jede Klasse eine Instanzvariable haben, die alle von der Klasse instanziierten Objekte enthält, sowie eine weitere, die diese Objekte zählt. Eine typische Methode jeder Klasse wäre z. B. ""new"", die eine neue Instanz dieser Klasse zurückgibt. Was aber, wenn man weitere Eigenschaften (Instanzvariablen oder Methoden) für eine Klasse haben möchte, die diese nicht mit allen anderen teilt? Was, wenn man eine Methode wie z. B. ""new"" für eine Klasse anders definieren will als für andere? Im Fall von ""new"" z. B. ist es denkbar, dass man sie für bestimmte Klassen so umschreiben möchte, dass die Instanzvariablen der neu erzeugten Instanzen bestimmte Startwerte zugewiesen bekommen (so wie es beim Beispiel mit ""Stack"" oben der Fall wäre).
Tatsächlich hat die Programmierpraxis gezeigt, dass es günstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu müssen. Um dies zu ermöglichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können. Und genau das ist in SMALLTALK der Fall.
Zu jeder Klasse des SMALLTALK-Systems gehört nämlich genau eine Klasse, von der erstere (und nur diese) eine Instanz ist. Diese zweite Klasse wird Metaklasse der ersten genannt. Da eine 1:1-Beziehung zwischen Klassen und ihren Metaklassen besteht, ist es nicht sinnvoll, ihre Benennung den Programmiererinnen zu überlassen; sie wird in SMALLTALK stets durch den Ausdruck ""<Klassenname> class"", also beispielsweise ""Stack class"", bezeichnet. Daraus folgt bereits, dass die Programmiererin die Metaklasse nicht selbst anlegen muss (denn dabei müsste sie ja auch einen Namen vergeben) — sie wird vielmehr automatisch mit angelegt, wenn die Programmiererin eine neue Klasse definiert.
Im Prinzip ist die Definition einer Metaklasse genauso aufgebaut wie die einer normalen Klasse: Sie besteht aus der Angabe einer Menge von benannten Instanzvariablen und einer Menge von Instanzmethodendefinitionen. Lediglich indizierte Instanzvariablen sind nicht vorgesehen, und der Klassenname kann wie gesagt nicht frei angegeben werden.
Für die Implementierung der Methode ""new"" fehlt uns noch etwas; sie wird im nächsten Abschnitt nachgeliefert. Hier ist wichtig, dass Sie verstehen, dass ""new"" eine Instanzmethode der Metaklasse ""Stack class"" ist und damit das Verhalten der Klasse ""Stack"" bestimmt und nicht ihrer Objekte.
Aufgrund der bestehenden 1:1-Beziehung zwischen Klassen und Metaklassen werden diese in SMALLTALK nicht getrennt voneinander definiert, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt demnach neben den Abschnitten zur Deklaration der Instanzvariablen und zur Definition der Methoden auch noch über zwei Abschnitte für die entsprechenden Angaben zur ihrer Metaklasse, die Angabe der sogenannten Klassenvariablen und -methoden: Es sind dies die Variablen bzw. Methoden, die den Klassen als Instanzen ihrer Metaklassen zugeordnet sind.
Klassenvariablen sind übrigens relativ zu den Instanzen der Klassen global; sie beginnen deswegen mit einem Großbuchstaben. Klassenmethoden schreibt man jedoch wie Instanzmethoden klein. Beachten Sie, dass Klassenvariablen nur einmal pro Klasse angelegt werden — sie sind also für alle Instanzen einer Klasse dieselben.
Ein Beispiel für eine Klassenvariable ist ""Dependents Fields"" in der Klasse ""Object"" (zu ihrer Verwendung s. Abschnitt 14.3), eins für eine Klassenmethode ist ""pi"" in der Klasse ""Float"":
Sie retourniert (den Inhalt der) Klassenvariable ""Pi"" und ist, da sie eine Klassenmethode ist, allen Instanzen der Klasse ""Float"" zugeordnet. Dazu, wie der Wert in ""Pi"" hineinkommt, s. Abschnitt 8.2.
Wir sehen also, dass die Bezeichnungen Klassenvariable bzw. -methode und Instanzvariable bzw. -methode eigentlich nur relative Bedeutung haben, da es sich in beiden Fällen um Variablen und Methoden handelt, die Objekten zugeordnet sind. Da man von Instanzen einer Klasse aus aber auch häufiger auf die Variablen und Methoden ihrer Klassen zugreift, ist es guter Brauch (und vermeidet umständliche Formulierungen), stets die längeren Bezeichnungen zu führen. Zudem gibt es neben Instanz- und Klassenvariablen ja auch noch andere Variabletypen (formale Parameter und temporäre Variablen), so dass die Verwendung von „Variable“ allein meist mehrdeutig wäre. Lediglich bei Methoden hat es sich eingebürgert, anstelle von Instanzmethoden nur von Methoden zu sprechen. Wenn der Kontext nichts anderes nahelegt, können Sie dann immer davon ausgehen, dass Instanzmethoden gemeint sind.","<answer> Die 1:1-Beziehung zwischen Klassen und ihren Metaklassen in SMALLTALK gewährleistet, dass jede Klasse ihre eigenen Instanzvariablen und Methoden definieren kann, ohne andere Klassen zu beeinflussen. Dadurch wird die Flexibilität und Unabhängigkeit der Klassen in SMALLTALK gewährleistet. <answer> <question> Warum gibt es eine 1:1-Beziehung zwischen Klassen und ihren Metaklassen in SMALLTALK? <question>"
"Abkürzungen sind nicht grundsätzlich zu vermeiden — im Gegenteil, wenn sie etabliert sind und man davon ausgehen darf, dass eine Leserin des Programms sie kennt, ist ihre Verwendung (aus den oben angeführten Gründen gegen zu lange Namen) sogar angezeigt. Auf hausgemachte Abkürzungen, deren Bedeutung nur von einem selbst bekannt ist, sollte man hingegen verzichten.
Bei der Programmierung mit JAVA und anderen typisierten objektorientierten Programmiersprachen begegnet man häufig dem Phänomen, dass Typen und Variablen gleich heißen, sich nur in der Groß- bzw. Kleinschreibung ihres Anfangsbuchstabens unterscheiden. Ein typisches Beispiel dafür ist das folgende:
In diesen Fällen, wenn es keinen besseren Namen für die Variable gibt, ist es vollkommen legitim, eine Abkürzung für den Variablennamen zu wählen, insbesondere dann, wenn die Sichtbarkeit der Variable auf die unmittelbare Umgebung der Deklaration beschränkt ist. Sobald dies jedoch nicht der Fall ist (typischerweise schon bei der Deklaration von Instanzvariablen), sollte der lange Name bevorzugt werden. Dies gilt auch für den Fall, dass der Typ der Variable aus dem Kontext abgeleitet werden kann und deswegen nicht mehr angegeben wird (Typinferenz).","<answer> Abkürzungen in der Programmierung sind nicht grundsätzlich zu vermeiden, besonders wenn sie etabliert sind und die Leserin des Programms wahrscheinlich weiß, was sie bedeuten. Dies kann dazu beitragen, zu lange Namen zu vermeiden und den Code lesbarer zu machen. <answer> <question> Warum sind Abkürzungen in der Programmierung nicht grundsätzlich zu vermeiden? <question>"
"Abkürzungen sind nicht grundsätzlich zu vermeiden — im Gegenteil, wenn sie etabliert sind und man davon ausgehen darf, dass eine Leserin des Programms sie kennt, ist ihre Verwendung (aus den oben angeführten Gründen gegen zu lange Namen) sogar angezeigt. Auf hausgemachte Abkürzungen, deren Bedeutung nur von einem selbst bekannt ist, sollte man hingegen verzichten.
Bei der Programmierung mit JAVA und anderen typisierten objektorientierten Programmiersprachen begegnet man häufig dem Phänomen, dass Typen und Variablen gleich heißen, sich nur in der Groß- bzw. Kleinschreibung ihres Anfangsbuchstabens unterscheiden. Ein typisches Beispiel dafür ist das folgende:
In diesen Fällen, wenn es keinen besseren Namen für die Variable gibt, ist es vollkommen legitim, eine Abkürzung für den Variablennamen zu wählen, insbesondere dann, wenn die Sichtbarkeit der Variable auf die unmittelbare Umgebung der Deklaration beschränkt ist. Sobald dies jedoch nicht der Fall ist (typischerweise schon bei der Deklaration von Instanzvariablen), sollte der lange Name bevorzugt werden. Dies gilt auch für den Fall, dass der Typ der Variable aus dem Kontext abgeleitet werden kann und deswegen nicht mehr angegeben wird (Typinferenz).","<answer> Auf selbst erstellte Abkürzungen sollte man verzichten, da ihre Bedeutung oft nur von der Person bekannt ist, die sie erstellt hat. Dies kann die Lesbarkeit des Codes für andere Programmiererinnen beeinträchtigen und zu Missverständnissen führen. <answer> <question> Warum sollte man auf selbst erstellte Abkürzungen verzichten? <question>"
"Abkürzungen sind nicht grundsätzlich zu vermeiden — im Gegenteil, wenn sie etabliert sind und man davon ausgehen darf, dass eine Leserin des Programms sie kennt, ist ihre Verwendung (aus den oben angeführten Gründen gegen zu lange Namen) sogar angezeigt. Auf hausgemachte Abkürzungen, deren Bedeutung nur von einem selbst bekannt ist, sollte man hingegen verzichten.
Bei der Programmierung mit JAVA und anderen typisierten objektorientierten Programmiersprachen begegnet man häufig dem Phänomen, dass Typen und Variablen gleich heißen, sich nur in der Groß- bzw. Kleinschreibung ihres Anfangsbuchstabens unterscheiden. Ein typisches Beispiel dafür ist das folgende:
In diesen Fällen, wenn es keinen besseren Namen für die Variable gibt, ist es vollkommen legitim, eine Abkürzung für den Variablennamen zu wählen, insbesondere dann, wenn die Sichtbarkeit der Variable auf die unmittelbare Umgebung der Deklaration beschränkt ist. Sobald dies jedoch nicht der Fall ist (typischerweise schon bei der Deklaration von Instanzvariablen), sollte der lange Name bevorzugt werden. Dies gilt auch für den Fall, dass der Typ der Variable aus dem Kontext abgeleitet werden kann und deswegen nicht mehr angegeben wird (Typinferenz).","<answer> In JAVA und ähnlichen objektorientierten Programmiersprachen ist die Verwendung von Abkürzungen legitim, wenn Typen und Variablen denselben Namen haben und sich nur in der Groß- bzw. Kleinschreibung ihres Anfangsbuchstabens unterscheiden. Dies kann in Fällen auftreten, in denen es keinen besseren Namen für die Variable gibt und die Sichtbarkeit der Variable auf die unmittelbare Umgebung der Deklaration beschränkt ist. <answer> <question> In welchen Fällen ist die Verwendung von Abkürzungen in JAVA und ähnlichen objektorientierten Programmiersprachen legitim? <question>"
"Abkürzungen sind nicht grundsätzlich zu vermeiden — im Gegenteil, wenn sie etabliert sind und man davon ausgehen darf, dass eine Leserin des Programms sie kennt, ist ihre Verwendung (aus den oben angeführten Gründen gegen zu lange Namen) sogar angezeigt. Auf hausgemachte Abkürzungen, deren Bedeutung nur von einem selbst bekannt ist, sollte man hingegen verzichten.
Bei der Programmierung mit JAVA und anderen typisierten objektorientierten Programmiersprachen begegnet man häufig dem Phänomen, dass Typen und Variablen gleich heißen, sich nur in der Groß- bzw. Kleinschreibung ihres Anfangsbuchstabens unterscheiden. Ein typisches Beispiel dafür ist das folgende:
In diesen Fällen, wenn es keinen besseren Namen für die Variable gibt, ist es vollkommen legitim, eine Abkürzung für den Variablennamen zu wählen, insbesondere dann, wenn die Sichtbarkeit der Variable auf die unmittelbare Umgebung der Deklaration beschränkt ist. Sobald dies jedoch nicht der Fall ist (typischerweise schon bei der Deklaration von Instanzvariablen), sollte der lange Name bevorzugt werden. Dies gilt auch für den Fall, dass der Typ der Variable aus dem Kontext abgeleitet werden kann und deswegen nicht mehr angegeben wird (Typinferenz).","<answer> Der lange Name einer Variable sollte bevorzugt werden, sobald dies nicht mehr der Fall ist, wenn die Sichtbarkeit der Variable über die unmittelbare Umgebung der Deklaration hinausgeht, wie es typischerweise bei der Deklaration von Instanzvariablen der Fall ist. Dies gilt auch, wenn der Typ der Variable aus dem Kontext abgeleitet werden kann (Typinferenz). <answer> <question> Wann sollte der lange Name einer Variable bevorzugt werden? <question>"
"Generalisierung und Spezialisierung, wie oben dargestellt, sind eher theoretisch motivierte Konzepte. In der Programmierung orientiert man sich jedoch häufig, wie im obigen Beispiel mit Pinguinen angedeutet, an praktischen Gesichtspunkten. Daher haben nicht Generalisierung und Spezialisierung die Entwicklung objektorientierter Programmiersprachen geprägt, sondern abstrakte Klassen und Vererbung. Diese pragmatische Ausrichtung ist jedoch nicht ohne Probleme, und daher werden uns die Überlegungen zu Generalisierung und Spezialisierung spätestens in Kurseinheit 3 wieder begegnen.",<answer> Die Entwicklung objektorientierter Programmiersprachen wurde eher von abstrakten Klassen und Vererbung als von den theoretischen Konzepten der Generalisierung und Spezialisierung geprägt. <answer> <question> Welche Konzepte haben die Entwicklung objektorientierter Programmiersprachen im Gegensatz zu Generalisierung und Spezialisierung geprägt? <question>
"Generalisierung und Spezialisierung, wie oben dargestellt, sind eher theoretisch motivierte Konzepte. In der Programmierung orientiert man sich jedoch häufig, wie im obigen Beispiel mit Pinguinen angedeutet, an praktischen Gesichtspunkten. Daher haben nicht Generalisierung und Spezialisierung die Entwicklung objektorientierter Programmiersprachen geprägt, sondern abstrakte Klassen und Vererbung. Diese pragmatische Ausrichtung ist jedoch nicht ohne Probleme, und daher werden uns die Überlegungen zu Generalisierung und Spezialisierung spätestens in Kurseinheit 3 wieder begegnen.","<answer> Abstrakte Klassen und Vererbung haben die Entwicklung objektorientierter Programmiersprachen geprägt, weil sie pragmatische Werkzeuge sind, die die Wiederverwendung von Code und die Strukturierung von Software erleichtern. Sie ermöglichen es, gemeinsame Eigenschaften und Methoden in einer Oberklasse zu definieren und von dieser Oberklasse abgeleitete Unterklassen zu erstellen, die diese Eigenschaften und Methoden erben und bei Bedarf überschreiben können. <answer> <question> Warum haben abstrakte Klassen und Vererbung die Entwicklung objektorientierter Programmiersprachen geprägt? <question>"
"Generalisierung und Spezialisierung, wie oben dargestellt, sind eher theoretisch motivierte Konzepte. In der Programmierung orientiert man sich jedoch häufig, wie im obigen Beispiel mit Pinguinen angedeutet, an praktischen Gesichtspunkten. Daher haben nicht Generalisierung und Spezialisierung die Entwicklung objektorientierter Programmiersprachen geprägt, sondern abstrakte Klassen und Vererbung. Diese pragmatische Ausrichtung ist jedoch nicht ohne Probleme, und daher werden uns die Überlegungen zu Generalisierung und Spezialisierung spätestens in Kurseinheit 3 wieder begegnen.","<answer> Obwohl Generalisierung und Spezialisierung eher theoretisch motivierte Konzepte sind, sind sie dennoch relevant, da sie dazu beitragen, die Struktur und Hierarchie von Klassen in objektorientierten Programmen zu definieren. Sie ermöglichen es, Klassen in Beziehung zueinander zu setzen und abstrakte Modelle für die Softwareentwicklung zu entwickeln. Diese Konzepte können in komplexen Softwareprojekten zur Verbesserung der Wartbarkeit und Erweiterbarkeit beitragen. <answer> <question> Warum sind Generalisierung und Spezialisierung in der objektorientierten Programmierung dennoch relevant? <question>"
"Modul und Interface sind eigentlich ein Begriffspaar — das eine lässt sich nur mithilfe des anderen definieren. Die Interfaces in JAVA sind jedoch durchaus eigenständige Konstrukte, die inzwischen weit über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle zu definieren, hinausgehen. Auch wenn JAVAs Interfaces Vorgänger haben, betrachte ich sie doch als einen von JAVAs wichtigsten Beiträgen für die Entwicklung objektorientierter Programmiersprachen.","<answer> Interfaces und Module sind in JAVA eng miteinander verknüpft und dienen dazu, die Schnittstellen und die Modularisierung von Klassen und Programmen zu definieren. <answer> <question> Welche Bedeutung haben Interfaces und Module in JAVA? <question>"
"Modul und Interface sind eigentlich ein Begriffspaar — das eine lässt sich nur mithilfe des anderen definieren. Die Interfaces in JAVA sind jedoch durchaus eigenständige Konstrukte, die inzwischen weit über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle zu definieren, hinausgehen. Auch wenn JAVAs Interfaces Vorgänger haben, betrachte ich sie doch als einen von JAVAs wichtigsten Beiträgen für die Entwicklung objektorientierter Programmiersprachen.","<answer> Interfaces spielen in der objektorientierten Programmierung eine wichtige Rolle, da sie dazu dienen, Schnittstellen zu definieren, über die Klassen miteinander kommunizieren können. Sie ermöglichen die Implementierung von Methoden in verschiedenen Klassen und erlauben die Implementierung von Polymorphismus. <answer> <question> Welche Rolle spielen Interfaces in der objektorientierten Programmierung? <question>"
"Modul und Interface sind eigentlich ein Begriffspaar — das eine lässt sich nur mithilfe des anderen definieren. Die Interfaces in JAVA sind jedoch durchaus eigenständige Konstrukte, die inzwischen weit über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle zu definieren, hinausgehen. Auch wenn JAVAs Interfaces Vorgänger haben, betrachte ich sie doch als einen von JAVAs wichtigsten Beiträgen für die Entwicklung objektorientierter Programmiersprachen.","<answer> JAVAs Interfaces sind eigenständige Konstrukte, die über die ursprüngliche Bedeutung hinausgehen und weitreichende Möglichkeiten zur Definition von Schnittstellen und zur Entwicklung objektorientierter Programmiersprachen bieten. <answer> <question> Was ist die Besonderheit von JAVAs Interfaces? <question>"
"Modul und Interface sind eigentlich ein Begriffspaar — das eine lässt sich nur mithilfe des anderen definieren. Die Interfaces in JAVA sind jedoch durchaus eigenständige Konstrukte, die inzwischen weit über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle zu definieren, hinausgehen. Auch wenn JAVAs Interfaces Vorgänger haben, betrachte ich sie doch als einen von JAVAs wichtigsten Beiträgen für die Entwicklung objektorientierter Programmiersprachen.","<answer> Interfaces in JAVA sind einer der wichtigsten Beiträge zur objektorientierten Programmierung, da sie die Möglichkeit bieten, Schnittstellen und Polymorphismus zu implementieren, was die Flexibilität und Erweiterbarkeit von Programmen erheblich verbessert. <answer> <question> Warum werden Interfaces in JAVA als einer der wichtigsten Beiträge zur objektorientierten Programmierung angesehen? <question>"
"Ein- und Ausgabeströme spielen in der konventionellen (objektorientierten) Programmierung eine wichtige Rolle, da über sie Eingaben in und Ausgaben aus dem System erfolgen, und zwar sowohl von/zu der Benutzerin als auch vom/zum Dateisystem. Nun ist SMALLTALK aber als fensterbasiertes, grafisches System konzipiert, das der zeilenorientierten und textbasierten Ein- und Ausgabe der damals vorherrschenden Programme eine Alternative gegenüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden. Da ist es nur konsequent, dass die Ein- und Ausgabe über Streams wenig Gewicht hat.
In SMALLTALK haben Streams somit zunächst auch eine andere Aufgabe: Sie erlauben eine Form des Zugriffs auf Collections, die das Collection-Protokoll nicht bieten kann, nämlich: den sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen (bei den Iteratoren wird immer in einem Schritt, oder in einer Anweisung, über die ganze Collection iteriert) sowie den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Collection durch mehrere andere Objekte.
Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die zu liefern ist die Funktion von Streams.
Streams werden zunächst immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält. Das Basisprotokoll auf Instanzebene enthält die folgenden Methoden:
Für frei positionierbare Streams kommt noch das Protokoll zur Änderung des Zeigers hinzu:
Für peek ist die freie Positionierbarkeit notwendig, weil man dazu erst das nächste Element anspringen und dann wieder einen Schritt zurückgehen muss.
Da ein Stream (wie eine Collection) eine Menge von Objekten repräsentiert, möchte man darüber (genau wie über eine Collection) iterieren können. Kein Problem:
Außerdem wird natürlich zwischen (nur) lesbaren und schreibbaren Streams unterschieden.
Erst eine weitere Kategorie von Streams operiert nicht auf Collections, sondern auf externen Daten. Dazu gehören insbesondere die File streams. In SMALLTALK-80 wurde mit den Klassen FileDirectory, File und FilePage (die selbst keine Streams sind) ein eigenes Dateisystem geschaffen; die meisten heute gebräuchlichen Implementierungen nehmen jedoch eine Abbildung auf das Betriebssystem vor, für das sie geschrieben wurden. Man erkennt hier noch sehr schön, welche Funktion SMALLTALK ursprünglich zugedacht war: die der einzigen Software auf einem Computer.
Besonders in SQUEAK gibt es noch zahllose weitere Streams, so u. a. für Multimedia-Aufgaben; insgesamt unterscheiden sich die verschiedenen SMALLTALK-Dialekte bei der Handhabung von Streams zum Teil erheblich, weswegen wir hier auch nicht weiter darauf eingehen.","<answer> Ein- und Ausgabeströme spielen in der objektorientierten Programmierung eine wichtige Rolle, da sie den Zugriff auf Eingabe- und Ausgabedaten im System ermöglichen. Sie dienen dazu, Daten sowohl von/zu Benutzern als auch von/zu Dateisystemen zu lesen und zu schreiben. <answer> <question> Welche Rolle spielen Ein- und Ausgabeströme in der objektorientierten Programmierung? <question>"
"Ein- und Ausgabeströme spielen in der konventionellen (objektorientierten) Programmierung eine wichtige Rolle, da über sie Eingaben in und Ausgaben aus dem System erfolgen, und zwar sowohl von/zu der Benutzerin als auch vom/zum Dateisystem. Nun ist SMALLTALK aber als fensterbasiertes, grafisches System konzipiert, das der zeilenorientierten und textbasierten Ein- und Ausgabe der damals vorherrschenden Programme eine Alternative gegenüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden. Da ist es nur konsequent, dass die Ein- und Ausgabe über Streams wenig Gewicht hat.
In SMALLTALK haben Streams somit zunächst auch eine andere Aufgabe: Sie erlauben eine Form des Zugriffs auf Collections, die das Collection-Protokoll nicht bieten kann, nämlich: den sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen (bei den Iteratoren wird immer in einem Schritt, oder in einer Anweisung, über die ganze Collection iteriert) sowie den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Collection durch mehrere andere Objekte.
Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die zu liefern ist die Funktion von Streams.
Streams werden zunächst immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält. Das Basisprotokoll auf Instanzebene enthält die folgenden Methoden:
Für frei positionierbare Streams kommt noch das Protokoll zur Änderung des Zeigers hinzu:
Für peek ist die freie Positionierbarkeit notwendig, weil man dazu erst das nächste Element anspringen und dann wieder einen Schritt zurückgehen muss.
Da ein Stream (wie eine Collection) eine Menge von Objekten repräsentiert, möchte man darüber (genau wie über eine Collection) iterieren können. Kein Problem:
Außerdem wird natürlich zwischen (nur) lesbaren und schreibbaren Streams unterschieden.
Erst eine weitere Kategorie von Streams operiert nicht auf Collections, sondern auf externen Daten. Dazu gehören insbesondere die File streams. In SMALLTALK-80 wurde mit den Klassen FileDirectory, File und FilePage (die selbst keine Streams sind) ein eigenes Dateisystem geschaffen; die meisten heute gebräuchlichen Implementierungen nehmen jedoch eine Abbildung auf das Betriebssystem vor, für das sie geschrieben wurden. Man erkennt hier noch sehr schön, welche Funktion SMALLTALK ursprünglich zugedacht war: die der einzigen Software auf einem Computer.
Besonders in SQUEAK gibt es noch zahllose weitere Streams, so u. a. für Multimedia-Aufgaben; insgesamt unterscheiden sich die verschiedenen SMALLTALK-Dialekte bei der Handhabung von Streams zum Teil erheblich, weswegen wir hier auch nicht weiter darauf eingehen.","<answer> In SMALLTALK wurde die Ein- und Ausgabe über Streams anders konzipiert als in konventionellen textbasierten Programmen. SMALLTALK ist ein fensterbasiertes, grafisches System, das eine Alternative zur zeilenorientierten Ein- und Ausgabe bieten wollte. Zudem sind in SMALLTALK permanente Datenspeicherung in Dateien nicht notwendig, da alle Objekte im Image dauerhaft gespeichert werden. Daher haben Streams in SMALLTALK eine andere Aufgabe, nämlich den sequentiellen Zugriff auf einzelne Elemente in Collections und den gleichzeitigen Zugriff durch mehrere Objekte auf Collections zu ermöglichen. <answer> <question> Warum hat die Ein- und Ausgabe über Streams in SMALLTALK eine besondere Bedeutung? <question>"
"Ein- und Ausgabeströme spielen in der konventionellen (objektorientierten) Programmierung eine wichtige Rolle, da über sie Eingaben in und Ausgaben aus dem System erfolgen, und zwar sowohl von/zu der Benutzerin als auch vom/zum Dateisystem. Nun ist SMALLTALK aber als fensterbasiertes, grafisches System konzipiert, das der zeilenorientierten und textbasierten Ein- und Ausgabe der damals vorherrschenden Programme eine Alternative gegenüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden. Da ist es nur konsequent, dass die Ein- und Ausgabe über Streams wenig Gewicht hat.
In SMALLTALK haben Streams somit zunächst auch eine andere Aufgabe: Sie erlauben eine Form des Zugriffs auf Collections, die das Collection-Protokoll nicht bieten kann, nämlich: den sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen (bei den Iteratoren wird immer in einem Schritt, oder in einer Anweisung, über die ganze Collection iteriert) sowie den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Collection durch mehrere andere Objekte.
Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die zu liefern ist die Funktion von Streams.
Streams werden zunächst immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält. Das Basisprotokoll auf Instanzebene enthält die folgenden Methoden:
Für frei positionierbare Streams kommt noch das Protokoll zur Änderung des Zeigers hinzu:
Für peek ist die freie Positionierbarkeit notwendig, weil man dazu erst das nächste Element anspringen und dann wieder einen Schritt zurückgehen muss.
Da ein Stream (wie eine Collection) eine Menge von Objekten repräsentiert, möchte man darüber (genau wie über eine Collection) iterieren können. Kein Problem:
Außerdem wird natürlich zwischen (nur) lesbaren und schreibbaren Streams unterschieden.
Erst eine weitere Kategorie von Streams operiert nicht auf Collections, sondern auf externen Daten. Dazu gehören insbesondere die File streams. In SMALLTALK-80 wurde mit den Klassen FileDirectory, File und FilePage (die selbst keine Streams sind) ein eigenes Dateisystem geschaffen; die meisten heute gebräuchlichen Implementierungen nehmen jedoch eine Abbildung auf das Betriebssystem vor, für das sie geschrieben wurden. Man erkennt hier noch sehr schön, welche Funktion SMALLTALK ursprünglich zugedacht war: die der einzigen Software auf einem Computer.
Besonders in SQUEAK gibt es noch zahllose weitere Streams, so u. a. für Multimedia-Aufgaben; insgesamt unterscheiden sich die verschiedenen SMALLTALK-Dialekte bei der Handhabung von Streams zum Teil erheblich, weswegen wir hier auch nicht weiter darauf eingehen.","<answer> Streams ermöglichen einen sequentiellen Zugriff auf einzelne Elemente in Collections zu beliebigen Zeitpunkten. Dies unterscheidet sich von Iteratoren, die die gesamte Collection in einem Schritt durchlaufen. Streams ermöglichen auch den gleichzeitigen oder zeitlich abwechselnden Zugriff auf die Elemente einer Collection durch mehrere andere Objekte. Streams stellen Positionszeiger in eine Collection bereit, um diese Funktionen umzusetzen. <answer> <question> Welche Funktion haben Streams in Bezug auf Collections? <question>"
"Ein- und Ausgabeströme spielen in der konventionellen (objektorientierten) Programmierung eine wichtige Rolle, da über sie Eingaben in und Ausgaben aus dem System erfolgen, und zwar sowohl von/zu der Benutzerin als auch vom/zum Dateisystem. Nun ist SMALLTALK aber als fensterbasiertes, grafisches System konzipiert, das der zeilenorientierten und textbasierten Ein- und Ausgabe der damals vorherrschenden Programme eine Alternative gegenüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden. Da ist es nur konsequent, dass die Ein- und Ausgabe über Streams wenig Gewicht hat.
In SMALLTALK haben Streams somit zunächst auch eine andere Aufgabe: Sie erlauben eine Form des Zugriffs auf Collections, die das Collection-Protokoll nicht bieten kann, nämlich: den sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen (bei den Iteratoren wird immer in einem Schritt, oder in einer Anweisung, über die ganze Collection iteriert) sowie den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Collection durch mehrere andere Objekte.
Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die zu liefern ist die Funktion von Streams.
Streams werden zunächst immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält. Das Basisprotokoll auf Instanzebene enthält die folgenden Methoden:
Für frei positionierbare Streams kommt noch das Protokoll zur Änderung des Zeigers hinzu:
Für peek ist die freie Positionierbarkeit notwendig, weil man dazu erst das nächste Element anspringen und dann wieder einen Schritt zurückgehen muss.
Da ein Stream (wie eine Collection) eine Menge von Objekten repräsentiert, möchte man darüber (genau wie über eine Collection) iterieren können. Kein Problem:
Außerdem wird natürlich zwischen (nur) lesbaren und schreibbaren Streams unterschieden.
Erst eine weitere Kategorie von Streams operiert nicht auf Collections, sondern auf externen Daten. Dazu gehören insbesondere die File streams. In SMALLTALK-80 wurde mit den Klassen FileDirectory, File und FilePage (die selbst keine Streams sind) ein eigenes Dateisystem geschaffen; die meisten heute gebräuchlichen Implementierungen nehmen jedoch eine Abbildung auf das Betriebssystem vor, für das sie geschrieben wurden. Man erkennt hier noch sehr schön, welche Funktion SMALLTALK ursprünglich zugedacht war: die der einzigen Software auf einem Computer.
Besonders in SQUEAK gibt es noch zahllose weitere Streams, so u. a. für Multimedia-Aufgaben; insgesamt unterscheiden sich die verschiedenen SMALLTALK-Dialekte bei der Handhabung von Streams zum Teil erheblich, weswegen wir hier auch nicht weiter darauf eingehen.","<answer> Streams werden normalerweise durch die Klassenmethode on: auf einer Collection erzeugt. Diese Methode erhält eine Collection als Parameter und erstellt einen Stream, der auf dem Inhalt der Collection basiert. <answer> <question> Wie werden Streams in SMALLTALK normalerweise erzeugt? <question>"
"Ein- und Ausgabeströme spielen in der konventionellen (objektorientierten) Programmierung eine wichtige Rolle, da über sie Eingaben in und Ausgaben aus dem System erfolgen, und zwar sowohl von/zu der Benutzerin als auch vom/zum Dateisystem. Nun ist SMALLTALK aber als fensterbasiertes, grafisches System konzipiert, das der zeilenorientierten und textbasierten Ein- und Ausgabe der damals vorherrschenden Programme eine Alternative gegenüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden. Da ist es nur konsequent, dass die Ein- und Ausgabe über Streams wenig Gewicht hat.
In SMALLTALK haben Streams somit zunächst auch eine andere Aufgabe: Sie erlauben eine Form des Zugriffs auf Collections, die das Collection-Protokoll nicht bieten kann, nämlich: den sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen (bei den Iteratoren wird immer in einem Schritt, oder in einer Anweisung, über die ganze Collection iteriert) sowie den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Collection durch mehrere andere Objekte.
Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die zu liefern ist die Funktion von Streams.
Streams werden zunächst immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält. Das Basisprotokoll auf Instanzebene enthält die folgenden Methoden:
Für frei positionierbare Streams kommt noch das Protokoll zur Änderung des Zeigers hinzu:
Für peek ist die freie Positionierbarkeit notwendig, weil man dazu erst das nächste Element anspringen und dann wieder einen Schritt zurückgehen muss.
Da ein Stream (wie eine Collection) eine Menge von Objekten repräsentiert, möchte man darüber (genau wie über eine Collection) iterieren können. Kein Problem:
Außerdem wird natürlich zwischen (nur) lesbaren und schreibbaren Streams unterschieden.
Erst eine weitere Kategorie von Streams operiert nicht auf Collections, sondern auf externen Daten. Dazu gehören insbesondere die File streams. In SMALLTALK-80 wurde mit den Klassen FileDirectory, File und FilePage (die selbst keine Streams sind) ein eigenes Dateisystem geschaffen; die meisten heute gebräuchlichen Implementierungen nehmen jedoch eine Abbildung auf das Betriebssystem vor, für das sie geschrieben wurden. Man erkennt hier noch sehr schön, welche Funktion SMALLTALK ursprünglich zugedacht war: die der einzigen Software auf einem Computer.
Besonders in SQUEAK gibt es noch zahllose weitere Streams, so u. a. für Multimedia-Aufgaben; insgesamt unterscheiden sich die verschiedenen SMALLTALK-Dialekte bei der Handhabung von Streams zum Teil erheblich, weswegen wir hier auch nicht weiter darauf eingehen.","<answer> Lesbare Streams ermöglichen das Lesen von Daten aus einer Quelle, während schreibbare Streams das Schreiben von Daten in eine Zielquelle ermöglichen. Lesbare Streams bieten Methoden zum Lesen von Daten, während schreibbare Streams Methoden zum Schreiben von Daten bereitstellen. <answer> <question> Was sind die Unterschiede zwischen lesbarbaren und schreibbaren Streams? <question>"
"Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraussetzung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (beispielsweise der Verwendung von Nicht-Zahlen in arithmetischen Ausdrücken), muss bekannt sein, welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden werden können, schnell gefasst: Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein Protokoll (s. Abschnitt 4.3.8 in Kurseinheit 1). Ein solches Protokoll definiert einen Typ: Er umfasst die Menge der Objekte, die über das Protokoll verfügen.
Wenn man nun eine Variable mit einem solchen Protokoll als Typ typisiert und das Programm typkorrekt ist, dann ist garantiert, dass jede Methode, die im Protokoll enthalten ist und die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist. Typfehler, also Fehler der Sorte „does not understand“ (s. Abschnitt 4.3.2 in Kurseinheit 1), treten dann nicht mehr auf.
Nun kommen in Protokollen aber selbst Variablen vor, nämlich die formalen Parameter der Methoden, die das Protokoll ausmachen. Außerdem ist eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Objekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle definieren also nicht nur Typen, sie verwenden auch selbst welche, nämlich indem sie die Typen der Ein- und Ausgabeobjekte spezifizieren. Ein einfaches Beispiel für eine Typdefinition, die selbst Typen verwendet, ist die folgende:
Wie schon bei einer temporären Variable, stehen die Typannotationen von formalen Parametern in STRONGTALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kennzeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Methode ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zurück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo-Typvariable (entsprechend der Pseudovariable self, deren Typ sie darstellt).
Falls Sie sich wundern, dass obige Zeilen kein Schlüsselwort zur Einleitung der Typdefinition beinhalten: STRONGTALK ist, genau wie SMALLTALK, ein interaktives, browsergestütztes System, in dem Typen in Formulare eingetragen und nicht in Textdateien spezifiziert werden. Gleichwohl fällt auf, dass innerhalb der Typdefinition in Typen als Teile von den spitzen Klammern (also da, wo Typen stehen sollen) keine Typdefinition auftauchen, sondern Namen. Und tatsächlich wird in STRONGTALK jeder Typ benannt (in seiner Typdefinition mit einem Namen versehen). Im folgenden werden Typen, ähnlich wie Klassen, in tabellarischer Form notiert.
In STRONGTALK ist die Protokollbildung der einzige sogenannte Typkonstruktor, d. h., das einzige Sprachkonstrukt, mit dem man neue Typen definieren kann. Andere Programmiersprachen sehen ein reichhaltigeres Angebot vor: In PASCAL beispielsweise gibt es die Typkonstruktoren record, array of, set of, file of, Zeiger auf (^) sowie Aufzählungen (enumerations) und Teilbereiche (ranges). In C++ gibt es u. a. class und struct (entsprechend record in PASCAL), JAVA, C# und EIFFEL bieten auch jeweils verschiedene Typkonstruktoren an. Für eine puristische Sprache wie SMALLTALK bzw. STRONGTALK reicht jedoch einer vollkommen aus.
Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten. Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das wirft natürlich die Frage auf, wie man Typen unter zwangsläufiger Selbstbezüglichkeit überhaupt eine Bedeutung beimessen kann.","<answer> Es ist wichtig, die Eigenschaften eines Typs und seiner Elemente in einem Typsystem zu kennen, um Fehler im Programm zu vermeiden, die auf der Annahme von Eigenschaften beruhen, die Objekte möglicherweise nicht haben. Ein Typsystem definiert, welche Methoden auf einem Objekt aufgerufen werden können, und stellt sicher, dass diese Methoden auch für das Objekt definiert sind. <answer> <question> Warum ist es wichtig, die Eigenschaften eines Typs und seiner Elemente in einem Typsystem zu kennen? <question>"
"Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraussetzung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (beispielsweise der Verwendung von Nicht-Zahlen in arithmetischen Ausdrücken), muss bekannt sein, welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden werden können, schnell gefasst: Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein Protokoll (s. Abschnitt 4.3.8 in Kurseinheit 1). Ein solches Protokoll definiert einen Typ: Er umfasst die Menge der Objekte, die über das Protokoll verfügen.
Wenn man nun eine Variable mit einem solchen Protokoll als Typ typisiert und das Programm typkorrekt ist, dann ist garantiert, dass jede Methode, die im Protokoll enthalten ist und die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist. Typfehler, also Fehler der Sorte „does not understand“ (s. Abschnitt 4.3.2 in Kurseinheit 1), treten dann nicht mehr auf.
Nun kommen in Protokollen aber selbst Variablen vor, nämlich die formalen Parameter der Methoden, die das Protokoll ausmachen. Außerdem ist eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Objekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle definieren also nicht nur Typen, sie verwenden auch selbst welche, nämlich indem sie die Typen der Ein- und Ausgabeobjekte spezifizieren. Ein einfaches Beispiel für eine Typdefinition, die selbst Typen verwendet, ist die folgende:
Wie schon bei einer temporären Variable, stehen die Typannotationen von formalen Parametern in STRONGTALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kennzeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Methode ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zurück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo-Typvariable (entsprechend der Pseudovariable self, deren Typ sie darstellt).
Falls Sie sich wundern, dass obige Zeilen kein Schlüsselwort zur Einleitung der Typdefinition beinhalten: STRONGTALK ist, genau wie SMALLTALK, ein interaktives, browsergestütztes System, in dem Typen in Formulare eingetragen und nicht in Textdateien spezifiziert werden. Gleichwohl fällt auf, dass innerhalb der Typdefinition in Typen als Teile von den spitzen Klammern (also da, wo Typen stehen sollen) keine Typdefinition auftauchen, sondern Namen. Und tatsächlich wird in STRONGTALK jeder Typ benannt (in seiner Typdefinition mit einem Namen versehen). Im folgenden werden Typen, ähnlich wie Klassen, in tabellarischer Form notiert.
In STRONGTALK ist die Protokollbildung der einzige sogenannte Typkonstruktor, d. h., das einzige Sprachkonstrukt, mit dem man neue Typen definieren kann. Andere Programmiersprachen sehen ein reichhaltigeres Angebot vor: In PASCAL beispielsweise gibt es die Typkonstruktoren record, array of, set of, file of, Zeiger auf (^) sowie Aufzählungen (enumerations) und Teilbereiche (ranges). In C++ gibt es u. a. class und struct (entsprechend record in PASCAL), JAVA, C# und EIFFEL bieten auch jeweils verschiedene Typkonstruktoren an. Für eine puristische Sprache wie SMALLTALK bzw. STRONGTALK reicht jedoch einer vollkommen aus.
Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten. Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das wirft natürlich die Frage auf, wie man Typen unter zwangsläufiger Selbstbezüglichkeit überhaupt eine Bedeutung beimessen kann.","<answer> In STRONGTALK werden Typfehler vermieden, indem Variablen mit einem Protokoll als Typ typisiert werden. Wenn das Programm typkorrekt ist, bedeutet dies, dass jede Methode im Protokoll, die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist. <answer> <question> Wie werden Typfehler in STRONGTALK vermieden? <question>"
"Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraussetzung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (beispielsweise der Verwendung von Nicht-Zahlen in arithmetischen Ausdrücken), muss bekannt sein, welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden werden können, schnell gefasst: Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein Protokoll (s. Abschnitt 4.3.8 in Kurseinheit 1). Ein solches Protokoll definiert einen Typ: Er umfasst die Menge der Objekte, die über das Protokoll verfügen.
Wenn man nun eine Variable mit einem solchen Protokoll als Typ typisiert und das Programm typkorrekt ist, dann ist garantiert, dass jede Methode, die im Protokoll enthalten ist und die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist. Typfehler, also Fehler der Sorte „does not understand“ (s. Abschnitt 4.3.2 in Kurseinheit 1), treten dann nicht mehr auf.
Nun kommen in Protokollen aber selbst Variablen vor, nämlich die formalen Parameter der Methoden, die das Protokoll ausmachen. Außerdem ist eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Objekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle definieren also nicht nur Typen, sie verwenden auch selbst welche, nämlich indem sie die Typen der Ein- und Ausgabeobjekte spezifizieren. Ein einfaches Beispiel für eine Typdefinition, die selbst Typen verwendet, ist die folgende:
Wie schon bei einer temporären Variable, stehen die Typannotationen von formalen Parametern in STRONGTALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kennzeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Methode ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zurück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo-Typvariable (entsprechend der Pseudovariable self, deren Typ sie darstellt).
Falls Sie sich wundern, dass obige Zeilen kein Schlüsselwort zur Einleitung der Typdefinition beinhalten: STRONGTALK ist, genau wie SMALLTALK, ein interaktives, browsergestütztes System, in dem Typen in Formulare eingetragen und nicht in Textdateien spezifiziert werden. Gleichwohl fällt auf, dass innerhalb der Typdefinition in Typen als Teile von den spitzen Klammern (also da, wo Typen stehen sollen) keine Typdefinition auftauchen, sondern Namen. Und tatsächlich wird in STRONGTALK jeder Typ benannt (in seiner Typdefinition mit einem Namen versehen). Im folgenden werden Typen, ähnlich wie Klassen, in tabellarischer Form notiert.
In STRONGTALK ist die Protokollbildung der einzige sogenannte Typkonstruktor, d. h., das einzige Sprachkonstrukt, mit dem man neue Typen definieren kann. Andere Programmiersprachen sehen ein reichhaltigeres Angebot vor: In PASCAL beispielsweise gibt es die Typkonstruktoren record, array of, set of, file of, Zeiger auf (^) sowie Aufzählungen (enumerations) und Teilbereiche (ranges). In C++ gibt es u. a. class und struct (entsprechend record in PASCAL), JAVA, C# und EIFFEL bieten auch jeweils verschiedene Typkonstruktoren an. Für eine puristische Sprache wie SMALLTALK bzw. STRONGTALK reicht jedoch einer vollkommen aus.
Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten. Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das wirft natürlich die Frage auf, wie man Typen unter zwangsläufiger Selbstbezüglichkeit überhaupt eine Bedeutung beimessen kann.","<answer> Protokolle in STRONGTALK verwenden selbst Typen, da sie die Typen der Eingabe- und Ausgabeobjekte in den Methoden spezifizieren. Dies gewährleistet, dass die Typen der Objekte, die mit den Methoden interagieren, kompatibel sind. <answer> <question> Warum müssen Protokolle in STRONGTALK selbst Typen verwenden? <question>"
"Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraussetzung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (beispielsweise der Verwendung von Nicht-Zahlen in arithmetischen Ausdrücken), muss bekannt sein, welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden werden können, schnell gefasst: Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein Protokoll (s. Abschnitt 4.3.8 in Kurseinheit 1). Ein solches Protokoll definiert einen Typ: Er umfasst die Menge der Objekte, die über das Protokoll verfügen.
Wenn man nun eine Variable mit einem solchen Protokoll als Typ typisiert und das Programm typkorrekt ist, dann ist garantiert, dass jede Methode, die im Protokoll enthalten ist und die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist. Typfehler, also Fehler der Sorte „does not understand“ (s. Abschnitt 4.3.2 in Kurseinheit 1), treten dann nicht mehr auf.
Nun kommen in Protokollen aber selbst Variablen vor, nämlich die formalen Parameter der Methoden, die das Protokoll ausmachen. Außerdem ist eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Objekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle definieren also nicht nur Typen, sie verwenden auch selbst welche, nämlich indem sie die Typen der Ein- und Ausgabeobjekte spezifizieren. Ein einfaches Beispiel für eine Typdefinition, die selbst Typen verwendet, ist die folgende:
Wie schon bei einer temporären Variable, stehen die Typannotationen von formalen Parametern in STRONGTALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kennzeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Methode ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zurück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo-Typvariable (entsprechend der Pseudovariable self, deren Typ sie darstellt).
Falls Sie sich wundern, dass obige Zeilen kein Schlüsselwort zur Einleitung der Typdefinition beinhalten: STRONGTALK ist, genau wie SMALLTALK, ein interaktives, browsergestütztes System, in dem Typen in Formulare eingetragen und nicht in Textdateien spezifiziert werden. Gleichwohl fällt auf, dass innerhalb der Typdefinition in Typen als Teile von den spitzen Klammern (also da, wo Typen stehen sollen) keine Typdefinition auftauchen, sondern Namen. Und tatsächlich wird in STRONGTALK jeder Typ benannt (in seiner Typdefinition mit einem Namen versehen). Im folgenden werden Typen, ähnlich wie Klassen, in tabellarischer Form notiert.
In STRONGTALK ist die Protokollbildung der einzige sogenannte Typkonstruktor, d. h., das einzige Sprachkonstrukt, mit dem man neue Typen definieren kann. Andere Programmiersprachen sehen ein reichhaltigeres Angebot vor: In PASCAL beispielsweise gibt es die Typkonstruktoren record, array of, set of, file of, Zeiger auf (^) sowie Aufzählungen (enumerations) und Teilbereiche (ranges). In C++ gibt es u. a. class und struct (entsprechend record in PASCAL), JAVA, C# und EIFFEL bieten auch jeweils verschiedene Typkonstruktoren an. Für eine puristische Sprache wie SMALLTALK bzw. STRONGTALK reicht jedoch einer vollkommen aus.
Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten. Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das wirft natürlich die Frage auf, wie man Typen unter zwangsläufiger Selbstbezüglichkeit überhaupt eine Bedeutung beimessen kann.",<answer> Formale Parameter in STRONGTALK werden durch Typannotationen in spitzen Klammern hinter den Parametern typisiert. <answer> <question> Wie werden formale Parameter in STRONGTALK typisiert? <question>
"Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraussetzung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (beispielsweise der Verwendung von Nicht-Zahlen in arithmetischen Ausdrücken), muss bekannt sein, welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden werden können, schnell gefasst: Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein Protokoll (s. Abschnitt 4.3.8 in Kurseinheit 1). Ein solches Protokoll definiert einen Typ: Er umfasst die Menge der Objekte, die über das Protokoll verfügen.
Wenn man nun eine Variable mit einem solchen Protokoll als Typ typisiert und das Programm typkorrekt ist, dann ist garantiert, dass jede Methode, die im Protokoll enthalten ist und die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist. Typfehler, also Fehler der Sorte „does not understand“ (s. Abschnitt 4.3.2 in Kurseinheit 1), treten dann nicht mehr auf.
Nun kommen in Protokollen aber selbst Variablen vor, nämlich die formalen Parameter der Methoden, die das Protokoll ausmachen. Außerdem ist eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Objekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle definieren also nicht nur Typen, sie verwenden auch selbst welche, nämlich indem sie die Typen der Ein- und Ausgabeobjekte spezifizieren. Ein einfaches Beispiel für eine Typdefinition, die selbst Typen verwendet, ist die folgende:
Wie schon bei einer temporären Variable, stehen die Typannotationen von formalen Parametern in STRONGTALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kennzeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Methode ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zurück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo-Typvariable (entsprechend der Pseudovariable self, deren Typ sie darstellt).
Falls Sie sich wundern, dass obige Zeilen kein Schlüsselwort zur Einleitung der Typdefinition beinhalten: STRONGTALK ist, genau wie SMALLTALK, ein interaktives, browsergestütztes System, in dem Typen in Formulare eingetragen und nicht in Textdateien spezifiziert werden. Gleichwohl fällt auf, dass innerhalb der Typdefinition in Typen als Teile von den spitzen Klammern (also da, wo Typen stehen sollen) keine Typdefinition auftauchen, sondern Namen. Und tatsächlich wird in STRONGTALK jeder Typ benannt (in seiner Typdefinition mit einem Namen versehen). Im folgenden werden Typen, ähnlich wie Klassen, in tabellarischer Form notiert.
In STRONGTALK ist die Protokollbildung der einzige sogenannte Typkonstruktor, d. h., das einzige Sprachkonstrukt, mit dem man neue Typen definieren kann. Andere Programmiersprachen sehen ein reichhaltigeres Angebot vor: In PASCAL beispielsweise gibt es die Typkonstruktoren record, array of, set of, file of, Zeiger auf (^) sowie Aufzählungen (enumerations) und Teilbereiche (ranges). In C++ gibt es u. a. class und struct (entsprechend record in PASCAL), JAVA, C# und EIFFEL bieten auch jeweils verschiedene Typkonstruktoren an. Für eine puristische Sprache wie SMALLTALK bzw. STRONGTALK reicht jedoch einer vollkommen aus.
Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten. Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das wirft natürlich die Frage auf, wie man Typen unter zwangsläufiger Selbstbezüglichkeit überhaupt eine Bedeutung beimessen kann.",<answer> In STRONGTALK wird der Rückgabetyp einer Methode durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter der Methode. <answer> <question> Wie kennzeichnet man in STRONGTALK den Rückgabetyp einer Methode? <question>
"Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraussetzung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (beispielsweise der Verwendung von Nicht-Zahlen in arithmetischen Ausdrücken), muss bekannt sein, welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden werden können, schnell gefasst: Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein Protokoll (s. Abschnitt 4.3.8 in Kurseinheit 1). Ein solches Protokoll definiert einen Typ: Er umfasst die Menge der Objekte, die über das Protokoll verfügen.
Wenn man nun eine Variable mit einem solchen Protokoll als Typ typisiert und das Programm typkorrekt ist, dann ist garantiert, dass jede Methode, die im Protokoll enthalten ist und die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist. Typfehler, also Fehler der Sorte „does not understand“ (s. Abschnitt 4.3.2 in Kurseinheit 1), treten dann nicht mehr auf.
Nun kommen in Protokollen aber selbst Variablen vor, nämlich die formalen Parameter der Methoden, die das Protokoll ausmachen. Außerdem ist eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Objekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle definieren also nicht nur Typen, sie verwenden auch selbst welche, nämlich indem sie die Typen der Ein- und Ausgabeobjekte spezifizieren. Ein einfaches Beispiel für eine Typdefinition, die selbst Typen verwendet, ist die folgende:
Wie schon bei einer temporären Variable, stehen die Typannotationen von formalen Parametern in STRONGTALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kennzeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Methode ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zurück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo-Typvariable (entsprechend der Pseudovariable self, deren Typ sie darstellt).
Falls Sie sich wundern, dass obige Zeilen kein Schlüsselwort zur Einleitung der Typdefinition beinhalten: STRONGTALK ist, genau wie SMALLTALK, ein interaktives, browsergestütztes System, in dem Typen in Formulare eingetragen und nicht in Textdateien spezifiziert werden. Gleichwohl fällt auf, dass innerhalb der Typdefinition in Typen als Teile von den spitzen Klammern (also da, wo Typen stehen sollen) keine Typdefinition auftauchen, sondern Namen. Und tatsächlich wird in STRONGTALK jeder Typ benannt (in seiner Typdefinition mit einem Namen versehen). Im folgenden werden Typen, ähnlich wie Klassen, in tabellarischer Form notiert.
In STRONGTALK ist die Protokollbildung der einzige sogenannte Typkonstruktor, d. h., das einzige Sprachkonstrukt, mit dem man neue Typen definieren kann. Andere Programmiersprachen sehen ein reichhaltigeres Angebot vor: In PASCAL beispielsweise gibt es die Typkonstruktoren record, array of, set of, file of, Zeiger auf (^) sowie Aufzählungen (enumerations) und Teilbereiche (ranges). In C++ gibt es u. a. class und struct (entsprechend record in PASCAL), JAVA, C# und EIFFEL bieten auch jeweils verschiedene Typkonstruktoren an. Für eine puristische Sprache wie SMALLTALK bzw. STRONGTALK reicht jedoch einer vollkommen aus.
Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten. Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das wirft natürlich die Frage auf, wie man Typen unter zwangsläufiger Selbstbezüglichkeit überhaupt eine Bedeutung beimessen kann.","<answer> In STRONGTALK gibt es keine primitiven Typen, da alle Typen in STRONGTALK auf andere Typen zurückgeführt werden können. Selbst wenn eine Typannotation weggelassen wird, hat die entsprechende Variable bzw. der Rückgabewert der Methode immer einen impliziten Typ. Dies ermöglicht es, Typen mit zwangsläufiger Selbstbezüglichkeit eine Bedeutung zuzuweisen. <answer> <question> Warum gibt es in STRONGTALK keine primitiven Typen? <question>"
"Bei allen Bemühungen, für EIFFEL ein möglichst ""wasserdichtes"" Typsystem vorzulegen und dabei so viel wie möglich zur Übersetzungszeit zu erledigen, bleibt es natürlich auch in EIFFEL-Programmen nicht aus, dass man in einen Container (eine Variable oder eine Collection) Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden (einem dynamisch gebundenen Methodenaufruf) überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt.
Solche Typtests werden in EIFFEL von einem sogenannten Zuweisungsversuch (engl. ""assignment attempt"") übernommen, der bei mangelnder (dynamisch festgestellter) Zuweisungskompatibilität einfach ""void"" (das Äquivalent von ""nil"" in SMALLTALK und ""null"" in JAVA) zuweist.
Dies ergibt nie einen Typfehler, sondern führt höchstens dazu, dass ""a"" ""void"" zugewiesen wird. Es bleibt dann die Aufgabe der Programmiererin, ""a"" nach der Zuweisung zu kontrollieren. Es entspricht dies direkt dem ""as"" aus C#, dem ""dynamic_cast<T>(x)"" aus C++ sowie dem JAVA-Konstrukt.
Explizite Typumwandlungen gibt es in EIFFEL nicht; sie können also auch keine Laufzeitfehler verursachen. Der Zuweisungsversuch erfüllt aber weitgehend die Funktion einer Typumwandlung, denn er ist nur erfolgreich, wenn die rechte Seite zuweisungskompatibel mit der linken ist, was per Definition nur dann der Fall ist, wenn die rechte Seite ein Objekt eines Subtyps (einschließlich Gleichheit) der linken Seite hat. Es wird hier allerdings die Typumwandlung immer mit einer Zuweisung verbunden; man braucht also unter Umständen eine temporäre Variable, die man sich sonst hätte sparen können. Dass der Zuweisungsversuch in EIFFEL anders als der Downcast in JAVA keinen Laufzeitfehler verursachen kann, ist wenig tröstlich, denn der Wert ""void"" in einer Variable kann es natürlich schon; in Wirklichkeit wird hier lediglich ein Typumwandlungsfehler gegen eine Nullzeiger-Ausnahme getauscht.
Die Typumwandlung wird in EIFFEL aber auch noch für etwas anderes gebraucht, nämlich für das Binden von Aufrufen kovariant redefinierter Methoden. Da EIFFEL ja, wie oben beschrieben, polymorphe CAT-Calls verbieten muss, diese aber gleichwohl notwendig sein können, hat man nur die Möglichkeit, die dynamische Bindung programmatisch zu emulieren. Und dafür braucht man Zuweisungsversuche.","<answer> Typtests in EIFFEL sind manchmal notwendig, um festzustellen, welchen genauen Typ ein Element hat, das in einen Container (eine Variable oder eine Collection) ungleichen Typs gelegt wurde. Dadurch kann das Element entsprechend seines Typs verwendet werden. <answer> <question> Warum sind Typtests in EIFFEL manchmal notwendig? <question>"
"Bei allen Bemühungen, für EIFFEL ein möglichst ""wasserdichtes"" Typsystem vorzulegen und dabei so viel wie möglich zur Übersetzungszeit zu erledigen, bleibt es natürlich auch in EIFFEL-Programmen nicht aus, dass man in einen Container (eine Variable oder eine Collection) Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden (einem dynamisch gebundenen Methodenaufruf) überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt.
Solche Typtests werden in EIFFEL von einem sogenannten Zuweisungsversuch (engl. ""assignment attempt"") übernommen, der bei mangelnder (dynamisch festgestellter) Zuweisungskompatibilität einfach ""void"" (das Äquivalent von ""nil"" in SMALLTALK und ""null"" in JAVA) zuweist.
Dies ergibt nie einen Typfehler, sondern führt höchstens dazu, dass ""a"" ""void"" zugewiesen wird. Es bleibt dann die Aufgabe der Programmiererin, ""a"" nach der Zuweisung zu kontrollieren. Es entspricht dies direkt dem ""as"" aus C#, dem ""dynamic_cast<T>(x)"" aus C++ sowie dem JAVA-Konstrukt.
Explizite Typumwandlungen gibt es in EIFFEL nicht; sie können also auch keine Laufzeitfehler verursachen. Der Zuweisungsversuch erfüllt aber weitgehend die Funktion einer Typumwandlung, denn er ist nur erfolgreich, wenn die rechte Seite zuweisungskompatibel mit der linken ist, was per Definition nur dann der Fall ist, wenn die rechte Seite ein Objekt eines Subtyps (einschließlich Gleichheit) der linken Seite hat. Es wird hier allerdings die Typumwandlung immer mit einer Zuweisung verbunden; man braucht also unter Umständen eine temporäre Variable, die man sich sonst hätte sparen können. Dass der Zuweisungsversuch in EIFFEL anders als der Downcast in JAVA keinen Laufzeitfehler verursachen kann, ist wenig tröstlich, denn der Wert ""void"" in einer Variable kann es natürlich schon; in Wirklichkeit wird hier lediglich ein Typumwandlungsfehler gegen eine Nullzeiger-Ausnahme getauscht.
Die Typumwandlung wird in EIFFEL aber auch noch für etwas anderes gebraucht, nämlich für das Binden von Aufrufen kovariant redefinierter Methoden. Da EIFFEL ja, wie oben beschrieben, polymorphe CAT-Calls verbieten muss, diese aber gleichwohl notwendig sein können, hat man nur die Möglichkeit, die dynamische Bindung programmatisch zu emulieren. Und dafür braucht man Zuweisungsversuche.","<answer> In EIFFEL wird ein Typtest mithilfe eines ""Zuweisungsversuchs"" (engl. ""assignment attempt"") durchgeführt. Wenn es keine Zuweisungskompatibilität zwischen den Typen gibt, wird ""void"" (entsprechend ""nil"" in SMALLTALK oder ""null"" in JAVA) zugewiesen. Die Programmiererin muss dann den Typ von ""a"" nach der Zuweisung überprüfen. <answer> <question> Wie wird in EIFFEL ein Typtest durchgeführt? <question>"
"Bei allen Bemühungen, für EIFFEL ein möglichst ""wasserdichtes"" Typsystem vorzulegen und dabei so viel wie möglich zur Übersetzungszeit zu erledigen, bleibt es natürlich auch in EIFFEL-Programmen nicht aus, dass man in einen Container (eine Variable oder eine Collection) Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden (einem dynamisch gebundenen Methodenaufruf) überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt.
Solche Typtests werden in EIFFEL von einem sogenannten Zuweisungsversuch (engl. ""assignment attempt"") übernommen, der bei mangelnder (dynamisch festgestellter) Zuweisungskompatibilität einfach ""void"" (das Äquivalent von ""nil"" in SMALLTALK und ""null"" in JAVA) zuweist.
Dies ergibt nie einen Typfehler, sondern führt höchstens dazu, dass ""a"" ""void"" zugewiesen wird. Es bleibt dann die Aufgabe der Programmiererin, ""a"" nach der Zuweisung zu kontrollieren. Es entspricht dies direkt dem ""as"" aus C#, dem ""dynamic_cast<T>(x)"" aus C++ sowie dem JAVA-Konstrukt.
Explizite Typumwandlungen gibt es in EIFFEL nicht; sie können also auch keine Laufzeitfehler verursachen. Der Zuweisungsversuch erfüllt aber weitgehend die Funktion einer Typumwandlung, denn er ist nur erfolgreich, wenn die rechte Seite zuweisungskompatibel mit der linken ist, was per Definition nur dann der Fall ist, wenn die rechte Seite ein Objekt eines Subtyps (einschließlich Gleichheit) der linken Seite hat. Es wird hier allerdings die Typumwandlung immer mit einer Zuweisung verbunden; man braucht also unter Umständen eine temporäre Variable, die man sich sonst hätte sparen können. Dass der Zuweisungsversuch in EIFFEL anders als der Downcast in JAVA keinen Laufzeitfehler verursachen kann, ist wenig tröstlich, denn der Wert ""void"" in einer Variable kann es natürlich schon; in Wirklichkeit wird hier lediglich ein Typumwandlungsfehler gegen eine Nullzeiger-Ausnahme getauscht.
Die Typumwandlung wird in EIFFEL aber auch noch für etwas anderes gebraucht, nämlich für das Binden von Aufrufen kovariant redefinierter Methoden. Da EIFFEL ja, wie oben beschrieben, polymorphe CAT-Calls verbieten muss, diese aber gleichwohl notwendig sein können, hat man nur die Möglichkeit, die dynamische Bindung programmatisch zu emulieren. Und dafür braucht man Zuweisungsversuche.","<answer> Der Zuweisungsversuch spielt eine Rolle bei kovarianten Redefinitionen in EIFFEL, da er verwendet wird, um dynamische Bindungen programmatisch zu emulieren. Da EIFFEL polymorphe CAT-Calls verbietet, werden Zuweisungsversuche genutzt, um das dynamische Binden zu ermöglichen. <answer> <question> Welche Rolle spielt der Zuweisungsversuch bei kovarianten Redefinitionen in EIFFEL? <question>"
"Bei allen Bemühungen, für EIFFEL ein möglichst ""wasserdichtes"" Typsystem vorzulegen und dabei so viel wie möglich zur Übersetzungszeit zu erledigen, bleibt es natürlich auch in EIFFEL-Programmen nicht aus, dass man in einen Container (eine Variable oder eine Collection) Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden (einem dynamisch gebundenen Methodenaufruf) überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt.
Solche Typtests werden in EIFFEL von einem sogenannten Zuweisungsversuch (engl. ""assignment attempt"") übernommen, der bei mangelnder (dynamisch festgestellter) Zuweisungskompatibilität einfach ""void"" (das Äquivalent von ""nil"" in SMALLTALK und ""null"" in JAVA) zuweist.
Dies ergibt nie einen Typfehler, sondern führt höchstens dazu, dass ""a"" ""void"" zugewiesen wird. Es bleibt dann die Aufgabe der Programmiererin, ""a"" nach der Zuweisung zu kontrollieren. Es entspricht dies direkt dem ""as"" aus C#, dem ""dynamic_cast<T>(x)"" aus C++ sowie dem JAVA-Konstrukt.
Explizite Typumwandlungen gibt es in EIFFEL nicht; sie können also auch keine Laufzeitfehler verursachen. Der Zuweisungsversuch erfüllt aber weitgehend die Funktion einer Typumwandlung, denn er ist nur erfolgreich, wenn die rechte Seite zuweisungskompatibel mit der linken ist, was per Definition nur dann der Fall ist, wenn die rechte Seite ein Objekt eines Subtyps (einschließlich Gleichheit) der linken Seite hat. Es wird hier allerdings die Typumwandlung immer mit einer Zuweisung verbunden; man braucht also unter Umständen eine temporäre Variable, die man sich sonst hätte sparen können. Dass der Zuweisungsversuch in EIFFEL anders als der Downcast in JAVA keinen Laufzeitfehler verursachen kann, ist wenig tröstlich, denn der Wert ""void"" in einer Variable kann es natürlich schon; in Wirklichkeit wird hier lediglich ein Typumwandlungsfehler gegen eine Nullzeiger-Ausnahme getauscht.
Die Typumwandlung wird in EIFFEL aber auch noch für etwas anderes gebraucht, nämlich für das Binden von Aufrufen kovariant redefinierter Methoden. Da EIFFEL ja, wie oben beschrieben, polymorphe CAT-Calls verbieten muss, diese aber gleichwohl notwendig sein können, hat man nur die Möglichkeit, die dynamische Bindung programmatisch zu emulieren. Und dafür braucht man Zuweisungsversuche.","<answer> Ein Unterschied besteht darin, dass Zuweisungsversuche in EIFFEL keinen Laufzeitfehler verursachen können, im Gegensatz zu Downcasts in JAVA. Allerdings kann ""void"" in einer Variable in EIFFEL zur Laufzeit eine Nullzeiger-Ausnahme auslösen. <answer> <question> Welche Unterschiede gibt es zwischen Zuweisungsversuchen in EIFFEL und Downcasts in JAVA? <question>"
"Bei allen Bemühungen, für EIFFEL ein möglichst ""wasserdichtes"" Typsystem vorzulegen und dabei so viel wie möglich zur Übersetzungszeit zu erledigen, bleibt es natürlich auch in EIFFEL-Programmen nicht aus, dass man in einen Container (eine Variable oder eine Collection) Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden (einem dynamisch gebundenen Methodenaufruf) überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt.
Solche Typtests werden in EIFFEL von einem sogenannten Zuweisungsversuch (engl. ""assignment attempt"") übernommen, der bei mangelnder (dynamisch festgestellter) Zuweisungskompatibilität einfach ""void"" (das Äquivalent von ""nil"" in SMALLTALK und ""null"" in JAVA) zuweist.
Dies ergibt nie einen Typfehler, sondern führt höchstens dazu, dass ""a"" ""void"" zugewiesen wird. Es bleibt dann die Aufgabe der Programmiererin, ""a"" nach der Zuweisung zu kontrollieren. Es entspricht dies direkt dem ""as"" aus C#, dem ""dynamic_cast<T>(x)"" aus C++ sowie dem JAVA-Konstrukt.
Explizite Typumwandlungen gibt es in EIFFEL nicht; sie können also auch keine Laufzeitfehler verursachen. Der Zuweisungsversuch erfüllt aber weitgehend die Funktion einer Typumwandlung, denn er ist nur erfolgreich, wenn die rechte Seite zuweisungskompatibel mit der linken ist, was per Definition nur dann der Fall ist, wenn die rechte Seite ein Objekt eines Subtyps (einschließlich Gleichheit) der linken Seite hat. Es wird hier allerdings die Typumwandlung immer mit einer Zuweisung verbunden; man braucht also unter Umständen eine temporäre Variable, die man sich sonst hätte sparen können. Dass der Zuweisungsversuch in EIFFEL anders als der Downcast in JAVA keinen Laufzeitfehler verursachen kann, ist wenig tröstlich, denn der Wert ""void"" in einer Variable kann es natürlich schon; in Wirklichkeit wird hier lediglich ein Typumwandlungsfehler gegen eine Nullzeiger-Ausnahme getauscht.
Die Typumwandlung wird in EIFFEL aber auch noch für etwas anderes gebraucht, nämlich für das Binden von Aufrufen kovariant redefinierter Methoden. Da EIFFEL ja, wie oben beschrieben, polymorphe CAT-Calls verbieten muss, diese aber gleichwohl notwendig sein können, hat man nur die Möglichkeit, die dynamische Bindung programmatisch zu emulieren. Und dafür braucht man Zuweisungsversuche.",<answer> In EIFFEL gibt es keine expliziten Typumwandlungen wie in einigen anderen Sprachen. Die Typumwandlung erfolgt immer in Verbindung mit einer Zuweisung. <answer> <question> Gibt es in EIFFEL explizite Typumwandlungen wie in anderen Sprachen? <question>
"Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.
Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger (Delegates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug feiert).","<answer> Nicht alle Aufgaben sind gleichermaßen zur Lösung per objektorientierter Programmierung geeignet, da einige Aufgaben besser mit anderen Programmierparadigmen wie funktionale oder logische Programmiersprachen gelöst werden können. Auch Batch- und Scripting-Probleme, die einen imperativ-prozeduralen Charakter haben, eignen sich möglicherweise nicht optimal für die objektorientierte Programmierung. <answer> <question> Warum sind nicht alle Aufgaben gleichermaßen zur Lösung per objektorientierter Programmierung geeignet? <question>"
"Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.
Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger (Delegates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug feiert).","<answer> Die gute objektorientierte Programmierung erfordert, den Code auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Bei Problemen mit einfachen Datenstrukturen und einem hohen algorithmischen Anteil müssen größere Probleme jedoch in der Regel auf durch verschiedene Klassen definierte Daten zugreifen. Dies kann dazu führen, dass der Code durch seine Datenbindung regelrecht zerfleddert wird. <answer> <question> Warum ist die gute objektorientierte Programmierung bei Problemen mit einem hohen algorithmischen Anteil und einfachen Datenstrukturen möglicherweise weniger geeignet? <question>"
"Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.
Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger (Delegates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug feiert).","<answer> In Programmen, in denen es hauptsächlich um Abläufe geht, möchte man oft, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten, was die objektorientierte Programmierung weniger ideal macht. <answer> <question> Warum ist die objektorientierte Programmierung möglicherweise nicht ideal für Programme, in denen es hauptsächlich um Abläufe geht? <question>"
"Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.
Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger (Delegates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug feiert).","<answer> Die Wahl einer geeigneten Programmiersprache ist oft ein Abwägungsproblem, da verschiedene Programmiersprachen unterschiedliche Vor- und Nachteile haben. Bei der objektorientierten Programmierung kann die Organisation der Funktionen auf der Strecke bleiben, während bei der prozeduralen Programmierung die Daten häufig in unüberschaubarer Weise hin- und hergeschickt werden oder global sind. <answer> <question> Warum ist die Wahl einer geeigneten Programmiersprache in der Praxis oft ein Abwägungsproblem? <question>"
"Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.
Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger (Delegates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug feiert).","<answer> Programmiersprachen, die eine Mischung mehrerer Paradigmen erlauben, können Anfängerinnen aufgrund ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen überfordern, wie man ein einzelnes Problem lösen kann. <answer> <question> Warum eignen sich Programmiersprachen, die eine Mischung mehrerer Paradigmen erlauben, weniger für Anfängerinnen? <question>"
"Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.
Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger (Delegates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug feiert).","<answer> Bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung besteht häufig ein Impedanzmismatch, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Die beiden Ansätze verwenden unterschiedliche Mittel zur Darstellung von Beziehungen und Datenstrukturen. <answer> <question> Warum wird bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung oft von einem Impedanzmismatch gesprochen? <question>"
"Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.
Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger (Delegates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug feiert).","<answer> Bei der Verarbeitung von relationalen Daten durch objektorientierte Programme muss man sich an die Prinzipien der relationalen Welt anpassen, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Dies erfordert häufig, einen Teil dessen, was Objektorientierung ausmacht, aufzugeben. <answer> <question> Warum muss man bei der Verarbeitung von relationalen Daten durch objektorientierte Programme oft Prinzipien der relationalen Welt anpassen? <question>"
"Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.
Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger (Delegates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug feiert).","<answer> Die GUI-Programmierung ist nicht unbedingt ein Heimspiel für die objektorientierte Programmierung, da die Instanzen einer Klasse alle Methoden teilen und es nicht möglich ist, für verschiedene GUI-Elemente derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Dies kann zu Problemen führen, insbesondere wenn es um das gemeinsame Verhalten von GUI-Elementen geht. <answer> <question> Warum ist die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung? <question>"
"Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.
Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die ""gute"" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.
Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.
So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.
Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort ""Fehlanpassung"" ist in diesem Zusammenhang ungebräuchlich).
Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine objektorientierte zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.
Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in JAVA über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C# über Funktionszeiger (Delegates in C#). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JAVASCRIPT seit Jahren einen heimlichen Siegeszug feiert).","<answer> Die prototypenbasierte Variante der objektorientierten Programmierung, wie sie in JAVASCRIPT verwendet wird, scheint besser für die GUI-Programmierung geeignet zu sein. <answer> <question> Welche Variante der objektorientierten Programmierung scheint besser für die GUI-Programmierung geeignet zu sein? <question>"
"Programme bestehen aus Schlüsselwörtern und -zeichen sowie aus Programmelementen, deren Namen, die sogenannten Bezeichner, frei vergeben werden können. Viele Programmiersprachen verlangen, dass man diese Programmelemente vor der ersten Verwendung vereinbart oder deklariert. Durch eine solche Deklaration gibt man dem Compiler den Bezeichner bekannt; er kann ihn in der Folge wiedererkennen und mit der Deklaration in Verbindung bringen.
Bei der Definition wird dem Bezeichner das zugeordnet, wofür er steht. Im Falle einer Variable ist das eine bestimmte Stelle im Speicher, die genügend Platz bietet, um den Wert der Variable aufzunehmen. Im Falle einer Methode sind es die Anweisungen, die durch die Methode zusammengefasst werden. Nicht selten (aber immer abhängig von der Programmiersprache) erfolgen Deklaration und Definition in einem Ausdruck. In solchen Fällen spricht man von Deklaration beziehungsweise Definition des Programmelementes, abhängig davon, was man gerade meint. Bei Variablen ist die Definition in der Regel implizit und aus der Deklaration ableitbar (der Speicherplatz wird vom Compiler automatisch zugewiesen), so dass man hier häufig Deklaration meint, selbst wenn man Definition sagt. Bei Methoden hingegen ist die Unterscheidung essentiell: In ihrer Deklaration wird ihre Signatur, das ist ihr Name (in SMALLTALK der Nachrichtenselektor), und die Liste der formalen Parameter bekanntgegeben. In ihrer Definition wird der Signatur der Methodenrumpf, also die Folge der mit der Methode verbundenen und bei einem Aufruf auszuführenden Anweisungen, zugeordnet. Von der Definition einer Variable zu unterscheiden ist übrigens ihre Initialisierung, bei der ihr (der dafür vorgesehenen Speicherstelle) ein Anfangswert zugewiesen wird; in manchen Kontexten (insbesondere im Kontext der Programmanalyse) ist mit Variablendefinition aber auch die Zuweisung eines Werts an eine Variable ganz allgemein gemeint.
Deklaration und Definition dienen letztlich nur einem Zweck: der Verwendung. Die Verwendung eines Programmelements äußert sich darin, dass sein Name, der Bezeichner, im Programmtext angeführt oder referenziert wird. An der Stelle der Verwendung steht eine Variable für den Wert, den sie hat (bzw., wenn sie auf der linken Seite einer Zuweisung auftaucht, haben soll). Der Bezeichner einer Methode steht hingegen meistens für ihren Aufruf (in manchen Sprachen durch ein Schlüsselwort eingeleitet), seltener auch für einen Zeiger auf die Implementierung.
Variablendeklarationen haben Sie in SMALLTALK bislang an zwei Stellen gesehen: als formale Parameter in Methodendeklarationen und als temporäre, lokale Variablen in Methodenrümpfen. Im Beispiel stecken die Deklarationen von a und b als formaler Parameter und von c als temporäre Variable. Weitere Formen der Deklaration werden Sie im Verlauf dieses Kurstextes noch kennenlernen.
In untypisierten Sprachen werden Variablen ohne Angabe eines Typs (wie z. B. in SMALLTALK) oder gar nicht (etliche Skriptsprachen und z. B. BASIC) deklariert. Letzteres hat den erheblichen Nachteil, dass Variablen durch ihre erste Verwendung quasi implizit deklariert (und damit angelegt) werden, was bei Schreibfehlern dazu führt, dass man plötzlich zwei Variablen anstatt einer hat, wobei die eine mit der anderen nichts zu tun hat. Eine solche Einladung zu Programmierfehlern sollten Sie als diejenige, die die Entscheidung für die Auswahl einer Sprache zu treffen hat, stets ablehnen.","<answer> Bezeichner sind Namen, die in der Programmierung frei vergeben werden können. Sie werden verwendet, um Programmelemente zu identifizieren und auf sie zu verweisen, beispielsweise Variablen oder Methoden. <answer> <question> Was sind Bezeichner in der Programmierung, und wie werden sie verwendet? <question>"
"Programme bestehen aus Schlüsselwörtern und -zeichen sowie aus Programmelementen, deren Namen, die sogenannten Bezeichner, frei vergeben werden können. Viele Programmiersprachen verlangen, dass man diese Programmelemente vor der ersten Verwendung vereinbart oder deklariert. Durch eine solche Deklaration gibt man dem Compiler den Bezeichner bekannt; er kann ihn in der Folge wiedererkennen und mit der Deklaration in Verbindung bringen.
Bei der Definition wird dem Bezeichner das zugeordnet, wofür er steht. Im Falle einer Variable ist das eine bestimmte Stelle im Speicher, die genügend Platz bietet, um den Wert der Variable aufzunehmen. Im Falle einer Methode sind es die Anweisungen, die durch die Methode zusammengefasst werden. Nicht selten (aber immer abhängig von der Programmiersprache) erfolgen Deklaration und Definition in einem Ausdruck. In solchen Fällen spricht man von Deklaration beziehungsweise Definition des Programmelementes, abhängig davon, was man gerade meint. Bei Variablen ist die Definition in der Regel implizit und aus der Deklaration ableitbar (der Speicherplatz wird vom Compiler automatisch zugewiesen), so dass man hier häufig Deklaration meint, selbst wenn man Definition sagt. Bei Methoden hingegen ist die Unterscheidung essentiell: In ihrer Deklaration wird ihre Signatur, das ist ihr Name (in SMALLTALK der Nachrichtenselektor), und die Liste der formalen Parameter bekanntgegeben. In ihrer Definition wird der Signatur der Methodenrumpf, also die Folge der mit der Methode verbundenen und bei einem Aufruf auszuführenden Anweisungen, zugeordnet. Von der Definition einer Variable zu unterscheiden ist übrigens ihre Initialisierung, bei der ihr (der dafür vorgesehenen Speicherstelle) ein Anfangswert zugewiesen wird; in manchen Kontexten (insbesondere im Kontext der Programmanalyse) ist mit Variablendefinition aber auch die Zuweisung eines Werts an eine Variable ganz allgemein gemeint.
Deklaration und Definition dienen letztlich nur einem Zweck: der Verwendung. Die Verwendung eines Programmelements äußert sich darin, dass sein Name, der Bezeichner, im Programmtext angeführt oder referenziert wird. An der Stelle der Verwendung steht eine Variable für den Wert, den sie hat (bzw., wenn sie auf der linken Seite einer Zuweisung auftaucht, haben soll). Der Bezeichner einer Methode steht hingegen meistens für ihren Aufruf (in manchen Sprachen durch ein Schlüsselwort eingeleitet), seltener auch für einen Zeiger auf die Implementierung.
Variablendeklarationen haben Sie in SMALLTALK bislang an zwei Stellen gesehen: als formale Parameter in Methodendeklarationen und als temporäre, lokale Variablen in Methodenrümpfen. Im Beispiel stecken die Deklarationen von a und b als formaler Parameter und von c als temporäre Variable. Weitere Formen der Deklaration werden Sie im Verlauf dieses Kurstextes noch kennenlernen.
In untypisierten Sprachen werden Variablen ohne Angabe eines Typs (wie z. B. in SMALLTALK) oder gar nicht (etliche Skriptsprachen und z. B. BASIC) deklariert. Letzteres hat den erheblichen Nachteil, dass Variablen durch ihre erste Verwendung quasi implizit deklariert (und damit angelegt) werden, was bei Schreibfehlern dazu führt, dass man plötzlich zwei Variablen anstatt einer hat, wobei die eine mit der anderen nichts zu tun hat. Eine solche Einladung zu Programmierfehlern sollten Sie als diejenige, die die Entscheidung für die Auswahl einer Sprache zu treffen hat, stets ablehnen.","<answer> Die Deklaration von Programmelementen in der Programmierung dient dazu, dem Compiler den Bezeichner bekanntzugeben, damit er ihn in der Folge wiedererkennen und mit der entsprechenden Definition in Verbindung bringen kann. <answer> <question> Was ist der Zweck der Deklaration von Programmelementen in der Programmierung? <question>"
"Programme bestehen aus Schlüsselwörtern und -zeichen sowie aus Programmelementen, deren Namen, die sogenannten Bezeichner, frei vergeben werden können. Viele Programmiersprachen verlangen, dass man diese Programmelemente vor der ersten Verwendung vereinbart oder deklariert. Durch eine solche Deklaration gibt man dem Compiler den Bezeichner bekannt; er kann ihn in der Folge wiedererkennen und mit der Deklaration in Verbindung bringen.
Bei der Definition wird dem Bezeichner das zugeordnet, wofür er steht. Im Falle einer Variable ist das eine bestimmte Stelle im Speicher, die genügend Platz bietet, um den Wert der Variable aufzunehmen. Im Falle einer Methode sind es die Anweisungen, die durch die Methode zusammengefasst werden. Nicht selten (aber immer abhängig von der Programmiersprache) erfolgen Deklaration und Definition in einem Ausdruck. In solchen Fällen spricht man von Deklaration beziehungsweise Definition des Programmelementes, abhängig davon, was man gerade meint. Bei Variablen ist die Definition in der Regel implizit und aus der Deklaration ableitbar (der Speicherplatz wird vom Compiler automatisch zugewiesen), so dass man hier häufig Deklaration meint, selbst wenn man Definition sagt. Bei Methoden hingegen ist die Unterscheidung essentiell: In ihrer Deklaration wird ihre Signatur, das ist ihr Name (in SMALLTALK der Nachrichtenselektor), und die Liste der formalen Parameter bekanntgegeben. In ihrer Definition wird der Signatur der Methodenrumpf, also die Folge der mit der Methode verbundenen und bei einem Aufruf auszuführenden Anweisungen, zugeordnet. Von der Definition einer Variable zu unterscheiden ist übrigens ihre Initialisierung, bei der ihr (der dafür vorgesehenen Speicherstelle) ein Anfangswert zugewiesen wird; in manchen Kontexten (insbesondere im Kontext der Programmanalyse) ist mit Variablendefinition aber auch die Zuweisung eines Werts an eine Variable ganz allgemein gemeint.
Deklaration und Definition dienen letztlich nur einem Zweck: der Verwendung. Die Verwendung eines Programmelements äußert sich darin, dass sein Name, der Bezeichner, im Programmtext angeführt oder referenziert wird. An der Stelle der Verwendung steht eine Variable für den Wert, den sie hat (bzw., wenn sie auf der linken Seite einer Zuweisung auftaucht, haben soll). Der Bezeichner einer Methode steht hingegen meistens für ihren Aufruf (in manchen Sprachen durch ein Schlüsselwort eingeleitet), seltener auch für einen Zeiger auf die Implementierung.
Variablendeklarationen haben Sie in SMALLTALK bislang an zwei Stellen gesehen: als formale Parameter in Methodendeklarationen und als temporäre, lokale Variablen in Methodenrümpfen. Im Beispiel stecken die Deklarationen von a und b als formaler Parameter und von c als temporäre Variable. Weitere Formen der Deklaration werden Sie im Verlauf dieses Kurstextes noch kennenlernen.
In untypisierten Sprachen werden Variablen ohne Angabe eines Typs (wie z. B. in SMALLTALK) oder gar nicht (etliche Skriptsprachen und z. B. BASIC) deklariert. Letzteres hat den erheblichen Nachteil, dass Variablen durch ihre erste Verwendung quasi implizit deklariert (und damit angelegt) werden, was bei Schreibfehlern dazu führt, dass man plötzlich zwei Variablen anstatt einer hat, wobei die eine mit der anderen nichts zu tun hat. Eine solche Einladung zu Programmierfehlern sollten Sie als diejenige, die die Entscheidung für die Auswahl einer Sprache zu treffen hat, stets ablehnen.","<answer> Deklaration gibt dem Bezeichner bekannt, während Definition ihm sagt, wofür er steht. Bei Variablen kann die Definition implizit sein und aus der Deklaration abgeleitet werden, während bei Methoden die Unterscheidung zwischen Deklaration (Signatur) und Definition (Methodenrumpf) essentiell ist. <answer> <question> Was ist der Unterschied zwischen Deklaration und Definition in der Programmierung? <question>"
"Programme bestehen aus Schlüsselwörtern und -zeichen sowie aus Programmelementen, deren Namen, die sogenannten Bezeichner, frei vergeben werden können. Viele Programmiersprachen verlangen, dass man diese Programmelemente vor der ersten Verwendung vereinbart oder deklariert. Durch eine solche Deklaration gibt man dem Compiler den Bezeichner bekannt; er kann ihn in der Folge wiedererkennen und mit der Deklaration in Verbindung bringen.
Bei der Definition wird dem Bezeichner das zugeordnet, wofür er steht. Im Falle einer Variable ist das eine bestimmte Stelle im Speicher, die genügend Platz bietet, um den Wert der Variable aufzunehmen. Im Falle einer Methode sind es die Anweisungen, die durch die Methode zusammengefasst werden. Nicht selten (aber immer abhängig von der Programmiersprache) erfolgen Deklaration und Definition in einem Ausdruck. In solchen Fällen spricht man von Deklaration beziehungsweise Definition des Programmelementes, abhängig davon, was man gerade meint. Bei Variablen ist die Definition in der Regel implizit und aus der Deklaration ableitbar (der Speicherplatz wird vom Compiler automatisch zugewiesen), so dass man hier häufig Deklaration meint, selbst wenn man Definition sagt. Bei Methoden hingegen ist die Unterscheidung essentiell: In ihrer Deklaration wird ihre Signatur, das ist ihr Name (in SMALLTALK der Nachrichtenselektor), und die Liste der formalen Parameter bekanntgegeben. In ihrer Definition wird der Signatur der Methodenrumpf, also die Folge der mit der Methode verbundenen und bei einem Aufruf auszuführenden Anweisungen, zugeordnet. Von der Definition einer Variable zu unterscheiden ist übrigens ihre Initialisierung, bei der ihr (der dafür vorgesehenen Speicherstelle) ein Anfangswert zugewiesen wird; in manchen Kontexten (insbesondere im Kontext der Programmanalyse) ist mit Variablendefinition aber auch die Zuweisung eines Werts an eine Variable ganz allgemein gemeint.
Deklaration und Definition dienen letztlich nur einem Zweck: der Verwendung. Die Verwendung eines Programmelements äußert sich darin, dass sein Name, der Bezeichner, im Programmtext angeführt oder referenziert wird. An der Stelle der Verwendung steht eine Variable für den Wert, den sie hat (bzw., wenn sie auf der linken Seite einer Zuweisung auftaucht, haben soll). Der Bezeichner einer Methode steht hingegen meistens für ihren Aufruf (in manchen Sprachen durch ein Schlüsselwort eingeleitet), seltener auch für einen Zeiger auf die Implementierung.
Variablendeklarationen haben Sie in SMALLTALK bislang an zwei Stellen gesehen: als formale Parameter in Methodendeklarationen und als temporäre, lokale Variablen in Methodenrümpfen. Im Beispiel stecken die Deklarationen von a und b als formaler Parameter und von c als temporäre Variable. Weitere Formen der Deklaration werden Sie im Verlauf dieses Kurstextes noch kennenlernen.
In untypisierten Sprachen werden Variablen ohne Angabe eines Typs (wie z. B. in SMALLTALK) oder gar nicht (etliche Skriptsprachen und z. B. BASIC) deklariert. Letzteres hat den erheblichen Nachteil, dass Variablen durch ihre erste Verwendung quasi implizit deklariert (und damit angelegt) werden, was bei Schreibfehlern dazu führt, dass man plötzlich zwei Variablen anstatt einer hat, wobei die eine mit der anderen nichts zu tun hat. Eine solche Einladung zu Programmierfehlern sollten Sie als diejenige, die die Entscheidung für die Auswahl einer Sprache zu treffen hat, stets ablehnen.","<answer> Die Verwendung eines Programmelements zeigt sich darin, dass sein Name (Bezeichner) im Programmtext angeführt oder referenziert wird. An dieser Stelle kann eine Variable für ihren aktuellen Wert oder eine Methode für ihren Aufruf stehen. <answer> <question> Wie äußert sich die Verwendung eines Programmelements in einem Programmtext? <question>"
"Programme bestehen aus Schlüsselwörtern und -zeichen sowie aus Programmelementen, deren Namen, die sogenannten Bezeichner, frei vergeben werden können. Viele Programmiersprachen verlangen, dass man diese Programmelemente vor der ersten Verwendung vereinbart oder deklariert. Durch eine solche Deklaration gibt man dem Compiler den Bezeichner bekannt; er kann ihn in der Folge wiedererkennen und mit der Deklaration in Verbindung bringen.
Bei der Definition wird dem Bezeichner das zugeordnet, wofür er steht. Im Falle einer Variable ist das eine bestimmte Stelle im Speicher, die genügend Platz bietet, um den Wert der Variable aufzunehmen. Im Falle einer Methode sind es die Anweisungen, die durch die Methode zusammengefasst werden. Nicht selten (aber immer abhängig von der Programmiersprache) erfolgen Deklaration und Definition in einem Ausdruck. In solchen Fällen spricht man von Deklaration beziehungsweise Definition des Programmelementes, abhängig davon, was man gerade meint. Bei Variablen ist die Definition in der Regel implizit und aus der Deklaration ableitbar (der Speicherplatz wird vom Compiler automatisch zugewiesen), so dass man hier häufig Deklaration meint, selbst wenn man Definition sagt. Bei Methoden hingegen ist die Unterscheidung essentiell: In ihrer Deklaration wird ihre Signatur, das ist ihr Name (in SMALLTALK der Nachrichtenselektor), und die Liste der formalen Parameter bekanntgegeben. In ihrer Definition wird der Signatur der Methodenrumpf, also die Folge der mit der Methode verbundenen und bei einem Aufruf auszuführenden Anweisungen, zugeordnet. Von der Definition einer Variable zu unterscheiden ist übrigens ihre Initialisierung, bei der ihr (der dafür vorgesehenen Speicherstelle) ein Anfangswert zugewiesen wird; in manchen Kontexten (insbesondere im Kontext der Programmanalyse) ist mit Variablendefinition aber auch die Zuweisung eines Werts an eine Variable ganz allgemein gemeint.
Deklaration und Definition dienen letztlich nur einem Zweck: der Verwendung. Die Verwendung eines Programmelements äußert sich darin, dass sein Name, der Bezeichner, im Programmtext angeführt oder referenziert wird. An der Stelle der Verwendung steht eine Variable für den Wert, den sie hat (bzw., wenn sie auf der linken Seite einer Zuweisung auftaucht, haben soll). Der Bezeichner einer Methode steht hingegen meistens für ihren Aufruf (in manchen Sprachen durch ein Schlüsselwort eingeleitet), seltener auch für einen Zeiger auf die Implementierung.
Variablendeklarationen haben Sie in SMALLTALK bislang an zwei Stellen gesehen: als formale Parameter in Methodendeklarationen und als temporäre, lokale Variablen in Methodenrümpfen. Im Beispiel stecken die Deklarationen von a und b als formaler Parameter und von c als temporäre Variable. Weitere Formen der Deklaration werden Sie im Verlauf dieses Kurstextes noch kennenlernen.
In untypisierten Sprachen werden Variablen ohne Angabe eines Typs (wie z. B. in SMALLTALK) oder gar nicht (etliche Skriptsprachen und z. B. BASIC) deklariert. Letzteres hat den erheblichen Nachteil, dass Variablen durch ihre erste Verwendung quasi implizit deklariert (und damit angelegt) werden, was bei Schreibfehlern dazu führt, dass man plötzlich zwei Variablen anstatt einer hat, wobei die eine mit der anderen nichts zu tun hat. Eine solche Einladung zu Programmierfehlern sollten Sie als diejenige, die die Entscheidung für die Auswahl einer Sprache zu treffen hat, stets ablehnen.","<answer> In untypisierten Sprachen, in denen Variablen ohne Angabe eines Typs deklariert werden, kann es zu Problemen führen, da Variablen quasi implizit deklariert werden, wenn sie zum ersten Mal verwendet werden. Dies kann zu Schreibfehlern führen, bei denen versehentlich zwei Variablen mit dem gleichen Namen erstellt werden, die jedoch nichts miteinander zu tun haben. Dies erhöht das Risiko von Programmierfehlern. <answer> <question> Welche Probleme können in untypisierten Sprachen auftreten, wenn Variablen ohne Angabe eines Typs deklariert werden? <question>"
"Laufzeitfehler der obigen Art vermeidet man in JAVA mit Hilfe sogenannter Typtests, die man vor einer Typumwandlung durchführt. Das dazugehörige Schlüsselwort heißt instanceof.
Typtests in Kombination mit bedingten Umwandlungen (Casting) bilden die typsichere Variante der Typumwandlung. Es bleibt allerdings an der Programmiererin hängen, zu sagen, was passieren soll, wenn der Wert von 'o' nicht den geforderten Typ (hier String) hat.","<answer> Man vermeidet Laufzeitfehler bei Typumwandlungen in Java mithilfe von Typtests, die vor der Typumwandlung durchgeführt werden. <answer> <question> Wie vermeidet man Laufzeitfehler bei Typumwandlungen in Java? <question>"
"Laufzeitfehler der obigen Art vermeidet man in JAVA mit Hilfe sogenannter Typtests, die man vor einer Typumwandlung durchführt. Das dazugehörige Schlüsselwort heißt instanceof.
Typtests in Kombination mit bedingten Umwandlungen (Casting) bilden die typsichere Variante der Typumwandlung. Es bleibt allerdings an der Programmiererin hängen, zu sagen, was passieren soll, wenn der Wert von 'o' nicht den geforderten Typ (hier String) hat.","<answer> Das Schlüsselwort für Typtests in Java lautet ""instanceof"". <answer> <question> Welches Schlüsselwort wird in Java für Typtests verwendet? <question>"
"Laufzeitfehler der obigen Art vermeidet man in JAVA mit Hilfe sogenannter Typtests, die man vor einer Typumwandlung durchführt. Das dazugehörige Schlüsselwort heißt instanceof.
Typtests in Kombination mit bedingten Umwandlungen (Casting) bilden die typsichere Variante der Typumwandlung. Es bleibt allerdings an der Programmiererin hängen, zu sagen, was passieren soll, wenn der Wert von 'o' nicht den geforderten Typ (hier String) hat.","<answer> Typtests in Kombination mit bedingten Umwandlungen bilden die typsichere Variante der Typumwandlung und helfen, Laufzeitfehler zu vermeiden. <answer> <question> Welche Vorteile bieten Typtests in Kombination mit bedingten Umwandlungen? <question>"
"Laufzeitfehler der obigen Art vermeidet man in JAVA mit Hilfe sogenannter Typtests, die man vor einer Typumwandlung durchführt. Das dazugehörige Schlüsselwort heißt instanceof.
Typtests in Kombination mit bedingten Umwandlungen (Casting) bilden die typsichere Variante der Typumwandlung. Es bleibt allerdings an der Programmiererin hängen, zu sagen, was passieren soll, wenn der Wert von 'o' nicht den geforderten Typ (hier String) hat.","<answer> Es obliegt der Programmiererin, zu definieren, was passieren soll, wenn der Typtest fehlschlägt, d.h., wenn das Objekt nicht den geforderten Typ hat. <answer> <question> Wem obliegt es, zu definieren, was passieren soll, wenn der Typtest fehlschlägt? <question>"
"Definierte Typen können in Programmen verwendet werden, in STRONGTALK bei der Deklaration von (anderen) Typen, von Variablen, von Blöcken und von Methoden. Man spricht dann von einer Typisierung der deklarierten Programmelemente. Die Verwendung in Typdefinitionen haben Sie bereits oben kennengelernt, die Verwendung in Methoden verläuft analog. Variablen (Instanzvariablen, temporäre Variablen, etc.) werden in STRONGTALK genauso wie formale Parameter (die ebenfalls Variablen sind) typisiert, nämlich durch die Anfügung eines Typnamens in spitzen Klammern. Bei Blöcken taucht der Rückgabetyp im selben Segment wie die formalen Parameter auf, also vor dem Seperator.","<answer> Definierte Typen können in STRONGTALK-Programmen bei der Deklaration von (anderen) Typen, von Variablen, von Blöcken und von Methoden verwendet werden. Dies führt zu einer Typisierung der deklarierten Programmelemente. <answer> <question> Wie können definierte Typen in STRONGTALK-Programmen verwendet werden? <question>"
"Definierte Typen können in Programmen verwendet werden, in STRONGTALK bei der Deklaration von (anderen) Typen, von Variablen, von Blöcken und von Methoden. Man spricht dann von einer Typisierung der deklarierten Programmelemente. Die Verwendung in Typdefinitionen haben Sie bereits oben kennengelernt, die Verwendung in Methoden verläuft analog. Variablen (Instanzvariablen, temporäre Variablen, etc.) werden in STRONGTALK genauso wie formale Parameter (die ebenfalls Variablen sind) typisiert, nämlich durch die Anfügung eines Typnamens in spitzen Klammern. Bei Blöcken taucht der Rückgabetyp im selben Segment wie die formalen Parameter auf, also vor dem Seperator.","<answer> Die Verwendung von definierten Typen in Typdefinitionen und Methoden erfolgt analog. In Methoden werden Variablen (einschließlich formaler Parameter) durch die Anfügung eines Typnamens in spitzen Klammern typisiert. Der Rückgabetyp eines Blocks wird im selben Segment wie die formalen Parameter angegeben, also vor dem Trennzeichen. <answer> <question> Wie erfolgt die Verwendung definierter Typen in Typdefinitionen und Methoden in STRONGTALK? <question>"
"Definierte Typen können in Programmen verwendet werden, in STRONGTALK bei der Deklaration von (anderen) Typen, von Variablen, von Blöcken und von Methoden. Man spricht dann von einer Typisierung der deklarierten Programmelemente. Die Verwendung in Typdefinitionen haben Sie bereits oben kennengelernt, die Verwendung in Methoden verläuft analog. Variablen (Instanzvariablen, temporäre Variablen, etc.) werden in STRONGTALK genauso wie formale Parameter (die ebenfalls Variablen sind) typisiert, nämlich durch die Anfügung eines Typnamens in spitzen Klammern. Bei Blöcken taucht der Rückgabetyp im selben Segment wie die formalen Parameter auf, also vor dem Seperator.","<answer> Variablen (einschließlich Instanzvariablen und temporäre Variablen) werden in STRONGTALK typisiert, indem ein Typname in spitzen Klammern an die Variable angehängt wird. <answer> <question> Wie werden Variablen in STRONGTALK typisiert? <question>"
"Definierte Typen können in Programmen verwendet werden, in STRONGTALK bei der Deklaration von (anderen) Typen, von Variablen, von Blöcken und von Methoden. Man spricht dann von einer Typisierung der deklarierten Programmelemente. Die Verwendung in Typdefinitionen haben Sie bereits oben kennengelernt, die Verwendung in Methoden verläuft analog. Variablen (Instanzvariablen, temporäre Variablen, etc.) werden in STRONGTALK genauso wie formale Parameter (die ebenfalls Variablen sind) typisiert, nämlich durch die Anfügung eines Typnamens in spitzen Klammern. Bei Blöcken taucht der Rückgabetyp im selben Segment wie die formalen Parameter auf, also vor dem Seperator.","<answer> Der Rückgabetyp für Blöcke in STRONGTALK wird im selben Segment wie die formalen Parameter angegeben, und zwar vor dem Trennzeichen. <answer> <question> Wo wird der Rückgabetyp für Blöcke in STRONGTALK angegeben? <question>"
"Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).
An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.
Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.
Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumindest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft. Dies verlangt nach Erklärung.
Stellen Sie sich einen Collection-Typ MyCollection vor, dessen Werte solche Collections sein sollen, deren Elemente sortiert und summiert werden können.
Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren lässt, der vom Typ Number oder einem Subtyp davon ist. Man kann daraus schließen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müssen, die einen solchen Wert zurückliefern.
Das aber verlangt, dass der Elementtyp von MyCollection Number oder ein Subtyp davon sein muss, da sonst die Zuweisung an den formalen Blockparameter element nicht zulässig wäre.
Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.
Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicherheit, dass alle Typen, die für E eingesetzt werden können, bestimmte Eigenschaften haben, im gegebenen Beispiel, dass sie sortierbar und addierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, sondern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, nämlich bei der Verwendung (der Instanziierung) der parametrischen Typdefinition in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Polymorphismus, der im nächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.","<answer> Bei der Verwendung von Inklusionspolymorphie tritt der konkrete Typ ""Object"" an die Stelle der Typvariable E. <answer> <question> Welcher konkrete Typ tritt an die Stelle der Typvariable E bei der Verwendung von Inklusionspolymorphie? <question>"
"Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).
An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.
Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.
Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumindest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft. Dies verlangt nach Erklärung.
Stellen Sie sich einen Collection-Typ MyCollection vor, dessen Werte solche Collections sein sollen, deren Elemente sortiert und summiert werden können.
Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren lässt, der vom Typ Number oder einem Subtyp davon ist. Man kann daraus schließen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müssen, die einen solchen Wert zurückliefern.
Das aber verlangt, dass der Elementtyp von MyCollection Number oder ein Subtyp davon sein muss, da sonst die Zuweisung an den formalen Blockparameter element nicht zulässig wäre.
Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.
Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicherheit, dass alle Typen, die für E eingesetzt werden können, bestimmte Eigenschaften haben, im gegebenen Beispiel, dass sie sortierbar und addierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, sondern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, nämlich bei der Verwendung (der Instanziierung) der parametrischen Typdefinition in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Polymorphismus, der im nächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.","<answer> Ein Typfehler kann auftreten, wenn Methoden auf Objekten eines konkreten Subtyps von ""Object"" aufgerufen werden, da die statische Typprüfung solche Methoden nicht unterstützt. <answer> <question> Welche Art von Typfehler kann auftreten, wenn Inklusionspolymorphie verwendet wird? <question>"
"Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).
An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.
Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.
Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumindest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft. Dies verlangt nach Erklärung.
Stellen Sie sich einen Collection-Typ MyCollection vor, dessen Werte solche Collections sein sollen, deren Elemente sortiert und summiert werden können.
Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren lässt, der vom Typ Number oder einem Subtyp davon ist. Man kann daraus schließen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müssen, die einen solchen Wert zurückliefern.
Das aber verlangt, dass der Elementtyp von MyCollection Number oder ein Subtyp davon sein muss, da sonst die Zuweisung an den formalen Blockparameter element nicht zulässig wäre.
Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.
Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicherheit, dass alle Typen, die für E eingesetzt werden können, bestimmte Eigenschaften haben, im gegebenen Beispiel, dass sie sortierbar und addierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, sondern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, nämlich bei der Verwendung (der Instanziierung) der parametrischen Typdefinition in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Polymorphismus, der im nächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.","<answer> Der parametrische Polymorphismus bietet den Vorteil einer erhöhten Typsicherheit, da Typfehler bereits zur Instanziierung des parametrischen Typs erkannt werden können. <answer> <question> Welchen Vorteil bietet der parametrische Polymorphismus gegenüber der Inklusionspolymorphie? <question>"
"Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).
An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.
Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.
Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumindest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft. Dies verlangt nach Erklärung.
Stellen Sie sich einen Collection-Typ MyCollection vor, dessen Werte solche Collections sein sollen, deren Elemente sortiert und summiert werden können.
Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren lässt, der vom Typ Number oder einem Subtyp davon ist. Man kann daraus schließen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müssen, die einen solchen Wert zurückliefern.
Das aber verlangt, dass der Elementtyp von MyCollection Number oder ein Subtyp davon sein muss, da sonst die Zuweisung an den formalen Blockparameter element nicht zulässig wäre.
Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.
Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicherheit, dass alle Typen, die für E eingesetzt werden können, bestimmte Eigenschaften haben, im gegebenen Beispiel, dass sie sortierbar und addierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, sondern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, nämlich bei der Verwendung (der Instanziierung) der parametrischen Typdefinition in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Polymorphismus, der im nächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.","<answer> In der Praxis wird trotz Verwendung parametrischer Definitionen von Collections oft auf Inklusionspolymorphie zurückgegriffen, da heterogene Collections, die Objekte unterschiedlicher Subtypen enthalten, häufig vorkommen und Inklusionspolymorphie dies ermöglicht. <answer> <question> Warum wird in der Praxis trotz Verwendung parametrischer Definitionen von Collections oft auch auf Inklusionspolymorphie zurückgegriffen? <question>"
"Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).
An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.
Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.
Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumindest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft. Dies verlangt nach Erklärung.
Stellen Sie sich einen Collection-Typ MyCollection vor, dessen Werte solche Collections sein sollen, deren Elemente sortiert und summiert werden können.
Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren lässt, der vom Typ Number oder einem Subtyp davon ist. Man kann daraus schließen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müssen, die einen solchen Wert zurückliefern.
Das aber verlangt, dass der Elementtyp von MyCollection Number oder ein Subtyp davon sein muss, da sonst die Zuweisung an den formalen Blockparameter element nicht zulässig wäre.
Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.
Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicherheit, dass alle Typen, die für E eingesetzt werden können, bestimmte Eigenschaften haben, im gegebenen Beispiel, dass sie sortierbar und addierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, sondern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, nämlich bei der Verwendung (der Instanziierung) der parametrischen Typdefinition in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Polymorphismus, der im nächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.","<answer> Bei der Verwendung parametrischer Typen geht man einen Kompromiss ein, bei dem die erhöhte Typsicherheit außerhalb der Typdefinition durch eine geringere Typsicherheit innerhalb der Typdefinition erkauft wird. <answer> <question> Welchen Kompromiss geht man bei der Verwendung parametrischer Typen ein? <question>"
"Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).
An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.
Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.
Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumindest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft. Dies verlangt nach Erklärung.
Stellen Sie sich einen Collection-Typ MyCollection vor, dessen Werte solche Collections sein sollen, deren Elemente sortiert und summiert werden können.
Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren lässt, der vom Typ Number oder einem Subtyp davon ist. Man kann daraus schließen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müssen, die einen solchen Wert zurückliefern.
Das aber verlangt, dass der Elementtyp von MyCollection Number oder ein Subtyp davon sein muss, da sonst die Zuweisung an den formalen Blockparameter element nicht zulässig wäre.
Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.
Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicherheit, dass alle Typen, die für E eingesetzt werden können, bestimmte Eigenschaften haben, im gegebenen Beispiel, dass sie sortierbar und addierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, sondern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, nämlich bei der Verwendung (der Instanziierung) der parametrischen Typdefinition in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Polymorphismus, der im nächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.","<answer> Die Typen, die für die Typvariable E eingesetzt werden können, müssen bestimmte Eigenschaften haben, wie z.B. Sortierbarkeit und Addierbarkeit, um die Sicherheit zu gewährleisten. <answer> <question> Welche Eigenschaften müssen die Typen haben, die für die Typvariable E eingesetzt werden können, um die Sicherheit zu gewährleisten? <question>"
"Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).
An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.
Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.
Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumindest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft. Dies verlangt nach Erklärung.
Stellen Sie sich einen Collection-Typ MyCollection vor, dessen Werte solche Collections sein sollen, deren Elemente sortiert und summiert werden können.
Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren lässt, der vom Typ Number oder einem Subtyp davon ist. Man kann daraus schließen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müssen, die einen solchen Wert zurückliefern.
Das aber verlangt, dass der Elementtyp von MyCollection Number oder ein Subtyp davon sein muss, da sonst die Zuweisung an den formalen Blockparameter element nicht zulässig wäre.
Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.
Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicherheit, dass alle Typen, die für E eingesetzt werden können, bestimmte Eigenschaften haben, im gegebenen Beispiel, dass sie sortierbar und addierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, sondern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, nämlich bei der Verwendung (der Instanziierung) der parametrischen Typdefinition in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Polymorphismus, der im nächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.","<answer> Es ist wichtig, dass ein Typfehler bereits bei der Verwendung der parametrischen Typdefinition erkannt wird, um sicherzustellen, dass alle eingesetzten Typen die erforderlichen Eigenschaften haben, bevor sie verwendet werden. <answer> <question> Warum ist es wichtig, dass ein Typfehler bereits bei der Verwendung der parametrischen Typdefinition erkannt wird? <question>"
"Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).
An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast (s. Kapitel 27), vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.
Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.
Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumindest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft. Dies verlangt nach Erklärung.
Stellen Sie sich einen Collection-Typ MyCollection vor, dessen Werte solche Collections sein sollen, deren Elemente sortiert und summiert werden können.
Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren lässt, der vom Typ Number oder einem Subtyp davon ist. Man kann daraus schließen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müssen, die einen solchen Wert zurückliefern.
Das aber verlangt, dass der Elementtyp von MyCollection Number oder ein Subtyp davon sein muss, da sonst die Zuweisung an den formalen Blockparameter element nicht zulässig wäre.
Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.
Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicherheit, dass alle Typen, die für E eingesetzt werden können, bestimmte Eigenschaften haben, im gegebenen Beispiel, dass sie sortierbar und addierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, sondern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, nämlich bei der Verwendung (der Instanziierung) der parametrischen Typdefinition in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Polymorphismus, der im nächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.","<answer> Der beschränkte parametrische Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen, um Typfehler frühzeitig zu erkennen. <answer> <question> Welche Art von Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen? <question>"
"Kein Objekt existiert isoliert. Im Gegenteil, Objekte müssen in Beziehung zueinander stehen, um Bedeutung zu erlangen. Zum Beispiel hat das Objekt ""1"" keine Bedeutung, solange es nicht eine spezifische Eigenschaft eines anderen Objekts beschreibt, wie die Hausnummer eines Hauses oder die Anzahl der Elemente in einem Array. Tatsächlich werden die meisten Objekte in einem System erst durch ihre Beziehungen zu anderen Objekten nützlich. Ein Objekt, das eine Person repräsentiert, wird erst dann durch den Namen ""Hans Mustermann"" identifizierbar, wenn es in einer entsprechenden Beziehung zur Person steht, und umgekehrt.
In der objektorientierten Programmierung wird, wie bereits zu Beginn dieses Abschnitts erwähnt, alle Information als ein Netzwerk von miteinander verbundenen Objekten dargestellt. Dieses Netzwerk kann auf zwei Arten verwendet werden: Durch Navigation, um von einem Datenelement (Information) zum anderen zu gelangen, oder durch Manipulation, um die repräsentierte Information zu ändern.
Das Datenmodell der objektorientierten Programmierung ähnelt dem Netzwerkmodell, das vor einigen Jahrzehnten die Grundlage für große Datenbankmanagementsysteme bildete, bevor es vom relationalen Datenmodell verdrängt wurde. Erst mit der Einführung objektorientierter Datenbanken gewinnt das Netzwerkmodell wieder an theoretischer Bedeutung.
In der objektorientierten Programmierung werden Beziehungen zwischen Objekten über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten ""navigieren"". Es ist wichtig zu beachten, dass diese Verknüpfung immer gerichtet ist. Das bedeutet, dass man von einem Objekt zu einem anderen navigieren kann, aber nicht zwangsläufig wieder zurück. Dafür wäre ein Zeiger in Gegenrichtung erforderlich.
Variablen selbst enthalten ebenfalls Verweise. Wer also Zugriff auf die Variable hat, kann auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.","<answer> Objekte müssen in Beziehung zueinander stehen, um Bedeutung zu erlangen, da die meisten Objekte in einem System erst durch ihre Beziehungen zu anderen Objekten nützlich werden. Ein Objekt allein, wie das Objekt ""1"", hat keine Bedeutung, bis es in einer entsprechenden Beziehung zu einem anderen Objekt steht, das seine Bedeutung verleiht. <answer> <question> Warum ist es wichtig, dass Objekte in Beziehung zueinander stehen, um Bedeutung zu erlangen? <question>"
"Kein Objekt existiert isoliert. Im Gegenteil, Objekte müssen in Beziehung zueinander stehen, um Bedeutung zu erlangen. Zum Beispiel hat das Objekt ""1"" keine Bedeutung, solange es nicht eine spezifische Eigenschaft eines anderen Objekts beschreibt, wie die Hausnummer eines Hauses oder die Anzahl der Elemente in einem Array. Tatsächlich werden die meisten Objekte in einem System erst durch ihre Beziehungen zu anderen Objekten nützlich. Ein Objekt, das eine Person repräsentiert, wird erst dann durch den Namen ""Hans Mustermann"" identifizierbar, wenn es in einer entsprechenden Beziehung zur Person steht, und umgekehrt.
In der objektorientierten Programmierung wird, wie bereits zu Beginn dieses Abschnitts erwähnt, alle Information als ein Netzwerk von miteinander verbundenen Objekten dargestellt. Dieses Netzwerk kann auf zwei Arten verwendet werden: Durch Navigation, um von einem Datenelement (Information) zum anderen zu gelangen, oder durch Manipulation, um die repräsentierte Information zu ändern.
Das Datenmodell der objektorientierten Programmierung ähnelt dem Netzwerkmodell, das vor einigen Jahrzehnten die Grundlage für große Datenbankmanagementsysteme bildete, bevor es vom relationalen Datenmodell verdrängt wurde. Erst mit der Einführung objektorientierter Datenbanken gewinnt das Netzwerkmodell wieder an theoretischer Bedeutung.
In der objektorientierten Programmierung werden Beziehungen zwischen Objekten über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten ""navigieren"". Es ist wichtig zu beachten, dass diese Verknüpfung immer gerichtet ist. Das bedeutet, dass man von einem Objekt zu einem anderen navigieren kann, aber nicht zwangsläufig wieder zurück. Dafür wäre ein Zeiger in Gegenrichtung erforderlich.
Variablen selbst enthalten ebenfalls Verweise. Wer also Zugriff auf die Variable hat, kann auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.",<answer> In der objektorientierten Programmierung wird Information als ein Netzwerk von miteinander verbundenen Objekten dargestellt. <answer> <question> Wie wird in der objektorientierten Programmierung Information dargestellt? <question>
"Kein Objekt existiert isoliert. Im Gegenteil, Objekte müssen in Beziehung zueinander stehen, um Bedeutung zu erlangen. Zum Beispiel hat das Objekt ""1"" keine Bedeutung, solange es nicht eine spezifische Eigenschaft eines anderen Objekts beschreibt, wie die Hausnummer eines Hauses oder die Anzahl der Elemente in einem Array. Tatsächlich werden die meisten Objekte in einem System erst durch ihre Beziehungen zu anderen Objekten nützlich. Ein Objekt, das eine Person repräsentiert, wird erst dann durch den Namen ""Hans Mustermann"" identifizierbar, wenn es in einer entsprechenden Beziehung zur Person steht, und umgekehrt.
In der objektorientierten Programmierung wird, wie bereits zu Beginn dieses Abschnitts erwähnt, alle Information als ein Netzwerk von miteinander verbundenen Objekten dargestellt. Dieses Netzwerk kann auf zwei Arten verwendet werden: Durch Navigation, um von einem Datenelement (Information) zum anderen zu gelangen, oder durch Manipulation, um die repräsentierte Information zu ändern.
Das Datenmodell der objektorientierten Programmierung ähnelt dem Netzwerkmodell, das vor einigen Jahrzehnten die Grundlage für große Datenbankmanagementsysteme bildete, bevor es vom relationalen Datenmodell verdrängt wurde. Erst mit der Einführung objektorientierter Datenbanken gewinnt das Netzwerkmodell wieder an theoretischer Bedeutung.
In der objektorientierten Programmierung werden Beziehungen zwischen Objekten über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten ""navigieren"". Es ist wichtig zu beachten, dass diese Verknüpfung immer gerichtet ist. Das bedeutet, dass man von einem Objekt zu einem anderen navigieren kann, aber nicht zwangsläufig wieder zurück. Dafür wäre ein Zeiger in Gegenrichtung erforderlich.
Variablen selbst enthalten ebenfalls Verweise. Wer also Zugriff auf die Variable hat, kann auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.","<answer> In der objektorientierten Programmierung kann das Netzwerk von miteinander verbundenen Objekten auf zwei Arten verwendet werden: durch Navigation, um von einem Datenelement zum anderen zu gelangen, oder durch Manipulation, um die repräsentierte Information zu ändern. <answer> <question> Welche beiden Arten der Verwendung des Netzwerks von miteinander verbundenen Objekten gibt es in der objektorientierten Programmierung? <question>"
"Kein Objekt existiert isoliert. Im Gegenteil, Objekte müssen in Beziehung zueinander stehen, um Bedeutung zu erlangen. Zum Beispiel hat das Objekt ""1"" keine Bedeutung, solange es nicht eine spezifische Eigenschaft eines anderen Objekts beschreibt, wie die Hausnummer eines Hauses oder die Anzahl der Elemente in einem Array. Tatsächlich werden die meisten Objekte in einem System erst durch ihre Beziehungen zu anderen Objekten nützlich. Ein Objekt, das eine Person repräsentiert, wird erst dann durch den Namen ""Hans Mustermann"" identifizierbar, wenn es in einer entsprechenden Beziehung zur Person steht, und umgekehrt.
In der objektorientierten Programmierung wird, wie bereits zu Beginn dieses Abschnitts erwähnt, alle Information als ein Netzwerk von miteinander verbundenen Objekten dargestellt. Dieses Netzwerk kann auf zwei Arten verwendet werden: Durch Navigation, um von einem Datenelement (Information) zum anderen zu gelangen, oder durch Manipulation, um die repräsentierte Information zu ändern.
Das Datenmodell der objektorientierten Programmierung ähnelt dem Netzwerkmodell, das vor einigen Jahrzehnten die Grundlage für große Datenbankmanagementsysteme bildete, bevor es vom relationalen Datenmodell verdrängt wurde. Erst mit der Einführung objektorientierter Datenbanken gewinnt das Netzwerkmodell wieder an theoretischer Bedeutung.
In der objektorientierten Programmierung werden Beziehungen zwischen Objekten über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten ""navigieren"". Es ist wichtig zu beachten, dass diese Verknüpfung immer gerichtet ist. Das bedeutet, dass man von einem Objekt zu einem anderen navigieren kann, aber nicht zwangsläufig wieder zurück. Dafür wäre ein Zeiger in Gegenrichtung erforderlich.
Variablen selbst enthalten ebenfalls Verweise. Wer also Zugriff auf die Variable hat, kann auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.","<answer> Das Datenmodell der objektorientierten Programmierung ähnelt dem Netzwerkmodell, das vor einigen Jahrzehnten die Grundlage für große Datenbankmanagementsysteme bildete, bevor es vom relationalen Datenmodell verdrängt wurde. <answer> <question> Welches Datenmodell in der objektorientierten Programmierung ähnelt dem Netzwerkmodell, das vor einigen Jahrzehnten die Grundlage für große Datenbankmanagementsysteme bildete? <question>"
"Kein Objekt existiert isoliert. Im Gegenteil, Objekte müssen in Beziehung zueinander stehen, um Bedeutung zu erlangen. Zum Beispiel hat das Objekt ""1"" keine Bedeutung, solange es nicht eine spezifische Eigenschaft eines anderen Objekts beschreibt, wie die Hausnummer eines Hauses oder die Anzahl der Elemente in einem Array. Tatsächlich werden die meisten Objekte in einem System erst durch ihre Beziehungen zu anderen Objekten nützlich. Ein Objekt, das eine Person repräsentiert, wird erst dann durch den Namen ""Hans Mustermann"" identifizierbar, wenn es in einer entsprechenden Beziehung zur Person steht, und umgekehrt.
In der objektorientierten Programmierung wird, wie bereits zu Beginn dieses Abschnitts erwähnt, alle Information als ein Netzwerk von miteinander verbundenen Objekten dargestellt. Dieses Netzwerk kann auf zwei Arten verwendet werden: Durch Navigation, um von einem Datenelement (Information) zum anderen zu gelangen, oder durch Manipulation, um die repräsentierte Information zu ändern.
Das Datenmodell der objektorientierten Programmierung ähnelt dem Netzwerkmodell, das vor einigen Jahrzehnten die Grundlage für große Datenbankmanagementsysteme bildete, bevor es vom relationalen Datenmodell verdrängt wurde. Erst mit der Einführung objektorientierter Datenbanken gewinnt das Netzwerkmodell wieder an theoretischer Bedeutung.
In der objektorientierten Programmierung werden Beziehungen zwischen Objekten über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten ""navigieren"". Es ist wichtig zu beachten, dass diese Verknüpfung immer gerichtet ist. Das bedeutet, dass man von einem Objekt zu einem anderen navigieren kann, aber nicht zwangsläufig wieder zurück. Dafür wäre ein Zeiger in Gegenrichtung erforderlich.
Variablen selbst enthalten ebenfalls Verweise. Wer also Zugriff auf die Variable hat, kann auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.","<answer> Beziehungen zwischen Objekten in der objektorientierten Programmierung werden über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten ""navigieren"". Dabei ist zu beachten, dass diese Verknüpfung immer gerichtet ist, was bedeutet, dass man von einem Objekt zu einem anderen navigieren kann, aber nicht zwangsläufig wieder zurück. <answer> <question> Wie werden Beziehungen zwischen Objekten in der objektorientierten Programmierung hergestellt? <question>"
"Kein Objekt existiert isoliert. Im Gegenteil, Objekte müssen in Beziehung zueinander stehen, um Bedeutung zu erlangen. Zum Beispiel hat das Objekt ""1"" keine Bedeutung, solange es nicht eine spezifische Eigenschaft eines anderen Objekts beschreibt, wie die Hausnummer eines Hauses oder die Anzahl der Elemente in einem Array. Tatsächlich werden die meisten Objekte in einem System erst durch ihre Beziehungen zu anderen Objekten nützlich. Ein Objekt, das eine Person repräsentiert, wird erst dann durch den Namen ""Hans Mustermann"" identifizierbar, wenn es in einer entsprechenden Beziehung zur Person steht, und umgekehrt.
In der objektorientierten Programmierung wird, wie bereits zu Beginn dieses Abschnitts erwähnt, alle Information als ein Netzwerk von miteinander verbundenen Objekten dargestellt. Dieses Netzwerk kann auf zwei Arten verwendet werden: Durch Navigation, um von einem Datenelement (Information) zum anderen zu gelangen, oder durch Manipulation, um die repräsentierte Information zu ändern.
Das Datenmodell der objektorientierten Programmierung ähnelt dem Netzwerkmodell, das vor einigen Jahrzehnten die Grundlage für große Datenbankmanagementsysteme bildete, bevor es vom relationalen Datenmodell verdrängt wurde. Erst mit der Einführung objektorientierter Datenbanken gewinnt das Netzwerkmodell wieder an theoretischer Bedeutung.
In der objektorientierten Programmierung werden Beziehungen zwischen Objekten über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten ""navigieren"". Es ist wichtig zu beachten, dass diese Verknüpfung immer gerichtet ist. Das bedeutet, dass man von einem Objekt zu einem anderen navigieren kann, aber nicht zwangsläufig wieder zurück. Dafür wäre ein Zeiger in Gegenrichtung erforderlich.
Variablen selbst enthalten ebenfalls Verweise. Wer also Zugriff auf die Variable hat, kann auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.","<answer> Variablen in der objektorientierten Programmierung enthalten ebenfalls Verweise. Wenn jemand Zugriff auf die Variable hat, kann er auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden. <answer> <question> Wie sind Variablen in der objektorientierten Programmierung mit Beziehungen verknüpft? <question>"
"Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Damit dies erreicht wird, muss die Abhängigkeit der Module möglichst gering ausfallen. Dabei bedeutet Abhängigkeit in der Regel Änderungsabhängigkeit: Wenn sich in einem Teil etwas ändert, muss sich auch im davon abhängigen Teil etwas ändern. Sie ergibt sich regelmäßig aus einer Benutzungsbeziehung. In der objektorientierten Programmierung kommt jedoch noch die Vererbungsabhängigkeit hinzu. Module, die vollkommen unabhängig voneinander sind, sind ein Indikator dafür, dass man nicht ein Programm entwickelt, sondern mehrere. Wo keine Abhängigkeiten bestehen, gibt es auch kein Zusammenspiel.
Abhängigkeit ist eine gerichtete Beziehung: Dass A von B abhängt, heißt nicht, dass auch B von A abhängt. Und so manifestieren sich auch in den Klassen als Modulen der JAVA-Programmierung die zwei Richtungen von Abhängigkeit in zwei verschiedenen Formen: Dass eine Klasse von (der Schnittstelle) einer anderen abhängt, erkennt man daran, dass auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich wiederum daran, dass Variablen des entsprechenden Typs deklariert werden und, sofern sich die andere Klasse in einem anderen Paket befindet, die Klasse oder sogar das ganze Paket importiert wird. Dass eine Klasse einige ihrer Member anderen zur Benutzung anbietet und diese dadurch von ihr abhängig werden können, erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht private sind, sowie an der Implementierung von Interfaces.
In JAVA sind zunächst zirkuläre Abhängigkeiten erlaubt. Insbesondere dürfen sich zwei Klassen (genauer: Kompilierungseinheiten) wechselseitig importieren. In der Softwareentwicklung ist dies jedoch verpönt, schon weil eine wechselseitige Abhängigkeit eine enge Kopplung dokumentiert, die zwischen Modulen grundsätzlich vermieden werden sollte. Für JAVA-Module (siehe unten) sind zirkuläre Abhängigkeiten daher verboten. Wenn Sie einmal in die Verlegenheit kommen sollten, selbst JAVA-Module zu definieren, werden Sie feststellen, dass dieses Verbot eine sehr sorgfältige Planung der Modularisierung erzwingt, was an sich schon von großem Wert ist.
Vererbungsabhängigkeiten zwischen Klassen, die in JAVA durch die Verwendung des Zugriffsmodifikators protected und der Annotation @Override zumindest angedeutet werden (mehr dazu in Kurseinheit 6, Kapitel 55), sind naturgemäß nicht zirkulär. Bei der Ausdehnung der Abhängigkeit von Klassen auf Pakete können jedoch auch zirkuläre Abhängigkeiten entstehen.","<answer> Die Aufteilung eines Programms in Module ist wichtig, um die unabhängige Entwicklung von Programmteilen zu ermöglichen. Dadurch sollen Abhängigkeiten zwischen den Modulen minimiert werden, insbesondere in Bezug auf Änderungen. <answer> <question> Warum ist die Aufteilung eines Programms in Module wichtig? <question>"
"Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Damit dies erreicht wird, muss die Abhängigkeit der Module möglichst gering ausfallen. Dabei bedeutet Abhängigkeit in der Regel Änderungsabhängigkeit: Wenn sich in einem Teil etwas ändert, muss sich auch im davon abhängigen Teil etwas ändern. Sie ergibt sich regelmäßig aus einer Benutzungsbeziehung. In der objektorientierten Programmierung kommt jedoch noch die Vererbungsabhängigkeit hinzu. Module, die vollkommen unabhängig voneinander sind, sind ein Indikator dafür, dass man nicht ein Programm entwickelt, sondern mehrere. Wo keine Abhängigkeiten bestehen, gibt es auch kein Zusammenspiel.
Abhängigkeit ist eine gerichtete Beziehung: Dass A von B abhängt, heißt nicht, dass auch B von A abhängt. Und so manifestieren sich auch in den Klassen als Modulen der JAVA-Programmierung die zwei Richtungen von Abhängigkeit in zwei verschiedenen Formen: Dass eine Klasse von (der Schnittstelle) einer anderen abhängt, erkennt man daran, dass auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich wiederum daran, dass Variablen des entsprechenden Typs deklariert werden und, sofern sich die andere Klasse in einem anderen Paket befindet, die Klasse oder sogar das ganze Paket importiert wird. Dass eine Klasse einige ihrer Member anderen zur Benutzung anbietet und diese dadurch von ihr abhängig werden können, erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht private sind, sowie an der Implementierung von Interfaces.
In JAVA sind zunächst zirkuläre Abhängigkeiten erlaubt. Insbesondere dürfen sich zwei Klassen (genauer: Kompilierungseinheiten) wechselseitig importieren. In der Softwareentwicklung ist dies jedoch verpönt, schon weil eine wechselseitige Abhängigkeit eine enge Kopplung dokumentiert, die zwischen Modulen grundsätzlich vermieden werden sollte. Für JAVA-Module (siehe unten) sind zirkuläre Abhängigkeiten daher verboten. Wenn Sie einmal in die Verlegenheit kommen sollten, selbst JAVA-Module zu definieren, werden Sie feststellen, dass dieses Verbot eine sehr sorgfältige Planung der Modularisierung erzwingt, was an sich schon von großem Wert ist.
Vererbungsabhängigkeiten zwischen Klassen, die in JAVA durch die Verwendung des Zugriffsmodifikators protected und der Annotation @Override zumindest angedeutet werden (mehr dazu in Kurseinheit 6, Kapitel 55), sind naturgemäß nicht zirkulär. Bei der Ausdehnung der Abhängigkeit von Klassen auf Pakete können jedoch auch zirkuläre Abhängigkeiten entstehen.","<answer> In der Programmierung bedeutet Abhängigkeit zwischen Modulen in der Regel Änderungsabhängigkeit. Wenn sich in einem Modul etwas ändert, kann dies Auswirkungen auf andere davon abhängige Module haben. Abhängigkeiten ergeben sich oft aus Benutzungsbeziehungen und können in der objektorientierten Programmierung auch Vererbungsabhängigkeiten einschließen. <answer> <question> Was bedeutet Abhängigkeit zwischen Modulen in der Programmierung? <question>"
"Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Damit dies erreicht wird, muss die Abhängigkeit der Module möglichst gering ausfallen. Dabei bedeutet Abhängigkeit in der Regel Änderungsabhängigkeit: Wenn sich in einem Teil etwas ändert, muss sich auch im davon abhängigen Teil etwas ändern. Sie ergibt sich regelmäßig aus einer Benutzungsbeziehung. In der objektorientierten Programmierung kommt jedoch noch die Vererbungsabhängigkeit hinzu. Module, die vollkommen unabhängig voneinander sind, sind ein Indikator dafür, dass man nicht ein Programm entwickelt, sondern mehrere. Wo keine Abhängigkeiten bestehen, gibt es auch kein Zusammenspiel.
Abhängigkeit ist eine gerichtete Beziehung: Dass A von B abhängt, heißt nicht, dass auch B von A abhängt. Und so manifestieren sich auch in den Klassen als Modulen der JAVA-Programmierung die zwei Richtungen von Abhängigkeit in zwei verschiedenen Formen: Dass eine Klasse von (der Schnittstelle) einer anderen abhängt, erkennt man daran, dass auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich wiederum daran, dass Variablen des entsprechenden Typs deklariert werden und, sofern sich die andere Klasse in einem anderen Paket befindet, die Klasse oder sogar das ganze Paket importiert wird. Dass eine Klasse einige ihrer Member anderen zur Benutzung anbietet und diese dadurch von ihr abhängig werden können, erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht private sind, sowie an der Implementierung von Interfaces.
In JAVA sind zunächst zirkuläre Abhängigkeiten erlaubt. Insbesondere dürfen sich zwei Klassen (genauer: Kompilierungseinheiten) wechselseitig importieren. In der Softwareentwicklung ist dies jedoch verpönt, schon weil eine wechselseitige Abhängigkeit eine enge Kopplung dokumentiert, die zwischen Modulen grundsätzlich vermieden werden sollte. Für JAVA-Module (siehe unten) sind zirkuläre Abhängigkeiten daher verboten. Wenn Sie einmal in die Verlegenheit kommen sollten, selbst JAVA-Module zu definieren, werden Sie feststellen, dass dieses Verbot eine sehr sorgfältige Planung der Modularisierung erzwingt, was an sich schon von großem Wert ist.
Vererbungsabhängigkeiten zwischen Klassen, die in JAVA durch die Verwendung des Zugriffsmodifikators protected und der Annotation @Override zumindest angedeutet werden (mehr dazu in Kurseinheit 6, Kapitel 55), sind naturgemäß nicht zirkulär. Bei der Ausdehnung der Abhängigkeit von Klassen auf Pakete können jedoch auch zirkuläre Abhängigkeiten entstehen.","<answer> In den Klassen als Modulen der JAVA-Programmierung gibt es zwei Formen von Abhängigkeiten: Eine Klasse hängt von einer anderen ab, wenn auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich durch die Deklaration von Variablen des entsprechenden Typs und gegebenenfalls durch das Importieren der Klasse oder des Pakets, in dem sich die andere Klasse befindet. Eine Klasse bietet einige ihrer Member zur Benutzung durch andere Klassen an und diese werden dadurch von ihr abhängig. Dies erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht privat sind, sowie an der Implementierung von Interfaces. <answer> <question> Welche Formen von Abhängigkeiten gibt es in den Klassen als Modulen der JAVA-Programmierung? <question>"
"Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Damit dies erreicht wird, muss die Abhängigkeit der Module möglichst gering ausfallen. Dabei bedeutet Abhängigkeit in der Regel Änderungsabhängigkeit: Wenn sich in einem Teil etwas ändert, muss sich auch im davon abhängigen Teil etwas ändern. Sie ergibt sich regelmäßig aus einer Benutzungsbeziehung. In der objektorientierten Programmierung kommt jedoch noch die Vererbungsabhängigkeit hinzu. Module, die vollkommen unabhängig voneinander sind, sind ein Indikator dafür, dass man nicht ein Programm entwickelt, sondern mehrere. Wo keine Abhängigkeiten bestehen, gibt es auch kein Zusammenspiel.
Abhängigkeit ist eine gerichtete Beziehung: Dass A von B abhängt, heißt nicht, dass auch B von A abhängt. Und so manifestieren sich auch in den Klassen als Modulen der JAVA-Programmierung die zwei Richtungen von Abhängigkeit in zwei verschiedenen Formen: Dass eine Klasse von (der Schnittstelle) einer anderen abhängt, erkennt man daran, dass auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich wiederum daran, dass Variablen des entsprechenden Typs deklariert werden und, sofern sich die andere Klasse in einem anderen Paket befindet, die Klasse oder sogar das ganze Paket importiert wird. Dass eine Klasse einige ihrer Member anderen zur Benutzung anbietet und diese dadurch von ihr abhängig werden können, erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht private sind, sowie an der Implementierung von Interfaces.
In JAVA sind zunächst zirkuläre Abhängigkeiten erlaubt. Insbesondere dürfen sich zwei Klassen (genauer: Kompilierungseinheiten) wechselseitig importieren. In der Softwareentwicklung ist dies jedoch verpönt, schon weil eine wechselseitige Abhängigkeit eine enge Kopplung dokumentiert, die zwischen Modulen grundsätzlich vermieden werden sollte. Für JAVA-Module (siehe unten) sind zirkuläre Abhängigkeiten daher verboten. Wenn Sie einmal in die Verlegenheit kommen sollten, selbst JAVA-Module zu definieren, werden Sie feststellen, dass dieses Verbot eine sehr sorgfältige Planung der Modularisierung erzwingt, was an sich schon von großem Wert ist.
Vererbungsabhängigkeiten zwischen Klassen, die in JAVA durch die Verwendung des Zugriffsmodifikators protected und der Annotation @Override zumindest angedeutet werden (mehr dazu in Kurseinheit 6, Kapitel 55), sind naturgemäß nicht zirkulär. Bei der Ausdehnung der Abhängigkeit von Klassen auf Pakete können jedoch auch zirkuläre Abhängigkeiten entstehen.","<answer> Ja, zirkuläre Abhängigkeiten zwischen Klassen sind in JAVA zunächst erlaubt. Dies bedeutet, dass sich zwei Klassen wechselseitig importieren können. Jedoch wird dies in der Softwareentwicklung vermieden, da wechselseitige Abhängigkeiten eine enge Kopplung zwischen Modulen anzeigen, die vermieden werden sollte. Für JAVA-Module sind zirkuläre Abhängigkeiten jedoch verboten. <answer> <question> Sind zirkuläre Abhängigkeiten zwischen Klassen in JAVA erlaubt? <question>"
"Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Damit dies erreicht wird, muss die Abhängigkeit der Module möglichst gering ausfallen. Dabei bedeutet Abhängigkeit in der Regel Änderungsabhängigkeit: Wenn sich in einem Teil etwas ändert, muss sich auch im davon abhängigen Teil etwas ändern. Sie ergibt sich regelmäßig aus einer Benutzungsbeziehung. In der objektorientierten Programmierung kommt jedoch noch die Vererbungsabhängigkeit hinzu. Module, die vollkommen unabhängig voneinander sind, sind ein Indikator dafür, dass man nicht ein Programm entwickelt, sondern mehrere. Wo keine Abhängigkeiten bestehen, gibt es auch kein Zusammenspiel.
Abhängigkeit ist eine gerichtete Beziehung: Dass A von B abhängt, heißt nicht, dass auch B von A abhängt. Und so manifestieren sich auch in den Klassen als Modulen der JAVA-Programmierung die zwei Richtungen von Abhängigkeit in zwei verschiedenen Formen: Dass eine Klasse von (der Schnittstelle) einer anderen abhängt, erkennt man daran, dass auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich wiederum daran, dass Variablen des entsprechenden Typs deklariert werden und, sofern sich die andere Klasse in einem anderen Paket befindet, die Klasse oder sogar das ganze Paket importiert wird. Dass eine Klasse einige ihrer Member anderen zur Benutzung anbietet und diese dadurch von ihr abhängig werden können, erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht private sind, sowie an der Implementierung von Interfaces.
In JAVA sind zunächst zirkuläre Abhängigkeiten erlaubt. Insbesondere dürfen sich zwei Klassen (genauer: Kompilierungseinheiten) wechselseitig importieren. In der Softwareentwicklung ist dies jedoch verpönt, schon weil eine wechselseitige Abhängigkeit eine enge Kopplung dokumentiert, die zwischen Modulen grundsätzlich vermieden werden sollte. Für JAVA-Module (siehe unten) sind zirkuläre Abhängigkeiten daher verboten. Wenn Sie einmal in die Verlegenheit kommen sollten, selbst JAVA-Module zu definieren, werden Sie feststellen, dass dieses Verbot eine sehr sorgfältige Planung der Modularisierung erzwingt, was an sich schon von großem Wert ist.
Vererbungsabhängigkeiten zwischen Klassen, die in JAVA durch die Verwendung des Zugriffsmodifikators protected und der Annotation @Override zumindest angedeutet werden (mehr dazu in Kurseinheit 6, Kapitel 55), sind naturgemäß nicht zirkulär. Bei der Ausdehnung der Abhängigkeit von Klassen auf Pakete können jedoch auch zirkuläre Abhängigkeiten entstehen.","<answer> Zirkuläre Abhängigkeiten in JAVA-Modulen sind verpönt, da sie eine enge Kopplung zwischen Modulen dokumentieren und dies vermieden werden sollte. Das Verbot zirkulärer Abhängigkeiten erfordert eine sorgfältige Planung der Modularisierung, was generell von großem Wert ist. <answer> <question> Warum sind zirkuläre Abhängigkeiten in JAVA-Modulen verpönt? <question>"
"Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Damit dies erreicht wird, muss die Abhängigkeit der Module möglichst gering ausfallen. Dabei bedeutet Abhängigkeit in der Regel Änderungsabhängigkeit: Wenn sich in einem Teil etwas ändert, muss sich auch im davon abhängigen Teil etwas ändern. Sie ergibt sich regelmäßig aus einer Benutzungsbeziehung. In der objektorientierten Programmierung kommt jedoch noch die Vererbungsabhängigkeit hinzu. Module, die vollkommen unabhängig voneinander sind, sind ein Indikator dafür, dass man nicht ein Programm entwickelt, sondern mehrere. Wo keine Abhängigkeiten bestehen, gibt es auch kein Zusammenspiel.
Abhängigkeit ist eine gerichtete Beziehung: Dass A von B abhängt, heißt nicht, dass auch B von A abhängt. Und so manifestieren sich auch in den Klassen als Modulen der JAVA-Programmierung die zwei Richtungen von Abhängigkeit in zwei verschiedenen Formen: Dass eine Klasse von (der Schnittstelle) einer anderen abhängt, erkennt man daran, dass auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich wiederum daran, dass Variablen des entsprechenden Typs deklariert werden und, sofern sich die andere Klasse in einem anderen Paket befindet, die Klasse oder sogar das ganze Paket importiert wird. Dass eine Klasse einige ihrer Member anderen zur Benutzung anbietet und diese dadurch von ihr abhängig werden können, erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht private sind, sowie an der Implementierung von Interfaces.
In JAVA sind zunächst zirkuläre Abhängigkeiten erlaubt. Insbesondere dürfen sich zwei Klassen (genauer: Kompilierungseinheiten) wechselseitig importieren. In der Softwareentwicklung ist dies jedoch verpönt, schon weil eine wechselseitige Abhängigkeit eine enge Kopplung dokumentiert, die zwischen Modulen grundsätzlich vermieden werden sollte. Für JAVA-Module (siehe unten) sind zirkuläre Abhängigkeiten daher verboten. Wenn Sie einmal in die Verlegenheit kommen sollten, selbst JAVA-Module zu definieren, werden Sie feststellen, dass dieses Verbot eine sehr sorgfältige Planung der Modularisierung erzwingt, was an sich schon von großem Wert ist.
Vererbungsabhängigkeiten zwischen Klassen, die in JAVA durch die Verwendung des Zugriffsmodifikators protected und der Annotation @Override zumindest angedeutet werden (mehr dazu in Kurseinheit 6, Kapitel 55), sind naturgemäß nicht zirkulär. Bei der Ausdehnung der Abhängigkeit von Klassen auf Pakete können jedoch auch zirkuläre Abhängigkeiten entstehen.","<answer> In JAVA können Vererbungsabhängigkeiten zwischen Klassen auftreten, die nicht zirkulär sind. Bei der Ausdehnung der Abhängigkeiten auf Pakete können jedoch auch zirkuläre Abhängigkeiten zwischen Paketen entstehen. <answer> <question> Welche Arten von Abhängigkeiten können zwischen Klassen und Paketen in JAVA entstehen? <question>"
"Wie bereits in Kapitel 27 von Kurseinheit 3 erläutert, versteht man unter einem Type cast (einer Typumwandlung) den Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde. Type casts werden also insbesondere auf Variablen und auf Methodenausdrücke angewendet, und zwar immer dann, wenn man diese einer Variable zuweisen will, zu der keine Zuweisungskompatibilität besteht, oder wenn man darauf eine Methode aufrufen (oder ein Feld zugreifen) will, das der deklarierte Typ nicht anbietet.
Wie schon in Kapitel 27, so unterscheiden wir auch hier in Abhängigkeit davon, wie die beteiligten Typen, der Ausgangstyp und der Zieltyp eines Type casts, miteinander in Beziehung stehen, drei Arten von Typumwandlungen: Up casts: Der Zieltyp ist ein Supertyp des Ausgangstyps. Down casts: Der Zieltyp ist ein Subtyp des Ausgangstyps. Cross casts: Zieltyp und Ausgangstyp stehen in keiner Subtypenbeziehung zueinander, stehen also gewissermaßen nebeneinander.
Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen.
Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.","<answer> Ein Type cast ist der Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde. <answer> <question> Was versteht man unter einem Type cast (Typumwandlung)? <question>"
"Wie bereits in Kapitel 27 von Kurseinheit 3 erläutert, versteht man unter einem Type cast (einer Typumwandlung) den Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde. Type casts werden also insbesondere auf Variablen und auf Methodenausdrücke angewendet, und zwar immer dann, wenn man diese einer Variable zuweisen will, zu der keine Zuweisungskompatibilität besteht, oder wenn man darauf eine Methode aufrufen (oder ein Feld zugreifen) will, das der deklarierte Typ nicht anbietet.
Wie schon in Kapitel 27, so unterscheiden wir auch hier in Abhängigkeit davon, wie die beteiligten Typen, der Ausgangstyp und der Zieltyp eines Type casts, miteinander in Beziehung stehen, drei Arten von Typumwandlungen: Up casts: Der Zieltyp ist ein Supertyp des Ausgangstyps. Down casts: Der Zieltyp ist ein Subtyp des Ausgangstyps. Cross casts: Zieltyp und Ausgangstyp stehen in keiner Subtypenbeziehung zueinander, stehen also gewissermaßen nebeneinander.
Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen.
Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.","<answer> Type casts werden in Java verwendet, wenn man einem Programmelement, das einen bestimmten Typ hat, einen anderen Typ zuweisen möchte oder wenn man auf Methoden oder Felder zugreifen möchte, die nicht im deklarierten Typ verfügbar sind. <answer> <question> Wann werden Type casts in Java verwendet? <question>"
"Wie bereits in Kapitel 27 von Kurseinheit 3 erläutert, versteht man unter einem Type cast (einer Typumwandlung) den Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde. Type casts werden also insbesondere auf Variablen und auf Methodenausdrücke angewendet, und zwar immer dann, wenn man diese einer Variable zuweisen will, zu der keine Zuweisungskompatibilität besteht, oder wenn man darauf eine Methode aufrufen (oder ein Feld zugreifen) will, das der deklarierte Typ nicht anbietet.
Wie schon in Kapitel 27, so unterscheiden wir auch hier in Abhängigkeit davon, wie die beteiligten Typen, der Ausgangstyp und der Zieltyp eines Type casts, miteinander in Beziehung stehen, drei Arten von Typumwandlungen: Up casts: Der Zieltyp ist ein Supertyp des Ausgangstyps. Down casts: Der Zieltyp ist ein Subtyp des Ausgangstyps. Cross casts: Zieltyp und Ausgangstyp stehen in keiner Subtypenbeziehung zueinander, stehen also gewissermaßen nebeneinander.
Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen.
Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.","<answer> In Java gibt es drei Arten von Typumwandlungen: Up casts, Down casts und Cross casts. <answer> <question> Welche Arten von Typumwandlungen gibt es in Java? <question>"
"Wie bereits in Kapitel 27 von Kurseinheit 3 erläutert, versteht man unter einem Type cast (einer Typumwandlung) den Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde. Type casts werden also insbesondere auf Variablen und auf Methodenausdrücke angewendet, und zwar immer dann, wenn man diese einer Variable zuweisen will, zu der keine Zuweisungskompatibilität besteht, oder wenn man darauf eine Methode aufrufen (oder ein Feld zugreifen) will, das der deklarierte Typ nicht anbietet.
Wie schon in Kapitel 27, so unterscheiden wir auch hier in Abhängigkeit davon, wie die beteiligten Typen, der Ausgangstyp und der Zieltyp eines Type casts, miteinander in Beziehung stehen, drei Arten von Typumwandlungen: Up casts: Der Zieltyp ist ein Supertyp des Ausgangstyps. Down casts: Der Zieltyp ist ein Subtyp des Ausgangstyps. Cross casts: Zieltyp und Ausgangstyp stehen in keiner Subtypenbeziehung zueinander, stehen also gewissermaßen nebeneinander.
Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen.
Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.","<answer> Ein Up cast tritt auf, wenn der Zieltyp ein Supertyp des Ausgangstyps ist. <answer> <question> Was ist ein Up cast? <question>"
"Wie bereits in Kapitel 27 von Kurseinheit 3 erläutert, versteht man unter einem Type cast (einer Typumwandlung) den Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde. Type casts werden also insbesondere auf Variablen und auf Methodenausdrücke angewendet, und zwar immer dann, wenn man diese einer Variable zuweisen will, zu der keine Zuweisungskompatibilität besteht, oder wenn man darauf eine Methode aufrufen (oder ein Feld zugreifen) will, das der deklarierte Typ nicht anbietet.
Wie schon in Kapitel 27, so unterscheiden wir auch hier in Abhängigkeit davon, wie die beteiligten Typen, der Ausgangstyp und der Zieltyp eines Type casts, miteinander in Beziehung stehen, drei Arten von Typumwandlungen: Up casts: Der Zieltyp ist ein Supertyp des Ausgangstyps. Down casts: Der Zieltyp ist ein Subtyp des Ausgangstyps. Cross casts: Zieltyp und Ausgangstyp stehen in keiner Subtypenbeziehung zueinander, stehen also gewissermaßen nebeneinander.
Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen.
Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.","<answer> Ein Down cast tritt auf, wenn der Zieltyp ein Subtyp des Ausgangstyps ist. <answer> <question> Was ist ein Down cast? <question>"
"Wie bereits in Kapitel 27 von Kurseinheit 3 erläutert, versteht man unter einem Type cast (einer Typumwandlung) den Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde. Type casts werden also insbesondere auf Variablen und auf Methodenausdrücke angewendet, und zwar immer dann, wenn man diese einer Variable zuweisen will, zu der keine Zuweisungskompatibilität besteht, oder wenn man darauf eine Methode aufrufen (oder ein Feld zugreifen) will, das der deklarierte Typ nicht anbietet.
Wie schon in Kapitel 27, so unterscheiden wir auch hier in Abhängigkeit davon, wie die beteiligten Typen, der Ausgangstyp und der Zieltyp eines Type casts, miteinander in Beziehung stehen, drei Arten von Typumwandlungen: Up casts: Der Zieltyp ist ein Supertyp des Ausgangstyps. Down casts: Der Zieltyp ist ein Subtyp des Ausgangstyps. Cross casts: Zieltyp und Ausgangstyp stehen in keiner Subtypenbeziehung zueinander, stehen also gewissermaßen nebeneinander.
Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen.
Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.","<answer> Ein Cross cast tritt auf, wenn Zieltyp und Ausgangstyp keine Subtypenbeziehung zueinander haben und nebeneinander stehen. <answer> <question> Was ist ein Cross cast? <question>"
"Wie bereits in Kapitel 27 von Kurseinheit 3 erläutert, versteht man unter einem Type cast (einer Typumwandlung) den Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde. Type casts werden also insbesondere auf Variablen und auf Methodenausdrücke angewendet, und zwar immer dann, wenn man diese einer Variable zuweisen will, zu der keine Zuweisungskompatibilität besteht, oder wenn man darauf eine Methode aufrufen (oder ein Feld zugreifen) will, das der deklarierte Typ nicht anbietet.
Wie schon in Kapitel 27, so unterscheiden wir auch hier in Abhängigkeit davon, wie die beteiligten Typen, der Ausgangstyp und der Zieltyp eines Type casts, miteinander in Beziehung stehen, drei Arten von Typumwandlungen: Up casts: Der Zieltyp ist ein Supertyp des Ausgangstyps. Down casts: Der Zieltyp ist ein Subtyp des Ausgangstyps. Cross casts: Zieltyp und Ausgangstyp stehen in keiner Subtypenbeziehung zueinander, stehen also gewissermaßen nebeneinander.
Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen.
Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.","<answer> Ein Up cast ist immer sicher, da jedes Objekt neben seinem Typ auch den Typ all seiner Supertypen hat. <answer> <question> Welche Art von Typumwandlung ist immer sicher? <question>"
"Wie bereits in Kapitel 27 von Kurseinheit 3 erläutert, versteht man unter einem Type cast (einer Typumwandlung) den Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde. Type casts werden also insbesondere auf Variablen und auf Methodenausdrücke angewendet, und zwar immer dann, wenn man diese einer Variable zuweisen will, zu der keine Zuweisungskompatibilität besteht, oder wenn man darauf eine Methode aufrufen (oder ein Feld zugreifen) will, das der deklarierte Typ nicht anbietet.
Wie schon in Kapitel 27, so unterscheiden wir auch hier in Abhängigkeit davon, wie die beteiligten Typen, der Ausgangstyp und der Zieltyp eines Type casts, miteinander in Beziehung stehen, drei Arten von Typumwandlungen: Up casts: Der Zieltyp ist ein Supertyp des Ausgangstyps. Down casts: Der Zieltyp ist ein Subtyp des Ausgangstyps. Cross casts: Zieltyp und Ausgangstyp stehen in keiner Subtypenbeziehung zueinander, stehen also gewissermaßen nebeneinander.
Wie man sich leicht vor Augen hält, ist ein Up cast auch in Java immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat (weswegen der Up cast auch immer weggelassen werden kann); Down und Cross casts sind jedoch nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden; Down und Cross casts können daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen.
Mit der Einführung von Generics ergeben sich ein paar Probleme mit impliziten Typumwandlungen.","<answer> Down und Cross casts können zu Laufzeittypfehlern führen, wenn das Objekt, zu dem der typumgewandelte Ausdruck ausgewertet wird, nicht den Zieltyp oder einen Subtyp davon hat. Dies kann zur Laufzeit zu ClassCastException-Fehlern führen. <answer> <question> Welche Art von Typumwandlung kann zu Laufzeittypfehlern führen? <question>"
"In gewisser Weise hat man es beim rekursiv beschränkten parametrischen Polymorphismus wie oben vorgestellt mit einem Fall von kovarianter Redefinition zu tun: Der Parametertyp der Methode = ändert sich mit dem Empfängertyp. Allerdings ergibt sich daraus, anders als bei der Verwendung von Self als Typvariable, kein Widerspruch zur Kontravarianzregel des Subtyping, denn Integer wird dadurch unmittelbar ja lediglich zu einem Subtyp von Equatable[Integer] und nicht etwa von Equatable[Object]. Tatsächlich sind Equatable[Integer] und Equatable[Object] ja zwei vollkommen verschiedene Typen (mit disjunkten Wertebereichen), und Equatable[T] ist gar kein Typ (so dass man auch keine Variable mit ihm deklarieren kann), sodass keinerlei Zuweisungskompatibilität und damit auch kein Problem mit Typkorrektheit besteht.
Trotzdem stellt sich die Frage, ob sich das in Abschnitt 26.3 angesprochene allgemeine Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischen Polymorphismus nicht irgendwie lösen lässt. Die Antwort ist unbefriedigend: nur zum Teil.
Die Deklaration von Zeichnung mit Typparameter T als Subtyp von Dokument vorausgesetzt, lassen sich die folgenden Variablendeklarationen bilden:
Weiterhin die Deklarationen von Plotter und Zeilendrucker als Subtypen von Drucker vorausgesetzt, wäre ein Methodenaufruf typkorrekt, hingegen nicht. Allerdings ist die Assoziation von Zeichnung mit Plotter, die Kovarianz, in keiner Typdefinition festgehalten, sondern lediglich in der Deklaration von z. Es hindert einen insbesondere nichts daran, dieselbe oder eine andere Variable als vom Typ Zeichnung[Zeilendrucker] zu deklarieren. Man beachte, dass es anders als im obigen Beispiel von Equatable, wo ja der Typparameter auf den definierten Typ selbst eingeschränkt wurde, hier keine Möglichkeit gibt, einen bestimmten Wert für einen Typparameter vorzuschreiben.
Was man allerdings tun könnte, ist, Zeichnung als Subtyp von Dokument[Plotter] zu definieren. Dies hat jedoch den Nachteil, dass Zeichnung damit kein Subtyp mehr von Dokument ist und, wie auch zuvor schon Zeichnung[Plotter] kein Subtyp von Dokument[Drucker] ist (s. Abschnitt 29.3), wodurch die Zuweisungskompatibilität mit entsprechend deklarierten Variablen verlorengeht. Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie lässt sich auch mittels parametrischer Typen nicht hinbekommen.","<answer> Das Kovarianzproblem im Zusammenhang mit parametrischem Polymorphismus bezieht sich darauf, wie Eingabeparameter in Methoden kovariant, also flexibel, in Bezug auf ihren Typ angepasst werden können. <answer> <question> Was ist das Kovarianzproblem im Zusammenhang mit parametrischem Polymorphismus? <question>"
"In gewisser Weise hat man es beim rekursiv beschränkten parametrischen Polymorphismus wie oben vorgestellt mit einem Fall von kovarianter Redefinition zu tun: Der Parametertyp der Methode = ändert sich mit dem Empfängertyp. Allerdings ergibt sich daraus, anders als bei der Verwendung von Self als Typvariable, kein Widerspruch zur Kontravarianzregel des Subtyping, denn Integer wird dadurch unmittelbar ja lediglich zu einem Subtyp von Equatable[Integer] und nicht etwa von Equatable[Object]. Tatsächlich sind Equatable[Integer] und Equatable[Object] ja zwei vollkommen verschiedene Typen (mit disjunkten Wertebereichen), und Equatable[T] ist gar kein Typ (so dass man auch keine Variable mit ihm deklarieren kann), sodass keinerlei Zuweisungskompatibilität und damit auch kein Problem mit Typkorrektheit besteht.
Trotzdem stellt sich die Frage, ob sich das in Abschnitt 26.3 angesprochene allgemeine Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischen Polymorphismus nicht irgendwie lösen lässt. Die Antwort ist unbefriedigend: nur zum Teil.
Die Deklaration von Zeichnung mit Typparameter T als Subtyp von Dokument vorausgesetzt, lassen sich die folgenden Variablendeklarationen bilden:
Weiterhin die Deklarationen von Plotter und Zeilendrucker als Subtypen von Drucker vorausgesetzt, wäre ein Methodenaufruf typkorrekt, hingegen nicht. Allerdings ist die Assoziation von Zeichnung mit Plotter, die Kovarianz, in keiner Typdefinition festgehalten, sondern lediglich in der Deklaration von z. Es hindert einen insbesondere nichts daran, dieselbe oder eine andere Variable als vom Typ Zeichnung[Zeilendrucker] zu deklarieren. Man beachte, dass es anders als im obigen Beispiel von Equatable, wo ja der Typparameter auf den definierten Typ selbst eingeschränkt wurde, hier keine Möglichkeit gibt, einen bestimmten Wert für einen Typparameter vorzuschreiben.
Was man allerdings tun könnte, ist, Zeichnung als Subtyp von Dokument[Plotter] zu definieren. Dies hat jedoch den Nachteil, dass Zeichnung damit kein Subtyp mehr von Dokument ist und, wie auch zuvor schon Zeichnung[Plotter] kein Subtyp von Dokument[Drucker] ist (s. Abschnitt 29.3), wodurch die Zuweisungskompatibilität mit entsprechend deklarierten Variablen verlorengeht. Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie lässt sich auch mittels parametrischer Typen nicht hinbekommen.","<answer> Beim rekursiv beschränkten parametrischen Polymorphismus ändert sich der Parametertyp der Methode = mit dem Empfängertyp, was kovariant wirkt. Es ergibt sich jedoch kein Widerspruch zur Kontravarianzregel des Subtyping, da der Empfängertyp (z. B. Integer) lediglich zu einem Subtyp von Equatable[Integer] wird und nicht von Equatable[Object]. <answer> <question> Warum ergibt sich beim rekursiv beschränkten parametrischen Polymorphismus kein Widerspruch zur Kontravarianzregel des Subtyping? <question>"
"In gewisser Weise hat man es beim rekursiv beschränkten parametrischen Polymorphismus wie oben vorgestellt mit einem Fall von kovarianter Redefinition zu tun: Der Parametertyp der Methode = ändert sich mit dem Empfängertyp. Allerdings ergibt sich daraus, anders als bei der Verwendung von Self als Typvariable, kein Widerspruch zur Kontravarianzregel des Subtyping, denn Integer wird dadurch unmittelbar ja lediglich zu einem Subtyp von Equatable[Integer] und nicht etwa von Equatable[Object]. Tatsächlich sind Equatable[Integer] und Equatable[Object] ja zwei vollkommen verschiedene Typen (mit disjunkten Wertebereichen), und Equatable[T] ist gar kein Typ (so dass man auch keine Variable mit ihm deklarieren kann), sodass keinerlei Zuweisungskompatibilität und damit auch kein Problem mit Typkorrektheit besteht.
Trotzdem stellt sich die Frage, ob sich das in Abschnitt 26.3 angesprochene allgemeine Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischen Polymorphismus nicht irgendwie lösen lässt. Die Antwort ist unbefriedigend: nur zum Teil.
Die Deklaration von Zeichnung mit Typparameter T als Subtyp von Dokument vorausgesetzt, lassen sich die folgenden Variablendeklarationen bilden:
Weiterhin die Deklarationen von Plotter und Zeilendrucker als Subtypen von Drucker vorausgesetzt, wäre ein Methodenaufruf typkorrekt, hingegen nicht. Allerdings ist die Assoziation von Zeichnung mit Plotter, die Kovarianz, in keiner Typdefinition festgehalten, sondern lediglich in der Deklaration von z. Es hindert einen insbesondere nichts daran, dieselbe oder eine andere Variable als vom Typ Zeichnung[Zeilendrucker] zu deklarieren. Man beachte, dass es anders als im obigen Beispiel von Equatable, wo ja der Typparameter auf den definierten Typ selbst eingeschränkt wurde, hier keine Möglichkeit gibt, einen bestimmten Wert für einen Typparameter vorzuschreiben.
Was man allerdings tun könnte, ist, Zeichnung als Subtyp von Dokument[Plotter] zu definieren. Dies hat jedoch den Nachteil, dass Zeichnung damit kein Subtyp mehr von Dokument ist und, wie auch zuvor schon Zeichnung[Plotter] kein Subtyp von Dokument[Drucker] ist (s. Abschnitt 29.3), wodurch die Zuweisungskompatibilität mit entsprechend deklarierten Variablen verlorengeht. Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie lässt sich auch mittels parametrischer Typen nicht hinbekommen.","<answer> Es gibt keine zufriedenstellende Lösung für das Problem der kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischem Polymorphismus. Die Kovarianz kann zwar in bestimmten Fällen erreicht werden, aber sie ist nicht in allen Typdefinitionen festgehalten und bietet keine vollständige Kontrolle über die Typkorrektheit. <answer> <question> Gibt es eine Lösung für das Problem der kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischem Polymorphismus? <question>"
"In gewisser Weise hat man es beim rekursiv beschränkten parametrischen Polymorphismus wie oben vorgestellt mit einem Fall von kovarianter Redefinition zu tun: Der Parametertyp der Methode = ändert sich mit dem Empfängertyp. Allerdings ergibt sich daraus, anders als bei der Verwendung von Self als Typvariable, kein Widerspruch zur Kontravarianzregel des Subtyping, denn Integer wird dadurch unmittelbar ja lediglich zu einem Subtyp von Equatable[Integer] und nicht etwa von Equatable[Object]. Tatsächlich sind Equatable[Integer] und Equatable[Object] ja zwei vollkommen verschiedene Typen (mit disjunkten Wertebereichen), und Equatable[T] ist gar kein Typ (so dass man auch keine Variable mit ihm deklarieren kann), sodass keinerlei Zuweisungskompatibilität und damit auch kein Problem mit Typkorrektheit besteht.
Trotzdem stellt sich die Frage, ob sich das in Abschnitt 26.3 angesprochene allgemeine Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischen Polymorphismus nicht irgendwie lösen lässt. Die Antwort ist unbefriedigend: nur zum Teil.
Die Deklaration von Zeichnung mit Typparameter T als Subtyp von Dokument vorausgesetzt, lassen sich die folgenden Variablendeklarationen bilden:
Weiterhin die Deklarationen von Plotter und Zeilendrucker als Subtypen von Drucker vorausgesetzt, wäre ein Methodenaufruf typkorrekt, hingegen nicht. Allerdings ist die Assoziation von Zeichnung mit Plotter, die Kovarianz, in keiner Typdefinition festgehalten, sondern lediglich in der Deklaration von z. Es hindert einen insbesondere nichts daran, dieselbe oder eine andere Variable als vom Typ Zeichnung[Zeilendrucker] zu deklarieren. Man beachte, dass es anders als im obigen Beispiel von Equatable, wo ja der Typparameter auf den definierten Typ selbst eingeschränkt wurde, hier keine Möglichkeit gibt, einen bestimmten Wert für einen Typparameter vorzuschreiben.
Was man allerdings tun könnte, ist, Zeichnung als Subtyp von Dokument[Plotter] zu definieren. Dies hat jedoch den Nachteil, dass Zeichnung damit kein Subtyp mehr von Dokument ist und, wie auch zuvor schon Zeichnung[Plotter] kein Subtyp von Dokument[Drucker] ist (s. Abschnitt 29.3), wodurch die Zuweisungskompatibilität mit entsprechend deklarierten Variablen verlorengeht. Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie lässt sich auch mittels parametrischer Typen nicht hinbekommen.","<answer> Die Assoziation von Zeichnung mit Plotter, die Kovarianz, ist in keiner Typdefinition festgehalten, da es keine Möglichkeit gibt, einen bestimmten Wert für einen Typparameter vorzuschreiben. Die Kovarianz ist nicht in allen Fällen durch parametrische Typen abbildbar. <answer> <question> Warum ist die Assoziation von Zeichnung mit Plotter in keiner Typdefinition festgehalten? <question>"
"In gewisser Weise hat man es beim rekursiv beschränkten parametrischen Polymorphismus wie oben vorgestellt mit einem Fall von kovarianter Redefinition zu tun: Der Parametertyp der Methode = ändert sich mit dem Empfängertyp. Allerdings ergibt sich daraus, anders als bei der Verwendung von Self als Typvariable, kein Widerspruch zur Kontravarianzregel des Subtyping, denn Integer wird dadurch unmittelbar ja lediglich zu einem Subtyp von Equatable[Integer] und nicht etwa von Equatable[Object]. Tatsächlich sind Equatable[Integer] und Equatable[Object] ja zwei vollkommen verschiedene Typen (mit disjunkten Wertebereichen), und Equatable[T] ist gar kein Typ (so dass man auch keine Variable mit ihm deklarieren kann), sodass keinerlei Zuweisungskompatibilität und damit auch kein Problem mit Typkorrektheit besteht.
Trotzdem stellt sich die Frage, ob sich das in Abschnitt 26.3 angesprochene allgemeine Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischen Polymorphismus nicht irgendwie lösen lässt. Die Antwort ist unbefriedigend: nur zum Teil.
Die Deklaration von Zeichnung mit Typparameter T als Subtyp von Dokument vorausgesetzt, lassen sich die folgenden Variablendeklarationen bilden:
Weiterhin die Deklarationen von Plotter und Zeilendrucker als Subtypen von Drucker vorausgesetzt, wäre ein Methodenaufruf typkorrekt, hingegen nicht. Allerdings ist die Assoziation von Zeichnung mit Plotter, die Kovarianz, in keiner Typdefinition festgehalten, sondern lediglich in der Deklaration von z. Es hindert einen insbesondere nichts daran, dieselbe oder eine andere Variable als vom Typ Zeichnung[Zeilendrucker] zu deklarieren. Man beachte, dass es anders als im obigen Beispiel von Equatable, wo ja der Typparameter auf den definierten Typ selbst eingeschränkt wurde, hier keine Möglichkeit gibt, einen bestimmten Wert für einen Typparameter vorzuschreiben.
Was man allerdings tun könnte, ist, Zeichnung als Subtyp von Dokument[Plotter] zu definieren. Dies hat jedoch den Nachteil, dass Zeichnung damit kein Subtyp mehr von Dokument ist und, wie auch zuvor schon Zeichnung[Plotter] kein Subtyp von Dokument[Drucker] ist (s. Abschnitt 29.3), wodurch die Zuweisungskompatibilität mit entsprechend deklarierten Variablen verlorengeht. Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie lässt sich auch mittels parametrischer Typen nicht hinbekommen.","<answer> Das Kovarianzproblem kann in bestimmten Fällen durch parametrische Typen gelöst werden, aber es gibt keine allgemeine Lösung, die in allen Fällen die kovariante Redefinition von Eingabeparametern in Methoden ermöglicht. Die Flexibilität ist begrenzt, und es kann zu Einschränkungen bei der Verwendung von parametrischen Typen führen. <answer> <question> Kann das Kovarianzproblem durch parametrische Typen gelöst werden? <question>"
"Ein von Christopher Strachey, einem der Urväter der Programmierung als wissenschaftliche Disziplin, eingeführter Begriff ist der der Polymorphie. Polymorphie bedeutet allgemein Vielgestaltigkeit und wird vor allem in der Biologie verwendet. In der Programmierung steht er für verschiedene Dinge, die jedoch alle mit Typen zu tun haben. Unter Inklusionspolymorphie, auch Subtyp-Polymorphie genannt, versteht man im Wesentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, können Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert). Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus (engl. parametric polymorphism, s. Kapitel 29) gebräuchlich; sonst redet man eher von Subtyping. Das Interessante an der Inklusionspolymorphie ist, dass sich der Wertebereich von Typen dadurch auf unvorhergesehene Umfänge aufweiten lässt. Dies ist insbesondere für die Weiterentwicklung und Wiederverwendung von Programmen interessant, bei der einfach neue Typen hinzugefügt werden können, die anstelle bereits existierender eingesetzt werden können, ohne dass dazu am Programm sonst etwas geändert werden müsste. Die Regeln einer strengen Typprüfung werden durch Inklusionspolymorphie aufgelockert, ohne an Typsicherheit zu verlieren. Insgesamt krankt die Definition des Subtypings und der Inklusionspolymorphie in der objektorientierten Programmierung jedoch daran, dass nicht klar definiert ist, was alles zu verlangen ist, damit ein Objekt eines Typs tatsächlich auch da auftauchen kann, wo ein Objekt eines anderen Typs erwartet wird. Zwar gibt die Regel von Ko- und Kontravarianz eine klare Bedingung vor, aber wie Sie schon gesehen haben, ist diese Bedingung aus praktischen Gründen nicht unumstritten. Dazu kommt, dass die Regel einerseits gar nicht ausreicht, um Ersetzbarkeit zu garantieren, und andererseits zu streng ist (s. Kurseinheit 6, Kapitel 54). Da Ersetzbarkeit jedoch der Definition des Subtypenbegriffs zugrunde liegt, bleibt das Ganze schwammig. In dieser Kurseinheit habe ich mich, den meisten gängigen objektorientierten Programmiersprachen folgend, darauf zurückgezogen, zu garantieren, dass keine Typfehler auftreten können, also keine Fehler der Art, dass eine bestimmte geforderte Eigenschaft (Methode) bei einem Objekt nicht vorhanden ist; alles weitere wird dann in Kapitel 54 behandelt.","<answer> Inklusionspolymorphie, auch als Subtyp-Polymorphie bezeichnet, bedeutet, dass Objekte eines bestimmten Typs an Stellen erwartet werden können, an denen Objekte anderer Typen verwendet werden können, wenn der erste Typ die anderen Typen einschließt oder subsumiert. <answer> <question> Was ist Inklusionspolymorphie? <question>"
"Ein von Christopher Strachey, einem der Urväter der Programmierung als wissenschaftliche Disziplin, eingeführter Begriff ist der der Polymorphie. Polymorphie bedeutet allgemein Vielgestaltigkeit und wird vor allem in der Biologie verwendet. In der Programmierung steht er für verschiedene Dinge, die jedoch alle mit Typen zu tun haben. Unter Inklusionspolymorphie, auch Subtyp-Polymorphie genannt, versteht man im Wesentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, können Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert). Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus (engl. parametric polymorphism, s. Kapitel 29) gebräuchlich; sonst redet man eher von Subtyping. Das Interessante an der Inklusionspolymorphie ist, dass sich der Wertebereich von Typen dadurch auf unvorhergesehene Umfänge aufweiten lässt. Dies ist insbesondere für die Weiterentwicklung und Wiederverwendung von Programmen interessant, bei der einfach neue Typen hinzugefügt werden können, die anstelle bereits existierender eingesetzt werden können, ohne dass dazu am Programm sonst etwas geändert werden müsste. Die Regeln einer strengen Typprüfung werden durch Inklusionspolymorphie aufgelockert, ohne an Typsicherheit zu verlieren. Insgesamt krankt die Definition des Subtypings und der Inklusionspolymorphie in der objektorientierten Programmierung jedoch daran, dass nicht klar definiert ist, was alles zu verlangen ist, damit ein Objekt eines Typs tatsächlich auch da auftauchen kann, wo ein Objekt eines anderen Typs erwartet wird. Zwar gibt die Regel von Ko- und Kontravarianz eine klare Bedingung vor, aber wie Sie schon gesehen haben, ist diese Bedingung aus praktischen Gründen nicht unumstritten. Dazu kommt, dass die Regel einerseits gar nicht ausreicht, um Ersetzbarkeit zu garantieren, und andererseits zu streng ist (s. Kurseinheit 6, Kapitel 54). Da Ersetzbarkeit jedoch der Definition des Subtypenbegriffs zugrunde liegt, bleibt das Ganze schwammig. In dieser Kurseinheit habe ich mich, den meisten gängigen objektorientierten Programmiersprachen folgend, darauf zurückgezogen, zu garantieren, dass keine Typfehler auftreten können, also keine Fehler der Art, dass eine bestimmte geforderte Eigenschaft (Methode) bei einem Objekt nicht vorhanden ist; alles weitere wird dann in Kapitel 54 behandelt.","<answer> Inklusionspolymorphie und Subtyping sind im Wesentlichen dasselbe Konzept. Beide Begriffe beschreiben, wie Objekte eines Subtyps anstelle ihres Supertyps verwendet werden können. <answer> <question> Wie steht Inklusionspolymorphie in Beziehung zum Subtyping? <question>"
"Ein von Christopher Strachey, einem der Urväter der Programmierung als wissenschaftliche Disziplin, eingeführter Begriff ist der der Polymorphie. Polymorphie bedeutet allgemein Vielgestaltigkeit und wird vor allem in der Biologie verwendet. In der Programmierung steht er für verschiedene Dinge, die jedoch alle mit Typen zu tun haben. Unter Inklusionspolymorphie, auch Subtyp-Polymorphie genannt, versteht man im Wesentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, können Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert). Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus (engl. parametric polymorphism, s. Kapitel 29) gebräuchlich; sonst redet man eher von Subtyping. Das Interessante an der Inklusionspolymorphie ist, dass sich der Wertebereich von Typen dadurch auf unvorhergesehene Umfänge aufweiten lässt. Dies ist insbesondere für die Weiterentwicklung und Wiederverwendung von Programmen interessant, bei der einfach neue Typen hinzugefügt werden können, die anstelle bereits existierender eingesetzt werden können, ohne dass dazu am Programm sonst etwas geändert werden müsste. Die Regeln einer strengen Typprüfung werden durch Inklusionspolymorphie aufgelockert, ohne an Typsicherheit zu verlieren. Insgesamt krankt die Definition des Subtypings und der Inklusionspolymorphie in der objektorientierten Programmierung jedoch daran, dass nicht klar definiert ist, was alles zu verlangen ist, damit ein Objekt eines Typs tatsächlich auch da auftauchen kann, wo ein Objekt eines anderen Typs erwartet wird. Zwar gibt die Regel von Ko- und Kontravarianz eine klare Bedingung vor, aber wie Sie schon gesehen haben, ist diese Bedingung aus praktischen Gründen nicht unumstritten. Dazu kommt, dass die Regel einerseits gar nicht ausreicht, um Ersetzbarkeit zu garantieren, und andererseits zu streng ist (s. Kurseinheit 6, Kapitel 54). Da Ersetzbarkeit jedoch der Definition des Subtypenbegriffs zugrunde liegt, bleibt das Ganze schwammig. In dieser Kurseinheit habe ich mich, den meisten gängigen objektorientierten Programmiersprachen folgend, darauf zurückgezogen, zu garantieren, dass keine Typfehler auftreten können, also keine Fehler der Art, dass eine bestimmte geforderte Eigenschaft (Methode) bei einem Objekt nicht vorhanden ist; alles weitere wird dann in Kapitel 54 behandelt.","<answer> Inklusionspolymorphie ermöglicht die Erweiterung des Wertebereichs von Typen, indem neue Typen hinzugefügt werden können, die anstelle bereits existierender Typen verwendet werden können, ohne dass am Programm sonst etwas geändert werden muss. Dies ist besonders nützlich für die Weiterentwicklung und Wiederverwendung von Programmen. <answer> <question> Warum ist Inklusionspolymorphie interessant? <question>"
"Ein von Christopher Strachey, einem der Urväter der Programmierung als wissenschaftliche Disziplin, eingeführter Begriff ist der der Polymorphie. Polymorphie bedeutet allgemein Vielgestaltigkeit und wird vor allem in der Biologie verwendet. In der Programmierung steht er für verschiedene Dinge, die jedoch alle mit Typen zu tun haben. Unter Inklusionspolymorphie, auch Subtyp-Polymorphie genannt, versteht man im Wesentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, können Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert). Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus (engl. parametric polymorphism, s. Kapitel 29) gebräuchlich; sonst redet man eher von Subtyping. Das Interessante an der Inklusionspolymorphie ist, dass sich der Wertebereich von Typen dadurch auf unvorhergesehene Umfänge aufweiten lässt. Dies ist insbesondere für die Weiterentwicklung und Wiederverwendung von Programmen interessant, bei der einfach neue Typen hinzugefügt werden können, die anstelle bereits existierender eingesetzt werden können, ohne dass dazu am Programm sonst etwas geändert werden müsste. Die Regeln einer strengen Typprüfung werden durch Inklusionspolymorphie aufgelockert, ohne an Typsicherheit zu verlieren. Insgesamt krankt die Definition des Subtypings und der Inklusionspolymorphie in der objektorientierten Programmierung jedoch daran, dass nicht klar definiert ist, was alles zu verlangen ist, damit ein Objekt eines Typs tatsächlich auch da auftauchen kann, wo ein Objekt eines anderen Typs erwartet wird. Zwar gibt die Regel von Ko- und Kontravarianz eine klare Bedingung vor, aber wie Sie schon gesehen haben, ist diese Bedingung aus praktischen Gründen nicht unumstritten. Dazu kommt, dass die Regel einerseits gar nicht ausreicht, um Ersetzbarkeit zu garantieren, und andererseits zu streng ist (s. Kurseinheit 6, Kapitel 54). Da Ersetzbarkeit jedoch der Definition des Subtypenbegriffs zugrunde liegt, bleibt das Ganze schwammig. In dieser Kurseinheit habe ich mich, den meisten gängigen objektorientierten Programmiersprachen folgend, darauf zurückgezogen, zu garantieren, dass keine Typfehler auftreten können, also keine Fehler der Art, dass eine bestimmte geforderte Eigenschaft (Methode) bei einem Objekt nicht vorhanden ist; alles weitere wird dann in Kapitel 54 behandelt.","<answer> Die Definition von Subtyping und Inklusionspolymorphie in der objektorientierten Programmierung ist unklar, insbesondere in Bezug darauf, was erforderlich ist, damit ein Objekt eines Typs tatsächlich an Stellen verwendet werden kann, an denen ein Objekt eines anderen Typs erwartet wird. Die Regeln von Ko- und Kontravarianz geben zwar klare Bedingungen vor, sind aber in der Praxis umstritten und reichen nicht immer aus, um Ersetzbarkeit sicherzustellen. Dies führt zu Unsicherheiten in der Definition des Subtypenbegriffs. <answer> <question> Welche Probleme gibt es in Bezug auf die Definition von Subtyping und Inklusionspolymorphie in der objektorientierten Programmierung? <question>"
"Nun mögen Sie sich vielleicht fragen, warum Typen und Klassen über so viele Seiten hinweg als getrennte Begriffe dargestellt wurden, nur um am Ende zum Schluss zu kommen, dass eine Klassendefinition in der Regel auch als Typdefinition herhält. Nun, erstens ist das nicht in allen Sprachen der Fall, und zweitens ist es selbst in den Sprachen, in denen es so zu sein scheint, nicht immer der Fall (siehe Fußnote 54). Es handelt sich eher um eine Symbiose zweier verschiedener Konzepte, die unterschiedlichen Zwecken dienen, deren strukturelle Ähnlichkeit sich jedoch durch eine syntaktische Zusammenlegung ausnutzen lässt: Klassen dienen der Angabe von Implementierungen und damit als Container für ausführbaren Code. Typen dienen der Formulierung von Invarianten, die für Variablenzuweisungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmfehler hinweist.
Da beide im Wesentlichen über die gleichen Elemente verfügen, lässt sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied zwischen den beiden Konzepten, Klasse und Typ, manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante abbrechen lässt (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zu identifizierenden Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms, indem sie die Grundlage des dynamischen Bindens bildet und in einem Programm als Eigenschaft von Objekten abgefragt werden kann. In Sprachen, in denen jede Klasse einen Typ definiert, ist diese Unterscheidung jedoch nicht immer klar getroffen und wird deswegen von Programmierern nicht unbedingt wahrgenommen.","<answer> Die Trennung von Typen und Klassen wird gezeigt, weil sie nicht in allen Programmiersprachen identisch sind, und selbst in den Sprachen, in denen sie ähnlich sind, gibt es Unterschiede und spezifische Verwendungszwecke. <answer> <question> Warum wurden Typen und Klassen in diesem Text als separate Konzepte dargestellt, obwohl sie in vielen Sprachen gleich sind? <question>"
"Nun mögen Sie sich vielleicht fragen, warum Typen und Klassen über so viele Seiten hinweg als getrennte Begriffe dargestellt wurden, nur um am Ende zum Schluss zu kommen, dass eine Klassendefinition in der Regel auch als Typdefinition herhält. Nun, erstens ist das nicht in allen Sprachen der Fall, und zweitens ist es selbst in den Sprachen, in denen es so zu sein scheint, nicht immer der Fall (siehe Fußnote 54). Es handelt sich eher um eine Symbiose zweier verschiedener Konzepte, die unterschiedlichen Zwecken dienen, deren strukturelle Ähnlichkeit sich jedoch durch eine syntaktische Zusammenlegung ausnutzen lässt: Klassen dienen der Angabe von Implementierungen und damit als Container für ausführbaren Code. Typen dienen der Formulierung von Invarianten, die für Variablenzuweisungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmfehler hinweist.
Da beide im Wesentlichen über die gleichen Elemente verfügen, lässt sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied zwischen den beiden Konzepten, Klasse und Typ, manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante abbrechen lässt (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zu identifizierenden Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms, indem sie die Grundlage des dynamischen Bindens bildet und in einem Programm als Eigenschaft von Objekten abgefragt werden kann. In Sprachen, in denen jede Klasse einen Typ definiert, ist diese Unterscheidung jedoch nicht immer klar getroffen und wird deswegen von Programmierern nicht unbedingt wahrgenommen.","<answer> Klassen dienen der Angabe von Implementierungen und fungieren als Container für ausführbaren Code. Sie sind strukturell ähnlich wie Typen, haben jedoch unterschiedliche Verwendungszwecke. <answer> <question> Welche Rolle spielen Klassen in der Programmierung, und wie unterscheiden sie sich von Typen? <question>"
"Nun mögen Sie sich vielleicht fragen, warum Typen und Klassen über so viele Seiten hinweg als getrennte Begriffe dargestellt wurden, nur um am Ende zum Schluss zu kommen, dass eine Klassendefinition in der Regel auch als Typdefinition herhält. Nun, erstens ist das nicht in allen Sprachen der Fall, und zweitens ist es selbst in den Sprachen, in denen es so zu sein scheint, nicht immer der Fall (siehe Fußnote 54). Es handelt sich eher um eine Symbiose zweier verschiedener Konzepte, die unterschiedlichen Zwecken dienen, deren strukturelle Ähnlichkeit sich jedoch durch eine syntaktische Zusammenlegung ausnutzen lässt: Klassen dienen der Angabe von Implementierungen und damit als Container für ausführbaren Code. Typen dienen der Formulierung von Invarianten, die für Variablenzuweisungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmfehler hinweist.
Da beide im Wesentlichen über die gleichen Elemente verfügen, lässt sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied zwischen den beiden Konzepten, Klasse und Typ, manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante abbrechen lässt (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zu identifizierenden Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms, indem sie die Grundlage des dynamischen Bindens bildet und in einem Programm als Eigenschaft von Objekten abgefragt werden kann. In Sprachen, in denen jede Klasse einen Typ definiert, ist diese Unterscheidung jedoch nicht immer klar getroffen und wird deswegen von Programmierern nicht unbedingt wahrgenommen.","<answer> Typen dienen der Formulierung von Invarianten, die für Variablenzuweisungen gelten müssen und bei deren Verletzung auf Programmfehler hinweisen. Sie sind strukturell ähnlich wie Klassen, haben jedoch eine andere Rolle zur Laufzeit des Programms. <answer> <question> Welche Funktion erfüllen Typen in der Programmierung, und wie unterscheiden sie sich von Klassen? <question>"
"Nun mögen Sie sich vielleicht fragen, warum Typen und Klassen über so viele Seiten hinweg als getrennte Begriffe dargestellt wurden, nur um am Ende zum Schluss zu kommen, dass eine Klassendefinition in der Regel auch als Typdefinition herhält. Nun, erstens ist das nicht in allen Sprachen der Fall, und zweitens ist es selbst in den Sprachen, in denen es so zu sein scheint, nicht immer der Fall (siehe Fußnote 54). Es handelt sich eher um eine Symbiose zweier verschiedener Konzepte, die unterschiedlichen Zwecken dienen, deren strukturelle Ähnlichkeit sich jedoch durch eine syntaktische Zusammenlegung ausnutzen lässt: Klassen dienen der Angabe von Implementierungen und damit als Container für ausführbaren Code. Typen dienen der Formulierung von Invarianten, die für Variablenzuweisungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmfehler hinweist.
Da beide im Wesentlichen über die gleichen Elemente verfügen, lässt sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied zwischen den beiden Konzepten, Klasse und Typ, manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante abbrechen lässt (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zu identifizierenden Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms, indem sie die Grundlage des dynamischen Bindens bildet und in einem Programm als Eigenschaft von Objekten abgefragt werden kann. In Sprachen, in denen jede Klasse einen Typ definiert, ist diese Unterscheidung jedoch nicht immer klar getroffen und wird deswegen von Programmierern nicht unbedingt wahrgenommen.","<answer> Obwohl Typen und Klassen unterschiedliche Zwecke haben, teilen sie sich strukturelle Ähnlichkeiten, die es ermöglichen, ihre Definition in einem Sprachkonstrukt zu kombinieren. Dies erleichtert die Verwendung beider Konzepte in einer Programmiersprache. <answer> <question> Wie können Typen und Klassen in einem Sprachkonstrukt zusammengefasst werden, obwohl sie unterschiedliche Zwecke haben? <question>"
"Nun mögen Sie sich vielleicht fragen, warum Typen und Klassen über so viele Seiten hinweg als getrennte Begriffe dargestellt wurden, nur um am Ende zum Schluss zu kommen, dass eine Klassendefinition in der Regel auch als Typdefinition herhält. Nun, erstens ist das nicht in allen Sprachen der Fall, und zweitens ist es selbst in den Sprachen, in denen es so zu sein scheint, nicht immer der Fall (siehe Fußnote 54). Es handelt sich eher um eine Symbiose zweier verschiedener Konzepte, die unterschiedlichen Zwecken dienen, deren strukturelle Ähnlichkeit sich jedoch durch eine syntaktische Zusammenlegung ausnutzen lässt: Klassen dienen der Angabe von Implementierungen und damit als Container für ausführbaren Code. Typen dienen der Formulierung von Invarianten, die für Variablenzuweisungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmfehler hinweist.
Da beide im Wesentlichen über die gleichen Elemente verfügen, lässt sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied zwischen den beiden Konzepten, Klasse und Typ, manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante abbrechen lässt (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zu identifizierenden Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms, indem sie die Grundlage des dynamischen Bindens bildet und in einem Programm als Eigenschaft von Objekten abgefragt werden kann. In Sprachen, in denen jede Klasse einen Typ definiert, ist diese Unterscheidung jedoch nicht immer klar getroffen und wird deswegen von Programmierern nicht unbedingt wahrgenommen.","<answer> Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante durch einen dynamischen Typtest abbricht. Klasseninformation hingegen bildet die Grundlage des dynamischen Bindens und kann in einem Programm als Eigenschaft von Objekten abgefragt werden. <answer> <question> Welche Rolle spielt Typinformation zur Laufzeit eines Programms, und wie unterscheidet sie sich von Klasseninformation? <question>"
"Nun mögen Sie sich vielleicht fragen, warum Typen und Klassen über so viele Seiten hinweg als getrennte Begriffe dargestellt wurden, nur um am Ende zum Schluss zu kommen, dass eine Klassendefinition in der Regel auch als Typdefinition herhält. Nun, erstens ist das nicht in allen Sprachen der Fall, und zweitens ist es selbst in den Sprachen, in denen es so zu sein scheint, nicht immer der Fall (siehe Fußnote 54). Es handelt sich eher um eine Symbiose zweier verschiedener Konzepte, die unterschiedlichen Zwecken dienen, deren strukturelle Ähnlichkeit sich jedoch durch eine syntaktische Zusammenlegung ausnutzen lässt: Klassen dienen der Angabe von Implementierungen und damit als Container für ausführbaren Code. Typen dienen der Formulierung von Invarianten, die für Variablenzuweisungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmfehler hinweist.
Da beide im Wesentlichen über die gleichen Elemente verfügen, lässt sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied zwischen den beiden Konzepten, Klasse und Typ, manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante abbrechen lässt (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zu identifizierenden Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms, indem sie die Grundlage des dynamischen Bindens bildet und in einem Programm als Eigenschaft von Objekten abgefragt werden kann. In Sprachen, in denen jede Klasse einen Typ definiert, ist diese Unterscheidung jedoch nicht immer klar getroffen und wird deswegen von Programmierern nicht unbedingt wahrgenommen.","<answer> In Sprachen, in denen Klassen auch Typen definieren, kann die Unterscheidung zwischen den beiden Konzepten verschwommen sein, da Programmierer möglicherweise nicht immer klar wahrnehmen, wie sie zur Laufzeit eines Programms wirken. <answer> <question> Warum wird die Unterscheidung zwischen Klassen und Typen in Sprachen, in denen jede Klasse einen Typ definiert, manchmal nicht klar getroffen? <question>"
"Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht für eine besondere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung. Die Gegenrolle heißt Supertyp.
Man beachte, dass diese Definition von Subtypen Zuweisungskompatibilität impliziert: Wenn die Objekte eines Subtypen überall auftauchen dürfen, wo Objekte seines Supertyps erwartet werden, dann dürfen sie auch Werte von jemandem zugreifen, der bei einer Zeichnung auf ihre Zeilen zugreifen will. Außerdem müsste bei der ersten Annahme des allgemeinsten Typs, von dem alle anderen abgeleitet sind (Object in STRONGTALK), immer alle Attribute deklariert werden, die einem jemals in den Sinn kämen, und das wäre nun wirklich unpraktisch. Die Problemquelle könnten Variablen sein, die mit dem Supertypen annotiert sind (auf Werte des Supertyps beschränkt). Ein Subtyp ist also per Definition mit seinem Supertyp zuweisungskompatibel. In dieser Definition steckt jedoch eine gewisse Zirkularität (Subtyp als Voraussetzung und Ergebnis der Zuweisungskompatibilität), die eine Einfachheit der Zusammenhänge vortäuscht, die es in Wirklichkeit nicht gibt. Die eigentliche Frage, was nämlich erfüllt sein muss, damit ein Objekt eines Typs tatsächlich dort erscheinen darf, wo ein Objekt eines anderen Typs erwartet wird, bleibt unberücksichtigt. Eine Befassung mit dieser Frage erfolgt hier jedoch nur insoweit, wie dies heutige Typsysteme tatsächlich tun; eine genauere Betrachtung erfolgt dann erst in Kurseinheit 6, Kapitel 54.","<answer> Ein Subtyp ist ein Typ, dessen Werte oder Objekte überall dort verwendet werden können, wo die Werte des Supertyps, von dem er ein Subtyp ist, erwartet werden. Der Begriff ""Subtyp"" bezieht sich auf die Rolle eines Typs in der Beziehung zu einem anderen Typ, nämlich der Subtypenbeziehung. Die Gegenrolle in dieser Beziehung wird als Supertyp bezeichnet. <answer> <question> Was versteht man unter einem Subtyp und wie steht er in Beziehung zu einem Supertyp? <question>"
"Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht für eine besondere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung. Die Gegenrolle heißt Supertyp.
Man beachte, dass diese Definition von Subtypen Zuweisungskompatibilität impliziert: Wenn die Objekte eines Subtypen überall auftauchen dürfen, wo Objekte seines Supertyps erwartet werden, dann dürfen sie auch Werte von jemandem zugreifen, der bei einer Zeichnung auf ihre Zeilen zugreifen will. Außerdem müsste bei der ersten Annahme des allgemeinsten Typs, von dem alle anderen abgeleitet sind (Object in STRONGTALK), immer alle Attribute deklariert werden, die einem jemals in den Sinn kämen, und das wäre nun wirklich unpraktisch. Die Problemquelle könnten Variablen sein, die mit dem Supertypen annotiert sind (auf Werte des Supertyps beschränkt). Ein Subtyp ist also per Definition mit seinem Supertyp zuweisungskompatibel. In dieser Definition steckt jedoch eine gewisse Zirkularität (Subtyp als Voraussetzung und Ergebnis der Zuweisungskompatibilität), die eine Einfachheit der Zusammenhänge vortäuscht, die es in Wirklichkeit nicht gibt. Die eigentliche Frage, was nämlich erfüllt sein muss, damit ein Objekt eines Typs tatsächlich dort erscheinen darf, wo ein Objekt eines anderen Typs erwartet wird, bleibt unberücksichtigt. Eine Befassung mit dieser Frage erfolgt hier jedoch nur insoweit, wie dies heutige Typsysteme tatsächlich tun; eine genauere Betrachtung erfolgt dann erst in Kurseinheit 6, Kapitel 54.","<answer> Die Definition von Subtypen impliziert Zuweisungskompatibilität. Wenn die Objekte eines Subtyps überall dort verwendet werden können, wo Objekte seines Supertyps erwartet werden, dann können sie auch Werte für Variablen des Supertyps sein. Dies bedeutet, dass ein Subtyp per Definition zuweisungskompatibel mit seinem Supertyp ist. <answer> <question> Welche Implikation hat die Definition von Subtypen in Bezug auf die Zuweisungskompatibilität? <question>"
"Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht für eine besondere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung. Die Gegenrolle heißt Supertyp.
Man beachte, dass diese Definition von Subtypen Zuweisungskompatibilität impliziert: Wenn die Objekte eines Subtypen überall auftauchen dürfen, wo Objekte seines Supertyps erwartet werden, dann dürfen sie auch Werte von jemandem zugreifen, der bei einer Zeichnung auf ihre Zeilen zugreifen will. Außerdem müsste bei der ersten Annahme des allgemeinsten Typs, von dem alle anderen abgeleitet sind (Object in STRONGTALK), immer alle Attribute deklariert werden, die einem jemals in den Sinn kämen, und das wäre nun wirklich unpraktisch. Die Problemquelle könnten Variablen sein, die mit dem Supertypen annotiert sind (auf Werte des Supertyps beschränkt). Ein Subtyp ist also per Definition mit seinem Supertyp zuweisungskompatibel. In dieser Definition steckt jedoch eine gewisse Zirkularität (Subtyp als Voraussetzung und Ergebnis der Zuweisungskompatibilität), die eine Einfachheit der Zusammenhänge vortäuscht, die es in Wirklichkeit nicht gibt. Die eigentliche Frage, was nämlich erfüllt sein muss, damit ein Objekt eines Typs tatsächlich dort erscheinen darf, wo ein Objekt eines anderen Typs erwartet wird, bleibt unberücksichtigt. Eine Befassung mit dieser Frage erfolgt hier jedoch nur insoweit, wie dies heutige Typsysteme tatsächlich tun; eine genauere Betrachtung erfolgt dann erst in Kurseinheit 6, Kapitel 54.","<answer> Ja, es gibt eine gewisse Zirkularität in der Definition von Subtypen. Die Definition selbst basiert auf der Zuweisungskompatibilität zwischen Subtypen und Supertypen. Dies kann den Eindruck erwecken, dass die Beziehung zwischen Subtypen und Supertypen einfacher ist, als sie in der Realität ist. Die eigentliche Frage, welche Bedingungen erfüllt sein müssen, damit ein Objekt eines Subtyps tatsächlich an Stellen verwendet werden darf, an denen ein Objekt eines Supertyps erwartet wird, wird jedoch in dieser Definition nicht näher erläutert. <answer> <question> Gibt es eine gewisse Zirkularität in der Definition von Subtypen? <question>"
"Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht für eine besondere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung. Die Gegenrolle heißt Supertyp.
Man beachte, dass diese Definition von Subtypen Zuweisungskompatibilität impliziert: Wenn die Objekte eines Subtypen überall auftauchen dürfen, wo Objekte seines Supertyps erwartet werden, dann dürfen sie auch Werte von jemandem zugreifen, der bei einer Zeichnung auf ihre Zeilen zugreifen will. Außerdem müsste bei der ersten Annahme des allgemeinsten Typs, von dem alle anderen abgeleitet sind (Object in STRONGTALK), immer alle Attribute deklariert werden, die einem jemals in den Sinn kämen, und das wäre nun wirklich unpraktisch. Die Problemquelle könnten Variablen sein, die mit dem Supertypen annotiert sind (auf Werte des Supertyps beschränkt). Ein Subtyp ist also per Definition mit seinem Supertyp zuweisungskompatibel. In dieser Definition steckt jedoch eine gewisse Zirkularität (Subtyp als Voraussetzung und Ergebnis der Zuweisungskompatibilität), die eine Einfachheit der Zusammenhänge vortäuscht, die es in Wirklichkeit nicht gibt. Die eigentliche Frage, was nämlich erfüllt sein muss, damit ein Objekt eines Typs tatsächlich dort erscheinen darf, wo ein Objekt eines anderen Typs erwartet wird, bleibt unberücksichtigt. Eine Befassung mit dieser Frage erfolgt hier jedoch nur insoweit, wie dies heutige Typsysteme tatsächlich tun; eine genauere Betrachtung erfolgt dann erst in Kurseinheit 6, Kapitel 54.","<answer> Die Annotation von Variablen mit dem Supertypen könnte ein Problem darstellen, da dies die Verwendung von Subtypen einschränken würde. Wenn Variablen mit dem Supertypen annotiert sind und nur Werte des Supertyps akzeptieren, könnten keine Objekte des Subtyps in diesen Variablen gespeichert werden, selbst wenn sie die gleiche Struktur oder das gleiche Verhalten aufweisen. Dies würde die Flexibilität des Typsystems einschränken und die Verwendung von Subtypen weniger nützlich machen. <answer> <question> Warum könnte die Annotation von Variablen mit dem Supertypen ein Problem darstellen? <question>"
"Beim Subtyping unterscheidet man, wie bei der Typäquivalenz und -konformität, zwischen nominalem und strukturellem Subtyping. Nominales Subtyping liegt vor, wenn ein Subtyp aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. Strukturelles Subtyping liegt vor, wenn ein Typ lediglich die obige Definition von Subtyp erfüllen muss, um als solcher zu gelten. Nominales Subtyping impliziert strukturelles; analog zur Typkonformität macht das nominale Subtyping die Subtypenbeziehung antisymmetrisch, das strukturelle hingegen nicht.",<answer> Beim Subtyping gibt es zwei Unterscheidungen: nominales und strukturelles Subtyping. <answer> <question> Was ist der Unterschied zwischen nominalem und strukturellem Subtyping? <question>
"Beim Subtyping unterscheidet man, wie bei der Typäquivalenz und -konformität, zwischen nominalem und strukturellem Subtyping. Nominales Subtyping liegt vor, wenn ein Subtyp aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. Strukturelles Subtyping liegt vor, wenn ein Typ lediglich die obige Definition von Subtyp erfüllen muss, um als solcher zu gelten. Nominales Subtyping impliziert strukturelles; analog zur Typkonformität macht das nominale Subtyping die Subtypenbeziehung antisymmetrisch, das strukturelle hingegen nicht.","<answer> Nominales Subtyping bedeutet, dass ein Subtyp explizit aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. In diesem Fall ist die Namensähnlichkeit entscheidend. <answer> <question> Was ist nominales Subtyping? <question>"
"Beim Subtyping unterscheidet man, wie bei der Typäquivalenz und -konformität, zwischen nominalem und strukturellem Subtyping. Nominales Subtyping liegt vor, wenn ein Subtyp aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. Strukturelles Subtyping liegt vor, wenn ein Typ lediglich die obige Definition von Subtyp erfüllen muss, um als solcher zu gelten. Nominales Subtyping impliziert strukturelles; analog zur Typkonformität macht das nominale Subtyping die Subtypenbeziehung antisymmetrisch, das strukturelle hingegen nicht.","<answer> Strukturelles Subtyping liegt vor, wenn ein Typ die allgemeine Definition eines Subtyps erfüllt, unabhängig von seiner expliziten Nennung als Supertyp. Hier ist die Struktur und das Verhalten des Typs entscheidend, nicht seine explizite Nennung als Supertyp. <answer> <question> Was ist strukturelles Subtyping? <question>"
"Beim Subtyping unterscheidet man, wie bei der Typäquivalenz und -konformität, zwischen nominalem und strukturellem Subtyping. Nominales Subtyping liegt vor, wenn ein Subtyp aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. Strukturelles Subtyping liegt vor, wenn ein Typ lediglich die obige Definition von Subtyp erfüllen muss, um als solcher zu gelten. Nominales Subtyping impliziert strukturelles; analog zur Typkonformität macht das nominale Subtyping die Subtypenbeziehung antisymmetrisch, das strukturelle hingegen nicht.","<answer> Nominales Subtyping impliziert strukturelles Subtyping. Das bedeutet, wenn ein Subtyp nominal als Supertyp erwähnt wird, erfüllt er automatisch auch die strukturellen Kriterien eines Subtyps. <answer> <question> Welches der beiden Subtyping-Modelle impliziert das andere? <question>"
"Beim Subtyping unterscheidet man, wie bei der Typäquivalenz und -konformität, zwischen nominalem und strukturellem Subtyping. Nominales Subtyping liegt vor, wenn ein Subtyp aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. Strukturelles Subtyping liegt vor, wenn ein Typ lediglich die obige Definition von Subtyp erfüllen muss, um als solcher zu gelten. Nominales Subtyping impliziert strukturelles; analog zur Typkonformität macht das nominale Subtyping die Subtypenbeziehung antisymmetrisch, das strukturelle hingegen nicht.","<answer> Nominales Subtyping macht die Subtypenbeziehung antisymmetrisch, während strukturelles Subtyping dies nicht tut. Das bedeutet, dass im Fall des nominalen Subtypings ein Subtyp nicht gleichzeitig Subtyp seines Supertyps sein kann, während dies im strukturellen Subtyping möglich ist. <answer> <question> Was sind die Auswirkungen von nominalem und strukturellem Subtyping auf die Subtypenbeziehung? <question>"
"Wie Sie sehen, ist das Problem der kovarianten Redefinition ziemlich hartnäckig. Man muss aber gar nicht so weit gehen, um an die praktischen Grenzen der Typisierung zu gelangen. Nun könnte man einen Typ NotZero definieren und x als von diesem Typ deklarieren, womit der obige Ausdruck kein Problem mehr wäre. Selbst wenn es Typsysteme gibt, die das können, so sind diese kaum praxistauglich.","<answer> In diesem Abschnitt wird das Problem der praktischen Grenzen der Typisierung diskutiert, insbesondere im Kontext von Typfehlern und der Einschränkung bei der Überprüfung von Zuweisungen. <answer> <question> Welches Problem wird in diesem Abschnitt ""Grenzen der Typisierung"" angesprochen? <question>"
"Wie Sie sehen, ist das Problem der kovarianten Redefinition ziemlich hartnäckig. Man muss aber gar nicht so weit gehen, um an die praktischen Grenzen der Typisierung zu gelangen. Nun könnte man einen Typ NotZero definieren und x als von diesem Typ deklarieren, womit der obige Ausdruck kein Problem mehr wäre. Selbst wenn es Typsysteme gibt, die das können, so sind diese kaum praxistauglich.","<answer> Bestimmte Typsysteme, die in der Lage sind, solche Einschränkungen zu überprüfen, werden als kaum praxistauglich bezeichnet, da sie die Flexibilität und die praktische Anwendbarkeit in realen Programmiersituationen stark einschränken. Sie können zu komplexen und schwer wartbaren Code führen. <answer> <question> Warum werden bestimmte Typsysteme als kaum praxistauglich bezeichnet? <question>"
"Da Ausdrücke andere Ausdrücke enthalten können, stellt sich die Frage nach der Reihenfolge der Auswertung von geschachtelten Ausdrücken. Diese Reihenfolge wird, wie in anderen Programmiersprachen, implizit durch Präzedenzen und explizit durch Klammern festgelegt.
Betrachten wir zunächst die doppelte Zuweisung in Zeile 38 oben. Anfangs mag es nicht sofort klar sein, welche der beiden Zuweisungen zuerst ausgewertet (ausgeführt) werden soll: y := x oder x := 1. Wenn man jedoch berücksichtigt, dass y := x := 1 ein geschachtelter Ausdruck ist, und jeder (Teil-)Ausdruck für ein Objekt steht, ergibt sich, dass der zweite Ausdruck zuerst ausgewertet und durch das Ergebnis, nämlich ""1"", ersetzt werden muss. Andernfalls würde die ""1"" dem Ergebnis von y := x zugewiesen, was aber gemäß Abschnitt 4.1.3 ein Objekt und keine Variable ist. Zeile 38 weist also zuerst x und dann y das Objekt ""1"" zu, und die Auswertung erfolgt von rechts nach links.
Dies ist jedoch ein Sonderfall. Im Allgemeinen werden in SMALLTALK alle Ausdrücke von links nach rechts ausgewertet. Dabei haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke wiederum haben Vorrang vor Schlüsselwortnachrichten. Bei gleichrangigen Ausdrücken erfolgt die Auswertung von links nach rechts.
Um die Präzedenz zu ändern, können Sie einfach Klammern verwenden. SMALLTALK unterstützt keine individuellen Operatorpräzedenzen wie beispielsweise ""Punktrechnung vor Strichrechnung"".
Bei mehrstelligen Nachrichten mit Schlüsselwörtern werden alle Schlüsselwörter eines Ausdrucks als zu einer Nachricht gehörig interpretiert, es sei denn, es werden Klammern gesetzt.",<answer> Die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK wird durch Präzedenzen und Klammern festgelegt. <answer> <question> Wie wird die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK festgelegt? <question>
"Da Ausdrücke andere Ausdrücke enthalten können, stellt sich die Frage nach der Reihenfolge der Auswertung von geschachtelten Ausdrücken. Diese Reihenfolge wird, wie in anderen Programmiersprachen, implizit durch Präzedenzen und explizit durch Klammern festgelegt.
Betrachten wir zunächst die doppelte Zuweisung in Zeile 38 oben. Anfangs mag es nicht sofort klar sein, welche der beiden Zuweisungen zuerst ausgewertet (ausgeführt) werden soll: y := x oder x := 1. Wenn man jedoch berücksichtigt, dass y := x := 1 ein geschachtelter Ausdruck ist, und jeder (Teil-)Ausdruck für ein Objekt steht, ergibt sich, dass der zweite Ausdruck zuerst ausgewertet und durch das Ergebnis, nämlich ""1"", ersetzt werden muss. Andernfalls würde die ""1"" dem Ergebnis von y := x zugewiesen, was aber gemäß Abschnitt 4.1.3 ein Objekt und keine Variable ist. Zeile 38 weist also zuerst x und dann y das Objekt ""1"" zu, und die Auswertung erfolgt von rechts nach links.
Dies ist jedoch ein Sonderfall. Im Allgemeinen werden in SMALLTALK alle Ausdrücke von links nach rechts ausgewertet. Dabei haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke wiederum haben Vorrang vor Schlüsselwortnachrichten. Bei gleichrangigen Ausdrücken erfolgt die Auswertung von links nach rechts.
Um die Präzedenz zu ändern, können Sie einfach Klammern verwenden. SMALLTALK unterstützt keine individuellen Operatorpräzedenzen wie beispielsweise ""Punktrechnung vor Strichrechnung"".
Bei mehrstelligen Nachrichten mit Schlüsselwörtern werden alle Schlüsselwörter eines Ausdrucks als zu einer Nachricht gehörig interpretiert, es sei denn, es werden Klammern gesetzt.",<answer> In SMALLTALK werden Ausdrücke normalerweise von links nach rechts ausgewertet. <answer> <question> Welcher Teil eines geschachtelten Ausdrucks wird in SMALLTALK normalerweise zuerst ausgewertet? <question>
"Da Ausdrücke andere Ausdrücke enthalten können, stellt sich die Frage nach der Reihenfolge der Auswertung von geschachtelten Ausdrücken. Diese Reihenfolge wird, wie in anderen Programmiersprachen, implizit durch Präzedenzen und explizit durch Klammern festgelegt.
Betrachten wir zunächst die doppelte Zuweisung in Zeile 38 oben. Anfangs mag es nicht sofort klar sein, welche der beiden Zuweisungen zuerst ausgewertet (ausgeführt) werden soll: y := x oder x := 1. Wenn man jedoch berücksichtigt, dass y := x := 1 ein geschachtelter Ausdruck ist, und jeder (Teil-)Ausdruck für ein Objekt steht, ergibt sich, dass der zweite Ausdruck zuerst ausgewertet und durch das Ergebnis, nämlich ""1"", ersetzt werden muss. Andernfalls würde die ""1"" dem Ergebnis von y := x zugewiesen, was aber gemäß Abschnitt 4.1.3 ein Objekt und keine Variable ist. Zeile 38 weist also zuerst x und dann y das Objekt ""1"" zu, und die Auswertung erfolgt von rechts nach links.
Dies ist jedoch ein Sonderfall. Im Allgemeinen werden in SMALLTALK alle Ausdrücke von links nach rechts ausgewertet. Dabei haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke wiederum haben Vorrang vor Schlüsselwortnachrichten. Bei gleichrangigen Ausdrücken erfolgt die Auswertung von links nach rechts.
Um die Präzedenz zu ändern, können Sie einfach Klammern verwenden. SMALLTALK unterstützt keine individuellen Operatorpräzedenzen wie beispielsweise ""Punktrechnung vor Strichrechnung"".
Bei mehrstelligen Nachrichten mit Schlüsselwörtern werden alle Schlüsselwörter eines Ausdrucks als zu einer Nachricht gehörig interpretiert, es sei denn, es werden Klammern gesetzt.","<answer> In SMALLTALK haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke haben Vorrang vor Schlüsselwortnachrichten. <answer> <question> Welche Art von Ausdrücken hat in SMALLTALK Vorrang vor anderen, wenn sie gleichzeitig auftreten? <question>"
"Da Ausdrücke andere Ausdrücke enthalten können, stellt sich die Frage nach der Reihenfolge der Auswertung von geschachtelten Ausdrücken. Diese Reihenfolge wird, wie in anderen Programmiersprachen, implizit durch Präzedenzen und explizit durch Klammern festgelegt.
Betrachten wir zunächst die doppelte Zuweisung in Zeile 38 oben. Anfangs mag es nicht sofort klar sein, welche der beiden Zuweisungen zuerst ausgewertet (ausgeführt) werden soll: y := x oder x := 1. Wenn man jedoch berücksichtigt, dass y := x := 1 ein geschachtelter Ausdruck ist, und jeder (Teil-)Ausdruck für ein Objekt steht, ergibt sich, dass der zweite Ausdruck zuerst ausgewertet und durch das Ergebnis, nämlich ""1"", ersetzt werden muss. Andernfalls würde die ""1"" dem Ergebnis von y := x zugewiesen, was aber gemäß Abschnitt 4.1.3 ein Objekt und keine Variable ist. Zeile 38 weist also zuerst x und dann y das Objekt ""1"" zu, und die Auswertung erfolgt von rechts nach links.
Dies ist jedoch ein Sonderfall. Im Allgemeinen werden in SMALLTALK alle Ausdrücke von links nach rechts ausgewertet. Dabei haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke wiederum haben Vorrang vor Schlüsselwortnachrichten. Bei gleichrangigen Ausdrücken erfolgt die Auswertung von links nach rechts.
Um die Präzedenz zu ändern, können Sie einfach Klammern verwenden. SMALLTALK unterstützt keine individuellen Operatorpräzedenzen wie beispielsweise ""Punktrechnung vor Strichrechnung"".
Bei mehrstelligen Nachrichten mit Schlüsselwörtern werden alle Schlüsselwörter eines Ausdrucks als zu einer Nachricht gehörig interpretiert, es sei denn, es werden Klammern gesetzt.","<answer> Um die Reihenfolge der Auswertung in SMALLTALK zu ändern, können Sie Klammern verwenden, um sicherzustellen, dass bestimmte Teile eines Ausdrucks zuerst ausgewertet werden. <answer> <question> Wie können Sie in SMALLTALK die Reihenfolge der Auswertung ändern? <question>"
"Da Ausdrücke andere Ausdrücke enthalten können, stellt sich die Frage nach der Reihenfolge der Auswertung von geschachtelten Ausdrücken. Diese Reihenfolge wird, wie in anderen Programmiersprachen, implizit durch Präzedenzen und explizit durch Klammern festgelegt.
Betrachten wir zunächst die doppelte Zuweisung in Zeile 38 oben. Anfangs mag es nicht sofort klar sein, welche der beiden Zuweisungen zuerst ausgewertet (ausgeführt) werden soll: y := x oder x := 1. Wenn man jedoch berücksichtigt, dass y := x := 1 ein geschachtelter Ausdruck ist, und jeder (Teil-)Ausdruck für ein Objekt steht, ergibt sich, dass der zweite Ausdruck zuerst ausgewertet und durch das Ergebnis, nämlich ""1"", ersetzt werden muss. Andernfalls würde die ""1"" dem Ergebnis von y := x zugewiesen, was aber gemäß Abschnitt 4.1.3 ein Objekt und keine Variable ist. Zeile 38 weist also zuerst x und dann y das Objekt ""1"" zu, und die Auswertung erfolgt von rechts nach links.
Dies ist jedoch ein Sonderfall. Im Allgemeinen werden in SMALLTALK alle Ausdrücke von links nach rechts ausgewertet. Dabei haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke wiederum haben Vorrang vor Schlüsselwortnachrichten. Bei gleichrangigen Ausdrücken erfolgt die Auswertung von links nach rechts.
Um die Präzedenz zu ändern, können Sie einfach Klammern verwenden. SMALLTALK unterstützt keine individuellen Operatorpräzedenzen wie beispielsweise ""Punktrechnung vor Strichrechnung"".
Bei mehrstelligen Nachrichten mit Schlüsselwörtern werden alle Schlüsselwörter eines Ausdrucks als zu einer Nachricht gehörig interpretiert, es sei denn, es werden Klammern gesetzt.",<answer> In SMALLTALK werden mehrstellige Nachrichten mit Schlüsselwörtern normalerweise als zu einer einzelnen Nachricht gehörig interpretiert. <answer> <question> Wie werden mehrstellige Nachrichten mit Schlüsselwörtern in SMALLTALK normalerweise interpretiert? <question>
"Zuweisungsausdrücke wurden bereits in Abschnitt 1.6 eingeführt. Sie setzen sich aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite zusammen. Wie bereits erwähnt, bewirken Zuweisungen als einzige Ausdrücke den Zustandswechsel von Objekten. Da eine Zuweisung selbst ein Ausdruck ist, kann sie auch auf der rechten Seite einer anderen Zuweisung erscheinen.","<answer> Zuweisungsausdrücke bestehen aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite. Sie bewirken den Zustandswechsel von Objekten und sind die einzigen Ausdrücke, die dies tun. <answer> <question> Was sind Zuweisungsausdrücke? <question>"
"Zuweisungsausdrücke wurden bereits in Abschnitt 1.6 eingeführt. Sie setzen sich aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite zusammen. Wie bereits erwähnt, bewirken Zuweisungen als einzige Ausdrücke den Zustandswechsel von Objekten. Da eine Zuweisung selbst ein Ausdruck ist, kann sie auch auf der rechten Seite einer anderen Zuweisung erscheinen.","<answer> Zuweisungsausdrücke ändern den Zustand von Objekten, indem sie neue Werte in Variablen zuweisen. <answer> <question> Welche Auswirkung haben Zuweisungsausdrücke auf Objekte? <question>"
"Zuweisungsausdrücke wurden bereits in Abschnitt 1.6 eingeführt. Sie setzen sich aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite zusammen. Wie bereits erwähnt, bewirken Zuweisungen als einzige Ausdrücke den Zustandswechsel von Objekten. Da eine Zuweisung selbst ein Ausdruck ist, kann sie auch auf der rechten Seite einer anderen Zuweisung erscheinen.","<answer> Ja, Zuweisungsausdrücke können selbst Ausdrücke sein und daher auch auf der rechten Seite einer anderen Zuweisung erscheinen. <answer> <question> Können Zuweisungsausdrücke auch auf der rechten Seite einer anderen Zuweisung erscheinen? <question>"
"Die öffentliche Schnittstelle einer Klasse in JAVA ist die Menge ihrer Instanzvariablen und -methoden (in JAVA zusammen auch Member genannt), die public deklariert sind. Nun gibt es in JAVA die Möglichkeit, eine öffentliche Schnittstelle als eigenständiges Konstrukt zu deklarieren, das von dem der Klasse unabhängig ist, das aber genauso wie eine Klasse einen Typ definiert. Es geschieht dies mit Hilfe des Schlüsselwortes ""interface"":
Anders als bei Klassen entspricht hier das Fehlen eines Zugriffsmodifikators der Zugreifbarkeit ""public"" — alles andere scheint für eine Schnittstelle auch unsinnig. Folgende weitere syntaktischen Unterschiede der Interfacedeklaration in den Zeilen 1029–1032 zur Klassendefinition der Zeilen 986–991 fallen auf: die Verwendung des Schlüsselwortes ""interface"" anstelle von ""class"" (klar), das Fehlen von Felddeklarationen und der Umstand, dass der Methodendeklaration keine Implementierung mehr folgt, sondern lediglich das abschließende Semikolon.
Das Schlüsselwort ""abstract"", das eine Klasse für eine solche Methodendeklaration anführen müsste, wird in Interfaces automatisch angenommen; Interfaces liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begründung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen Deklaration und Implementierung (Definition; s. Kapitel 19 in Kurseinheit 3) unterschieden werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch für eine Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes), wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter und Setter) ersetzt werden kann.
Eine Klasse kann nun angeben, dass sie ein Interface implementiert. Sie tut das unter Verwendung des Schlüsselwortes ""implements"". Damit verpflichtet sich die Klasse, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten. Dabei kann eine Klasse mehrere Interfaces gleichzeitig implementieren (die entsprechenden Namen werden einfach, durch Kommata getrennt, überlassen; in diesem Fall muss die Methode aber zumindest als abstrakt deklariert werden. Interface - aneinandergehängt); zugleich ist die Angabe der implementierten Interfaces eine nominale Typkonformitätsdeklaration, d. h., Instanzen der Klasse sind mit allen Variablen jedes der genannten Interfaces zuweisungskompatibel.
Es definieren also die Interfaces von JAVA genau wie Klassen Typen und können daher genauso wie Klassen in Variablendeklarationen verwendet werden. Der Type checker garantiert dann, dass auf der Variable mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ. Eine genauere Betrachtung der Bedeutung der Verwendung von Interfaces erfolgt in Kapitel 45.
Es kann also eine Klasse in JAVA zwar nur direkte Subklasse genau einer anderen Klasse sein, dafür aber mehrere Interfaces gleichzeitig implementieren. Diese mögliche „Mehrfachimplementierung“ von Interfaces wurde häufig als Ersatz für die in JAVA fehlende Möglichkeit der Mehrfachvererbung angepriesen — das aber war Unsinn, denn bei der Implementierung eines Interfaces wurde nichts vererbt (sieht man mal von der sog. Interfacevererbung ab, die aber auch keine wirkliche Vererbung ist, denn auch die Deklarationen werden nicht automatisch von einem Interface auf seine implementierenden Klassen übertragen, sondern müssen dort wiederholt werden). Vielmehr hat man es mit einer Art Mehrfach - Subtyping zu tun, das aber auch ganz nett ist, wie die Überlegungen in Kapitel 45 zeigen werden.","<answer> Ein Interface in JAVA ist eine eigenständige Schnittstellendeklaration, die von einer Klasse unabhängig ist, aber genauso wie eine Klasse einen Typ definiert. Interfaces werden mit dem Schlüsselwort ""interface"" deklariert. <answer> <question> Was ist ein Interface in JAVA und wie wird es deklariert? <question>"
"Die öffentliche Schnittstelle einer Klasse in JAVA ist die Menge ihrer Instanzvariablen und -methoden (in JAVA zusammen auch Member genannt), die public deklariert sind. Nun gibt es in JAVA die Möglichkeit, eine öffentliche Schnittstelle als eigenständiges Konstrukt zu deklarieren, das von dem der Klasse unabhängig ist, das aber genauso wie eine Klasse einen Typ definiert. Es geschieht dies mit Hilfe des Schlüsselwortes ""interface"":
Anders als bei Klassen entspricht hier das Fehlen eines Zugriffsmodifikators der Zugreifbarkeit ""public"" — alles andere scheint für eine Schnittstelle auch unsinnig. Folgende weitere syntaktischen Unterschiede der Interfacedeklaration in den Zeilen 1029–1032 zur Klassendefinition der Zeilen 986–991 fallen auf: die Verwendung des Schlüsselwortes ""interface"" anstelle von ""class"" (klar), das Fehlen von Felddeklarationen und der Umstand, dass der Methodendeklaration keine Implementierung mehr folgt, sondern lediglich das abschließende Semikolon.
Das Schlüsselwort ""abstract"", das eine Klasse für eine solche Methodendeklaration anführen müsste, wird in Interfaces automatisch angenommen; Interfaces liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begründung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen Deklaration und Implementierung (Definition; s. Kapitel 19 in Kurseinheit 3) unterschieden werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch für eine Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes), wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter und Setter) ersetzt werden kann.
Eine Klasse kann nun angeben, dass sie ein Interface implementiert. Sie tut das unter Verwendung des Schlüsselwortes ""implements"". Damit verpflichtet sich die Klasse, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten. Dabei kann eine Klasse mehrere Interfaces gleichzeitig implementieren (die entsprechenden Namen werden einfach, durch Kommata getrennt, überlassen; in diesem Fall muss die Methode aber zumindest als abstrakt deklariert werden. Interface - aneinandergehängt); zugleich ist die Angabe der implementierten Interfaces eine nominale Typkonformitätsdeklaration, d. h., Instanzen der Klasse sind mit allen Variablen jedes der genannten Interfaces zuweisungskompatibel.
Es definieren also die Interfaces von JAVA genau wie Klassen Typen und können daher genauso wie Klassen in Variablendeklarationen verwendet werden. Der Type checker garantiert dann, dass auf der Variable mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ. Eine genauere Betrachtung der Bedeutung der Verwendung von Interfaces erfolgt in Kapitel 45.
Es kann also eine Klasse in JAVA zwar nur direkte Subklasse genau einer anderen Klasse sein, dafür aber mehrere Interfaces gleichzeitig implementieren. Diese mögliche „Mehrfachimplementierung“ von Interfaces wurde häufig als Ersatz für die in JAVA fehlende Möglichkeit der Mehrfachvererbung angepriesen — das aber war Unsinn, denn bei der Implementierung eines Interfaces wurde nichts vererbt (sieht man mal von der sog. Interfacevererbung ab, die aber auch keine wirkliche Vererbung ist, denn auch die Deklarationen werden nicht automatisch von einem Interface auf seine implementierenden Klassen übertragen, sondern müssen dort wiederholt werden). Vielmehr hat man es mit einer Art Mehrfach - Subtyping zu tun, das aber auch ganz nett ist, wie die Überlegungen in Kapitel 45 zeigen werden.","<answer> Die Unterschiede zwischen der Deklaration eines Interfaces und einer Klasse sind: Verwendung des Schlüsselworts ""interface"" anstelle von ""class"". Fehlen von Felddeklarationen in Interfaces. In Interfaces folgt auf die Methodendeklaration lediglich ein abschließendes Semikolon, ohne Implementierung. <answer> <question> Welche Unterschiede gibt es zwischen der Deklaration eines Interfaces und einer Klasse? <question>"
"Die öffentliche Schnittstelle einer Klasse in JAVA ist die Menge ihrer Instanzvariablen und -methoden (in JAVA zusammen auch Member genannt), die public deklariert sind. Nun gibt es in JAVA die Möglichkeit, eine öffentliche Schnittstelle als eigenständiges Konstrukt zu deklarieren, das von dem der Klasse unabhängig ist, das aber genauso wie eine Klasse einen Typ definiert. Es geschieht dies mit Hilfe des Schlüsselwortes ""interface"":
Anders als bei Klassen entspricht hier das Fehlen eines Zugriffsmodifikators der Zugreifbarkeit ""public"" — alles andere scheint für eine Schnittstelle auch unsinnig. Folgende weitere syntaktischen Unterschiede der Interfacedeklaration in den Zeilen 1029–1032 zur Klassendefinition der Zeilen 986–991 fallen auf: die Verwendung des Schlüsselwortes ""interface"" anstelle von ""class"" (klar), das Fehlen von Felddeklarationen und der Umstand, dass der Methodendeklaration keine Implementierung mehr folgt, sondern lediglich das abschließende Semikolon.
Das Schlüsselwort ""abstract"", das eine Klasse für eine solche Methodendeklaration anführen müsste, wird in Interfaces automatisch angenommen; Interfaces liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begründung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen Deklaration und Implementierung (Definition; s. Kapitel 19 in Kurseinheit 3) unterschieden werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch für eine Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes), wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter und Setter) ersetzt werden kann.
Eine Klasse kann nun angeben, dass sie ein Interface implementiert. Sie tut das unter Verwendung des Schlüsselwortes ""implements"". Damit verpflichtet sich die Klasse, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten. Dabei kann eine Klasse mehrere Interfaces gleichzeitig implementieren (die entsprechenden Namen werden einfach, durch Kommata getrennt, überlassen; in diesem Fall muss die Methode aber zumindest als abstrakt deklariert werden. Interface - aneinandergehängt); zugleich ist die Angabe der implementierten Interfaces eine nominale Typkonformitätsdeklaration, d. h., Instanzen der Klasse sind mit allen Variablen jedes der genannten Interfaces zuweisungskompatibel.
Es definieren also die Interfaces von JAVA genau wie Klassen Typen und können daher genauso wie Klassen in Variablendeklarationen verwendet werden. Der Type checker garantiert dann, dass auf der Variable mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ. Eine genauere Betrachtung der Bedeutung der Verwendung von Interfaces erfolgt in Kapitel 45.
Es kann also eine Klasse in JAVA zwar nur direkte Subklasse genau einer anderen Klasse sein, dafür aber mehrere Interfaces gleichzeitig implementieren. Diese mögliche „Mehrfachimplementierung“ von Interfaces wurde häufig als Ersatz für die in JAVA fehlende Möglichkeit der Mehrfachvererbung angepriesen — das aber war Unsinn, denn bei der Implementierung eines Interfaces wurde nichts vererbt (sieht man mal von der sog. Interfacevererbung ab, die aber auch keine wirkliche Vererbung ist, denn auch die Deklarationen werden nicht automatisch von einem Interface auf seine implementierenden Klassen übertragen, sondern müssen dort wiederholt werden). Vielmehr hat man es mit einer Art Mehrfach - Subtyping zu tun, das aber auch ganz nett ist, wie die Überlegungen in Kapitel 45 zeigen werden.","<answer> Das Schlüsselwort ""abstract"" wird in Interfaces automatisch angenommen, da Interfaces zunächst weder Implementierungen noch Objekte liefern. Sie dienen der Definition von Schnittstellen und Typen. <answer> <question> Warum wird das Schlüsselwort ""abstract"" in Interfaces automatisch angenommen? <question>"
"Die öffentliche Schnittstelle einer Klasse in JAVA ist die Menge ihrer Instanzvariablen und -methoden (in JAVA zusammen auch Member genannt), die public deklariert sind. Nun gibt es in JAVA die Möglichkeit, eine öffentliche Schnittstelle als eigenständiges Konstrukt zu deklarieren, das von dem der Klasse unabhängig ist, das aber genauso wie eine Klasse einen Typ definiert. Es geschieht dies mit Hilfe des Schlüsselwortes ""interface"":
Anders als bei Klassen entspricht hier das Fehlen eines Zugriffsmodifikators der Zugreifbarkeit ""public"" — alles andere scheint für eine Schnittstelle auch unsinnig. Folgende weitere syntaktischen Unterschiede der Interfacedeklaration in den Zeilen 1029–1032 zur Klassendefinition der Zeilen 986–991 fallen auf: die Verwendung des Schlüsselwortes ""interface"" anstelle von ""class"" (klar), das Fehlen von Felddeklarationen und der Umstand, dass der Methodendeklaration keine Implementierung mehr folgt, sondern lediglich das abschließende Semikolon.
Das Schlüsselwort ""abstract"", das eine Klasse für eine solche Methodendeklaration anführen müsste, wird in Interfaces automatisch angenommen; Interfaces liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begründung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen Deklaration und Implementierung (Definition; s. Kapitel 19 in Kurseinheit 3) unterschieden werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch für eine Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes), wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter und Setter) ersetzt werden kann.
Eine Klasse kann nun angeben, dass sie ein Interface implementiert. Sie tut das unter Verwendung des Schlüsselwortes ""implements"". Damit verpflichtet sich die Klasse, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten. Dabei kann eine Klasse mehrere Interfaces gleichzeitig implementieren (die entsprechenden Namen werden einfach, durch Kommata getrennt, überlassen; in diesem Fall muss die Methode aber zumindest als abstrakt deklariert werden. Interface - aneinandergehängt); zugleich ist die Angabe der implementierten Interfaces eine nominale Typkonformitätsdeklaration, d. h., Instanzen der Klasse sind mit allen Variablen jedes der genannten Interfaces zuweisungskompatibel.
Es definieren also die Interfaces von JAVA genau wie Klassen Typen und können daher genauso wie Klassen in Variablendeklarationen verwendet werden. Der Type checker garantiert dann, dass auf der Variable mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ. Eine genauere Betrachtung der Bedeutung der Verwendung von Interfaces erfolgt in Kapitel 45.
Es kann also eine Klasse in JAVA zwar nur direkte Subklasse genau einer anderen Klasse sein, dafür aber mehrere Interfaces gleichzeitig implementieren. Diese mögliche „Mehrfachimplementierung“ von Interfaces wurde häufig als Ersatz für die in JAVA fehlende Möglichkeit der Mehrfachvererbung angepriesen — das aber war Unsinn, denn bei der Implementierung eines Interfaces wurde nichts vererbt (sieht man mal von der sog. Interfacevererbung ab, die aber auch keine wirkliche Vererbung ist, denn auch die Deklarationen werden nicht automatisch von einem Interface auf seine implementierenden Klassen übertragen, sondern müssen dort wiederholt werden). Vielmehr hat man es mit einer Art Mehrfach - Subtyping zu tun, das aber auch ganz nett ist, wie die Überlegungen in Kapitel 45 zeigen werden.","<answer> Eine Klasse gibt an, dass sie ein Interface implementiert, indem sie das Schlüsselwort ""implements"" verwendet, gefolgt vom Namen des Interfaces. Die Klasse verpflichtet sich, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten. <answer> <question> Wie gibt eine Klasse an, dass sie ein Interface implementiert, und welche Verpflichtung ergibt sich daraus? <question>"
"Die öffentliche Schnittstelle einer Klasse in JAVA ist die Menge ihrer Instanzvariablen und -methoden (in JAVA zusammen auch Member genannt), die public deklariert sind. Nun gibt es in JAVA die Möglichkeit, eine öffentliche Schnittstelle als eigenständiges Konstrukt zu deklarieren, das von dem der Klasse unabhängig ist, das aber genauso wie eine Klasse einen Typ definiert. Es geschieht dies mit Hilfe des Schlüsselwortes ""interface"":
Anders als bei Klassen entspricht hier das Fehlen eines Zugriffsmodifikators der Zugreifbarkeit ""public"" — alles andere scheint für eine Schnittstelle auch unsinnig. Folgende weitere syntaktischen Unterschiede der Interfacedeklaration in den Zeilen 1029–1032 zur Klassendefinition der Zeilen 986–991 fallen auf: die Verwendung des Schlüsselwortes ""interface"" anstelle von ""class"" (klar), das Fehlen von Felddeklarationen und der Umstand, dass der Methodendeklaration keine Implementierung mehr folgt, sondern lediglich das abschließende Semikolon.
Das Schlüsselwort ""abstract"", das eine Klasse für eine solche Methodendeklaration anführen müsste, wird in Interfaces automatisch angenommen; Interfaces liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begründung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen Deklaration und Implementierung (Definition; s. Kapitel 19 in Kurseinheit 3) unterschieden werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch für eine Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes), wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter und Setter) ersetzt werden kann.
Eine Klasse kann nun angeben, dass sie ein Interface implementiert. Sie tut das unter Verwendung des Schlüsselwortes ""implements"". Damit verpflichtet sich die Klasse, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten. Dabei kann eine Klasse mehrere Interfaces gleichzeitig implementieren (die entsprechenden Namen werden einfach, durch Kommata getrennt, überlassen; in diesem Fall muss die Methode aber zumindest als abstrakt deklariert werden. Interface - aneinandergehängt); zugleich ist die Angabe der implementierten Interfaces eine nominale Typkonformitätsdeklaration, d. h., Instanzen der Klasse sind mit allen Variablen jedes der genannten Interfaces zuweisungskompatibel.
Es definieren also die Interfaces von JAVA genau wie Klassen Typen und können daher genauso wie Klassen in Variablendeklarationen verwendet werden. Der Type checker garantiert dann, dass auf der Variable mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ. Eine genauere Betrachtung der Bedeutung der Verwendung von Interfaces erfolgt in Kapitel 45.
Es kann also eine Klasse in JAVA zwar nur direkte Subklasse genau einer anderen Klasse sein, dafür aber mehrere Interfaces gleichzeitig implementieren. Diese mögliche „Mehrfachimplementierung“ von Interfaces wurde häufig als Ersatz für die in JAVA fehlende Möglichkeit der Mehrfachvererbung angepriesen — das aber war Unsinn, denn bei der Implementierung eines Interfaces wurde nichts vererbt (sieht man mal von der sog. Interfacevererbung ab, die aber auch keine wirkliche Vererbung ist, denn auch die Deklarationen werden nicht automatisch von einem Interface auf seine implementierenden Klassen übertragen, sondern müssen dort wiederholt werden). Vielmehr hat man es mit einer Art Mehrfach - Subtyping zu tun, das aber auch ganz nett ist, wie die Überlegungen in Kapitel 45 zeigen werden.","<answer> Ja, eine Klasse kann mehrere Interfaces gleichzeitig implementieren, indem die entsprechenden Interface-Namen durch Kommata getrennt angegeben werden. In diesem Fall müssen die Methoden in der Klasse zumindest als abstrakt deklariert werden. <answer> <question> Kann eine Klasse mehrere Interfaces gleichzeitig implementieren? <question>"
"Die öffentliche Schnittstelle einer Klasse in JAVA ist die Menge ihrer Instanzvariablen und -methoden (in JAVA zusammen auch Member genannt), die public deklariert sind. Nun gibt es in JAVA die Möglichkeit, eine öffentliche Schnittstelle als eigenständiges Konstrukt zu deklarieren, das von dem der Klasse unabhängig ist, das aber genauso wie eine Klasse einen Typ definiert. Es geschieht dies mit Hilfe des Schlüsselwortes ""interface"":
Anders als bei Klassen entspricht hier das Fehlen eines Zugriffsmodifikators der Zugreifbarkeit ""public"" — alles andere scheint für eine Schnittstelle auch unsinnig. Folgende weitere syntaktischen Unterschiede der Interfacedeklaration in den Zeilen 1029–1032 zur Klassendefinition der Zeilen 986–991 fallen auf: die Verwendung des Schlüsselwortes ""interface"" anstelle von ""class"" (klar), das Fehlen von Felddeklarationen und der Umstand, dass der Methodendeklaration keine Implementierung mehr folgt, sondern lediglich das abschließende Semikolon.
Das Schlüsselwort ""abstract"", das eine Klasse für eine solche Methodendeklaration anführen müsste, wird in Interfaces automatisch angenommen; Interfaces liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begründung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen Deklaration und Implementierung (Definition; s. Kapitel 19 in Kurseinheit 3) unterschieden werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch für eine Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes), wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter und Setter) ersetzt werden kann.
Eine Klasse kann nun angeben, dass sie ein Interface implementiert. Sie tut das unter Verwendung des Schlüsselwortes ""implements"". Damit verpflichtet sich die Klasse, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten. Dabei kann eine Klasse mehrere Interfaces gleichzeitig implementieren (die entsprechenden Namen werden einfach, durch Kommata getrennt, überlassen; in diesem Fall muss die Methode aber zumindest als abstrakt deklariert werden. Interface - aneinandergehängt); zugleich ist die Angabe der implementierten Interfaces eine nominale Typkonformitätsdeklaration, d. h., Instanzen der Klasse sind mit allen Variablen jedes der genannten Interfaces zuweisungskompatibel.
Es definieren also die Interfaces von JAVA genau wie Klassen Typen und können daher genauso wie Klassen in Variablendeklarationen verwendet werden. Der Type checker garantiert dann, dass auf der Variable mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ. Eine genauere Betrachtung der Bedeutung der Verwendung von Interfaces erfolgt in Kapitel 45.
Es kann also eine Klasse in JAVA zwar nur direkte Subklasse genau einer anderen Klasse sein, dafür aber mehrere Interfaces gleichzeitig implementieren. Diese mögliche „Mehrfachimplementierung“ von Interfaces wurde häufig als Ersatz für die in JAVA fehlende Möglichkeit der Mehrfachvererbung angepriesen — das aber war Unsinn, denn bei der Implementierung eines Interfaces wurde nichts vererbt (sieht man mal von der sog. Interfacevererbung ab, die aber auch keine wirkliche Vererbung ist, denn auch die Deklarationen werden nicht automatisch von einem Interface auf seine implementierenden Klassen übertragen, sondern müssen dort wiederholt werden). Vielmehr hat man es mit einer Art Mehrfach - Subtyping zu tun, das aber auch ganz nett ist, wie die Überlegungen in Kapitel 45 zeigen werden.","<answer> Interfaces können in Variablendeklarationen als Typen verwendet werden. Der Type Checker garantiert dann, dass auf der Variable nur die Methoden aufgerufen werden können, die im Interface deklariert sind, selbst wenn das Objekt, das die Variable referenziert, mehr Methoden anbietet. <answer> <question> Wie können Interfaces in Variablendeklarationen verwendet werden? <question>"
"Die öffentliche Schnittstelle einer Klasse in JAVA ist die Menge ihrer Instanzvariablen und -methoden (in JAVA zusammen auch Member genannt), die public deklariert sind. Nun gibt es in JAVA die Möglichkeit, eine öffentliche Schnittstelle als eigenständiges Konstrukt zu deklarieren, das von dem der Klasse unabhängig ist, das aber genauso wie eine Klasse einen Typ definiert. Es geschieht dies mit Hilfe des Schlüsselwortes ""interface"":
Anders als bei Klassen entspricht hier das Fehlen eines Zugriffsmodifikators der Zugreifbarkeit ""public"" — alles andere scheint für eine Schnittstelle auch unsinnig. Folgende weitere syntaktischen Unterschiede der Interfacedeklaration in den Zeilen 1029–1032 zur Klassendefinition der Zeilen 986–991 fallen auf: die Verwendung des Schlüsselwortes ""interface"" anstelle von ""class"" (klar), das Fehlen von Felddeklarationen und der Umstand, dass der Methodendeklaration keine Implementierung mehr folgt, sondern lediglich das abschließende Semikolon.
Das Schlüsselwort ""abstract"", das eine Klasse für eine solche Methodendeklaration anführen müsste, wird in Interfaces automatisch angenommen; Interfaces liefern zunächst erwartungsgemäß weder Implementierungen noch Objekte (Instanzen). Mit derselben Begründung kann auch das Fehlen von Feldern erklärt werden: Da bei Feldern nicht zwischen Deklaration und Implementierung (Definition; s. Kapitel 19 in Kurseinheit 3) unterschieden werden kann (die Deklaration ist, da sie Namen und Typ vorgibt und mehr auch für eine Implementierung nicht angegeben werden kann, zugleich Implementierung des Feldes), wurden sie aus den Interfaces verbannt. Diese Einschränkung ist aber keine wirkliche, da ein Feldzugriff in einem Interface durch Zugriffsmethoden (Accessoren, also durch Getter und Setter) ersetzt werden kann.
Eine Klasse kann nun angeben, dass sie ein Interface implementiert. Sie tut das unter Verwendung des Schlüsselwortes ""implements"". Damit verpflichtet sich die Klasse, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten. Dabei kann eine Klasse mehrere Interfaces gleichzeitig implementieren (die entsprechenden Namen werden einfach, durch Kommata getrennt, überlassen; in diesem Fall muss die Methode aber zumindest als abstrakt deklariert werden. Interface - aneinandergehängt); zugleich ist die Angabe der implementierten Interfaces eine nominale Typkonformitätsdeklaration, d. h., Instanzen der Klasse sind mit allen Variablen jedes der genannten Interfaces zuweisungskompatibel.
Es definieren also die Interfaces von JAVA genau wie Klassen Typen und können daher genauso wie Klassen in Variablendeklarationen verwendet werden. Der Type checker garantiert dann, dass auf der Variable mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ. Eine genauere Betrachtung der Bedeutung der Verwendung von Interfaces erfolgt in Kapitel 45.
Es kann also eine Klasse in JAVA zwar nur direkte Subklasse genau einer anderen Klasse sein, dafür aber mehrere Interfaces gleichzeitig implementieren. Diese mögliche „Mehrfachimplementierung“ von Interfaces wurde häufig als Ersatz für die in JAVA fehlende Möglichkeit der Mehrfachvererbung angepriesen — das aber war Unsinn, denn bei der Implementierung eines Interfaces wurde nichts vererbt (sieht man mal von der sog. Interfacevererbung ab, die aber auch keine wirkliche Vererbung ist, denn auch die Deklarationen werden nicht automatisch von einem Interface auf seine implementierenden Klassen übertragen, sondern müssen dort wiederholt werden). Vielmehr hat man es mit einer Art Mehrfach - Subtyping zu tun, das aber auch ganz nett ist, wie die Überlegungen in Kapitel 45 zeigen werden.","<answer> Die Verwendung von Interfaces ermöglicht es, Methoden und Felder einer Instanz vor anderen Instanzen zu verbergen. Durch die Deklaration von Variablen mit dem Interface als Typ kann der Zugriff auf bestimmte Methoden und Felder beschränkt werden. <answer> <question> Welchen Vorteil bietet die Verwendung von Interfaces bei der Verwendung von Variablen? <question>"
"Wie bereits in Abschnitt 10.3 erwähnt, wird die Programmiererin, die eine abstrakte, weil unvollständige, Klasse instanziiert, irgendwann damit bestraft, dass das Versenden einer Nachricht an die entsprechende Instanz zu einer Fehlermeldung führt, die ihr (per subclassResponsibility oder implementedBySubclass, die, genau wie doesNotUnderstand:, in der Klasse Object definiert ist) anzeigt, dass die Methode (erst) in einer Subklasse implementiert werden sollte. Dummerweise bekommt die Programmiererin diesen Hinweis erst zur Laufzeit des Programms zu Gesicht, also dann, wenn es schon zu spät ist (es sei denn, man testet gerade). Man erkennt hieran sehr schön den interaktiven Geist des SMALLTALK-Systems, insbesondere die Philosophie, nach der Programmieren nichts weiter ist als das iterative Zurechtbiegen und Erweitern eines bereits bestehenden, funktionierenden Systems. Man muss eine Weile damit gespielt haben, um diesem Charme zu erliegen.
Wenn man sich erst einmal damit abgefunden hat, dass man als Programmiererin Methoden schreibt, die ausschließlich dem Zweck dienen, sich selbst oder eine Kollegin auf Programmierfehler hinzuweisen, dann erscheint einem eine weitere SMALLTALK-Konvention geradezu als elegant, nämlich die, geerbte Methoden durch Überschreiben auszulöschen. Tatsächlich ist genau hierfür eine weitere Methode in der Klasse Object mit dem Namen „shouldNotImplement“ vorgesehen, die zu einer entsprechenden Fehlermeldung führt. Eine Klasse, die also eine geerbte Methode löschen möchte, überschreibt diese einfach mit shouldNotImplement. Bevor Sie jetzt als disziplinierte Programmiererin den Stab über SMALLTALK brechen, erlauben Sie noch den Hinweis, dass der Wunsch, geerbte Methoden zu löschen, eine direkte Folge der vorrangigen Orientierung an Vererbung ist, die bereits oben kritisiert wurde: Wäre die Superklasse auf Grundlage des Prinzips der Generalisierung ausgewählt worden, käme man gar nicht in die Verlegenheit, Methoden löschen zu wollen, denn alles, was für die Generalisierung sinnvoll ist, ist grundsätzlich auch für ihre Spezialisierungen sinnvoll, oder die Generalisierung ist keine Generalisierung. Außerdem haben Sie auch in Sprachen mit starker Typprüfung, in denen das Löschen von Methoden nicht möglich ist, als Programmiererin immer die Freiheit, eine Methode so zu überschreiben, dass sie garantiert nichts tut, was mit der Idee der Klasse, von der sie geerbt ist, in Einklang zu bringen wäre. Auch hier wäre ein Laufzeitfehler die unvermeidbare Folge. Mehr dazu in Kurseinheit 3; hier sei nur so viel bemerkt wie, dass wenn man sich bei der Organisation seiner Klassenhierarchie auf das Prinzip der Generalisierung stützt, man dann auch nicht in die Verlegenheit kommt, Methoden löschen zu wollen.","<answer> In SMALLTALK und ähnlichen objektorientierten Programmiersprachen erhalten Programmierer zur Laufzeit des Programms eine Fehlermeldung, wenn sie eine Nachricht an eine Instanz einer abstrakten Klasse senden, da diese abstrakten Klassen unvollständig sind und daher nicht implementierte Methoden enthalten können. Die Fehlermeldung, die durch die Methode ""doesNotUnderstand:"" (in der Klasse ""Object"") ausgelöst wird, informiert die Programmierer darüber, dass die Methode in einer Subklasse implementiert werden sollte. Dieser Ansatz entspricht dem interaktiven Geist des SMALLTALK-Systems, bei dem das Programmieren als iteratives Zurechtbiegen und Erweitern eines bereits funktionierenden Systems betrachtet wird. <answer> <question> Warum erhalten Programmierer in SMALLTALK erst zur Laufzeit des Programms eine Fehlermeldung, wenn sie eine Nachricht an eine Instanz einer abstrakten Klasse senden? <question>"
"Wie bereits in Abschnitt 10.3 erwähnt, wird die Programmiererin, die eine abstrakte, weil unvollständige, Klasse instanziiert, irgendwann damit bestraft, dass das Versenden einer Nachricht an die entsprechende Instanz zu einer Fehlermeldung führt, die ihr (per subclassResponsibility oder implementedBySubclass, die, genau wie doesNotUnderstand:, in der Klasse Object definiert ist) anzeigt, dass die Methode (erst) in einer Subklasse implementiert werden sollte. Dummerweise bekommt die Programmiererin diesen Hinweis erst zur Laufzeit des Programms zu Gesicht, also dann, wenn es schon zu spät ist (es sei denn, man testet gerade). Man erkennt hieran sehr schön den interaktiven Geist des SMALLTALK-Systems, insbesondere die Philosophie, nach der Programmieren nichts weiter ist als das iterative Zurechtbiegen und Erweitern eines bereits bestehenden, funktionierenden Systems. Man muss eine Weile damit gespielt haben, um diesem Charme zu erliegen.
Wenn man sich erst einmal damit abgefunden hat, dass man als Programmiererin Methoden schreibt, die ausschließlich dem Zweck dienen, sich selbst oder eine Kollegin auf Programmierfehler hinzuweisen, dann erscheint einem eine weitere SMALLTALK-Konvention geradezu als elegant, nämlich die, geerbte Methoden durch Überschreiben auszulöschen. Tatsächlich ist genau hierfür eine weitere Methode in der Klasse Object mit dem Namen „shouldNotImplement“ vorgesehen, die zu einer entsprechenden Fehlermeldung führt. Eine Klasse, die also eine geerbte Methode löschen möchte, überschreibt diese einfach mit shouldNotImplement. Bevor Sie jetzt als disziplinierte Programmiererin den Stab über SMALLTALK brechen, erlauben Sie noch den Hinweis, dass der Wunsch, geerbte Methoden zu löschen, eine direkte Folge der vorrangigen Orientierung an Vererbung ist, die bereits oben kritisiert wurde: Wäre die Superklasse auf Grundlage des Prinzips der Generalisierung ausgewählt worden, käme man gar nicht in die Verlegenheit, Methoden löschen zu wollen, denn alles, was für die Generalisierung sinnvoll ist, ist grundsätzlich auch für ihre Spezialisierungen sinnvoll, oder die Generalisierung ist keine Generalisierung. Außerdem haben Sie auch in Sprachen mit starker Typprüfung, in denen das Löschen von Methoden nicht möglich ist, als Programmiererin immer die Freiheit, eine Methode so zu überschreiben, dass sie garantiert nichts tut, was mit der Idee der Klasse, von der sie geerbt ist, in Einklang zu bringen wäre. Auch hier wäre ein Laufzeitfehler die unvermeidbare Folge. Mehr dazu in Kurseinheit 3; hier sei nur so viel bemerkt wie, dass wenn man sich bei der Organisation seiner Klassenhierarchie auf das Prinzip der Generalisierung stützt, man dann auch nicht in die Verlegenheit kommt, Methoden löschen zu wollen.","<answer> In SMALLTALK können Programmierer geerbte Methoden löschen, indem sie die Methode ""shouldNotImplement"" in der Subklasse implementieren und die geerbte Methode überschreiben. Wenn eine Klasse also eine geerbte Methode löschen möchte, überschreibt sie diese Methode einfach mit ""shouldNotImplement"". Diese Konvention ermöglicht es Programmierern, geerbte Methoden elegant auszulöschen, sollte dies erforderlich sein. Es ist jedoch wichtig zu beachten, dass der Wunsch, geerbte Methoden zu löschen, eine direkte Folge der Orientierung an Vererbung ist, die in dieser Textpassage kritisiert wird. Wenn die Superklasse auf Grundlage des Prinzips der Generalisierung ausgewählt wurde, besteht normalerweise keine Notwendigkeit, geerbte Methoden zu löschen, da alles, was für die Generalisierung sinnvoll ist, auch für ihre Spezialisierungen sinnvoll ist. Dieses Prinzip wird in späteren Kurseinheiten weiter erläutert. <answer> <question> Wie können Programmierer in SMALLTALK geerbte Methoden löschen? <question>"
"Die Einführung von Typäquivalenz und Typkonformität bezog sich bislang lediglich auf das Verhältnis der Typdefinitionen, also der Intensionen der Typen. Die Frage des Zusammenhangs der Wertebereiche der Typen, also der Extensionen, ist dabei unberücksichtigt geblieben. Wenn aber die obige Definition von Typkorrektheit weiter Bestand haben soll, dann müssen die Werte zuweisungskompatibler Typen zum Wertebereich des Typen, an den zugewiesen werden soll, gehören. Zur Erinnerung: Typannotationen stellen Invarianten dar, die die möglichen Werte einer Variable beschränken. Diese Invarianten dürfen durch Zuweisungen nicht verletzt werden. Wenn man aber nun Zuweisungen von einem anderen Typen zulässt, dann wird die Typkorrektheit nur dann nicht verletzt, wenn der Wertebereich des anderen Typen (seine Extension) in dem desjenigen, dem zugewiesen wird, enthalten (inkludiert) ist. Mit anderen Worten: Damit eine Zuweisung a := b, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein. Im Fall der Typerweiterung ist dies nicht automatisch der Fall.
Auch nicht selbstverständlich ist die Teilmengenbeziehung bei der Typeinschränkung: Durch das Weglassen von Eigenschaften (Methoden) wird die Extension, also die Menge der Werte (Objekte), die darunter fallen, eher größer denn kleiner — je weniger spezifisch die Menge der geforderten Eigenschaften ist, desto mehr Objekte fallen darunter. Die sich daraus ergebende Teilmengebeziehung wäre also eher umgekehrt (die Extension des einschränkenden Typs enthält die des eingeschränkten). Etwas anders sieht es aus, wenn durch Typeinschränkung (Redefinition) die Ein- oder Rückgabetypen von Methoden beschränkt werden: Die Menge der Zeichnungen ist eine Teilmenge der Menge der Dokumente, auch weil sich Zeichnungen eben nur auf Plottern ausgeben lassen. Die Zuweisungskompatibilität von Zeichnung mit Dokument wäre also, was die Inklusion der Extensionen angeht, kein Problem. Man könnte nun die Typerweiterung unter oben gemachter Einschränkung und die zweite Form der Typeinschränkung als in dieselbe Richtung zielende Maßnahmen ansehen: Beide schränken Extensionen ein. Das lässt sich wie folgt erklären: Wenn man einer Menge von Objekten, die durch eine Anzahl Attribute alle gleichermaßen charakterisiert werden, weitere Attribute beimisst, dann schränkt man diese Menge ein, wenn die hinzugefügten Attribute nicht alle Objekte der Menge charakterisieren. Wenn man beispielsweise wie oben geschehen die Attributmenge des Typs Dokument um die Methode zeilen ^ <Collection> erweitert, dann fallen die Zeichnungen aus der durch Dokument beschriebenen Menge von Objekten heraus, weil sie keine Zeilen haben. Alternativ könnte man auch sagen, dass Dokumente grundsätzlich über Zeilen verfügen können, diese aber bei Zeichnungen immer in der Anzahl erscheint das weniger natürlich. 51 Man beachte die Parallelität zum Begriff der Spezialisierung (Abschnitt 9.2 in Kurseinheit 2): Der durch Typerweiterung oder -einschränkung aus Dokument hervorgegangene Typ Zeichnung ist spezieller als seine Vorlage. Nun ergibt sich aber gemäß obigem Beispiel (Zeilen 900–902) ein Sachverhalt, der trotz aller Harmonie von Typerweiterung und -einschränkung nicht weniger als den Verlust der Zuweisungskompatibilität bedeutet. Dieser resultiert jedoch bei genauerer Betrachtung nicht daraus, dass Zeichnungen keine Dokumente wären, sondern aus der mit der Typkorrektheit verbundenen, impliziten Allquantifiziertheit von Typinvarianten: Eine Methodendeklaration im Protokoll eines Typs Dokument wird nämlich interpretiert als „druckenAuf: ist definiert für alle Empfängerobjekte vom Typ Dokument und Parameterobjekte vom Typ Drucker“, was aber in dieser Allgemeinheit sachlich falsch ist. Typsysteme mit Typinvarianten der hier vorgestellten Art sind nicht in der Lage, andere als implizit allquantifizierte Aussagen über Wertebereiche zu treffen. Dies ist gewissermaßen der Preis der Einfachheit. Abhilfe schaffen neuere Typsysteme wie die Idee von den Dependent types, wie sie beispielsweise in SCALA zum Einsatz kommen: Hier kann man sich die Parametertypen von Methoden als Funktionen des Typs, zu dem die Methode gehört, vorstellen. Der Parametertyp von druckenAuf: aus obigem Beispiel wäre dann, in Abhängigkeit davon, ob die Methode auf einem Objekt vom Typ Dokument oder Zeichnung aufgerufen wird, Drucker oder Plotter. Wie man sich leicht vorstellen kann, ist die statische Prüfung solcher Bedingungen (Invarianz) aber nicht so einfach. Die Vereinigung von Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität und der daraus folgenden Typkorrektheit bietet der Begriff des Subtyps.","<answer> Damit Typkorrektheit erhalten bleibt, müssen die Wertebereiche von Typen in Bezug auf Zuweisungen miteinander in Beziehung stehen. Wenn ein Objekt eines Typs einem Objekt eines anderen Typs zugewiesen werden soll, muss die Extension des zweiten Typs eine Teilmenge der Extension des ersten Typs sein. <answer> <question> Wie ist die Beziehung zwischen Typäquivalenz und Typkonformität auf der einen Seite und den Wertebereichen (Extensionen) von Typen auf der anderen Seite? <question>"
"Die Einführung von Typäquivalenz und Typkonformität bezog sich bislang lediglich auf das Verhältnis der Typdefinitionen, also der Intensionen der Typen. Die Frage des Zusammenhangs der Wertebereiche der Typen, also der Extensionen, ist dabei unberücksichtigt geblieben. Wenn aber die obige Definition von Typkorrektheit weiter Bestand haben soll, dann müssen die Werte zuweisungskompatibler Typen zum Wertebereich des Typen, an den zugewiesen werden soll, gehören. Zur Erinnerung: Typannotationen stellen Invarianten dar, die die möglichen Werte einer Variable beschränken. Diese Invarianten dürfen durch Zuweisungen nicht verletzt werden. Wenn man aber nun Zuweisungen von einem anderen Typen zulässt, dann wird die Typkorrektheit nur dann nicht verletzt, wenn der Wertebereich des anderen Typen (seine Extension) in dem desjenigen, dem zugewiesen wird, enthalten (inkludiert) ist. Mit anderen Worten: Damit eine Zuweisung a := b, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein. Im Fall der Typerweiterung ist dies nicht automatisch der Fall.
Auch nicht selbstverständlich ist die Teilmengenbeziehung bei der Typeinschränkung: Durch das Weglassen von Eigenschaften (Methoden) wird die Extension, also die Menge der Werte (Objekte), die darunter fallen, eher größer denn kleiner — je weniger spezifisch die Menge der geforderten Eigenschaften ist, desto mehr Objekte fallen darunter. Die sich daraus ergebende Teilmengebeziehung wäre also eher umgekehrt (die Extension des einschränkenden Typs enthält die des eingeschränkten). Etwas anders sieht es aus, wenn durch Typeinschränkung (Redefinition) die Ein- oder Rückgabetypen von Methoden beschränkt werden: Die Menge der Zeichnungen ist eine Teilmenge der Menge der Dokumente, auch weil sich Zeichnungen eben nur auf Plottern ausgeben lassen. Die Zuweisungskompatibilität von Zeichnung mit Dokument wäre also, was die Inklusion der Extensionen angeht, kein Problem. Man könnte nun die Typerweiterung unter oben gemachter Einschränkung und die zweite Form der Typeinschränkung als in dieselbe Richtung zielende Maßnahmen ansehen: Beide schränken Extensionen ein. Das lässt sich wie folgt erklären: Wenn man einer Menge von Objekten, die durch eine Anzahl Attribute alle gleichermaßen charakterisiert werden, weitere Attribute beimisst, dann schränkt man diese Menge ein, wenn die hinzugefügten Attribute nicht alle Objekte der Menge charakterisieren. Wenn man beispielsweise wie oben geschehen die Attributmenge des Typs Dokument um die Methode zeilen ^ <Collection> erweitert, dann fallen die Zeichnungen aus der durch Dokument beschriebenen Menge von Objekten heraus, weil sie keine Zeilen haben. Alternativ könnte man auch sagen, dass Dokumente grundsätzlich über Zeilen verfügen können, diese aber bei Zeichnungen immer in der Anzahl erscheint das weniger natürlich. 51 Man beachte die Parallelität zum Begriff der Spezialisierung (Abschnitt 9.2 in Kurseinheit 2): Der durch Typerweiterung oder -einschränkung aus Dokument hervorgegangene Typ Zeichnung ist spezieller als seine Vorlage. Nun ergibt sich aber gemäß obigem Beispiel (Zeilen 900–902) ein Sachverhalt, der trotz aller Harmonie von Typerweiterung und -einschränkung nicht weniger als den Verlust der Zuweisungskompatibilität bedeutet. Dieser resultiert jedoch bei genauerer Betrachtung nicht daraus, dass Zeichnungen keine Dokumente wären, sondern aus der mit der Typkorrektheit verbundenen, impliziten Allquantifiziertheit von Typinvarianten: Eine Methodendeklaration im Protokoll eines Typs Dokument wird nämlich interpretiert als „druckenAuf: ist definiert für alle Empfängerobjekte vom Typ Dokument und Parameterobjekte vom Typ Drucker“, was aber in dieser Allgemeinheit sachlich falsch ist. Typsysteme mit Typinvarianten der hier vorgestellten Art sind nicht in der Lage, andere als implizit allquantifizierte Aussagen über Wertebereiche zu treffen. Dies ist gewissermaßen der Preis der Einfachheit. Abhilfe schaffen neuere Typsysteme wie die Idee von den Dependent types, wie sie beispielsweise in SCALA zum Einsatz kommen: Hier kann man sich die Parametertypen von Methoden als Funktionen des Typs, zu dem die Methode gehört, vorstellen. Der Parametertyp von druckenAuf: aus obigem Beispiel wäre dann, in Abhängigkeit davon, ob die Methode auf einem Objekt vom Typ Dokument oder Zeichnung aufgerufen wird, Drucker oder Plotter. Wie man sich leicht vorstellen kann, ist die statische Prüfung solcher Bedingungen (Invarianz) aber nicht so einfach. Die Vereinigung von Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität und der daraus folgenden Typkorrektheit bietet der Begriff des Subtyps.","<answer> Wenn die Extension eines Typs in der Extension eines anderen Typs enthalten ist, bedeutet dies, dass Objekte des ersten Typs an Stellen verwendet werden können, an denen Objekte des zweiten Typs erwartet werden, ohne die Typkorrektheit zu verletzen. <answer> <question> Was bedeutet es, wenn die Extension eines Typs in der Extension eines anderen Typs enthalten ist? <question>"
"Die Einführung von Typäquivalenz und Typkonformität bezog sich bislang lediglich auf das Verhältnis der Typdefinitionen, also der Intensionen der Typen. Die Frage des Zusammenhangs der Wertebereiche der Typen, also der Extensionen, ist dabei unberücksichtigt geblieben. Wenn aber die obige Definition von Typkorrektheit weiter Bestand haben soll, dann müssen die Werte zuweisungskompatibler Typen zum Wertebereich des Typen, an den zugewiesen werden soll, gehören. Zur Erinnerung: Typannotationen stellen Invarianten dar, die die möglichen Werte einer Variable beschränken. Diese Invarianten dürfen durch Zuweisungen nicht verletzt werden. Wenn man aber nun Zuweisungen von einem anderen Typen zulässt, dann wird die Typkorrektheit nur dann nicht verletzt, wenn der Wertebereich des anderen Typen (seine Extension) in dem desjenigen, dem zugewiesen wird, enthalten (inkludiert) ist. Mit anderen Worten: Damit eine Zuweisung a := b, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein. Im Fall der Typerweiterung ist dies nicht automatisch der Fall.
Auch nicht selbstverständlich ist die Teilmengenbeziehung bei der Typeinschränkung: Durch das Weglassen von Eigenschaften (Methoden) wird die Extension, also die Menge der Werte (Objekte), die darunter fallen, eher größer denn kleiner — je weniger spezifisch die Menge der geforderten Eigenschaften ist, desto mehr Objekte fallen darunter. Die sich daraus ergebende Teilmengebeziehung wäre also eher umgekehrt (die Extension des einschränkenden Typs enthält die des eingeschränkten). Etwas anders sieht es aus, wenn durch Typeinschränkung (Redefinition) die Ein- oder Rückgabetypen von Methoden beschränkt werden: Die Menge der Zeichnungen ist eine Teilmenge der Menge der Dokumente, auch weil sich Zeichnungen eben nur auf Plottern ausgeben lassen. Die Zuweisungskompatibilität von Zeichnung mit Dokument wäre also, was die Inklusion der Extensionen angeht, kein Problem. Man könnte nun die Typerweiterung unter oben gemachter Einschränkung und die zweite Form der Typeinschränkung als in dieselbe Richtung zielende Maßnahmen ansehen: Beide schränken Extensionen ein. Das lässt sich wie folgt erklären: Wenn man einer Menge von Objekten, die durch eine Anzahl Attribute alle gleichermaßen charakterisiert werden, weitere Attribute beimisst, dann schränkt man diese Menge ein, wenn die hinzugefügten Attribute nicht alle Objekte der Menge charakterisieren. Wenn man beispielsweise wie oben geschehen die Attributmenge des Typs Dokument um die Methode zeilen ^ <Collection> erweitert, dann fallen die Zeichnungen aus der durch Dokument beschriebenen Menge von Objekten heraus, weil sie keine Zeilen haben. Alternativ könnte man auch sagen, dass Dokumente grundsätzlich über Zeilen verfügen können, diese aber bei Zeichnungen immer in der Anzahl erscheint das weniger natürlich. 51 Man beachte die Parallelität zum Begriff der Spezialisierung (Abschnitt 9.2 in Kurseinheit 2): Der durch Typerweiterung oder -einschränkung aus Dokument hervorgegangene Typ Zeichnung ist spezieller als seine Vorlage. Nun ergibt sich aber gemäß obigem Beispiel (Zeilen 900–902) ein Sachverhalt, der trotz aller Harmonie von Typerweiterung und -einschränkung nicht weniger als den Verlust der Zuweisungskompatibilität bedeutet. Dieser resultiert jedoch bei genauerer Betrachtung nicht daraus, dass Zeichnungen keine Dokumente wären, sondern aus der mit der Typkorrektheit verbundenen, impliziten Allquantifiziertheit von Typinvarianten: Eine Methodendeklaration im Protokoll eines Typs Dokument wird nämlich interpretiert als „druckenAuf: ist definiert für alle Empfängerobjekte vom Typ Dokument und Parameterobjekte vom Typ Drucker“, was aber in dieser Allgemeinheit sachlich falsch ist. Typsysteme mit Typinvarianten der hier vorgestellten Art sind nicht in der Lage, andere als implizit allquantifizierte Aussagen über Wertebereiche zu treffen. Dies ist gewissermaßen der Preis der Einfachheit. Abhilfe schaffen neuere Typsysteme wie die Idee von den Dependent types, wie sie beispielsweise in SCALA zum Einsatz kommen: Hier kann man sich die Parametertypen von Methoden als Funktionen des Typs, zu dem die Methode gehört, vorstellen. Der Parametertyp von druckenAuf: aus obigem Beispiel wäre dann, in Abhängigkeit davon, ob die Methode auf einem Objekt vom Typ Dokument oder Zeichnung aufgerufen wird, Drucker oder Plotter. Wie man sich leicht vorstellen kann, ist die statische Prüfung solcher Bedingungen (Invarianz) aber nicht so einfach. Die Vereinigung von Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität und der daraus folgenden Typkorrektheit bietet der Begriff des Subtyps.","<answer> Bei der Typeinschränkung, bei der Eigenschaften (Methoden) entfernt werden, kann die Extension des eingeschränkten Typs tatsächlich größer werden, da weniger spezifische Anforderungen gestellt werden. Dies kann zu einer scheinbaren Umkehrung der Teilmengenbeziehung führen. <answer> <question> Warum ist die Teilmengenbeziehung bei der Typeinschränkung nicht immer offensichtlich? <question>"
"Die Einführung von Typäquivalenz und Typkonformität bezog sich bislang lediglich auf das Verhältnis der Typdefinitionen, also der Intensionen der Typen. Die Frage des Zusammenhangs der Wertebereiche der Typen, also der Extensionen, ist dabei unberücksichtigt geblieben. Wenn aber die obige Definition von Typkorrektheit weiter Bestand haben soll, dann müssen die Werte zuweisungskompatibler Typen zum Wertebereich des Typen, an den zugewiesen werden soll, gehören. Zur Erinnerung: Typannotationen stellen Invarianten dar, die die möglichen Werte einer Variable beschränken. Diese Invarianten dürfen durch Zuweisungen nicht verletzt werden. Wenn man aber nun Zuweisungen von einem anderen Typen zulässt, dann wird die Typkorrektheit nur dann nicht verletzt, wenn der Wertebereich des anderen Typen (seine Extension) in dem desjenigen, dem zugewiesen wird, enthalten (inkludiert) ist. Mit anderen Worten: Damit eine Zuweisung a := b, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein. Im Fall der Typerweiterung ist dies nicht automatisch der Fall.
Auch nicht selbstverständlich ist die Teilmengenbeziehung bei der Typeinschränkung: Durch das Weglassen von Eigenschaften (Methoden) wird die Extension, also die Menge der Werte (Objekte), die darunter fallen, eher größer denn kleiner — je weniger spezifisch die Menge der geforderten Eigenschaften ist, desto mehr Objekte fallen darunter. Die sich daraus ergebende Teilmengebeziehung wäre also eher umgekehrt (die Extension des einschränkenden Typs enthält die des eingeschränkten). Etwas anders sieht es aus, wenn durch Typeinschränkung (Redefinition) die Ein- oder Rückgabetypen von Methoden beschränkt werden: Die Menge der Zeichnungen ist eine Teilmenge der Menge der Dokumente, auch weil sich Zeichnungen eben nur auf Plottern ausgeben lassen. Die Zuweisungskompatibilität von Zeichnung mit Dokument wäre also, was die Inklusion der Extensionen angeht, kein Problem. Man könnte nun die Typerweiterung unter oben gemachter Einschränkung und die zweite Form der Typeinschränkung als in dieselbe Richtung zielende Maßnahmen ansehen: Beide schränken Extensionen ein. Das lässt sich wie folgt erklären: Wenn man einer Menge von Objekten, die durch eine Anzahl Attribute alle gleichermaßen charakterisiert werden, weitere Attribute beimisst, dann schränkt man diese Menge ein, wenn die hinzugefügten Attribute nicht alle Objekte der Menge charakterisieren. Wenn man beispielsweise wie oben geschehen die Attributmenge des Typs Dokument um die Methode zeilen ^ <Collection> erweitert, dann fallen die Zeichnungen aus der durch Dokument beschriebenen Menge von Objekten heraus, weil sie keine Zeilen haben. Alternativ könnte man auch sagen, dass Dokumente grundsätzlich über Zeilen verfügen können, diese aber bei Zeichnungen immer in der Anzahl erscheint das weniger natürlich. 51 Man beachte die Parallelität zum Begriff der Spezialisierung (Abschnitt 9.2 in Kurseinheit 2): Der durch Typerweiterung oder -einschränkung aus Dokument hervorgegangene Typ Zeichnung ist spezieller als seine Vorlage. Nun ergibt sich aber gemäß obigem Beispiel (Zeilen 900–902) ein Sachverhalt, der trotz aller Harmonie von Typerweiterung und -einschränkung nicht weniger als den Verlust der Zuweisungskompatibilität bedeutet. Dieser resultiert jedoch bei genauerer Betrachtung nicht daraus, dass Zeichnungen keine Dokumente wären, sondern aus der mit der Typkorrektheit verbundenen, impliziten Allquantifiziertheit von Typinvarianten: Eine Methodendeklaration im Protokoll eines Typs Dokument wird nämlich interpretiert als „druckenAuf: ist definiert für alle Empfängerobjekte vom Typ Dokument und Parameterobjekte vom Typ Drucker“, was aber in dieser Allgemeinheit sachlich falsch ist. Typsysteme mit Typinvarianten der hier vorgestellten Art sind nicht in der Lage, andere als implizit allquantifizierte Aussagen über Wertebereiche zu treffen. Dies ist gewissermaßen der Preis der Einfachheit. Abhilfe schaffen neuere Typsysteme wie die Idee von den Dependent types, wie sie beispielsweise in SCALA zum Einsatz kommen: Hier kann man sich die Parametertypen von Methoden als Funktionen des Typs, zu dem die Methode gehört, vorstellen. Der Parametertyp von druckenAuf: aus obigem Beispiel wäre dann, in Abhängigkeit davon, ob die Methode auf einem Objekt vom Typ Dokument oder Zeichnung aufgerufen wird, Drucker oder Plotter. Wie man sich leicht vorstellen kann, ist die statische Prüfung solcher Bedingungen (Invarianz) aber nicht so einfach. Die Vereinigung von Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität und der daraus folgenden Typkorrektheit bietet der Begriff des Subtyps.","<answer> Die Einschränkung von Ein- oder Rückgabetypen von Methoden kann die Zuweisungskompatibilität beeinflussen, indem sie sicherstellt, dass die Extension des eingeschränkten Typs eine Teilmenge der Extension des einschränkenden Typs ist. Dies kann dazu beitragen, die Typkorrektheit von Zuweisungen zu gewährleisten. <answer> <question> Wie kann die Einschränkung von Ein- oder Rückgabetypen von Methoden die Zuweisungskompatibilität beeinflussen? <question>"
"Die Einführung von Typäquivalenz und Typkonformität bezog sich bislang lediglich auf das Verhältnis der Typdefinitionen, also der Intensionen der Typen. Die Frage des Zusammenhangs der Wertebereiche der Typen, also der Extensionen, ist dabei unberücksichtigt geblieben. Wenn aber die obige Definition von Typkorrektheit weiter Bestand haben soll, dann müssen die Werte zuweisungskompatibler Typen zum Wertebereich des Typen, an den zugewiesen werden soll, gehören. Zur Erinnerung: Typannotationen stellen Invarianten dar, die die möglichen Werte einer Variable beschränken. Diese Invarianten dürfen durch Zuweisungen nicht verletzt werden. Wenn man aber nun Zuweisungen von einem anderen Typen zulässt, dann wird die Typkorrektheit nur dann nicht verletzt, wenn der Wertebereich des anderen Typen (seine Extension) in dem desjenigen, dem zugewiesen wird, enthalten (inkludiert) ist. Mit anderen Worten: Damit eine Zuweisung a := b, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein. Im Fall der Typerweiterung ist dies nicht automatisch der Fall.
Auch nicht selbstverständlich ist die Teilmengenbeziehung bei der Typeinschränkung: Durch das Weglassen von Eigenschaften (Methoden) wird die Extension, also die Menge der Werte (Objekte), die darunter fallen, eher größer denn kleiner — je weniger spezifisch die Menge der geforderten Eigenschaften ist, desto mehr Objekte fallen darunter. Die sich daraus ergebende Teilmengebeziehung wäre also eher umgekehrt (die Extension des einschränkenden Typs enthält die des eingeschränkten). Etwas anders sieht es aus, wenn durch Typeinschränkung (Redefinition) die Ein- oder Rückgabetypen von Methoden beschränkt werden: Die Menge der Zeichnungen ist eine Teilmenge der Menge der Dokumente, auch weil sich Zeichnungen eben nur auf Plottern ausgeben lassen. Die Zuweisungskompatibilität von Zeichnung mit Dokument wäre also, was die Inklusion der Extensionen angeht, kein Problem. Man könnte nun die Typerweiterung unter oben gemachter Einschränkung und die zweite Form der Typeinschränkung als in dieselbe Richtung zielende Maßnahmen ansehen: Beide schränken Extensionen ein. Das lässt sich wie folgt erklären: Wenn man einer Menge von Objekten, die durch eine Anzahl Attribute alle gleichermaßen charakterisiert werden, weitere Attribute beimisst, dann schränkt man diese Menge ein, wenn die hinzugefügten Attribute nicht alle Objekte der Menge charakterisieren. Wenn man beispielsweise wie oben geschehen die Attributmenge des Typs Dokument um die Methode zeilen ^ <Collection> erweitert, dann fallen die Zeichnungen aus der durch Dokument beschriebenen Menge von Objekten heraus, weil sie keine Zeilen haben. Alternativ könnte man auch sagen, dass Dokumente grundsätzlich über Zeilen verfügen können, diese aber bei Zeichnungen immer in der Anzahl erscheint das weniger natürlich. 51 Man beachte die Parallelität zum Begriff der Spezialisierung (Abschnitt 9.2 in Kurseinheit 2): Der durch Typerweiterung oder -einschränkung aus Dokument hervorgegangene Typ Zeichnung ist spezieller als seine Vorlage. Nun ergibt sich aber gemäß obigem Beispiel (Zeilen 900–902) ein Sachverhalt, der trotz aller Harmonie von Typerweiterung und -einschränkung nicht weniger als den Verlust der Zuweisungskompatibilität bedeutet. Dieser resultiert jedoch bei genauerer Betrachtung nicht daraus, dass Zeichnungen keine Dokumente wären, sondern aus der mit der Typkorrektheit verbundenen, impliziten Allquantifiziertheit von Typinvarianten: Eine Methodendeklaration im Protokoll eines Typs Dokument wird nämlich interpretiert als „druckenAuf: ist definiert für alle Empfängerobjekte vom Typ Dokument und Parameterobjekte vom Typ Drucker“, was aber in dieser Allgemeinheit sachlich falsch ist. Typsysteme mit Typinvarianten der hier vorgestellten Art sind nicht in der Lage, andere als implizit allquantifizierte Aussagen über Wertebereiche zu treffen. Dies ist gewissermaßen der Preis der Einfachheit. Abhilfe schaffen neuere Typsysteme wie die Idee von den Dependent types, wie sie beispielsweise in SCALA zum Einsatz kommen: Hier kann man sich die Parametertypen von Methoden als Funktionen des Typs, zu dem die Methode gehört, vorstellen. Der Parametertyp von druckenAuf: aus obigem Beispiel wäre dann, in Abhängigkeit davon, ob die Methode auf einem Objekt vom Typ Dokument oder Zeichnung aufgerufen wird, Drucker oder Plotter. Wie man sich leicht vorstellen kann, ist die statische Prüfung solcher Bedingungen (Invarianz) aber nicht so einfach. Die Vereinigung von Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität und der daraus folgenden Typkorrektheit bietet der Begriff des Subtyps.","<answer> Der Verlust der Zuweisungskompatibilität kann aus der impliziten Allquantifiziertheit von Typinvarianten resultieren. Typsysteme mit solchen Invarianten sind nicht in der Lage, Aussagen über Wertebereiche zu treffen, die nicht implizit allquantifiziert sind. <answer> <question> Warum kann es trotz der Harmonie von Typerweiterung und -einschränkung zu einem Verlust der Zuweisungskompatibilität kommen? <question>"
"Die Einführung von Typäquivalenz und Typkonformität bezog sich bislang lediglich auf das Verhältnis der Typdefinitionen, also der Intensionen der Typen. Die Frage des Zusammenhangs der Wertebereiche der Typen, also der Extensionen, ist dabei unberücksichtigt geblieben. Wenn aber die obige Definition von Typkorrektheit weiter Bestand haben soll, dann müssen die Werte zuweisungskompatibler Typen zum Wertebereich des Typen, an den zugewiesen werden soll, gehören. Zur Erinnerung: Typannotationen stellen Invarianten dar, die die möglichen Werte einer Variable beschränken. Diese Invarianten dürfen durch Zuweisungen nicht verletzt werden. Wenn man aber nun Zuweisungen von einem anderen Typen zulässt, dann wird die Typkorrektheit nur dann nicht verletzt, wenn der Wertebereich des anderen Typen (seine Extension) in dem desjenigen, dem zugewiesen wird, enthalten (inkludiert) ist. Mit anderen Worten: Damit eine Zuweisung a := b, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein. Im Fall der Typerweiterung ist dies nicht automatisch der Fall.
Auch nicht selbstverständlich ist die Teilmengenbeziehung bei der Typeinschränkung: Durch das Weglassen von Eigenschaften (Methoden) wird die Extension, also die Menge der Werte (Objekte), die darunter fallen, eher größer denn kleiner — je weniger spezifisch die Menge der geforderten Eigenschaften ist, desto mehr Objekte fallen darunter. Die sich daraus ergebende Teilmengebeziehung wäre also eher umgekehrt (die Extension des einschränkenden Typs enthält die des eingeschränkten). Etwas anders sieht es aus, wenn durch Typeinschränkung (Redefinition) die Ein- oder Rückgabetypen von Methoden beschränkt werden: Die Menge der Zeichnungen ist eine Teilmenge der Menge der Dokumente, auch weil sich Zeichnungen eben nur auf Plottern ausgeben lassen. Die Zuweisungskompatibilität von Zeichnung mit Dokument wäre also, was die Inklusion der Extensionen angeht, kein Problem. Man könnte nun die Typerweiterung unter oben gemachter Einschränkung und die zweite Form der Typeinschränkung als in dieselbe Richtung zielende Maßnahmen ansehen: Beide schränken Extensionen ein. Das lässt sich wie folgt erklären: Wenn man einer Menge von Objekten, die durch eine Anzahl Attribute alle gleichermaßen charakterisiert werden, weitere Attribute beimisst, dann schränkt man diese Menge ein, wenn die hinzugefügten Attribute nicht alle Objekte der Menge charakterisieren. Wenn man beispielsweise wie oben geschehen die Attributmenge des Typs Dokument um die Methode zeilen ^ <Collection> erweitert, dann fallen die Zeichnungen aus der durch Dokument beschriebenen Menge von Objekten heraus, weil sie keine Zeilen haben. Alternativ könnte man auch sagen, dass Dokumente grundsätzlich über Zeilen verfügen können, diese aber bei Zeichnungen immer in der Anzahl erscheint das weniger natürlich. 51 Man beachte die Parallelität zum Begriff der Spezialisierung (Abschnitt 9.2 in Kurseinheit 2): Der durch Typerweiterung oder -einschränkung aus Dokument hervorgegangene Typ Zeichnung ist spezieller als seine Vorlage. Nun ergibt sich aber gemäß obigem Beispiel (Zeilen 900–902) ein Sachverhalt, der trotz aller Harmonie von Typerweiterung und -einschränkung nicht weniger als den Verlust der Zuweisungskompatibilität bedeutet. Dieser resultiert jedoch bei genauerer Betrachtung nicht daraus, dass Zeichnungen keine Dokumente wären, sondern aus der mit der Typkorrektheit verbundenen, impliziten Allquantifiziertheit von Typinvarianten: Eine Methodendeklaration im Protokoll eines Typs Dokument wird nämlich interpretiert als „druckenAuf: ist definiert für alle Empfängerobjekte vom Typ Dokument und Parameterobjekte vom Typ Drucker“, was aber in dieser Allgemeinheit sachlich falsch ist. Typsysteme mit Typinvarianten der hier vorgestellten Art sind nicht in der Lage, andere als implizit allquantifizierte Aussagen über Wertebereiche zu treffen. Dies ist gewissermaßen der Preis der Einfachheit. Abhilfe schaffen neuere Typsysteme wie die Idee von den Dependent types, wie sie beispielsweise in SCALA zum Einsatz kommen: Hier kann man sich die Parametertypen von Methoden als Funktionen des Typs, zu dem die Methode gehört, vorstellen. Der Parametertyp von druckenAuf: aus obigem Beispiel wäre dann, in Abhängigkeit davon, ob die Methode auf einem Objekt vom Typ Dokument oder Zeichnung aufgerufen wird, Drucker oder Plotter. Wie man sich leicht vorstellen kann, ist die statische Prüfung solcher Bedingungen (Invarianz) aber nicht so einfach. Die Vereinigung von Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität und der daraus folgenden Typkorrektheit bietet der Begriff des Subtyps.","<answer> Der Begriff des Subtyps bietet eine Möglichkeit, Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität und Typkorrektheit zu vereinen. Ein Subtyp ist ein Typ, dessen Extension eine Teilmenge der Extension seines Supertyps ist, was sicherstellt, dass Objekte des Subtyps an Stellen verwendet werden können, an denen Objekte des Supertyps erwartet werden. <answer> <question> Was bietet der Begriff des Subtyps als Lösung für diese Probleme? <question>"
"Wie auch in JAVA definiert jede unparametrisierte Klasse in EIFFEL einen Typ, und jede parametrisierte Klasse eine (generische) Menge von Typen. Alle Variablen (einschließlich Methoden und deren Parameter) müssen einen Typ haben. Die Zuweisungskompatibilität ist an nominale Typkonformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung genannt) einhergeht, ganz wie in JAVA. Anders als in JAVA ist es jedoch zulässig, Instanzvariablen und Funktionsparameter wie im obigen Beispiel kovariant zu redefinieren. Von kontravarianter Redefinition will MEYER nichts wissen (eine Begründung sollten Sie mittlerweile selbst zur Verfügung haben). Das bedeutet jedoch mangelnde Substituierbarkeit und bereitet EIFFEL erwartungsgemäß einige nicht triviale Probleme.
Zunächst einmal wollen wir uns das Typsystem von EIFFEL noch genauer ansehen. Es basiert, wie in der objektorientierten Programmierung üblich, auf dem Begriff der Typkonformität (Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ U typkonform zu einem Typ T: Wenn U und T gleich sind, Wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder Wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist (U ist eine indirekte Erweiterung von T).
Außerdem gibt es in EIFFEL noch einen Typkonstruktor like <ein Ausdruck>, dessen erzeugter Typ typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der Basistyp konform, keiner seiner Subtypen.
EIFFEL benutzt also eckige Klammern und -> anstelle von spitzen Klammern und extends in JAVA.
In EIFFEL wird übrigens anders als in C# nicht pro Typkonstruktor zwischen Wert- und Referenztypen unterschieden. Zu jedem Typ kann es (ähnlich wie in C++) beide Formen geben. Dazu gibt es in EIFFEL die Möglichkeit, bei einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik, also ein Objekt anstelle einer Referenz auf ein Objekt zum Inhalt haben sollen. Dies ist manchmal für alle Variablen eines Typs sinnvoll, z. B. bei Zahlen und Wahrheitswerten, manchmal aber auch nur für manche. So gibt es in EIFFEL einen Typkonstruktor expanded, der einer einzelnen Variable Wertsemantik gibt und in Klassendefinitionen allen Variablen des entsprechenden Typs automatisch Wertsemantik gibt. EIFFELs Typkonstruktor expanded entspricht also gewissermaßen einer Umkehrung des in PASCAL-artigen Sprachen verwendeten Typkonstruktors ^ (Zeiger auf). Die Unterscheidung von Wert- und Referenztypen einer Klasse hat in EIFFEL einen starken konzeptuellen Hintergrund, da sie die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen (vgl. dazu auch Kapitel 59 in Kurseinheit 6).
Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer Typkonstruktoren für entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) zu haben. Dieses Feature ist nicht in C# (zumindest nicht im Safe mode) verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen. In C++ (und im Unsafe mode von C#) kann man es simulieren, zahlt jedoch den Preis, mit expliziten Pointern umgehen zu müssen.
Nun stand bereits in Kurseinheit 1, Abschnitt 1.6 zu lesen, dass bei der Zuweisung zwischen zwei Variablen mit Wertsemantik der Wert der einen Variable in die andere Variable kopiert wird, während bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik lediglich der Zeiger kopiert wird. Dies ist auch in EIFFEL so. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte. Stattdessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert). Im umgekehrten Fall, also wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt, und eine Referenz auf diesen Klon wird übergeben.
Eine solche Verankerung bewirkt, dass sich der Typ von x automatisch mit dem von y verändert. Dies hat zunächst noch nichts mit Kovarianz zu tun.
Da die Typen der Parameter von setF und getF alle per Deklaration dieselben sind wie der Typ von f, muss in der Definition von B textuell nichts anderes stehen. Da nun aber in EIFFEL die Redefinition von Instanzvariablen per Definition immer kovariant sein muss, muss Y ein Subtyp von X sein. Der Rückgabetyp von getF und der Parametertyp von setF ändern sich damit automatisch ebenfalls kovariant.
Ein besonderer Fall von verankerten Typen ergibt sich bei rekursiven Typen, also Typen, deren Definition den definierten Typ selbst referenziert.
In diesem Fall schreibt man in EIFFEL anstelle der Typreferenz bei der Deklaration einer Variable vom zu definierenden Typ like Current. Bei einem entsprechend deklarierten Feld ändert sich der Typ bei der Vererbung also immer automatisch zum erbenden Typ hin, also immer mit dem Typ und damit kovariant. Für das Beispiel der zu trennenden Skifahrerinnen (Zeilen 1391–1425) ergibt sich damit. Die beiden erbenden Klassen GIRL und BOY müssen dann nichts mehr redefinieren.
Wir können nun zur Lösung des Problems der Kovarianz in EIFFEL kommen. Die obige Konstruktion (hier unverändert wiederholt) wird dann vom Type checker zur Übersetzungszeit zurückgewiesen, da g1 nicht vom Typ like s1 ist, was aber laut den Typkonformitätsregeln von EIFFEL notwendig wäre. Leider ist das nur ein Teilerfolg.
Die erste und einfachste Möglichkeit, dies zu verhindern, wäre, die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einzuschränken und unter ihnen nur noch Typäquivalenz zu akzeptieren. Es wären dann nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit solchen, die ihn als Anker benutzen, erlaubt. Insbesondere wäre eine Zuweisung wie s1 := g1 (die ja notwendig war, um ein Objekt vom Typ GIRL so zu „verpacken“, dass es an g2 mit seinem verankerten Typ like s1 zugewiesen werden kann) damit nicht mehr möglich. Alle anderen Zuweisungen wären natürlich weiterhin zugelassen. Dies hätte jedoch zur Konsequenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem wäre es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll.
Die zweite Möglichkeit wäre, eine Typinferenz für das gesamte Programm durchzuführen, um die möglichen Zuweisungen an Variablen zu sammeln. Dazu sind insbesondere alle Methodenaufrufe anzusehen. Diese können je nach Konfiguration des endgültigen Systems sehr unterschiedlich ausfallen. Eine solche Typinferenz ist jedoch in den meisten Fällen unrealistisch.
Die dritte Möglichkeit ist die, alle dynamisch gebundenen Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“) ändern (die von MEYER so genannten CAT-Calls, wobei CAT für „Change Availability or Type“ steht), zu verbieten. Ein Aufruf von share auf s1 wie oben ist damit verboten, weil share in BOY und GIRL kovariant redefiniert wird. Auf einer Variable vom Typ GIRL oder BOY wäre er hingegen zulässig, solange sichergestellt ist, dass diese Variable keinen Wert von einem Subtyp von GIRL bzw. BOY zugewiesen bekommen kann. Das ist möglich, wenn kein solcher Subtyp existiert oder wenn keine Zuweisung an die Variable existiert, bei der die rechte Seite ein Subtyp der Variable ist. Das erste ist lokal nicht nachzuweisen, das zweite hingegen schon, jedoch nur für explizite Zuweisungen (inklusive der Instanziierung, die in EIFFEL auf einer Variable durchgeführt wird und ihr automatisch einen Wert gibt). Für die Zuweisung an formale Parameter kann dies jedoch nicht lokal nachgewiesen werden, weil im Gegensatz zu expliziten Zuweisungen an Variablen die Methodenaufrufe von überall her erfolgen können.
Wie Sie sehen, sind die Bedingungen ziemlich restriktiv, und man kommt nicht umhin, das Typsystem von EIFFEL als etwas eigenartig zu empfinden. Wie es sich in der Praxis auswirkt, ist mir leider nicht bekannt; MEYER behauptet, dass die Probleme praktisch keine Rolle spielen. Ich möchte hinzufügen, dass falls doch, die durchschnittliche Programmiererin kaum verstehen wird, was denn nun genau das Problem ist und was sie tun kann, es zu umgehen.","<answer> In EIFFEL definiert jede unparametrisierte Klasse einen Typ, während jede parametrisierte Klasse eine (generische) Menge von Typen definiert. <answer> <question> Wie definiert EIFFEL unparametrisierte und parametrisierte Klassen? <question>"
"Wie auch in JAVA definiert jede unparametrisierte Klasse in EIFFEL einen Typ, und jede parametrisierte Klasse eine (generische) Menge von Typen. Alle Variablen (einschließlich Methoden und deren Parameter) müssen einen Typ haben. Die Zuweisungskompatibilität ist an nominale Typkonformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung genannt) einhergeht, ganz wie in JAVA. Anders als in JAVA ist es jedoch zulässig, Instanzvariablen und Funktionsparameter wie im obigen Beispiel kovariant zu redefinieren. Von kontravarianter Redefinition will MEYER nichts wissen (eine Begründung sollten Sie mittlerweile selbst zur Verfügung haben). Das bedeutet jedoch mangelnde Substituierbarkeit und bereitet EIFFEL erwartungsgemäß einige nicht triviale Probleme.
Zunächst einmal wollen wir uns das Typsystem von EIFFEL noch genauer ansehen. Es basiert, wie in der objektorientierten Programmierung üblich, auf dem Begriff der Typkonformität (Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ U typkonform zu einem Typ T: Wenn U und T gleich sind, Wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder Wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist (U ist eine indirekte Erweiterung von T).
Außerdem gibt es in EIFFEL noch einen Typkonstruktor like <ein Ausdruck>, dessen erzeugter Typ typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der Basistyp konform, keiner seiner Subtypen.
EIFFEL benutzt also eckige Klammern und -> anstelle von spitzen Klammern und extends in JAVA.
In EIFFEL wird übrigens anders als in C# nicht pro Typkonstruktor zwischen Wert- und Referenztypen unterschieden. Zu jedem Typ kann es (ähnlich wie in C++) beide Formen geben. Dazu gibt es in EIFFEL die Möglichkeit, bei einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik, also ein Objekt anstelle einer Referenz auf ein Objekt zum Inhalt haben sollen. Dies ist manchmal für alle Variablen eines Typs sinnvoll, z. B. bei Zahlen und Wahrheitswerten, manchmal aber auch nur für manche. So gibt es in EIFFEL einen Typkonstruktor expanded, der einer einzelnen Variable Wertsemantik gibt und in Klassendefinitionen allen Variablen des entsprechenden Typs automatisch Wertsemantik gibt. EIFFELs Typkonstruktor expanded entspricht also gewissermaßen einer Umkehrung des in PASCAL-artigen Sprachen verwendeten Typkonstruktors ^ (Zeiger auf). Die Unterscheidung von Wert- und Referenztypen einer Klasse hat in EIFFEL einen starken konzeptuellen Hintergrund, da sie die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen (vgl. dazu auch Kapitel 59 in Kurseinheit 6).
Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer Typkonstruktoren für entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) zu haben. Dieses Feature ist nicht in C# (zumindest nicht im Safe mode) verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen. In C++ (und im Unsafe mode von C#) kann man es simulieren, zahlt jedoch den Preis, mit expliziten Pointern umgehen zu müssen.
Nun stand bereits in Kurseinheit 1, Abschnitt 1.6 zu lesen, dass bei der Zuweisung zwischen zwei Variablen mit Wertsemantik der Wert der einen Variable in die andere Variable kopiert wird, während bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik lediglich der Zeiger kopiert wird. Dies ist auch in EIFFEL so. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte. Stattdessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert). Im umgekehrten Fall, also wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt, und eine Referenz auf diesen Klon wird übergeben.
Eine solche Verankerung bewirkt, dass sich der Typ von x automatisch mit dem von y verändert. Dies hat zunächst noch nichts mit Kovarianz zu tun.
Da die Typen der Parameter von setF und getF alle per Deklaration dieselben sind wie der Typ von f, muss in der Definition von B textuell nichts anderes stehen. Da nun aber in EIFFEL die Redefinition von Instanzvariablen per Definition immer kovariant sein muss, muss Y ein Subtyp von X sein. Der Rückgabetyp von getF und der Parametertyp von setF ändern sich damit automatisch ebenfalls kovariant.
Ein besonderer Fall von verankerten Typen ergibt sich bei rekursiven Typen, also Typen, deren Definition den definierten Typ selbst referenziert.
In diesem Fall schreibt man in EIFFEL anstelle der Typreferenz bei der Deklaration einer Variable vom zu definierenden Typ like Current. Bei einem entsprechend deklarierten Feld ändert sich der Typ bei der Vererbung also immer automatisch zum erbenden Typ hin, also immer mit dem Typ und damit kovariant. Für das Beispiel der zu trennenden Skifahrerinnen (Zeilen 1391–1425) ergibt sich damit. Die beiden erbenden Klassen GIRL und BOY müssen dann nichts mehr redefinieren.
Wir können nun zur Lösung des Problems der Kovarianz in EIFFEL kommen. Die obige Konstruktion (hier unverändert wiederholt) wird dann vom Type checker zur Übersetzungszeit zurückgewiesen, da g1 nicht vom Typ like s1 ist, was aber laut den Typkonformitätsregeln von EIFFEL notwendig wäre. Leider ist das nur ein Teilerfolg.
Die erste und einfachste Möglichkeit, dies zu verhindern, wäre, die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einzuschränken und unter ihnen nur noch Typäquivalenz zu akzeptieren. Es wären dann nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit solchen, die ihn als Anker benutzen, erlaubt. Insbesondere wäre eine Zuweisung wie s1 := g1 (die ja notwendig war, um ein Objekt vom Typ GIRL so zu „verpacken“, dass es an g2 mit seinem verankerten Typ like s1 zugewiesen werden kann) damit nicht mehr möglich. Alle anderen Zuweisungen wären natürlich weiterhin zugelassen. Dies hätte jedoch zur Konsequenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem wäre es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll.
Die zweite Möglichkeit wäre, eine Typinferenz für das gesamte Programm durchzuführen, um die möglichen Zuweisungen an Variablen zu sammeln. Dazu sind insbesondere alle Methodenaufrufe anzusehen. Diese können je nach Konfiguration des endgültigen Systems sehr unterschiedlich ausfallen. Eine solche Typinferenz ist jedoch in den meisten Fällen unrealistisch.
Die dritte Möglichkeit ist die, alle dynamisch gebundenen Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“) ändern (die von MEYER so genannten CAT-Calls, wobei CAT für „Change Availability or Type“ steht), zu verbieten. Ein Aufruf von share auf s1 wie oben ist damit verboten, weil share in BOY und GIRL kovariant redefiniert wird. Auf einer Variable vom Typ GIRL oder BOY wäre er hingegen zulässig, solange sichergestellt ist, dass diese Variable keinen Wert von einem Subtyp von GIRL bzw. BOY zugewiesen bekommen kann. Das ist möglich, wenn kein solcher Subtyp existiert oder wenn keine Zuweisung an die Variable existiert, bei der die rechte Seite ein Subtyp der Variable ist. Das erste ist lokal nicht nachzuweisen, das zweite hingegen schon, jedoch nur für explizite Zuweisungen (inklusive der Instanziierung, die in EIFFEL auf einer Variable durchgeführt wird und ihr automatisch einen Wert gibt). Für die Zuweisung an formale Parameter kann dies jedoch nicht lokal nachgewiesen werden, weil im Gegensatz zu expliziten Zuweisungen an Variablen die Methodenaufrufe von überall her erfolgen können.
Wie Sie sehen, sind die Bedingungen ziemlich restriktiv, und man kommt nicht umhin, das Typsystem von EIFFEL als etwas eigenartig zu empfinden. Wie es sich in der Praxis auswirkt, ist mir leider nicht bekannt; MEYER behauptet, dass die Probleme praktisch keine Rolle spielen. Ich möchte hinzufügen, dass falls doch, die durchschnittliche Programmiererin kaum verstehen wird, was denn nun genau das Problem ist und was sie tun kann, es zu umgehen.","<answer> In EIFFEL kann die kovariante Redefinition verwendet werden, um den Typ von Variablen automatisch mit dem Typ eines anderen, bereits typisierten Programms zu verknüpfen. Dies ermöglicht die automatische Anpassung von Typen bei Vererbung. <answer> <question> Welche Rolle spielt die kovariante Redefinition in EIFFEL? <question>"
"Wie auch in JAVA definiert jede unparametrisierte Klasse in EIFFEL einen Typ, und jede parametrisierte Klasse eine (generische) Menge von Typen. Alle Variablen (einschließlich Methoden und deren Parameter) müssen einen Typ haben. Die Zuweisungskompatibilität ist an nominale Typkonformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung genannt) einhergeht, ganz wie in JAVA. Anders als in JAVA ist es jedoch zulässig, Instanzvariablen und Funktionsparameter wie im obigen Beispiel kovariant zu redefinieren. Von kontravarianter Redefinition will MEYER nichts wissen (eine Begründung sollten Sie mittlerweile selbst zur Verfügung haben). Das bedeutet jedoch mangelnde Substituierbarkeit und bereitet EIFFEL erwartungsgemäß einige nicht triviale Probleme.
Zunächst einmal wollen wir uns das Typsystem von EIFFEL noch genauer ansehen. Es basiert, wie in der objektorientierten Programmierung üblich, auf dem Begriff der Typkonformität (Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ U typkonform zu einem Typ T: Wenn U und T gleich sind, Wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder Wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist (U ist eine indirekte Erweiterung von T).
Außerdem gibt es in EIFFEL noch einen Typkonstruktor like <ein Ausdruck>, dessen erzeugter Typ typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der Basistyp konform, keiner seiner Subtypen.
EIFFEL benutzt also eckige Klammern und -> anstelle von spitzen Klammern und extends in JAVA.
In EIFFEL wird übrigens anders als in C# nicht pro Typkonstruktor zwischen Wert- und Referenztypen unterschieden. Zu jedem Typ kann es (ähnlich wie in C++) beide Formen geben. Dazu gibt es in EIFFEL die Möglichkeit, bei einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik, also ein Objekt anstelle einer Referenz auf ein Objekt zum Inhalt haben sollen. Dies ist manchmal für alle Variablen eines Typs sinnvoll, z. B. bei Zahlen und Wahrheitswerten, manchmal aber auch nur für manche. So gibt es in EIFFEL einen Typkonstruktor expanded, der einer einzelnen Variable Wertsemantik gibt und in Klassendefinitionen allen Variablen des entsprechenden Typs automatisch Wertsemantik gibt. EIFFELs Typkonstruktor expanded entspricht also gewissermaßen einer Umkehrung des in PASCAL-artigen Sprachen verwendeten Typkonstruktors ^ (Zeiger auf). Die Unterscheidung von Wert- und Referenztypen einer Klasse hat in EIFFEL einen starken konzeptuellen Hintergrund, da sie die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen (vgl. dazu auch Kapitel 59 in Kurseinheit 6).
Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer Typkonstruktoren für entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) zu haben. Dieses Feature ist nicht in C# (zumindest nicht im Safe mode) verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen. In C++ (und im Unsafe mode von C#) kann man es simulieren, zahlt jedoch den Preis, mit expliziten Pointern umgehen zu müssen.
Nun stand bereits in Kurseinheit 1, Abschnitt 1.6 zu lesen, dass bei der Zuweisung zwischen zwei Variablen mit Wertsemantik der Wert der einen Variable in die andere Variable kopiert wird, während bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik lediglich der Zeiger kopiert wird. Dies ist auch in EIFFEL so. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte. Stattdessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert). Im umgekehrten Fall, also wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt, und eine Referenz auf diesen Klon wird übergeben.
Eine solche Verankerung bewirkt, dass sich der Typ von x automatisch mit dem von y verändert. Dies hat zunächst noch nichts mit Kovarianz zu tun.
Da die Typen der Parameter von setF und getF alle per Deklaration dieselben sind wie der Typ von f, muss in der Definition von B textuell nichts anderes stehen. Da nun aber in EIFFEL die Redefinition von Instanzvariablen per Definition immer kovariant sein muss, muss Y ein Subtyp von X sein. Der Rückgabetyp von getF und der Parametertyp von setF ändern sich damit automatisch ebenfalls kovariant.
Ein besonderer Fall von verankerten Typen ergibt sich bei rekursiven Typen, also Typen, deren Definition den definierten Typ selbst referenziert.
In diesem Fall schreibt man in EIFFEL anstelle der Typreferenz bei der Deklaration einer Variable vom zu definierenden Typ like Current. Bei einem entsprechend deklarierten Feld ändert sich der Typ bei der Vererbung also immer automatisch zum erbenden Typ hin, also immer mit dem Typ und damit kovariant. Für das Beispiel der zu trennenden Skifahrerinnen (Zeilen 1391–1425) ergibt sich damit. Die beiden erbenden Klassen GIRL und BOY müssen dann nichts mehr redefinieren.
Wir können nun zur Lösung des Problems der Kovarianz in EIFFEL kommen. Die obige Konstruktion (hier unverändert wiederholt) wird dann vom Type checker zur Übersetzungszeit zurückgewiesen, da g1 nicht vom Typ like s1 ist, was aber laut den Typkonformitätsregeln von EIFFEL notwendig wäre. Leider ist das nur ein Teilerfolg.
Die erste und einfachste Möglichkeit, dies zu verhindern, wäre, die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einzuschränken und unter ihnen nur noch Typäquivalenz zu akzeptieren. Es wären dann nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit solchen, die ihn als Anker benutzen, erlaubt. Insbesondere wäre eine Zuweisung wie s1 := g1 (die ja notwendig war, um ein Objekt vom Typ GIRL so zu „verpacken“, dass es an g2 mit seinem verankerten Typ like s1 zugewiesen werden kann) damit nicht mehr möglich. Alle anderen Zuweisungen wären natürlich weiterhin zugelassen. Dies hätte jedoch zur Konsequenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem wäre es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll.
Die zweite Möglichkeit wäre, eine Typinferenz für das gesamte Programm durchzuführen, um die möglichen Zuweisungen an Variablen zu sammeln. Dazu sind insbesondere alle Methodenaufrufe anzusehen. Diese können je nach Konfiguration des endgültigen Systems sehr unterschiedlich ausfallen. Eine solche Typinferenz ist jedoch in den meisten Fällen unrealistisch.
Die dritte Möglichkeit ist die, alle dynamisch gebundenen Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“) ändern (die von MEYER so genannten CAT-Calls, wobei CAT für „Change Availability or Type“ steht), zu verbieten. Ein Aufruf von share auf s1 wie oben ist damit verboten, weil share in BOY und GIRL kovariant redefiniert wird. Auf einer Variable vom Typ GIRL oder BOY wäre er hingegen zulässig, solange sichergestellt ist, dass diese Variable keinen Wert von einem Subtyp von GIRL bzw. BOY zugewiesen bekommen kann. Das ist möglich, wenn kein solcher Subtyp existiert oder wenn keine Zuweisung an die Variable existiert, bei der die rechte Seite ein Subtyp der Variable ist. Das erste ist lokal nicht nachzuweisen, das zweite hingegen schon, jedoch nur für explizite Zuweisungen (inklusive der Instanziierung, die in EIFFEL auf einer Variable durchgeführt wird und ihr automatisch einen Wert gibt). Für die Zuweisung an formale Parameter kann dies jedoch nicht lokal nachgewiesen werden, weil im Gegensatz zu expliziten Zuweisungen an Variablen die Methodenaufrufe von überall her erfolgen können.
Wie Sie sehen, sind die Bedingungen ziemlich restriktiv, und man kommt nicht umhin, das Typsystem von EIFFEL als etwas eigenartig zu empfinden. Wie es sich in der Praxis auswirkt, ist mir leider nicht bekannt; MEYER behauptet, dass die Probleme praktisch keine Rolle spielen. Ich möchte hinzufügen, dass falls doch, die durchschnittliche Programmiererin kaum verstehen wird, was denn nun genau das Problem ist und was sie tun kann, es zu umgehen.",<answer> Anders als in C# unterscheidet EIFFEL nicht zwischen Wert- und Referenztypen auf der Ebene von Typkonstruktoren. Stattdessen kann es für jeden Typ sowohl Wertsemantik als auch Referenzsemantik geben. <answer> <question> Was ist der Unterschied zwischen Wert- und Referenztypen in EIFFEL? <question>
"Wie auch in JAVA definiert jede unparametrisierte Klasse in EIFFEL einen Typ, und jede parametrisierte Klasse eine (generische) Menge von Typen. Alle Variablen (einschließlich Methoden und deren Parameter) müssen einen Typ haben. Die Zuweisungskompatibilität ist an nominale Typkonformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung genannt) einhergeht, ganz wie in JAVA. Anders als in JAVA ist es jedoch zulässig, Instanzvariablen und Funktionsparameter wie im obigen Beispiel kovariant zu redefinieren. Von kontravarianter Redefinition will MEYER nichts wissen (eine Begründung sollten Sie mittlerweile selbst zur Verfügung haben). Das bedeutet jedoch mangelnde Substituierbarkeit und bereitet EIFFEL erwartungsgemäß einige nicht triviale Probleme.
Zunächst einmal wollen wir uns das Typsystem von EIFFEL noch genauer ansehen. Es basiert, wie in der objektorientierten Programmierung üblich, auf dem Begriff der Typkonformität (Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ U typkonform zu einem Typ T: Wenn U und T gleich sind, Wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder Wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist (U ist eine indirekte Erweiterung von T).
Außerdem gibt es in EIFFEL noch einen Typkonstruktor like <ein Ausdruck>, dessen erzeugter Typ typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der Basistyp konform, keiner seiner Subtypen.
EIFFEL benutzt also eckige Klammern und -> anstelle von spitzen Klammern und extends in JAVA.
In EIFFEL wird übrigens anders als in C# nicht pro Typkonstruktor zwischen Wert- und Referenztypen unterschieden. Zu jedem Typ kann es (ähnlich wie in C++) beide Formen geben. Dazu gibt es in EIFFEL die Möglichkeit, bei einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik, also ein Objekt anstelle einer Referenz auf ein Objekt zum Inhalt haben sollen. Dies ist manchmal für alle Variablen eines Typs sinnvoll, z. B. bei Zahlen und Wahrheitswerten, manchmal aber auch nur für manche. So gibt es in EIFFEL einen Typkonstruktor expanded, der einer einzelnen Variable Wertsemantik gibt und in Klassendefinitionen allen Variablen des entsprechenden Typs automatisch Wertsemantik gibt. EIFFELs Typkonstruktor expanded entspricht also gewissermaßen einer Umkehrung des in PASCAL-artigen Sprachen verwendeten Typkonstruktors ^ (Zeiger auf). Die Unterscheidung von Wert- und Referenztypen einer Klasse hat in EIFFEL einen starken konzeptuellen Hintergrund, da sie die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen (vgl. dazu auch Kapitel 59 in Kurseinheit 6).
Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer Typkonstruktoren für entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) zu haben. Dieses Feature ist nicht in C# (zumindest nicht im Safe mode) verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen. In C++ (und im Unsafe mode von C#) kann man es simulieren, zahlt jedoch den Preis, mit expliziten Pointern umgehen zu müssen.
Nun stand bereits in Kurseinheit 1, Abschnitt 1.6 zu lesen, dass bei der Zuweisung zwischen zwei Variablen mit Wertsemantik der Wert der einen Variable in die andere Variable kopiert wird, während bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik lediglich der Zeiger kopiert wird. Dies ist auch in EIFFEL so. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte. Stattdessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert). Im umgekehrten Fall, also wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt, und eine Referenz auf diesen Klon wird übergeben.
Eine solche Verankerung bewirkt, dass sich der Typ von x automatisch mit dem von y verändert. Dies hat zunächst noch nichts mit Kovarianz zu tun.
Da die Typen der Parameter von setF und getF alle per Deklaration dieselben sind wie der Typ von f, muss in der Definition von B textuell nichts anderes stehen. Da nun aber in EIFFEL die Redefinition von Instanzvariablen per Definition immer kovariant sein muss, muss Y ein Subtyp von X sein. Der Rückgabetyp von getF und der Parametertyp von setF ändern sich damit automatisch ebenfalls kovariant.
Ein besonderer Fall von verankerten Typen ergibt sich bei rekursiven Typen, also Typen, deren Definition den definierten Typ selbst referenziert.
In diesem Fall schreibt man in EIFFEL anstelle der Typreferenz bei der Deklaration einer Variable vom zu definierenden Typ like Current. Bei einem entsprechend deklarierten Feld ändert sich der Typ bei der Vererbung also immer automatisch zum erbenden Typ hin, also immer mit dem Typ und damit kovariant. Für das Beispiel der zu trennenden Skifahrerinnen (Zeilen 1391–1425) ergibt sich damit. Die beiden erbenden Klassen GIRL und BOY müssen dann nichts mehr redefinieren.
Wir können nun zur Lösung des Problems der Kovarianz in EIFFEL kommen. Die obige Konstruktion (hier unverändert wiederholt) wird dann vom Type checker zur Übersetzungszeit zurückgewiesen, da g1 nicht vom Typ like s1 ist, was aber laut den Typkonformitätsregeln von EIFFEL notwendig wäre. Leider ist das nur ein Teilerfolg.
Die erste und einfachste Möglichkeit, dies zu verhindern, wäre, die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einzuschränken und unter ihnen nur noch Typäquivalenz zu akzeptieren. Es wären dann nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit solchen, die ihn als Anker benutzen, erlaubt. Insbesondere wäre eine Zuweisung wie s1 := g1 (die ja notwendig war, um ein Objekt vom Typ GIRL so zu „verpacken“, dass es an g2 mit seinem verankerten Typ like s1 zugewiesen werden kann) damit nicht mehr möglich. Alle anderen Zuweisungen wären natürlich weiterhin zugelassen. Dies hätte jedoch zur Konsequenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem wäre es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll.
Die zweite Möglichkeit wäre, eine Typinferenz für das gesamte Programm durchzuführen, um die möglichen Zuweisungen an Variablen zu sammeln. Dazu sind insbesondere alle Methodenaufrufe anzusehen. Diese können je nach Konfiguration des endgültigen Systems sehr unterschiedlich ausfallen. Eine solche Typinferenz ist jedoch in den meisten Fällen unrealistisch.
Die dritte Möglichkeit ist die, alle dynamisch gebundenen Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“) ändern (die von MEYER so genannten CAT-Calls, wobei CAT für „Change Availability or Type“ steht), zu verbieten. Ein Aufruf von share auf s1 wie oben ist damit verboten, weil share in BOY und GIRL kovariant redefiniert wird. Auf einer Variable vom Typ GIRL oder BOY wäre er hingegen zulässig, solange sichergestellt ist, dass diese Variable keinen Wert von einem Subtyp von GIRL bzw. BOY zugewiesen bekommen kann. Das ist möglich, wenn kein solcher Subtyp existiert oder wenn keine Zuweisung an die Variable existiert, bei der die rechte Seite ein Subtyp der Variable ist. Das erste ist lokal nicht nachzuweisen, das zweite hingegen schon, jedoch nur für explizite Zuweisungen (inklusive der Instanziierung, die in EIFFEL auf einer Variable durchgeführt wird und ihr automatisch einen Wert gibt). Für die Zuweisung an formale Parameter kann dies jedoch nicht lokal nachgewiesen werden, weil im Gegensatz zu expliziten Zuweisungen an Variablen die Methodenaufrufe von überall her erfolgen können.
Wie Sie sehen, sind die Bedingungen ziemlich restriktiv, und man kommt nicht umhin, das Typsystem von EIFFEL als etwas eigenartig zu empfinden. Wie es sich in der Praxis auswirkt, ist mir leider nicht bekannt; MEYER behauptet, dass die Probleme praktisch keine Rolle spielen. Ich möchte hinzufügen, dass falls doch, die durchschnittliche Programmiererin kaum verstehen wird, was denn nun genau das Problem ist und was sie tun kann, es zu umgehen.","<answer> In EIFFEL kann bei der Deklaration angegeben werden, ob Variablen eines Typs Wertsemantik oder Referenzsemantik haben sollen. Dies kann für alle Variablen eines Typs oder nur für bestimmte Variablen festgelegt werden. <answer> <question> Wie wird in EIFFEL zwischen Wert- und Referenztypen unterschieden? <question>"
"Wie auch in JAVA definiert jede unparametrisierte Klasse in EIFFEL einen Typ, und jede parametrisierte Klasse eine (generische) Menge von Typen. Alle Variablen (einschließlich Methoden und deren Parameter) müssen einen Typ haben. Die Zuweisungskompatibilität ist an nominale Typkonformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung genannt) einhergeht, ganz wie in JAVA. Anders als in JAVA ist es jedoch zulässig, Instanzvariablen und Funktionsparameter wie im obigen Beispiel kovariant zu redefinieren. Von kontravarianter Redefinition will MEYER nichts wissen (eine Begründung sollten Sie mittlerweile selbst zur Verfügung haben). Das bedeutet jedoch mangelnde Substituierbarkeit und bereitet EIFFEL erwartungsgemäß einige nicht triviale Probleme.
Zunächst einmal wollen wir uns das Typsystem von EIFFEL noch genauer ansehen. Es basiert, wie in der objektorientierten Programmierung üblich, auf dem Begriff der Typkonformität (Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ U typkonform zu einem Typ T: Wenn U und T gleich sind, Wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder Wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist (U ist eine indirekte Erweiterung von T).
Außerdem gibt es in EIFFEL noch einen Typkonstruktor like <ein Ausdruck>, dessen erzeugter Typ typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der Basistyp konform, keiner seiner Subtypen.
EIFFEL benutzt also eckige Klammern und -> anstelle von spitzen Klammern und extends in JAVA.
In EIFFEL wird übrigens anders als in C# nicht pro Typkonstruktor zwischen Wert- und Referenztypen unterschieden. Zu jedem Typ kann es (ähnlich wie in C++) beide Formen geben. Dazu gibt es in EIFFEL die Möglichkeit, bei einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik, also ein Objekt anstelle einer Referenz auf ein Objekt zum Inhalt haben sollen. Dies ist manchmal für alle Variablen eines Typs sinnvoll, z. B. bei Zahlen und Wahrheitswerten, manchmal aber auch nur für manche. So gibt es in EIFFEL einen Typkonstruktor expanded, der einer einzelnen Variable Wertsemantik gibt und in Klassendefinitionen allen Variablen des entsprechenden Typs automatisch Wertsemantik gibt. EIFFELs Typkonstruktor expanded entspricht also gewissermaßen einer Umkehrung des in PASCAL-artigen Sprachen verwendeten Typkonstruktors ^ (Zeiger auf). Die Unterscheidung von Wert- und Referenztypen einer Klasse hat in EIFFEL einen starken konzeptuellen Hintergrund, da sie die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen (vgl. dazu auch Kapitel 59 in Kurseinheit 6).
Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer Typkonstruktoren für entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) zu haben. Dieses Feature ist nicht in C# (zumindest nicht im Safe mode) verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen. In C++ (und im Unsafe mode von C#) kann man es simulieren, zahlt jedoch den Preis, mit expliziten Pointern umgehen zu müssen.
Nun stand bereits in Kurseinheit 1, Abschnitt 1.6 zu lesen, dass bei der Zuweisung zwischen zwei Variablen mit Wertsemantik der Wert der einen Variable in die andere Variable kopiert wird, während bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik lediglich der Zeiger kopiert wird. Dies ist auch in EIFFEL so. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte. Stattdessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert). Im umgekehrten Fall, also wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt, und eine Referenz auf diesen Klon wird übergeben.
Eine solche Verankerung bewirkt, dass sich der Typ von x automatisch mit dem von y verändert. Dies hat zunächst noch nichts mit Kovarianz zu tun.
Da die Typen der Parameter von setF und getF alle per Deklaration dieselben sind wie der Typ von f, muss in der Definition von B textuell nichts anderes stehen. Da nun aber in EIFFEL die Redefinition von Instanzvariablen per Definition immer kovariant sein muss, muss Y ein Subtyp von X sein. Der Rückgabetyp von getF und der Parametertyp von setF ändern sich damit automatisch ebenfalls kovariant.
Ein besonderer Fall von verankerten Typen ergibt sich bei rekursiven Typen, also Typen, deren Definition den definierten Typ selbst referenziert.
In diesem Fall schreibt man in EIFFEL anstelle der Typreferenz bei der Deklaration einer Variable vom zu definierenden Typ like Current. Bei einem entsprechend deklarierten Feld ändert sich der Typ bei der Vererbung also immer automatisch zum erbenden Typ hin, also immer mit dem Typ und damit kovariant. Für das Beispiel der zu trennenden Skifahrerinnen (Zeilen 1391–1425) ergibt sich damit. Die beiden erbenden Klassen GIRL und BOY müssen dann nichts mehr redefinieren.
Wir können nun zur Lösung des Problems der Kovarianz in EIFFEL kommen. Die obige Konstruktion (hier unverändert wiederholt) wird dann vom Type checker zur Übersetzungszeit zurückgewiesen, da g1 nicht vom Typ like s1 ist, was aber laut den Typkonformitätsregeln von EIFFEL notwendig wäre. Leider ist das nur ein Teilerfolg.
Die erste und einfachste Möglichkeit, dies zu verhindern, wäre, die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einzuschränken und unter ihnen nur noch Typäquivalenz zu akzeptieren. Es wären dann nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit solchen, die ihn als Anker benutzen, erlaubt. Insbesondere wäre eine Zuweisung wie s1 := g1 (die ja notwendig war, um ein Objekt vom Typ GIRL so zu „verpacken“, dass es an g2 mit seinem verankerten Typ like s1 zugewiesen werden kann) damit nicht mehr möglich. Alle anderen Zuweisungen wären natürlich weiterhin zugelassen. Dies hätte jedoch zur Konsequenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem wäre es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll.
Die zweite Möglichkeit wäre, eine Typinferenz für das gesamte Programm durchzuführen, um die möglichen Zuweisungen an Variablen zu sammeln. Dazu sind insbesondere alle Methodenaufrufe anzusehen. Diese können je nach Konfiguration des endgültigen Systems sehr unterschiedlich ausfallen. Eine solche Typinferenz ist jedoch in den meisten Fällen unrealistisch.
Die dritte Möglichkeit ist die, alle dynamisch gebundenen Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“) ändern (die von MEYER so genannten CAT-Calls, wobei CAT für „Change Availability or Type“ steht), zu verbieten. Ein Aufruf von share auf s1 wie oben ist damit verboten, weil share in BOY und GIRL kovariant redefiniert wird. Auf einer Variable vom Typ GIRL oder BOY wäre er hingegen zulässig, solange sichergestellt ist, dass diese Variable keinen Wert von einem Subtyp von GIRL bzw. BOY zugewiesen bekommen kann. Das ist möglich, wenn kein solcher Subtyp existiert oder wenn keine Zuweisung an die Variable existiert, bei der die rechte Seite ein Subtyp der Variable ist. Das erste ist lokal nicht nachzuweisen, das zweite hingegen schon, jedoch nur für explizite Zuweisungen (inklusive der Instanziierung, die in EIFFEL auf einer Variable durchgeführt wird und ihr automatisch einen Wert gibt). Für die Zuweisung an formale Parameter kann dies jedoch nicht lokal nachgewiesen werden, weil im Gegensatz zu expliziten Zuweisungen an Variablen die Methodenaufrufe von überall her erfolgen können.
Wie Sie sehen, sind die Bedingungen ziemlich restriktiv, und man kommt nicht umhin, das Typsystem von EIFFEL als etwas eigenartig zu empfinden. Wie es sich in der Praxis auswirkt, ist mir leider nicht bekannt; MEYER behauptet, dass die Probleme praktisch keine Rolle spielen. Ich möchte hinzufügen, dass falls doch, die durchschnittliche Programmiererin kaum verstehen wird, was denn nun genau das Problem ist und was sie tun kann, es zu umgehen.","<answer> Die Verwendung von kovarianten Redefinitionen in EIFFEL kann zu Problemen führen, insbesondere wenn dynamische Bindungen auftreten. Dies kann dazu führen, dass Typen inkonsistent werden und unerwartetes Verhalten auftritt. <answer> <question> Welche Probleme ergeben sich aus der Verwendung von kovarianten Redefinitionen in EIFFEL? <question>"
"Wie auch in JAVA definiert jede unparametrisierte Klasse in EIFFEL einen Typ, und jede parametrisierte Klasse eine (generische) Menge von Typen. Alle Variablen (einschließlich Methoden und deren Parameter) müssen einen Typ haben. Die Zuweisungskompatibilität ist an nominale Typkonformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung genannt) einhergeht, ganz wie in JAVA. Anders als in JAVA ist es jedoch zulässig, Instanzvariablen und Funktionsparameter wie im obigen Beispiel kovariant zu redefinieren. Von kontravarianter Redefinition will MEYER nichts wissen (eine Begründung sollten Sie mittlerweile selbst zur Verfügung haben). Das bedeutet jedoch mangelnde Substituierbarkeit und bereitet EIFFEL erwartungsgemäß einige nicht triviale Probleme.
Zunächst einmal wollen wir uns das Typsystem von EIFFEL noch genauer ansehen. Es basiert, wie in der objektorientierten Programmierung üblich, auf dem Begriff der Typkonformität (Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ U typkonform zu einem Typ T: Wenn U und T gleich sind, Wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder Wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist (U ist eine indirekte Erweiterung von T).
Außerdem gibt es in EIFFEL noch einen Typkonstruktor like <ein Ausdruck>, dessen erzeugter Typ typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der Basistyp konform, keiner seiner Subtypen.
EIFFEL benutzt also eckige Klammern und -> anstelle von spitzen Klammern und extends in JAVA.
In EIFFEL wird übrigens anders als in C# nicht pro Typkonstruktor zwischen Wert- und Referenztypen unterschieden. Zu jedem Typ kann es (ähnlich wie in C++) beide Formen geben. Dazu gibt es in EIFFEL die Möglichkeit, bei einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik, also ein Objekt anstelle einer Referenz auf ein Objekt zum Inhalt haben sollen. Dies ist manchmal für alle Variablen eines Typs sinnvoll, z. B. bei Zahlen und Wahrheitswerten, manchmal aber auch nur für manche. So gibt es in EIFFEL einen Typkonstruktor expanded, der einer einzelnen Variable Wertsemantik gibt und in Klassendefinitionen allen Variablen des entsprechenden Typs automatisch Wertsemantik gibt. EIFFELs Typkonstruktor expanded entspricht also gewissermaßen einer Umkehrung des in PASCAL-artigen Sprachen verwendeten Typkonstruktors ^ (Zeiger auf). Die Unterscheidung von Wert- und Referenztypen einer Klasse hat in EIFFEL einen starken konzeptuellen Hintergrund, da sie die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen (vgl. dazu auch Kapitel 59 in Kurseinheit 6).
Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer Typkonstruktoren für entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) zu haben. Dieses Feature ist nicht in C# (zumindest nicht im Safe mode) verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen. In C++ (und im Unsafe mode von C#) kann man es simulieren, zahlt jedoch den Preis, mit expliziten Pointern umgehen zu müssen.
Nun stand bereits in Kurseinheit 1, Abschnitt 1.6 zu lesen, dass bei der Zuweisung zwischen zwei Variablen mit Wertsemantik der Wert der einen Variable in die andere Variable kopiert wird, während bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik lediglich der Zeiger kopiert wird. Dies ist auch in EIFFEL so. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte. Stattdessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert). Im umgekehrten Fall, also wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt, und eine Referenz auf diesen Klon wird übergeben.
Eine solche Verankerung bewirkt, dass sich der Typ von x automatisch mit dem von y verändert. Dies hat zunächst noch nichts mit Kovarianz zu tun.
Da die Typen der Parameter von setF und getF alle per Deklaration dieselben sind wie der Typ von f, muss in der Definition von B textuell nichts anderes stehen. Da nun aber in EIFFEL die Redefinition von Instanzvariablen per Definition immer kovariant sein muss, muss Y ein Subtyp von X sein. Der Rückgabetyp von getF und der Parametertyp von setF ändern sich damit automatisch ebenfalls kovariant.
Ein besonderer Fall von verankerten Typen ergibt sich bei rekursiven Typen, also Typen, deren Definition den definierten Typ selbst referenziert.
In diesem Fall schreibt man in EIFFEL anstelle der Typreferenz bei der Deklaration einer Variable vom zu definierenden Typ like Current. Bei einem entsprechend deklarierten Feld ändert sich der Typ bei der Vererbung also immer automatisch zum erbenden Typ hin, also immer mit dem Typ und damit kovariant. Für das Beispiel der zu trennenden Skifahrerinnen (Zeilen 1391–1425) ergibt sich damit. Die beiden erbenden Klassen GIRL und BOY müssen dann nichts mehr redefinieren.
Wir können nun zur Lösung des Problems der Kovarianz in EIFFEL kommen. Die obige Konstruktion (hier unverändert wiederholt) wird dann vom Type checker zur Übersetzungszeit zurückgewiesen, da g1 nicht vom Typ like s1 ist, was aber laut den Typkonformitätsregeln von EIFFEL notwendig wäre. Leider ist das nur ein Teilerfolg.
Die erste und einfachste Möglichkeit, dies zu verhindern, wäre, die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einzuschränken und unter ihnen nur noch Typäquivalenz zu akzeptieren. Es wären dann nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit solchen, die ihn als Anker benutzen, erlaubt. Insbesondere wäre eine Zuweisung wie s1 := g1 (die ja notwendig war, um ein Objekt vom Typ GIRL so zu „verpacken“, dass es an g2 mit seinem verankerten Typ like s1 zugewiesen werden kann) damit nicht mehr möglich. Alle anderen Zuweisungen wären natürlich weiterhin zugelassen. Dies hätte jedoch zur Konsequenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem wäre es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll.
Die zweite Möglichkeit wäre, eine Typinferenz für das gesamte Programm durchzuführen, um die möglichen Zuweisungen an Variablen zu sammeln. Dazu sind insbesondere alle Methodenaufrufe anzusehen. Diese können je nach Konfiguration des endgültigen Systems sehr unterschiedlich ausfallen. Eine solche Typinferenz ist jedoch in den meisten Fällen unrealistisch.
Die dritte Möglichkeit ist die, alle dynamisch gebundenen Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“) ändern (die von MEYER so genannten CAT-Calls, wobei CAT für „Change Availability or Type“ steht), zu verbieten. Ein Aufruf von share auf s1 wie oben ist damit verboten, weil share in BOY und GIRL kovariant redefiniert wird. Auf einer Variable vom Typ GIRL oder BOY wäre er hingegen zulässig, solange sichergestellt ist, dass diese Variable keinen Wert von einem Subtyp von GIRL bzw. BOY zugewiesen bekommen kann. Das ist möglich, wenn kein solcher Subtyp existiert oder wenn keine Zuweisung an die Variable existiert, bei der die rechte Seite ein Subtyp der Variable ist. Das erste ist lokal nicht nachzuweisen, das zweite hingegen schon, jedoch nur für explizite Zuweisungen (inklusive der Instanziierung, die in EIFFEL auf einer Variable durchgeführt wird und ihr automatisch einen Wert gibt). Für die Zuweisung an formale Parameter kann dies jedoch nicht lokal nachgewiesen werden, weil im Gegensatz zu expliziten Zuweisungen an Variablen die Methodenaufrufe von überall her erfolgen können.
Wie Sie sehen, sind die Bedingungen ziemlich restriktiv, und man kommt nicht umhin, das Typsystem von EIFFEL als etwas eigenartig zu empfinden. Wie es sich in der Praxis auswirkt, ist mir leider nicht bekannt; MEYER behauptet, dass die Probleme praktisch keine Rolle spielen. Ich möchte hinzufügen, dass falls doch, die durchschnittliche Programmiererin kaum verstehen wird, was denn nun genau das Problem ist und was sie tun kann, es zu umgehen.","<answer> Es gibt verschiedene Ansätze, um die Kovarianzprobleme in EIFFEL zu verhindern, darunter die Beschränkung der Zuweisungskompatibilität, die Durchführung einer Typinferenz für das gesamte Programm und das Verbot dynamisch gebundener Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen ändern. Jede dieser Methoden hat jedoch ihre eigenen Einschränkungen und Herausforderungen. <answer> <question> Wie könnte man die Kovarianzprobleme in EIFFEL verhindern? <question>"
"Wie auch in JAVA definiert jede unparametrisierte Klasse in EIFFEL einen Typ, und jede parametrisierte Klasse eine (generische) Menge von Typen. Alle Variablen (einschließlich Methoden und deren Parameter) müssen einen Typ haben. Die Zuweisungskompatibilität ist an nominale Typkonformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung genannt) einhergeht, ganz wie in JAVA. Anders als in JAVA ist es jedoch zulässig, Instanzvariablen und Funktionsparameter wie im obigen Beispiel kovariant zu redefinieren. Von kontravarianter Redefinition will MEYER nichts wissen (eine Begründung sollten Sie mittlerweile selbst zur Verfügung haben). Das bedeutet jedoch mangelnde Substituierbarkeit und bereitet EIFFEL erwartungsgemäß einige nicht triviale Probleme.
Zunächst einmal wollen wir uns das Typsystem von EIFFEL noch genauer ansehen. Es basiert, wie in der objektorientierten Programmierung üblich, auf dem Begriff der Typkonformität (Kapitel 23 in Kurseinheit 3). In EIFFEL ist ein Typ U typkonform zu einem Typ T: Wenn U und T gleich sind, Wenn U eine direkte Erweiterung von T ist (direkt von T erbt) und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder Wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist (U ist eine indirekte Erweiterung von T).
Außerdem gibt es in EIFFEL noch einen Typkonstruktor like <ein Ausdruck>, dessen erzeugter Typ typkonform zum Typ von <ein Ausdruck> ist. Dieser spielt bei der kovarianten Redefinition eine wichtige Rolle. Zu einem so erzeugten Typ ist jedoch nur der Basistyp konform, keiner seiner Subtypen.
EIFFEL benutzt also eckige Klammern und -> anstelle von spitzen Klammern und extends in JAVA.
In EIFFEL wird übrigens anders als in C# nicht pro Typkonstruktor zwischen Wert- und Referenztypen unterschieden. Zu jedem Typ kann es (ähnlich wie in C++) beide Formen geben. Dazu gibt es in EIFFEL die Möglichkeit, bei einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik, also ein Objekt anstelle einer Referenz auf ein Objekt zum Inhalt haben sollen. Dies ist manchmal für alle Variablen eines Typs sinnvoll, z. B. bei Zahlen und Wahrheitswerten, manchmal aber auch nur für manche. So gibt es in EIFFEL einen Typkonstruktor expanded, der einer einzelnen Variable Wertsemantik gibt und in Klassendefinitionen allen Variablen des entsprechenden Typs automatisch Wertsemantik gibt. EIFFELs Typkonstruktor expanded entspricht also gewissermaßen einer Umkehrung des in PASCAL-artigen Sprachen verwendeten Typkonstruktors ^ (Zeiger auf). Die Unterscheidung von Wert- und Referenztypen einer Klasse hat in EIFFEL einen starken konzeptuellen Hintergrund, da sie die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen (vgl. dazu auch Kapitel 59 in Kurseinheit 6).
Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer Typkonstruktoren für entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) zu haben. Dieses Feature ist nicht in C# (zumindest nicht im Safe mode) verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen. In C++ (und im Unsafe mode von C#) kann man es simulieren, zahlt jedoch den Preis, mit expliziten Pointern umgehen zu müssen.
Nun stand bereits in Kurseinheit 1, Abschnitt 1.6 zu lesen, dass bei der Zuweisung zwischen zwei Variablen mit Wertsemantik der Wert der einen Variable in die andere Variable kopiert wird, während bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik lediglich der Zeiger kopiert wird. Dies ist auch in EIFFEL so. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte. Stattdessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert). Im umgekehrten Fall, also wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt, und eine Referenz auf diesen Klon wird übergeben.
Eine solche Verankerung bewirkt, dass sich der Typ von x automatisch mit dem von y verändert. Dies hat zunächst noch nichts mit Kovarianz zu tun.
Da die Typen der Parameter von setF und getF alle per Deklaration dieselben sind wie der Typ von f, muss in der Definition von B textuell nichts anderes stehen. Da nun aber in EIFFEL die Redefinition von Instanzvariablen per Definition immer kovariant sein muss, muss Y ein Subtyp von X sein. Der Rückgabetyp von getF und der Parametertyp von setF ändern sich damit automatisch ebenfalls kovariant.
Ein besonderer Fall von verankerten Typen ergibt sich bei rekursiven Typen, also Typen, deren Definition den definierten Typ selbst referenziert.
In diesem Fall schreibt man in EIFFEL anstelle der Typreferenz bei der Deklaration einer Variable vom zu definierenden Typ like Current. Bei einem entsprechend deklarierten Feld ändert sich der Typ bei der Vererbung also immer automatisch zum erbenden Typ hin, also immer mit dem Typ und damit kovariant. Für das Beispiel der zu trennenden Skifahrerinnen (Zeilen 1391–1425) ergibt sich damit. Die beiden erbenden Klassen GIRL und BOY müssen dann nichts mehr redefinieren.
Wir können nun zur Lösung des Problems der Kovarianz in EIFFEL kommen. Die obige Konstruktion (hier unverändert wiederholt) wird dann vom Type checker zur Übersetzungszeit zurückgewiesen, da g1 nicht vom Typ like s1 ist, was aber laut den Typkonformitätsregeln von EIFFEL notwendig wäre. Leider ist das nur ein Teilerfolg.
Die erste und einfachste Möglichkeit, dies zu verhindern, wäre, die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einzuschränken und unter ihnen nur noch Typäquivalenz zu akzeptieren. Es wären dann nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit solchen, die ihn als Anker benutzen, erlaubt. Insbesondere wäre eine Zuweisung wie s1 := g1 (die ja notwendig war, um ein Objekt vom Typ GIRL so zu „verpacken“, dass es an g2 mit seinem verankerten Typ like s1 zugewiesen werden kann) damit nicht mehr möglich. Alle anderen Zuweisungen wären natürlich weiterhin zugelassen. Dies hätte jedoch zur Konsequenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem wäre es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll.
Die zweite Möglichkeit wäre, eine Typinferenz für das gesamte Programm durchzuführen, um die möglichen Zuweisungen an Variablen zu sammeln. Dazu sind insbesondere alle Methodenaufrufe anzusehen. Diese können je nach Konfiguration des endgültigen Systems sehr unterschiedlich ausfallen. Eine solche Typinferenz ist jedoch in den meisten Fällen unrealistisch.
Die dritte Möglichkeit ist die, alle dynamisch gebundenen Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“) ändern (die von MEYER so genannten CAT-Calls, wobei CAT für „Change Availability or Type“ steht), zu verbieten. Ein Aufruf von share auf s1 wie oben ist damit verboten, weil share in BOY und GIRL kovariant redefiniert wird. Auf einer Variable vom Typ GIRL oder BOY wäre er hingegen zulässig, solange sichergestellt ist, dass diese Variable keinen Wert von einem Subtyp von GIRL bzw. BOY zugewiesen bekommen kann. Das ist möglich, wenn kein solcher Subtyp existiert oder wenn keine Zuweisung an die Variable existiert, bei der die rechte Seite ein Subtyp der Variable ist. Das erste ist lokal nicht nachzuweisen, das zweite hingegen schon, jedoch nur für explizite Zuweisungen (inklusive der Instanziierung, die in EIFFEL auf einer Variable durchgeführt wird und ihr automatisch einen Wert gibt). Für die Zuweisung an formale Parameter kann dies jedoch nicht lokal nachgewiesen werden, weil im Gegensatz zu expliziten Zuweisungen an Variablen die Methodenaufrufe von überall her erfolgen können.
Wie Sie sehen, sind die Bedingungen ziemlich restriktiv, und man kommt nicht umhin, das Typsystem von EIFFEL als etwas eigenartig zu empfinden. Wie es sich in der Praxis auswirkt, ist mir leider nicht bekannt; MEYER behauptet, dass die Probleme praktisch keine Rolle spielen. Ich möchte hinzufügen, dass falls doch, die durchschnittliche Programmiererin kaum verstehen wird, was denn nun genau das Problem ist und was sie tun kann, es zu umgehen.","<answer> Verankerte Typdeklarationen in EIFFEL ermöglichen es, den Typ von Variablen automatisch an den Typ eines bereits typisierten Programms zu binden. Dies erleichtert die Verwendung von kovarianten Redefinitionen. <answer> <question> Welche Rolle spielen verankerte Typdeklarationen in EIFFEL? <question>"
"Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark an die der englischen Sprache angelehnt ist. Sie verlangt ein Subjekt (den Empfänger der Nachricht), ein Prädikat (die Nachricht) sowie eine optionale Liste von Objekten als Prädikatsergänzungen (die Parameter der Nachricht). Dabei wird auf die in anderen Sprachen übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und Klammern zum Umschließen der Parameterliste verzichtet. Stattdessen verwendet man bei Zustandswechsel von zwei oder mehr Parametern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nachrichtenteile, die den Parametern vorangestellt werden. Ein Parameter kann auch eine Variable sein oder ein anderer Ausdruck.
In SMALLTALK werden parameterlose Nachrichten auch als ""unär"" (unary messages) bezeichnet, da sie trotz fehlender expliziter Argumente als ""unär"" bezeichnet werden, weil der Empfänger das erste, implizite Argument ist. Nachrichten mit einem Parameter werden als ""binäre Nachrichten"" (binary messages) bezeichnet, da sie nur einen Parameter haben, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.
Binäre Nachrichten bestehen aus einem oder mehreren nicht alphanumerischen Zeichen, die keine reservierten Zeichen sind. Alle anderen Nachrichten, die neben dem Empfänger mindestens ein Argument erfordern, werden in SMALLTALK Schlüsselwortnachrichten (keyword messages) genannt. Diese Nachrichten enthalten normalerweise keinen Schlüsselwort im herkömmlichen Sinne, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.
Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken, die die Teile des Nachrichtenselektors sperren. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.
Da ein Nachrichtenausdruck für ein Objekt steht, kann er selbst Teil eines anderen Nachrichtenausdrucks sein, entweder als Empfänger der Nachricht oder als eines ihrer Argumente. In diesem Fall ist es möglicherweise notwendig, den geschachtelten Nachrichtenausdruck in Klammern zu setzen, um sicherzustellen, dass er korrekt erkannt wird.
Die Kaskadierung ist eine syntaktische Abkürzung, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen.
Es ist wichtig zu beachten, dass die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor die Bedeutung der Nachricht bestimmt. Die an das Objekt gesendete Nachricht, der sogenannte Nachrichtenselektor, ist immer ein Symbol, das aus der Konkatenation aller seiner Teile besteht. Die Namen der Nachrichtenteile sind frei wählbar, beginnen jedoch konventionell mit einem Kleinbuchstaben.
Die Verwendung der Kaskadierung kann die Einführung temporärer Variablen in einigen Fällen vermeiden, insbesondere wenn ein Ausdruck, der das Empfängerobjekt liefert und nur einmal ausgewertet werden soll, anstelle einer Variablen steht.","<answer> ""Unäre Nachrichten"" sind parameterlose Nachrichten, die den Empfänger als implizites erstes Argument haben. ""Binäre Nachrichten"" sind Nachrichten mit einem Parameter, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument. <answer> <question> Was sind ""unäre Nachrichten"" und ""binäre Nachrichten"" in SMALLTALK? <question>"
"Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark an die der englischen Sprache angelehnt ist. Sie verlangt ein Subjekt (den Empfänger der Nachricht), ein Prädikat (die Nachricht) sowie eine optionale Liste von Objekten als Prädikatsergänzungen (die Parameter der Nachricht). Dabei wird auf die in anderen Sprachen übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und Klammern zum Umschließen der Parameterliste verzichtet. Stattdessen verwendet man bei Zustandswechsel von zwei oder mehr Parametern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nachrichtenteile, die den Parametern vorangestellt werden. Ein Parameter kann auch eine Variable sein oder ein anderer Ausdruck.
In SMALLTALK werden parameterlose Nachrichten auch als ""unär"" (unary messages) bezeichnet, da sie trotz fehlender expliziter Argumente als ""unär"" bezeichnet werden, weil der Empfänger das erste, implizite Argument ist. Nachrichten mit einem Parameter werden als ""binäre Nachrichten"" (binary messages) bezeichnet, da sie nur einen Parameter haben, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.
Binäre Nachrichten bestehen aus einem oder mehreren nicht alphanumerischen Zeichen, die keine reservierten Zeichen sind. Alle anderen Nachrichten, die neben dem Empfänger mindestens ein Argument erfordern, werden in SMALLTALK Schlüsselwortnachrichten (keyword messages) genannt. Diese Nachrichten enthalten normalerweise keinen Schlüsselwort im herkömmlichen Sinne, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.
Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken, die die Teile des Nachrichtenselektors sperren. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.
Da ein Nachrichtenausdruck für ein Objekt steht, kann er selbst Teil eines anderen Nachrichtenausdrucks sein, entweder als Empfänger der Nachricht oder als eines ihrer Argumente. In diesem Fall ist es möglicherweise notwendig, den geschachtelten Nachrichtenausdruck in Klammern zu setzen, um sicherzustellen, dass er korrekt erkannt wird.
Die Kaskadierung ist eine syntaktische Abkürzung, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen.
Es ist wichtig zu beachten, dass die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor die Bedeutung der Nachricht bestimmt. Die an das Objekt gesendete Nachricht, der sogenannte Nachrichtenselektor, ist immer ein Symbol, das aus der Konkatenation aller seiner Teile besteht. Die Namen der Nachrichtenteile sind frei wählbar, beginnen jedoch konventionell mit einem Kleinbuchstaben.
Die Verwendung der Kaskadierung kann die Einführung temporärer Variablen in einigen Fällen vermeiden, insbesondere wenn ein Ausdruck, der das Empfängerobjekt liefert und nur einmal ausgewertet werden soll, anstelle einer Variablen steht.","<answer> Die Kaskadierung ist eine syntaktische Abkürzung in SMALLTALK, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen. Dies erleichtert das Verketten von Nachrichten an dasselbe Objekt. <answer> <question> Was ist die Kaskadierung in SMALLTALK? <question>"
"Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark an die der englischen Sprache angelehnt ist. Sie verlangt ein Subjekt (den Empfänger der Nachricht), ein Prädikat (die Nachricht) sowie eine optionale Liste von Objekten als Prädikatsergänzungen (die Parameter der Nachricht). Dabei wird auf die in anderen Sprachen übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und Klammern zum Umschließen der Parameterliste verzichtet. Stattdessen verwendet man bei Zustandswechsel von zwei oder mehr Parametern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nachrichtenteile, die den Parametern vorangestellt werden. Ein Parameter kann auch eine Variable sein oder ein anderer Ausdruck.
In SMALLTALK werden parameterlose Nachrichten auch als ""unär"" (unary messages) bezeichnet, da sie trotz fehlender expliziter Argumente als ""unär"" bezeichnet werden, weil der Empfänger das erste, implizite Argument ist. Nachrichten mit einem Parameter werden als ""binäre Nachrichten"" (binary messages) bezeichnet, da sie nur einen Parameter haben, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.
Binäre Nachrichten bestehen aus einem oder mehreren nicht alphanumerischen Zeichen, die keine reservierten Zeichen sind. Alle anderen Nachrichten, die neben dem Empfänger mindestens ein Argument erfordern, werden in SMALLTALK Schlüsselwortnachrichten (keyword messages) genannt. Diese Nachrichten enthalten normalerweise keinen Schlüsselwort im herkömmlichen Sinne, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.
Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken, die die Teile des Nachrichtenselektors sperren. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.
Da ein Nachrichtenausdruck für ein Objekt steht, kann er selbst Teil eines anderen Nachrichtenausdrucks sein, entweder als Empfänger der Nachricht oder als eines ihrer Argumente. In diesem Fall ist es möglicherweise notwendig, den geschachtelten Nachrichtenausdruck in Klammern zu setzen, um sicherzustellen, dass er korrekt erkannt wird.
Die Kaskadierung ist eine syntaktische Abkürzung, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen.
Es ist wichtig zu beachten, dass die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor die Bedeutung der Nachricht bestimmt. Die an das Objekt gesendete Nachricht, der sogenannte Nachrichtenselektor, ist immer ein Symbol, das aus der Konkatenation aller seiner Teile besteht. Die Namen der Nachrichtenteile sind frei wählbar, beginnen jedoch konventionell mit einem Kleinbuchstaben.
Die Verwendung der Kaskadierung kann die Einführung temporärer Variablen in einigen Fällen vermeiden, insbesondere wenn ein Ausdruck, der das Empfängerobjekt liefert und nur einmal ausgewertet werden soll, anstelle einer Variablen steht.",<answer> Die weite wichtige Ausdrucksform neben der Zuweisung in der objektorientierten Programmierung ist der Nachrichtenversand. <answer> <question> Welche ist die zweite wichtige Ausdrucksform in der objektorientierten Programmierung neben der Zuweisung? <question>
"Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark an die der englischen Sprache angelehnt ist. Sie verlangt ein Subjekt (den Empfänger der Nachricht), ein Prädikat (die Nachricht) sowie eine optionale Liste von Objekten als Prädikatsergänzungen (die Parameter der Nachricht). Dabei wird auf die in anderen Sprachen übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und Klammern zum Umschließen der Parameterliste verzichtet. Stattdessen verwendet man bei Zustandswechsel von zwei oder mehr Parametern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nachrichtenteile, die den Parametern vorangestellt werden. Ein Parameter kann auch eine Variable sein oder ein anderer Ausdruck.
In SMALLTALK werden parameterlose Nachrichten auch als ""unär"" (unary messages) bezeichnet, da sie trotz fehlender expliziter Argumente als ""unär"" bezeichnet werden, weil der Empfänger das erste, implizite Argument ist. Nachrichten mit einem Parameter werden als ""binäre Nachrichten"" (binary messages) bezeichnet, da sie nur einen Parameter haben, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.
Binäre Nachrichten bestehen aus einem oder mehreren nicht alphanumerischen Zeichen, die keine reservierten Zeichen sind. Alle anderen Nachrichten, die neben dem Empfänger mindestens ein Argument erfordern, werden in SMALLTALK Schlüsselwortnachrichten (keyword messages) genannt. Diese Nachrichten enthalten normalerweise keinen Schlüsselwort im herkömmlichen Sinne, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.
Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken, die die Teile des Nachrichtenselektors sperren. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.
Da ein Nachrichtenausdruck für ein Objekt steht, kann er selbst Teil eines anderen Nachrichtenausdrucks sein, entweder als Empfänger der Nachricht oder als eines ihrer Argumente. In diesem Fall ist es möglicherweise notwendig, den geschachtelten Nachrichtenausdruck in Klammern zu setzen, um sicherzustellen, dass er korrekt erkannt wird.
Die Kaskadierung ist eine syntaktische Abkürzung, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen.
Es ist wichtig zu beachten, dass die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor die Bedeutung der Nachricht bestimmt. Die an das Objekt gesendete Nachricht, der sogenannte Nachrichtenselektor, ist immer ein Symbol, das aus der Konkatenation aller seiner Teile besteht. Die Namen der Nachrichtenteile sind frei wählbar, beginnen jedoch konventionell mit einem Kleinbuchstaben.
Die Verwendung der Kaskadierung kann die Einführung temporärer Variablen in einigen Fällen vermeiden, insbesondere wenn ein Ausdruck, der das Empfängerobjekt liefert und nur einmal ausgewertet werden soll, anstelle einer Variablen steht.","<answer> Schlüsselwortnachrichten (keyword messages) sind Nachrichten in SMALLTALK, die neben dem Empfänger mindestens ein Argument erfordern. Sie enthalten normalerweise kein herkömmliches Schlüsselwort im Sinne von Schlüsselwort-Argumenten, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet. <answer> <question> Was sind Schlüsselwortnachrichten in SMALLTALK? <question>"
"Neben der Zuweisung ist der Nachrichtenversand die zweite wichtige Ausdrucksform der objektorientierten Programmierung. SMALLTALK verwendet hierfür eine Syntax, die stark an die der englischen Sprache angelehnt ist. Sie verlangt ein Subjekt (den Empfänger der Nachricht), ein Prädikat (die Nachricht) sowie eine optionale Liste von Objekten als Prädikatsergänzungen (die Parameter der Nachricht). Dabei wird auf die in anderen Sprachen übliche Verwendung des Punkts als Trennzeichen zwischen Empfänger und Nachricht und Klammern zum Umschließen der Parameterliste verzichtet. Stattdessen verwendet man bei Zustandswechsel von zwei oder mehr Parametern Partikeln (Präpositionen oder Konjunktionen) ähnelnde Nachrichtenteile, die den Parametern vorangestellt werden. Ein Parameter kann auch eine Variable sein oder ein anderer Ausdruck.
In SMALLTALK werden parameterlose Nachrichten auch als ""unär"" (unary messages) bezeichnet, da sie trotz fehlender expliziter Argumente als ""unär"" bezeichnet werden, weil der Empfänger das erste, implizite Argument ist. Nachrichten mit einem Parameter werden als ""binäre Nachrichten"" (binary messages) bezeichnet, da sie nur einen Parameter haben, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.
Binäre Nachrichten bestehen aus einem oder mehreren nicht alphanumerischen Zeichen, die keine reservierten Zeichen sind. Alle anderen Nachrichten, die neben dem Empfänger mindestens ein Argument erfordern, werden in SMALLTALK Schlüsselwortnachrichten (keyword messages) genannt. Diese Nachrichten enthalten normalerweise keinen Schlüsselwort im herkömmlichen Sinne, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.
Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken, die die Teile des Nachrichtenselektors sperren. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.
Da ein Nachrichtenausdruck für ein Objekt steht, kann er selbst Teil eines anderen Nachrichtenausdrucks sein, entweder als Empfänger der Nachricht oder als eines ihrer Argumente. In diesem Fall ist es möglicherweise notwendig, den geschachtelten Nachrichtenausdruck in Klammern zu setzen, um sicherzustellen, dass er korrekt erkannt wird.
Die Kaskadierung ist eine syntaktische Abkürzung, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen.
Es ist wichtig zu beachten, dass die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor die Bedeutung der Nachricht bestimmt. Die an das Objekt gesendete Nachricht, der sogenannte Nachrichtenselektor, ist immer ein Symbol, das aus der Konkatenation aller seiner Teile besteht. Die Namen der Nachrichtenteile sind frei wählbar, beginnen jedoch konventionell mit einem Kleinbuchstaben.
Die Verwendung der Kaskadierung kann die Einführung temporärer Variablen in einigen Fällen vermeiden, insbesondere wenn ein Ausdruck, der das Empfängerobjekt liefert und nur einmal ausgewertet werden soll, anstelle einer Variablen steht.","<answer> Die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor bestimmt die Bedeutung der Nachricht. Der Nachrichtenselektor selbst ist ein Symbol, das aus der Konkatenation aller seiner Teile besteht. <answer> <question> Welche Bedeutung hat die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor in SMALLTALK? <question>"
"Ein interessantes Konzept von C++, das einen direkten Bezug zur objektorientierten Programmierung hat, ist das Friends-Konzept. In der Praxis kommt es häufig vor, dass ein bestimmtes Teilproblem nicht von einer Klasse allein, sondern nur durch das Zusammenwirken mehrerer Klassen gelöst werden kann. Während diese Klassen untereinander eng kooperieren müssen und deshalb (relativ) intime Kenntnis voneinander benötigen (das heißt, auf Elemente zugreifen können müssen, die anderen Klassen verborgen bleiben sollen), gilt das für andere Klassen nicht unbedingt. Die Schnittstelle solcher kooperierenden Klassen sollte also nicht absolut, sondern relativ zu anderen Klassen definierbar sein.
In JAVA hatte man dazu bis zur Version 8 nur die Möglichkeit, die besagten Klassen in ein Paket zu verfrachten und die fraglichen Elemente mit paketweitem Zugriff (also ohne Zugriffsmodifizierer) zu deklarieren (Abschnitt 39.1 in Kurseinheit 4). Das hat jedoch den Nachteil, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben; wenn es eine Klasse gibt, die eine ansonsten unsichtbare Eigenschaft x einer Klasse A sehen und eine andere, die eine Eigenschaft y derselben Klasse sehen soll, dann gibt es keine Aufteilung der Klassen auf Pakete, die genau dieses gestattet. Was man stattdessen gern hätte, ist ein dedizierter Export von Elementen einer Klasse, also ein zur Verfügung Stellen von Elementen an genau benannte Klassen. Dies bietet, in etwas gröberer Form, das Friends-Konzept von C++: Die Definition friend class B; friend class C; bewirkt, dass (Instanzen von) B und (von) C auf alle privat deklarierten Elemente von (Instanzen von) A zugreifen können (jedoch weder umgekehrt von A auf B und C noch B und C gegenseitig). Ein spezifischer, dedizierter Export von einzelnen Membern an bestimmte Klassen ist in C++ nicht möglich; diesen gibt es dafür in EIFFEL (s. Abschnitt 52.2). Mit JAVAs Modulen und dem dedizierten (qualifiziert genannten) Export wird das Friend-Konzept auf Ebene der Pakete zumindest angenähert.","<answer> Das Friends-Konzept in C++ ermöglicht es, dass bestimmte Klassen auf private Elemente einer anderen Klasse zugreifen können, ohne direkte Mitglieder dieser Klasse zu sein. <answer> <question> Was ist das Friends-Konzept in C++? <question>"
"Ein interessantes Konzept von C++, das einen direkten Bezug zur objektorientierten Programmierung hat, ist das Friends-Konzept. In der Praxis kommt es häufig vor, dass ein bestimmtes Teilproblem nicht von einer Klasse allein, sondern nur durch das Zusammenwirken mehrerer Klassen gelöst werden kann. Während diese Klassen untereinander eng kooperieren müssen und deshalb (relativ) intime Kenntnis voneinander benötigen (das heißt, auf Elemente zugreifen können müssen, die anderen Klassen verborgen bleiben sollen), gilt das für andere Klassen nicht unbedingt. Die Schnittstelle solcher kooperierenden Klassen sollte also nicht absolut, sondern relativ zu anderen Klassen definierbar sein.
In JAVA hatte man dazu bis zur Version 8 nur die Möglichkeit, die besagten Klassen in ein Paket zu verfrachten und die fraglichen Elemente mit paketweitem Zugriff (also ohne Zugriffsmodifizierer) zu deklarieren (Abschnitt 39.1 in Kurseinheit 4). Das hat jedoch den Nachteil, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben; wenn es eine Klasse gibt, die eine ansonsten unsichtbare Eigenschaft x einer Klasse A sehen und eine andere, die eine Eigenschaft y derselben Klasse sehen soll, dann gibt es keine Aufteilung der Klassen auf Pakete, die genau dieses gestattet. Was man stattdessen gern hätte, ist ein dedizierter Export von Elementen einer Klasse, also ein zur Verfügung Stellen von Elementen an genau benannte Klassen. Dies bietet, in etwas gröberer Form, das Friends-Konzept von C++: Die Definition friend class B; friend class C; bewirkt, dass (Instanzen von) B und (von) C auf alle privat deklarierten Elemente von (Instanzen von) A zugreifen können (jedoch weder umgekehrt von A auf B und C noch B und C gegenseitig). Ein spezifischer, dedizierter Export von einzelnen Membern an bestimmte Klassen ist in C++ nicht möglich; diesen gibt es dafür in EIFFEL (s. Abschnitt 52.2). Mit JAVAs Modulen und dem dedizierten (qualifiziert genannten) Export wird das Friend-Konzept auf Ebene der Pakete zumindest angenähert.","<answer> Das Friends-Konzept ist nützlich, wenn ein Teilproblem in der Programmierung nicht von einer einzelnen Klasse gelöst werden kann, sondern die Zusammenarbeit mehrerer Klassen erfordert. Es ermöglicht, dass diese Klassen eng zusammenarbeiten können, ohne dass alle Klassen dieselbe Schnittstelle haben müssen. <answer> <question> Warum ist das Friends-Konzept in C++ nützlich? <question>"
"Ein interessantes Konzept von C++, das einen direkten Bezug zur objektorientierten Programmierung hat, ist das Friends-Konzept. In der Praxis kommt es häufig vor, dass ein bestimmtes Teilproblem nicht von einer Klasse allein, sondern nur durch das Zusammenwirken mehrerer Klassen gelöst werden kann. Während diese Klassen untereinander eng kooperieren müssen und deshalb (relativ) intime Kenntnis voneinander benötigen (das heißt, auf Elemente zugreifen können müssen, die anderen Klassen verborgen bleiben sollen), gilt das für andere Klassen nicht unbedingt. Die Schnittstelle solcher kooperierenden Klassen sollte also nicht absolut, sondern relativ zu anderen Klassen definierbar sein.
In JAVA hatte man dazu bis zur Version 8 nur die Möglichkeit, die besagten Klassen in ein Paket zu verfrachten und die fraglichen Elemente mit paketweitem Zugriff (also ohne Zugriffsmodifizierer) zu deklarieren (Abschnitt 39.1 in Kurseinheit 4). Das hat jedoch den Nachteil, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben; wenn es eine Klasse gibt, die eine ansonsten unsichtbare Eigenschaft x einer Klasse A sehen und eine andere, die eine Eigenschaft y derselben Klasse sehen soll, dann gibt es keine Aufteilung der Klassen auf Pakete, die genau dieses gestattet. Was man stattdessen gern hätte, ist ein dedizierter Export von Elementen einer Klasse, also ein zur Verfügung Stellen von Elementen an genau benannte Klassen. Dies bietet, in etwas gröberer Form, das Friends-Konzept von C++: Die Definition friend class B; friend class C; bewirkt, dass (Instanzen von) B und (von) C auf alle privat deklarierten Elemente von (Instanzen von) A zugreifen können (jedoch weder umgekehrt von A auf B und C noch B und C gegenseitig). Ein spezifischer, dedizierter Export von einzelnen Membern an bestimmte Klassen ist in C++ nicht möglich; diesen gibt es dafür in EIFFEL (s. Abschnitt 52.2). Mit JAVAs Modulen und dem dedizierten (qualifiziert genannten) Export wird das Friend-Konzept auf Ebene der Pakete zumindest angenähert.","<answer> In C++ wird festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen, indem man die betreffenden Klassen mit dem Schlüsselwort ""friend"" in der Zielsklasse deklariert. Zum Beispiel: friend class B; und friend class C; <answer> <question> Wie wird in C++ festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen? <question>"
"Ein interessantes Konzept von C++, das einen direkten Bezug zur objektorientierten Programmierung hat, ist das Friends-Konzept. In der Praxis kommt es häufig vor, dass ein bestimmtes Teilproblem nicht von einer Klasse allein, sondern nur durch das Zusammenwirken mehrerer Klassen gelöst werden kann. Während diese Klassen untereinander eng kooperieren müssen und deshalb (relativ) intime Kenntnis voneinander benötigen (das heißt, auf Elemente zugreifen können müssen, die anderen Klassen verborgen bleiben sollen), gilt das für andere Klassen nicht unbedingt. Die Schnittstelle solcher kooperierenden Klassen sollte also nicht absolut, sondern relativ zu anderen Klassen definierbar sein.
In JAVA hatte man dazu bis zur Version 8 nur die Möglichkeit, die besagten Klassen in ein Paket zu verfrachten und die fraglichen Elemente mit paketweitem Zugriff (also ohne Zugriffsmodifizierer) zu deklarieren (Abschnitt 39.1 in Kurseinheit 4). Das hat jedoch den Nachteil, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben; wenn es eine Klasse gibt, die eine ansonsten unsichtbare Eigenschaft x einer Klasse A sehen und eine andere, die eine Eigenschaft y derselben Klasse sehen soll, dann gibt es keine Aufteilung der Klassen auf Pakete, die genau dieses gestattet. Was man stattdessen gern hätte, ist ein dedizierter Export von Elementen einer Klasse, also ein zur Verfügung Stellen von Elementen an genau benannte Klassen. Dies bietet, in etwas gröberer Form, das Friends-Konzept von C++: Die Definition friend class B; friend class C; bewirkt, dass (Instanzen von) B und (von) C auf alle privat deklarierten Elemente von (Instanzen von) A zugreifen können (jedoch weder umgekehrt von A auf B und C noch B und C gegenseitig). Ein spezifischer, dedizierter Export von einzelnen Membern an bestimmte Klassen ist in C++ nicht möglich; diesen gibt es dafür in EIFFEL (s. Abschnitt 52.2). Mit JAVAs Modulen und dem dedizierten (qualifiziert genannten) Export wird das Friend-Konzept auf Ebene der Pakete zumindest angenähert.","<answer> In Java hatte man bis zur Version 8 die Möglichkeit, Klassen in ein Paket zu verfrachten, um die Zusammenarbeit von Klassen zu ermöglichen. Der Nachteil dabei ist, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben, was die Aufteilung der Klassen auf Pakete einschränken kann. <answer> <question> Welchen Nachteil hat die Verwendung von Paketen in Java für die Zusammenarbeit von Klassen? <question>"
"Ein interessantes Konzept von C++, das einen direkten Bezug zur objektorientierten Programmierung hat, ist das Friends-Konzept. In der Praxis kommt es häufig vor, dass ein bestimmtes Teilproblem nicht von einer Klasse allein, sondern nur durch das Zusammenwirken mehrerer Klassen gelöst werden kann. Während diese Klassen untereinander eng kooperieren müssen und deshalb (relativ) intime Kenntnis voneinander benötigen (das heißt, auf Elemente zugreifen können müssen, die anderen Klassen verborgen bleiben sollen), gilt das für andere Klassen nicht unbedingt. Die Schnittstelle solcher kooperierenden Klassen sollte also nicht absolut, sondern relativ zu anderen Klassen definierbar sein.
In JAVA hatte man dazu bis zur Version 8 nur die Möglichkeit, die besagten Klassen in ein Paket zu verfrachten und die fraglichen Elemente mit paketweitem Zugriff (also ohne Zugriffsmodifizierer) zu deklarieren (Abschnitt 39.1 in Kurseinheit 4). Das hat jedoch den Nachteil, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben; wenn es eine Klasse gibt, die eine ansonsten unsichtbare Eigenschaft x einer Klasse A sehen und eine andere, die eine Eigenschaft y derselben Klasse sehen soll, dann gibt es keine Aufteilung der Klassen auf Pakete, die genau dieses gestattet. Was man stattdessen gern hätte, ist ein dedizierter Export von Elementen einer Klasse, also ein zur Verfügung Stellen von Elementen an genau benannte Klassen. Dies bietet, in etwas gröberer Form, das Friends-Konzept von C++: Die Definition friend class B; friend class C; bewirkt, dass (Instanzen von) B und (von) C auf alle privat deklarierten Elemente von (Instanzen von) A zugreifen können (jedoch weder umgekehrt von A auf B und C noch B und C gegenseitig). Ein spezifischer, dedizierter Export von einzelnen Membern an bestimmte Klassen ist in C++ nicht möglich; diesen gibt es dafür in EIFFEL (s. Abschnitt 52.2). Mit JAVAs Modulen und dem dedizierten (qualifiziert genannten) Export wird das Friend-Konzept auf Ebene der Pakete zumindest angenähert.","<answer> Nein, in C++ ist es nicht möglich, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren. Stattdessen erlaubt das Friends-Konzept, dass bestimmte Klassen auf alle privaten Elemente einer anderen Klasse zugreifen können. <answer> <question> Gibt es in C++ die Möglichkeit, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren? <question>"
"Ein interessantes Konzept von C++, das einen direkten Bezug zur objektorientierten Programmierung hat, ist das Friends-Konzept. In der Praxis kommt es häufig vor, dass ein bestimmtes Teilproblem nicht von einer Klasse allein, sondern nur durch das Zusammenwirken mehrerer Klassen gelöst werden kann. Während diese Klassen untereinander eng kooperieren müssen und deshalb (relativ) intime Kenntnis voneinander benötigen (das heißt, auf Elemente zugreifen können müssen, die anderen Klassen verborgen bleiben sollen), gilt das für andere Klassen nicht unbedingt. Die Schnittstelle solcher kooperierenden Klassen sollte also nicht absolut, sondern relativ zu anderen Klassen definierbar sein.
In JAVA hatte man dazu bis zur Version 8 nur die Möglichkeit, die besagten Klassen in ein Paket zu verfrachten und die fraglichen Elemente mit paketweitem Zugriff (also ohne Zugriffsmodifizierer) zu deklarieren (Abschnitt 39.1 in Kurseinheit 4). Das hat jedoch den Nachteil, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben; wenn es eine Klasse gibt, die eine ansonsten unsichtbare Eigenschaft x einer Klasse A sehen und eine andere, die eine Eigenschaft y derselben Klasse sehen soll, dann gibt es keine Aufteilung der Klassen auf Pakete, die genau dieses gestattet. Was man stattdessen gern hätte, ist ein dedizierter Export von Elementen einer Klasse, also ein zur Verfügung Stellen von Elementen an genau benannte Klassen. Dies bietet, in etwas gröberer Form, das Friends-Konzept von C++: Die Definition friend class B; friend class C; bewirkt, dass (Instanzen von) B und (von) C auf alle privat deklarierten Elemente von (Instanzen von) A zugreifen können (jedoch weder umgekehrt von A auf B und C noch B und C gegenseitig). Ein spezifischer, dedizierter Export von einzelnen Membern an bestimmte Klassen ist in C++ nicht möglich; diesen gibt es dafür in EIFFEL (s. Abschnitt 52.2). Mit JAVAs Modulen und dem dedizierten (qualifiziert genannten) Export wird das Friend-Konzept auf Ebene der Pakete zumindest angenähert.",<answer> Das Friends-Konzept wird in Java durch die Verwendung von Modulen und den dedizierten (qualifizierten) Export auf Ebene der Pakete angenähert. Dies ermöglicht eine kontrollierte Freigabe von Elementen an bestimmte Pakete. <answer> <question> Wie wird das Friends-Konzept in Java angenähert? <question>
"In SMALLTALK werden Klassen erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Dies ist notwendig, da Instanzen, für die es keine literale Repräsentation gibt, in SMALLTALK grundsätzlich über Konstruktoren erstellt werden, und jede Klasse ist eine Instanz ihrer Metaklasse. Dies wirft die Frage auf, wie Klassen in SMALLTALK tatsächlich erzeugt werden können. Allein die Existenz eines Browsers mit entsprechender Funktion erklärt dies nicht ausreichend. Andererseits kann man auch nicht einfach ""new"" oder ähnliches an die Metaklasse einer Klasse senden, da diese zu diesem Zeitpunkt noch nicht existiert. Dies führt uns in gewisser Weise zur sprichwörtlichen Frage nach dem Huhn und dem Ei – genauer gesagt, wer von beiden zuerst existieren muss.
Dieses Dilemma wird intern von SMALLTALK gelöst. Eine Klasse wird in SMALLTALK erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet.
Durch Ausführung dieser Methode wird eine neue Klasse und gleichzeitig ihre Metaklasse erstellt. Dem Kommentar kann entnommen werden, dass die neue Klasse eine Subklasse des Empfängers (einer Klasse) werden soll. Die Bedeutung dieses Vorgangs wird im Kapitel 11 näher erläutert. An dieser Stelle möchten wir uns eher der Frage widmen, welche Klassen die mit erzeugten Metaklassen als Instanzen haben.","<answer> In SMALLTALK werden Klassen erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Dies ist notwendig, da Instanzen in SMALLTALK grundsätzlich über Konstruktoren erstellt werden, und jede Klasse ist eine Instanz ihrer Metaklasse. <answer> <question> Wie werden Klassen in SMALLTALK erzeugt? <question>"
"In SMALLTALK werden Klassen erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Dies ist notwendig, da Instanzen, für die es keine literale Repräsentation gibt, in SMALLTALK grundsätzlich über Konstruktoren erstellt werden, und jede Klasse ist eine Instanz ihrer Metaklasse. Dies wirft die Frage auf, wie Klassen in SMALLTALK tatsächlich erzeugt werden können. Allein die Existenz eines Browsers mit entsprechender Funktion erklärt dies nicht ausreichend. Andererseits kann man auch nicht einfach ""new"" oder ähnliches an die Metaklasse einer Klasse senden, da diese zu diesem Zeitpunkt noch nicht existiert. Dies führt uns in gewisser Weise zur sprichwörtlichen Frage nach dem Huhn und dem Ei – genauer gesagt, wer von beiden zuerst existieren muss.
Dieses Dilemma wird intern von SMALLTALK gelöst. Eine Klasse wird in SMALLTALK erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet.
Durch Ausführung dieser Methode wird eine neue Klasse und gleichzeitig ihre Metaklasse erstellt. Dem Kommentar kann entnommen werden, dass die neue Klasse eine Subklasse des Empfängers (einer Klasse) werden soll. Die Bedeutung dieses Vorgangs wird im Kapitel 11 näher erläutert. An dieser Stelle möchten wir uns eher der Frage widmen, welche Klassen die mit erzeugten Metaklassen als Instanzen haben.","<answer> Man kann nicht einfach ""new"" oder ähnliches an die Metaklasse einer Klasse senden, da die Metaklasse zu diesem Zeitpunkt noch nicht existiert. Dies führt zu einem Dilemma, da die Frage aufkommt, ob die Klasse zuerst oder die Metaklasse zuerst erstellt werden muss. <answer> <question> Warum kann man nicht einfach ""new"" an die Metaklasse einer Klasse senden, um eine neue Klasse zu erstellen? <question>"
"In SMALLTALK werden Klassen erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Dies ist notwendig, da Instanzen, für die es keine literale Repräsentation gibt, in SMALLTALK grundsätzlich über Konstruktoren erstellt werden, und jede Klasse ist eine Instanz ihrer Metaklasse. Dies wirft die Frage auf, wie Klassen in SMALLTALK tatsächlich erzeugt werden können. Allein die Existenz eines Browsers mit entsprechender Funktion erklärt dies nicht ausreichend. Andererseits kann man auch nicht einfach ""new"" oder ähnliches an die Metaklasse einer Klasse senden, da diese zu diesem Zeitpunkt noch nicht existiert. Dies führt uns in gewisser Weise zur sprichwörtlichen Frage nach dem Huhn und dem Ei – genauer gesagt, wer von beiden zuerst existieren muss.
Dieses Dilemma wird intern von SMALLTALK gelöst. Eine Klasse wird in SMALLTALK erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet.
Durch Ausführung dieser Methode wird eine neue Klasse und gleichzeitig ihre Metaklasse erstellt. Dem Kommentar kann entnommen werden, dass die neue Klasse eine Subklasse des Empfängers (einer Klasse) werden soll. Die Bedeutung dieses Vorgangs wird im Kapitel 11 näher erläutert. An dieser Stelle möchten wir uns eher der Frage widmen, welche Klassen die mit erzeugten Metaklassen als Instanzen haben.","<answer> In SMALLTALK wird das Dilemma gelöst, indem eine Klasse in SMALLTALK erzeugt wird, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Diese Nachricht führt zur Erzeugung einer neuen Klasse und gleichzeitig ihrer Metaklasse. <answer> <question> Wie wird das Dilemma, welche Klasse zuerst erstellt werden muss, in SMALLTALK gelöst? <question>"
"In JAVA gibt es Literale für Zahlen, Zeichen und Strings. Für Arrays gibt es, da sie nicht aus Literalen zusammengesetzt sein müssen, etwas Ähnliches, nämlich die sogenannten Array-Initialisierer; sie werden in Kapitel 41 behandelt. Ob ""true"" und ""false"" bzw. ""null"" in JAVA Literale oder Schlüsselwörter sind, hängt vom Standpunkt ab: Die meisten Syntaxeditoren behandeln sie wie Schlüsselwörter, gemäß der Sprachdefinition handelt es sich jedoch um Literale, die die beiden booleschen Wahrheitswerte ""wahr"" und ""falsch"" bzw. den Wert des Nulltypen (UndefinedObject in SMALLTALK, in JAVA umbenannt) repräsentieren.
Zahlenliterale in JAVA können eine Vielzahl von Formen annehmen. Für drei besondere Werte im Fließkommabereich stehen jedoch keine Literale, sondern nur Konstanten zur Verfügung: Es handelt sich um ""NaN"" (für das englische ""Not a Number"") sowie ""POSITIVE_INFINITY"" und ""NEGATIVE_INFINITY"". Zeichenliterale werden in JAVA durch einfache Anführungsstriche eingeschlossen, String-Literale durch doppelte Anführungsstriche. Beide können Escape-Sequenzen zur Darstellung von Sonderzeichen enthalten.
Anders als in SMALLTALK sind in JAVA Klassen keine Objekte. Dennoch muss man in Programmen gelegentlich Klassen als Werte angeben. Das geht dann nicht (wie in SMALLTALK) per Angabe des Klassennamens (der dort ja zugleich als Pseudovariable definiert war), sondern mittels eines sogenannten Klassenliterals. Dieses besteht aus dem Namen der Klasse, gefolgt von "".class"", also beispielsweise ""Klasse.class"".
Der Typ eines solchen Klassenliterals ist ""Class<T>"", also im obigen Beispiel ""Class<Object>"". Da in JAVA-Programmen Klassennamen auch direkt vorkommen dürfen, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof"" (siehe Abschnitt 35.4), sind Klassenliterale eher selten anzutreffen. Die ganze Unterscheidung von Klassennamen und Klassenliteralen in JAVA ist meiner Meinung nach alles andere als glücklich.","<answer> In JAVA gibt es Literale für Zahlen, Zeichen und Strings. <answer> <question> Welche Arten von Literale gibt es in JAVA? <question>"
"In JAVA gibt es Literale für Zahlen, Zeichen und Strings. Für Arrays gibt es, da sie nicht aus Literalen zusammengesetzt sein müssen, etwas Ähnliches, nämlich die sogenannten Array-Initialisierer; sie werden in Kapitel 41 behandelt. Ob ""true"" und ""false"" bzw. ""null"" in JAVA Literale oder Schlüsselwörter sind, hängt vom Standpunkt ab: Die meisten Syntaxeditoren behandeln sie wie Schlüsselwörter, gemäß der Sprachdefinition handelt es sich jedoch um Literale, die die beiden booleschen Wahrheitswerte ""wahr"" und ""falsch"" bzw. den Wert des Nulltypen (UndefinedObject in SMALLTALK, in JAVA umbenannt) repräsentieren.
Zahlenliterale in JAVA können eine Vielzahl von Formen annehmen. Für drei besondere Werte im Fließkommabereich stehen jedoch keine Literale, sondern nur Konstanten zur Verfügung: Es handelt sich um ""NaN"" (für das englische ""Not a Number"") sowie ""POSITIVE_INFINITY"" und ""NEGATIVE_INFINITY"". Zeichenliterale werden in JAVA durch einfache Anführungsstriche eingeschlossen, String-Literale durch doppelte Anführungsstriche. Beide können Escape-Sequenzen zur Darstellung von Sonderzeichen enthalten.
Anders als in SMALLTALK sind in JAVA Klassen keine Objekte. Dennoch muss man in Programmen gelegentlich Klassen als Werte angeben. Das geht dann nicht (wie in SMALLTALK) per Angabe des Klassennamens (der dort ja zugleich als Pseudovariable definiert war), sondern mittels eines sogenannten Klassenliterals. Dieses besteht aus dem Namen der Klasse, gefolgt von "".class"", also beispielsweise ""Klasse.class"".
Der Typ eines solchen Klassenliterals ist ""Class<T>"", also im obigen Beispiel ""Class<Object>"". Da in JAVA-Programmen Klassennamen auch direkt vorkommen dürfen, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof"" (siehe Abschnitt 35.4), sind Klassenliterale eher selten anzutreffen. Die ganze Unterscheidung von Klassennamen und Klassenliteralen in JAVA ist meiner Meinung nach alles andere als glücklich.","<answer> Die drei besonderen Werte im Fließkommabereich, die keine Literale, sondern nur Konstanten in JAVA haben, sind ""NaN"" (Not a Number), ""POSITIVE_INFINITY"" und ""NEGATIVE_INFINITY"". <answer> <question> Welche drei besonderen Werte im Fließkommabereich haben keine Literale, sondern nur Konstanten in JAVA? <question>"
"In JAVA gibt es Literale für Zahlen, Zeichen und Strings. Für Arrays gibt es, da sie nicht aus Literalen zusammengesetzt sein müssen, etwas Ähnliches, nämlich die sogenannten Array-Initialisierer; sie werden in Kapitel 41 behandelt. Ob ""true"" und ""false"" bzw. ""null"" in JAVA Literale oder Schlüsselwörter sind, hängt vom Standpunkt ab: Die meisten Syntaxeditoren behandeln sie wie Schlüsselwörter, gemäß der Sprachdefinition handelt es sich jedoch um Literale, die die beiden booleschen Wahrheitswerte ""wahr"" und ""falsch"" bzw. den Wert des Nulltypen (UndefinedObject in SMALLTALK, in JAVA umbenannt) repräsentieren.
Zahlenliterale in JAVA können eine Vielzahl von Formen annehmen. Für drei besondere Werte im Fließkommabereich stehen jedoch keine Literale, sondern nur Konstanten zur Verfügung: Es handelt sich um ""NaN"" (für das englische ""Not a Number"") sowie ""POSITIVE_INFINITY"" und ""NEGATIVE_INFINITY"". Zeichenliterale werden in JAVA durch einfache Anführungsstriche eingeschlossen, String-Literale durch doppelte Anführungsstriche. Beide können Escape-Sequenzen zur Darstellung von Sonderzeichen enthalten.
Anders als in SMALLTALK sind in JAVA Klassen keine Objekte. Dennoch muss man in Programmen gelegentlich Klassen als Werte angeben. Das geht dann nicht (wie in SMALLTALK) per Angabe des Klassennamens (der dort ja zugleich als Pseudovariable definiert war), sondern mittels eines sogenannten Klassenliterals. Dieses besteht aus dem Namen der Klasse, gefolgt von "".class"", also beispielsweise ""Klasse.class"".
Der Typ eines solchen Klassenliterals ist ""Class<T>"", also im obigen Beispiel ""Class<Object>"". Da in JAVA-Programmen Klassennamen auch direkt vorkommen dürfen, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof"" (siehe Abschnitt 35.4), sind Klassenliterale eher selten anzutreffen. Die ganze Unterscheidung von Klassennamen und Klassenliteralen in JAVA ist meiner Meinung nach alles andere als glücklich.","<answer> Zeichenliterale werden in JAVA durch einfache Anführungsstriche (' ') eingeschlossen, während String-Literale durch doppelte Anführungsstriche ("" "") eingeschlossen werden. <answer> <question> Wie werden Zeichenliterale und String-Literale in JAVA dargestellt? <question>"
"In JAVA gibt es Literale für Zahlen, Zeichen und Strings. Für Arrays gibt es, da sie nicht aus Literalen zusammengesetzt sein müssen, etwas Ähnliches, nämlich die sogenannten Array-Initialisierer; sie werden in Kapitel 41 behandelt. Ob ""true"" und ""false"" bzw. ""null"" in JAVA Literale oder Schlüsselwörter sind, hängt vom Standpunkt ab: Die meisten Syntaxeditoren behandeln sie wie Schlüsselwörter, gemäß der Sprachdefinition handelt es sich jedoch um Literale, die die beiden booleschen Wahrheitswerte ""wahr"" und ""falsch"" bzw. den Wert des Nulltypen (UndefinedObject in SMALLTALK, in JAVA umbenannt) repräsentieren.
Zahlenliterale in JAVA können eine Vielzahl von Formen annehmen. Für drei besondere Werte im Fließkommabereich stehen jedoch keine Literale, sondern nur Konstanten zur Verfügung: Es handelt sich um ""NaN"" (für das englische ""Not a Number"") sowie ""POSITIVE_INFINITY"" und ""NEGATIVE_INFINITY"". Zeichenliterale werden in JAVA durch einfache Anführungsstriche eingeschlossen, String-Literale durch doppelte Anführungsstriche. Beide können Escape-Sequenzen zur Darstellung von Sonderzeichen enthalten.
Anders als in SMALLTALK sind in JAVA Klassen keine Objekte. Dennoch muss man in Programmen gelegentlich Klassen als Werte angeben. Das geht dann nicht (wie in SMALLTALK) per Angabe des Klassennamens (der dort ja zugleich als Pseudovariable definiert war), sondern mittels eines sogenannten Klassenliterals. Dieses besteht aus dem Namen der Klasse, gefolgt von "".class"", also beispielsweise ""Klasse.class"".
Der Typ eines solchen Klassenliterals ist ""Class<T>"", also im obigen Beispiel ""Class<Object>"". Da in JAVA-Programmen Klassennamen auch direkt vorkommen dürfen, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof"" (siehe Abschnitt 35.4), sind Klassenliterale eher selten anzutreffen. Die ganze Unterscheidung von Klassennamen und Klassenliteralen in JAVA ist meiner Meinung nach alles andere als glücklich.","<answer> In JAVA gibt man den Typ einer Klasse als Wert mittels eines sogenannten Klassenliterals an. Dieses besteht aus dem Namen der Klasse, gefolgt von "".class"", z. B. ""Klasse.class"". <answer> <question> Wie gibt man in JAVA den Typ einer Klasse als Wert an? <question>"
"In JAVA gibt es Literale für Zahlen, Zeichen und Strings. Für Arrays gibt es, da sie nicht aus Literalen zusammengesetzt sein müssen, etwas Ähnliches, nämlich die sogenannten Array-Initialisierer; sie werden in Kapitel 41 behandelt. Ob ""true"" und ""false"" bzw. ""null"" in JAVA Literale oder Schlüsselwörter sind, hängt vom Standpunkt ab: Die meisten Syntaxeditoren behandeln sie wie Schlüsselwörter, gemäß der Sprachdefinition handelt es sich jedoch um Literale, die die beiden booleschen Wahrheitswerte ""wahr"" und ""falsch"" bzw. den Wert des Nulltypen (UndefinedObject in SMALLTALK, in JAVA umbenannt) repräsentieren.
Zahlenliterale in JAVA können eine Vielzahl von Formen annehmen. Für drei besondere Werte im Fließkommabereich stehen jedoch keine Literale, sondern nur Konstanten zur Verfügung: Es handelt sich um ""NaN"" (für das englische ""Not a Number"") sowie ""POSITIVE_INFINITY"" und ""NEGATIVE_INFINITY"". Zeichenliterale werden in JAVA durch einfache Anführungsstriche eingeschlossen, String-Literale durch doppelte Anführungsstriche. Beide können Escape-Sequenzen zur Darstellung von Sonderzeichen enthalten.
Anders als in SMALLTALK sind in JAVA Klassen keine Objekte. Dennoch muss man in Programmen gelegentlich Klassen als Werte angeben. Das geht dann nicht (wie in SMALLTALK) per Angabe des Klassennamens (der dort ja zugleich als Pseudovariable definiert war), sondern mittels eines sogenannten Klassenliterals. Dieses besteht aus dem Namen der Klasse, gefolgt von "".class"", also beispielsweise ""Klasse.class"".
Der Typ eines solchen Klassenliterals ist ""Class<T>"", also im obigen Beispiel ""Class<Object>"". Da in JAVA-Programmen Klassennamen auch direkt vorkommen dürfen, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof"" (siehe Abschnitt 35.4), sind Klassenliterale eher selten anzutreffen. Die ganze Unterscheidung von Klassennamen und Klassenliteralen in JAVA ist meiner Meinung nach alles andere als glücklich.","<answer> Der Typ eines Klassenliterals in JAVA ist ""Class<T>"", wobei T der Typ der Klasse ist. Zum Beispiel hat ""Class<Object>"" den Typ ""Class<Object>"". <answer> <question> Welcher Typ hat ein Klassenliteral in JAVA? <question>"
"In JAVA gibt es Literale für Zahlen, Zeichen und Strings. Für Arrays gibt es, da sie nicht aus Literalen zusammengesetzt sein müssen, etwas Ähnliches, nämlich die sogenannten Array-Initialisierer; sie werden in Kapitel 41 behandelt. Ob ""true"" und ""false"" bzw. ""null"" in JAVA Literale oder Schlüsselwörter sind, hängt vom Standpunkt ab: Die meisten Syntaxeditoren behandeln sie wie Schlüsselwörter, gemäß der Sprachdefinition handelt es sich jedoch um Literale, die die beiden booleschen Wahrheitswerte ""wahr"" und ""falsch"" bzw. den Wert des Nulltypen (UndefinedObject in SMALLTALK, in JAVA umbenannt) repräsentieren.
Zahlenliterale in JAVA können eine Vielzahl von Formen annehmen. Für drei besondere Werte im Fließkommabereich stehen jedoch keine Literale, sondern nur Konstanten zur Verfügung: Es handelt sich um ""NaN"" (für das englische ""Not a Number"") sowie ""POSITIVE_INFINITY"" und ""NEGATIVE_INFINITY"". Zeichenliterale werden in JAVA durch einfache Anführungsstriche eingeschlossen, String-Literale durch doppelte Anführungsstriche. Beide können Escape-Sequenzen zur Darstellung von Sonderzeichen enthalten.
Anders als in SMALLTALK sind in JAVA Klassen keine Objekte. Dennoch muss man in Programmen gelegentlich Klassen als Werte angeben. Das geht dann nicht (wie in SMALLTALK) per Angabe des Klassennamens (der dort ja zugleich als Pseudovariable definiert war), sondern mittels eines sogenannten Klassenliterals. Dieses besteht aus dem Namen der Klasse, gefolgt von "".class"", also beispielsweise ""Klasse.class"".
Der Typ eines solchen Klassenliterals ist ""Class<T>"", also im obigen Beispiel ""Class<Object>"". Da in JAVA-Programmen Klassennamen auch direkt vorkommen dürfen, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof"" (siehe Abschnitt 35.4), sind Klassenliterale eher selten anzutreffen. Die ganze Unterscheidung von Klassennamen und Klassenliteralen in JAVA ist meiner Meinung nach alles andere als glücklich.","<answer> Klassenliterale sind in JAVA eher selten anzutreffen, da Klassennamen auch direkt in JAVA-Programmen verwendet werden können, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie ""instanceof"". <answer> <question> Warum sind Klassenliterale in JAVA eher selten anzutreffen? <question>"
"Einhergehend mit der Trennung zwischen primitiven und Referenztypen gibt es in JAVA auch eine Trennung zwischen Operationen und Methoden: Auf den primitiven Typen sind bestimmte Operationen, wie mathematische und boolesche Operationen, fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Da primitive Typen jedoch keine Klassen sind, gibt es beispielsweise für mathematische Funktionen eine spezielle Klasse namens Math, in der Funktionen wie sin(.) als Klassenmethoden hinterlegt sind. Umgekehrt ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren, wie es bei den binären Methoden in SMALLTALK der Fall ist (siehe Abschnitt 4.1.2 in Kurseinheit 1). Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von JAVA als Programmiersprache geprägt hat. Anfangs führte dies zu ihrem Ruf als hybride Programmiersprache, die sowohl objektorientierte als auch imperative Eigenschaften aufweist. Aus meiner Sicht ist die Unterscheidung zwischen Objekten und Werten, wie sie in JAVA vorgenommen wurde, jedoch sinnvoll: Werte besitzen weder Identität noch Zustand, daher unterscheiden sie sich von Objekten.
Die Methoden in JAVA können in Prozeduren und Funktionen unterteilt werden, wobei der einzige Unterschied darin besteht, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp ""void"" deklarieren. Dies ist eine der vielen Erbschaften aus der Programmiersprache C.
Ein Operator, der speziell für Referenztypen in JAVA zur Verfügung steht, ist der Typtest ""instanceof"". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist. Dabei wird nicht zwischen direkten und indirekten Instanzen unterschieden. Zum Beispiel ergibt ""x instanceof Object"" immer ""true"", unabhängig davon, für welches Objekt ""x"" steht. Weitere Informationen zur Bedeutung des Typtests finden Sie in Kapitel 44.","<answer> In JAVA gibt es eine Trennung zwischen Operationen, die auf primitiven Typen fest vorgegeben sind, und Methoden, die in Klassen definiert werden müssen. <answer> <question> Welche Trennung gibt es in JAVA zwischen Operationen und Methoden? <question>"
"Einhergehend mit der Trennung zwischen primitiven und Referenztypen gibt es in JAVA auch eine Trennung zwischen Operationen und Methoden: Auf den primitiven Typen sind bestimmte Operationen, wie mathematische und boolesche Operationen, fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Da primitive Typen jedoch keine Klassen sind, gibt es beispielsweise für mathematische Funktionen eine spezielle Klasse namens Math, in der Funktionen wie sin(.) als Klassenmethoden hinterlegt sind. Umgekehrt ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren, wie es bei den binären Methoden in SMALLTALK der Fall ist (siehe Abschnitt 4.1.2 in Kurseinheit 1). Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von JAVA als Programmiersprache geprägt hat. Anfangs führte dies zu ihrem Ruf als hybride Programmiersprache, die sowohl objektorientierte als auch imperative Eigenschaften aufweist. Aus meiner Sicht ist die Unterscheidung zwischen Objekten und Werten, wie sie in JAVA vorgenommen wurde, jedoch sinnvoll: Werte besitzen weder Identität noch Zustand, daher unterscheiden sie sich von Objekten.
Die Methoden in JAVA können in Prozeduren und Funktionen unterteilt werden, wobei der einzige Unterschied darin besteht, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp ""void"" deklarieren. Dies ist eine der vielen Erbschaften aus der Programmiersprache C.
Ein Operator, der speziell für Referenztypen in JAVA zur Verfügung steht, ist der Typtest ""instanceof"". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist. Dabei wird nicht zwischen direkten und indirekten Instanzen unterschieden. Zum Beispiel ergibt ""x instanceof Object"" immer ""true"", unabhängig davon, für welches Objekt ""x"" steht. Weitere Informationen zur Bedeutung des Typtests finden Sie in Kapitel 44.","<answer> Die primitiven Typen in JAVA sind keine Klassen, daher werden mathematische Funktionen wie sin(.) in der speziellen Klasse Math als Klassenmethoden definiert. <answer> <question> Warum gibt es für mathematische Funktionen in JAVA die spezielle Klasse Math? <question>"
"Einhergehend mit der Trennung zwischen primitiven und Referenztypen gibt es in JAVA auch eine Trennung zwischen Operationen und Methoden: Auf den primitiven Typen sind bestimmte Operationen, wie mathematische und boolesche Operationen, fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Da primitive Typen jedoch keine Klassen sind, gibt es beispielsweise für mathematische Funktionen eine spezielle Klasse namens Math, in der Funktionen wie sin(.) als Klassenmethoden hinterlegt sind. Umgekehrt ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren, wie es bei den binären Methoden in SMALLTALK der Fall ist (siehe Abschnitt 4.1.2 in Kurseinheit 1). Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von JAVA als Programmiersprache geprägt hat. Anfangs führte dies zu ihrem Ruf als hybride Programmiersprache, die sowohl objektorientierte als auch imperative Eigenschaften aufweist. Aus meiner Sicht ist die Unterscheidung zwischen Objekten und Werten, wie sie in JAVA vorgenommen wurde, jedoch sinnvoll: Werte besitzen weder Identität noch Zustand, daher unterscheiden sie sich von Objekten.
Die Methoden in JAVA können in Prozeduren und Funktionen unterteilt werden, wobei der einzige Unterschied darin besteht, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp ""void"" deklarieren. Dies ist eine der vielen Erbschaften aus der Programmiersprache C.
Ein Operator, der speziell für Referenztypen in JAVA zur Verfügung steht, ist der Typtest ""instanceof"". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist. Dabei wird nicht zwischen direkten und indirekten Instanzen unterschieden. Zum Beispiel ergibt ""x instanceof Object"" immer ""true"", unabhängig davon, für welches Objekt ""x"" steht. Weitere Informationen zur Bedeutung des Typtests finden Sie in Kapitel 44.","<answer> Nein, in JAVA ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren wie es bei den binären Methoden in SMALLTALK der Fall ist. <answer> <question> Können Klassendefinitionen in JAVA Operatoren definieren? <question>"
"Einhergehend mit der Trennung zwischen primitiven und Referenztypen gibt es in JAVA auch eine Trennung zwischen Operationen und Methoden: Auf den primitiven Typen sind bestimmte Operationen, wie mathematische und boolesche Operationen, fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Da primitive Typen jedoch keine Klassen sind, gibt es beispielsweise für mathematische Funktionen eine spezielle Klasse namens Math, in der Funktionen wie sin(.) als Klassenmethoden hinterlegt sind. Umgekehrt ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren, wie es bei den binären Methoden in SMALLTALK der Fall ist (siehe Abschnitt 4.1.2 in Kurseinheit 1). Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von JAVA als Programmiersprache geprägt hat. Anfangs führte dies zu ihrem Ruf als hybride Programmiersprache, die sowohl objektorientierte als auch imperative Eigenschaften aufweist. Aus meiner Sicht ist die Unterscheidung zwischen Objekten und Werten, wie sie in JAVA vorgenommen wurde, jedoch sinnvoll: Werte besitzen weder Identität noch Zustand, daher unterscheiden sie sich von Objekten.
Die Methoden in JAVA können in Prozeduren und Funktionen unterteilt werden, wobei der einzige Unterschied darin besteht, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp ""void"" deklarieren. Dies ist eine der vielen Erbschaften aus der Programmiersprache C.
Ein Operator, der speziell für Referenztypen in JAVA zur Verfügung steht, ist der Typtest ""instanceof"". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist. Dabei wird nicht zwischen direkten und indirekten Instanzen unterschieden. Zum Beispiel ergibt ""x instanceof Object"" immer ""true"", unabhängig davon, für welches Objekt ""x"" steht. Weitere Informationen zur Bedeutung des Typtests finden Sie in Kapitel 44.","<answer> In JAVA können Methoden in Prozeduren und Funktionen unterteilt werden. Der einzige Unterschied besteht darin, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp ""void"" deklarieren. <answer> <question> Was ist der Unterschied zwischen Prozeduren und Funktionen in JAVA? <question>"
"Einhergehend mit der Trennung zwischen primitiven und Referenztypen gibt es in JAVA auch eine Trennung zwischen Operationen und Methoden: Auf den primitiven Typen sind bestimmte Operationen, wie mathematische und boolesche Operationen, fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Da primitive Typen jedoch keine Klassen sind, gibt es beispielsweise für mathematische Funktionen eine spezielle Klasse namens Math, in der Funktionen wie sin(.) als Klassenmethoden hinterlegt sind. Umgekehrt ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren, wie es bei den binären Methoden in SMALLTALK der Fall ist (siehe Abschnitt 4.1.2 in Kurseinheit 1). Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von JAVA als Programmiersprache geprägt hat. Anfangs führte dies zu ihrem Ruf als hybride Programmiersprache, die sowohl objektorientierte als auch imperative Eigenschaften aufweist. Aus meiner Sicht ist die Unterscheidung zwischen Objekten und Werten, wie sie in JAVA vorgenommen wurde, jedoch sinnvoll: Werte besitzen weder Identität noch Zustand, daher unterscheiden sie sich von Objekten.
Die Methoden in JAVA können in Prozeduren und Funktionen unterteilt werden, wobei der einzige Unterschied darin besteht, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp ""void"" deklarieren. Dies ist eine der vielen Erbschaften aus der Programmiersprache C.
Ein Operator, der speziell für Referenztypen in JAVA zur Verfügung steht, ist der Typtest ""instanceof"". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist. Dabei wird nicht zwischen direkten und indirekten Instanzen unterschieden. Zum Beispiel ergibt ""x instanceof Object"" immer ""true"", unabhängig davon, für welches Objekt ""x"" steht. Weitere Informationen zur Bedeutung des Typtests finden Sie in Kapitel 44.","<answer> Ein Operator, der speziell für Referenztypen in JAVA zur Verfügung steht, ist der Typtest ""instanceof"". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist. <answer> <question> Welcher Operator steht speziell für Referenztypen in JAVA zur Verfügung? <question>"
"Methoden sind immer Objekten, den sogenannten Empfängerobjekten, zugeordnet. In dieser Kurseinheit werden wir uns nicht darauf festlegen, wie diese Zuordnung erfolgt. Sie dürfen jedoch davon ausgehen, dass jedes Objekt über einen Katalog von Methoden verfügt und somit auf die entsprechenden Nachrichten reagieren kann. Diesen Katalog nennt man auch das Protokoll eines Objekts (siehe Abschnitt 4.3.8).
Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen. Da der Zustand eines Objekts durch die Belegung seiner Instanzvariablen repräsentiert wird (siehe Kapitel 3) und weil in den Methoden das Verhalten eines Objekts spezifiziert ist, ergibt sich, dass das Verhalten vom Zustand des Objekts abhängt (durch Berücksichtigung seiner Instanzvariablen) und es gleichzeitig beeinflussen kann (durch Zuweisungen an die Instanzvariablen). Da Instanzvariablen lokale Variablen sind (lokal zum besitzenden Objekt), sind Methoden sogar die einzige Stelle, an der der Zustand von Objekten geändert werden kann. Mehr dazu in Abschnitt 4.3.4.
Neben den formalen Parametern der Methode und den Instanzvariablen des Empfängerobjekts ist im Rumpf jeder Methode eine weitere Variable zugreifbar, die den Namen ""self"" trägt. Diese Variable, die wie die formalen Parameter eine Pseudovariable ist, verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird immer dann benötigt, wenn eine Nachricht aus einer Methode heraus (also per darin enthaltener Anweisung) an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. ""self"" ist somit gewissermaßen der implizite erste Parameter einer Methode.","<answer> Methoden sind immer Objekten, den sogenannten Empfängerobjekten, zugeordnet. <answer> <question> Wie werden Methoden in SMALLTALK den Objekten zugeordnet? <question>"
"Methoden sind immer Objekten, den sogenannten Empfängerobjekten, zugeordnet. In dieser Kurseinheit werden wir uns nicht darauf festlegen, wie diese Zuordnung erfolgt. Sie dürfen jedoch davon ausgehen, dass jedes Objekt über einen Katalog von Methoden verfügt und somit auf die entsprechenden Nachrichten reagieren kann. Diesen Katalog nennt man auch das Protokoll eines Objekts (siehe Abschnitt 4.3.8).
Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen. Da der Zustand eines Objekts durch die Belegung seiner Instanzvariablen repräsentiert wird (siehe Kapitel 3) und weil in den Methoden das Verhalten eines Objekts spezifiziert ist, ergibt sich, dass das Verhalten vom Zustand des Objekts abhängt (durch Berücksichtigung seiner Instanzvariablen) und es gleichzeitig beeinflussen kann (durch Zuweisungen an die Instanzvariablen). Da Instanzvariablen lokale Variablen sind (lokal zum besitzenden Objekt), sind Methoden sogar die einzige Stelle, an der der Zustand von Objekten geändert werden kann. Mehr dazu in Abschnitt 4.3.4.
Neben den formalen Parametern der Methode und den Instanzvariablen des Empfängerobjekts ist im Rumpf jeder Methode eine weitere Variable zugreifbar, die den Namen ""self"" trägt. Diese Variable, die wie die formalen Parameter eine Pseudovariable ist, verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird immer dann benötigt, wenn eine Nachricht aus einer Methode heraus (also per darin enthaltener Anweisung) an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. ""self"" ist somit gewissermaßen der implizite erste Parameter einer Methode.","<answer> Das Protokoll eines Objekts ist der Katalog von Methoden, über den ein Objekt verfügt und auf den es entsprechend reagieren kann. <answer> <question> Was ist das Protokoll eines Objekts? <question>"
"Methoden sind immer Objekten, den sogenannten Empfängerobjekten, zugeordnet. In dieser Kurseinheit werden wir uns nicht darauf festlegen, wie diese Zuordnung erfolgt. Sie dürfen jedoch davon ausgehen, dass jedes Objekt über einen Katalog von Methoden verfügt und somit auf die entsprechenden Nachrichten reagieren kann. Diesen Katalog nennt man auch das Protokoll eines Objekts (siehe Abschnitt 4.3.8).
Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen. Da der Zustand eines Objekts durch die Belegung seiner Instanzvariablen repräsentiert wird (siehe Kapitel 3) und weil in den Methoden das Verhalten eines Objekts spezifiziert ist, ergibt sich, dass das Verhalten vom Zustand des Objekts abhängt (durch Berücksichtigung seiner Instanzvariablen) und es gleichzeitig beeinflussen kann (durch Zuweisungen an die Instanzvariablen). Da Instanzvariablen lokale Variablen sind (lokal zum besitzenden Objekt), sind Methoden sogar die einzige Stelle, an der der Zustand von Objekten geändert werden kann. Mehr dazu in Abschnitt 4.3.4.
Neben den formalen Parametern der Methode und den Instanzvariablen des Empfängerobjekts ist im Rumpf jeder Methode eine weitere Variable zugreifbar, die den Namen ""self"" trägt. Diese Variable, die wie die formalen Parameter eine Pseudovariable ist, verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird immer dann benötigt, wenn eine Nachricht aus einer Methode heraus (also per darin enthaltener Anweisung) an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. ""self"" ist somit gewissermaßen der implizite erste Parameter einer Methode.","<answer> Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen und somit das Verhalten des Objekts zu spezifizieren und zu beeinflussen. <answer> <question> Warum ist die Zuordnung von Methoden zu Objekten wichtig? <question>"
"Methoden sind immer Objekten, den sogenannten Empfängerobjekten, zugeordnet. In dieser Kurseinheit werden wir uns nicht darauf festlegen, wie diese Zuordnung erfolgt. Sie dürfen jedoch davon ausgehen, dass jedes Objekt über einen Katalog von Methoden verfügt und somit auf die entsprechenden Nachrichten reagieren kann. Diesen Katalog nennt man auch das Protokoll eines Objekts (siehe Abschnitt 4.3.8).
Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen. Da der Zustand eines Objekts durch die Belegung seiner Instanzvariablen repräsentiert wird (siehe Kapitel 3) und weil in den Methoden das Verhalten eines Objekts spezifiziert ist, ergibt sich, dass das Verhalten vom Zustand des Objekts abhängt (durch Berücksichtigung seiner Instanzvariablen) und es gleichzeitig beeinflussen kann (durch Zuweisungen an die Instanzvariablen). Da Instanzvariablen lokale Variablen sind (lokal zum besitzenden Objekt), sind Methoden sogar die einzige Stelle, an der der Zustand von Objekten geändert werden kann. Mehr dazu in Abschnitt 4.3.4.
Neben den formalen Parametern der Methode und den Instanzvariablen des Empfängerobjekts ist im Rumpf jeder Methode eine weitere Variable zugreifbar, die den Namen ""self"" trägt. Diese Variable, die wie die formalen Parameter eine Pseudovariable ist, verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird immer dann benötigt, wenn eine Nachricht aus einer Methode heraus (also per darin enthaltener Anweisung) an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. ""self"" ist somit gewissermaßen der implizite erste Parameter einer Methode.","<answer> Die Variable ""self"" verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird benötigt, wenn eine Nachricht aus einer Methode heraus an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. ""self"" ist somit der implizite erste Parameter einer Methode. <answer> <question> Welche Rolle spielt die Variable ""self"" in Methoden? <question>"
"Ähnlich wie bei der Klassifikation kann man das Prinzip der Generalisierung umkehren. Man spricht dann von der Spezialisierung. Während die Generalisierung Eigenschaften weglässt oder generalisiert (Abstraktion), fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene. Man kann also von jeder Klasse sagen, dass sie eine Spezialisierung ihrer Generalisierungen ist (sofern sie welche hat).
Dass eine Generalisierung bereits über Spezialisierungen verfügt, hindert eine Klasse nicht daran, neue hinzuzufügen. So ist es beispielsweise im obigen Beispiel von ""Zweibeiner"" denkbar, dass man im Nachhinein noch ""Menschenaffe"" als Spezialisierung ergänzt. Als Unterscheidungsmerkmal könnte z. B. eine Methode ""klettern"" dienen, die Mensch und Vogel fehlt. Sie zu ergänzen stellt überhaupt kein Problem dar - ja, es ist sogar eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind. Mehr dazu in Kapitel 26 in Kurseinheit 3.
Leider ist es in der Programmierpraxis nicht immer ganz so einfach. Oftmals findet man Klassen (bzw. Instanzen), die ungefähr das tun, was man möchte, und denen man nur noch ein wenig hinzufügen möchte. Man möchte dann von einer Klasse spezialisieren, die selbst keine Generalisierung im oben genannten Sinne ist.
Ähnlich wie bei der Generalisierung ist es bei der Spezialisierung auch möglich, dies ohne das Hinzufügen von Eigenschaften zu erreichen, nämlich durch das Beschränken von Eigenschaften. So kann z. B. bei der Spezialisierung von ""Säugetier"" zu ""Zweibeiner"" der Wertebereich der Instanzvariable ""anzahlBeine"" von {2, 4} (also entweder zwei oder vier) auf {2} (also nur noch zwei) eingeschränkt werden. Die sprachlichen Möglichkeiten, dies auf Klassendefinitionsebene auszudrücken, sind allerdings in SMALLTALK (wie bereits im Zusammenhang mit der Generalisierung erwähnt) nicht gegeben; diese kommen erst mit der Typisierung von Variablen (Kapitel 18 in Kurseinheit 3). Die Beschränkung des Wertebereichs durch Spezialisierung ist jedoch in jedem Fall von der Instanziierung zu unterscheiden, bei der (gegebenenfalls durch Initialisierung) einer Instanzvariable eines Objekts ein Element aus dem Wertebereich (wie z. B. 2) zugewiesen wird. Dass im Fall von ""Zweibeiner"" dafür nur noch ein Element als Wert in Frage kommt, spielt dabei keine Rolle.
Vollkommen unvereinbar mit der Spezialisierung ist übrigens das Entfernen von Instanzvariablen oder Methoden. Dies ergibt sich schon daraus, dass die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Die Richtung von Spezialisierung und Generalisierung würde zudem, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte, beliebig werden.","<answer> Spezialisierung ist das Gegenteil von Generalisierung in der objektorientierten Programmierung. Während bei der Generalisierung Eigenschaften weggelassen oder verallgemeinert werden, fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene Eigenschaften von Klassen. Es bedeutet, dass eine Klasse eine Spezialisierung ihrer Generalisierungen sein kann, wenn sie zusätzliche Merkmale oder Verhaltensweisen hinzufügt. <answer> <question> Was ist Spezialisierung in Bezug auf die objektorientierte Programmierung? <question>"
"Ähnlich wie bei der Klassifikation kann man das Prinzip der Generalisierung umkehren. Man spricht dann von der Spezialisierung. Während die Generalisierung Eigenschaften weglässt oder generalisiert (Abstraktion), fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene. Man kann also von jeder Klasse sagen, dass sie eine Spezialisierung ihrer Generalisierungen ist (sofern sie welche hat).
Dass eine Generalisierung bereits über Spezialisierungen verfügt, hindert eine Klasse nicht daran, neue hinzuzufügen. So ist es beispielsweise im obigen Beispiel von ""Zweibeiner"" denkbar, dass man im Nachhinein noch ""Menschenaffe"" als Spezialisierung ergänzt. Als Unterscheidungsmerkmal könnte z. B. eine Methode ""klettern"" dienen, die Mensch und Vogel fehlt. Sie zu ergänzen stellt überhaupt kein Problem dar - ja, es ist sogar eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind. Mehr dazu in Kapitel 26 in Kurseinheit 3.
Leider ist es in der Programmierpraxis nicht immer ganz so einfach. Oftmals findet man Klassen (bzw. Instanzen), die ungefähr das tun, was man möchte, und denen man nur noch ein wenig hinzufügen möchte. Man möchte dann von einer Klasse spezialisieren, die selbst keine Generalisierung im oben genannten Sinne ist.
Ähnlich wie bei der Generalisierung ist es bei der Spezialisierung auch möglich, dies ohne das Hinzufügen von Eigenschaften zu erreichen, nämlich durch das Beschränken von Eigenschaften. So kann z. B. bei der Spezialisierung von ""Säugetier"" zu ""Zweibeiner"" der Wertebereich der Instanzvariable ""anzahlBeine"" von {2, 4} (also entweder zwei oder vier) auf {2} (also nur noch zwei) eingeschränkt werden. Die sprachlichen Möglichkeiten, dies auf Klassendefinitionsebene auszudrücken, sind allerdings in SMALLTALK (wie bereits im Zusammenhang mit der Generalisierung erwähnt) nicht gegeben; diese kommen erst mit der Typisierung von Variablen (Kapitel 18 in Kurseinheit 3). Die Beschränkung des Wertebereichs durch Spezialisierung ist jedoch in jedem Fall von der Instanziierung zu unterscheiden, bei der (gegebenenfalls durch Initialisierung) einer Instanzvariable eines Objekts ein Element aus dem Wertebereich (wie z. B. 2) zugewiesen wird. Dass im Fall von ""Zweibeiner"" dafür nur noch ein Element als Wert in Frage kommt, spielt dabei keine Rolle.
Vollkommen unvereinbar mit der Spezialisierung ist übrigens das Entfernen von Instanzvariablen oder Methoden. Dies ergibt sich schon daraus, dass die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Die Richtung von Spezialisierung und Generalisierung würde zudem, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte, beliebig werden.","<answer> Spezialisierung ermöglicht es, bestehende Klassen um spezifische Eigenschaften oder Verhaltensweisen zu erweitern, ohne andere Teile des Programms zu beeinflussen. Dies fördert die Modularität und die Möglichkeit zur Erweiterung von Klassen, was eine der Stärken der objektorientierten Programmierung ist. <answer> <question> Warum ist die Spezialisierung in der objektorientierten Programmierung wichtig? <question>"
"Ähnlich wie bei der Klassifikation kann man das Prinzip der Generalisierung umkehren. Man spricht dann von der Spezialisierung. Während die Generalisierung Eigenschaften weglässt oder generalisiert (Abstraktion), fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene. Man kann also von jeder Klasse sagen, dass sie eine Spezialisierung ihrer Generalisierungen ist (sofern sie welche hat).
Dass eine Generalisierung bereits über Spezialisierungen verfügt, hindert eine Klasse nicht daran, neue hinzuzufügen. So ist es beispielsweise im obigen Beispiel von ""Zweibeiner"" denkbar, dass man im Nachhinein noch ""Menschenaffe"" als Spezialisierung ergänzt. Als Unterscheidungsmerkmal könnte z. B. eine Methode ""klettern"" dienen, die Mensch und Vogel fehlt. Sie zu ergänzen stellt überhaupt kein Problem dar - ja, es ist sogar eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind. Mehr dazu in Kapitel 26 in Kurseinheit 3.
Leider ist es in der Programmierpraxis nicht immer ganz so einfach. Oftmals findet man Klassen (bzw. Instanzen), die ungefähr das tun, was man möchte, und denen man nur noch ein wenig hinzufügen möchte. Man möchte dann von einer Klasse spezialisieren, die selbst keine Generalisierung im oben genannten Sinne ist.
Ähnlich wie bei der Generalisierung ist es bei der Spezialisierung auch möglich, dies ohne das Hinzufügen von Eigenschaften zu erreichen, nämlich durch das Beschränken von Eigenschaften. So kann z. B. bei der Spezialisierung von ""Säugetier"" zu ""Zweibeiner"" der Wertebereich der Instanzvariable ""anzahlBeine"" von {2, 4} (also entweder zwei oder vier) auf {2} (also nur noch zwei) eingeschränkt werden. Die sprachlichen Möglichkeiten, dies auf Klassendefinitionsebene auszudrücken, sind allerdings in SMALLTALK (wie bereits im Zusammenhang mit der Generalisierung erwähnt) nicht gegeben; diese kommen erst mit der Typisierung von Variablen (Kapitel 18 in Kurseinheit 3). Die Beschränkung des Wertebereichs durch Spezialisierung ist jedoch in jedem Fall von der Instanziierung zu unterscheiden, bei der (gegebenenfalls durch Initialisierung) einer Instanzvariable eines Objekts ein Element aus dem Wertebereich (wie z. B. 2) zugewiesen wird. Dass im Fall von ""Zweibeiner"" dafür nur noch ein Element als Wert in Frage kommt, spielt dabei keine Rolle.
Vollkommen unvereinbar mit der Spezialisierung ist übrigens das Entfernen von Instanzvariablen oder Methoden. Dies ergibt sich schon daraus, dass die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Die Richtung von Spezialisierung und Generalisierung würde zudem, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte, beliebig werden.","<answer> Ja, es gibt Einschränkungen bei der Spezialisierung von Klassen. Das Entfernen von Instanzvariablen oder Methoden ist vollkommen unvereinbar mit der Spezialisierung, da dies die Umkehrung der Spezialisierung, die Generalisierung, verhindern würde. Es ist jedoch möglich, Eigenschaften durch Beschränkungen zu ändern oder hinzuzufügen, aber das Entfernen ist nicht erlaubt. <answer> <question> Gibt es Einschränkungen bei der Spezialisierung von Klassen? <question>"
"Ähnlich wie bei der Klassifikation kann man das Prinzip der Generalisierung umkehren. Man spricht dann von der Spezialisierung. Während die Generalisierung Eigenschaften weglässt oder generalisiert (Abstraktion), fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene. Man kann also von jeder Klasse sagen, dass sie eine Spezialisierung ihrer Generalisierungen ist (sofern sie welche hat).
Dass eine Generalisierung bereits über Spezialisierungen verfügt, hindert eine Klasse nicht daran, neue hinzuzufügen. So ist es beispielsweise im obigen Beispiel von ""Zweibeiner"" denkbar, dass man im Nachhinein noch ""Menschenaffe"" als Spezialisierung ergänzt. Als Unterscheidungsmerkmal könnte z. B. eine Methode ""klettern"" dienen, die Mensch und Vogel fehlt. Sie zu ergänzen stellt überhaupt kein Problem dar - ja, es ist sogar eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind. Mehr dazu in Kapitel 26 in Kurseinheit 3.
Leider ist es in der Programmierpraxis nicht immer ganz so einfach. Oftmals findet man Klassen (bzw. Instanzen), die ungefähr das tun, was man möchte, und denen man nur noch ein wenig hinzufügen möchte. Man möchte dann von einer Klasse spezialisieren, die selbst keine Generalisierung im oben genannten Sinne ist.
Ähnlich wie bei der Generalisierung ist es bei der Spezialisierung auch möglich, dies ohne das Hinzufügen von Eigenschaften zu erreichen, nämlich durch das Beschränken von Eigenschaften. So kann z. B. bei der Spezialisierung von ""Säugetier"" zu ""Zweibeiner"" der Wertebereich der Instanzvariable ""anzahlBeine"" von {2, 4} (also entweder zwei oder vier) auf {2} (also nur noch zwei) eingeschränkt werden. Die sprachlichen Möglichkeiten, dies auf Klassendefinitionsebene auszudrücken, sind allerdings in SMALLTALK (wie bereits im Zusammenhang mit der Generalisierung erwähnt) nicht gegeben; diese kommen erst mit der Typisierung von Variablen (Kapitel 18 in Kurseinheit 3). Die Beschränkung des Wertebereichs durch Spezialisierung ist jedoch in jedem Fall von der Instanziierung zu unterscheiden, bei der (gegebenenfalls durch Initialisierung) einer Instanzvariable eines Objekts ein Element aus dem Wertebereich (wie z. B. 2) zugewiesen wird. Dass im Fall von ""Zweibeiner"" dafür nur noch ein Element als Wert in Frage kommt, spielt dabei keine Rolle.
Vollkommen unvereinbar mit der Spezialisierung ist übrigens das Entfernen von Instanzvariablen oder Methoden. Dies ergibt sich schon daraus, dass die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Die Richtung von Spezialisierung und Generalisierung würde zudem, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte, beliebig werden.","<answer> Das Problem der Spezialisierung von Klassen kann elegant gelöst werden, indem parallel zur spezialisierten Klasse eine Klasse ""NichtSpezialisierteKlasse"" eingeführt wird. Alle Eigenschaften, die andere Instanzen von derselben Generalisierung unterscheiden, können in der ""NichtSpezialisierteKlasse"" platziert werden. Dadurch bleibt die Hierarchie sauber und ermöglicht eine klare Unterscheidung zwischen spezialisierten und nicht spezialisierten Klassen. <answer> <question> Wie kann man das Problem der Spezialisierung von Klassen elegant lösen? <question>"
"In JAVA ist die Typkonformität und damit die Zuweisungskompatibilität unter Referenztypen an Subtyping gebunden. Damit Ausdrücke von einem Typ Variablen eines anderen zugeordnet werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen den beiden bestehen. In den meisten Fällen muss die Subtypbeziehung explizit deklariert werden; JAVA setzt also auf nominale Typkonformität. Dies hat den Vorteil der Filterfunktion, wie in Abschnitt 22.2 von Kurseinheit 3 beschrieben, aber auch den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen. Dies kann insbesondere bei verteilten Anwendungen problematisch sein, deren Teile nicht von vornherein für einander entworfen wurden (zum Beispiel Web Services).
Weiterhin verlangt das Subtyping in JAVA, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen. JAVA verlangt also Kovarianz. Dadurch wird zumindest eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt (vergleiche Abschnitt 26.3 und Kapitel 54 in Kurseinheit 6). Allerdings kann der Rückgabetyp von Methoden kovariant redefiniert werden; mehr dazu in Abschnitt 36.4.
Im Gegensatz zu ihren Vorläufern SMALLTALK und C++ ist JAVA eine Sprache mit einem strengen Typsystem. Das bedeutet insbesondere, dass in JAVA alle Typfehler entweder schon während der Übersetzung durch den Compiler oder während der Laufzeit, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung (bei der eine Typinvariante verletzt wird), erkannt werden. In einem Fall kann jedoch die Meinung vertreten werden, dass die Typinvarianten in JAVA zu lasch sind und Zuweisungen gestattet werden, bei denen nicht ausgeschlossen werden kann, dass sie später zu einem Typfehler führen. Hierzu mehr in Kapitel 41.",<answer> Die Typkonformität und die Zuweisungskompatibilität unter Referenztypen in JAVA sind an das Konzept des Subtypings gebunden. <answer> <question> An welches Konzept in JAVA ist die Typkonformität und die Zuweisungskompatibilität unter Referenztypen gebunden? <question>
"In JAVA ist die Typkonformität und damit die Zuweisungskompatibilität unter Referenztypen an Subtyping gebunden. Damit Ausdrücke von einem Typ Variablen eines anderen zugeordnet werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen den beiden bestehen. In den meisten Fällen muss die Subtypbeziehung explizit deklariert werden; JAVA setzt also auf nominale Typkonformität. Dies hat den Vorteil der Filterfunktion, wie in Abschnitt 22.2 von Kurseinheit 3 beschrieben, aber auch den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen. Dies kann insbesondere bei verteilten Anwendungen problematisch sein, deren Teile nicht von vornherein für einander entworfen wurden (zum Beispiel Web Services).
Weiterhin verlangt das Subtyping in JAVA, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen. JAVA verlangt also Kovarianz. Dadurch wird zumindest eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt (vergleiche Abschnitt 26.3 und Kapitel 54 in Kurseinheit 6). Allerdings kann der Rückgabetyp von Methoden kovariant redefiniert werden; mehr dazu in Abschnitt 36.4.
Im Gegensatz zu ihren Vorläufern SMALLTALK und C++ ist JAVA eine Sprache mit einem strengen Typsystem. Das bedeutet insbesondere, dass in JAVA alle Typfehler entweder schon während der Übersetzung durch den Compiler oder während der Laufzeit, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung (bei der eine Typinvariante verletzt wird), erkannt werden. In einem Fall kann jedoch die Meinung vertreten werden, dass die Typinvarianten in JAVA zu lasch sind und Zuweisungen gestattet werden, bei denen nicht ausgeschlossen werden kann, dass sie später zu einem Typfehler führen. Hierzu mehr in Kapitel 41.","<answer> Damit Ausdrücke von einem Typ Variablen eines anderen Typs zugewiesen werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen ihnen bestehen. <answer> <question> Welche Beziehung müssen die Typen in JAVA haben, damit Ausdrücke von einem Typ Variablen eines anderen Typs zugewiesen werden können? <question>"
"In JAVA ist die Typkonformität und damit die Zuweisungskompatibilität unter Referenztypen an Subtyping gebunden. Damit Ausdrücke von einem Typ Variablen eines anderen zugeordnet werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen den beiden bestehen. In den meisten Fällen muss die Subtypbeziehung explizit deklariert werden; JAVA setzt also auf nominale Typkonformität. Dies hat den Vorteil der Filterfunktion, wie in Abschnitt 22.2 von Kurseinheit 3 beschrieben, aber auch den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen. Dies kann insbesondere bei verteilten Anwendungen problematisch sein, deren Teile nicht von vornherein für einander entworfen wurden (zum Beispiel Web Services).
Weiterhin verlangt das Subtyping in JAVA, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen. JAVA verlangt also Kovarianz. Dadurch wird zumindest eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt (vergleiche Abschnitt 26.3 und Kapitel 54 in Kurseinheit 6). Allerdings kann der Rückgabetyp von Methoden kovariant redefiniert werden; mehr dazu in Abschnitt 36.4.
Im Gegensatz zu ihren Vorläufern SMALLTALK und C++ ist JAVA eine Sprache mit einem strengen Typsystem. Das bedeutet insbesondere, dass in JAVA alle Typfehler entweder schon während der Übersetzung durch den Compiler oder während der Laufzeit, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung (bei der eine Typinvariante verletzt wird), erkannt werden. In einem Fall kann jedoch die Meinung vertreten werden, dass die Typinvarianten in JAVA zu lasch sind und Zuweisungen gestattet werden, bei denen nicht ausgeschlossen werden kann, dass sie später zu einem Typfehler führen. Hierzu mehr in Kapitel 41.","<answer> Nominale Typkonformität bedeutet, dass die Subtypbeziehung explizit deklariert werden muss. Dies hat den Vorteil der Filterfunktion, aber den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen, was bei verteilten Anwendungen problematisch sein kann. <answer> <question> Was ist nominale Typkonformität, und welche Vor- und Nachteile hat sie? <question>"
"In JAVA ist die Typkonformität und damit die Zuweisungskompatibilität unter Referenztypen an Subtyping gebunden. Damit Ausdrücke von einem Typ Variablen eines anderen zugeordnet werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen den beiden bestehen. In den meisten Fällen muss die Subtypbeziehung explizit deklariert werden; JAVA setzt also auf nominale Typkonformität. Dies hat den Vorteil der Filterfunktion, wie in Abschnitt 22.2 von Kurseinheit 3 beschrieben, aber auch den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen. Dies kann insbesondere bei verteilten Anwendungen problematisch sein, deren Teile nicht von vornherein für einander entworfen wurden (zum Beispiel Web Services).
Weiterhin verlangt das Subtyping in JAVA, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen. JAVA verlangt also Kovarianz. Dadurch wird zumindest eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt (vergleiche Abschnitt 26.3 und Kapitel 54 in Kurseinheit 6). Allerdings kann der Rückgabetyp von Methoden kovariant redefiniert werden; mehr dazu in Abschnitt 36.4.
Im Gegensatz zu ihren Vorläufern SMALLTALK und C++ ist JAVA eine Sprache mit einem strengen Typsystem. Das bedeutet insbesondere, dass in JAVA alle Typfehler entweder schon während der Übersetzung durch den Compiler oder während der Laufzeit, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung (bei der eine Typinvariante verletzt wird), erkannt werden. In einem Fall kann jedoch die Meinung vertreten werden, dass die Typinvarianten in JAVA zu lasch sind und Zuweisungen gestattet werden, bei denen nicht ausgeschlossen werden kann, dass sie später zu einem Typfehler führen. Hierzu mehr in Kapitel 41.","<answer> JAVA verlangt, dass die Typen geerbter Variablen nicht verändert werden dürfen. Dies wird als Kovarianz bezeichnet. <answer> <question> Welche Anforderung stellt JAVA an geerbte Variablen (Felder und Parametertypen von Methoden)? <question>"
"In JAVA ist die Typkonformität und damit die Zuweisungskompatibilität unter Referenztypen an Subtyping gebunden. Damit Ausdrücke von einem Typ Variablen eines anderen zugeordnet werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen den beiden bestehen. In den meisten Fällen muss die Subtypbeziehung explizit deklariert werden; JAVA setzt also auf nominale Typkonformität. Dies hat den Vorteil der Filterfunktion, wie in Abschnitt 22.2 von Kurseinheit 3 beschrieben, aber auch den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen. Dies kann insbesondere bei verteilten Anwendungen problematisch sein, deren Teile nicht von vornherein für einander entworfen wurden (zum Beispiel Web Services).
Weiterhin verlangt das Subtyping in JAVA, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen. JAVA verlangt also Kovarianz. Dadurch wird zumindest eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt (vergleiche Abschnitt 26.3 und Kapitel 54 in Kurseinheit 6). Allerdings kann der Rückgabetyp von Methoden kovariant redefiniert werden; mehr dazu in Abschnitt 36.4.
Im Gegensatz zu ihren Vorläufern SMALLTALK und C++ ist JAVA eine Sprache mit einem strengen Typsystem. Das bedeutet insbesondere, dass in JAVA alle Typfehler entweder schon während der Übersetzung durch den Compiler oder während der Laufzeit, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung (bei der eine Typinvariante verletzt wird), erkannt werden. In einem Fall kann jedoch die Meinung vertreten werden, dass die Typinvarianten in JAVA zu lasch sind und Zuweisungen gestattet werden, bei denen nicht ausgeschlossen werden kann, dass sie später zu einem Typfehler führen. Hierzu mehr in Kapitel 41.","<answer> Ja, JAVA ist eine Sprache mit einem strengen Typsystem, was bedeutet, dass alle Typfehler entweder während der Übersetzung durch den Compiler oder während der Laufzeit erkannt werden, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung, bei der eine Typinvariante verletzt wird. <answer> <question> Ist JAVA eine Sprache mit einem strengen Typsystem, und was bedeutet das? <question>"
"Wenn das Versenden von Nachrichten bisher als die Übergabe eines entsprechenden Nachrichtenobjekts an den Empfänger dargestellt wurde, ist das nicht ganz korrekt. Vielmehr wird ein Nachrichtenausdruck auch in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung (wie z.B. in PASCAL oder C) vergleichbar ist.
Dennoch wird das Mysterium des Nachrichtenversands in der objektorientierten Literatur aus didaktischen Gründen weiter gepflegt. Es gibt jedoch auch einen kleinen, feinen Unterschied zum gewöhnlichen Prozeduraufruf.
Die Entscheidung darüber, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Es ist nämlich durchaus üblich, dass verschiedene Objekte mit gleichen Methodensignaturen unterschiedliche Methodenimplementierungen verbinden. Beispielsweise implementieren Zahlen und Symbole die Methode ""printString"" jeweils anders. Somit führt der Ausdruck ""1 + 2"" zu einem anderen Methodenaufruf als ""a + b"", wenn ""a"" und ""b"" unterschiedliche Objekte sind.
Aus der Abhängigkeit des Methodenaufrufs vom Empfängerobjekt folgt, dass nicht immer schon zur Übersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgewählt werden muss. Dies geschieht erst zur Laufzeit, wenn das Empfängerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird. Dies nennt man dynamisches Binden (im Gegensatz zum statischen Binden, bei dem ein Aufruf schon zur Übersetzungszeit an eine Implementierung gebunden wird). Das dynamische Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung und wird auch als Polymorphismus oder Polymorphie bezeichnet. Details dazu werden in den nächsten Kapiteln erläutert.
Nachdem festgelegt wurde, welche Methode aufgerufen wird, erfolgt die Zuweisung der formalen Parameter mit Objekten. Dies geschieht durch eine implizite Zuweisung der tatsächlichen Parameter des Aufrufs an die formalen Parameter der Methode. Die tatsächlichen Parameter sind die Objekte, die an der Stelle des Methodenaufrufs als Argumente stehen. Je nach Sichtweise kann bei der Ausführung einer Return-Anweisung eine weitere implizite Zuweisung erfolgen, wobei das Ergebnis des Ausdrucks der Return-Anweisung der ""Variable"" des Methodennamens zugewiesen wird.
Es ist jedoch zu beachten, dass formale Parameter in SMALLTALK Pseudovariablen sind und daher keine explizite Zuweisung an sie erlaubt ist (außer bei der impliziten Zuweisung beim Aufruf).
Was passiert, wenn ein Methodenaufruf ins Leere läuft, ist ebenfalls von Interesse. Da in SMALLTALK Ausdrücke beliebige Objekte liefern können, kann der Compiler nicht garantieren, dass das Empfängerobjekt tatsächlich über eine entsprechende Methode verfügt. In solchen Fällen wird der Methodenaufruf in einen Aufruf der Methode ""doesNotUnderstand:"" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung wie ""<Objekt> does not understand: <Nachrichtenselektor>"". Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren.","<answer> Ein Nachrichtenausdruck wird in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung vergleichbar ist. <answer> <question> Wie wird ein Nachrichtenausdruck in SMALLTALK aus Effizienzgründen übersetzt? <question>"
"Wenn das Versenden von Nachrichten bisher als die Übergabe eines entsprechenden Nachrichtenobjekts an den Empfänger dargestellt wurde, ist das nicht ganz korrekt. Vielmehr wird ein Nachrichtenausdruck auch in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung (wie z.B. in PASCAL oder C) vergleichbar ist.
Dennoch wird das Mysterium des Nachrichtenversands in der objektorientierten Literatur aus didaktischen Gründen weiter gepflegt. Es gibt jedoch auch einen kleinen, feinen Unterschied zum gewöhnlichen Prozeduraufruf.
Die Entscheidung darüber, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Es ist nämlich durchaus üblich, dass verschiedene Objekte mit gleichen Methodensignaturen unterschiedliche Methodenimplementierungen verbinden. Beispielsweise implementieren Zahlen und Symbole die Methode ""printString"" jeweils anders. Somit führt der Ausdruck ""1 + 2"" zu einem anderen Methodenaufruf als ""a + b"", wenn ""a"" und ""b"" unterschiedliche Objekte sind.
Aus der Abhängigkeit des Methodenaufrufs vom Empfängerobjekt folgt, dass nicht immer schon zur Übersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgewählt werden muss. Dies geschieht erst zur Laufzeit, wenn das Empfängerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird. Dies nennt man dynamisches Binden (im Gegensatz zum statischen Binden, bei dem ein Aufruf schon zur Übersetzungszeit an eine Implementierung gebunden wird). Das dynamische Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung und wird auch als Polymorphismus oder Polymorphie bezeichnet. Details dazu werden in den nächsten Kapiteln erläutert.
Nachdem festgelegt wurde, welche Methode aufgerufen wird, erfolgt die Zuweisung der formalen Parameter mit Objekten. Dies geschieht durch eine implizite Zuweisung der tatsächlichen Parameter des Aufrufs an die formalen Parameter der Methode. Die tatsächlichen Parameter sind die Objekte, die an der Stelle des Methodenaufrufs als Argumente stehen. Je nach Sichtweise kann bei der Ausführung einer Return-Anweisung eine weitere implizite Zuweisung erfolgen, wobei das Ergebnis des Ausdrucks der Return-Anweisung der ""Variable"" des Methodennamens zugewiesen wird.
Es ist jedoch zu beachten, dass formale Parameter in SMALLTALK Pseudovariablen sind und daher keine explizite Zuweisung an sie erlaubt ist (außer bei der impliziten Zuweisung beim Aufruf).
Was passiert, wenn ein Methodenaufruf ins Leere läuft, ist ebenfalls von Interesse. Da in SMALLTALK Ausdrücke beliebige Objekte liefern können, kann der Compiler nicht garantieren, dass das Empfängerobjekt tatsächlich über eine entsprechende Methode verfügt. In solchen Fällen wird der Methodenaufruf in einen Aufruf der Methode ""doesNotUnderstand:"" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung wie ""<Objekt> does not understand: <Nachrichtenselektor>"". Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren.","<answer> Die Auswahl der Methode, die aufgerufen wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Verschiedene Objekte mit gleichen Methodensignaturen können unterschiedliche Methodenimplementierungen haben. <answer> <question> Warum hängt die Auswahl der Methode, die aufgerufen wird, nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt ab? <question>"
"Wenn das Versenden von Nachrichten bisher als die Übergabe eines entsprechenden Nachrichtenobjekts an den Empfänger dargestellt wurde, ist das nicht ganz korrekt. Vielmehr wird ein Nachrichtenausdruck auch in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung (wie z.B. in PASCAL oder C) vergleichbar ist.
Dennoch wird das Mysterium des Nachrichtenversands in der objektorientierten Literatur aus didaktischen Gründen weiter gepflegt. Es gibt jedoch auch einen kleinen, feinen Unterschied zum gewöhnlichen Prozeduraufruf.
Die Entscheidung darüber, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Es ist nämlich durchaus üblich, dass verschiedene Objekte mit gleichen Methodensignaturen unterschiedliche Methodenimplementierungen verbinden. Beispielsweise implementieren Zahlen und Symbole die Methode ""printString"" jeweils anders. Somit führt der Ausdruck ""1 + 2"" zu einem anderen Methodenaufruf als ""a + b"", wenn ""a"" und ""b"" unterschiedliche Objekte sind.
Aus der Abhängigkeit des Methodenaufrufs vom Empfängerobjekt folgt, dass nicht immer schon zur Übersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgewählt werden muss. Dies geschieht erst zur Laufzeit, wenn das Empfängerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird. Dies nennt man dynamisches Binden (im Gegensatz zum statischen Binden, bei dem ein Aufruf schon zur Übersetzungszeit an eine Implementierung gebunden wird). Das dynamische Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung und wird auch als Polymorphismus oder Polymorphie bezeichnet. Details dazu werden in den nächsten Kapiteln erläutert.
Nachdem festgelegt wurde, welche Methode aufgerufen wird, erfolgt die Zuweisung der formalen Parameter mit Objekten. Dies geschieht durch eine implizite Zuweisung der tatsächlichen Parameter des Aufrufs an die formalen Parameter der Methode. Die tatsächlichen Parameter sind die Objekte, die an der Stelle des Methodenaufrufs als Argumente stehen. Je nach Sichtweise kann bei der Ausführung einer Return-Anweisung eine weitere implizite Zuweisung erfolgen, wobei das Ergebnis des Ausdrucks der Return-Anweisung der ""Variable"" des Methodennamens zugewiesen wird.
Es ist jedoch zu beachten, dass formale Parameter in SMALLTALK Pseudovariablen sind und daher keine explizite Zuweisung an sie erlaubt ist (außer bei der impliziten Zuweisung beim Aufruf).
Was passiert, wenn ein Methodenaufruf ins Leere läuft, ist ebenfalls von Interesse. Da in SMALLTALK Ausdrücke beliebige Objekte liefern können, kann der Compiler nicht garantieren, dass das Empfängerobjekt tatsächlich über eine entsprechende Methode verfügt. In solchen Fällen wird der Methodenaufruf in einen Aufruf der Methode ""doesNotUnderstand:"" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung wie ""<Objekt> does not understand: <Nachrichtenselektor>"". Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren.","<answer> Dynamisches Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung, bei der die Auswahl der Methodenimplementierung erst zur Laufzeit erfolgt, abhängig vom Empfängerobjekt des Methodenaufrufs. Dies wird auch als Polymorphismus oder Polymorphie bezeichnet. <answer> <question> Was versteht man unter dynamischem Binden in der objektorientierten Programmierung? <question>"
"Wenn das Versenden von Nachrichten bisher als die Übergabe eines entsprechenden Nachrichtenobjekts an den Empfänger dargestellt wurde, ist das nicht ganz korrekt. Vielmehr wird ein Nachrichtenausdruck auch in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung (wie z.B. in PASCAL oder C) vergleichbar ist.
Dennoch wird das Mysterium des Nachrichtenversands in der objektorientierten Literatur aus didaktischen Gründen weiter gepflegt. Es gibt jedoch auch einen kleinen, feinen Unterschied zum gewöhnlichen Prozeduraufruf.
Die Entscheidung darüber, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Es ist nämlich durchaus üblich, dass verschiedene Objekte mit gleichen Methodensignaturen unterschiedliche Methodenimplementierungen verbinden. Beispielsweise implementieren Zahlen und Symbole die Methode ""printString"" jeweils anders. Somit führt der Ausdruck ""1 + 2"" zu einem anderen Methodenaufruf als ""a + b"", wenn ""a"" und ""b"" unterschiedliche Objekte sind.
Aus der Abhängigkeit des Methodenaufrufs vom Empfängerobjekt folgt, dass nicht immer schon zur Übersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgewählt werden muss. Dies geschieht erst zur Laufzeit, wenn das Empfängerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird. Dies nennt man dynamisches Binden (im Gegensatz zum statischen Binden, bei dem ein Aufruf schon zur Übersetzungszeit an eine Implementierung gebunden wird). Das dynamische Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung und wird auch als Polymorphismus oder Polymorphie bezeichnet. Details dazu werden in den nächsten Kapiteln erläutert.
Nachdem festgelegt wurde, welche Methode aufgerufen wird, erfolgt die Zuweisung der formalen Parameter mit Objekten. Dies geschieht durch eine implizite Zuweisung der tatsächlichen Parameter des Aufrufs an die formalen Parameter der Methode. Die tatsächlichen Parameter sind die Objekte, die an der Stelle des Methodenaufrufs als Argumente stehen. Je nach Sichtweise kann bei der Ausführung einer Return-Anweisung eine weitere implizite Zuweisung erfolgen, wobei das Ergebnis des Ausdrucks der Return-Anweisung der ""Variable"" des Methodennamens zugewiesen wird.
Es ist jedoch zu beachten, dass formale Parameter in SMALLTALK Pseudovariablen sind und daher keine explizite Zuweisung an sie erlaubt ist (außer bei der impliziten Zuweisung beim Aufruf).
Was passiert, wenn ein Methodenaufruf ins Leere läuft, ist ebenfalls von Interesse. Da in SMALLTALK Ausdrücke beliebige Objekte liefern können, kann der Compiler nicht garantieren, dass das Empfängerobjekt tatsächlich über eine entsprechende Methode verfügt. In solchen Fällen wird der Methodenaufruf in einen Aufruf der Methode ""doesNotUnderstand:"" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung wie ""<Objekt> does not understand: <Nachrichtenselektor>"". Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren.",<answer> Die Zuweisung der formalen Parameter erfolgt in einer Methode durch eine implizite Zuweisung der tatsächlichen Parameter des Methodenaufrufs an die formalen Parameter der Methode. <answer> <question> Wie erfolgt die Zuweisung der formalen Parameter in einer Methode? <question>
"Wenn das Versenden von Nachrichten bisher als die Übergabe eines entsprechenden Nachrichtenobjekts an den Empfänger dargestellt wurde, ist das nicht ganz korrekt. Vielmehr wird ein Nachrichtenausdruck auch in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung (wie z.B. in PASCAL oder C) vergleichbar ist.
Dennoch wird das Mysterium des Nachrichtenversands in der objektorientierten Literatur aus didaktischen Gründen weiter gepflegt. Es gibt jedoch auch einen kleinen, feinen Unterschied zum gewöhnlichen Prozeduraufruf.
Die Entscheidung darüber, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Es ist nämlich durchaus üblich, dass verschiedene Objekte mit gleichen Methodensignaturen unterschiedliche Methodenimplementierungen verbinden. Beispielsweise implementieren Zahlen und Symbole die Methode ""printString"" jeweils anders. Somit führt der Ausdruck ""1 + 2"" zu einem anderen Methodenaufruf als ""a + b"", wenn ""a"" und ""b"" unterschiedliche Objekte sind.
Aus der Abhängigkeit des Methodenaufrufs vom Empfängerobjekt folgt, dass nicht immer schon zur Übersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgewählt werden muss. Dies geschieht erst zur Laufzeit, wenn das Empfängerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird. Dies nennt man dynamisches Binden (im Gegensatz zum statischen Binden, bei dem ein Aufruf schon zur Übersetzungszeit an eine Implementierung gebunden wird). Das dynamische Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung und wird auch als Polymorphismus oder Polymorphie bezeichnet. Details dazu werden in den nächsten Kapiteln erläutert.
Nachdem festgelegt wurde, welche Methode aufgerufen wird, erfolgt die Zuweisung der formalen Parameter mit Objekten. Dies geschieht durch eine implizite Zuweisung der tatsächlichen Parameter des Aufrufs an die formalen Parameter der Methode. Die tatsächlichen Parameter sind die Objekte, die an der Stelle des Methodenaufrufs als Argumente stehen. Je nach Sichtweise kann bei der Ausführung einer Return-Anweisung eine weitere implizite Zuweisung erfolgen, wobei das Ergebnis des Ausdrucks der Return-Anweisung der ""Variable"" des Methodennamens zugewiesen wird.
Es ist jedoch zu beachten, dass formale Parameter in SMALLTALK Pseudovariablen sind und daher keine explizite Zuweisung an sie erlaubt ist (außer bei der impliziten Zuweisung beim Aufruf).
Was passiert, wenn ein Methodenaufruf ins Leere läuft, ist ebenfalls von Interesse. Da in SMALLTALK Ausdrücke beliebige Objekte liefern können, kann der Compiler nicht garantieren, dass das Empfängerobjekt tatsächlich über eine entsprechende Methode verfügt. In solchen Fällen wird der Methodenaufruf in einen Aufruf der Methode ""doesNotUnderstand:"" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung wie ""<Objekt> does not understand: <Nachrichtenselektor>"". Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren.","<answer> Wenn ein Methodenaufruf ins Leere läuft, wird er in einen Aufruf der Methode ""doesNotUnderstand:"" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung, die besagt, dass das Objekt die Nachricht nicht versteht. Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren. <answer> <question> Was passiert, wenn ein Methodenaufruf in SMALLTALK ins Leere läuft? <question>"
"Das Fragile Base-Class-Problem bezieht sich auf eine ganze Familie von Problemen, die eng mit der Vererbung zusammenhängen. Der Name ist insofern etwas irreführend, als nicht unbedingt die Basisklassen, also die Superklassen (siehe Abschnitt 11.1), als ""anfällig"" oder ""zerbrechlich"" gelten, sondern eher die Klassen, die von ihnen erben. Ein einfaches Beispiel soll verdeutlichen, um was es geht.
Angenommen, wir haben eine Klasse namens TapeArchive geschrieben, die Videobänder archiviert. Da es sich nicht um eine einfache Desktop-Anwendung handelt, sondern um ein kommerzielles System, erfolgt die Datenhaltung in einer Datenbank. Die folgende SMALLTALK-Klassendefinition gibt einen kleinen Einblick in das System:
In der objektorientierten Programmierung ist es üblich, solche Klassen wiederzuverwenden, indem man von ihnen neue Klassen ableitet. Wenn beispielsweise eine Anforderung von Kunden besteht, bei jeder Archivierung eine Nachricht zu senden, und diese Anforderung nicht für alle Kunden der Software gleichermaßen interessant ist, dann schreibt man eine Subklasse, die dieses geänderte Verhalten bereitstellt.
Das Schöne an der Objektorientierung ist dabei, dass man nur die Unterschiede (Differentia) spezifizieren muss, der Rest wird einfach geerbt. Im gegebenen Fall genügt es, die Initialisierung und die Methode addTape: anzupassen. Das Verhalten von addAllTapes: kann unverändert bleiben, da es die (dynamisch gebundene) Methode addTape: aufruft und somit auch das von NotifyingTapeArchive geforderte Verhalten, nämlich die Benachrichtigung aller archivierten Bänder, garantiert.
Das Problem ist jedoch, dass man der Klasse TapeArchive nicht ansieht, was sie garantiert oder wovon die Korrektheit ihrer Subklassen abhängt. Wenn später eine andere Kundin bemängelt, dass das Hinzufügen großer Mengen von Bändern zu lange dauert, und das wiederholte Aufrufen von addTape: aus addAllTapes: als Ursache identifiziert, könnte sie vorschlagen, nicht nur die nörgelnde Kundin, sondern alle Kundinnen mit der optimierten Implementierung von TapeArchive zu beglücken. Das klingt verlockend, aber hier liegt bereits das Problem.
Vermutlich können die meisten von Ihnen nicht sofort sagen, was dagegen spricht, denn in der Klasse TapeArchive scheint alles in Ordnung zu sein. Der Fehler liegt darin, dass die Korrektheit der Methode addAllTapes: davon abhängt, dass sie addTape: aufruft - nicht unbedingt für die Klasse TapeArchive selbst, aber für ihre Subklasse NotifyingTapeArchive. Hier werden nun nur noch für einzeln archivierte Bänder Benachrichtigungen verschickt. Hätten Sie diesen Fehler vorhergesehen? Wahrscheinlich nicht, da die Täuschung darin besteht, dass addAllTapes: in TapeArchive die Methode addTape: der benachbarten Methode aufruft. Wenn Sie den Aufruf von addTape: in addAllTapes: entfernen und nur den Beitrag von addTape: in addAllTapes: verlagern, wäre dies eine semantikerhaltende Umstrukturierung (ein sogenanntes Refactoring). Allerdings beraubt dies die Subklassen der Möglichkeit, eigenes Verhalten genau an dieser Stelle, dem Aufruf von addTape:, einzubringen. Wenn diese Beraubung im Nachhinein erfolgt, kann sie den Code ""zerbrechen"".
Das Problem ist, dass nicht einmal klar ist, wem die Schuld zuzuweisen ist - TapeArchive, weil es einen Vertrag bricht, den es nicht abgeschlossen hat (oder weil es keine Rücksicht auf Subklassen nimmt, die es nicht kennt), oder NotifyingTapeArchive, weil es sich grundlos darauf verlässt, dass die geerbten Methoden dauerhaft die eigenen Methoden aufrufen? Wenn die Schuld nicht einmal feststeht, wie kann man das Problem verhindern?
Es gibt zahlreiche Varianten des Fragile Base-Class-Problems, die hier nicht alle aufgeführt werden sollen. Ihnen allen ist gemeinsam, dass zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, die nur unvollständig dokumentiert sind. Es könnte angenommen werden, dass von allem, was vererbt wird, eine Abhängigkeit ausgeht, die bei Änderungen berücksichtigt werden muss. Dies würde jedoch die Möglichkeiten, in Superklassen Änderungen vorzunehmen, so stark einschränken, dass das gesamte Konzept ad absurdum geführt würde. Es bleibt daher wenig mehr, als bei der Verwendung von Vererbung äußerst vorsichtig zu sein oder sie gänzlich zu verbieten.
Die Vererbung von Implementierung - die Fähigkeit, eine Komponente von einer anderen Komponente abzuleiten oder Teile ihrer Funktionalität zu erben - ist eine sehr nützliche Technologie zum Erstellen von Anwendungen. Die Vererbung von Implementierung kann jedoch viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen.
Das Problem bei der Vererbung von Implementierung besteht darin, dass der ""Vertrag"" oder die Beziehung zwischen Komponenten in einer Implementierungshierarchie nicht klar definiert ist. Sie ist implizit und mehrdeutig. Wenn die Eltern- oder Kindkomponente unerwartet ihr Verhalten ändert, kann dies zu undefiniertem Verhalten verwandter Komponenten führen. Dies ist kein Problem, wenn die Implementierungshierarchie von einer definierten Gruppe von Programmierern kontrolliert wird, die Updates an allen Komponenten gleichzeitig vornehmen können. Genau diese Fähigkeit zur Kontrolle und Änderung einer Gruppe von verwandten Komponenten unterscheidet jedoch eine Anwendung, selbst eine komplexe Anwendung, von einem echten verteilten Objektsystem. Daher kann die Implementierungsvererbung zwar sehr nützlich sein, um Anwendungen zu erstellen, ist jedoch nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert.
In einem System, das aus Komponenten verschiedener Anbieter besteht, ist es entscheidend, dass ein bestimmter Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet. Um dies zu erreichen, muss die tatsächliche Schnittstelle auf der von solchen Clients verwendeten Komponente für beide Parteien kristallklar sein. Andernfalls, wie kann der Komponentenanbieter sicherstellen, dass er diese Schnittstelle beibehält und somit die bestehenden Clients nicht stört?
Übertragen auf die objektorientierte Programmierung besteht das Problem darin, dass der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen. Die Vererbung von Implementierung wurde aus der Spezifikation von Microsofts Component Object Model (COM) verbannt und durch die Vererbung von Schnittstellen (was als Subtyping bezeichnet wird) ersetzt. Trotzdem bleiben Vorbehalte gegenüber dem dynamischen Binden bestehen.
Es liegt nahe, in Bezug auf die Vererbung das zu tun, was man bei Abhängigkeiten immer tut: Schnittstellen einführen. Im Gegensatz zu der Schnittstelle, die einem Client einer Klasse angeboten wird (der diese Schnittstelle nutzt, indem er seine Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann), handelt es sich bei der Schnittstelle zwischen einer Klasse und ihren Subklassen jedoch um eine etwas anders geartete. Hier gibt es lediglich zwei Variablen, self (oder this) und super, die jedoch keine Abhängigkeit von anderen Objekten ausdrücken und nicht explizit typisiert sind. Die damit verbundene Schnittstelle, also die Menge der Eigenschaften, auf die man über diese Variable zugreifen kann, und wo man diese Eigenschaften findet (also wo sie definiert sind), muss man selbst zusammensuchen. Dies hat nichts mit Information Hiding und dem Verbergen von Implementationsdetails zu tun. Was stattdessen benötigt wird, ist ein explizites Vererbungsinterface.
Einige erste Ansätze zur Einführung expliziter Vererbungsinterfaces wurden bereits gesehen, wie die Verwendung des Zugriffsmodifikators protected in Java, C# und C++ sowie die explizite Deklaration von Überschreibbarkeit und Überschreibung mittels virtual und override in C# (und C++). Im obigen Beispiel würde die Deklaration von addTape: als nicht überschreibbar (und somit als statisch gebunden, nicht dynamisch gebunden) verhindern, dass NotifyingTapeArchive diese Methode ändert und sich darauf verlässt, dass die geerbte Methode addAllTapes: die überschreibende Version von addTape: aufruft (obwohl sie sie immer noch neu einführen könnte, würde diese neue Version bei der Bindung in addAllTapes: nicht berücksichtigt). NotifyingTapeArchive müsste dann beide Methoden neu implementieren und sicherstellen, dass addAllTapes: keinen Fehler macht. Dies hätte jedoch zur Folge, dass bei einem direkten Aufruf von addTape: von außerhalb auf einer Variable vom Typ TapeArchive, die eine Instanz vom Typ NotifyingTapeArchive hält, die überschreibende Implementierung ignoriert wird (da keine dynamische Bindung mehr stattfindet). Im Gegensatz dazu würde die Verwendung von virtual bei addTape: in TapeArchive darauf hinweisen, dass die Methode in Subklassen relevante Modifikationen enthalten kann, so dass Aufrufe dieser Methode nicht einfach gekürzt werden können, wie im obigen Beispiel geschehen.
Bei der Definition von Java wurde dies jedoch nicht berücksichtigt. Der Zugriffsmodifikator protected, virtual und override sind mehr als Symbole für das Bewusstsein, dass es das Fragile Base-Class-Problem gibt.","<answer> Das Fragile Base-Class-Problem bezieht sich auf eine Gruppe von Problemen in der Vererbung von Klassen. Der Name ist etwas irreführend, da nicht unbedingt die Basisklassen, sondern eher die abgeleiteten Klassen als ""anfällig"" oder ""zerbrechlich"" gelten. <answer> <question> Was ist das Fragile Base-Class-Problem, und warum ist der Name etwas irreführend? <question>"
"Das Fragile Base-Class-Problem bezieht sich auf eine ganze Familie von Problemen, die eng mit der Vererbung zusammenhängen. Der Name ist insofern etwas irreführend, als nicht unbedingt die Basisklassen, also die Superklassen (siehe Abschnitt 11.1), als ""anfällig"" oder ""zerbrechlich"" gelten, sondern eher die Klassen, die von ihnen erben. Ein einfaches Beispiel soll verdeutlichen, um was es geht.
Angenommen, wir haben eine Klasse namens TapeArchive geschrieben, die Videobänder archiviert. Da es sich nicht um eine einfache Desktop-Anwendung handelt, sondern um ein kommerzielles System, erfolgt die Datenhaltung in einer Datenbank. Die folgende SMALLTALK-Klassendefinition gibt einen kleinen Einblick in das System:
In der objektorientierten Programmierung ist es üblich, solche Klassen wiederzuverwenden, indem man von ihnen neue Klassen ableitet. Wenn beispielsweise eine Anforderung von Kunden besteht, bei jeder Archivierung eine Nachricht zu senden, und diese Anforderung nicht für alle Kunden der Software gleichermaßen interessant ist, dann schreibt man eine Subklasse, die dieses geänderte Verhalten bereitstellt.
Das Schöne an der Objektorientierung ist dabei, dass man nur die Unterschiede (Differentia) spezifizieren muss, der Rest wird einfach geerbt. Im gegebenen Fall genügt es, die Initialisierung und die Methode addTape: anzupassen. Das Verhalten von addAllTapes: kann unverändert bleiben, da es die (dynamisch gebundene) Methode addTape: aufruft und somit auch das von NotifyingTapeArchive geforderte Verhalten, nämlich die Benachrichtigung aller archivierten Bänder, garantiert.
Das Problem ist jedoch, dass man der Klasse TapeArchive nicht ansieht, was sie garantiert oder wovon die Korrektheit ihrer Subklassen abhängt. Wenn später eine andere Kundin bemängelt, dass das Hinzufügen großer Mengen von Bändern zu lange dauert, und das wiederholte Aufrufen von addTape: aus addAllTapes: als Ursache identifiziert, könnte sie vorschlagen, nicht nur die nörgelnde Kundin, sondern alle Kundinnen mit der optimierten Implementierung von TapeArchive zu beglücken. Das klingt verlockend, aber hier liegt bereits das Problem.
Vermutlich können die meisten von Ihnen nicht sofort sagen, was dagegen spricht, denn in der Klasse TapeArchive scheint alles in Ordnung zu sein. Der Fehler liegt darin, dass die Korrektheit der Methode addAllTapes: davon abhängt, dass sie addTape: aufruft - nicht unbedingt für die Klasse TapeArchive selbst, aber für ihre Subklasse NotifyingTapeArchive. Hier werden nun nur noch für einzeln archivierte Bänder Benachrichtigungen verschickt. Hätten Sie diesen Fehler vorhergesehen? Wahrscheinlich nicht, da die Täuschung darin besteht, dass addAllTapes: in TapeArchive die Methode addTape: der benachbarten Methode aufruft. Wenn Sie den Aufruf von addTape: in addAllTapes: entfernen und nur den Beitrag von addTape: in addAllTapes: verlagern, wäre dies eine semantikerhaltende Umstrukturierung (ein sogenanntes Refactoring). Allerdings beraubt dies die Subklassen der Möglichkeit, eigenes Verhalten genau an dieser Stelle, dem Aufruf von addTape:, einzubringen. Wenn diese Beraubung im Nachhinein erfolgt, kann sie den Code ""zerbrechen"".
Das Problem ist, dass nicht einmal klar ist, wem die Schuld zuzuweisen ist - TapeArchive, weil es einen Vertrag bricht, den es nicht abgeschlossen hat (oder weil es keine Rücksicht auf Subklassen nimmt, die es nicht kennt), oder NotifyingTapeArchive, weil es sich grundlos darauf verlässt, dass die geerbten Methoden dauerhaft die eigenen Methoden aufrufen? Wenn die Schuld nicht einmal feststeht, wie kann man das Problem verhindern?
Es gibt zahlreiche Varianten des Fragile Base-Class-Problems, die hier nicht alle aufgeführt werden sollen. Ihnen allen ist gemeinsam, dass zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, die nur unvollständig dokumentiert sind. Es könnte angenommen werden, dass von allem, was vererbt wird, eine Abhängigkeit ausgeht, die bei Änderungen berücksichtigt werden muss. Dies würde jedoch die Möglichkeiten, in Superklassen Änderungen vorzunehmen, so stark einschränken, dass das gesamte Konzept ad absurdum geführt würde. Es bleibt daher wenig mehr, als bei der Verwendung von Vererbung äußerst vorsichtig zu sein oder sie gänzlich zu verbieten.
Die Vererbung von Implementierung - die Fähigkeit, eine Komponente von einer anderen Komponente abzuleiten oder Teile ihrer Funktionalität zu erben - ist eine sehr nützliche Technologie zum Erstellen von Anwendungen. Die Vererbung von Implementierung kann jedoch viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen.
Das Problem bei der Vererbung von Implementierung besteht darin, dass der ""Vertrag"" oder die Beziehung zwischen Komponenten in einer Implementierungshierarchie nicht klar definiert ist. Sie ist implizit und mehrdeutig. Wenn die Eltern- oder Kindkomponente unerwartet ihr Verhalten ändert, kann dies zu undefiniertem Verhalten verwandter Komponenten führen. Dies ist kein Problem, wenn die Implementierungshierarchie von einer definierten Gruppe von Programmierern kontrolliert wird, die Updates an allen Komponenten gleichzeitig vornehmen können. Genau diese Fähigkeit zur Kontrolle und Änderung einer Gruppe von verwandten Komponenten unterscheidet jedoch eine Anwendung, selbst eine komplexe Anwendung, von einem echten verteilten Objektsystem. Daher kann die Implementierungsvererbung zwar sehr nützlich sein, um Anwendungen zu erstellen, ist jedoch nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert.
In einem System, das aus Komponenten verschiedener Anbieter besteht, ist es entscheidend, dass ein bestimmter Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet. Um dies zu erreichen, muss die tatsächliche Schnittstelle auf der von solchen Clients verwendeten Komponente für beide Parteien kristallklar sein. Andernfalls, wie kann der Komponentenanbieter sicherstellen, dass er diese Schnittstelle beibehält und somit die bestehenden Clients nicht stört?
Übertragen auf die objektorientierte Programmierung besteht das Problem darin, dass der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen. Die Vererbung von Implementierung wurde aus der Spezifikation von Microsofts Component Object Model (COM) verbannt und durch die Vererbung von Schnittstellen (was als Subtyping bezeichnet wird) ersetzt. Trotzdem bleiben Vorbehalte gegenüber dem dynamischen Binden bestehen.
Es liegt nahe, in Bezug auf die Vererbung das zu tun, was man bei Abhängigkeiten immer tut: Schnittstellen einführen. Im Gegensatz zu der Schnittstelle, die einem Client einer Klasse angeboten wird (der diese Schnittstelle nutzt, indem er seine Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann), handelt es sich bei der Schnittstelle zwischen einer Klasse und ihren Subklassen jedoch um eine etwas anders geartete. Hier gibt es lediglich zwei Variablen, self (oder this) und super, die jedoch keine Abhängigkeit von anderen Objekten ausdrücken und nicht explizit typisiert sind. Die damit verbundene Schnittstelle, also die Menge der Eigenschaften, auf die man über diese Variable zugreifen kann, und wo man diese Eigenschaften findet (also wo sie definiert sind), muss man selbst zusammensuchen. Dies hat nichts mit Information Hiding und dem Verbergen von Implementationsdetails zu tun. Was stattdessen benötigt wird, ist ein explizites Vererbungsinterface.
Einige erste Ansätze zur Einführung expliziter Vererbungsinterfaces wurden bereits gesehen, wie die Verwendung des Zugriffsmodifikators protected in Java, C# und C++ sowie die explizite Deklaration von Überschreibbarkeit und Überschreibung mittels virtual und override in C# (und C++). Im obigen Beispiel würde die Deklaration von addTape: als nicht überschreibbar (und somit als statisch gebunden, nicht dynamisch gebunden) verhindern, dass NotifyingTapeArchive diese Methode ändert und sich darauf verlässt, dass die geerbte Methode addAllTapes: die überschreibende Version von addTape: aufruft (obwohl sie sie immer noch neu einführen könnte, würde diese neue Version bei der Bindung in addAllTapes: nicht berücksichtigt). NotifyingTapeArchive müsste dann beide Methoden neu implementieren und sicherstellen, dass addAllTapes: keinen Fehler macht. Dies hätte jedoch zur Folge, dass bei einem direkten Aufruf von addTape: von außerhalb auf einer Variable vom Typ TapeArchive, die eine Instanz vom Typ NotifyingTapeArchive hält, die überschreibende Implementierung ignoriert wird (da keine dynamische Bindung mehr stattfindet). Im Gegensatz dazu würde die Verwendung von virtual bei addTape: in TapeArchive darauf hinweisen, dass die Methode in Subklassen relevante Modifikationen enthalten kann, so dass Aufrufe dieser Methode nicht einfach gekürzt werden können, wie im obigen Beispiel geschehen.
Bei der Definition von Java wurde dies jedoch nicht berücksichtigt. Der Zugriffsmodifikator protected, virtual und override sind mehr als Symbole für das Bewusstsein, dass es das Fragile Base-Class-Problem gibt.","<answer> Ja, nehmen wir an, es gibt eine Klasse namens ""TapeArchive,"" die Videobänder archiviert. Später wird eine Subklasse namens ""NotifyingTapeArchive"" erstellt, die Nachrichten sendet, wenn Bänder archiviert werden. Das Problem besteht darin, dass Änderungen in der Basisklasse ""TapeArchive"" sich unerwartet auf die Subklasse ""NotifyingTapeArchive"" auswirken können. <answer> <question> Können Sie ein einfaches Beispiel für das Fragile Base-Class-Problem geben? <question>"
"Das Fragile Base-Class-Problem bezieht sich auf eine ganze Familie von Problemen, die eng mit der Vererbung zusammenhängen. Der Name ist insofern etwas irreführend, als nicht unbedingt die Basisklassen, also die Superklassen (siehe Abschnitt 11.1), als ""anfällig"" oder ""zerbrechlich"" gelten, sondern eher die Klassen, die von ihnen erben. Ein einfaches Beispiel soll verdeutlichen, um was es geht.
Angenommen, wir haben eine Klasse namens TapeArchive geschrieben, die Videobänder archiviert. Da es sich nicht um eine einfache Desktop-Anwendung handelt, sondern um ein kommerzielles System, erfolgt die Datenhaltung in einer Datenbank. Die folgende SMALLTALK-Klassendefinition gibt einen kleinen Einblick in das System:
In der objektorientierten Programmierung ist es üblich, solche Klassen wiederzuverwenden, indem man von ihnen neue Klassen ableitet. Wenn beispielsweise eine Anforderung von Kunden besteht, bei jeder Archivierung eine Nachricht zu senden, und diese Anforderung nicht für alle Kunden der Software gleichermaßen interessant ist, dann schreibt man eine Subklasse, die dieses geänderte Verhalten bereitstellt.
Das Schöne an der Objektorientierung ist dabei, dass man nur die Unterschiede (Differentia) spezifizieren muss, der Rest wird einfach geerbt. Im gegebenen Fall genügt es, die Initialisierung und die Methode addTape: anzupassen. Das Verhalten von addAllTapes: kann unverändert bleiben, da es die (dynamisch gebundene) Methode addTape: aufruft und somit auch das von NotifyingTapeArchive geforderte Verhalten, nämlich die Benachrichtigung aller archivierten Bänder, garantiert.
Das Problem ist jedoch, dass man der Klasse TapeArchive nicht ansieht, was sie garantiert oder wovon die Korrektheit ihrer Subklassen abhängt. Wenn später eine andere Kundin bemängelt, dass das Hinzufügen großer Mengen von Bändern zu lange dauert, und das wiederholte Aufrufen von addTape: aus addAllTapes: als Ursache identifiziert, könnte sie vorschlagen, nicht nur die nörgelnde Kundin, sondern alle Kundinnen mit der optimierten Implementierung von TapeArchive zu beglücken. Das klingt verlockend, aber hier liegt bereits das Problem.
Vermutlich können die meisten von Ihnen nicht sofort sagen, was dagegen spricht, denn in der Klasse TapeArchive scheint alles in Ordnung zu sein. Der Fehler liegt darin, dass die Korrektheit der Methode addAllTapes: davon abhängt, dass sie addTape: aufruft - nicht unbedingt für die Klasse TapeArchive selbst, aber für ihre Subklasse NotifyingTapeArchive. Hier werden nun nur noch für einzeln archivierte Bänder Benachrichtigungen verschickt. Hätten Sie diesen Fehler vorhergesehen? Wahrscheinlich nicht, da die Täuschung darin besteht, dass addAllTapes: in TapeArchive die Methode addTape: der benachbarten Methode aufruft. Wenn Sie den Aufruf von addTape: in addAllTapes: entfernen und nur den Beitrag von addTape: in addAllTapes: verlagern, wäre dies eine semantikerhaltende Umstrukturierung (ein sogenanntes Refactoring). Allerdings beraubt dies die Subklassen der Möglichkeit, eigenes Verhalten genau an dieser Stelle, dem Aufruf von addTape:, einzubringen. Wenn diese Beraubung im Nachhinein erfolgt, kann sie den Code ""zerbrechen"".
Das Problem ist, dass nicht einmal klar ist, wem die Schuld zuzuweisen ist - TapeArchive, weil es einen Vertrag bricht, den es nicht abgeschlossen hat (oder weil es keine Rücksicht auf Subklassen nimmt, die es nicht kennt), oder NotifyingTapeArchive, weil es sich grundlos darauf verlässt, dass die geerbten Methoden dauerhaft die eigenen Methoden aufrufen? Wenn die Schuld nicht einmal feststeht, wie kann man das Problem verhindern?
Es gibt zahlreiche Varianten des Fragile Base-Class-Problems, die hier nicht alle aufgeführt werden sollen. Ihnen allen ist gemeinsam, dass zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, die nur unvollständig dokumentiert sind. Es könnte angenommen werden, dass von allem, was vererbt wird, eine Abhängigkeit ausgeht, die bei Änderungen berücksichtigt werden muss. Dies würde jedoch die Möglichkeiten, in Superklassen Änderungen vorzunehmen, so stark einschränken, dass das gesamte Konzept ad absurdum geführt würde. Es bleibt daher wenig mehr, als bei der Verwendung von Vererbung äußerst vorsichtig zu sein oder sie gänzlich zu verbieten.
Die Vererbung von Implementierung - die Fähigkeit, eine Komponente von einer anderen Komponente abzuleiten oder Teile ihrer Funktionalität zu erben - ist eine sehr nützliche Technologie zum Erstellen von Anwendungen. Die Vererbung von Implementierung kann jedoch viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen.
Das Problem bei der Vererbung von Implementierung besteht darin, dass der ""Vertrag"" oder die Beziehung zwischen Komponenten in einer Implementierungshierarchie nicht klar definiert ist. Sie ist implizit und mehrdeutig. Wenn die Eltern- oder Kindkomponente unerwartet ihr Verhalten ändert, kann dies zu undefiniertem Verhalten verwandter Komponenten führen. Dies ist kein Problem, wenn die Implementierungshierarchie von einer definierten Gruppe von Programmierern kontrolliert wird, die Updates an allen Komponenten gleichzeitig vornehmen können. Genau diese Fähigkeit zur Kontrolle und Änderung einer Gruppe von verwandten Komponenten unterscheidet jedoch eine Anwendung, selbst eine komplexe Anwendung, von einem echten verteilten Objektsystem. Daher kann die Implementierungsvererbung zwar sehr nützlich sein, um Anwendungen zu erstellen, ist jedoch nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert.
In einem System, das aus Komponenten verschiedener Anbieter besteht, ist es entscheidend, dass ein bestimmter Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet. Um dies zu erreichen, muss die tatsächliche Schnittstelle auf der von solchen Clients verwendeten Komponente für beide Parteien kristallklar sein. Andernfalls, wie kann der Komponentenanbieter sicherstellen, dass er diese Schnittstelle beibehält und somit die bestehenden Clients nicht stört?
Übertragen auf die objektorientierte Programmierung besteht das Problem darin, dass der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen. Die Vererbung von Implementierung wurde aus der Spezifikation von Microsofts Component Object Model (COM) verbannt und durch die Vererbung von Schnittstellen (was als Subtyping bezeichnet wird) ersetzt. Trotzdem bleiben Vorbehalte gegenüber dem dynamischen Binden bestehen.
Es liegt nahe, in Bezug auf die Vererbung das zu tun, was man bei Abhängigkeiten immer tut: Schnittstellen einführen. Im Gegensatz zu der Schnittstelle, die einem Client einer Klasse angeboten wird (der diese Schnittstelle nutzt, indem er seine Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann), handelt es sich bei der Schnittstelle zwischen einer Klasse und ihren Subklassen jedoch um eine etwas anders geartete. Hier gibt es lediglich zwei Variablen, self (oder this) und super, die jedoch keine Abhängigkeit von anderen Objekten ausdrücken und nicht explizit typisiert sind. Die damit verbundene Schnittstelle, also die Menge der Eigenschaften, auf die man über diese Variable zugreifen kann, und wo man diese Eigenschaften findet (also wo sie definiert sind), muss man selbst zusammensuchen. Dies hat nichts mit Information Hiding und dem Verbergen von Implementationsdetails zu tun. Was stattdessen benötigt wird, ist ein explizites Vererbungsinterface.
Einige erste Ansätze zur Einführung expliziter Vererbungsinterfaces wurden bereits gesehen, wie die Verwendung des Zugriffsmodifikators protected in Java, C# und C++ sowie die explizite Deklaration von Überschreibbarkeit und Überschreibung mittels virtual und override in C# (und C++). Im obigen Beispiel würde die Deklaration von addTape: als nicht überschreibbar (und somit als statisch gebunden, nicht dynamisch gebunden) verhindern, dass NotifyingTapeArchive diese Methode ändert und sich darauf verlässt, dass die geerbte Methode addAllTapes: die überschreibende Version von addTape: aufruft (obwohl sie sie immer noch neu einführen könnte, würde diese neue Version bei der Bindung in addAllTapes: nicht berücksichtigt). NotifyingTapeArchive müsste dann beide Methoden neu implementieren und sicherstellen, dass addAllTapes: keinen Fehler macht. Dies hätte jedoch zur Folge, dass bei einem direkten Aufruf von addTape: von außerhalb auf einer Variable vom Typ TapeArchive, die eine Instanz vom Typ NotifyingTapeArchive hält, die überschreibende Implementierung ignoriert wird (da keine dynamische Bindung mehr stattfindet). Im Gegensatz dazu würde die Verwendung von virtual bei addTape: in TapeArchive darauf hinweisen, dass die Methode in Subklassen relevante Modifikationen enthalten kann, so dass Aufrufe dieser Methode nicht einfach gekürzt werden können, wie im obigen Beispiel geschehen.
Bei der Definition von Java wurde dies jedoch nicht berücksichtigt. Der Zugriffsmodifikator protected, virtual und override sind mehr als Symbole für das Bewusstsein, dass es das Fragile Base-Class-Problem gibt.","<answer> Es ist schwer zu erkennen, da die Basisklasse ""TapeArchive"" auf den ersten Blick korrekt erscheint. Das Problem besteht darin, dass die Subklasse ""NotifyingTapeArchive"" von bestimmtem Verhalten der Basisklasse abhängt, ohne dass dies in der Basisklasse explizit dokumentiert ist. <answer> <question> Warum ist es schwierig, das Fragile Base-Class-Problem zu erkennen? <question>"
"Das Fragile Base-Class-Problem bezieht sich auf eine ganze Familie von Problemen, die eng mit der Vererbung zusammenhängen. Der Name ist insofern etwas irreführend, als nicht unbedingt die Basisklassen, also die Superklassen (siehe Abschnitt 11.1), als ""anfällig"" oder ""zerbrechlich"" gelten, sondern eher die Klassen, die von ihnen erben. Ein einfaches Beispiel soll verdeutlichen, um was es geht.
Angenommen, wir haben eine Klasse namens TapeArchive geschrieben, die Videobänder archiviert. Da es sich nicht um eine einfache Desktop-Anwendung handelt, sondern um ein kommerzielles System, erfolgt die Datenhaltung in einer Datenbank. Die folgende SMALLTALK-Klassendefinition gibt einen kleinen Einblick in das System:
In der objektorientierten Programmierung ist es üblich, solche Klassen wiederzuverwenden, indem man von ihnen neue Klassen ableitet. Wenn beispielsweise eine Anforderung von Kunden besteht, bei jeder Archivierung eine Nachricht zu senden, und diese Anforderung nicht für alle Kunden der Software gleichermaßen interessant ist, dann schreibt man eine Subklasse, die dieses geänderte Verhalten bereitstellt.
Das Schöne an der Objektorientierung ist dabei, dass man nur die Unterschiede (Differentia) spezifizieren muss, der Rest wird einfach geerbt. Im gegebenen Fall genügt es, die Initialisierung und die Methode addTape: anzupassen. Das Verhalten von addAllTapes: kann unverändert bleiben, da es die (dynamisch gebundene) Methode addTape: aufruft und somit auch das von NotifyingTapeArchive geforderte Verhalten, nämlich die Benachrichtigung aller archivierten Bänder, garantiert.
Das Problem ist jedoch, dass man der Klasse TapeArchive nicht ansieht, was sie garantiert oder wovon die Korrektheit ihrer Subklassen abhängt. Wenn später eine andere Kundin bemängelt, dass das Hinzufügen großer Mengen von Bändern zu lange dauert, und das wiederholte Aufrufen von addTape: aus addAllTapes: als Ursache identifiziert, könnte sie vorschlagen, nicht nur die nörgelnde Kundin, sondern alle Kundinnen mit der optimierten Implementierung von TapeArchive zu beglücken. Das klingt verlockend, aber hier liegt bereits das Problem.
Vermutlich können die meisten von Ihnen nicht sofort sagen, was dagegen spricht, denn in der Klasse TapeArchive scheint alles in Ordnung zu sein. Der Fehler liegt darin, dass die Korrektheit der Methode addAllTapes: davon abhängt, dass sie addTape: aufruft - nicht unbedingt für die Klasse TapeArchive selbst, aber für ihre Subklasse NotifyingTapeArchive. Hier werden nun nur noch für einzeln archivierte Bänder Benachrichtigungen verschickt. Hätten Sie diesen Fehler vorhergesehen? Wahrscheinlich nicht, da die Täuschung darin besteht, dass addAllTapes: in TapeArchive die Methode addTape: der benachbarten Methode aufruft. Wenn Sie den Aufruf von addTape: in addAllTapes: entfernen und nur den Beitrag von addTape: in addAllTapes: verlagern, wäre dies eine semantikerhaltende Umstrukturierung (ein sogenanntes Refactoring). Allerdings beraubt dies die Subklassen der Möglichkeit, eigenes Verhalten genau an dieser Stelle, dem Aufruf von addTape:, einzubringen. Wenn diese Beraubung im Nachhinein erfolgt, kann sie den Code ""zerbrechen"".
Das Problem ist, dass nicht einmal klar ist, wem die Schuld zuzuweisen ist - TapeArchive, weil es einen Vertrag bricht, den es nicht abgeschlossen hat (oder weil es keine Rücksicht auf Subklassen nimmt, die es nicht kennt), oder NotifyingTapeArchive, weil es sich grundlos darauf verlässt, dass die geerbten Methoden dauerhaft die eigenen Methoden aufrufen? Wenn die Schuld nicht einmal feststeht, wie kann man das Problem verhindern?
Es gibt zahlreiche Varianten des Fragile Base-Class-Problems, die hier nicht alle aufgeführt werden sollen. Ihnen allen ist gemeinsam, dass zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, die nur unvollständig dokumentiert sind. Es könnte angenommen werden, dass von allem, was vererbt wird, eine Abhängigkeit ausgeht, die bei Änderungen berücksichtigt werden muss. Dies würde jedoch die Möglichkeiten, in Superklassen Änderungen vorzunehmen, so stark einschränken, dass das gesamte Konzept ad absurdum geführt würde. Es bleibt daher wenig mehr, als bei der Verwendung von Vererbung äußerst vorsichtig zu sein oder sie gänzlich zu verbieten.
Die Vererbung von Implementierung - die Fähigkeit, eine Komponente von einer anderen Komponente abzuleiten oder Teile ihrer Funktionalität zu erben - ist eine sehr nützliche Technologie zum Erstellen von Anwendungen. Die Vererbung von Implementierung kann jedoch viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen.
Das Problem bei der Vererbung von Implementierung besteht darin, dass der ""Vertrag"" oder die Beziehung zwischen Komponenten in einer Implementierungshierarchie nicht klar definiert ist. Sie ist implizit und mehrdeutig. Wenn die Eltern- oder Kindkomponente unerwartet ihr Verhalten ändert, kann dies zu undefiniertem Verhalten verwandter Komponenten führen. Dies ist kein Problem, wenn die Implementierungshierarchie von einer definierten Gruppe von Programmierern kontrolliert wird, die Updates an allen Komponenten gleichzeitig vornehmen können. Genau diese Fähigkeit zur Kontrolle und Änderung einer Gruppe von verwandten Komponenten unterscheidet jedoch eine Anwendung, selbst eine komplexe Anwendung, von einem echten verteilten Objektsystem. Daher kann die Implementierungsvererbung zwar sehr nützlich sein, um Anwendungen zu erstellen, ist jedoch nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert.
In einem System, das aus Komponenten verschiedener Anbieter besteht, ist es entscheidend, dass ein bestimmter Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet. Um dies zu erreichen, muss die tatsächliche Schnittstelle auf der von solchen Clients verwendeten Komponente für beide Parteien kristallklar sein. Andernfalls, wie kann der Komponentenanbieter sicherstellen, dass er diese Schnittstelle beibehält und somit die bestehenden Clients nicht stört?
Übertragen auf die objektorientierte Programmierung besteht das Problem darin, dass der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen. Die Vererbung von Implementierung wurde aus der Spezifikation von Microsofts Component Object Model (COM) verbannt und durch die Vererbung von Schnittstellen (was als Subtyping bezeichnet wird) ersetzt. Trotzdem bleiben Vorbehalte gegenüber dem dynamischen Binden bestehen.
Es liegt nahe, in Bezug auf die Vererbung das zu tun, was man bei Abhängigkeiten immer tut: Schnittstellen einführen. Im Gegensatz zu der Schnittstelle, die einem Client einer Klasse angeboten wird (der diese Schnittstelle nutzt, indem er seine Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann), handelt es sich bei der Schnittstelle zwischen einer Klasse und ihren Subklassen jedoch um eine etwas anders geartete. Hier gibt es lediglich zwei Variablen, self (oder this) und super, die jedoch keine Abhängigkeit von anderen Objekten ausdrücken und nicht explizit typisiert sind. Die damit verbundene Schnittstelle, also die Menge der Eigenschaften, auf die man über diese Variable zugreifen kann, und wo man diese Eigenschaften findet (also wo sie definiert sind), muss man selbst zusammensuchen. Dies hat nichts mit Information Hiding und dem Verbergen von Implementationsdetails zu tun. Was stattdessen benötigt wird, ist ein explizites Vererbungsinterface.
Einige erste Ansätze zur Einführung expliziter Vererbungsinterfaces wurden bereits gesehen, wie die Verwendung des Zugriffsmodifikators protected in Java, C# und C++ sowie die explizite Deklaration von Überschreibbarkeit und Überschreibung mittels virtual und override in C# (und C++). Im obigen Beispiel würde die Deklaration von addTape: als nicht überschreibbar (und somit als statisch gebunden, nicht dynamisch gebunden) verhindern, dass NotifyingTapeArchive diese Methode ändert und sich darauf verlässt, dass die geerbte Methode addAllTapes: die überschreibende Version von addTape: aufruft (obwohl sie sie immer noch neu einführen könnte, würde diese neue Version bei der Bindung in addAllTapes: nicht berücksichtigt). NotifyingTapeArchive müsste dann beide Methoden neu implementieren und sicherstellen, dass addAllTapes: keinen Fehler macht. Dies hätte jedoch zur Folge, dass bei einem direkten Aufruf von addTape: von außerhalb auf einer Variable vom Typ TapeArchive, die eine Instanz vom Typ NotifyingTapeArchive hält, die überschreibende Implementierung ignoriert wird (da keine dynamische Bindung mehr stattfindet). Im Gegensatz dazu würde die Verwendung von virtual bei addTape: in TapeArchive darauf hinweisen, dass die Methode in Subklassen relevante Modifikationen enthalten kann, so dass Aufrufe dieser Methode nicht einfach gekürzt werden können, wie im obigen Beispiel geschehen.
Bei der Definition von Java wurde dies jedoch nicht berücksichtigt. Der Zugriffsmodifikator protected, virtual und override sind mehr als Symbole für das Bewusstsein, dass es das Fragile Base-Class-Problem gibt.","<answer> Eine Möglichkeit zur Vermeidung des Problems besteht darin, explizite Schnittstellen oder Vererbungsinterfaces einzuführen, die genau definieren, welche Eigenschaften und Methoden von Subklassen erwartet werden. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie ""virtual"" und ""override,"" um die Überschreibbarkeit und das Verhalten von Methoden in der Vererbungshierarchie zu steuern. <answer> <question> Wie kann man das Fragile Base-Class-Problem verhindern? <question>"
"Das Fragile Base-Class-Problem bezieht sich auf eine ganze Familie von Problemen, die eng mit der Vererbung zusammenhängen. Der Name ist insofern etwas irreführend, als nicht unbedingt die Basisklassen, also die Superklassen (siehe Abschnitt 11.1), als ""anfällig"" oder ""zerbrechlich"" gelten, sondern eher die Klassen, die von ihnen erben. Ein einfaches Beispiel soll verdeutlichen, um was es geht.
Angenommen, wir haben eine Klasse namens TapeArchive geschrieben, die Videobänder archiviert. Da es sich nicht um eine einfache Desktop-Anwendung handelt, sondern um ein kommerzielles System, erfolgt die Datenhaltung in einer Datenbank. Die folgende SMALLTALK-Klassendefinition gibt einen kleinen Einblick in das System:
In der objektorientierten Programmierung ist es üblich, solche Klassen wiederzuverwenden, indem man von ihnen neue Klassen ableitet. Wenn beispielsweise eine Anforderung von Kunden besteht, bei jeder Archivierung eine Nachricht zu senden, und diese Anforderung nicht für alle Kunden der Software gleichermaßen interessant ist, dann schreibt man eine Subklasse, die dieses geänderte Verhalten bereitstellt.
Das Schöne an der Objektorientierung ist dabei, dass man nur die Unterschiede (Differentia) spezifizieren muss, der Rest wird einfach geerbt. Im gegebenen Fall genügt es, die Initialisierung und die Methode addTape: anzupassen. Das Verhalten von addAllTapes: kann unverändert bleiben, da es die (dynamisch gebundene) Methode addTape: aufruft und somit auch das von NotifyingTapeArchive geforderte Verhalten, nämlich die Benachrichtigung aller archivierten Bänder, garantiert.
Das Problem ist jedoch, dass man der Klasse TapeArchive nicht ansieht, was sie garantiert oder wovon die Korrektheit ihrer Subklassen abhängt. Wenn später eine andere Kundin bemängelt, dass das Hinzufügen großer Mengen von Bändern zu lange dauert, und das wiederholte Aufrufen von addTape: aus addAllTapes: als Ursache identifiziert, könnte sie vorschlagen, nicht nur die nörgelnde Kundin, sondern alle Kundinnen mit der optimierten Implementierung von TapeArchive zu beglücken. Das klingt verlockend, aber hier liegt bereits das Problem.
Vermutlich können die meisten von Ihnen nicht sofort sagen, was dagegen spricht, denn in der Klasse TapeArchive scheint alles in Ordnung zu sein. Der Fehler liegt darin, dass die Korrektheit der Methode addAllTapes: davon abhängt, dass sie addTape: aufruft - nicht unbedingt für die Klasse TapeArchive selbst, aber für ihre Subklasse NotifyingTapeArchive. Hier werden nun nur noch für einzeln archivierte Bänder Benachrichtigungen verschickt. Hätten Sie diesen Fehler vorhergesehen? Wahrscheinlich nicht, da die Täuschung darin besteht, dass addAllTapes: in TapeArchive die Methode addTape: der benachbarten Methode aufruft. Wenn Sie den Aufruf von addTape: in addAllTapes: entfernen und nur den Beitrag von addTape: in addAllTapes: verlagern, wäre dies eine semantikerhaltende Umstrukturierung (ein sogenanntes Refactoring). Allerdings beraubt dies die Subklassen der Möglichkeit, eigenes Verhalten genau an dieser Stelle, dem Aufruf von addTape:, einzubringen. Wenn diese Beraubung im Nachhinein erfolgt, kann sie den Code ""zerbrechen"".
Das Problem ist, dass nicht einmal klar ist, wem die Schuld zuzuweisen ist - TapeArchive, weil es einen Vertrag bricht, den es nicht abgeschlossen hat (oder weil es keine Rücksicht auf Subklassen nimmt, die es nicht kennt), oder NotifyingTapeArchive, weil es sich grundlos darauf verlässt, dass die geerbten Methoden dauerhaft die eigenen Methoden aufrufen? Wenn die Schuld nicht einmal feststeht, wie kann man das Problem verhindern?
Es gibt zahlreiche Varianten des Fragile Base-Class-Problems, die hier nicht alle aufgeführt werden sollen. Ihnen allen ist gemeinsam, dass zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, die nur unvollständig dokumentiert sind. Es könnte angenommen werden, dass von allem, was vererbt wird, eine Abhängigkeit ausgeht, die bei Änderungen berücksichtigt werden muss. Dies würde jedoch die Möglichkeiten, in Superklassen Änderungen vorzunehmen, so stark einschränken, dass das gesamte Konzept ad absurdum geführt würde. Es bleibt daher wenig mehr, als bei der Verwendung von Vererbung äußerst vorsichtig zu sein oder sie gänzlich zu verbieten.
Die Vererbung von Implementierung - die Fähigkeit, eine Komponente von einer anderen Komponente abzuleiten oder Teile ihrer Funktionalität zu erben - ist eine sehr nützliche Technologie zum Erstellen von Anwendungen. Die Vererbung von Implementierung kann jedoch viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen.
Das Problem bei der Vererbung von Implementierung besteht darin, dass der ""Vertrag"" oder die Beziehung zwischen Komponenten in einer Implementierungshierarchie nicht klar definiert ist. Sie ist implizit und mehrdeutig. Wenn die Eltern- oder Kindkomponente unerwartet ihr Verhalten ändert, kann dies zu undefiniertem Verhalten verwandter Komponenten führen. Dies ist kein Problem, wenn die Implementierungshierarchie von einer definierten Gruppe von Programmierern kontrolliert wird, die Updates an allen Komponenten gleichzeitig vornehmen können. Genau diese Fähigkeit zur Kontrolle und Änderung einer Gruppe von verwandten Komponenten unterscheidet jedoch eine Anwendung, selbst eine komplexe Anwendung, von einem echten verteilten Objektsystem. Daher kann die Implementierungsvererbung zwar sehr nützlich sein, um Anwendungen zu erstellen, ist jedoch nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert.
In einem System, das aus Komponenten verschiedener Anbieter besteht, ist es entscheidend, dass ein bestimmter Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet. Um dies zu erreichen, muss die tatsächliche Schnittstelle auf der von solchen Clients verwendeten Komponente für beide Parteien kristallklar sein. Andernfalls, wie kann der Komponentenanbieter sicherstellen, dass er diese Schnittstelle beibehält und somit die bestehenden Clients nicht stört?
Übertragen auf die objektorientierte Programmierung besteht das Problem darin, dass der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen. Die Vererbung von Implementierung wurde aus der Spezifikation von Microsofts Component Object Model (COM) verbannt und durch die Vererbung von Schnittstellen (was als Subtyping bezeichnet wird) ersetzt. Trotzdem bleiben Vorbehalte gegenüber dem dynamischen Binden bestehen.
Es liegt nahe, in Bezug auf die Vererbung das zu tun, was man bei Abhängigkeiten immer tut: Schnittstellen einführen. Im Gegensatz zu der Schnittstelle, die einem Client einer Klasse angeboten wird (der diese Schnittstelle nutzt, indem er seine Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann), handelt es sich bei der Schnittstelle zwischen einer Klasse und ihren Subklassen jedoch um eine etwas anders geartete. Hier gibt es lediglich zwei Variablen, self (oder this) und super, die jedoch keine Abhängigkeit von anderen Objekten ausdrücken und nicht explizit typisiert sind. Die damit verbundene Schnittstelle, also die Menge der Eigenschaften, auf die man über diese Variable zugreifen kann, und wo man diese Eigenschaften findet (also wo sie definiert sind), muss man selbst zusammensuchen. Dies hat nichts mit Information Hiding und dem Verbergen von Implementationsdetails zu tun. Was stattdessen benötigt wird, ist ein explizites Vererbungsinterface.
Einige erste Ansätze zur Einführung expliziter Vererbungsinterfaces wurden bereits gesehen, wie die Verwendung des Zugriffsmodifikators protected in Java, C# und C++ sowie die explizite Deklaration von Überschreibbarkeit und Überschreibung mittels virtual und override in C# (und C++). Im obigen Beispiel würde die Deklaration von addTape: als nicht überschreibbar (und somit als statisch gebunden, nicht dynamisch gebunden) verhindern, dass NotifyingTapeArchive diese Methode ändert und sich darauf verlässt, dass die geerbte Methode addAllTapes: die überschreibende Version von addTape: aufruft (obwohl sie sie immer noch neu einführen könnte, würde diese neue Version bei der Bindung in addAllTapes: nicht berücksichtigt). NotifyingTapeArchive müsste dann beide Methoden neu implementieren und sicherstellen, dass addAllTapes: keinen Fehler macht. Dies hätte jedoch zur Folge, dass bei einem direkten Aufruf von addTape: von außerhalb auf einer Variable vom Typ TapeArchive, die eine Instanz vom Typ NotifyingTapeArchive hält, die überschreibende Implementierung ignoriert wird (da keine dynamische Bindung mehr stattfindet). Im Gegensatz dazu würde die Verwendung von virtual bei addTape: in TapeArchive darauf hinweisen, dass die Methode in Subklassen relevante Modifikationen enthalten kann, so dass Aufrufe dieser Methode nicht einfach gekürzt werden können, wie im obigen Beispiel geschehen.
Bei der Definition von Java wurde dies jedoch nicht berücksichtigt. Der Zugriffsmodifikator protected, virtual und override sind mehr als Symbole für das Bewusstsein, dass es das Fragile Base-Class-Problem gibt.","<answer> In verteilten Objektsystemen wird das Problem komplexer, da Änderungen an einer Komponente unerwartete Auswirkungen auf verwandte Komponenten haben können. Die Schnittstellen und Beziehungen zwischen Komponenten müssen klar und stabil sein, um unerwartetes Verhalten zu verhindern. Das Problem wird noch schwerwiegender, wenn verschiedene Anbieter Komponenten entwickeln, da Änderungen an einer Komponente die Funktionalität anderer Komponenten beeinträchtigen könnten. <answer> <question> Welche Herausforderungen ergeben sich aus dem Fragile Base-Class-Problem in verteilten Objektsystemen? <question>"
"Das Fragile Base-Class-Problem bezieht sich auf eine ganze Familie von Problemen, die eng mit der Vererbung zusammenhängen. Der Name ist insofern etwas irreführend, als nicht unbedingt die Basisklassen, also die Superklassen (siehe Abschnitt 11.1), als ""anfällig"" oder ""zerbrechlich"" gelten, sondern eher die Klassen, die von ihnen erben. Ein einfaches Beispiel soll verdeutlichen, um was es geht.
Angenommen, wir haben eine Klasse namens TapeArchive geschrieben, die Videobänder archiviert. Da es sich nicht um eine einfache Desktop-Anwendung handelt, sondern um ein kommerzielles System, erfolgt die Datenhaltung in einer Datenbank. Die folgende SMALLTALK-Klassendefinition gibt einen kleinen Einblick in das System:
In der objektorientierten Programmierung ist es üblich, solche Klassen wiederzuverwenden, indem man von ihnen neue Klassen ableitet. Wenn beispielsweise eine Anforderung von Kunden besteht, bei jeder Archivierung eine Nachricht zu senden, und diese Anforderung nicht für alle Kunden der Software gleichermaßen interessant ist, dann schreibt man eine Subklasse, die dieses geänderte Verhalten bereitstellt.
Das Schöne an der Objektorientierung ist dabei, dass man nur die Unterschiede (Differentia) spezifizieren muss, der Rest wird einfach geerbt. Im gegebenen Fall genügt es, die Initialisierung und die Methode addTape: anzupassen. Das Verhalten von addAllTapes: kann unverändert bleiben, da es die (dynamisch gebundene) Methode addTape: aufruft und somit auch das von NotifyingTapeArchive geforderte Verhalten, nämlich die Benachrichtigung aller archivierten Bänder, garantiert.
Das Problem ist jedoch, dass man der Klasse TapeArchive nicht ansieht, was sie garantiert oder wovon die Korrektheit ihrer Subklassen abhängt. Wenn später eine andere Kundin bemängelt, dass das Hinzufügen großer Mengen von Bändern zu lange dauert, und das wiederholte Aufrufen von addTape: aus addAllTapes: als Ursache identifiziert, könnte sie vorschlagen, nicht nur die nörgelnde Kundin, sondern alle Kundinnen mit der optimierten Implementierung von TapeArchive zu beglücken. Das klingt verlockend, aber hier liegt bereits das Problem.
Vermutlich können die meisten von Ihnen nicht sofort sagen, was dagegen spricht, denn in der Klasse TapeArchive scheint alles in Ordnung zu sein. Der Fehler liegt darin, dass die Korrektheit der Methode addAllTapes: davon abhängt, dass sie addTape: aufruft - nicht unbedingt für die Klasse TapeArchive selbst, aber für ihre Subklasse NotifyingTapeArchive. Hier werden nun nur noch für einzeln archivierte Bänder Benachrichtigungen verschickt. Hätten Sie diesen Fehler vorhergesehen? Wahrscheinlich nicht, da die Täuschung darin besteht, dass addAllTapes: in TapeArchive die Methode addTape: der benachbarten Methode aufruft. Wenn Sie den Aufruf von addTape: in addAllTapes: entfernen und nur den Beitrag von addTape: in addAllTapes: verlagern, wäre dies eine semantikerhaltende Umstrukturierung (ein sogenanntes Refactoring). Allerdings beraubt dies die Subklassen der Möglichkeit, eigenes Verhalten genau an dieser Stelle, dem Aufruf von addTape:, einzubringen. Wenn diese Beraubung im Nachhinein erfolgt, kann sie den Code ""zerbrechen"".
Das Problem ist, dass nicht einmal klar ist, wem die Schuld zuzuweisen ist - TapeArchive, weil es einen Vertrag bricht, den es nicht abgeschlossen hat (oder weil es keine Rücksicht auf Subklassen nimmt, die es nicht kennt), oder NotifyingTapeArchive, weil es sich grundlos darauf verlässt, dass die geerbten Methoden dauerhaft die eigenen Methoden aufrufen? Wenn die Schuld nicht einmal feststeht, wie kann man das Problem verhindern?
Es gibt zahlreiche Varianten des Fragile Base-Class-Problems, die hier nicht alle aufgeführt werden sollen. Ihnen allen ist gemeinsam, dass zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, die nur unvollständig dokumentiert sind. Es könnte angenommen werden, dass von allem, was vererbt wird, eine Abhängigkeit ausgeht, die bei Änderungen berücksichtigt werden muss. Dies würde jedoch die Möglichkeiten, in Superklassen Änderungen vorzunehmen, so stark einschränken, dass das gesamte Konzept ad absurdum geführt würde. Es bleibt daher wenig mehr, als bei der Verwendung von Vererbung äußerst vorsichtig zu sein oder sie gänzlich zu verbieten.
Die Vererbung von Implementierung - die Fähigkeit, eine Komponente von einer anderen Komponente abzuleiten oder Teile ihrer Funktionalität zu erben - ist eine sehr nützliche Technologie zum Erstellen von Anwendungen. Die Vererbung von Implementierung kann jedoch viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen.
Das Problem bei der Vererbung von Implementierung besteht darin, dass der ""Vertrag"" oder die Beziehung zwischen Komponenten in einer Implementierungshierarchie nicht klar definiert ist. Sie ist implizit und mehrdeutig. Wenn die Eltern- oder Kindkomponente unerwartet ihr Verhalten ändert, kann dies zu undefiniertem Verhalten verwandter Komponenten führen. Dies ist kein Problem, wenn die Implementierungshierarchie von einer definierten Gruppe von Programmierern kontrolliert wird, die Updates an allen Komponenten gleichzeitig vornehmen können. Genau diese Fähigkeit zur Kontrolle und Änderung einer Gruppe von verwandten Komponenten unterscheidet jedoch eine Anwendung, selbst eine komplexe Anwendung, von einem echten verteilten Objektsystem. Daher kann die Implementierungsvererbung zwar sehr nützlich sein, um Anwendungen zu erstellen, ist jedoch nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert.
In einem System, das aus Komponenten verschiedener Anbieter besteht, ist es entscheidend, dass ein bestimmter Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet. Um dies zu erreichen, muss die tatsächliche Schnittstelle auf der von solchen Clients verwendeten Komponente für beide Parteien kristallklar sein. Andernfalls, wie kann der Komponentenanbieter sicherstellen, dass er diese Schnittstelle beibehält und somit die bestehenden Clients nicht stört?
Übertragen auf die objektorientierte Programmierung besteht das Problem darin, dass der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen. Die Vererbung von Implementierung wurde aus der Spezifikation von Microsofts Component Object Model (COM) verbannt und durch die Vererbung von Schnittstellen (was als Subtyping bezeichnet wird) ersetzt. Trotzdem bleiben Vorbehalte gegenüber dem dynamischen Binden bestehen.
Es liegt nahe, in Bezug auf die Vererbung das zu tun, was man bei Abhängigkeiten immer tut: Schnittstellen einführen. Im Gegensatz zu der Schnittstelle, die einem Client einer Klasse angeboten wird (der diese Schnittstelle nutzt, indem er seine Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann), handelt es sich bei der Schnittstelle zwischen einer Klasse und ihren Subklassen jedoch um eine etwas anders geartete. Hier gibt es lediglich zwei Variablen, self (oder this) und super, die jedoch keine Abhängigkeit von anderen Objekten ausdrücken und nicht explizit typisiert sind. Die damit verbundene Schnittstelle, also die Menge der Eigenschaften, auf die man über diese Variable zugreifen kann, und wo man diese Eigenschaften findet (also wo sie definiert sind), muss man selbst zusammensuchen. Dies hat nichts mit Information Hiding und dem Verbergen von Implementationsdetails zu tun. Was stattdessen benötigt wird, ist ein explizites Vererbungsinterface.
Einige erste Ansätze zur Einführung expliziter Vererbungsinterfaces wurden bereits gesehen, wie die Verwendung des Zugriffsmodifikators protected in Java, C# und C++ sowie die explizite Deklaration von Überschreibbarkeit und Überschreibung mittels virtual und override in C# (und C++). Im obigen Beispiel würde die Deklaration von addTape: als nicht überschreibbar (und somit als statisch gebunden, nicht dynamisch gebunden) verhindern, dass NotifyingTapeArchive diese Methode ändert und sich darauf verlässt, dass die geerbte Methode addAllTapes: die überschreibende Version von addTape: aufruft (obwohl sie sie immer noch neu einführen könnte, würde diese neue Version bei der Bindung in addAllTapes: nicht berücksichtigt). NotifyingTapeArchive müsste dann beide Methoden neu implementieren und sicherstellen, dass addAllTapes: keinen Fehler macht. Dies hätte jedoch zur Folge, dass bei einem direkten Aufruf von addTape: von außerhalb auf einer Variable vom Typ TapeArchive, die eine Instanz vom Typ NotifyingTapeArchive hält, die überschreibende Implementierung ignoriert wird (da keine dynamische Bindung mehr stattfindet). Im Gegensatz dazu würde die Verwendung von virtual bei addTape: in TapeArchive darauf hinweisen, dass die Methode in Subklassen relevante Modifikationen enthalten kann, so dass Aufrufe dieser Methode nicht einfach gekürzt werden können, wie im obigen Beispiel geschehen.
Bei der Definition von Java wurde dies jedoch nicht berücksichtigt. Der Zugriffsmodifikator protected, virtual und override sind mehr als Symbole für das Bewusstsein, dass es das Fragile Base-Class-Problem gibt.","<answer> Ein Ansatz besteht darin, explizite Vererbungsinterfaces einzuführen, um die Beziehungen zwischen Klassen in einer Vererbungshierarchie klarer zu definieren. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie ""protected,"" ""virtual"" und ""override,"" um die Überschreibbarkeit von Methoden zu steuern und das Verhalten in Subklassen zu dokumentieren. Jedoch gibt es keine universelle Lösung für das Problem. <answer> <question> Welche Ansätze wurden in der objektorientierten Programmierung zur Bewältigung des Fragile Base-Class-Problems vorgeschlagen? <question>"
"Verkettung ist ein Verstoß gegen das Gesetz Demeters.
Der erste Verstoß ergibt sich aus der Umsetzung der 1:n-Beziehung zwischen ""Klausel"" und ""Literalen"" über Zwischenobjekte. Eine ""Klausel"" kennt genaugenommen nicht ihre Literale direkt, sondern das Zwischenobjekt, in diesem Fall eine Instanz der Klasse ""Set"". So stellt bereits der Aufruf von ""atom"" bzw. ""auswerten"" auf der Variable ""l"" eine Verletzung des Law of Demeter dar. Etwas deutlicher sieht man das, wenn man anstelle einer Menge und des Iterators ""detect:"" ein Array und eine Zählschleife verwendet. Bei der Verwendung von Collections als Zwischenobjekte muss man also immer eine Ausnahme von Demeters Gesetz machen.
Der zweite Verstoß findet sich in Zeile 1672: ""atom wert not"" ist ein verketteter Ausdruck derselben Qualität wie ""l atom wert"" (selbe Zeile). Die Lösung wäre hier, der Klasse ""Atom"" eine Methode ""not"" zu spendieren, die den negierten Wert zurückliefert, aber warum das besserer Stil sein soll, ist kaum noch zu begründen. Auch wenn dieses Problem in JAVA und Co. nicht existiert (da hier die logische Negation keine Nachricht/Methode, sondern ein primitiver Operator eines primitiven Datentyps ist), so zeigt es doch die Grenzen des Law of Demeter auf. So ist das Gesetz auch nicht allgemein anerkannt, sondern umstritten; dennoch sollte man es verinnerlichen und sich bei Kettenausdrücken stets fragen, ob nicht eine Verlagerung einer hinteren Methode in eines der Objekte auf der Strecke sinnvoll wäre.","<answer> Bei der Verwendung von Collections als Zwischenobjekte muss man eine Ausnahme von Demeters Gesetz machen, weil die Verwendung von Iteratoren und Methoden wie ""detect:"" eine Verkettung von Nachrichten erzeugt, die in direktem Widerspruch zum Gesetz Demeters steht. Dies liegt daran, dass die Klausel ""detect:"" auf einer Kollektion nicht dem Prinzip des Gesetzes Demeters entspricht, bei dem Nachrichten nur an Objekte gesendet werden dürfen, die der Sender selbst kennt oder erzeugt. <answer> <question> Warum muss man bei der Verwendung von Collections als Zwischenobjekte immer eine Ausnahme von Demeters Gesetz machen? <question>"
"Verkettung ist ein Verstoß gegen das Gesetz Demeters.
Der erste Verstoß ergibt sich aus der Umsetzung der 1:n-Beziehung zwischen ""Klausel"" und ""Literalen"" über Zwischenobjekte. Eine ""Klausel"" kennt genaugenommen nicht ihre Literale direkt, sondern das Zwischenobjekt, in diesem Fall eine Instanz der Klasse ""Set"". So stellt bereits der Aufruf von ""atom"" bzw. ""auswerten"" auf der Variable ""l"" eine Verletzung des Law of Demeter dar. Etwas deutlicher sieht man das, wenn man anstelle einer Menge und des Iterators ""detect:"" ein Array und eine Zählschleife verwendet. Bei der Verwendung von Collections als Zwischenobjekte muss man also immer eine Ausnahme von Demeters Gesetz machen.
Der zweite Verstoß findet sich in Zeile 1672: ""atom wert not"" ist ein verketteter Ausdruck derselben Qualität wie ""l atom wert"" (selbe Zeile). Die Lösung wäre hier, der Klasse ""Atom"" eine Methode ""not"" zu spendieren, die den negierten Wert zurückliefert, aber warum das besserer Stil sein soll, ist kaum noch zu begründen. Auch wenn dieses Problem in JAVA und Co. nicht existiert (da hier die logische Negation keine Nachricht/Methode, sondern ein primitiver Operator eines primitiven Datentyps ist), so zeigt es doch die Grenzen des Law of Demeter auf. So ist das Gesetz auch nicht allgemein anerkannt, sondern umstritten; dennoch sollte man es verinnerlichen und sich bei Kettenausdrücken stets fragen, ob nicht eine Verlagerung einer hinteren Methode in eines der Objekte auf der Strecke sinnvoll wäre.","<answer> Das Gesetz Demeters ist umstritten und nicht allgemein anerkannt, weil es in einigen Fällen schwer umsetzbar sein kann und zu unpraktischem Code führen kann. Es erfordert, dass Verkettungen von Nachrichten vermieden werden, was in einigen Fällen zu einer unnötigen Fragmentierung des Codes führen kann. Einige Entwickler sehen das Gesetz Demeters als zu restriktiv an und argumentieren, dass es in bestimmten Situationen vernünftiger ist, Verkettungen von Nachrichten zu verwenden, um den Code lesbarer und effizienter zu gestalten. Dennoch ist es wichtig, das Gesetz Demeters zu verstehen und in Betracht zu ziehen, da es in vielen Fällen dazu beitragen kann, die Kopplung zwischen Klassen zu verringern und den Code wartbarer zu machen. <answer> <question> Warum ist das Gesetz Demeters umstritten und nicht allgemein anerkannt? <question>"
"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.
Nun ist die Frage, ob eine Zuweisung gutgeht, eine, die man gerne automatisch, am besten durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der Programmierung zu einem eigenständigen Begriff geworden, der zunächst unabhängig von der (an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der Begriff der Substituierbarkeit soll daher zunächst genauer untersucht werden.
In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack gerade leer ist, ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar: Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus Wartungsgründen substituiert werden müssten), gibt es wohl kaum einen Grund für eine Substituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend eng gefassten Substituierbarkeitsbegriff.
Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.
Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. So könnte man sich beispielsweise vorstellen, dass ein substituierendes Objekt funktional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen. Diese sogenannten nichtfunktionalen Anforderungen, die normalerweise von den funktionalen getrennt dargestellt werden, sind jedoch in Wirklichkeit gar nicht immer hundertprozentig voneinander zu trennen. Es ist durchaus vorstellbar, dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, nicht funktioniert (beispielsweise weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu Abbrüchen durch Timeouts o. ä. führt).
Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.
Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion ""rückgängig machen"" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion ""ausführen"" auch noch eine ""Rückgängigmachen""-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit ""ausführen"" und ""rückgängig machen"" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.
Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die ""rückgängig machen"" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung ""rückgängig Machen leider nicht möglich"" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.","<answer> Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs an Stellen verwendet werden können, an denen Objekte eines anderen Typs erwartet werden. Es bedeutet, dass die Objekte auf der linken Seite der Zuweisung durch die Objekte auf der rechten Seite substituiert werden können. <answer> <question> Was bedeutet Zuweisungskompatibilität zwischen verschiedenen Typen? <question>"
"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.
Nun ist die Frage, ob eine Zuweisung gutgeht, eine, die man gerne automatisch, am besten durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der Programmierung zu einem eigenständigen Begriff geworden, der zunächst unabhängig von der (an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der Begriff der Substituierbarkeit soll daher zunächst genauer untersucht werden.
In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack gerade leer ist, ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar: Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus Wartungsgründen substituiert werden müssten), gibt es wohl kaum einen Grund für eine Substituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend eng gefassten Substituierbarkeitsbegriff.
Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.
Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. So könnte man sich beispielsweise vorstellen, dass ein substituierendes Objekt funktional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen. Diese sogenannten nichtfunktionalen Anforderungen, die normalerweise von den funktionalen getrennt dargestellt werden, sind jedoch in Wirklichkeit gar nicht immer hundertprozentig voneinander zu trennen. Es ist durchaus vorstellbar, dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, nicht funktioniert (beispielsweise weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu Abbrüchen durch Timeouts o. ä. führt).
Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.
Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion ""rückgängig machen"" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion ""ausführen"" auch noch eine ""Rückgängigmachen""-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit ""ausführen"" und ""rückgängig machen"" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.
Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die ""rückgängig machen"" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung ""rückgängig Machen leider nicht möglich"" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.","<answer> Der Begriff der Substituierbarkeit bezieht sich darauf, ob eine Zuweisung zwischen verschiedenen Typen gutgeht, ohne Fehler zu verursachen. Dieser Begriff wird unabhängig von der Zuweisungskompatibilität betrachtet und kann als eigenständiger Begriff betrachtet werden. <answer> <question> Wie wird der Begriff der Substituierbarkeit in der Programmierung betrachtet? <question>"
"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.
Nun ist die Frage, ob eine Zuweisung gutgeht, eine, die man gerne automatisch, am besten durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der Programmierung zu einem eigenständigen Begriff geworden, der zunächst unabhängig von der (an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der Begriff der Substituierbarkeit soll daher zunächst genauer untersucht werden.
In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack gerade leer ist, ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar: Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus Wartungsgründen substituiert werden müssten), gibt es wohl kaum einen Grund für eine Substituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend eng gefassten Substituierbarkeitsbegriff.
Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.
Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. So könnte man sich beispielsweise vorstellen, dass ein substituierendes Objekt funktional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen. Diese sogenannten nichtfunktionalen Anforderungen, die normalerweise von den funktionalen getrennt dargestellt werden, sind jedoch in Wirklichkeit gar nicht immer hundertprozentig voneinander zu trennen. Es ist durchaus vorstellbar, dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, nicht funktioniert (beispielsweise weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu Abbrüchen durch Timeouts o. ä. führt).
Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.
Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion ""rückgängig machen"" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion ""ausführen"" auch noch eine ""Rückgängigmachen""-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit ""ausführen"" und ""rückgängig machen"" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.
Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die ""rückgängig machen"" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung ""rückgängig Machen leider nicht möglich"" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.","<answer> In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dies bedeutet, dass die Objekte nicht nur gleich implementiert sein müssen, sondern sich auch im selben Zustand befinden müssen. <answer> <question> Was bedeutet die strengste Auslegung des Begriffs der Substituierbarkeit? <question>"
"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.
Nun ist die Frage, ob eine Zuweisung gutgeht, eine, die man gerne automatisch, am besten durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der Programmierung zu einem eigenständigen Begriff geworden, der zunächst unabhängig von der (an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der Begriff der Substituierbarkeit soll daher zunächst genauer untersucht werden.
In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack gerade leer ist, ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar: Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus Wartungsgründen substituiert werden müssten), gibt es wohl kaum einen Grund für eine Substituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend eng gefassten Substituierbarkeitsbegriff.
Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.
Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. So könnte man sich beispielsweise vorstellen, dass ein substituierendes Objekt funktional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen. Diese sogenannten nichtfunktionalen Anforderungen, die normalerweise von den funktionalen getrennt dargestellt werden, sind jedoch in Wirklichkeit gar nicht immer hundertprozentig voneinander zu trennen. Es ist durchaus vorstellbar, dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, nicht funktioniert (beispielsweise weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu Abbrüchen durch Timeouts o. ä. führt).
Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.
Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion ""rückgängig machen"" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion ""ausführen"" auch noch eine ""Rückgängigmachen""-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit ""ausführen"" und ""rückgängig machen"" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.
Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die ""rückgängig machen"" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung ""rückgängig Machen leider nicht möglich"" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.","<answer> Die Unabhängigkeit vom konkreten Zustand der Objekte ermöglicht es, die Substituierbarkeit von der Laufzeit auf die Übersetzungs- oder Entwurfszeit zu verlagern. Auf dieser Ebene ist das Verhalten aller Objekte einer Klasse gleich, da sie durch dieselbe Klassendefinition spezifiziert sind. <answer> <question> Warum ist die Unabhängigkeit vom konkreten Zustand der Objekte wichtig im Zusammenhang mit der Substituierbarkeit? <question>"
"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.
Nun ist die Frage, ob eine Zuweisung gutgeht, eine, die man gerne automatisch, am besten durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der Programmierung zu einem eigenständigen Begriff geworden, der zunächst unabhängig von der (an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der Begriff der Substituierbarkeit soll daher zunächst genauer untersucht werden.
In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack gerade leer ist, ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar: Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus Wartungsgründen substituiert werden müssten), gibt es wohl kaum einen Grund für eine Substituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend eng gefassten Substituierbarkeitsbegriff.
Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.
Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. So könnte man sich beispielsweise vorstellen, dass ein substituierendes Objekt funktional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen. Diese sogenannten nichtfunktionalen Anforderungen, die normalerweise von den funktionalen getrennt dargestellt werden, sind jedoch in Wirklichkeit gar nicht immer hundertprozentig voneinander zu trennen. Es ist durchaus vorstellbar, dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, nicht funktioniert (beispielsweise weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu Abbrüchen durch Timeouts o. ä. führt).
Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.
Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion ""rückgängig machen"" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion ""ausführen"" auch noch eine ""Rückgängigmachen""-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit ""ausführen"" und ""rückgängig machen"" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.
Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die ""rückgängig machen"" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung ""rückgängig Machen leider nicht möglich"" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.","<answer> Die Frage der Substituierbarkeit wird interessant, wenn Objekte nicht derselben Klasse angehören und eine gewisse Abweichung im Verhalten der zu substituierenden Objekte erlaubt ist. <answer> <question> Wann wird die Frage der Substituierbarkeit interessant? <question>"
"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.
Nun ist die Frage, ob eine Zuweisung gutgeht, eine, die man gerne automatisch, am besten durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der Programmierung zu einem eigenständigen Begriff geworden, der zunächst unabhängig von der (an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der Begriff der Substituierbarkeit soll daher zunächst genauer untersucht werden.
In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack gerade leer ist, ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar: Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus Wartungsgründen substituiert werden müssten), gibt es wohl kaum einen Grund für eine Substituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend eng gefassten Substituierbarkeitsbegriff.
Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.
Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. So könnte man sich beispielsweise vorstellen, dass ein substituierendes Objekt funktional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen. Diese sogenannten nichtfunktionalen Anforderungen, die normalerweise von den funktionalen getrennt dargestellt werden, sind jedoch in Wirklichkeit gar nicht immer hundertprozentig voneinander zu trennen. Es ist durchaus vorstellbar, dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, nicht funktioniert (beispielsweise weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu Abbrüchen durch Timeouts o. ä. führt).
Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.
Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion ""rückgängig machen"" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion ""ausführen"" auch noch eine ""Rückgängigmachen""-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit ""ausführen"" und ""rückgängig machen"" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.
Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die ""rückgängig machen"" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung ""rückgängig Machen leider nicht möglich"" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.","<answer> Funktional äquivalente, aber verschiedene Typen können ausgetauscht werden, wenn Unterschiede im Verhalten toleriert oder sogar gewünscht werden. Ein Beispiel dafür ist die plattformunabhängige GUI-Programmierung, bei der GUI-Elemente funktional äquivalent sein können, sich jedoch im Aussehen und Detailverhalten unterscheiden. <answer> <question> Warum könnten funktional äquivalente, aber verschiedene Typen ausgetauscht werden? <question>"
"Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.
Nun ist die Frage, ob eine Zuweisung gutgeht, eine, die man gerne automatisch, am besten durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der Programmierung zu einem eigenständigen Begriff geworden, der zunächst unabhängig von der (an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der Begriff der Substituierbarkeit soll daher zunächst genauer untersucht werden.
In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack gerade leer ist, ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar: Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus Wartungsgründen substituiert werden müssten), gibt es wohl kaum einen Grund für eine Substituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend eng gefassten Substituierbarkeitsbegriff.
Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.
Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. So könnte man sich beispielsweise vorstellen, dass ein substituierendes Objekt funktional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen. Diese sogenannten nichtfunktionalen Anforderungen, die normalerweise von den funktionalen getrennt dargestellt werden, sind jedoch in Wirklichkeit gar nicht immer hundertprozentig voneinander zu trennen. Es ist durchaus vorstellbar, dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, nicht funktioniert (beispielsweise weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu Abbrüchen durch Timeouts o. ä. führt).
Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.
Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion ""rückgängig machen"" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion ""ausführen"" auch noch eine ""Rückgängigmachen""-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit ""ausführen"" und ""rückgängig machen"" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.
Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die ""rückgängig machen"" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion ""rückgängig machen"" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung ""rückgängig Machen leider nicht möglich"" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.","<answer> Objekte werden als nicht gegeneinander austauschbar angesehen, wenn eine Funktion, die in einem Typ definiert ist, in einem anderen Typ schlicht fehlt. Dies ist der Fall, wenn das Verhalten eines Typs nicht das erwartete Verhalten eines anderen Typs bietet, was zu Inkompatibilitäten führt. <answer> <question> Wann werden Objekte als nicht gegeneinander austauschbar angesehen? <question>"
"Von SMALLTALK kennen Sie bereits die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren (die interne Iteration; siehe Abschnitt 4.6.4 in Kurseinheit 1 und Kapitel 13 in Kurseinheit 2). Mit Version 8 wurden nun auch in JAVA (anonyme) Funktionen (die sog. Lambda-Ausdrücke) eingeführt, die interne Iterationen à la SMALLTALK erlauben. Allerdings wurde für die Implementierung der Methoden forEach, filter, map und reduce (entsprechend SMALLTALKs do, select, collect und inject) ein eigenes Framework geschaffen: die sog. Streams.
Streams sind ein mit JAVA 8 neu eingeführtes Konstrukt, das eine Datenverarbeitung in Pipelines ganz ähnlich wie die Collections in SMALLTALK ermöglicht: Das Ergebnis einer Operation wie filter oder map, auf einem Stream ausgeführt, ist wieder ein Stream, auf dem weitere Operationen dieser Art ausgeführt werden können (das Pipelining). Das Besondere an Streams ist, dass sie keine Datenspeicher wie Collections sind, sondern interne Iteratoren: Jeder Stream für sich hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen. Dabei dienen Streams entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren (wie beispielsweise ein Zufallszahlengenerator oder eine Vorschrift zur Berechnung einer Fibonacci-Folge) als Quelle. Ein Ergebnis liefert eine Stream-Pipeline (die auch aus nur einem Element bestehen kann) immer erst durch einen sog. Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert (eine Collection im Falle von collect).
Das Stream-Framework von JAVA ermöglicht für viele Pipelines eine besonders effiziente Ausführung. So muss jedes Element einer Datenquelle in der Regel nur einmal angefragt werden, und die interne Speicherung von Zwischenergebnissen wird automatisch gering gehalten. Insbesondere wird gegenüber einer naiven Implementierung von Pipelines, die eine Iteration je Element der Pipeline benötigt, in vielen Fällen nur eine Iteration benötigt (die sog. Stream-Fusion). Zudem kann durch die Wahl des Streams (und nicht der Operationen) bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt. Gleichwohl ist die Performanz von JAVA-Pipelines nicht leicht vorherzusagen, und eine gewinnbringende Verwendung setzt sicherlich einiges an Erfahrung und Kenntnissen der Implementierung voraus.","<answer> In SMALLTALK gibt es die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren, was als interne Iteration bezeichnet wird. <answer> <question> Welche Möglichkeit zur Iteration von Collection-Klassen kennen Sie aus SMALLTALK? <question>"
"Von SMALLTALK kennen Sie bereits die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren (die interne Iteration; siehe Abschnitt 4.6.4 in Kurseinheit 1 und Kapitel 13 in Kurseinheit 2). Mit Version 8 wurden nun auch in JAVA (anonyme) Funktionen (die sog. Lambda-Ausdrücke) eingeführt, die interne Iterationen à la SMALLTALK erlauben. Allerdings wurde für die Implementierung der Methoden forEach, filter, map und reduce (entsprechend SMALLTALKs do, select, collect und inject) ein eigenes Framework geschaffen: die sog. Streams.
Streams sind ein mit JAVA 8 neu eingeführtes Konstrukt, das eine Datenverarbeitung in Pipelines ganz ähnlich wie die Collections in SMALLTALK ermöglicht: Das Ergebnis einer Operation wie filter oder map, auf einem Stream ausgeführt, ist wieder ein Stream, auf dem weitere Operationen dieser Art ausgeführt werden können (das Pipelining). Das Besondere an Streams ist, dass sie keine Datenspeicher wie Collections sind, sondern interne Iteratoren: Jeder Stream für sich hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen. Dabei dienen Streams entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren (wie beispielsweise ein Zufallszahlengenerator oder eine Vorschrift zur Berechnung einer Fibonacci-Folge) als Quelle. Ein Ergebnis liefert eine Stream-Pipeline (die auch aus nur einem Element bestehen kann) immer erst durch einen sog. Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert (eine Collection im Falle von collect).
Das Stream-Framework von JAVA ermöglicht für viele Pipelines eine besonders effiziente Ausführung. So muss jedes Element einer Datenquelle in der Regel nur einmal angefragt werden, und die interne Speicherung von Zwischenergebnissen wird automatisch gering gehalten. Insbesondere wird gegenüber einer naiven Implementierung von Pipelines, die eine Iteration je Element der Pipeline benötigt, in vielen Fällen nur eine Iteration benötigt (die sog. Stream-Fusion). Zudem kann durch die Wahl des Streams (und nicht der Operationen) bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt. Gleichwohl ist die Performanz von JAVA-Pipelines nicht leicht vorherzusagen, und eine gewinnbringende Verwendung setzt sicherlich einiges an Erfahrung und Kenntnissen der Implementierung voraus.","<answer> In JAVA 8 wurden (anonyme) Funktionen, auch bekannt als Lambda-Ausdrücke, eingeführt, um interne Iterationen à la SMALLTALK zu ermöglichen. <answer> <question> Welche neuen Funktionen wurden in JAVA 8 eingeführt, um interne Iterationen zu ermöglichen? <question>"
"Von SMALLTALK kennen Sie bereits die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren (die interne Iteration; siehe Abschnitt 4.6.4 in Kurseinheit 1 und Kapitel 13 in Kurseinheit 2). Mit Version 8 wurden nun auch in JAVA (anonyme) Funktionen (die sog. Lambda-Ausdrücke) eingeführt, die interne Iterationen à la SMALLTALK erlauben. Allerdings wurde für die Implementierung der Methoden forEach, filter, map und reduce (entsprechend SMALLTALKs do, select, collect und inject) ein eigenes Framework geschaffen: die sog. Streams.
Streams sind ein mit JAVA 8 neu eingeführtes Konstrukt, das eine Datenverarbeitung in Pipelines ganz ähnlich wie die Collections in SMALLTALK ermöglicht: Das Ergebnis einer Operation wie filter oder map, auf einem Stream ausgeführt, ist wieder ein Stream, auf dem weitere Operationen dieser Art ausgeführt werden können (das Pipelining). Das Besondere an Streams ist, dass sie keine Datenspeicher wie Collections sind, sondern interne Iteratoren: Jeder Stream für sich hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen. Dabei dienen Streams entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren (wie beispielsweise ein Zufallszahlengenerator oder eine Vorschrift zur Berechnung einer Fibonacci-Folge) als Quelle. Ein Ergebnis liefert eine Stream-Pipeline (die auch aus nur einem Element bestehen kann) immer erst durch einen sog. Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert (eine Collection im Falle von collect).
Das Stream-Framework von JAVA ermöglicht für viele Pipelines eine besonders effiziente Ausführung. So muss jedes Element einer Datenquelle in der Regel nur einmal angefragt werden, und die interne Speicherung von Zwischenergebnissen wird automatisch gering gehalten. Insbesondere wird gegenüber einer naiven Implementierung von Pipelines, die eine Iteration je Element der Pipeline benötigt, in vielen Fällen nur eine Iteration benötigt (die sog. Stream-Fusion). Zudem kann durch die Wahl des Streams (und nicht der Operationen) bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt. Gleichwohl ist die Performanz von JAVA-Pipelines nicht leicht vorherzusagen, und eine gewinnbringende Verwendung setzt sicherlich einiges an Erfahrung und Kenntnissen der Implementierung voraus.","<answer> Für die Implementierung der Methoden forEach, filter, map und reduce in JAVA 8 wurde das Stream-Framework geschaffen. <answer> <question> Welches Framework wurde für die Implementierung der Methoden forEach, filter, map und reduce in JAVA 8 geschaffen? <question>"
"Von SMALLTALK kennen Sie bereits die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren (die interne Iteration; siehe Abschnitt 4.6.4 in Kurseinheit 1 und Kapitel 13 in Kurseinheit 2). Mit Version 8 wurden nun auch in JAVA (anonyme) Funktionen (die sog. Lambda-Ausdrücke) eingeführt, die interne Iterationen à la SMALLTALK erlauben. Allerdings wurde für die Implementierung der Methoden forEach, filter, map und reduce (entsprechend SMALLTALKs do, select, collect und inject) ein eigenes Framework geschaffen: die sog. Streams.
Streams sind ein mit JAVA 8 neu eingeführtes Konstrukt, das eine Datenverarbeitung in Pipelines ganz ähnlich wie die Collections in SMALLTALK ermöglicht: Das Ergebnis einer Operation wie filter oder map, auf einem Stream ausgeführt, ist wieder ein Stream, auf dem weitere Operationen dieser Art ausgeführt werden können (das Pipelining). Das Besondere an Streams ist, dass sie keine Datenspeicher wie Collections sind, sondern interne Iteratoren: Jeder Stream für sich hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen. Dabei dienen Streams entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren (wie beispielsweise ein Zufallszahlengenerator oder eine Vorschrift zur Berechnung einer Fibonacci-Folge) als Quelle. Ein Ergebnis liefert eine Stream-Pipeline (die auch aus nur einem Element bestehen kann) immer erst durch einen sog. Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert (eine Collection im Falle von collect).
Das Stream-Framework von JAVA ermöglicht für viele Pipelines eine besonders effiziente Ausführung. So muss jedes Element einer Datenquelle in der Regel nur einmal angefragt werden, und die interne Speicherung von Zwischenergebnissen wird automatisch gering gehalten. Insbesondere wird gegenüber einer naiven Implementierung von Pipelines, die eine Iteration je Element der Pipeline benötigt, in vielen Fällen nur eine Iteration benötigt (die sog. Stream-Fusion). Zudem kann durch die Wahl des Streams (und nicht der Operationen) bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt. Gleichwohl ist die Performanz von JAVA-Pipelines nicht leicht vorherzusagen, und eine gewinnbringende Verwendung setzt sicherlich einiges an Erfahrung und Kenntnissen der Implementierung voraus.","<answer> Streams unterscheiden sich von Collections in JAVA dadurch, dass sie keine Datenspeicher sind, sondern interne Iteratoren. Jeder Stream hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen. <answer> <question> Wie unterscheiden sich Streams von Collections in JAVA? <question>"
"Von SMALLTALK kennen Sie bereits die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren (die interne Iteration; siehe Abschnitt 4.6.4 in Kurseinheit 1 und Kapitel 13 in Kurseinheit 2). Mit Version 8 wurden nun auch in JAVA (anonyme) Funktionen (die sog. Lambda-Ausdrücke) eingeführt, die interne Iterationen à la SMALLTALK erlauben. Allerdings wurde für die Implementierung der Methoden forEach, filter, map und reduce (entsprechend SMALLTALKs do, select, collect und inject) ein eigenes Framework geschaffen: die sog. Streams.
Streams sind ein mit JAVA 8 neu eingeführtes Konstrukt, das eine Datenverarbeitung in Pipelines ganz ähnlich wie die Collections in SMALLTALK ermöglicht: Das Ergebnis einer Operation wie filter oder map, auf einem Stream ausgeführt, ist wieder ein Stream, auf dem weitere Operationen dieser Art ausgeführt werden können (das Pipelining). Das Besondere an Streams ist, dass sie keine Datenspeicher wie Collections sind, sondern interne Iteratoren: Jeder Stream für sich hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen. Dabei dienen Streams entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren (wie beispielsweise ein Zufallszahlengenerator oder eine Vorschrift zur Berechnung einer Fibonacci-Folge) als Quelle. Ein Ergebnis liefert eine Stream-Pipeline (die auch aus nur einem Element bestehen kann) immer erst durch einen sog. Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert (eine Collection im Falle von collect).
Das Stream-Framework von JAVA ermöglicht für viele Pipelines eine besonders effiziente Ausführung. So muss jedes Element einer Datenquelle in der Regel nur einmal angefragt werden, und die interne Speicherung von Zwischenergebnissen wird automatisch gering gehalten. Insbesondere wird gegenüber einer naiven Implementierung von Pipelines, die eine Iteration je Element der Pipeline benötigt, in vielen Fällen nur eine Iteration benötigt (die sog. Stream-Fusion). Zudem kann durch die Wahl des Streams (und nicht der Operationen) bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt. Gleichwohl ist die Performanz von JAVA-Pipelines nicht leicht vorherzusagen, und eine gewinnbringende Verwendung setzt sicherlich einiges an Erfahrung und Kenntnissen der Implementierung voraus.","<answer> Eine Stream-Pipeline in JAVA liefert ein Ergebnis immer erst durch einen sogenannten Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert, beispielsweise eine Collection im Falle von collect. <answer> <question> Wann liefert eine Stream-Pipeline in JAVA ein Ergebnis? <question>"
"Von SMALLTALK kennen Sie bereits die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren (die interne Iteration; siehe Abschnitt 4.6.4 in Kurseinheit 1 und Kapitel 13 in Kurseinheit 2). Mit Version 8 wurden nun auch in JAVA (anonyme) Funktionen (die sog. Lambda-Ausdrücke) eingeführt, die interne Iterationen à la SMALLTALK erlauben. Allerdings wurde für die Implementierung der Methoden forEach, filter, map und reduce (entsprechend SMALLTALKs do, select, collect und inject) ein eigenes Framework geschaffen: die sog. Streams.
Streams sind ein mit JAVA 8 neu eingeführtes Konstrukt, das eine Datenverarbeitung in Pipelines ganz ähnlich wie die Collections in SMALLTALK ermöglicht: Das Ergebnis einer Operation wie filter oder map, auf einem Stream ausgeführt, ist wieder ein Stream, auf dem weitere Operationen dieser Art ausgeführt werden können (das Pipelining). Das Besondere an Streams ist, dass sie keine Datenspeicher wie Collections sind, sondern interne Iteratoren: Jeder Stream für sich hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen. Dabei dienen Streams entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren (wie beispielsweise ein Zufallszahlengenerator oder eine Vorschrift zur Berechnung einer Fibonacci-Folge) als Quelle. Ein Ergebnis liefert eine Stream-Pipeline (die auch aus nur einem Element bestehen kann) immer erst durch einen sog. Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert (eine Collection im Falle von collect).
Das Stream-Framework von JAVA ermöglicht für viele Pipelines eine besonders effiziente Ausführung. So muss jedes Element einer Datenquelle in der Regel nur einmal angefragt werden, und die interne Speicherung von Zwischenergebnissen wird automatisch gering gehalten. Insbesondere wird gegenüber einer naiven Implementierung von Pipelines, die eine Iteration je Element der Pipeline benötigt, in vielen Fällen nur eine Iteration benötigt (die sog. Stream-Fusion). Zudem kann durch die Wahl des Streams (und nicht der Operationen) bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt. Gleichwohl ist die Performanz von JAVA-Pipelines nicht leicht vorherzusagen, und eine gewinnbringende Verwendung setzt sicherlich einiges an Erfahrung und Kenntnissen der Implementierung voraus.","<answer> Das Stream-Framework von JAVA ermöglicht für viele Pipelines eine besonders effiziente Ausführung. Es minimiert die Anzahl der Iterationen, reduziert die interne Speicherung von Zwischenergebnissen und erlaubt die Auswahl zwischen paralleler und sequenzieller Verarbeitung der Pipeline. Dennoch ist die Performanz von JAVA-Pipelines nicht leicht vorherzusagen und erfordert Erfahrung und Kenntnisse der Implementierung. <answer> <question> Welche Vorteile bietet das Stream-Framework von JAVA im Vergleich zu naiven Implementierungen von Pipelines? <question>"
"In SMALLTALK sind Klassen Instanzen von Metaklassen, die selbst Instanzen einer weiteren Klasse sind, und alle diese zusammen sind Objekte. Daher ist jedes SMALLTALK-Programm, ja das ganze SMALLTALK-System, nichts weiter als ein Geflecht von Objekten (abgesehen von den primitiven Methoden). SMALLTALK ist somit nicht nur ein Programmiersystem, sondern auch ein Metaprogrammiersystem in der Tradition funktionaler und logischer Programmiersprachen wie LISP und PROLOG. In der Welt der imperativen und objektorientierten Programmiersprachen sucht diese Mächtigkeit bis heute ihresgleichen.
Als Programmiererin, die nicht gleich eine neue Sprache entwickeln möchte, werden Sie wahrscheinlich nicht in die Ebene der Metaklassen hinabsteigen oder diese gar selbst ändern. Wenn Sie beispielsweise möchten, dass beim Erstellen einer neuen Klasse automatisch Zugriffsmethoden für alle benannten Instanzvariablen dieser Klasse generiert werden, ist dies leicht möglich, indem Sie an der entsprechenden Stelle (z. B. in der Klasse ""Class"" oder ""Behavior"", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert.
Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.","<answer> In SMALLTALK wird die Mächtigkeit eines Programms hervorgehoben, indem betont wird, dass Klassen Instanzen von Metaklassen sind, die selbst Instanzen einer weiteren Klasse sind. Dieses Zusammenspiel von Klassen und Metaklassen ermöglicht eine hohe Programmiermächtigkeit. Im Vergleich zu imperativen und objektorientierten Programmiersprachen sucht diese Mächtigkeit bis heute ihresgleichen. <answer> <question> Wie wird in SMALLTALK die Mächtigkeit eines Programms hervorgehoben, insbesondere im Vergleich zu imperativen und objektorientierten Programmiersprachen? <question>"
"In SMALLTALK sind Klassen Instanzen von Metaklassen, die selbst Instanzen einer weiteren Klasse sind, und alle diese zusammen sind Objekte. Daher ist jedes SMALLTALK-Programm, ja das ganze SMALLTALK-System, nichts weiter als ein Geflecht von Objekten (abgesehen von den primitiven Methoden). SMALLTALK ist somit nicht nur ein Programmiersystem, sondern auch ein Metaprogrammiersystem in der Tradition funktionaler und logischer Programmiersprachen wie LISP und PROLOG. In der Welt der imperativen und objektorientierten Programmiersprachen sucht diese Mächtigkeit bis heute ihresgleichen.
Als Programmiererin, die nicht gleich eine neue Sprache entwickeln möchte, werden Sie wahrscheinlich nicht in die Ebene der Metaklassen hinabsteigen oder diese gar selbst ändern. Wenn Sie beispielsweise möchten, dass beim Erstellen einer neuen Klasse automatisch Zugriffsmethoden für alle benannten Instanzvariablen dieser Klasse generiert werden, ist dies leicht möglich, indem Sie an der entsprechenden Stelle (z. B. in der Klasse ""Class"" oder ""Behavior"", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert.
Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.","<answer> Metaklassen haben in SMALLTALK die praktische Bedeutung, dass sie die Definition von Klassen steuern und die Struktur des Programms beeinflussen. Sie ermöglichen es, Klassen dynamisch zu erzeugen und zu verändern. Zum Beispiel können Sie an der Ebene der Metaklassen Methoden hinzufügen, um das Verhalten von Klassen zu ändern, ohne die Klassen selbst zu ändern. <answer> <question> Welche praktische Bedeutung haben Metaklassen für die Programmierung in SMALLTALK? <question>"
"In SMALLTALK sind Klassen Instanzen von Metaklassen, die selbst Instanzen einer weiteren Klasse sind, und alle diese zusammen sind Objekte. Daher ist jedes SMALLTALK-Programm, ja das ganze SMALLTALK-System, nichts weiter als ein Geflecht von Objekten (abgesehen von den primitiven Methoden). SMALLTALK ist somit nicht nur ein Programmiersystem, sondern auch ein Metaprogrammiersystem in der Tradition funktionaler und logischer Programmiersprachen wie LISP und PROLOG. In der Welt der imperativen und objektorientierten Programmiersprachen sucht diese Mächtigkeit bis heute ihresgleichen.
Als Programmiererin, die nicht gleich eine neue Sprache entwickeln möchte, werden Sie wahrscheinlich nicht in die Ebene der Metaklassen hinabsteigen oder diese gar selbst ändern. Wenn Sie beispielsweise möchten, dass beim Erstellen einer neuen Klasse automatisch Zugriffsmethoden für alle benannten Instanzvariablen dieser Klasse generiert werden, ist dies leicht möglich, indem Sie an der entsprechenden Stelle (z. B. in der Klasse ""Class"" oder ""Behavior"", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert.
Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.","<answer> Programmierer können in SMALLTALK an der entsprechenden Stelle (z. B. in der Klasse ""Class"" oder ""Behavior"", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden (Accessoren) für ausgewählte Instanzvariablen erweitert. Dies ermöglicht es, Zugriffsmethoden für Instanzvariablen automatisch zu generieren. <answer> <question> Was können Programmierer tun, um automatisch Zugriffsmethoden für Instanzvariablen in SMALLTALK zu generieren? <question>"
"In SMALLTALK sind Klassen Instanzen von Metaklassen, die selbst Instanzen einer weiteren Klasse sind, und alle diese zusammen sind Objekte. Daher ist jedes SMALLTALK-Programm, ja das ganze SMALLTALK-System, nichts weiter als ein Geflecht von Objekten (abgesehen von den primitiven Methoden). SMALLTALK ist somit nicht nur ein Programmiersystem, sondern auch ein Metaprogrammiersystem in der Tradition funktionaler und logischer Programmiersprachen wie LISP und PROLOG. In der Welt der imperativen und objektorientierten Programmiersprachen sucht diese Mächtigkeit bis heute ihresgleichen.
Als Programmiererin, die nicht gleich eine neue Sprache entwickeln möchte, werden Sie wahrscheinlich nicht in die Ebene der Metaklassen hinabsteigen oder diese gar selbst ändern. Wenn Sie beispielsweise möchten, dass beim Erstellen einer neuen Klasse automatisch Zugriffsmethoden für alle benannten Instanzvariablen dieser Klasse generiert werden, ist dies leicht möglich, indem Sie an der entsprechenden Stelle (z. B. in der Klasse ""Class"" oder ""Behavior"", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert.
Im täglichen Programmieralltag werden Sie dies jedoch wahrscheinlich nicht tun. Stattdessen beschränkt sich Ihre Arbeit darauf, einfache Klassen anzulegen und zu ändern, also Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.","<answer> Im täglichen Programmieralltag beschränken sich die Aufgaben der Programmierer im Zusammenhang mit Metaklassen darauf, einfache Klassen anzulegen und zu ändern, insbesondere Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar. <answer> <question> Was ist die Hauptaufgabe von Programmierern im täglichen Programmieralltag im Zusammenhang mit Metaklassen? <question>"
"Indexer übertragen gewissermaßen das Konzept der indizierten Instanzvariablen von SMALLTALK auf C#: Jede Instanz einer Klasse, für die ein Indexer definiert ist, hat eine Menge von (scheinbar unbenannten) Instanzvariablen, auf die über einen Index zugegriffen werden kann. Allerdings muss die indizierte Instanzvariable klassenintern durch eine normale, benannte Instanzvariable (Feld) repräsentiert werden. Indexer ähneln Properties insofern, als der Zugriff über einen Index mittels entsprechender Get- und Set-Abbildungen auf einen Zugriff auf eine benannte Instanzvariable übertragen wird.
Dabei wird das Schlüsselwort ""this"" missbraucht, um anzudeuten, dass bei Zugriffen auf die indizierte Instanzvariable kein Name einer Instanzvariable (eines Feldes) steht, sondern lediglich der Name des Objekts, zu dem sie gehört.
Nun darf der Indexer in C# überladen werden, sodass ein Objekt mehrere indizierte Instanzvariablen haben kann. Der Zugriff erfolgt aufgrund des fehlenden Namens einzig über den Typ des Indexes. Durch das Überladen ist es wiederum möglich, nicht eine, sondern mehrere indizierte Instanzvariablen zu simulieren, wobei jedoch die Einschränkung besteht, dass der Elementtyp (der Rückgabetyp beim Überladen) gleich bleiben muss. Schließlich muss ein Indexer in C# auf keine interne (benannte) Instanzvariable zugreifen – alle Inhalte können, genau wie bei Properties, auch berechnet werden.","<answer> Indexer in C# sind eine Möglichkeit, auf indizierte Instanzvariablen zuzugreifen, ähnlich dem Konzept der indizierten Instanzvariablen in SMALLTALK. Jede Instanz einer Klasse mit einem Indexer hat eine Menge von indizierten Instanzvariablen, auf die über einen Index zugegriffen werden kann. Indexer verwenden Get- und Set-Methoden, um den Zugriff auf diese indizierten Variablen zu ermöglichen. Sie ähneln Properties insofern, als der Zugriff über einen Index mithilfe von Get- und Set-Abbildungen auf eine benannte Instanzvariable übertragen wird. <answer> <question> Was sind Indexer in C# und wie ähneln sie Properties? <question>"
"Indexer übertragen gewissermaßen das Konzept der indizierten Instanzvariablen von SMALLTALK auf C#: Jede Instanz einer Klasse, für die ein Indexer definiert ist, hat eine Menge von (scheinbar unbenannten) Instanzvariablen, auf die über einen Index zugegriffen werden kann. Allerdings muss die indizierte Instanzvariable klassenintern durch eine normale, benannte Instanzvariable (Feld) repräsentiert werden. Indexer ähneln Properties insofern, als der Zugriff über einen Index mittels entsprechender Get- und Set-Abbildungen auf einen Zugriff auf eine benannte Instanzvariable übertragen wird.
Dabei wird das Schlüsselwort ""this"" missbraucht, um anzudeuten, dass bei Zugriffen auf die indizierte Instanzvariable kein Name einer Instanzvariable (eines Feldes) steht, sondern lediglich der Name des Objekts, zu dem sie gehört.
Nun darf der Indexer in C# überladen werden, sodass ein Objekt mehrere indizierte Instanzvariablen haben kann. Der Zugriff erfolgt aufgrund des fehlenden Namens einzig über den Typ des Indexes. Durch das Überladen ist es wiederum möglich, nicht eine, sondern mehrere indizierte Instanzvariablen zu simulieren, wobei jedoch die Einschränkung besteht, dass der Elementtyp (der Rückgabetyp beim Überladen) gleich bleiben muss. Schließlich muss ein Indexer in C# auf keine interne (benannte) Instanzvariable zugreifen – alle Inhalte können, genau wie bei Properties, auch berechnet werden.","<answer> Ja, Indexer in C# können überladen werden, um mehrere indizierte Instanzvariablen zu simulieren. Dies ermöglicht einem Objekt, mehrere indizierte Variablen mit unterschiedlichen Indexen zu haben. Die Einschränkung dabei ist, dass der Rückgabetyp (Elementtyp) beim Überladen gleich bleiben muss. Indexer können auch berechnete Werte zurückgeben, ohne auf interne Instanzvariablen zuzugreifen, ähnlich wie Properties. <answer> <question> Können Indexer in C# überladen werden und mehrere indizierte Instanzvariablen simulieren? <question>"
"In JAVA wird, genau wie in SMALLTALK, zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) (wobei (.) hier für einen nicht näher spezifizierten Parameter steht) geprüft, die Identität mittels == (bzw. != für das Negativ). equals(.) wird von der Klasse Object (in JAVA genau wie in SMALLTALK die Superklasse aller Klassen) geerbt und sollte in den Subklassen entsprechend der jeweiligen Bedeutung von Gleichheit überschrieben werden. Die Verwechslung von equals(.) und == ist auch in JAVA ein ziemlich häufiger Programmierfehler (siehe Abschnitt 1.4 in Kurseinheit 1). Das Gleichheitszeichen = steht in JAVA übrigens (genau wie in C, C++ und C#) für die Wertzuweisung, was ich persönlich für eine der großen Tragödien in der Informatik halte.","<answer> In JAVA wird zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) geprüft, während die Identität mittels == (bzw. !=) überprüft wird. <answer> <question> Wie wird in JAVA zwischen Gleichheit und Identität von Objekten unterschieden? <question>"
"In JAVA wird, genau wie in SMALLTALK, zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) (wobei (.) hier für einen nicht näher spezifizierten Parameter steht) geprüft, die Identität mittels == (bzw. != für das Negativ). equals(.) wird von der Klasse Object (in JAVA genau wie in SMALLTALK die Superklasse aller Klassen) geerbt und sollte in den Subklassen entsprechend der jeweiligen Bedeutung von Gleichheit überschrieben werden. Die Verwechslung von equals(.) und == ist auch in JAVA ein ziemlich häufiger Programmierfehler (siehe Abschnitt 1.4 in Kurseinheit 1). Das Gleichheitszeichen = steht in JAVA übrigens (genau wie in C, C++ und C#) für die Wertzuweisung, was ich persönlich für eine der großen Tragödien in der Informatik halte.","<answer> In JAVA wird die Methode equals(.) verwendet, um die Gleichheit von Objekten zu prüfen. <answer> <question> Welche Methode wird in JAVA verwendet, um die Gleichheit von Objekten zu prüfen? <question>"
"In JAVA wird, genau wie in SMALLTALK, zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) (wobei (.) hier für einen nicht näher spezifizierten Parameter steht) geprüft, die Identität mittels == (bzw. != für das Negativ). equals(.) wird von der Klasse Object (in JAVA genau wie in SMALLTALK die Superklasse aller Klassen) geerbt und sollte in den Subklassen entsprechend der jeweiligen Bedeutung von Gleichheit überschrieben werden. Die Verwechslung von equals(.) und == ist auch in JAVA ein ziemlich häufiger Programmierfehler (siehe Abschnitt 1.4 in Kurseinheit 1). Das Gleichheitszeichen = steht in JAVA übrigens (genau wie in C, C++ und C#) für die Wertzuweisung, was ich persönlich für eine der großen Tragödien in der Informatik halte.","<answer> Die Methode equals(.) wird von der Klasse Object geerbt, die in JAVA die Superklasse aller Klassen ist. <answer> <question> Welche Klasse erbt die Methode equals(.) in JAVA? <question>"
"In JAVA wird, genau wie in SMALLTALK, zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) (wobei (.) hier für einen nicht näher spezifizierten Parameter steht) geprüft, die Identität mittels == (bzw. != für das Negativ). equals(.) wird von der Klasse Object (in JAVA genau wie in SMALLTALK die Superklasse aller Klassen) geerbt und sollte in den Subklassen entsprechend der jeweiligen Bedeutung von Gleichheit überschrieben werden. Die Verwechslung von equals(.) und == ist auch in JAVA ein ziemlich häufiger Programmierfehler (siehe Abschnitt 1.4 in Kurseinheit 1). Das Gleichheitszeichen = steht in JAVA übrigens (genau wie in C, C++ und C#) für die Wertzuweisung, was ich persönlich für eine der großen Tragödien in der Informatik halte.","<answer> Die Verwechslung von equals(.) und == ist auch in JAVA ein häufiger Programmierfehler, da sie unterschiedliche Bedeutungen haben. equals(.) prüft die Gleichheit von Objekten, während == die Identität überprüft. <answer> <question> Warum ist die Verwechslung von equals(.) und == ein häufiger Programmierfehler in JAVA? <question>"
"In JAVA wird, genau wie in SMALLTALK, zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) (wobei (.) hier für einen nicht näher spezifizierten Parameter steht) geprüft, die Identität mittels == (bzw. != für das Negativ). equals(.) wird von der Klasse Object (in JAVA genau wie in SMALLTALK die Superklasse aller Klassen) geerbt und sollte in den Subklassen entsprechend der jeweiligen Bedeutung von Gleichheit überschrieben werden. Die Verwechslung von equals(.) und == ist auch in JAVA ein ziemlich häufiger Programmierfehler (siehe Abschnitt 1.4 in Kurseinheit 1). Das Gleichheitszeichen = steht in JAVA übrigens (genau wie in C, C++ und C#) für die Wertzuweisung, was ich persönlich für eine der großen Tragödien in der Informatik halte.","<answer> Das Gleichheitszeichen = in JAVA steht für die Wertzuweisung, nicht für die Überprüfung der Gleichheit von Objekten. <answer> <question> Wofür steht das Gleichheitszeichen = in JAVA? <question>"
"Die Typisierung von Variablen (und anderen Programmelementen – wenn im nachfolgenden nur von Variablen die Rede ist, dann sind letztere meistens mitgemeint) soll also bewirken, dass in einem Programm jede Variable nur die Werte haben kann, für die sie (die Variable) vorgesehen ist (die Einhaltung der Typinvariante). Voraussetzung dafür ist zum einen, dass jeder Variable ein Typ zugeordnet ist, zum anderen, dass auch jedes Objekt sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Ersteres geschieht in sogenannten Variablendeklarationen, letzteres ergibt sich aus den zu einem Typsystem gehörenden Regeln zur Zuordnung eines Typs zu Ausdrücken, nämlich bei Literalen aus der Art des Literals, dessen Typ dem Compiler bekannt ist, bei der Instanziierung aus dem noch zu klärenden Zusammenhang von der instanziierten Klasse mit den Typen eines Programms sowie bei Nachrichtenausdrücken aus der Deklaration der dazugehörigen Methode, die ja (genau wie eine Variablendeklaration) angeben muss, welchen Typs die Objekte sind, die sie liefert.
Es bleibt die Frage nach den ebenfalls zu einem Typsystem gehörenden Typregeln, die von Ausdrücken einzuhalten sind, nämlich wie die Typkorrektheit bzw. andernfalls die Verletzung einer Typinvariante genau festgestellt wird. Es ist ja bereits klar, dass es dazu ausreicht, die Wertzuweisungen in einem Programm zu überprüfen. Diese Überprüfung findet in der Regel in Form der Feststellung der sog. Zuweisungskompatibilität statt. Die Sprachregelung ist hier leider nicht ganz einheitlich, aber im folgenden gehen wir davon aus, dass alle typisierten Sprachen den Begriff der Zuweisungskompatibilität kennen und sich lediglich in ihren Definitionen der Regeln, die für das Bestehen einer Zuweisungskompatibilität eingehalten werden müssen, unterscheiden. Vor allem darum wird es in den nächsten Kapiteln gehen.
Dann sind, unter der Annahme, dass 12 vom Typ Integer ist und true vom Typ Boolean, die Zuweisungen zulässig (da sie keine Typinvariante verletzen), hingegen nicht. Ist eine Zuweisung zulässig, dann spricht man auch von einer Zuweisungskompatibilität der beteiligten Typen. Die für das Programmieren relevante Implikation ist allerdings die umgekehrte: Wenn zwei Typen zuweisungskompatibel sind, dann gilt, dass eine entsprechende Zuweisung zulässig ist, also zu keiner Verletzung einer Typinvariante führt. Wie Sie noch sehen werden, verlangt Zuweisungskompatibilität keineswegs identische Typen; daraus ergibt sich aber eine sprachliche Uneindeutigkeit, die zunächst behoben werden muss.
Dem Satz „a ist zuweisungskompatibel mit b“ kann man nicht eindeutig entnehmen, ob nun a b zugewiesen werden kann oder b a. Dass beides geht, ist nur dann der Fall, wenn die beteiligten Typen äquivalent in einem noch zu bestimmenden Sinne sind, was aber, wie schon gesagt, nicht unbedingt der Fall sein muss. Im folgenden soll daher die Richtung der erlaubten Zuweisung so gelesen werden, dass beim Satz „a ist zuweisungskompatibel mit b“ die Zuweisung b := a zulässig ist. Die umgekehrte Richtung, a := b, kann ebenfalls zulässig sein; dies wird durch den Satz jedoch nicht ausgesagt. Zuweisungskompatibilität ist übrigens (in der Regel) eine transitive Eigenschaft: Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c, dann ist auch a zuweisungskompatibel mit c.
Auch bei impliziten Zuweisungen wie der Parameterübergabe von Methodenaufrufen (den dabei stattfindenden Zuweisungen der tatsächlichen an die formalen Parameter; s. Abschnitt 4.3.2) impliziert Zuweisungskompatibilität Typkorrektheit. Außerdem kann eine Methode, wenn sie Werte zurückgibt, ja selbst in rechten Seiten von Zuweisungen auftreten; der Typ dieser Werte muss dann mit der Variable auf der linken Seite zuweisungskompatibel sein.","<answer> Die Typisierung von Variablen und Ausdrücken in einem Programm ist wichtig, um sicherzustellen, dass jede Variable nur Werte haben kann, für die sie vorgesehen ist. Dies gewährleistet die Einhaltung der Typinvariante und verhindert Typfehler im Programm. <answer> <question> Warum ist die Typisierung von Variablen und Ausdrücken in einem Programm wichtig? <question>"
"Die Typisierung von Variablen (und anderen Programmelementen – wenn im nachfolgenden nur von Variablen die Rede ist, dann sind letztere meistens mitgemeint) soll also bewirken, dass in einem Programm jede Variable nur die Werte haben kann, für die sie (die Variable) vorgesehen ist (die Einhaltung der Typinvariante). Voraussetzung dafür ist zum einen, dass jeder Variable ein Typ zugeordnet ist, zum anderen, dass auch jedes Objekt sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Ersteres geschieht in sogenannten Variablendeklarationen, letzteres ergibt sich aus den zu einem Typsystem gehörenden Regeln zur Zuordnung eines Typs zu Ausdrücken, nämlich bei Literalen aus der Art des Literals, dessen Typ dem Compiler bekannt ist, bei der Instanziierung aus dem noch zu klärenden Zusammenhang von der instanziierten Klasse mit den Typen eines Programms sowie bei Nachrichtenausdrücken aus der Deklaration der dazugehörigen Methode, die ja (genau wie eine Variablendeklaration) angeben muss, welchen Typs die Objekte sind, die sie liefert.
Es bleibt die Frage nach den ebenfalls zu einem Typsystem gehörenden Typregeln, die von Ausdrücken einzuhalten sind, nämlich wie die Typkorrektheit bzw. andernfalls die Verletzung einer Typinvariante genau festgestellt wird. Es ist ja bereits klar, dass es dazu ausreicht, die Wertzuweisungen in einem Programm zu überprüfen. Diese Überprüfung findet in der Regel in Form der Feststellung der sog. Zuweisungskompatibilität statt. Die Sprachregelung ist hier leider nicht ganz einheitlich, aber im folgenden gehen wir davon aus, dass alle typisierten Sprachen den Begriff der Zuweisungskompatibilität kennen und sich lediglich in ihren Definitionen der Regeln, die für das Bestehen einer Zuweisungskompatibilität eingehalten werden müssen, unterscheiden. Vor allem darum wird es in den nächsten Kapiteln gehen.
Dann sind, unter der Annahme, dass 12 vom Typ Integer ist und true vom Typ Boolean, die Zuweisungen zulässig (da sie keine Typinvariante verletzen), hingegen nicht. Ist eine Zuweisung zulässig, dann spricht man auch von einer Zuweisungskompatibilität der beteiligten Typen. Die für das Programmieren relevante Implikation ist allerdings die umgekehrte: Wenn zwei Typen zuweisungskompatibel sind, dann gilt, dass eine entsprechende Zuweisung zulässig ist, also zu keiner Verletzung einer Typinvariante führt. Wie Sie noch sehen werden, verlangt Zuweisungskompatibilität keineswegs identische Typen; daraus ergibt sich aber eine sprachliche Uneindeutigkeit, die zunächst behoben werden muss.
Dem Satz „a ist zuweisungskompatibel mit b“ kann man nicht eindeutig entnehmen, ob nun a b zugewiesen werden kann oder b a. Dass beides geht, ist nur dann der Fall, wenn die beteiligten Typen äquivalent in einem noch zu bestimmenden Sinne sind, was aber, wie schon gesagt, nicht unbedingt der Fall sein muss. Im folgenden soll daher die Richtung der erlaubten Zuweisung so gelesen werden, dass beim Satz „a ist zuweisungskompatibel mit b“ die Zuweisung b := a zulässig ist. Die umgekehrte Richtung, a := b, kann ebenfalls zulässig sein; dies wird durch den Satz jedoch nicht ausgesagt. Zuweisungskompatibilität ist übrigens (in der Regel) eine transitive Eigenschaft: Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c, dann ist auch a zuweisungskompatibel mit c.
Auch bei impliziten Zuweisungen wie der Parameterübergabe von Methodenaufrufen (den dabei stattfindenden Zuweisungen der tatsächlichen an die formalen Parameter; s. Abschnitt 4.3.2) impliziert Zuweisungskompatibilität Typkorrektheit. Außerdem kann eine Methode, wenn sie Werte zurückgibt, ja selbst in rechten Seiten von Zuweisungen auftreten; der Typ dieser Werte muss dann mit der Variable auf der linken Seite zuweisungskompatibel sein.","<answer> Typen werden in Variablendeklarationen explizit angegeben, um jedem Objekt und Ausdruck im Programm einen Typ zuzuordnen. <answer> <question> Wie werden Typen in Variablendeklarationen zugeordnet? <question>"
"Die Typisierung von Variablen (und anderen Programmelementen – wenn im nachfolgenden nur von Variablen die Rede ist, dann sind letztere meistens mitgemeint) soll also bewirken, dass in einem Programm jede Variable nur die Werte haben kann, für die sie (die Variable) vorgesehen ist (die Einhaltung der Typinvariante). Voraussetzung dafür ist zum einen, dass jeder Variable ein Typ zugeordnet ist, zum anderen, dass auch jedes Objekt sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Ersteres geschieht in sogenannten Variablendeklarationen, letzteres ergibt sich aus den zu einem Typsystem gehörenden Regeln zur Zuordnung eines Typs zu Ausdrücken, nämlich bei Literalen aus der Art des Literals, dessen Typ dem Compiler bekannt ist, bei der Instanziierung aus dem noch zu klärenden Zusammenhang von der instanziierten Klasse mit den Typen eines Programms sowie bei Nachrichtenausdrücken aus der Deklaration der dazugehörigen Methode, die ja (genau wie eine Variablendeklaration) angeben muss, welchen Typs die Objekte sind, die sie liefert.
Es bleibt die Frage nach den ebenfalls zu einem Typsystem gehörenden Typregeln, die von Ausdrücken einzuhalten sind, nämlich wie die Typkorrektheit bzw. andernfalls die Verletzung einer Typinvariante genau festgestellt wird. Es ist ja bereits klar, dass es dazu ausreicht, die Wertzuweisungen in einem Programm zu überprüfen. Diese Überprüfung findet in der Regel in Form der Feststellung der sog. Zuweisungskompatibilität statt. Die Sprachregelung ist hier leider nicht ganz einheitlich, aber im folgenden gehen wir davon aus, dass alle typisierten Sprachen den Begriff der Zuweisungskompatibilität kennen und sich lediglich in ihren Definitionen der Regeln, die für das Bestehen einer Zuweisungskompatibilität eingehalten werden müssen, unterscheiden. Vor allem darum wird es in den nächsten Kapiteln gehen.
Dann sind, unter der Annahme, dass 12 vom Typ Integer ist und true vom Typ Boolean, die Zuweisungen zulässig (da sie keine Typinvariante verletzen), hingegen nicht. Ist eine Zuweisung zulässig, dann spricht man auch von einer Zuweisungskompatibilität der beteiligten Typen. Die für das Programmieren relevante Implikation ist allerdings die umgekehrte: Wenn zwei Typen zuweisungskompatibel sind, dann gilt, dass eine entsprechende Zuweisung zulässig ist, also zu keiner Verletzung einer Typinvariante führt. Wie Sie noch sehen werden, verlangt Zuweisungskompatibilität keineswegs identische Typen; daraus ergibt sich aber eine sprachliche Uneindeutigkeit, die zunächst behoben werden muss.
Dem Satz „a ist zuweisungskompatibel mit b“ kann man nicht eindeutig entnehmen, ob nun a b zugewiesen werden kann oder b a. Dass beides geht, ist nur dann der Fall, wenn die beteiligten Typen äquivalent in einem noch zu bestimmenden Sinne sind, was aber, wie schon gesagt, nicht unbedingt der Fall sein muss. Im folgenden soll daher die Richtung der erlaubten Zuweisung so gelesen werden, dass beim Satz „a ist zuweisungskompatibel mit b“ die Zuweisung b := a zulässig ist. Die umgekehrte Richtung, a := b, kann ebenfalls zulässig sein; dies wird durch den Satz jedoch nicht ausgesagt. Zuweisungskompatibilität ist übrigens (in der Regel) eine transitive Eigenschaft: Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c, dann ist auch a zuweisungskompatibel mit c.
Auch bei impliziten Zuweisungen wie der Parameterübergabe von Methodenaufrufen (den dabei stattfindenden Zuweisungen der tatsächlichen an die formalen Parameter; s. Abschnitt 4.3.2) impliziert Zuweisungskompatibilität Typkorrektheit. Außerdem kann eine Methode, wenn sie Werte zurückgibt, ja selbst in rechten Seiten von Zuweisungen auftreten; der Typ dieser Werte muss dann mit der Variable auf der linken Seite zuweisungskompatibel sein.","<answer> Die Zuweisungskompatibilität ist wichtig, um festzustellen, ob Zuweisungen zwischen Variablen oder Ausdrücken zulässig sind, ohne die Typinvariante zu verletzen. Sie stellt sicher, dass die Typen der beteiligten Objekte oder Ausdrücke kompatibel sind, um Typfehler zu vermeiden. <answer> <question> Was ist die Zuweisungskompatibilität, und warum ist sie wichtig? <question>"
"Die Typisierung von Variablen (und anderen Programmelementen – wenn im nachfolgenden nur von Variablen die Rede ist, dann sind letztere meistens mitgemeint) soll also bewirken, dass in einem Programm jede Variable nur die Werte haben kann, für die sie (die Variable) vorgesehen ist (die Einhaltung der Typinvariante). Voraussetzung dafür ist zum einen, dass jeder Variable ein Typ zugeordnet ist, zum anderen, dass auch jedes Objekt sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Ersteres geschieht in sogenannten Variablendeklarationen, letzteres ergibt sich aus den zu einem Typsystem gehörenden Regeln zur Zuordnung eines Typs zu Ausdrücken, nämlich bei Literalen aus der Art des Literals, dessen Typ dem Compiler bekannt ist, bei der Instanziierung aus dem noch zu klärenden Zusammenhang von der instanziierten Klasse mit den Typen eines Programms sowie bei Nachrichtenausdrücken aus der Deklaration der dazugehörigen Methode, die ja (genau wie eine Variablendeklaration) angeben muss, welchen Typs die Objekte sind, die sie liefert.
Es bleibt die Frage nach den ebenfalls zu einem Typsystem gehörenden Typregeln, die von Ausdrücken einzuhalten sind, nämlich wie die Typkorrektheit bzw. andernfalls die Verletzung einer Typinvariante genau festgestellt wird. Es ist ja bereits klar, dass es dazu ausreicht, die Wertzuweisungen in einem Programm zu überprüfen. Diese Überprüfung findet in der Regel in Form der Feststellung der sog. Zuweisungskompatibilität statt. Die Sprachregelung ist hier leider nicht ganz einheitlich, aber im folgenden gehen wir davon aus, dass alle typisierten Sprachen den Begriff der Zuweisungskompatibilität kennen und sich lediglich in ihren Definitionen der Regeln, die für das Bestehen einer Zuweisungskompatibilität eingehalten werden müssen, unterscheiden. Vor allem darum wird es in den nächsten Kapiteln gehen.
Dann sind, unter der Annahme, dass 12 vom Typ Integer ist und true vom Typ Boolean, die Zuweisungen zulässig (da sie keine Typinvariante verletzen), hingegen nicht. Ist eine Zuweisung zulässig, dann spricht man auch von einer Zuweisungskompatibilität der beteiligten Typen. Die für das Programmieren relevante Implikation ist allerdings die umgekehrte: Wenn zwei Typen zuweisungskompatibel sind, dann gilt, dass eine entsprechende Zuweisung zulässig ist, also zu keiner Verletzung einer Typinvariante führt. Wie Sie noch sehen werden, verlangt Zuweisungskompatibilität keineswegs identische Typen; daraus ergibt sich aber eine sprachliche Uneindeutigkeit, die zunächst behoben werden muss.
Dem Satz „a ist zuweisungskompatibel mit b“ kann man nicht eindeutig entnehmen, ob nun a b zugewiesen werden kann oder b a. Dass beides geht, ist nur dann der Fall, wenn die beteiligten Typen äquivalent in einem noch zu bestimmenden Sinne sind, was aber, wie schon gesagt, nicht unbedingt der Fall sein muss. Im folgenden soll daher die Richtung der erlaubten Zuweisung so gelesen werden, dass beim Satz „a ist zuweisungskompatibel mit b“ die Zuweisung b := a zulässig ist. Die umgekehrte Richtung, a := b, kann ebenfalls zulässig sein; dies wird durch den Satz jedoch nicht ausgesagt. Zuweisungskompatibilität ist übrigens (in der Regel) eine transitive Eigenschaft: Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c, dann ist auch a zuweisungskompatibel mit c.
Auch bei impliziten Zuweisungen wie der Parameterübergabe von Methodenaufrufen (den dabei stattfindenden Zuweisungen der tatsächlichen an die formalen Parameter; s. Abschnitt 4.3.2) impliziert Zuweisungskompatibilität Typkorrektheit. Außerdem kann eine Methode, wenn sie Werte zurückgibt, ja selbst in rechten Seiten von Zuweisungen auftreten; der Typ dieser Werte muss dann mit der Variable auf der linken Seite zuweisungskompatibel sein.","<answer> Bei der Zuweisungskompatibilität wird die Richtung der erlaubten Zuweisung so interpretiert, dass beim Satz ""a ist zuweisungskompatibel mit b"" die Zuweisung ""b := a"" zulässig ist. Die umgekehrte Richtung, ""a := b,"" wird durch den Satz nicht ausgesagt. <answer> <question> Wie wird die Richtung der erlaubten Zuweisung bei der Zuweisungskompatibilität interpretiert? <question>"
"Die Typisierung von Variablen (und anderen Programmelementen – wenn im nachfolgenden nur von Variablen die Rede ist, dann sind letztere meistens mitgemeint) soll also bewirken, dass in einem Programm jede Variable nur die Werte haben kann, für die sie (die Variable) vorgesehen ist (die Einhaltung der Typinvariante). Voraussetzung dafür ist zum einen, dass jeder Variable ein Typ zugeordnet ist, zum anderen, dass auch jedes Objekt sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Ersteres geschieht in sogenannten Variablendeklarationen, letzteres ergibt sich aus den zu einem Typsystem gehörenden Regeln zur Zuordnung eines Typs zu Ausdrücken, nämlich bei Literalen aus der Art des Literals, dessen Typ dem Compiler bekannt ist, bei der Instanziierung aus dem noch zu klärenden Zusammenhang von der instanziierten Klasse mit den Typen eines Programms sowie bei Nachrichtenausdrücken aus der Deklaration der dazugehörigen Methode, die ja (genau wie eine Variablendeklaration) angeben muss, welchen Typs die Objekte sind, die sie liefert.
Es bleibt die Frage nach den ebenfalls zu einem Typsystem gehörenden Typregeln, die von Ausdrücken einzuhalten sind, nämlich wie die Typkorrektheit bzw. andernfalls die Verletzung einer Typinvariante genau festgestellt wird. Es ist ja bereits klar, dass es dazu ausreicht, die Wertzuweisungen in einem Programm zu überprüfen. Diese Überprüfung findet in der Regel in Form der Feststellung der sog. Zuweisungskompatibilität statt. Die Sprachregelung ist hier leider nicht ganz einheitlich, aber im folgenden gehen wir davon aus, dass alle typisierten Sprachen den Begriff der Zuweisungskompatibilität kennen und sich lediglich in ihren Definitionen der Regeln, die für das Bestehen einer Zuweisungskompatibilität eingehalten werden müssen, unterscheiden. Vor allem darum wird es in den nächsten Kapiteln gehen.
Dann sind, unter der Annahme, dass 12 vom Typ Integer ist und true vom Typ Boolean, die Zuweisungen zulässig (da sie keine Typinvariante verletzen), hingegen nicht. Ist eine Zuweisung zulässig, dann spricht man auch von einer Zuweisungskompatibilität der beteiligten Typen. Die für das Programmieren relevante Implikation ist allerdings die umgekehrte: Wenn zwei Typen zuweisungskompatibel sind, dann gilt, dass eine entsprechende Zuweisung zulässig ist, also zu keiner Verletzung einer Typinvariante führt. Wie Sie noch sehen werden, verlangt Zuweisungskompatibilität keineswegs identische Typen; daraus ergibt sich aber eine sprachliche Uneindeutigkeit, die zunächst behoben werden muss.
Dem Satz „a ist zuweisungskompatibel mit b“ kann man nicht eindeutig entnehmen, ob nun a b zugewiesen werden kann oder b a. Dass beides geht, ist nur dann der Fall, wenn die beteiligten Typen äquivalent in einem noch zu bestimmenden Sinne sind, was aber, wie schon gesagt, nicht unbedingt der Fall sein muss. Im folgenden soll daher die Richtung der erlaubten Zuweisung so gelesen werden, dass beim Satz „a ist zuweisungskompatibel mit b“ die Zuweisung b := a zulässig ist. Die umgekehrte Richtung, a := b, kann ebenfalls zulässig sein; dies wird durch den Satz jedoch nicht ausgesagt. Zuweisungskompatibilität ist übrigens (in der Regel) eine transitive Eigenschaft: Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c, dann ist auch a zuweisungskompatibel mit c.
Auch bei impliziten Zuweisungen wie der Parameterübergabe von Methodenaufrufen (den dabei stattfindenden Zuweisungen der tatsächlichen an die formalen Parameter; s. Abschnitt 4.3.2) impliziert Zuweisungskompatibilität Typkorrektheit. Außerdem kann eine Methode, wenn sie Werte zurückgibt, ja selbst in rechten Seiten von Zuweisungen auftreten; der Typ dieser Werte muss dann mit der Variable auf der linken Seite zuweisungskompatibel sein.","<answer> Ja, in der Regel ist Zuweisungskompatibilität eine transitive Eigenschaft. Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c ist, dann ist auch a zuweisungskompatibel mit c. <answer> <question> Ist Zuweisungskompatibilität eine transitive Eigenschaft? <question>"
"Die Typisierung von Variablen (und anderen Programmelementen – wenn im nachfolgenden nur von Variablen die Rede ist, dann sind letztere meistens mitgemeint) soll also bewirken, dass in einem Programm jede Variable nur die Werte haben kann, für die sie (die Variable) vorgesehen ist (die Einhaltung der Typinvariante). Voraussetzung dafür ist zum einen, dass jeder Variable ein Typ zugeordnet ist, zum anderen, dass auch jedes Objekt sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Ersteres geschieht in sogenannten Variablendeklarationen, letzteres ergibt sich aus den zu einem Typsystem gehörenden Regeln zur Zuordnung eines Typs zu Ausdrücken, nämlich bei Literalen aus der Art des Literals, dessen Typ dem Compiler bekannt ist, bei der Instanziierung aus dem noch zu klärenden Zusammenhang von der instanziierten Klasse mit den Typen eines Programms sowie bei Nachrichtenausdrücken aus der Deklaration der dazugehörigen Methode, die ja (genau wie eine Variablendeklaration) angeben muss, welchen Typs die Objekte sind, die sie liefert.
Es bleibt die Frage nach den ebenfalls zu einem Typsystem gehörenden Typregeln, die von Ausdrücken einzuhalten sind, nämlich wie die Typkorrektheit bzw. andernfalls die Verletzung einer Typinvariante genau festgestellt wird. Es ist ja bereits klar, dass es dazu ausreicht, die Wertzuweisungen in einem Programm zu überprüfen. Diese Überprüfung findet in der Regel in Form der Feststellung der sog. Zuweisungskompatibilität statt. Die Sprachregelung ist hier leider nicht ganz einheitlich, aber im folgenden gehen wir davon aus, dass alle typisierten Sprachen den Begriff der Zuweisungskompatibilität kennen und sich lediglich in ihren Definitionen der Regeln, die für das Bestehen einer Zuweisungskompatibilität eingehalten werden müssen, unterscheiden. Vor allem darum wird es in den nächsten Kapiteln gehen.
Dann sind, unter der Annahme, dass 12 vom Typ Integer ist und true vom Typ Boolean, die Zuweisungen zulässig (da sie keine Typinvariante verletzen), hingegen nicht. Ist eine Zuweisung zulässig, dann spricht man auch von einer Zuweisungskompatibilität der beteiligten Typen. Die für das Programmieren relevante Implikation ist allerdings die umgekehrte: Wenn zwei Typen zuweisungskompatibel sind, dann gilt, dass eine entsprechende Zuweisung zulässig ist, also zu keiner Verletzung einer Typinvariante führt. Wie Sie noch sehen werden, verlangt Zuweisungskompatibilität keineswegs identische Typen; daraus ergibt sich aber eine sprachliche Uneindeutigkeit, die zunächst behoben werden muss.
Dem Satz „a ist zuweisungskompatibel mit b“ kann man nicht eindeutig entnehmen, ob nun a b zugewiesen werden kann oder b a. Dass beides geht, ist nur dann der Fall, wenn die beteiligten Typen äquivalent in einem noch zu bestimmenden Sinne sind, was aber, wie schon gesagt, nicht unbedingt der Fall sein muss. Im folgenden soll daher die Richtung der erlaubten Zuweisung so gelesen werden, dass beim Satz „a ist zuweisungskompatibel mit b“ die Zuweisung b := a zulässig ist. Die umgekehrte Richtung, a := b, kann ebenfalls zulässig sein; dies wird durch den Satz jedoch nicht ausgesagt. Zuweisungskompatibilität ist übrigens (in der Regel) eine transitive Eigenschaft: Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c, dann ist auch a zuweisungskompatibel mit c.
Auch bei impliziten Zuweisungen wie der Parameterübergabe von Methodenaufrufen (den dabei stattfindenden Zuweisungen der tatsächlichen an die formalen Parameter; s. Abschnitt 4.3.2) impliziert Zuweisungskompatibilität Typkorrektheit. Außerdem kann eine Methode, wenn sie Werte zurückgibt, ja selbst in rechten Seiten von Zuweisungen auftreten; der Typ dieser Werte muss dann mit der Variable auf der linken Seite zuweisungskompatibel sein.","<answer> Zuweisungskompatibilität ist auch bei impliziten Zuweisungen wichtig, da sie Typkorrektheit impliziert. Bei der Parameterübergabe von Methodenaufrufen oder impliziten Zuweisungen müssen die beteiligten Typen kompatibel sein, um Typfehler zu vermeiden. <answer> <question> Warum ist Zuweisungskompatibilität auch bei impliziten Zuweisungen wichtig? <question>"
"Sprachphilosophisch gesehen ist eine Klasse ein Allgemeinbegriff wie etwa ""Person"", ""Haus"" oder ""Dokument"". Diese Allgemeinbegriffe stehen in der Regel für eine ganze Menge von Objekten, also etwa alle Personen, Häuser oder Dokumente. Gleichwohl ist die Klasse selbst immer ein Singular — sie ist nämlich selbst ein Objekt, das unter den Allgemeinbegriff ""Klasse"" fällt. Diese Sprachregelung wird auch in der objektorientierten Programmierung eingehalten (obwohl sie natürlich nicht, da Computer unsere Sprache nicht kennen, überprüft werden kann und deswegen Abweichungen immer wieder vorkommen): Alle Klassennamen sind Singular.
Jede Klasse ist mit bestimmten Eigenschaften verbunden, die charakteristisch für sie sind. Diese Eigenschaften ordnen wir jedoch nicht der Klasse selbst zu, sondern den Objekten, die dieser Klasse angehören. Zum Beispiel sind mit dem Allgemeinbegriff ""Person"" Eigenschaften wie Name, Geburtstag und möglicherweise weitere Attribute verknüpft, aber auch bestimmtes, für Personen charakteristisches Verhalten. Dasselbe Prinzip gilt für ""Haus"", ""Dokument"" und alle anderen Allgemeinbegriffe. Existenz und Adäquatheit von Allgemeinbegriffen sind Themen großer philosophischer Diskurse wie etwa dem sog. Universalienstreit und stehen hier nicht zur Debatte. Wichtig ist, dass mit ihnen stets Sätze wie „<ein Individuum> ist ein <ein Allgemeinbegriff>“ gebildet werden können, also etwa „Peter ist eine Person“. Mit solchen Sätzen verbindet sich nämlich die Übertragung aller Eigenschaften, die mit einem Allgemeinbegriff verbunden sind (s. o.), auf das Individuum. So hat Peter, wenn er eine Person ist und ""Person"" wie oben definiert wurde, eben auch einen Namen und einen Geburtstag.","<answer> Sprachphilosophisch betrachtet ist eine Klasse ein Allgemeinbegriff, ähnlich wie ""Person"", ""Haus"" oder ""Dokument"". Diese Allgemeinbegriffe repräsentieren in der Regel eine Menge von Objekten, z.B. alle Personen, Häuser oder Dokumente. Dennoch ist die Klasse selbst immer im Singular, da sie selbst ein Objekt ist, das unter den Allgemeinbegriff ""Klasse"" fällt. <answer> <question> Wie wird eine Klasse sprachphilosophisch betrachtet? <question>"
"Sprachphilosophisch gesehen ist eine Klasse ein Allgemeinbegriff wie etwa ""Person"", ""Haus"" oder ""Dokument"". Diese Allgemeinbegriffe stehen in der Regel für eine ganze Menge von Objekten, also etwa alle Personen, Häuser oder Dokumente. Gleichwohl ist die Klasse selbst immer ein Singular — sie ist nämlich selbst ein Objekt, das unter den Allgemeinbegriff ""Klasse"" fällt. Diese Sprachregelung wird auch in der objektorientierten Programmierung eingehalten (obwohl sie natürlich nicht, da Computer unsere Sprache nicht kennen, überprüft werden kann und deswegen Abweichungen immer wieder vorkommen): Alle Klassennamen sind Singular.
Jede Klasse ist mit bestimmten Eigenschaften verbunden, die charakteristisch für sie sind. Diese Eigenschaften ordnen wir jedoch nicht der Klasse selbst zu, sondern den Objekten, die dieser Klasse angehören. Zum Beispiel sind mit dem Allgemeinbegriff ""Person"" Eigenschaften wie Name, Geburtstag und möglicherweise weitere Attribute verknüpft, aber auch bestimmtes, für Personen charakteristisches Verhalten. Dasselbe Prinzip gilt für ""Haus"", ""Dokument"" und alle anderen Allgemeinbegriffe. Existenz und Adäquatheit von Allgemeinbegriffen sind Themen großer philosophischer Diskurse wie etwa dem sog. Universalienstreit und stehen hier nicht zur Debatte. Wichtig ist, dass mit ihnen stets Sätze wie „<ein Individuum> ist ein <ein Allgemeinbegriff>“ gebildet werden können, also etwa „Peter ist eine Person“. Mit solchen Sätzen verbindet sich nämlich die Übertragung aller Eigenschaften, die mit einem Allgemeinbegriff verbunden sind (s. o.), auf das Individuum. So hat Peter, wenn er eine Person ist und ""Person"" wie oben definiert wurde, eben auch einen Namen und einen Geburtstag.","<answer> Die Eigenschaften einer Klasse ordnen wir den Objekten zu, die dieser Klasse angehören. Zum Beispiel sind mit dem Allgemeinbegriff ""Person"" Eigenschaften wie Name, Geburtstag und möglicherweise weitere Attribute verknüpft, aber auch bestimmtes Verhalten, das für Personen charakteristisch ist. Diese Eigenschaften gehören den individuellen Objekten an, die Teil der Klasse ""Person"" sind. <answer> <question> Welche Eigenschaften einer Klasse ordnen wir den Objekten zu? <question>"
"Sprachphilosophisch gesehen ist eine Klasse ein Allgemeinbegriff wie etwa ""Person"", ""Haus"" oder ""Dokument"". Diese Allgemeinbegriffe stehen in der Regel für eine ganze Menge von Objekten, also etwa alle Personen, Häuser oder Dokumente. Gleichwohl ist die Klasse selbst immer ein Singular — sie ist nämlich selbst ein Objekt, das unter den Allgemeinbegriff ""Klasse"" fällt. Diese Sprachregelung wird auch in der objektorientierten Programmierung eingehalten (obwohl sie natürlich nicht, da Computer unsere Sprache nicht kennen, überprüft werden kann und deswegen Abweichungen immer wieder vorkommen): Alle Klassennamen sind Singular.
Jede Klasse ist mit bestimmten Eigenschaften verbunden, die charakteristisch für sie sind. Diese Eigenschaften ordnen wir jedoch nicht der Klasse selbst zu, sondern den Objekten, die dieser Klasse angehören. Zum Beispiel sind mit dem Allgemeinbegriff ""Person"" Eigenschaften wie Name, Geburtstag und möglicherweise weitere Attribute verknüpft, aber auch bestimmtes, für Personen charakteristisches Verhalten. Dasselbe Prinzip gilt für ""Haus"", ""Dokument"" und alle anderen Allgemeinbegriffe. Existenz und Adäquatheit von Allgemeinbegriffen sind Themen großer philosophischer Diskurse wie etwa dem sog. Universalienstreit und stehen hier nicht zur Debatte. Wichtig ist, dass mit ihnen stets Sätze wie „<ein Individuum> ist ein <ein Allgemeinbegriff>“ gebildet werden können, also etwa „Peter ist eine Person“. Mit solchen Sätzen verbindet sich nämlich die Übertragung aller Eigenschaften, die mit einem Allgemeinbegriff verbunden sind (s. o.), auf das Individuum. So hat Peter, wenn er eine Person ist und ""Person"" wie oben definiert wurde, eben auch einen Namen und einen Geburtstag.","<answer> Die Sprachregelung in der objektorientierten Programmierung besagt, dass alle Klassennamen im Singular sind. Dies bedeutet, dass jeder Klassenname einen Singularausdruck verwendet, um die Klasse zu benennen, selbst wenn die Klasse eine Menge von Objekten repräsentiert. <answer> <question> Was ermöglicht die Sprachregelung in der objektorientierten Programmierung bezüglich der Klassennamen? <question>"
"Sprachphilosophisch gesehen ist eine Klasse ein Allgemeinbegriff wie etwa ""Person"", ""Haus"" oder ""Dokument"". Diese Allgemeinbegriffe stehen in der Regel für eine ganze Menge von Objekten, also etwa alle Personen, Häuser oder Dokumente. Gleichwohl ist die Klasse selbst immer ein Singular — sie ist nämlich selbst ein Objekt, das unter den Allgemeinbegriff ""Klasse"" fällt. Diese Sprachregelung wird auch in der objektorientierten Programmierung eingehalten (obwohl sie natürlich nicht, da Computer unsere Sprache nicht kennen, überprüft werden kann und deswegen Abweichungen immer wieder vorkommen): Alle Klassennamen sind Singular.
Jede Klasse ist mit bestimmten Eigenschaften verbunden, die charakteristisch für sie sind. Diese Eigenschaften ordnen wir jedoch nicht der Klasse selbst zu, sondern den Objekten, die dieser Klasse angehören. Zum Beispiel sind mit dem Allgemeinbegriff ""Person"" Eigenschaften wie Name, Geburtstag und möglicherweise weitere Attribute verknüpft, aber auch bestimmtes, für Personen charakteristisches Verhalten. Dasselbe Prinzip gilt für ""Haus"", ""Dokument"" und alle anderen Allgemeinbegriffe. Existenz und Adäquatheit von Allgemeinbegriffen sind Themen großer philosophischer Diskurse wie etwa dem sog. Universalienstreit und stehen hier nicht zur Debatte. Wichtig ist, dass mit ihnen stets Sätze wie „<ein Individuum> ist ein <ein Allgemeinbegriff>“ gebildet werden können, also etwa „Peter ist eine Person“. Mit solchen Sätzen verbindet sich nämlich die Übertragung aller Eigenschaften, die mit einem Allgemeinbegriff verbunden sind (s. o.), auf das Individuum. So hat Peter, wenn er eine Person ist und ""Person"" wie oben definiert wurde, eben auch einen Namen und einen Geburtstag.","<answer> Sätze wie „<ein Individuum> ist ein <ein Allgemeinbegriff>“ ermöglichen die Übertragung aller Eigenschaften, die mit einem Allgemeinbegriff verbunden sind, auf das Individuum. Zum Beispiel, wenn Peter eine Person ist („Peter ist eine Person“), dann hat er auch einen Namen und einen Geburtstag, da diese Eigenschaften mit dem Allgemeinbegriff ""Person"" verbunden sind. Dieser Mechanismus ermöglicht es, die charakteristischen Eigenschaften eines Allgemeinbegriffs auf individuelle Objekte anzuwenden. <answer> <question> Welche Bedeutung haben Sätze wie „<ein Individuum> ist ein <ein Allgemeinbegriff>“ in Bezug auf Allgemeinbegriffe? <question>"
"MEYERs klassisches Beispiel zur Motivation kovarianter Redefinition und verankerter Typen à la EIFFEL soll Ihnen hier nicht vorenthalten werden. Es wird immer wieder zitiert und ist, abgesehen davon, dass es zu Bemerkungen abseits der Informatik einlädt, intuitiv gut verständlich. Das Beispiel beginnt wie folgt:
Die Idee ist, dass jugendliche Skifahrerinnen sich zu zweit ein Zimmer teilen. Wie Sie vielleicht schon selbst bemerkt haben, ist der durch die Klasse ""Skier"" definierte Typ rekursiv: Seine Instanzvariable ""roommate"" ist selbst vom Typ ""Skier"".
Zwei Dinge fallen auf: Zum einen unterscheiden sich die beiden Subklassen lediglich darin, dass sie ""roommate"" einen anderen Typ zuordnen und dies in der Folge auch für den Parameter von ""share"" tun müssen.
Beim Funktionsaufruf von ""share"" wird nun aber, dank dynamischer Bindung, ""g1"" (und damit ein Objekt vom Typ ""GIRL"") an ""roommate"" in ""BOY"" und damit an eine Variable vom Typ ""BOY"" zugewiesen. Schon ist das Programm nicht mehr typkorrekt.
Naturgemäß kommt in EIFFEL dem Versuch der Reparatur des durch obiges Beispiel angedeuteten Verlusts der Typkorrektheit eine besondere Bedeutung zu. Hier sei nur noch schnell (und ohne etwas von der Lösung vorwegzunehmen) erwähnt, dass der eigentliche Fehler in der implizit angenommenen Allquantifizierung einer Deklaration wie ""SKIER.share(SKIER)"" (oder, mathematisch ausgedrückt, ""share : SKIER  SKIER"") liegt: Wie schon in Kurseinheit 3, Kapitel 26 erwähnt, bedeutet eine solche Deklaration eben nicht, dass alle Skifahrerinnen (beiden Geschlechts) ihr Zimmer mit allen Skifahrerinnen (wieder beiden Geschlechts) teilen können. Das ist aber auch schon unabhängig von den möglichen Geschlechtern (Subklassen) nicht der Fall: Wenn eine Skifahrerin beispielsweise vorübergehend ansteckend erkrankt ist, kann sie höchstens mit anderen Kranken das Zimmer teilen. Eine Klassifikation nach Kranken und Gesunden entzieht sich aber, da sie nicht dauerhaft ist, den Möglichkeiten der statischen Typisierung (zumindest den offensichtlichen).","<answer> In EIFFEL wird eine kovariante Redefinition benötigt, um die Unterkunft der jungen Skifahrerinnen nach Geschlechtern getrennt zu organisieren. Dies ermöglicht es, Mädchen und Jungen unterschiedliche Typen für ""roommate"" zuzuweisen. <answer> <question> Warum wird in EIFFEL eine kovariante Redefinition benötigt? <question>"
"MEYERs klassisches Beispiel zur Motivation kovarianter Redefinition und verankerter Typen à la EIFFEL soll Ihnen hier nicht vorenthalten werden. Es wird immer wieder zitiert und ist, abgesehen davon, dass es zu Bemerkungen abseits der Informatik einlädt, intuitiv gut verständlich. Das Beispiel beginnt wie folgt:
Die Idee ist, dass jugendliche Skifahrerinnen sich zu zweit ein Zimmer teilen. Wie Sie vielleicht schon selbst bemerkt haben, ist der durch die Klasse ""Skier"" definierte Typ rekursiv: Seine Instanzvariable ""roommate"" ist selbst vom Typ ""Skier"".
Zwei Dinge fallen auf: Zum einen unterscheiden sich die beiden Subklassen lediglich darin, dass sie ""roommate"" einen anderen Typ zuordnen und dies in der Folge auch für den Parameter von ""share"" tun müssen.
Beim Funktionsaufruf von ""share"" wird nun aber, dank dynamischer Bindung, ""g1"" (und damit ein Objekt vom Typ ""GIRL"") an ""roommate"" in ""BOY"" und damit an eine Variable vom Typ ""BOY"" zugewiesen. Schon ist das Programm nicht mehr typkorrekt.
Naturgemäß kommt in EIFFEL dem Versuch der Reparatur des durch obiges Beispiel angedeuteten Verlusts der Typkorrektheit eine besondere Bedeutung zu. Hier sei nur noch schnell (und ohne etwas von der Lösung vorwegzunehmen) erwähnt, dass der eigentliche Fehler in der implizit angenommenen Allquantifizierung einer Deklaration wie ""SKIER.share(SKIER)"" (oder, mathematisch ausgedrückt, ""share : SKIER  SKIER"") liegt: Wie schon in Kurseinheit 3, Kapitel 26 erwähnt, bedeutet eine solche Deklaration eben nicht, dass alle Skifahrerinnen (beiden Geschlechts) ihr Zimmer mit allen Skifahrerinnen (wieder beiden Geschlechts) teilen können. Das ist aber auch schon unabhängig von den möglichen Geschlechtern (Subklassen) nicht der Fall: Wenn eine Skifahrerin beispielsweise vorübergehend ansteckend erkrankt ist, kann sie höchstens mit anderen Kranken das Zimmer teilen. Eine Klassifikation nach Kranken und Gesunden entzieht sich aber, da sie nicht dauerhaft ist, den Möglichkeiten der statischen Typisierung (zumindest den offensichtlichen).","<answer> Durch die kovariante Redefinition wird bei einem Funktionsaufruf von ""share"" dynamische Bindung verwendet, was dazu führt, dass ein Objekt vom Typ ""GIRL"" einem ""BOY"" zugewiesen wird. Dies führt zu einem Programmfehler, da das Programm nicht mehr typkorrekt ist. <answer> <question> Welche Schwierigkeit ergibt sich aus der kovarianten Redefinition? <question>"
"MEYERs klassisches Beispiel zur Motivation kovarianter Redefinition und verankerter Typen à la EIFFEL soll Ihnen hier nicht vorenthalten werden. Es wird immer wieder zitiert und ist, abgesehen davon, dass es zu Bemerkungen abseits der Informatik einlädt, intuitiv gut verständlich. Das Beispiel beginnt wie folgt:
Die Idee ist, dass jugendliche Skifahrerinnen sich zu zweit ein Zimmer teilen. Wie Sie vielleicht schon selbst bemerkt haben, ist der durch die Klasse ""Skier"" definierte Typ rekursiv: Seine Instanzvariable ""roommate"" ist selbst vom Typ ""Skier"".
Zwei Dinge fallen auf: Zum einen unterscheiden sich die beiden Subklassen lediglich darin, dass sie ""roommate"" einen anderen Typ zuordnen und dies in der Folge auch für den Parameter von ""share"" tun müssen.
Beim Funktionsaufruf von ""share"" wird nun aber, dank dynamischer Bindung, ""g1"" (und damit ein Objekt vom Typ ""GIRL"") an ""roommate"" in ""BOY"" und damit an eine Variable vom Typ ""BOY"" zugewiesen. Schon ist das Programm nicht mehr typkorrekt.
Naturgemäß kommt in EIFFEL dem Versuch der Reparatur des durch obiges Beispiel angedeuteten Verlusts der Typkorrektheit eine besondere Bedeutung zu. Hier sei nur noch schnell (und ohne etwas von der Lösung vorwegzunehmen) erwähnt, dass der eigentliche Fehler in der implizit angenommenen Allquantifizierung einer Deklaration wie ""SKIER.share(SKIER)"" (oder, mathematisch ausgedrückt, ""share : SKIER  SKIER"") liegt: Wie schon in Kurseinheit 3, Kapitel 26 erwähnt, bedeutet eine solche Deklaration eben nicht, dass alle Skifahrerinnen (beiden Geschlechts) ihr Zimmer mit allen Skifahrerinnen (wieder beiden Geschlechts) teilen können. Das ist aber auch schon unabhängig von den möglichen Geschlechtern (Subklassen) nicht der Fall: Wenn eine Skifahrerin beispielsweise vorübergehend ansteckend erkrankt ist, kann sie höchstens mit anderen Kranken das Zimmer teilen. Eine Klassifikation nach Kranken und Gesunden entzieht sich aber, da sie nicht dauerhaft ist, den Möglichkeiten der statischen Typisierung (zumindest den offensichtlichen).","<answer> Die implizite Allquantifizierung einer Deklaration wie ""SKIER.share(SKIER)"" bedeutet nicht, dass alle Skifahrerinnen (beider Geschlechter) ihr Zimmer mit allen Skifahrerinnen teilen können. Dies ist aufgrund von Faktoren wie Krankheit nicht immer möglich. Die statische Typisierung kann solche situativen Unterschiede nicht abbilden. <answer> <question> Warum führt die implizite Allquantifizierung einer Deklaration zu einem Fehler? <question>"
"Wie bereits in Abschnitt 1.3 beschrieben, kann man zwischen veränderlichen und unveränderlichen Objekten unterscheiden. Veränderungen an veränderlichen Objekten erfolgen im Laufe der Zeit, und die Objekte ändern dabei ihren Zustand. Unveränderliche Objekte hingegen haben keinen Zustand.14 Aber was macht den Zustand eines Objektes aus?
Der Zustand eines Objektes setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert. Darüber hinaus folgt daraus, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, in der Zuweisung von Instanzvariablen liegt, was gleichbedeutend mit der Änderung seiner Beziehungen ist.","<answer> Veränderliche Objekte können ihren Zustand im Laufe der Zeit ändern, während unveränderliche Objekte keinen Zustand haben und ihre Werte konstant bleiben. <answer> <question> Was ist der Unterschied zwischen veränderlichen und unveränderlichen Objekten? <question>"
"Wie bereits in Abschnitt 1.3 beschrieben, kann man zwischen veränderlichen und unveränderlichen Objekten unterscheiden. Veränderungen an veränderlichen Objekten erfolgen im Laufe der Zeit, und die Objekte ändern dabei ihren Zustand. Unveränderliche Objekte hingegen haben keinen Zustand.14 Aber was macht den Zustand eines Objektes aus?
Der Zustand eines Objektes setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert. Darüber hinaus folgt daraus, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, in der Zuweisung von Instanzvariablen liegt, was gleichbedeutend mit der Änderung seiner Beziehungen ist.",<answer> Der Zustand eines Objekts setzt sich aus den Werten seiner Instanzvariablen zusammen. <answer> <question> Wie setzt sich der Zustand eines Objekts zusammen? <question>
"Wie bereits in Abschnitt 1.3 beschrieben, kann man zwischen veränderlichen und unveränderlichen Objekten unterscheiden. Veränderungen an veränderlichen Objekten erfolgen im Laufe der Zeit, und die Objekte ändern dabei ihren Zustand. Unveränderliche Objekte hingegen haben keinen Zustand.14 Aber was macht den Zustand eines Objektes aus?
Der Zustand eines Objektes setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert. Darüber hinaus folgt daraus, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, in der Zuweisung von Instanzvariablen liegt, was gleichbedeutend mit der Änderung seiner Beziehungen ist.",<answer> Instanzvariablen drücken Beziehungen aus und definieren den Zustand eines Objekts durch seine Verknüpfung mit anderen Objekten. <answer> <question> Welche Rolle spielen Instanzvariablen bei der Definition des Zustands eines Objekts? <question>
"Wie bereits in Abschnitt 1.3 beschrieben, kann man zwischen veränderlichen und unveränderlichen Objekten unterscheiden. Veränderungen an veränderlichen Objekten erfolgen im Laufe der Zeit, und die Objekte ändern dabei ihren Zustand. Unveränderliche Objekte hingegen haben keinen Zustand.14 Aber was macht den Zustand eines Objektes aus?
Der Zustand eines Objektes setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert. Darüber hinaus folgt daraus, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, in der Zuweisung von Instanzvariablen liegt, was gleichbedeutend mit der Änderung seiner Beziehungen ist.","<answer> Die einzige Möglichkeit, den Zustand eines Objekts zu ändern, besteht darin, die Werte seiner Instanzvariablen zuzuweisen, was gleichbedeutend mit der Änderung seiner Beziehungen ist. <answer> <question> Was ist die einzige Möglichkeit, den Zustand eines Objekts zu ändern? <question>"
"Wie bereits in Kurseinheit 3, Abschnitt 29.4 erwähnt, erwirbt man mit einfachem parametrischem Polymorphismus außerhalb der Typdefinition Typsicherheit auf Kosten der fehlenden Typsicherheit innerhalb. Solange man keine Aussagen über den konkreten Typ machen kann, der für einen Typparameter eingesetzt wird, kann man bei der Implementierung einer Klasse, die den parametrischen Typ definiert, auch keine Eigenschaften der Objekte voraussetzen, die von dem (unbekannten) Typ sein sollen. Was man stattdessen benötigt, ist beschränkter parametrischer Polymorphismus. Natürlich gibt es diesen auch in JAVA.
Die möglichen Werte der Typvariable ""E"" werden dadurch auf Typen eingeschränkt, die ""Comparable"" (direkt oder indirekt) erweitern. Die Implementierung der Methode zum Einfügen und Entfernen von Elementen in sortierten Listen kann also davon ausgehen, dass alle Objekte, die in einer solchen Liste gespeichert sind, die Methode ""compareTo(.)"" verstehen, die vom Interface ""Comparable"" vorgeschrieben wird. Beachten Sie, dass dadurch keine neue Subtypenrelation zwischen irgendwelchen Typen hergestellt wird. Es werden lediglich die Möglichkeiten eingeschränkt, konkrete Typen (z. B. in Variablendeklarationen) zu bilden. Wobei ""String"" ein Subtyp von ""Comparable"" ist, ist also möglich. Dennoch ist ""SortedList<String>"" kein Subtyp von ""SortedList<Comparable>"".","<answer> Beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Einschränkung der möglichen Typen, die für einen Typparameter einer generischen Klasse verwendet werden können. Dies geschieht durch das Festlegen von Beschränkungen oder Bedingungen für den Typparameter. <answer> <question> Was ist beschränkter parametrischer Polymorphismus in Java? <question>"
"Wie bereits in Kurseinheit 3, Abschnitt 29.4 erwähnt, erwirbt man mit einfachem parametrischem Polymorphismus außerhalb der Typdefinition Typsicherheit auf Kosten der fehlenden Typsicherheit innerhalb. Solange man keine Aussagen über den konkreten Typ machen kann, der für einen Typparameter eingesetzt wird, kann man bei der Implementierung einer Klasse, die den parametrischen Typ definiert, auch keine Eigenschaften der Objekte voraussetzen, die von dem (unbekannten) Typ sein sollen. Was man stattdessen benötigt, ist beschränkter parametrischer Polymorphismus. Natürlich gibt es diesen auch in JAVA.
Die möglichen Werte der Typvariable ""E"" werden dadurch auf Typen eingeschränkt, die ""Comparable"" (direkt oder indirekt) erweitern. Die Implementierung der Methode zum Einfügen und Entfernen von Elementen in sortierten Listen kann also davon ausgehen, dass alle Objekte, die in einer solchen Liste gespeichert sind, die Methode ""compareTo(.)"" verstehen, die vom Interface ""Comparable"" vorgeschrieben wird. Beachten Sie, dass dadurch keine neue Subtypenrelation zwischen irgendwelchen Typen hergestellt wird. Es werden lediglich die Möglichkeiten eingeschränkt, konkrete Typen (z. B. in Variablendeklarationen) zu bilden. Wobei ""String"" ein Subtyp von ""Comparable"" ist, ist also möglich. Dennoch ist ""SortedList<String>"" kein Subtyp von ""SortedList<Comparable>"".","<answer> Beschränkter parametrischer Polymorphismus ist wichtig, um sicherzustellen, dass die Objekte, die von einem generischen Typ erzeugt werden, bestimmte Eigenschaften oder Methoden haben. Dadurch wird die Typsicherheit erhöht und es können bestimmte Annahmen über die Objekte gemacht werden. <answer> <question> Warum ist beschränkter parametrischer Polymorphismus wichtig? <question>"
"Wie bereits in Kurseinheit 3, Abschnitt 29.4 erwähnt, erwirbt man mit einfachem parametrischem Polymorphismus außerhalb der Typdefinition Typsicherheit auf Kosten der fehlenden Typsicherheit innerhalb. Solange man keine Aussagen über den konkreten Typ machen kann, der für einen Typparameter eingesetzt wird, kann man bei der Implementierung einer Klasse, die den parametrischen Typ definiert, auch keine Eigenschaften der Objekte voraussetzen, die von dem (unbekannten) Typ sein sollen. Was man stattdessen benötigt, ist beschränkter parametrischer Polymorphismus. Natürlich gibt es diesen auch in JAVA.
Die möglichen Werte der Typvariable ""E"" werden dadurch auf Typen eingeschränkt, die ""Comparable"" (direkt oder indirekt) erweitern. Die Implementierung der Methode zum Einfügen und Entfernen von Elementen in sortierten Listen kann also davon ausgehen, dass alle Objekte, die in einer solchen Liste gespeichert sind, die Methode ""compareTo(.)"" verstehen, die vom Interface ""Comparable"" vorgeschrieben wird. Beachten Sie, dass dadurch keine neue Subtypenrelation zwischen irgendwelchen Typen hergestellt wird. Es werden lediglich die Möglichkeiten eingeschränkt, konkrete Typen (z. B. in Variablendeklarationen) zu bilden. Wobei ""String"" ein Subtyp von ""Comparable"" ist, ist also möglich. Dennoch ist ""SortedList<String>"" kein Subtyp von ""SortedList<Comparable>"".","<answer> In Java wird beschränkter parametrischer Polymorphismus durch das Hinzufügen von Beschränkungen für den Typparameter einer generischen Klasse oder Methode erreicht. Dies geschieht durch die Verwendung des ""extends"" oder ""super"" Schlüsselworts gefolgt von einem bestimmten Typ oder einer bestimmten Schnittstelle. <answer> <question> Wie wird beschränkter parametrischer Polymorphismus in Java implementiert? <question>"
"Wie bereits in Kurseinheit 3, Abschnitt 29.4 erwähnt, erwirbt man mit einfachem parametrischem Polymorphismus außerhalb der Typdefinition Typsicherheit auf Kosten der fehlenden Typsicherheit innerhalb. Solange man keine Aussagen über den konkreten Typ machen kann, der für einen Typparameter eingesetzt wird, kann man bei der Implementierung einer Klasse, die den parametrischen Typ definiert, auch keine Eigenschaften der Objekte voraussetzen, die von dem (unbekannten) Typ sein sollen. Was man stattdessen benötigt, ist beschränkter parametrischer Polymorphismus. Natürlich gibt es diesen auch in JAVA.
Die möglichen Werte der Typvariable ""E"" werden dadurch auf Typen eingeschränkt, die ""Comparable"" (direkt oder indirekt) erweitern. Die Implementierung der Methode zum Einfügen und Entfernen von Elementen in sortierten Listen kann also davon ausgehen, dass alle Objekte, die in einer solchen Liste gespeichert sind, die Methode ""compareTo(.)"" verstehen, die vom Interface ""Comparable"" vorgeschrieben wird. Beachten Sie, dass dadurch keine neue Subtypenrelation zwischen irgendwelchen Typen hergestellt wird. Es werden lediglich die Möglichkeiten eingeschränkt, konkrete Typen (z. B. in Variablendeklarationen) zu bilden. Wobei ""String"" ein Subtyp von ""Comparable"" ist, ist also möglich. Dennoch ist ""SortedList<String>"" kein Subtyp von ""SortedList<Comparable>"".","<answer> Die Einschränkung ""<E extends Comparable<E>>"" bedeutet, dass der Typparameter ""E"" auf Typen beschränkt ist, die das Interface ""Comparable"" implementieren oder davon erben. Dies stellt sicher, dass Objekte vom Typ ""E"" die Methode ""compareTo(.)"" implementieren können, die vom Interface ""Comparable"" vorgeschrieben wird. <answer> <question> Was bedeutet die Einschränkung ""<E extends Comparable<E>>"" in der Klasse ""SortedList""? <question>"
"Wie bereits in Kurseinheit 3, Abschnitt 29.4 erwähnt, erwirbt man mit einfachem parametrischem Polymorphismus außerhalb der Typdefinition Typsicherheit auf Kosten der fehlenden Typsicherheit innerhalb. Solange man keine Aussagen über den konkreten Typ machen kann, der für einen Typparameter eingesetzt wird, kann man bei der Implementierung einer Klasse, die den parametrischen Typ definiert, auch keine Eigenschaften der Objekte voraussetzen, die von dem (unbekannten) Typ sein sollen. Was man stattdessen benötigt, ist beschränkter parametrischer Polymorphismus. Natürlich gibt es diesen auch in JAVA.
Die möglichen Werte der Typvariable ""E"" werden dadurch auf Typen eingeschränkt, die ""Comparable"" (direkt oder indirekt) erweitern. Die Implementierung der Methode zum Einfügen und Entfernen von Elementen in sortierten Listen kann also davon ausgehen, dass alle Objekte, die in einer solchen Liste gespeichert sind, die Methode ""compareTo(.)"" verstehen, die vom Interface ""Comparable"" vorgeschrieben wird. Beachten Sie, dass dadurch keine neue Subtypenrelation zwischen irgendwelchen Typen hergestellt wird. Es werden lediglich die Möglichkeiten eingeschränkt, konkrete Typen (z. B. in Variablendeklarationen) zu bilden. Wobei ""String"" ein Subtyp von ""Comparable"" ist, ist also möglich. Dennoch ist ""SortedList<String>"" kein Subtyp von ""SortedList<Comparable>"".","<answer> ""SortedList<String>"" wird als gültige Deklaration betrachtet, weil ""String"" ein Subtyp von ""Comparable"" ist und daher die Bedingung ""<E extends Comparable<E>>"" erfüllt. ""SortedList<Integer>"" wird hingegen nicht als gültige Deklaration betrachtet, da ""Integer"" nicht ""Comparable<Integer>"" implementiert, was nicht der Einschränkung entspricht. <answer> <question> Warum wird ""SortedList<String>"" als gültige Deklaration betrachtet, aber ""SortedList<Integer>"" nicht? <question>"
"Wie bereits in Kurseinheit 3, Abschnitt 29.4 erwähnt, erwirbt man mit einfachem parametrischem Polymorphismus außerhalb der Typdefinition Typsicherheit auf Kosten der fehlenden Typsicherheit innerhalb. Solange man keine Aussagen über den konkreten Typ machen kann, der für einen Typparameter eingesetzt wird, kann man bei der Implementierung einer Klasse, die den parametrischen Typ definiert, auch keine Eigenschaften der Objekte voraussetzen, die von dem (unbekannten) Typ sein sollen. Was man stattdessen benötigt, ist beschränkter parametrischer Polymorphismus. Natürlich gibt es diesen auch in JAVA.
Die möglichen Werte der Typvariable ""E"" werden dadurch auf Typen eingeschränkt, die ""Comparable"" (direkt oder indirekt) erweitern. Die Implementierung der Methode zum Einfügen und Entfernen von Elementen in sortierten Listen kann also davon ausgehen, dass alle Objekte, die in einer solchen Liste gespeichert sind, die Methode ""compareTo(.)"" verstehen, die vom Interface ""Comparable"" vorgeschrieben wird. Beachten Sie, dass dadurch keine neue Subtypenrelation zwischen irgendwelchen Typen hergestellt wird. Es werden lediglich die Möglichkeiten eingeschränkt, konkrete Typen (z. B. in Variablendeklarationen) zu bilden. Wobei ""String"" ein Subtyp von ""Comparable"" ist, ist also möglich. Dennoch ist ""SortedList<String>"" kein Subtyp von ""SortedList<Comparable>"".","<answer> Nein, ""SortedList<String>"" ist kein Subtyp von ""SortedList<Comparable>"". Die Einschränkung ""<E extends Comparable<E>>"" in ""SortedList"" sorgt dafür, dass der Typparameter ""E"" ein Subtyp von ""Comparable<E>"" sein muss, aber sie schafft keine Subtypenbeziehung zwischen den ""SortedList""-Instanzen selbst. <answer> <question> Ist ""SortedList<String>"" ein Subtyp von ""SortedList<Comparable>""? <question>"
"Wenn Ihnen das noch nicht kompliziert genug ist, geht es noch weiter: Tatsächlich würde auch ""Comparable"" selbst von einer Parametrisierung profitieren. In einem ersten Ansatz würde man verlangen, dass von zwei vergleichbaren Elementen beide vom gleichen Typ sein müssen.
Bei genauerer Betrachtung des Beispiels stellt sich jedoch heraus, dass die Bedingung, dass die zu vergleichenden Elemente für eine Sortierung alle vom selben Typ sein müssen, zu restriktiv ist. Vielmehr würde es ausreichen, wenn die Objekte der sortierten Liste unter anderem mit Objekten desselben Typs vergleichbar wären – sie könnten auch mit Objekten von noch mehr Typen vergleichbar sein. Die Bedingung muss also lauten, dass der Parametertyp von ""Comparable"" mindestens ""E"" umfassen muss. Er kann jedoch auch allgemeiner sein, z. B. ""Object"" (für einen Vergleich beliebiger Objekte, wie auch immer dieser durchgeführt werden soll). Im gegebenen Fall muss es sich bei dem für das Wildcard einzusetzenden Typ um einen (direkten oder indirekten) Supertypen von ""E"" handeln (wobei ""E"" ja selbst eine Typvariable ist, die erst bei einer Variablendeklaration an einen konkreten Typ gebunden wird).","<answer> Rekursiv beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Möglichkeit, Beschränkungen für Typparameter auf eine Weise zu definieren, die auf sich selbst oder andere Typparameter verweist. <answer> <question> Was ist rekursiv beschränkter parametrischer Polymorphismus in Java? <question>"
"Wenn Ihnen das noch nicht kompliziert genug ist, geht es noch weiter: Tatsächlich würde auch ""Comparable"" selbst von einer Parametrisierung profitieren. In einem ersten Ansatz würde man verlangen, dass von zwei vergleichbaren Elementen beide vom gleichen Typ sein müssen.
Bei genauerer Betrachtung des Beispiels stellt sich jedoch heraus, dass die Bedingung, dass die zu vergleichenden Elemente für eine Sortierung alle vom selben Typ sein müssen, zu restriktiv ist. Vielmehr würde es ausreichen, wenn die Objekte der sortierten Liste unter anderem mit Objekten desselben Typs vergleichbar wären – sie könnten auch mit Objekten von noch mehr Typen vergleichbar sein. Die Bedingung muss also lauten, dass der Parametertyp von ""Comparable"" mindestens ""E"" umfassen muss. Er kann jedoch auch allgemeiner sein, z. B. ""Object"" (für einen Vergleich beliebiger Objekte, wie auch immer dieser durchgeführt werden soll). Im gegebenen Fall muss es sich bei dem für das Wildcard einzusetzenden Typ um einen (direkten oder indirekten) Supertypen von ""E"" handeln (wobei ""E"" ja selbst eine Typvariable ist, die erst bei einer Variablendeklaration an einen konkreten Typ gebunden wird).","<answer> Eine Parametrisierung von ""Comparable"" könnte vorteilhaft sein, um die Flexibilität bei der Verwendung von Vergleichen zu erhöhen. Es ermöglicht, dass Objekte mit verschiedenen, aber kompatiblen Typen miteinander verglichen werden können. <answer> <question> Warum könnte eine Parametrisierung von ""Comparable"" vorteilhaft sein? <question>"
"Wenn Ihnen das noch nicht kompliziert genug ist, geht es noch weiter: Tatsächlich würde auch ""Comparable"" selbst von einer Parametrisierung profitieren. In einem ersten Ansatz würde man verlangen, dass von zwei vergleichbaren Elementen beide vom gleichen Typ sein müssen.
Bei genauerer Betrachtung des Beispiels stellt sich jedoch heraus, dass die Bedingung, dass die zu vergleichenden Elemente für eine Sortierung alle vom selben Typ sein müssen, zu restriktiv ist. Vielmehr würde es ausreichen, wenn die Objekte der sortierten Liste unter anderem mit Objekten desselben Typs vergleichbar wären – sie könnten auch mit Objekten von noch mehr Typen vergleichbar sein. Die Bedingung muss also lauten, dass der Parametertyp von ""Comparable"" mindestens ""E"" umfassen muss. Er kann jedoch auch allgemeiner sein, z. B. ""Object"" (für einen Vergleich beliebiger Objekte, wie auch immer dieser durchgeführt werden soll). Im gegebenen Fall muss es sich bei dem für das Wildcard einzusetzenden Typ um einen (direkten oder indirekten) Supertypen von ""E"" handeln (wobei ""E"" ja selbst eine Typvariable ist, die erst bei einer Variablendeklaration an einen konkreten Typ gebunden wird).","<answer> Die Deklaration ""interface Comparable<T extends T>"" würde bedeuten, dass der Typparameter ""T"" vom gleichen Typ sein muss wie der Typparameter ""T"" selbst, was in der Praxis keine sinnvolle Einschränkung ist. <answer> <question> Was würde die Deklaration ""interface Comparable<T extends T>"" bedeuten? <question>"
"Wenn Ihnen das noch nicht kompliziert genug ist, geht es noch weiter: Tatsächlich würde auch ""Comparable"" selbst von einer Parametrisierung profitieren. In einem ersten Ansatz würde man verlangen, dass von zwei vergleichbaren Elementen beide vom gleichen Typ sein müssen.
Bei genauerer Betrachtung des Beispiels stellt sich jedoch heraus, dass die Bedingung, dass die zu vergleichenden Elemente für eine Sortierung alle vom selben Typ sein müssen, zu restriktiv ist. Vielmehr würde es ausreichen, wenn die Objekte der sortierten Liste unter anderem mit Objekten desselben Typs vergleichbar wären – sie könnten auch mit Objekten von noch mehr Typen vergleichbar sein. Die Bedingung muss also lauten, dass der Parametertyp von ""Comparable"" mindestens ""E"" umfassen muss. Er kann jedoch auch allgemeiner sein, z. B. ""Object"" (für einen Vergleich beliebiger Objekte, wie auch immer dieser durchgeführt werden soll). Im gegebenen Fall muss es sich bei dem für das Wildcard einzusetzenden Typ um einen (direkten oder indirekten) Supertypen von ""E"" handeln (wobei ""E"" ja selbst eine Typvariable ist, die erst bei einer Variablendeklaration an einen konkreten Typ gebunden wird).","<answer> Die Bedingung, dass zu vergleichende Elemente vom gleichen Typ sein müssen, ist zu restriktiv, weil es Fälle gibt, in denen Objekte unterschiedlicher, aber verwandter Typen miteinander verglichen werden sollen. Eine flexiblere Einschränkung ist erforderlich. <answer> <question> Warum ist die Bedingung, dass zu vergleichende Elemente vom gleichen Typ sein müssen, zu restriktiv? <question>"
"Wenn Ihnen das noch nicht kompliziert genug ist, geht es noch weiter: Tatsächlich würde auch ""Comparable"" selbst von einer Parametrisierung profitieren. In einem ersten Ansatz würde man verlangen, dass von zwei vergleichbaren Elementen beide vom gleichen Typ sein müssen.
Bei genauerer Betrachtung des Beispiels stellt sich jedoch heraus, dass die Bedingung, dass die zu vergleichenden Elemente für eine Sortierung alle vom selben Typ sein müssen, zu restriktiv ist. Vielmehr würde es ausreichen, wenn die Objekte der sortierten Liste unter anderem mit Objekten desselben Typs vergleichbar wären – sie könnten auch mit Objekten von noch mehr Typen vergleichbar sein. Die Bedingung muss also lauten, dass der Parametertyp von ""Comparable"" mindestens ""E"" umfassen muss. Er kann jedoch auch allgemeiner sein, z. B. ""Object"" (für einen Vergleich beliebiger Objekte, wie auch immer dieser durchgeführt werden soll). Im gegebenen Fall muss es sich bei dem für das Wildcard einzusetzenden Typ um einen (direkten oder indirekten) Supertypen von ""E"" handeln (wobei ""E"" ja selbst eine Typvariable ist, die erst bei einer Variablendeklaration an einen konkreten Typ gebunden wird).","<answer> ""Comparable<? super E>"" bedeutet, dass der Parametertyp von ""Comparable"" mindestens ""E"" umfassen muss, kann jedoch auch allgemeiner sein, z. B. ""Object"". Das ""?"" in der Typ-Wildcard steht für einen beliebigen Typen, der die Bedingung erfüllt, in diesem Fall ein Supertyp von ""E"". <answer> <question> Was bedeutet ""Comparable<? super E>""? <question>"
"Wenn Ihnen das noch nicht kompliziert genug ist, geht es noch weiter: Tatsächlich würde auch ""Comparable"" selbst von einer Parametrisierung profitieren. In einem ersten Ansatz würde man verlangen, dass von zwei vergleichbaren Elementen beide vom gleichen Typ sein müssen.
Bei genauerer Betrachtung des Beispiels stellt sich jedoch heraus, dass die Bedingung, dass die zu vergleichenden Elemente für eine Sortierung alle vom selben Typ sein müssen, zu restriktiv ist. Vielmehr würde es ausreichen, wenn die Objekte der sortierten Liste unter anderem mit Objekten desselben Typs vergleichbar wären – sie könnten auch mit Objekten von noch mehr Typen vergleichbar sein. Die Bedingung muss also lauten, dass der Parametertyp von ""Comparable"" mindestens ""E"" umfassen muss. Er kann jedoch auch allgemeiner sein, z. B. ""Object"" (für einen Vergleich beliebiger Objekte, wie auch immer dieser durchgeführt werden soll). Im gegebenen Fall muss es sich bei dem für das Wildcard einzusetzenden Typ um einen (direkten oder indirekten) Supertypen von ""E"" handeln (wobei ""E"" ja selbst eine Typvariable ist, die erst bei einer Variablendeklaration an einen konkreten Typ gebunden wird).","<answer> ""Comparable<? super E>"" ist flexibler, weil es eine größere Bandbreite von Typen zulässt, die miteinander verglichen werden können. Es erlaubt, dass Objekte vom Typ ""E"" mit Objekten anderer, aber verwandter Typen verglichen werden, was die Verwendung von ""Comparable"" vielseitiger macht. <answer> <question> Warum ist ""Comparable<? super E>"" flexibler als ""Comparable<T extends T>""? <question>"
"Genau wie in der SMALLTALK-Programmierung kommt man in der JAVA-Programmierung häufig in die Verlegenheit, :n-Beziehungen umsetzen zu müssen. Wie in SMALLTALK geschieht dies auch in JAVA mit Hilfe von Zwischenobjekten. Anders als in SMALLTALK wird hier aber grundsätzlich zwischen zwei Arten von Zwischenobjekten unterschieden: den Arrays und den Collections. Da JAVA-Arrays in ihrer Funktionalität beschränkt sind (siehe Kapitel 41: keine eigenen Methoden zur Unterstützung des Zugriffs, kein dynamisches Wachstum, dazu die etwas verkorkste Situation beim Subtyping), werden Arrays vornehmlich dort eingesetzt.",<answer> In der JAVA-Programmierung gibt es zwei Arten von Zwischenobjekten für die Umsetzung von :n-Beziehungen: Arrays und Collections. <answer> <question> In der JAVA-Programmierung gibt es zwei Arten von Zwischenobjekten für die Umsetzung von :n-Beziehungen. Welche sind das? <question>
"Genau wie in der SMALLTALK-Programmierung kommt man in der JAVA-Programmierung häufig in die Verlegenheit, :n-Beziehungen umsetzen zu müssen. Wie in SMALLTALK geschieht dies auch in JAVA mit Hilfe von Zwischenobjekten. Anders als in SMALLTALK wird hier aber grundsätzlich zwischen zwei Arten von Zwischenobjekten unterschieden: den Arrays und den Collections. Da JAVA-Arrays in ihrer Funktionalität beschränkt sind (siehe Kapitel 41: keine eigenen Methoden zur Unterstützung des Zugriffs, kein dynamisches Wachstum, dazu die etwas verkorkste Situation beim Subtyping), werden Arrays vornehmlich dort eingesetzt.","<answer> JAVA-Arrays haben im Vergleich zu Collections Einschränkungen in ihrer Funktionalität. Sie bieten keine eigenen Methoden zur Unterstützung des Zugriffs, kein dynamisches Wachstum und es gibt einige Probleme mit dem Subtyping von Arrays. <answer> <question> Was sind die Einschränkungen von JAVA-Arrays im Vergleich zu Collections? <question>"
"Typerweiterung ist nicht die einzige Möglichkeit, auf der Basis eines bereits bestehenden einen neuen, verwandten Typen zu erzeugen; Typeinschränkung ist eine andere. Eine erste, offensichtliche Form der Typeinschränkung liegt dann vor, wenn ein Typ auf Basis eines anderen unter Entfernen von Eigenschaften (Methoden) definiert wird (das Beispiel vom Pinguin als einem Vogel, der nicht fliegen kann, kennen Sie ja bereits aus Kurseinheit 1, Abschnitt 9.2; das Beispiel vom Quadrat als einem Rechteck, das nur eine Kantenlänge braucht, ist ein anderes). Diese Form der Typeinschränkung stellt zumindest auf Ebene der Typdefinition (der Intensionen) die Umkehrung der Typerweiterung dar. Es liegt auf der Hand, dass diese Form der Typeinschränkung nicht zur Zuweisungskompatibilität führt; dies folgt schon aus der fehlenden Symmetrie der Typkonformität. Sie soll hier deswegen keine weitere Berücksichtigung finden, auch wenn es Sprachen gibt, die sie erlauben (z. B. EIFFEL).
Eine unter dem Gesichtspunkt der Zuweisungskompatibilität interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere zu ersetzen (ohne hier schon zu sagen, was „spezieller“ im Zusammenhang mit Typen bedeutet). Diese Form der Typeinschränkung ergibt sich auf natürliche Weise, wenn man sich den Zusammenhang von Extensionen von definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht.
Man mag sich fragen, warum bei der Typerweiterung in Kapitel 23 keine zwei Formen analog zur Typeinschränkung eingeführt wurden. Die Typerweiterung würde damit zur vollständigen Umkehrung der Typeinschränkung wie hier beschrieben. Wie Sie noch sehen werden, ist das Ziel nicht die Schaffung zweier Komplementäre, sondern die Vereinigung beider zu einer Beziehung zwischen Typen – dazu müssen sie aber in dieselbe und nicht in gegensätzliche Richtungen gehen. Außerdem ist eine Erweiterung des Wertebereichs bei Einschränkung des Definitionsbereichs nicht durch den Begriff der Relation wie oben erklärt; eine wichtige Analogie zur Realität, die durch Typen zwecks semantischer Prüfung nachgebildet werden soll, ginge damit verloren.
Nun ergibt sich aber bei der Typeinschränkung auch ohne Löschen das Problem, dass sie die Zuweisungskompatibilität, die ja für die Typerweiterung noch per Typkonformität geregelt werden konnte, aushebelt.
Wesentlich für diese Betrachtungsweise, und damit das geschilderte Problem, ist übrigens, dass nach der Zuweisung von Zeile 901 d und z auf dasselbe Objekt, nämlich eine Zeichnung, verweisen. d ist also ein Alias für z (s. Kurseinheit 1, Abschnitt 1.8). Unter Wertsemantik, bei der bei der Zuweisung eine Kopie erstellt wird, hätte man hingegen überlegen müssen, wie man ein Objekt vom Typ Zeichnung in einer Variable vom Typ Dokument speichern kann; je nach interner Repräsentation der Objekte (die ja durch den Typ nicht festgelegt ist), ist dafür nämlich gar nicht genug Platz. Gleichzeitig mit der Kopie könnte dann eine Typkonvertierung erfolgen, bei der aus der Zeichnung ein Dokument gemacht würde (was auch immer das heißen mag). Dieses Dokument müsste dann, per obiger Typdefinition, auch auf einem Zeilendrucker druckbar sein. Es ist allerdings schwer vorstellbar, wie dies umzusetzen ist, wenn das entsprechende Objekt nicht einmal mehr weiß, dass es eine Zeichnung ist, geschweige denn, wie seine interne Repräsentation aussieht. In der Praxis der objektorientierten Programmierung ist daher auch nur die Referenzsemantik in Fragen der Zuweisungskompatibilität interessant.
Was die Freiheit von Typfehlern angeht, kann man das Löschen von Eigenschaften (Methoden) übrigens auch als einen Spezialfall der Typeinschränkung der obigen, zweiten Form auffassen, nämlich einer, in der der Wertebereich auf die leere Menge eingeschränkt wird. So wäre beispielsweise druckenAuf: mit einem Parametertyp ohne Elemente gar nicht mehr aufrufbar (da es kein typkorrektes Parameterobjekt gäbe), was einer Löschung gleichkäme.","<answer> Typeinschränkung ist eine Möglichkeit, auf der Basis eines bereits bestehenden Typs einen neuen, verwandten Typen zu erzeugen. Sie besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere Typen zu ersetzen. Im Gegensatz dazu erweitert Typerweiterung den vorhandenen Typ um zusätzliche Eigenschaften oder Methoden. Typeinschränkung ist also die Umkehrung der Typerweiterung in Bezug auf die Typdefinition. <answer> <question> Was ist Typeinschränkung, und wie unterscheidet sie sich von Typerweiterung? <question>"
"Typerweiterung ist nicht die einzige Möglichkeit, auf der Basis eines bereits bestehenden einen neuen, verwandten Typen zu erzeugen; Typeinschränkung ist eine andere. Eine erste, offensichtliche Form der Typeinschränkung liegt dann vor, wenn ein Typ auf Basis eines anderen unter Entfernen von Eigenschaften (Methoden) definiert wird (das Beispiel vom Pinguin als einem Vogel, der nicht fliegen kann, kennen Sie ja bereits aus Kurseinheit 1, Abschnitt 9.2; das Beispiel vom Quadrat als einem Rechteck, das nur eine Kantenlänge braucht, ist ein anderes). Diese Form der Typeinschränkung stellt zumindest auf Ebene der Typdefinition (der Intensionen) die Umkehrung der Typerweiterung dar. Es liegt auf der Hand, dass diese Form der Typeinschränkung nicht zur Zuweisungskompatibilität führt; dies folgt schon aus der fehlenden Symmetrie der Typkonformität. Sie soll hier deswegen keine weitere Berücksichtigung finden, auch wenn es Sprachen gibt, die sie erlauben (z. B. EIFFEL).
Eine unter dem Gesichtspunkt der Zuweisungskompatibilität interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere zu ersetzen (ohne hier schon zu sagen, was „spezieller“ im Zusammenhang mit Typen bedeutet). Diese Form der Typeinschränkung ergibt sich auf natürliche Weise, wenn man sich den Zusammenhang von Extensionen von definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht.
Man mag sich fragen, warum bei der Typerweiterung in Kapitel 23 keine zwei Formen analog zur Typeinschränkung eingeführt wurden. Die Typerweiterung würde damit zur vollständigen Umkehrung der Typeinschränkung wie hier beschrieben. Wie Sie noch sehen werden, ist das Ziel nicht die Schaffung zweier Komplementäre, sondern die Vereinigung beider zu einer Beziehung zwischen Typen – dazu müssen sie aber in dieselbe und nicht in gegensätzliche Richtungen gehen. Außerdem ist eine Erweiterung des Wertebereichs bei Einschränkung des Definitionsbereichs nicht durch den Begriff der Relation wie oben erklärt; eine wichtige Analogie zur Realität, die durch Typen zwecks semantischer Prüfung nachgebildet werden soll, ginge damit verloren.
Nun ergibt sich aber bei der Typeinschränkung auch ohne Löschen das Problem, dass sie die Zuweisungskompatibilität, die ja für die Typerweiterung noch per Typkonformität geregelt werden konnte, aushebelt.
Wesentlich für diese Betrachtungsweise, und damit das geschilderte Problem, ist übrigens, dass nach der Zuweisung von Zeile 901 d und z auf dasselbe Objekt, nämlich eine Zeichnung, verweisen. d ist also ein Alias für z (s. Kurseinheit 1, Abschnitt 1.8). Unter Wertsemantik, bei der bei der Zuweisung eine Kopie erstellt wird, hätte man hingegen überlegen müssen, wie man ein Objekt vom Typ Zeichnung in einer Variable vom Typ Dokument speichern kann; je nach interner Repräsentation der Objekte (die ja durch den Typ nicht festgelegt ist), ist dafür nämlich gar nicht genug Platz. Gleichzeitig mit der Kopie könnte dann eine Typkonvertierung erfolgen, bei der aus der Zeichnung ein Dokument gemacht würde (was auch immer das heißen mag). Dieses Dokument müsste dann, per obiger Typdefinition, auch auf einem Zeilendrucker druckbar sein. Es ist allerdings schwer vorstellbar, wie dies umzusetzen ist, wenn das entsprechende Objekt nicht einmal mehr weiß, dass es eine Zeichnung ist, geschweige denn, wie seine interne Repräsentation aussieht. In der Praxis der objektorientierten Programmierung ist daher auch nur die Referenzsemantik in Fragen der Zuweisungskompatibilität interessant.
Was die Freiheit von Typfehlern angeht, kann man das Löschen von Eigenschaften (Methoden) übrigens auch als einen Spezialfall der Typeinschränkung der obigen, zweiten Form auffassen, nämlich einer, in der der Wertebereich auf die leere Menge eingeschränkt wird. So wäre beispielsweise druckenAuf: mit einem Parametertyp ohne Elemente gar nicht mehr aufrufbar (da es kein typkorrektes Parameterobjekt gäbe), was einer Löschung gleichkäme.","<answer> Eine Form der Typeinschränkung besteht darin, einen Typ auf Basis eines anderen Typs zu definieren, indem man Eigenschaften (Methoden) entfernt. Diese Form führt jedoch nicht zur Zuweisungskompatibilität und wird in vielen Sprachen nicht unterstützt. Eine interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere Typen zu ersetzen, ohne Eigenschaften zu löschen. <answer> <question> Welche Formen der Typeinschränkung gibt es? <question>"
"Typerweiterung ist nicht die einzige Möglichkeit, auf der Basis eines bereits bestehenden einen neuen, verwandten Typen zu erzeugen; Typeinschränkung ist eine andere. Eine erste, offensichtliche Form der Typeinschränkung liegt dann vor, wenn ein Typ auf Basis eines anderen unter Entfernen von Eigenschaften (Methoden) definiert wird (das Beispiel vom Pinguin als einem Vogel, der nicht fliegen kann, kennen Sie ja bereits aus Kurseinheit 1, Abschnitt 9.2; das Beispiel vom Quadrat als einem Rechteck, das nur eine Kantenlänge braucht, ist ein anderes). Diese Form der Typeinschränkung stellt zumindest auf Ebene der Typdefinition (der Intensionen) die Umkehrung der Typerweiterung dar. Es liegt auf der Hand, dass diese Form der Typeinschränkung nicht zur Zuweisungskompatibilität führt; dies folgt schon aus der fehlenden Symmetrie der Typkonformität. Sie soll hier deswegen keine weitere Berücksichtigung finden, auch wenn es Sprachen gibt, die sie erlauben (z. B. EIFFEL).
Eine unter dem Gesichtspunkt der Zuweisungskompatibilität interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere zu ersetzen (ohne hier schon zu sagen, was „spezieller“ im Zusammenhang mit Typen bedeutet). Diese Form der Typeinschränkung ergibt sich auf natürliche Weise, wenn man sich den Zusammenhang von Extensionen von definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht.
Man mag sich fragen, warum bei der Typerweiterung in Kapitel 23 keine zwei Formen analog zur Typeinschränkung eingeführt wurden. Die Typerweiterung würde damit zur vollständigen Umkehrung der Typeinschränkung wie hier beschrieben. Wie Sie noch sehen werden, ist das Ziel nicht die Schaffung zweier Komplementäre, sondern die Vereinigung beider zu einer Beziehung zwischen Typen – dazu müssen sie aber in dieselbe und nicht in gegensätzliche Richtungen gehen. Außerdem ist eine Erweiterung des Wertebereichs bei Einschränkung des Definitionsbereichs nicht durch den Begriff der Relation wie oben erklärt; eine wichtige Analogie zur Realität, die durch Typen zwecks semantischer Prüfung nachgebildet werden soll, ginge damit verloren.
Nun ergibt sich aber bei der Typeinschränkung auch ohne Löschen das Problem, dass sie die Zuweisungskompatibilität, die ja für die Typerweiterung noch per Typkonformität geregelt werden konnte, aushebelt.
Wesentlich für diese Betrachtungsweise, und damit das geschilderte Problem, ist übrigens, dass nach der Zuweisung von Zeile 901 d und z auf dasselbe Objekt, nämlich eine Zeichnung, verweisen. d ist also ein Alias für z (s. Kurseinheit 1, Abschnitt 1.8). Unter Wertsemantik, bei der bei der Zuweisung eine Kopie erstellt wird, hätte man hingegen überlegen müssen, wie man ein Objekt vom Typ Zeichnung in einer Variable vom Typ Dokument speichern kann; je nach interner Repräsentation der Objekte (die ja durch den Typ nicht festgelegt ist), ist dafür nämlich gar nicht genug Platz. Gleichzeitig mit der Kopie könnte dann eine Typkonvertierung erfolgen, bei der aus der Zeichnung ein Dokument gemacht würde (was auch immer das heißen mag). Dieses Dokument müsste dann, per obiger Typdefinition, auch auf einem Zeilendrucker druckbar sein. Es ist allerdings schwer vorstellbar, wie dies umzusetzen ist, wenn das entsprechende Objekt nicht einmal mehr weiß, dass es eine Zeichnung ist, geschweige denn, wie seine interne Repräsentation aussieht. In der Praxis der objektorientierten Programmierung ist daher auch nur die Referenzsemantik in Fragen der Zuweisungskompatibilität interessant.
Was die Freiheit von Typfehlern angeht, kann man das Löschen von Eigenschaften (Methoden) übrigens auch als einen Spezialfall der Typeinschränkung der obigen, zweiten Form auffassen, nämlich einer, in der der Wertebereich auf die leere Menge eingeschränkt wird. So wäre beispielsweise druckenAuf: mit einem Parametertyp ohne Elemente gar nicht mehr aufrufbar (da es kein typkorrektes Parameterobjekt gäbe), was einer Löschung gleichkäme.","<answer> Die Typeinschränkung kann die Zuweisungskompatibilität beeinträchtigen, da sie die Parameter-Typen in Methoden neu definiert und dadurch potenziell Konflikte bei der Zuweisung von Objekten unterschiedlicher Typen verursachen kann. Dies führt dazu, dass nicht alle Zuweisungen, die bei Typerweiterung basierend auf Typkonformität zulässig wären, bei Typeinschränkung ebenfalls zulässig sind. <answer> <question> Warum führt die Typeinschränkung zur Problematik der Zuweisungskompatibilität? <question>"
"Typerweiterung ist nicht die einzige Möglichkeit, auf der Basis eines bereits bestehenden einen neuen, verwandten Typen zu erzeugen; Typeinschränkung ist eine andere. Eine erste, offensichtliche Form der Typeinschränkung liegt dann vor, wenn ein Typ auf Basis eines anderen unter Entfernen von Eigenschaften (Methoden) definiert wird (das Beispiel vom Pinguin als einem Vogel, der nicht fliegen kann, kennen Sie ja bereits aus Kurseinheit 1, Abschnitt 9.2; das Beispiel vom Quadrat als einem Rechteck, das nur eine Kantenlänge braucht, ist ein anderes). Diese Form der Typeinschränkung stellt zumindest auf Ebene der Typdefinition (der Intensionen) die Umkehrung der Typerweiterung dar. Es liegt auf der Hand, dass diese Form der Typeinschränkung nicht zur Zuweisungskompatibilität führt; dies folgt schon aus der fehlenden Symmetrie der Typkonformität. Sie soll hier deswegen keine weitere Berücksichtigung finden, auch wenn es Sprachen gibt, die sie erlauben (z. B. EIFFEL).
Eine unter dem Gesichtspunkt der Zuweisungskompatibilität interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere zu ersetzen (ohne hier schon zu sagen, was „spezieller“ im Zusammenhang mit Typen bedeutet). Diese Form der Typeinschränkung ergibt sich auf natürliche Weise, wenn man sich den Zusammenhang von Extensionen von definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht.
Man mag sich fragen, warum bei der Typerweiterung in Kapitel 23 keine zwei Formen analog zur Typeinschränkung eingeführt wurden. Die Typerweiterung würde damit zur vollständigen Umkehrung der Typeinschränkung wie hier beschrieben. Wie Sie noch sehen werden, ist das Ziel nicht die Schaffung zweier Komplementäre, sondern die Vereinigung beider zu einer Beziehung zwischen Typen – dazu müssen sie aber in dieselbe und nicht in gegensätzliche Richtungen gehen. Außerdem ist eine Erweiterung des Wertebereichs bei Einschränkung des Definitionsbereichs nicht durch den Begriff der Relation wie oben erklärt; eine wichtige Analogie zur Realität, die durch Typen zwecks semantischer Prüfung nachgebildet werden soll, ginge damit verloren.
Nun ergibt sich aber bei der Typeinschränkung auch ohne Löschen das Problem, dass sie die Zuweisungskompatibilität, die ja für die Typerweiterung noch per Typkonformität geregelt werden konnte, aushebelt.
Wesentlich für diese Betrachtungsweise, und damit das geschilderte Problem, ist übrigens, dass nach der Zuweisung von Zeile 901 d und z auf dasselbe Objekt, nämlich eine Zeichnung, verweisen. d ist also ein Alias für z (s. Kurseinheit 1, Abschnitt 1.8). Unter Wertsemantik, bei der bei der Zuweisung eine Kopie erstellt wird, hätte man hingegen überlegen müssen, wie man ein Objekt vom Typ Zeichnung in einer Variable vom Typ Dokument speichern kann; je nach interner Repräsentation der Objekte (die ja durch den Typ nicht festgelegt ist), ist dafür nämlich gar nicht genug Platz. Gleichzeitig mit der Kopie könnte dann eine Typkonvertierung erfolgen, bei der aus der Zeichnung ein Dokument gemacht würde (was auch immer das heißen mag). Dieses Dokument müsste dann, per obiger Typdefinition, auch auf einem Zeilendrucker druckbar sein. Es ist allerdings schwer vorstellbar, wie dies umzusetzen ist, wenn das entsprechende Objekt nicht einmal mehr weiß, dass es eine Zeichnung ist, geschweige denn, wie seine interne Repräsentation aussieht. In der Praxis der objektorientierten Programmierung ist daher auch nur die Referenzsemantik in Fragen der Zuweisungskompatibilität interessant.
Was die Freiheit von Typfehlern angeht, kann man das Löschen von Eigenschaften (Methoden) übrigens auch als einen Spezialfall der Typeinschränkung der obigen, zweiten Form auffassen, nämlich einer, in der der Wertebereich auf die leere Menge eingeschränkt wird. So wäre beispielsweise druckenAuf: mit einem Parametertyp ohne Elemente gar nicht mehr aufrufbar (da es kein typkorrektes Parameterobjekt gäbe), was einer Löschung gleichkäme.","<answer> Die Unterscheidung zwischen Wertsemantik und Referenzsemantik ist relevant, da sie Auswirkungen auf die Zuweisungskompatibilität hat. Unter Wertsemantik wird bei der Zuweisung eine Kopie des Objekts erstellt, während unter Referenzsemantik mehrere Variablen auf dasselbe Objekt verweisen können. In diesem Zusammenhang ist die Referenzsemantik interessanter, da Typeinschränkungen bei der Zuweisung von Aliasen (Variablen, die auf dasselbe Objekt verweisen) Probleme verursachen können, die bei Wertsemantik nicht auftreten. <answer> <question> Warum ist die Unterscheidung zwischen Wertsemantik und Referenzsemantik relevant, wenn es um Typeinschränkung geht? <question>"
"Typerweiterung ist nicht die einzige Möglichkeit, auf der Basis eines bereits bestehenden einen neuen, verwandten Typen zu erzeugen; Typeinschränkung ist eine andere. Eine erste, offensichtliche Form der Typeinschränkung liegt dann vor, wenn ein Typ auf Basis eines anderen unter Entfernen von Eigenschaften (Methoden) definiert wird (das Beispiel vom Pinguin als einem Vogel, der nicht fliegen kann, kennen Sie ja bereits aus Kurseinheit 1, Abschnitt 9.2; das Beispiel vom Quadrat als einem Rechteck, das nur eine Kantenlänge braucht, ist ein anderes). Diese Form der Typeinschränkung stellt zumindest auf Ebene der Typdefinition (der Intensionen) die Umkehrung der Typerweiterung dar. Es liegt auf der Hand, dass diese Form der Typeinschränkung nicht zur Zuweisungskompatibilität führt; dies folgt schon aus der fehlenden Symmetrie der Typkonformität. Sie soll hier deswegen keine weitere Berücksichtigung finden, auch wenn es Sprachen gibt, die sie erlauben (z. B. EIFFEL).
Eine unter dem Gesichtspunkt der Zuweisungskompatibilität interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere zu ersetzen (ohne hier schon zu sagen, was „spezieller“ im Zusammenhang mit Typen bedeutet). Diese Form der Typeinschränkung ergibt sich auf natürliche Weise, wenn man sich den Zusammenhang von Extensionen von definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht.
Man mag sich fragen, warum bei der Typerweiterung in Kapitel 23 keine zwei Formen analog zur Typeinschränkung eingeführt wurden. Die Typerweiterung würde damit zur vollständigen Umkehrung der Typeinschränkung wie hier beschrieben. Wie Sie noch sehen werden, ist das Ziel nicht die Schaffung zweier Komplementäre, sondern die Vereinigung beider zu einer Beziehung zwischen Typen – dazu müssen sie aber in dieselbe und nicht in gegensätzliche Richtungen gehen. Außerdem ist eine Erweiterung des Wertebereichs bei Einschränkung des Definitionsbereichs nicht durch den Begriff der Relation wie oben erklärt; eine wichtige Analogie zur Realität, die durch Typen zwecks semantischer Prüfung nachgebildet werden soll, ginge damit verloren.
Nun ergibt sich aber bei der Typeinschränkung auch ohne Löschen das Problem, dass sie die Zuweisungskompatibilität, die ja für die Typerweiterung noch per Typkonformität geregelt werden konnte, aushebelt.
Wesentlich für diese Betrachtungsweise, und damit das geschilderte Problem, ist übrigens, dass nach der Zuweisung von Zeile 901 d und z auf dasselbe Objekt, nämlich eine Zeichnung, verweisen. d ist also ein Alias für z (s. Kurseinheit 1, Abschnitt 1.8). Unter Wertsemantik, bei der bei der Zuweisung eine Kopie erstellt wird, hätte man hingegen überlegen müssen, wie man ein Objekt vom Typ Zeichnung in einer Variable vom Typ Dokument speichern kann; je nach interner Repräsentation der Objekte (die ja durch den Typ nicht festgelegt ist), ist dafür nämlich gar nicht genug Platz. Gleichzeitig mit der Kopie könnte dann eine Typkonvertierung erfolgen, bei der aus der Zeichnung ein Dokument gemacht würde (was auch immer das heißen mag). Dieses Dokument müsste dann, per obiger Typdefinition, auch auf einem Zeilendrucker druckbar sein. Es ist allerdings schwer vorstellbar, wie dies umzusetzen ist, wenn das entsprechende Objekt nicht einmal mehr weiß, dass es eine Zeichnung ist, geschweige denn, wie seine interne Repräsentation aussieht. In der Praxis der objektorientierten Programmierung ist daher auch nur die Referenzsemantik in Fragen der Zuweisungskompatibilität interessant.
Was die Freiheit von Typfehlern angeht, kann man das Löschen von Eigenschaften (Methoden) übrigens auch als einen Spezialfall der Typeinschränkung der obigen, zweiten Form auffassen, nämlich einer, in der der Wertebereich auf die leere Menge eingeschränkt wird. So wäre beispielsweise druckenAuf: mit einem Parametertyp ohne Elemente gar nicht mehr aufrufbar (da es kein typkorrektes Parameterobjekt gäbe), was einer Löschung gleichkäme.","<answer> In der Praxis der objektorientierten Programmierung wird oft die Referenzsemantik verwendet, da sie effizienter ist und es ermöglicht, auf dasselbe Objekt von verschiedenen Stellen im Code aus zuzugreifen. Dies erleichtert die Arbeit mit komplexen Datenstrukturen und verhindert unnötige Kopien von Objekten. Die Referenzsemantik ist daher die gebräuchlichere Semantik in vielen objektorientierten Programmiersprachen. <answer> <question> Warum wird in der Praxis der objektorientierten Programmierung oft die Referenzsemantik verwendet? <question>"
"Nun hat die Subklasse die Möglichkeit, neue Member hinzuzufügen und bereits vorhandene zu redefinieren. In JAVA ist die Redefinition auf das Überschreiben beschränkt, was bedeutet, dass eine Methode mit derselben Signatur (bestehend aus Methodennamen und formalen Parametertypen) erneut definiert werden kann, jedoch mit einer geänderten Implementierung. Die Methode kann auch den Rückgabetyp kovariant ändern, d.h., in Richtung Subtyp (vgl. dazu die Diskussion in Kurseinheit 3, Abschnitt 26.3). Die Einhaltung der Typinvarianten, die mit ihren (geerbten) Parametern verbunden sind, über die hinaus die überschreibende Methode nichts tut, was mit der überschriebenen Methode inkompatibel ist, kann durch die Sprachdefinition von JAVA nicht erzwungen werden. In diesem Punkt liegt die Verantwortung beim Programmierer (vgl. dazu auch Abschnitt 52.6 in Kurseinheit 5 und 54.1 in Kurseinheit 6).
In JAVA können auch Methoden mit demselben Namen, aber verschiedenen Parametertypen in derselben Klasse oder einer Subklasse vorhanden sein. Diese Methoden nennt man dann überladen. Es ist wichtig zu verstehen, dass in JAVA Überladen und Überschreiben zwei grundverschiedene Dinge sind, obwohl in beiden Fällen eine Methode mit dem gleichen Namen erneut definiert wird: Beim Überladen wird eine neue Methode eingeführt, beim Überschreiben wird eine bereits existierende Methode neu definiert. Diese Unterscheidung spielt beim dynamischen Binden eine entscheidende Rolle.
Um das dynamische Binden in JAVA genau zu verstehen (und damit das Verhalten eines Programms vorherzusagen), muss man sich den Bindealgorithmus vor Augen halten. Dieser funktioniert wie folgt:
Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode. Sie ist in der Klasse, die dem deklarierten Typ des Ausdrucks entspricht, der das Empfängerobjekt liefert (oftmals einfach eine Variable), deklariert oder wird von einer ihrer Superklassen geerbt. Die deklarierten Parametertypen des Aufrufs (die deklarierten tatsächlichen Parametertypen) sind jeweils Subtypen der deklarierten Parametertypen der Methodendeklaration (der deklarierten formalen Parametertypen). Es gibt keine andere Methode, die dieselben Voraussetzungen erfüllt, deren deklarierte formale Parametertypen jedoch näher oder gleich weit vom Typ des Aufrufs entfernt sind (Entfernung gemessen an der Anzahl der Subtypen, die dazwischen liegen).
Dadurch wird die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden ausgewählt, die für die Bindung infrage kommt. Beachten Sie, dass die überschreibenden Methoden dieselbe Signatur haben müssen wie die überschriebene Methode; diese Methoden bilden eine Art Familie, aus der eine Methode zur Bindung ausgewählt wird.
Zur Laufzeit wird dann nur noch der tatsächliche Typ des Empfängerobjekts (die Klasse, von der es eine Instanz ist) bestimmt. Dieser muss aufgrund der Regeln der Zuweisungskompatibilität ein Subtyp des deklarierten Typs des Ausdrucks sein, der das Empfängerobjekt liefert. Mit diesem tatsächlichen (auch dynamisch genannten) Typ wird dann aus der zuvor bestimmten Gruppe von in Frage kommenden überschriebenen Methoden diejenige ausgewählt, die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Superklassenkette am nächsten ist.
Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind, meldet der Compiler einen sogenannten Methodenambiguitätsfehler. Dieser bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist. Beachten Sie, dass dieser Fehler durch Methodenaufrufe, nicht durch Methodendeklarationen verursacht wird. Wenn Sie den problematischen Aufruf entfernen, tritt auch kein Fehler mehr auf.
Beachten Sie, dass in Sprachen, in denen das dynamische Binden auch die Typen der tatsächlichen Parameter berücksichtigt (sogenanntes Mehrfach-Dispatching), der Unterschied zwischen Überladen und Überschreiben verschwimmt. In JAVA hingegen muss das dynamische Binden anhand der Parametertypen genau wie in SMALLTALK über sogenanntes Doppel-Dispatching simuliert werden.","<answer> Das Überschreiben von Methoden in JAVA bedeutet, dass eine bereits vorhandene Methode in einer Subklasse mit derselben Signatur (Methodenname und formale Parametertypen) neu definiert wird. Die Bedingungen dafür sind, dass die Methode denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode hat und dass die deklarierten Parametertypen der Methode Subtypen der deklarierten Parametertypen der Methode in der Superklasse sind. <answer> <question> Was ist das Überschreiben von Methoden in JAVA, und welche Bedingungen gelten dafür? <question>"
"Nun hat die Subklasse die Möglichkeit, neue Member hinzuzufügen und bereits vorhandene zu redefinieren. In JAVA ist die Redefinition auf das Überschreiben beschränkt, was bedeutet, dass eine Methode mit derselben Signatur (bestehend aus Methodennamen und formalen Parametertypen) erneut definiert werden kann, jedoch mit einer geänderten Implementierung. Die Methode kann auch den Rückgabetyp kovariant ändern, d.h., in Richtung Subtyp (vgl. dazu die Diskussion in Kurseinheit 3, Abschnitt 26.3). Die Einhaltung der Typinvarianten, die mit ihren (geerbten) Parametern verbunden sind, über die hinaus die überschreibende Methode nichts tut, was mit der überschriebenen Methode inkompatibel ist, kann durch die Sprachdefinition von JAVA nicht erzwungen werden. In diesem Punkt liegt die Verantwortung beim Programmierer (vgl. dazu auch Abschnitt 52.6 in Kurseinheit 5 und 54.1 in Kurseinheit 6).
In JAVA können auch Methoden mit demselben Namen, aber verschiedenen Parametertypen in derselben Klasse oder einer Subklasse vorhanden sein. Diese Methoden nennt man dann überladen. Es ist wichtig zu verstehen, dass in JAVA Überladen und Überschreiben zwei grundverschiedene Dinge sind, obwohl in beiden Fällen eine Methode mit dem gleichen Namen erneut definiert wird: Beim Überladen wird eine neue Methode eingeführt, beim Überschreiben wird eine bereits existierende Methode neu definiert. Diese Unterscheidung spielt beim dynamischen Binden eine entscheidende Rolle.
Um das dynamische Binden in JAVA genau zu verstehen (und damit das Verhalten eines Programms vorherzusagen), muss man sich den Bindealgorithmus vor Augen halten. Dieser funktioniert wie folgt:
Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode. Sie ist in der Klasse, die dem deklarierten Typ des Ausdrucks entspricht, der das Empfängerobjekt liefert (oftmals einfach eine Variable), deklariert oder wird von einer ihrer Superklassen geerbt. Die deklarierten Parametertypen des Aufrufs (die deklarierten tatsächlichen Parametertypen) sind jeweils Subtypen der deklarierten Parametertypen der Methodendeklaration (der deklarierten formalen Parametertypen). Es gibt keine andere Methode, die dieselben Voraussetzungen erfüllt, deren deklarierte formale Parametertypen jedoch näher oder gleich weit vom Typ des Aufrufs entfernt sind (Entfernung gemessen an der Anzahl der Subtypen, die dazwischen liegen).
Dadurch wird die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden ausgewählt, die für die Bindung infrage kommt. Beachten Sie, dass die überschreibenden Methoden dieselbe Signatur haben müssen wie die überschriebene Methode; diese Methoden bilden eine Art Familie, aus der eine Methode zur Bindung ausgewählt wird.
Zur Laufzeit wird dann nur noch der tatsächliche Typ des Empfängerobjekts (die Klasse, von der es eine Instanz ist) bestimmt. Dieser muss aufgrund der Regeln der Zuweisungskompatibilität ein Subtyp des deklarierten Typs des Ausdrucks sein, der das Empfängerobjekt liefert. Mit diesem tatsächlichen (auch dynamisch genannten) Typ wird dann aus der zuvor bestimmten Gruppe von in Frage kommenden überschriebenen Methoden diejenige ausgewählt, die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Superklassenkette am nächsten ist.
Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind, meldet der Compiler einen sogenannten Methodenambiguitätsfehler. Dieser bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist. Beachten Sie, dass dieser Fehler durch Methodenaufrufe, nicht durch Methodendeklarationen verursacht wird. Wenn Sie den problematischen Aufruf entfernen, tritt auch kein Fehler mehr auf.
Beachten Sie, dass in Sprachen, in denen das dynamische Binden auch die Typen der tatsächlichen Parameter berücksichtigt (sogenanntes Mehrfach-Dispatching), der Unterschied zwischen Überladen und Überschreiben verschwimmt. In JAVA hingegen muss das dynamische Binden anhand der Parametertypen genau wie in SMALLTALK über sogenanntes Doppel-Dispatching simuliert werden.","<answer> Das Überladen von Methoden in JAVA bedeutet, dass Methoden denselben Namen haben, aber verschiedene Parametertypen in derselben Klasse oder einer Subklasse haben. Der Unterschied zum Überschreiben besteht darin, dass beim Überladen neue Methoden hinzugefügt werden, während beim Überschreiben bereits vorhandene Methoden neu definiert werden. <answer> <question> Was ist das Überladen von Methoden in JAVA, und wie unterscheidet es sich vom Überschreiben? <question>"
"Nun hat die Subklasse die Möglichkeit, neue Member hinzuzufügen und bereits vorhandene zu redefinieren. In JAVA ist die Redefinition auf das Überschreiben beschränkt, was bedeutet, dass eine Methode mit derselben Signatur (bestehend aus Methodennamen und formalen Parametertypen) erneut definiert werden kann, jedoch mit einer geänderten Implementierung. Die Methode kann auch den Rückgabetyp kovariant ändern, d.h., in Richtung Subtyp (vgl. dazu die Diskussion in Kurseinheit 3, Abschnitt 26.3). Die Einhaltung der Typinvarianten, die mit ihren (geerbten) Parametern verbunden sind, über die hinaus die überschreibende Methode nichts tut, was mit der überschriebenen Methode inkompatibel ist, kann durch die Sprachdefinition von JAVA nicht erzwungen werden. In diesem Punkt liegt die Verantwortung beim Programmierer (vgl. dazu auch Abschnitt 52.6 in Kurseinheit 5 und 54.1 in Kurseinheit 6).
In JAVA können auch Methoden mit demselben Namen, aber verschiedenen Parametertypen in derselben Klasse oder einer Subklasse vorhanden sein. Diese Methoden nennt man dann überladen. Es ist wichtig zu verstehen, dass in JAVA Überladen und Überschreiben zwei grundverschiedene Dinge sind, obwohl in beiden Fällen eine Methode mit dem gleichen Namen erneut definiert wird: Beim Überladen wird eine neue Methode eingeführt, beim Überschreiben wird eine bereits existierende Methode neu definiert. Diese Unterscheidung spielt beim dynamischen Binden eine entscheidende Rolle.
Um das dynamische Binden in JAVA genau zu verstehen (und damit das Verhalten eines Programms vorherzusagen), muss man sich den Bindealgorithmus vor Augen halten. Dieser funktioniert wie folgt:
Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode. Sie ist in der Klasse, die dem deklarierten Typ des Ausdrucks entspricht, der das Empfängerobjekt liefert (oftmals einfach eine Variable), deklariert oder wird von einer ihrer Superklassen geerbt. Die deklarierten Parametertypen des Aufrufs (die deklarierten tatsächlichen Parametertypen) sind jeweils Subtypen der deklarierten Parametertypen der Methodendeklaration (der deklarierten formalen Parametertypen). Es gibt keine andere Methode, die dieselben Voraussetzungen erfüllt, deren deklarierte formale Parametertypen jedoch näher oder gleich weit vom Typ des Aufrufs entfernt sind (Entfernung gemessen an der Anzahl der Subtypen, die dazwischen liegen).
Dadurch wird die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden ausgewählt, die für die Bindung infrage kommt. Beachten Sie, dass die überschreibenden Methoden dieselbe Signatur haben müssen wie die überschriebene Methode; diese Methoden bilden eine Art Familie, aus der eine Methode zur Bindung ausgewählt wird.
Zur Laufzeit wird dann nur noch der tatsächliche Typ des Empfängerobjekts (die Klasse, von der es eine Instanz ist) bestimmt. Dieser muss aufgrund der Regeln der Zuweisungskompatibilität ein Subtyp des deklarierten Typs des Ausdrucks sein, der das Empfängerobjekt liefert. Mit diesem tatsächlichen (auch dynamisch genannten) Typ wird dann aus der zuvor bestimmten Gruppe von in Frage kommenden überschriebenen Methoden diejenige ausgewählt, die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Superklassenkette am nächsten ist.
Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind, meldet der Compiler einen sogenannten Methodenambiguitätsfehler. Dieser bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist. Beachten Sie, dass dieser Fehler durch Methodenaufrufe, nicht durch Methodendeklarationen verursacht wird. Wenn Sie den problematischen Aufruf entfernen, tritt auch kein Fehler mehr auf.
Beachten Sie, dass in Sprachen, in denen das dynamische Binden auch die Typen der tatsächlichen Parameter berücksichtigt (sogenanntes Mehrfach-Dispatching), der Unterschied zwischen Überladen und Überschreiben verschwimmt. In JAVA hingegen muss das dynamische Binden anhand der Parametertypen genau wie in SMALLTALK über sogenanntes Doppel-Dispatching simuliert werden.","<answer> Das dynamische Binden in JAVA bezieht sich auf die Auswahl der Methode zur Laufzeit, basierend auf dem tatsächlichen Typ des Empfängerobjekts. Der Bindungsalgorithmus in JAVA wählt die Methode aus, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode, ist in der Klasse des deklarierten Typs des Ausdrucks deklariert und deren deklarierte Parametertypen sind Subtypen der deklarierten Parametertypen der aufgerufenen Methode. Wenn mehrere Methoden die Bedingungen erfüllen, wird diejenige ausgewählt, deren Klasse am nächsten zur Klasse des Empfängerobjekts in der Superklassenkette ist. <answer> <question> Was ist dynamisches Binden in JAVA, und wie funktioniert der Bindungsalgorithmus? <question>"
"Nun hat die Subklasse die Möglichkeit, neue Member hinzuzufügen und bereits vorhandene zu redefinieren. In JAVA ist die Redefinition auf das Überschreiben beschränkt, was bedeutet, dass eine Methode mit derselben Signatur (bestehend aus Methodennamen und formalen Parametertypen) erneut definiert werden kann, jedoch mit einer geänderten Implementierung. Die Methode kann auch den Rückgabetyp kovariant ändern, d.h., in Richtung Subtyp (vgl. dazu die Diskussion in Kurseinheit 3, Abschnitt 26.3). Die Einhaltung der Typinvarianten, die mit ihren (geerbten) Parametern verbunden sind, über die hinaus die überschreibende Methode nichts tut, was mit der überschriebenen Methode inkompatibel ist, kann durch die Sprachdefinition von JAVA nicht erzwungen werden. In diesem Punkt liegt die Verantwortung beim Programmierer (vgl. dazu auch Abschnitt 52.6 in Kurseinheit 5 und 54.1 in Kurseinheit 6).
In JAVA können auch Methoden mit demselben Namen, aber verschiedenen Parametertypen in derselben Klasse oder einer Subklasse vorhanden sein. Diese Methoden nennt man dann überladen. Es ist wichtig zu verstehen, dass in JAVA Überladen und Überschreiben zwei grundverschiedene Dinge sind, obwohl in beiden Fällen eine Methode mit dem gleichen Namen erneut definiert wird: Beim Überladen wird eine neue Methode eingeführt, beim Überschreiben wird eine bereits existierende Methode neu definiert. Diese Unterscheidung spielt beim dynamischen Binden eine entscheidende Rolle.
Um das dynamische Binden in JAVA genau zu verstehen (und damit das Verhalten eines Programms vorherzusagen), muss man sich den Bindealgorithmus vor Augen halten. Dieser funktioniert wie folgt:
Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode. Sie ist in der Klasse, die dem deklarierten Typ des Ausdrucks entspricht, der das Empfängerobjekt liefert (oftmals einfach eine Variable), deklariert oder wird von einer ihrer Superklassen geerbt. Die deklarierten Parametertypen des Aufrufs (die deklarierten tatsächlichen Parametertypen) sind jeweils Subtypen der deklarierten Parametertypen der Methodendeklaration (der deklarierten formalen Parametertypen). Es gibt keine andere Methode, die dieselben Voraussetzungen erfüllt, deren deklarierte formale Parametertypen jedoch näher oder gleich weit vom Typ des Aufrufs entfernt sind (Entfernung gemessen an der Anzahl der Subtypen, die dazwischen liegen).
Dadurch wird die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden ausgewählt, die für die Bindung infrage kommt. Beachten Sie, dass die überschreibenden Methoden dieselbe Signatur haben müssen wie die überschriebene Methode; diese Methoden bilden eine Art Familie, aus der eine Methode zur Bindung ausgewählt wird.
Zur Laufzeit wird dann nur noch der tatsächliche Typ des Empfängerobjekts (die Klasse, von der es eine Instanz ist) bestimmt. Dieser muss aufgrund der Regeln der Zuweisungskompatibilität ein Subtyp des deklarierten Typs des Ausdrucks sein, der das Empfängerobjekt liefert. Mit diesem tatsächlichen (auch dynamisch genannten) Typ wird dann aus der zuvor bestimmten Gruppe von in Frage kommenden überschriebenen Methoden diejenige ausgewählt, die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Superklassenkette am nächsten ist.
Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind, meldet der Compiler einen sogenannten Methodenambiguitätsfehler. Dieser bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist. Beachten Sie, dass dieser Fehler durch Methodenaufrufe, nicht durch Methodendeklarationen verursacht wird. Wenn Sie den problematischen Aufruf entfernen, tritt auch kein Fehler mehr auf.
Beachten Sie, dass in Sprachen, in denen das dynamische Binden auch die Typen der tatsächlichen Parameter berücksichtigt (sogenanntes Mehrfach-Dispatching), der Unterschied zwischen Überladen und Überschreiben verschwimmt. In JAVA hingegen muss das dynamische Binden anhand der Parametertypen genau wie in SMALLTALK über sogenanntes Doppel-Dispatching simuliert werden.","<answer> Wenn der Bindungsalgorithmus zu mehreren Methoden führt, die die Bedingungen erfüllen, meldet der Compiler einen Methodenambiguitätsfehler, da die aufgerufene Methode nicht eindeutig bestimmt werden kann. Dieser Fehler wird durch Methodenaufrufe, nicht durch Methodendeklarationen, verursacht. <answer> <question> Was passiert, wenn der Bindungsalgorithmus in JAVA zu mehreren Methoden führt, die die Bedingungen erfüllen? <question>"
"Nun hat die Subklasse die Möglichkeit, neue Member hinzuzufügen und bereits vorhandene zu redefinieren. In JAVA ist die Redefinition auf das Überschreiben beschränkt, was bedeutet, dass eine Methode mit derselben Signatur (bestehend aus Methodennamen und formalen Parametertypen) erneut definiert werden kann, jedoch mit einer geänderten Implementierung. Die Methode kann auch den Rückgabetyp kovariant ändern, d.h., in Richtung Subtyp (vgl. dazu die Diskussion in Kurseinheit 3, Abschnitt 26.3). Die Einhaltung der Typinvarianten, die mit ihren (geerbten) Parametern verbunden sind, über die hinaus die überschreibende Methode nichts tut, was mit der überschriebenen Methode inkompatibel ist, kann durch die Sprachdefinition von JAVA nicht erzwungen werden. In diesem Punkt liegt die Verantwortung beim Programmierer (vgl. dazu auch Abschnitt 52.6 in Kurseinheit 5 und 54.1 in Kurseinheit 6).
In JAVA können auch Methoden mit demselben Namen, aber verschiedenen Parametertypen in derselben Klasse oder einer Subklasse vorhanden sein. Diese Methoden nennt man dann überladen. Es ist wichtig zu verstehen, dass in JAVA Überladen und Überschreiben zwei grundverschiedene Dinge sind, obwohl in beiden Fällen eine Methode mit dem gleichen Namen erneut definiert wird: Beim Überladen wird eine neue Methode eingeführt, beim Überschreiben wird eine bereits existierende Methode neu definiert. Diese Unterscheidung spielt beim dynamischen Binden eine entscheidende Rolle.
Um das dynamische Binden in JAVA genau zu verstehen (und damit das Verhalten eines Programms vorherzusagen), muss man sich den Bindealgorithmus vor Augen halten. Dieser funktioniert wie folgt:
Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode. Sie ist in der Klasse, die dem deklarierten Typ des Ausdrucks entspricht, der das Empfängerobjekt liefert (oftmals einfach eine Variable), deklariert oder wird von einer ihrer Superklassen geerbt. Die deklarierten Parametertypen des Aufrufs (die deklarierten tatsächlichen Parametertypen) sind jeweils Subtypen der deklarierten Parametertypen der Methodendeklaration (der deklarierten formalen Parametertypen). Es gibt keine andere Methode, die dieselben Voraussetzungen erfüllt, deren deklarierte formale Parametertypen jedoch näher oder gleich weit vom Typ des Aufrufs entfernt sind (Entfernung gemessen an der Anzahl der Subtypen, die dazwischen liegen).
Dadurch wird die oberste Methode in einer Gruppe von potenziell in Subklassen überschriebenen Methoden ausgewählt, die für die Bindung infrage kommt. Beachten Sie, dass die überschreibenden Methoden dieselbe Signatur haben müssen wie die überschriebene Methode; diese Methoden bilden eine Art Familie, aus der eine Methode zur Bindung ausgewählt wird.
Zur Laufzeit wird dann nur noch der tatsächliche Typ des Empfängerobjekts (die Klasse, von der es eine Instanz ist) bestimmt. Dieser muss aufgrund der Regeln der Zuweisungskompatibilität ein Subtyp des deklarierten Typs des Ausdrucks sein, der das Empfängerobjekt liefert. Mit diesem tatsächlichen (auch dynamisch genannten) Typ wird dann aus der zuvor bestimmten Gruppe von in Frage kommenden überschriebenen Methoden diejenige ausgewählt, die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Superklassenkette am nächsten ist.
Wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind, meldet der Compiler einen sogenannten Methodenambiguitätsfehler. Dieser bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist. Beachten Sie, dass dieser Fehler durch Methodenaufrufe, nicht durch Methodendeklarationen verursacht wird. Wenn Sie den problematischen Aufruf entfernen, tritt auch kein Fehler mehr auf.
Beachten Sie, dass in Sprachen, in denen das dynamische Binden auch die Typen der tatsächlichen Parameter berücksichtigt (sogenanntes Mehrfach-Dispatching), der Unterschied zwischen Überladen und Überschreiben verschwimmt. In JAVA hingegen muss das dynamische Binden anhand der Parametertypen genau wie in SMALLTALK über sogenanntes Doppel-Dispatching simuliert werden.","<answer> Das dynamische Binden in JAVA erfolgt zur Laufzeit, wenn der tatsächliche Typ des Empfängerobjekts bestimmt wird, um die entsprechende Methode auszuwählen. Es ist wichtig zu verstehen, da es das Verhalten eines Programms beeinflusst und zur Vorhersage des Programmverhaltens beiträgt. <answer> <question> Wie wird das dynamische Binden in JAVA durchgeführt, und warum ist es wichtig zu verstehen? <question>"
"Das Programmiermodell von C# unterscheidet sich zunächst nicht wesentlich von dem von JAVA: Auch in C# ist der Code auf Klassen verteilt, die einzeln übersetzt werden können. Klassen werden in Dateien gespeichert, jedoch ist das Verhältnis von Klasse zu Datei lockerer als in JAVA (u. a. können Klassen anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden). Allerdings sind der Bytecode und die dazu passende virtuelle Maschine nicht speziell für C# entworfen, sondern für alle sog. .NET-Sprachen. So heißt denn auch die Sprache des Bytecode Common Intermediate Language (CIL); sie gilt als (gerade noch) menschenlesbar.
Anders als bei JAVA waren bei C# Flexibilität und Performanz von Anfang an kritische Gesichtspunkte des Sprachentwurfs. Für C# war daher von Anfang an und ausschließlich die sog. Just-in-time-(JIT-)Kompilierung vorgesehen, die den CIL-Code unmittelbar vor der Ausführung (und nur, wenn er überhaupt ausgeführt wird) in Maschinencode der Maschine, auf der er gerade läuft, übersetzt. Die Einheiten der JIT-Kompilierung gehen dabei hinunter bis zu einzelnen Methoden. Eine vollständige Kompilierung von CIL in nativen Maschinencode vor der Ausführung ist ebenfalls möglich.
Eine andere Eigenschaft von JAVA, mit der die Programmiererinnen von MICROSOFT offenbar nicht unter allen Umständen leben konnten, ist die Garbage Collection. In C# hat man daher die Möglichkeit, den Speicherplatz für Objekte, die mit ""new"" erzeugt wurden, selbst wieder freizugeben. Doch wehe derjenige, der das vergisst: Speicherlecks sind die unmittelbare Folge. Noch schlimmer sind aber Speicherfreigaben von Objekten, auf die noch Referenzen existieren: Diese zeigen dann ins Leere oder, wenn der Speicher wieder belegt wird, auf oder mitten hinein in ein anderes Objekt. Eine Katastrophe. Aber damit nicht genug: Das mit SMALLTALK und JAVA abgeschaffte Hantieren mit Pointern wurde in C# auch wiedereingeführt, wohl weil man in der systemnahen Programmierung (und bei Aufrufen in das hauseigene Betriebssystem) nicht darauf verzichten konnte. Allerdings sind beide Rückschritte — explizite Speicherverwaltung und das Hantieren mit Pointern — in sog. unsichere Bereiche verbannt. Dazu gibt es in C# einen Modifikator ""unsafe"", der solche Bereiche einleitet:
Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger-auf-Typ handelt; vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch überladen wurde. Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.","<answer> Das Programmiermodell von C# weist zunächst einige Ähnlichkeiten mit dem von JAVA auf, da es ebenfalls auf Klassen basiert und der Code in einzelnen Klassen organisiert ist. Die Klassen in C# können jedoch in lockererem Verhältnis zu Dateien stehen, und Klassen können anders benannt werden als ihre Dateien. Ein wesentlicher Unterschied besteht darin, dass der Bytecode von C# und die zugehörige virtuelle Maschine, Common Intermediate Language (CIL) genannt, für alle .NET-Sprachen entwickelt wurden und nicht exklusiv für C#. Die CIL gilt als menschenlesbar. <answer> <question> Wie unterscheidet sich das Programmiermodell von C# von dem von JAVA? <question>"
"Das Programmiermodell von C# unterscheidet sich zunächst nicht wesentlich von dem von JAVA: Auch in C# ist der Code auf Klassen verteilt, die einzeln übersetzt werden können. Klassen werden in Dateien gespeichert, jedoch ist das Verhältnis von Klasse zu Datei lockerer als in JAVA (u. a. können Klassen anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden). Allerdings sind der Bytecode und die dazu passende virtuelle Maschine nicht speziell für C# entworfen, sondern für alle sog. .NET-Sprachen. So heißt denn auch die Sprache des Bytecode Common Intermediate Language (CIL); sie gilt als (gerade noch) menschenlesbar.
Anders als bei JAVA waren bei C# Flexibilität und Performanz von Anfang an kritische Gesichtspunkte des Sprachentwurfs. Für C# war daher von Anfang an und ausschließlich die sog. Just-in-time-(JIT-)Kompilierung vorgesehen, die den CIL-Code unmittelbar vor der Ausführung (und nur, wenn er überhaupt ausgeführt wird) in Maschinencode der Maschine, auf der er gerade läuft, übersetzt. Die Einheiten der JIT-Kompilierung gehen dabei hinunter bis zu einzelnen Methoden. Eine vollständige Kompilierung von CIL in nativen Maschinencode vor der Ausführung ist ebenfalls möglich.
Eine andere Eigenschaft von JAVA, mit der die Programmiererinnen von MICROSOFT offenbar nicht unter allen Umständen leben konnten, ist die Garbage Collection. In C# hat man daher die Möglichkeit, den Speicherplatz für Objekte, die mit ""new"" erzeugt wurden, selbst wieder freizugeben. Doch wehe derjenige, der das vergisst: Speicherlecks sind die unmittelbare Folge. Noch schlimmer sind aber Speicherfreigaben von Objekten, auf die noch Referenzen existieren: Diese zeigen dann ins Leere oder, wenn der Speicher wieder belegt wird, auf oder mitten hinein in ein anderes Objekt. Eine Katastrophe. Aber damit nicht genug: Das mit SMALLTALK und JAVA abgeschaffte Hantieren mit Pointern wurde in C# auch wiedereingeführt, wohl weil man in der systemnahen Programmierung (und bei Aufrufen in das hauseigene Betriebssystem) nicht darauf verzichten konnte. Allerdings sind beide Rückschritte — explizite Speicherverwaltung und das Hantieren mit Pointern — in sog. unsichere Bereiche verbannt. Dazu gibt es in C# einen Modifikator ""unsafe"", der solche Bereiche einleitet:
Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger-auf-Typ handelt; vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch überladen wurde. Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.","<answer> In C# ist die Just-in-time-(JIT-)Kompilierung die Standardmethode zur Übersetzung des CIL-Codes in Maschinencode. Dieser Vorgang erfolgt unmittelbar vor der Ausführung und nur dann, wenn der Code tatsächlich ausgeführt wird. Im Gegensatz dazu verwendet JAVA normalerweise den Ahead-of-time-(AOT-)Kompilierungsansatz, bei dem der Bytecode vor der Ausführung in nativen Maschinencode übersetzt wird. Die JIT-Kompilierung in C# ermöglicht eine feinere Granularität, da sie bis auf die Ebene einzelner Methoden herabgeht. <answer> <question> Was ist die Just-in-time-(JIT-)Kompilierung in C# und wie unterscheidet sie sich von JAVA? <question>"
"Das Programmiermodell von C# unterscheidet sich zunächst nicht wesentlich von dem von JAVA: Auch in C# ist der Code auf Klassen verteilt, die einzeln übersetzt werden können. Klassen werden in Dateien gespeichert, jedoch ist das Verhältnis von Klasse zu Datei lockerer als in JAVA (u. a. können Klassen anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden). Allerdings sind der Bytecode und die dazu passende virtuelle Maschine nicht speziell für C# entworfen, sondern für alle sog. .NET-Sprachen. So heißt denn auch die Sprache des Bytecode Common Intermediate Language (CIL); sie gilt als (gerade noch) menschenlesbar.
Anders als bei JAVA waren bei C# Flexibilität und Performanz von Anfang an kritische Gesichtspunkte des Sprachentwurfs. Für C# war daher von Anfang an und ausschließlich die sog. Just-in-time-(JIT-)Kompilierung vorgesehen, die den CIL-Code unmittelbar vor der Ausführung (und nur, wenn er überhaupt ausgeführt wird) in Maschinencode der Maschine, auf der er gerade läuft, übersetzt. Die Einheiten der JIT-Kompilierung gehen dabei hinunter bis zu einzelnen Methoden. Eine vollständige Kompilierung von CIL in nativen Maschinencode vor der Ausführung ist ebenfalls möglich.
Eine andere Eigenschaft von JAVA, mit der die Programmiererinnen von MICROSOFT offenbar nicht unter allen Umständen leben konnten, ist die Garbage Collection. In C# hat man daher die Möglichkeit, den Speicherplatz für Objekte, die mit ""new"" erzeugt wurden, selbst wieder freizugeben. Doch wehe derjenige, der das vergisst: Speicherlecks sind die unmittelbare Folge. Noch schlimmer sind aber Speicherfreigaben von Objekten, auf die noch Referenzen existieren: Diese zeigen dann ins Leere oder, wenn der Speicher wieder belegt wird, auf oder mitten hinein in ein anderes Objekt. Eine Katastrophe. Aber damit nicht genug: Das mit SMALLTALK und JAVA abgeschaffte Hantieren mit Pointern wurde in C# auch wiedereingeführt, wohl weil man in der systemnahen Programmierung (und bei Aufrufen in das hauseigene Betriebssystem) nicht darauf verzichten konnte. Allerdings sind beide Rückschritte — explizite Speicherverwaltung und das Hantieren mit Pointern — in sog. unsichere Bereiche verbannt. Dazu gibt es in C# einen Modifikator ""unsafe"", der solche Bereiche einleitet:
Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger-auf-Typ handelt; vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch überladen wurde. Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.","<answer> In C# haben Entwickler die Möglichkeit, den Speicherplatz für Objekte, die mit ""new"" erstellt wurden, manuell freizugeben. Dies kann jedoch zu Speicherlecks führen, wenn Entwickler vergessen, den Speicher freizugeben, oder zu Problemen, wenn auf freigegebene Objekte weiterhin Referenzen vorhanden sind. Im Gegensatz dazu verwendet JAVA normalerweise eine automatische Garbage Collection, bei der nicht mehr benötigte Objekte automatisch erkannt und freigegeben werden. <answer> <question> Welche Unterschiede gibt es in Bezug auf die Garbage Collection zwischen C# und JAVA? <question>"
"Das Programmiermodell von C# unterscheidet sich zunächst nicht wesentlich von dem von JAVA: Auch in C# ist der Code auf Klassen verteilt, die einzeln übersetzt werden können. Klassen werden in Dateien gespeichert, jedoch ist das Verhältnis von Klasse zu Datei lockerer als in JAVA (u. a. können Klassen anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden). Allerdings sind der Bytecode und die dazu passende virtuelle Maschine nicht speziell für C# entworfen, sondern für alle sog. .NET-Sprachen. So heißt denn auch die Sprache des Bytecode Common Intermediate Language (CIL); sie gilt als (gerade noch) menschenlesbar.
Anders als bei JAVA waren bei C# Flexibilität und Performanz von Anfang an kritische Gesichtspunkte des Sprachentwurfs. Für C# war daher von Anfang an und ausschließlich die sog. Just-in-time-(JIT-)Kompilierung vorgesehen, die den CIL-Code unmittelbar vor der Ausführung (und nur, wenn er überhaupt ausgeführt wird) in Maschinencode der Maschine, auf der er gerade läuft, übersetzt. Die Einheiten der JIT-Kompilierung gehen dabei hinunter bis zu einzelnen Methoden. Eine vollständige Kompilierung von CIL in nativen Maschinencode vor der Ausführung ist ebenfalls möglich.
Eine andere Eigenschaft von JAVA, mit der die Programmiererinnen von MICROSOFT offenbar nicht unter allen Umständen leben konnten, ist die Garbage Collection. In C# hat man daher die Möglichkeit, den Speicherplatz für Objekte, die mit ""new"" erzeugt wurden, selbst wieder freizugeben. Doch wehe derjenige, der das vergisst: Speicherlecks sind die unmittelbare Folge. Noch schlimmer sind aber Speicherfreigaben von Objekten, auf die noch Referenzen existieren: Diese zeigen dann ins Leere oder, wenn der Speicher wieder belegt wird, auf oder mitten hinein in ein anderes Objekt. Eine Katastrophe. Aber damit nicht genug: Das mit SMALLTALK und JAVA abgeschaffte Hantieren mit Pointern wurde in C# auch wiedereingeführt, wohl weil man in der systemnahen Programmierung (und bei Aufrufen in das hauseigene Betriebssystem) nicht darauf verzichten konnte. Allerdings sind beide Rückschritte — explizite Speicherverwaltung und das Hantieren mit Pointern — in sog. unsichere Bereiche verbannt. Dazu gibt es in C# einen Modifikator ""unsafe"", der solche Bereiche einleitet:
Dabei bedeutet der Stern hinter einem Typ, dass es sich um einen Zeiger-auf-Typ handelt; vor einer Variable bedeutet er, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird. Nebenbei bedeutet der Stern aber auch noch die Multiplikation und all das, wofür er sonst noch überladen wurde. Neben Methoden können auch Klassen, Blöcke und Variablen unsicher sein.","<answer> In C# wurde das Hantieren mit Pointern in unsichere Bereiche verbannt, weil es in systemnahen Programmierungen und beim Zugriff auf das Betriebssystem notwendig ist. Der Modifikator ""unsafe"" kennzeichnet solche unsicheren Bereiche und wird verwendet, um den Einsatz von Pointern zu ermöglichen. In unsicheren Bereichen können Zeiger auf Typen deklariert werden, und die Dereferenzierung eines Zeigers erfolgt mit einem Stern (*). Dies ermöglicht das Hantieren mit Pointern in einem begrenzten und kontrollierten Umfeld. <answer> <question> Warum wurde in C# das Hantieren mit Pointern wieder eingeführt, und wie werden unsichere Bereiche behandelt? <question>"
"In Kapitel 2 von Kurseinheit 1 waren wir bereits auf :n-Beziehungen eingegangen, die logisch gleichberechtigt neben :1-Beziehungen stehen, die aber in der Umsetzung besonderer Mechanismen bedürfen. Als Basis der Umsetzung hatten Sie bereits Zwischenobjekte kennengelernt, die über ihre indizierten Instanzvariablen solche Beziehungen — wenn auch nur indirekt — herstellen können. Tatsächlich könnte man, wenn man sich der Häufigkeit des Vorkommens von :n-Beziehungen in der Programmierung bewusst ist, vermuten, dass indizierte Instanzvariablen speziell für diesen Zweck eingeführt wurden. Auf den ersten Blick bedauerlich ist nur, dass dafür eben diese Zwischenobjekte notwendig sind.
Es ergibt sich aus diesem Umstand aber auch ein entscheidender Vorteil. Da auch diese Zwischenobjekte Instanzen von Klassen sein müssen, ist es möglich, verschiedene Arten von :n-Beziehungen zu definieren und diese jeweils mit Verhalten zu versehen, das speziell auf die Art der Beziehung bezogen ist. So ist es beispielsweise möglich, :n-Beziehungen zu definieren, deren Elemente (die in Beziehung stehenden Objekte) jeweils nur einmal darin vorkommen dürfen (mengenwertige Beziehungen) oder nach einem bestimmten Kriterium sortiert sind. Auch können Operationen wie das Hinzufügen oder Entfernen von Objekten zu einer Beziehung, die bei :1-Beziehungen über die Zuweisung zu einer Instanzvariable erfolgen (das Entfernen durch Zuweisung von nil), beliebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu erhalten.
Besonders attraktiv ist jedoch die in SMALLTALK bestehende Möglichkeit, eigene Kontrollstrukturen für :n-Beziehungen zu spezifizieren. Die bereits vorhandenen durften Sie ja schon in Abschnitt 4.6.4 kennenlernen; hier kommt hinzu, dass die Standarditeratoren je nach Art der Beziehung unterschiedliche Eigenschaften haben. Außerdem ist es natürlich möglich, mit eigenen Arten von Beziehungen auch spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren.","<answer> :n-Beziehungen sind Beziehungen, bei denen ein Objekt mit mehreren anderen Objekten in Beziehung stehen kann. Sie stehen logisch gleichberechtigt neben :1-Beziehungen, bei denen ein Objekt nur mit einem anderen Objekt in Beziehung steht. Die Umsetzung von :n-Beziehungen erfordert jedoch besondere Mechanismen. <answer> <question> Was sind :n-Beziehungen und wie stehen sie zu :1-Beziehungen? <question>"
"In Kapitel 2 von Kurseinheit 1 waren wir bereits auf :n-Beziehungen eingegangen, die logisch gleichberechtigt neben :1-Beziehungen stehen, die aber in der Umsetzung besonderer Mechanismen bedürfen. Als Basis der Umsetzung hatten Sie bereits Zwischenobjekte kennengelernt, die über ihre indizierten Instanzvariablen solche Beziehungen — wenn auch nur indirekt — herstellen können. Tatsächlich könnte man, wenn man sich der Häufigkeit des Vorkommens von :n-Beziehungen in der Programmierung bewusst ist, vermuten, dass indizierte Instanzvariablen speziell für diesen Zweck eingeführt wurden. Auf den ersten Blick bedauerlich ist nur, dass dafür eben diese Zwischenobjekte notwendig sind.
Es ergibt sich aus diesem Umstand aber auch ein entscheidender Vorteil. Da auch diese Zwischenobjekte Instanzen von Klassen sein müssen, ist es möglich, verschiedene Arten von :n-Beziehungen zu definieren und diese jeweils mit Verhalten zu versehen, das speziell auf die Art der Beziehung bezogen ist. So ist es beispielsweise möglich, :n-Beziehungen zu definieren, deren Elemente (die in Beziehung stehenden Objekte) jeweils nur einmal darin vorkommen dürfen (mengenwertige Beziehungen) oder nach einem bestimmten Kriterium sortiert sind. Auch können Operationen wie das Hinzufügen oder Entfernen von Objekten zu einer Beziehung, die bei :1-Beziehungen über die Zuweisung zu einer Instanzvariable erfolgen (das Entfernen durch Zuweisung von nil), beliebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu erhalten.
Besonders attraktiv ist jedoch die in SMALLTALK bestehende Möglichkeit, eigene Kontrollstrukturen für :n-Beziehungen zu spezifizieren. Die bereits vorhandenen durften Sie ja schon in Abschnitt 4.6.4 kennenlernen; hier kommt hinzu, dass die Standarditeratoren je nach Art der Beziehung unterschiedliche Eigenschaften haben. Außerdem ist es natürlich möglich, mit eigenen Arten von Beziehungen auch spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren.","<answer> Zwischenobjekte spielen eine Rolle in der Umsetzung von :n-Beziehungen. Sie ermöglichen es, solche Beziehungen indirekt über ihre indizierten Instanzvariablen herzustellen. <answer> <question> Welche Rolle spielen Zwischenobjekte in der Umsetzung von :n-Beziehungen? <question>"
"In Kapitel 2 von Kurseinheit 1 waren wir bereits auf :n-Beziehungen eingegangen, die logisch gleichberechtigt neben :1-Beziehungen stehen, die aber in der Umsetzung besonderer Mechanismen bedürfen. Als Basis der Umsetzung hatten Sie bereits Zwischenobjekte kennengelernt, die über ihre indizierten Instanzvariablen solche Beziehungen — wenn auch nur indirekt — herstellen können. Tatsächlich könnte man, wenn man sich der Häufigkeit des Vorkommens von :n-Beziehungen in der Programmierung bewusst ist, vermuten, dass indizierte Instanzvariablen speziell für diesen Zweck eingeführt wurden. Auf den ersten Blick bedauerlich ist nur, dass dafür eben diese Zwischenobjekte notwendig sind.
Es ergibt sich aus diesem Umstand aber auch ein entscheidender Vorteil. Da auch diese Zwischenobjekte Instanzen von Klassen sein müssen, ist es möglich, verschiedene Arten von :n-Beziehungen zu definieren und diese jeweils mit Verhalten zu versehen, das speziell auf die Art der Beziehung bezogen ist. So ist es beispielsweise möglich, :n-Beziehungen zu definieren, deren Elemente (die in Beziehung stehenden Objekte) jeweils nur einmal darin vorkommen dürfen (mengenwertige Beziehungen) oder nach einem bestimmten Kriterium sortiert sind. Auch können Operationen wie das Hinzufügen oder Entfernen von Objekten zu einer Beziehung, die bei :1-Beziehungen über die Zuweisung zu einer Instanzvariable erfolgen (das Entfernen durch Zuweisung von nil), beliebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu erhalten.
Besonders attraktiv ist jedoch die in SMALLTALK bestehende Möglichkeit, eigene Kontrollstrukturen für :n-Beziehungen zu spezifizieren. Die bereits vorhandenen durften Sie ja schon in Abschnitt 4.6.4 kennenlernen; hier kommt hinzu, dass die Standarditeratoren je nach Art der Beziehung unterschiedliche Eigenschaften haben. Außerdem ist es natürlich möglich, mit eigenen Arten von Beziehungen auch spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren.","<answer> Indizierten Instanzvariablen könnten den Anschein erwecken, speziell für :n-Beziehungen eingeführt worden zu sein, da sie es ermöglichen, Elemente in Beziehung zu setzen, selbst wenn sie nur indirekt über Zwischenobjekte erreicht werden. Dies erleichtert die Arbeit mit :n-Beziehungen. <answer> <question> Warum könnte die Einführung von indizierten Instanzvariablen den Anschein erwecken, dass sie speziell für :n-Beziehungen eingeführt wurden? <question>"
"In Kapitel 2 von Kurseinheit 1 waren wir bereits auf :n-Beziehungen eingegangen, die logisch gleichberechtigt neben :1-Beziehungen stehen, die aber in der Umsetzung besonderer Mechanismen bedürfen. Als Basis der Umsetzung hatten Sie bereits Zwischenobjekte kennengelernt, die über ihre indizierten Instanzvariablen solche Beziehungen — wenn auch nur indirekt — herstellen können. Tatsächlich könnte man, wenn man sich der Häufigkeit des Vorkommens von :n-Beziehungen in der Programmierung bewusst ist, vermuten, dass indizierte Instanzvariablen speziell für diesen Zweck eingeführt wurden. Auf den ersten Blick bedauerlich ist nur, dass dafür eben diese Zwischenobjekte notwendig sind.
Es ergibt sich aus diesem Umstand aber auch ein entscheidender Vorteil. Da auch diese Zwischenobjekte Instanzen von Klassen sein müssen, ist es möglich, verschiedene Arten von :n-Beziehungen zu definieren und diese jeweils mit Verhalten zu versehen, das speziell auf die Art der Beziehung bezogen ist. So ist es beispielsweise möglich, :n-Beziehungen zu definieren, deren Elemente (die in Beziehung stehenden Objekte) jeweils nur einmal darin vorkommen dürfen (mengenwertige Beziehungen) oder nach einem bestimmten Kriterium sortiert sind. Auch können Operationen wie das Hinzufügen oder Entfernen von Objekten zu einer Beziehung, die bei :1-Beziehungen über die Zuweisung zu einer Instanzvariable erfolgen (das Entfernen durch Zuweisung von nil), beliebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu erhalten.
Besonders attraktiv ist jedoch die in SMALLTALK bestehende Möglichkeit, eigene Kontrollstrukturen für :n-Beziehungen zu spezifizieren. Die bereits vorhandenen durften Sie ja schon in Abschnitt 4.6.4 kennenlernen; hier kommt hinzu, dass die Standarditeratoren je nach Art der Beziehung unterschiedliche Eigenschaften haben. Außerdem ist es natürlich möglich, mit eigenen Arten von Beziehungen auch spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren.","<answer> Ein entscheidender Vorteil der Verwendung von Zwischenobjekten in Bezug auf :n-Beziehungen ist die Möglichkeit, verschiedene Arten von solchen Beziehungen zu definieren und diesen jeweils spezifisches Verhalten zuzuweisen, das auf die Art der Beziehung abgestimmt ist. Dies ermöglicht es, mengenwertige Beziehungen oder sortierte Beziehungen zu erstellen und Operationen wie das Hinzufügen oder Entfernen von Objekten individuell anzupassen. <answer> <question> Welcher Vorteil ergibt sich aus der Verwendung von Zwischenobjekten in Bezug auf :n-Beziehungen? <question>"
"In Kapitel 2 von Kurseinheit 1 waren wir bereits auf :n-Beziehungen eingegangen, die logisch gleichberechtigt neben :1-Beziehungen stehen, die aber in der Umsetzung besonderer Mechanismen bedürfen. Als Basis der Umsetzung hatten Sie bereits Zwischenobjekte kennengelernt, die über ihre indizierten Instanzvariablen solche Beziehungen — wenn auch nur indirekt — herstellen können. Tatsächlich könnte man, wenn man sich der Häufigkeit des Vorkommens von :n-Beziehungen in der Programmierung bewusst ist, vermuten, dass indizierte Instanzvariablen speziell für diesen Zweck eingeführt wurden. Auf den ersten Blick bedauerlich ist nur, dass dafür eben diese Zwischenobjekte notwendig sind.
Es ergibt sich aus diesem Umstand aber auch ein entscheidender Vorteil. Da auch diese Zwischenobjekte Instanzen von Klassen sein müssen, ist es möglich, verschiedene Arten von :n-Beziehungen zu definieren und diese jeweils mit Verhalten zu versehen, das speziell auf die Art der Beziehung bezogen ist. So ist es beispielsweise möglich, :n-Beziehungen zu definieren, deren Elemente (die in Beziehung stehenden Objekte) jeweils nur einmal darin vorkommen dürfen (mengenwertige Beziehungen) oder nach einem bestimmten Kriterium sortiert sind. Auch können Operationen wie das Hinzufügen oder Entfernen von Objekten zu einer Beziehung, die bei :1-Beziehungen über die Zuweisung zu einer Instanzvariable erfolgen (das Entfernen durch Zuweisung von nil), beliebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu erhalten.
Besonders attraktiv ist jedoch die in SMALLTALK bestehende Möglichkeit, eigene Kontrollstrukturen für :n-Beziehungen zu spezifizieren. Die bereits vorhandenen durften Sie ja schon in Abschnitt 4.6.4 kennenlernen; hier kommt hinzu, dass die Standarditeratoren je nach Art der Beziehung unterschiedliche Eigenschaften haben. Außerdem ist es natürlich möglich, mit eigenen Arten von Beziehungen auch spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren.","<answer> Ein Beispiel für eine spezielle Art von ""n-Beziehung"" ist eine mengenwertige Beziehung, bei der die Elemente jeweils nur einmal darin vorkommen dürfen. Eine weitere Art ist eine sortierte Beziehung, bei der die Elemente nach einem bestimmten Kriterium sortiert sind. <answer> <question> Was sind einige Beispiele für spezielle Arten von :n-Beziehungen? <question>"
"In Kapitel 2 von Kurseinheit 1 waren wir bereits auf :n-Beziehungen eingegangen, die logisch gleichberechtigt neben :1-Beziehungen stehen, die aber in der Umsetzung besonderer Mechanismen bedürfen. Als Basis der Umsetzung hatten Sie bereits Zwischenobjekte kennengelernt, die über ihre indizierten Instanzvariablen solche Beziehungen — wenn auch nur indirekt — herstellen können. Tatsächlich könnte man, wenn man sich der Häufigkeit des Vorkommens von :n-Beziehungen in der Programmierung bewusst ist, vermuten, dass indizierte Instanzvariablen speziell für diesen Zweck eingeführt wurden. Auf den ersten Blick bedauerlich ist nur, dass dafür eben diese Zwischenobjekte notwendig sind.
Es ergibt sich aus diesem Umstand aber auch ein entscheidender Vorteil. Da auch diese Zwischenobjekte Instanzen von Klassen sein müssen, ist es möglich, verschiedene Arten von :n-Beziehungen zu definieren und diese jeweils mit Verhalten zu versehen, das speziell auf die Art der Beziehung bezogen ist. So ist es beispielsweise möglich, :n-Beziehungen zu definieren, deren Elemente (die in Beziehung stehenden Objekte) jeweils nur einmal darin vorkommen dürfen (mengenwertige Beziehungen) oder nach einem bestimmten Kriterium sortiert sind. Auch können Operationen wie das Hinzufügen oder Entfernen von Objekten zu einer Beziehung, die bei :1-Beziehungen über die Zuweisung zu einer Instanzvariable erfolgen (das Entfernen durch Zuweisung von nil), beliebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu erhalten.
Besonders attraktiv ist jedoch die in SMALLTALK bestehende Möglichkeit, eigene Kontrollstrukturen für :n-Beziehungen zu spezifizieren. Die bereits vorhandenen durften Sie ja schon in Abschnitt 4.6.4 kennenlernen; hier kommt hinzu, dass die Standarditeratoren je nach Art der Beziehung unterschiedliche Eigenschaften haben. Außerdem ist es natürlich möglich, mit eigenen Arten von Beziehungen auch spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren.","<answer> Es ist besonders attraktiv, eigene Kontrollstrukturen für :n-Beziehungen in SMALLTALK zu spezifizieren, weil es die Möglichkeit bietet, maßgeschneiderte und auf die spezifische Art der Beziehung zugeschnittene Kontrollstrukturen zu erstellen. Dies ermöglicht eine flexible und effiziente Programmierung für unterschiedliche Arten von Beziehungen. <answer> <question> Warum ist es besonders attraktiv, eigene Kontrollstrukturen für :n-Beziehungen in SMALLTALK zu spezifizieren? <question>"
"In Kapitel 2 von Kurseinheit 1 waren wir bereits auf :n-Beziehungen eingegangen, die logisch gleichberechtigt neben :1-Beziehungen stehen, die aber in der Umsetzung besonderer Mechanismen bedürfen. Als Basis der Umsetzung hatten Sie bereits Zwischenobjekte kennengelernt, die über ihre indizierten Instanzvariablen solche Beziehungen — wenn auch nur indirekt — herstellen können. Tatsächlich könnte man, wenn man sich der Häufigkeit des Vorkommens von :n-Beziehungen in der Programmierung bewusst ist, vermuten, dass indizierte Instanzvariablen speziell für diesen Zweck eingeführt wurden. Auf den ersten Blick bedauerlich ist nur, dass dafür eben diese Zwischenobjekte notwendig sind.
Es ergibt sich aus diesem Umstand aber auch ein entscheidender Vorteil. Da auch diese Zwischenobjekte Instanzen von Klassen sein müssen, ist es möglich, verschiedene Arten von :n-Beziehungen zu definieren und diese jeweils mit Verhalten zu versehen, das speziell auf die Art der Beziehung bezogen ist. So ist es beispielsweise möglich, :n-Beziehungen zu definieren, deren Elemente (die in Beziehung stehenden Objekte) jeweils nur einmal darin vorkommen dürfen (mengenwertige Beziehungen) oder nach einem bestimmten Kriterium sortiert sind. Auch können Operationen wie das Hinzufügen oder Entfernen von Objekten zu einer Beziehung, die bei :1-Beziehungen über die Zuweisung zu einer Instanzvariable erfolgen (das Entfernen durch Zuweisung von nil), beliebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu erhalten.
Besonders attraktiv ist jedoch die in SMALLTALK bestehende Möglichkeit, eigene Kontrollstrukturen für :n-Beziehungen zu spezifizieren. Die bereits vorhandenen durften Sie ja schon in Abschnitt 4.6.4 kennenlernen; hier kommt hinzu, dass die Standarditeratoren je nach Art der Beziehung unterschiedliche Eigenschaften haben. Außerdem ist es natürlich möglich, mit eigenen Arten von Beziehungen auch spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren.","<answer> Standarditeratoren spielen eine Rolle in Bezug auf :n-Beziehungen, und je nach Art der Beziehung haben sie unterschiedliche Eigenschaften. Diese Standarditeratoren wurden bereits in Abschnitt 4.6.4 vorgestellt. <answer> <question> Welche Rolle spielen Standarditeratoren in Bezug auf :n-Beziehungen? <question>"
"In Kapitel 2 von Kurseinheit 1 waren wir bereits auf :n-Beziehungen eingegangen, die logisch gleichberechtigt neben :1-Beziehungen stehen, die aber in der Umsetzung besonderer Mechanismen bedürfen. Als Basis der Umsetzung hatten Sie bereits Zwischenobjekte kennengelernt, die über ihre indizierten Instanzvariablen solche Beziehungen — wenn auch nur indirekt — herstellen können. Tatsächlich könnte man, wenn man sich der Häufigkeit des Vorkommens von :n-Beziehungen in der Programmierung bewusst ist, vermuten, dass indizierte Instanzvariablen speziell für diesen Zweck eingeführt wurden. Auf den ersten Blick bedauerlich ist nur, dass dafür eben diese Zwischenobjekte notwendig sind.
Es ergibt sich aus diesem Umstand aber auch ein entscheidender Vorteil. Da auch diese Zwischenobjekte Instanzen von Klassen sein müssen, ist es möglich, verschiedene Arten von :n-Beziehungen zu definieren und diese jeweils mit Verhalten zu versehen, das speziell auf die Art der Beziehung bezogen ist. So ist es beispielsweise möglich, :n-Beziehungen zu definieren, deren Elemente (die in Beziehung stehenden Objekte) jeweils nur einmal darin vorkommen dürfen (mengenwertige Beziehungen) oder nach einem bestimmten Kriterium sortiert sind. Auch können Operationen wie das Hinzufügen oder Entfernen von Objekten zu einer Beziehung, die bei :1-Beziehungen über die Zuweisung zu einer Instanzvariable erfolgen (das Entfernen durch Zuweisung von nil), beliebig ausgestaltet werden, um beispielsweise die Mengenwertigkeit oder die Sortierung zu erhalten.
Besonders attraktiv ist jedoch die in SMALLTALK bestehende Möglichkeit, eigene Kontrollstrukturen für :n-Beziehungen zu spezifizieren. Die bereits vorhandenen durften Sie ja schon in Abschnitt 4.6.4 kennenlernen; hier kommt hinzu, dass die Standarditeratoren je nach Art der Beziehung unterschiedliche Eigenschaften haben. Außerdem ist es natürlich möglich, mit eigenen Arten von Beziehungen auch spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren.","<answer> Die Verwendung eigener Arten von Beziehungen in SMALLTALK ermöglicht es, spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren, um die Programmierung für diese Beziehungen effizienter zu gestalten. <answer> <question> Was ermöglicht die Verwendung eigener Arten von Beziehungen in SMALLTALK? <question>"
"Ein Großteil des Erfolgs der objektorientierten Programmierung hängt von der Verfügbarkeit und der systematischen Verwendung von Bibliotheken ab. In SMALLTALK ist das selbstverständlich, da hier Sprache und Bibliothek praktisch nicht zu trennen sind. Aber auch in JAVA ist ein Teil der Sprachdefinition in bestimmte, spezielle Klassen wie ""Object"", ""Thread"" und ""Throwable"" verlagert (vgl. Kapitel 47). Auch kommt praktisch kein JAVA-Programm ohne die Verwendung bestimmter Bibliotheksklassen aus – man denke nur an die allgegenwärtige Verwendung des Collection-Frameworks, ohne das Programmierer zur ständigen Abfassung ewig gleichen Codes verdammt wären.
Zum objektorientierten Programmierstil gehört es, eine Lösung eines konkreten Problems möglichst umfassend aus existierenden, idealerweise verbreiteten und bewährten Bibliotheken zusammenzustellen. Jede nicht selbst geschriebene Programmzeile ist ein Gewinn, jede Implementierung einer noch so kleinen Funktion, die es bereits in irgendeiner Bibliothek gibt, ist ein Verlust. Dabei sind die Vorteile der Verwendung von Bibliotheken mannigfaltig: In der Regel können Sie davon ausgehen, dass die Implementierungen korrekt sind (und Probleme sowie Sonderfälle berücksichtigen, an die Sie im Traum nicht gedacht hätten), die Wartung und Anpassung übernehmen andere für Sie, und nicht zuletzt dürfen Sie bei weit verbreiteten Bibliotheken voraussetzen, dass deren Funktionalität auch anderen Programmierern bekannt ist, sodass die Verwendung einer Bibliotheksklasse keiner weiteren Erklärung bedarf. Ihr eigener Beitrag wird dadurch klein und überschaubar, was man Ihnen in keinem Fall als Faulheit oder Arbeitsverweigerung auslegen sollte, sondern als wahre Größe: Sie kennen das Werk anderer, Sie wissen es zu schätzen und zu nutzen.",<answer> Bibliotheken spielen eine entscheidende Rolle in der objektorientierten Programmierung. Sie sind ein wesentlicher Bestandteil des objektorientierten Programmierstils und tragen maßgeblich zum Erfolg dieses Ansatzes bei. <answer> <question> Welche Rolle spielen Bibliotheken in der objektorientierten Programmierung? <question>
"Ein Großteil des Erfolgs der objektorientierten Programmierung hängt von der Verfügbarkeit und der systematischen Verwendung von Bibliotheken ab. In SMALLTALK ist das selbstverständlich, da hier Sprache und Bibliothek praktisch nicht zu trennen sind. Aber auch in JAVA ist ein Teil der Sprachdefinition in bestimmte, spezielle Klassen wie ""Object"", ""Thread"" und ""Throwable"" verlagert (vgl. Kapitel 47). Auch kommt praktisch kein JAVA-Programm ohne die Verwendung bestimmter Bibliotheksklassen aus – man denke nur an die allgegenwärtige Verwendung des Collection-Frameworks, ohne das Programmierer zur ständigen Abfassung ewig gleichen Codes verdammt wären.
Zum objektorientierten Programmierstil gehört es, eine Lösung eines konkreten Problems möglichst umfassend aus existierenden, idealerweise verbreiteten und bewährten Bibliotheken zusammenzustellen. Jede nicht selbst geschriebene Programmzeile ist ein Gewinn, jede Implementierung einer noch so kleinen Funktion, die es bereits in irgendeiner Bibliothek gibt, ist ein Verlust. Dabei sind die Vorteile der Verwendung von Bibliotheken mannigfaltig: In der Regel können Sie davon ausgehen, dass die Implementierungen korrekt sind (und Probleme sowie Sonderfälle berücksichtigen, an die Sie im Traum nicht gedacht hätten), die Wartung und Anpassung übernehmen andere für Sie, und nicht zuletzt dürfen Sie bei weit verbreiteten Bibliotheken voraussetzen, dass deren Funktionalität auch anderen Programmierern bekannt ist, sodass die Verwendung einer Bibliotheksklasse keiner weiteren Erklärung bedarf. Ihr eigener Beitrag wird dadurch klein und überschaubar, was man Ihnen in keinem Fall als Faulheit oder Arbeitsverweigerung auslegen sollte, sondern als wahre Größe: Sie kennen das Werk anderer, Sie wissen es zu schätzen und zu nutzen.","<answer> Die Verwendung von Bibliotheken in der objektorientierten Programmierung bietet mehrere Vorteile: Sie ermöglicht es, Lösungen für Probleme aus vorhandenen, bewährten und weit verbreiteten Bibliotheken zusammenzustellen, was Zeit und Aufwand spart. Bibliotheken enthalten in der Regel korrekte Implementierungen von Funktionen und berücksichtigen Probleme sowie Sonderfälle, die ein einzelner Entwickler möglicherweise übersehen würde. Die Wartung und Anpassung von Bibliotheken wird oft von anderen Entwicklern übernommen, was die Entwickler entlastet. Die Verwendung weit verbreiteter Bibliotheken erleichtert die Kommunikation und Zusammenarbeit mit anderen Entwicklern, da diese bereits mit den Bibliotheken vertraut sind. <answer> <question> Warum ist die Verwendung von Bibliotheken in der objektorientierten Programmierung wichtig? <question>"
"Ein Großteil des Erfolgs der objektorientierten Programmierung hängt von der Verfügbarkeit und der systematischen Verwendung von Bibliotheken ab. In SMALLTALK ist das selbstverständlich, da hier Sprache und Bibliothek praktisch nicht zu trennen sind. Aber auch in JAVA ist ein Teil der Sprachdefinition in bestimmte, spezielle Klassen wie ""Object"", ""Thread"" und ""Throwable"" verlagert (vgl. Kapitel 47). Auch kommt praktisch kein JAVA-Programm ohne die Verwendung bestimmter Bibliotheksklassen aus – man denke nur an die allgegenwärtige Verwendung des Collection-Frameworks, ohne das Programmierer zur ständigen Abfassung ewig gleichen Codes verdammt wären.
Zum objektorientierten Programmierstil gehört es, eine Lösung eines konkreten Problems möglichst umfassend aus existierenden, idealerweise verbreiteten und bewährten Bibliotheken zusammenzustellen. Jede nicht selbst geschriebene Programmzeile ist ein Gewinn, jede Implementierung einer noch so kleinen Funktion, die es bereits in irgendeiner Bibliothek gibt, ist ein Verlust. Dabei sind die Vorteile der Verwendung von Bibliotheken mannigfaltig: In der Regel können Sie davon ausgehen, dass die Implementierungen korrekt sind (und Probleme sowie Sonderfälle berücksichtigen, an die Sie im Traum nicht gedacht hätten), die Wartung und Anpassung übernehmen andere für Sie, und nicht zuletzt dürfen Sie bei weit verbreiteten Bibliotheken voraussetzen, dass deren Funktionalität auch anderen Programmierern bekannt ist, sodass die Verwendung einer Bibliotheksklasse keiner weiteren Erklärung bedarf. Ihr eigener Beitrag wird dadurch klein und überschaubar, was man Ihnen in keinem Fall als Faulheit oder Arbeitsverweigerung auslegen sollte, sondern als wahre Größe: Sie kennen das Werk anderer, Sie wissen es zu schätzen und zu nutzen.","<answer> Entwickler sollten Bibliotheken in der objektorientierten Programmierung nutzen, um Zeit zu sparen, Fehler zu vermeiden, auf bewährte Lösungen zuzugreifen und den Entwicklungsprozess effizienter zu gestalten. Die Verwendung von Bibliotheken ermöglicht es Entwicklern, sich auf die spezifischen Anforderungen ihres Projekts zu konzentrieren, anstatt grundlegende Funktionen und Implementierungen selbst zu schreiben. Dies trägt zur Produktivität und Qualität der Software bei. <answer> <question> Warum sollten Entwickler in der objektorientierten Programmierung Bibliotheken nutzen? <question>"
"Neben vielen anderen Neuerungen wird SMALLTALK auch das Model-View-Controller-Entwurfsmuster (MVC-Pattern) zugeschrieben, das sich heute noch (auch in Web-Anwendungen) großer Beliebtheit erfreut. Beim MVC-Pattern gibt es verschiedene (An-)Sichten auf ein logisches Modell, und da Änderungen im Modell potenziell alle Sichten betreffen, muss jede Änderung alle Sichten darüber unterrichten. Es ist also eine Eins-zu-viele-Kommunikation erforderlich, die nicht durch den normalen Nachrichtenversand abgedeckt wird.
Das folgende Protokoll setzt diese Form der Kommunikation in SMALLTALK um; es ist vollständig in SMALLTALK implementiert und sollte Ihnen inzwischen kein Problem mehr bereiten. Beachten Sie, dass Object keine Lazy Initialization seiner Klassenvariable Dependents vorsieht; die Methode initDependents muss daher bei Erzeugung einer neuen Klasse jeweils einmal aufgerufen werden.","<answer> SMALLTALK wird das Model-View-Controller-Entwurfsmuster (MVC-Pattern) zugeschrieben. Es ist wichtig, da es sich auch heute noch großer Beliebtheit erfreut und in vielen Anwendungen, einschließlich Web-Anwendungen, verwendet wird. Das MVC-Pattern ermöglicht verschiedene Ansichten auf ein logisches Modell, und Änderungen im Modell müssen alle Ansichten darüber informieren. Daher erfordert es eine Eins-zu-viele-Kommunikation, die nicht durch den normalen Nachrichtenversand abgedeckt wird. <answer> <question> Welches Entwurfsmuster wird SMALLTALK zugeschrieben und warum ist es wichtig? <question>"
"Neben vielen anderen Neuerungen wird SMALLTALK auch das Model-View-Controller-Entwurfsmuster (MVC-Pattern) zugeschrieben, das sich heute noch (auch in Web-Anwendungen) großer Beliebtheit erfreut. Beim MVC-Pattern gibt es verschiedene (An-)Sichten auf ein logisches Modell, und da Änderungen im Modell potenziell alle Sichten betreffen, muss jede Änderung alle Sichten darüber unterrichten. Es ist also eine Eins-zu-viele-Kommunikation erforderlich, die nicht durch den normalen Nachrichtenversand abgedeckt wird.
Das folgende Protokoll setzt diese Form der Kommunikation in SMALLTALK um; es ist vollständig in SMALLTALK implementiert und sollte Ihnen inzwischen kein Problem mehr bereiten. Beachten Sie, dass Object keine Lazy Initialization seiner Klassenvariable Dependents vorsieht; die Methode initDependents muss daher bei Erzeugung einer neuen Klasse jeweils einmal aufgerufen werden.","<answer> Im MVC-Pattern gibt es verschiedene Ansichten auf ein logisches Modell. Wenn Änderungen im Modell potenziell alle Ansichten betreffen, müssen diese Änderungen alle Ansichten darüber informieren. Daher ist eine Eins-zu-viele-Kommunikation erforderlich, um sicherzustellen, dass alle betroffenen Ansichten aktualisiert werden. <answer> <question> Warum ist eine Eins-zu-viele-Kommunikation im MVC-Pattern erforderlich? <question>"
"Neben vielen anderen Neuerungen wird SMALLTALK auch das Model-View-Controller-Entwurfsmuster (MVC-Pattern) zugeschrieben, das sich heute noch (auch in Web-Anwendungen) großer Beliebtheit erfreut. Beim MVC-Pattern gibt es verschiedene (An-)Sichten auf ein logisches Modell, und da Änderungen im Modell potenziell alle Sichten betreffen, muss jede Änderung alle Sichten darüber unterrichten. Es ist also eine Eins-zu-viele-Kommunikation erforderlich, die nicht durch den normalen Nachrichtenversand abgedeckt wird.
Das folgende Protokoll setzt diese Form der Kommunikation in SMALLTALK um; es ist vollständig in SMALLTALK implementiert und sollte Ihnen inzwischen kein Problem mehr bereiten. Beachten Sie, dass Object keine Lazy Initialization seiner Klassenvariable Dependents vorsieht; die Methode initDependents muss daher bei Erzeugung einer neuen Klasse jeweils einmal aufgerufen werden.","<answer> Die Eins-zu-viele-Kommunikation in SMALLTALK wird durch das in SMALLTALK implementierte Protokoll umgesetzt. Dieses Protokoll ermöglicht die Kommunikation zwischen verschiedenen Teilen einer Anwendung, insbesondere im Kontext des MVC-Patterns. <answer> <question> Wie wird die Eins-zu-viele-Kommunikation in SMALLTALK umgesetzt? <question>"
"Wie bereits in Abschnitt 4.3.2 erläutert, verbirgt sich hinter dem Nachrichtenversand in SMALLTALK der Methodenaufruf. Wann immer ein Objekt eine Nachricht an ein Empfängerobjekt verschickt, wechselt der Kontrollfluss damit zum Empfängerobjekt, genauer gesagt zur Methode des Empfängerobjekts, die zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung der Methode kehrt der Kontrollfluss an das sendende Objekt (genauer: zur Methode, aus der die Nachricht versandt wurde) zurück und setzt seine Arbeit dort fort. Bei der Rückkehr wird auch das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Der genaue Mechanismus des dynamischen Bindens in SMALLTALK wird in Kapitel 12 von Kurseinheit 2 untersucht.","<answer> Hinter dem Nachrichtenversand in SMALLTALK verbirgt sich der Methodenaufruf. Wenn ein Objekt eine Nachricht an ein Empfängerobjekt sendet, wird der Kontrollfluss zur Methode des Empfängerobjekts verschoben, die zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung dieser Methode kehrt der Kontrollfluss an das sendende Objekt zurück und setzt seine Arbeit dort fort. <answer> <question> Was verbirgt sich hinter dem Nachrichtenversand in SMALLTALK? <question>"
"Wie bereits in Abschnitt 4.3.2 erläutert, verbirgt sich hinter dem Nachrichtenversand in SMALLTALK der Methodenaufruf. Wann immer ein Objekt eine Nachricht an ein Empfängerobjekt verschickt, wechselt der Kontrollfluss damit zum Empfängerobjekt, genauer gesagt zur Methode des Empfängerobjekts, die zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung der Methode kehrt der Kontrollfluss an das sendende Objekt (genauer: zur Methode, aus der die Nachricht versandt wurde) zurück und setzt seine Arbeit dort fort. Bei der Rückkehr wird auch das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Der genaue Mechanismus des dynamischen Bindens in SMALLTALK wird in Kapitel 12 von Kurseinheit 2 untersucht.","<answer> Bei der Rückkehr nach der Abarbeitung einer Methode in SMALLTALK wird das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Dies ermöglicht die Weiterverarbeitung des Ergebnisses im Kontext des aufrufenden Objekts. <answer> <question> Was passiert bei der Rückkehr nach der Abarbeitung einer Methode in SMALLTALK? <question>"
"Um strukturelle Typäquivalenz festzustellen, werden die Definitionen der beteiligten Typen rekursiv expandiert, was so viel heißt wie, dass in einer Typdefinition vorkommende Namen anderer Typen durch ihre Struktur ersetzt werden.
Dann sind die Typen Person und Firma sowie Wohnung und Büro jeweils strukturäquivalent, aber nicht namensäquivalent. Bei der Strukturäquivalenz haben Namen also lediglich die Funktion der abkürzenden Schreibweise, bei der Namensäquivalenz hingegen auch eine von der Struktur unabhängige Bedeutung. Namensäquivalenz impliziert Strukturäquivalenz, aber nicht umgekehrt; Namensäquivalenz ist somit das stärkere Konzept.
Strukturäquivalenz als Bedingung der Zuweisungskompatibilität reicht aus, um Typfehler, also logische und Laufzeitfehler, die auf der Annahme einer nicht vorliegenden Eigenschaft (Methode) bei einem Wert einer Variable basieren, zu verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.
Strukturäquivalenz ist eine rein syntaktische Bedingung. Insbesondere können bei geforderter Strukturäquivalenz Typen zufällig zuweisungskompatibel sein, die inhaltlich überhaupt nichts miteinander zu tun haben. Dadurch können Objekte, die eigentlich getrennten Typen (disjunkten Wertebereichen) angehören, über Kreuz und über die Typgrenzen hinweg zugewiesen werden. Semantische Fehler sind also immer noch möglich. Man trifft daher in Sprachen mit Strukturäquivalenz gelegentlich die Praxis an, jedem Typ eine für ihn charakteristische Methode exklusiv zuzuordnen, so dass er mit keinem anderen mehr strukturäquivalent ist. Diese Technik nennt man Type branding.","<answer> Bei der Feststellung von Strukturäquivalenz werden die Definitionen der beteiligten Typen rekursiv expandiert, wobei Namen anderer Typen durch ihre Struktur ersetzt werden. Diese Strukturäquivalenz ermöglicht es, Typen zu vergleichen, indem ihre Strukturen miteinander verglichen werden. <answer> <question> Wie wird die Strukturäquivalenz bei der Feststellung von Typäquivalenz verwendet? <question>"
"Um strukturelle Typäquivalenz festzustellen, werden die Definitionen der beteiligten Typen rekursiv expandiert, was so viel heißt wie, dass in einer Typdefinition vorkommende Namen anderer Typen durch ihre Struktur ersetzt werden.
Dann sind die Typen Person und Firma sowie Wohnung und Büro jeweils strukturäquivalent, aber nicht namensäquivalent. Bei der Strukturäquivalenz haben Namen also lediglich die Funktion der abkürzenden Schreibweise, bei der Namensäquivalenz hingegen auch eine von der Struktur unabhängige Bedeutung. Namensäquivalenz impliziert Strukturäquivalenz, aber nicht umgekehrt; Namensäquivalenz ist somit das stärkere Konzept.
Strukturäquivalenz als Bedingung der Zuweisungskompatibilität reicht aus, um Typfehler, also logische und Laufzeitfehler, die auf der Annahme einer nicht vorliegenden Eigenschaft (Methode) bei einem Wert einer Variable basieren, zu verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.
Strukturäquivalenz ist eine rein syntaktische Bedingung. Insbesondere können bei geforderter Strukturäquivalenz Typen zufällig zuweisungskompatibel sein, die inhaltlich überhaupt nichts miteinander zu tun haben. Dadurch können Objekte, die eigentlich getrennten Typen (disjunkten Wertebereichen) angehören, über Kreuz und über die Typgrenzen hinweg zugewiesen werden. Semantische Fehler sind also immer noch möglich. Man trifft daher in Sprachen mit Strukturäquivalenz gelegentlich die Praxis an, jedem Typ eine für ihn charakteristische Methode exklusiv zuzuordnen, so dass er mit keinem anderen mehr strukturäquivalent ist. Diese Technik nennt man Type branding.","<answer> Bei der Namensäquivalenz spielen die Namen der Typen eine eigenständige Rolle und haben unabhängig von ihrer Struktur Bedeutung. Bei der Strukturäquivalenz dienen Namen lediglich als abkürzende Schreibweise für die Typstrukturen. Namensäquivalenz impliziert Strukturäquivalenz, aber nicht umgekehrt. <answer> <question> Was ist der Unterschied zwischen Namensäquivalenz und Strukturäquivalenz? <question>"
"Um strukturelle Typäquivalenz festzustellen, werden die Definitionen der beteiligten Typen rekursiv expandiert, was so viel heißt wie, dass in einer Typdefinition vorkommende Namen anderer Typen durch ihre Struktur ersetzt werden.
Dann sind die Typen Person und Firma sowie Wohnung und Büro jeweils strukturäquivalent, aber nicht namensäquivalent. Bei der Strukturäquivalenz haben Namen also lediglich die Funktion der abkürzenden Schreibweise, bei der Namensäquivalenz hingegen auch eine von der Struktur unabhängige Bedeutung. Namensäquivalenz impliziert Strukturäquivalenz, aber nicht umgekehrt; Namensäquivalenz ist somit das stärkere Konzept.
Strukturäquivalenz als Bedingung der Zuweisungskompatibilität reicht aus, um Typfehler, also logische und Laufzeitfehler, die auf der Annahme einer nicht vorliegenden Eigenschaft (Methode) bei einem Wert einer Variable basieren, zu verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.
Strukturäquivalenz ist eine rein syntaktische Bedingung. Insbesondere können bei geforderter Strukturäquivalenz Typen zufällig zuweisungskompatibel sein, die inhaltlich überhaupt nichts miteinander zu tun haben. Dadurch können Objekte, die eigentlich getrennten Typen (disjunkten Wertebereichen) angehören, über Kreuz und über die Typgrenzen hinweg zugewiesen werden. Semantische Fehler sind also immer noch möglich. Man trifft daher in Sprachen mit Strukturäquivalenz gelegentlich die Praxis an, jedem Typ eine für ihn charakteristische Methode exklusiv zuzuordnen, so dass er mit keinem anderen mehr strukturäquivalent ist. Diese Technik nennt man Type branding.","<answer> Strukturäquivalenz reicht als Bedingung für Zuweisungskompatibilität aus, um Typfehler zu verhindern, die auf der Annahme einer nicht vorhandenen Methode bei einem Wert einer Variable basieren. Sie gewährleistet, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können. <answer> <question> Warum reicht Strukturäquivalenz als Bedingung für Zuweisungskompatibilität aus? <question>"
"Um strukturelle Typäquivalenz festzustellen, werden die Definitionen der beteiligten Typen rekursiv expandiert, was so viel heißt wie, dass in einer Typdefinition vorkommende Namen anderer Typen durch ihre Struktur ersetzt werden.
Dann sind die Typen Person und Firma sowie Wohnung und Büro jeweils strukturäquivalent, aber nicht namensäquivalent. Bei der Strukturäquivalenz haben Namen also lediglich die Funktion der abkürzenden Schreibweise, bei der Namensäquivalenz hingegen auch eine von der Struktur unabhängige Bedeutung. Namensäquivalenz impliziert Strukturäquivalenz, aber nicht umgekehrt; Namensäquivalenz ist somit das stärkere Konzept.
Strukturäquivalenz als Bedingung der Zuweisungskompatibilität reicht aus, um Typfehler, also logische und Laufzeitfehler, die auf der Annahme einer nicht vorliegenden Eigenschaft (Methode) bei einem Wert einer Variable basieren, zu verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.
Strukturäquivalenz ist eine rein syntaktische Bedingung. Insbesondere können bei geforderter Strukturäquivalenz Typen zufällig zuweisungskompatibel sein, die inhaltlich überhaupt nichts miteinander zu tun haben. Dadurch können Objekte, die eigentlich getrennten Typen (disjunkten Wertebereichen) angehören, über Kreuz und über die Typgrenzen hinweg zugewiesen werden. Semantische Fehler sind also immer noch möglich. Man trifft daher in Sprachen mit Strukturäquivalenz gelegentlich die Praxis an, jedem Typ eine für ihn charakteristische Methode exklusiv zuzuordnen, so dass er mit keinem anderen mehr strukturäquivalent ist. Diese Technik nennt man Type branding.","<answer> Bei Verwendung der Strukturäquivalenz können Typen, die inhaltlich nichts miteinander zu tun haben, fälschlicherweise als äquivalent betrachtet werden. Dies kann dazu führen, dass Objekte, die eigentlich unterschiedlichen Typen angehören, fälschlicherweise zugewiesen werden können, was zu semantischen Fehlern führen kann. Dieses Problem kann durch die Technik des ""Type Branding"" gelöst werden, bei der jedem Typ eine charakteristische Methode exklusiv zugeordnet wird, um die Strukturäquivalenz einzuschränken. <answer> <question> Was sind mögliche Nachteile der Strukturäquivalenz? <question>"
"Die Auswertung von Nachrichtenausdrücken, also von Nachrichten, die an Objekte verschickt werden, erfolgt mithilfe sogenannter Methoden. Eine Methode beschreibt, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf, der in SMALLTALK auch als ""Message pattern"" bezeichnet wird, aber allgemein und im Folgenden eher als Methodensignatur bezeichnet wird. Es enthält eine optionale Liste von lokalen Variablen und einen Methodenrumpf. Der Methodenrumpf enthält die Anweisungen, die die Methode ausmachen und die zur Auswertung eines Nachrichtenausdrucks ausgeführt werden. Es ist üblich, jede Methode mit einem Kommentar in doppelten Anführungsstrichen zu versehen, der beschreibt, was diese Methode tut.
Die Methodensignatur besteht aus dem Namen der Methode und der Liste ihrer formalen Parameter. Formale Parameter sind lokale Variablen, denen beim Aufruf der Methode (siehe Abschnitt 4.3.2) automatisch ein Wert, der als sogenannter tatsächlicher Parameter bezeichnet wird, zugewiesen wird. Die Sichtbarkeit der formalen Parameter ist auf die Methode beschränkt, in deren Methodensignatur sie vorkommen. Wie alle lokalen Variablen müssen sie mit einem Kleinbuchstaben beginnen und sind temporäre Variablen. Das bedeutet, dass sie nur für die Dauer der Ausführung der Methode existieren. Alle durch formale Parameter gebildeten Aliase sind ebenfalls temporär. In SMALLTALK sind formale Parameter zudem Pseudovariablen (siehe Abschnitt 1.7), d.h., es kann ihnen innerhalb der Methode, für die sie sichtbar sind, nichts zugewiesen werden. Syntaktisch unterscheidet sich SMALLTALK von den meisten anderen Programmiersprachen auch in der Methodendefinition dadurch, dass die formalen Parameter nicht durch Kommata getrennt in einer in Klammern eingeschlossenen Liste hinter dem Methodennamen stehen, sondern jeder Parameter wird einzeln von einem Nachrichtenbestandteil eingeleitet.
Eine Methodendefinition folgt also dem Schema (in spitzen Klammern stehen metasyntaktische Variablen als Platzhalter für entsprechende Programmelemente).
Die Methodensignatur dient der Auswahl der zu einer Nachricht passenden Methode. Sie ist das Gegenstück zum Nachrichtenselektor aus Abschnitt 4.1.2, anhand dessen die Auswahl der zu einem Nachrichtenausdruck passenden Methode durchgeführt wird. Anders als ein Nachrichtenausdruck nennt eine Methodensignatur jedoch kein Empfängerobjekt, und die offenen Stellen eines Nachrichtenselektors werden ausschließlich durch Variablen, nämlich die formalen Parameter, und nicht durch beliebige Ausdrücke besetzt. Typische Methodensignaturen sind z.B.: Für Methoden ohne Parameter: methodName, für binäre Methoden (mit einem formalen Parameter namens anInteger): methodName: anInteger, für alle anderen Methoden mit einem oder mehreren Parametern (in diesem Fall mit nur einem formalen Parameter namens aStream): methodName: anArgument.
Die Methodenrümpfe bestehen aus einer Folge von Anweisungen, die jeweils durch einen Punkt getrennt sind. Wenn die Anweisungen nichts anderes vorsehen, wird die Ausführung einer Methode nach Abarbeitung der letzten Anweisung explizit mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung (siehe Abschnitt 4.2) vorgesehen. Eine Return-Anweisung darf an beliebigen Stellen innerhalb der Methode auftreten, wodurch die Abarbeitung der Methode vor Erreichen der textuell letzten Anweisung beendet werden kann. Die Return-Anweisung beeinflusst somit den Kontrollfluss des Programms. Wichtig ist, dass eine Methode immer ein Objekt zurückgibt. Ein Nachrichtenausdruck (oder Methodenaufruf) steht immer für ein Objekt. Prozeduren im Sinne von PASCAL oder Void-Methoden im Sinne von C, JAVA usw. gibt es in SMALLTALK nicht (vgl. auch Abschnitt 4.1.3).
Sollte eine Methode temporäre Variablen für ihre Berechnungen benötigen, müssen diese zu Beginn der Methode (nach der Methodensignatur und vor der ersten Anweisung) deklariert werden. Die Werte dieser Variablen werden standardmäßig mit nil initialisiert und sind außerhalb der Methode nicht sichtbar. Die Variablen werden nach Abarbeitung der Methode vom System wieder entfernt, und sie können sich daher zwischen zwei Ausführungen einer Methode nichts merken.
Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben. Umgekehrt können temporäre Variablen, die nur einmal verwendet werden, eingespart werden, indem man kaskadierte Nachrichtenausdrücke verwendet.
Rückkehr von Methoden sind die Einheiten des Programms, in denen Sie als Programmiererin Ihre Anweisungen unterbringen. Sie werden nach der Eingabe (und bei jeder Änderung) mit dem ""Speichern"" kompiliert. Beachten Sie dabei, dass Methoden nicht in Dateien gespeichert werden, sondern in einer Datenstruktur von SMALLTALK, und zwar in Form von Objekten. Tatsächlich besteht der Großteil eines jeden SMALLTALK-Programms, ja des gesamten SMALLTALK-Systems, aus Methodendefinitionen. Die Methodendefinitionen entsprechen im Wesentlichen der Definition von Funktionen (oder, mit obiger Einschränkung, Prozeduren) in anderen Sprachen. In SMALLTALK ist es jedoch nicht möglich (und in der objektorientierten Programmierung allgemein nicht üblich), Methoden zu verschachteln, d.h., eine Methode innerhalb einer anderen Methode zu deklarieren. Außerdem gibt es in SMALLTALK keine ""Hauptmethode"" wie beispielsweise die Main-Methoden in der C-Sprachfamilie. Sie müssen dem SMALLTALK-System explizit mitteilen, welche Methode Sie ausführen möchten, indem Sie einen entsprechenden Ausdruck eingeben und auswerten lassen.","<answer> In SMALLTALK ist eine Methode ein Programmblock, der beschreibt, was ein Objekt in Reaktion auf den Erhalt einer bestimmten Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf (Methodensignatur), einer optionalen Liste von lokalen Variablen und einem Methodenrumpf, der die Anweisungen für die Ausführung der Methode enthält. <answer> <question> Was ist eine Methode in SMALLTALK? <question>"
"Die Auswertung von Nachrichtenausdrücken, also von Nachrichten, die an Objekte verschickt werden, erfolgt mithilfe sogenannter Methoden. Eine Methode beschreibt, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf, der in SMALLTALK auch als ""Message pattern"" bezeichnet wird, aber allgemein und im Folgenden eher als Methodensignatur bezeichnet wird. Es enthält eine optionale Liste von lokalen Variablen und einen Methodenrumpf. Der Methodenrumpf enthält die Anweisungen, die die Methode ausmachen und die zur Auswertung eines Nachrichtenausdrucks ausgeführt werden. Es ist üblich, jede Methode mit einem Kommentar in doppelten Anführungsstrichen zu versehen, der beschreibt, was diese Methode tut.
Die Methodensignatur besteht aus dem Namen der Methode und der Liste ihrer formalen Parameter. Formale Parameter sind lokale Variablen, denen beim Aufruf der Methode (siehe Abschnitt 4.3.2) automatisch ein Wert, der als sogenannter tatsächlicher Parameter bezeichnet wird, zugewiesen wird. Die Sichtbarkeit der formalen Parameter ist auf die Methode beschränkt, in deren Methodensignatur sie vorkommen. Wie alle lokalen Variablen müssen sie mit einem Kleinbuchstaben beginnen und sind temporäre Variablen. Das bedeutet, dass sie nur für die Dauer der Ausführung der Methode existieren. Alle durch formale Parameter gebildeten Aliase sind ebenfalls temporär. In SMALLTALK sind formale Parameter zudem Pseudovariablen (siehe Abschnitt 1.7), d.h., es kann ihnen innerhalb der Methode, für die sie sichtbar sind, nichts zugewiesen werden. Syntaktisch unterscheidet sich SMALLTALK von den meisten anderen Programmiersprachen auch in der Methodendefinition dadurch, dass die formalen Parameter nicht durch Kommata getrennt in einer in Klammern eingeschlossenen Liste hinter dem Methodennamen stehen, sondern jeder Parameter wird einzeln von einem Nachrichtenbestandteil eingeleitet.
Eine Methodendefinition folgt also dem Schema (in spitzen Klammern stehen metasyntaktische Variablen als Platzhalter für entsprechende Programmelemente).
Die Methodensignatur dient der Auswahl der zu einer Nachricht passenden Methode. Sie ist das Gegenstück zum Nachrichtenselektor aus Abschnitt 4.1.2, anhand dessen die Auswahl der zu einem Nachrichtenausdruck passenden Methode durchgeführt wird. Anders als ein Nachrichtenausdruck nennt eine Methodensignatur jedoch kein Empfängerobjekt, und die offenen Stellen eines Nachrichtenselektors werden ausschließlich durch Variablen, nämlich die formalen Parameter, und nicht durch beliebige Ausdrücke besetzt. Typische Methodensignaturen sind z.B.: Für Methoden ohne Parameter: methodName, für binäre Methoden (mit einem formalen Parameter namens anInteger): methodName: anInteger, für alle anderen Methoden mit einem oder mehreren Parametern (in diesem Fall mit nur einem formalen Parameter namens aStream): methodName: anArgument.
Die Methodenrümpfe bestehen aus einer Folge von Anweisungen, die jeweils durch einen Punkt getrennt sind. Wenn die Anweisungen nichts anderes vorsehen, wird die Ausführung einer Methode nach Abarbeitung der letzten Anweisung explizit mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung (siehe Abschnitt 4.2) vorgesehen. Eine Return-Anweisung darf an beliebigen Stellen innerhalb der Methode auftreten, wodurch die Abarbeitung der Methode vor Erreichen der textuell letzten Anweisung beendet werden kann. Die Return-Anweisung beeinflusst somit den Kontrollfluss des Programms. Wichtig ist, dass eine Methode immer ein Objekt zurückgibt. Ein Nachrichtenausdruck (oder Methodenaufruf) steht immer für ein Objekt. Prozeduren im Sinne von PASCAL oder Void-Methoden im Sinne von C, JAVA usw. gibt es in SMALLTALK nicht (vgl. auch Abschnitt 4.1.3).
Sollte eine Methode temporäre Variablen für ihre Berechnungen benötigen, müssen diese zu Beginn der Methode (nach der Methodensignatur und vor der ersten Anweisung) deklariert werden. Die Werte dieser Variablen werden standardmäßig mit nil initialisiert und sind außerhalb der Methode nicht sichtbar. Die Variablen werden nach Abarbeitung der Methode vom System wieder entfernt, und sie können sich daher zwischen zwei Ausführungen einer Methode nichts merken.
Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben. Umgekehrt können temporäre Variablen, die nur einmal verwendet werden, eingespart werden, indem man kaskadierte Nachrichtenausdrücke verwendet.
Rückkehr von Methoden sind die Einheiten des Programms, in denen Sie als Programmiererin Ihre Anweisungen unterbringen. Sie werden nach der Eingabe (und bei jeder Änderung) mit dem ""Speichern"" kompiliert. Beachten Sie dabei, dass Methoden nicht in Dateien gespeichert werden, sondern in einer Datenstruktur von SMALLTALK, und zwar in Form von Objekten. Tatsächlich besteht der Großteil eines jeden SMALLTALK-Programms, ja des gesamten SMALLTALK-Systems, aus Methodendefinitionen. Die Methodendefinitionen entsprechen im Wesentlichen der Definition von Funktionen (oder, mit obiger Einschränkung, Prozeduren) in anderen Sprachen. In SMALLTALK ist es jedoch nicht möglich (und in der objektorientierten Programmierung allgemein nicht üblich), Methoden zu verschachteln, d.h., eine Methode innerhalb einer anderen Methode zu deklarieren. Außerdem gibt es in SMALLTALK keine ""Hauptmethode"" wie beispielsweise die Main-Methoden in der C-Sprachfamilie. Sie müssen dem SMALLTALK-System explizit mitteilen, welche Methode Sie ausführen möchten, indem Sie einen entsprechenden Ausdruck eingeben und auswerten lassen.","<answer> Die Methodensignatur beschreibt, welche Parameter eine Methode erwartet und wie sie in SMALLTALK aufgerufen wird. Sie besteht aus dem Methodennamen und der Liste der formalen Parameter. Der Nachrichtenselektor hingegen ist Teil eines Nachrichtenausdrucks und gibt an, welche Nachricht an ein Objekt gesendet wird. Die Methodensignatur hilft bei der Auswahl der passenden Methode für eine bestimmte Nachricht. <answer> <question> Was ist der Unterschied zwischen einer Methodensignatur und einem Nachrichtenselektor? <question>"
"Die Auswertung von Nachrichtenausdrücken, also von Nachrichten, die an Objekte verschickt werden, erfolgt mithilfe sogenannter Methoden. Eine Methode beschreibt, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf, der in SMALLTALK auch als ""Message pattern"" bezeichnet wird, aber allgemein und im Folgenden eher als Methodensignatur bezeichnet wird. Es enthält eine optionale Liste von lokalen Variablen und einen Methodenrumpf. Der Methodenrumpf enthält die Anweisungen, die die Methode ausmachen und die zur Auswertung eines Nachrichtenausdrucks ausgeführt werden. Es ist üblich, jede Methode mit einem Kommentar in doppelten Anführungsstrichen zu versehen, der beschreibt, was diese Methode tut.
Die Methodensignatur besteht aus dem Namen der Methode und der Liste ihrer formalen Parameter. Formale Parameter sind lokale Variablen, denen beim Aufruf der Methode (siehe Abschnitt 4.3.2) automatisch ein Wert, der als sogenannter tatsächlicher Parameter bezeichnet wird, zugewiesen wird. Die Sichtbarkeit der formalen Parameter ist auf die Methode beschränkt, in deren Methodensignatur sie vorkommen. Wie alle lokalen Variablen müssen sie mit einem Kleinbuchstaben beginnen und sind temporäre Variablen. Das bedeutet, dass sie nur für die Dauer der Ausführung der Methode existieren. Alle durch formale Parameter gebildeten Aliase sind ebenfalls temporär. In SMALLTALK sind formale Parameter zudem Pseudovariablen (siehe Abschnitt 1.7), d.h., es kann ihnen innerhalb der Methode, für die sie sichtbar sind, nichts zugewiesen werden. Syntaktisch unterscheidet sich SMALLTALK von den meisten anderen Programmiersprachen auch in der Methodendefinition dadurch, dass die formalen Parameter nicht durch Kommata getrennt in einer in Klammern eingeschlossenen Liste hinter dem Methodennamen stehen, sondern jeder Parameter wird einzeln von einem Nachrichtenbestandteil eingeleitet.
Eine Methodendefinition folgt also dem Schema (in spitzen Klammern stehen metasyntaktische Variablen als Platzhalter für entsprechende Programmelemente).
Die Methodensignatur dient der Auswahl der zu einer Nachricht passenden Methode. Sie ist das Gegenstück zum Nachrichtenselektor aus Abschnitt 4.1.2, anhand dessen die Auswahl der zu einem Nachrichtenausdruck passenden Methode durchgeführt wird. Anders als ein Nachrichtenausdruck nennt eine Methodensignatur jedoch kein Empfängerobjekt, und die offenen Stellen eines Nachrichtenselektors werden ausschließlich durch Variablen, nämlich die formalen Parameter, und nicht durch beliebige Ausdrücke besetzt. Typische Methodensignaturen sind z.B.: Für Methoden ohne Parameter: methodName, für binäre Methoden (mit einem formalen Parameter namens anInteger): methodName: anInteger, für alle anderen Methoden mit einem oder mehreren Parametern (in diesem Fall mit nur einem formalen Parameter namens aStream): methodName: anArgument.
Die Methodenrümpfe bestehen aus einer Folge von Anweisungen, die jeweils durch einen Punkt getrennt sind. Wenn die Anweisungen nichts anderes vorsehen, wird die Ausführung einer Methode nach Abarbeitung der letzten Anweisung explizit mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung (siehe Abschnitt 4.2) vorgesehen. Eine Return-Anweisung darf an beliebigen Stellen innerhalb der Methode auftreten, wodurch die Abarbeitung der Methode vor Erreichen der textuell letzten Anweisung beendet werden kann. Die Return-Anweisung beeinflusst somit den Kontrollfluss des Programms. Wichtig ist, dass eine Methode immer ein Objekt zurückgibt. Ein Nachrichtenausdruck (oder Methodenaufruf) steht immer für ein Objekt. Prozeduren im Sinne von PASCAL oder Void-Methoden im Sinne von C, JAVA usw. gibt es in SMALLTALK nicht (vgl. auch Abschnitt 4.1.3).
Sollte eine Methode temporäre Variablen für ihre Berechnungen benötigen, müssen diese zu Beginn der Methode (nach der Methodensignatur und vor der ersten Anweisung) deklariert werden. Die Werte dieser Variablen werden standardmäßig mit nil initialisiert und sind außerhalb der Methode nicht sichtbar. Die Variablen werden nach Abarbeitung der Methode vom System wieder entfernt, und sie können sich daher zwischen zwei Ausführungen einer Methode nichts merken.
Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben. Umgekehrt können temporäre Variablen, die nur einmal verwendet werden, eingespart werden, indem man kaskadierte Nachrichtenausdrücke verwendet.
Rückkehr von Methoden sind die Einheiten des Programms, in denen Sie als Programmiererin Ihre Anweisungen unterbringen. Sie werden nach der Eingabe (und bei jeder Änderung) mit dem ""Speichern"" kompiliert. Beachten Sie dabei, dass Methoden nicht in Dateien gespeichert werden, sondern in einer Datenstruktur von SMALLTALK, und zwar in Form von Objekten. Tatsächlich besteht der Großteil eines jeden SMALLTALK-Programms, ja des gesamten SMALLTALK-Systems, aus Methodendefinitionen. Die Methodendefinitionen entsprechen im Wesentlichen der Definition von Funktionen (oder, mit obiger Einschränkung, Prozeduren) in anderen Sprachen. In SMALLTALK ist es jedoch nicht möglich (und in der objektorientierten Programmierung allgemein nicht üblich), Methoden zu verschachteln, d.h., eine Methode innerhalb einer anderen Methode zu deklarieren. Außerdem gibt es in SMALLTALK keine ""Hauptmethode"" wie beispielsweise die Main-Methoden in der C-Sprachfamilie. Sie müssen dem SMALLTALK-System explizit mitteilen, welche Methode Sie ausführen möchten, indem Sie einen entsprechenden Ausdruck eingeben und auswerten lassen.","<answer> Temporäre Variablen in einer Methode müssen zu Beginn der Methode deklariert werden, nach der Methodensignatur und vor der ersten Anweisung. Sie existieren nur für die Dauer der Ausführung der Methode und werden vom System nach Beendigung der Methode entfernt. Die Werte dieser Variablen werden standardmäßig mit ""nil"" initialisiert und sind außerhalb der Methode nicht sichtbar. <answer> <question> Wie werden temporäre Variablen in einer Methode deklariert und wie lange existieren sie? <question>"
"Die Auswertung von Nachrichtenausdrücken, also von Nachrichten, die an Objekte verschickt werden, erfolgt mithilfe sogenannter Methoden. Eine Methode beschreibt, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf, der in SMALLTALK auch als ""Message pattern"" bezeichnet wird, aber allgemein und im Folgenden eher als Methodensignatur bezeichnet wird. Es enthält eine optionale Liste von lokalen Variablen und einen Methodenrumpf. Der Methodenrumpf enthält die Anweisungen, die die Methode ausmachen und die zur Auswertung eines Nachrichtenausdrucks ausgeführt werden. Es ist üblich, jede Methode mit einem Kommentar in doppelten Anführungsstrichen zu versehen, der beschreibt, was diese Methode tut.
Die Methodensignatur besteht aus dem Namen der Methode und der Liste ihrer formalen Parameter. Formale Parameter sind lokale Variablen, denen beim Aufruf der Methode (siehe Abschnitt 4.3.2) automatisch ein Wert, der als sogenannter tatsächlicher Parameter bezeichnet wird, zugewiesen wird. Die Sichtbarkeit der formalen Parameter ist auf die Methode beschränkt, in deren Methodensignatur sie vorkommen. Wie alle lokalen Variablen müssen sie mit einem Kleinbuchstaben beginnen und sind temporäre Variablen. Das bedeutet, dass sie nur für die Dauer der Ausführung der Methode existieren. Alle durch formale Parameter gebildeten Aliase sind ebenfalls temporär. In SMALLTALK sind formale Parameter zudem Pseudovariablen (siehe Abschnitt 1.7), d.h., es kann ihnen innerhalb der Methode, für die sie sichtbar sind, nichts zugewiesen werden. Syntaktisch unterscheidet sich SMALLTALK von den meisten anderen Programmiersprachen auch in der Methodendefinition dadurch, dass die formalen Parameter nicht durch Kommata getrennt in einer in Klammern eingeschlossenen Liste hinter dem Methodennamen stehen, sondern jeder Parameter wird einzeln von einem Nachrichtenbestandteil eingeleitet.
Eine Methodendefinition folgt also dem Schema (in spitzen Klammern stehen metasyntaktische Variablen als Platzhalter für entsprechende Programmelemente).
Die Methodensignatur dient der Auswahl der zu einer Nachricht passenden Methode. Sie ist das Gegenstück zum Nachrichtenselektor aus Abschnitt 4.1.2, anhand dessen die Auswahl der zu einem Nachrichtenausdruck passenden Methode durchgeführt wird. Anders als ein Nachrichtenausdruck nennt eine Methodensignatur jedoch kein Empfängerobjekt, und die offenen Stellen eines Nachrichtenselektors werden ausschließlich durch Variablen, nämlich die formalen Parameter, und nicht durch beliebige Ausdrücke besetzt. Typische Methodensignaturen sind z.B.: Für Methoden ohne Parameter: methodName, für binäre Methoden (mit einem formalen Parameter namens anInteger): methodName: anInteger, für alle anderen Methoden mit einem oder mehreren Parametern (in diesem Fall mit nur einem formalen Parameter namens aStream): methodName: anArgument.
Die Methodenrümpfe bestehen aus einer Folge von Anweisungen, die jeweils durch einen Punkt getrennt sind. Wenn die Anweisungen nichts anderes vorsehen, wird die Ausführung einer Methode nach Abarbeitung der letzten Anweisung explizit mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung (siehe Abschnitt 4.2) vorgesehen. Eine Return-Anweisung darf an beliebigen Stellen innerhalb der Methode auftreten, wodurch die Abarbeitung der Methode vor Erreichen der textuell letzten Anweisung beendet werden kann. Die Return-Anweisung beeinflusst somit den Kontrollfluss des Programms. Wichtig ist, dass eine Methode immer ein Objekt zurückgibt. Ein Nachrichtenausdruck (oder Methodenaufruf) steht immer für ein Objekt. Prozeduren im Sinne von PASCAL oder Void-Methoden im Sinne von C, JAVA usw. gibt es in SMALLTALK nicht (vgl. auch Abschnitt 4.1.3).
Sollte eine Methode temporäre Variablen für ihre Berechnungen benötigen, müssen diese zu Beginn der Methode (nach der Methodensignatur und vor der ersten Anweisung) deklariert werden. Die Werte dieser Variablen werden standardmäßig mit nil initialisiert und sind außerhalb der Methode nicht sichtbar. Die Variablen werden nach Abarbeitung der Methode vom System wieder entfernt, und sie können sich daher zwischen zwei Ausführungen einer Methode nichts merken.
Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben. Umgekehrt können temporäre Variablen, die nur einmal verwendet werden, eingespart werden, indem man kaskadierte Nachrichtenausdrücke verwendet.
Rückkehr von Methoden sind die Einheiten des Programms, in denen Sie als Programmiererin Ihre Anweisungen unterbringen. Sie werden nach der Eingabe (und bei jeder Änderung) mit dem ""Speichern"" kompiliert. Beachten Sie dabei, dass Methoden nicht in Dateien gespeichert werden, sondern in einer Datenstruktur von SMALLTALK, und zwar in Form von Objekten. Tatsächlich besteht der Großteil eines jeden SMALLTALK-Programms, ja des gesamten SMALLTALK-Systems, aus Methodendefinitionen. Die Methodendefinitionen entsprechen im Wesentlichen der Definition von Funktionen (oder, mit obiger Einschränkung, Prozeduren) in anderen Sprachen. In SMALLTALK ist es jedoch nicht möglich (und in der objektorientierten Programmierung allgemein nicht üblich), Methoden zu verschachteln, d.h., eine Methode innerhalb einer anderen Methode zu deklarieren. Außerdem gibt es in SMALLTALK keine ""Hauptmethode"" wie beispielsweise die Main-Methoden in der C-Sprachfamilie. Sie müssen dem SMALLTALK-System explizit mitteilen, welche Methode Sie ausführen möchten, indem Sie einen entsprechenden Ausdruck eingeben und auswerten lassen.",<answer> Die Ausführung einer Methode wird standardmäßig nach Abarbeitung der letzten Anweisung mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Die Return-Anweisung ermöglicht eine explizite Beendigung der Methode und die Rückgabe eines anderen Objekts als des Empfängers. Die Return-Anweisung kann an beliebigen Stellen innerhalb der Methode auftreten und beeinflusst den Kontrollfluss des Programms. <answer> <question> Wie wird die Ausführung einer Methode beendet und was ist die Return-Anweisung? <question>
"Die Auswertung von Nachrichtenausdrücken, also von Nachrichten, die an Objekte verschickt werden, erfolgt mithilfe sogenannter Methoden. Eine Methode beschreibt, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf, der in SMALLTALK auch als ""Message pattern"" bezeichnet wird, aber allgemein und im Folgenden eher als Methodensignatur bezeichnet wird. Es enthält eine optionale Liste von lokalen Variablen und einen Methodenrumpf. Der Methodenrumpf enthält die Anweisungen, die die Methode ausmachen und die zur Auswertung eines Nachrichtenausdrucks ausgeführt werden. Es ist üblich, jede Methode mit einem Kommentar in doppelten Anführungsstrichen zu versehen, der beschreibt, was diese Methode tut.
Die Methodensignatur besteht aus dem Namen der Methode und der Liste ihrer formalen Parameter. Formale Parameter sind lokale Variablen, denen beim Aufruf der Methode (siehe Abschnitt 4.3.2) automatisch ein Wert, der als sogenannter tatsächlicher Parameter bezeichnet wird, zugewiesen wird. Die Sichtbarkeit der formalen Parameter ist auf die Methode beschränkt, in deren Methodensignatur sie vorkommen. Wie alle lokalen Variablen müssen sie mit einem Kleinbuchstaben beginnen und sind temporäre Variablen. Das bedeutet, dass sie nur für die Dauer der Ausführung der Methode existieren. Alle durch formale Parameter gebildeten Aliase sind ebenfalls temporär. In SMALLTALK sind formale Parameter zudem Pseudovariablen (siehe Abschnitt 1.7), d.h., es kann ihnen innerhalb der Methode, für die sie sichtbar sind, nichts zugewiesen werden. Syntaktisch unterscheidet sich SMALLTALK von den meisten anderen Programmiersprachen auch in der Methodendefinition dadurch, dass die formalen Parameter nicht durch Kommata getrennt in einer in Klammern eingeschlossenen Liste hinter dem Methodennamen stehen, sondern jeder Parameter wird einzeln von einem Nachrichtenbestandteil eingeleitet.
Eine Methodendefinition folgt also dem Schema (in spitzen Klammern stehen metasyntaktische Variablen als Platzhalter für entsprechende Programmelemente).
Die Methodensignatur dient der Auswahl der zu einer Nachricht passenden Methode. Sie ist das Gegenstück zum Nachrichtenselektor aus Abschnitt 4.1.2, anhand dessen die Auswahl der zu einem Nachrichtenausdruck passenden Methode durchgeführt wird. Anders als ein Nachrichtenausdruck nennt eine Methodensignatur jedoch kein Empfängerobjekt, und die offenen Stellen eines Nachrichtenselektors werden ausschließlich durch Variablen, nämlich die formalen Parameter, und nicht durch beliebige Ausdrücke besetzt. Typische Methodensignaturen sind z.B.: Für Methoden ohne Parameter: methodName, für binäre Methoden (mit einem formalen Parameter namens anInteger): methodName: anInteger, für alle anderen Methoden mit einem oder mehreren Parametern (in diesem Fall mit nur einem formalen Parameter namens aStream): methodName: anArgument.
Die Methodenrümpfe bestehen aus einer Folge von Anweisungen, die jeweils durch einen Punkt getrennt sind. Wenn die Anweisungen nichts anderes vorsehen, wird die Ausführung einer Methode nach Abarbeitung der letzten Anweisung explizit mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung (siehe Abschnitt 4.2) vorgesehen. Eine Return-Anweisung darf an beliebigen Stellen innerhalb der Methode auftreten, wodurch die Abarbeitung der Methode vor Erreichen der textuell letzten Anweisung beendet werden kann. Die Return-Anweisung beeinflusst somit den Kontrollfluss des Programms. Wichtig ist, dass eine Methode immer ein Objekt zurückgibt. Ein Nachrichtenausdruck (oder Methodenaufruf) steht immer für ein Objekt. Prozeduren im Sinne von PASCAL oder Void-Methoden im Sinne von C, JAVA usw. gibt es in SMALLTALK nicht (vgl. auch Abschnitt 4.1.3).
Sollte eine Methode temporäre Variablen für ihre Berechnungen benötigen, müssen diese zu Beginn der Methode (nach der Methodensignatur und vor der ersten Anweisung) deklariert werden. Die Werte dieser Variablen werden standardmäßig mit nil initialisiert und sind außerhalb der Methode nicht sichtbar. Die Variablen werden nach Abarbeitung der Methode vom System wieder entfernt, und sie können sich daher zwischen zwei Ausführungen einer Methode nichts merken.
Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben. Umgekehrt können temporäre Variablen, die nur einmal verwendet werden, eingespart werden, indem man kaskadierte Nachrichtenausdrücke verwendet.
Rückkehr von Methoden sind die Einheiten des Programms, in denen Sie als Programmiererin Ihre Anweisungen unterbringen. Sie werden nach der Eingabe (und bei jeder Änderung) mit dem ""Speichern"" kompiliert. Beachten Sie dabei, dass Methoden nicht in Dateien gespeichert werden, sondern in einer Datenstruktur von SMALLTALK, und zwar in Form von Objekten. Tatsächlich besteht der Großteil eines jeden SMALLTALK-Programms, ja des gesamten SMALLTALK-Systems, aus Methodendefinitionen. Die Methodendefinitionen entsprechen im Wesentlichen der Definition von Funktionen (oder, mit obiger Einschränkung, Prozeduren) in anderen Sprachen. In SMALLTALK ist es jedoch nicht möglich (und in der objektorientierten Programmierung allgemein nicht üblich), Methoden zu verschachteln, d.h., eine Methode innerhalb einer anderen Methode zu deklarieren. Außerdem gibt es in SMALLTALK keine ""Hauptmethode"" wie beispielsweise die Main-Methoden in der C-Sprachfamilie. Sie müssen dem SMALLTALK-System explizit mitteilen, welche Methode Sie ausführen möchten, indem Sie einen entsprechenden Ausdruck eingeben und auswerten lassen.","<answer> Methoden in SMALLTALK werden nicht in Dateien gespeichert, sondern in einer Datenstruktur von SMALLTALK, nämlich in Form von Objekten. Sie werden nach der Eingabe und bei jeder Änderung mit dem ""Speichern"" kompiliert. Dies bedeutet, dass der Großteil eines jeden SMALLTALK-Programms aus Methodendefinitionen besteht, die im SMALLTALK-System als Objekte gespeichert sind. <answer> <question> Wie werden Methoden in SMALLTALK gespeichert und kompiliert? <question>"
"Wenn Sie sich bereits vor diesem Kurs mit objektorientierter Programmierung befasst haben, fragen Sie sich vielleicht, warum die Begriffe Superklasse und Subklasse bislang nicht erwähnt wurden. Das liegt daran, dass diese Begriffe in verschiedenen Programmiersprachen unterschiedliche Bedeutungen haben, während die Begriffe Generalisierung, Spezialisierung, Vererbung und abstrakte Klassen recht einheitlich interpretiert werden.
Die Subklassenbeziehung ist, genau wie die Generalisierung, Spezialisierung und Vererbung, eine Beziehung zwischen Klassen. Die beiden Enden dieser Beziehung tragen die Rollen Superklasse bzw. Subklasse; die Präfixe legen nahe, dass die Subklassenbeziehung eine Klassenhierarchie aufbaut, in der die Superklassen über den Subklassen stehen. Außerdem ist die Subklassenbeziehung transitiv: Wenn A eine Subklasse von B ist und B eine von C, dann ist A auch eine Subklasse von C. Analoges gilt natürlich auch für Superklassen. Man spricht übrigens von einer direkten Subklasse bzw. einer direkten Superklasse, wenn es keine weitere Klasse gibt, die in der Subklassenbeziehung dazwischen steht. Die Subklassenbeziehung ist (anders als die Subtypenbeziehung; vgl. Kapitel 26) nicht reflexiv (irreflexiv) — eine Klasse kann also keine Subklasse von sich selbst sein.","<answer> Die Begriffe ""Superklasse"" und ""Subklasse"" wurden in früheren Abschnitten nicht erwähnt, da sie in verschiedenen Programmiersprachen unterschiedliche Bedeutungen haben können, während die Begriffe ""Generalisierung"", ""Spezialisierung"", ""Vererbung"" und ""abstrakte Klassen"" eher einheitlich interpretiert werden. Diese Begriffe können je nach Programmiersprache und Kontext unterschiedliche Konzepte darstellen, daher wurden sie in diesem Kurs erst später spezifiziert. <answer> <question> Warum wurden die Begriffe ""Superklasse"" und ""Subklasse"" in früheren Abschnitten nicht erwähnt? <question>"
"Wenn Sie sich bereits vor diesem Kurs mit objektorientierter Programmierung befasst haben, fragen Sie sich vielleicht, warum die Begriffe Superklasse und Subklasse bislang nicht erwähnt wurden. Das liegt daran, dass diese Begriffe in verschiedenen Programmiersprachen unterschiedliche Bedeutungen haben, während die Begriffe Generalisierung, Spezialisierung, Vererbung und abstrakte Klassen recht einheitlich interpretiert werden.
Die Subklassenbeziehung ist, genau wie die Generalisierung, Spezialisierung und Vererbung, eine Beziehung zwischen Klassen. Die beiden Enden dieser Beziehung tragen die Rollen Superklasse bzw. Subklasse; die Präfixe legen nahe, dass die Subklassenbeziehung eine Klassenhierarchie aufbaut, in der die Superklassen über den Subklassen stehen. Außerdem ist die Subklassenbeziehung transitiv: Wenn A eine Subklasse von B ist und B eine von C, dann ist A auch eine Subklasse von C. Analoges gilt natürlich auch für Superklassen. Man spricht übrigens von einer direkten Subklasse bzw. einer direkten Superklasse, wenn es keine weitere Klasse gibt, die in der Subklassenbeziehung dazwischen steht. Die Subklassenbeziehung ist (anders als die Subtypenbeziehung; vgl. Kapitel 26) nicht reflexiv (irreflexiv) — eine Klasse kann also keine Subklasse von sich selbst sein.","<answer> Die beiden Enden der Subklassenbeziehung haben die Rollen ""Superklasse"" und ""Subklasse"". Diese Rollen legen nahe, dass die Subklassenbeziehung eine Hierarchie von Klassen aufbaut, in der die Superklassen über den Subklassen stehen. Die Superklasse ist die allgemeinere Klasse, von der die Subklasse erbt, während die Subklasse die speziellere Klasse ist, die die Eigenschaften der Superklasse erbt und möglicherweise erweitert oder anpasst. <answer> <question> Was sind die Rollen der beiden Enden der Subklassenbeziehung? <question>"
"Wenn Sie sich bereits vor diesem Kurs mit objektorientierter Programmierung befasst haben, fragen Sie sich vielleicht, warum die Begriffe Superklasse und Subklasse bislang nicht erwähnt wurden. Das liegt daran, dass diese Begriffe in verschiedenen Programmiersprachen unterschiedliche Bedeutungen haben, während die Begriffe Generalisierung, Spezialisierung, Vererbung und abstrakte Klassen recht einheitlich interpretiert werden.
Die Subklassenbeziehung ist, genau wie die Generalisierung, Spezialisierung und Vererbung, eine Beziehung zwischen Klassen. Die beiden Enden dieser Beziehung tragen die Rollen Superklasse bzw. Subklasse; die Präfixe legen nahe, dass die Subklassenbeziehung eine Klassenhierarchie aufbaut, in der die Superklassen über den Subklassen stehen. Außerdem ist die Subklassenbeziehung transitiv: Wenn A eine Subklasse von B ist und B eine von C, dann ist A auch eine Subklasse von C. Analoges gilt natürlich auch für Superklassen. Man spricht übrigens von einer direkten Subklasse bzw. einer direkten Superklasse, wenn es keine weitere Klasse gibt, die in der Subklassenbeziehung dazwischen steht. Die Subklassenbeziehung ist (anders als die Subtypenbeziehung; vgl. Kapitel 26) nicht reflexiv (irreflexiv) — eine Klasse kann also keine Subklasse von sich selbst sein.","<answer> Die Transitivität der Subklassenbeziehung bedeutet, dass, wenn Klasse A eine Subklasse von Klasse B ist und Klasse B eine Subklasse von Klasse C ist, dann ist Klasse A auch eine Subklasse von Klasse C. Dies bedeutet, dass die Vererbung von Eigenschaften und Verhalten in der Klassenhierarchie entlang der Subklassenbeziehung in einer kaskadierenden Weise erfolgt. <answer> <question> Was bedeutet es, dass die Subklassenbeziehung transitiv ist? <question>"
"Wenn Sie sich bereits vor diesem Kurs mit objektorientierter Programmierung befasst haben, fragen Sie sich vielleicht, warum die Begriffe Superklasse und Subklasse bislang nicht erwähnt wurden. Das liegt daran, dass diese Begriffe in verschiedenen Programmiersprachen unterschiedliche Bedeutungen haben, während die Begriffe Generalisierung, Spezialisierung, Vererbung und abstrakte Klassen recht einheitlich interpretiert werden.
Die Subklassenbeziehung ist, genau wie die Generalisierung, Spezialisierung und Vererbung, eine Beziehung zwischen Klassen. Die beiden Enden dieser Beziehung tragen die Rollen Superklasse bzw. Subklasse; die Präfixe legen nahe, dass die Subklassenbeziehung eine Klassenhierarchie aufbaut, in der die Superklassen über den Subklassen stehen. Außerdem ist die Subklassenbeziehung transitiv: Wenn A eine Subklasse von B ist und B eine von C, dann ist A auch eine Subklasse von C. Analoges gilt natürlich auch für Superklassen. Man spricht übrigens von einer direkten Subklasse bzw. einer direkten Superklasse, wenn es keine weitere Klasse gibt, die in der Subklassenbeziehung dazwischen steht. Die Subklassenbeziehung ist (anders als die Subtypenbeziehung; vgl. Kapitel 26) nicht reflexiv (irreflexiv) — eine Klasse kann also keine Subklasse von sich selbst sein.","<answer> Eine direkte Subklasse ist eine Klasse, die direkt von einer anderen Klasse erbt, ohne dass eine weitere Klasse dazwischen liegt. Eine indirekte Subklasse ist eine Klasse, die von einer Superklasse erbt, die selbst von einer anderen Klasse erbt. Mit anderen Worten, eine indirekte Subklasse ist eine Subklasse, die von einer Superklasse erbt, die ebenfalls eine Subklasse ist. <answer> <question> Was ist der Unterschied zwischen einer direkten Subklasse und einer indirekten Subklasse? <question>"
"Die Blöcke in SMALLTALK können auch als anonyme Funktionen aufgefasst werden. Bisher waren alle Blöcke parameterlos, und ihre Beziehung zur Umgebung wurde ausschließlich über den Home Context hergestellt. Es ist jedoch auch möglich, Blöcke mit Parametern zu versehen, die bei ihrer Auswertung an Objekte aus dem Auswertungskontext gebunden werden können.","<answer> Parametrisierte Blöcke in SMALLTALK können mit Parametern versehen werden, die bei ihrer Auswertung an Objekte aus dem Auswertungskontext gebunden werden können. Das bedeutet, dass sie bei ihrer Ausführung auf spezifische Werte zugreifen können, die ihnen als Parameter übergeben wurden. <answer> <question> Was ist die Besonderheit von parametrisierten Blöcken in SMALLTALK? <question>"
"Ausdrücke in JAVA können sein: Literale, Variablen, die spezielle Variable this, Operatoranwendungen, Feldzugriffe der Form a.x, wobei a für den Besitzer des Feldes (ein Objekt oder eine Klasse) und x für das Feld (die Instanz- bzw. Klassenvariable) steht (a kann auch durch super ersetzt werden), Methodenaufrufe der Form a.m(...), wobei a für den Empfänger des Aufrufs steht oder für super, m für die Methode und ... für die tatsächlichen Parameter (die wiederum Ausdrücke sind), Array-Zugriffe der Form a[i], wobei a für das Array und i für einen Index steht (eine ganze, positive Zahl; bei mehrdimensionalen Arrays können entsprechend weitere Indizes in eckigen Klammern angegeben werden), Klasseninstanziierungen der Form new <Klassenname>(<Parameter>), Array-Instanziierungen der Form new <Basistypname>[<n>], wobei <Basistypname> für den Typ der Elemente steht (z. B. int bei einem Array von Integern) und <n> für einen Ausdruck, dessen Auswertung eine ganze, positive Zahl liefert (es können auch mehrere Dimensionen angegeben werden), Konditionalausdrücke der Form <Boolescher Ausdruck> ? <Ausdruck 1> : <Ausdruck 2>, wobei in Abhängigkeit davon, ob <Boolescher Ausdruck> zu wahr oder zu falsch auswertet, entweder <Ausdruck 1> oder <Ausdruck 2> ausgewertet wird und das Ergebnis des Gesamtausdrucks liefert, Cast-Ausdrücke der Form (<Typname>) <Ausdruck>, wobei <Typname> für das Ziel des Casts steht und <Ausdruck> für den Ausdruck, dessen Ergebnis den mit <Typname> bezeichneten Typ annehmen soll, Lambda-Ausdrücke der Form (<Parameterdeklarationen>) -> <Rumpf>, wobei <Parameterdeklarationen> den formalen Parameterdeklarationen einer Methode entspricht und <Rumpf> entweder eine einzelne Anweisung oder ein Block von Anweisungen, entsprechend einem Methodenrumpf (inklusive der geschweiften Klammern), ist. Falls nur ein Parameter deklariert wird, können die runden Klammern auch weggelassen werden.
Wie man sieht, können in JAVA Ausdrücke rekursiv aus anderen aufgebaut werden. Methodenausdrücke beinhalten einen Ausdruck für den Empfänger sowie möglicherweise weitere Ausdrücke für die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung des Indexes bzw. der Größe, usw. Dabei müssen alle Ausdrücke korrekt typisiert sein, was bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks, an der Stelle, an der er eingesetzt wird, zuweisungskompatibel sein muss.
In JAVA gibt es nur Call by Value und kein Call by Reference, ähnlich wie in SMALLTALK. Das bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Das ist eine erhebliche Einschränkung.
Lambda-Ausdrücke in JAVA, die mit Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren, die ein Interface (siehe Abschnitt 40) mit nur einer Methode implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Die Funktionen, die Lambda-Ausdrücke darstellen, erhalten über das Interface einen Namen.
Anonyme Funktionen oder Blöcke wie in SMALLTALK können in JAVA über vordefinierte Interfaces erstellt werden.
Demnach heißt die Funktion des Funktionsobjekts ""apply"". Der Ausdruck f.apply(2) liefert entsprechend 4. Hierbei entspricht apply(.) dem aus SMALLTALK bekannten value.
Es gibt einige Unterschiede zwischen JAVA-Ausdrücken und SMALLTALK-Ausdrücken, darunter die Verwendung von direkten Feldzugriffen in JAVA (a.x) und das Fehlen von indizierten Instanzvariablen. Außerdem unterscheidet JAVA zwischen Operatoranwendungen (+, -, etc.), Methodenaufrufen, Konstruktoraufrufen und Arrayzugriffen, während in SMALLTALK nur Methodenaufrufe existieren.","<answer> In JAVA gibt es verschiedene Arten von Ausdrücken, darunter Literale, Variablen, Methodenaufrufe, Operatoranwendungen, Feldzugriffe, Klasseninstanziierungen, Array-Instanziierungen, Konditionalausdrücke, Cast-Ausdrücke und Lambda-Ausdrücke. <answer> <question> Welche Arten von Ausdrücken gibt es in JAVA? <question>"
"Ausdrücke in JAVA können sein: Literale, Variablen, die spezielle Variable this, Operatoranwendungen, Feldzugriffe der Form a.x, wobei a für den Besitzer des Feldes (ein Objekt oder eine Klasse) und x für das Feld (die Instanz- bzw. Klassenvariable) steht (a kann auch durch super ersetzt werden), Methodenaufrufe der Form a.m(...), wobei a für den Empfänger des Aufrufs steht oder für super, m für die Methode und ... für die tatsächlichen Parameter (die wiederum Ausdrücke sind), Array-Zugriffe der Form a[i], wobei a für das Array und i für einen Index steht (eine ganze, positive Zahl; bei mehrdimensionalen Arrays können entsprechend weitere Indizes in eckigen Klammern angegeben werden), Klasseninstanziierungen der Form new <Klassenname>(<Parameter>), Array-Instanziierungen der Form new <Basistypname>[<n>], wobei <Basistypname> für den Typ der Elemente steht (z. B. int bei einem Array von Integern) und <n> für einen Ausdruck, dessen Auswertung eine ganze, positive Zahl liefert (es können auch mehrere Dimensionen angegeben werden), Konditionalausdrücke der Form <Boolescher Ausdruck> ? <Ausdruck 1> : <Ausdruck 2>, wobei in Abhängigkeit davon, ob <Boolescher Ausdruck> zu wahr oder zu falsch auswertet, entweder <Ausdruck 1> oder <Ausdruck 2> ausgewertet wird und das Ergebnis des Gesamtausdrucks liefert, Cast-Ausdrücke der Form (<Typname>) <Ausdruck>, wobei <Typname> für das Ziel des Casts steht und <Ausdruck> für den Ausdruck, dessen Ergebnis den mit <Typname> bezeichneten Typ annehmen soll, Lambda-Ausdrücke der Form (<Parameterdeklarationen>) -> <Rumpf>, wobei <Parameterdeklarationen> den formalen Parameterdeklarationen einer Methode entspricht und <Rumpf> entweder eine einzelne Anweisung oder ein Block von Anweisungen, entsprechend einem Methodenrumpf (inklusive der geschweiften Klammern), ist. Falls nur ein Parameter deklariert wird, können die runden Klammern auch weggelassen werden.
Wie man sieht, können in JAVA Ausdrücke rekursiv aus anderen aufgebaut werden. Methodenausdrücke beinhalten einen Ausdruck für den Empfänger sowie möglicherweise weitere Ausdrücke für die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung des Indexes bzw. der Größe, usw. Dabei müssen alle Ausdrücke korrekt typisiert sein, was bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks, an der Stelle, an der er eingesetzt wird, zuweisungskompatibel sein muss.
In JAVA gibt es nur Call by Value und kein Call by Reference, ähnlich wie in SMALLTALK. Das bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Das ist eine erhebliche Einschränkung.
Lambda-Ausdrücke in JAVA, die mit Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren, die ein Interface (siehe Abschnitt 40) mit nur einer Methode implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Die Funktionen, die Lambda-Ausdrücke darstellen, erhalten über das Interface einen Namen.
Anonyme Funktionen oder Blöcke wie in SMALLTALK können in JAVA über vordefinierte Interfaces erstellt werden.
Demnach heißt die Funktion des Funktionsobjekts ""apply"". Der Ausdruck f.apply(2) liefert entsprechend 4. Hierbei entspricht apply(.) dem aus SMALLTALK bekannten value.
Es gibt einige Unterschiede zwischen JAVA-Ausdrücken und SMALLTALK-Ausdrücken, darunter die Verwendung von direkten Feldzugriffen in JAVA (a.x) und das Fehlen von indizierten Instanzvariablen. Außerdem unterscheidet JAVA zwischen Operatoranwendungen (+, -, etc.), Methodenaufrufen, Konstruktoraufrufen und Arrayzugriffen, während in SMALLTALK nur Methodenaufrufe existieren.","<answer> Ausdrücke in JAVA können rekursiv aus anderen Ausdrücken aufgebaut werden. Zum Beispiel enthalten Methodenausdrücke Ausdrücke für den Empfänger und die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung von Indexen oder Größen. <answer> <question> Wie werden Ausdrücke in JAVA aufgebaut, und welche rekursiven Elemente sind dabei beteiligt? <question>"
"Ausdrücke in JAVA können sein: Literale, Variablen, die spezielle Variable this, Operatoranwendungen, Feldzugriffe der Form a.x, wobei a für den Besitzer des Feldes (ein Objekt oder eine Klasse) und x für das Feld (die Instanz- bzw. Klassenvariable) steht (a kann auch durch super ersetzt werden), Methodenaufrufe der Form a.m(...), wobei a für den Empfänger des Aufrufs steht oder für super, m für die Methode und ... für die tatsächlichen Parameter (die wiederum Ausdrücke sind), Array-Zugriffe der Form a[i], wobei a für das Array und i für einen Index steht (eine ganze, positive Zahl; bei mehrdimensionalen Arrays können entsprechend weitere Indizes in eckigen Klammern angegeben werden), Klasseninstanziierungen der Form new <Klassenname>(<Parameter>), Array-Instanziierungen der Form new <Basistypname>[<n>], wobei <Basistypname> für den Typ der Elemente steht (z. B. int bei einem Array von Integern) und <n> für einen Ausdruck, dessen Auswertung eine ganze, positive Zahl liefert (es können auch mehrere Dimensionen angegeben werden), Konditionalausdrücke der Form <Boolescher Ausdruck> ? <Ausdruck 1> : <Ausdruck 2>, wobei in Abhängigkeit davon, ob <Boolescher Ausdruck> zu wahr oder zu falsch auswertet, entweder <Ausdruck 1> oder <Ausdruck 2> ausgewertet wird und das Ergebnis des Gesamtausdrucks liefert, Cast-Ausdrücke der Form (<Typname>) <Ausdruck>, wobei <Typname> für das Ziel des Casts steht und <Ausdruck> für den Ausdruck, dessen Ergebnis den mit <Typname> bezeichneten Typ annehmen soll, Lambda-Ausdrücke der Form (<Parameterdeklarationen>) -> <Rumpf>, wobei <Parameterdeklarationen> den formalen Parameterdeklarationen einer Methode entspricht und <Rumpf> entweder eine einzelne Anweisung oder ein Block von Anweisungen, entsprechend einem Methodenrumpf (inklusive der geschweiften Klammern), ist. Falls nur ein Parameter deklariert wird, können die runden Klammern auch weggelassen werden.
Wie man sieht, können in JAVA Ausdrücke rekursiv aus anderen aufgebaut werden. Methodenausdrücke beinhalten einen Ausdruck für den Empfänger sowie möglicherweise weitere Ausdrücke für die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung des Indexes bzw. der Größe, usw. Dabei müssen alle Ausdrücke korrekt typisiert sein, was bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks, an der Stelle, an der er eingesetzt wird, zuweisungskompatibel sein muss.
In JAVA gibt es nur Call by Value und kein Call by Reference, ähnlich wie in SMALLTALK. Das bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Das ist eine erhebliche Einschränkung.
Lambda-Ausdrücke in JAVA, die mit Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren, die ein Interface (siehe Abschnitt 40) mit nur einer Methode implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Die Funktionen, die Lambda-Ausdrücke darstellen, erhalten über das Interface einen Namen.
Anonyme Funktionen oder Blöcke wie in SMALLTALK können in JAVA über vordefinierte Interfaces erstellt werden.
Demnach heißt die Funktion des Funktionsobjekts ""apply"". Der Ausdruck f.apply(2) liefert entsprechend 4. Hierbei entspricht apply(.) dem aus SMALLTALK bekannten value.
Es gibt einige Unterschiede zwischen JAVA-Ausdrücken und SMALLTALK-Ausdrücken, darunter die Verwendung von direkten Feldzugriffen in JAVA (a.x) und das Fehlen von indizierten Instanzvariablen. Außerdem unterscheidet JAVA zwischen Operatoranwendungen (+, -, etc.), Methodenaufrufen, Konstruktoraufrufen und Arrayzugriffen, während in SMALLTALK nur Methodenaufrufe existieren.","<answer> In JAVA müssen alle Ausdrücke korrekt typisiert sein. Das bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks übereinstimmen muss, an der Stelle, an der er eingesetzt wird. <answer> <question> Welche Typisierungsanforderungen gelten für Ausdrücke in JAVA? <question>"
"Ausdrücke in JAVA können sein: Literale, Variablen, die spezielle Variable this, Operatoranwendungen, Feldzugriffe der Form a.x, wobei a für den Besitzer des Feldes (ein Objekt oder eine Klasse) und x für das Feld (die Instanz- bzw. Klassenvariable) steht (a kann auch durch super ersetzt werden), Methodenaufrufe der Form a.m(...), wobei a für den Empfänger des Aufrufs steht oder für super, m für die Methode und ... für die tatsächlichen Parameter (die wiederum Ausdrücke sind), Array-Zugriffe der Form a[i], wobei a für das Array und i für einen Index steht (eine ganze, positive Zahl; bei mehrdimensionalen Arrays können entsprechend weitere Indizes in eckigen Klammern angegeben werden), Klasseninstanziierungen der Form new <Klassenname>(<Parameter>), Array-Instanziierungen der Form new <Basistypname>[<n>], wobei <Basistypname> für den Typ der Elemente steht (z. B. int bei einem Array von Integern) und <n> für einen Ausdruck, dessen Auswertung eine ganze, positive Zahl liefert (es können auch mehrere Dimensionen angegeben werden), Konditionalausdrücke der Form <Boolescher Ausdruck> ? <Ausdruck 1> : <Ausdruck 2>, wobei in Abhängigkeit davon, ob <Boolescher Ausdruck> zu wahr oder zu falsch auswertet, entweder <Ausdruck 1> oder <Ausdruck 2> ausgewertet wird und das Ergebnis des Gesamtausdrucks liefert, Cast-Ausdrücke der Form (<Typname>) <Ausdruck>, wobei <Typname> für das Ziel des Casts steht und <Ausdruck> für den Ausdruck, dessen Ergebnis den mit <Typname> bezeichneten Typ annehmen soll, Lambda-Ausdrücke der Form (<Parameterdeklarationen>) -> <Rumpf>, wobei <Parameterdeklarationen> den formalen Parameterdeklarationen einer Methode entspricht und <Rumpf> entweder eine einzelne Anweisung oder ein Block von Anweisungen, entsprechend einem Methodenrumpf (inklusive der geschweiften Klammern), ist. Falls nur ein Parameter deklariert wird, können die runden Klammern auch weggelassen werden.
Wie man sieht, können in JAVA Ausdrücke rekursiv aus anderen aufgebaut werden. Methodenausdrücke beinhalten einen Ausdruck für den Empfänger sowie möglicherweise weitere Ausdrücke für die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung des Indexes bzw. der Größe, usw. Dabei müssen alle Ausdrücke korrekt typisiert sein, was bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks, an der Stelle, an der er eingesetzt wird, zuweisungskompatibel sein muss.
In JAVA gibt es nur Call by Value und kein Call by Reference, ähnlich wie in SMALLTALK. Das bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Das ist eine erhebliche Einschränkung.
Lambda-Ausdrücke in JAVA, die mit Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren, die ein Interface (siehe Abschnitt 40) mit nur einer Methode implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Die Funktionen, die Lambda-Ausdrücke darstellen, erhalten über das Interface einen Namen.
Anonyme Funktionen oder Blöcke wie in SMALLTALK können in JAVA über vordefinierte Interfaces erstellt werden.
Demnach heißt die Funktion des Funktionsobjekts ""apply"". Der Ausdruck f.apply(2) liefert entsprechend 4. Hierbei entspricht apply(.) dem aus SMALLTALK bekannten value.
Es gibt einige Unterschiede zwischen JAVA-Ausdrücken und SMALLTALK-Ausdrücken, darunter die Verwendung von direkten Feldzugriffen in JAVA (a.x) und das Fehlen von indizierten Instanzvariablen. Außerdem unterscheidet JAVA zwischen Operatoranwendungen (+, -, etc.), Methodenaufrufen, Konstruktoraufrufen und Arrayzugriffen, während in SMALLTALK nur Methodenaufrufe existieren.","<answer> In JAVA wird Call by Value verwendet, was bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Dies ist eine Einschränkung im Vergleich zu Call by Reference, bei dem eine Methode auf den ursprünglichen Wert einer Variablen zugreifen und ihn ändern kann. <answer> <question> Was ist der Unterschied zwischen Call by Value und Call by Reference, und wie wird dies in JAVA gehandhabt? <question>"
"Ausdrücke in JAVA können sein: Literale, Variablen, die spezielle Variable this, Operatoranwendungen, Feldzugriffe der Form a.x, wobei a für den Besitzer des Feldes (ein Objekt oder eine Klasse) und x für das Feld (die Instanz- bzw. Klassenvariable) steht (a kann auch durch super ersetzt werden), Methodenaufrufe der Form a.m(...), wobei a für den Empfänger des Aufrufs steht oder für super, m für die Methode und ... für die tatsächlichen Parameter (die wiederum Ausdrücke sind), Array-Zugriffe der Form a[i], wobei a für das Array und i für einen Index steht (eine ganze, positive Zahl; bei mehrdimensionalen Arrays können entsprechend weitere Indizes in eckigen Klammern angegeben werden), Klasseninstanziierungen der Form new <Klassenname>(<Parameter>), Array-Instanziierungen der Form new <Basistypname>[<n>], wobei <Basistypname> für den Typ der Elemente steht (z. B. int bei einem Array von Integern) und <n> für einen Ausdruck, dessen Auswertung eine ganze, positive Zahl liefert (es können auch mehrere Dimensionen angegeben werden), Konditionalausdrücke der Form <Boolescher Ausdruck> ? <Ausdruck 1> : <Ausdruck 2>, wobei in Abhängigkeit davon, ob <Boolescher Ausdruck> zu wahr oder zu falsch auswertet, entweder <Ausdruck 1> oder <Ausdruck 2> ausgewertet wird und das Ergebnis des Gesamtausdrucks liefert, Cast-Ausdrücke der Form (<Typname>) <Ausdruck>, wobei <Typname> für das Ziel des Casts steht und <Ausdruck> für den Ausdruck, dessen Ergebnis den mit <Typname> bezeichneten Typ annehmen soll, Lambda-Ausdrücke der Form (<Parameterdeklarationen>) -> <Rumpf>, wobei <Parameterdeklarationen> den formalen Parameterdeklarationen einer Methode entspricht und <Rumpf> entweder eine einzelne Anweisung oder ein Block von Anweisungen, entsprechend einem Methodenrumpf (inklusive der geschweiften Klammern), ist. Falls nur ein Parameter deklariert wird, können die runden Klammern auch weggelassen werden.
Wie man sieht, können in JAVA Ausdrücke rekursiv aus anderen aufgebaut werden. Methodenausdrücke beinhalten einen Ausdruck für den Empfänger sowie möglicherweise weitere Ausdrücke für die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung des Indexes bzw. der Größe, usw. Dabei müssen alle Ausdrücke korrekt typisiert sein, was bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks, an der Stelle, an der er eingesetzt wird, zuweisungskompatibel sein muss.
In JAVA gibt es nur Call by Value und kein Call by Reference, ähnlich wie in SMALLTALK. Das bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Das ist eine erhebliche Einschränkung.
Lambda-Ausdrücke in JAVA, die mit Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren, die ein Interface (siehe Abschnitt 40) mit nur einer Methode implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Die Funktionen, die Lambda-Ausdrücke darstellen, erhalten über das Interface einen Namen.
Anonyme Funktionen oder Blöcke wie in SMALLTALK können in JAVA über vordefinierte Interfaces erstellt werden.
Demnach heißt die Funktion des Funktionsobjekts ""apply"". Der Ausdruck f.apply(2) liefert entsprechend 4. Hierbei entspricht apply(.) dem aus SMALLTALK bekannten value.
Es gibt einige Unterschiede zwischen JAVA-Ausdrücken und SMALLTALK-Ausdrücken, darunter die Verwendung von direkten Feldzugriffen in JAVA (a.x) und das Fehlen von indizierten Instanzvariablen. Außerdem unterscheidet JAVA zwischen Operatoranwendungen (+, -, etc.), Methodenaufrufen, Konstruktoraufrufen und Arrayzugriffen, während in SMALLTALK nur Methodenaufrufe existieren.","<answer> Lambda-Ausdrücke in JAVA, die in Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Sie ermöglichen die Darstellung von Funktionen als Werte und werden häufig für die Implementierung von Schnittstellen mit nur einer Methode (Funktionale Interfaces) verwendet. Im Gegensatz dazu verwenden anonyme innere Klassen explizite Klassendefinitionen, um Schnittstellen zu implementieren. <answer> <question> Welche Rolle spielen Lambda-Ausdrücke in JAVA, und wie unterscheiden sie sich von anonymen inneren Klassen? <question>"
"Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, die seine Ausführung bestimmen. Anders als in anderen Programmiersprachen gibt es in SMALLTALK nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf; alle anderen, einschließlich der Verzweigung und der Wiederholung (Schleife), müssen durch diese simuliert werden. Dies ist möglich, weil SMALLTALK Blöcke hat und weil in SMALLTALK (wie in allen anderen objektorientierten Programmiersprachen) der Methodenaufruf variabler ist als der gewöhnliche Prozedur- oder Funktionsaufruf, den Sie vielleicht von Sprachen wie PASCAL oder C kennen. Er enthält, wie bereits in Abschnitt 4.3.2 angedeutet, eine versteckte Fallunterscheidung in Form des dynamischen Bindens.","<answer> In SMALLTALK gibt es nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf. <answer> <question> Welche beiden Kontrollstrukturen gibt es in SMALLTALK? <question>"
"Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, die seine Ausführung bestimmen. Anders als in anderen Programmiersprachen gibt es in SMALLTALK nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf; alle anderen, einschließlich der Verzweigung und der Wiederholung (Schleife), müssen durch diese simuliert werden. Dies ist möglich, weil SMALLTALK Blöcke hat und weil in SMALLTALK (wie in allen anderen objektorientierten Programmiersprachen) der Methodenaufruf variabler ist als der gewöhnliche Prozedur- oder Funktionsaufruf, den Sie vielleicht von Sprachen wie PASCAL oder C kennen. Er enthält, wie bereits in Abschnitt 4.3.2 angedeutet, eine versteckte Fallunterscheidung in Form des dynamischen Bindens.","<answer> Verzweigungen und Wiederholungen in SMALLTALK werden durch die Verwendung von Blöcken und dynamisch gebundenen Methodenaufrufen simuliert. Da SMALLTALK keine direkten Verzweigungs- und Schleifenkonstrukte wie in einigen anderen Programmiersprachen hat, werden Entscheidungen und Wiederholungen durch den Aufruf entsprechender Methoden und die Auswertung von Blöcken erreicht. <answer> <question> Wie werden Verzweigungen und Wiederholungen in SMALLTALK simuliert? <question>"
"Einhergehend mit kurzen Methoden und aussagekräftigen Bezeichnern ist ein deklarativer Programmierstil für die objektorientierte Programmierung typisch: Die Ausdrucksform bemüht sich mehr um das ""Was"" als um das ""Wie"". Der Effizienzgedanke ist dabei sekundär – mögliche Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben, wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung zu ineffizient ist.
Da die objektorientierte Programmierung ihrem Wesen nach eher imperativ als deklarativ ist, beschränkt sich das Deklarative im Wesentlichen auf den Aufruf von Methoden, die nach dem benannt sind, was sie tun. So ist es in der objektorientierten Programmierung durchaus üblich, einzelne Schleifen, in denen beispielsweise ein Element gesucht wird, aus einem Methodenrumpf in eine eigene Methode zu verschieben und durch einen entsprechenden Methodenaufruf zu ersetzen. Das Programm liest sich also nur deklarativ und ist es nicht wirklich – es handelt sich ja auch nur um einen Stil.
Für beide Alternativen der Methode ""auswerten"" in Klasse ""Klausel"" gibt es übrigens eine ""Shortcut""-Variante (die so heißt, weil die Iteration ggf. vorzeitig abgebrochen wird).
Aber solange man sich nicht sicher ist, dass eine (vermeintliche) Abkürzung funktional äquivalent ist (also dasselbe Ergebnis liefert), sollte man von solchen Optimierungen die Finger lassen. (Es könnte beispielsweise sein, dass ""auswerten"" für ""Literale"" einen Seiteneffekt hat; in diesem Fall wären die optimierten Versionen nicht mehr äquivalent!)
Ein anderes Zeichen eines deklarativen Programmierstils ist die Verwendung von Zusicherungen (Vor- und Nachbedingungen, Invarianten) anstelle von Kommentaren.
Wenn es die Sprache zulässt. Damit schlägt man zwei Fliegen mit einer Klappe: Man kann die Zusicherungen zur Laufzeitverifikation einsetzen und zeigt dem Aufrufer der Methode, wie er selbst prüfen kann, ob die Vorbedingung eingehalten ist.","<answer> Der deklarative Programmierstil in der objektorientierten Programmierung legt mehr Wert auf das ""Was"" als auf das ""Wie"". Er betont die Ausdrucksform und verschiebt mögliche Optimierungen auf den Compiler oder später in der Entwicklung. Das bedeutet, dass die Programmiererin sich auf das Beschreiben dessen konzentriert, was erreicht werden soll, anstatt detaillierte Anweisungen zur Durchführung zu geben. <answer> <question> Was kennzeichnet den deklarativen Programmierstil in der objektorientierten Programmierung? <question>"
"Einhergehend mit kurzen Methoden und aussagekräftigen Bezeichnern ist ein deklarativer Programmierstil für die objektorientierte Programmierung typisch: Die Ausdrucksform bemüht sich mehr um das ""Was"" als um das ""Wie"". Der Effizienzgedanke ist dabei sekundär – mögliche Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben, wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung zu ineffizient ist.
Da die objektorientierte Programmierung ihrem Wesen nach eher imperativ als deklarativ ist, beschränkt sich das Deklarative im Wesentlichen auf den Aufruf von Methoden, die nach dem benannt sind, was sie tun. So ist es in der objektorientierten Programmierung durchaus üblich, einzelne Schleifen, in denen beispielsweise ein Element gesucht wird, aus einem Methodenrumpf in eine eigene Methode zu verschieben und durch einen entsprechenden Methodenaufruf zu ersetzen. Das Programm liest sich also nur deklarativ und ist es nicht wirklich – es handelt sich ja auch nur um einen Stil.
Für beide Alternativen der Methode ""auswerten"" in Klasse ""Klausel"" gibt es übrigens eine ""Shortcut""-Variante (die so heißt, weil die Iteration ggf. vorzeitig abgebrochen wird).
Aber solange man sich nicht sicher ist, dass eine (vermeintliche) Abkürzung funktional äquivalent ist (also dasselbe Ergebnis liefert), sollte man von solchen Optimierungen die Finger lassen. (Es könnte beispielsweise sein, dass ""auswerten"" für ""Literale"" einen Seiteneffekt hat; in diesem Fall wären die optimierten Versionen nicht mehr äquivalent!)
Ein anderes Zeichen eines deklarativen Programmierstils ist die Verwendung von Zusicherungen (Vor- und Nachbedingungen, Invarianten) anstelle von Kommentaren.
Wenn es die Sprache zulässt. Damit schlägt man zwei Fliegen mit einer Klappe: Man kann die Zusicherungen zur Laufzeitverifikation einsetzen und zeigt dem Aufrufer der Methode, wie er selbst prüfen kann, ob die Vorbedingung eingehalten ist.","<answer> Der deklarative Programmierstil ist in der objektorientierten Programmierung relevant, da er die Lesbarkeit und Wartbarkeit des Codes verbessert. Obwohl die objektorientierte Programmierung tendenziell eher imperativ ist, kann der deklarative Stil durch den Einsatz von aussagekräftigen Bezeichnern und die Aufteilung von Funktionalität in separate Methoden erreicht werden. Dies führt dazu, dass der Code leichter zu verstehen ist und die Absicht der Programmiererin klarer hervortritt. <answer> <question> Warum ist der deklarative Programmierstil in der objektorientierten Programmierung trotz ihres eher imperativen Charakters relevant? <question>"
"Einhergehend mit kurzen Methoden und aussagekräftigen Bezeichnern ist ein deklarativer Programmierstil für die objektorientierte Programmierung typisch: Die Ausdrucksform bemüht sich mehr um das ""Was"" als um das ""Wie"". Der Effizienzgedanke ist dabei sekundär – mögliche Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben, wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung zu ineffizient ist.
Da die objektorientierte Programmierung ihrem Wesen nach eher imperativ als deklarativ ist, beschränkt sich das Deklarative im Wesentlichen auf den Aufruf von Methoden, die nach dem benannt sind, was sie tun. So ist es in der objektorientierten Programmierung durchaus üblich, einzelne Schleifen, in denen beispielsweise ein Element gesucht wird, aus einem Methodenrumpf in eine eigene Methode zu verschieben und durch einen entsprechenden Methodenaufruf zu ersetzen. Das Programm liest sich also nur deklarativ und ist es nicht wirklich – es handelt sich ja auch nur um einen Stil.
Für beide Alternativen der Methode ""auswerten"" in Klasse ""Klausel"" gibt es übrigens eine ""Shortcut""-Variante (die so heißt, weil die Iteration ggf. vorzeitig abgebrochen wird).
Aber solange man sich nicht sicher ist, dass eine (vermeintliche) Abkürzung funktional äquivalent ist (also dasselbe Ergebnis liefert), sollte man von solchen Optimierungen die Finger lassen. (Es könnte beispielsweise sein, dass ""auswerten"" für ""Literale"" einen Seiteneffekt hat; in diesem Fall wären die optimierten Versionen nicht mehr äquivalent!)
Ein anderes Zeichen eines deklarativen Programmierstils ist die Verwendung von Zusicherungen (Vor- und Nachbedingungen, Invarianten) anstelle von Kommentaren.
Wenn es die Sprache zulässt. Damit schlägt man zwei Fliegen mit einer Klappe: Man kann die Zusicherungen zur Laufzeitverifikation einsetzen und zeigt dem Aufrufer der Methode, wie er selbst prüfen kann, ob die Vorbedingung eingehalten ist.","<answer> Der deklarative Programmierstil in der objektorientierten Programmierung zeichnet sich durch folgende Techniken und Praktiken aus: Verwendung von aussagekräftigen Bezeichnern, die beschreiben, was eine Methode tut. Aufteilung von komplexen Funktionen in separate Methoden mit klaren Namen. Betonung des ""Was"" anstelle des ""Wie"" bei der Formulierung des Codes. Verwendung von Zusicherungen (Vor- und Nachbedingungen, Invarianten) anstelle von Kommentaren, um die Absichten und Bedingungen des Codes deutlicher zu machen. Zurückhaltung bei der Verwendung von Optimierungen, die die funktionale Äquivalenz gefährden könnten, bis ihre Auswirkungen vollständig verstanden sind. <answer> <question> Welche Techniken und Praktiken kennzeichnen den deklarativen Programmierstil in der objektorientierten Programmierung? <question>"
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!","<answer> Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten und wird in SMALLTALK durch den Gleichheitsoperator = getestet. Identität wird in SMALLTALK durch == getestet und bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren. <answer> <question> Was ist der Unterschied zwischen Gleichheit und Identität von Objekten? <question>"
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!","<answer> Die Gleichheit von Objekten wird in SMALLTALK durch den Gleichheitsoperator = getestet, während die Identität zweier Objekte durch == getestet wird. <answer> <question> Wie werden die Gleichheit und die Identität von Objekten in SMALLTALK getestet? <question>"
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!","<answer> Syntaktisch gleiche String-Literale können in SMALLTALK unterschiedliche Identitäten haben, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. <answer> <question> Warum können syntaktisch gleiche String-Literale in SMALLTALK unterschiedliche Identitäten haben? <question>"
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!","<answer> In SMALLTALK werden gleiche Zahlen manchmal als identisch behandelt und manchmal nicht, abhängig von ihrer Größe und technischen Gründen. <answer> <question> Warum werden gleiche Zahlen in SMALLTALK manchmal als identisch behandelt und manchmal nicht? <question>"
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!","<answer> In der objektorientierten Programmierung sind ""das gleiche"" und ""dasselbe"" nicht dasselbe. Zwei Objekte können gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins. <answer> <question> Warum ist die Unterscheidung zwischen ""das gleiche"" und ""dasselbe"" wichtig in der objektorientierten Programmierung? <question>"
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!","<answer> Die Identität von Objekten ist wichtig, um festzustellen, ob zwei Namen oder Variablen dasselbe Objekt repräsentieren oder nicht. <answer> <question> Warum ist die Identität von Objekten in der objektorientierten Programmierung wichtig? <question>"
"Schließlich ist es in JAVA auch noch möglich, Variablen generisch zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Allerdings geht das, da eine Variable anders als eine Klasse oder Methoden keinen neuen Sichtbarkeitsbereich definiert, nur mit anonymen Typvariablen, also Wildcards. Man beachte jedoch, dass eine solche Variablendeklaration, genau wie eine generische Methodendefinition, keinen neuen Typ einführt (siehe Fußnote 72); vielmehr handelt es sich bei dem durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzten Typ selbst um einen konkreten Typ. Der per ""Wildcard"" deklarierten Variable ""liste"" können also Listen beliebigen Elementtyps zugewiesen werden, einfach weil ""List<?>"" (unter den in Abschnitt 43.2 genannten Einschränkungen) Supertyp aller Instanziierungen von ""List<T>"" ist.","<answer> Ja, es ist in Java möglich, generische Variablen zu deklarieren. <answer> <question> Ist es in Java möglich, generische Variablen zu deklarieren? <question>"
"Schließlich ist es in JAVA auch noch möglich, Variablen generisch zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Allerdings geht das, da eine Variable anders als eine Klasse oder Methoden keinen neuen Sichtbarkeitsbereich definiert, nur mit anonymen Typvariablen, also Wildcards. Man beachte jedoch, dass eine solche Variablendeklaration, genau wie eine generische Methodendefinition, keinen neuen Typ einführt (siehe Fußnote 72); vielmehr handelt es sich bei dem durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzten Typ selbst um einen konkreten Typ. Der per ""Wildcard"" deklarierten Variable ""liste"" können also Listen beliebigen Elementtyps zugewiesen werden, einfach weil ""List<?>"" (unter den in Abschnitt 43.2 genannten Einschränkungen) Supertyp aller Instanziierungen von ""List<T>"" ist.","<answer> In generischen Variablen können anonyme Typvariablen, also Wildcards, verwendet werden. <answer> <question> Welche Art von Typvariablen können in generischen Variablen verwendet werden? <question>"
"Schließlich ist es in JAVA auch noch möglich, Variablen generisch zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Allerdings geht das, da eine Variable anders als eine Klasse oder Methoden keinen neuen Sichtbarkeitsbereich definiert, nur mit anonymen Typvariablen, also Wildcards. Man beachte jedoch, dass eine solche Variablendeklaration, genau wie eine generische Methodendefinition, keinen neuen Typ einführt (siehe Fußnote 72); vielmehr handelt es sich bei dem durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzten Typ selbst um einen konkreten Typ. Der per ""Wildcard"" deklarierten Variable ""liste"" können also Listen beliebigen Elementtyps zugewiesen werden, einfach weil ""List<?>"" (unter den in Abschnitt 43.2 genannten Einschränkungen) Supertyp aller Instanziierungen von ""List<T>"" ist.","<answer> Wenn eine Variable mit einem Typ-Wildcard deklariert wird, kann ihr eine Instanz eines beliebigen konkreten Typs zugewiesen werden, der den Anforderungen der Wildcard entspricht. <answer> <question> Was passiert, wenn eine Variable mit einem Typ-Wildcard deklariert wird? <question>"
"Schließlich ist es in JAVA auch noch möglich, Variablen generisch zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Allerdings geht das, da eine Variable anders als eine Klasse oder Methoden keinen neuen Sichtbarkeitsbereich definiert, nur mit anonymen Typvariablen, also Wildcards. Man beachte jedoch, dass eine solche Variablendeklaration, genau wie eine generische Methodendefinition, keinen neuen Typ einführt (siehe Fußnote 72); vielmehr handelt es sich bei dem durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzten Typ selbst um einen konkreten Typ. Der per ""Wildcard"" deklarierten Variable ""liste"" können also Listen beliebigen Elementtyps zugewiesen werden, einfach weil ""List<?>"" (unter den in Abschnitt 43.2 genannten Einschränkungen) Supertyp aller Instanziierungen von ""List<T>"" ist.","<answer> Nein, generische Variablendeklarationen führen keinen neuen Typ ein. Der durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzte Typ ist ein konkreter Typ. <answer> <question> Führen generische Variablendeklarationen einen neuen Typ ein? <question>"
"Schließlich ist es in JAVA auch noch möglich, Variablen generisch zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Allerdings geht das, da eine Variable anders als eine Klasse oder Methoden keinen neuen Sichtbarkeitsbereich definiert, nur mit anonymen Typvariablen, also Wildcards. Man beachte jedoch, dass eine solche Variablendeklaration, genau wie eine generische Methodendefinition, keinen neuen Typ einführt (siehe Fußnote 72); vielmehr handelt es sich bei dem durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzten Typ selbst um einen konkreten Typ. Der per ""Wildcard"" deklarierten Variable ""liste"" können also Listen beliebigen Elementtyps zugewiesen werden, einfach weil ""List<?>"" (unter den in Abschnitt 43.2 genannten Einschränkungen) Supertyp aller Instanziierungen von ""List<T>"" ist.","<answer> Generische Variablen mit Typ-Wildcards unterliegen den im Abschnitt 43.2 genannten Einschränkungen, insbesondere in Bezug auf die Verwendung von Wildcards mit oberen und unteren Schranken. <answer> <question> Welche Einschränkungen gelten für generische Variablen mit Typ-Wildcards? <question>"
"Eine weitere nützliche Collection-Klasse wird durch SortedCollection implementiert. Es handelt sich dabei um eine Subklasse von OrderedCollection, bei der die Reihenfolge der Elemente nicht von außen, also durch die Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt wird, sondern von innen, genauer durch eine Qualität der eingefügten Objekte. Zwischenobjekte der Klasse SortedCollection setzt man ein, wenn man die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge haben möchte, wie z. B. die Kinder einer Person in der Namensfolge, und zwar unabhängig davon, in welcher Reihenfolge sie der Collection hinzugefügt wurden. Voraussetzung dafür, dass die Elemente einer SortedCollection sortiert werden können, ist, dass sie verglichen werden können, dass also die (binäre) Methode <= (für kleiner gleich) darauf definiert ist. So liefert beispielsweise mit #(1 2 3) das gewünschte Ergebnis.
Wenn die Elemente, die in eine sortierte Collection eingefügt werden sollen, keine Größen sind und insbesondere den Vergleich <= nicht implementieren, dann ist es immer noch möglich, für eine neue Instanz einer SortedCollection einen sogenannten Sortierblock zu spezifizieren, der zwei formale Parameter hat und dessen Auswertung zurückliefert, ob der erste tatsächlich e Parameter kleiner oder gleich dem zweiten ist.
Eine Menge von Objekten aus einer Collection kann in eine andere übertragen werden, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z. B. asSet, das doppelte Elemente entfernt. Diese Konvertierungsmethoden sind in Collection implementiert, analog zu asBag und asOrderedCollection oben. Besonders interessant sind natürlich Konvertierungen in Collections, die strengere Bedingungen stellen, z. B. asSet und asSortedCollection.
Bitte beachten Sie jedoch, dass eine nachträgliche Änderung der Attributwerte, die zum Vergleich der Objekte für die Sortierung herangezogen wurden, keine automatische Änderung der Reihenfolge bewirkt, selbst wenn dies eigentlich notwendig wäre.","<answer> Eine SortedCollection ist eine Collection-Klasse in SMALLTALK, die eine Subklasse von OrderedCollection ist. Im Gegensatz zu anderen Collection-Klassen wird die Reihenfolge der Elemente in einer SortedCollection nicht von außen, durch Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt. Stattdessen wird die Reihenfolge von innen durch eine Qualität der eingefügten Objekte bestimmt. Dies ermöglicht es, die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge zu halten, unabhängig von der Reihenfolge, in der sie der Collection hinzugefügt wurden. <answer> <question> Was ist eine SortedCollection in SMALLTALK, und wie unterscheidet sie sich von anderen Collection-Klassen? <question>"
"Eine weitere nützliche Collection-Klasse wird durch SortedCollection implementiert. Es handelt sich dabei um eine Subklasse von OrderedCollection, bei der die Reihenfolge der Elemente nicht von außen, also durch die Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt wird, sondern von innen, genauer durch eine Qualität der eingefügten Objekte. Zwischenobjekte der Klasse SortedCollection setzt man ein, wenn man die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge haben möchte, wie z. B. die Kinder einer Person in der Namensfolge, und zwar unabhängig davon, in welcher Reihenfolge sie der Collection hinzugefügt wurden. Voraussetzung dafür, dass die Elemente einer SortedCollection sortiert werden können, ist, dass sie verglichen werden können, dass also die (binäre) Methode <= (für kleiner gleich) darauf definiert ist. So liefert beispielsweise mit #(1 2 3) das gewünschte Ergebnis.
Wenn die Elemente, die in eine sortierte Collection eingefügt werden sollen, keine Größen sind und insbesondere den Vergleich <= nicht implementieren, dann ist es immer noch möglich, für eine neue Instanz einer SortedCollection einen sogenannten Sortierblock zu spezifizieren, der zwei formale Parameter hat und dessen Auswertung zurückliefert, ob der erste tatsächlich e Parameter kleiner oder gleich dem zweiten ist.
Eine Menge von Objekten aus einer Collection kann in eine andere übertragen werden, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z. B. asSet, das doppelte Elemente entfernt. Diese Konvertierungsmethoden sind in Collection implementiert, analog zu asBag und asOrderedCollection oben. Besonders interessant sind natürlich Konvertierungen in Collections, die strengere Bedingungen stellen, z. B. asSet und asSortedCollection.
Bitte beachten Sie jedoch, dass eine nachträgliche Änderung der Attributwerte, die zum Vergleich der Objekte für die Sortierung herangezogen wurden, keine automatische Änderung der Reihenfolge bewirkt, selbst wenn dies eigentlich notwendig wäre.","<answer> Damit die Elemente einer SortedCollection sortiert werden können, müssen sie vergleichbar sein, dh die Methode <= (für kleiner gleich) muss für die Elemente definiert sein. Dies ermöglicht es, die Elemente aufsteigend zu sortieren. <answer> <question> Welche Voraussetzungen müssen erfüllt sein, damit die Elemente einer SortedCollection sortiert werden können? <question>"
"Eine weitere nützliche Collection-Klasse wird durch SortedCollection implementiert. Es handelt sich dabei um eine Subklasse von OrderedCollection, bei der die Reihenfolge der Elemente nicht von außen, also durch die Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt wird, sondern von innen, genauer durch eine Qualität der eingefügten Objekte. Zwischenobjekte der Klasse SortedCollection setzt man ein, wenn man die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge haben möchte, wie z. B. die Kinder einer Person in der Namensfolge, und zwar unabhängig davon, in welcher Reihenfolge sie der Collection hinzugefügt wurden. Voraussetzung dafür, dass die Elemente einer SortedCollection sortiert werden können, ist, dass sie verglichen werden können, dass also die (binäre) Methode <= (für kleiner gleich) darauf definiert ist. So liefert beispielsweise mit #(1 2 3) das gewünschte Ergebnis.
Wenn die Elemente, die in eine sortierte Collection eingefügt werden sollen, keine Größen sind und insbesondere den Vergleich <= nicht implementieren, dann ist es immer noch möglich, für eine neue Instanz einer SortedCollection einen sogenannten Sortierblock zu spezifizieren, der zwei formale Parameter hat und dessen Auswertung zurückliefert, ob der erste tatsächlich e Parameter kleiner oder gleich dem zweiten ist.
Eine Menge von Objekten aus einer Collection kann in eine andere übertragen werden, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z. B. asSet, das doppelte Elemente entfernt. Diese Konvertierungsmethoden sind in Collection implementiert, analog zu asBag und asOrderedCollection oben. Besonders interessant sind natürlich Konvertierungen in Collections, die strengere Bedingungen stellen, z. B. asSet und asSortedCollection.
Bitte beachten Sie jedoch, dass eine nachträgliche Änderung der Attributwerte, die zum Vergleich der Objekte für die Sortierung herangezogen wurden, keine automatische Änderung der Reihenfolge bewirkt, selbst wenn dies eigentlich notwendig wäre.","<answer> Ein Sortierblock ist eine Funktion, die zwei formale Parameter hat und zurückliefert, ob der erste Parameter kleiner oder gleich dem zweiten ist. In einer SortedCollection kann ein Sortierblock angegeben werden, wenn die Elemente keine Größen sind oder keinen natürlichen Vergleich unterstützen. Der Sortierblock wird verwendet, um die Elemente zu vergleichen und die Reihenfolge in der SortedCollection festzulegen. Wenn kein Sortierblock angegeben wird, wird ein Standardsortierblock verwendet. <answer> <question> Was ist ein Sortierblock in einer SortedCollection, und wie wird er verwendet? <question>"
"Eine weitere nützliche Collection-Klasse wird durch SortedCollection implementiert. Es handelt sich dabei um eine Subklasse von OrderedCollection, bei der die Reihenfolge der Elemente nicht von außen, also durch die Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt wird, sondern von innen, genauer durch eine Qualität der eingefügten Objekte. Zwischenobjekte der Klasse SortedCollection setzt man ein, wenn man die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge haben möchte, wie z. B. die Kinder einer Person in der Namensfolge, und zwar unabhängig davon, in welcher Reihenfolge sie der Collection hinzugefügt wurden. Voraussetzung dafür, dass die Elemente einer SortedCollection sortiert werden können, ist, dass sie verglichen werden können, dass also die (binäre) Methode <= (für kleiner gleich) darauf definiert ist. So liefert beispielsweise mit #(1 2 3) das gewünschte Ergebnis.
Wenn die Elemente, die in eine sortierte Collection eingefügt werden sollen, keine Größen sind und insbesondere den Vergleich <= nicht implementieren, dann ist es immer noch möglich, für eine neue Instanz einer SortedCollection einen sogenannten Sortierblock zu spezifizieren, der zwei formale Parameter hat und dessen Auswertung zurückliefert, ob der erste tatsächlich e Parameter kleiner oder gleich dem zweiten ist.
Eine Menge von Objekten aus einer Collection kann in eine andere übertragen werden, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z. B. asSet, das doppelte Elemente entfernt. Diese Konvertierungsmethoden sind in Collection implementiert, analog zu asBag und asOrderedCollection oben. Besonders interessant sind natürlich Konvertierungen in Collections, die strengere Bedingungen stellen, z. B. asSet und asSortedCollection.
Bitte beachten Sie jedoch, dass eine nachträgliche Änderung der Attributwerte, die zum Vergleich der Objekte für die Sortierung herangezogen wurden, keine automatische Änderung der Reihenfolge bewirkt, selbst wenn dies eigentlich notwendig wäre.","<answer> Eine Menge von Objekten aus einer Collection kann in eine andere übertragen werden, indem Konvertierungsmethoden wie asSet oder asSortedCollection verwendet werden. Dies ist nützlich, um die Eigenschaften der Ziel-Collection zu berücksichtigen, z. B. doppelte Elemente zu entfernen oder die Elemente zu sortieren. Es ermöglicht auch die Umwandlung von Collections in Collections mit strengeren Bedingungen, was je nach Anwendungsfall nützlich sein kann. <answer> <question> Wie können Objekte von einer Collection in eine andere übertragen werden, und warum kann dies nützlich sein? <question>"
"Eine weitere nützliche Collection-Klasse wird durch SortedCollection implementiert. Es handelt sich dabei um eine Subklasse von OrderedCollection, bei der die Reihenfolge der Elemente nicht von außen, also durch die Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt wird, sondern von innen, genauer durch eine Qualität der eingefügten Objekte. Zwischenobjekte der Klasse SortedCollection setzt man ein, wenn man die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge haben möchte, wie z. B. die Kinder einer Person in der Namensfolge, und zwar unabhängig davon, in welcher Reihenfolge sie der Collection hinzugefügt wurden. Voraussetzung dafür, dass die Elemente einer SortedCollection sortiert werden können, ist, dass sie verglichen werden können, dass also die (binäre) Methode <= (für kleiner gleich) darauf definiert ist. So liefert beispielsweise mit #(1 2 3) das gewünschte Ergebnis.
Wenn die Elemente, die in eine sortierte Collection eingefügt werden sollen, keine Größen sind und insbesondere den Vergleich <= nicht implementieren, dann ist es immer noch möglich, für eine neue Instanz einer SortedCollection einen sogenannten Sortierblock zu spezifizieren, der zwei formale Parameter hat und dessen Auswertung zurückliefert, ob der erste tatsächlich e Parameter kleiner oder gleich dem zweiten ist.
Eine Menge von Objekten aus einer Collection kann in eine andere übertragen werden, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z. B. asSet, das doppelte Elemente entfernt. Diese Konvertierungsmethoden sind in Collection implementiert, analog zu asBag und asOrderedCollection oben. Besonders interessant sind natürlich Konvertierungen in Collections, die strengere Bedingungen stellen, z. B. asSet und asSortedCollection.
Bitte beachten Sie jedoch, dass eine nachträgliche Änderung der Attributwerte, die zum Vergleich der Objekte für die Sortierung herangezogen wurden, keine automatische Änderung der Reihenfolge bewirkt, selbst wenn dies eigentlich notwendig wäre.","<answer> Wenn Sie die Attributwerte von Objekten in einer SortedCollection nachträglich ändern, führt dies nicht automatisch zu einer Änderung der Reihenfolge der Elemente in der SortedCollection. Dies gilt selbst dann, wenn eine Änderung der Reihenfolge erforderlich wäre. Sie müssen sicherstellen, dass die Sortierung erneut durchgeführt wird, um die korrekte Reihenfolge beizubehalten. <answer> <question> Was sollten Sie beachten, wenn Sie die Attributwerte von Objekten in einer SortedCollection ändern? <question>"
"Da die meisten von Ihnen wahrscheinlich nie beruflich mit SMALLTALK programmieren werden, werden wir uns in dieser und der nächsten Kurseinheit anderen objektorientierten Programmiersprachen zuwenden. Dabei wird JAVA den größten Raum einnehmen. Einerseits ist JAVA immer noch die am weitesten verbreitete objektorientierte Programmiersprache, und andererseits erlaubt es viele Parallelen zu SMALLTALK, was eine gute Brücke zu anderen Programmiersprachen schafft. Aus theoretischer Sicht nimmt JAVA jedoch keine besondere Position ein, und sein Erfolg war wahrscheinlich eher auf das Internet zurückzuführen (JAVA hatte zuvor die Rolle, die heute JAVASCRIPT hat), als auf ein besonders geniales Sprachdesign.
Aus der Ferne betrachtet ist JAVA eine Mischung aus SMALLTALK und C++. Von C++ wurden weite Teile der Syntax und der statischen Typüberprüfung übernommen sowie der eher klassisch prozedurale Charakter (Methodenaufrufe anstelle von Nachrichtenversand). Von SMALLTALK übernahm es die umfassende Objektorientierung (es gibt keinen Code außerhalb von Klassen), die Einfachvererbung sowie die Garbage Collection (um nur die wichtigsten Punkte zu nennen). Wenn Sie jedoch genauer verstehen möchten, was JAVA ist und warum es so ist, wie es ist, sollten Sie einen Blick in seine Geschichte werfen. Ich empfehle dringend, ""The Long Strange Trip to Java"" von PATRICK NAUGHTON zu lesen; danach wird Ihnen wahrscheinlich einiges klarer sein.","<answer> In den kommenden Kurseinheiten wird JAVA behandelt, da es immer noch die am weitesten verbreitete objektorientierte Programmiersprache ist und viele Parallelen zu SMALLTALK aufweist, was den Übergang zu anderen Programmiersprachen erleichtert. Es ist jedoch wichtig zu beachten, dass JAVA aus theoretischer Sicht keine besondere Position einnimmt, und sein Erfolg war wahrscheinlich eher auf das Internet zurückzuführen. <answer> <question> Warum wird in den kommenden Kurseinheiten JAVA behandelt? <question>"
"Da die meisten von Ihnen wahrscheinlich nie beruflich mit SMALLTALK programmieren werden, werden wir uns in dieser und der nächsten Kurseinheit anderen objektorientierten Programmiersprachen zuwenden. Dabei wird JAVA den größten Raum einnehmen. Einerseits ist JAVA immer noch die am weitesten verbreitete objektorientierte Programmiersprache, und andererseits erlaubt es viele Parallelen zu SMALLTALK, was eine gute Brücke zu anderen Programmiersprachen schafft. Aus theoretischer Sicht nimmt JAVA jedoch keine besondere Position ein, und sein Erfolg war wahrscheinlich eher auf das Internet zurückzuführen (JAVA hatte zuvor die Rolle, die heute JAVASCRIPT hat), als auf ein besonders geniales Sprachdesign.
Aus der Ferne betrachtet ist JAVA eine Mischung aus SMALLTALK und C++. Von C++ wurden weite Teile der Syntax und der statischen Typüberprüfung übernommen sowie der eher klassisch prozedurale Charakter (Methodenaufrufe anstelle von Nachrichtenversand). Von SMALLTALK übernahm es die umfassende Objektorientierung (es gibt keinen Code außerhalb von Klassen), die Einfachvererbung sowie die Garbage Collection (um nur die wichtigsten Punkte zu nennen). Wenn Sie jedoch genauer verstehen möchten, was JAVA ist und warum es so ist, wie es ist, sollten Sie einen Blick in seine Geschichte werfen. Ich empfehle dringend, ""The Long Strange Trip to Java"" von PATRICK NAUGHTON zu lesen; danach wird Ihnen wahrscheinlich einiges klarer sein.","<answer> In JAVA wurden weite Teile der Syntax und der statischen Typüberprüfung von C++ übernommen. Außerdem wurde der eher klassisch prozedurale Charakter von C++ beibehalten, wobei Methodenaufrufe anstelle von Nachrichtenversand verwendet werden. Von SMALLTALK wurden die umfassende Objektorientierung (es gibt keinen Code außerhalb von Klassen), die Einfachvererbung sowie die Garbage Collection übernommen. <answer> <question> Welche Merkmale von C++ und SMALLTALK wurden in JAVA übernommen? <question>"
"In Bezug auf verhaltensbasiertes Subtyping haben die Arbeiten von Barbara Liskov und Jeannette Wing die größte Bekanntheit erlangt. Tatsächlich ist das sogenannte Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) eines der am häufigsten diskutierten Themen im Zusammenhang mit Subtyping, daher sollte es hier ebenfalls behandelt werden. Ohne die Verdienste der beiden schmälern zu wollen, sollte jedoch beachtet werden, dass die Anerkennung dieser Prinzipien nicht ausschließlich auf ihre Arbeit beschränkt ist. Es gab frühere Arbeiten, die ebenfalls Anerkennung verdienen, und außerdem ist das LSP, wie Sie noch sehen werden, zu streng formuliert und schließt nützliche und praxisrelevante Fälle des verhaltensbasierten Subtypings aus.
Der historische Hintergrund des Liskov-Substitutionsprinzips bestand darin, eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen zu finden. Wie wir bereits in Kapitel 26 (Einheit 3) festgestellt hatten, reicht es in den meisten Programmiersprachen aus, wenn ein Typ B deklariert, ein Subtyp eines Typs A zu sein, damit die Zuweisungskompatibilität von B nach A festgestellt werden kann. Hierbei war es jedoch erforderlich, dass die Eigenschaften von A auf B übertragen (vererbt) wurden und dabei die Regeln für die ko- bzw. kontravariante Neudeklaration von Parametertypen eingehalten wurden. Dies wird im Allgemeinen durch die Sprachdefinition und den Compiler sichergestellt.
Das verhaltensbezogene Subtyping geht über die syntaktische Subtypenbeziehung hinaus, die sich auf die Kontrolle der Parametertypen beschränkt, und fordert stattdessen, dass sich Objekte eines Subtyps und seines Supertyps gleich verhalten sollten. Dies sollte für jeden erkennbar sein, der das Objekt oder ein beliebiges Programm, das es verwendet, betrachtet. Diese Forderung kulminiert in der Regel als ""Subtype Requirement"": ""Lassen Sie φ(x) eine über Objekte x des Typs T bewiesene Eigenschaft sein. Dann sollte φ(y) für Objekte y des Typs S wahr sein, wobei S ein Subtyp von T ist."" Eine deutsche Paraphrase dieser Idee wurde bereits im Abschnitt 26.1 gegeben.
Diese Definition weist mehrere problematische Aspekte auf: Da sie die Subtypenbeziehung definiert, wird davon ausgegangen, dass x genau vom Typ T und y genau vom Typ S ist. Dies bedeutet insbesondere, dass x und y keine Objekte von Subtypen von T bzw. S sein können. Daher ist diese Definition nicht auf abstrakte Typen und Interfaces anwendbar. Die Aussage ist unabhängig von einem konkreten Gebrauch der Objekte. Wie im Abschnitt 54.5 näher erläutert wird, kann Substituierbarkeit in einem bestimmten Kontext durchaus existieren, selbst wenn die Typen nach obiger Definition nicht substituierbar sind. In einem solchen Fall könnten die Anforderungen in einem Interfacetypen festgehalten werden, der nur die im Kontext benötigten Eigenschaften spezifiziert. Dieser Typ hat jedoch (gemäß Punkt 1) keine Objekte x. Die Aussage bezieht sich implizit auf alle möglichen Eigenschaften (Prädikate) φ, was bedeutet, dass alle Eigenschaften von T auch für S gelten sollen. Dies stellt die Idee des Subtypings in Frage, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Dies steht im Widerspruch zur eigentlichen Absicht des Subtypings: Wenn ein Objekt keine zusätzlichen Funktionen bietet, warum sollte man es dann überhaupt verwenden?
Es ist jedoch zu beachten, dass die Bedingung in Punkt 3 möglicherweise abgeschwächt werden kann, indem sie sich auf das Verhalten des Programms bezieht und sicherstellt, dass es immer noch seinen beabsichtigten Zweck erfüllt, d.h., seiner Spezifikation genügt. Dies unterscheidet sich jedoch von dem, was im Prinzip ausgedrückt wird.
Liskov und Wing definieren zunächst eine Subtypenbeziehung zwischen S und T, die das oben genannte Subtype Requirement erfüllt. Diese Beziehung wird durch folgende Regeln beschrieben: Überschreibende Methoden in S übernehmen das Verhalten der überschriebenen Methoden in T. Dies umfasst: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode (die Typen der geworfenen Ausnahmen sind entweder Subtypen der Typen der Ausnahmen der überschriebenen Methode oder es werden überhaupt keine Ausnahmen ausgelöst; es dürfen keine zusätzlichen Ausnahmen auftreten). d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T.
Es ist zu beachten, dass die semantischen Regeln 1.d und 1.e die syntaktischen Regeln 1.a bis 1.c implizieren. In typlosen Sprachen wie Smalltalk würden die entsprechenden Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert, und die Menge der ausgelösten Ausnahmen wäre Teil der Nachbedingungen.
Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.
Dennoch bleibt das zu Beginn beschriebene Problem mit Aliasbildung und der Möglichkeit zusätzlicher Methodenaufrufe bestehen. Liskov und Wing identifizieren zwei Lösungen:
Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existiert (oder deren überschriebene, verhaltenskonforme Varianten), die denselben Effekt wie die zusätzliche Methode hat und vom Klienten des Objekts selbst oder von einem anderen Klienten, der jedoch das Objekt als denselben Typ sieht, durchgeführt werden kann. Diese Bedingung ist ziemlich restriktiv, da sie im Wesentlichen besagt, dass ein Subtyp lediglich Makros hinzufügen darf. Auf der anderen Seite ist die Einhaltung dieser Bedingung, wenn auch nicht automatisch, zumindest intuitiv einfacher nachzuweisen, was in der Praxis von großer Bedeutung ist.
Die zweite Lösung ist weniger restriktiv, aber in der Praxis schwerer nachzuweisen. Sie erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden (einschließlich der üblichen Vor- und Nachbedingungen) die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet. Dazu wäre eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Das Problem dabei ist jedoch, dass die Zustände eines Objekts nicht abstrakt existieren, sondern sich in der Belegung von Instanzvariablen manifestieren. Daher ergibt sich der Zustandsraum kombinatorisch (abzüglich der funktionalen Abhängigkeiten der Attribute). Um dies zu umgehen, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss.
Es ist wichtig zu beachten, dass die Einhaltung der ersten Lösung die Einhaltung der zweiten Lösung impliziert: Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.
Obwohl das Liskov-Substitutionsprinzip gut begründet ist, erweist es sich in der Praxis als zu restriktiv. Zum Beispiel könnte in einem Typ T eine Methode ""echo: i <Integer> ^Integer"" definiert werden, die den Eingabeparameter einfach ausgibt (die sogenannte Identitätsfunktion). In einem Subtyp S könnte diese Methode so überschrieben werden, dass sie beliebige Objekte entgegennimmt und sie unverändert zurückgibt: ""echo: i <Object> ^ Object"". Die Methode ist daher in ihrem Eingabeparameter kontravariant, aber nicht kovariant im Ausgabeparameter. Sie erfüllt somit nicht die Bedingungen des LSP. Dennoch kann ""echo:"" auf einem Objekt vom Typ S überall dort aufgerufen werden, wo es auf einem Objekt vom Typ T aufgerufen werden kann, ohne dass die Kovarianzregel des Ausgabeparameters verletzt wird. Das Liskov-Substitutionsprinzip stellt daher eine Typüberprüfung dar, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.","<answer> Das Liskov-Substitutionsprinzip (LSP) ist ein Prinzip im Zusammenhang mit Subtyping, das von Barbara Liskov und Jeannette Wing entwickelt wurde. Es besagt, dass ein Subtyp (z. B. eine abgeleitete Klasse) eines Typs (z. B. eine Basisklasse) sich so verhalten sollte, dass er anstelle des Supertyps (der Basisklasse) in jedem Programm oder Kontext verwendet werden kann, ohne die Korrektheit des Programms zu gefährden. Das LSP ist wichtig, um sicherzustellen, dass Subtypen die Spezifikationen und das Verhalten des Supertyps beibehalten und korrekt verwenden. <answer> <question> Was ist das Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) und warum ist es wichtig? <question>"
"In Bezug auf verhaltensbasiertes Subtyping haben die Arbeiten von Barbara Liskov und Jeannette Wing die größte Bekanntheit erlangt. Tatsächlich ist das sogenannte Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) eines der am häufigsten diskutierten Themen im Zusammenhang mit Subtyping, daher sollte es hier ebenfalls behandelt werden. Ohne die Verdienste der beiden schmälern zu wollen, sollte jedoch beachtet werden, dass die Anerkennung dieser Prinzipien nicht ausschließlich auf ihre Arbeit beschränkt ist. Es gab frühere Arbeiten, die ebenfalls Anerkennung verdienen, und außerdem ist das LSP, wie Sie noch sehen werden, zu streng formuliert und schließt nützliche und praxisrelevante Fälle des verhaltensbasierten Subtypings aus.
Der historische Hintergrund des Liskov-Substitutionsprinzips bestand darin, eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen zu finden. Wie wir bereits in Kapitel 26 (Einheit 3) festgestellt hatten, reicht es in den meisten Programmiersprachen aus, wenn ein Typ B deklariert, ein Subtyp eines Typs A zu sein, damit die Zuweisungskompatibilität von B nach A festgestellt werden kann. Hierbei war es jedoch erforderlich, dass die Eigenschaften von A auf B übertragen (vererbt) wurden und dabei die Regeln für die ko- bzw. kontravariante Neudeklaration von Parametertypen eingehalten wurden. Dies wird im Allgemeinen durch die Sprachdefinition und den Compiler sichergestellt.
Das verhaltensbezogene Subtyping geht über die syntaktische Subtypenbeziehung hinaus, die sich auf die Kontrolle der Parametertypen beschränkt, und fordert stattdessen, dass sich Objekte eines Subtyps und seines Supertyps gleich verhalten sollten. Dies sollte für jeden erkennbar sein, der das Objekt oder ein beliebiges Programm, das es verwendet, betrachtet. Diese Forderung kulminiert in der Regel als ""Subtype Requirement"": ""Lassen Sie φ(x) eine über Objekte x des Typs T bewiesene Eigenschaft sein. Dann sollte φ(y) für Objekte y des Typs S wahr sein, wobei S ein Subtyp von T ist."" Eine deutsche Paraphrase dieser Idee wurde bereits im Abschnitt 26.1 gegeben.
Diese Definition weist mehrere problematische Aspekte auf: Da sie die Subtypenbeziehung definiert, wird davon ausgegangen, dass x genau vom Typ T und y genau vom Typ S ist. Dies bedeutet insbesondere, dass x und y keine Objekte von Subtypen von T bzw. S sein können. Daher ist diese Definition nicht auf abstrakte Typen und Interfaces anwendbar. Die Aussage ist unabhängig von einem konkreten Gebrauch der Objekte. Wie im Abschnitt 54.5 näher erläutert wird, kann Substituierbarkeit in einem bestimmten Kontext durchaus existieren, selbst wenn die Typen nach obiger Definition nicht substituierbar sind. In einem solchen Fall könnten die Anforderungen in einem Interfacetypen festgehalten werden, der nur die im Kontext benötigten Eigenschaften spezifiziert. Dieser Typ hat jedoch (gemäß Punkt 1) keine Objekte x. Die Aussage bezieht sich implizit auf alle möglichen Eigenschaften (Prädikate) φ, was bedeutet, dass alle Eigenschaften von T auch für S gelten sollen. Dies stellt die Idee des Subtypings in Frage, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Dies steht im Widerspruch zur eigentlichen Absicht des Subtypings: Wenn ein Objekt keine zusätzlichen Funktionen bietet, warum sollte man es dann überhaupt verwenden?
Es ist jedoch zu beachten, dass die Bedingung in Punkt 3 möglicherweise abgeschwächt werden kann, indem sie sich auf das Verhalten des Programms bezieht und sicherstellt, dass es immer noch seinen beabsichtigten Zweck erfüllt, d.h., seiner Spezifikation genügt. Dies unterscheidet sich jedoch von dem, was im Prinzip ausgedrückt wird.
Liskov und Wing definieren zunächst eine Subtypenbeziehung zwischen S und T, die das oben genannte Subtype Requirement erfüllt. Diese Beziehung wird durch folgende Regeln beschrieben: Überschreibende Methoden in S übernehmen das Verhalten der überschriebenen Methoden in T. Dies umfasst: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode (die Typen der geworfenen Ausnahmen sind entweder Subtypen der Typen der Ausnahmen der überschriebenen Methode oder es werden überhaupt keine Ausnahmen ausgelöst; es dürfen keine zusätzlichen Ausnahmen auftreten). d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T.
Es ist zu beachten, dass die semantischen Regeln 1.d und 1.e die syntaktischen Regeln 1.a bis 1.c implizieren. In typlosen Sprachen wie Smalltalk würden die entsprechenden Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert, und die Menge der ausgelösten Ausnahmen wäre Teil der Nachbedingungen.
Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.
Dennoch bleibt das zu Beginn beschriebene Problem mit Aliasbildung und der Möglichkeit zusätzlicher Methodenaufrufe bestehen. Liskov und Wing identifizieren zwei Lösungen:
Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existiert (oder deren überschriebene, verhaltenskonforme Varianten), die denselben Effekt wie die zusätzliche Methode hat und vom Klienten des Objekts selbst oder von einem anderen Klienten, der jedoch das Objekt als denselben Typ sieht, durchgeführt werden kann. Diese Bedingung ist ziemlich restriktiv, da sie im Wesentlichen besagt, dass ein Subtyp lediglich Makros hinzufügen darf. Auf der anderen Seite ist die Einhaltung dieser Bedingung, wenn auch nicht automatisch, zumindest intuitiv einfacher nachzuweisen, was in der Praxis von großer Bedeutung ist.
Die zweite Lösung ist weniger restriktiv, aber in der Praxis schwerer nachzuweisen. Sie erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden (einschließlich der üblichen Vor- und Nachbedingungen) die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet. Dazu wäre eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Das Problem dabei ist jedoch, dass die Zustände eines Objekts nicht abstrakt existieren, sondern sich in der Belegung von Instanzvariablen manifestieren. Daher ergibt sich der Zustandsraum kombinatorisch (abzüglich der funktionalen Abhängigkeiten der Attribute). Um dies zu umgehen, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss.
Es ist wichtig zu beachten, dass die Einhaltung der ersten Lösung die Einhaltung der zweiten Lösung impliziert: Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.
Obwohl das Liskov-Substitutionsprinzip gut begründet ist, erweist es sich in der Praxis als zu restriktiv. Zum Beispiel könnte in einem Typ T eine Methode ""echo: i <Integer> ^Integer"" definiert werden, die den Eingabeparameter einfach ausgibt (die sogenannte Identitätsfunktion). In einem Subtyp S könnte diese Methode so überschrieben werden, dass sie beliebige Objekte entgegennimmt und sie unverändert zurückgibt: ""echo: i <Object> ^ Object"". Die Methode ist daher in ihrem Eingabeparameter kontravariant, aber nicht kovariant im Ausgabeparameter. Sie erfüllt somit nicht die Bedingungen des LSP. Dennoch kann ""echo:"" auf einem Objekt vom Typ S überall dort aufgerufen werden, wo es auf einem Objekt vom Typ T aufgerufen werden kann, ohne dass die Kovarianzregel des Ausgabeparameters verletzt wird. Das Liskov-Substitutionsprinzip stellt daher eine Typüberprüfung dar, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.","<answer> Es wird darauf hingewiesen, dass das Liskov-Substitutionsprinzip nicht ausschließlich auf die Arbeiten von Barbara Liskov und Jeannette Wing beschränkt ist, um anzuerkennen, dass es frühere Arbeiten gab, die ebenfalls zur Entwicklung dieses Prinzips beigetragen haben. Das Prinzip selbst ist eine wichtige Konzeption in Bezug auf Subtyping und geht über die Beiträge einzelner Personen hinaus. <answer> <question> Warum wird darauf hingewiesen, dass das Liskov-Substitutionsprinzip nicht ausschließlich auf die Arbeiten von Barbara Liskov und Jeannette Wing beschränkt ist? <question>"
"In Bezug auf verhaltensbasiertes Subtyping haben die Arbeiten von Barbara Liskov und Jeannette Wing die größte Bekanntheit erlangt. Tatsächlich ist das sogenannte Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) eines der am häufigsten diskutierten Themen im Zusammenhang mit Subtyping, daher sollte es hier ebenfalls behandelt werden. Ohne die Verdienste der beiden schmälern zu wollen, sollte jedoch beachtet werden, dass die Anerkennung dieser Prinzipien nicht ausschließlich auf ihre Arbeit beschränkt ist. Es gab frühere Arbeiten, die ebenfalls Anerkennung verdienen, und außerdem ist das LSP, wie Sie noch sehen werden, zu streng formuliert und schließt nützliche und praxisrelevante Fälle des verhaltensbasierten Subtypings aus.
Der historische Hintergrund des Liskov-Substitutionsprinzips bestand darin, eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen zu finden. Wie wir bereits in Kapitel 26 (Einheit 3) festgestellt hatten, reicht es in den meisten Programmiersprachen aus, wenn ein Typ B deklariert, ein Subtyp eines Typs A zu sein, damit die Zuweisungskompatibilität von B nach A festgestellt werden kann. Hierbei war es jedoch erforderlich, dass die Eigenschaften von A auf B übertragen (vererbt) wurden und dabei die Regeln für die ko- bzw. kontravariante Neudeklaration von Parametertypen eingehalten wurden. Dies wird im Allgemeinen durch die Sprachdefinition und den Compiler sichergestellt.
Das verhaltensbezogene Subtyping geht über die syntaktische Subtypenbeziehung hinaus, die sich auf die Kontrolle der Parametertypen beschränkt, und fordert stattdessen, dass sich Objekte eines Subtyps und seines Supertyps gleich verhalten sollten. Dies sollte für jeden erkennbar sein, der das Objekt oder ein beliebiges Programm, das es verwendet, betrachtet. Diese Forderung kulminiert in der Regel als ""Subtype Requirement"": ""Lassen Sie φ(x) eine über Objekte x des Typs T bewiesene Eigenschaft sein. Dann sollte φ(y) für Objekte y des Typs S wahr sein, wobei S ein Subtyp von T ist."" Eine deutsche Paraphrase dieser Idee wurde bereits im Abschnitt 26.1 gegeben.
Diese Definition weist mehrere problematische Aspekte auf: Da sie die Subtypenbeziehung definiert, wird davon ausgegangen, dass x genau vom Typ T und y genau vom Typ S ist. Dies bedeutet insbesondere, dass x und y keine Objekte von Subtypen von T bzw. S sein können. Daher ist diese Definition nicht auf abstrakte Typen und Interfaces anwendbar. Die Aussage ist unabhängig von einem konkreten Gebrauch der Objekte. Wie im Abschnitt 54.5 näher erläutert wird, kann Substituierbarkeit in einem bestimmten Kontext durchaus existieren, selbst wenn die Typen nach obiger Definition nicht substituierbar sind. In einem solchen Fall könnten die Anforderungen in einem Interfacetypen festgehalten werden, der nur die im Kontext benötigten Eigenschaften spezifiziert. Dieser Typ hat jedoch (gemäß Punkt 1) keine Objekte x. Die Aussage bezieht sich implizit auf alle möglichen Eigenschaften (Prädikate) φ, was bedeutet, dass alle Eigenschaften von T auch für S gelten sollen. Dies stellt die Idee des Subtypings in Frage, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Dies steht im Widerspruch zur eigentlichen Absicht des Subtypings: Wenn ein Objekt keine zusätzlichen Funktionen bietet, warum sollte man es dann überhaupt verwenden?
Es ist jedoch zu beachten, dass die Bedingung in Punkt 3 möglicherweise abgeschwächt werden kann, indem sie sich auf das Verhalten des Programms bezieht und sicherstellt, dass es immer noch seinen beabsichtigten Zweck erfüllt, d.h., seiner Spezifikation genügt. Dies unterscheidet sich jedoch von dem, was im Prinzip ausgedrückt wird.
Liskov und Wing definieren zunächst eine Subtypenbeziehung zwischen S und T, die das oben genannte Subtype Requirement erfüllt. Diese Beziehung wird durch folgende Regeln beschrieben: Überschreibende Methoden in S übernehmen das Verhalten der überschriebenen Methoden in T. Dies umfasst: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode (die Typen der geworfenen Ausnahmen sind entweder Subtypen der Typen der Ausnahmen der überschriebenen Methode oder es werden überhaupt keine Ausnahmen ausgelöst; es dürfen keine zusätzlichen Ausnahmen auftreten). d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T.
Es ist zu beachten, dass die semantischen Regeln 1.d und 1.e die syntaktischen Regeln 1.a bis 1.c implizieren. In typlosen Sprachen wie Smalltalk würden die entsprechenden Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert, und die Menge der ausgelösten Ausnahmen wäre Teil der Nachbedingungen.
Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.
Dennoch bleibt das zu Beginn beschriebene Problem mit Aliasbildung und der Möglichkeit zusätzlicher Methodenaufrufe bestehen. Liskov und Wing identifizieren zwei Lösungen:
Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existiert (oder deren überschriebene, verhaltenskonforme Varianten), die denselben Effekt wie die zusätzliche Methode hat und vom Klienten des Objekts selbst oder von einem anderen Klienten, der jedoch das Objekt als denselben Typ sieht, durchgeführt werden kann. Diese Bedingung ist ziemlich restriktiv, da sie im Wesentlichen besagt, dass ein Subtyp lediglich Makros hinzufügen darf. Auf der anderen Seite ist die Einhaltung dieser Bedingung, wenn auch nicht automatisch, zumindest intuitiv einfacher nachzuweisen, was in der Praxis von großer Bedeutung ist.
Die zweite Lösung ist weniger restriktiv, aber in der Praxis schwerer nachzuweisen. Sie erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden (einschließlich der üblichen Vor- und Nachbedingungen) die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet. Dazu wäre eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Das Problem dabei ist jedoch, dass die Zustände eines Objekts nicht abstrakt existieren, sondern sich in der Belegung von Instanzvariablen manifestieren. Daher ergibt sich der Zustandsraum kombinatorisch (abzüglich der funktionalen Abhängigkeiten der Attribute). Um dies zu umgehen, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss.
Es ist wichtig zu beachten, dass die Einhaltung der ersten Lösung die Einhaltung der zweiten Lösung impliziert: Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.
Obwohl das Liskov-Substitutionsprinzip gut begründet ist, erweist es sich in der Praxis als zu restriktiv. Zum Beispiel könnte in einem Typ T eine Methode ""echo: i <Integer> ^Integer"" definiert werden, die den Eingabeparameter einfach ausgibt (die sogenannte Identitätsfunktion). In einem Subtyp S könnte diese Methode so überschrieben werden, dass sie beliebige Objekte entgegennimmt und sie unverändert zurückgibt: ""echo: i <Object> ^ Object"". Die Methode ist daher in ihrem Eingabeparameter kontravariant, aber nicht kovariant im Ausgabeparameter. Sie erfüllt somit nicht die Bedingungen des LSP. Dennoch kann ""echo:"" auf einem Objekt vom Typ S überall dort aufgerufen werden, wo es auf einem Objekt vom Typ T aufgerufen werden kann, ohne dass die Kovarianzregel des Ausgabeparameters verletzt wird. Das Liskov-Substitutionsprinzip stellt daher eine Typüberprüfung dar, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.","<answer> Das Liskov-Substitutionsprinzip (LSP) könnte zu streng formuliert sein, da es einige problematische Aspekte aufweist. Zum Beispiel geht es davon aus, dass Objekte genau die Typen T oder S haben, was nicht auf abstrakte Typen und Interfaces anwendbar ist. Außerdem verlangt es, dass alle Eigenschaften von T auch für S gelten, was im Widerspruch zur eigentlichen Absicht des Subtypings steht, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Daher könnte eine weniger strenge Formulierung des Prinzips notwendig sein. <answer> <question> Warum ist das Liskov-Substitutionsprinzip möglicherweise zu streng formuliert? <question>"
"In Bezug auf verhaltensbasiertes Subtyping haben die Arbeiten von Barbara Liskov und Jeannette Wing die größte Bekanntheit erlangt. Tatsächlich ist das sogenannte Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) eines der am häufigsten diskutierten Themen im Zusammenhang mit Subtyping, daher sollte es hier ebenfalls behandelt werden. Ohne die Verdienste der beiden schmälern zu wollen, sollte jedoch beachtet werden, dass die Anerkennung dieser Prinzipien nicht ausschließlich auf ihre Arbeit beschränkt ist. Es gab frühere Arbeiten, die ebenfalls Anerkennung verdienen, und außerdem ist das LSP, wie Sie noch sehen werden, zu streng formuliert und schließt nützliche und praxisrelevante Fälle des verhaltensbasierten Subtypings aus.
Der historische Hintergrund des Liskov-Substitutionsprinzips bestand darin, eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen zu finden. Wie wir bereits in Kapitel 26 (Einheit 3) festgestellt hatten, reicht es in den meisten Programmiersprachen aus, wenn ein Typ B deklariert, ein Subtyp eines Typs A zu sein, damit die Zuweisungskompatibilität von B nach A festgestellt werden kann. Hierbei war es jedoch erforderlich, dass die Eigenschaften von A auf B übertragen (vererbt) wurden und dabei die Regeln für die ko- bzw. kontravariante Neudeklaration von Parametertypen eingehalten wurden. Dies wird im Allgemeinen durch die Sprachdefinition und den Compiler sichergestellt.
Das verhaltensbezogene Subtyping geht über die syntaktische Subtypenbeziehung hinaus, die sich auf die Kontrolle der Parametertypen beschränkt, und fordert stattdessen, dass sich Objekte eines Subtyps und seines Supertyps gleich verhalten sollten. Dies sollte für jeden erkennbar sein, der das Objekt oder ein beliebiges Programm, das es verwendet, betrachtet. Diese Forderung kulminiert in der Regel als ""Subtype Requirement"": ""Lassen Sie φ(x) eine über Objekte x des Typs T bewiesene Eigenschaft sein. Dann sollte φ(y) für Objekte y des Typs S wahr sein, wobei S ein Subtyp von T ist."" Eine deutsche Paraphrase dieser Idee wurde bereits im Abschnitt 26.1 gegeben.
Diese Definition weist mehrere problematische Aspekte auf: Da sie die Subtypenbeziehung definiert, wird davon ausgegangen, dass x genau vom Typ T und y genau vom Typ S ist. Dies bedeutet insbesondere, dass x und y keine Objekte von Subtypen von T bzw. S sein können. Daher ist diese Definition nicht auf abstrakte Typen und Interfaces anwendbar. Die Aussage ist unabhängig von einem konkreten Gebrauch der Objekte. Wie im Abschnitt 54.5 näher erläutert wird, kann Substituierbarkeit in einem bestimmten Kontext durchaus existieren, selbst wenn die Typen nach obiger Definition nicht substituierbar sind. In einem solchen Fall könnten die Anforderungen in einem Interfacetypen festgehalten werden, der nur die im Kontext benötigten Eigenschaften spezifiziert. Dieser Typ hat jedoch (gemäß Punkt 1) keine Objekte x. Die Aussage bezieht sich implizit auf alle möglichen Eigenschaften (Prädikate) φ, was bedeutet, dass alle Eigenschaften von T auch für S gelten sollen. Dies stellt die Idee des Subtypings in Frage, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Dies steht im Widerspruch zur eigentlichen Absicht des Subtypings: Wenn ein Objekt keine zusätzlichen Funktionen bietet, warum sollte man es dann überhaupt verwenden?
Es ist jedoch zu beachten, dass die Bedingung in Punkt 3 möglicherweise abgeschwächt werden kann, indem sie sich auf das Verhalten des Programms bezieht und sicherstellt, dass es immer noch seinen beabsichtigten Zweck erfüllt, d.h., seiner Spezifikation genügt. Dies unterscheidet sich jedoch von dem, was im Prinzip ausgedrückt wird.
Liskov und Wing definieren zunächst eine Subtypenbeziehung zwischen S und T, die das oben genannte Subtype Requirement erfüllt. Diese Beziehung wird durch folgende Regeln beschrieben: Überschreibende Methoden in S übernehmen das Verhalten der überschriebenen Methoden in T. Dies umfasst: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode (die Typen der geworfenen Ausnahmen sind entweder Subtypen der Typen der Ausnahmen der überschriebenen Methode oder es werden überhaupt keine Ausnahmen ausgelöst; es dürfen keine zusätzlichen Ausnahmen auftreten). d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T.
Es ist zu beachten, dass die semantischen Regeln 1.d und 1.e die syntaktischen Regeln 1.a bis 1.c implizieren. In typlosen Sprachen wie Smalltalk würden die entsprechenden Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert, und die Menge der ausgelösten Ausnahmen wäre Teil der Nachbedingungen.
Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.
Dennoch bleibt das zu Beginn beschriebene Problem mit Aliasbildung und der Möglichkeit zusätzlicher Methodenaufrufe bestehen. Liskov und Wing identifizieren zwei Lösungen:
Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existiert (oder deren überschriebene, verhaltenskonforme Varianten), die denselben Effekt wie die zusätzliche Methode hat und vom Klienten des Objekts selbst oder von einem anderen Klienten, der jedoch das Objekt als denselben Typ sieht, durchgeführt werden kann. Diese Bedingung ist ziemlich restriktiv, da sie im Wesentlichen besagt, dass ein Subtyp lediglich Makros hinzufügen darf. Auf der anderen Seite ist die Einhaltung dieser Bedingung, wenn auch nicht automatisch, zumindest intuitiv einfacher nachzuweisen, was in der Praxis von großer Bedeutung ist.
Die zweite Lösung ist weniger restriktiv, aber in der Praxis schwerer nachzuweisen. Sie erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden (einschließlich der üblichen Vor- und Nachbedingungen) die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet. Dazu wäre eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Das Problem dabei ist jedoch, dass die Zustände eines Objekts nicht abstrakt existieren, sondern sich in der Belegung von Instanzvariablen manifestieren. Daher ergibt sich der Zustandsraum kombinatorisch (abzüglich der funktionalen Abhängigkeiten der Attribute). Um dies zu umgehen, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss.
Es ist wichtig zu beachten, dass die Einhaltung der ersten Lösung die Einhaltung der zweiten Lösung impliziert: Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.
Obwohl das Liskov-Substitutionsprinzip gut begründet ist, erweist es sich in der Praxis als zu restriktiv. Zum Beispiel könnte in einem Typ T eine Methode ""echo: i <Integer> ^Integer"" definiert werden, die den Eingabeparameter einfach ausgibt (die sogenannte Identitätsfunktion). In einem Subtyp S könnte diese Methode so überschrieben werden, dass sie beliebige Objekte entgegennimmt und sie unverändert zurückgibt: ""echo: i <Object> ^ Object"". Die Methode ist daher in ihrem Eingabeparameter kontravariant, aber nicht kovariant im Ausgabeparameter. Sie erfüllt somit nicht die Bedingungen des LSP. Dennoch kann ""echo:"" auf einem Objekt vom Typ S überall dort aufgerufen werden, wo es auf einem Objekt vom Typ T aufgerufen werden kann, ohne dass die Kovarianzregel des Ausgabeparameters verletzt wird. Das Liskov-Substitutionsprinzip stellt daher eine Typüberprüfung dar, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.","<answer> Es werden zwei Lösungen vorgeschlagen, um das Problem der Aliasbildung und zusätzlicher Methodenaufrufe zu lösen: Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existieren muss, die denselben Effekt wie die zusätzliche Methode hat. Die zweite Lösung erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet und erfordern eine Art Spezifikation endlicher Automaten, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. <answer> <question> Welche beiden Lösungen werden vorgeschlagen, um das Problem der Aliasbildung und zusätzlicher Methodenaufrufe zu lösen? <question>"
"In Bezug auf verhaltensbasiertes Subtyping haben die Arbeiten von Barbara Liskov und Jeannette Wing die größte Bekanntheit erlangt. Tatsächlich ist das sogenannte Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) eines der am häufigsten diskutierten Themen im Zusammenhang mit Subtyping, daher sollte es hier ebenfalls behandelt werden. Ohne die Verdienste der beiden schmälern zu wollen, sollte jedoch beachtet werden, dass die Anerkennung dieser Prinzipien nicht ausschließlich auf ihre Arbeit beschränkt ist. Es gab frühere Arbeiten, die ebenfalls Anerkennung verdienen, und außerdem ist das LSP, wie Sie noch sehen werden, zu streng formuliert und schließt nützliche und praxisrelevante Fälle des verhaltensbasierten Subtypings aus.
Der historische Hintergrund des Liskov-Substitutionsprinzips bestand darin, eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen zu finden. Wie wir bereits in Kapitel 26 (Einheit 3) festgestellt hatten, reicht es in den meisten Programmiersprachen aus, wenn ein Typ B deklariert, ein Subtyp eines Typs A zu sein, damit die Zuweisungskompatibilität von B nach A festgestellt werden kann. Hierbei war es jedoch erforderlich, dass die Eigenschaften von A auf B übertragen (vererbt) wurden und dabei die Regeln für die ko- bzw. kontravariante Neudeklaration von Parametertypen eingehalten wurden. Dies wird im Allgemeinen durch die Sprachdefinition und den Compiler sichergestellt.
Das verhaltensbezogene Subtyping geht über die syntaktische Subtypenbeziehung hinaus, die sich auf die Kontrolle der Parametertypen beschränkt, und fordert stattdessen, dass sich Objekte eines Subtyps und seines Supertyps gleich verhalten sollten. Dies sollte für jeden erkennbar sein, der das Objekt oder ein beliebiges Programm, das es verwendet, betrachtet. Diese Forderung kulminiert in der Regel als ""Subtype Requirement"": ""Lassen Sie φ(x) eine über Objekte x des Typs T bewiesene Eigenschaft sein. Dann sollte φ(y) für Objekte y des Typs S wahr sein, wobei S ein Subtyp von T ist."" Eine deutsche Paraphrase dieser Idee wurde bereits im Abschnitt 26.1 gegeben.
Diese Definition weist mehrere problematische Aspekte auf: Da sie die Subtypenbeziehung definiert, wird davon ausgegangen, dass x genau vom Typ T und y genau vom Typ S ist. Dies bedeutet insbesondere, dass x und y keine Objekte von Subtypen von T bzw. S sein können. Daher ist diese Definition nicht auf abstrakte Typen und Interfaces anwendbar. Die Aussage ist unabhängig von einem konkreten Gebrauch der Objekte. Wie im Abschnitt 54.5 näher erläutert wird, kann Substituierbarkeit in einem bestimmten Kontext durchaus existieren, selbst wenn die Typen nach obiger Definition nicht substituierbar sind. In einem solchen Fall könnten die Anforderungen in einem Interfacetypen festgehalten werden, der nur die im Kontext benötigten Eigenschaften spezifiziert. Dieser Typ hat jedoch (gemäß Punkt 1) keine Objekte x. Die Aussage bezieht sich implizit auf alle möglichen Eigenschaften (Prädikate) φ, was bedeutet, dass alle Eigenschaften von T auch für S gelten sollen. Dies stellt die Idee des Subtypings in Frage, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Dies steht im Widerspruch zur eigentlichen Absicht des Subtypings: Wenn ein Objekt keine zusätzlichen Funktionen bietet, warum sollte man es dann überhaupt verwenden?
Es ist jedoch zu beachten, dass die Bedingung in Punkt 3 möglicherweise abgeschwächt werden kann, indem sie sich auf das Verhalten des Programms bezieht und sicherstellt, dass es immer noch seinen beabsichtigten Zweck erfüllt, d.h., seiner Spezifikation genügt. Dies unterscheidet sich jedoch von dem, was im Prinzip ausgedrückt wird.
Liskov und Wing definieren zunächst eine Subtypenbeziehung zwischen S und T, die das oben genannte Subtype Requirement erfüllt. Diese Beziehung wird durch folgende Regeln beschrieben: Überschreibende Methoden in S übernehmen das Verhalten der überschriebenen Methoden in T. Dies umfasst: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode (die Typen der geworfenen Ausnahmen sind entweder Subtypen der Typen der Ausnahmen der überschriebenen Methode oder es werden überhaupt keine Ausnahmen ausgelöst; es dürfen keine zusätzlichen Ausnahmen auftreten). d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T.
Es ist zu beachten, dass die semantischen Regeln 1.d und 1.e die syntaktischen Regeln 1.a bis 1.c implizieren. In typlosen Sprachen wie Smalltalk würden die entsprechenden Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert, und die Menge der ausgelösten Ausnahmen wäre Teil der Nachbedingungen.
Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.
Dennoch bleibt das zu Beginn beschriebene Problem mit Aliasbildung und der Möglichkeit zusätzlicher Methodenaufrufe bestehen. Liskov und Wing identifizieren zwei Lösungen:
Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existiert (oder deren überschriebene, verhaltenskonforme Varianten), die denselben Effekt wie die zusätzliche Methode hat und vom Klienten des Objekts selbst oder von einem anderen Klienten, der jedoch das Objekt als denselben Typ sieht, durchgeführt werden kann. Diese Bedingung ist ziemlich restriktiv, da sie im Wesentlichen besagt, dass ein Subtyp lediglich Makros hinzufügen darf. Auf der anderen Seite ist die Einhaltung dieser Bedingung, wenn auch nicht automatisch, zumindest intuitiv einfacher nachzuweisen, was in der Praxis von großer Bedeutung ist.
Die zweite Lösung ist weniger restriktiv, aber in der Praxis schwerer nachzuweisen. Sie erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden (einschließlich der üblichen Vor- und Nachbedingungen) die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet. Dazu wäre eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Das Problem dabei ist jedoch, dass die Zustände eines Objekts nicht abstrakt existieren, sondern sich in der Belegung von Instanzvariablen manifestieren. Daher ergibt sich der Zustandsraum kombinatorisch (abzüglich der funktionalen Abhängigkeiten der Attribute). Um dies zu umgehen, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss.
Es ist wichtig zu beachten, dass die Einhaltung der ersten Lösung die Einhaltung der zweiten Lösung impliziert: Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.
Obwohl das Liskov-Substitutionsprinzip gut begründet ist, erweist es sich in der Praxis als zu restriktiv. Zum Beispiel könnte in einem Typ T eine Methode ""echo: i <Integer> ^Integer"" definiert werden, die den Eingabeparameter einfach ausgibt (die sogenannte Identitätsfunktion). In einem Subtyp S könnte diese Methode so überschrieben werden, dass sie beliebige Objekte entgegennimmt und sie unverändert zurückgibt: ""echo: i <Object> ^ Object"". Die Methode ist daher in ihrem Eingabeparameter kontravariant, aber nicht kovariant im Ausgabeparameter. Sie erfüllt somit nicht die Bedingungen des LSP. Dennoch kann ""echo:"" auf einem Objekt vom Typ S überall dort aufgerufen werden, wo es auf einem Objekt vom Typ T aufgerufen werden kann, ohne dass die Kovarianzregel des Ausgabeparameters verletzt wird. Das Liskov-Substitutionsprinzip stellt daher eine Typüberprüfung dar, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.","<answer> Das Liskov-Substitutionsprinzip (LSP) könnte in der Praxis als zu restriktiv angesehen werden, da es strengere Anforderungen an die Subtypen stellt und einige gültige Programme ablehnt. Zum Beispiel kann es vorkommen, dass ein Subtyp spezifische Methodenaufrufe erlaubt, die nicht im Supertyp vorhanden sind, aber dennoch in bestimmten Kontexten korrekt und sicher sind. Das LSP kann diese Fälle nicht berücksichtigen, was zu einer unnötigen Ablehnung von gültigen Programmen führen kann. <answer> <question> Warum könnte das Liskov-Substitutionsprinzip in der Praxis als zu restriktiv angesehen werden? <question>"
"In einem objektorientierten Programm repräsentieren Objekte nicht nur Literale (Abschnitt 1.2) und Variablen (Abschnitt 1.5), sondern auch Ausdrücke. Tatsächlich sind Literale und Variablen primitive Ausdrücke, die nicht aus anderen Ausdrücken zusammengesetzt sind. Um mit den Objekten jedoch Aktionen auszuführen und damit ein Programm tatsächlich auszuführen, benötigen wir weitere Arten von Ausdrücken, nämlich Zuweisungsausdrücke und Nachrichtenausdrücke. Auch diese repräsentieren jeweils ein Objekt und können daher an allen Stellen verwendet werden, an denen Objekte erforderlich sind. Es ist sogar möglich, sie geschachtelt anzuordnen.","<answer> Es gibt Literale, Variablen, Zuweisungsausdrücke und Nachrichtenausdrücke. <answer> <question> Welche Arten von Ausdrücken gibt es in einem objektorientierten Programm? <question>"
"In einem objektorientierten Programm repräsentieren Objekte nicht nur Literale (Abschnitt 1.2) und Variablen (Abschnitt 1.5), sondern auch Ausdrücke. Tatsächlich sind Literale und Variablen primitive Ausdrücke, die nicht aus anderen Ausdrücken zusammengesetzt sind. Um mit den Objekten jedoch Aktionen auszuführen und damit ein Programm tatsächlich auszuführen, benötigen wir weitere Arten von Ausdrücken, nämlich Zuweisungsausdrücke und Nachrichtenausdrücke. Auch diese repräsentieren jeweils ein Objekt und können daher an allen Stellen verwendet werden, an denen Objekte erforderlich sind. Es ist sogar möglich, sie geschachtelt anzuordnen.","<answer> Primitive Ausdrücke, die nicht aus anderen Ausdrücken zusammengesetzt sind, sind Literale und Variablen. <answer> <question> Was sind primitive Ausdrücke, die nicht aus anderen Ausdrücken zusammengesetzt sind? <question>"
"In einem objektorientierten Programm repräsentieren Objekte nicht nur Literale (Abschnitt 1.2) und Variablen (Abschnitt 1.5), sondern auch Ausdrücke. Tatsächlich sind Literale und Variablen primitive Ausdrücke, die nicht aus anderen Ausdrücken zusammengesetzt sind. Um mit den Objekten jedoch Aktionen auszuführen und damit ein Programm tatsächlich auszuführen, benötigen wir weitere Arten von Ausdrücken, nämlich Zuweisungsausdrücke und Nachrichtenausdrücke. Auch diese repräsentieren jeweils ein Objekt und können daher an allen Stellen verwendet werden, an denen Objekte erforderlich sind. Es ist sogar möglich, sie geschachtelt anzuordnen.","<answer> Zuweisungsausdrücke und Nachrichtenausdrücke ermöglichen es, Aktionen mit den repräsentierten Objekten auszuführen und damit ein Programm tatsächlich auszuführen. <answer> <question> Warum sind Zuweisungsausdrücke und Nachrichtenausdrücke wichtig? <question>"
"In einem objektorientierten Programm repräsentieren Objekte nicht nur Literale (Abschnitt 1.2) und Variablen (Abschnitt 1.5), sondern auch Ausdrücke. Tatsächlich sind Literale und Variablen primitive Ausdrücke, die nicht aus anderen Ausdrücken zusammengesetzt sind. Um mit den Objekten jedoch Aktionen auszuführen und damit ein Programm tatsächlich auszuführen, benötigen wir weitere Arten von Ausdrücken, nämlich Zuweisungsausdrücke und Nachrichtenausdrücke. Auch diese repräsentieren jeweils ein Objekt und können daher an allen Stellen verwendet werden, an denen Objekte erforderlich sind. Es ist sogar möglich, sie geschachtelt anzuordnen.","<answer> Ja, es ist möglich, Zuweisungsausdrücke und Nachrichtenausdrücke geschachtelt anzuordnen. <answer> <question> Können Zuweisungsausdrücke und Nachrichtenausdrücke geschachtelt angeordnet werden? <question>"
"In Beziehungen mit :n-Verbindungen müssen häufig mehrere Elemente der gleichen Behandlung unterzogen werden oder es müssen Elemente aus der Menge gesucht werden.
Wenn jedoch Collections verwendet werden, die nicht indiziert sind (JAVA bietet auch Collections wie Bäume oder verkettete Listen), ist die oben gezeigte Form der Iteration nicht anwendbar. Stattdessen gibt es in JAVA die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer), die eine einheitliche Iteration über Collections mittels sogenannter Iteratoren erlauben. Jede Collection-Klasse, die Iterator implementiert, bietet dazu eine Methode iterator() an, die ein solches Iteratorobjekt (vom Typ Iterator) zurückliefert.
Mit der Methode next() erhält man von diesem Iterator-Objekt zunächst das erste und anschließend alle weiteren Objekte der Collection. Mit der Methode hasNext() fragt man ab, ob die Collection noch weitere Objekte enthält.
Die Wahl der unnötig langen Bezeichner lässt vermuten, dass man die Häufigkeit solcher Konstruktionen in der Programmierpraxis unterschätzt hatte. Dieser Fehler wurde mit JAVA 5 korrigiert. Voraussetzung ist allerdings, dass die Klasse von ""aCollection"" das Interface ""Iterable"" implementiert, das wiederum verspricht, dass die Instanzen die Methode ""Iterator iterator()"" anbieten und damit einen Iterator zurückliefern, der dann von der ""for""-Schleife zur Produktion der Elemente ausgenutzt werden kann. Es handelt sich bei dieser Version der ""for""-Schleife also lediglich um ""syntaktischen Zucker"". Man beachte, dass dabei eine weitere Verquickung von Sprachdefinition und Klassenbibliothek (API; speziell des Interface ""Iterator"") stattgefunden hat, die nicht schön ist.","<answer> Die oben gezeigte Form der Iteration mittels Indizes ist nicht anwendbar, wenn Collections verwendet werden, die nicht indiziert sind, da diese Collections keine numerischen Indizes für den Zugriff auf ihre Elemente bereitstellen. <answer> <question> Warum ist die oben gezeigte Form der Iteration in JAVA nicht anwendbar, wenn Collections verwendet werden, die nicht indiziert sind? <question>"
"In Beziehungen mit :n-Verbindungen müssen häufig mehrere Elemente der gleichen Behandlung unterzogen werden oder es müssen Elemente aus der Menge gesucht werden.
Wenn jedoch Collections verwendet werden, die nicht indiziert sind (JAVA bietet auch Collections wie Bäume oder verkettete Listen), ist die oben gezeigte Form der Iteration nicht anwendbar. Stattdessen gibt es in JAVA die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer), die eine einheitliche Iteration über Collections mittels sogenannter Iteratoren erlauben. Jede Collection-Klasse, die Iterator implementiert, bietet dazu eine Methode iterator() an, die ein solches Iteratorobjekt (vom Typ Iterator) zurückliefert.
Mit der Methode next() erhält man von diesem Iterator-Objekt zunächst das erste und anschließend alle weiteren Objekte der Collection. Mit der Methode hasNext() fragt man ab, ob die Collection noch weitere Objekte enthält.
Die Wahl der unnötig langen Bezeichner lässt vermuten, dass man die Häufigkeit solcher Konstruktionen in der Programmierpraxis unterschätzt hatte. Dieser Fehler wurde mit JAVA 5 korrigiert. Voraussetzung ist allerdings, dass die Klasse von ""aCollection"" das Interface ""Iterable"" implementiert, das wiederum verspricht, dass die Instanzen die Methode ""Iterator iterator()"" anbieten und damit einen Iterator zurückliefern, der dann von der ""for""-Schleife zur Produktion der Elemente ausgenutzt werden kann. Es handelt sich bei dieser Version der ""for""-Schleife also lediglich um ""syntaktischen Zucker"". Man beachte, dass dabei eine weitere Verquickung von Sprachdefinition und Klassenbibliothek (API; speziell des Interface ""Iterator"") stattgefunden hat, die nicht schön ist.",<answer> In JAVA ermöglichen die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer) eine einheitliche Iteration über Collections mittels Iteratoren. <answer> <question> Welche beiden Interfaces in JAVA ermöglichen eine einheitliche Iteration über Collections mittels Iteratoren? <question>
"In Beziehungen mit :n-Verbindungen müssen häufig mehrere Elemente der gleichen Behandlung unterzogen werden oder es müssen Elemente aus der Menge gesucht werden.
Wenn jedoch Collections verwendet werden, die nicht indiziert sind (JAVA bietet auch Collections wie Bäume oder verkettete Listen), ist die oben gezeigte Form der Iteration nicht anwendbar. Stattdessen gibt es in JAVA die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer), die eine einheitliche Iteration über Collections mittels sogenannter Iteratoren erlauben. Jede Collection-Klasse, die Iterator implementiert, bietet dazu eine Methode iterator() an, die ein solches Iteratorobjekt (vom Typ Iterator) zurückliefert.
Mit der Methode next() erhält man von diesem Iterator-Objekt zunächst das erste und anschließend alle weiteren Objekte der Collection. Mit der Methode hasNext() fragt man ab, ob die Collection noch weitere Objekte enthält.
Die Wahl der unnötig langen Bezeichner lässt vermuten, dass man die Häufigkeit solcher Konstruktionen in der Programmierpraxis unterschätzt hatte. Dieser Fehler wurde mit JAVA 5 korrigiert. Voraussetzung ist allerdings, dass die Klasse von ""aCollection"" das Interface ""Iterable"" implementiert, das wiederum verspricht, dass die Instanzen die Methode ""Iterator iterator()"" anbieten und damit einen Iterator zurückliefern, der dann von der ""for""-Schleife zur Produktion der Elemente ausgenutzt werden kann. Es handelt sich bei dieser Version der ""for""-Schleife also lediglich um ""syntaktischen Zucker"". Man beachte, dass dabei eine weitere Verquickung von Sprachdefinition und Klassenbibliothek (API; speziell des Interface ""Iterator"") stattgefunden hat, die nicht schön ist.","<answer> Die Methode next() eines Iterator-Objekts gibt das nächste Element der Collection zurück, über die iteriert wird. <answer> <question> Was tut die Methode next() eines Iterator-Objekts? <question>"
"In Beziehungen mit :n-Verbindungen müssen häufig mehrere Elemente der gleichen Behandlung unterzogen werden oder es müssen Elemente aus der Menge gesucht werden.
Wenn jedoch Collections verwendet werden, die nicht indiziert sind (JAVA bietet auch Collections wie Bäume oder verkettete Listen), ist die oben gezeigte Form der Iteration nicht anwendbar. Stattdessen gibt es in JAVA die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer), die eine einheitliche Iteration über Collections mittels sogenannter Iteratoren erlauben. Jede Collection-Klasse, die Iterator implementiert, bietet dazu eine Methode iterator() an, die ein solches Iteratorobjekt (vom Typ Iterator) zurückliefert.
Mit der Methode next() erhält man von diesem Iterator-Objekt zunächst das erste und anschließend alle weiteren Objekte der Collection. Mit der Methode hasNext() fragt man ab, ob die Collection noch weitere Objekte enthält.
Die Wahl der unnötig langen Bezeichner lässt vermuten, dass man die Häufigkeit solcher Konstruktionen in der Programmierpraxis unterschätzt hatte. Dieser Fehler wurde mit JAVA 5 korrigiert. Voraussetzung ist allerdings, dass die Klasse von ""aCollection"" das Interface ""Iterable"" implementiert, das wiederum verspricht, dass die Instanzen die Methode ""Iterator iterator()"" anbieten und damit einen Iterator zurückliefern, der dann von der ""for""-Schleife zur Produktion der Elemente ausgenutzt werden kann. Es handelt sich bei dieser Version der ""for""-Schleife also lediglich um ""syntaktischen Zucker"". Man beachte, dass dabei eine weitere Verquickung von Sprachdefinition und Klassenbibliothek (API; speziell des Interface ""Iterator"") stattgefunden hat, die nicht schön ist.","<answer> Die Methode hasNext() wird bei der Verwendung von Iteratoren in JAVA eingesetzt, um abzufragen, ob die Collection noch weitere Elemente enthält, die iteriert werden können. <answer> <question> Wofür wird die Methode hasNext() bei der Verwendung von Iteratoren in JAVA eingesetzt? <question>"
"In Beziehungen mit :n-Verbindungen müssen häufig mehrere Elemente der gleichen Behandlung unterzogen werden oder es müssen Elemente aus der Menge gesucht werden.
Wenn jedoch Collections verwendet werden, die nicht indiziert sind (JAVA bietet auch Collections wie Bäume oder verkettete Listen), ist die oben gezeigte Form der Iteration nicht anwendbar. Stattdessen gibt es in JAVA die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer), die eine einheitliche Iteration über Collections mittels sogenannter Iteratoren erlauben. Jede Collection-Klasse, die Iterator implementiert, bietet dazu eine Methode iterator() an, die ein solches Iteratorobjekt (vom Typ Iterator) zurückliefert.
Mit der Methode next() erhält man von diesem Iterator-Objekt zunächst das erste und anschließend alle weiteren Objekte der Collection. Mit der Methode hasNext() fragt man ab, ob die Collection noch weitere Objekte enthält.
Die Wahl der unnötig langen Bezeichner lässt vermuten, dass man die Häufigkeit solcher Konstruktionen in der Programmierpraxis unterschätzt hatte. Dieser Fehler wurde mit JAVA 5 korrigiert. Voraussetzung ist allerdings, dass die Klasse von ""aCollection"" das Interface ""Iterable"" implementiert, das wiederum verspricht, dass die Instanzen die Methode ""Iterator iterator()"" anbieten und damit einen Iterator zurückliefern, der dann von der ""for""-Schleife zur Produktion der Elemente ausgenutzt werden kann. Es handelt sich bei dieser Version der ""for""-Schleife also lediglich um ""syntaktischen Zucker"". Man beachte, dass dabei eine weitere Verquickung von Sprachdefinition und Klassenbibliothek (API; speziell des Interface ""Iterator"") stattgefunden hat, die nicht schön ist.","<answer> Der Fehler bezüglich unnötig langer Bezeichner in Iterationen wurde mit JAVA 5 korrigiert, indem die ""for""-Schleife um eine vereinfachte Schreibweise für die externe Iteration über Collections ergänzt wurde. <answer> <question> Wie wurde der Fehler bezüglich unnötig langer Bezeichner in Iterationen mit JAVA 5 korrigiert? <question>"
"In Beziehungen mit :n-Verbindungen müssen häufig mehrere Elemente der gleichen Behandlung unterzogen werden oder es müssen Elemente aus der Menge gesucht werden.
Wenn jedoch Collections verwendet werden, die nicht indiziert sind (JAVA bietet auch Collections wie Bäume oder verkettete Listen), ist die oben gezeigte Form der Iteration nicht anwendbar. Stattdessen gibt es in JAVA die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer), die eine einheitliche Iteration über Collections mittels sogenannter Iteratoren erlauben. Jede Collection-Klasse, die Iterator implementiert, bietet dazu eine Methode iterator() an, die ein solches Iteratorobjekt (vom Typ Iterator) zurückliefert.
Mit der Methode next() erhält man von diesem Iterator-Objekt zunächst das erste und anschließend alle weiteren Objekte der Collection. Mit der Methode hasNext() fragt man ab, ob die Collection noch weitere Objekte enthält.
Die Wahl der unnötig langen Bezeichner lässt vermuten, dass man die Häufigkeit solcher Konstruktionen in der Programmierpraxis unterschätzt hatte. Dieser Fehler wurde mit JAVA 5 korrigiert. Voraussetzung ist allerdings, dass die Klasse von ""aCollection"" das Interface ""Iterable"" implementiert, das wiederum verspricht, dass die Instanzen die Methode ""Iterator iterator()"" anbieten und damit einen Iterator zurückliefern, der dann von der ""for""-Schleife zur Produktion der Elemente ausgenutzt werden kann. Es handelt sich bei dieser Version der ""for""-Schleife also lediglich um ""syntaktischen Zucker"". Man beachte, dass dabei eine weitere Verquickung von Sprachdefinition und Klassenbibliothek (API; speziell des Interface ""Iterator"") stattgefunden hat, die nicht schön ist.","<answer> Eine Klasse muss das Interface ""Iterable"" implementieren, um die ""syntaktische Zucker""-Version der ""for""-Schleife in JAVA verwenden zu können. Diese Version ermöglicht die externe Iteration über Collections. <answer> <question> Welches Interface muss eine Klasse implementieren, um die ""syntaktische Zucker""-Version der ""for""-Schleife in JAVA verwenden zu können? <question>"
"Ein relativ neues Feature in EIFFEL sind die sogenannten Tupel. Tupel ermöglichen es, ohne großen Aufwand mehrere Objekte zu gruppieren, insbesondere ohne die Notwendigkeit, eine Klasse zu definieren. Tupel sind besonders interessant, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugeordnet wird. Dies ist besonders prominent bei Methoden, die mehrere Werte anstelle eines einzigen Wertes zurückgeben sollen.
Tupeltypen werden deklariert, indem für jede Position ein Typ angegeben wird. Konkrete Werte eines Tupels werden in eckigen Klammern notiert. Die Positionen eines Tupels können auch Namen erhalten. Da Tupeltypen anonym sind, erfolgt die Zuordnung eines Tupels zu einem Tupeltyp (normalerweise während der Instanziierung) durch den Abgleich der vorhandenen Positionen mit den deklarierten Positionstypen sowie gegebenenfalls den Positionsnamen.","<answer> Tupel sind in EIFFEL eine relativ neue Funktion, die es ermöglicht, mehrere Objekte ohne die Notwendigkeit der Definition einer eigenen Klasse zu gruppieren. Sie sind besonders nützlich, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugewiesen wird. Tupel werden oft verwendet, wenn Methoden mehrere Werte zurückgeben sollen. <answer> <question> Was sind Tupel in EIFFEL und wofür werden sie verwendet? <question>"
"Ein relativ neues Feature in EIFFEL sind die sogenannten Tupel. Tupel ermöglichen es, ohne großen Aufwand mehrere Objekte zu gruppieren, insbesondere ohne die Notwendigkeit, eine Klasse zu definieren. Tupel sind besonders interessant, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugeordnet wird. Dies ist besonders prominent bei Methoden, die mehrere Werte anstelle eines einzigen Wertes zurückgeben sollen.
Tupeltypen werden deklariert, indem für jede Position ein Typ angegeben wird. Konkrete Werte eines Tupels werden in eckigen Klammern notiert. Die Positionen eines Tupels können auch Namen erhalten. Da Tupeltypen anonym sind, erfolgt die Zuordnung eines Tupels zu einem Tupeltyp (normalerweise während der Instanziierung) durch den Abgleich der vorhandenen Positionen mit den deklarierten Positionstypen sowie gegebenenfalls den Positionsnamen.","<answer> Tupeltypen in EIFFEL werden deklariert, indem für jede Position im Tupel ein Typ angegeben wird. Konkrete Werte eines Tupels werden in eckigen Klammern notiert, wobei die Positionen optional auch Namen erhalten können. <answer> <question> Wie werden Tupeltypen in EIFFEL deklariert? <question>"
"Ein relativ neues Feature in EIFFEL sind die sogenannten Tupel. Tupel ermöglichen es, ohne großen Aufwand mehrere Objekte zu gruppieren, insbesondere ohne die Notwendigkeit, eine Klasse zu definieren. Tupel sind besonders interessant, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugeordnet wird. Dies ist besonders prominent bei Methoden, die mehrere Werte anstelle eines einzigen Wertes zurückgeben sollen.
Tupeltypen werden deklariert, indem für jede Position ein Typ angegeben wird. Konkrete Werte eines Tupels werden in eckigen Klammern notiert. Die Positionen eines Tupels können auch Namen erhalten. Da Tupeltypen anonym sind, erfolgt die Zuordnung eines Tupels zu einem Tupeltyp (normalerweise während der Instanziierung) durch den Abgleich der vorhandenen Positionen mit den deklarierten Positionstypen sowie gegebenenfalls den Positionsnamen.","<answer> In Tupeln spielen die Positionen und gegebenenfalls die Positionsnamen eine wichtige Rolle. Sie dienen dazu, die Struktur des Tupels festzulegen und die Werte den richtigen Positionen zuzuordnen. Die Zuordnung eines Tupels zu einem Tupeltyp erfolgt durch den Abgleich der vorhandenen Positionen mit den deklarierten Positionstypen sowie gegebenenfalls den Positionsnamen. <answer> <question> Welche Rolle spielen die Positionen und Positionsnamen in Tupeln? <question>"
"C# ist Microsofts Antwort auf Java. Oberflächlich betrachtet ähnelt es Java recht stark, dennoch enthält C# einige zusätzliche Merkmale von C++, aber auch von Microsofts hauseigener Sprache, Visual Basic. Dabei ist die Entwicklung von C# wohl weniger ein Versuch, mit Microsofts eigener Marktmacht einen proprietären Standard durchzusetzen (was bei Programmiersprachen meines Wissens nach bisher noch nie gelungen ist), sondern vielmehr dem Umstand geschuldet, dass Java keine volle Kontrolle über Hardware und Betriebssystem bietet und somit nicht für jede kommerzielle Softwareentwicklung geeignet ist. Zwar hat sich Sun bemüht, bekannte Schwächen zu beheben, doch gestaltete sich dieser Prozess recht träge. Angesichts des nicht zu übersehenden Erfolgs von Java in der Entwicklergemeinschaft war die Entwicklung einer eigenen, Java-ähnlichen, aber dennoch in wichtigen Punkten unterschiedlichen Sprache eigentlich nur folgerichtig.",<answer> C# ist Microsofts Antwort auf Java. <answer> <question> Welche Antwort auf Java stellt C# dar? <question>
"C# ist Microsofts Antwort auf Java. Oberflächlich betrachtet ähnelt es Java recht stark, dennoch enthält C# einige zusätzliche Merkmale von C++, aber auch von Microsofts hauseigener Sprache, Visual Basic. Dabei ist die Entwicklung von C# wohl weniger ein Versuch, mit Microsofts eigener Marktmacht einen proprietären Standard durchzusetzen (was bei Programmiersprachen meines Wissens nach bisher noch nie gelungen ist), sondern vielmehr dem Umstand geschuldet, dass Java keine volle Kontrolle über Hardware und Betriebssystem bietet und somit nicht für jede kommerzielle Softwareentwicklung geeignet ist. Zwar hat sich Sun bemüht, bekannte Schwächen zu beheben, doch gestaltete sich dieser Prozess recht träge. Angesichts des nicht zu übersehenden Erfolgs von Java in der Entwicklergemeinschaft war die Entwicklung einer eigenen, Java-ähnlichen, aber dennoch in wichtigen Punkten unterschiedlichen Sprache eigentlich nur folgerichtig.","<answer> C# enthält einige zusätzliche Merkmale von C++ sowie von Microsofts hauseigener Sprache, Visual Basic. <answer> <question> Was sind einige der zusätzlichen Merkmale von C#, die es im Vergleich zu Java enthält? <question>"
"C# ist Microsofts Antwort auf Java. Oberflächlich betrachtet ähnelt es Java recht stark, dennoch enthält C# einige zusätzliche Merkmale von C++, aber auch von Microsofts hauseigener Sprache, Visual Basic. Dabei ist die Entwicklung von C# wohl weniger ein Versuch, mit Microsofts eigener Marktmacht einen proprietären Standard durchzusetzen (was bei Programmiersprachen meines Wissens nach bisher noch nie gelungen ist), sondern vielmehr dem Umstand geschuldet, dass Java keine volle Kontrolle über Hardware und Betriebssystem bietet und somit nicht für jede kommerzielle Softwareentwicklung geeignet ist. Zwar hat sich Sun bemüht, bekannte Schwächen zu beheben, doch gestaltete sich dieser Prozess recht träge. Angesichts des nicht zu übersehenden Erfolgs von Java in der Entwicklergemeinschaft war die Entwicklung einer eigenen, Java-ähnlichen, aber dennoch in wichtigen Punkten unterschiedlichen Sprache eigentlich nur folgerichtig.","<answer> Die Entwicklung von C# wurde weniger als Versuch betrachtet, mit Microsofts Marktmacht einen proprietären Standard durchzusetzen, sondern war vielmehr dem Umstand geschuldet, dass Java keine volle Kontrolle über Hardware und Betriebssystem bietet und somit nicht für jede kommerzielle Softwareentwicklung geeignet ist. <answer> <question> Warum wurde C# entwickelt? <question>"
"Die Genera Aristoteles' sind allesamt abstrakt — es gibt keine Säugetiere, die nicht Mensch, Hund, Katze oder etwas Konkretes wären. Übertragen auf die objektorientierte Programmierung bedeutet das: Generalisierungen, also Klassen, die aus Generalisierungen hervorgegangen sind, haben selbst keine Instanzen und sind daher insbesondere nicht instanziierbar.
In der objektorientierten Programmierung nennt man nicht instanziierbare Klassen abstrakt. Der Grund für die mangelnde Instanziierbarkeit ist nicht immer konzeptuell (wie beispielsweise das Prinzip, dass eine Klasse eine Generalisierung ist und daher nicht instanziierbar sein sollte), sondern oft rein technisch. Abstrakten Klassen fehlen in der Regel Angaben, die das Verhalten ihrer Instanzen vollständig spezifizieren und diese somit brauchbar machen würden. Instanzen dieser Klassen wären unvollständig definiert und würden zu Laufzeitfehlern führen. Diese fehlenden Eigenschaften werden in den Klassen geliefert, die von den abstrakten erben (siehe nächstes Kapitel), wobei die Idee ist, dass sich die Eigenschaften von Klasse zu Klasse unterscheiden. Klassen, die nicht abstrakt sind und eigene Instanzen haben können, nennt man konkret. Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse Collection.
Schon am Fehlen von Instanzvariablen erkennt man, dass die Implementierung von Collection begrenzt ist. Instanzen wären schlicht zustandslos und daher kaum zu gebrauchen. Besonders deutlich wird die Abstraktheit jedoch an der Implementation der Methode add:. Hier wird anstatt etwas Entsprechendes zu tun, die Methode implementedBySubclass aufgerufen, die eine Fehlermeldung ausgibt. Wenn jemand versuchen würde, add: auf einer Instanz von Collection oder einer ihrer Subklassen aufzurufen, würde das zu einer Enttäuschung führen.
Allerdings tritt diese Enttäuschung erst zur Laufzeit auf. Viele andere Sprachen verlangen daher, dass man abstrakte Klassen mit einem Schlüsselwort wie ""abstract"" markiert und verbieten dann (durch den Compiler), die Klasse zu instanziieren. Dies ist in SMALLTALK jedoch nicht möglich, da Klassen in Variablen gespeichert werden können und der Compiler nicht wissen kann, welches Objekt die Variable nun gerade bezeichnet.
Der Hinweis, dass man eine abstrakte Klasse instanziiert hat, erfolgt in SMALLTALK nicht nur zur Laufzeit, sondern auch dann, wenn man versucht, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere ""new"" und ""new:"", entsprechend überschreiben (siehe Abschnitt 8.2). Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von Collection erben, was kaum zumutbar ist. Diese Klassen müssten dann ""new"" und ""new:"" wieder neu einführen, da ""new"" und ""new:"" primitive Methoden aufrufen.
Man könnte in SMALLTALK die Methode add: in der Klasse Collection ganz weglassen. Ein Aufruf von add: auf einer Instanz von Collection oder einer ihrer Subklassen würde dann zu einem Aufruf von doesNotUnderstand und der Ausgabe einer entsprechenden Fehlermeldung führen. Diese Fehlermeldung wäre jedoch weniger aufschlussreich für die Programmierer, da sie nicht zwischen einem falschen Methodennamen und dem Vergessen der Implementierung in einer Subklasse unterscheiden könnte. Es ist sinnvoll, eine Methode wie add: in Collection bereitzustellen, die auf ein Versäumnis hinweist, falls eines vorliegt.
Der Aufruf einer abstrakten, in der Klasse nicht implementierten Methode aus derselben Klasse heraus (mit ""self"" als Empfänger) ist ein gängiges Muster in der objektorientierten Programmierung. Man nennt es auch ""offene Rekursion"", da der Aufruf auf dem Objekt selbst erfolgt und noch nicht klar ist, welche erbende Klasse die Implementierung liefert. Dieses Muster wird auch verwendet, um das oben beschriebene Dilemma von Quadrat und Rechteck aufzulösen.","<answer> Abstrakte Klassen in der objektorientierten Programmierung sind Klassen, die selbst keine Instanzen haben und daher nicht instanziierbar sind. Sie werden oft verwendet, um gemeinsame Eigenschaften und Methoden für ihre Subklassen bereitzustellen, aber sie sind in der Regel unvollständig definiert und können zu Laufzeitfehlern führen, wenn sie direkt instanziiert werden. <answer> <question> Was sind abstrakte Klassen in der objektorientierten Programmierung? <question>"
"Die Genera Aristoteles' sind allesamt abstrakt — es gibt keine Säugetiere, die nicht Mensch, Hund, Katze oder etwas Konkretes wären. Übertragen auf die objektorientierte Programmierung bedeutet das: Generalisierungen, also Klassen, die aus Generalisierungen hervorgegangen sind, haben selbst keine Instanzen und sind daher insbesondere nicht instanziierbar.
In der objektorientierten Programmierung nennt man nicht instanziierbare Klassen abstrakt. Der Grund für die mangelnde Instanziierbarkeit ist nicht immer konzeptuell (wie beispielsweise das Prinzip, dass eine Klasse eine Generalisierung ist und daher nicht instanziierbar sein sollte), sondern oft rein technisch. Abstrakten Klassen fehlen in der Regel Angaben, die das Verhalten ihrer Instanzen vollständig spezifizieren und diese somit brauchbar machen würden. Instanzen dieser Klassen wären unvollständig definiert und würden zu Laufzeitfehlern führen. Diese fehlenden Eigenschaften werden in den Klassen geliefert, die von den abstrakten erben (siehe nächstes Kapitel), wobei die Idee ist, dass sich die Eigenschaften von Klasse zu Klasse unterscheiden. Klassen, die nicht abstrakt sind und eigene Instanzen haben können, nennt man konkret. Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse Collection.
Schon am Fehlen von Instanzvariablen erkennt man, dass die Implementierung von Collection begrenzt ist. Instanzen wären schlicht zustandslos und daher kaum zu gebrauchen. Besonders deutlich wird die Abstraktheit jedoch an der Implementation der Methode add:. Hier wird anstatt etwas Entsprechendes zu tun, die Methode implementedBySubclass aufgerufen, die eine Fehlermeldung ausgibt. Wenn jemand versuchen würde, add: auf einer Instanz von Collection oder einer ihrer Subklassen aufzurufen, würde das zu einer Enttäuschung führen.
Allerdings tritt diese Enttäuschung erst zur Laufzeit auf. Viele andere Sprachen verlangen daher, dass man abstrakte Klassen mit einem Schlüsselwort wie ""abstract"" markiert und verbieten dann (durch den Compiler), die Klasse zu instanziieren. Dies ist in SMALLTALK jedoch nicht möglich, da Klassen in Variablen gespeichert werden können und der Compiler nicht wissen kann, welches Objekt die Variable nun gerade bezeichnet.
Der Hinweis, dass man eine abstrakte Klasse instanziiert hat, erfolgt in SMALLTALK nicht nur zur Laufzeit, sondern auch dann, wenn man versucht, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere ""new"" und ""new:"", entsprechend überschreiben (siehe Abschnitt 8.2). Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von Collection erben, was kaum zumutbar ist. Diese Klassen müssten dann ""new"" und ""new:"" wieder neu einführen, da ""new"" und ""new:"" primitive Methoden aufrufen.
Man könnte in SMALLTALK die Methode add: in der Klasse Collection ganz weglassen. Ein Aufruf von add: auf einer Instanz von Collection oder einer ihrer Subklassen würde dann zu einem Aufruf von doesNotUnderstand und der Ausgabe einer entsprechenden Fehlermeldung führen. Diese Fehlermeldung wäre jedoch weniger aufschlussreich für die Programmierer, da sie nicht zwischen einem falschen Methodennamen und dem Vergessen der Implementierung in einer Subklasse unterscheiden könnte. Es ist sinnvoll, eine Methode wie add: in Collection bereitzustellen, die auf ein Versäumnis hinweist, falls eines vorliegt.
Der Aufruf einer abstrakten, in der Klasse nicht implementierten Methode aus derselben Klasse heraus (mit ""self"" als Empfänger) ist ein gängiges Muster in der objektorientierten Programmierung. Man nennt es auch ""offene Rekursion"", da der Aufruf auf dem Objekt selbst erfolgt und noch nicht klar ist, welche erbende Klasse die Implementierung liefert. Dieses Muster wird auch verwendet, um das oben beschriebene Dilemma von Quadrat und Rechteck aufzulösen.","<answer> Abstrakte Klassen sind in der Regel nicht instanziierbar, weil ihnen oft die notwendigen Informationen fehlen, um Instanzen vollständig zu initialisieren. Sie dienen als Vorlagen für Subklassen, die die fehlenden Details ergänzen. <answer> <question> Warum sind abstrakte Klassen in der objektorientierten Programmierung nicht instanziierbar? <question>"
"Die Genera Aristoteles' sind allesamt abstrakt — es gibt keine Säugetiere, die nicht Mensch, Hund, Katze oder etwas Konkretes wären. Übertragen auf die objektorientierte Programmierung bedeutet das: Generalisierungen, also Klassen, die aus Generalisierungen hervorgegangen sind, haben selbst keine Instanzen und sind daher insbesondere nicht instanziierbar.
In der objektorientierten Programmierung nennt man nicht instanziierbare Klassen abstrakt. Der Grund für die mangelnde Instanziierbarkeit ist nicht immer konzeptuell (wie beispielsweise das Prinzip, dass eine Klasse eine Generalisierung ist und daher nicht instanziierbar sein sollte), sondern oft rein technisch. Abstrakten Klassen fehlen in der Regel Angaben, die das Verhalten ihrer Instanzen vollständig spezifizieren und diese somit brauchbar machen würden. Instanzen dieser Klassen wären unvollständig definiert und würden zu Laufzeitfehlern führen. Diese fehlenden Eigenschaften werden in den Klassen geliefert, die von den abstrakten erben (siehe nächstes Kapitel), wobei die Idee ist, dass sich die Eigenschaften von Klasse zu Klasse unterscheiden. Klassen, die nicht abstrakt sind und eigene Instanzen haben können, nennt man konkret. Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse Collection.
Schon am Fehlen von Instanzvariablen erkennt man, dass die Implementierung von Collection begrenzt ist. Instanzen wären schlicht zustandslos und daher kaum zu gebrauchen. Besonders deutlich wird die Abstraktheit jedoch an der Implementation der Methode add:. Hier wird anstatt etwas Entsprechendes zu tun, die Methode implementedBySubclass aufgerufen, die eine Fehlermeldung ausgibt. Wenn jemand versuchen würde, add: auf einer Instanz von Collection oder einer ihrer Subklassen aufzurufen, würde das zu einer Enttäuschung führen.
Allerdings tritt diese Enttäuschung erst zur Laufzeit auf. Viele andere Sprachen verlangen daher, dass man abstrakte Klassen mit einem Schlüsselwort wie ""abstract"" markiert und verbieten dann (durch den Compiler), die Klasse zu instanziieren. Dies ist in SMALLTALK jedoch nicht möglich, da Klassen in Variablen gespeichert werden können und der Compiler nicht wissen kann, welches Objekt die Variable nun gerade bezeichnet.
Der Hinweis, dass man eine abstrakte Klasse instanziiert hat, erfolgt in SMALLTALK nicht nur zur Laufzeit, sondern auch dann, wenn man versucht, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere ""new"" und ""new:"", entsprechend überschreiben (siehe Abschnitt 8.2). Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von Collection erben, was kaum zumutbar ist. Diese Klassen müssten dann ""new"" und ""new:"" wieder neu einführen, da ""new"" und ""new:"" primitive Methoden aufrufen.
Man könnte in SMALLTALK die Methode add: in der Klasse Collection ganz weglassen. Ein Aufruf von add: auf einer Instanz von Collection oder einer ihrer Subklassen würde dann zu einem Aufruf von doesNotUnderstand und der Ausgabe einer entsprechenden Fehlermeldung führen. Diese Fehlermeldung wäre jedoch weniger aufschlussreich für die Programmierer, da sie nicht zwischen einem falschen Methodennamen und dem Vergessen der Implementierung in einer Subklasse unterscheiden könnte. Es ist sinnvoll, eine Methode wie add: in Collection bereitzustellen, die auf ein Versäumnis hinweist, falls eines vorliegt.
Der Aufruf einer abstrakten, in der Klasse nicht implementierten Methode aus derselben Klasse heraus (mit ""self"" als Empfänger) ist ein gängiges Muster in der objektorientierten Programmierung. Man nennt es auch ""offene Rekursion"", da der Aufruf auf dem Objekt selbst erfolgt und noch nicht klar ist, welche erbende Klasse die Implementierung liefert. Dieses Muster wird auch verwendet, um das oben beschriebene Dilemma von Quadrat und Rechteck aufzulösen.","<answer> Ein Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse ""Collection"". Ihre Abstraktheit zeigt sich darin, dass sie keine benannten Instanzvariablen hat und einige ihrer Methoden, wie ""add:"", nicht implementiert sind. Wenn jemand versuchen würde, die Methode ""add:"" auf einer Instanz von ""Collection"" oder einer ihrer Subklassen aufzurufen, würde dies zu einer Fehlermeldung führen. <answer> <question> Was ist ein Beispiel für eine abstrakte Klasse in SMALLTALK und wie zeigt sich ihre Abstraktheit? <question>"
"Die Genera Aristoteles' sind allesamt abstrakt — es gibt keine Säugetiere, die nicht Mensch, Hund, Katze oder etwas Konkretes wären. Übertragen auf die objektorientierte Programmierung bedeutet das: Generalisierungen, also Klassen, die aus Generalisierungen hervorgegangen sind, haben selbst keine Instanzen und sind daher insbesondere nicht instanziierbar.
In der objektorientierten Programmierung nennt man nicht instanziierbare Klassen abstrakt. Der Grund für die mangelnde Instanziierbarkeit ist nicht immer konzeptuell (wie beispielsweise das Prinzip, dass eine Klasse eine Generalisierung ist und daher nicht instanziierbar sein sollte), sondern oft rein technisch. Abstrakten Klassen fehlen in der Regel Angaben, die das Verhalten ihrer Instanzen vollständig spezifizieren und diese somit brauchbar machen würden. Instanzen dieser Klassen wären unvollständig definiert und würden zu Laufzeitfehlern führen. Diese fehlenden Eigenschaften werden in den Klassen geliefert, die von den abstrakten erben (siehe nächstes Kapitel), wobei die Idee ist, dass sich die Eigenschaften von Klasse zu Klasse unterscheiden. Klassen, die nicht abstrakt sind und eigene Instanzen haben können, nennt man konkret. Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse Collection.
Schon am Fehlen von Instanzvariablen erkennt man, dass die Implementierung von Collection begrenzt ist. Instanzen wären schlicht zustandslos und daher kaum zu gebrauchen. Besonders deutlich wird die Abstraktheit jedoch an der Implementation der Methode add:. Hier wird anstatt etwas Entsprechendes zu tun, die Methode implementedBySubclass aufgerufen, die eine Fehlermeldung ausgibt. Wenn jemand versuchen würde, add: auf einer Instanz von Collection oder einer ihrer Subklassen aufzurufen, würde das zu einer Enttäuschung führen.
Allerdings tritt diese Enttäuschung erst zur Laufzeit auf. Viele andere Sprachen verlangen daher, dass man abstrakte Klassen mit einem Schlüsselwort wie ""abstract"" markiert und verbieten dann (durch den Compiler), die Klasse zu instanziieren. Dies ist in SMALLTALK jedoch nicht möglich, da Klassen in Variablen gespeichert werden können und der Compiler nicht wissen kann, welches Objekt die Variable nun gerade bezeichnet.
Der Hinweis, dass man eine abstrakte Klasse instanziiert hat, erfolgt in SMALLTALK nicht nur zur Laufzeit, sondern auch dann, wenn man versucht, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere ""new"" und ""new:"", entsprechend überschreiben (siehe Abschnitt 8.2). Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von Collection erben, was kaum zumutbar ist. Diese Klassen müssten dann ""new"" und ""new:"" wieder neu einführen, da ""new"" und ""new:"" primitive Methoden aufrufen.
Man könnte in SMALLTALK die Methode add: in der Klasse Collection ganz weglassen. Ein Aufruf von add: auf einer Instanz von Collection oder einer ihrer Subklassen würde dann zu einem Aufruf von doesNotUnderstand und der Ausgabe einer entsprechenden Fehlermeldung führen. Diese Fehlermeldung wäre jedoch weniger aufschlussreich für die Programmierer, da sie nicht zwischen einem falschen Methodennamen und dem Vergessen der Implementierung in einer Subklasse unterscheiden könnte. Es ist sinnvoll, eine Methode wie add: in Collection bereitzustellen, die auf ein Versäumnis hinweist, falls eines vorliegt.
Der Aufruf einer abstrakten, in der Klasse nicht implementierten Methode aus derselben Klasse heraus (mit ""self"" als Empfänger) ist ein gängiges Muster in der objektorientierten Programmierung. Man nennt es auch ""offene Rekursion"", da der Aufruf auf dem Objekt selbst erfolgt und noch nicht klar ist, welche erbende Klasse die Implementierung liefert. Dieses Muster wird auch verwendet, um das oben beschriebene Dilemma von Quadrat und Rechteck aufzulösen.","<answer> In SMALLTALK erfolgt die Erkennung, dass eine abstrakte Klasse instanziiert wurde, zur Laufzeit, wenn versucht wird, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere ""new"" und ""new:"", entsprechend überschreiben. Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von der abstrakten Klasse erben, was oft nicht akzeptabel ist. <answer> <question> Wie kann in SMALLTALK verhindert werden, dass Instanzen einer abstrakten Klasse erzeugt werden? <question>"
"Die Genera Aristoteles' sind allesamt abstrakt — es gibt keine Säugetiere, die nicht Mensch, Hund, Katze oder etwas Konkretes wären. Übertragen auf die objektorientierte Programmierung bedeutet das: Generalisierungen, also Klassen, die aus Generalisierungen hervorgegangen sind, haben selbst keine Instanzen und sind daher insbesondere nicht instanziierbar.
In der objektorientierten Programmierung nennt man nicht instanziierbare Klassen abstrakt. Der Grund für die mangelnde Instanziierbarkeit ist nicht immer konzeptuell (wie beispielsweise das Prinzip, dass eine Klasse eine Generalisierung ist und daher nicht instanziierbar sein sollte), sondern oft rein technisch. Abstrakten Klassen fehlen in der Regel Angaben, die das Verhalten ihrer Instanzen vollständig spezifizieren und diese somit brauchbar machen würden. Instanzen dieser Klassen wären unvollständig definiert und würden zu Laufzeitfehlern führen. Diese fehlenden Eigenschaften werden in den Klassen geliefert, die von den abstrakten erben (siehe nächstes Kapitel), wobei die Idee ist, dass sich die Eigenschaften von Klasse zu Klasse unterscheiden. Klassen, die nicht abstrakt sind und eigene Instanzen haben können, nennt man konkret. Ein typisches Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse Collection.
Schon am Fehlen von Instanzvariablen erkennt man, dass die Implementierung von Collection begrenzt ist. Instanzen wären schlicht zustandslos und daher kaum zu gebrauchen. Besonders deutlich wird die Abstraktheit jedoch an der Implementation der Methode add:. Hier wird anstatt etwas Entsprechendes zu tun, die Methode implementedBySubclass aufgerufen, die eine Fehlermeldung ausgibt. Wenn jemand versuchen würde, add: auf einer Instanz von Collection oder einer ihrer Subklassen aufzurufen, würde das zu einer Enttäuschung führen.
Allerdings tritt diese Enttäuschung erst zur Laufzeit auf. Viele andere Sprachen verlangen daher, dass man abstrakte Klassen mit einem Schlüsselwort wie ""abstract"" markiert und verbieten dann (durch den Compiler), die Klasse zu instanziieren. Dies ist in SMALLTALK jedoch nicht möglich, da Klassen in Variablen gespeichert werden können und der Compiler nicht wissen kann, welches Objekt die Variable nun gerade bezeichnet.
Der Hinweis, dass man eine abstrakte Klasse instanziiert hat, erfolgt in SMALLTALK nicht nur zur Laufzeit, sondern auch dann, wenn man versucht, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere ""new"" und ""new:"", entsprechend überschreiben (siehe Abschnitt 8.2). Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von Collection erben, was kaum zumutbar ist. Diese Klassen müssten dann ""new"" und ""new:"" wieder neu einführen, da ""new"" und ""new:"" primitive Methoden aufrufen.
Man könnte in SMALLTALK die Methode add: in der Klasse Collection ganz weglassen. Ein Aufruf von add: auf einer Instanz von Collection oder einer ihrer Subklassen würde dann zu einem Aufruf von doesNotUnderstand und der Ausgabe einer entsprechenden Fehlermeldung führen. Diese Fehlermeldung wäre jedoch weniger aufschlussreich für die Programmierer, da sie nicht zwischen einem falschen Methodennamen und dem Vergessen der Implementierung in einer Subklasse unterscheiden könnte. Es ist sinnvoll, eine Methode wie add: in Collection bereitzustellen, die auf ein Versäumnis hinweist, falls eines vorliegt.
Der Aufruf einer abstrakten, in der Klasse nicht implementierten Methode aus derselben Klasse heraus (mit ""self"" als Empfänger) ist ein gängiges Muster in der objektorientierten Programmierung. Man nennt es auch ""offene Rekursion"", da der Aufruf auf dem Objekt selbst erfolgt und noch nicht klar ist, welche erbende Klasse die Implementierung liefert. Dieses Muster wird auch verwendet, um das oben beschriebene Dilemma von Quadrat und Rechteck aufzulösen.","<answer> Das Weglassen einer Methode wie ""add:"" in einer abstrakten Klasse in SMALLTALK könnte weniger aufschlussreich sein, da die Fehlermeldung, die bei einem Aufruf dieser Methode auftritt, nicht zwischen einem falschen Methodennamen und dem Vergessen der Implementierung in einer Subklasse unterscheiden könnte. Das Bereitstellen einer Methode wie ""add:"" in der abstrakten Klasse, die auf ein Versäumnis hinweist, ist sinnvoll, um Programmierer auf das Problem aufmerksam zu machen. <answer> <question> Warum könnte das Weglassen einer Methode wie ""add:"" in einer abstrakten Klasse in SMALLTALK weniger aufschlussreich für Programmierer sein? <question>"
"Dass Typerweiterung als Basis des Subtyping keine technischen Probleme bereitet, sollte hinreichend klargeworden sein: Typfehler sind damit ausgeschlossen, und es bleibt lediglich das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind (wie im Beispiel von zweidimensionalen und dreidimensionalen Punkten). Es bleibt noch die Frage, ob und falls ja, in welchem Umfang Typeinschränkung im Rahmen des Subtyping erlaubt ist. Diese Frage soll an einem Beispiel beantwortet werden.
Die Methode m wird in B redefiniert. Die Frage ist nun, in welchem Verhältnis die dabei verwendeten Typen X und Z zu Y stehen müssen, damit die Zuweisung aus Zeile 915 weiterhin zulässig ist, selbst wenn die Variable a auf ein Objekt vom Typ B verweist. Mit anderen Worten: Welche Bedingungen sind an die Parametertypen bei der Redefinition zu stellen, damit eine Zuweisung eines Objekts vom Typ B an eine Variable vom Typ A in der Folge zu keiner Verletzung einer (anderen) Typinvariante führt? Solche Folgefehler waren ja bereits in Kapitel 25 thematisiert worden.
Die Antwort lässt sich systematisch herleiten, indem man sich die zu Zeile z dem formalen Parameter von m, y, zugewiesen. Wenn y nun in B einen anderen Typ als Y bekommen soll, dann darf es sich dabei nur um einen handeln, der mehr Werte zulässt — würde er weniger Werte zulassen, könnte es sein, dass er die Zuweisung von z ausschließt, wodurch Zeile 915 zu einem Typfehler (einem typinkorrekten Programm) führen würde. Der Typ des formalen Parameters y von m in B, Z, muss also ein Supertyp dessen in A, Y, sein. Zuletzt, d. h., nach erfolgter Auswertung des Methodenaufrufs, wird dann das Ergebnis x zugewiesen. Wenn nun der Rückgabewert von m in B, X, einen anderen Typ als in A, Y, bekommen soll, dann kann dies aufgrund der geforderten Zuweisungskompatibilität nur um einen Typen handeln, der weniger Werte zulässt, da ja sonst die Zuweisung an x zu einem Typfehler führen könnte. Es kommt also als Rückgabetyp für m in B nur ein Subtyp von dem in A, Y, infrage. Es ergibt sich also, dass sich bei einer Redefinition einer Methode die Eingabeparametertypen einer Funktion nur „nach oben“ (also zu einem Supertypen hin), die Ausgabeparameter hingegen nur „nach unten“ (hin zu einem Subtyp) verändern dürfen, wenn die Typkorrektheit eines Programms nicht verletzt werden soll.
Nun ändern sich aber bei der Redefinition nicht nur die Parametertypen (Ein- und Ausgabe bzw. Rückgabe), sondern auch der Typ des Empfängers. Dieser ändert sich bei der Redefinition aber immer nach unten (da der redefinierende Typ ja als Subtyp vom redefinierten abgeleitet wird). Es folgt also, dass die Eingabeparameter zum Empfängertyp gegenläufig variieren müssen, der Ausgabeparameter hingegen gleichgerichtet. Man spricht im ersten Fall daher von einer Kontravarianz, im zweiten von einer Kovarianz, und sagt:
Man spricht im Kontext von Subtyping auch von Typkonformität des Subtypen mit dem Supertypen.
Nun enthält die Idee von der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren einen kleinen Schönheitsfehler: Wenn es sich nämlich bei der Eingabe in eine Funktion und bei ihrer Ausgabe um dasselbe Objekt handelt, kann diesem nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden, denn der Subtyp verlangt ja mehr Eigenschaften, als der Supertyp garantiert.
Da das Umgekehrte freilich auch nicht geht, bleibt nichts anderes, als die Unveränderlichkeit der Parametertypen, auch als Invarianz oder besser (da das dazu passende Adjektiv „invariant“ in seiner Bedeutung schon belegt ist) als Novarianz bezeichnet, zu verlangen.
Obige analytischen Überlegungen führen also, mit der eben gemachten Einschränkung, zur Regel von den kontravarianten Parameter- und den kovarianten Rückgabetypredefinitionen. Es gibt aber noch einen zweiten Ansatz zur Klärung der Frage nach der richtigen Varianz der Parametertypen redefinierter Funktionen, die diese Betrachtung deutlich in Frage stellen. Dazu soll (wie schon in Kapitel 25) die Interpretation von Methoden als Relationen bzw., da hier der Rückgabetyp mit berücksichtigt wird, als Funktionen oder Abbildungen herhalten. Der hier zweistellige Definitionsbereich (Empfängertyp plus Parametertyp) der Funktion steht dabei stellvertretend für beliebige Stellenzahl, also für Methoden mit beliebig vielen Parametern. Der Wertebereich ist hingegen immer einstellig, da eine Methode stets nur einen Wert zurückgibt.
Wenn man nun die Anzahl der Empfängerobjekte einschränkt (was ja beim Übergang zu einem Subtypen geschieht), dann schrumpft damit nicht nur der Wertebereich der Funktion (wie in Kapitel 25 schon illustriert), sondern auch die Menge der möglichen Eingabewerte (der zweite und alle weiteren Definitionsbereiche), die mit der bereits eingeschränkten Menge der Empfänger gemeinsam auftreten können. Es verhalten sich also nicht nur die Ergebnistypen, sondern auch die Parametertypen kovariant.
Dieses Ergebnis ist gewissermaßen frustrierend, da es die soeben hergeleitete Kontravarianzregel für Parametertypen infrage stellt: Was programmiertechnisch möglich und sinnvoll erscheint, hat in der Realität (der Interpretation oder Semantik) keine Bedeutung. Auf der anderen Seite erklärt es aber, warum kontravariante Parameterredefinitionen in der Programmierpraxis nicht benötigt werden. Kovarianz für Parametertypen zuzulassen, so sinnvoll es auch zu sein scheint, erlaubt jedoch typinkorrekte Programme; Sie werden im Kontext der Programmiersprache EIFFEL (Kurseinheit 5, Abschnitt 52.5) noch ausführlicher auf das Problem und eine mögliche Lösung hingewiesen.","<answer> Bei Methodenaufrufen und Subtyping unterscheidet man zwischen Kovarianz und Kontravarianz. Kovarianz bezieht sich auf die Veränderung von Rückgabetypen, während Kontravarianz die Veränderung von Parametertypen beschreibt. <answer> <question> Was ist Kovarianz und Kontravarianz bei Methodenaufrufen im Zusammenhang mit Subtyping? <question>"
"Dass Typerweiterung als Basis des Subtyping keine technischen Probleme bereitet, sollte hinreichend klargeworden sein: Typfehler sind damit ausgeschlossen, und es bleibt lediglich das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind (wie im Beispiel von zweidimensionalen und dreidimensionalen Punkten). Es bleibt noch die Frage, ob und falls ja, in welchem Umfang Typeinschränkung im Rahmen des Subtyping erlaubt ist. Diese Frage soll an einem Beispiel beantwortet werden.
Die Methode m wird in B redefiniert. Die Frage ist nun, in welchem Verhältnis die dabei verwendeten Typen X und Z zu Y stehen müssen, damit die Zuweisung aus Zeile 915 weiterhin zulässig ist, selbst wenn die Variable a auf ein Objekt vom Typ B verweist. Mit anderen Worten: Welche Bedingungen sind an die Parametertypen bei der Redefinition zu stellen, damit eine Zuweisung eines Objekts vom Typ B an eine Variable vom Typ A in der Folge zu keiner Verletzung einer (anderen) Typinvariante führt? Solche Folgefehler waren ja bereits in Kapitel 25 thematisiert worden.
Die Antwort lässt sich systematisch herleiten, indem man sich die zu Zeile z dem formalen Parameter von m, y, zugewiesen. Wenn y nun in B einen anderen Typ als Y bekommen soll, dann darf es sich dabei nur um einen handeln, der mehr Werte zulässt — würde er weniger Werte zulassen, könnte es sein, dass er die Zuweisung von z ausschließt, wodurch Zeile 915 zu einem Typfehler (einem typinkorrekten Programm) führen würde. Der Typ des formalen Parameters y von m in B, Z, muss also ein Supertyp dessen in A, Y, sein. Zuletzt, d. h., nach erfolgter Auswertung des Methodenaufrufs, wird dann das Ergebnis x zugewiesen. Wenn nun der Rückgabewert von m in B, X, einen anderen Typ als in A, Y, bekommen soll, dann kann dies aufgrund der geforderten Zuweisungskompatibilität nur um einen Typen handeln, der weniger Werte zulässt, da ja sonst die Zuweisung an x zu einem Typfehler führen könnte. Es kommt also als Rückgabetyp für m in B nur ein Subtyp von dem in A, Y, infrage. Es ergibt sich also, dass sich bei einer Redefinition einer Methode die Eingabeparametertypen einer Funktion nur „nach oben“ (also zu einem Supertypen hin), die Ausgabeparameter hingegen nur „nach unten“ (hin zu einem Subtyp) verändern dürfen, wenn die Typkorrektheit eines Programms nicht verletzt werden soll.
Nun ändern sich aber bei der Redefinition nicht nur die Parametertypen (Ein- und Ausgabe bzw. Rückgabe), sondern auch der Typ des Empfängers. Dieser ändert sich bei der Redefinition aber immer nach unten (da der redefinierende Typ ja als Subtyp vom redefinierten abgeleitet wird). Es folgt also, dass die Eingabeparameter zum Empfängertyp gegenläufig variieren müssen, der Ausgabeparameter hingegen gleichgerichtet. Man spricht im ersten Fall daher von einer Kontravarianz, im zweiten von einer Kovarianz, und sagt:
Man spricht im Kontext von Subtyping auch von Typkonformität des Subtypen mit dem Supertypen.
Nun enthält die Idee von der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren einen kleinen Schönheitsfehler: Wenn es sich nämlich bei der Eingabe in eine Funktion und bei ihrer Ausgabe um dasselbe Objekt handelt, kann diesem nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden, denn der Subtyp verlangt ja mehr Eigenschaften, als der Supertyp garantiert.
Da das Umgekehrte freilich auch nicht geht, bleibt nichts anderes, als die Unveränderlichkeit der Parametertypen, auch als Invarianz oder besser (da das dazu passende Adjektiv „invariant“ in seiner Bedeutung schon belegt ist) als Novarianz bezeichnet, zu verlangen.
Obige analytischen Überlegungen führen also, mit der eben gemachten Einschränkung, zur Regel von den kontravarianten Parameter- und den kovarianten Rückgabetypredefinitionen. Es gibt aber noch einen zweiten Ansatz zur Klärung der Frage nach der richtigen Varianz der Parametertypen redefinierter Funktionen, die diese Betrachtung deutlich in Frage stellen. Dazu soll (wie schon in Kapitel 25) die Interpretation von Methoden als Relationen bzw., da hier der Rückgabetyp mit berücksichtigt wird, als Funktionen oder Abbildungen herhalten. Der hier zweistellige Definitionsbereich (Empfängertyp plus Parametertyp) der Funktion steht dabei stellvertretend für beliebige Stellenzahl, also für Methoden mit beliebig vielen Parametern. Der Wertebereich ist hingegen immer einstellig, da eine Methode stets nur einen Wert zurückgibt.
Wenn man nun die Anzahl der Empfängerobjekte einschränkt (was ja beim Übergang zu einem Subtypen geschieht), dann schrumpft damit nicht nur der Wertebereich der Funktion (wie in Kapitel 25 schon illustriert), sondern auch die Menge der möglichen Eingabewerte (der zweite und alle weiteren Definitionsbereiche), die mit der bereits eingeschränkten Menge der Empfänger gemeinsam auftreten können. Es verhalten sich also nicht nur die Ergebnistypen, sondern auch die Parametertypen kovariant.
Dieses Ergebnis ist gewissermaßen frustrierend, da es die soeben hergeleitete Kontravarianzregel für Parametertypen infrage stellt: Was programmiertechnisch möglich und sinnvoll erscheint, hat in der Realität (der Interpretation oder Semantik) keine Bedeutung. Auf der anderen Seite erklärt es aber, warum kontravariante Parameterredefinitionen in der Programmierpraxis nicht benötigt werden. Kovarianz für Parametertypen zuzulassen, so sinnvoll es auch zu sein scheint, erlaubt jedoch typinkorrekte Programme; Sie werden im Kontext der Programmiersprache EIFFEL (Kurseinheit 5, Abschnitt 52.5) noch ausführlicher auf das Problem und eine mögliche Lösung hingewiesen.","<answer> Kovarianz tritt auf, wenn der Rückgabetyp einer Methode in einem Subtyp ein Subtyp des Rückgabetyps in einem Supertyp ist. Dies bedeutet, dass der Subtyp mehr Werte zurückgeben kann als der Supertyp. <answer> <question> Was ist Kovarianz? <question>"
"Dass Typerweiterung als Basis des Subtyping keine technischen Probleme bereitet, sollte hinreichend klargeworden sein: Typfehler sind damit ausgeschlossen, und es bleibt lediglich das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind (wie im Beispiel von zweidimensionalen und dreidimensionalen Punkten). Es bleibt noch die Frage, ob und falls ja, in welchem Umfang Typeinschränkung im Rahmen des Subtyping erlaubt ist. Diese Frage soll an einem Beispiel beantwortet werden.
Die Methode m wird in B redefiniert. Die Frage ist nun, in welchem Verhältnis die dabei verwendeten Typen X und Z zu Y stehen müssen, damit die Zuweisung aus Zeile 915 weiterhin zulässig ist, selbst wenn die Variable a auf ein Objekt vom Typ B verweist. Mit anderen Worten: Welche Bedingungen sind an die Parametertypen bei der Redefinition zu stellen, damit eine Zuweisung eines Objekts vom Typ B an eine Variable vom Typ A in der Folge zu keiner Verletzung einer (anderen) Typinvariante führt? Solche Folgefehler waren ja bereits in Kapitel 25 thematisiert worden.
Die Antwort lässt sich systematisch herleiten, indem man sich die zu Zeile z dem formalen Parameter von m, y, zugewiesen. Wenn y nun in B einen anderen Typ als Y bekommen soll, dann darf es sich dabei nur um einen handeln, der mehr Werte zulässt — würde er weniger Werte zulassen, könnte es sein, dass er die Zuweisung von z ausschließt, wodurch Zeile 915 zu einem Typfehler (einem typinkorrekten Programm) führen würde. Der Typ des formalen Parameters y von m in B, Z, muss also ein Supertyp dessen in A, Y, sein. Zuletzt, d. h., nach erfolgter Auswertung des Methodenaufrufs, wird dann das Ergebnis x zugewiesen. Wenn nun der Rückgabewert von m in B, X, einen anderen Typ als in A, Y, bekommen soll, dann kann dies aufgrund der geforderten Zuweisungskompatibilität nur um einen Typen handeln, der weniger Werte zulässt, da ja sonst die Zuweisung an x zu einem Typfehler führen könnte. Es kommt also als Rückgabetyp für m in B nur ein Subtyp von dem in A, Y, infrage. Es ergibt sich also, dass sich bei einer Redefinition einer Methode die Eingabeparametertypen einer Funktion nur „nach oben“ (also zu einem Supertypen hin), die Ausgabeparameter hingegen nur „nach unten“ (hin zu einem Subtyp) verändern dürfen, wenn die Typkorrektheit eines Programms nicht verletzt werden soll.
Nun ändern sich aber bei der Redefinition nicht nur die Parametertypen (Ein- und Ausgabe bzw. Rückgabe), sondern auch der Typ des Empfängers. Dieser ändert sich bei der Redefinition aber immer nach unten (da der redefinierende Typ ja als Subtyp vom redefinierten abgeleitet wird). Es folgt also, dass die Eingabeparameter zum Empfängertyp gegenläufig variieren müssen, der Ausgabeparameter hingegen gleichgerichtet. Man spricht im ersten Fall daher von einer Kontravarianz, im zweiten von einer Kovarianz, und sagt:
Man spricht im Kontext von Subtyping auch von Typkonformität des Subtypen mit dem Supertypen.
Nun enthält die Idee von der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren einen kleinen Schönheitsfehler: Wenn es sich nämlich bei der Eingabe in eine Funktion und bei ihrer Ausgabe um dasselbe Objekt handelt, kann diesem nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden, denn der Subtyp verlangt ja mehr Eigenschaften, als der Supertyp garantiert.
Da das Umgekehrte freilich auch nicht geht, bleibt nichts anderes, als die Unveränderlichkeit der Parametertypen, auch als Invarianz oder besser (da das dazu passende Adjektiv „invariant“ in seiner Bedeutung schon belegt ist) als Novarianz bezeichnet, zu verlangen.
Obige analytischen Überlegungen führen also, mit der eben gemachten Einschränkung, zur Regel von den kontravarianten Parameter- und den kovarianten Rückgabetypredefinitionen. Es gibt aber noch einen zweiten Ansatz zur Klärung der Frage nach der richtigen Varianz der Parametertypen redefinierter Funktionen, die diese Betrachtung deutlich in Frage stellen. Dazu soll (wie schon in Kapitel 25) die Interpretation von Methoden als Relationen bzw., da hier der Rückgabetyp mit berücksichtigt wird, als Funktionen oder Abbildungen herhalten. Der hier zweistellige Definitionsbereich (Empfängertyp plus Parametertyp) der Funktion steht dabei stellvertretend für beliebige Stellenzahl, also für Methoden mit beliebig vielen Parametern. Der Wertebereich ist hingegen immer einstellig, da eine Methode stets nur einen Wert zurückgibt.
Wenn man nun die Anzahl der Empfängerobjekte einschränkt (was ja beim Übergang zu einem Subtypen geschieht), dann schrumpft damit nicht nur der Wertebereich der Funktion (wie in Kapitel 25 schon illustriert), sondern auch die Menge der möglichen Eingabewerte (der zweite und alle weiteren Definitionsbereiche), die mit der bereits eingeschränkten Menge der Empfänger gemeinsam auftreten können. Es verhalten sich also nicht nur die Ergebnistypen, sondern auch die Parametertypen kovariant.
Dieses Ergebnis ist gewissermaßen frustrierend, da es die soeben hergeleitete Kontravarianzregel für Parametertypen infrage stellt: Was programmiertechnisch möglich und sinnvoll erscheint, hat in der Realität (der Interpretation oder Semantik) keine Bedeutung. Auf der anderen Seite erklärt es aber, warum kontravariante Parameterredefinitionen in der Programmierpraxis nicht benötigt werden. Kovarianz für Parametertypen zuzulassen, so sinnvoll es auch zu sein scheint, erlaubt jedoch typinkorrekte Programme; Sie werden im Kontext der Programmiersprache EIFFEL (Kurseinheit 5, Abschnitt 52.5) noch ausführlicher auf das Problem und eine mögliche Lösung hingewiesen.","<answer> Kontravarianz tritt auf, wenn die Parametertypen einer Methode in einem Subtyp Supertypen der Parametertypen in einem Supertyp sind. Dies bedeutet, dass der Subtyp Eingabeparameter akzeptiert, die allgemeiner sind als die des Supertyps. <answer> <question> Was ist Kontravarianz? <question>"
"Dass Typerweiterung als Basis des Subtyping keine technischen Probleme bereitet, sollte hinreichend klargeworden sein: Typfehler sind damit ausgeschlossen, und es bleibt lediglich das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind (wie im Beispiel von zweidimensionalen und dreidimensionalen Punkten). Es bleibt noch die Frage, ob und falls ja, in welchem Umfang Typeinschränkung im Rahmen des Subtyping erlaubt ist. Diese Frage soll an einem Beispiel beantwortet werden.
Die Methode m wird in B redefiniert. Die Frage ist nun, in welchem Verhältnis die dabei verwendeten Typen X und Z zu Y stehen müssen, damit die Zuweisung aus Zeile 915 weiterhin zulässig ist, selbst wenn die Variable a auf ein Objekt vom Typ B verweist. Mit anderen Worten: Welche Bedingungen sind an die Parametertypen bei der Redefinition zu stellen, damit eine Zuweisung eines Objekts vom Typ B an eine Variable vom Typ A in der Folge zu keiner Verletzung einer (anderen) Typinvariante führt? Solche Folgefehler waren ja bereits in Kapitel 25 thematisiert worden.
Die Antwort lässt sich systematisch herleiten, indem man sich die zu Zeile z dem formalen Parameter von m, y, zugewiesen. Wenn y nun in B einen anderen Typ als Y bekommen soll, dann darf es sich dabei nur um einen handeln, der mehr Werte zulässt — würde er weniger Werte zulassen, könnte es sein, dass er die Zuweisung von z ausschließt, wodurch Zeile 915 zu einem Typfehler (einem typinkorrekten Programm) führen würde. Der Typ des formalen Parameters y von m in B, Z, muss also ein Supertyp dessen in A, Y, sein. Zuletzt, d. h., nach erfolgter Auswertung des Methodenaufrufs, wird dann das Ergebnis x zugewiesen. Wenn nun der Rückgabewert von m in B, X, einen anderen Typ als in A, Y, bekommen soll, dann kann dies aufgrund der geforderten Zuweisungskompatibilität nur um einen Typen handeln, der weniger Werte zulässt, da ja sonst die Zuweisung an x zu einem Typfehler führen könnte. Es kommt also als Rückgabetyp für m in B nur ein Subtyp von dem in A, Y, infrage. Es ergibt sich also, dass sich bei einer Redefinition einer Methode die Eingabeparametertypen einer Funktion nur „nach oben“ (also zu einem Supertypen hin), die Ausgabeparameter hingegen nur „nach unten“ (hin zu einem Subtyp) verändern dürfen, wenn die Typkorrektheit eines Programms nicht verletzt werden soll.
Nun ändern sich aber bei der Redefinition nicht nur die Parametertypen (Ein- und Ausgabe bzw. Rückgabe), sondern auch der Typ des Empfängers. Dieser ändert sich bei der Redefinition aber immer nach unten (da der redefinierende Typ ja als Subtyp vom redefinierten abgeleitet wird). Es folgt also, dass die Eingabeparameter zum Empfängertyp gegenläufig variieren müssen, der Ausgabeparameter hingegen gleichgerichtet. Man spricht im ersten Fall daher von einer Kontravarianz, im zweiten von einer Kovarianz, und sagt:
Man spricht im Kontext von Subtyping auch von Typkonformität des Subtypen mit dem Supertypen.
Nun enthält die Idee von der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren einen kleinen Schönheitsfehler: Wenn es sich nämlich bei der Eingabe in eine Funktion und bei ihrer Ausgabe um dasselbe Objekt handelt, kann diesem nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden, denn der Subtyp verlangt ja mehr Eigenschaften, als der Supertyp garantiert.
Da das Umgekehrte freilich auch nicht geht, bleibt nichts anderes, als die Unveränderlichkeit der Parametertypen, auch als Invarianz oder besser (da das dazu passende Adjektiv „invariant“ in seiner Bedeutung schon belegt ist) als Novarianz bezeichnet, zu verlangen.
Obige analytischen Überlegungen führen also, mit der eben gemachten Einschränkung, zur Regel von den kontravarianten Parameter- und den kovarianten Rückgabetypredefinitionen. Es gibt aber noch einen zweiten Ansatz zur Klärung der Frage nach der richtigen Varianz der Parametertypen redefinierter Funktionen, die diese Betrachtung deutlich in Frage stellen. Dazu soll (wie schon in Kapitel 25) die Interpretation von Methoden als Relationen bzw., da hier der Rückgabetyp mit berücksichtigt wird, als Funktionen oder Abbildungen herhalten. Der hier zweistellige Definitionsbereich (Empfängertyp plus Parametertyp) der Funktion steht dabei stellvertretend für beliebige Stellenzahl, also für Methoden mit beliebig vielen Parametern. Der Wertebereich ist hingegen immer einstellig, da eine Methode stets nur einen Wert zurückgibt.
Wenn man nun die Anzahl der Empfängerobjekte einschränkt (was ja beim Übergang zu einem Subtypen geschieht), dann schrumpft damit nicht nur der Wertebereich der Funktion (wie in Kapitel 25 schon illustriert), sondern auch die Menge der möglichen Eingabewerte (der zweite und alle weiteren Definitionsbereiche), die mit der bereits eingeschränkten Menge der Empfänger gemeinsam auftreten können. Es verhalten sich also nicht nur die Ergebnistypen, sondern auch die Parametertypen kovariant.
Dieses Ergebnis ist gewissermaßen frustrierend, da es die soeben hergeleitete Kontravarianzregel für Parametertypen infrage stellt: Was programmiertechnisch möglich und sinnvoll erscheint, hat in der Realität (der Interpretation oder Semantik) keine Bedeutung. Auf der anderen Seite erklärt es aber, warum kontravariante Parameterredefinitionen in der Programmierpraxis nicht benötigt werden. Kovarianz für Parametertypen zuzulassen, so sinnvoll es auch zu sein scheint, erlaubt jedoch typinkorrekte Programme; Sie werden im Kontext der Programmiersprache EIFFEL (Kurseinheit 5, Abschnitt 52.5) noch ausführlicher auf das Problem und eine mögliche Lösung hingewiesen.","<answer> Bei der Redefinition von Methodenaufrufen im Subtyping müssen die Parametertypen kontravariant und die Rückgabetypen kovariant sein. Dies bedeutet, dass die Eingabeparameter des Subtyps genereller sein dürfen als die des Supertyps, während der Subtyp mehr Werte zurückgeben kann als der Supertyp. <answer> <question> Wie wird Kovarianz und Kontravarianz bei der Redefinition von Methodenaufrufen im Subtyping angewendet? <question>"
"Dass Typerweiterung als Basis des Subtyping keine technischen Probleme bereitet, sollte hinreichend klargeworden sein: Typfehler sind damit ausgeschlossen, und es bleibt lediglich das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind (wie im Beispiel von zweidimensionalen und dreidimensionalen Punkten). Es bleibt noch die Frage, ob und falls ja, in welchem Umfang Typeinschränkung im Rahmen des Subtyping erlaubt ist. Diese Frage soll an einem Beispiel beantwortet werden.
Die Methode m wird in B redefiniert. Die Frage ist nun, in welchem Verhältnis die dabei verwendeten Typen X und Z zu Y stehen müssen, damit die Zuweisung aus Zeile 915 weiterhin zulässig ist, selbst wenn die Variable a auf ein Objekt vom Typ B verweist. Mit anderen Worten: Welche Bedingungen sind an die Parametertypen bei der Redefinition zu stellen, damit eine Zuweisung eines Objekts vom Typ B an eine Variable vom Typ A in der Folge zu keiner Verletzung einer (anderen) Typinvariante führt? Solche Folgefehler waren ja bereits in Kapitel 25 thematisiert worden.
Die Antwort lässt sich systematisch herleiten, indem man sich die zu Zeile z dem formalen Parameter von m, y, zugewiesen. Wenn y nun in B einen anderen Typ als Y bekommen soll, dann darf es sich dabei nur um einen handeln, der mehr Werte zulässt — würde er weniger Werte zulassen, könnte es sein, dass er die Zuweisung von z ausschließt, wodurch Zeile 915 zu einem Typfehler (einem typinkorrekten Programm) führen würde. Der Typ des formalen Parameters y von m in B, Z, muss also ein Supertyp dessen in A, Y, sein. Zuletzt, d. h., nach erfolgter Auswertung des Methodenaufrufs, wird dann das Ergebnis x zugewiesen. Wenn nun der Rückgabewert von m in B, X, einen anderen Typ als in A, Y, bekommen soll, dann kann dies aufgrund der geforderten Zuweisungskompatibilität nur um einen Typen handeln, der weniger Werte zulässt, da ja sonst die Zuweisung an x zu einem Typfehler führen könnte. Es kommt also als Rückgabetyp für m in B nur ein Subtyp von dem in A, Y, infrage. Es ergibt sich also, dass sich bei einer Redefinition einer Methode die Eingabeparametertypen einer Funktion nur „nach oben“ (also zu einem Supertypen hin), die Ausgabeparameter hingegen nur „nach unten“ (hin zu einem Subtyp) verändern dürfen, wenn die Typkorrektheit eines Programms nicht verletzt werden soll.
Nun ändern sich aber bei der Redefinition nicht nur die Parametertypen (Ein- und Ausgabe bzw. Rückgabe), sondern auch der Typ des Empfängers. Dieser ändert sich bei der Redefinition aber immer nach unten (da der redefinierende Typ ja als Subtyp vom redefinierten abgeleitet wird). Es folgt also, dass die Eingabeparameter zum Empfängertyp gegenläufig variieren müssen, der Ausgabeparameter hingegen gleichgerichtet. Man spricht im ersten Fall daher von einer Kontravarianz, im zweiten von einer Kovarianz, und sagt:
Man spricht im Kontext von Subtyping auch von Typkonformität des Subtypen mit dem Supertypen.
Nun enthält die Idee von der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren einen kleinen Schönheitsfehler: Wenn es sich nämlich bei der Eingabe in eine Funktion und bei ihrer Ausgabe um dasselbe Objekt handelt, kann diesem nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden, denn der Subtyp verlangt ja mehr Eigenschaften, als der Supertyp garantiert.
Da das Umgekehrte freilich auch nicht geht, bleibt nichts anderes, als die Unveränderlichkeit der Parametertypen, auch als Invarianz oder besser (da das dazu passende Adjektiv „invariant“ in seiner Bedeutung schon belegt ist) als Novarianz bezeichnet, zu verlangen.
Obige analytischen Überlegungen führen also, mit der eben gemachten Einschränkung, zur Regel von den kontravarianten Parameter- und den kovarianten Rückgabetypredefinitionen. Es gibt aber noch einen zweiten Ansatz zur Klärung der Frage nach der richtigen Varianz der Parametertypen redefinierter Funktionen, die diese Betrachtung deutlich in Frage stellen. Dazu soll (wie schon in Kapitel 25) die Interpretation von Methoden als Relationen bzw., da hier der Rückgabetyp mit berücksichtigt wird, als Funktionen oder Abbildungen herhalten. Der hier zweistellige Definitionsbereich (Empfängertyp plus Parametertyp) der Funktion steht dabei stellvertretend für beliebige Stellenzahl, also für Methoden mit beliebig vielen Parametern. Der Wertebereich ist hingegen immer einstellig, da eine Methode stets nur einen Wert zurückgibt.
Wenn man nun die Anzahl der Empfängerobjekte einschränkt (was ja beim Übergang zu einem Subtypen geschieht), dann schrumpft damit nicht nur der Wertebereich der Funktion (wie in Kapitel 25 schon illustriert), sondern auch die Menge der möglichen Eingabewerte (der zweite und alle weiteren Definitionsbereiche), die mit der bereits eingeschränkten Menge der Empfänger gemeinsam auftreten können. Es verhalten sich also nicht nur die Ergebnistypen, sondern auch die Parametertypen kovariant.
Dieses Ergebnis ist gewissermaßen frustrierend, da es die soeben hergeleitete Kontravarianzregel für Parametertypen infrage stellt: Was programmiertechnisch möglich und sinnvoll erscheint, hat in der Realität (der Interpretation oder Semantik) keine Bedeutung. Auf der anderen Seite erklärt es aber, warum kontravariante Parameterredefinitionen in der Programmierpraxis nicht benötigt werden. Kovarianz für Parametertypen zuzulassen, so sinnvoll es auch zu sein scheint, erlaubt jedoch typinkorrekte Programme; Sie werden im Kontext der Programmiersprache EIFFEL (Kurseinheit 5, Abschnitt 52.5) noch ausführlicher auf das Problem und eine mögliche Lösung hingewiesen.","<answer> Obwohl Kovarianz für Parametertypen auf den ersten Blick sinnvoll erscheint, kann sie in der Praxis zu typinkorrekten Programmen führen. Dies liegt daran, dass die Anzahl der möglichen Eingabewerte in einem Subtyp reduziert wird, wenn die Menge der Empfängerobjekte eingeschränkt wird. Dies führt dazu, dass die Parametertypen tatsächlich kontravariant sind. Kovarianz für Parametertypen würde typinkorrekte Programme ermöglichen. <answer> <question> Warum ist die Kovarianz für Parametertypen in der Praxis nicht notwendig und kann sogar zu typinkorrekten Programmen führen? <question>"
"In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar (und somit auch zugreifbar) [^23^]. Genauer gesagt, sind die Methoden die einzigen Stellen im gesamten Programm, an denen auf die Instanzvariablen des Objekts, dem die Methoden zugeordnet sind, direkt zugegriffen werden kann. Die Struktur des Objekts bleibt somit verborgen, und sein Zustand wird gekapselt (siehe Abschnitt 3.2 sowie unten für ein praktisches Beispiel).
Um die Belegung der Instanzvariablen und damit den Zustand eines Objekts auszulesen oder zu verändern, sind Methoden erforderlich. Beispielsweise muss das Objekt eine Methode bereitstellen, die den Wert einer Instanzvariable mit dem Namen ""a"" zurückgibt.
Diese Methode entspricht im Wesentlichen einem in JAVA gebräuchlichen sogenannten ""Getter"" für eine ansonsten nicht zugreifbare Variable. Es ist wichtig zu beachten, dass die Namensgleichheit von Methode und Variable nicht darüber hinwegtäuschen sollte, dass es sich um verschiedene Dinge handelt - Methode und Variable könnten genauso gut unterschiedliche Namen haben.Getter und Setter werden zusammen auch als ""Zugriffsmethoden"" oder ""Accessoren"" bezeichnet.
Die oben genannten Zugriffsmethoden werden aufgerufen, indem man dem Objekt, zu dem die Instanzvariable ""a"" gehört, die Nachricht ""a"" (zum Lesen) oder ""a:"" mit einem Objekt als Parameter (zum Schreiben) sendet. Das Empfängerobjekt antwortet darauf im ersten Fall, indem es ""a"" zurückgibt, und im zweiten Fall, indem es sich selbst zurückgibt. Es ist wichtig zu beachten, dass bei der Rückgabe keine Kopie, sondern der Inhalt der Variable (oder vielmehr ein Verweis darauf) zurückgegeben wird.
Auf der anderen Seite bedeutet die begrenzte Sichtbarkeit von Instanzvariablen nicht, dass der Zugriff auf Objekte, auf die sie verweisen, verhindert wird (aufgrund von möglichen Aliasen). Beachten Sie, dass sowohl ""b"" als auch die Instanzvariable ""a"" von ""anObject"" auf dasselbe Objekt verweisen, was faktisch die Kapselung des Zustands von ""anObject"" durchbricht.
Es sollte nochmals betont werden, dass im ersten Ausdruck ""a"" eine Nachricht darstellt und keinesfalls der Name der Instanzvariable des Objekts ist. Es handelt sich nicht um das Äquivalent zu dem aus JAVA bekannten ""anObject.a"", sondern vielmehr dem von ""anObject.getA()"" (wobei die Methode in JAVA per Konvention natürlich genauso gut ""a()"" genannt werden könnte). In SMALLTALK ist ein direkter Zugriff auf die Instanzvariable von außen wie in JAVA nicht möglich. Der Zugriff auf eine Instanzvariable kann also durch das Fehlen entsprechender Zugriffsmethoden verhindert werden, oder er kann auf Lesen oder Schreiben beschränkt werden, indem nur die jeweilige Zugriffsmethode zur Verfügung gestellt wird.
Schließlich sei darauf hingewiesen, dass im Gegensatz zu benannten Instanzvariablen indizierte Instanzvariablen nicht direkt, sondern nur über die beiden vordefinierten Nachrichten ""at:"" und ""at:put:"" gelesen und geschrieben werden können.
Es ist in SMALLTALK also nicht möglich, indizierte Instanzvariablen eines Objekts (im Gegensatz zu benannten) durch Nicht-Deklaration von Zugriffsmethoden zu verbergen (vor Zugriff zu schützen). Zugleich folgt aus der festen Vorgabe der beiden Zugriffsmethoden, dass jedes Objekt nur genau eine (unbenannte) Menge von indizierten Instanzvariablen haben kann.
Die ausschließliche Abfrage und Änderung des Zustandes von Objekten über Methoden hat den Vorteil, dass man sich nicht darauf festlegt, wie der Zustand eines Objekts tatsächlich codiert ist. So können beispielsweise einem Punktobjekt Methoden zum Setzen und Abfragen sowohl von kartesischen als auch von polaren Koordinaten zugeordnet werden. Dabei muss nur eine Instanzvariable für eine Art von Koordinaten vorgesehen werden, und die anderen können jeweils berechnet werden. Dies ermöglicht eine flexible Gestaltung der Zustandsrepräsentation eines Objekts, während die Schnittstelle zur Abfrage und Änderung des Zustands durch Methoden definiert wird.
Man betrachtet die Art und Weise, wie ein Objekt seinen Zustand codiert, als sein Implementationsgeheimnis und die Menge der Methodensignaturen, die den Zugriff auf das Objekt (seinen Zustand) erlauben, als sein Interface. Mehr dazu in Abschnitt 4.3.8.","<answer> In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar, um den Zustand des Objekts zu kapseln und seine Struktur vor direktem Zugriff von außen zu schützen. Dies fördert das Prinzip der Verbergen von Implementierungsdetails und ermöglicht eine flexiblere Gestaltung der Zustandsrepräsentation eines Objekts. <answer> <question> Warum sind die Instanzvariablen eines Objekts in SMALLTALK nur für das Objekt selbst sichtbar und nicht für den Zugriff von außen? <question>"
"In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar (und somit auch zugreifbar) [^23^]. Genauer gesagt, sind die Methoden die einzigen Stellen im gesamten Programm, an denen auf die Instanzvariablen des Objekts, dem die Methoden zugeordnet sind, direkt zugegriffen werden kann. Die Struktur des Objekts bleibt somit verborgen, und sein Zustand wird gekapselt (siehe Abschnitt 3.2 sowie unten für ein praktisches Beispiel).
Um die Belegung der Instanzvariablen und damit den Zustand eines Objekts auszulesen oder zu verändern, sind Methoden erforderlich. Beispielsweise muss das Objekt eine Methode bereitstellen, die den Wert einer Instanzvariable mit dem Namen ""a"" zurückgibt.
Diese Methode entspricht im Wesentlichen einem in JAVA gebräuchlichen sogenannten ""Getter"" für eine ansonsten nicht zugreifbare Variable. Es ist wichtig zu beachten, dass die Namensgleichheit von Methode und Variable nicht darüber hinwegtäuschen sollte, dass es sich um verschiedene Dinge handelt - Methode und Variable könnten genauso gut unterschiedliche Namen haben.Getter und Setter werden zusammen auch als ""Zugriffsmethoden"" oder ""Accessoren"" bezeichnet.
Die oben genannten Zugriffsmethoden werden aufgerufen, indem man dem Objekt, zu dem die Instanzvariable ""a"" gehört, die Nachricht ""a"" (zum Lesen) oder ""a:"" mit einem Objekt als Parameter (zum Schreiben) sendet. Das Empfängerobjekt antwortet darauf im ersten Fall, indem es ""a"" zurückgibt, und im zweiten Fall, indem es sich selbst zurückgibt. Es ist wichtig zu beachten, dass bei der Rückgabe keine Kopie, sondern der Inhalt der Variable (oder vielmehr ein Verweis darauf) zurückgegeben wird.
Auf der anderen Seite bedeutet die begrenzte Sichtbarkeit von Instanzvariablen nicht, dass der Zugriff auf Objekte, auf die sie verweisen, verhindert wird (aufgrund von möglichen Aliasen). Beachten Sie, dass sowohl ""b"" als auch die Instanzvariable ""a"" von ""anObject"" auf dasselbe Objekt verweisen, was faktisch die Kapselung des Zustands von ""anObject"" durchbricht.
Es sollte nochmals betont werden, dass im ersten Ausdruck ""a"" eine Nachricht darstellt und keinesfalls der Name der Instanzvariable des Objekts ist. Es handelt sich nicht um das Äquivalent zu dem aus JAVA bekannten ""anObject.a"", sondern vielmehr dem von ""anObject.getA()"" (wobei die Methode in JAVA per Konvention natürlich genauso gut ""a()"" genannt werden könnte). In SMALLTALK ist ein direkter Zugriff auf die Instanzvariable von außen wie in JAVA nicht möglich. Der Zugriff auf eine Instanzvariable kann also durch das Fehlen entsprechender Zugriffsmethoden verhindert werden, oder er kann auf Lesen oder Schreiben beschränkt werden, indem nur die jeweilige Zugriffsmethode zur Verfügung gestellt wird.
Schließlich sei darauf hingewiesen, dass im Gegensatz zu benannten Instanzvariablen indizierte Instanzvariablen nicht direkt, sondern nur über die beiden vordefinierten Nachrichten ""at:"" und ""at:put:"" gelesen und geschrieben werden können.
Es ist in SMALLTALK also nicht möglich, indizierte Instanzvariablen eines Objekts (im Gegensatz zu benannten) durch Nicht-Deklaration von Zugriffsmethoden zu verbergen (vor Zugriff zu schützen). Zugleich folgt aus der festen Vorgabe der beiden Zugriffsmethoden, dass jedes Objekt nur genau eine (unbenannte) Menge von indizierten Instanzvariablen haben kann.
Die ausschließliche Abfrage und Änderung des Zustandes von Objekten über Methoden hat den Vorteil, dass man sich nicht darauf festlegt, wie der Zustand eines Objekts tatsächlich codiert ist. So können beispielsweise einem Punktobjekt Methoden zum Setzen und Abfragen sowohl von kartesischen als auch von polaren Koordinaten zugeordnet werden. Dabei muss nur eine Instanzvariable für eine Art von Koordinaten vorgesehen werden, und die anderen können jeweils berechnet werden. Dies ermöglicht eine flexible Gestaltung der Zustandsrepräsentation eines Objekts, während die Schnittstelle zur Abfrage und Änderung des Zustands durch Methoden definiert wird.
Man betrachtet die Art und Weise, wie ein Objekt seinen Zustand codiert, als sein Implementationsgeheimnis und die Menge der Methodensignaturen, die den Zugriff auf das Objekt (seinen Zustand) erlauben, als sein Interface. Mehr dazu in Abschnitt 4.3.8.","<answer> In SMALLTALK können Zugriffsmethoden für Instanzvariablen erstellt werden, indem Methoden erstellt werden, die den Wert einer Instanzvariable zurückgeben (Getter-Methode) oder den Wert einer Instanzvariable setzen (Setter-Methode). Zum Beispiel kann eine Methode ""getA"" erstellt werden, um den Wert der Instanzvariable ""a"" zurückzugeben, und eine Methode ""setA:"" kann erstellt werden, um den Wert der Instanzvariable ""a"" zu setzen. <answer> <question> Wie können in SMALLTALK Zugriffsmethoden für Instanzvariablen erstellt werden? <question>"
"In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar (und somit auch zugreifbar) [^23^]. Genauer gesagt, sind die Methoden die einzigen Stellen im gesamten Programm, an denen auf die Instanzvariablen des Objekts, dem die Methoden zugeordnet sind, direkt zugegriffen werden kann. Die Struktur des Objekts bleibt somit verborgen, und sein Zustand wird gekapselt (siehe Abschnitt 3.2 sowie unten für ein praktisches Beispiel).
Um die Belegung der Instanzvariablen und damit den Zustand eines Objekts auszulesen oder zu verändern, sind Methoden erforderlich. Beispielsweise muss das Objekt eine Methode bereitstellen, die den Wert einer Instanzvariable mit dem Namen ""a"" zurückgibt.
Diese Methode entspricht im Wesentlichen einem in JAVA gebräuchlichen sogenannten ""Getter"" für eine ansonsten nicht zugreifbare Variable. Es ist wichtig zu beachten, dass die Namensgleichheit von Methode und Variable nicht darüber hinwegtäuschen sollte, dass es sich um verschiedene Dinge handelt - Methode und Variable könnten genauso gut unterschiedliche Namen haben.Getter und Setter werden zusammen auch als ""Zugriffsmethoden"" oder ""Accessoren"" bezeichnet.
Die oben genannten Zugriffsmethoden werden aufgerufen, indem man dem Objekt, zu dem die Instanzvariable ""a"" gehört, die Nachricht ""a"" (zum Lesen) oder ""a:"" mit einem Objekt als Parameter (zum Schreiben) sendet. Das Empfängerobjekt antwortet darauf im ersten Fall, indem es ""a"" zurückgibt, und im zweiten Fall, indem es sich selbst zurückgibt. Es ist wichtig zu beachten, dass bei der Rückgabe keine Kopie, sondern der Inhalt der Variable (oder vielmehr ein Verweis darauf) zurückgegeben wird.
Auf der anderen Seite bedeutet die begrenzte Sichtbarkeit von Instanzvariablen nicht, dass der Zugriff auf Objekte, auf die sie verweisen, verhindert wird (aufgrund von möglichen Aliasen). Beachten Sie, dass sowohl ""b"" als auch die Instanzvariable ""a"" von ""anObject"" auf dasselbe Objekt verweisen, was faktisch die Kapselung des Zustands von ""anObject"" durchbricht.
Es sollte nochmals betont werden, dass im ersten Ausdruck ""a"" eine Nachricht darstellt und keinesfalls der Name der Instanzvariable des Objekts ist. Es handelt sich nicht um das Äquivalent zu dem aus JAVA bekannten ""anObject.a"", sondern vielmehr dem von ""anObject.getA()"" (wobei die Methode in JAVA per Konvention natürlich genauso gut ""a()"" genannt werden könnte). In SMALLTALK ist ein direkter Zugriff auf die Instanzvariable von außen wie in JAVA nicht möglich. Der Zugriff auf eine Instanzvariable kann also durch das Fehlen entsprechender Zugriffsmethoden verhindert werden, oder er kann auf Lesen oder Schreiben beschränkt werden, indem nur die jeweilige Zugriffsmethode zur Verfügung gestellt wird.
Schließlich sei darauf hingewiesen, dass im Gegensatz zu benannten Instanzvariablen indizierte Instanzvariablen nicht direkt, sondern nur über die beiden vordefinierten Nachrichten ""at:"" und ""at:put:"" gelesen und geschrieben werden können.
Es ist in SMALLTALK also nicht möglich, indizierte Instanzvariablen eines Objekts (im Gegensatz zu benannten) durch Nicht-Deklaration von Zugriffsmethoden zu verbergen (vor Zugriff zu schützen). Zugleich folgt aus der festen Vorgabe der beiden Zugriffsmethoden, dass jedes Objekt nur genau eine (unbenannte) Menge von indizierten Instanzvariablen haben kann.
Die ausschließliche Abfrage und Änderung des Zustandes von Objekten über Methoden hat den Vorteil, dass man sich nicht darauf festlegt, wie der Zustand eines Objekts tatsächlich codiert ist. So können beispielsweise einem Punktobjekt Methoden zum Setzen und Abfragen sowohl von kartesischen als auch von polaren Koordinaten zugeordnet werden. Dabei muss nur eine Instanzvariable für eine Art von Koordinaten vorgesehen werden, und die anderen können jeweils berechnet werden. Dies ermöglicht eine flexible Gestaltung der Zustandsrepräsentation eines Objekts, während die Schnittstelle zur Abfrage und Änderung des Zustands durch Methoden definiert wird.
Man betrachtet die Art und Weise, wie ein Objekt seinen Zustand codiert, als sein Implementationsgeheimnis und die Menge der Methodensignaturen, die den Zugriff auf das Objekt (seinen Zustand) erlauben, als sein Interface. Mehr dazu in Abschnitt 4.3.8.","<answer> In SMALLTALK ist es nicht möglich, direkt auf die Instanzvariablen eines Objekts zuzugreifen, um die Kapselung des Zustands und das Verbergen von Implementierungsdetails zu fördern. Der Zugriff auf Instanzvariablen erfolgt stattdessen über Zugriffsmethoden, die die Leser- und Schreiberfunktionalität bereitstellen. <answer> <question> Warum ist es in SMALLTALK nicht möglich, direkt auf die Instanzvariablen eines Objekts zuzugreifen? <question>"
"In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar (und somit auch zugreifbar) [^23^]. Genauer gesagt, sind die Methoden die einzigen Stellen im gesamten Programm, an denen auf die Instanzvariablen des Objekts, dem die Methoden zugeordnet sind, direkt zugegriffen werden kann. Die Struktur des Objekts bleibt somit verborgen, und sein Zustand wird gekapselt (siehe Abschnitt 3.2 sowie unten für ein praktisches Beispiel).
Um die Belegung der Instanzvariablen und damit den Zustand eines Objekts auszulesen oder zu verändern, sind Methoden erforderlich. Beispielsweise muss das Objekt eine Methode bereitstellen, die den Wert einer Instanzvariable mit dem Namen ""a"" zurückgibt.
Diese Methode entspricht im Wesentlichen einem in JAVA gebräuchlichen sogenannten ""Getter"" für eine ansonsten nicht zugreifbare Variable. Es ist wichtig zu beachten, dass die Namensgleichheit von Methode und Variable nicht darüber hinwegtäuschen sollte, dass es sich um verschiedene Dinge handelt - Methode und Variable könnten genauso gut unterschiedliche Namen haben.Getter und Setter werden zusammen auch als ""Zugriffsmethoden"" oder ""Accessoren"" bezeichnet.
Die oben genannten Zugriffsmethoden werden aufgerufen, indem man dem Objekt, zu dem die Instanzvariable ""a"" gehört, die Nachricht ""a"" (zum Lesen) oder ""a:"" mit einem Objekt als Parameter (zum Schreiben) sendet. Das Empfängerobjekt antwortet darauf im ersten Fall, indem es ""a"" zurückgibt, und im zweiten Fall, indem es sich selbst zurückgibt. Es ist wichtig zu beachten, dass bei der Rückgabe keine Kopie, sondern der Inhalt der Variable (oder vielmehr ein Verweis darauf) zurückgegeben wird.
Auf der anderen Seite bedeutet die begrenzte Sichtbarkeit von Instanzvariablen nicht, dass der Zugriff auf Objekte, auf die sie verweisen, verhindert wird (aufgrund von möglichen Aliasen). Beachten Sie, dass sowohl ""b"" als auch die Instanzvariable ""a"" von ""anObject"" auf dasselbe Objekt verweisen, was faktisch die Kapselung des Zustands von ""anObject"" durchbricht.
Es sollte nochmals betont werden, dass im ersten Ausdruck ""a"" eine Nachricht darstellt und keinesfalls der Name der Instanzvariable des Objekts ist. Es handelt sich nicht um das Äquivalent zu dem aus JAVA bekannten ""anObject.a"", sondern vielmehr dem von ""anObject.getA()"" (wobei die Methode in JAVA per Konvention natürlich genauso gut ""a()"" genannt werden könnte). In SMALLTALK ist ein direkter Zugriff auf die Instanzvariable von außen wie in JAVA nicht möglich. Der Zugriff auf eine Instanzvariable kann also durch das Fehlen entsprechender Zugriffsmethoden verhindert werden, oder er kann auf Lesen oder Schreiben beschränkt werden, indem nur die jeweilige Zugriffsmethode zur Verfügung gestellt wird.
Schließlich sei darauf hingewiesen, dass im Gegensatz zu benannten Instanzvariablen indizierte Instanzvariablen nicht direkt, sondern nur über die beiden vordefinierten Nachrichten ""at:"" und ""at:put:"" gelesen und geschrieben werden können.
Es ist in SMALLTALK also nicht möglich, indizierte Instanzvariablen eines Objekts (im Gegensatz zu benannten) durch Nicht-Deklaration von Zugriffsmethoden zu verbergen (vor Zugriff zu schützen). Zugleich folgt aus der festen Vorgabe der beiden Zugriffsmethoden, dass jedes Objekt nur genau eine (unbenannte) Menge von indizierten Instanzvariablen haben kann.
Die ausschließliche Abfrage und Änderung des Zustandes von Objekten über Methoden hat den Vorteil, dass man sich nicht darauf festlegt, wie der Zustand eines Objekts tatsächlich codiert ist. So können beispielsweise einem Punktobjekt Methoden zum Setzen und Abfragen sowohl von kartesischen als auch von polaren Koordinaten zugeordnet werden. Dabei muss nur eine Instanzvariable für eine Art von Koordinaten vorgesehen werden, und die anderen können jeweils berechnet werden. Dies ermöglicht eine flexible Gestaltung der Zustandsrepräsentation eines Objekts, während die Schnittstelle zur Abfrage und Änderung des Zustands durch Methoden definiert wird.
Man betrachtet die Art und Weise, wie ein Objekt seinen Zustand codiert, als sein Implementationsgeheimnis und die Menge der Methodensignaturen, die den Zugriff auf das Objekt (seinen Zustand) erlauben, als sein Interface. Mehr dazu in Abschnitt 4.3.8.","<answer> In SMALLTALK können benannte Instanzvariablen direkt über ihren Namen zugegriffen werden, während indizierte Instanzvariablen nur über die vordefinierten Nachrichten ""at:"" und ""at:put:"" gelesen und geschrieben werden können. Der Zugriff auf indizierte Instanzvariablen erfolgt nicht über Zugriffsmethoden, sondern über diese Nachrichten. <answer> <question> Was ist der Unterschied zwischen einer benannten Instanzvariable und einer indizierten Instanzvariable in SMALLTALK? <question>"
"Obwohl in JAVA längst nicht alles ein Objekt ist, gibt es dennoch die Möglichkeit, auf die Elemente eines Programms zuzugreifen. Dafür ist das sog. Reflection API zuständig, in dem für jede Art von Programmelement eine Klasse existiert, deren Instanzen entsprechende Programmelemente repräsentieren. (So gibt es dort eine Klasse Method, eine Klasse Field etc.) Eine detaillierte Untersuchung dieses APIs würde an dieser Stelle jedoch zu weit führen; sie wird im Kurs 01853 („Moderne Programmiertechniken und -methoden“) ausführlicher behandelt.
Eine andere Form der Metaprogrammierung, die sog. Annotationen, hat zunächst nichts mit Objektorientierung zu tun — sie ordnen lediglich Programmmetadaten den Programmelementen im Quelltext zu. Diese können dann während der Übersetzung und/oder während der Ausführung des Programms abgefragt werden und so den jeweiligen Prozess beeinflussen oder sogar steuern. In JAVA 5 wurden Annotationen als eine spezielle Art von Interfaces eingeführt, die jedoch keine Methoden, sondern nur Felder (!) deklarieren.","<answer> Das Reflection API in JAVA ermöglicht den Zugriff auf die Elemente eines Programms, obwohl nicht alles in JAVA ein Objekt ist. Es stellt Klassen zur Verfügung, die verschiedene Programmelemente repräsentieren, wie Methoden (Klasse Method) oder Felder (Klasse Field). Dies ermöglicht es, Programmierung auf einer höheren Ebene durchzuführen, indem man dynamisch auf Programmstrukturen zugreift. Eine ausführliche Untersuchung dieses APIs wird im Kurs 01853 (""Moderne Programmiertechniken und -methoden"") behandelt. <answer> <question> Was ist das Reflection API in JAVA und wofür wird es verwendet? <question>"
"Obwohl in JAVA längst nicht alles ein Objekt ist, gibt es dennoch die Möglichkeit, auf die Elemente eines Programms zuzugreifen. Dafür ist das sog. Reflection API zuständig, in dem für jede Art von Programmelement eine Klasse existiert, deren Instanzen entsprechende Programmelemente repräsentieren. (So gibt es dort eine Klasse Method, eine Klasse Field etc.) Eine detaillierte Untersuchung dieses APIs würde an dieser Stelle jedoch zu weit führen; sie wird im Kurs 01853 („Moderne Programmiertechniken und -methoden“) ausführlicher behandelt.
Eine andere Form der Metaprogrammierung, die sog. Annotationen, hat zunächst nichts mit Objektorientierung zu tun — sie ordnen lediglich Programmmetadaten den Programmelementen im Quelltext zu. Diese können dann während der Übersetzung und/oder während der Ausführung des Programms abgefragt werden und so den jeweiligen Prozess beeinflussen oder sogar steuern. In JAVA 5 wurden Annotationen als eine spezielle Art von Interfaces eingeführt, die jedoch keine Methoden, sondern nur Felder (!) deklarieren.","<answer> Annotationen in JAVA sind eine Form der Metaprogrammierung, bei der Programmmetadaten den Programmelementen im Quelltext zugeordnet werden. Diese Metadaten können während der Übersetzung und/oder während der Ausführung des Programms abgefragt werden und den jeweiligen Prozess beeinflussen oder steuern. In JAVA 5 wurden Annotationen als eine spezielle Art von Interfaces eingeführt, die jedoch keine Methoden, sondern nur Felder deklarieren. Annotationen werden häufig verwendet, um zusätzliche Informationen oder Konfigurationen zu einem Programm hinzuzufügen. <answer> <question> Was sind Annotationen in JAVA und welche Rolle spielen sie in der Metaprogrammierung? <question>"
"C# ist nicht nur ein Nachahmer von JAVA, sondern war auch ein Pionier für Spracherweiterungen, die es inzwischen auch in JAVA gibt: So gab es in C# von Anfang an sog. Attributes, die in JAVA in der Version 5 als Annotationen (was in jedem Fall der bessere Name ist) Einzug gehalten haben. C# hatte auch schon ab der Version 3.0 Lambda-Ausdrücke (ein Element funktionaler Programmiersprachen, in SMALLTALK — in Form von Blöcken — schon immer vorhanden und ein Grundelement der Sprache); JAVA ist erst mit Version 8 nachgezogen. Die Gefahr besteht jedoch darin, dass sich die beiden Sprachen gegenseitig übertrumpfen könnten — irgendwann wird jemand auf die Idee kommen, aus den besten Eigenschaften beider eine neue Sprache zu destillieren (KOTLIN mag hier ein erstes Beispiel sein). Vielleicht wird bei der Gelegenheit auch endlich mit dem C-Erbe aufgeräumt und die fürchterliche Syntax entsorgt.","<answer> In C# gab es von Anfang an sogenannte ""Attributes"" (Attribute), die in Java in der Version 5 als ""Annotationen"" Einzug hielten. C# führte auch bereits ab Version 3.0 Lambda-Ausdrücke ein, während Java erst mit Version 8 nachzog. <answer> <question> Welche Spracherweiterungen, die später in Java eingeführt wurden, gab es bereits in C#? <question>"
"C# ist nicht nur ein Nachahmer von JAVA, sondern war auch ein Pionier für Spracherweiterungen, die es inzwischen auch in JAVA gibt: So gab es in C# von Anfang an sog. Attributes, die in JAVA in der Version 5 als Annotationen (was in jedem Fall der bessere Name ist) Einzug gehalten haben. C# hatte auch schon ab der Version 3.0 Lambda-Ausdrücke (ein Element funktionaler Programmiersprachen, in SMALLTALK — in Form von Blöcken — schon immer vorhanden und ein Grundelement der Sprache); JAVA ist erst mit Version 8 nachgezogen. Die Gefahr besteht jedoch darin, dass sich die beiden Sprachen gegenseitig übertrumpfen könnten — irgendwann wird jemand auf die Idee kommen, aus den besten Eigenschaften beider eine neue Sprache zu destillieren (KOTLIN mag hier ein erstes Beispiel sein). Vielleicht wird bei der Gelegenheit auch endlich mit dem C-Erbe aufgeräumt und die fürchterliche Syntax entsorgt.","<answer> Als mögliche Gefahr wird erwähnt, dass die beiden Sprachen sich gegenseitig übertrumpfen könnten. Es besteht die Möglichkeit, dass jemand auf die Idee kommt, die besten Eigenschaften beider Sprachen zu kombinieren und eine neue Sprache zu entwickeln. Dies könnte auch eine Gelegenheit sein, sich von den Syntax-Erben aus der C-Welt zu verabschieden. <answer> <question> Was wird als mögliche Gefahr hinsichtlich der Entwicklung von C# und Java erwähnt? <question>"
"C++ ist eine sehr komplexe Sprache. Ihre Beherrschung dauert Jahre, selbst bei täglichem Umgang mit ihr; sie zu lehren erscheint fast aussichtslos. Selbst wenn man die zahlreichen Konstrukte der Sprache der Reihe nach durchginge, ergibt sich die eigentliche Komplexität erst aus deren kombinierter Verwendung, und die Zahl der Möglichkeiten ist den Gesetzen der Kombinatorik folgend hoch. Entsprechend groß ist auch die Zahl der Idiome (Wendungen), die es für C++ gibt. Auch wenn längst nicht alle Beiträge zur Komplexität von C++ in Zusammenhang mit der Objektorientierung stehen, so ist es doch schwierig, sie davon zu trennen. Deshalb soll es an dieser Stelle auch genug damit sein.","<answer> C++ wird als eine sehr komplexe Sprache beschrieben, weil ihre Beherrschung Jahre dauern kann, selbst bei täglichem Umgang mit ihr. Die eigentliche Komplexität ergibt sich aus der kombinierten Verwendung ihrer zahlreichen Konstrukte, und die Möglichkeiten sind vielfältig. <answer> <question> Warum wird C++ als eine sehr komplexe Sprache beschrieben? <question>"
"C++ ist eine sehr komplexe Sprache. Ihre Beherrschung dauert Jahre, selbst bei täglichem Umgang mit ihr; sie zu lehren erscheint fast aussichtslos. Selbst wenn man die zahlreichen Konstrukte der Sprache der Reihe nach durchginge, ergibt sich die eigentliche Komplexität erst aus deren kombinierter Verwendung, und die Zahl der Möglichkeiten ist den Gesetzen der Kombinatorik folgend hoch. Entsprechend groß ist auch die Zahl der Idiome (Wendungen), die es für C++ gibt. Auch wenn längst nicht alle Beiträge zur Komplexität von C++ in Zusammenhang mit der Objektorientierung stehen, so ist es doch schwierig, sie davon zu trennen. Deshalb soll es an dieser Stelle auch genug damit sein.","<answer> Es ist schwer, C++ zu lehren, weil die Sprache sehr komplex ist und die Kombinatorik ihrer Konstrukte zu einer hohen Zahl von Möglichkeiten führt. Die Vielzahl von Idiomen (Wendungen) in C++ trägt ebenfalls zur Komplexität bei. <answer> <question> Warum ist es schwer, C++ zu lehren? <question>"
"C++ ist eine sehr komplexe Sprache. Ihre Beherrschung dauert Jahre, selbst bei täglichem Umgang mit ihr; sie zu lehren erscheint fast aussichtslos. Selbst wenn man die zahlreichen Konstrukte der Sprache der Reihe nach durchginge, ergibt sich die eigentliche Komplexität erst aus deren kombinierter Verwendung, und die Zahl der Möglichkeiten ist den Gesetzen der Kombinatorik folgend hoch. Entsprechend groß ist auch die Zahl der Idiome (Wendungen), die es für C++ gibt. Auch wenn längst nicht alle Beiträge zur Komplexität von C++ in Zusammenhang mit der Objektorientierung stehen, so ist es doch schwierig, sie davon zu trennen. Deshalb soll es an dieser Stelle auch genug damit sein.","<answer> Es ist schwierig, die Komplexität von C++ von der Objektorientierung zu trennen, weil viele Beiträge zur Komplexität von C++ in Zusammenhang mit der Objektorientierung stehen. Die Kombination von objektorientierten Konzepten und anderen Sprachmerkmalen macht C++ zu einer komplexen Sprache. <answer> <question> Warum ist es schwierig, die Komplexität von C++ von der Objektorientierung zu trennen? <question>"
"Unter Vererbung versteht man in der objektorientierten Programmierung die Übertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere. Vererbung dient vor allem der Wiederverwendung von Code und damit der Ökonomie in der Softwareentwicklung.
Wenn man das Prinzip von Generalisierung und Spezialisierung vor Augen hat, dann ist die Vererbung eigentlich nur noch ein Mechanismus, der Definitionen von einer Klasse auf eine andere überträgt. So wird jede benannte Instanzvariable, die in einer Generalisierung deklariert ist, nicht nur für Instanzen dieser Generalisierung (so sie denn welche hat) angelegt, sondern auch für die Instanzen all ihrer Spezialisierungen. Analog stehen Methoden, die in einer Generalisierung definiert werden, auch ihren Spezialisierungen zur Verfügung, und zwar beinahe so, als wären sie in den Spezialisierungen definiert.
Spezialisierung und Vererbung scheinen also Hand in Hand zu gehen. Doch ist dies nur solange der Fall, wie man von der Spezialisierung ausgeht und die Vererbung als ökonomisches Abfallprodukt erhält. In der Praxis lässt man sich jedoch leider häufig von oberflächlichen Gewinnerwartungen leiten und folgt der (vermeintlichen) Ökonomie der Vererbung, ohne dabei auf die Prinzipien von Generalisierung und Spezialisierung einzugehen. Obiges Beispiel von Pinguinen und Vögeln hatte bereits gezeigt, zu welchen Komplikationen eine unbedachte Spezialisierung führen kann; im Folgenden soll gezeigt werden, zu welchen Problemen eine Fixierung auf die Nutzung der Vererbung führt.
Nun möchte man eine zweite Klasse Rechteck definieren und dabei ausnutzen, dass man bereits eine ähnliche Klasse, nämlich Quadrat, hat. Aus Quadrat könnte man nämlich die Instanzvariable laenge übernehmen. (Das Beispiel wurde absichtlich einfach gewählt, auch wenn es dadurch wenig überzeugend wirkt; das Problem sollte aber trotzdem klar werden.)
Was die Instanzvariablen angeht, so muss Rechteck die Instanzvariable laenge nicht neu definieren, sondern lediglich breite hinzufügen. Allerdings können die Methoden zur Berechnung von Fläche und Umfang nicht mitgeerbt werden, obwohl Quadrate und Rechtecke die Eigenschaft teilen, über solche Merkmale zu verfügen. Die entsprechenden Methoden müssen also in Rechteck neu definiert werden. Man nennt das Überschreiben, weil die neuen Methoden dasselbe tun wie die alten. Die Möglichkeit des Überschreibens ist häufig Voraussetzung dafür, Vererbung überhaupt sinnvoll einzusetzen.
Wenn man nun glaubt, man hätte gleichzeitig mit der Vererbung auch eine Spezialisierungs- bzw. Generalisierungsbeziehung geschaffen, irrt man sich: Die Menge der Quadrate enthält nicht die Menge der Rechtecke, was eine charakteristische Begleiterscheinung der Generalisierung gewesen wäre. Dass die Intension von Rechteck umfangreicher ist als die von Quadrat (sie enthält eine Instanzvariable mehr), ist eine Täuschung: Ein Quadrat hat, genau wie ein Rechteck, vier Seiten, nur ist die Bedingung für diese vier Seiten in Quadraten die, dass sie alle gleich lang sind, so dass man sich drei Instanzvariablen sparen kann; für Rechtecke sind nur jeweils zwei Seiten gleich lang, so dass man sich nur zwei Instanzvariablen spart. Die Intension für Quadrate ist aber trotzdem restriktiver als die für Rechtecke (sie enthält eine zusätzliche Bedingung), so dass der inverse Zusammenhang von Intension und Extension auch für Quadrate und Rechtecke gilt: je größer die Intension, desto kleiner die Extension (und umgekehrt).
Das Problem mit der Vererbung ist nun, dass sie auf die oberflächliche Wiederverwendung von Elementen einer Klassendefinition ausgerichtet ist. Sie lässt dabei insbesondere den Zusammenhang der Extensionen der beteiligten Klassen, der für Generalisierung/Spezialisierung wesentlich ist, außer Acht. Diese Ignoranz hat jedoch weitreichende Konsequenzen, die wir in Kapitel 26 von Kurseinheit 3 noch kennenlernen werden.
Man hätte nun auch umgekehrt vorgehen können und dabei das Prinzip von Generalisierung und Spezialisierung hochhalten können, indem man Quadrat von Rechteck erben lässt (sofern man akzeptiert, dass die Generalisierung Rechteck eigene Instanzen hat). Der Nachteil dieses Ansatzes wäre jedoch, dass Quadrat dann ebenfalls zwei Instanzvariablen für Seitenlängen hätte, obwohl eine ausgereicht hätte. Auf der anderen Seite hätte man die Methoden für Fläche und Umfang nicht überschreiben müssen, denn wenn laenge und breite gleich sind, unterscheiden sich die beiden obigen Implementierungen von flaeche und umfang im Ergebnis nicht. Man muss nur sicherstellen, dass in Instanzen von Quadrat laenge und breite tatsächlich immer gleiche Werte haben.
Nun kann man aber auch auf die Idee kommen, die zu viel geerbte Instanzvariable breite einfach wieder zu löschen. Tatsächlich ist dies vom Standpunkt der Vererbung aus kein Problem: Genauso, wie man Teile der Definition überschreiben kann, kann man sie auch löschen. Im konkreten Fall der Klasse Quadrat, die von Rechteck erbt, müsste man mit dem Löschen von breite aber auch die Methoden flaeche und umfang überschreiben. (Das Löschen von Methoden wäre auch möglich, wird hier aber nicht gebraucht.)
Was bleibt, ist ein Eindruck von Beliebigkeit bei der Vererbungsrichtung, die für Generalisierung/Spezialisierung nicht existiert. In gewisser Weise spiegeln Generalisierung/Spezialisierung und Vererbung auch zwei verschiedene Weltansichten wider: Generalisierung/Spezialisierung steht für die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze (die sog. Client-Schnittstelle), Vererbung für die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung (die Vererbungsschnittstelle). Vererbung stellt eine Art genetischen Zusammenhang zwischen Klassen dar, der deren Entstehung aus Vorhandenem widerspiegelt, Generalisierung/Spezialisierung eher eine abstrakte Ordnung. Vererbung bringt Komplexität in ein System, Generalisierung/Spezialisierung versucht, sie durch Strukturierung zu reduzieren. Wie Sie gesehen haben, führen beide Sichten nicht automatisch zum selben Ergebnis; sie zu vereinen ist die hohe Kunst des objektorientierten Entwurfs.","<answer> In der objektorientierten Programmierung bezieht sich Vererbung auf die Übertragung der Definition von Eigenschaften und Verhalten von einer Klasse auf eine andere. Der Zweck der Vererbung besteht vor allem darin, Code wiederzuverwenden und die Ökonomie in der Softwareentwicklung zu verbessern. <answer> <question> Was versteht man in der objektorientierten Programmierung unter Vererbung, und welchen Zweck erfüllt sie? <question>"
"Unter Vererbung versteht man in der objektorientierten Programmierung die Übertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere. Vererbung dient vor allem der Wiederverwendung von Code und damit der Ökonomie in der Softwareentwicklung.
Wenn man das Prinzip von Generalisierung und Spezialisierung vor Augen hat, dann ist die Vererbung eigentlich nur noch ein Mechanismus, der Definitionen von einer Klasse auf eine andere überträgt. So wird jede benannte Instanzvariable, die in einer Generalisierung deklariert ist, nicht nur für Instanzen dieser Generalisierung (so sie denn welche hat) angelegt, sondern auch für die Instanzen all ihrer Spezialisierungen. Analog stehen Methoden, die in einer Generalisierung definiert werden, auch ihren Spezialisierungen zur Verfügung, und zwar beinahe so, als wären sie in den Spezialisierungen definiert.
Spezialisierung und Vererbung scheinen also Hand in Hand zu gehen. Doch ist dies nur solange der Fall, wie man von der Spezialisierung ausgeht und die Vererbung als ökonomisches Abfallprodukt erhält. In der Praxis lässt man sich jedoch leider häufig von oberflächlichen Gewinnerwartungen leiten und folgt der (vermeintlichen) Ökonomie der Vererbung, ohne dabei auf die Prinzipien von Generalisierung und Spezialisierung einzugehen. Obiges Beispiel von Pinguinen und Vögeln hatte bereits gezeigt, zu welchen Komplikationen eine unbedachte Spezialisierung führen kann; im Folgenden soll gezeigt werden, zu welchen Problemen eine Fixierung auf die Nutzung der Vererbung führt.
Nun möchte man eine zweite Klasse Rechteck definieren und dabei ausnutzen, dass man bereits eine ähnliche Klasse, nämlich Quadrat, hat. Aus Quadrat könnte man nämlich die Instanzvariable laenge übernehmen. (Das Beispiel wurde absichtlich einfach gewählt, auch wenn es dadurch wenig überzeugend wirkt; das Problem sollte aber trotzdem klar werden.)
Was die Instanzvariablen angeht, so muss Rechteck die Instanzvariable laenge nicht neu definieren, sondern lediglich breite hinzufügen. Allerdings können die Methoden zur Berechnung von Fläche und Umfang nicht mitgeerbt werden, obwohl Quadrate und Rechtecke die Eigenschaft teilen, über solche Merkmale zu verfügen. Die entsprechenden Methoden müssen also in Rechteck neu definiert werden. Man nennt das Überschreiben, weil die neuen Methoden dasselbe tun wie die alten. Die Möglichkeit des Überschreibens ist häufig Voraussetzung dafür, Vererbung überhaupt sinnvoll einzusetzen.
Wenn man nun glaubt, man hätte gleichzeitig mit der Vererbung auch eine Spezialisierungs- bzw. Generalisierungsbeziehung geschaffen, irrt man sich: Die Menge der Quadrate enthält nicht die Menge der Rechtecke, was eine charakteristische Begleiterscheinung der Generalisierung gewesen wäre. Dass die Intension von Rechteck umfangreicher ist als die von Quadrat (sie enthält eine Instanzvariable mehr), ist eine Täuschung: Ein Quadrat hat, genau wie ein Rechteck, vier Seiten, nur ist die Bedingung für diese vier Seiten in Quadraten die, dass sie alle gleich lang sind, so dass man sich drei Instanzvariablen sparen kann; für Rechtecke sind nur jeweils zwei Seiten gleich lang, so dass man sich nur zwei Instanzvariablen spart. Die Intension für Quadrate ist aber trotzdem restriktiver als die für Rechtecke (sie enthält eine zusätzliche Bedingung), so dass der inverse Zusammenhang von Intension und Extension auch für Quadrate und Rechtecke gilt: je größer die Intension, desto kleiner die Extension (und umgekehrt).
Das Problem mit der Vererbung ist nun, dass sie auf die oberflächliche Wiederverwendung von Elementen einer Klassendefinition ausgerichtet ist. Sie lässt dabei insbesondere den Zusammenhang der Extensionen der beteiligten Klassen, der für Generalisierung/Spezialisierung wesentlich ist, außer Acht. Diese Ignoranz hat jedoch weitreichende Konsequenzen, die wir in Kapitel 26 von Kurseinheit 3 noch kennenlernen werden.
Man hätte nun auch umgekehrt vorgehen können und dabei das Prinzip von Generalisierung und Spezialisierung hochhalten können, indem man Quadrat von Rechteck erben lässt (sofern man akzeptiert, dass die Generalisierung Rechteck eigene Instanzen hat). Der Nachteil dieses Ansatzes wäre jedoch, dass Quadrat dann ebenfalls zwei Instanzvariablen für Seitenlängen hätte, obwohl eine ausgereicht hätte. Auf der anderen Seite hätte man die Methoden für Fläche und Umfang nicht überschreiben müssen, denn wenn laenge und breite gleich sind, unterscheiden sich die beiden obigen Implementierungen von flaeche und umfang im Ergebnis nicht. Man muss nur sicherstellen, dass in Instanzen von Quadrat laenge und breite tatsächlich immer gleiche Werte haben.
Nun kann man aber auch auf die Idee kommen, die zu viel geerbte Instanzvariable breite einfach wieder zu löschen. Tatsächlich ist dies vom Standpunkt der Vererbung aus kein Problem: Genauso, wie man Teile der Definition überschreiben kann, kann man sie auch löschen. Im konkreten Fall der Klasse Quadrat, die von Rechteck erbt, müsste man mit dem Löschen von breite aber auch die Methoden flaeche und umfang überschreiben. (Das Löschen von Methoden wäre auch möglich, wird hier aber nicht gebraucht.)
Was bleibt, ist ein Eindruck von Beliebigkeit bei der Vererbungsrichtung, die für Generalisierung/Spezialisierung nicht existiert. In gewisser Weise spiegeln Generalisierung/Spezialisierung und Vererbung auch zwei verschiedene Weltansichten wider: Generalisierung/Spezialisierung steht für die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze (die sog. Client-Schnittstelle), Vererbung für die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung (die Vererbungsschnittstelle). Vererbung stellt eine Art genetischen Zusammenhang zwischen Klassen dar, der deren Entstehung aus Vorhandenem widerspiegelt, Generalisierung/Spezialisierung eher eine abstrakte Ordnung. Vererbung bringt Komplexität in ein System, Generalisierung/Spezialisierung versucht, sie durch Strukturierung zu reduzieren. Wie Sie gesehen haben, führen beide Sichten nicht automatisch zum selben Ergebnis; sie zu vereinen ist die hohe Kunst des objektorientierten Entwurfs.","<answer> Die Prinzipien von Generalisierung und Spezialisierung gehen der Vererbung voraus. Generalisierung und Spezialisierung sind eng mit der Vererbung verbunden, da Vererbung oft verwendet wird, um diese Prinzipien umzusetzen. Generalisierung ist die Bildung von allgemeineren Klassen aus spezifischeren Klassen, während Spezialisierung die Bildung spezifischerer Klassen aus allgemeineren Klassen ist. <answer> <question> Welches Prinzip geht der Vererbung voraus und wie stehen sie in Beziehung zueinander? <question>"
"Unter Vererbung versteht man in der objektorientierten Programmierung die Übertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere. Vererbung dient vor allem der Wiederverwendung von Code und damit der Ökonomie in der Softwareentwicklung.
Wenn man das Prinzip von Generalisierung und Spezialisierung vor Augen hat, dann ist die Vererbung eigentlich nur noch ein Mechanismus, der Definitionen von einer Klasse auf eine andere überträgt. So wird jede benannte Instanzvariable, die in einer Generalisierung deklariert ist, nicht nur für Instanzen dieser Generalisierung (so sie denn welche hat) angelegt, sondern auch für die Instanzen all ihrer Spezialisierungen. Analog stehen Methoden, die in einer Generalisierung definiert werden, auch ihren Spezialisierungen zur Verfügung, und zwar beinahe so, als wären sie in den Spezialisierungen definiert.
Spezialisierung und Vererbung scheinen also Hand in Hand zu gehen. Doch ist dies nur solange der Fall, wie man von der Spezialisierung ausgeht und die Vererbung als ökonomisches Abfallprodukt erhält. In der Praxis lässt man sich jedoch leider häufig von oberflächlichen Gewinnerwartungen leiten und folgt der (vermeintlichen) Ökonomie der Vererbung, ohne dabei auf die Prinzipien von Generalisierung und Spezialisierung einzugehen. Obiges Beispiel von Pinguinen und Vögeln hatte bereits gezeigt, zu welchen Komplikationen eine unbedachte Spezialisierung führen kann; im Folgenden soll gezeigt werden, zu welchen Problemen eine Fixierung auf die Nutzung der Vererbung führt.
Nun möchte man eine zweite Klasse Rechteck definieren und dabei ausnutzen, dass man bereits eine ähnliche Klasse, nämlich Quadrat, hat. Aus Quadrat könnte man nämlich die Instanzvariable laenge übernehmen. (Das Beispiel wurde absichtlich einfach gewählt, auch wenn es dadurch wenig überzeugend wirkt; das Problem sollte aber trotzdem klar werden.)
Was die Instanzvariablen angeht, so muss Rechteck die Instanzvariable laenge nicht neu definieren, sondern lediglich breite hinzufügen. Allerdings können die Methoden zur Berechnung von Fläche und Umfang nicht mitgeerbt werden, obwohl Quadrate und Rechtecke die Eigenschaft teilen, über solche Merkmale zu verfügen. Die entsprechenden Methoden müssen also in Rechteck neu definiert werden. Man nennt das Überschreiben, weil die neuen Methoden dasselbe tun wie die alten. Die Möglichkeit des Überschreibens ist häufig Voraussetzung dafür, Vererbung überhaupt sinnvoll einzusetzen.
Wenn man nun glaubt, man hätte gleichzeitig mit der Vererbung auch eine Spezialisierungs- bzw. Generalisierungsbeziehung geschaffen, irrt man sich: Die Menge der Quadrate enthält nicht die Menge der Rechtecke, was eine charakteristische Begleiterscheinung der Generalisierung gewesen wäre. Dass die Intension von Rechteck umfangreicher ist als die von Quadrat (sie enthält eine Instanzvariable mehr), ist eine Täuschung: Ein Quadrat hat, genau wie ein Rechteck, vier Seiten, nur ist die Bedingung für diese vier Seiten in Quadraten die, dass sie alle gleich lang sind, so dass man sich drei Instanzvariablen sparen kann; für Rechtecke sind nur jeweils zwei Seiten gleich lang, so dass man sich nur zwei Instanzvariablen spart. Die Intension für Quadrate ist aber trotzdem restriktiver als die für Rechtecke (sie enthält eine zusätzliche Bedingung), so dass der inverse Zusammenhang von Intension und Extension auch für Quadrate und Rechtecke gilt: je größer die Intension, desto kleiner die Extension (und umgekehrt).
Das Problem mit der Vererbung ist nun, dass sie auf die oberflächliche Wiederverwendung von Elementen einer Klassendefinition ausgerichtet ist. Sie lässt dabei insbesondere den Zusammenhang der Extensionen der beteiligten Klassen, der für Generalisierung/Spezialisierung wesentlich ist, außer Acht. Diese Ignoranz hat jedoch weitreichende Konsequenzen, die wir in Kapitel 26 von Kurseinheit 3 noch kennenlernen werden.
Man hätte nun auch umgekehrt vorgehen können und dabei das Prinzip von Generalisierung und Spezialisierung hochhalten können, indem man Quadrat von Rechteck erben lässt (sofern man akzeptiert, dass die Generalisierung Rechteck eigene Instanzen hat). Der Nachteil dieses Ansatzes wäre jedoch, dass Quadrat dann ebenfalls zwei Instanzvariablen für Seitenlängen hätte, obwohl eine ausgereicht hätte. Auf der anderen Seite hätte man die Methoden für Fläche und Umfang nicht überschreiben müssen, denn wenn laenge und breite gleich sind, unterscheiden sich die beiden obigen Implementierungen von flaeche und umfang im Ergebnis nicht. Man muss nur sicherstellen, dass in Instanzen von Quadrat laenge und breite tatsächlich immer gleiche Werte haben.
Nun kann man aber auch auf die Idee kommen, die zu viel geerbte Instanzvariable breite einfach wieder zu löschen. Tatsächlich ist dies vom Standpunkt der Vererbung aus kein Problem: Genauso, wie man Teile der Definition überschreiben kann, kann man sie auch löschen. Im konkreten Fall der Klasse Quadrat, die von Rechteck erbt, müsste man mit dem Löschen von breite aber auch die Methoden flaeche und umfang überschreiben. (Das Löschen von Methoden wäre auch möglich, wird hier aber nicht gebraucht.)
Was bleibt, ist ein Eindruck von Beliebigkeit bei der Vererbungsrichtung, die für Generalisierung/Spezialisierung nicht existiert. In gewisser Weise spiegeln Generalisierung/Spezialisierung und Vererbung auch zwei verschiedene Weltansichten wider: Generalisierung/Spezialisierung steht für die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze (die sog. Client-Schnittstelle), Vererbung für die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung (die Vererbungsschnittstelle). Vererbung stellt eine Art genetischen Zusammenhang zwischen Klassen dar, der deren Entstehung aus Vorhandenem widerspiegelt, Generalisierung/Spezialisierung eher eine abstrakte Ordnung. Vererbung bringt Komplexität in ein System, Generalisierung/Spezialisierung versucht, sie durch Strukturierung zu reduzieren. Wie Sie gesehen haben, führen beide Sichten nicht automatisch zum selben Ergebnis; sie zu vereinen ist die hohe Kunst des objektorientierten Entwurfs.","<answer> Ein Problem bei der Vererbung tritt auf, wenn sie oberflächlich zur Wiederverwendung von Elementen einer Klassendefinition verwendet wird, ohne die Prinzipien von Generalisierung und Spezialisierung zu berücksichtigen. Dies kann dazu führen, dass die Beziehung zwischen den Extensionen der beteiligten Klassen nicht angemessen berücksichtigt wird und zu unerwarteten Konsequenzen führt. <answer> <question> Welches Problem kann bei der Vererbung auftreten, wenn sie nicht in Einklang mit den Prinzipien von Generalisierung und Spezialisierung angewendet wird? <question>"
"Unter Vererbung versteht man in der objektorientierten Programmierung die Übertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere. Vererbung dient vor allem der Wiederverwendung von Code und damit der Ökonomie in der Softwareentwicklung.
Wenn man das Prinzip von Generalisierung und Spezialisierung vor Augen hat, dann ist die Vererbung eigentlich nur noch ein Mechanismus, der Definitionen von einer Klasse auf eine andere überträgt. So wird jede benannte Instanzvariable, die in einer Generalisierung deklariert ist, nicht nur für Instanzen dieser Generalisierung (so sie denn welche hat) angelegt, sondern auch für die Instanzen all ihrer Spezialisierungen. Analog stehen Methoden, die in einer Generalisierung definiert werden, auch ihren Spezialisierungen zur Verfügung, und zwar beinahe so, als wären sie in den Spezialisierungen definiert.
Spezialisierung und Vererbung scheinen also Hand in Hand zu gehen. Doch ist dies nur solange der Fall, wie man von der Spezialisierung ausgeht und die Vererbung als ökonomisches Abfallprodukt erhält. In der Praxis lässt man sich jedoch leider häufig von oberflächlichen Gewinnerwartungen leiten und folgt der (vermeintlichen) Ökonomie der Vererbung, ohne dabei auf die Prinzipien von Generalisierung und Spezialisierung einzugehen. Obiges Beispiel von Pinguinen und Vögeln hatte bereits gezeigt, zu welchen Komplikationen eine unbedachte Spezialisierung führen kann; im Folgenden soll gezeigt werden, zu welchen Problemen eine Fixierung auf die Nutzung der Vererbung führt.
Nun möchte man eine zweite Klasse Rechteck definieren und dabei ausnutzen, dass man bereits eine ähnliche Klasse, nämlich Quadrat, hat. Aus Quadrat könnte man nämlich die Instanzvariable laenge übernehmen. (Das Beispiel wurde absichtlich einfach gewählt, auch wenn es dadurch wenig überzeugend wirkt; das Problem sollte aber trotzdem klar werden.)
Was die Instanzvariablen angeht, so muss Rechteck die Instanzvariable laenge nicht neu definieren, sondern lediglich breite hinzufügen. Allerdings können die Methoden zur Berechnung von Fläche und Umfang nicht mitgeerbt werden, obwohl Quadrate und Rechtecke die Eigenschaft teilen, über solche Merkmale zu verfügen. Die entsprechenden Methoden müssen also in Rechteck neu definiert werden. Man nennt das Überschreiben, weil die neuen Methoden dasselbe tun wie die alten. Die Möglichkeit des Überschreibens ist häufig Voraussetzung dafür, Vererbung überhaupt sinnvoll einzusetzen.
Wenn man nun glaubt, man hätte gleichzeitig mit der Vererbung auch eine Spezialisierungs- bzw. Generalisierungsbeziehung geschaffen, irrt man sich: Die Menge der Quadrate enthält nicht die Menge der Rechtecke, was eine charakteristische Begleiterscheinung der Generalisierung gewesen wäre. Dass die Intension von Rechteck umfangreicher ist als die von Quadrat (sie enthält eine Instanzvariable mehr), ist eine Täuschung: Ein Quadrat hat, genau wie ein Rechteck, vier Seiten, nur ist die Bedingung für diese vier Seiten in Quadraten die, dass sie alle gleich lang sind, so dass man sich drei Instanzvariablen sparen kann; für Rechtecke sind nur jeweils zwei Seiten gleich lang, so dass man sich nur zwei Instanzvariablen spart. Die Intension für Quadrate ist aber trotzdem restriktiver als die für Rechtecke (sie enthält eine zusätzliche Bedingung), so dass der inverse Zusammenhang von Intension und Extension auch für Quadrate und Rechtecke gilt: je größer die Intension, desto kleiner die Extension (und umgekehrt).
Das Problem mit der Vererbung ist nun, dass sie auf die oberflächliche Wiederverwendung von Elementen einer Klassendefinition ausgerichtet ist. Sie lässt dabei insbesondere den Zusammenhang der Extensionen der beteiligten Klassen, der für Generalisierung/Spezialisierung wesentlich ist, außer Acht. Diese Ignoranz hat jedoch weitreichende Konsequenzen, die wir in Kapitel 26 von Kurseinheit 3 noch kennenlernen werden.
Man hätte nun auch umgekehrt vorgehen können und dabei das Prinzip von Generalisierung und Spezialisierung hochhalten können, indem man Quadrat von Rechteck erben lässt (sofern man akzeptiert, dass die Generalisierung Rechteck eigene Instanzen hat). Der Nachteil dieses Ansatzes wäre jedoch, dass Quadrat dann ebenfalls zwei Instanzvariablen für Seitenlängen hätte, obwohl eine ausgereicht hätte. Auf der anderen Seite hätte man die Methoden für Fläche und Umfang nicht überschreiben müssen, denn wenn laenge und breite gleich sind, unterscheiden sich die beiden obigen Implementierungen von flaeche und umfang im Ergebnis nicht. Man muss nur sicherstellen, dass in Instanzen von Quadrat laenge und breite tatsächlich immer gleiche Werte haben.
Nun kann man aber auch auf die Idee kommen, die zu viel geerbte Instanzvariable breite einfach wieder zu löschen. Tatsächlich ist dies vom Standpunkt der Vererbung aus kein Problem: Genauso, wie man Teile der Definition überschreiben kann, kann man sie auch löschen. Im konkreten Fall der Klasse Quadrat, die von Rechteck erbt, müsste man mit dem Löschen von breite aber auch die Methoden flaeche und umfang überschreiben. (Das Löschen von Methoden wäre auch möglich, wird hier aber nicht gebraucht.)
Was bleibt, ist ein Eindruck von Beliebigkeit bei der Vererbungsrichtung, die für Generalisierung/Spezialisierung nicht existiert. In gewisser Weise spiegeln Generalisierung/Spezialisierung und Vererbung auch zwei verschiedene Weltansichten wider: Generalisierung/Spezialisierung steht für die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze (die sog. Client-Schnittstelle), Vererbung für die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung (die Vererbungsschnittstelle). Vererbung stellt eine Art genetischen Zusammenhang zwischen Klassen dar, der deren Entstehung aus Vorhandenem widerspiegelt, Generalisierung/Spezialisierung eher eine abstrakte Ordnung. Vererbung bringt Komplexität in ein System, Generalisierung/Spezialisierung versucht, sie durch Strukturierung zu reduzieren. Wie Sie gesehen haben, führen beide Sichten nicht automatisch zum selben Ergebnis; sie zu vereinen ist die hohe Kunst des objektorientierten Entwurfs.","<answer> Generalisierung/Spezialisierung repräsentieren die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze (Client-Schnittstelle). Vererbung hingegen repräsentiert die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung (Vererbungsschnittstelle). Generalisierung/Spezialisierung versuchen, Komplexität durch Strukturierung zu reduzieren, während Vererbung eine Art genetischen Zusammenhang zwischen Klassen darstellt, der deren Entstehung aus Vorhandenem widerspiegelt. Beide Sichten führen nicht automatisch zum selben Ergebnis, und die Kunst des objektorientierten Entwurfs besteht darin, sie in Einklang zu bringen. <answer> <question> Wie unterscheiden sich die Weltansichten von Generalisierung/Spezialisierung und Vererbung? <question>"
"In SMALLTALK muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. So kann also insbesondere self nicht (wie beispielsweise this in JAVA) weggelassen werden, wenn ein Objekt eine Nachricht an sich selbst senden möchte. Wie bereits in Abschnitt 4.3.1 erwähnt, bezeichnet die Pseudovariable self immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind. (Die einzige Ausnahme hiervon bilden Blöcke, in denen self sich auf den Empfänger des Home-Kontexts bezieht; siehe Abschnitt 4.4.1 in Kurseinheit 1).
Dabei ist allerdings zu beachten, dass die Klasse des durch self bezeichneten Objekts nicht unbedingt dieselbe sein muss, in der die gerade ausgeführte Methode (in der auch das self steht) definiert ist, denn das kann ja aufgrund von Vererbung durchaus eine Superklasse sein. Das hat eine fundamentale Auswirkung: Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden, nämlich dann, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde.
Man beachte, dass Vererbung tatsächlich eine Kopieren-und-Einfügen-Semantik hat, wie in Abschnitt 11.2 bereits nahegelegt: Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.
Während offene Rekursion im gegebenen Beispiel durchaus erwünscht ist und ihr Effekt wohl auch den Erwartungen der Programmiererin entspricht, ergeben sich doch immer wieder Konstellationen, in denen man unangenehm überrascht wird. Das Problem ist unter dem Namen ""Fragile-base-class-Problem"" bekannt geworden; es wird in Kapitel 55 (Kurseinheit 6) ausführlicher behandelt. Fragile-base-class-Probleme entstehen durch die Möglichkeit der offenen Rekursion.","<answer> In SMALLTALK muss das Empfängerobjekt einer Nachricht immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. Dies unterscheidet sich von einigen anderen Programmiersprachen wie JAVA, in denen das Empfängerobjekt manchmal implizit ist. Die Verwendung von self ist notwendig, um das Objekt zu identifizieren, auf dem die Methode ausgeführt wird, und auf dessen Instanzvariablen zugegriffen werden kann. <answer> <question> Warum muss in SMALLTALK das Empfängerobjekt einer Nachricht immer explizit angegeben werden? <question>"
"In SMALLTALK muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. So kann also insbesondere self nicht (wie beispielsweise this in JAVA) weggelassen werden, wenn ein Objekt eine Nachricht an sich selbst senden möchte. Wie bereits in Abschnitt 4.3.1 erwähnt, bezeichnet die Pseudovariable self immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind. (Die einzige Ausnahme hiervon bilden Blöcke, in denen self sich auf den Empfänger des Home-Kontexts bezieht; siehe Abschnitt 4.4.1 in Kurseinheit 1).
Dabei ist allerdings zu beachten, dass die Klasse des durch self bezeichneten Objekts nicht unbedingt dieselbe sein muss, in der die gerade ausgeführte Methode (in der auch das self steht) definiert ist, denn das kann ja aufgrund von Vererbung durchaus eine Superklasse sein. Das hat eine fundamentale Auswirkung: Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden, nämlich dann, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde.
Man beachte, dass Vererbung tatsächlich eine Kopieren-und-Einfügen-Semantik hat, wie in Abschnitt 11.2 bereits nahegelegt: Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.
Während offene Rekursion im gegebenen Beispiel durchaus erwünscht ist und ihr Effekt wohl auch den Erwartungen der Programmiererin entspricht, ergeben sich doch immer wieder Konstellationen, in denen man unangenehm überrascht wird. Das Problem ist unter dem Namen ""Fragile-base-class-Problem"" bekannt geworden; es wird in Kapitel 55 (Kurseinheit 6) ausführlicher behandelt. Fragile-base-class-Probleme entstehen durch die Möglichkeit der offenen Rekursion.","<answer> Die Pseudovariable self bezeichnet immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird. Sie ermöglicht den Zugriff auf die Instanzvariablen dieses Objekts. <answer> <question> Was bezeichnet die Pseudovariable self in SMALLTALK? <question>"
"In SMALLTALK muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. So kann also insbesondere self nicht (wie beispielsweise this in JAVA) weggelassen werden, wenn ein Objekt eine Nachricht an sich selbst senden möchte. Wie bereits in Abschnitt 4.3.1 erwähnt, bezeichnet die Pseudovariable self immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind. (Die einzige Ausnahme hiervon bilden Blöcke, in denen self sich auf den Empfänger des Home-Kontexts bezieht; siehe Abschnitt 4.4.1 in Kurseinheit 1).
Dabei ist allerdings zu beachten, dass die Klasse des durch self bezeichneten Objekts nicht unbedingt dieselbe sein muss, in der die gerade ausgeführte Methode (in der auch das self steht) definiert ist, denn das kann ja aufgrund von Vererbung durchaus eine Superklasse sein. Das hat eine fundamentale Auswirkung: Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden, nämlich dann, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde.
Man beachte, dass Vererbung tatsächlich eine Kopieren-und-Einfügen-Semantik hat, wie in Abschnitt 11.2 bereits nahegelegt: Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.
Während offene Rekursion im gegebenen Beispiel durchaus erwünscht ist und ihr Effekt wohl auch den Erwartungen der Programmiererin entspricht, ergeben sich doch immer wieder Konstellationen, in denen man unangenehm überrascht wird. Das Problem ist unter dem Namen ""Fragile-base-class-Problem"" bekannt geworden; es wird in Kapitel 55 (Kurseinheit 6) ausführlicher behandelt. Fragile-base-class-Probleme entstehen durch die Möglichkeit der offenen Rekursion.","<answer> Das Konzept der offenen Rekursion in SMALLTALK bedeutet, dass die Methode, die durch eine Nachricht an self aufgerufen wird, nicht zwangsläufig die in derselben Klasse definierte Methode ist. Stattdessen kann die passende Methode in einer Subklasse gefunden werden, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde. Dies kann zu überraschenden Ergebnissen führen, wenn nicht erwartet wird, dass die Methode in einer Subklasse überschrieben wurde. <answer> <question> Was ist das Konzept der offenen Rekursion in SMALLTALK? <question>"
"In der Daten- und Softwaremodellierung werden Beziehungen (oder Relationen) häufig mit sog. Kardinalitäten versehen. (Manchmal, besonders im Kontext der Softwaremodellierung mit der Unified Modeling Language UML, werden diese auch Multiplizitäten genannt.) Sie geben an, mit wie vielen anderen Objekten ein Objekt gleichzeitig in derselben Beziehung stehen kann. Beispielsweise kann eine Person zu mehreren anderen Personen in einer Verwandtschaftsbeziehung stehen. Häufig sind die möglichen Kardinalitäten auf ein Intervall beschränkt; sie werden dann durch eben dieses Intervall beschrieben.
Von den theoretisch unendlich vielen möglichen Intervallen, die die Kardinalität beschränken können, sind vor allem drei interessant: [0..1], [1..1] und [0..∞). Dabei ist [1..1], also dass ein Objekt immer mit genau einem in Beziehung stehen muss, technisch nur schwer umzusetzen, so dass [1..1] hier nicht weiter betrachtet wird. Die untere Schranke 0, die den beiden verbleibenden Intervallen gemeinsam ist und die ausdrückt, dass ein Objekt auch mit gar keinem anderen in der Beziehung stehen kann, muss daher nicht erwähnt werden.
Im Fall von [0..1] sprechen wir also von Zu-eins-Beziehungen (im folgenden mit :1-Beziehung notiert), im Fall von [0..∞) von Zu-n-Beziehungen (:n-Beziehungen), wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.
Objekt nil (null in anderen Sprachen) ausgedrückt. Nach und nach kommen in verschiedenen objektorientierten Programmiersprachen die sog. Not-null-Annotationen auf, die sicherstellen sollen, dass eine Variable nie den Wert null hat.
Beziehungen sind nicht von Natur aus auf ein Gegenüber eingeschränkt: Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren anderen stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die „Namen“ der Gegenüber sind einfach Indizes: 1, 2, 3 usw.
Es ergibt sich nun aber das Problem, dass bei durch indizierte Instanzvariablen eines Objekts realisierten :n-Beziehungen nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden kann — die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden :n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer über Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die :n-Beziehung ggf. mit weiteren Attributen (z. B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o. ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die :n-Beziehung eigentlich haben sollte, steht dann stattdessen in einer von einer benannten Instanzvariable hergestellten :1-Beziehung zu dem Zwischenobjekt, das die :n-Beziehung herstellt.
Wie wir noch sehen werden, erlaubt der Umstand, dass :n-Beziehungen über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, die Beziehungen beliebig auszugestalten. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z. B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z. B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schlüssels können auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z. B. spezielle Schleifen) anbieten können, sind der Ausgestaltung von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt.
Da :n-Beziehungen häufig vorkommen, ist ihre Handhabung von entscheidender Bedeutung für die Ausdrucksstärke der verwendeten Programmiersprache und die Produktivität der Programmierung insgesamt. Wie sich schon in Abschnitt 4.6.4 zeigen wird, erlaubt die Ausgestaltung von Zwischenobjekten in SMALLTALK Möglichkeiten, die bis heute Vorbildcharakter für andere objektorientierte Programmiersprachen haben.","<answer> Kardinalitäten sind in der Daten- und Softwaremodellierung häufig verwendete Beziehungsattribute, die angeben, wie viele andere Objekte ein Objekt in einer Beziehung haben kann. <answer> <question> Was sind Kardinalitäten und wie werden sie in der Daten- und Softwaremodellierung verwendet? <question>"
"In der Daten- und Softwaremodellierung werden Beziehungen (oder Relationen) häufig mit sog. Kardinalitäten versehen. (Manchmal, besonders im Kontext der Softwaremodellierung mit der Unified Modeling Language UML, werden diese auch Multiplizitäten genannt.) Sie geben an, mit wie vielen anderen Objekten ein Objekt gleichzeitig in derselben Beziehung stehen kann. Beispielsweise kann eine Person zu mehreren anderen Personen in einer Verwandtschaftsbeziehung stehen. Häufig sind die möglichen Kardinalitäten auf ein Intervall beschränkt; sie werden dann durch eben dieses Intervall beschrieben.
Von den theoretisch unendlich vielen möglichen Intervallen, die die Kardinalität beschränken können, sind vor allem drei interessant: [0..1], [1..1] und [0..∞). Dabei ist [1..1], also dass ein Objekt immer mit genau einem in Beziehung stehen muss, technisch nur schwer umzusetzen, so dass [1..1] hier nicht weiter betrachtet wird. Die untere Schranke 0, die den beiden verbleibenden Intervallen gemeinsam ist und die ausdrückt, dass ein Objekt auch mit gar keinem anderen in der Beziehung stehen kann, muss daher nicht erwähnt werden.
Im Fall von [0..1] sprechen wir also von Zu-eins-Beziehungen (im folgenden mit :1-Beziehung notiert), im Fall von [0..∞) von Zu-n-Beziehungen (:n-Beziehungen), wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.
Objekt nil (null in anderen Sprachen) ausgedrückt. Nach und nach kommen in verschiedenen objektorientierten Programmiersprachen die sog. Not-null-Annotationen auf, die sicherstellen sollen, dass eine Variable nie den Wert null hat.
Beziehungen sind nicht von Natur aus auf ein Gegenüber eingeschränkt: Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren anderen stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die „Namen“ der Gegenüber sind einfach Indizes: 1, 2, 3 usw.
Es ergibt sich nun aber das Problem, dass bei durch indizierte Instanzvariablen eines Objekts realisierten :n-Beziehungen nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden kann — die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden :n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer über Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die :n-Beziehung ggf. mit weiteren Attributen (z. B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o. ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die :n-Beziehung eigentlich haben sollte, steht dann stattdessen in einer von einer benannten Instanzvariable hergestellten :1-Beziehung zu dem Zwischenobjekt, das die :n-Beziehung herstellt.
Wie wir noch sehen werden, erlaubt der Umstand, dass :n-Beziehungen über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, die Beziehungen beliebig auszugestalten. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z. B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z. B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schlüssels können auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z. B. spezielle Schleifen) anbieten können, sind der Ausgestaltung von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt.
Da :n-Beziehungen häufig vorkommen, ist ihre Handhabung von entscheidender Bedeutung für die Ausdrucksstärke der verwendeten Programmiersprache und die Produktivität der Programmierung insgesamt. Wie sich schon in Abschnitt 4.6.4 zeigen wird, erlaubt die Ausgestaltung von Zwischenobjekten in SMALLTALK Möglichkeiten, die bis heute Vorbildcharakter für andere objektorientierte Programmiersprachen haben.","<answer> Die besonders interessanten Kardinalitäten sind [0..1] und [0..∞), wobei [1..1] aufgrund technischer Schwierigkeiten nicht weiter betrachtet wird. [0..1] entspricht :1-Beziehungen und [0..∞) entspricht :n-Beziehungen. <answer> <question> Welche Kardinalitäten sind in diesem Abschnitt besonders interessant, und warum? <question>"
"In der Daten- und Softwaremodellierung werden Beziehungen (oder Relationen) häufig mit sog. Kardinalitäten versehen. (Manchmal, besonders im Kontext der Softwaremodellierung mit der Unified Modeling Language UML, werden diese auch Multiplizitäten genannt.) Sie geben an, mit wie vielen anderen Objekten ein Objekt gleichzeitig in derselben Beziehung stehen kann. Beispielsweise kann eine Person zu mehreren anderen Personen in einer Verwandtschaftsbeziehung stehen. Häufig sind die möglichen Kardinalitäten auf ein Intervall beschränkt; sie werden dann durch eben dieses Intervall beschrieben.
Von den theoretisch unendlich vielen möglichen Intervallen, die die Kardinalität beschränken können, sind vor allem drei interessant: [0..1], [1..1] und [0..∞). Dabei ist [1..1], also dass ein Objekt immer mit genau einem in Beziehung stehen muss, technisch nur schwer umzusetzen, so dass [1..1] hier nicht weiter betrachtet wird. Die untere Schranke 0, die den beiden verbleibenden Intervallen gemeinsam ist und die ausdrückt, dass ein Objekt auch mit gar keinem anderen in der Beziehung stehen kann, muss daher nicht erwähnt werden.
Im Fall von [0..1] sprechen wir also von Zu-eins-Beziehungen (im folgenden mit :1-Beziehung notiert), im Fall von [0..∞) von Zu-n-Beziehungen (:n-Beziehungen), wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.
Objekt nil (null in anderen Sprachen) ausgedrückt. Nach und nach kommen in verschiedenen objektorientierten Programmiersprachen die sog. Not-null-Annotationen auf, die sicherstellen sollen, dass eine Variable nie den Wert null hat.
Beziehungen sind nicht von Natur aus auf ein Gegenüber eingeschränkt: Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren anderen stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die „Namen“ der Gegenüber sind einfach Indizes: 1, 2, 3 usw.
Es ergibt sich nun aber das Problem, dass bei durch indizierte Instanzvariablen eines Objekts realisierten :n-Beziehungen nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden kann — die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden :n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer über Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die :n-Beziehung ggf. mit weiteren Attributen (z. B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o. ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die :n-Beziehung eigentlich haben sollte, steht dann stattdessen in einer von einer benannten Instanzvariable hergestellten :1-Beziehung zu dem Zwischenobjekt, das die :n-Beziehung herstellt.
Wie wir noch sehen werden, erlaubt der Umstand, dass :n-Beziehungen über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, die Beziehungen beliebig auszugestalten. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z. B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z. B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schlüssels können auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z. B. spezielle Schleifen) anbieten können, sind der Ausgestaltung von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt.
Da :n-Beziehungen häufig vorkommen, ist ihre Handhabung von entscheidender Bedeutung für die Ausdrucksstärke der verwendeten Programmiersprache und die Produktivität der Programmierung insgesamt. Wie sich schon in Abschnitt 4.6.4 zeigen wird, erlaubt die Ausgestaltung von Zwischenobjekten in SMALLTALK Möglichkeiten, die bis heute Vorbildcharakter für andere objektorientierte Programmiersprachen haben.",<answer> :1-Beziehungen können direkt durch benannte Instanzvariablen zwischen Objekten realisiert werden. <answer> <question> Wie werden :1-Beziehungen in der objektorientierten Programmierung umgesetzt? <question>
"In der Daten- und Softwaremodellierung werden Beziehungen (oder Relationen) häufig mit sog. Kardinalitäten versehen. (Manchmal, besonders im Kontext der Softwaremodellierung mit der Unified Modeling Language UML, werden diese auch Multiplizitäten genannt.) Sie geben an, mit wie vielen anderen Objekten ein Objekt gleichzeitig in derselben Beziehung stehen kann. Beispielsweise kann eine Person zu mehreren anderen Personen in einer Verwandtschaftsbeziehung stehen. Häufig sind die möglichen Kardinalitäten auf ein Intervall beschränkt; sie werden dann durch eben dieses Intervall beschrieben.
Von den theoretisch unendlich vielen möglichen Intervallen, die die Kardinalität beschränken können, sind vor allem drei interessant: [0..1], [1..1] und [0..∞). Dabei ist [1..1], also dass ein Objekt immer mit genau einem in Beziehung stehen muss, technisch nur schwer umzusetzen, so dass [1..1] hier nicht weiter betrachtet wird. Die untere Schranke 0, die den beiden verbleibenden Intervallen gemeinsam ist und die ausdrückt, dass ein Objekt auch mit gar keinem anderen in der Beziehung stehen kann, muss daher nicht erwähnt werden.
Im Fall von [0..1] sprechen wir also von Zu-eins-Beziehungen (im folgenden mit :1-Beziehung notiert), im Fall von [0..∞) von Zu-n-Beziehungen (:n-Beziehungen), wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.
Objekt nil (null in anderen Sprachen) ausgedrückt. Nach und nach kommen in verschiedenen objektorientierten Programmiersprachen die sog. Not-null-Annotationen auf, die sicherstellen sollen, dass eine Variable nie den Wert null hat.
Beziehungen sind nicht von Natur aus auf ein Gegenüber eingeschränkt: Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren anderen stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die „Namen“ der Gegenüber sind einfach Indizes: 1, 2, 3 usw.
Es ergibt sich nun aber das Problem, dass bei durch indizierte Instanzvariablen eines Objekts realisierten :n-Beziehungen nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden kann — die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden :n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer über Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die :n-Beziehung ggf. mit weiteren Attributen (z. B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o. ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die :n-Beziehung eigentlich haben sollte, steht dann stattdessen in einer von einer benannten Instanzvariable hergestellten :1-Beziehung zu dem Zwischenobjekt, das die :n-Beziehung herstellt.
Wie wir noch sehen werden, erlaubt der Umstand, dass :n-Beziehungen über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, die Beziehungen beliebig auszugestalten. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z. B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z. B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schlüssels können auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z. B. spezielle Schleifen) anbieten können, sind der Ausgestaltung von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt.
Da :n-Beziehungen häufig vorkommen, ist ihre Handhabung von entscheidender Bedeutung für die Ausdrucksstärke der verwendeten Programmiersprache und die Produktivität der Programmierung insgesamt. Wie sich schon in Abschnitt 4.6.4 zeigen wird, erlaubt die Ausgestaltung von Zwischenobjekten in SMALLTALK Möglichkeiten, die bis heute Vorbildcharakter für andere objektorientierte Programmiersprachen haben.","<answer> :n-Beziehungen werden über Zwischenobjekte realisiert, da die indizierten Instanzvariablen eines Objekts nicht benannt sind und daher nicht zwischen verschiedenen :n-Beziehungen unterschieden werden kann. <answer> <question> Warum werden :n-Beziehungen in der objektorientierten Programmierung oft über Zwischenobjekte realisiert? <question>"
"In der Daten- und Softwaremodellierung werden Beziehungen (oder Relationen) häufig mit sog. Kardinalitäten versehen. (Manchmal, besonders im Kontext der Softwaremodellierung mit der Unified Modeling Language UML, werden diese auch Multiplizitäten genannt.) Sie geben an, mit wie vielen anderen Objekten ein Objekt gleichzeitig in derselben Beziehung stehen kann. Beispielsweise kann eine Person zu mehreren anderen Personen in einer Verwandtschaftsbeziehung stehen. Häufig sind die möglichen Kardinalitäten auf ein Intervall beschränkt; sie werden dann durch eben dieses Intervall beschrieben.
Von den theoretisch unendlich vielen möglichen Intervallen, die die Kardinalität beschränken können, sind vor allem drei interessant: [0..1], [1..1] und [0..∞). Dabei ist [1..1], also dass ein Objekt immer mit genau einem in Beziehung stehen muss, technisch nur schwer umzusetzen, so dass [1..1] hier nicht weiter betrachtet wird. Die untere Schranke 0, die den beiden verbleibenden Intervallen gemeinsam ist und die ausdrückt, dass ein Objekt auch mit gar keinem anderen in der Beziehung stehen kann, muss daher nicht erwähnt werden.
Im Fall von [0..1] sprechen wir also von Zu-eins-Beziehungen (im folgenden mit :1-Beziehung notiert), im Fall von [0..∞) von Zu-n-Beziehungen (:n-Beziehungen), wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.
Objekt nil (null in anderen Sprachen) ausgedrückt. Nach und nach kommen in verschiedenen objektorientierten Programmiersprachen die sog. Not-null-Annotationen auf, die sicherstellen sollen, dass eine Variable nie den Wert null hat.
Beziehungen sind nicht von Natur aus auf ein Gegenüber eingeschränkt: Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren anderen stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die „Namen“ der Gegenüber sind einfach Indizes: 1, 2, 3 usw.
Es ergibt sich nun aber das Problem, dass bei durch indizierte Instanzvariablen eines Objekts realisierten :n-Beziehungen nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden kann — die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden :n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer über Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die :n-Beziehung ggf. mit weiteren Attributen (z. B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o. ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die :n-Beziehung eigentlich haben sollte, steht dann stattdessen in einer von einer benannten Instanzvariable hergestellten :1-Beziehung zu dem Zwischenobjekt, das die :n-Beziehung herstellt.
Wie wir noch sehen werden, erlaubt der Umstand, dass :n-Beziehungen über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, die Beziehungen beliebig auszugestalten. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z. B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z. B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schlüssels können auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z. B. spezielle Schleifen) anbieten können, sind der Ausgestaltung von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt.
Da :n-Beziehungen häufig vorkommen, ist ihre Handhabung von entscheidender Bedeutung für die Ausdrucksstärke der verwendeten Programmiersprache und die Produktivität der Programmierung insgesamt. Wie sich schon in Abschnitt 4.6.4 zeigen wird, erlaubt die Ausgestaltung von Zwischenobjekten in SMALLTALK Möglichkeiten, die bis heute Vorbildcharakter für andere objektorientierte Programmiersprachen haben.","<answer> Zwischenobjekte können zusätzliche Attribute (wie Sortierreihenfolge, Anzahl n, Verweise auf bestimmte Elemente usw.) enthalten, die in den benannten Instanzvariablen der Zwischenobjekte gespeichert werden. Dadurch können :n-Beziehungen flexibel gestaltet werden. <answer> <question> Wie können Zwischenobjekte in der :n-Beziehungsmodellierung genutzt werden, um zusätzliche Informationen hinzuzufügen? <question>"
"In der Daten- und Softwaremodellierung werden Beziehungen (oder Relationen) häufig mit sog. Kardinalitäten versehen. (Manchmal, besonders im Kontext der Softwaremodellierung mit der Unified Modeling Language UML, werden diese auch Multiplizitäten genannt.) Sie geben an, mit wie vielen anderen Objekten ein Objekt gleichzeitig in derselben Beziehung stehen kann. Beispielsweise kann eine Person zu mehreren anderen Personen in einer Verwandtschaftsbeziehung stehen. Häufig sind die möglichen Kardinalitäten auf ein Intervall beschränkt; sie werden dann durch eben dieses Intervall beschrieben.
Von den theoretisch unendlich vielen möglichen Intervallen, die die Kardinalität beschränken können, sind vor allem drei interessant: [0..1], [1..1] und [0..∞). Dabei ist [1..1], also dass ein Objekt immer mit genau einem in Beziehung stehen muss, technisch nur schwer umzusetzen, so dass [1..1] hier nicht weiter betrachtet wird. Die untere Schranke 0, die den beiden verbleibenden Intervallen gemeinsam ist und die ausdrückt, dass ein Objekt auch mit gar keinem anderen in der Beziehung stehen kann, muss daher nicht erwähnt werden.
Im Fall von [0..1] sprechen wir also von Zu-eins-Beziehungen (im folgenden mit :1-Beziehung notiert), im Fall von [0..∞) von Zu-n-Beziehungen (:n-Beziehungen), wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.
Objekt nil (null in anderen Sprachen) ausgedrückt. Nach und nach kommen in verschiedenen objektorientierten Programmiersprachen die sog. Not-null-Annotationen auf, die sicherstellen sollen, dass eine Variable nie den Wert null hat.
Beziehungen sind nicht von Natur aus auf ein Gegenüber eingeschränkt: Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren anderen stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die „Namen“ der Gegenüber sind einfach Indizes: 1, 2, 3 usw.
Es ergibt sich nun aber das Problem, dass bei durch indizierte Instanzvariablen eines Objekts realisierten :n-Beziehungen nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden kann — die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden :n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer über Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die :n-Beziehung ggf. mit weiteren Attributen (z. B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o. ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die :n-Beziehung eigentlich haben sollte, steht dann stattdessen in einer von einer benannten Instanzvariable hergestellten :1-Beziehung zu dem Zwischenobjekt, das die :n-Beziehung herstellt.
Wie wir noch sehen werden, erlaubt der Umstand, dass :n-Beziehungen über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, die Beziehungen beliebig auszugestalten. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z. B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z. B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schlüssels können auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z. B. spezielle Schleifen) anbieten können, sind der Ausgestaltung von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt.
Da :n-Beziehungen häufig vorkommen, ist ihre Handhabung von entscheidender Bedeutung für die Ausdrucksstärke der verwendeten Programmiersprache und die Produktivität der Programmierung insgesamt. Wie sich schon in Abschnitt 4.6.4 zeigen wird, erlaubt die Ausgestaltung von Zwischenobjekten in SMALLTALK Möglichkeiten, die bis heute Vorbildcharakter für andere objektorientierte Programmiersprachen haben.","<answer> :n-Beziehungen sind wichtig, da sie häufig vorkommen, und SMALLTALK ermöglicht die flexible Gestaltung von :n-Beziehungen über Zwischenobjekte. Dadurch können komplexe Beziehungen in SMALLTALK effizient umgesetzt werden. <answer> <question> Warum sind :n-Beziehungen in SMALLTALK wichtig, und wie ermöglicht SMALLTALK die flexible Handhabung von :n-Beziehungen? <question>"
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".
Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?
In JAVA wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel.
Das Fragezeichen nicht durch ""Integer"" ersetzt wird; die anschließende Zuweisung ist also möglich.
Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C# existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).
List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie ""List<?>"" und ""ArrayList<?>"", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt.
Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen.
Da nicht sichergestellt werden kann, dass ""list"" tatsächlich auf ein Objekt vom Typ ""List<Integer>"" verweist. Die einzige gültige Zuweisung an Elemente von ""list"" ist die von ""null"". Umgekehrt kann beim Lesen der Elemente aus ""list"" kein anderer Typ als ""Object"" angenommen werden, da ""list"" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.
Wir kennen bereits das Konzept der Beschränkung von Typparametern aus Abschnitt 29.4. Dieses Konzept kann auch auf Typ-Wildcards angewendet werden.
Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.
""List<? super Integer>"" ist also ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.
Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.
Dies ermöglicht es, eine Liste von Zahlen oder eine Liste von Untertypen von ""Number"" zu übergeben und die Summe der Zahlen zu berechnen, unabhängig von ihrem konkreten Typ.","<answer> Typ-Wildcards wurden eingeführt, um eine flexiblere Form der Zuweisungskompatibilität für generische Typen zu ermöglichen, insbesondere bei der Verwendung von Collections mit unterschiedlichen Typparametern. <answer> <question> Warum wurden Typ-Wildcards (Wildcard-Typen) in Java eingeführt? <question>"
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".
Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?
In JAVA wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel.
Das Fragezeichen nicht durch ""Integer"" ersetzt wird; die anschließende Zuweisung ist also möglich.
Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C# existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).
List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie ""List<?>"" und ""ArrayList<?>"", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt.
Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen.
Da nicht sichergestellt werden kann, dass ""list"" tatsächlich auf ein Objekt vom Typ ""List<Integer>"" verweist. Die einzige gültige Zuweisung an Elemente von ""list"" ist die von ""null"". Umgekehrt kann beim Lesen der Elemente aus ""list"" kein anderer Typ als ""Object"" angenommen werden, da ""list"" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.
Wir kennen bereits das Konzept der Beschränkung von Typparametern aus Abschnitt 29.4. Dieses Konzept kann auch auf Typ-Wildcards angewendet werden.
Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.
""List<? super Integer>"" ist also ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.
Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.
Dies ermöglicht es, eine Liste von Zahlen oder eine Liste von Untertypen von ""Number"" zu übergeben und die Summe der Zahlen zu berechnen, unabhängig von ihrem konkreten Typ.",<answer> Das Symbol für eine Typ-Wildcard in Java ist das Fragezeichen (?). <answer> <question> Was ist das Symbol für eine Typ-Wildcard in Java? <question>
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".
Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?
In JAVA wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel.
Das Fragezeichen nicht durch ""Integer"" ersetzt wird; die anschließende Zuweisung ist also möglich.
Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C# existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).
List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie ""List<?>"" und ""ArrayList<?>"", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt.
Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen.
Da nicht sichergestellt werden kann, dass ""list"" tatsächlich auf ein Objekt vom Typ ""List<Integer>"" verweist. Die einzige gültige Zuweisung an Elemente von ""list"" ist die von ""null"". Umgekehrt kann beim Lesen der Elemente aus ""list"" kein anderer Typ als ""Object"" angenommen werden, da ""list"" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.
Wir kennen bereits das Konzept der Beschränkung von Typparametern aus Abschnitt 29.4. Dieses Konzept kann auch auf Typ-Wildcards angewendet werden.
Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.
""List<? super Integer>"" ist also ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.
Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.
Dies ermöglicht es, eine Liste von Zahlen oder eine Liste von Untertypen von ""Number"" zu übergeben und die Summe der Zahlen zu berechnen, unabhängig von ihrem konkreten Typ.","<answer> Wenn ein Typ mit einer Typ-Wildcard deklariert wird, bedeutet dies, dass die Variable dieses Typs Objekte beliebigen, aber unbekannten Typparameters akzeptieren kann. Es ist eine abstrakte Deklaration. <answer> <question> Was bedeutet es, wenn ein Typ mit einer Typ-Wildcard (z. B. List<?>) deklariert wird? <question>"
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".
Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?
In JAVA wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel.
Das Fragezeichen nicht durch ""Integer"" ersetzt wird; die anschließende Zuweisung ist also möglich.
Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C# existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).
List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie ""List<?>"" und ""ArrayList<?>"", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt.
Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen.
Da nicht sichergestellt werden kann, dass ""list"" tatsächlich auf ein Objekt vom Typ ""List<Integer>"" verweist. Die einzige gültige Zuweisung an Elemente von ""list"" ist die von ""null"". Umgekehrt kann beim Lesen der Elemente aus ""list"" kein anderer Typ als ""Object"" angenommen werden, da ""list"" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.
Wir kennen bereits das Konzept der Beschränkung von Typparametern aus Abschnitt 29.4. Dieses Konzept kann auch auf Typ-Wildcards angewendet werden.
Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.
""List<? super Integer>"" ist also ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.
Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.
Dies ermöglicht es, eine Liste von Zahlen oder eine Liste von Untertypen von ""Number"" zu übergeben und die Summe der Zahlen zu berechnen, unabhängig von ihrem konkreten Typ.","<answer> ""extends"" wird verwendet, um eine obere Schranke für Typ-Wildcards anzugeben, während ""super"" verwendet wird, um eine untere Schranke anzugeben. Mit ""extends"" beschränkte Wildcard-Typen sind kovariant, und mit ""super"" beschränkte Wildcard-Typen sind kontravariant. <answer> <question> Was ist die Verwendung von ""extends"" und ""super"" in Verbindung mit Typ-Wildcards? <question>"
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".
Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?
In JAVA wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel.
Das Fragezeichen nicht durch ""Integer"" ersetzt wird; die anschließende Zuweisung ist also möglich.
Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C# existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).
List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie ""List<?>"" und ""ArrayList<?>"", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt.
Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen.
Da nicht sichergestellt werden kann, dass ""list"" tatsächlich auf ein Objekt vom Typ ""List<Integer>"" verweist. Die einzige gültige Zuweisung an Elemente von ""list"" ist die von ""null"". Umgekehrt kann beim Lesen der Elemente aus ""list"" kein anderer Typ als ""Object"" angenommen werden, da ""list"" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.
Wir kennen bereits das Konzept der Beschränkung von Typparametern aus Abschnitt 29.4. Dieses Konzept kann auch auf Typ-Wildcards angewendet werden.
Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.
""List<? super Integer>"" ist also ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.
Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.
Dies ermöglicht es, eine Liste von Zahlen oder eine Liste von Untertypen von ""Number"" zu übergeben und die Summe der Zahlen zu berechnen, unabhängig von ihrem konkreten Typ.","<answer> Bei ""super"" beschränkten Typ-Wildcards ist der Zugriff auf Elemente in der Regel auf schreibende Zugriffe beschränkt, und lesende Zugriffe haben immer den Typ ""Object"". <answer> <question> Welche Einschränkung gibt es bei der Verwendung von ""super"" beschränkten Typ-Wildcards? <question>"
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".
Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?
In JAVA wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel.
Das Fragezeichen nicht durch ""Integer"" ersetzt wird; die anschließende Zuweisung ist also möglich.
Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C# existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).
List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie ""List<?>"" und ""ArrayList<?>"", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt.
Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen.
Da nicht sichergestellt werden kann, dass ""list"" tatsächlich auf ein Objekt vom Typ ""List<Integer>"" verweist. Die einzige gültige Zuweisung an Elemente von ""list"" ist die von ""null"". Umgekehrt kann beim Lesen der Elemente aus ""list"" kein anderer Typ als ""Object"" angenommen werden, da ""list"" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.
Wir kennen bereits das Konzept der Beschränkung von Typparametern aus Abschnitt 29.4. Dieses Konzept kann auch auf Typ-Wildcards angewendet werden.
Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.
""List<? super Integer>"" ist also ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.
Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.
Dies ermöglicht es, eine Liste von Zahlen oder eine Liste von Untertypen von ""Number"" zu übergeben und die Summe der Zahlen zu berechnen, unabhängig von ihrem konkreten Typ.","<answer> Typ-Wildcards können verwendet werden, um sicherzustellen, dass Zuweisungen und Zugriffe auf generische Typen zur Übersetzungszeit statisch typsicher sind, ohne dass es zu Laufzeitfehlern kommt. Dies erhöht die Typsicherheit von Java-Programmen. <answer> <question> Wie können Typ-Wildcards in Java zur Verbesserung der Typsicherheit verwendet werden? <question>"
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".
Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?
In JAVA wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel.
Das Fragezeichen nicht durch ""Integer"" ersetzt wird; die anschließende Zuweisung ist also möglich.
Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C# existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).
List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie ""List<?>"" und ""ArrayList<?>"", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt.
Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen.
Da nicht sichergestellt werden kann, dass ""list"" tatsächlich auf ein Objekt vom Typ ""List<Integer>"" verweist. Die einzige gültige Zuweisung an Elemente von ""list"" ist die von ""null"". Umgekehrt kann beim Lesen der Elemente aus ""list"" kein anderer Typ als ""Object"" angenommen werden, da ""list"" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.
Wir kennen bereits das Konzept der Beschränkung von Typparametern aus Abschnitt 29.4. Dieses Konzept kann auch auf Typ-Wildcards angewendet werden.
Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.
""List<? super Integer>"" ist also ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.
Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.
Dies ermöglicht es, eine Liste von Zahlen oder eine Liste von Untertypen von ""Number"" zu übergeben und die Summe der Zahlen zu berechnen, unabhängig von ihrem konkreten Typ.","<answer> ""ArrayList<Integer>"" und ""ArrayList<String>"" sind nicht zuweisungskompatibel mit ""ArrayList<Comparable>"", weil generische Typen in Java keine kovariante Zuweisung von Subtypen erlauben. Dies wurde durch die Einführung von Typ-Wildcards gelöst. <answer> <question> Warum sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz ""Integer"" und ""String"" als Subtypen von ""Comparable"" nicht zuweisungskompatibel mit ""ArrayList<Comparable>""? <question>"
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".
Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?
In JAVA wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel.
Das Fragezeichen nicht durch ""Integer"" ersetzt wird; die anschließende Zuweisung ist also möglich.
Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C# existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).
List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie ""List<?>"" und ""ArrayList<?>"", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt.
Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen.
Da nicht sichergestellt werden kann, dass ""list"" tatsächlich auf ein Objekt vom Typ ""List<Integer>"" verweist. Die einzige gültige Zuweisung an Elemente von ""list"" ist die von ""null"". Umgekehrt kann beim Lesen der Elemente aus ""list"" kein anderer Typ als ""Object"" angenommen werden, da ""list"" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.
Wir kennen bereits das Konzept der Beschränkung von Typparametern aus Abschnitt 29.4. Dieses Konzept kann auch auf Typ-Wildcards angewendet werden.
Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.
""List<? super Integer>"" ist also ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.
Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.
Dies ermöglicht es, eine Liste von Zahlen oder eine Liste von Untertypen von ""Number"" zu übergeben und die Summe der Zahlen zu berechnen, unabhängig von ihrem konkreten Typ.","<answer> ""extends"" beschränkte Wildcard-Typen verwenden kovariantes Subtyping. <answer> <question> Welche Art von Subtyping wird bei ""extends"" beschränkten Wildcard-Typen verwendet? <question>"
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".
Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?
In JAVA wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel.
Das Fragezeichen nicht durch ""Integer"" ersetzt wird; die anschließende Zuweisung ist also möglich.
Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C# existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).
List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie ""List<?>"" und ""ArrayList<?>"", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt.
Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen.
Da nicht sichergestellt werden kann, dass ""list"" tatsächlich auf ein Objekt vom Typ ""List<Integer>"" verweist. Die einzige gültige Zuweisung an Elemente von ""list"" ist die von ""null"". Umgekehrt kann beim Lesen der Elemente aus ""list"" kein anderer Typ als ""Object"" angenommen werden, da ""list"" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.
Wir kennen bereits das Konzept der Beschränkung von Typparametern aus Abschnitt 29.4. Dieses Konzept kann auch auf Typ-Wildcards angewendet werden.
Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.
""List<? super Integer>"" ist also ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.
Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.
Dies ermöglicht es, eine Liste von Zahlen oder eine Liste von Untertypen von ""Number"" zu übergeben und die Summe der Zahlen zu berechnen, unabhängig von ihrem konkreten Typ.","<answer> ""super"" beschränkte Wildcard-Typen verwenden kontravariantes Subtyping. <answer> <question> Welche Art von Subtyping wird bei ""super"" beschränkten Wildcard-Typen verwendet? <question>"
"Für generische Typen ist es ebenso wie für Arrays durchaus sinnvoll, eine liberalere Form der Zuweisungskompatibilität zuzulassen. Dies ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel möchte man für generische Collections eine Methode ""sort"" mit einem Parameter definieren, der eine zu sortierende Liste oder Ähnliches enthält. Dann sollten Sie diese Methode mit Objekten verschiedener Instanzen von ""ArrayList<E>"" (wie in Zeile 1052 ff. definiert) aufrufen können, also beispielsweise mit Objekten vom Typ ""ArrayList<Integer>"" und ""ArrayList<String>"".
Aber wie wir bereits gesehen haben, sind ""ArrayList<Integer>"" und ""ArrayList<String>"" trotz der Tatsache, dass ""Integer"" und ""String"" Subtypen von ""Comparable"" sind, nicht zuweisungskompatibel mit ""ArrayList<Comparable>"". Was also tun?
In JAVA wurde das Konzept der Typ-Wildcards (auch als Typ-Joker oder Platzhalter bezeichnet) eingeführt, um dieses Problem zu lösen. Wildcards können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: ""List<?>"" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ ""List<?>"" ein Supertyp aller Instanziierungen von ""List<T>"" - beispielsweise sind ""List<Integer>"" und ""List<String>"" mit ""List<?>"" zuweisungskompatibel.
Das Fragezeichen nicht durch ""Integer"" ersetzt wird; die anschließende Zuweisung ist also möglich.
Wildcards sind jedoch keine Typvariablen und können nicht ersetzt werden. Sie werden bei der Verwendung an der Stelle definiert, an der sie benötigt werden. Dies nennt man Use-site-Variance im Gegensatz zur Declaration-site-Variance, wie sie beispielsweise in C# existiert (siehe Abschnitt 50.4.3 in Kurseinheit 5).
List<?> ist also selbst ein Typ, aber das Fragezeichen selbst ist keiner (und auch keine Typvariable). Mit Typ-Wildcards parametrisierte Typen wie ""List<?>"" und ""ArrayList<?>"", im Folgenden als Wildcard-Typen bezeichnet, sind abstrakt, da es keine direkten Instanzen von ihnen gibt.
Die Verwendung von Typ-Wildcards kann jedoch nicht alle Probleme im Zusammenhang mit dem Aliasing lösen.
Da nicht sichergestellt werden kann, dass ""list"" tatsächlich auf ein Objekt vom Typ ""List<Integer>"" verweist. Die einzige gültige Zuweisung an Elemente von ""list"" ist die von ""null"". Umgekehrt kann beim Lesen der Elemente aus ""list"" kein anderer Typ als ""Object"" angenommen werden, da ""list"" Listen mit beliebigem Elementtyp zugewiesen werden dürfen. Dies ist jedoch unbefriedigend.
Wir kennen bereits das Konzept der Beschränkung von Typparametern aus Abschnitt 29.4. Dieses Konzept kann auch auf Typ-Wildcards angewendet werden.
Per extends beschränkte Typ-Wildcards erlauben also eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays (Kapitel 41) lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird. Dies stellt sicher, dass es niemals zu einem Laufzeitfehler, wie der Array Store Exception, kommt. Ein entsprechender dynamischer Typtest kann somit entfallen.
Nun kann man sich fragen, ob nicht auch eine umgekehrte, nur schreibenden Zugriff erlaubende Art des Subtypings möglich ist. Die Antwort ist einfach: Ja. Man muss dazu nur die Beschränkung des Typ-Wildcards umkehren und verlangen, dass nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.
""List<? super Integer>"" ist also ein spezieller Supertyp von allen Instanzen von ""List<E>"", deren tatsächlicher Typparameter (also der für ""E"" eingesetzte Typ) ein Supertyp von ""Integer"" ist. Der Supertyp ist speziell, weil zwar eine Zuweisungskompatibilität gegeben ist, der Zugriff auf die Elementtypen (die mit dem Typparameter typisierten Elemente des Typs) auf schreibenden beschränkt ist.
Die mögliche Beschränkung von Typ-Wildcards führt zu einer (potenziell unendlichen) Menge von Typen für jeden generischen Typ. Daher stellt sich die Frage, ob diese Typen in einer bestimmten Subtyp-Beziehung zueinander stehen. Dies ist tatsächlich der Fall: Für mit ""extends"" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also ""Integer"" ein Subtyp von ""Number"" ist, dann ist auch ""List<? extends Integer>"" ein Subtyp von ""List<? extends Number>"". Umgekehrt gilt für mit ""super"" nach unten beschränkte Typen, dass ""List<? super Integer>"" ein Supertyp von ""List<? super Number>"" ist. Man sagt auch, das Subtyping mit ""extends"" beschränkter Wildcard-Typen sei kovariant und das mit ""super"" beschränkter Wildcard-Typen kontravariant.
Dies ermöglicht es, eine Liste von Zahlen oder eine Liste von Untertypen von ""Number"" zu übergeben und die Summe der Zahlen zu berechnen, unabhängig von ihrem konkreten Typ.","<answer> Typ-Wildcards können verwendet werden, um eine Methode wie ""sum(List<? extends Number> list)"" zu erstellen, die eine Liste von Zahlen oder Untertypen von ""Number"" akzeptiert und die Summe der Zahlen berechnet, unabhängig von ihrem konkreten Typ. <answer> <question> Wie können Typ-Wildcards in Java dazu verwendet werden, eine Liste von Zahlen oder Untertypen von ""Number"" zu verarbeiten? <question>"
"Wir hatten bereits ausgenutzt, dass alle Objekte in SMALLTALK eine (mehr oder weniger aussagekräftige) String-Repräsentation besitzen. Die Methode printString gibt eine Darstellung des Objekts als String zurück. Dies ist für Ausgaben auf dem Transcript interessant, aber auch für die Inspektion von Objekten und für das Debugging, bei denen sich die Objekte unter Verwendung dieser Methode der Betrachterin präsentieren.
Die Methode inspect startet auf dem Empfänger einen Inspektor und gibt den Empfänger zurück. Dies ist nützlich, wenn man ein Zwischenergebnis eines Ausdrucks inspizieren möchte, ohne den Ausdruck dazu in zwei aufteilen zu wollen. Man fügt einfach inspect an der Stelle des Ausdrucks ein, an der das zu inspizierende Objekt gewonnen wurde.
Die Methode storeOn: erlaubt, ein Objekt so auf einen Ausgabestrom zu schreiben, dass es daraus rekonstruiert werden kann. Dabei wird keine binäre, sondern eine textuelle Repräsentation verwendet. So schreibt beispielsweise SQUEAK bei Auswertung von Time noon storeOn: aStream die Zeichenfolge '12:00 pm' auf den durch aStream bezeichneten Ausgabestrom und (Interval from: 1 to: 5) die Zeichenfolge '(1 to: 5)'.","<answer> Die Methode printString gibt eine String-Repräsentation eines Objekts zurück. Diese Repräsentation kann für Ausgaben auf dem Transcript, zur Inspektion von Objekten und für das Debugging verwendet werden. <answer> <question> Was ist die Funktion der Methode printString in SMALLTALK? <question>"
"Wir hatten bereits ausgenutzt, dass alle Objekte in SMALLTALK eine (mehr oder weniger aussagekräftige) String-Repräsentation besitzen. Die Methode printString gibt eine Darstellung des Objekts als String zurück. Dies ist für Ausgaben auf dem Transcript interessant, aber auch für die Inspektion von Objekten und für das Debugging, bei denen sich die Objekte unter Verwendung dieser Methode der Betrachterin präsentieren.
Die Methode inspect startet auf dem Empfänger einen Inspektor und gibt den Empfänger zurück. Dies ist nützlich, wenn man ein Zwischenergebnis eines Ausdrucks inspizieren möchte, ohne den Ausdruck dazu in zwei aufteilen zu wollen. Man fügt einfach inspect an der Stelle des Ausdrucks ein, an der das zu inspizierende Objekt gewonnen wurde.
Die Methode storeOn: erlaubt, ein Objekt so auf einen Ausgabestrom zu schreiben, dass es daraus rekonstruiert werden kann. Dabei wird keine binäre, sondern eine textuelle Repräsentation verwendet. So schreibt beispielsweise SQUEAK bei Auswertung von Time noon storeOn: aStream die Zeichenfolge '12:00 pm' auf den durch aStream bezeichneten Ausgabestrom und (Interval from: 1 to: 5) die Zeichenfolge '(1 to: 5)'.","<answer> Die Methode inspect startet einen Inspektor auf dem Empfängerobjekt und gibt das Empfängerobjekt zurück. Sie ist nützlich, wenn Sie ein Zwischenergebnis eines Ausdrucks inspizieren möchten, ohne den Ausdruck in zwei Teile aufteilen zu müssen. Sie fügen einfach inspect an der Stelle des Ausdrucks ein, an der das zu inspizierende Objekt gewonnen wurde. <answer> <question> Wie kann die Methode inspect in SMALLTALK genutzt werden und wofür ist sie nützlich? <question>"
"Wir hatten bereits ausgenutzt, dass alle Objekte in SMALLTALK eine (mehr oder weniger aussagekräftige) String-Repräsentation besitzen. Die Methode printString gibt eine Darstellung des Objekts als String zurück. Dies ist für Ausgaben auf dem Transcript interessant, aber auch für die Inspektion von Objekten und für das Debugging, bei denen sich die Objekte unter Verwendung dieser Methode der Betrachterin präsentieren.
Die Methode inspect startet auf dem Empfänger einen Inspektor und gibt den Empfänger zurück. Dies ist nützlich, wenn man ein Zwischenergebnis eines Ausdrucks inspizieren möchte, ohne den Ausdruck dazu in zwei aufteilen zu wollen. Man fügt einfach inspect an der Stelle des Ausdrucks ein, an der das zu inspizierende Objekt gewonnen wurde.
Die Methode storeOn: erlaubt, ein Objekt so auf einen Ausgabestrom zu schreiben, dass es daraus rekonstruiert werden kann. Dabei wird keine binäre, sondern eine textuelle Repräsentation verwendet. So schreibt beispielsweise SQUEAK bei Auswertung von Time noon storeOn: aStream die Zeichenfolge '12:00 pm' auf den durch aStream bezeichneten Ausgabestrom und (Interval from: 1 to: 5) die Zeichenfolge '(1 to: 5)'.","<answer> Die Methode storeOn: ermöglicht das Schreiben eines Objekts auf einen Ausgabestrom in einer textuellen Repräsentation, die später zur Rekonstruktion des Objekts verwendet werden kann. Es wird keine binäre Repräsentation verwendet. Dies ist nützlich, um Objekte in einer menschenlesbaren Form zu speichern und später wiederherzustellen. <answer> <question> Was ist die Funktion der Methode storeOn: in SMALLTALK? <question>"
"Damit eine Variable ein Objekt bezeichnet, muss dieses ihr durch eine sogenannte Zuweisung, in anderen Kontexten auch als Wertzuweisung bezeichnet, zugeordnet werden. Ursprünglich wurde als Zuweisungsoperator das Symbol „“ gewählt; aufgrund der mangelnden Verfügbarkeit auf Tastaturen wurde es jedoch in den meisten SMALLTALK-Implementierungen durch das aus ALGOL und PASCAL bekannte := (englisch als „becomes“ gelesen) ersetzt.7 Die Variable ""lieblingszahl"" bezeichnet also in Folge der Zuweisung ein Objekt „2“ (in der Zuweisung repräsentiert durch das Literal 2).
Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.
Lokale und globale Variablen ""x"" und ""y"" bezeichnen möglicherweise dasselbe Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.
Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.
Nach den drei Zuweisungen bezeichnen ""x"" und ""y"" beide die „3“. Wäre die letzte Zuweisung jedoch ""y := x"" gewesen, bezeichneten ""x"" und ""y"" beide „5“.
Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben der expliziten Zuweisung durch den Zuweisungsoperator kommt auch eine implizite Zuweisung (bei Methodenaufrufen) vor; diese wird jedoch erst in Abschnitt 4.3.2 behandelt.
Der oben geschilderte Unterschied zwischen Wert- und Verweissemantik von Variablen hat erhebliche Konsequenzen für die Zuweisung: Bei einer Zuweisung unter Wertsemantik muss eine Kopie angefertigt werden, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist), und ein Objekt nicht in zwei Variablen gespeichert sein kann. Das hat zur Folge, dass die beiden Variablen ""x"" und ""y"" nach der Zuweisung aus Zeile 21 nicht dasselbe (identische) Objekt bezeichnen (was unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), sodass z. B. Änderungen am in ""x"" gespeicherten Objekt das in ""y"" gespeicherte Objekt nicht betreffen. Bei einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite kopiert und in der Variablen auf der linken Seite gespeichert. Wenn die Variablen auf der linken und der rechten Seite unterschiedliche Semantiken haben, dann liegt entweder eine unzulässige Zuweisung (siehe Kapitel 18) vor, oder es muss, je nach Art der Variable auf der linken Seite, eine Kopie eines Objekts oder ein Verweis auf ein Objekt angefertigt werden (siehe dazu auch Abschnitt 52.5.2 in Kurseinheit 5).","<answer> Eine Zuweisung ist der Vorgang, bei dem einer Variable ein Objekt zugewiesen wird, damit sie dieses Objekt bezeichnet. <answer> <question> Was ist eine Zuweisung in der Programmierung? <question>"
"Damit eine Variable ein Objekt bezeichnet, muss dieses ihr durch eine sogenannte Zuweisung, in anderen Kontexten auch als Wertzuweisung bezeichnet, zugeordnet werden. Ursprünglich wurde als Zuweisungsoperator das Symbol „“ gewählt; aufgrund der mangelnden Verfügbarkeit auf Tastaturen wurde es jedoch in den meisten SMALLTALK-Implementierungen durch das aus ALGOL und PASCAL bekannte := (englisch als „becomes“ gelesen) ersetzt.7 Die Variable ""lieblingszahl"" bezeichnet also in Folge der Zuweisung ein Objekt „2“ (in der Zuweisung repräsentiert durch das Literal 2).
Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.
Lokale und globale Variablen ""x"" und ""y"" bezeichnen möglicherweise dasselbe Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.
Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.
Nach den drei Zuweisungen bezeichnen ""x"" und ""y"" beide die „3“. Wäre die letzte Zuweisung jedoch ""y := x"" gewesen, bezeichneten ""x"" und ""y"" beide „5“.
Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben der expliziten Zuweisung durch den Zuweisungsoperator kommt auch eine implizite Zuweisung (bei Methodenaufrufen) vor; diese wird jedoch erst in Abschnitt 4.3.2 behandelt.
Der oben geschilderte Unterschied zwischen Wert- und Verweissemantik von Variablen hat erhebliche Konsequenzen für die Zuweisung: Bei einer Zuweisung unter Wertsemantik muss eine Kopie angefertigt werden, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist), und ein Objekt nicht in zwei Variablen gespeichert sein kann. Das hat zur Folge, dass die beiden Variablen ""x"" und ""y"" nach der Zuweisung aus Zeile 21 nicht dasselbe (identische) Objekt bezeichnen (was unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), sodass z. B. Änderungen am in ""x"" gespeicherten Objekt das in ""y"" gespeicherte Objekt nicht betreffen. Bei einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite kopiert und in der Variablen auf der linken Seite gespeichert. Wenn die Variablen auf der linken und der rechten Seite unterschiedliche Semantiken haben, dann liegt entweder eine unzulässige Zuweisung (siehe Kapitel 18) vor, oder es muss, je nach Art der Variable auf der linken Seite, eine Kopie eines Objekts oder ein Verweis auf ein Objekt angefertigt werden (siehe dazu auch Abschnitt 52.5.2 in Kurseinheit 5).","<answer> Die Verwechslung von ""="" für die Zuweisung mit dem Test auf Gleichheit kann zu fehlerhaftem Verhalten führen, da es zu unerwarteten Änderungen in Variablenwerten führen kann. <answer> <question> Warum kann die Verwechslung von ""="" für die Zuweisung mit dem Test auf Gleichheit zu schwerwiegenden Fehlern in der Programmierung führen? <question>"
"Damit eine Variable ein Objekt bezeichnet, muss dieses ihr durch eine sogenannte Zuweisung, in anderen Kontexten auch als Wertzuweisung bezeichnet, zugeordnet werden. Ursprünglich wurde als Zuweisungsoperator das Symbol „“ gewählt; aufgrund der mangelnden Verfügbarkeit auf Tastaturen wurde es jedoch in den meisten SMALLTALK-Implementierungen durch das aus ALGOL und PASCAL bekannte := (englisch als „becomes“ gelesen) ersetzt.7 Die Variable ""lieblingszahl"" bezeichnet also in Folge der Zuweisung ein Objekt „2“ (in der Zuweisung repräsentiert durch das Literal 2).
Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.
Lokale und globale Variablen ""x"" und ""y"" bezeichnen möglicherweise dasselbe Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.
Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.
Nach den drei Zuweisungen bezeichnen ""x"" und ""y"" beide die „3“. Wäre die letzte Zuweisung jedoch ""y := x"" gewesen, bezeichneten ""x"" und ""y"" beide „5“.
Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben der expliziten Zuweisung durch den Zuweisungsoperator kommt auch eine implizite Zuweisung (bei Methodenaufrufen) vor; diese wird jedoch erst in Abschnitt 4.3.2 behandelt.
Der oben geschilderte Unterschied zwischen Wert- und Verweissemantik von Variablen hat erhebliche Konsequenzen für die Zuweisung: Bei einer Zuweisung unter Wertsemantik muss eine Kopie angefertigt werden, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist), und ein Objekt nicht in zwei Variablen gespeichert sein kann. Das hat zur Folge, dass die beiden Variablen ""x"" und ""y"" nach der Zuweisung aus Zeile 21 nicht dasselbe (identische) Objekt bezeichnen (was unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), sodass z. B. Änderungen am in ""x"" gespeicherten Objekt das in ""y"" gespeicherte Objekt nicht betreffen. Bei einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite kopiert und in der Variablen auf der linken Seite gespeichert. Wenn die Variablen auf der linken und der rechten Seite unterschiedliche Semantiken haben, dann liegt entweder eine unzulässige Zuweisung (siehe Kapitel 18) vor, oder es muss, je nach Art der Variable auf der linken Seite, eine Kopie eines Objekts oder ein Verweis auf ein Objekt angefertigt werden (siehe dazu auch Abschnitt 52.5.2 in Kurseinheit 5).","<answer> In SMALLTALK gibt es keine Einschränkungen hinsichtlich der Art der zugewiesenen Werte. Variablen können Zeichen, Zahlen, Arrays und mehr zugewiesen werden. <answer> <question> Unterscheidet sich die Zuweisung in SMALLTALK von typisierten Sprachen hinsichtlich der Art der zugewiesenen Werte? <question>"
"Damit eine Variable ein Objekt bezeichnet, muss dieses ihr durch eine sogenannte Zuweisung, in anderen Kontexten auch als Wertzuweisung bezeichnet, zugeordnet werden. Ursprünglich wurde als Zuweisungsoperator das Symbol „“ gewählt; aufgrund der mangelnden Verfügbarkeit auf Tastaturen wurde es jedoch in den meisten SMALLTALK-Implementierungen durch das aus ALGOL und PASCAL bekannte := (englisch als „becomes“ gelesen) ersetzt.7 Die Variable ""lieblingszahl"" bezeichnet also in Folge der Zuweisung ein Objekt „2“ (in der Zuweisung repräsentiert durch das Literal 2).
Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.
Lokale und globale Variablen ""x"" und ""y"" bezeichnen möglicherweise dasselbe Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.
Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.
Nach den drei Zuweisungen bezeichnen ""x"" und ""y"" beide die „3“. Wäre die letzte Zuweisung jedoch ""y := x"" gewesen, bezeichneten ""x"" und ""y"" beide „5“.
Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben der expliziten Zuweisung durch den Zuweisungsoperator kommt auch eine implizite Zuweisung (bei Methodenaufrufen) vor; diese wird jedoch erst in Abschnitt 4.3.2 behandelt.
Der oben geschilderte Unterschied zwischen Wert- und Verweissemantik von Variablen hat erhebliche Konsequenzen für die Zuweisung: Bei einer Zuweisung unter Wertsemantik muss eine Kopie angefertigt werden, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist), und ein Objekt nicht in zwei Variablen gespeichert sein kann. Das hat zur Folge, dass die beiden Variablen ""x"" und ""y"" nach der Zuweisung aus Zeile 21 nicht dasselbe (identische) Objekt bezeichnen (was unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), sodass z. B. Änderungen am in ""x"" gespeicherten Objekt das in ""y"" gespeicherte Objekt nicht betreffen. Bei einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite kopiert und in der Variablen auf der linken Seite gespeichert. Wenn die Variablen auf der linken und der rechten Seite unterschiedliche Semantiken haben, dann liegt entweder eine unzulässige Zuweisung (siehe Kapitel 18) vor, oder es muss, je nach Art der Variable auf der linken Seite, eine Kopie eines Objekts oder ein Verweis auf ein Objekt angefertigt werden (siehe dazu auch Abschnitt 52.5.2 in Kurseinheit 5).","<answer> Die Zuweisung ist nicht kommutativ, da ""x := y"" und ""y := x"" unterschiedliche Bedeutungen haben, es sei denn, ""x"" und ""y"" hatten bereits denselben Wert vor der jeweiligen Zuweisung. <answer> <question> Warum ist die Zuweisung kommutativ? <question>"
"Damit eine Variable ein Objekt bezeichnet, muss dieses ihr durch eine sogenannte Zuweisung, in anderen Kontexten auch als Wertzuweisung bezeichnet, zugeordnet werden. Ursprünglich wurde als Zuweisungsoperator das Symbol „“ gewählt; aufgrund der mangelnden Verfügbarkeit auf Tastaturen wurde es jedoch in den meisten SMALLTALK-Implementierungen durch das aus ALGOL und PASCAL bekannte := (englisch als „becomes“ gelesen) ersetzt.7 Die Variable ""lieblingszahl"" bezeichnet also in Folge der Zuweisung ein Objekt „2“ (in der Zuweisung repräsentiert durch das Literal 2).
Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.
Lokale und globale Variablen ""x"" und ""y"" bezeichnen möglicherweise dasselbe Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.
Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.
Nach den drei Zuweisungen bezeichnen ""x"" und ""y"" beide die „3“. Wäre die letzte Zuweisung jedoch ""y := x"" gewesen, bezeichneten ""x"" und ""y"" beide „5“.
Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben der expliziten Zuweisung durch den Zuweisungsoperator kommt auch eine implizite Zuweisung (bei Methodenaufrufen) vor; diese wird jedoch erst in Abschnitt 4.3.2 behandelt.
Der oben geschilderte Unterschied zwischen Wert- und Verweissemantik von Variablen hat erhebliche Konsequenzen für die Zuweisung: Bei einer Zuweisung unter Wertsemantik muss eine Kopie angefertigt werden, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist), und ein Objekt nicht in zwei Variablen gespeichert sein kann. Das hat zur Folge, dass die beiden Variablen ""x"" und ""y"" nach der Zuweisung aus Zeile 21 nicht dasselbe (identische) Objekt bezeichnen (was unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), sodass z. B. Änderungen am in ""x"" gespeicherten Objekt das in ""y"" gespeicherte Objekt nicht betreffen. Bei einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite kopiert und in der Variablen auf der linken Seite gespeichert. Wenn die Variablen auf der linken und der rechten Seite unterschiedliche Semantiken haben, dann liegt entweder eine unzulässige Zuweisung (siehe Kapitel 18) vor, oder es muss, je nach Art der Variable auf der linken Seite, eine Kopie eines Objekts oder ein Verweis auf ein Objekt angefertigt werden (siehe dazu auch Abschnitt 52.5.2 in Kurseinheit 5).","<answer> Bei Zuweisungen unter Wertsemantik muss eine Kopie des Objekts angefertigt werden, da die Variable das Objekt selbst speichert. Bei Zuweisungen unter Verweissemantik wird nur der Verweis auf das Objekt kopiert und in der Variable gespeichert. Dies hat Auswirkungen darauf, ob Änderungen an einem Objekt in einer Variable sich auf dasselbe Objekt in einer anderen Variable auswirken. <answer> <question> Welchen Unterschied gibt es zwischen Zuweisungen unter Wertsemantik und Verweissemantik hinsichtlich des Kopierens von Objekten? <question>"
"In SMALLTALK gibt es keine frei bezeichenbaren Konstanten, sondern nur Literale (siehe Abschnitt 1.2). Da verschiedene Vorkommen gleicher Literale jedoch (außer bei Symbolen) verschiedene Objekte erzeugen, sind Literale nicht für alle Zwecke ausreichend. Hierfür gibt es einen Trick, um dasselbe Literal mehrfach verwenden zu können, nämlich durch eine sogenannte konstante Methode.
An einer konstanten Methode ist nichts weiter konstant, als dass sie immer dasselbe Objekt zurückgibt. Der Trick besteht darin, dass das zum Literal gehörende Objekt nur einmal, nämlich zur Übersetzungszeit der Methode, erzeugt wird, und die Ausführung der Methode immer auf dieses und damit dasselbe Objekt zurückgreift.
Es gibt jedoch zwei Probleme. Das erste ist offensichtlich: Bei einer erneuten Übersetzung der Methode wird auch ein neues Objekt erzeugt, das dann nicht mehr identisch ist mit dem früher zurückgegebenen (abgesehen von den bereits bekannten Ausnahmen). Das kann zu Problemen führen, wenn das früher zurückgegebene Objekt in Variablen gespeichert wurde und nun mit dem neuen auf Identität verglichen werden soll. Daher sollte man dies tunlichst vermeiden.
Das zweite Problem ist subtiler: Bei der konstanten Methode eines Objekts o und nach Auswertung der Anweisungen b := o konstanteMethode. enthält b an erster Stelle ebenfalls eine 0! Die vermeintlich konstante Methode ist also alles andere als konstant! Interessanterweise ist das Ergebnis dieses Experiments genau das Gegenteil dessen, was wir erwartet hätten.
Zumindest das zweite Problem lässt sich eindämmen, indem man auf Sprachebene durch Literale erzeugte Objekte als unveränderlich annimmt und Änderungen der Art von b := o konstanteMethode. vermeidet. Die eigentliche Erkenntnis ist jedoch, dass die Referenzsemantik von Variablen und das damit verbundene Aliasing von Objekten zu höchst subtilen Problemen führen kann, derer man sich immer bewusst sein sollte.","<answer> Konstante Methoden in SMALLTALK sind Methoden, die immer dasselbe Objekt zurückgeben. Sie werden häufig verwendet, um Literale auf eine Weise zu repräsentieren, die sicherstellt, dass sie konsistent sind und immer auf dasselbe Objekt verweisen. <answer> <question> Was sind konstante Methoden in SMALLTALK? <question>"
"In SMALLTALK gibt es keine frei bezeichenbaren Konstanten, sondern nur Literale (siehe Abschnitt 1.2). Da verschiedene Vorkommen gleicher Literale jedoch (außer bei Symbolen) verschiedene Objekte erzeugen, sind Literale nicht für alle Zwecke ausreichend. Hierfür gibt es einen Trick, um dasselbe Literal mehrfach verwenden zu können, nämlich durch eine sogenannte konstante Methode.
An einer konstanten Methode ist nichts weiter konstant, als dass sie immer dasselbe Objekt zurückgibt. Der Trick besteht darin, dass das zum Literal gehörende Objekt nur einmal, nämlich zur Übersetzungszeit der Methode, erzeugt wird, und die Ausführung der Methode immer auf dieses und damit dasselbe Objekt zurückgreift.
Es gibt jedoch zwei Probleme. Das erste ist offensichtlich: Bei einer erneuten Übersetzung der Methode wird auch ein neues Objekt erzeugt, das dann nicht mehr identisch ist mit dem früher zurückgegebenen (abgesehen von den bereits bekannten Ausnahmen). Das kann zu Problemen führen, wenn das früher zurückgegebene Objekt in Variablen gespeichert wurde und nun mit dem neuen auf Identität verglichen werden soll. Daher sollte man dies tunlichst vermeiden.
Das zweite Problem ist subtiler: Bei der konstanten Methode eines Objekts o und nach Auswertung der Anweisungen b := o konstanteMethode. enthält b an erster Stelle ebenfalls eine 0! Die vermeintlich konstante Methode ist also alles andere als konstant! Interessanterweise ist das Ergebnis dieses Experiments genau das Gegenteil dessen, was wir erwartet hätten.
Zumindest das zweite Problem lässt sich eindämmen, indem man auf Sprachebene durch Literale erzeugte Objekte als unveränderlich annimmt und Änderungen der Art von b := o konstanteMethode. vermeidet. Die eigentliche Erkenntnis ist jedoch, dass die Referenzsemantik von Variablen und das damit verbundene Aliasing von Objekten zu höchst subtilen Problemen führen kann, derer man sich immer bewusst sein sollte.","<answer> Konstante Methoden werden verwendet, um sicherzustellen, dass bestimmte Literale in einem Programm konsistent sind und immer auf dasselbe Objekt verweisen. Dies ist wichtig, um Probleme im Zusammenhang mit Objektidentität und Vergleichen zu vermeiden. <answer> <question> Warum werden konstante Methoden verwendet? <question>"
"In SMALLTALK gibt es keine frei bezeichenbaren Konstanten, sondern nur Literale (siehe Abschnitt 1.2). Da verschiedene Vorkommen gleicher Literale jedoch (außer bei Symbolen) verschiedene Objekte erzeugen, sind Literale nicht für alle Zwecke ausreichend. Hierfür gibt es einen Trick, um dasselbe Literal mehrfach verwenden zu können, nämlich durch eine sogenannte konstante Methode.
An einer konstanten Methode ist nichts weiter konstant, als dass sie immer dasselbe Objekt zurückgibt. Der Trick besteht darin, dass das zum Literal gehörende Objekt nur einmal, nämlich zur Übersetzungszeit der Methode, erzeugt wird, und die Ausführung der Methode immer auf dieses und damit dasselbe Objekt zurückgreift.
Es gibt jedoch zwei Probleme. Das erste ist offensichtlich: Bei einer erneuten Übersetzung der Methode wird auch ein neues Objekt erzeugt, das dann nicht mehr identisch ist mit dem früher zurückgegebenen (abgesehen von den bereits bekannten Ausnahmen). Das kann zu Problemen führen, wenn das früher zurückgegebene Objekt in Variablen gespeichert wurde und nun mit dem neuen auf Identität verglichen werden soll. Daher sollte man dies tunlichst vermeiden.
Das zweite Problem ist subtiler: Bei der konstanten Methode eines Objekts o und nach Auswertung der Anweisungen b := o konstanteMethode. enthält b an erster Stelle ebenfalls eine 0! Die vermeintlich konstante Methode ist also alles andere als konstant! Interessanterweise ist das Ergebnis dieses Experiments genau das Gegenteil dessen, was wir erwartet hätten.
Zumindest das zweite Problem lässt sich eindämmen, indem man auf Sprachebene durch Literale erzeugte Objekte als unveränderlich annimmt und Änderungen der Art von b := o konstanteMethode. vermeidet. Die eigentliche Erkenntnis ist jedoch, dass die Referenzsemantik von Variablen und das damit verbundene Aliasing von Objekten zu höchst subtilen Problemen führen kann, derer man sich immer bewusst sein sollte.","<answer> Bei der erneuten Übersetzung einer Methode mit einer konstanten Methode wird möglicherweise ein neues Objekt erzeugt, das nicht identisch mit dem zuvor zurückgegebenen Objekt ist. Dies kann zu Problemen führen, wenn das zuvor zurückgegebene Objekt in Variablen gespeichert wurde und mit dem neuen Objekt auf Identität verglichen wird. <answer> <question> Welches Problem kann bei der erneuten Übersetzung einer Methode mit konstanter Methode auftreten? <question>"
"In SMALLTALK gibt es keine frei bezeichenbaren Konstanten, sondern nur Literale (siehe Abschnitt 1.2). Da verschiedene Vorkommen gleicher Literale jedoch (außer bei Symbolen) verschiedene Objekte erzeugen, sind Literale nicht für alle Zwecke ausreichend. Hierfür gibt es einen Trick, um dasselbe Literal mehrfach verwenden zu können, nämlich durch eine sogenannte konstante Methode.
An einer konstanten Methode ist nichts weiter konstant, als dass sie immer dasselbe Objekt zurückgibt. Der Trick besteht darin, dass das zum Literal gehörende Objekt nur einmal, nämlich zur Übersetzungszeit der Methode, erzeugt wird, und die Ausführung der Methode immer auf dieses und damit dasselbe Objekt zurückgreift.
Es gibt jedoch zwei Probleme. Das erste ist offensichtlich: Bei einer erneuten Übersetzung der Methode wird auch ein neues Objekt erzeugt, das dann nicht mehr identisch ist mit dem früher zurückgegebenen (abgesehen von den bereits bekannten Ausnahmen). Das kann zu Problemen führen, wenn das früher zurückgegebene Objekt in Variablen gespeichert wurde und nun mit dem neuen auf Identität verglichen werden soll. Daher sollte man dies tunlichst vermeiden.
Das zweite Problem ist subtiler: Bei der konstanten Methode eines Objekts o und nach Auswertung der Anweisungen b := o konstanteMethode. enthält b an erster Stelle ebenfalls eine 0! Die vermeintlich konstante Methode ist also alles andere als konstant! Interessanterweise ist das Ergebnis dieses Experiments genau das Gegenteil dessen, was wir erwartet hätten.
Zumindest das zweite Problem lässt sich eindämmen, indem man auf Sprachebene durch Literale erzeugte Objekte als unveränderlich annimmt und Änderungen der Art von b := o konstanteMethode. vermeidet. Die eigentliche Erkenntnis ist jedoch, dass die Referenzsemantik von Variablen und das damit verbundene Aliasing von Objekten zu höchst subtilen Problemen führen kann, derer man sich immer bewusst sein sollte.","<answer> Um das Problem der Inkonsistenz zu vermeiden, sollte man auf Sprachebene durch Literale erzeugte Objekte als unveränderlich betrachten und Änderungen an ihnen vermeiden, insbesondere nach der erneuten Übersetzung der Methode. Es ist wichtig, sich bewusst zu sein, dass Objekte in SMALLTALK durch Referenzsemantik behandelt werden, was zu subtilen Problemen führen kann. <answer> <question> Wie kann das Problem der Inkonsistenz bei der erneuten Übersetzung einer Methode mit konstanter Methode vermieden werden? <question>"
"Überaus angemessen, wenn auch nicht immer in letzter Konsequenz einzuhalten, ist, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. So legt beispielsweise der in Kurseinheit 1, Kapitel für Klassennamen Substantive verwendet. Tatsächlich ist es eine vielzitierte objektorientierte Technik, in der Analysephase eines Projekts alle Substantive der Spezifikation zu extrahieren, um auf der Basis der so gewonnenen Liste die Menge der Klassen eines Systems zu identifizieren.
Methoden, die eine Aktion implementieren (Befehle in EIFFEL, s. Kurseinheit 5, Abschnitt 52.2), wird man aufgrund ihres prädikativen Charakters mit Verben benennen, wobei es eine Stilfrage ist, ob man die Infinitiv- oder die Imperativform (im Englischen übrigens kein Unterschied in der Erscheinungsform) bevorzugt. Persönlich fühle ich mich hier an keine Regel gebunden außer an die, dass Ausdrücke durch meine Namenwahl möglichst lesbar werden. So klingt ""hinzufügen"" (Infinitivform) in meinen Ohren besser als ""add"" (Imperativform), ""entfernen"" (Imperativform) klingt dagegen besser als ""remove"" (Infinitivform). Man könnte natürlich der imperativen Form ein Reflexivpronomen hinzufügen wie etwa in ""sich entfernen,"" aber das ist eher unüblich (obwohl nicht ohne Charme!). Verbergänzungen wie Präpositionen verwendet man in SMALLTALK dauernd (schon um mehrere Parameter voneinander abzusetzen); in Sprachen wie JAVA fügt man einem allgemeinen (und häufig überladenen) Verb dann gelegentlich noch ein Substantiv als Objekt des Prädikats hinzu, wie in ""addElement."" Gerade dieses Beispiel ist jedoch nicht unumstritten, da „Element“ hier gewissermaßen redundant ist — wenn es mehrere Methoden namens „add“ gibt, kann man sie auch mittels ihrer Parametertypen unterscheiden (also überladen). So heißt die entsprechende Methode im JDK heute auch nur noch ""add(.)"".
Keine Verben, sondern Adjektive (oder Kopula plus Prädikatsnomen) verwendet man hingegen für Methoden, die eine Abfrage darstellen (Queries; s. Abschnitt 52.2), wie etwa ""istLeer"" oder ""hatInhalt.""
Für Instanzvariablen verwendet man unterschiedliche Wortarten, und zwar abhängig davon, ob eine Instanzvariable ein Attribut oder eine Beziehung repräsentiert. Wenn es sich um ein Attribut handelt, das eine mehrwertige Qualität ausdrückt (wie Größe, Farbe etc.), dann wird man den Namen der Qualität verwenden und damit ein Substantiv (ggf. in Kleinschreibung). Wenn es sich um ein zweiwertiges (Boolesches) Attribut handelt, dann nimmt man das entsprechende Adjektiv (wie etwa ""leer""), ein Gerundivum (z. B. ""laufend"") oder ein Partizip (wie etwa ""gelöst""). Für Instanzvariablen, die Beziehungen ausdrücken, nimmt man gerne den Namen der Gegenrolle, also beispielsweise ""mutter"" in einer Kind-Mutter-Beziehung. Bei n-Beziehungen nehme ich persönlich gerne den Plural, also z. B. ""kinder"" (statt ""kind"") für die umgekehrte Richtung.
Interfaces sind zwar wie Klassen Typen, aber bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte, die konkrete Ausprägungen der Allgemeinbegriffe sind, spielen können. Rollen werden aber, genau wie Allgemeinbegriffe, häufig durch Substantive bezeichnet: „Mutter“ ist ein Beispiel hierfür. Andere Rollen, insbesondere die, die mit Parametern von Methoden verbunden sind, werden häufig durch Adjektive bezeichnet: ""Druckbar"" beispielsweise könnte der Parametertyp einer Methode ""drucken"" sein, den das zu druckende Objekt haben muss. Tatsächlich enden viele der gebräuchlichen Interfacenamen im Englischen auf „able“ oder „ible“, so z. B. bei ""Serializable.""
Eine ganz interessante Option ergibt sich übrigens für Programmiererinnen, deren Muttersprache nicht Englisch ist: Man hat hier die Möglichkeit, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Ich persönlich verwende dann gerne für Begrifflichkeiten aus der Anwendungsdomäne (also dem Gegenstandsbereich, mit dem sich das Programm befasst) deutsche Bezeichner und für solche aus der technischen Umsetzung (Hilfsklassen etc.) englische. Alternativ kann man natürlich auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden.","<answer> Es ist angemessen, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. Zum Beispiel werden in der objektorientierten Programmierung Substantive oft für Klassennamen verwendet. <answer> <question> Welche Wortarten einer natürlichen Sprache sollten für verschiedene Arten von Programmelementen verwendet werden? <question>"
"Überaus angemessen, wenn auch nicht immer in letzter Konsequenz einzuhalten, ist, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. So legt beispielsweise der in Kurseinheit 1, Kapitel für Klassennamen Substantive verwendet. Tatsächlich ist es eine vielzitierte objektorientierte Technik, in der Analysephase eines Projekts alle Substantive der Spezifikation zu extrahieren, um auf der Basis der so gewonnenen Liste die Menge der Klassen eines Systems zu identifizieren.
Methoden, die eine Aktion implementieren (Befehle in EIFFEL, s. Kurseinheit 5, Abschnitt 52.2), wird man aufgrund ihres prädikativen Charakters mit Verben benennen, wobei es eine Stilfrage ist, ob man die Infinitiv- oder die Imperativform (im Englischen übrigens kein Unterschied in der Erscheinungsform) bevorzugt. Persönlich fühle ich mich hier an keine Regel gebunden außer an die, dass Ausdrücke durch meine Namenwahl möglichst lesbar werden. So klingt ""hinzufügen"" (Infinitivform) in meinen Ohren besser als ""add"" (Imperativform), ""entfernen"" (Imperativform) klingt dagegen besser als ""remove"" (Infinitivform). Man könnte natürlich der imperativen Form ein Reflexivpronomen hinzufügen wie etwa in ""sich entfernen,"" aber das ist eher unüblich (obwohl nicht ohne Charme!). Verbergänzungen wie Präpositionen verwendet man in SMALLTALK dauernd (schon um mehrere Parameter voneinander abzusetzen); in Sprachen wie JAVA fügt man einem allgemeinen (und häufig überladenen) Verb dann gelegentlich noch ein Substantiv als Objekt des Prädikats hinzu, wie in ""addElement."" Gerade dieses Beispiel ist jedoch nicht unumstritten, da „Element“ hier gewissermaßen redundant ist — wenn es mehrere Methoden namens „add“ gibt, kann man sie auch mittels ihrer Parametertypen unterscheiden (also überladen). So heißt die entsprechende Methode im JDK heute auch nur noch ""add(.)"".
Keine Verben, sondern Adjektive (oder Kopula plus Prädikatsnomen) verwendet man hingegen für Methoden, die eine Abfrage darstellen (Queries; s. Abschnitt 52.2), wie etwa ""istLeer"" oder ""hatInhalt.""
Für Instanzvariablen verwendet man unterschiedliche Wortarten, und zwar abhängig davon, ob eine Instanzvariable ein Attribut oder eine Beziehung repräsentiert. Wenn es sich um ein Attribut handelt, das eine mehrwertige Qualität ausdrückt (wie Größe, Farbe etc.), dann wird man den Namen der Qualität verwenden und damit ein Substantiv (ggf. in Kleinschreibung). Wenn es sich um ein zweiwertiges (Boolesches) Attribut handelt, dann nimmt man das entsprechende Adjektiv (wie etwa ""leer""), ein Gerundivum (z. B. ""laufend"") oder ein Partizip (wie etwa ""gelöst""). Für Instanzvariablen, die Beziehungen ausdrücken, nimmt man gerne den Namen der Gegenrolle, also beispielsweise ""mutter"" in einer Kind-Mutter-Beziehung. Bei n-Beziehungen nehme ich persönlich gerne den Plural, also z. B. ""kinder"" (statt ""kind"") für die umgekehrte Richtung.
Interfaces sind zwar wie Klassen Typen, aber bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte, die konkrete Ausprägungen der Allgemeinbegriffe sind, spielen können. Rollen werden aber, genau wie Allgemeinbegriffe, häufig durch Substantive bezeichnet: „Mutter“ ist ein Beispiel hierfür. Andere Rollen, insbesondere die, die mit Parametern von Methoden verbunden sind, werden häufig durch Adjektive bezeichnet: ""Druckbar"" beispielsweise könnte der Parametertyp einer Methode ""drucken"" sein, den das zu druckende Objekt haben muss. Tatsächlich enden viele der gebräuchlichen Interfacenamen im Englischen auf „able“ oder „ible“, so z. B. bei ""Serializable.""
Eine ganz interessante Option ergibt sich übrigens für Programmiererinnen, deren Muttersprache nicht Englisch ist: Man hat hier die Möglichkeit, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Ich persönlich verwende dann gerne für Begrifflichkeiten aus der Anwendungsdomäne (also dem Gegenstandsbereich, mit dem sich das Programm befasst) deutsche Bezeichner und für solche aus der technischen Umsetzung (Hilfsklassen etc.) englische. Alternativ kann man natürlich auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden.","<answer> In der Analysephase eines Projekts können alle Substantive aus der Spezifikation extrahiert werden, um auf der Basis dieser Liste die Menge der Klassen eines Systems zu identifizieren. Dies ist eine vielzitierte objektorientierte Technik. <answer> <question> Wie kann die Analysephase eines Projekts zur Identifizierung der Klassen eines Systems beitragen? <question>"
"Überaus angemessen, wenn auch nicht immer in letzter Konsequenz einzuhalten, ist, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. So legt beispielsweise der in Kurseinheit 1, Kapitel für Klassennamen Substantive verwendet. Tatsächlich ist es eine vielzitierte objektorientierte Technik, in der Analysephase eines Projekts alle Substantive der Spezifikation zu extrahieren, um auf der Basis der so gewonnenen Liste die Menge der Klassen eines Systems zu identifizieren.
Methoden, die eine Aktion implementieren (Befehle in EIFFEL, s. Kurseinheit 5, Abschnitt 52.2), wird man aufgrund ihres prädikativen Charakters mit Verben benennen, wobei es eine Stilfrage ist, ob man die Infinitiv- oder die Imperativform (im Englischen übrigens kein Unterschied in der Erscheinungsform) bevorzugt. Persönlich fühle ich mich hier an keine Regel gebunden außer an die, dass Ausdrücke durch meine Namenwahl möglichst lesbar werden. So klingt ""hinzufügen"" (Infinitivform) in meinen Ohren besser als ""add"" (Imperativform), ""entfernen"" (Imperativform) klingt dagegen besser als ""remove"" (Infinitivform). Man könnte natürlich der imperativen Form ein Reflexivpronomen hinzufügen wie etwa in ""sich entfernen,"" aber das ist eher unüblich (obwohl nicht ohne Charme!). Verbergänzungen wie Präpositionen verwendet man in SMALLTALK dauernd (schon um mehrere Parameter voneinander abzusetzen); in Sprachen wie JAVA fügt man einem allgemeinen (und häufig überladenen) Verb dann gelegentlich noch ein Substantiv als Objekt des Prädikats hinzu, wie in ""addElement."" Gerade dieses Beispiel ist jedoch nicht unumstritten, da „Element“ hier gewissermaßen redundant ist — wenn es mehrere Methoden namens „add“ gibt, kann man sie auch mittels ihrer Parametertypen unterscheiden (also überladen). So heißt die entsprechende Methode im JDK heute auch nur noch ""add(.)"".
Keine Verben, sondern Adjektive (oder Kopula plus Prädikatsnomen) verwendet man hingegen für Methoden, die eine Abfrage darstellen (Queries; s. Abschnitt 52.2), wie etwa ""istLeer"" oder ""hatInhalt.""
Für Instanzvariablen verwendet man unterschiedliche Wortarten, und zwar abhängig davon, ob eine Instanzvariable ein Attribut oder eine Beziehung repräsentiert. Wenn es sich um ein Attribut handelt, das eine mehrwertige Qualität ausdrückt (wie Größe, Farbe etc.), dann wird man den Namen der Qualität verwenden und damit ein Substantiv (ggf. in Kleinschreibung). Wenn es sich um ein zweiwertiges (Boolesches) Attribut handelt, dann nimmt man das entsprechende Adjektiv (wie etwa ""leer""), ein Gerundivum (z. B. ""laufend"") oder ein Partizip (wie etwa ""gelöst""). Für Instanzvariablen, die Beziehungen ausdrücken, nimmt man gerne den Namen der Gegenrolle, also beispielsweise ""mutter"" in einer Kind-Mutter-Beziehung. Bei n-Beziehungen nehme ich persönlich gerne den Plural, also z. B. ""kinder"" (statt ""kind"") für die umgekehrte Richtung.
Interfaces sind zwar wie Klassen Typen, aber bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte, die konkrete Ausprägungen der Allgemeinbegriffe sind, spielen können. Rollen werden aber, genau wie Allgemeinbegriffe, häufig durch Substantive bezeichnet: „Mutter“ ist ein Beispiel hierfür. Andere Rollen, insbesondere die, die mit Parametern von Methoden verbunden sind, werden häufig durch Adjektive bezeichnet: ""Druckbar"" beispielsweise könnte der Parametertyp einer Methode ""drucken"" sein, den das zu druckende Objekt haben muss. Tatsächlich enden viele der gebräuchlichen Interfacenamen im Englischen auf „able“ oder „ible“, so z. B. bei ""Serializable.""
Eine ganz interessante Option ergibt sich übrigens für Programmiererinnen, deren Muttersprache nicht Englisch ist: Man hat hier die Möglichkeit, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Ich persönlich verwende dann gerne für Begrifflichkeiten aus der Anwendungsdomäne (also dem Gegenstandsbereich, mit dem sich das Programm befasst) deutsche Bezeichner und für solche aus der technischen Umsetzung (Hilfsklassen etc.) englische. Alternativ kann man natürlich auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden.","<answer> Methoden, die eine Aktion implementieren (Befehle), werden oft mit Verben benannt. Bei der Wahl der Verben ist es eine Stilfrage, ob man die Infinitiv- oder die Imperativform bevorzugt. Beispielsweise kann man ""hinzufügen"" (Infinitivform) oder ""entfernen"" (Imperativform) verwenden. <answer> <question> Welche Art von Methoden wird oft mit Verben benannt, und welche Formen von Verben können verwendet werden? <question>"
"Überaus angemessen, wenn auch nicht immer in letzter Konsequenz einzuhalten, ist, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. So legt beispielsweise der in Kurseinheit 1, Kapitel für Klassennamen Substantive verwendet. Tatsächlich ist es eine vielzitierte objektorientierte Technik, in der Analysephase eines Projekts alle Substantive der Spezifikation zu extrahieren, um auf der Basis der so gewonnenen Liste die Menge der Klassen eines Systems zu identifizieren.
Methoden, die eine Aktion implementieren (Befehle in EIFFEL, s. Kurseinheit 5, Abschnitt 52.2), wird man aufgrund ihres prädikativen Charakters mit Verben benennen, wobei es eine Stilfrage ist, ob man die Infinitiv- oder die Imperativform (im Englischen übrigens kein Unterschied in der Erscheinungsform) bevorzugt. Persönlich fühle ich mich hier an keine Regel gebunden außer an die, dass Ausdrücke durch meine Namenwahl möglichst lesbar werden. So klingt ""hinzufügen"" (Infinitivform) in meinen Ohren besser als ""add"" (Imperativform), ""entfernen"" (Imperativform) klingt dagegen besser als ""remove"" (Infinitivform). Man könnte natürlich der imperativen Form ein Reflexivpronomen hinzufügen wie etwa in ""sich entfernen,"" aber das ist eher unüblich (obwohl nicht ohne Charme!). Verbergänzungen wie Präpositionen verwendet man in SMALLTALK dauernd (schon um mehrere Parameter voneinander abzusetzen); in Sprachen wie JAVA fügt man einem allgemeinen (und häufig überladenen) Verb dann gelegentlich noch ein Substantiv als Objekt des Prädikats hinzu, wie in ""addElement."" Gerade dieses Beispiel ist jedoch nicht unumstritten, da „Element“ hier gewissermaßen redundant ist — wenn es mehrere Methoden namens „add“ gibt, kann man sie auch mittels ihrer Parametertypen unterscheiden (also überladen). So heißt die entsprechende Methode im JDK heute auch nur noch ""add(.)"".
Keine Verben, sondern Adjektive (oder Kopula plus Prädikatsnomen) verwendet man hingegen für Methoden, die eine Abfrage darstellen (Queries; s. Abschnitt 52.2), wie etwa ""istLeer"" oder ""hatInhalt.""
Für Instanzvariablen verwendet man unterschiedliche Wortarten, und zwar abhängig davon, ob eine Instanzvariable ein Attribut oder eine Beziehung repräsentiert. Wenn es sich um ein Attribut handelt, das eine mehrwertige Qualität ausdrückt (wie Größe, Farbe etc.), dann wird man den Namen der Qualität verwenden und damit ein Substantiv (ggf. in Kleinschreibung). Wenn es sich um ein zweiwertiges (Boolesches) Attribut handelt, dann nimmt man das entsprechende Adjektiv (wie etwa ""leer""), ein Gerundivum (z. B. ""laufend"") oder ein Partizip (wie etwa ""gelöst""). Für Instanzvariablen, die Beziehungen ausdrücken, nimmt man gerne den Namen der Gegenrolle, also beispielsweise ""mutter"" in einer Kind-Mutter-Beziehung. Bei n-Beziehungen nehme ich persönlich gerne den Plural, also z. B. ""kinder"" (statt ""kind"") für die umgekehrte Richtung.
Interfaces sind zwar wie Klassen Typen, aber bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte, die konkrete Ausprägungen der Allgemeinbegriffe sind, spielen können. Rollen werden aber, genau wie Allgemeinbegriffe, häufig durch Substantive bezeichnet: „Mutter“ ist ein Beispiel hierfür. Andere Rollen, insbesondere die, die mit Parametern von Methoden verbunden sind, werden häufig durch Adjektive bezeichnet: ""Druckbar"" beispielsweise könnte der Parametertyp einer Methode ""drucken"" sein, den das zu druckende Objekt haben muss. Tatsächlich enden viele der gebräuchlichen Interfacenamen im Englischen auf „able“ oder „ible“, so z. B. bei ""Serializable.""
Eine ganz interessante Option ergibt sich übrigens für Programmiererinnen, deren Muttersprache nicht Englisch ist: Man hat hier die Möglichkeit, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Ich persönlich verwende dann gerne für Begrifflichkeiten aus der Anwendungsdomäne (also dem Gegenstandsbereich, mit dem sich das Programm befasst) deutsche Bezeichner und für solche aus der technischen Umsetzung (Hilfsklassen etc.) englische. Alternativ kann man natürlich auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden.","<answer> Für Methoden, die Abfragen darstellen (Queries), werden oft Adjektive oder Kopula plus Prädikatsnomen verwendet. Beispiele hierfür sind ""istLeer"" oder ""hatInhalt."" <answer> <question> Welche Namenskonvention wird für Methoden, die Abfragen darstellen (Queries), vorgeschlagen? <question>"
"Überaus angemessen, wenn auch nicht immer in letzter Konsequenz einzuhalten, ist, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. So legt beispielsweise der in Kurseinheit 1, Kapitel für Klassennamen Substantive verwendet. Tatsächlich ist es eine vielzitierte objektorientierte Technik, in der Analysephase eines Projekts alle Substantive der Spezifikation zu extrahieren, um auf der Basis der so gewonnenen Liste die Menge der Klassen eines Systems zu identifizieren.
Methoden, die eine Aktion implementieren (Befehle in EIFFEL, s. Kurseinheit 5, Abschnitt 52.2), wird man aufgrund ihres prädikativen Charakters mit Verben benennen, wobei es eine Stilfrage ist, ob man die Infinitiv- oder die Imperativform (im Englischen übrigens kein Unterschied in der Erscheinungsform) bevorzugt. Persönlich fühle ich mich hier an keine Regel gebunden außer an die, dass Ausdrücke durch meine Namenwahl möglichst lesbar werden. So klingt ""hinzufügen"" (Infinitivform) in meinen Ohren besser als ""add"" (Imperativform), ""entfernen"" (Imperativform) klingt dagegen besser als ""remove"" (Infinitivform). Man könnte natürlich der imperativen Form ein Reflexivpronomen hinzufügen wie etwa in ""sich entfernen,"" aber das ist eher unüblich (obwohl nicht ohne Charme!). Verbergänzungen wie Präpositionen verwendet man in SMALLTALK dauernd (schon um mehrere Parameter voneinander abzusetzen); in Sprachen wie JAVA fügt man einem allgemeinen (und häufig überladenen) Verb dann gelegentlich noch ein Substantiv als Objekt des Prädikats hinzu, wie in ""addElement."" Gerade dieses Beispiel ist jedoch nicht unumstritten, da „Element“ hier gewissermaßen redundant ist — wenn es mehrere Methoden namens „add“ gibt, kann man sie auch mittels ihrer Parametertypen unterscheiden (also überladen). So heißt die entsprechende Methode im JDK heute auch nur noch ""add(.)"".
Keine Verben, sondern Adjektive (oder Kopula plus Prädikatsnomen) verwendet man hingegen für Methoden, die eine Abfrage darstellen (Queries; s. Abschnitt 52.2), wie etwa ""istLeer"" oder ""hatInhalt.""
Für Instanzvariablen verwendet man unterschiedliche Wortarten, und zwar abhängig davon, ob eine Instanzvariable ein Attribut oder eine Beziehung repräsentiert. Wenn es sich um ein Attribut handelt, das eine mehrwertige Qualität ausdrückt (wie Größe, Farbe etc.), dann wird man den Namen der Qualität verwenden und damit ein Substantiv (ggf. in Kleinschreibung). Wenn es sich um ein zweiwertiges (Boolesches) Attribut handelt, dann nimmt man das entsprechende Adjektiv (wie etwa ""leer""), ein Gerundivum (z. B. ""laufend"") oder ein Partizip (wie etwa ""gelöst""). Für Instanzvariablen, die Beziehungen ausdrücken, nimmt man gerne den Namen der Gegenrolle, also beispielsweise ""mutter"" in einer Kind-Mutter-Beziehung. Bei n-Beziehungen nehme ich persönlich gerne den Plural, also z. B. ""kinder"" (statt ""kind"") für die umgekehrte Richtung.
Interfaces sind zwar wie Klassen Typen, aber bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte, die konkrete Ausprägungen der Allgemeinbegriffe sind, spielen können. Rollen werden aber, genau wie Allgemeinbegriffe, häufig durch Substantive bezeichnet: „Mutter“ ist ein Beispiel hierfür. Andere Rollen, insbesondere die, die mit Parametern von Methoden verbunden sind, werden häufig durch Adjektive bezeichnet: ""Druckbar"" beispielsweise könnte der Parametertyp einer Methode ""drucken"" sein, den das zu druckende Objekt haben muss. Tatsächlich enden viele der gebräuchlichen Interfacenamen im Englischen auf „able“ oder „ible“, so z. B. bei ""Serializable.""
Eine ganz interessante Option ergibt sich übrigens für Programmiererinnen, deren Muttersprache nicht Englisch ist: Man hat hier die Möglichkeit, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Ich persönlich verwende dann gerne für Begrifflichkeiten aus der Anwendungsdomäne (also dem Gegenstandsbereich, mit dem sich das Programm befasst) deutsche Bezeichner und für solche aus der technischen Umsetzung (Hilfsklassen etc.) englische. Alternativ kann man natürlich auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden.","<answer> Für Instanzvariablen, die Attribute repräsentieren, wie Größe oder Farbe, verwendet man oft den Namen der Qualität als Substantiv. Wenn es sich um zweiwertige (Boolesche) Attribute handelt, nimmt man das entsprechende Adjektiv oder ein Gerundivum. Für Instanzvariablen, die Beziehungen repräsentieren, verwendet man oft den Namen der Gegenrolle, wie ""mutter"" in einer Kind-Mutter-Beziehung. <answer> <question> Welche Wortarten werden für Instanzvariablen verwendet, abhängig davon, ob sie Attribute oder Beziehungen repräsentieren? <question>"
"Überaus angemessen, wenn auch nicht immer in letzter Konsequenz einzuhalten, ist, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. So legt beispielsweise der in Kurseinheit 1, Kapitel für Klassennamen Substantive verwendet. Tatsächlich ist es eine vielzitierte objektorientierte Technik, in der Analysephase eines Projekts alle Substantive der Spezifikation zu extrahieren, um auf der Basis der so gewonnenen Liste die Menge der Klassen eines Systems zu identifizieren.
Methoden, die eine Aktion implementieren (Befehle in EIFFEL, s. Kurseinheit 5, Abschnitt 52.2), wird man aufgrund ihres prädikativen Charakters mit Verben benennen, wobei es eine Stilfrage ist, ob man die Infinitiv- oder die Imperativform (im Englischen übrigens kein Unterschied in der Erscheinungsform) bevorzugt. Persönlich fühle ich mich hier an keine Regel gebunden außer an die, dass Ausdrücke durch meine Namenwahl möglichst lesbar werden. So klingt ""hinzufügen"" (Infinitivform) in meinen Ohren besser als ""add"" (Imperativform), ""entfernen"" (Imperativform) klingt dagegen besser als ""remove"" (Infinitivform). Man könnte natürlich der imperativen Form ein Reflexivpronomen hinzufügen wie etwa in ""sich entfernen,"" aber das ist eher unüblich (obwohl nicht ohne Charme!). Verbergänzungen wie Präpositionen verwendet man in SMALLTALK dauernd (schon um mehrere Parameter voneinander abzusetzen); in Sprachen wie JAVA fügt man einem allgemeinen (und häufig überladenen) Verb dann gelegentlich noch ein Substantiv als Objekt des Prädikats hinzu, wie in ""addElement."" Gerade dieses Beispiel ist jedoch nicht unumstritten, da „Element“ hier gewissermaßen redundant ist — wenn es mehrere Methoden namens „add“ gibt, kann man sie auch mittels ihrer Parametertypen unterscheiden (also überladen). So heißt die entsprechende Methode im JDK heute auch nur noch ""add(.)"".
Keine Verben, sondern Adjektive (oder Kopula plus Prädikatsnomen) verwendet man hingegen für Methoden, die eine Abfrage darstellen (Queries; s. Abschnitt 52.2), wie etwa ""istLeer"" oder ""hatInhalt.""
Für Instanzvariablen verwendet man unterschiedliche Wortarten, und zwar abhängig davon, ob eine Instanzvariable ein Attribut oder eine Beziehung repräsentiert. Wenn es sich um ein Attribut handelt, das eine mehrwertige Qualität ausdrückt (wie Größe, Farbe etc.), dann wird man den Namen der Qualität verwenden und damit ein Substantiv (ggf. in Kleinschreibung). Wenn es sich um ein zweiwertiges (Boolesches) Attribut handelt, dann nimmt man das entsprechende Adjektiv (wie etwa ""leer""), ein Gerundivum (z. B. ""laufend"") oder ein Partizip (wie etwa ""gelöst""). Für Instanzvariablen, die Beziehungen ausdrücken, nimmt man gerne den Namen der Gegenrolle, also beispielsweise ""mutter"" in einer Kind-Mutter-Beziehung. Bei n-Beziehungen nehme ich persönlich gerne den Plural, also z. B. ""kinder"" (statt ""kind"") für die umgekehrte Richtung.
Interfaces sind zwar wie Klassen Typen, aber bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte, die konkrete Ausprägungen der Allgemeinbegriffe sind, spielen können. Rollen werden aber, genau wie Allgemeinbegriffe, häufig durch Substantive bezeichnet: „Mutter“ ist ein Beispiel hierfür. Andere Rollen, insbesondere die, die mit Parametern von Methoden verbunden sind, werden häufig durch Adjektive bezeichnet: ""Druckbar"" beispielsweise könnte der Parametertyp einer Methode ""drucken"" sein, den das zu druckende Objekt haben muss. Tatsächlich enden viele der gebräuchlichen Interfacenamen im Englischen auf „able“ oder „ible“, so z. B. bei ""Serializable.""
Eine ganz interessante Option ergibt sich übrigens für Programmiererinnen, deren Muttersprache nicht Englisch ist: Man hat hier die Möglichkeit, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Ich persönlich verwende dann gerne für Begrifflichkeiten aus der Anwendungsdomäne (also dem Gegenstandsbereich, mit dem sich das Programm befasst) deutsche Bezeichner und für solche aus der technischen Umsetzung (Hilfsklassen etc.) englische. Alternativ kann man natürlich auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden.","<answer> Interfaces sind wie Klassen Typen, aber sie bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte spielen können. Diese Rollen werden häufig durch Substantive oder Adjektive bezeichnet. Zum Beispiel enden viele Interfacenamen im Englischen auf „able“ oder „ible“, wie ""Serializable."" <answer> <question> Warum werden Interfaces oft mit Substantiven oder Adjektiven bezeichnet? <question>"
"Überaus angemessen, wenn auch nicht immer in letzter Konsequenz einzuhalten, ist, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. So legt beispielsweise der in Kurseinheit 1, Kapitel für Klassennamen Substantive verwendet. Tatsächlich ist es eine vielzitierte objektorientierte Technik, in der Analysephase eines Projekts alle Substantive der Spezifikation zu extrahieren, um auf der Basis der so gewonnenen Liste die Menge der Klassen eines Systems zu identifizieren.
Methoden, die eine Aktion implementieren (Befehle in EIFFEL, s. Kurseinheit 5, Abschnitt 52.2), wird man aufgrund ihres prädikativen Charakters mit Verben benennen, wobei es eine Stilfrage ist, ob man die Infinitiv- oder die Imperativform (im Englischen übrigens kein Unterschied in der Erscheinungsform) bevorzugt. Persönlich fühle ich mich hier an keine Regel gebunden außer an die, dass Ausdrücke durch meine Namenwahl möglichst lesbar werden. So klingt ""hinzufügen"" (Infinitivform) in meinen Ohren besser als ""add"" (Imperativform), ""entfernen"" (Imperativform) klingt dagegen besser als ""remove"" (Infinitivform). Man könnte natürlich der imperativen Form ein Reflexivpronomen hinzufügen wie etwa in ""sich entfernen,"" aber das ist eher unüblich (obwohl nicht ohne Charme!). Verbergänzungen wie Präpositionen verwendet man in SMALLTALK dauernd (schon um mehrere Parameter voneinander abzusetzen); in Sprachen wie JAVA fügt man einem allgemeinen (und häufig überladenen) Verb dann gelegentlich noch ein Substantiv als Objekt des Prädikats hinzu, wie in ""addElement."" Gerade dieses Beispiel ist jedoch nicht unumstritten, da „Element“ hier gewissermaßen redundant ist — wenn es mehrere Methoden namens „add“ gibt, kann man sie auch mittels ihrer Parametertypen unterscheiden (also überladen). So heißt die entsprechende Methode im JDK heute auch nur noch ""add(.)"".
Keine Verben, sondern Adjektive (oder Kopula plus Prädikatsnomen) verwendet man hingegen für Methoden, die eine Abfrage darstellen (Queries; s. Abschnitt 52.2), wie etwa ""istLeer"" oder ""hatInhalt.""
Für Instanzvariablen verwendet man unterschiedliche Wortarten, und zwar abhängig davon, ob eine Instanzvariable ein Attribut oder eine Beziehung repräsentiert. Wenn es sich um ein Attribut handelt, das eine mehrwertige Qualität ausdrückt (wie Größe, Farbe etc.), dann wird man den Namen der Qualität verwenden und damit ein Substantiv (ggf. in Kleinschreibung). Wenn es sich um ein zweiwertiges (Boolesches) Attribut handelt, dann nimmt man das entsprechende Adjektiv (wie etwa ""leer""), ein Gerundivum (z. B. ""laufend"") oder ein Partizip (wie etwa ""gelöst""). Für Instanzvariablen, die Beziehungen ausdrücken, nimmt man gerne den Namen der Gegenrolle, also beispielsweise ""mutter"" in einer Kind-Mutter-Beziehung. Bei n-Beziehungen nehme ich persönlich gerne den Plural, also z. B. ""kinder"" (statt ""kind"") für die umgekehrte Richtung.
Interfaces sind zwar wie Klassen Typen, aber bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte, die konkrete Ausprägungen der Allgemeinbegriffe sind, spielen können. Rollen werden aber, genau wie Allgemeinbegriffe, häufig durch Substantive bezeichnet: „Mutter“ ist ein Beispiel hierfür. Andere Rollen, insbesondere die, die mit Parametern von Methoden verbunden sind, werden häufig durch Adjektive bezeichnet: ""Druckbar"" beispielsweise könnte der Parametertyp einer Methode ""drucken"" sein, den das zu druckende Objekt haben muss. Tatsächlich enden viele der gebräuchlichen Interfacenamen im Englischen auf „able“ oder „ible“, so z. B. bei ""Serializable.""
Eine ganz interessante Option ergibt sich übrigens für Programmiererinnen, deren Muttersprache nicht Englisch ist: Man hat hier die Möglichkeit, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Ich persönlich verwende dann gerne für Begrifflichkeiten aus der Anwendungsdomäne (also dem Gegenstandsbereich, mit dem sich das Programm befasst) deutsche Bezeichner und für solche aus der technischen Umsetzung (Hilfsklassen etc.) englische. Alternativ kann man natürlich auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden.","<answer> Programmiererinnen, deren Muttersprache nicht Englisch ist, haben die Möglichkeit, zwischen zwei Sprachen bei der Wahl der Bezeichner zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Man kann deutsche Bezeichner für Begrifflichkeiten aus der Anwendungsdomäne und englische Bezeichner für technische Umsetzungselemente verwenden, oder alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von denen aus Bibliotheken und Frameworks zu unterscheiden. <answer> <question> Was ist eine interessante Option für Programmiererinnen, deren Muttersprache nicht Englisch ist, in Bezug auf die Wahl der Bezeichner? <question>"
"Die Klasse Object definiert die Eigenschaften, die allen Objekten, einschließlich Array-Objekten, gemeinsam sind. Hierbei handelt es sich nicht um Felder (Instanzvariablen), sondern um elf Methoden. Diese sind: Object clone(): Zum Erzeugen von Kopien (vergleichbar mit SMALLTALK's copy). boolean equals(Object): Zum Test auf Gleichheit anstelle von Identität (entsprechend SMALLTALK's =). String toString(): Gibt eine String-Repräsentation des Objekts zurück (entsprechend SMALLTALK's printString). Class<? extends Object> getClass(): Zur Ermittlung des Klassentyps (entsprechend SMALLTALK's class). int hashCode(): Zur Speicherung von Objekten in Hash-Tabellen (entsprechend SMALLTALK's hash). void finalize(): Wird vom Garbage Collector aufgerufen, wenn das Objekt aus dem Speicher entfernt wird (dies ermöglicht das Freigeben von externen Ressourcen, die mit dem Objekt verbunden sind, wie z. B. das Schließen von Dateien). void notify() und void notifyAll(): Zur Benachrichtigung von Threads, die auf den Monitor des Objekts warten. void wait(): In drei Versionen, um den ausführenden Thread zum Warten zu bringen, entweder bis dem Objekt ein Notify gesendet wird oder ein anderes Ereignis eintritt.
In JAVA ist jeder Typ ein Subtyp von Object. Dies gilt auch für Interfaces. Es ist jedoch zu beachten, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können.","<answer> In JAVA ist jeder Typ, einschließlich Klassen und Interfaces, ein Subtyp von Object. Das bedeutet, dass alle Typen in JAVA die Methoden und Eigenschaften erben, die in der Object-Klasse definiert sind. Dies ermöglicht eine gewisse Einheitlichkeit und Polymorphie in der JAVA-Programmierung. Beachten Sie jedoch, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können, obwohl sie Object erweitern. <answer> <question> Was bedeutet es, dass in JAVA jeder Typ ein Subtyp von Object ist? <question>"
"Mit einer so chaotischen Syntax, dass sogar Compiler raten müssen, ist es besser, dass C++-Code wiederverwendbar ist, denn niemand wird jemals daran denken, ihn rückzuentwickeln. Die ""Funktion"" der Programmiersprache - nämlich eine Erweiterung von C zu sein - ist ein grundlegendes Problem. Mit zahlreichen großen Projekten, die bereits in veralteten Dialekten geschrieben wurden, kann man C++ sicherlich als eine ""sofortige Legacy""-Sprache betrachten.
Über C++ wurde viel geschrieben, und nicht alles davon war positiv. Dabei wird jedoch häufig vergessen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss. Natürlich kann man in C++ völlig unlesbaren Code schreiben, aber das gilt auch für C, weil man in C völlig unlesbaren Code schreiben kann. Aber man kann auch C++ mit einer neuen Syntax versehen (mithilfe seines Präprozessors, der übrigens Turing-äquivalent ist und daher die Ausdrucksstärke einer vollwertigen Programmiersprache besitzt) und dann völlig lesbaren Code schreiben.","<answer> C++ wird als ""sofortige Legacy""-Sprache bezeichnet, weil sie eine Erweiterung von C ist und eine chaotische Syntax hat, die es schwer macht, den Code zu verstehen oder zurückzuentwickeln. Außerdem gibt es viele große Projekte, die bereits in veralteten C++-Dialekten geschrieben wurden. <answer> <question> Warum wird C++ als ""sofortige Legacy""-Sprache bezeichnet? <question>"
"Mit einer so chaotischen Syntax, dass sogar Compiler raten müssen, ist es besser, dass C++-Code wiederverwendbar ist, denn niemand wird jemals daran denken, ihn rückzuentwickeln. Die ""Funktion"" der Programmiersprache - nämlich eine Erweiterung von C zu sein - ist ein grundlegendes Problem. Mit zahlreichen großen Projekten, die bereits in veralteten Dialekten geschrieben wurden, kann man C++ sicherlich als eine ""sofortige Legacy""-Sprache betrachten.
Über C++ wurde viel geschrieben, und nicht alles davon war positiv. Dabei wird jedoch häufig vergessen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss. Natürlich kann man in C++ völlig unlesbaren Code schreiben, aber das gilt auch für C, weil man in C völlig unlesbaren Code schreiben kann. Aber man kann auch C++ mit einer neuen Syntax versehen (mithilfe seines Präprozessors, der übrigens Turing-äquivalent ist und daher die Ausdrucksstärke einer vollwertigen Programmiersprache besitzt) und dann völlig lesbaren Code schreiben.","<answer> Es wird darauf hingewiesen, dass C++ eine Erweiterung von C ist, um zu betonen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist. Dies bedeutet, dass C++-Code mit C-Code kombiniert werden kann und C++-Programmierer auf bestehende C-Bibliotheken zugreifen können. <answer> <question> Warum wird darauf hingewiesen, dass C++ eine Erweiterung von C ist? <question>"
"Mit einer so chaotischen Syntax, dass sogar Compiler raten müssen, ist es besser, dass C++-Code wiederverwendbar ist, denn niemand wird jemals daran denken, ihn rückzuentwickeln. Die ""Funktion"" der Programmiersprache - nämlich eine Erweiterung von C zu sein - ist ein grundlegendes Problem. Mit zahlreichen großen Projekten, die bereits in veralteten Dialekten geschrieben wurden, kann man C++ sicherlich als eine ""sofortige Legacy""-Sprache betrachten.
Über C++ wurde viel geschrieben, und nicht alles davon war positiv. Dabei wird jedoch häufig vergessen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss. Natürlich kann man in C++ völlig unlesbaren Code schreiben, aber das gilt auch für C, weil man in C völlig unlesbaren Code schreiben kann. Aber man kann auch C++ mit einer neuen Syntax versehen (mithilfe seines Präprozessors, der übrigens Turing-äquivalent ist und daher die Ausdrucksstärke einer vollwertigen Programmiersprache besitzt) und dann völlig lesbaren Code schreiben.","<answer> Es wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann, um zu betonen, dass die Lesbarkeit des Codes in C++ stark von der Programmierpraxis abhängt. C++ bietet die Flexibilität, Code auf unterschiedliche Weisen zu schreiben, von sehr lesbar bis hin zu sehr unlesbar, je nach den Entscheidungen der Entwickler. <answer> <question> Warum wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann? <question>"
"Mit einer so chaotischen Syntax, dass sogar Compiler raten müssen, ist es besser, dass C++-Code wiederverwendbar ist, denn niemand wird jemals daran denken, ihn rückzuentwickeln. Die ""Funktion"" der Programmiersprache - nämlich eine Erweiterung von C zu sein - ist ein grundlegendes Problem. Mit zahlreichen großen Projekten, die bereits in veralteten Dialekten geschrieben wurden, kann man C++ sicherlich als eine ""sofortige Legacy""-Sprache betrachten.
Über C++ wurde viel geschrieben, und nicht alles davon war positiv. Dabei wird jedoch häufig vergessen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss. Natürlich kann man in C++ völlig unlesbaren Code schreiben, aber das gilt auch für C, weil man in C völlig unlesbaren Code schreiben kann. Aber man kann auch C++ mit einer neuen Syntax versehen (mithilfe seines Präprozessors, der übrigens Turing-äquivalent ist und daher die Ausdrucksstärke einer vollwertigen Programmiersprache besitzt) und dann völlig lesbaren Code schreiben.","<answer> Der Präprozessor in C++ bietet die Freiheit, die Syntax der Sprache durch Hinzufügen einer neuen Syntax zu verändern. Dies ermöglicht es, Code in einer für Entwickler verständlicheren Weise zu schreiben, wenn gewünscht. <answer> <question> Welche Freiheit bietet der Präprozessor in C++? <question>"
"In der klassenbasierten Form der objektorientierten Programmierung ist die Vererbung an Klassen gebunden: Selbst wenn sich die Definitionen eigentlich auf die Instanzen der Klassen beziehen, so ist es doch die Klasse, die Teile ihrer Definition (Intension) von anderen erbt. Im Gegensatz dazu ist die Vererbung in prototypenbasierten objektorientierten Programmiersprachen, in denen es ja keine Klassen gibt, vollständig zwischen Objekten definiert: Jedes Objekt gibt eines oder mehrere andere an, deren Eigenschaften und Verhalten es übernimmt. Dabei kann es geerbte Teile der Definition überschreiben und auch löschen.
Auf den ersten Blick scheint es so, als sei dies sogar der natürlichere Weg der Vererbung: Schließlich findet in der Natur Vererbung ja auch ausschließlich zwischen Individuen statt, ja genaugenommen gibt es so etwas wie biologische Klassen (Arten etc.) in der Natur überhaupt nicht. Denn es differenzieren sich ständig einzelne „Arten“ zu neuen, und es ist nicht ausgeschlossen, dass einmal ausdifferenzierte Arten irgendwann wieder verschmelzen. Abgesehen davon ist, wie bereits in Kapitel 7 erwähnt, die reale Existenz von Allgemeinbegriffen strittig (der Universalienstreit).
Man kann dem freilich entgegenhalten, dass man als Programmierer keine einzelnen Objekte, sondern Klassen entwirft, die damit die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Auch sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung, eben der Evolution, und somit sind auch Klassendefinitionen im ständigen Wandel. Eine Übertragung der Vererbung auf Klassen ist also nicht vollkommen unnatürlich.
Nicht zuletzt muss man auch erkennen, dass viele Anwendungsdomänen, für die programmiert wird, aus massenhaft gleichen Objekten bestehen, die durch den klassenbasierten Ansatz besser abgedeckt werden als durch den prototypenbasierten (vgl. die entsprechenden Kommentare zur Klassifikation in Abschnitt 7.1). Und so macht denn auch die Vererbung unter Instanzen das Nachvollziehen (und Debuggen) eines Programms eher noch schwieriger als die Vererbung unter Klassen ohnehin schon (s. Kapitel 56 in Kurseinheit 6).","<answer> In klassenbasierten objektorientierten Programmiersprachen ist die Vererbung an Klassen gebunden, während in prototypenbasierten Sprachen die Vererbung vollständig zwischen Objekten definiert ist. In prototypenbasierten Systemen gibt jedes Objekt eines oder mehrere andere an, von denen es Eigenschaften und Verhalten erbt. Es hat die Möglichkeit, geerbte Teile der Definition zu überschreiben und zu löschen. <answer> <question> Wie unterscheidet sich Vererbung in prototypenbasierten objektorientierten Programmiersprachen von der Vererbung in klassenbasierten Systemen? <question>"
"In der klassenbasierten Form der objektorientierten Programmierung ist die Vererbung an Klassen gebunden: Selbst wenn sich die Definitionen eigentlich auf die Instanzen der Klassen beziehen, so ist es doch die Klasse, die Teile ihrer Definition (Intension) von anderen erbt. Im Gegensatz dazu ist die Vererbung in prototypenbasierten objektorientierten Programmiersprachen, in denen es ja keine Klassen gibt, vollständig zwischen Objekten definiert: Jedes Objekt gibt eines oder mehrere andere an, deren Eigenschaften und Verhalten es übernimmt. Dabei kann es geerbte Teile der Definition überschreiben und auch löschen.
Auf den ersten Blick scheint es so, als sei dies sogar der natürlichere Weg der Vererbung: Schließlich findet in der Natur Vererbung ja auch ausschließlich zwischen Individuen statt, ja genaugenommen gibt es so etwas wie biologische Klassen (Arten etc.) in der Natur überhaupt nicht. Denn es differenzieren sich ständig einzelne „Arten“ zu neuen, und es ist nicht ausgeschlossen, dass einmal ausdifferenzierte Arten irgendwann wieder verschmelzen. Abgesehen davon ist, wie bereits in Kapitel 7 erwähnt, die reale Existenz von Allgemeinbegriffen strittig (der Universalienstreit).
Man kann dem freilich entgegenhalten, dass man als Programmierer keine einzelnen Objekte, sondern Klassen entwirft, die damit die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Auch sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung, eben der Evolution, und somit sind auch Klassendefinitionen im ständigen Wandel. Eine Übertragung der Vererbung auf Klassen ist also nicht vollkommen unnatürlich.
Nicht zuletzt muss man auch erkennen, dass viele Anwendungsdomänen, für die programmiert wird, aus massenhaft gleichen Objekten bestehen, die durch den klassenbasierten Ansatz besser abgedeckt werden als durch den prototypenbasierten (vgl. die entsprechenden Kommentare zur Klassifikation in Abschnitt 7.1). Und so macht denn auch die Vererbung unter Instanzen das Nachvollziehen (und Debuggen) eines Programms eher noch schwieriger als die Vererbung unter Klassen ohnehin schon (s. Kapitel 56 in Kurseinheit 6).","<answer> Auf den ersten Blick könnte die prototypenbasierte Vererbung als natürlicher angesehen werden, da sie dem Prinzip der biologischen Vererbung ähnelt, bei dem Merkmale von Individuum zu Individuum weitergegeben werden. In der Natur gibt es keine festen biologischen Klassen wie in klassenbasierten Systemen, und Arten können sich ständig verändern und anpassen. <answer> <question> Warum könnte die prototypenbasierte Vererbung auf den ersten Blick als natürlicher angesehen werden? <question>"
"In der klassenbasierten Form der objektorientierten Programmierung ist die Vererbung an Klassen gebunden: Selbst wenn sich die Definitionen eigentlich auf die Instanzen der Klassen beziehen, so ist es doch die Klasse, die Teile ihrer Definition (Intension) von anderen erbt. Im Gegensatz dazu ist die Vererbung in prototypenbasierten objektorientierten Programmiersprachen, in denen es ja keine Klassen gibt, vollständig zwischen Objekten definiert: Jedes Objekt gibt eines oder mehrere andere an, deren Eigenschaften und Verhalten es übernimmt. Dabei kann es geerbte Teile der Definition überschreiben und auch löschen.
Auf den ersten Blick scheint es so, als sei dies sogar der natürlichere Weg der Vererbung: Schließlich findet in der Natur Vererbung ja auch ausschließlich zwischen Individuen statt, ja genaugenommen gibt es so etwas wie biologische Klassen (Arten etc.) in der Natur überhaupt nicht. Denn es differenzieren sich ständig einzelne „Arten“ zu neuen, und es ist nicht ausgeschlossen, dass einmal ausdifferenzierte Arten irgendwann wieder verschmelzen. Abgesehen davon ist, wie bereits in Kapitel 7 erwähnt, die reale Existenz von Allgemeinbegriffen strittig (der Universalienstreit).
Man kann dem freilich entgegenhalten, dass man als Programmierer keine einzelnen Objekte, sondern Klassen entwirft, die damit die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Auch sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung, eben der Evolution, und somit sind auch Klassendefinitionen im ständigen Wandel. Eine Übertragung der Vererbung auf Klassen ist also nicht vollkommen unnatürlich.
Nicht zuletzt muss man auch erkennen, dass viele Anwendungsdomänen, für die programmiert wird, aus massenhaft gleichen Objekten bestehen, die durch den klassenbasierten Ansatz besser abgedeckt werden als durch den prototypenbasierten (vgl. die entsprechenden Kommentare zur Klassifikation in Abschnitt 7.1). Und so macht denn auch die Vererbung unter Instanzen das Nachvollziehen (und Debuggen) eines Programms eher noch schwieriger als die Vererbung unter Klassen ohnehin schon (s. Kapitel 56 in Kurseinheit 6).","<answer> Programmierer entwerfen normalerweise Klassen, nicht einzelne Objekte. Klassen sind die grundlegende Entität in der klassenbasierten objektorientierten Programmierung, und Klassendefinitionen ändern sich im Laufe der Zeit. Klassen bieten auch eine bessere Abdeckung für Anwendungsdomänen, die aus vielen gleichen Objekten bestehen. Daher wird die Vererbung oft auf Klassen übertragen, da sie besser zur strukturierten Programmierung passt und das Verfolgen und Debuggen von Programmen erleichtert. <answer> <question> Warum wird die Vererbung oft auf Klassen in der objektorientierten Programmierung übertragen, obwohl sie in prototypenbasierten Sprachen zwischen Objekten definiert ist? <question>"
"In der klassenbasierten Form der objektorientierten Programmierung ist die Vererbung an Klassen gebunden: Selbst wenn sich die Definitionen eigentlich auf die Instanzen der Klassen beziehen, so ist es doch die Klasse, die Teile ihrer Definition (Intension) von anderen erbt. Im Gegensatz dazu ist die Vererbung in prototypenbasierten objektorientierten Programmiersprachen, in denen es ja keine Klassen gibt, vollständig zwischen Objekten definiert: Jedes Objekt gibt eines oder mehrere andere an, deren Eigenschaften und Verhalten es übernimmt. Dabei kann es geerbte Teile der Definition überschreiben und auch löschen.
Auf den ersten Blick scheint es so, als sei dies sogar der natürlichere Weg der Vererbung: Schließlich findet in der Natur Vererbung ja auch ausschließlich zwischen Individuen statt, ja genaugenommen gibt es so etwas wie biologische Klassen (Arten etc.) in der Natur überhaupt nicht. Denn es differenzieren sich ständig einzelne „Arten“ zu neuen, und es ist nicht ausgeschlossen, dass einmal ausdifferenzierte Arten irgendwann wieder verschmelzen. Abgesehen davon ist, wie bereits in Kapitel 7 erwähnt, die reale Existenz von Allgemeinbegriffen strittig (der Universalienstreit).
Man kann dem freilich entgegenhalten, dass man als Programmierer keine einzelnen Objekte, sondern Klassen entwirft, die damit die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Auch sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung, eben der Evolution, und somit sind auch Klassendefinitionen im ständigen Wandel. Eine Übertragung der Vererbung auf Klassen ist also nicht vollkommen unnatürlich.
Nicht zuletzt muss man auch erkennen, dass viele Anwendungsdomänen, für die programmiert wird, aus massenhaft gleichen Objekten bestehen, die durch den klassenbasierten Ansatz besser abgedeckt werden als durch den prototypenbasierten (vgl. die entsprechenden Kommentare zur Klassifikation in Abschnitt 7.1). Und so macht denn auch die Vererbung unter Instanzen das Nachvollziehen (und Debuggen) eines Programms eher noch schwieriger als die Vererbung unter Klassen ohnehin schon (s. Kapitel 56 in Kurseinheit 6).","<answer> Die Vererbung zwischen Instanzen kann das Verfolgen und Debuggen von Programmen erschweren, da sie die Beziehungen zwischen Objekten komplexer gestaltet. Wenn Objekte Eigenschaften und Verhalten von anderen Objekten erben können und diese Eigenschaften überschreiben oder löschen können, kann dies zu unvorhersehbarem Verhalten führen und die Fehlersuche erschweren. <answer> <question> Warum könnte die Vererbung zwischen Instanzen in der objektorientierten Programmierung das Verfolgen und Debuggen von Programmen erschweren? <question>"
"Logischerweise können Instanzvariablen in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Typische Eigenschaften sind beispielsweise die Farbe von etwas oder der Name; sie unterscheiden sich inhaltlich von Beziehungen dadurch, dass das bezogene Objekt seine Bedeutung verliert, wenn es isoliert betrachtet wird. Ein Objekt wie ""Rot"" ist allein nichts anderes als eine Farbe; es erhält erst Bedeutung, wenn es als Attribut eines Objekts wie ""Apfel"" betrachtet wird. Das Gleiche gilt für ""Schmidtchen"" oder ""1"". Zudem ist zu beachten, dass Attributwerte wie die genannten in der Regel selbst keine Attribute besitzen oder Beziehungen zu anderen Objekten nicht eingehen.
Es ist jedoch wichtig zu beachten, dass dieses Unterscheidungskriterium relativ zur jeweils betrachteten Domäne ist. Wenn es beispielsweise um Farben geht, hat ""Rot"" an sich bereits eine Bedeutung und kann vollwertige Beziehungen zu anderen Objekten eingehen, wie zum Beispiel ""Grün"" als sein Komplementärkontrast.
Wenn wir von Attributwerten sprechen, ist das nicht zufällig. Häufig haben Variablen, die Attribute repräsentieren, zumindest logisch eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Ein typisches Beispiel dafür haben Sie bereits in Abschnitt 1.8 kennengelernt. Es ist sinnvoll, dass die Änderung des Namens (genauer gesagt, des Namensobjekts) bei einer Person nicht gleichzeitig andere Personen betrifft, die denselben (nicht denselben!) Namen haben. Eine ähnliche Überlegung spielt auch im Zusammenhang mit der Betrachtung des Zustands eines Objekts eine Rolle.","<answer> Instanzvariablen können logischerweise in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Eigenschaften sind Attribute wie Farbe oder Name, die ihre Bedeutung verlieren, wenn sie isoliert betrachtet werden. Beziehungen hingegen repräsentieren Verbindungen zwischen Objekten und behalten ihre Bedeutung auch isoliert betrachtet. <answer> <question> Wie können Instanzvariablen logischerweise in zwei Kategorien unterteilt werden, und welche Unterschiede gibt es zwischen diesen Kategorien? <question>"
"Logischerweise können Instanzvariablen in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Typische Eigenschaften sind beispielsweise die Farbe von etwas oder der Name; sie unterscheiden sich inhaltlich von Beziehungen dadurch, dass das bezogene Objekt seine Bedeutung verliert, wenn es isoliert betrachtet wird. Ein Objekt wie ""Rot"" ist allein nichts anderes als eine Farbe; es erhält erst Bedeutung, wenn es als Attribut eines Objekts wie ""Apfel"" betrachtet wird. Das Gleiche gilt für ""Schmidtchen"" oder ""1"". Zudem ist zu beachten, dass Attributwerte wie die genannten in der Regel selbst keine Attribute besitzen oder Beziehungen zu anderen Objekten nicht eingehen.
Es ist jedoch wichtig zu beachten, dass dieses Unterscheidungskriterium relativ zur jeweils betrachteten Domäne ist. Wenn es beispielsweise um Farben geht, hat ""Rot"" an sich bereits eine Bedeutung und kann vollwertige Beziehungen zu anderen Objekten eingehen, wie zum Beispiel ""Grün"" als sein Komplementärkontrast.
Wenn wir von Attributwerten sprechen, ist das nicht zufällig. Häufig haben Variablen, die Attribute repräsentieren, zumindest logisch eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Ein typisches Beispiel dafür haben Sie bereits in Abschnitt 1.8 kennengelernt. Es ist sinnvoll, dass die Änderung des Namens (genauer gesagt, des Namensobjekts) bei einer Person nicht gleichzeitig andere Personen betrifft, die denselben (nicht denselben!) Namen haben. Eine ähnliche Überlegung spielt auch im Zusammenhang mit der Betrachtung des Zustands eines Objekts eine Rolle.","<answer> Das Unterscheidungskriterium zwischen Attributen und Beziehungen hängt von der betrachteten Domäne ab. In einigen Kontexten, wie bei Farben, kann ""Rot"" bereits eine Bedeutung haben und vollwertige Beziehungen zu anderen Objekten eingehen, während es in anderen Kontexten lediglich eine Farbe ohne spezifische Bedeutung ist. Die Unterscheidung zwischen Attributen und Beziehungen ist daher relativ und kontextabhängig. <answer> <question> Warum ist es wichtig zu beachten, dass das Unterscheidungskriterium zwischen Attributen und Beziehungen relativ zur betrachteten Domäne ist? <question>"
"Logischerweise können Instanzvariablen in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Typische Eigenschaften sind beispielsweise die Farbe von etwas oder der Name; sie unterscheiden sich inhaltlich von Beziehungen dadurch, dass das bezogene Objekt seine Bedeutung verliert, wenn es isoliert betrachtet wird. Ein Objekt wie ""Rot"" ist allein nichts anderes als eine Farbe; es erhält erst Bedeutung, wenn es als Attribut eines Objekts wie ""Apfel"" betrachtet wird. Das Gleiche gilt für ""Schmidtchen"" oder ""1"". Zudem ist zu beachten, dass Attributwerte wie die genannten in der Regel selbst keine Attribute besitzen oder Beziehungen zu anderen Objekten nicht eingehen.
Es ist jedoch wichtig zu beachten, dass dieses Unterscheidungskriterium relativ zur jeweils betrachteten Domäne ist. Wenn es beispielsweise um Farben geht, hat ""Rot"" an sich bereits eine Bedeutung und kann vollwertige Beziehungen zu anderen Objekten eingehen, wie zum Beispiel ""Grün"" als sein Komplementärkontrast.
Wenn wir von Attributwerten sprechen, ist das nicht zufällig. Häufig haben Variablen, die Attribute repräsentieren, zumindest logisch eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Ein typisches Beispiel dafür haben Sie bereits in Abschnitt 1.8 kennengelernt. Es ist sinnvoll, dass die Änderung des Namens (genauer gesagt, des Namensobjekts) bei einer Person nicht gleichzeitig andere Personen betrifft, die denselben (nicht denselben!) Namen haben. Eine ähnliche Überlegung spielt auch im Zusammenhang mit der Betrachtung des Zustands eines Objekts eine Rolle.","<answer> Variablen, die Attribute repräsentieren, haben in der Regel eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Dies ermöglicht es, dass Änderungen an einem Attributwert nicht automatisch andere Objekte mit dem gleichen Attributwert beeinflussen. Zum Beispiel sollte die Änderung des Namens einer Person nicht gleichzeitig andere Personen mit dem gleichen Namen betreffen. <answer> <question> Welche Art von Semantik haben Variablen, die Attribute repräsentieren, in der Regel? <question>"
"Logischerweise können Instanzvariablen in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Typische Eigenschaften sind beispielsweise die Farbe von etwas oder der Name; sie unterscheiden sich inhaltlich von Beziehungen dadurch, dass das bezogene Objekt seine Bedeutung verliert, wenn es isoliert betrachtet wird. Ein Objekt wie ""Rot"" ist allein nichts anderes als eine Farbe; es erhält erst Bedeutung, wenn es als Attribut eines Objekts wie ""Apfel"" betrachtet wird. Das Gleiche gilt für ""Schmidtchen"" oder ""1"". Zudem ist zu beachten, dass Attributwerte wie die genannten in der Regel selbst keine Attribute besitzen oder Beziehungen zu anderen Objekten nicht eingehen.
Es ist jedoch wichtig zu beachten, dass dieses Unterscheidungskriterium relativ zur jeweils betrachteten Domäne ist. Wenn es beispielsweise um Farben geht, hat ""Rot"" an sich bereits eine Bedeutung und kann vollwertige Beziehungen zu anderen Objekten eingehen, wie zum Beispiel ""Grün"" als sein Komplementärkontrast.
Wenn wir von Attributwerten sprechen, ist das nicht zufällig. Häufig haben Variablen, die Attribute repräsentieren, zumindest logisch eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Ein typisches Beispiel dafür haben Sie bereits in Abschnitt 1.8 kennengelernt. Es ist sinnvoll, dass die Änderung des Namens (genauer gesagt, des Namensobjekts) bei einer Person nicht gleichzeitig andere Personen betrifft, die denselben (nicht denselben!) Namen haben. Eine ähnliche Überlegung spielt auch im Zusammenhang mit der Betrachtung des Zustands eines Objekts eine Rolle.","<answer> Im Zusammenhang mit der Betrachtung des Zustands eines Objekts spielt die Überlegung eine Rolle, dass Änderungen an Attributen den Zustand eines Objekts beeinflussen können. Dies ist wichtig, um sicherzustellen, dass der Zustand eines Objekts konsistent und isoliert von anderen Objekten behandelt wird. In solchen Fällen ist eine Wertsemantik für Attribute oft sinnvoll. <answer> <question> Welche Überlegungen spielen eine Rolle im Zusammenhang mit der Betrachtung des Zustands eines Objekts im Kontext von Attributen? <question>"
"Für die Implementierung von Wiederholungen (Schleifen) müssen wir etwas weiter ausholen: Da das Abbruchkriterium von Schleifen immer wieder (bei jedem Schleifendurchlauf) ausgewertet werden muss, kann nicht einfach einmal eine Nachricht an eine Variable mit Inhalt true oder false gesendet werden. Vielmehr muss die Auswertung des Abbruchkriteriums selbst in einem Block stattfinden, der bei jedem Schleifendurchlauf erneut ausgewertet wird. Aber auch das ist kein Problem: Der Nachrichtenempfänger ist einfach ein Block, dessen Auswertung entweder true oder false zurückliefert; der Parameter der Nachricht ist dann der Block, der den Schleifenrumpf darstellt.
Die Schleife wird durch eine sogenannte Endrekursion simuliert: whileTrue: ruft sich am Ende selbst wieder auf. Wegen der Performanz (oder möglicher Beschränkungen der Anzahl der Schleifendurchläufe durch die Größe des Aufrufstacks) brauchen Sie sich dabei keine Sorgen zu machen: Da hinter dem rekursiven Aufruf nichts mehr passiert (deshalb Endrekursion), kann dieser vom Compiler in eine echte Schleife übersetzt werden.
Für die ebenfalls aus anderen Sprachen bekannten For-Schleifen hat SMALLTALK eine andere elegante Lösung parat, auf die wir im nächsten Abschnitt eingehen werden.","<answer> In SMALLTALK wird die Implementierung von Wiederholungen (Schleifen) durch Endrekursion simuliert. Dabei wird eine Methode wie whileTrue: am Ende selbst wieder aufgerufen. Der Schleifenrumpf wird durch einen Block dargestellt, und das Abbruchkriterium wird ebenfalls in einem Block ausgewertet. Der rekursive Aufruf am Ende der Methode kann vom Compiler in eine echte Schleife übersetzt werden. <answer> <question> Wie wird die Implementierung von Wiederholungen (Schleifen) in SMALLTALK realisiert? <question>"
"Sicher ist Ihnen aufgefallen, dass uns bislang keine Schlüsselwörter in SMALLTALK begegnet sind (bis auf die sog. Schlüsselwortnachrichten, die aber frei wählbar sind und deswegen eben gerade keine Schlüsselwörter sind; vgl. Abschnitt 4.1.2). Der Grund hierfür ist einfach: Es gibt keine Schlüsselwörter, lediglich ein paar Symbole mit spezieller Bedeutung. Es sind dies:
:=	Zuweisung
.	Trennzeichen zwischen zwei Anweisungen sowie Dezimalpunkt für Gleitkommazahlen
;	Trennzeichen zum Kaskadieren von Nachrichten
:	Markierung von Parametern in Nachrichten und Blöcken
( )	Klammerung von Ausdrücken zur Festlegung der Reihenfolge der Auswertung
[ ]	Bildung von Blöcken
	Trennzeichen zwischen den Parametern eines Blocks und seinen Anweisungen
"" ""	Markierung von Kommentaren
' '	Markierung von String-Literalen
$	Markierung von Zeichenliteralen
| Markierung von Symbol- und Array-Literalen
^ | Rückgabe-Operator (Return)
Das ist alles! Die reservierten Namen true, false, nil, self und super sind die von Pseudovariablen; alle aus anderen Sprachen bekannten Schlüsselwörter sind als Methoden in SMALLTALK selbst definiert.","<answer> In SMALLTALK gibt es einige reservierte Namen, die als Pseudovariablen dienen. Diese reservierten Namen sind: true, false, nil, self and super. Alle anderen Schlüsselwörter, die in anderen Programmiersprachen üblich sind, werden in SMALLTALK als Methoden definiert und können daher erweitert oder angepasst werden. <answer> <question> Welche reservierten Namen sind in SMALLTALK vorhanden? <question>"
"Die Klasse ""Collection"" ist, wie gesagt, abstrakt. SMALLTALK sieht nun eine ganze Hierarchie von spezielleren, instanziierbaren (konkreten) Collection-Klassen vor, die für die unterschiedlichsten Zwecke eingesetzt werden können. Darunter sind so offensichtliche wie ""Set"" (für ungeordnete Collections, in denen jedes Element höchstens einmal vorkommen darf, also Mengen) und ""Bag"" (für solche, in denen die letzte Einschränkung aufgehoben ist). ""Set"" und ""Bag"" haben (neben der mangelnden Ordnung ihrer Elemente) gemeinsam, dass die Elemente in beiden nicht über einen Index zugreifbar sind. Im Gegensatz dazu stehen geordnete Collections (Klasse ""SequenceableCollection"" oder ""IndexedCollection"", je nach System), in denen das i-te Element eindeutig bestimmt ist und die entsprechend die Methoden ""at:"" und ""at:put:"" implementieren (genaugenommen überschreiben, denn diese Methoden sind ja für alle Objekte, die über indizierte Instanzvariablen verfügen, schon definiert und werden lediglich für ungeordnete Collections wieder gelöscht). Aber auch ungeordnete Collections (in denen keine Reihenfolge festgelegt ist) können indiziert sein: In Objekten der Klasse ""Dictionary"" wird jedes Element unter einem Schlüssel, der selbst wieder ein Objekt sein kann, gespeichert. Die dazugehörigen Methoden heißen wiederum ""at:"" und ""at:put:"", erlauben aber Objekte anderer Klassen als Integer als Indizes.","<answer> Einige Beispiele für spezielle, instanziierbare (konkrete) Collection-Klassen in SMALLTALK sind: Set: Diese Klasse wird verwendet, um ungeordnete Collections darzustellen, in denen jedes Element höchstens einmal vorkommen darf, was einer Menge entspricht. Bag: Bag wird verwendet, um ungeordnete Collections darzustellen, in denen die Einschränkung aufgehoben ist, dass Elemente nur einmal vorkommen dürfen. In einer Bag können Elemente mehrmals vorhanden sein. SequenceableCollection oder IndexedCollection: Diese Klassen repräsentieren geordnete Collections, bei denen das i-te Element eindeutig bestimmt ist. Sie implementieren die Methoden ""at:"" und ""at:put:"", um auf Elemente zuzugreifen oder Elemente an einer bestimmten Position einzufügen oder zu ändern. Dictionary: Diese Klasse repräsentiert eine ungeordnete Collection, bei der jedes Element unter einem Schlüssel gespeichert wird. Die Methoden ""at:"" und ""at:put:"" werden verwendet, um auf die Elemente zuzugreifen oder sie zu ändern. Dabei können Schlüssel Objekte verschiedener Klassen sein, nicht nur Integer. <answer> <question> Was sind einige Beispiele für spezielle, instanziierbare (konkrete) Collection-Klassen in SMALLTALK und wofür werden sie verwendet? <question>"
"Die Klasse ""Collection"" ist, wie gesagt, abstrakt. SMALLTALK sieht nun eine ganze Hierarchie von spezielleren, instanziierbaren (konkreten) Collection-Klassen vor, die für die unterschiedlichsten Zwecke eingesetzt werden können. Darunter sind so offensichtliche wie ""Set"" (für ungeordnete Collections, in denen jedes Element höchstens einmal vorkommen darf, also Mengen) und ""Bag"" (für solche, in denen die letzte Einschränkung aufgehoben ist). ""Set"" und ""Bag"" haben (neben der mangelnden Ordnung ihrer Elemente) gemeinsam, dass die Elemente in beiden nicht über einen Index zugreifbar sind. Im Gegensatz dazu stehen geordnete Collections (Klasse ""SequenceableCollection"" oder ""IndexedCollection"", je nach System), in denen das i-te Element eindeutig bestimmt ist und die entsprechend die Methoden ""at:"" und ""at:put:"" implementieren (genaugenommen überschreiben, denn diese Methoden sind ja für alle Objekte, die über indizierte Instanzvariablen verfügen, schon definiert und werden lediglich für ungeordnete Collections wieder gelöscht). Aber auch ungeordnete Collections (in denen keine Reihenfolge festgelegt ist) können indiziert sein: In Objekten der Klasse ""Dictionary"" wird jedes Element unter einem Schlüssel, der selbst wieder ein Objekt sein kann, gespeichert. Die dazugehörigen Methoden heißen wiederum ""at:"" und ""at:put:"", erlauben aber Objekte anderer Klassen als Integer als Indizes.","<answer> Die Gemeinsamkeit zwischen den Klassen ""Set"" und ""Bag"" besteht darin, dass beide ungeordnete Collections repräsentieren. In diesen Collections darf jedes Element höchstens einmal vorkommen. Sie unterscheiden sich jedoch darin, dass in einem Set die Elemente eindeutig sind und keine Duplikate enthalten, während in einer Bag Elemente mehrmals vorhanden sein können. <answer> <question> Welche Gemeinsamkeiten haben die Klassen ""Set"" und ""Bag"" in SMALLTALK? <question>"
"In :1-Beziehungen sendet man häufig Nachrichten an das Objekt, auf das die betreffende Variable verweist.
Wenn Sie dasselbe mit :n-Beziehungen tun möchten, erreicht die Nachricht – bei gleicher Vorgehensweise – nicht mehr die logisch in Beziehung stehenden Objekte, sondern das Zwischenobjekt, das die Beziehung selbst repräsentiert (das ja der Wert der Variable ist). Dieses Zwischenobjekt kann jedoch mit dieser Nachricht nichts anfangen. Um die Nachricht stattdessen an alle von diesem Zwischenobjekt referenzierten Objekte zu senden, verwendet man die Nachricht do: aBlock, wobei aBlock ein Block ist, der mit einem Parameter parametrisiert ist und der für jedes Element des Arrays genau einmal (mit dem Element als tatsächlichem Parameter) aufgerufen wird.
Man könnte sich fragen, warum die SMALLTALK-Syntax nicht erlaubt, die Nachricht direkt an das Zwischenobjekt zu senden, das die :n-Beziehung repräsentiert (zum Beispiel freunde einladen) und sie dann intern so umzusetzen, dass die Nachricht an alle Objekte gesendet wird. Der einfache Grund dafür wird sofort klar: Denn oft möchte man die Nachricht gar nicht an alle Objekte senden, sondern nur an ausgewählte, und es sind oft weitere Angaben erforderlich. Daher hätte ein solcher Ansatz im Allgemeinen keine Vorteile.
Basierend auf do: lassen sich nun zahlreiche weitere natürliche und äußerst praktische Steuerstrukturen erstellen. So ist es beispielsweise in vielen Fällen nicht erforderlich, die Nachricht an alle Elemente einer :n-Beziehung zu senden, sondern nur an solche, die bestimmte Kriterien erfüllen. Dazu kann man die Beziehung quasi ""unterwegs"" einschränken und den Block dann nur auf der eingeschränkten Menge ausführen:
Sie müssen Zeile 244 hier noch nicht vollständig verstehen; der Rest sollte Ihnen jedoch mittlerweile klar sein. answer ist eine temporäre Variable, die nur innerhalb der Methode Gültigkeit hat. In der Do-Schleife werden mit der Methode add: (eine Methode mit offensichtlicher Funktion) alle Elemente des Empfängers hinzugefügt, für die der Parameterblock aBlock zu true auswertet.
Auf ähnlich einfache Weise können nahezu beliebige weitere Steuerstrukturen implementiert werden. Als Ergänzung zu select: gibt es beispielsweise die Methode reject:, die aus einer :n-Beziehung alle Elemente entfernt, die eine angegebene Bedingung nicht erfüllen:
Es ist kaum zu glauben, wie einfach es ist, mit so wenig Aufwand eine neue Steuerstruktur hinzuzufügen.
Eine weitere nützliche Methode, die eine Sammlung von Objekten zurückgibt, über die dann (mittels do:) iteriert werden kann, ist collect:. Diese Methode sammelt alle Elemente, für die die Auswertung des ihr als Parameter übergebenen Blocks basierend auf den Elementen der ursprünglichen Sammlung Werte zurückgibt:
Aber Sie können auch einzelne Elemente einer Beziehung bestimmen. Zum Beispiel gibt detect: mit einem Block aBlock als Parameter das erste Element aus einer Sammlung von Elementen zurück, für das aBlock ausgewertet den Wahrheitswert true ergibt (wobei im Fehlen eines solchen Elements ein Fehler zurückgegeben wird). Dies ermöglicht es, Ausdrücke zu formulieren, die besagen, dass man sich mit dem ersten engen Freund, und nur mit diesem, trifft.","<answer> In :1-Beziehungen in SMALLTALK sendet man oft Nachrichten direkt an das Objekt, auf das die betreffende Variable verweist. Bei :n-Beziehungen erreicht die Nachricht jedoch nicht mehr die logisch in Beziehung stehenden Objekte, sondern das Zwischenobjekt, das die Beziehung selbst repräsentiert (der Wert der Variable). Um die Nachricht stattdessen an alle von diesem Zwischenobjekt referenzierten Objekte zu senden, verwendet man die Nachricht do: aBlock, wobei aBlock ein Block ist, der mit einem Parameter parametrisiert ist und der für jedes Element des Arrays genau einmal (mit dem Element als tatsächlichem Parameter) aufgerufen wird. <answer> <question> Wie sendet man Nachrichten an Objekte in :1-Beziehungen und :n-Beziehungen in SMALLTALK, und welche Methode wird für :n-Beziehungen verwendet? <question>"
"In :1-Beziehungen sendet man häufig Nachrichten an das Objekt, auf das die betreffende Variable verweist.
Wenn Sie dasselbe mit :n-Beziehungen tun möchten, erreicht die Nachricht – bei gleicher Vorgehensweise – nicht mehr die logisch in Beziehung stehenden Objekte, sondern das Zwischenobjekt, das die Beziehung selbst repräsentiert (das ja der Wert der Variable ist). Dieses Zwischenobjekt kann jedoch mit dieser Nachricht nichts anfangen. Um die Nachricht stattdessen an alle von diesem Zwischenobjekt referenzierten Objekte zu senden, verwendet man die Nachricht do: aBlock, wobei aBlock ein Block ist, der mit einem Parameter parametrisiert ist und der für jedes Element des Arrays genau einmal (mit dem Element als tatsächlichem Parameter) aufgerufen wird.
Man könnte sich fragen, warum die SMALLTALK-Syntax nicht erlaubt, die Nachricht direkt an das Zwischenobjekt zu senden, das die :n-Beziehung repräsentiert (zum Beispiel freunde einladen) und sie dann intern so umzusetzen, dass die Nachricht an alle Objekte gesendet wird. Der einfache Grund dafür wird sofort klar: Denn oft möchte man die Nachricht gar nicht an alle Objekte senden, sondern nur an ausgewählte, und es sind oft weitere Angaben erforderlich. Daher hätte ein solcher Ansatz im Allgemeinen keine Vorteile.
Basierend auf do: lassen sich nun zahlreiche weitere natürliche und äußerst praktische Steuerstrukturen erstellen. So ist es beispielsweise in vielen Fällen nicht erforderlich, die Nachricht an alle Elemente einer :n-Beziehung zu senden, sondern nur an solche, die bestimmte Kriterien erfüllen. Dazu kann man die Beziehung quasi ""unterwegs"" einschränken und den Block dann nur auf der eingeschränkten Menge ausführen:
Sie müssen Zeile 244 hier noch nicht vollständig verstehen; der Rest sollte Ihnen jedoch mittlerweile klar sein. answer ist eine temporäre Variable, die nur innerhalb der Methode Gültigkeit hat. In der Do-Schleife werden mit der Methode add: (eine Methode mit offensichtlicher Funktion) alle Elemente des Empfängers hinzugefügt, für die der Parameterblock aBlock zu true auswertet.
Auf ähnlich einfache Weise können nahezu beliebige weitere Steuerstrukturen implementiert werden. Als Ergänzung zu select: gibt es beispielsweise die Methode reject:, die aus einer :n-Beziehung alle Elemente entfernt, die eine angegebene Bedingung nicht erfüllen:
Es ist kaum zu glauben, wie einfach es ist, mit so wenig Aufwand eine neue Steuerstruktur hinzuzufügen.
Eine weitere nützliche Methode, die eine Sammlung von Objekten zurückgibt, über die dann (mittels do:) iteriert werden kann, ist collect:. Diese Methode sammelt alle Elemente, für die die Auswertung des ihr als Parameter übergebenen Blocks basierend auf den Elementen der ursprünglichen Sammlung Werte zurückgibt:
Aber Sie können auch einzelne Elemente einer Beziehung bestimmen. Zum Beispiel gibt detect: mit einem Block aBlock als Parameter das erste Element aus einer Sammlung von Elementen zurück, für das aBlock ausgewertet den Wahrheitswert true ergibt (wobei im Fehlen eines solchen Elements ein Fehler zurückgegeben wird). Dies ermöglicht es, Ausdrücke zu formulieren, die besagen, dass man sich mit dem ersten engen Freund, und nur mit diesem, trifft.","<answer> Der Grund, warum die SMALLTALK-Syntax nicht erlaubt, die Nachricht direkt an das Zwischenobjekt zu senden und sie dann intern umzusetzen, besteht darin, dass oft die Nachricht nicht an alle Objekte in der :n-Beziehung gesendet werden soll, sondern nur an bestimmte, und es können oft weitere Angaben erforderlich sein. Ein solcher Ansatz würde im Allgemeinen keine Vorteile bieten, da er nicht die erforderliche Flexibilität bieten würde. <answer> <question> Warum erlaubt die SMALLTALK-Syntax nicht, die Nachricht direkt an das Zwischenobjekt in :n-Beziehungen zu senden und sie intern so umzusetzen, dass sie an alle Objekte gesendet wird? <question>"
"Eine Sonderrolle unter den Beziehungen nimmt die sogenannte Teil-Ganzes-Beziehung ein, die je nach Kontext und Jargon auch als Komposition oder Aggregation bezeichnet wird. Teil-Ganzes-Beziehungen bestimmen ganz wesentlich unsere Weltsicht: Alles, was wir anfassen oder betrachten können, ist aus kleineren Teilen zusammengesetzt, die selbst wieder Zusammensetzungen (Aggregate, Komposita) sind, bis hinunter zu den elementaren, unteilbaren Bausteinen.
Leider ist der Begriff der Teil-Ganzes-Beziehung nicht so klar definiert, wie es auf den ersten Blick scheint. Tatsächlich bestehen, je nach Art der Zusammensetzung, zum Teil völlig unterschiedliche Wechselwirkungen zwischen dem Ganzen und seinen Teilen. Zudem gibt es neben der physischen Teil-Ganzes-Beziehung auch eine logische: So ist zum Beispiel der Deutsche Bundestag aus einer Anzahl von Abgeordneten zusammengesetzt, und jede Familie besteht aus ihren Mitgliedern. Tatsächlich gibt es so viele Varianten der Teil-Ganzes-Beziehung, dass der philosophische Diskurs darüber ganze Regale füllt und zu einer eigenen Disziplin geführt hat (die sogenannte Mereologie). Verständlicherweise kann dem eine Programmiersprache nicht folgen und für jede dieser Beziehungen ein eigenes Sprachkonstrukt anbieten.
Stattdessen bieten die meisten (objektorientierten) Programmiersprachen leider überhaupt kein Sprachkonstrukt an, das speziell für die Teil-Ganzes-Beziehung gedacht wäre. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden: Bei Wertsemantik wird mit der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt. Hier kann man tatsächlich von der Umsetzung einer bestimmten Form von Teil-Ganzes-Beziehung sprechen, nämlich einer solchen, bei der die Existenz der Teile von der Existenz des Ganzen abhängt (in der UML auch Komposition genannt). Für andere Formen, wie zum Beispiel die Bildung einer Gruppe von Objekten als Objekt mit eigener Identität (zum Beispiel ein Verein), ist dieses Modell jedoch nicht geeignet, da sonst mit der Auflösung der Gruppe auch die Gruppenmitglieder verschwinden würden. Für die SMALLTALK-Programmiererin sind diese Überlegungen jedoch kein Thema, denn sie hat die Wahl, diese spezielle Beziehung zu modellieren oder nicht.
Mit der Teil-Ganzes-Beziehung auf Programmebene werden wir uns in Kurseinheit 6 (genauer: Kapitel 58 und 59) noch ausführlicher beschäftigen. Hier sei nur schon so viel gesagt, dass die Möglichkeit des (rekursiven) Aufbaus eines Software-Systems aus Teilen, die jeweils ihren inneren Aufbau (ihre Komposition) kapseln und insbesondere die Nichtexistenz von Aliases auf ihre Teile garantieren, genau das ist, was der objektorientierten Programmierung im Wesentlichen bis heute fehlt.","<answer> Die Teil-Ganzes-Beziehung spielt eine besondere Rolle unter den Beziehungen und wird je nach Kontext auch als Komposition oder Aggregation bezeichnet. Sie ist von grundlegender Bedeutung für unsere Vorstellung davon, wie die Welt aufgebaut ist, da sie besagt, dass alles, was wir sehen oder berühren können, aus kleineren Teilen besteht, die wiederum aus noch kleineren Bausteinen zusammengesetzt sind. <answer> <question> Welche besondere Rolle nimmt die Teil-Ganzes-Beziehung in Bezug auf Beziehungen ein, und welche anderen Namen werden häufig verwendet, um sie zu beschreiben? <question>"
"Eine Sonderrolle unter den Beziehungen nimmt die sogenannte Teil-Ganzes-Beziehung ein, die je nach Kontext und Jargon auch als Komposition oder Aggregation bezeichnet wird. Teil-Ganzes-Beziehungen bestimmen ganz wesentlich unsere Weltsicht: Alles, was wir anfassen oder betrachten können, ist aus kleineren Teilen zusammengesetzt, die selbst wieder Zusammensetzungen (Aggregate, Komposita) sind, bis hinunter zu den elementaren, unteilbaren Bausteinen.
Leider ist der Begriff der Teil-Ganzes-Beziehung nicht so klar definiert, wie es auf den ersten Blick scheint. Tatsächlich bestehen, je nach Art der Zusammensetzung, zum Teil völlig unterschiedliche Wechselwirkungen zwischen dem Ganzen und seinen Teilen. Zudem gibt es neben der physischen Teil-Ganzes-Beziehung auch eine logische: So ist zum Beispiel der Deutsche Bundestag aus einer Anzahl von Abgeordneten zusammengesetzt, und jede Familie besteht aus ihren Mitgliedern. Tatsächlich gibt es so viele Varianten der Teil-Ganzes-Beziehung, dass der philosophische Diskurs darüber ganze Regale füllt und zu einer eigenen Disziplin geführt hat (die sogenannte Mereologie). Verständlicherweise kann dem eine Programmiersprache nicht folgen und für jede dieser Beziehungen ein eigenes Sprachkonstrukt anbieten.
Stattdessen bieten die meisten (objektorientierten) Programmiersprachen leider überhaupt kein Sprachkonstrukt an, das speziell für die Teil-Ganzes-Beziehung gedacht wäre. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden: Bei Wertsemantik wird mit der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt. Hier kann man tatsächlich von der Umsetzung einer bestimmten Form von Teil-Ganzes-Beziehung sprechen, nämlich einer solchen, bei der die Existenz der Teile von der Existenz des Ganzen abhängt (in der UML auch Komposition genannt). Für andere Formen, wie zum Beispiel die Bildung einer Gruppe von Objekten als Objekt mit eigener Identität (zum Beispiel ein Verein), ist dieses Modell jedoch nicht geeignet, da sonst mit der Auflösung der Gruppe auch die Gruppenmitglieder verschwinden würden. Für die SMALLTALK-Programmiererin sind diese Überlegungen jedoch kein Thema, denn sie hat die Wahl, diese spezielle Beziehung zu modellieren oder nicht.
Mit der Teil-Ganzes-Beziehung auf Programmebene werden wir uns in Kurseinheit 6 (genauer: Kapitel 58 und 59) noch ausführlicher beschäftigen. Hier sei nur schon so viel gesagt, dass die Möglichkeit des (rekursiven) Aufbaus eines Software-Systems aus Teilen, die jeweils ihren inneren Aufbau (ihre Komposition) kapseln und insbesondere die Nichtexistenz von Aliases auf ihre Teile garantieren, genau das ist, was der objektorientierten Programmierung im Wesentlichen bis heute fehlt.","<answer> Die Definition der Teil-Ganzes-Beziehung ist komplex, da es verschiedene Arten von Beziehungen zwischen einem Ganzen und seinen Teilen gibt, die je nach Art der Zusammensetzung unterschiedliche Wechselwirkungen aufweisen. Es existieren sowohl physische als auch logische Teil-Ganzes-Beziehungen, und diese Vielfalt macht es schwer, eine klare und einheitliche Definition zu finden. <answer> <question> Warum ist die Definition der Teil-Ganzes-Beziehung so komplex und vielschichtig? <question>"
"Eine Sonderrolle unter den Beziehungen nimmt die sogenannte Teil-Ganzes-Beziehung ein, die je nach Kontext und Jargon auch als Komposition oder Aggregation bezeichnet wird. Teil-Ganzes-Beziehungen bestimmen ganz wesentlich unsere Weltsicht: Alles, was wir anfassen oder betrachten können, ist aus kleineren Teilen zusammengesetzt, die selbst wieder Zusammensetzungen (Aggregate, Komposita) sind, bis hinunter zu den elementaren, unteilbaren Bausteinen.
Leider ist der Begriff der Teil-Ganzes-Beziehung nicht so klar definiert, wie es auf den ersten Blick scheint. Tatsächlich bestehen, je nach Art der Zusammensetzung, zum Teil völlig unterschiedliche Wechselwirkungen zwischen dem Ganzen und seinen Teilen. Zudem gibt es neben der physischen Teil-Ganzes-Beziehung auch eine logische: So ist zum Beispiel der Deutsche Bundestag aus einer Anzahl von Abgeordneten zusammengesetzt, und jede Familie besteht aus ihren Mitgliedern. Tatsächlich gibt es so viele Varianten der Teil-Ganzes-Beziehung, dass der philosophische Diskurs darüber ganze Regale füllt und zu einer eigenen Disziplin geführt hat (die sogenannte Mereologie). Verständlicherweise kann dem eine Programmiersprache nicht folgen und für jede dieser Beziehungen ein eigenes Sprachkonstrukt anbieten.
Stattdessen bieten die meisten (objektorientierten) Programmiersprachen leider überhaupt kein Sprachkonstrukt an, das speziell für die Teil-Ganzes-Beziehung gedacht wäre. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden: Bei Wertsemantik wird mit der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt. Hier kann man tatsächlich von der Umsetzung einer bestimmten Form von Teil-Ganzes-Beziehung sprechen, nämlich einer solchen, bei der die Existenz der Teile von der Existenz des Ganzen abhängt (in der UML auch Komposition genannt). Für andere Formen, wie zum Beispiel die Bildung einer Gruppe von Objekten als Objekt mit eigener Identität (zum Beispiel ein Verein), ist dieses Modell jedoch nicht geeignet, da sonst mit der Auflösung der Gruppe auch die Gruppenmitglieder verschwinden würden. Für die SMALLTALK-Programmiererin sind diese Überlegungen jedoch kein Thema, denn sie hat die Wahl, diese spezielle Beziehung zu modellieren oder nicht.
Mit der Teil-Ganzes-Beziehung auf Programmebene werden wir uns in Kurseinheit 6 (genauer: Kapitel 58 und 59) noch ausführlicher beschäftigen. Hier sei nur schon so viel gesagt, dass die Möglichkeit des (rekursiven) Aufbaus eines Software-Systems aus Teilen, die jeweils ihren inneren Aufbau (ihre Komposition) kapseln und insbesondere die Nichtexistenz von Aliases auf ihre Teile garantieren, genau das ist, was der objektorientierten Programmierung im Wesentlichen bis heute fehlt.","<answer> Die meisten objektorientierten Programmiersprachen bieten keine speziellen Sprachkonstrukte für die Teil-Ganzes-Beziehung. Stattdessen können Programmierer die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik nutzen, um eine bestimmte Form der Teil-Ganzes-Beziehung darzustellen. Bei Wertsemantik werden beim Entfernen eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt. <answer> <question> Wie gehen die meisten objektorientierten Programmiersprachen mit der Teil-Ganzes-Beziehung um? <question>"
"Eine Sonderrolle unter den Beziehungen nimmt die sogenannte Teil-Ganzes-Beziehung ein, die je nach Kontext und Jargon auch als Komposition oder Aggregation bezeichnet wird. Teil-Ganzes-Beziehungen bestimmen ganz wesentlich unsere Weltsicht: Alles, was wir anfassen oder betrachten können, ist aus kleineren Teilen zusammengesetzt, die selbst wieder Zusammensetzungen (Aggregate, Komposita) sind, bis hinunter zu den elementaren, unteilbaren Bausteinen.
Leider ist der Begriff der Teil-Ganzes-Beziehung nicht so klar definiert, wie es auf den ersten Blick scheint. Tatsächlich bestehen, je nach Art der Zusammensetzung, zum Teil völlig unterschiedliche Wechselwirkungen zwischen dem Ganzen und seinen Teilen. Zudem gibt es neben der physischen Teil-Ganzes-Beziehung auch eine logische: So ist zum Beispiel der Deutsche Bundestag aus einer Anzahl von Abgeordneten zusammengesetzt, und jede Familie besteht aus ihren Mitgliedern. Tatsächlich gibt es so viele Varianten der Teil-Ganzes-Beziehung, dass der philosophische Diskurs darüber ganze Regale füllt und zu einer eigenen Disziplin geführt hat (die sogenannte Mereologie). Verständlicherweise kann dem eine Programmiersprache nicht folgen und für jede dieser Beziehungen ein eigenes Sprachkonstrukt anbieten.
Stattdessen bieten die meisten (objektorientierten) Programmiersprachen leider überhaupt kein Sprachkonstrukt an, das speziell für die Teil-Ganzes-Beziehung gedacht wäre. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden: Bei Wertsemantik wird mit der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt. Hier kann man tatsächlich von der Umsetzung einer bestimmten Form von Teil-Ganzes-Beziehung sprechen, nämlich einer solchen, bei der die Existenz der Teile von der Existenz des Ganzen abhängt (in der UML auch Komposition genannt). Für andere Formen, wie zum Beispiel die Bildung einer Gruppe von Objekten als Objekt mit eigener Identität (zum Beispiel ein Verein), ist dieses Modell jedoch nicht geeignet, da sonst mit der Auflösung der Gruppe auch die Gruppenmitglieder verschwinden würden. Für die SMALLTALK-Programmiererin sind diese Überlegungen jedoch kein Thema, denn sie hat die Wahl, diese spezielle Beziehung zu modellieren oder nicht.
Mit der Teil-Ganzes-Beziehung auf Programmebene werden wir uns in Kurseinheit 6 (genauer: Kapitel 58 und 59) noch ausführlicher beschäftigen. Hier sei nur schon so viel gesagt, dass die Möglichkeit des (rekursiven) Aufbaus eines Software-Systems aus Teilen, die jeweils ihren inneren Aufbau (ihre Komposition) kapseln und insbesondere die Nichtexistenz von Aliases auf ihre Teile garantieren, genau das ist, was der objektorientierten Programmierung im Wesentlichen bis heute fehlt.","<answer> Die Teil-Ganzes-Beziehung ist in der objektorientierten Programmierung wichtig, da sie es ermöglicht, komplexe Software-Systeme aus Teilen aufzubauen, wobei jeder Teil seine eigene interne Struktur kapselt. Dies hilft dabei, sicherzustellen, dass keine Aliasnamen für Teile existieren und Änderungen an einem Teil nicht unabsichtlich andere Teile beeinflussen. Dieses Konzept ist entscheidend für die Entwicklung komplexer und intakter Software-Systeme. <answer> <question> Warum ist die Teil-Ganzes-Beziehung in der objektorientierten Programmierung von Bedeutung? <question>"
"Wie bereits in den Abschnitten 4.3.2 und 4.5.2 in Kurseinheit 1 angerissen, verbirgt sich hinter dem Nachrichtenversand ein dynamisch gebundener Methodenaufruf. Dabei ist die Auswahl der Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt abhängig. In Abschnitt 11.2 hatten wir bereits angedeutet, wie in Superklassen definierte Methoden für ihre Subklassen zugreifbar sind; hier schauen wir uns nun etwas genauer an, wie die dynamische Bindung von Methodenaufrufen vonstatten geht.
Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Dies kann man auch selbst tun: Es gibt dafür in der Klasse Behavior eine Instanzmethode oder so ähnlich (je nach System), die somit allen Klassen (als Klassenmethode) zur Verfügung steht. (Behavior ist ja eine Superklasse von Class, die wiederum Superklasse aller Metaklassen ist, von denen jede Klasse eine Instanz ist, so dass alle Klassen die Methode includesSelector: verstehen.)
Wird die Methode gefunden, dann wird sie ausgeführt. Wird sie nicht gefunden, wird zunächst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum bereits erwähnten Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument.
Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Methode einer Superklasse des Empfängerobjekts ausgeführt wird, das Objekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilierung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden — handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch Instanz seiner Klasse ist. Die gerade ausgeführte Methode betrachtet es lediglich wie ein Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die Bedeutung der Pseudovariable super, wie wir noch sehen werden.
Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, aus Effizienzgründen direkt in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im Wesentlichen äquivalent zu der der Methode canUnderstand:, die genau wie includesSelector: in der Klasse Behavior definiert ist.
Man beachte übrigens, wie wenig Aufwand es ist, aus dem klassenbasierten Methoden-Lookup einen objektbasierten zu machen: Man muss dazu lediglich jedem einzelnen Objekt sein eigenes Methodenwörterbuch zur Verfügung stellen. Wenn man zusätzlich noch Objekte von Objekten anstelle von Klassen von Klassen erben lässt, dann hat man schon die prototypenbasierte Form der objektorientierten Programmierung. Der Unterschied ist also technisch nicht besonders groß — konzeptuell hingegen schon, denn mit den Klassen entfielen auch die sonst so nützlichen Begriffe von Generalisierung und Spezialisierung (von der Generalisierung von Objekten zu sprechen erscheint wenig sinnvoll).
Eines der immer wieder vorgetragenen Hauptargumente gegen den Einsatz von SMALLTALK in der kommerziellen Programmierung ist der Umstand, dass das dynamische Binden wirklich vollkommen dynamisch ist: Dass einem Objekt eine Nachricht geschickt wird, die es nicht versteht, tritt immer erst zur Laufzeit zutage (s. Verhältnis von Abschnitt 10.3 und 11.3).41 In den statisch typgeprüften Sprachen, die wir in den nächsten Kurseinheiten kennenlernen werden, ist das charakteristischerweise nicht so. Dem kann man entgegenhalten, dass die heutigen (auch) statisch typgeprüften Programmiersprachen wie JAVA, C# oder C++ sämtliche nicht ohne dynamische Typumwandlungen auskommen, die ebenfalls zu Laufzeitfehlern führen können. Tatsächlich ist es sowohl in SMALLTALK als auch in JAVA und C# (in C++ nur mit Einschränkungen; s. Abschnitt 51.5) nicht nur möglich, sondern sogar geboten, Laufzeitfehler da, wo möglich, zu vermeiden, indem man vor einem Methodenaufruf explizit prüft, ob ein Objekt die gewünschte Methode auch hat — in SMALLTALK mittels canUnderstand:, in JAVA et al. mittels eines entsprechenden Typtests vor einem Downcast. Die größere Flexibilität, die die objektorientierte Programmierung durch das dynamische Binden bietet, hat eben den Preis, dass bestimmte Laufzeitprüfungen durchgeführt werden müssen. Statische Typprüfung kann das Risiko von Typfehlern verringern, aber nicht ausschließen — gleichzeitig schränkt es die Flexibilität beim Programmieren ein, ein Umstand, der so manchen, der schon einmal größere Programme in SMALLTALK geschrieben hat, an der Verwendung typgeprüfter Sprachen stört.","<answer> Beim dynamischen Binden von Methodenaufrufen in SMALLTALK hängt die Auswahl der auszuführenden Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt ab. Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zuerst überprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Wenn die Methode gefunden wird, wird sie ausgeführt. Andernfalls wird in der direkten Superklasse der Klasse des Objekts gesucht, und so weiter, bis die Methode gefunden wird oder ein Laufzeitfehler auftritt. <answer> <question> Was versteht man unter dynamischem Binden von Methodenaufrufen in SMALLTALK? <question>"
"Wie bereits in den Abschnitten 4.3.2 und 4.5.2 in Kurseinheit 1 angerissen, verbirgt sich hinter dem Nachrichtenversand ein dynamisch gebundener Methodenaufruf. Dabei ist die Auswahl der Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt abhängig. In Abschnitt 11.2 hatten wir bereits angedeutet, wie in Superklassen definierte Methoden für ihre Subklassen zugreifbar sind; hier schauen wir uns nun etwas genauer an, wie die dynamische Bindung von Methodenaufrufen vonstatten geht.
Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Dies kann man auch selbst tun: Es gibt dafür in der Klasse Behavior eine Instanzmethode oder so ähnlich (je nach System), die somit allen Klassen (als Klassenmethode) zur Verfügung steht. (Behavior ist ja eine Superklasse von Class, die wiederum Superklasse aller Metaklassen ist, von denen jede Klasse eine Instanz ist, so dass alle Klassen die Methode includesSelector: verstehen.)
Wird die Methode gefunden, dann wird sie ausgeführt. Wird sie nicht gefunden, wird zunächst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum bereits erwähnten Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument.
Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Methode einer Superklasse des Empfängerobjekts ausgeführt wird, das Objekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilierung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden — handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch Instanz seiner Klasse ist. Die gerade ausgeführte Methode betrachtet es lediglich wie ein Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die Bedeutung der Pseudovariable super, wie wir noch sehen werden.
Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, aus Effizienzgründen direkt in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im Wesentlichen äquivalent zu der der Methode canUnderstand:, die genau wie includesSelector: in der Klasse Behavior definiert ist.
Man beachte übrigens, wie wenig Aufwand es ist, aus dem klassenbasierten Methoden-Lookup einen objektbasierten zu machen: Man muss dazu lediglich jedem einzelnen Objekt sein eigenes Methodenwörterbuch zur Verfügung stellen. Wenn man zusätzlich noch Objekte von Objekten anstelle von Klassen von Klassen erben lässt, dann hat man schon die prototypenbasierte Form der objektorientierten Programmierung. Der Unterschied ist also technisch nicht besonders groß — konzeptuell hingegen schon, denn mit den Klassen entfielen auch die sonst so nützlichen Begriffe von Generalisierung und Spezialisierung (von der Generalisierung von Objekten zu sprechen erscheint wenig sinnvoll).
Eines der immer wieder vorgetragenen Hauptargumente gegen den Einsatz von SMALLTALK in der kommerziellen Programmierung ist der Umstand, dass das dynamische Binden wirklich vollkommen dynamisch ist: Dass einem Objekt eine Nachricht geschickt wird, die es nicht versteht, tritt immer erst zur Laufzeit zutage (s. Verhältnis von Abschnitt 10.3 und 11.3).41 In den statisch typgeprüften Sprachen, die wir in den nächsten Kurseinheiten kennenlernen werden, ist das charakteristischerweise nicht so. Dem kann man entgegenhalten, dass die heutigen (auch) statisch typgeprüften Programmiersprachen wie JAVA, C# oder C++ sämtliche nicht ohne dynamische Typumwandlungen auskommen, die ebenfalls zu Laufzeitfehlern führen können. Tatsächlich ist es sowohl in SMALLTALK als auch in JAVA und C# (in C++ nur mit Einschränkungen; s. Abschnitt 51.5) nicht nur möglich, sondern sogar geboten, Laufzeitfehler da, wo möglich, zu vermeiden, indem man vor einem Methodenaufruf explizit prüft, ob ein Objekt die gewünschte Methode auch hat — in SMALLTALK mittels canUnderstand:, in JAVA et al. mittels eines entsprechenden Typtests vor einem Downcast. Die größere Flexibilität, die die objektorientierte Programmierung durch das dynamische Binden bietet, hat eben den Preis, dass bestimmte Laufzeitprüfungen durchgeführt werden müssen. Statische Typprüfung kann das Risiko von Typfehlern verringern, aber nicht ausschließen — gleichzeitig schränkt es die Flexibilität beim Programmieren ein, ein Umstand, der so manchen, der schon einmal größere Programme in SMALLTALK geschrieben hat, an der Verwendung typgeprüfter Sprachen stört.","<answer> Bei der Suche nach einer Methode wird zunächst im Methodenwörterbuch der Klasse des Empfängers nachgeschlagen. Wenn die Methode dort nicht gefunden wird, wird in der direkten Superklasse der Klasse des Objekts gesucht, und dieser Prozess setzt sich fort, bis die Methode gefunden wird oder bis zur Klasse ""Object"". Sobald die Methode gefunden wird, wird sie ausgeführt. Falls die Methode auch in ""Object"" nicht gefunden wird, wird die Nachricht ""doesNotUnderstand:"" an den ursprünglichen Empfänger mit der ursprünglichen Nachricht als Argument gesendet. <answer> <question> Wie funktioniert die Suche nach einer Methode in SMALLTALK? <question>"
"Wie bereits in den Abschnitten 4.3.2 und 4.5.2 in Kurseinheit 1 angerissen, verbirgt sich hinter dem Nachrichtenversand ein dynamisch gebundener Methodenaufruf. Dabei ist die Auswahl der Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt abhängig. In Abschnitt 11.2 hatten wir bereits angedeutet, wie in Superklassen definierte Methoden für ihre Subklassen zugreifbar sind; hier schauen wir uns nun etwas genauer an, wie die dynamische Bindung von Methodenaufrufen vonstatten geht.
Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Dies kann man auch selbst tun: Es gibt dafür in der Klasse Behavior eine Instanzmethode oder so ähnlich (je nach System), die somit allen Klassen (als Klassenmethode) zur Verfügung steht. (Behavior ist ja eine Superklasse von Class, die wiederum Superklasse aller Metaklassen ist, von denen jede Klasse eine Instanz ist, so dass alle Klassen die Methode includesSelector: verstehen.)
Wird die Methode gefunden, dann wird sie ausgeführt. Wird sie nicht gefunden, wird zunächst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum bereits erwähnten Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument.
Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Methode einer Superklasse des Empfängerobjekts ausgeführt wird, das Objekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilierung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden — handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch Instanz seiner Klasse ist. Die gerade ausgeführte Methode betrachtet es lediglich wie ein Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die Bedeutung der Pseudovariable super, wie wir noch sehen werden.
Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, aus Effizienzgründen direkt in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im Wesentlichen äquivalent zu der der Methode canUnderstand:, die genau wie includesSelector: in der Klasse Behavior definiert ist.
Man beachte übrigens, wie wenig Aufwand es ist, aus dem klassenbasierten Methoden-Lookup einen objektbasierten zu machen: Man muss dazu lediglich jedem einzelnen Objekt sein eigenes Methodenwörterbuch zur Verfügung stellen. Wenn man zusätzlich noch Objekte von Objekten anstelle von Klassen von Klassen erben lässt, dann hat man schon die prototypenbasierte Form der objektorientierten Programmierung. Der Unterschied ist also technisch nicht besonders groß — konzeptuell hingegen schon, denn mit den Klassen entfielen auch die sonst so nützlichen Begriffe von Generalisierung und Spezialisierung (von der Generalisierung von Objekten zu sprechen erscheint wenig sinnvoll).
Eines der immer wieder vorgetragenen Hauptargumente gegen den Einsatz von SMALLTALK in der kommerziellen Programmierung ist der Umstand, dass das dynamische Binden wirklich vollkommen dynamisch ist: Dass einem Objekt eine Nachricht geschickt wird, die es nicht versteht, tritt immer erst zur Laufzeit zutage (s. Verhältnis von Abschnitt 10.3 und 11.3).41 In den statisch typgeprüften Sprachen, die wir in den nächsten Kurseinheiten kennenlernen werden, ist das charakteristischerweise nicht so. Dem kann man entgegenhalten, dass die heutigen (auch) statisch typgeprüften Programmiersprachen wie JAVA, C# oder C++ sämtliche nicht ohne dynamische Typumwandlungen auskommen, die ebenfalls zu Laufzeitfehlern führen können. Tatsächlich ist es sowohl in SMALLTALK als auch in JAVA und C# (in C++ nur mit Einschränkungen; s. Abschnitt 51.5) nicht nur möglich, sondern sogar geboten, Laufzeitfehler da, wo möglich, zu vermeiden, indem man vor einem Methodenaufruf explizit prüft, ob ein Objekt die gewünschte Methode auch hat — in SMALLTALK mittels canUnderstand:, in JAVA et al. mittels eines entsprechenden Typtests vor einem Downcast. Die größere Flexibilität, die die objektorientierte Programmierung durch das dynamische Binden bietet, hat eben den Preis, dass bestimmte Laufzeitprüfungen durchgeführt werden müssen. Statische Typprüfung kann das Risiko von Typfehlern verringern, aber nicht ausschließen — gleichzeitig schränkt es die Flexibilität beim Programmieren ein, ein Umstand, der so manchen, der schon einmal größere Programme in SMALLTALK geschrieben hat, an der Verwendung typgeprüfter Sprachen stört.","<answer> Obwohl bei der Ausführung einer Methode aus einer Superklasse die Methode in einer Superklasse kompiliert wurde, bleibt das Objekt, auf dem sie ausgeführt wird, dasselbe Empfängerobjekt. Dies bedeutet, dass das Objekt immer noch Instanz seiner ursprünglichen Klasse ist. Die Methode betrachtet es jedoch wie ein Objekt der Klasse, in der sie selbst definiert ist. Dies ermöglicht den Zugriff auf die Instanzvariablen, die für die Objekte dieser Klasse zugreifbar sind. <answer> <question> Warum bleibt das Empfängerobjekt bei der Ausführung einer Methode aus einer Superklasse dasselbe? <question>"
"Wie bereits in den Abschnitten 4.3.2 und 4.5.2 in Kurseinheit 1 angerissen, verbirgt sich hinter dem Nachrichtenversand ein dynamisch gebundener Methodenaufruf. Dabei ist die Auswahl der Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt abhängig. In Abschnitt 11.2 hatten wir bereits angedeutet, wie in Superklassen definierte Methoden für ihre Subklassen zugreifbar sind; hier schauen wir uns nun etwas genauer an, wie die dynamische Bindung von Methodenaufrufen vonstatten geht.
Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Dies kann man auch selbst tun: Es gibt dafür in der Klasse Behavior eine Instanzmethode oder so ähnlich (je nach System), die somit allen Klassen (als Klassenmethode) zur Verfügung steht. (Behavior ist ja eine Superklasse von Class, die wiederum Superklasse aller Metaklassen ist, von denen jede Klasse eine Instanz ist, so dass alle Klassen die Methode includesSelector: verstehen.)
Wird die Methode gefunden, dann wird sie ausgeführt. Wird sie nicht gefunden, wird zunächst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum bereits erwähnten Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument.
Man beachte, dass selbst wenn auf den Empfang einer Nachricht die Methode einer Superklasse des Empfängerobjekts ausgeführt wird, das Objekt, auf dem sie ausgeführt wird, das Empfängerobjekt bleibt. Da die Methode jedoch in einer Superklasse kompiliert wurde (und zum Zeitpunkt der Kompilierung die Subklassen u. U. noch gar nicht existierten), kann die Methode nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar. Gleichwohl — und das wird häufig nicht verstanden — handelt es sich immer noch um das ursprüngliche Empfängerobjekt, das auch immer noch Instanz seiner Klasse ist. Die gerade ausgeführte Methode betrachtet es lediglich wie ein Objekt der Klasse, in der sie (die Methode) definiert ist. Dies hat auch Auswirkungen auf die Bedeutung der Pseudovariable super, wie wir noch sehen werden.
Der Suchalgorithmus ist, genau wie der Methodenaufruf selbst, aus Effizienzgründen direkt in der virtuellen Maschine implementiert. Die Implementierung ist jedoch im Wesentlichen äquivalent zu der der Methode canUnderstand:, die genau wie includesSelector: in der Klasse Behavior definiert ist.
Man beachte übrigens, wie wenig Aufwand es ist, aus dem klassenbasierten Methoden-Lookup einen objektbasierten zu machen: Man muss dazu lediglich jedem einzelnen Objekt sein eigenes Methodenwörterbuch zur Verfügung stellen. Wenn man zusätzlich noch Objekte von Objekten anstelle von Klassen von Klassen erben lässt, dann hat man schon die prototypenbasierte Form der objektorientierten Programmierung. Der Unterschied ist also technisch nicht besonders groß — konzeptuell hingegen schon, denn mit den Klassen entfielen auch die sonst so nützlichen Begriffe von Generalisierung und Spezialisierung (von der Generalisierung von Objekten zu sprechen erscheint wenig sinnvoll).
Eines der immer wieder vorgetragenen Hauptargumente gegen den Einsatz von SMALLTALK in der kommerziellen Programmierung ist der Umstand, dass das dynamische Binden wirklich vollkommen dynamisch ist: Dass einem Objekt eine Nachricht geschickt wird, die es nicht versteht, tritt immer erst zur Laufzeit zutage (s. Verhältnis von Abschnitt 10.3 und 11.3).41 In den statisch typgeprüften Sprachen, die wir in den nächsten Kurseinheiten kennenlernen werden, ist das charakteristischerweise nicht so. Dem kann man entgegenhalten, dass die heutigen (auch) statisch typgeprüften Programmiersprachen wie JAVA, C# oder C++ sämtliche nicht ohne dynamische Typumwandlungen auskommen, die ebenfalls zu Laufzeitfehlern führen können. Tatsächlich ist es sowohl in SMALLTALK als auch in JAVA und C# (in C++ nur mit Einschränkungen; s. Abschnitt 51.5) nicht nur möglich, sondern sogar geboten, Laufzeitfehler da, wo möglich, zu vermeiden, indem man vor einem Methodenaufruf explizit prüft, ob ein Objekt die gewünschte Methode auch hat — in SMALLTALK mittels canUnderstand:, in JAVA et al. mittels eines entsprechenden Typtests vor einem Downcast. Die größere Flexibilität, die die objektorientierte Programmierung durch das dynamische Binden bietet, hat eben den Preis, dass bestimmte Laufzeitprüfungen durchgeführt werden müssen. Statische Typprüfung kann das Risiko von Typfehlern verringern, aber nicht ausschließen — gleichzeitig schränkt es die Flexibilität beim Programmieren ein, ein Umstand, der so manchen, der schon einmal größere Programme in SMALLTALK geschrieben hat, an der Verwendung typgeprüfter Sprachen stört.","<answer> In der dynamischen Bindung, wie sie in SMALLTALK verwendet wird, erfolgt die Auswahl der Methode zur Laufzeit und hängt von der Art des Empfängerobjekts ab. In der statischen Typisierung, wie sie in statisch typgeprüften Sprachen wie JAVA, C# und C++ verwendet wird, erfolgt die Typüberprüfung zur Übersetzungszeit und nicht zur Laufzeit. Statisch typisierte Sprachen erfordern in der Regel, dass der Programmierer den Datentyp der Objekte und deren Methoden im Voraus festlegt, während dynamisch typisierte Sprachen mehr Flexibilität bieten, da die Typüberprüfung erst zur Laufzeit erfolgt. Allerdings erhöht die dynamische Bindung das Risiko von Laufzeitfehlern, die in statisch typisierten Sprachen vermieden werden können, indem explizite Typüberprüfungen durchgeführt werden. <answer> <question> Was ist der Unterschied zwischen dynamischer und statischer Typisierung in Bezug auf das dynamische Binden? <question>"
"Die Regeln des Subtypings aus Kapitel 26 und die damit verbundene Regelung der Zuweisungskompatibilität bezogen sich lediglich auf die Elemente einer Typdeklaration und somit auf rein statische Informationen. Um nun auch das Verhalten der Objekte eines Typs zu berücksichtigen, greift man auf eine Idee aus der formalen Programmverifikation zurück, nämlich die Überführung von Vorbedingungen in Nachbedingungen, ähnlich wie in (54.1).
Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methodenausführung, verletzt werden).
Damit meinen wir, dass für eine Implementierung von m in der zugehörigen Klasse von T, die auf einem Empfängerobjekt vom Typ T (einer Instanz der entsprechenden Klasse) aufgerufen wird, die Nachbedingung aus der Vorbedingung folgt. Wir müssen diesen Beweis jedoch nicht führen, da unser Interesse hier nicht auf der Korrektheit der Implementierungen an sich liegt, sondern vielmehr daran, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird und es durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Mehr dazu in Abschnitt 54.5.
Uns interessiert, ob eine umfassende Substituierung möglich ist. Konkret: Wir möchten eine verhaltensbasierte Subtypenrelation betrachten, das heißt, wir möchten die Bedingungen verstehen, die potenzielle Subtypen erfüllen müssen, damit sie die Spezifikation des Supertyps erfüllen und als verhaltenskonform betrachtet werden können. Dabei handelt es sich um eine Subtypenbeziehung, wie sie in Kapitel 26 beschrieben wird. Dies ist dann der Fall, wenn die obige Implikation auch für Objekte des potenziellen Subtypen S gilt.
Man spricht dann von einem Behavior Subtyping, was am besten als verhaltensbasiertes Subtyping wiedergegeben wird.
Wir müssen also sicherstellen, dass (6.3) erfüllt ist. Bei der Spezifikation der Methoden des (potenziellen Sub-)Typs S werden wir zunächst nicht auf die Vor- und Nachbedingungen von T zurückgreifen, sondern unsere eigenen definieren. Dies ist jedoch im Allgemeinen nicht der Fall. Die Frage lautet also: Wie müssen 𝑝𝑟𝑒𝑚S, 𝑝𝑟𝑒𝑚T, 𝑝𝑜𝑠𝑡𝑚S und 𝑝𝑜𝑠𝑡𝑚T miteinander in Beziehung stehen, damit Objekte vom Typ S die Anforderungen für Objekte vom Typ T erfüllen? Formal ausgedrückt: Was müssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), dem Verhalten von m in T angewandt auf Objekte aus S, folgt?
Leider reicht es nicht aus, diese Frage zu beantworten. Aufgrund des weit verbreiteten Aliasings in der objektorientierten Programmierung kann ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel. Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht also nicht aus. Man kann bereits erahnen, dass diese Angelegenheit komplex wird.","<answer> Die Idee aus der formalen Programmverifikation besteht darin, Vorbedingungen in Nachbedingungen zu überführen, um das Verhalten von Objekten eines Typs zu berücksichtigen. Dies wird verwendet, um sicherzustellen, dass die Implementierung eines Typs korrekt ist und dass aus Vorbedingungen die entsprechenden Nachbedingungen folgen. <answer> <question> Welche Idee aus der formalen Programmverifikation wird verwendet, um das Verhalten von Objekten in der Subtypenbeziehung zu berücksichtigen? <question>"
"Die Regeln des Subtypings aus Kapitel 26 und die damit verbundene Regelung der Zuweisungskompatibilität bezogen sich lediglich auf die Elemente einer Typdeklaration und somit auf rein statische Informationen. Um nun auch das Verhalten der Objekte eines Typs zu berücksichtigen, greift man auf eine Idee aus der formalen Programmverifikation zurück, nämlich die Überführung von Vorbedingungen in Nachbedingungen, ähnlich wie in (54.1).
Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methodenausführung, verletzt werden).
Damit meinen wir, dass für eine Implementierung von m in der zugehörigen Klasse von T, die auf einem Empfängerobjekt vom Typ T (einer Instanz der entsprechenden Klasse) aufgerufen wird, die Nachbedingung aus der Vorbedingung folgt. Wir müssen diesen Beweis jedoch nicht führen, da unser Interesse hier nicht auf der Korrektheit der Implementierungen an sich liegt, sondern vielmehr daran, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird und es durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Mehr dazu in Abschnitt 54.5.
Uns interessiert, ob eine umfassende Substituierung möglich ist. Konkret: Wir möchten eine verhaltensbasierte Subtypenrelation betrachten, das heißt, wir möchten die Bedingungen verstehen, die potenzielle Subtypen erfüllen müssen, damit sie die Spezifikation des Supertyps erfüllen und als verhaltenskonform betrachtet werden können. Dabei handelt es sich um eine Subtypenbeziehung, wie sie in Kapitel 26 beschrieben wird. Dies ist dann der Fall, wenn die obige Implikation auch für Objekte des potenziellen Subtypen S gilt.
Man spricht dann von einem Behavior Subtyping, was am besten als verhaltensbasiertes Subtyping wiedergegeben wird.
Wir müssen also sicherstellen, dass (6.3) erfüllt ist. Bei der Spezifikation der Methoden des (potenziellen Sub-)Typs S werden wir zunächst nicht auf die Vor- und Nachbedingungen von T zurückgreifen, sondern unsere eigenen definieren. Dies ist jedoch im Allgemeinen nicht der Fall. Die Frage lautet also: Wie müssen 𝑝𝑟𝑒𝑚S, 𝑝𝑟𝑒𝑚T, 𝑝𝑜𝑠𝑡𝑚S und 𝑝𝑜𝑠𝑡𝑚T miteinander in Beziehung stehen, damit Objekte vom Typ S die Anforderungen für Objekte vom Typ T erfüllen? Formal ausgedrückt: Was müssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), dem Verhalten von m in T angewandt auf Objekte aus S, folgt?
Leider reicht es nicht aus, diese Frage zu beantworten. Aufgrund des weit verbreiteten Aliasings in der objektorientierten Programmierung kann ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel. Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht also nicht aus. Man kann bereits erahnen, dass diese Angelegenheit komplex wird.","<answer> ""Verhaltensbasiertes Subtyping"" oder ""Behavior Subtyping"" bezieht sich auf eine Subtypenbeziehung, bei der die Bedingungen erfüllt sein müssen, damit die Spezifikation des Subtyps die des Supertyps erfüllt und als verhaltenskonform betrachtet werden kann. Dies bedeutet, dass das Verhalten der Objekte des Subtyps mit dem Verhalten des Supertyps übereinstimmen muss. <answer> <question> Was bedeutet ""verhaltensbasiertes Subtyping"" oder ""Behavior Subtyping""? <question>"
"Die Regeln des Subtypings aus Kapitel 26 und die damit verbundene Regelung der Zuweisungskompatibilität bezogen sich lediglich auf die Elemente einer Typdeklaration und somit auf rein statische Informationen. Um nun auch das Verhalten der Objekte eines Typs zu berücksichtigen, greift man auf eine Idee aus der formalen Programmverifikation zurück, nämlich die Überführung von Vorbedingungen in Nachbedingungen, ähnlich wie in (54.1).
Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methodenausführung, verletzt werden).
Damit meinen wir, dass für eine Implementierung von m in der zugehörigen Klasse von T, die auf einem Empfängerobjekt vom Typ T (einer Instanz der entsprechenden Klasse) aufgerufen wird, die Nachbedingung aus der Vorbedingung folgt. Wir müssen diesen Beweis jedoch nicht führen, da unser Interesse hier nicht auf der Korrektheit der Implementierungen an sich liegt, sondern vielmehr daran, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird und es durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Mehr dazu in Abschnitt 54.5.
Uns interessiert, ob eine umfassende Substituierung möglich ist. Konkret: Wir möchten eine verhaltensbasierte Subtypenrelation betrachten, das heißt, wir möchten die Bedingungen verstehen, die potenzielle Subtypen erfüllen müssen, damit sie die Spezifikation des Supertyps erfüllen und als verhaltenskonform betrachtet werden können. Dabei handelt es sich um eine Subtypenbeziehung, wie sie in Kapitel 26 beschrieben wird. Dies ist dann der Fall, wenn die obige Implikation auch für Objekte des potenziellen Subtypen S gilt.
Man spricht dann von einem Behavior Subtyping, was am besten als verhaltensbasiertes Subtyping wiedergegeben wird.
Wir müssen also sicherstellen, dass (6.3) erfüllt ist. Bei der Spezifikation der Methoden des (potenziellen Sub-)Typs S werden wir zunächst nicht auf die Vor- und Nachbedingungen von T zurückgreifen, sondern unsere eigenen definieren. Dies ist jedoch im Allgemeinen nicht der Fall. Die Frage lautet also: Wie müssen 𝑝𝑟𝑒𝑚S, 𝑝𝑟𝑒𝑚T, 𝑝𝑜𝑠𝑡𝑚S und 𝑝𝑜𝑠𝑡𝑚T miteinander in Beziehung stehen, damit Objekte vom Typ S die Anforderungen für Objekte vom Typ T erfüllen? Formal ausgedrückt: Was müssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), dem Verhalten von m in T angewandt auf Objekte aus S, folgt?
Leider reicht es nicht aus, diese Frage zu beantworten. Aufgrund des weit verbreiteten Aliasings in der objektorientierten Programmierung kann ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel. Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht also nicht aus. Man kann bereits erahnen, dass diese Angelegenheit komplex wird.","<answer> Es können Probleme auftreten, wenn Objekte vom Typ S von einem Klienten als Typ T betrachtet werden, da dies zu Aliasen führen kann, bei denen das Objekt von verschiedenen Klienten unterschiedliche Typen hat. Dies kann dazu führen, dass Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und kann für Benutzer, die das Objekt als T betrachten, nicht akzeptabel sein. <answer> <question> Warum kann es zu Problemen kommen, wenn Objekte vom Typ S von einem Klienten als Typ T betrachtet werden? <question>"
"Die Regeln des Subtypings aus Kapitel 26 und die damit verbundene Regelung der Zuweisungskompatibilität bezogen sich lediglich auf die Elemente einer Typdeklaration und somit auf rein statische Informationen. Um nun auch das Verhalten der Objekte eines Typs zu berücksichtigen, greift man auf eine Idee aus der formalen Programmverifikation zurück, nämlich die Überführung von Vorbedingungen in Nachbedingungen, ähnlich wie in (54.1).
Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methodenausführung, verletzt werden).
Damit meinen wir, dass für eine Implementierung von m in der zugehörigen Klasse von T, die auf einem Empfängerobjekt vom Typ T (einer Instanz der entsprechenden Klasse) aufgerufen wird, die Nachbedingung aus der Vorbedingung folgt. Wir müssen diesen Beweis jedoch nicht führen, da unser Interesse hier nicht auf der Korrektheit der Implementierungen an sich liegt, sondern vielmehr daran, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird und es durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Mehr dazu in Abschnitt 54.5.
Uns interessiert, ob eine umfassende Substituierung möglich ist. Konkret: Wir möchten eine verhaltensbasierte Subtypenrelation betrachten, das heißt, wir möchten die Bedingungen verstehen, die potenzielle Subtypen erfüllen müssen, damit sie die Spezifikation des Supertyps erfüllen und als verhaltenskonform betrachtet werden können. Dabei handelt es sich um eine Subtypenbeziehung, wie sie in Kapitel 26 beschrieben wird. Dies ist dann der Fall, wenn die obige Implikation auch für Objekte des potenziellen Subtypen S gilt.
Man spricht dann von einem Behavior Subtyping, was am besten als verhaltensbasiertes Subtyping wiedergegeben wird.
Wir müssen also sicherstellen, dass (6.3) erfüllt ist. Bei der Spezifikation der Methoden des (potenziellen Sub-)Typs S werden wir zunächst nicht auf die Vor- und Nachbedingungen von T zurückgreifen, sondern unsere eigenen definieren. Dies ist jedoch im Allgemeinen nicht der Fall. Die Frage lautet also: Wie müssen 𝑝𝑟𝑒𝑚S, 𝑝𝑟𝑒𝑚T, 𝑝𝑜𝑠𝑡𝑚S und 𝑝𝑜𝑠𝑡𝑚T miteinander in Beziehung stehen, damit Objekte vom Typ S die Anforderungen für Objekte vom Typ T erfüllen? Formal ausgedrückt: Was müssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), dem Verhalten von m in T angewandt auf Objekte aus S, folgt?
Leider reicht es nicht aus, diese Frage zu beantworten. Aufgrund des weit verbreiteten Aliasings in der objektorientierten Programmierung kann ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel. Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht also nicht aus. Man kann bereits erahnen, dass diese Angelegenheit komplex wird.","<answer> Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht nicht aus, da Aliasings in der objektorientierten Programmierung dazu führen kann, dass ein Objekt vom Typ S von verschiedenen Klienten unterschiedliche Typen hat und Methodenaufrufe auf dem Objekt Zustandsänderungen verursachen können, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Daher muss eine umfassendere Betrachtung erfolgen, die die Auswirkungen des Verhaltens auf den Zustand und die Spezifikation des Typs berücksichtigt. <answer> <question> Warum reicht eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit nicht aus? <question>"
"Das Gesetz Demeters besagt nicht mehr, als dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Dabei ist ""kennen"" im Sinne von Kurseinheit 1 zu verstehen: Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, wenn es also auf eine Variable direkt (also ohne den Umweg über ein anderes Objekt) zugreift, die das andere Objekt benennt. Es kennt das andere Objekt dauerhaft (oder zumindest für eine längere Dauer), wenn es sich bei der Variable um eine Instanzvariable handelt, und temporär, wenn es sich bei der Variable um den formalen Parameter einer Methode handelt (wobei die Dauer des Kennens dann auf die Dauer der Abarbeitung der Methode beschränkt ist, es sei denn, der formale Parameter wird einer Instanzvariable zugewiesen). Temporäre (lokale) Variablen werden beim Gesetz Demeters nicht mitgezählt.
Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet (Methoden auf Objekten aufgerufen) werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks (Methodenaufrufs) vorliegen. Dies ist in der Regel bei Kettenaufrufen der Fall (s. u.), kann aber auch über eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen.
Sinn und Zweck des Gesetzes Demeters ist, die Kopplung und damit die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wird das Gesetz Demeters verletzt, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen (sondern eben nur in einer mittelbaren, die nach dem Gesetz vermieden werden soll).
Das Gesetz Demeters wird oft (und leicht verkürzt) in folgender Phrase zusammengefasst: ""Sprich nicht mit Fremden"" Bezogen auf SMALLTALK heißt das, dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen.
Man beachte, dass Demeters Gesetz faktisch eine neue, kontextabhängige Zugriffbarkeitsregel einführt: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt, auf die es aber nicht zugreifen darf.","<answer> Das Gesetz Demeters besagt, dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, indem es auf eine Variable direkt zugreift, die das andere Objekt benennt. Die Dauer des Kennens kann variieren, wobei Instanzvariablen eine dauerhafte Bindung darstellen, während formale Parameter einer Methode temporär bekannt sind. <answer> <question> Was besagt das Gesetz Demeters in Bezug auf die Nachrichtenübermittlung in der objektorientierten Programmierung? <question>"
"Das Gesetz Demeters besagt nicht mehr, als dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Dabei ist ""kennen"" im Sinne von Kurseinheit 1 zu verstehen: Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, wenn es also auf eine Variable direkt (also ohne den Umweg über ein anderes Objekt) zugreift, die das andere Objekt benennt. Es kennt das andere Objekt dauerhaft (oder zumindest für eine längere Dauer), wenn es sich bei der Variable um eine Instanzvariable handelt, und temporär, wenn es sich bei der Variable um den formalen Parameter einer Methode handelt (wobei die Dauer des Kennens dann auf die Dauer der Abarbeitung der Methode beschränkt ist, es sei denn, der formale Parameter wird einer Instanzvariable zugewiesen). Temporäre (lokale) Variablen werden beim Gesetz Demeters nicht mitgezählt.
Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet (Methoden auf Objekten aufgerufen) werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks (Methodenaufrufs) vorliegen. Dies ist in der Regel bei Kettenaufrufen der Fall (s. u.), kann aber auch über eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen.
Sinn und Zweck des Gesetzes Demeters ist, die Kopplung und damit die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wird das Gesetz Demeters verletzt, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen (sondern eben nur in einer mittelbaren, die nach dem Gesetz vermieden werden soll).
Das Gesetz Demeters wird oft (und leicht verkürzt) in folgender Phrase zusammengefasst: ""Sprich nicht mit Fremden"" Bezogen auf SMALLTALK heißt das, dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen.
Man beachte, dass Demeters Gesetz faktisch eine neue, kontextabhängige Zugriffbarkeitsregel einführt: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt, auf die es aber nicht zugreifen darf.","<answer> Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks vorliegen. Dies tritt oft bei Kettenaufrufen auf oder kann durch eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen. Eine Verletzung des Gesetzes Demeters äußert sich darin, dass Nachrichten an Objekte gesendet werden, die nicht vom Sender direkt gekannt oder erzeugt wurden. <answer> <question> Wann wird das Gesetz Demeters typischerweise verletzt, und wie äußert sich diese Verletzung? <question>"
"Das Gesetz Demeters besagt nicht mehr, als dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Dabei ist ""kennen"" im Sinne von Kurseinheit 1 zu verstehen: Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, wenn es also auf eine Variable direkt (also ohne den Umweg über ein anderes Objekt) zugreift, die das andere Objekt benennt. Es kennt das andere Objekt dauerhaft (oder zumindest für eine längere Dauer), wenn es sich bei der Variable um eine Instanzvariable handelt, und temporär, wenn es sich bei der Variable um den formalen Parameter einer Methode handelt (wobei die Dauer des Kennens dann auf die Dauer der Abarbeitung der Methode beschränkt ist, es sei denn, der formale Parameter wird einer Instanzvariable zugewiesen). Temporäre (lokale) Variablen werden beim Gesetz Demeters nicht mitgezählt.
Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet (Methoden auf Objekten aufgerufen) werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks (Methodenaufrufs) vorliegen. Dies ist in der Regel bei Kettenaufrufen der Fall (s. u.), kann aber auch über eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen.
Sinn und Zweck des Gesetzes Demeters ist, die Kopplung und damit die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wird das Gesetz Demeters verletzt, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen (sondern eben nur in einer mittelbaren, die nach dem Gesetz vermieden werden soll).
Das Gesetz Demeters wird oft (und leicht verkürzt) in folgender Phrase zusammengefasst: ""Sprich nicht mit Fremden"" Bezogen auf SMALLTALK heißt das, dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen.
Man beachte, dass Demeters Gesetz faktisch eine neue, kontextabhängige Zugriffbarkeitsregel einführt: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt, auf die es aber nicht zugreifen darf.","<answer> Der Sinn und Zweck des Gesetzes Demeters ist es, die Kopplung und die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wenn das Gesetz Demeters verletzt wird, kann eine Änderung des Protokolls einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zur Klasse stehen, was vermieden werden sollte. <answer> <question> Was ist der Sinn und Zweck des Gesetzes Demeters in der objektorientierten Programmierung? <question>"
"Das Gesetz Demeters besagt nicht mehr, als dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Dabei ist ""kennen"" im Sinne von Kurseinheit 1 zu verstehen: Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, wenn es also auf eine Variable direkt (also ohne den Umweg über ein anderes Objekt) zugreift, die das andere Objekt benennt. Es kennt das andere Objekt dauerhaft (oder zumindest für eine längere Dauer), wenn es sich bei der Variable um eine Instanzvariable handelt, und temporär, wenn es sich bei der Variable um den formalen Parameter einer Methode handelt (wobei die Dauer des Kennens dann auf die Dauer der Abarbeitung der Methode beschränkt ist, es sei denn, der formale Parameter wird einer Instanzvariable zugewiesen). Temporäre (lokale) Variablen werden beim Gesetz Demeters nicht mitgezählt.
Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet (Methoden auf Objekten aufgerufen) werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks (Methodenaufrufs) vorliegen. Dies ist in der Regel bei Kettenaufrufen der Fall (s. u.), kann aber auch über eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen.
Sinn und Zweck des Gesetzes Demeters ist, die Kopplung und damit die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wird das Gesetz Demeters verletzt, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen (sondern eben nur in einer mittelbaren, die nach dem Gesetz vermieden werden soll).
Das Gesetz Demeters wird oft (und leicht verkürzt) in folgender Phrase zusammengefasst: ""Sprich nicht mit Fremden"" Bezogen auf SMALLTALK heißt das, dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen.
Man beachte, dass Demeters Gesetz faktisch eine neue, kontextabhängige Zugriffbarkeitsregel einführt: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt, auf die es aber nicht zugreifen darf.","<answer> Das Gesetz Demeters wird oft in folgender Phrase zusammengefasst: ""Sprich nicht mit Fremden."" In Bezug auf SMALLTALK bedeutet dies, dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen. <answer> <question> Wie wird das Gesetz Demeters oft in einer kurzen Phrase zusammengefasst? <question>"
"Das Gesetz Demeters besagt nicht mehr, als dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Dabei ist ""kennen"" im Sinne von Kurseinheit 1 zu verstehen: Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, wenn es also auf eine Variable direkt (also ohne den Umweg über ein anderes Objekt) zugreift, die das andere Objekt benennt. Es kennt das andere Objekt dauerhaft (oder zumindest für eine längere Dauer), wenn es sich bei der Variable um eine Instanzvariable handelt, und temporär, wenn es sich bei der Variable um den formalen Parameter einer Methode handelt (wobei die Dauer des Kennens dann auf die Dauer der Abarbeitung der Methode beschränkt ist, es sei denn, der formale Parameter wird einer Instanzvariable zugewiesen). Temporäre (lokale) Variablen werden beim Gesetz Demeters nicht mitgezählt.
Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet (Methoden auf Objekten aufgerufen) werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks (Methodenaufrufs) vorliegen. Dies ist in der Regel bei Kettenaufrufen der Fall (s. u.), kann aber auch über eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen.
Sinn und Zweck des Gesetzes Demeters ist, die Kopplung und damit die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wird das Gesetz Demeters verletzt, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen (sondern eben nur in einer mittelbaren, die nach dem Gesetz vermieden werden soll).
Das Gesetz Demeters wird oft (und leicht verkürzt) in folgender Phrase zusammengefasst: ""Sprich nicht mit Fremden"" Bezogen auf SMALLTALK heißt das, dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen.
Man beachte, dass Demeters Gesetz faktisch eine neue, kontextabhängige Zugriffbarkeitsregel einführt: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt, auf die es aber nicht zugreifen darf.","<answer> Demeters Gesetz führt faktisch eine neue, kontextabhängige Zugriffsregel ein: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt, auf die es aber nicht zugreifen darf. Dies führt zu einer klaren Trennung zwischen direkten und indirekten Beziehungen zwischen Objekten. <answer> <question> Welche Art von Zugriffsregel führt Demeters Gesetz faktisch ein? <question>"
"Wenn ich im vorangegangenen Absatz das Präteritum bemüht habe, dann liegt das daran, dass Interfaces in JAVA seit Version 8 einen Bedeutungswandel erfahren haben. Der ursprüngliche Anlass hierfür ergibt sich aus der Evolution von Software, genauer aus der Erweiterung von Interfaces im Laufe der Zeit um zusätzliche Methoden und der Tatsache, dass solche Erweiterungen ein Nachführen der Klassen, die die Interfaces implementieren, zwingend erfordern. Insbesondere bei sog. Black-box-Frameworks, deren Interfaces dazu gedacht sind, von Anwendungsklassen implementiert zu werden, deren Entwicklung in den Händen Dritter liegt, ist dies ein erhebliches Problem. Dasselbe Problem hätte man nicht, wenn man stattdessen abstrakte Klassen verwenden würde — dann könnte man nämlich die zusätzlichen Methoden mit einer Default-Implementierung versehen, die von den „implementierenden“ Klassen geerbt würde, sofern diese Klassen keine eigenen Implementierungen angeben. Interfaces in Varia -
Genau das wurde in JAVA 8 auch für Interfaces eingeführt: Ein Interface kann die Implementierung einer Methode vorgeben, die dann an implementierende Klassen (oder per ""extends"" abgeleitete Interfaces) vererbt wird. Dafür hat JAVA ein neues Schlüsselwort spendiert bekommen: ""default"". Allerdings haben Interfaces immer noch keine Instanzvariablen, und entsprechend können Default-Methoden allenfalls auf abstrakte Getter und Setter zugreifen.
Mit JAVA 9 schließlich wurde — letztlich nur konsequent — erlaubt, in Interfaces auch private Methoden zu definieren. Da diese ausschließlich aus dem Interface selbst heraus zugreifbar sind, dienen sie ausschließlich der Verbesserung der Lesbarkeit von Default-Methoden, indem man zusammenhängende Teile aus ihnen herauslöst und in private Methoden verlegt.","<answer> Interfaces in JAVA haben einen Bedeutungswandel erfahren, weil sie im Laufe der Zeit um zusätzliche Methoden erweitert wurden, was dazu führte, dass Klassen, die diese Interfaces implementieren, aktualisiert werden mussten. Insbesondere bei Black-Box-Frameworks, bei denen die Entwicklung von Anwendungsklassen in den Händen Dritter liegt, führte dies zu erheblichen Problemen. <answer> <question> Warum haben Interfaces in JAVA seit Version 8 einen Bedeutungswandel erfahren? <question>"
"Wenn ich im vorangegangenen Absatz das Präteritum bemüht habe, dann liegt das daran, dass Interfaces in JAVA seit Version 8 einen Bedeutungswandel erfahren haben. Der ursprüngliche Anlass hierfür ergibt sich aus der Evolution von Software, genauer aus der Erweiterung von Interfaces im Laufe der Zeit um zusätzliche Methoden und der Tatsache, dass solche Erweiterungen ein Nachführen der Klassen, die die Interfaces implementieren, zwingend erfordern. Insbesondere bei sog. Black-box-Frameworks, deren Interfaces dazu gedacht sind, von Anwendungsklassen implementiert zu werden, deren Entwicklung in den Händen Dritter liegt, ist dies ein erhebliches Problem. Dasselbe Problem hätte man nicht, wenn man stattdessen abstrakte Klassen verwenden würde — dann könnte man nämlich die zusätzlichen Methoden mit einer Default-Implementierung versehen, die von den „implementierenden“ Klassen geerbt würde, sofern diese Klassen keine eigenen Implementierungen angeben. Interfaces in Varia -
Genau das wurde in JAVA 8 auch für Interfaces eingeführt: Ein Interface kann die Implementierung einer Methode vorgeben, die dann an implementierende Klassen (oder per ""extends"" abgeleitete Interfaces) vererbt wird. Dafür hat JAVA ein neues Schlüsselwort spendiert bekommen: ""default"". Allerdings haben Interfaces immer noch keine Instanzvariablen, und entsprechend können Default-Methoden allenfalls auf abstrakte Getter und Setter zugreifen.
Mit JAVA 9 schließlich wurde — letztlich nur konsequent — erlaubt, in Interfaces auch private Methoden zu definieren. Da diese ausschließlich aus dem Interface selbst heraus zugreifbar sind, dienen sie ausschließlich der Verbesserung der Lesbarkeit von Default-Methoden, indem man zusammenhängende Teile aus ihnen herauslöst und in private Methoden verlegt.","<answer> Bei der Erweiterung von Interfaces, insbesondere wenn diese von Anwendungsklassen implementiert werden, entsteht das Problem, dass die Klassen, die diese Interfaces implementieren, aktualisiert werden müssen. Dies kann zu Schwierigkeiten führen, insbesondere wenn die Entwicklung dieser Klassen in den Händen Dritter liegt. <answer> <question> Welches Problem ergibt sich bei der Erweiterung von Interfaces, wenn man keine abstrakten Klassen verwendet? <question>"
"Wenn ich im vorangegangenen Absatz das Präteritum bemüht habe, dann liegt das daran, dass Interfaces in JAVA seit Version 8 einen Bedeutungswandel erfahren haben. Der ursprüngliche Anlass hierfür ergibt sich aus der Evolution von Software, genauer aus der Erweiterung von Interfaces im Laufe der Zeit um zusätzliche Methoden und der Tatsache, dass solche Erweiterungen ein Nachführen der Klassen, die die Interfaces implementieren, zwingend erfordern. Insbesondere bei sog. Black-box-Frameworks, deren Interfaces dazu gedacht sind, von Anwendungsklassen implementiert zu werden, deren Entwicklung in den Händen Dritter liegt, ist dies ein erhebliches Problem. Dasselbe Problem hätte man nicht, wenn man stattdessen abstrakte Klassen verwenden würde — dann könnte man nämlich die zusätzlichen Methoden mit einer Default-Implementierung versehen, die von den „implementierenden“ Klassen geerbt würde, sofern diese Klassen keine eigenen Implementierungen angeben. Interfaces in Varia -
Genau das wurde in JAVA 8 auch für Interfaces eingeführt: Ein Interface kann die Implementierung einer Methode vorgeben, die dann an implementierende Klassen (oder per ""extends"" abgeleitete Interfaces) vererbt wird. Dafür hat JAVA ein neues Schlüsselwort spendiert bekommen: ""default"". Allerdings haben Interfaces immer noch keine Instanzvariablen, und entsprechend können Default-Methoden allenfalls auf abstrakte Getter und Setter zugreifen.
Mit JAVA 9 schließlich wurde — letztlich nur konsequent — erlaubt, in Interfaces auch private Methoden zu definieren. Da diese ausschließlich aus dem Interface selbst heraus zugreifbar sind, dienen sie ausschließlich der Verbesserung der Lesbarkeit von Default-Methoden, indem man zusammenhängende Teile aus ihnen herauslöst und in private Methoden verlegt.","<answer> In JAVA 8 wurde das Problem der Erweiterung von Interfaces gelöst, indem Interfaces die Implementierung von Methoden durch das Schlüsselwort ""default"" vorgeben konnten. Dadurch konnten zusätzliche Methoden in Interfaces hinzugefügt werden, ohne die implementierenden Klassen zu zwingen, sie zu implementieren. <answer> <question> Wie wurde das Problem der Erweiterung von Interfaces in JAVA 8 gelöst? <question>"
"Wenn ich im vorangegangenen Absatz das Präteritum bemüht habe, dann liegt das daran, dass Interfaces in JAVA seit Version 8 einen Bedeutungswandel erfahren haben. Der ursprüngliche Anlass hierfür ergibt sich aus der Evolution von Software, genauer aus der Erweiterung von Interfaces im Laufe der Zeit um zusätzliche Methoden und der Tatsache, dass solche Erweiterungen ein Nachführen der Klassen, die die Interfaces implementieren, zwingend erfordern. Insbesondere bei sog. Black-box-Frameworks, deren Interfaces dazu gedacht sind, von Anwendungsklassen implementiert zu werden, deren Entwicklung in den Händen Dritter liegt, ist dies ein erhebliches Problem. Dasselbe Problem hätte man nicht, wenn man stattdessen abstrakte Klassen verwenden würde — dann könnte man nämlich die zusätzlichen Methoden mit einer Default-Implementierung versehen, die von den „implementierenden“ Klassen geerbt würde, sofern diese Klassen keine eigenen Implementierungen angeben. Interfaces in Varia -
Genau das wurde in JAVA 8 auch für Interfaces eingeführt: Ein Interface kann die Implementierung einer Methode vorgeben, die dann an implementierende Klassen (oder per ""extends"" abgeleitete Interfaces) vererbt wird. Dafür hat JAVA ein neues Schlüsselwort spendiert bekommen: ""default"". Allerdings haben Interfaces immer noch keine Instanzvariablen, und entsprechend können Default-Methoden allenfalls auf abstrakte Getter und Setter zugreifen.
Mit JAVA 9 schließlich wurde — letztlich nur konsequent — erlaubt, in Interfaces auch private Methoden zu definieren. Da diese ausschließlich aus dem Interface selbst heraus zugreifbar sind, dienen sie ausschließlich der Verbesserung der Lesbarkeit von Default-Methoden, indem man zusammenhängende Teile aus ihnen herauslöst und in private Methoden verlegt.","<answer> In JAVA 9 wurde es erlaubt, in Interfaces auch private Methoden zu definieren. Diese privaten Methoden sind nur innerhalb des Interfaces selbst zugreifbar und dienen dazu, die Lesbarkeit von Default-Methoden zu verbessern, indem gemeinsame Teile in private Methoden ausgelagert werden können. <answer> <question> Was erlaubte JAVA 9 in Bezug auf Interfaces? <question>"
"Ein laufendes objektorientiertes Programm muss man sich als eine Menge interagierender Objekte vorstellen. Damit die Objekte interagieren können, müssen sie verbunden sein; sie bilden dazu ein Geflecht, das neben Objekten aus Beziehungen zwischen diesen besteht. Das Geflecht verändert sich dynamisch infolge der Interaktion zwischen Objekten; es unterliegt aber gewissen, durch das Programm vorgegebenen statischen Strukturen. Die Unterscheidung zwischen Statik und Dynamik ist eine klassische der Programmierung. Während Programme traditionell statische Gebilde sind, die auf Papier oder in einem Nur-Lese-Speicher festgehalten werden können, ist ihre Ausführung immer etwas Dynamisches. Wenn aber Programme selbst als Daten aufgefasst werden, dann verwischt die Grenze zwischen Statik und Dynamik: Programme werden veränderlich. Insbesondere, wenn Programme sich selbst verändern können, ist die Unterscheidung zwischen Statik und Dynamik nur noch bedingt nützlich. Alternativ zu Statik und Dynamik kann man auch zwischen Struktur und Verhalten unterscheiden, wobei mit Struktur das oben erwähnte Objektgeflecht und mit Verhalten die (Spezifikation der) Folge seiner Veränderungen gemeint ist. Diese Unterscheidung liegt der Gliederung des Rests dieser Kurseinheit zugrunde: von Objekten (Kapitel 1) und Beziehungen zwischen diesen (Kapitel 2) geht es über den Zustand als Bindeglied (Kapitel 3) zu den Elementen der Verhaltensbeschreibung (Kapitel 4).","<answer> Ein laufendes objektorientiertes Programm kann man sich als eine Menge interagierender Objekte vorstellen. Diese Objekte sind miteinander verbunden und bilden ein Geflecht von Beziehungen. Das Geflecht ändert sich dynamisch durch die Interaktion der Objekte, wobei bestimmte statische Strukturen durch das Programm vorgegeben sind. <answer> <question> Wie kann man sich ein laufendes objektorientiertes Programm vorstellen? <question>"
"Ein laufendes objektorientiertes Programm muss man sich als eine Menge interagierender Objekte vorstellen. Damit die Objekte interagieren können, müssen sie verbunden sein; sie bilden dazu ein Geflecht, das neben Objekten aus Beziehungen zwischen diesen besteht. Das Geflecht verändert sich dynamisch infolge der Interaktion zwischen Objekten; es unterliegt aber gewissen, durch das Programm vorgegebenen statischen Strukturen. Die Unterscheidung zwischen Statik und Dynamik ist eine klassische der Programmierung. Während Programme traditionell statische Gebilde sind, die auf Papier oder in einem Nur-Lese-Speicher festgehalten werden können, ist ihre Ausführung immer etwas Dynamisches. Wenn aber Programme selbst als Daten aufgefasst werden, dann verwischt die Grenze zwischen Statik und Dynamik: Programme werden veränderlich. Insbesondere, wenn Programme sich selbst verändern können, ist die Unterscheidung zwischen Statik und Dynamik nur noch bedingt nützlich. Alternativ zu Statik und Dynamik kann man auch zwischen Struktur und Verhalten unterscheiden, wobei mit Struktur das oben erwähnte Objektgeflecht und mit Verhalten die (Spezifikation der) Folge seiner Veränderungen gemeint ist. Diese Unterscheidung liegt der Gliederung des Rests dieser Kurseinheit zugrunde: von Objekten (Kapitel 1) und Beziehungen zwischen diesen (Kapitel 2) geht es über den Zustand als Bindeglied (Kapitel 3) zu den Elementen der Verhaltensbeschreibung (Kapitel 4).","<answer> Die Unterscheidung zwischen Statik und Dynamik ist wichtig, um das Verhalten von Programmen zu verstehen. Programme haben eine statische Struktur, die ihre Komponenten und ihre Beziehungen zueinander beschreibt. Diese Struktur kann als Grundlage für die Ausführung des Programms dienen. Auf der anderen Seite ist die Ausführung eines Programms immer dynamisch und kann sich im Laufe der Zeit ändern. Die Unterscheidung hilft dabei, die Beziehung zwischen der Programmstruktur und ihrem Verhalten zu verstehen. <answer> <question> Warum ist die Unterscheidung zwischen Statik und Dynamik in der Programmierung wichtig? <question>"
"Ein laufendes objektorientiertes Programm muss man sich als eine Menge interagierender Objekte vorstellen. Damit die Objekte interagieren können, müssen sie verbunden sein; sie bilden dazu ein Geflecht, das neben Objekten aus Beziehungen zwischen diesen besteht. Das Geflecht verändert sich dynamisch infolge der Interaktion zwischen Objekten; es unterliegt aber gewissen, durch das Programm vorgegebenen statischen Strukturen. Die Unterscheidung zwischen Statik und Dynamik ist eine klassische der Programmierung. Während Programme traditionell statische Gebilde sind, die auf Papier oder in einem Nur-Lese-Speicher festgehalten werden können, ist ihre Ausführung immer etwas Dynamisches. Wenn aber Programme selbst als Daten aufgefasst werden, dann verwischt die Grenze zwischen Statik und Dynamik: Programme werden veränderlich. Insbesondere, wenn Programme sich selbst verändern können, ist die Unterscheidung zwischen Statik und Dynamik nur noch bedingt nützlich. Alternativ zu Statik und Dynamik kann man auch zwischen Struktur und Verhalten unterscheiden, wobei mit Struktur das oben erwähnte Objektgeflecht und mit Verhalten die (Spezifikation der) Folge seiner Veränderungen gemeint ist. Diese Unterscheidung liegt der Gliederung des Rests dieser Kurseinheit zugrunde: von Objekten (Kapitel 1) und Beziehungen zwischen diesen (Kapitel 2) geht es über den Zustand als Bindeglied (Kapitel 3) zu den Elementen der Verhaltensbeschreibung (Kapitel 4).","<answer> In der objektorientierten Programmierung kann die Unterscheidung zwischen Struktur und Verhalten angewendet werden, um die verschiedenen Aspekte eines Programms zu analysieren und zu gestalten. Die Struktur bezieht sich auf das Objektgeflecht und die Beziehungen zwischen den Objekten. Das Verhalten bezieht sich auf die Spezifikation der Änderungen, die im Verlauf der Programmausführung auftreten. Diese Unterscheidung kann bei der Analyse und Gestaltung von Programmen hilfreich sein, da sie ermöglicht, sich auf die Struktur und das Verhalten von Objekten und Klassen zu konzentrieren und diese getrennt zu behandeln. <answer> <question> Wie kann die Unterscheidung zwischen Struktur und Verhalten in der objektorientierten Programmierung angewendet werden? <question>"
"Man kann sich fragen, ob sich die Einhaltung des Law of Demeter so wie die Einhaltung der Zugreifbarkeitsregeln automatisch überprüfen lässt. Dabei gibt es aber ein Problem: Das Gesetz ist nämlich oben in Termini von Objekten, nicht von Variablen oder Typen formuliert. Eine Überprüfung würde also die Auswertung von konkreten Zuweisungen und damit des dynamischen Programmflusses erfordern, die aber mechanisch extrem aufwendig bis gar nicht durchzuführen ist. Statt dessen prüfen automatische Checker des Law of Demeter zumeist lediglich die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters (wenn der Aufruf aus einer Methode heraus erfolgt, was meistens der Fall ist) haben. Daraus folgt, dass eine solche Prüfung in SMALLTALK nicht möglich ist (da Ausdrücke nicht typisiert sind).
Was aber tun, wenn man die Funktion von Ausdrücken wie oben haben und zugleich Demeters Gesetz folgen möchte? Die Antwort ist einfach: Man erweitert das Protokoll der Klasse des ersten Nachrichtenempfängers um die Methode(n), die man nicht verkettet aufrufen darf, also beispielsweise die Klasse des von ""a"" benannten Objekts um die Methode ""doY"". Da ""a"" das Ergebnis von ""doX"" ist, nennen wir es ""b"", muss ""a"" auch die Methode ""doY"" aufrufen und das Ergebnis zurückgeben. Die Implementierung von ""doY"" würde dann durch ""^ b doY"" abgeschlossen.
Komplizierter wird die Sache jedoch, wenn die Verkettung länger ist, wenn also der zu vermeidende Ausdruck ""a doX doY doZ"" heißen würde, denn dann müsste auch noch ""doZ"" zur Klasse von ""a"" hinzugefügt und mit entsprechenden Implementierungen versehen werden. Man ahnt schon, wohin das führt: zu einem Wachstum des Protokolls von ""a"".","<answer> Die automatische Überprüfung des Gesetzes Demeters gestaltet sich schwierig, da das Gesetz in Bezug auf Objekte formuliert ist und die Auswertung von konkreten Zuweisungen und dynamischen Programmfluss erfordern würde, was mechanisch extrem aufwendig oder sogar unmöglich ist. Stattdessen überprüfen automatische Checker des Gesetzes Demeters in der Regel die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters haben. <answer> <question> Ist es möglich, die Einhaltung des Gesetzes Demeters automatisch zu überprüfen? Warum oder warum nicht? <question>"
"Man kann sich fragen, ob sich die Einhaltung des Law of Demeter so wie die Einhaltung der Zugreifbarkeitsregeln automatisch überprüfen lässt. Dabei gibt es aber ein Problem: Das Gesetz ist nämlich oben in Termini von Objekten, nicht von Variablen oder Typen formuliert. Eine Überprüfung würde also die Auswertung von konkreten Zuweisungen und damit des dynamischen Programmflusses erfordern, die aber mechanisch extrem aufwendig bis gar nicht durchzuführen ist. Statt dessen prüfen automatische Checker des Law of Demeter zumeist lediglich die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters (wenn der Aufruf aus einer Methode heraus erfolgt, was meistens der Fall ist) haben. Daraus folgt, dass eine solche Prüfung in SMALLTALK nicht möglich ist (da Ausdrücke nicht typisiert sind).
Was aber tun, wenn man die Funktion von Ausdrücken wie oben haben und zugleich Demeters Gesetz folgen möchte? Die Antwort ist einfach: Man erweitert das Protokoll der Klasse des ersten Nachrichtenempfängers um die Methode(n), die man nicht verkettet aufrufen darf, also beispielsweise die Klasse des von ""a"" benannten Objekts um die Methode ""doY"". Da ""a"" das Ergebnis von ""doX"" ist, nennen wir es ""b"", muss ""a"" auch die Methode ""doY"" aufrufen und das Ergebnis zurückgeben. Die Implementierung von ""doY"" würde dann durch ""^ b doY"" abgeschlossen.
Komplizierter wird die Sache jedoch, wenn die Verkettung länger ist, wenn also der zu vermeidende Ausdruck ""a doX doY doZ"" heißen würde, denn dann müsste auch noch ""doZ"" zur Klasse von ""a"" hinzugefügt und mit entsprechenden Implementierungen versehen werden. Man ahnt schon, wohin das führt: zu einem Wachstum des Protokolls von ""a"".","<answer> In SMALLTALK ist die automatische Überprüfung des Gesetzes Demeters nicht möglich, da Ausdrücke in SMALLTALK nicht typisiert sind. Daher können Checker nicht feststellen, ob die Art und Weise, wie auf Objekte zugegriffen wird, dem Gesetz Demeters entspricht. <answer> <question> Warum ist die automatische Überprüfung des Gesetzes Demeters in SMALLTALK nicht möglich? <question>"
"Man kann sich fragen, ob sich die Einhaltung des Law of Demeter so wie die Einhaltung der Zugreifbarkeitsregeln automatisch überprüfen lässt. Dabei gibt es aber ein Problem: Das Gesetz ist nämlich oben in Termini von Objekten, nicht von Variablen oder Typen formuliert. Eine Überprüfung würde also die Auswertung von konkreten Zuweisungen und damit des dynamischen Programmflusses erfordern, die aber mechanisch extrem aufwendig bis gar nicht durchzuführen ist. Statt dessen prüfen automatische Checker des Law of Demeter zumeist lediglich die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters (wenn der Aufruf aus einer Methode heraus erfolgt, was meistens der Fall ist) haben. Daraus folgt, dass eine solche Prüfung in SMALLTALK nicht möglich ist (da Ausdrücke nicht typisiert sind).
Was aber tun, wenn man die Funktion von Ausdrücken wie oben haben und zugleich Demeters Gesetz folgen möchte? Die Antwort ist einfach: Man erweitert das Protokoll der Klasse des ersten Nachrichtenempfängers um die Methode(n), die man nicht verkettet aufrufen darf, also beispielsweise die Klasse des von ""a"" benannten Objekts um die Methode ""doY"". Da ""a"" das Ergebnis von ""doX"" ist, nennen wir es ""b"", muss ""a"" auch die Methode ""doY"" aufrufen und das Ergebnis zurückgeben. Die Implementierung von ""doY"" würde dann durch ""^ b doY"" abgeschlossen.
Komplizierter wird die Sache jedoch, wenn die Verkettung länger ist, wenn also der zu vermeidende Ausdruck ""a doX doY doZ"" heißen würde, denn dann müsste auch noch ""doZ"" zur Klasse von ""a"" hinzugefügt und mit entsprechenden Implementierungen versehen werden. Man ahnt schon, wohin das führt: zu einem Wachstum des Protokolls von ""a"".","<answer> Um sowohl die Funktionalität von Ausdrücken beizubehalten als auch das Gesetz Demeters einzuhalten, kann man das Protokoll der Klasse des ersten Nachrichtenempfängers erweitern. Dies bedeutet, dass die Klasse des von ""a"" benannten Objekts um die Methode ""doY"" erweitert wird, wenn ""a"" das Ergebnis von ""doX"" ist. Dadurch wird sicherer gestellt, dass ""a"" auch die Methode ""doY"" aufruft und das Ergebnis zurückgibt. <answer> <question> Wie kann man die Einhaltung des Gesetzes Demeters sicherstellen und dennoch die Funktionalität von Ausdrücken beibehalten? <question>"
"Man kann sich fragen, ob sich die Einhaltung des Law of Demeter so wie die Einhaltung der Zugreifbarkeitsregeln automatisch überprüfen lässt. Dabei gibt es aber ein Problem: Das Gesetz ist nämlich oben in Termini von Objekten, nicht von Variablen oder Typen formuliert. Eine Überprüfung würde also die Auswertung von konkreten Zuweisungen und damit des dynamischen Programmflusses erfordern, die aber mechanisch extrem aufwendig bis gar nicht durchzuführen ist. Statt dessen prüfen automatische Checker des Law of Demeter zumeist lediglich die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters (wenn der Aufruf aus einer Methode heraus erfolgt, was meistens der Fall ist) haben. Daraus folgt, dass eine solche Prüfung in SMALLTALK nicht möglich ist (da Ausdrücke nicht typisiert sind).
Was aber tun, wenn man die Funktion von Ausdrücken wie oben haben und zugleich Demeters Gesetz folgen möchte? Die Antwort ist einfach: Man erweitert das Protokoll der Klasse des ersten Nachrichtenempfängers um die Methode(n), die man nicht verkettet aufrufen darf, also beispielsweise die Klasse des von ""a"" benannten Objekts um die Methode ""doY"". Da ""a"" das Ergebnis von ""doX"" ist, nennen wir es ""b"", muss ""a"" auch die Methode ""doY"" aufrufen und das Ergebnis zurückgeben. Die Implementierung von ""doY"" würde dann durch ""^ b doY"" abgeschlossen.
Komplizierter wird die Sache jedoch, wenn die Verkettung länger ist, wenn also der zu vermeidende Ausdruck ""a doX doY doZ"" heißen würde, denn dann müsste auch noch ""doZ"" zur Klasse von ""a"" hinzugefügt und mit entsprechenden Implementierungen versehen werden. Man ahnt schon, wohin das führt: zu einem Wachstum des Protokolls von ""a"".","<answer> Die Sache wird komplizierter, wenn die Verkettung von Methodenaufrufen länger ist, da dann alle Methoden in der Verkettung zur Klasse des ersten Nachrichtenempfängers hinzugefügt und mit entsprechenden Implementierungen versehen werden müssen. Dies führt zu einem Wachstum des Protokolls der Klasse des ersten Nachrichtenempfängers. <answer> <question> Was wird komplizierter, wenn die Verkettung von Methodenaufrufen länger ist? <question>"
"C# soll genau wie JAVA und anders als C++ eine typsichere Sprache sein, also eine strikte Typprüfung durchführen. Da aber (ebenfalls genau wie in JAVA) nicht alles zur Übersetzungszeit geschehen kann, hat auch das Typsystem von C# eine Laufzeitkomponente.
Um einen Ausdruck einer Typumwandlung zu unterziehen, bietet C# genau wie JAVA und C++ Casts an. Auch die Syntax unterscheidet sich nicht.
Dies bewirkt, dass der Ausdruck a den Typ T aufgedrückt bekommt. Ist dies nicht möglich, weil der tatsächliche Typ des Objekts, auf das a verweist, kein Subtyp von T ist oder weil keine entsprechende Typumwandlung definiert ist (einschließlich Boxing/Unboxing), wird dies mit einem Laufzeitfehler quittiert. Casts sind also typsicher (in dem Sinne, dass keiner Variable ein Wert zugewiesen wird, den sie nicht haben darf), aber nicht sicher (sie können zu Ausnahmesituationen und, im Falle einer Nichtbehandlung, zu Programmabbrüchen führen).
Um Casts sicher zu machen, bietet C# den Operator is. Er entspricht im Wesentlichen dem instanceof von JAVA, wobei a für einen beliebigen Ausdruck und T für einen Typ steht, zurück, ob das Ergebnis der Auswertung von a mit einer Variable vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.","<answer> Eine typsichere Sprache wie C# soll strikte Typprüfungen durchführen, um sicherzustellen, dass Variablen nur Werte akzeptieren, die ihrem deklarierten Typ entsprechen. <answer> <question> Welche Eigenschaften sollte eine typsichere Sprache haben? <question>"
"C# soll genau wie JAVA und anders als C++ eine typsichere Sprache sein, also eine strikte Typprüfung durchführen. Da aber (ebenfalls genau wie in JAVA) nicht alles zur Übersetzungszeit geschehen kann, hat auch das Typsystem von C# eine Laufzeitkomponente.
Um einen Ausdruck einer Typumwandlung zu unterziehen, bietet C# genau wie JAVA und C++ Casts an. Auch die Syntax unterscheidet sich nicht.
Dies bewirkt, dass der Ausdruck a den Typ T aufgedrückt bekommt. Ist dies nicht möglich, weil der tatsächliche Typ des Objekts, auf das a verweist, kein Subtyp von T ist oder weil keine entsprechende Typumwandlung definiert ist (einschließlich Boxing/Unboxing), wird dies mit einem Laufzeitfehler quittiert. Casts sind also typsicher (in dem Sinne, dass keiner Variable ein Wert zugewiesen wird, den sie nicht haben darf), aber nicht sicher (sie können zu Ausnahmesituationen und, im Falle einer Nichtbehandlung, zu Programmabbrüchen führen).
Um Casts sicher zu machen, bietet C# den Operator is. Er entspricht im Wesentlichen dem instanceof von JAVA, wobei a für einen beliebigen Ausdruck und T für einen Typ steht, zurück, ob das Ergebnis der Auswertung von a mit einer Variable vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.","<answer> In C# kann eine Typumwandlung mithilfe von Casts durchgeführt werden. Die Syntax dafür ist (T)a;, wobei T der Zieltyp ist und a der Ausdruck, der umgewandelt werden soll. <answer> <question> Wie kann in C# eine Typumwandlung (Casting) durchgeführt werden? <question>"
"C# soll genau wie JAVA und anders als C++ eine typsichere Sprache sein, also eine strikte Typprüfung durchführen. Da aber (ebenfalls genau wie in JAVA) nicht alles zur Übersetzungszeit geschehen kann, hat auch das Typsystem von C# eine Laufzeitkomponente.
Um einen Ausdruck einer Typumwandlung zu unterziehen, bietet C# genau wie JAVA und C++ Casts an. Auch die Syntax unterscheidet sich nicht.
Dies bewirkt, dass der Ausdruck a den Typ T aufgedrückt bekommt. Ist dies nicht möglich, weil der tatsächliche Typ des Objekts, auf das a verweist, kein Subtyp von T ist oder weil keine entsprechende Typumwandlung definiert ist (einschließlich Boxing/Unboxing), wird dies mit einem Laufzeitfehler quittiert. Casts sind also typsicher (in dem Sinne, dass keiner Variable ein Wert zugewiesen wird, den sie nicht haben darf), aber nicht sicher (sie können zu Ausnahmesituationen und, im Falle einer Nichtbehandlung, zu Programmabbrüchen führen).
Um Casts sicher zu machen, bietet C# den Operator is. Er entspricht im Wesentlichen dem instanceof von JAVA, wobei a für einen beliebigen Ausdruck und T für einen Typ steht, zurück, ob das Ergebnis der Auswertung von a mit einer Variable vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.","<answer> Wenn eine Typumwandlung in C# nicht möglich ist, weil der tatsächliche Typ des Ausdrucks a kein Subtyp von T ist oder keine entsprechende Typumwandlung definiert ist, führt dies zu einem Laufzeitfehler. <answer> <question> Was passiert, wenn eine Typumwandlung in C# nicht möglich ist? <question>"
"C# soll genau wie JAVA und anders als C++ eine typsichere Sprache sein, also eine strikte Typprüfung durchführen. Da aber (ebenfalls genau wie in JAVA) nicht alles zur Übersetzungszeit geschehen kann, hat auch das Typsystem von C# eine Laufzeitkomponente.
Um einen Ausdruck einer Typumwandlung zu unterziehen, bietet C# genau wie JAVA und C++ Casts an. Auch die Syntax unterscheidet sich nicht.
Dies bewirkt, dass der Ausdruck a den Typ T aufgedrückt bekommt. Ist dies nicht möglich, weil der tatsächliche Typ des Objekts, auf das a verweist, kein Subtyp von T ist oder weil keine entsprechende Typumwandlung definiert ist (einschließlich Boxing/Unboxing), wird dies mit einem Laufzeitfehler quittiert. Casts sind also typsicher (in dem Sinne, dass keiner Variable ein Wert zugewiesen wird, den sie nicht haben darf), aber nicht sicher (sie können zu Ausnahmesituationen und, im Falle einer Nichtbehandlung, zu Programmabbrüchen führen).
Um Casts sicher zu machen, bietet C# den Operator is. Er entspricht im Wesentlichen dem instanceof von JAVA, wobei a für einen beliebigen Ausdruck und T für einen Typ steht, zurück, ob das Ergebnis der Auswertung von a mit einer Variable vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.","<answer> In C# entspricht der Operator is dem instanceof-Operator in Java. Er prüft, ob das Ergebnis der Auswertung eines Ausdrucks mit einem gegebenen Typ T zuweisungskompatibel ist. <answer> <question> Welcher Operator in C# entspricht dem instanceof-Operator in Java? <question>"
"C# soll genau wie JAVA und anders als C++ eine typsichere Sprache sein, also eine strikte Typprüfung durchführen. Da aber (ebenfalls genau wie in JAVA) nicht alles zur Übersetzungszeit geschehen kann, hat auch das Typsystem von C# eine Laufzeitkomponente.
Um einen Ausdruck einer Typumwandlung zu unterziehen, bietet C# genau wie JAVA und C++ Casts an. Auch die Syntax unterscheidet sich nicht.
Dies bewirkt, dass der Ausdruck a den Typ T aufgedrückt bekommt. Ist dies nicht möglich, weil der tatsächliche Typ des Objekts, auf das a verweist, kein Subtyp von T ist oder weil keine entsprechende Typumwandlung definiert ist (einschließlich Boxing/Unboxing), wird dies mit einem Laufzeitfehler quittiert. Casts sind also typsicher (in dem Sinne, dass keiner Variable ein Wert zugewiesen wird, den sie nicht haben darf), aber nicht sicher (sie können zu Ausnahmesituationen und, im Falle einer Nichtbehandlung, zu Programmabbrüchen führen).
Um Casts sicher zu machen, bietet C# den Operator is. Er entspricht im Wesentlichen dem instanceof von JAVA, wobei a für einen beliebigen Ausdruck und T für einen Typ steht, zurück, ob das Ergebnis der Auswertung von a mit einer Variable vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.","<answer> In C# wird ein Cast sicher gemacht, indem der is-Operator verwendet wird, um zu prüfen, ob die Zuweisung kompatibel ist. Zusätzlich kann der as-Operator verwendet werden, der bei fehlschlagender Zuweisung null zurückgibt. <answer> <question> Wie wird in C# sichergestellt, dass ein Cast sicher ist? <question>"
"Es ist Ihnen vielleicht aufgefallen, dass im oben beschriebenen Verfahren zum Auffinden der auszuführenden Methode nur das Empfängerobjekt, jedoch nicht die Parameterobjekte berücksichtigt wurden. Das erscheint zunächst natürlich. Manchmal hängt jedoch die Auswahl einer geeigneten Methode auch von den tatsächlichen Parametern ab.
Typische Fälle, in denen auch die tatsächlichen Parameter eine Rolle bei der Methodenauswahl spielen, sind arithmetische Operatoren wie +, –, *, und /. Diese sind nämlich sowohl für Ganzzahlen als auch für Brüche und Gleitkommazahlen definiert, wobei die Implementierung einer Operation von der Art der Operanden abhängt. Nehmen wir beispielsweise an, es gäbe zwei primitive Methoden für die Addition, und zwar eine effiziente für die Integer-Addition (IAdd) und eine weniger effiziente für die Float-Addition (FAdd), und man möchte Additionen für beliebige Kombinationen von Summanden möglichst effizient durchführen können.
Während die Unterscheidung nach Empfängerobjekten vom dynamischen Binden und damit dem Laufzeitsystem vorgenommen wird, bleibt die Frage, wie man die Unterscheidung nach den Parameterobjekten vornimmt: Zumindest die Implementation der Addition in der Klasse Integer muss ja danach unterscheiden, ob der Parameter auch ein Integer oder vielleicht ein Float ist. Anstatt nun diese Fallunterscheidung (mittels entsprechender Methoden wie isInteger bzw. isFloat) explizit zu machen, kann man sich eines einfachen Tricks bedienen: Man ruft im Rumpf einer Methode dieselbe Methode einfach noch einmal auf und vertauscht dabei Empfänger (self) und Parameter. Damit es dabei nicht zu unendlichen Rekursionen kommt, kodiert man die Klasse des Empfängers im Nachrichtenselektor der neu aufgerufenen Methode42, also z. B. plusFloat: anstelle von nur plus:.
Diese Technik, nämlich eine Methode gleicher Bedeutung unter Vertauschung von Sender und Empfänger aufzurufen, nennt man ""Double Dispatch"", und zwar deshalb, weil die dynamische Bindung (auch Method oder Message dispatching genannt) zweimal, und zwar unmittelbar hintereinander, erfolgt. Etwas Ähnliches haben Sie bei der Implementierung von + in Integer in Abschnitt 4.3.7 (Kurseinheit 1, Zeile 154) schon gesehen. Die Technik des Double Dispatch wurde übrigens von DAN INGALLS am Beispiel von SMALLTALK erstmals beschrieben; sie findet auch in anderen Sprachen mit Single Dispatch (wie JAVA und C#) verbreitet Anwendung. Double Dispatch wird in Sprachen, bei denen bei der (dynamischen) Methodenauswahl von Haus aus die Parametertypen mit berücksichtigt werden (die sog. Multi Dispatch -Sprachen), naturgemäß nicht benötigt.","<answer> In bestimmten Situationen hängt die Auswahl einer geeigneten Methode nicht nur vom Empfängerobjekt ab, sondern auch von den tatsächlichen Parametern, die an die Methode übergeben werden. Dies ist beispielsweise bei arithmetischen Operationen wie Addition, Subtraktion, Multiplikation und Division der Fall, bei denen die Implementierung der Operation von der Art der Operanden abhängt (z. B. Ganzzahlen oder Gleitkommazahlen). Es ist notwendig, die Unterscheidung nach den Parameterobjekten vorzunehmen, um die richtige Methode auszuwählen. <answer> <question> Warum ist es manchmal notwendig, auch die tatsächlichen Parameter bei der Methodenauswahl zu berücksichtigen? <question>"
"Es ist Ihnen vielleicht aufgefallen, dass im oben beschriebenen Verfahren zum Auffinden der auszuführenden Methode nur das Empfängerobjekt, jedoch nicht die Parameterobjekte berücksichtigt wurden. Das erscheint zunächst natürlich. Manchmal hängt jedoch die Auswahl einer geeigneten Methode auch von den tatsächlichen Parametern ab.
Typische Fälle, in denen auch die tatsächlichen Parameter eine Rolle bei der Methodenauswahl spielen, sind arithmetische Operatoren wie +, –, *, und /. Diese sind nämlich sowohl für Ganzzahlen als auch für Brüche und Gleitkommazahlen definiert, wobei die Implementierung einer Operation von der Art der Operanden abhängt. Nehmen wir beispielsweise an, es gäbe zwei primitive Methoden für die Addition, und zwar eine effiziente für die Integer-Addition (IAdd) und eine weniger effiziente für die Float-Addition (FAdd), und man möchte Additionen für beliebige Kombinationen von Summanden möglichst effizient durchführen können.
Während die Unterscheidung nach Empfängerobjekten vom dynamischen Binden und damit dem Laufzeitsystem vorgenommen wird, bleibt die Frage, wie man die Unterscheidung nach den Parameterobjekten vornimmt: Zumindest die Implementation der Addition in der Klasse Integer muss ja danach unterscheiden, ob der Parameter auch ein Integer oder vielleicht ein Float ist. Anstatt nun diese Fallunterscheidung (mittels entsprechender Methoden wie isInteger bzw. isFloat) explizit zu machen, kann man sich eines einfachen Tricks bedienen: Man ruft im Rumpf einer Methode dieselbe Methode einfach noch einmal auf und vertauscht dabei Empfänger (self) und Parameter. Damit es dabei nicht zu unendlichen Rekursionen kommt, kodiert man die Klasse des Empfängers im Nachrichtenselektor der neu aufgerufenen Methode42, also z. B. plusFloat: anstelle von nur plus:.
Diese Technik, nämlich eine Methode gleicher Bedeutung unter Vertauschung von Sender und Empfänger aufzurufen, nennt man ""Double Dispatch"", und zwar deshalb, weil die dynamische Bindung (auch Method oder Message dispatching genannt) zweimal, und zwar unmittelbar hintereinander, erfolgt. Etwas Ähnliches haben Sie bei der Implementierung von + in Integer in Abschnitt 4.3.7 (Kurseinheit 1, Zeile 154) schon gesehen. Die Technik des Double Dispatch wurde übrigens von DAN INGALLS am Beispiel von SMALLTALK erstmals beschrieben; sie findet auch in anderen Sprachen mit Single Dispatch (wie JAVA und C#) verbreitet Anwendung. Double Dispatch wird in Sprachen, bei denen bei der (dynamischen) Methodenauswahl von Haus aus die Parametertypen mit berücksichtigt werden (die sog. Multi Dispatch -Sprachen), naturgemäß nicht benötigt.","<answer> In SMALLTALK kann die Unterscheidung nach den Parameterobjekten mithilfe einer Technik namens ""Double Dispatch"" durchgeführt werden. Bei dieser Technik wird im Rumpf einer Methode dieselbe Methode noch einmal aufgerufen, wobei Empfänger (self) und Parameter vertauscht werden. Die Klasse des Empfängers wird im Nachrichtenselektor der neu aufgerufenen Methode kodiert. Dadurch erfolgt die dynamische Bindung zweimal hintereinander, einmal für den Empfänger und einmal für den Parameter, um die richtige Methode basierend auf beiden Objekten auszuwählen. <answer> <question> Wie wird die Unterscheidung nach den Parameterobjekten in SMALLTALK durchgeführt? <question>"
"Es ist Ihnen vielleicht aufgefallen, dass im oben beschriebenen Verfahren zum Auffinden der auszuführenden Methode nur das Empfängerobjekt, jedoch nicht die Parameterobjekte berücksichtigt wurden. Das erscheint zunächst natürlich. Manchmal hängt jedoch die Auswahl einer geeigneten Methode auch von den tatsächlichen Parametern ab.
Typische Fälle, in denen auch die tatsächlichen Parameter eine Rolle bei der Methodenauswahl spielen, sind arithmetische Operatoren wie +, –, *, und /. Diese sind nämlich sowohl für Ganzzahlen als auch für Brüche und Gleitkommazahlen definiert, wobei die Implementierung einer Operation von der Art der Operanden abhängt. Nehmen wir beispielsweise an, es gäbe zwei primitive Methoden für die Addition, und zwar eine effiziente für die Integer-Addition (IAdd) und eine weniger effiziente für die Float-Addition (FAdd), und man möchte Additionen für beliebige Kombinationen von Summanden möglichst effizient durchführen können.
Während die Unterscheidung nach Empfängerobjekten vom dynamischen Binden und damit dem Laufzeitsystem vorgenommen wird, bleibt die Frage, wie man die Unterscheidung nach den Parameterobjekten vornimmt: Zumindest die Implementation der Addition in der Klasse Integer muss ja danach unterscheiden, ob der Parameter auch ein Integer oder vielleicht ein Float ist. Anstatt nun diese Fallunterscheidung (mittels entsprechender Methoden wie isInteger bzw. isFloat) explizit zu machen, kann man sich eines einfachen Tricks bedienen: Man ruft im Rumpf einer Methode dieselbe Methode einfach noch einmal auf und vertauscht dabei Empfänger (self) und Parameter. Damit es dabei nicht zu unendlichen Rekursionen kommt, kodiert man die Klasse des Empfängers im Nachrichtenselektor der neu aufgerufenen Methode42, also z. B. plusFloat: anstelle von nur plus:.
Diese Technik, nämlich eine Methode gleicher Bedeutung unter Vertauschung von Sender und Empfänger aufzurufen, nennt man ""Double Dispatch"", und zwar deshalb, weil die dynamische Bindung (auch Method oder Message dispatching genannt) zweimal, und zwar unmittelbar hintereinander, erfolgt. Etwas Ähnliches haben Sie bei der Implementierung von + in Integer in Abschnitt 4.3.7 (Kurseinheit 1, Zeile 154) schon gesehen. Die Technik des Double Dispatch wurde übrigens von DAN INGALLS am Beispiel von SMALLTALK erstmals beschrieben; sie findet auch in anderen Sprachen mit Single Dispatch (wie JAVA und C#) verbreitet Anwendung. Double Dispatch wird in Sprachen, bei denen bei der (dynamischen) Methodenauswahl von Haus aus die Parametertypen mit berücksichtigt werden (die sog. Multi Dispatch -Sprachen), naturgemäß nicht benötigt.","<answer> Die Technik des ""Double Dispatch"" wurde von Dan Ingalls am Beispiel von SMALLTALK erstmals beschrieben. Diese Technik wird auch in anderen Programmiersprachen mit ""Single Dispatch"" (wie JAVA und C#) verbreitet angewendet. Es ist jedoch zu beachten, dass in Sprachen, in denen die Parametertypen von Haus aus bei der (dynamischen) Methodenauswahl berücksichtigt werden (sog. ""Multi Dispatch""-Sprachen), Double Dispatch nicht benötigt wird. <answer> <question> Wer hat die Technik des ""Double Dispatch"" erstmals beschrieben und in welchen Programmiersprachen wird sie verwendet? <question>"
"SMALLTALK stammt aus einer Zeit, in der man noch relativ wenig praktische Erfahrung mit objektorientierter Programmierung gesammelt hatte. Damals war man der Ansicht, dass einer der Hauptvorteile der objektorientierten Programmierung die Wiederverwendung von Code durch Vererbung sei. Wie in Abschnitt 10.1 dargelegt, hat die Vererbung etwas mit der auf Generalisierung bzw. Spezialisierung beruhenden Abstraktionshierarchie zu tun: Der allgemeinere Begriff (die Superklasse) überträgt (vererbt) alle seine Eigenschaften auf die spezielleren Begriffe (Subklassen), und der speziellere erbt sie von den allgemeineren. Dies liegt in der Natur der Sache. Problematisch wird es jedoch, sobald man den kausalen Zusammenhang umkehren und von einer möglichen Vererbung auf eine Generalisierung/Spezialisierung schließen will: Nur weil eine Klasse (zufällig) Eigenschaften einer anderen geerbt haben könnte, heißt das noch lange nicht, dass die erbende Klasse auch eine Spezialisierung der vererbenden ist. Ein klassisches Beispiel hierzu hatten wir bereits mit der Ableitung der Klasse Rechteck von der Klasse Quadrat kennengelernt; den unangenehmen Folgen solch vererbungsorientierter Vorgehensweisen werden wir in der nächsten Kurseinheit noch begegnen.","<answer> In den Anfängen von SMALLTALK herrschte die Ansicht vor, dass einer der Hauptvorteile der objektorientierten Programmierung die Wiederverwendung von Code durch Vererbung sei. Man glaubte, dass die Vererbung dazu diene, Code und Eigenschaften von einer allgemeineren Klasse (Superklasse) auf speziellere Klassen (Subklassen) zu übertragen, was die Wiederverwendung von Code fördert. <answer> <question> Welche Ansicht über die objektorientierte Programmierung herrschte in den Anfängen von SMALLTALK? <question>"
"SMALLTALK stammt aus einer Zeit, in der man noch relativ wenig praktische Erfahrung mit objektorientierter Programmierung gesammelt hatte. Damals war man der Ansicht, dass einer der Hauptvorteile der objektorientierten Programmierung die Wiederverwendung von Code durch Vererbung sei. Wie in Abschnitt 10.1 dargelegt, hat die Vererbung etwas mit der auf Generalisierung bzw. Spezialisierung beruhenden Abstraktionshierarchie zu tun: Der allgemeinere Begriff (die Superklasse) überträgt (vererbt) alle seine Eigenschaften auf die spezielleren Begriffe (Subklassen), und der speziellere erbt sie von den allgemeineren. Dies liegt in der Natur der Sache. Problematisch wird es jedoch, sobald man den kausalen Zusammenhang umkehren und von einer möglichen Vererbung auf eine Generalisierung/Spezialisierung schließen will: Nur weil eine Klasse (zufällig) Eigenschaften einer anderen geerbt haben könnte, heißt das noch lange nicht, dass die erbende Klasse auch eine Spezialisierung der vererbenden ist. Ein klassisches Beispiel hierzu hatten wir bereits mit der Ableitung der Klasse Rechteck von der Klasse Quadrat kennengelernt; den unangenehmen Folgen solch vererbungsorientierter Vorgehensweisen werden wir in der nächsten Kurseinheit noch begegnen.","<answer> Die Vererbung allein kann nicht als Indikator für Generalisierung und Spezialisierung dienen, da sie keinen kausalen Zusammenhang zwischen Klassen herstellt. Nur weil eine Klasse Eigenschaften von einer anderen geerbt hat, bedeutet das nicht zwangsläufig, dass die erbende Klasse eine Spezialisierung der vererbenden ist. Ein klassisches Beispiel dafür wurde bereits mit der Ableitung der Klasse ""Rechteck"" von der Klasse ""Quadrat"" gegeben. Es ist wichtig zu erkennen, dass die Vererbung nicht immer eindeutig auf eine Generalisierung/Spezialisierung hinweist und vorsichtige Analyse und Planung erfordert. In einigen Fällen kann eine zu starke Vererbung sogar zu unerwünschten Ergebnissen führen. <answer> <question> Warum kann die Vererbung allein nicht als Indikator für Generalisierung und Spezialisierung dienen? <question>"
"In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen (der Umgang mit Konstruktoren in EIFFEL unterscheidet sich erheblich von dem in SMALLTALK und auch von dem in JAVA/C#/C++; hierauf wird jedoch nicht weiter eingegangen) sowie den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat. In der Praxis kann dies lästig sein, zu sehr ausgedehnten Programmen führen und dürfte ein Grund für die geringe Akzeptanz von EIFFEL unter professionellen Programmierern sein. Trotzdem bietet EIFFEL ein Exception Handling, das sich angenehm von dem in JAVA/C#/C++ unterscheidet (insbesondere erlaubt es ein ""Retry"", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss). Auf Einzelheiten des Exception Handling in EIFFEL wird hier jedoch nicht eingegangen, da es nur begrenzt mit der Objektorientierung zu tun hat.
In EIFFEL, ähnlich wie in PASCAL, dient das Semikolon als Trennzeichen und ist kein Bestandteil einer Anweisung. Darüber hinaus kann es am Ende einer Zeile auch weggelassen werden. Kleine EIFFEL-Programme wirken daher optisch aufgeräumt, und aufgrund des Verzichts auf Blöcke außerhalb von Kontrollstrukturen - es gibt weder { ... } noch ""begin ... end"" - wirken große Programme jedoch schnell aufgebläht.","<answer> In EIFFEL gibt es Anweisungen, die aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung bestehen. <answer> <question> Welche Arten von Anweisungen gibt es in EIFFEL? <question>"
"In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen (der Umgang mit Konstruktoren in EIFFEL unterscheidet sich erheblich von dem in SMALLTALK und auch von dem in JAVA/C#/C++; hierauf wird jedoch nicht weiter eingegangen) sowie den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat. In der Praxis kann dies lästig sein, zu sehr ausgedehnten Programmen führen und dürfte ein Grund für die geringe Akzeptanz von EIFFEL unter professionellen Programmierern sein. Trotzdem bietet EIFFEL ein Exception Handling, das sich angenehm von dem in JAVA/C#/C++ unterscheidet (insbesondere erlaubt es ein ""Retry"", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss). Auf Einzelheiten des Exception Handling in EIFFEL wird hier jedoch nicht eingegangen, da es nur begrenzt mit der Objektorientierung zu tun hat.
In EIFFEL, ähnlich wie in PASCAL, dient das Semikolon als Trennzeichen und ist kein Bestandteil einer Anweisung. Darüber hinaus kann es am Ende einer Zeile auch weggelassen werden. Kleine EIFFEL-Programme wirken daher optisch aufgeräumt, und aufgrund des Verzichts auf Blöcke außerhalb von Kontrollstrukturen - es gibt weder { ... } noch ""begin ... end"" - wirken große Programme jedoch schnell aufgebläht.","<answer> EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat. <answer> <question> Welche Prinzipien der Programmierung werden von EIFFEL strikt eingehalten? <question>"
"In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen (der Umgang mit Konstruktoren in EIFFEL unterscheidet sich erheblich von dem in SMALLTALK und auch von dem in JAVA/C#/C++; hierauf wird jedoch nicht weiter eingegangen) sowie den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat. In der Praxis kann dies lästig sein, zu sehr ausgedehnten Programmen führen und dürfte ein Grund für die geringe Akzeptanz von EIFFEL unter professionellen Programmierern sein. Trotzdem bietet EIFFEL ein Exception Handling, das sich angenehm von dem in JAVA/C#/C++ unterscheidet (insbesondere erlaubt es ein ""Retry"", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss). Auf Einzelheiten des Exception Handling in EIFFEL wird hier jedoch nicht eingegangen, da es nur begrenzt mit der Objektorientierung zu tun hat.
In EIFFEL, ähnlich wie in PASCAL, dient das Semikolon als Trennzeichen und ist kein Bestandteil einer Anweisung. Darüber hinaus kann es am Ende einer Zeile auch weggelassen werden. Kleine EIFFEL-Programme wirken daher optisch aufgeräumt, und aufgrund des Verzichts auf Blöcke außerhalb von Kontrollstrukturen - es gibt weder { ... } noch ""begin ... end"" - wirken große Programme jedoch schnell aufgebläht.","<answer> EIFFEL bietet ein Exception Handling, das sich angenehm von dem in JAVA/C#/C++ unterscheidet, insbesondere erlaubt es ein ""Retry"", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss. <answer> <question> Welche Besonderheit bietet das Exception Handling in EIFFEL? <question>"
"In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen (der Umgang mit Konstruktoren in EIFFEL unterscheidet sich erheblich von dem in SMALLTALK und auch von dem in JAVA/C#/C++; hierauf wird jedoch nicht weiter eingegangen) sowie den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat. In der Praxis kann dies lästig sein, zu sehr ausgedehnten Programmen führen und dürfte ein Grund für die geringe Akzeptanz von EIFFEL unter professionellen Programmierern sein. Trotzdem bietet EIFFEL ein Exception Handling, das sich angenehm von dem in JAVA/C#/C++ unterscheidet (insbesondere erlaubt es ein ""Retry"", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss). Auf Einzelheiten des Exception Handling in EIFFEL wird hier jedoch nicht eingegangen, da es nur begrenzt mit der Objektorientierung zu tun hat.
In EIFFEL, ähnlich wie in PASCAL, dient das Semikolon als Trennzeichen und ist kein Bestandteil einer Anweisung. Darüber hinaus kann es am Ende einer Zeile auch weggelassen werden. Kleine EIFFEL-Programme wirken daher optisch aufgeräumt, und aufgrund des Verzichts auf Blöcke außerhalb von Kontrollstrukturen - es gibt weder { ... } noch ""begin ... end"" - wirken große Programme jedoch schnell aufgebläht.","<answer> In EIFFEL dient das Semikolon als Trennzeichen und ist kein Bestandteil einer Anweisung. Darüber hinaus kann es am Ende einer Zeile auch weggelassen werden, was dazu führt, dass kleine EIFFEL-Programme optisch aufgeräumt wirken. <answer> <question> Was ist die Besonderheit bezüglich der Verwendung des Semikolons in EIFFEL? <question>"
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).","<answer> Ein Literal ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. <answer> <question> Was sind Literale in der Programmierung? <question>"
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).","<answer> Der Compiler erzeugt bei der Übersetzung eines Literals das entsprechende Objekt im Speicher, während objekterzeugende Anweisungen erst zur Laufzeit des Programms ausgeführt werden. <answer> <question> Wie unterscheiden sich Literale von objekterzeugenden Anweisungen in einem Programm? <question>"
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).","<answer> Literale repräsentieren Objekte, sind jedoch selbst keine Objekte, da sie textuelle Spezifikationen von Objekten sind. <answer> <question> Warum repräsentieren Literale Objekte, aber sind selbst keine Objekte? <question>"
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).",<answer> Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten) und Zahl-Literale. <answer> <question> Was repräsentieren die einfachsten Literale in SMALLTALK? <question>
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).","<answer> Symbole sind eine weitere Art von Objekten mit literaler Repräsentation in SMALLTALK. Sie dienen dazu, sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen. Symbole dürfen im Gegensatz zu Strings keine Leerzeichen enthalten. <answer> <question> Was sind Symbole in SMALLTALK und wie unterscheiden sie sich von Strings? <question>"
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).",<answer> Bei der Verwendung identischer Symbolliterale kann es durch sogenanntes Aliasing zu unerwarteten Ergebnissen führen. <answer> <question> Welche Herausforderungen können bei der Verwendung von identischen Symbolliteralen auftreten? <question>
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).","<answer> Array-Literale repräsentieren Objekte, die aus einer Folge beliebiger anderer Objekte bestehen. <answer> <question> Was sind Array-Literale in SMALLTALK ? <question>"
"Zwar besteht jedes laufende objektorientierte Programm aus einer Menge von Objekten, jede Spezifikation eines solchen Programms besteht jedoch bei den heute gebräuchlichen klassenbasierten objektorientierten Programmiersprachen aus einer Menge von Klassen. Die strukturbildende Einheit der objektorientierten Programmierung auf Programmebene ist daher die Klasse. Größere Einheiten sind innerhalb der gängigsten objektorientierten Programmiersprachen nicht vorgesehen: JAVAs Packages und ähnliche Konstrukte sind allenfalls Namensräume und Einheiten der Auslieferung — der Status eines Sprachkonstrukts vergleichbar mit Klasse oder Methode kommt ihnen kaum zu.
Nun sind Klassen relativ feingranulare Gebilde. Zwar hindert einen nichts daran, große Klassen (mit Hunderten von Attributen und Methoden) zu schreiben, aber dies gilt nicht nur als schlechter Stil, es spiegelt auch die Anwendungsdomäne in aller Regel nicht angemessen wider. Dort sind nämlich alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Dasselbe gilt auch für die Artefakte anderer Ingenieursdisziplinen: Baupläne sind in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert. Da wünscht man sich natürlich analoge Möglichkeiten in der objektorientierten Programmierung.
Nun ist es zwar möglich, Objekte mit Hilfe der Teil-Ganzes-Beziehung rekursiv aufzubauen (und im oben diskutierten Rahmen auch zu kapseln, also Teile vollständig hinter Ganzen zu verbergen), aber für Klassen gilt das nicht. Zwar ist es hier möglich, über sogenannte innere Klassen (in JAVA) Klassen zu strukturieren, aber allein schon die Tatsache, wie relativ wenig davon Gebrauch gemacht wird, zeigt, dass es sich dabei um keinen besonders nützlichen Mechanismus handelt.93 Tatsächlich ist es nämlich — wie schon in Kapitel 58 angesprochen — so, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind (und schon gar nicht immer der gleichen Klasse), sondern vielmehr einzelne Exemplare (Instanzen) Teil sein und vielleicht sogar selbst Teile haben können. Man kann also die hierarchische Struktur objektorientierter Systeme genauso wenig auf Klassenebene vorschreiben, wie man den Aufbau einer Maschine anhand lediglich der Typen ihrer Teile (Schrauben etc.) beschreiben könnte (ohne festzulegen, wo jede einzelne Instanz genau hingehört). Was man vielmehr bräuchte, sind Komponenten als zusätzliches, von Klassen und Objekten verschiedenes Programmiersprachenkonstrukt.
Leider ist es mit der Einführung von Komponenten in objektorientierte Programmiersprachen bislang noch nicht besonders weit. Das merkt man schon daran, dass keine weit verbreitete objektorientierte Programmiersprache das Schlüsselwort ""component"" verwendet, ja nicht einmal reserviert. Stattdessen lässt man die Programmierer alles in Form von Klassen definieren und Komponenten immer zur Laufzeit, per Aggregation von Objekten, zusammenbauen. So schwache Konzepte wie Pakete (JAVA) oder Assemblies (C#) können dabei keineswegs einen Komponentenbegriff ersetzen, da sie lediglich Klassen gruppieren (und dabei auch noch ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann). Es ist meine persönliche Vermutung, dass an dieser Front in den nächsten Jahren noch der größte Fortschritt erzielt werden kann.",<answer> Auf Programmebene besteht die strukturbildende Einheit in der objektorientierten Programmierung hauptsächlich aus Klassen. <answer> <question> Welche strukturbildende Einheit wird in der objektorientierten Programmierung auf Programmebene hauptsächlich verwendet? <question>
"Zwar besteht jedes laufende objektorientierte Programm aus einer Menge von Objekten, jede Spezifikation eines solchen Programms besteht jedoch bei den heute gebräuchlichen klassenbasierten objektorientierten Programmiersprachen aus einer Menge von Klassen. Die strukturbildende Einheit der objektorientierten Programmierung auf Programmebene ist daher die Klasse. Größere Einheiten sind innerhalb der gängigsten objektorientierten Programmiersprachen nicht vorgesehen: JAVAs Packages und ähnliche Konstrukte sind allenfalls Namensräume und Einheiten der Auslieferung — der Status eines Sprachkonstrukts vergleichbar mit Klasse oder Methode kommt ihnen kaum zu.
Nun sind Klassen relativ feingranulare Gebilde. Zwar hindert einen nichts daran, große Klassen (mit Hunderten von Attributen und Methoden) zu schreiben, aber dies gilt nicht nur als schlechter Stil, es spiegelt auch die Anwendungsdomäne in aller Regel nicht angemessen wider. Dort sind nämlich alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Dasselbe gilt auch für die Artefakte anderer Ingenieursdisziplinen: Baupläne sind in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert. Da wünscht man sich natürlich analoge Möglichkeiten in der objektorientierten Programmierung.
Nun ist es zwar möglich, Objekte mit Hilfe der Teil-Ganzes-Beziehung rekursiv aufzubauen (und im oben diskutierten Rahmen auch zu kapseln, also Teile vollständig hinter Ganzen zu verbergen), aber für Klassen gilt das nicht. Zwar ist es hier möglich, über sogenannte innere Klassen (in JAVA) Klassen zu strukturieren, aber allein schon die Tatsache, wie relativ wenig davon Gebrauch gemacht wird, zeigt, dass es sich dabei um keinen besonders nützlichen Mechanismus handelt.93 Tatsächlich ist es nämlich — wie schon in Kapitel 58 angesprochen — so, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind (und schon gar nicht immer der gleichen Klasse), sondern vielmehr einzelne Exemplare (Instanzen) Teil sein und vielleicht sogar selbst Teile haben können. Man kann also die hierarchische Struktur objektorientierter Systeme genauso wenig auf Klassenebene vorschreiben, wie man den Aufbau einer Maschine anhand lediglich der Typen ihrer Teile (Schrauben etc.) beschreiben könnte (ohne festzulegen, wo jede einzelne Instanz genau hingehört). Was man vielmehr bräuchte, sind Komponenten als zusätzliches, von Klassen und Objekten verschiedenes Programmiersprachenkonstrukt.
Leider ist es mit der Einführung von Komponenten in objektorientierte Programmiersprachen bislang noch nicht besonders weit. Das merkt man schon daran, dass keine weit verbreitete objektorientierte Programmiersprache das Schlüsselwort ""component"" verwendet, ja nicht einmal reserviert. Stattdessen lässt man die Programmierer alles in Form von Klassen definieren und Komponenten immer zur Laufzeit, per Aggregation von Objekten, zusammenbauen. So schwache Konzepte wie Pakete (JAVA) oder Assemblies (C#) können dabei keineswegs einen Komponentenbegriff ersetzen, da sie lediglich Klassen gruppieren (und dabei auch noch ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann). Es ist meine persönliche Vermutung, dass an dieser Front in den nächsten Jahren noch der größte Fortschritt erzielt werden kann.","<answer> Große Klassen gelten in der Regel als schlechter Stil, da sie die Anwendungsdomäne nicht angemessen widerspiegeln. In der Anwendungsdomäne sind komplexe Dinge normalerweise aus einfacheren Teilen zusammengesetzt, die selbst wieder aus kleineren Teilen bestehen. <answer> <question> Warum werden große Klassen (mit vielen Attributen und Methoden) in der objektorientierten Programmierung in der Regel vermieden? <question>"
"Zwar besteht jedes laufende objektorientierte Programm aus einer Menge von Objekten, jede Spezifikation eines solchen Programms besteht jedoch bei den heute gebräuchlichen klassenbasierten objektorientierten Programmiersprachen aus einer Menge von Klassen. Die strukturbildende Einheit der objektorientierten Programmierung auf Programmebene ist daher die Klasse. Größere Einheiten sind innerhalb der gängigsten objektorientierten Programmiersprachen nicht vorgesehen: JAVAs Packages und ähnliche Konstrukte sind allenfalls Namensräume und Einheiten der Auslieferung — der Status eines Sprachkonstrukts vergleichbar mit Klasse oder Methode kommt ihnen kaum zu.
Nun sind Klassen relativ feingranulare Gebilde. Zwar hindert einen nichts daran, große Klassen (mit Hunderten von Attributen und Methoden) zu schreiben, aber dies gilt nicht nur als schlechter Stil, es spiegelt auch die Anwendungsdomäne in aller Regel nicht angemessen wider. Dort sind nämlich alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Dasselbe gilt auch für die Artefakte anderer Ingenieursdisziplinen: Baupläne sind in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert. Da wünscht man sich natürlich analoge Möglichkeiten in der objektorientierten Programmierung.
Nun ist es zwar möglich, Objekte mit Hilfe der Teil-Ganzes-Beziehung rekursiv aufzubauen (und im oben diskutierten Rahmen auch zu kapseln, also Teile vollständig hinter Ganzen zu verbergen), aber für Klassen gilt das nicht. Zwar ist es hier möglich, über sogenannte innere Klassen (in JAVA) Klassen zu strukturieren, aber allein schon die Tatsache, wie relativ wenig davon Gebrauch gemacht wird, zeigt, dass es sich dabei um keinen besonders nützlichen Mechanismus handelt.93 Tatsächlich ist es nämlich — wie schon in Kapitel 58 angesprochen — so, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind (und schon gar nicht immer der gleichen Klasse), sondern vielmehr einzelne Exemplare (Instanzen) Teil sein und vielleicht sogar selbst Teile haben können. Man kann also die hierarchische Struktur objektorientierter Systeme genauso wenig auf Klassenebene vorschreiben, wie man den Aufbau einer Maschine anhand lediglich der Typen ihrer Teile (Schrauben etc.) beschreiben könnte (ohne festzulegen, wo jede einzelne Instanz genau hingehört). Was man vielmehr bräuchte, sind Komponenten als zusätzliches, von Klassen und Objekten verschiedenes Programmiersprachenkonstrukt.
Leider ist es mit der Einführung von Komponenten in objektorientierte Programmiersprachen bislang noch nicht besonders weit. Das merkt man schon daran, dass keine weit verbreitete objektorientierte Programmiersprache das Schlüsselwort ""component"" verwendet, ja nicht einmal reserviert. Stattdessen lässt man die Programmierer alles in Form von Klassen definieren und Komponenten immer zur Laufzeit, per Aggregation von Objekten, zusammenbauen. So schwache Konzepte wie Pakete (JAVA) oder Assemblies (C#) können dabei keineswegs einen Komponentenbegriff ersetzen, da sie lediglich Klassen gruppieren (und dabei auch noch ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann). Es ist meine persönliche Vermutung, dass an dieser Front in den nächsten Jahren noch der größte Fortschritt erzielt werden kann.","<answer> Eine Herausforderung besteht darin, dass die hierarchische Struktur objektorientierter Systeme auf Klassenebene nicht immer vorschreibbar ist. Objekte einer Klasse sind nicht immer Teile von Objekten anderer Klassen, sondern können auch einzelne Exemplare (Instanzen) sein und selbst Teile haben können. Es fehlen Konstrukte zur Definition von Komponenten als separate strukturbildende Einheiten neben Klassen und Objekten. <answer> <question> Welche Herausforderung besteht hinsichtlich der Strukturierung von Klassen in der objektorientierten Programmierung? <question>"
"Zwar besteht jedes laufende objektorientierte Programm aus einer Menge von Objekten, jede Spezifikation eines solchen Programms besteht jedoch bei den heute gebräuchlichen klassenbasierten objektorientierten Programmiersprachen aus einer Menge von Klassen. Die strukturbildende Einheit der objektorientierten Programmierung auf Programmebene ist daher die Klasse. Größere Einheiten sind innerhalb der gängigsten objektorientierten Programmiersprachen nicht vorgesehen: JAVAs Packages und ähnliche Konstrukte sind allenfalls Namensräume und Einheiten der Auslieferung — der Status eines Sprachkonstrukts vergleichbar mit Klasse oder Methode kommt ihnen kaum zu.
Nun sind Klassen relativ feingranulare Gebilde. Zwar hindert einen nichts daran, große Klassen (mit Hunderten von Attributen und Methoden) zu schreiben, aber dies gilt nicht nur als schlechter Stil, es spiegelt auch die Anwendungsdomäne in aller Regel nicht angemessen wider. Dort sind nämlich alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Dasselbe gilt auch für die Artefakte anderer Ingenieursdisziplinen: Baupläne sind in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert. Da wünscht man sich natürlich analoge Möglichkeiten in der objektorientierten Programmierung.
Nun ist es zwar möglich, Objekte mit Hilfe der Teil-Ganzes-Beziehung rekursiv aufzubauen (und im oben diskutierten Rahmen auch zu kapseln, also Teile vollständig hinter Ganzen zu verbergen), aber für Klassen gilt das nicht. Zwar ist es hier möglich, über sogenannte innere Klassen (in JAVA) Klassen zu strukturieren, aber allein schon die Tatsache, wie relativ wenig davon Gebrauch gemacht wird, zeigt, dass es sich dabei um keinen besonders nützlichen Mechanismus handelt.93 Tatsächlich ist es nämlich — wie schon in Kapitel 58 angesprochen — so, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind (und schon gar nicht immer der gleichen Klasse), sondern vielmehr einzelne Exemplare (Instanzen) Teil sein und vielleicht sogar selbst Teile haben können. Man kann also die hierarchische Struktur objektorientierter Systeme genauso wenig auf Klassenebene vorschreiben, wie man den Aufbau einer Maschine anhand lediglich der Typen ihrer Teile (Schrauben etc.) beschreiben könnte (ohne festzulegen, wo jede einzelne Instanz genau hingehört). Was man vielmehr bräuchte, sind Komponenten als zusätzliches, von Klassen und Objekten verschiedenes Programmiersprachenkonstrukt.
Leider ist es mit der Einführung von Komponenten in objektorientierte Programmiersprachen bislang noch nicht besonders weit. Das merkt man schon daran, dass keine weit verbreitete objektorientierte Programmiersprache das Schlüsselwort ""component"" verwendet, ja nicht einmal reserviert. Stattdessen lässt man die Programmierer alles in Form von Klassen definieren und Komponenten immer zur Laufzeit, per Aggregation von Objekten, zusammenbauen. So schwache Konzepte wie Pakete (JAVA) oder Assemblies (C#) können dabei keineswegs einen Komponentenbegriff ersetzen, da sie lediglich Klassen gruppieren (und dabei auch noch ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann). Es ist meine persönliche Vermutung, dass an dieser Front in den nächsten Jahren noch der größte Fortschritt erzielt werden kann.","<answer> Innere Klassen in JAVA können Klassen strukturieren, aber sie werden relativ wenig verwendet, da sie sich nicht als besonders nützlich erweisen. Objekte einer Klasse sind nicht immer Teile von Objekten anderer Klassen, daher ist die hierarchische Struktur auf Klassenebene nicht immer passend. <answer> <question> Warum sind innere Klassen (in JAVA) allein keine ausreichende Lösung für die Strukturierung von Klassen? <question>"
"Zwar besteht jedes laufende objektorientierte Programm aus einer Menge von Objekten, jede Spezifikation eines solchen Programms besteht jedoch bei den heute gebräuchlichen klassenbasierten objektorientierten Programmiersprachen aus einer Menge von Klassen. Die strukturbildende Einheit der objektorientierten Programmierung auf Programmebene ist daher die Klasse. Größere Einheiten sind innerhalb der gängigsten objektorientierten Programmiersprachen nicht vorgesehen: JAVAs Packages und ähnliche Konstrukte sind allenfalls Namensräume und Einheiten der Auslieferung — der Status eines Sprachkonstrukts vergleichbar mit Klasse oder Methode kommt ihnen kaum zu.
Nun sind Klassen relativ feingranulare Gebilde. Zwar hindert einen nichts daran, große Klassen (mit Hunderten von Attributen und Methoden) zu schreiben, aber dies gilt nicht nur als schlechter Stil, es spiegelt auch die Anwendungsdomäne in aller Regel nicht angemessen wider. Dort sind nämlich alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Dasselbe gilt auch für die Artefakte anderer Ingenieursdisziplinen: Baupläne sind in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert. Da wünscht man sich natürlich analoge Möglichkeiten in der objektorientierten Programmierung.
Nun ist es zwar möglich, Objekte mit Hilfe der Teil-Ganzes-Beziehung rekursiv aufzubauen (und im oben diskutierten Rahmen auch zu kapseln, also Teile vollständig hinter Ganzen zu verbergen), aber für Klassen gilt das nicht. Zwar ist es hier möglich, über sogenannte innere Klassen (in JAVA) Klassen zu strukturieren, aber allein schon die Tatsache, wie relativ wenig davon Gebrauch gemacht wird, zeigt, dass es sich dabei um keinen besonders nützlichen Mechanismus handelt.93 Tatsächlich ist es nämlich — wie schon in Kapitel 58 angesprochen — so, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind (und schon gar nicht immer der gleichen Klasse), sondern vielmehr einzelne Exemplare (Instanzen) Teil sein und vielleicht sogar selbst Teile haben können. Man kann also die hierarchische Struktur objektorientierter Systeme genauso wenig auf Klassenebene vorschreiben, wie man den Aufbau einer Maschine anhand lediglich der Typen ihrer Teile (Schrauben etc.) beschreiben könnte (ohne festzulegen, wo jede einzelne Instanz genau hingehört). Was man vielmehr bräuchte, sind Komponenten als zusätzliches, von Klassen und Objekten verschiedenes Programmiersprachenkonstrukt.
Leider ist es mit der Einführung von Komponenten in objektorientierte Programmiersprachen bislang noch nicht besonders weit. Das merkt man schon daran, dass keine weit verbreitete objektorientierte Programmiersprache das Schlüsselwort ""component"" verwendet, ja nicht einmal reserviert. Stattdessen lässt man die Programmierer alles in Form von Klassen definieren und Komponenten immer zur Laufzeit, per Aggregation von Objekten, zusammenbauen. So schwache Konzepte wie Pakete (JAVA) oder Assemblies (C#) können dabei keineswegs einen Komponentenbegriff ersetzen, da sie lediglich Klassen gruppieren (und dabei auch noch ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann). Es ist meine persönliche Vermutung, dass an dieser Front in den nächsten Jahren noch der größte Fortschritt erzielt werden kann.","<answer> Pakete (JAVA) oder Assemblies (C#) gruppieren lediglich Klassen und berücksichtigen nicht, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann. Sie können den Begriff der Komponente daher nicht vollständig ersetzen. <answer> <question> Warum können Konzepte wie Pakete (JAVA) oder Assemblies (C#) den Begriff der Komponente nicht ersetzen? <question>"
"Ausdrücke allein sind lediglich syntaktische Elemente; um das Objekt zu erhalten, für das sie stehen, müssen sie ausgewertet werden. Die Auswertung ist der Prozess, bei dem ein Programm tatsächlich ""etwas tut"".
Eine der grundlegendsten Aktionen, die ein Programm durchführen kann, ist die Auswertung einer Zuweisung, wie zum Beispiel y := x. Diese Auswertung bewirkt, dass die Variable y nach der Zuweisung auf dasselbe Objekt verweist wie zuvor x. Dabei steht der gesamte Ausdruck y := x für (eine Referenz auf) das Objekt, auf das x (und nach seiner Auswertung auch y) verweist. Die Zuweisung dieses Objektes an y ist eine Art Seiteneffekt der Auswertung des Ausdrucks.
Es ist wichtig zu beachten, dass der Zuweisungsoperator := keinen (binären) Nachrichtenselektor darstellt. Hier wird keine Nachricht an ein Objekt gesendet, sondern der Inhalt einer Variable wird verändert. Die Zuweisung ist tatsächlich eine der wenigen Primitiven in SMALLTALK und gehört zu den fest in die Sprache integrierten Operationen (siehe Abschnitt 1.6).
Die Verwendung des Begriffs ""Seiteneffekt"" ist möglicherweise nicht notwendig, wenn ""Wirkung"" oder ""Effekt"" verwendet wird, da der erzielte Effekt das Hauptziel einer Zuweisung ist.
Nachrichtenausdrücke werden ausgewertet, indem die Nachricht (das Prädikat des Satzes) an das Empfängerobjekt (das Subjekt) mit den Parametern (den Prädikatsergänzungen) gesendet wird, und das Empfängerobjekt liefert als Ergebnis der Nachricht ein Objekt zurück. Die genauen Mechanismen zur Bestimmung des Ergebnisobjekts durch das Empfängerobjekt werden später erläutert. Hier ist nur wichtig zu wissen, dass der Nachrichtenausdruck während der Auswertung praktisch durch das Objekt ersetzt wird, für das er steht. Dies kann ähnlich betrachtet werden wie die Auswertung einer (mathematischen) Funktion f, deren Funktionsanwendung f(x) für den Funktionswert steht.
Eine häufig verwendete unäre Nachricht, die von allen Objekten verstanden wird, ist printString. In Reaktion darauf gibt das Empfängerobjekt normalerweise eine textuelle Repräsentation von sich zurück.
In SMALLTALK, anders als in Sprachen wie JAVA oder C#, bei denen Methoden mit dem Rückgabetyp ""void"" deklariert werden können, ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben. Dies könnte in Zeile 70 als sinnvoll angesehen werden, da dort lediglich an dem (Seiten-)Effekt, der Ausgabe von „12“ auf dem Transcript, interessiert ist. Wenn die Methode, die zur Nachricht gehört, keinen sinnvollen Rückgabewert hat, wird standardmäßig immer das Empfängerobjekt zurückgegeben. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API. Wenn der Rückgabewert des Nachrichtenausdrucks im Kontext der Nachricht keine Verwendung findet, verfällt er einfach. Die Existenz des Objekts wird jedoch nur dann beeinflusst, wenn es keine weiteren Referenzen auf das Objekt gibt und es bei der nächsten Speicherbereinigung entfernt wird.
Die Auswertung eines Nachrichtenausdrucks führt zur Ausführung der Anweisungen im Rumpf einer Methode, weshalb sie auch als Methodenaufruf bezeichnet wird. Die Legitimität dieser Bezeichnung wird jedoch erst in Abschnitt 4.3 vollständig erklärt.
Zusammenfassend lässt sich sagen, dass: Ein Literal zu dem Objekt ausgewertet wird, das es repräsentiert. Eine Variable zu dem Objekt ausgewertet wird, das sie benennt. Eine Zuweisung zu dem Objekt ausgewertet wird, zu dem der Ausdruck auf der rechten Seite der Zuweisung ausgewertet wird. Ein Nachrichtenausdruck zu dem Objekt ausgewertet wird, das als Antwort auf die Nachricht zurückgegeben wird. Ein kaskadierter Nachrichtenausdruck zu dem Objekt ausgewertet wird, zu dem sein letzter Nachrichtenausdruck ausgewertet wird.","<answer> Die Auswertung von Ausdrücken ist der Prozess, bei dem ein Programm tatsächlich Aktionen ausführt. Sie ist wichtig, weil sie den eigentlichen ""Tätigkeitsprozess"" eines Programms darstellt und sicherstellt, dass die gewünschten Operationen durchgeführt werden. <answer> <question> Was ist die Auswertung von Ausdrücken in der objektorientierten Programmierung, und warum ist sie wichtig? <question>"
"Ausdrücke allein sind lediglich syntaktische Elemente; um das Objekt zu erhalten, für das sie stehen, müssen sie ausgewertet werden. Die Auswertung ist der Prozess, bei dem ein Programm tatsächlich ""etwas tut"".
Eine der grundlegendsten Aktionen, die ein Programm durchführen kann, ist die Auswertung einer Zuweisung, wie zum Beispiel y := x. Diese Auswertung bewirkt, dass die Variable y nach der Zuweisung auf dasselbe Objekt verweist wie zuvor x. Dabei steht der gesamte Ausdruck y := x für (eine Referenz auf) das Objekt, auf das x (und nach seiner Auswertung auch y) verweist. Die Zuweisung dieses Objektes an y ist eine Art Seiteneffekt der Auswertung des Ausdrucks.
Es ist wichtig zu beachten, dass der Zuweisungsoperator := keinen (binären) Nachrichtenselektor darstellt. Hier wird keine Nachricht an ein Objekt gesendet, sondern der Inhalt einer Variable wird verändert. Die Zuweisung ist tatsächlich eine der wenigen Primitiven in SMALLTALK und gehört zu den fest in die Sprache integrierten Operationen (siehe Abschnitt 1.6).
Die Verwendung des Begriffs ""Seiteneffekt"" ist möglicherweise nicht notwendig, wenn ""Wirkung"" oder ""Effekt"" verwendet wird, da der erzielte Effekt das Hauptziel einer Zuweisung ist.
Nachrichtenausdrücke werden ausgewertet, indem die Nachricht (das Prädikat des Satzes) an das Empfängerobjekt (das Subjekt) mit den Parametern (den Prädikatsergänzungen) gesendet wird, und das Empfängerobjekt liefert als Ergebnis der Nachricht ein Objekt zurück. Die genauen Mechanismen zur Bestimmung des Ergebnisobjekts durch das Empfängerobjekt werden später erläutert. Hier ist nur wichtig zu wissen, dass der Nachrichtenausdruck während der Auswertung praktisch durch das Objekt ersetzt wird, für das er steht. Dies kann ähnlich betrachtet werden wie die Auswertung einer (mathematischen) Funktion f, deren Funktionsanwendung f(x) für den Funktionswert steht.
Eine häufig verwendete unäre Nachricht, die von allen Objekten verstanden wird, ist printString. In Reaktion darauf gibt das Empfängerobjekt normalerweise eine textuelle Repräsentation von sich zurück.
In SMALLTALK, anders als in Sprachen wie JAVA oder C#, bei denen Methoden mit dem Rückgabetyp ""void"" deklariert werden können, ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben. Dies könnte in Zeile 70 als sinnvoll angesehen werden, da dort lediglich an dem (Seiten-)Effekt, der Ausgabe von „12“ auf dem Transcript, interessiert ist. Wenn die Methode, die zur Nachricht gehört, keinen sinnvollen Rückgabewert hat, wird standardmäßig immer das Empfängerobjekt zurückgegeben. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API. Wenn der Rückgabewert des Nachrichtenausdrucks im Kontext der Nachricht keine Verwendung findet, verfällt er einfach. Die Existenz des Objekts wird jedoch nur dann beeinflusst, wenn es keine weiteren Referenzen auf das Objekt gibt und es bei der nächsten Speicherbereinigung entfernt wird.
Die Auswertung eines Nachrichtenausdrucks führt zur Ausführung der Anweisungen im Rumpf einer Methode, weshalb sie auch als Methodenaufruf bezeichnet wird. Die Legitimität dieser Bezeichnung wird jedoch erst in Abschnitt 4.3 vollständig erklärt.
Zusammenfassend lässt sich sagen, dass: Ein Literal zu dem Objekt ausgewertet wird, das es repräsentiert. Eine Variable zu dem Objekt ausgewertet wird, das sie benennt. Eine Zuweisung zu dem Objekt ausgewertet wird, zu dem der Ausdruck auf der rechten Seite der Zuweisung ausgewertet wird. Ein Nachrichtenausdruck zu dem Objekt ausgewertet wird, das als Antwort auf die Nachricht zurückgegeben wird. Ein kaskadierter Nachrichtenausdruck zu dem Objekt ausgewertet wird, zu dem sein letzter Nachrichtenausdruck ausgewertet wird.","<answer> Eine Zuweisung ist eine Aktion, bei der der Inhalt einer Variable geändert wird. Die Auswertung einer Zuweisung, wie z.B. y := x, bewirkt, dass die Variable y auf dasselbe Objekt verweist wie x. Die Zuweisung selbst steht für (eine Referenz auf) das Objekt, auf das x und nach seiner Auswertung auch y verweisen. Dies ist eine Art von Seiteneffekt der Auswertung des Ausdrucks. <answer> <question> Was ist eine Zuweisung, und wie wirkt sich die Auswertung einer Zuweisung auf Variablen aus? <question>"
"Ausdrücke allein sind lediglich syntaktische Elemente; um das Objekt zu erhalten, für das sie stehen, müssen sie ausgewertet werden. Die Auswertung ist der Prozess, bei dem ein Programm tatsächlich ""etwas tut"".
Eine der grundlegendsten Aktionen, die ein Programm durchführen kann, ist die Auswertung einer Zuweisung, wie zum Beispiel y := x. Diese Auswertung bewirkt, dass die Variable y nach der Zuweisung auf dasselbe Objekt verweist wie zuvor x. Dabei steht der gesamte Ausdruck y := x für (eine Referenz auf) das Objekt, auf das x (und nach seiner Auswertung auch y) verweist. Die Zuweisung dieses Objektes an y ist eine Art Seiteneffekt der Auswertung des Ausdrucks.
Es ist wichtig zu beachten, dass der Zuweisungsoperator := keinen (binären) Nachrichtenselektor darstellt. Hier wird keine Nachricht an ein Objekt gesendet, sondern der Inhalt einer Variable wird verändert. Die Zuweisung ist tatsächlich eine der wenigen Primitiven in SMALLTALK und gehört zu den fest in die Sprache integrierten Operationen (siehe Abschnitt 1.6).
Die Verwendung des Begriffs ""Seiteneffekt"" ist möglicherweise nicht notwendig, wenn ""Wirkung"" oder ""Effekt"" verwendet wird, da der erzielte Effekt das Hauptziel einer Zuweisung ist.
Nachrichtenausdrücke werden ausgewertet, indem die Nachricht (das Prädikat des Satzes) an das Empfängerobjekt (das Subjekt) mit den Parametern (den Prädikatsergänzungen) gesendet wird, und das Empfängerobjekt liefert als Ergebnis der Nachricht ein Objekt zurück. Die genauen Mechanismen zur Bestimmung des Ergebnisobjekts durch das Empfängerobjekt werden später erläutert. Hier ist nur wichtig zu wissen, dass der Nachrichtenausdruck während der Auswertung praktisch durch das Objekt ersetzt wird, für das er steht. Dies kann ähnlich betrachtet werden wie die Auswertung einer (mathematischen) Funktion f, deren Funktionsanwendung f(x) für den Funktionswert steht.
Eine häufig verwendete unäre Nachricht, die von allen Objekten verstanden wird, ist printString. In Reaktion darauf gibt das Empfängerobjekt normalerweise eine textuelle Repräsentation von sich zurück.
In SMALLTALK, anders als in Sprachen wie JAVA oder C#, bei denen Methoden mit dem Rückgabetyp ""void"" deklariert werden können, ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben. Dies könnte in Zeile 70 als sinnvoll angesehen werden, da dort lediglich an dem (Seiten-)Effekt, der Ausgabe von „12“ auf dem Transcript, interessiert ist. Wenn die Methode, die zur Nachricht gehört, keinen sinnvollen Rückgabewert hat, wird standardmäßig immer das Empfängerobjekt zurückgegeben. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API. Wenn der Rückgabewert des Nachrichtenausdrucks im Kontext der Nachricht keine Verwendung findet, verfällt er einfach. Die Existenz des Objekts wird jedoch nur dann beeinflusst, wenn es keine weiteren Referenzen auf das Objekt gibt und es bei der nächsten Speicherbereinigung entfernt wird.
Die Auswertung eines Nachrichtenausdrucks führt zur Ausführung der Anweisungen im Rumpf einer Methode, weshalb sie auch als Methodenaufruf bezeichnet wird. Die Legitimität dieser Bezeichnung wird jedoch erst in Abschnitt 4.3 vollständig erklärt.
Zusammenfassend lässt sich sagen, dass: Ein Literal zu dem Objekt ausgewertet wird, das es repräsentiert. Eine Variable zu dem Objekt ausgewertet wird, das sie benennt. Eine Zuweisung zu dem Objekt ausgewertet wird, zu dem der Ausdruck auf der rechten Seite der Zuweisung ausgewertet wird. Ein Nachrichtenausdruck zu dem Objekt ausgewertet wird, das als Antwort auf die Nachricht zurückgegeben wird. Ein kaskadierter Nachrichtenausdruck zu dem Objekt ausgewertet wird, zu dem sein letzter Nachrichtenausdruck ausgewertet wird.","<answer> Der Zuweisungsoperator := stellt keinen (binären) Nachrichtenselektor dar. Hier wird keine Nachricht an ein Objekt gesendet, sondern der Inhalt einer Variable wird verändert. Die Zuweisung ist eine grundlegende Operation in SMALLTALK und fest in die Sprache integriert. <answer> <question> Warum wird der Zuweisungsoperator := nicht als (binärer) Nachrichtenselektor betrachtet? <question>"
"Ausdrücke allein sind lediglich syntaktische Elemente; um das Objekt zu erhalten, für das sie stehen, müssen sie ausgewertet werden. Die Auswertung ist der Prozess, bei dem ein Programm tatsächlich ""etwas tut"".
Eine der grundlegendsten Aktionen, die ein Programm durchführen kann, ist die Auswertung einer Zuweisung, wie zum Beispiel y := x. Diese Auswertung bewirkt, dass die Variable y nach der Zuweisung auf dasselbe Objekt verweist wie zuvor x. Dabei steht der gesamte Ausdruck y := x für (eine Referenz auf) das Objekt, auf das x (und nach seiner Auswertung auch y) verweist. Die Zuweisung dieses Objektes an y ist eine Art Seiteneffekt der Auswertung des Ausdrucks.
Es ist wichtig zu beachten, dass der Zuweisungsoperator := keinen (binären) Nachrichtenselektor darstellt. Hier wird keine Nachricht an ein Objekt gesendet, sondern der Inhalt einer Variable wird verändert. Die Zuweisung ist tatsächlich eine der wenigen Primitiven in SMALLTALK und gehört zu den fest in die Sprache integrierten Operationen (siehe Abschnitt 1.6).
Die Verwendung des Begriffs ""Seiteneffekt"" ist möglicherweise nicht notwendig, wenn ""Wirkung"" oder ""Effekt"" verwendet wird, da der erzielte Effekt das Hauptziel einer Zuweisung ist.
Nachrichtenausdrücke werden ausgewertet, indem die Nachricht (das Prädikat des Satzes) an das Empfängerobjekt (das Subjekt) mit den Parametern (den Prädikatsergänzungen) gesendet wird, und das Empfängerobjekt liefert als Ergebnis der Nachricht ein Objekt zurück. Die genauen Mechanismen zur Bestimmung des Ergebnisobjekts durch das Empfängerobjekt werden später erläutert. Hier ist nur wichtig zu wissen, dass der Nachrichtenausdruck während der Auswertung praktisch durch das Objekt ersetzt wird, für das er steht. Dies kann ähnlich betrachtet werden wie die Auswertung einer (mathematischen) Funktion f, deren Funktionsanwendung f(x) für den Funktionswert steht.
Eine häufig verwendete unäre Nachricht, die von allen Objekten verstanden wird, ist printString. In Reaktion darauf gibt das Empfängerobjekt normalerweise eine textuelle Repräsentation von sich zurück.
In SMALLTALK, anders als in Sprachen wie JAVA oder C#, bei denen Methoden mit dem Rückgabetyp ""void"" deklariert werden können, ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben. Dies könnte in Zeile 70 als sinnvoll angesehen werden, da dort lediglich an dem (Seiten-)Effekt, der Ausgabe von „12“ auf dem Transcript, interessiert ist. Wenn die Methode, die zur Nachricht gehört, keinen sinnvollen Rückgabewert hat, wird standardmäßig immer das Empfängerobjekt zurückgegeben. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API. Wenn der Rückgabewert des Nachrichtenausdrucks im Kontext der Nachricht keine Verwendung findet, verfällt er einfach. Die Existenz des Objekts wird jedoch nur dann beeinflusst, wenn es keine weiteren Referenzen auf das Objekt gibt und es bei der nächsten Speicherbereinigung entfernt wird.
Die Auswertung eines Nachrichtenausdrucks führt zur Ausführung der Anweisungen im Rumpf einer Methode, weshalb sie auch als Methodenaufruf bezeichnet wird. Die Legitimität dieser Bezeichnung wird jedoch erst in Abschnitt 4.3 vollständig erklärt.
Zusammenfassend lässt sich sagen, dass: Ein Literal zu dem Objekt ausgewertet wird, das es repräsentiert. Eine Variable zu dem Objekt ausgewertet wird, das sie benennt. Eine Zuweisung zu dem Objekt ausgewertet wird, zu dem der Ausdruck auf der rechten Seite der Zuweisung ausgewertet wird. Ein Nachrichtenausdruck zu dem Objekt ausgewertet wird, das als Antwort auf die Nachricht zurückgegeben wird. Ein kaskadierter Nachrichtenausdruck zu dem Objekt ausgewertet wird, zu dem sein letzter Nachrichtenausdruck ausgewertet wird.",<answer> Die Zuweisung und Nachrichtenausdrücke werden in SMALLTALK als Primitiven betrachtet. <answer> <question> Welche Ausdrücke werden in SMALLTALK als Primitiven betrachtet? <question>
"Ausdrücke allein sind lediglich syntaktische Elemente; um das Objekt zu erhalten, für das sie stehen, müssen sie ausgewertet werden. Die Auswertung ist der Prozess, bei dem ein Programm tatsächlich ""etwas tut"".
Eine der grundlegendsten Aktionen, die ein Programm durchführen kann, ist die Auswertung einer Zuweisung, wie zum Beispiel y := x. Diese Auswertung bewirkt, dass die Variable y nach der Zuweisung auf dasselbe Objekt verweist wie zuvor x. Dabei steht der gesamte Ausdruck y := x für (eine Referenz auf) das Objekt, auf das x (und nach seiner Auswertung auch y) verweist. Die Zuweisung dieses Objektes an y ist eine Art Seiteneffekt der Auswertung des Ausdrucks.
Es ist wichtig zu beachten, dass der Zuweisungsoperator := keinen (binären) Nachrichtenselektor darstellt. Hier wird keine Nachricht an ein Objekt gesendet, sondern der Inhalt einer Variable wird verändert. Die Zuweisung ist tatsächlich eine der wenigen Primitiven in SMALLTALK und gehört zu den fest in die Sprache integrierten Operationen (siehe Abschnitt 1.6).
Die Verwendung des Begriffs ""Seiteneffekt"" ist möglicherweise nicht notwendig, wenn ""Wirkung"" oder ""Effekt"" verwendet wird, da der erzielte Effekt das Hauptziel einer Zuweisung ist.
Nachrichtenausdrücke werden ausgewertet, indem die Nachricht (das Prädikat des Satzes) an das Empfängerobjekt (das Subjekt) mit den Parametern (den Prädikatsergänzungen) gesendet wird, und das Empfängerobjekt liefert als Ergebnis der Nachricht ein Objekt zurück. Die genauen Mechanismen zur Bestimmung des Ergebnisobjekts durch das Empfängerobjekt werden später erläutert. Hier ist nur wichtig zu wissen, dass der Nachrichtenausdruck während der Auswertung praktisch durch das Objekt ersetzt wird, für das er steht. Dies kann ähnlich betrachtet werden wie die Auswertung einer (mathematischen) Funktion f, deren Funktionsanwendung f(x) für den Funktionswert steht.
Eine häufig verwendete unäre Nachricht, die von allen Objekten verstanden wird, ist printString. In Reaktion darauf gibt das Empfängerobjekt normalerweise eine textuelle Repräsentation von sich zurück.
In SMALLTALK, anders als in Sprachen wie JAVA oder C#, bei denen Methoden mit dem Rückgabetyp ""void"" deklariert werden können, ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben. Dies könnte in Zeile 70 als sinnvoll angesehen werden, da dort lediglich an dem (Seiten-)Effekt, der Ausgabe von „12“ auf dem Transcript, interessiert ist. Wenn die Methode, die zur Nachricht gehört, keinen sinnvollen Rückgabewert hat, wird standardmäßig immer das Empfängerobjekt zurückgegeben. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API. Wenn der Rückgabewert des Nachrichtenausdrucks im Kontext der Nachricht keine Verwendung findet, verfällt er einfach. Die Existenz des Objekts wird jedoch nur dann beeinflusst, wenn es keine weiteren Referenzen auf das Objekt gibt und es bei der nächsten Speicherbereinigung entfernt wird.
Die Auswertung eines Nachrichtenausdrucks führt zur Ausführung der Anweisungen im Rumpf einer Methode, weshalb sie auch als Methodenaufruf bezeichnet wird. Die Legitimität dieser Bezeichnung wird jedoch erst in Abschnitt 4.3 vollständig erklärt.
Zusammenfassend lässt sich sagen, dass: Ein Literal zu dem Objekt ausgewertet wird, das es repräsentiert. Eine Variable zu dem Objekt ausgewertet wird, das sie benennt. Eine Zuweisung zu dem Objekt ausgewertet wird, zu dem der Ausdruck auf der rechten Seite der Zuweisung ausgewertet wird. Ein Nachrichtenausdruck zu dem Objekt ausgewertet wird, das als Antwort auf die Nachricht zurückgegeben wird. Ein kaskadierter Nachrichtenausdruck zu dem Objekt ausgewertet wird, zu dem sein letzter Nachrichtenausdruck ausgewertet wird.","<answer> Nachrichtenausdrücke in SMALLTALK werden ausgewertet, indem die Nachricht (das Prädikat) an das Empfängerobjekt (das Subjekt) mit den Parametern (Prädikatsergänzungen) gesendet wird. Nach der Auswertung repräsentiert der Nachrichtenausdruck das Ergebnis der Nachricht, das von dem Empfängerobjekt zurückgegeben wird. <answer> <question> Wie werden Nachrichtenausdrücke in SMALLTALK ausgewertet, und was repräsentieren sie nach der Auswertung? <question>"
"Ausdrücke allein sind lediglich syntaktische Elemente; um das Objekt zu erhalten, für das sie stehen, müssen sie ausgewertet werden. Die Auswertung ist der Prozess, bei dem ein Programm tatsächlich ""etwas tut"".
Eine der grundlegendsten Aktionen, die ein Programm durchführen kann, ist die Auswertung einer Zuweisung, wie zum Beispiel y := x. Diese Auswertung bewirkt, dass die Variable y nach der Zuweisung auf dasselbe Objekt verweist wie zuvor x. Dabei steht der gesamte Ausdruck y := x für (eine Referenz auf) das Objekt, auf das x (und nach seiner Auswertung auch y) verweist. Die Zuweisung dieses Objektes an y ist eine Art Seiteneffekt der Auswertung des Ausdrucks.
Es ist wichtig zu beachten, dass der Zuweisungsoperator := keinen (binären) Nachrichtenselektor darstellt. Hier wird keine Nachricht an ein Objekt gesendet, sondern der Inhalt einer Variable wird verändert. Die Zuweisung ist tatsächlich eine der wenigen Primitiven in SMALLTALK und gehört zu den fest in die Sprache integrierten Operationen (siehe Abschnitt 1.6).
Die Verwendung des Begriffs ""Seiteneffekt"" ist möglicherweise nicht notwendig, wenn ""Wirkung"" oder ""Effekt"" verwendet wird, da der erzielte Effekt das Hauptziel einer Zuweisung ist.
Nachrichtenausdrücke werden ausgewertet, indem die Nachricht (das Prädikat des Satzes) an das Empfängerobjekt (das Subjekt) mit den Parametern (den Prädikatsergänzungen) gesendet wird, und das Empfängerobjekt liefert als Ergebnis der Nachricht ein Objekt zurück. Die genauen Mechanismen zur Bestimmung des Ergebnisobjekts durch das Empfängerobjekt werden später erläutert. Hier ist nur wichtig zu wissen, dass der Nachrichtenausdruck während der Auswertung praktisch durch das Objekt ersetzt wird, für das er steht. Dies kann ähnlich betrachtet werden wie die Auswertung einer (mathematischen) Funktion f, deren Funktionsanwendung f(x) für den Funktionswert steht.
Eine häufig verwendete unäre Nachricht, die von allen Objekten verstanden wird, ist printString. In Reaktion darauf gibt das Empfängerobjekt normalerweise eine textuelle Repräsentation von sich zurück.
In SMALLTALK, anders als in Sprachen wie JAVA oder C#, bei denen Methoden mit dem Rückgabetyp ""void"" deklariert werden können, ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben. Dies könnte in Zeile 70 als sinnvoll angesehen werden, da dort lediglich an dem (Seiten-)Effekt, der Ausgabe von „12“ auf dem Transcript, interessiert ist. Wenn die Methode, die zur Nachricht gehört, keinen sinnvollen Rückgabewert hat, wird standardmäßig immer das Empfängerobjekt zurückgegeben. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API. Wenn der Rückgabewert des Nachrichtenausdrucks im Kontext der Nachricht keine Verwendung findet, verfällt er einfach. Die Existenz des Objekts wird jedoch nur dann beeinflusst, wenn es keine weiteren Referenzen auf das Objekt gibt und es bei der nächsten Speicherbereinigung entfernt wird.
Die Auswertung eines Nachrichtenausdrucks führt zur Ausführung der Anweisungen im Rumpf einer Methode, weshalb sie auch als Methodenaufruf bezeichnet wird. Die Legitimität dieser Bezeichnung wird jedoch erst in Abschnitt 4.3 vollständig erklärt.
Zusammenfassend lässt sich sagen, dass: Ein Literal zu dem Objekt ausgewertet wird, das es repräsentiert. Eine Variable zu dem Objekt ausgewertet wird, das sie benennt. Eine Zuweisung zu dem Objekt ausgewertet wird, zu dem der Ausdruck auf der rechten Seite der Zuweisung ausgewertet wird. Ein Nachrichtenausdruck zu dem Objekt ausgewertet wird, das als Antwort auf die Nachricht zurückgegeben wird. Ein kaskadierter Nachrichtenausdruck zu dem Objekt ausgewertet wird, zu dem sein letzter Nachrichtenausdruck ausgewertet wird.","<answer> In SMALLTALK ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben, da jeder Nachrichtenversand ein Ergebnis zurückgibt. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API (fließende Programmierung). <answer> <question> Warum ist es in SMALLTALK nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben? <question>"
"Ausdrücke allein sind lediglich syntaktische Elemente; um das Objekt zu erhalten, für das sie stehen, müssen sie ausgewertet werden. Die Auswertung ist der Prozess, bei dem ein Programm tatsächlich ""etwas tut"".
Eine der grundlegendsten Aktionen, die ein Programm durchführen kann, ist die Auswertung einer Zuweisung, wie zum Beispiel y := x. Diese Auswertung bewirkt, dass die Variable y nach der Zuweisung auf dasselbe Objekt verweist wie zuvor x. Dabei steht der gesamte Ausdruck y := x für (eine Referenz auf) das Objekt, auf das x (und nach seiner Auswertung auch y) verweist. Die Zuweisung dieses Objektes an y ist eine Art Seiteneffekt der Auswertung des Ausdrucks.
Es ist wichtig zu beachten, dass der Zuweisungsoperator := keinen (binären) Nachrichtenselektor darstellt. Hier wird keine Nachricht an ein Objekt gesendet, sondern der Inhalt einer Variable wird verändert. Die Zuweisung ist tatsächlich eine der wenigen Primitiven in SMALLTALK und gehört zu den fest in die Sprache integrierten Operationen (siehe Abschnitt 1.6).
Die Verwendung des Begriffs ""Seiteneffekt"" ist möglicherweise nicht notwendig, wenn ""Wirkung"" oder ""Effekt"" verwendet wird, da der erzielte Effekt das Hauptziel einer Zuweisung ist.
Nachrichtenausdrücke werden ausgewertet, indem die Nachricht (das Prädikat des Satzes) an das Empfängerobjekt (das Subjekt) mit den Parametern (den Prädikatsergänzungen) gesendet wird, und das Empfängerobjekt liefert als Ergebnis der Nachricht ein Objekt zurück. Die genauen Mechanismen zur Bestimmung des Ergebnisobjekts durch das Empfängerobjekt werden später erläutert. Hier ist nur wichtig zu wissen, dass der Nachrichtenausdruck während der Auswertung praktisch durch das Objekt ersetzt wird, für das er steht. Dies kann ähnlich betrachtet werden wie die Auswertung einer (mathematischen) Funktion f, deren Funktionsanwendung f(x) für den Funktionswert steht.
Eine häufig verwendete unäre Nachricht, die von allen Objekten verstanden wird, ist printString. In Reaktion darauf gibt das Empfängerobjekt normalerweise eine textuelle Repräsentation von sich zurück.
In SMALLTALK, anders als in Sprachen wie JAVA oder C#, bei denen Methoden mit dem Rückgabetyp ""void"" deklariert werden können, ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben. Dies könnte in Zeile 70 als sinnvoll angesehen werden, da dort lediglich an dem (Seiten-)Effekt, der Ausgabe von „12“ auf dem Transcript, interessiert ist. Wenn die Methode, die zur Nachricht gehört, keinen sinnvollen Rückgabewert hat, wird standardmäßig immer das Empfängerobjekt zurückgegeben. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API. Wenn der Rückgabewert des Nachrichtenausdrucks im Kontext der Nachricht keine Verwendung findet, verfällt er einfach. Die Existenz des Objekts wird jedoch nur dann beeinflusst, wenn es keine weiteren Referenzen auf das Objekt gibt und es bei der nächsten Speicherbereinigung entfernt wird.
Die Auswertung eines Nachrichtenausdrucks führt zur Ausführung der Anweisungen im Rumpf einer Methode, weshalb sie auch als Methodenaufruf bezeichnet wird. Die Legitimität dieser Bezeichnung wird jedoch erst in Abschnitt 4.3 vollständig erklärt.
Zusammenfassend lässt sich sagen, dass: Ein Literal zu dem Objekt ausgewertet wird, das es repräsentiert. Eine Variable zu dem Objekt ausgewertet wird, das sie benennt. Eine Zuweisung zu dem Objekt ausgewertet wird, zu dem der Ausdruck auf der rechten Seite der Zuweisung ausgewertet wird. Ein Nachrichtenausdruck zu dem Objekt ausgewertet wird, das als Antwort auf die Nachricht zurückgegeben wird. Ein kaskadierter Nachrichtenausdruck zu dem Objekt ausgewertet wird, zu dem sein letzter Nachrichtenausdruck ausgewertet wird.",<answer> Die Auswertung eines Nachrichtenausdrucks führt zur Ausführung der Anweisungen im Rumpf einer Methode. Daher wird die Auswertung eines Nachrichtenausdrucks auch als Methodenaufruf bezeichnet. <answer> <question> Wie wird die Auswertung eines Nachrichtenausdrucks in SMALLTALK mit dem Ausführen von Anweisungen im Rumpf einer Methode in Verbindung gebracht? <question>
"Bis JAVA 1.4 waren class, interface und [] (Array) die einzigen Typkonstruktoren; mit JAVA 1.5 ist auch enum für Aufzählungstypen hinzugekommen, wobei diese unter die Klassentypen fallen: Neben der Angabe der Elemente der Aufzählung kann man auch Felder und Methoden angeben, die auf ihnen definiert sind. Damit werden die Elemente einer Aufzählung gewissermaßen zu Konstanten, also zu lebenslang gültigen Namen für Objekte einer Klasse, die den Aufzählungstyp repräsentiert.","<answer> Bis JAVA 1.4 gab es die Typkonstruktoren class, interface und [] (Array). <answer> <question> Welche Typkonstruktoren gab es in JAVA bis zur Version 1.4? <question>"
"Bis JAVA 1.4 waren class, interface und [] (Array) die einzigen Typkonstruktoren; mit JAVA 1.5 ist auch enum für Aufzählungstypen hinzugekommen, wobei diese unter die Klassentypen fallen: Neben der Angabe der Elemente der Aufzählung kann man auch Felder und Methoden angeben, die auf ihnen definiert sind. Damit werden die Elemente einer Aufzählung gewissermaßen zu Konstanten, also zu lebenslang gültigen Namen für Objekte einer Klasse, die den Aufzählungstyp repräsentiert.",<answer> In JAVA 1.5 wurde der Typkonstruktor enum für Aufzählungstypen hinzugefügt. <answer> <question> Welcher Typkonstruktor wurde in JAVA 1.5 für Aufzählungstypen hinzugefügt? <question>
"Bis JAVA 1.4 waren class, interface und [] (Array) die einzigen Typkonstruktoren; mit JAVA 1.5 ist auch enum für Aufzählungstypen hinzugekommen, wobei diese unter die Klassentypen fallen: Neben der Angabe der Elemente der Aufzählung kann man auch Felder und Methoden angeben, die auf ihnen definiert sind. Damit werden die Elemente einer Aufzählung gewissermaßen zu Konstanten, also zu lebenslang gültigen Namen für Objekte einer Klasse, die den Aufzählungstyp repräsentiert.",<answer> Aufzählungstypen in JAVA sind Klassentypen. Sie können neben den Aufzählungselementen auch Felder und Methoden enthalten. <answer> <question> Welche Art von Typen sind Aufzählungstypen in JAVA? <question>
"Das Konzept des Home Context eines Blocks geht aber noch weiter: Es umfasst nicht nur die sichtbaren Variablen aus dem Kontext der Definition des Blocks, sondern auch den sogenannten Call Stack. Dabei handelt es sich um den Speicher, in dem die Rücksprungadressen von Methodenaufrufen abgelegt werden. Folglich bedeutet eine Return-Anweisung innerhalb eines Blocks bei seiner Auswertung immer die unmittelbare Rückkehr in den Kontext, in dem der Block definiert wurde, also in den Home Context (der Methode), und nicht in den Kontext, in dem der Block durch Senden von value ausgewertet wird. Das nachfolgende Beispiel verdeutlicht dies:
Der Aufruf der Methode homeContext gibt ""home"" auf der Konsole aus, jedoch nicht ""other"". Dieses Konzept, das ebenfalls aus der Welt der funktionalen Programmierung stammt, wird auch als Continuation bezeichnet. Continuations spielen bei der Implementierung von Kontrollstrukturen in SMALLTALK eine entscheidende Rolle (siehe Kapitel 4.6).
Das Prinzip der Continuation gilt übrigens auch für geschachtelte Blöcke. Explizite Return-Anweisungen aus Blöcken kehrt immer dahin zurück, wo die Definition des Blocks angestoßen wurde.
Continuations können jedoch zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde.
Return-Anweisungen in Blöcken sind ein umstrittenes Konzept, können jedoch für SMALLTALK unverzichtbar sein, da sie zur Implementierung von nahezu allen Kontrollstrukturen verwendet werden (siehe Kapitel 4.6).","<answer> Das Konzept des Home Contexts eines Blocks in SMALLTALK umfasst nicht nur die sichtbaren Variablen aus dem Kontext der Definition des Blocks, sondern auch den sogenannten Call Stack, der die Rücksprungadressen von Methodenaufrufen speichert. <answer> <question> Was umfasst das Konzept des Home Contexts eines Blocks in SMALLTALK? <question>"
"Das Konzept des Home Context eines Blocks geht aber noch weiter: Es umfasst nicht nur die sichtbaren Variablen aus dem Kontext der Definition des Blocks, sondern auch den sogenannten Call Stack. Dabei handelt es sich um den Speicher, in dem die Rücksprungadressen von Methodenaufrufen abgelegt werden. Folglich bedeutet eine Return-Anweisung innerhalb eines Blocks bei seiner Auswertung immer die unmittelbare Rückkehr in den Kontext, in dem der Block definiert wurde, also in den Home Context (der Methode), und nicht in den Kontext, in dem der Block durch Senden von value ausgewertet wird. Das nachfolgende Beispiel verdeutlicht dies:
Der Aufruf der Methode homeContext gibt ""home"" auf der Konsole aus, jedoch nicht ""other"". Dieses Konzept, das ebenfalls aus der Welt der funktionalen Programmierung stammt, wird auch als Continuation bezeichnet. Continuations spielen bei der Implementierung von Kontrollstrukturen in SMALLTALK eine entscheidende Rolle (siehe Kapitel 4.6).
Das Prinzip der Continuation gilt übrigens auch für geschachtelte Blöcke. Explizite Return-Anweisungen aus Blöcken kehrt immer dahin zurück, wo die Definition des Blocks angestoßen wurde.
Continuations können jedoch zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde.
Return-Anweisungen in Blöcken sind ein umstrittenes Konzept, können jedoch für SMALLTALK unverzichtbar sein, da sie zur Implementierung von nahezu allen Kontrollstrukturen verwendet werden (siehe Kapitel 4.6).","<answer> Wenn eine Return-Anweisung innerhalb eines Blocks in SMALLTALK ausgewertet wird, bewirkt sie immer die unmittelbare Rückkehr in den Kontext, in dem der Block definiert wurde, also in den Home Context (der Methode), und nicht in den Kontext, in dem der Block durch Senden von value ausgewertet wurde. <answer> <question> Was bedeutet es, wenn eine Return-Anweisung innerhalb eines Blocks bei seiner Auswertung immer die unmittelbare Rückkehr in den Home Context des Blocks bewirkt? <question>"
"Das Konzept des Home Context eines Blocks geht aber noch weiter: Es umfasst nicht nur die sichtbaren Variablen aus dem Kontext der Definition des Blocks, sondern auch den sogenannten Call Stack. Dabei handelt es sich um den Speicher, in dem die Rücksprungadressen von Methodenaufrufen abgelegt werden. Folglich bedeutet eine Return-Anweisung innerhalb eines Blocks bei seiner Auswertung immer die unmittelbare Rückkehr in den Kontext, in dem der Block definiert wurde, also in den Home Context (der Methode), und nicht in den Kontext, in dem der Block durch Senden von value ausgewertet wird. Das nachfolgende Beispiel verdeutlicht dies:
Der Aufruf der Methode homeContext gibt ""home"" auf der Konsole aus, jedoch nicht ""other"". Dieses Konzept, das ebenfalls aus der Welt der funktionalen Programmierung stammt, wird auch als Continuation bezeichnet. Continuations spielen bei der Implementierung von Kontrollstrukturen in SMALLTALK eine entscheidende Rolle (siehe Kapitel 4.6).
Das Prinzip der Continuation gilt übrigens auch für geschachtelte Blöcke. Explizite Return-Anweisungen aus Blöcken kehrt immer dahin zurück, wo die Definition des Blocks angestoßen wurde.
Continuations können jedoch zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde.
Return-Anweisungen in Blöcken sind ein umstrittenes Konzept, können jedoch für SMALLTALK unverzichtbar sein, da sie zur Implementierung von nahezu allen Kontrollstrukturen verwendet werden (siehe Kapitel 4.6).","<answer> Im Kontext von Blöcken in SMALLTALK bezieht sich ""Continuation"" auf das Konzept, dass eine Return-Anweisung innerhalb eines Blocks immer zur unmittelbaren Rückkehr in den Home Context des Blocks führt. Dieses Konzept stammt aus der Welt der funktionalen Programmierung und spielt bei der Implementierung von Kontrollstrukturen in SMALLTALK eine wichtige Rolle. <answer> <question> Was wird mit ""Continuation"" im Kontext von Blöcken in SMALLTALK gemeint? <question>"
"Das Konzept des Home Context eines Blocks geht aber noch weiter: Es umfasst nicht nur die sichtbaren Variablen aus dem Kontext der Definition des Blocks, sondern auch den sogenannten Call Stack. Dabei handelt es sich um den Speicher, in dem die Rücksprungadressen von Methodenaufrufen abgelegt werden. Folglich bedeutet eine Return-Anweisung innerhalb eines Blocks bei seiner Auswertung immer die unmittelbare Rückkehr in den Kontext, in dem der Block definiert wurde, also in den Home Context (der Methode), und nicht in den Kontext, in dem der Block durch Senden von value ausgewertet wird. Das nachfolgende Beispiel verdeutlicht dies:
Der Aufruf der Methode homeContext gibt ""home"" auf der Konsole aus, jedoch nicht ""other"". Dieses Konzept, das ebenfalls aus der Welt der funktionalen Programmierung stammt, wird auch als Continuation bezeichnet. Continuations spielen bei der Implementierung von Kontrollstrukturen in SMALLTALK eine entscheidende Rolle (siehe Kapitel 4.6).
Das Prinzip der Continuation gilt übrigens auch für geschachtelte Blöcke. Explizite Return-Anweisungen aus Blöcken kehrt immer dahin zurück, wo die Definition des Blocks angestoßen wurde.
Continuations können jedoch zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde.
Return-Anweisungen in Blöcken sind ein umstrittenes Konzept, können jedoch für SMALLTALK unverzichtbar sein, da sie zur Implementierung von nahezu allen Kontrollstrukturen verwendet werden (siehe Kapitel 4.6).","<answer> Continuations können zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde. Dies kann zu inkonsistentem Verhalten und unerwarteten Zuständen führen. Return-Anweisungen in Blöcken sind daher ein umstrittenes Konzept, werden jedoch in SMALLTALK zur Implementierung von nahezu allen Kontrollstrukturen verwendet. <answer> <question> Warum können Continuations zu Laufzeitfehlern führen? <question>"
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s. Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Konstruktor für die Klasse A als gegeben voraussetzt.
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine Pointervariable handelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder C#.
Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++
Dies ist äquivalent zu (*a).x bzw. (*a).f(x). Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.
Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt.
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.",<answer> C++ bietet sowohl Strukturen (structs) als auch Klassen (classes) im Bereich der objektorientierten Programmierung. <answer> <question> Welche Strukturen bietet C++ im Bereich der objektorientierten Programmierung? <question>
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s. Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Konstruktor für die Klasse A als gegeben voraussetzt.
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine Pointervariable handelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder C#.
Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++
Dies ist äquivalent zu (*a).x bzw. (*a).f(x). Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.
Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt.
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.",<answer> Eine C++ Klasse enthält neben Feldern (Instanzvariablen) auch Methoden. <answer> <question> Was enthält eine C++ Klasse neben Feldern (Instanzvariablen)? <question>
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s. Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Konstruktor für die Klasse A als gegeben voraussetzt.
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine Pointervariable handelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder C#.
Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++
Dies ist äquivalent zu (*a).x bzw. (*a).f(x). Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.
Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt.
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.","<answer> Klassenfelder und -methoden werden in C++ mit dem Schlüsselwort ""static"" in einer Klasse eingeführt, ähnlich wie in Java. <answer> <question> Wie werden Klassenfelder und -methoden in C++ deklariert? <question>"
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s. Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Konstruktor für die Klasse A als gegeben voraussetzt.
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine Pointervariable handelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder C#.
Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++
Dies ist äquivalent zu (*a).x bzw. (*a).f(x). Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.
Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt.
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.","<answer> In C++ erfolgt die Erzeugung von Objekten oft ohne ""new"". Der benötigte Speicherplatz wird bei der Deklaration reserviert, und es entstehen Werte (Objekte) mit Wertsemantik, im Gegensatz zu Java, wo ""new"" verwendet wird. <answer> <question> Wie erfolgt die Erzeugung von Objekten in C++ im Vergleich zu Java? <question>"
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s. Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Konstruktor für die Klasse A als gegeben voraussetzt.
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine Pointervariable handelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder C#.
Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++
Dies ist äquivalent zu (*a).x bzw. (*a).f(x). Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.
Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt.
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.","<answer> Um in C++ Objekte mit Identität zu erzeugen, muss man Zeigervariablen (Pointer) verwenden und eine Klasse mit dem ""new""-Operator instanziieren. <answer> <question> Wie erzeugt man in C++ Objekte mit Identität? <question>"
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s. Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Konstruktor für die Klasse A als gegeben voraussetzt.
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine Pointervariable handelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder C#.
Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++
Dies ist äquivalent zu (*a).x bzw. (*a).f(x). Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.
Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt.
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.","<answer> In C++ erfolgt die Dereferenzierung eines Zeigers auf ein Objekt mit ""->"", z.B., ""a->x"" oder ""a->f(x)"" für ein Feld oder eine Methode der Klasse. <answer> <question> Wie sieht die Dereferenzierung eines Zeigers auf ein Objekt in C++ aus? <question>"
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s. Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Konstruktor für die Klasse A als gegeben voraussetzt.
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine Pointervariable handelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder C#.
Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++
Dies ist äquivalent zu (*a).x bzw. (*a).f(x). Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.
Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt.
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.","<answer> Bei Zuweisungen von Pointervariablen muss man sich in C++ genau überlegen, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen möchte. C++ verwendet standardmäßig ""Call by value"" für Methodenaufrufe, was bedeutet, dass Kopien von Parametern übergeben werden. <answer> <question> Welche Besonderheiten gibt es bei Zuweisungen von Pointervariablen in C++? <question>"
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s. Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Konstruktor für die Klasse A als gegeben voraussetzt.
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine Pointervariable handelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder C#.
Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++
Dies ist äquivalent zu (*a).x bzw. (*a).f(x). Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.
Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt.
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.","<answer> In C++ kann ""Call by reference"" erreicht werden, indem man den Zeigeroperator ""&"" verwendet und die formalen Parameter so deklariert, dass sie Zeiger auf Zeiger aufnehmen können. <answer> <question> Wie kann in C++ ""Call by reference"" erreicht werden? <question>"
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s. Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Konstruktor für die Klasse A als gegeben voraussetzt.
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine Pointervariable handelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder C#.
Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++
Dies ist äquivalent zu (*a).x bzw. (*a).f(x). Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.
Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt.
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.","<answer> Ja, in C++ gibt es die Möglichkeit, ""Call by reference"" ohne Verwendung des Zeigeroperators ""&"" zu erreichen, ähnlich wie in Pascal. Hierbei bleiben die Aufrufstellen unverändert. <answer> <question> Gibt es in C++ die Möglichkeit, ""Call by reference"" ohne Verwendung des Zeigeroperators ""&"" zu erreichen? <question>"
"C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s. Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die ""Objekte"", nicht erst mit new angelegt werden — der für ein ""Objekt"" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht ""Objekt"" hier deswegen in Anführungsstrichen, weil diese ""Objekte"" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Konstruktor für die Klasse A als gegeben voraussetzt.
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine Pointervariable handelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder C#.
Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++
Dies ist äquivalent zu (*a).x bzw. (*a).f(x). Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein ""Call by value"", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.
Wenn man nun davon abweichend ein ""Call by reference"" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt.
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.","<answer> In C++-Methodenaufrufen erfolgt die Übertragung von Parametern standardmäßig durch ""Call by value"", was bedeutet, dass Kopien der Parameter übergeben werden. <answer> <question> Was ist die Grundlage für die Übertragung von Parametern in C++-Methodenaufrufen? <question>"
"Eine wichtige Gruppe von Klassen, die Sie in den letzten beiden Kurseinheiten kennengelernt haben, sind die sog. Collection-Klassen. Auch diese bilden jeweils einen Typ, so dass Variablen, die auf eine Collection verweisen, mit diesem Typ deklariert werden können.
Nun dienen Collections ja u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen (s. Kurseinheit 2, Kapitel 13). Und so bilden die mit den Collection-Klassen assoziierten Typen auch nur die Typen für die Zwischenobjekte. Was man jedoch eigentlich bei der Deklaration von n-wertigen Attributen angeben (deklarieren) möchte, ist der Typ der in Beziehung stehenden Objekte.
Wenn das Attribut beispielsweise kinder heißt und man damit eine Person mit einer Menge anderer Objekte vom Typ Person, den Kindern, in Beziehung setzen möchte, dann nutzt es nichts, wenn man kinder vom Typ Person deklariert — es könnte dann höchstens eine Person enthalten und nicht mehrere. Was man vielmehr gern hätte, wäre etwas, das dem Array-Typkonstruktor array [<Bereich>] of <Elementtyp> (spitze Klammern hier wieder als Begrenzer von metasyntaktischen Variablen) von PASCAL gleicht: Im gegebenen Beispiel würde man gern deklarieren, dass kinder den Typ Collection of Person haben soll.
Ein anderes Beispiel für eine parametrische Definition einer Collection ist Dictionary: Hier sollte nicht nur der Element-, sondern auch der Schlüsseltyp variabel gehalten werden.
Dabei ist der parametrische Typ Dictionary ein Subtyp des ebenfalls parametrischen Typs Collection. Man beachte, dass der Typparameter E hier bereits in der Supertypdeklaration verwendet wird. Ein Dictionary, in dem Integer auf beliebige Objekte abgebildet werden, erhält man dann durch die Instanziierung Dictionary[Integer, Object]. Es ist mit einer Variable vom Typ Collection[Object] zuweisungskompatibel. Auf die Einzelheiten des Subtypings bei parametrischen Typen wird in Kapitel 30 eingegangen.","<answer> Collections dienen u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen. <answer> <question> Welchen Zweck dienen Collections in der Programmierung? <question>"
"Eine wichtige Gruppe von Klassen, die Sie in den letzten beiden Kurseinheiten kennengelernt haben, sind die sog. Collection-Klassen. Auch diese bilden jeweils einen Typ, so dass Variablen, die auf eine Collection verweisen, mit diesem Typ deklariert werden können.
Nun dienen Collections ja u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen (s. Kurseinheit 2, Kapitel 13). Und so bilden die mit den Collection-Klassen assoziierten Typen auch nur die Typen für die Zwischenobjekte. Was man jedoch eigentlich bei der Deklaration von n-wertigen Attributen angeben (deklarieren) möchte, ist der Typ der in Beziehung stehenden Objekte.
Wenn das Attribut beispielsweise kinder heißt und man damit eine Person mit einer Menge anderer Objekte vom Typ Person, den Kindern, in Beziehung setzen möchte, dann nutzt es nichts, wenn man kinder vom Typ Person deklariert — es könnte dann höchstens eine Person enthalten und nicht mehrere. Was man vielmehr gern hätte, wäre etwas, das dem Array-Typkonstruktor array [<Bereich>] of <Elementtyp> (spitze Klammern hier wieder als Begrenzer von metasyntaktischen Variablen) von PASCAL gleicht: Im gegebenen Beispiel würde man gern deklarieren, dass kinder den Typ Collection of Person haben soll.
Ein anderes Beispiel für eine parametrische Definition einer Collection ist Dictionary: Hier sollte nicht nur der Element-, sondern auch der Schlüsseltyp variabel gehalten werden.
Dabei ist der parametrische Typ Dictionary ein Subtyp des ebenfalls parametrischen Typs Collection. Man beachte, dass der Typparameter E hier bereits in der Supertypdeklaration verwendet wird. Ein Dictionary, in dem Integer auf beliebige Objekte abgebildet werden, erhält man dann durch die Instanziierung Dictionary[Integer, Object]. Es ist mit einer Variable vom Typ Collection[Object] zuweisungskompatibel. Auf die Einzelheiten des Subtypings bei parametrischen Typen wird in Kapitel 30 eingegangen.",<answer> Die mit Collection-Klassen assoziierten Typen repräsentieren die Typen für die Zwischenobjekte in den Collections. <answer> <question> Welchen Typ repräsentieren die mit Collection-Klassen assoziierten Typen? <question>
"Eine wichtige Gruppe von Klassen, die Sie in den letzten beiden Kurseinheiten kennengelernt haben, sind die sog. Collection-Klassen. Auch diese bilden jeweils einen Typ, so dass Variablen, die auf eine Collection verweisen, mit diesem Typ deklariert werden können.
Nun dienen Collections ja u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen (s. Kurseinheit 2, Kapitel 13). Und so bilden die mit den Collection-Klassen assoziierten Typen auch nur die Typen für die Zwischenobjekte. Was man jedoch eigentlich bei der Deklaration von n-wertigen Attributen angeben (deklarieren) möchte, ist der Typ der in Beziehung stehenden Objekte.
Wenn das Attribut beispielsweise kinder heißt und man damit eine Person mit einer Menge anderer Objekte vom Typ Person, den Kindern, in Beziehung setzen möchte, dann nutzt es nichts, wenn man kinder vom Typ Person deklariert — es könnte dann höchstens eine Person enthalten und nicht mehrere. Was man vielmehr gern hätte, wäre etwas, das dem Array-Typkonstruktor array [<Bereich>] of <Elementtyp> (spitze Klammern hier wieder als Begrenzer von metasyntaktischen Variablen) von PASCAL gleicht: Im gegebenen Beispiel würde man gern deklarieren, dass kinder den Typ Collection of Person haben soll.
Ein anderes Beispiel für eine parametrische Definition einer Collection ist Dictionary: Hier sollte nicht nur der Element-, sondern auch der Schlüsseltyp variabel gehalten werden.
Dabei ist der parametrische Typ Dictionary ein Subtyp des ebenfalls parametrischen Typs Collection. Man beachte, dass der Typparameter E hier bereits in der Supertypdeklaration verwendet wird. Ein Dictionary, in dem Integer auf beliebige Objekte abgebildet werden, erhält man dann durch die Instanziierung Dictionary[Integer, Object]. Es ist mit einer Variable vom Typ Collection[Object] zuweisungskompatibel. Auf die Einzelheiten des Subtypings bei parametrischen Typen wird in Kapitel 30 eingegangen.",<answer> Bei der Deklaration von n-wertigen Attributen möchte man den Typ der in Beziehung stehenden Objekte angeben. <answer> <question> Was möchte man bei der Deklaration von n-wertigen Attributen angeben? <question>
"Eine wichtige Gruppe von Klassen, die Sie in den letzten beiden Kurseinheiten kennengelernt haben, sind die sog. Collection-Klassen. Auch diese bilden jeweils einen Typ, so dass Variablen, die auf eine Collection verweisen, mit diesem Typ deklariert werden können.
Nun dienen Collections ja u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen (s. Kurseinheit 2, Kapitel 13). Und so bilden die mit den Collection-Klassen assoziierten Typen auch nur die Typen für die Zwischenobjekte. Was man jedoch eigentlich bei der Deklaration von n-wertigen Attributen angeben (deklarieren) möchte, ist der Typ der in Beziehung stehenden Objekte.
Wenn das Attribut beispielsweise kinder heißt und man damit eine Person mit einer Menge anderer Objekte vom Typ Person, den Kindern, in Beziehung setzen möchte, dann nutzt es nichts, wenn man kinder vom Typ Person deklariert — es könnte dann höchstens eine Person enthalten und nicht mehrere. Was man vielmehr gern hätte, wäre etwas, das dem Array-Typkonstruktor array [<Bereich>] of <Elementtyp> (spitze Klammern hier wieder als Begrenzer von metasyntaktischen Variablen) von PASCAL gleicht: Im gegebenen Beispiel würde man gern deklarieren, dass kinder den Typ Collection of Person haben soll.
Ein anderes Beispiel für eine parametrische Definition einer Collection ist Dictionary: Hier sollte nicht nur der Element-, sondern auch der Schlüsseltyp variabel gehalten werden.
Dabei ist der parametrische Typ Dictionary ein Subtyp des ebenfalls parametrischen Typs Collection. Man beachte, dass der Typparameter E hier bereits in der Supertypdeklaration verwendet wird. Ein Dictionary, in dem Integer auf beliebige Objekte abgebildet werden, erhält man dann durch die Instanziierung Dictionary[Integer, Object]. Es ist mit einer Variable vom Typ Collection[Object] zuweisungskompatibel. Auf die Einzelheiten des Subtypings bei parametrischen Typen wird in Kapitel 30 eingegangen.","<answer> Ein Beispiel für eine parametrische Definition einer Collection ist Dictionary, bei dem nicht nur der Elementtyp, sondern auch der Schlüsseltyp variabel gehalten werden sollte. <answer> <question> Was ist ein Beispiel für eine parametrische Definition einer Collection? <question>"
"EIFFEL ist, wie alle anderen hier behandelten Sprachen (mit Ausnahme von C++), eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist. Klassen können (mit der in Abschnitt 52.5 gemachten Einschränkung) separat übersetzt werden. Die Ausführung von EIFFEL erfolgt nicht auf einer virtuellen Maschine, sondern direkt auf der Zielmaschine. Es gibt jedoch mittlerweile auch eine Version von EIFFEL für .NET, die wie alle .NET-Sprachen zunächst in CIL übersetzt wird und dann in Maschinencode. Die Sprache selbst sieht aufgrund ihrer Einfachheit keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Eventuelle Performance-Verbesserungen werden ganz der Verantwortung eines optimierenden Compilers überlassen. EIFFEL verwendet Garbage Collection zur Speicherfreigabe. Es handelt sich um eine akademische Sprache.","<answer> Das Programmiermodell von EIFFEL ist rein objektorientiert, bei dem der gesamte Code in Klassen organisiert ist. Diese Klassen können separat übersetzt werden, und die Ausführung erfolgt direkt auf der Zielmaschine. <answer> <question> Was ist das Programmiermodell von EIFFEL? <question>"
"EIFFEL ist, wie alle anderen hier behandelten Sprachen (mit Ausnahme von C++), eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist. Klassen können (mit der in Abschnitt 52.5 gemachten Einschränkung) separat übersetzt werden. Die Ausführung von EIFFEL erfolgt nicht auf einer virtuellen Maschine, sondern direkt auf der Zielmaschine. Es gibt jedoch mittlerweile auch eine Version von EIFFEL für .NET, die wie alle .NET-Sprachen zunächst in CIL übersetzt wird und dann in Maschinencode. Die Sprache selbst sieht aufgrund ihrer Einfachheit keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Eventuelle Performance-Verbesserungen werden ganz der Verantwortung eines optimierenden Compilers überlassen. EIFFEL verwendet Garbage Collection zur Speicherfreigabe. Es handelt sich um eine akademische Sprache.","<answer> Im Gegensatz zu C++ führt EIFFEL den Code nicht auf einer virtuellen Maschine aus, sondern direkt auf der Zielmaschine. Es gibt jedoch auch eine Version von EIFFEL für .NET, die in CIL übersetzt und dann in Maschinencode ausgeführt wird. <answer> <question> Wie unterscheidet sich EIFFEL von C++ in Bezug auf die Ausführungsumgebung? <question>"
"EIFFEL ist, wie alle anderen hier behandelten Sprachen (mit Ausnahme von C++), eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist. Klassen können (mit der in Abschnitt 52.5 gemachten Einschränkung) separat übersetzt werden. Die Ausführung von EIFFEL erfolgt nicht auf einer virtuellen Maschine, sondern direkt auf der Zielmaschine. Es gibt jedoch mittlerweile auch eine Version von EIFFEL für .NET, die wie alle .NET-Sprachen zunächst in CIL übersetzt wird und dann in Maschinencode. Die Sprache selbst sieht aufgrund ihrer Einfachheit keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Eventuelle Performance-Verbesserungen werden ganz der Verantwortung eines optimierenden Compilers überlassen. EIFFEL verwendet Garbage Collection zur Speicherfreigabe. Es handelt sich um eine akademische Sprache.","<answer> Nein, EIFFEL sieht keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Die Performance-Verbesserungen werden vollständig einem optimierenden Compiler überlassen. <answer> <question> Bietet EIFFEL spezielle Konstrukte zur Leistungsoptimierung? <question>"
"EIFFEL ist, wie alle anderen hier behandelten Sprachen (mit Ausnahme von C++), eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist. Klassen können (mit der in Abschnitt 52.5 gemachten Einschränkung) separat übersetzt werden. Die Ausführung von EIFFEL erfolgt nicht auf einer virtuellen Maschine, sondern direkt auf der Zielmaschine. Es gibt jedoch mittlerweile auch eine Version von EIFFEL für .NET, die wie alle .NET-Sprachen zunächst in CIL übersetzt wird und dann in Maschinencode. Die Sprache selbst sieht aufgrund ihrer Einfachheit keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Eventuelle Performance-Verbesserungen werden ganz der Verantwortung eines optimierenden Compilers überlassen. EIFFEL verwendet Garbage Collection zur Speicherfreigabe. Es handelt sich um eine akademische Sprache.",<answer> EIFFEL verwendet Garbage Collection zur Speicherfreigabe. <answer> <question> Welche Methode verwendet EIFFEL zur Speicherfreigabe? <question>
"EIFFEL ist, wie alle anderen hier behandelten Sprachen (mit Ausnahme von C++), eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist. Klassen können (mit der in Abschnitt 52.5 gemachten Einschränkung) separat übersetzt werden. Die Ausführung von EIFFEL erfolgt nicht auf einer virtuellen Maschine, sondern direkt auf der Zielmaschine. Es gibt jedoch mittlerweile auch eine Version von EIFFEL für .NET, die wie alle .NET-Sprachen zunächst in CIL übersetzt wird und dann in Maschinencode. Die Sprache selbst sieht aufgrund ihrer Einfachheit keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Eventuelle Performance-Verbesserungen werden ganz der Verantwortung eines optimierenden Compilers überlassen. EIFFEL verwendet Garbage Collection zur Speicherfreigabe. Es handelt sich um eine akademische Sprache.","<answer> EIFFEL wird als eine akademische Sprache charakterisiert, was bedeutet, dass sie in erster Linie in der akademischen Welt verwendet wird und möglicherweise weniger in kommerziellen Anwendungen anzutreffen ist. <answer> <question> Wie wird EIFFEL als Sprache häufig charakterisiert? <question>"
"Eine etwas eingeschränktere Sicht auf den Zustand eines Objekts berücksichtigt lediglich seine Attributwerte. Dies setzt jedoch voraus, dass überhaupt eine klare Unterscheidung zwischen Attributen und Beziehungen getroffen werden kann. In Ermangelung spezieller Schlüsselwörter könnte dies, wie bereits oben diskutiert, allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese Unterscheidung ist jedoch nicht immer eindeutig, und in einigen Programmiersprachen ist sie gar nicht zutreffend (z.B., in JAVA, in dem Strings zwar unveränderlich sind und daher eigentlich als Werte gelten, aber dennoch Referenzsemantik aufweisen). In SMALLTALK hingegen, in dem alle Instanzvariablen Referenzen sein können, ist diese Einschränkung nicht anwendbar.
Man könnte nun die oben genannte Aussage, dass Zustandsänderungen eines Objekts ausschließlich über Zuweisungen an seine Instanzvariablen erfolgen können, anzweifeln und fragen, ob sich der Zustand eines Objekts auch dann ändert, wenn sich der Zustand eines Objekts, auf das es (per Instanzvariable) verweist, ändert. Zunächst würde man diese Frage verneinen, da andernfalls jede Änderung an einem Objekt fast immer zu einer Kettenreaktion führen würde. Der Zustand aller Objekte, die direkt oder indirekt darauf verweisen, würde sich ändern. Diese Definition von Zustand würde jedoch kaum unserem Weltbild entsprechen. Zum Beispiel würde eine Änderung Ihres Familienstandes kaum etwas an meinem Zustand ändern, obwohl wir in einer (direkten oder indirekten) Beziehung stehen. Doch wie ist es, wenn ich meinen Namen ändere? Ändert sich dann mein Zustand?
Während man diese Frage sicherlich mit ""ja"" beantworten wird, ist Ihr Name als String ein eigenständiges Objekt, das seinen Zustand ändert, wenn einzelne Buchstaben darin ausgetauscht oder hinzugefügt werden, wie im Beispiel in Abschnitt 1.8 gezeigt. Nach der oben genannten Auffassung ändert sich jedoch mein Zustand als Besitzer des Namens dadurch nicht. Für einen solchen Fall lässt sich technisch kein Sonderfall begründen. Das objektorientierte Denkmodell ist daher nicht ganz ohne Herausforderungen und Programmierfehler können in vermeintlich simplen Situationen auftreten. Es ist daher sinnvoll, wenn Strings, wie von einigen SMALLTALK-Dialekten (und übrigens auch von JAVA) vorgesehen, immer unveränderlich (immutable) sind.
Obwohl es nicht sinnvoll ist, den Zustandsbegriff auf mehrere Objekte im Allgemeinen auszudehnen, ist dies für Kompositionen, also für aus Teilen zusammengesetzte Ganze (siehe Abschnitt 2.3), durchaus angemessen. Wenn zum Beispiel ein Dokument aus mehreren Seiten besteht, die wiederum aus Zeilen und Spalten bestehen, ändert sich der Zustand des gesamten Dokuments, wenn eine Zeile geändert wird. Dies wird weiter unten noch eine Rolle spielen, insbesondere im Zusammenhang mit Aliasing. Wenn man davon ausgeht, dass Zustandsänderungen eines Objekts immer die Angelegenheit des Objekts selbst sind, dürfen keine externen Aliase auf seine Teile existieren. Andernfalls könnte eine Zustandsänderung von außen aufgezwungen werden. Die Zustandsänderung sollte daher gekapselt sein.",<answer> Eine etwas eingeschränktere Sicht auf den Zustand eines Objekts berücksichtigt lediglich seine Attributwerte. <answer> <question> Welche Einschränkung in Bezug auf den Zustand eines Objekts wird in diesem Abschnitt diskutiert? <question>
"Eine etwas eingeschränktere Sicht auf den Zustand eines Objekts berücksichtigt lediglich seine Attributwerte. Dies setzt jedoch voraus, dass überhaupt eine klare Unterscheidung zwischen Attributen und Beziehungen getroffen werden kann. In Ermangelung spezieller Schlüsselwörter könnte dies, wie bereits oben diskutiert, allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese Unterscheidung ist jedoch nicht immer eindeutig, und in einigen Programmiersprachen ist sie gar nicht zutreffend (z.B., in JAVA, in dem Strings zwar unveränderlich sind und daher eigentlich als Werte gelten, aber dennoch Referenzsemantik aufweisen). In SMALLTALK hingegen, in dem alle Instanzvariablen Referenzen sein können, ist diese Einschränkung nicht anwendbar.
Man könnte nun die oben genannte Aussage, dass Zustandsänderungen eines Objekts ausschließlich über Zuweisungen an seine Instanzvariablen erfolgen können, anzweifeln und fragen, ob sich der Zustand eines Objekts auch dann ändert, wenn sich der Zustand eines Objekts, auf das es (per Instanzvariable) verweist, ändert. Zunächst würde man diese Frage verneinen, da andernfalls jede Änderung an einem Objekt fast immer zu einer Kettenreaktion führen würde. Der Zustand aller Objekte, die direkt oder indirekt darauf verweisen, würde sich ändern. Diese Definition von Zustand würde jedoch kaum unserem Weltbild entsprechen. Zum Beispiel würde eine Änderung Ihres Familienstandes kaum etwas an meinem Zustand ändern, obwohl wir in einer (direkten oder indirekten) Beziehung stehen. Doch wie ist es, wenn ich meinen Namen ändere? Ändert sich dann mein Zustand?
Während man diese Frage sicherlich mit ""ja"" beantworten wird, ist Ihr Name als String ein eigenständiges Objekt, das seinen Zustand ändert, wenn einzelne Buchstaben darin ausgetauscht oder hinzugefügt werden, wie im Beispiel in Abschnitt 1.8 gezeigt. Nach der oben genannten Auffassung ändert sich jedoch mein Zustand als Besitzer des Namens dadurch nicht. Für einen solchen Fall lässt sich technisch kein Sonderfall begründen. Das objektorientierte Denkmodell ist daher nicht ganz ohne Herausforderungen und Programmierfehler können in vermeintlich simplen Situationen auftreten. Es ist daher sinnvoll, wenn Strings, wie von einigen SMALLTALK-Dialekten (und übrigens auch von JAVA) vorgesehen, immer unveränderlich (immutable) sind.
Obwohl es nicht sinnvoll ist, den Zustandsbegriff auf mehrere Objekte im Allgemeinen auszudehnen, ist dies für Kompositionen, also für aus Teilen zusammengesetzte Ganze (siehe Abschnitt 2.3), durchaus angemessen. Wenn zum Beispiel ein Dokument aus mehreren Seiten besteht, die wiederum aus Zeilen und Spalten bestehen, ändert sich der Zustand des gesamten Dokuments, wenn eine Zeile geändert wird. Dies wird weiter unten noch eine Rolle spielen, insbesondere im Zusammenhang mit Aliasing. Wenn man davon ausgeht, dass Zustandsänderungen eines Objekts immer die Angelegenheit des Objekts selbst sind, dürfen keine externen Aliase auf seine Teile existieren. Andernfalls könnte eine Zustandsänderung von außen aufgezwungen werden. Die Zustandsänderung sollte daher gekapselt sein.","<answer> Die Unterscheidung zwischen Attributen und Beziehungen in der objektorientierten Programmierung kann schwierig sein, da in einigen Programmiersprachen wie Java die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik nicht immer eindeutig ist. <answer> <question> Warum ist die Unterscheidung zwischen Attributen und Beziehungen in der objektorientierten Programmierung manchmal schwierig? <question>"
"Eine etwas eingeschränktere Sicht auf den Zustand eines Objekts berücksichtigt lediglich seine Attributwerte. Dies setzt jedoch voraus, dass überhaupt eine klare Unterscheidung zwischen Attributen und Beziehungen getroffen werden kann. In Ermangelung spezieller Schlüsselwörter könnte dies, wie bereits oben diskutiert, allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese Unterscheidung ist jedoch nicht immer eindeutig, und in einigen Programmiersprachen ist sie gar nicht zutreffend (z.B., in JAVA, in dem Strings zwar unveränderlich sind und daher eigentlich als Werte gelten, aber dennoch Referenzsemantik aufweisen). In SMALLTALK hingegen, in dem alle Instanzvariablen Referenzen sein können, ist diese Einschränkung nicht anwendbar.
Man könnte nun die oben genannte Aussage, dass Zustandsänderungen eines Objekts ausschließlich über Zuweisungen an seine Instanzvariablen erfolgen können, anzweifeln und fragen, ob sich der Zustand eines Objekts auch dann ändert, wenn sich der Zustand eines Objekts, auf das es (per Instanzvariable) verweist, ändert. Zunächst würde man diese Frage verneinen, da andernfalls jede Änderung an einem Objekt fast immer zu einer Kettenreaktion führen würde. Der Zustand aller Objekte, die direkt oder indirekt darauf verweisen, würde sich ändern. Diese Definition von Zustand würde jedoch kaum unserem Weltbild entsprechen. Zum Beispiel würde eine Änderung Ihres Familienstandes kaum etwas an meinem Zustand ändern, obwohl wir in einer (direkten oder indirekten) Beziehung stehen. Doch wie ist es, wenn ich meinen Namen ändere? Ändert sich dann mein Zustand?
Während man diese Frage sicherlich mit ""ja"" beantworten wird, ist Ihr Name als String ein eigenständiges Objekt, das seinen Zustand ändert, wenn einzelne Buchstaben darin ausgetauscht oder hinzugefügt werden, wie im Beispiel in Abschnitt 1.8 gezeigt. Nach der oben genannten Auffassung ändert sich jedoch mein Zustand als Besitzer des Namens dadurch nicht. Für einen solchen Fall lässt sich technisch kein Sonderfall begründen. Das objektorientierte Denkmodell ist daher nicht ganz ohne Herausforderungen und Programmierfehler können in vermeintlich simplen Situationen auftreten. Es ist daher sinnvoll, wenn Strings, wie von einigen SMALLTALK-Dialekten (und übrigens auch von JAVA) vorgesehen, immer unveränderlich (immutable) sind.
Obwohl es nicht sinnvoll ist, den Zustandsbegriff auf mehrere Objekte im Allgemeinen auszudehnen, ist dies für Kompositionen, also für aus Teilen zusammengesetzte Ganze (siehe Abschnitt 2.3), durchaus angemessen. Wenn zum Beispiel ein Dokument aus mehreren Seiten besteht, die wiederum aus Zeilen und Spalten bestehen, ändert sich der Zustand des gesamten Dokuments, wenn eine Zeile geändert wird. Dies wird weiter unten noch eine Rolle spielen, insbesondere im Zusammenhang mit Aliasing. Wenn man davon ausgeht, dass Zustandsänderungen eines Objekts immer die Angelegenheit des Objekts selbst sind, dürfen keine externen Aliase auf seine Teile existieren. Andernfalls könnte eine Zustandsänderung von außen aufgezwungen werden. Die Zustandsänderung sollte daher gekapselt sein.","<answer> Wenn Änderungen am Zustand eines Objekts, auf das ein anderes Objekt per Instanzvariable verweist, als Änderung des Zustands des ersten Objekts betrachtet würden, könnte jede Änderung an einem Objekt zu einer Kettenreaktion führen, da der Zustand aller Objekte, die darauf verweisen, sich ändern würde. Dies entspricht nicht unserem üblichen Verständnis von Zustand. <answer> <question> Warum ist die Änderung des Zustands eines Objekts, auf das ein anderes Objekt per Instanzvariable verweist, normalerweise nicht als Änderung des Zustands des ersten Objekts zu betrachten? <question>"
"Eine etwas eingeschränktere Sicht auf den Zustand eines Objekts berücksichtigt lediglich seine Attributwerte. Dies setzt jedoch voraus, dass überhaupt eine klare Unterscheidung zwischen Attributen und Beziehungen getroffen werden kann. In Ermangelung spezieller Schlüsselwörter könnte dies, wie bereits oben diskutiert, allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese Unterscheidung ist jedoch nicht immer eindeutig, und in einigen Programmiersprachen ist sie gar nicht zutreffend (z.B., in JAVA, in dem Strings zwar unveränderlich sind und daher eigentlich als Werte gelten, aber dennoch Referenzsemantik aufweisen). In SMALLTALK hingegen, in dem alle Instanzvariablen Referenzen sein können, ist diese Einschränkung nicht anwendbar.
Man könnte nun die oben genannte Aussage, dass Zustandsänderungen eines Objekts ausschließlich über Zuweisungen an seine Instanzvariablen erfolgen können, anzweifeln und fragen, ob sich der Zustand eines Objekts auch dann ändert, wenn sich der Zustand eines Objekts, auf das es (per Instanzvariable) verweist, ändert. Zunächst würde man diese Frage verneinen, da andernfalls jede Änderung an einem Objekt fast immer zu einer Kettenreaktion führen würde. Der Zustand aller Objekte, die direkt oder indirekt darauf verweisen, würde sich ändern. Diese Definition von Zustand würde jedoch kaum unserem Weltbild entsprechen. Zum Beispiel würde eine Änderung Ihres Familienstandes kaum etwas an meinem Zustand ändern, obwohl wir in einer (direkten oder indirekten) Beziehung stehen. Doch wie ist es, wenn ich meinen Namen ändere? Ändert sich dann mein Zustand?
Während man diese Frage sicherlich mit ""ja"" beantworten wird, ist Ihr Name als String ein eigenständiges Objekt, das seinen Zustand ändert, wenn einzelne Buchstaben darin ausgetauscht oder hinzugefügt werden, wie im Beispiel in Abschnitt 1.8 gezeigt. Nach der oben genannten Auffassung ändert sich jedoch mein Zustand als Besitzer des Namens dadurch nicht. Für einen solchen Fall lässt sich technisch kein Sonderfall begründen. Das objektorientierte Denkmodell ist daher nicht ganz ohne Herausforderungen und Programmierfehler können in vermeintlich simplen Situationen auftreten. Es ist daher sinnvoll, wenn Strings, wie von einigen SMALLTALK-Dialekten (und übrigens auch von JAVA) vorgesehen, immer unveränderlich (immutable) sind.
Obwohl es nicht sinnvoll ist, den Zustandsbegriff auf mehrere Objekte im Allgemeinen auszudehnen, ist dies für Kompositionen, also für aus Teilen zusammengesetzte Ganze (siehe Abschnitt 2.3), durchaus angemessen. Wenn zum Beispiel ein Dokument aus mehreren Seiten besteht, die wiederum aus Zeilen und Spalten bestehen, ändert sich der Zustand des gesamten Dokuments, wenn eine Zeile geändert wird. Dies wird weiter unten noch eine Rolle spielen, insbesondere im Zusammenhang mit Aliasing. Wenn man davon ausgeht, dass Zustandsänderungen eines Objekts immer die Angelegenheit des Objekts selbst sind, dürfen keine externen Aliase auf seine Teile existieren. Andernfalls könnte eine Zustandsänderung von außen aufgezwungen werden. Die Zustandsänderung sollte daher gekapselt sein.","<answer> Der Zustandsbegriff kann nicht auf mehrere Objekte im Allgemeinen ausgedehnt werden, da dies zu komplexen Problemen führen würde und das objektorientierte Modell nicht ohne Herausforderungen ist. Programmierfehler könnten in vermeintlich simplen Situationen auftreten. <answer> <question> Warum kann der Zustandsbegriff nicht auf mehrere Objekte im Allgemeinen ausgedehnt werden? <question>"
"Eine etwas eingeschränktere Sicht auf den Zustand eines Objekts berücksichtigt lediglich seine Attributwerte. Dies setzt jedoch voraus, dass überhaupt eine klare Unterscheidung zwischen Attributen und Beziehungen getroffen werden kann. In Ermangelung spezieller Schlüsselwörter könnte dies, wie bereits oben diskutiert, allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese Unterscheidung ist jedoch nicht immer eindeutig, und in einigen Programmiersprachen ist sie gar nicht zutreffend (z.B., in JAVA, in dem Strings zwar unveränderlich sind und daher eigentlich als Werte gelten, aber dennoch Referenzsemantik aufweisen). In SMALLTALK hingegen, in dem alle Instanzvariablen Referenzen sein können, ist diese Einschränkung nicht anwendbar.
Man könnte nun die oben genannte Aussage, dass Zustandsänderungen eines Objekts ausschließlich über Zuweisungen an seine Instanzvariablen erfolgen können, anzweifeln und fragen, ob sich der Zustand eines Objekts auch dann ändert, wenn sich der Zustand eines Objekts, auf das es (per Instanzvariable) verweist, ändert. Zunächst würde man diese Frage verneinen, da andernfalls jede Änderung an einem Objekt fast immer zu einer Kettenreaktion führen würde. Der Zustand aller Objekte, die direkt oder indirekt darauf verweisen, würde sich ändern. Diese Definition von Zustand würde jedoch kaum unserem Weltbild entsprechen. Zum Beispiel würde eine Änderung Ihres Familienstandes kaum etwas an meinem Zustand ändern, obwohl wir in einer (direkten oder indirekten) Beziehung stehen. Doch wie ist es, wenn ich meinen Namen ändere? Ändert sich dann mein Zustand?
Während man diese Frage sicherlich mit ""ja"" beantworten wird, ist Ihr Name als String ein eigenständiges Objekt, das seinen Zustand ändert, wenn einzelne Buchstaben darin ausgetauscht oder hinzugefügt werden, wie im Beispiel in Abschnitt 1.8 gezeigt. Nach der oben genannten Auffassung ändert sich jedoch mein Zustand als Besitzer des Namens dadurch nicht. Für einen solchen Fall lässt sich technisch kein Sonderfall begründen. Das objektorientierte Denkmodell ist daher nicht ganz ohne Herausforderungen und Programmierfehler können in vermeintlich simplen Situationen auftreten. Es ist daher sinnvoll, wenn Strings, wie von einigen SMALLTALK-Dialekten (und übrigens auch von JAVA) vorgesehen, immer unveränderlich (immutable) sind.
Obwohl es nicht sinnvoll ist, den Zustandsbegriff auf mehrere Objekte im Allgemeinen auszudehnen, ist dies für Kompositionen, also für aus Teilen zusammengesetzte Ganze (siehe Abschnitt 2.3), durchaus angemessen. Wenn zum Beispiel ein Dokument aus mehreren Seiten besteht, die wiederum aus Zeilen und Spalten bestehen, ändert sich der Zustand des gesamten Dokuments, wenn eine Zeile geändert wird. Dies wird weiter unten noch eine Rolle spielen, insbesondere im Zusammenhang mit Aliasing. Wenn man davon ausgeht, dass Zustandsänderungen eines Objekts immer die Angelegenheit des Objekts selbst sind, dürfen keine externen Aliase auf seine Teile existieren. Andernfalls könnte eine Zustandsänderung von außen aufgezwungen werden. Die Zustandsänderung sollte daher gekapselt sein.","<answer> Es ist angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen, wenn es sich um Kompositionen handelt, also um aus Teilen zusammengesetzte Ganze. Zum Beispiel ändert sich der Zustand eines gesamten Dokuments, wenn eine Zeile innerhalb des Dokuments geändert wird. <answer> <question> In welchem Kontext ist es angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen? <question>"
"In SMALLTALK gibt es also eine Hierarchie, die auf dem Konzept der Klassifikation aufbaut. Aufgrund praktischer Überlegungen ist diese Hierarchie beschränkt; sie ist mit der Sprachdefinition festgelegt und stellt gewissermaßen einen Teil derselben dar. Konzeptionell ist diese Hierarchie eine Abstraktionshierarchie: Von den konkreten Objekten der Ebene 0 geht es über die Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Konzepte auf Ebene 2 und schließlich zur Fassung von Definitionen allgemein auf Ebene 3. Mit jeder Stufe, mit Ausnahme der mittleren, wird die Zahl der Objekte, die unter die darin angesiedelten Konzepte fallen, drastisch reduziert: von Ebene 0 auf Ebene 1 von theoretisch unendlich vielen Objekten einer Anwendung zur Zahl der Anwendungsklassen, von Ebene 2 auf Ebene 3.
In der Praxis bewegen Sie sich jedoch vor allem auf Ebene 1: Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen Sie also nur eine Abstraktionsstufe für die Programmierung.","<answer> In SMALLTALK gibt es eine Hierarchie, die auf dem Konzept der Klassifikation basiert. Diese Hierarchie stellt eine Abstraktionshierarchie dar, bei der von konkreten Objekten der Ebene 0 über Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Konzepte auf Ebene 2 und schließlich zur Fassung von Definitionen auf Ebene 3 fortgeschritten wird. <answer> <question> Was ist die Hierarchie in SMALLTALK, die auf dem Konzept der Klassifikation basiert? <question>"
"In SMALLTALK gibt es also eine Hierarchie, die auf dem Konzept der Klassifikation aufbaut. Aufgrund praktischer Überlegungen ist diese Hierarchie beschränkt; sie ist mit der Sprachdefinition festgelegt und stellt gewissermaßen einen Teil derselben dar. Konzeptionell ist diese Hierarchie eine Abstraktionshierarchie: Von den konkreten Objekten der Ebene 0 geht es über die Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Konzepte auf Ebene 2 und schließlich zur Fassung von Definitionen allgemein auf Ebene 3. Mit jeder Stufe, mit Ausnahme der mittleren, wird die Zahl der Objekte, die unter die darin angesiedelten Konzepte fallen, drastisch reduziert: von Ebene 0 auf Ebene 1 von theoretisch unendlich vielen Objekten einer Anwendung zur Zahl der Anwendungsklassen, von Ebene 2 auf Ebene 3.
In der Praxis bewegen Sie sich jedoch vor allem auf Ebene 1: Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen Sie also nur eine Abstraktionsstufe für die Programmierung.","<answer> In der Praxis bewegen sich Programmierer hauptsächlich auf Ebene 1. Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen sie also hauptsächlich eine Abstraktionsstufe für die Programmierung. <answer> <question> Welche Ebene der Hierarchie nutzen Programmierer in der Praxis am meisten? <question>"
"In SMALLTALK gibt es also eine Hierarchie, die auf dem Konzept der Klassifikation aufbaut. Aufgrund praktischer Überlegungen ist diese Hierarchie beschränkt; sie ist mit der Sprachdefinition festgelegt und stellt gewissermaßen einen Teil derselben dar. Konzeptionell ist diese Hierarchie eine Abstraktionshierarchie: Von den konkreten Objekten der Ebene 0 geht es über die Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Konzepte auf Ebene 2 und schließlich zur Fassung von Definitionen allgemein auf Ebene 3. Mit jeder Stufe, mit Ausnahme der mittleren, wird die Zahl der Objekte, die unter die darin angesiedelten Konzepte fallen, drastisch reduziert: von Ebene 0 auf Ebene 1 von theoretisch unendlich vielen Objekten einer Anwendung zur Zahl der Anwendungsklassen, von Ebene 2 auf Ebene 3.
In der Praxis bewegen Sie sich jedoch vor allem auf Ebene 1: Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen Sie also nur eine Abstraktionsstufe für die Programmierung.","<answer> Die Hierarchie in SMALLTALK ist aus praktischen Überlegungen beschränkt und ist in der Sprachdefinition festgelegt. Dies bedeutet, dass die Hierarchie nicht unbegrenzt erweitert oder verändert werden kann, sondern einen festen Rahmen hat. <answer> <question> Warum ist die Hierarchie in SMALLTALK beschränkt? <question>"
"Man kann nun argumentieren, dass die Substituierbarkeit im Einzelfall von der jeweiligen Verwendung der Typen abhängt (vgl. Fußnote 86). Im Beispiel von ""Set"" und ""Bag"" kann man daher nicht grundsätzlich behaupten, dass das eine den Ersatz des anderen ausschließt. Es kann durchaus Anwendungsfälle für den einen oder anderen Typ geben, in denen der jeweils andere als Ersatz dienen kann. Das Vorhandensein einer tatsächlichen Substituierbarkeit hängt also nicht allein von den beteiligten Typen ab, sondern auch von ihrer Verwendung. Dies wiederum bedeutet (auch vor dem Hintergrund des oben Gesagten zur funktionalen Äquivalenz), dass es so etwas wie eine absolute Substituierbarkeit, die von jeder möglichen Verwendung losgelöst ist, eigentlich nicht existiert.
Wie kann man diesem Umstand begegnen? Nun, indem man nicht nur die Sichtweise der Programmiererin berücksichtigt, die die Typen erstellt und sich um deren Substituierbarkeit (sowie die darauf basierende Subtypenbeziehung) kümmert, sondern auch die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte. Nur diese Programmiererin weiß genau, welche Erwartungen sie an einen Typen (genauer gesagt, an die Objekte eines Typs) hat, und nur sie kann beurteilen, welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind.
Wie drückt aber die Programmiererin ihre Erwartungen aus? Die Antwort ist überraschend einfach: Sie definiert selbst einen Typen, dessen Definition nur die Eigenschaften umfasst, die sie benötigt. Ein solcher Typ spezifiziert gewissermaßen die Rolle, die die Objekte im Kontext der Verwendung spielen sollen. In der Regel wird dieser Typ nur einen Teil der Eigenschaften umfassen, die allgemeine Typen wie ""Set"" oder ""Bag"" spezifizieren. Im Gegenzug erweitert sich jedoch die Auswahl der Typen, deren Objekte für ihre speziellen Zwecke in Frage kommen.
Die einzige Voraussetzung dafür, dass Objekte die ihnen aus Sicht der Anwenderin zugewiesene Rolle auch tatsächlich spielen können, ist, dass sie typkonform sind.
Diese doppelte Sichtweise auf Typen, sowohl aus Sicht der Nutzerin als auch aus Sicht der Anbieterin, beginnt sich erst langsam durchzusetzen. Die Programmiersprachen Java und später auch C# bieten immerhin das Konzept von ""Interfaces als Typen"" an (siehe Kapitel 40 in Kurseinheit 4 und Abschnitt 50.4.2 in Kurseinheit 5), mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. In der Praxis wird diese Möglichkeit jedoch in beiden Sprachen selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen. Möglicherweise wird dies in Zukunft anders gehandhabt.","<answer> Die Substituierbarkeit von Typen hängt von ihrer jeweiligen Verwendung ab, da verschiedene Anwendungsfälle unterschiedliche Anforderungen an Typen und deren Objekte haben können. Ein Typ kann in einem bestimmten Kontext problemlos durch einen anderen Typen ersetzt werden, während dies in einem anderen Kontext nicht der Fall sein kann. Die Substituierbarkeit ist daher relativ zur Verwendung der Typen. <answer> <question> Warum hängt die Substituierbarkeit von Typen von ihrer jeweiligen Verwendung ab? <question>"
"Man kann nun argumentieren, dass die Substituierbarkeit im Einzelfall von der jeweiligen Verwendung der Typen abhängt (vgl. Fußnote 86). Im Beispiel von ""Set"" und ""Bag"" kann man daher nicht grundsätzlich behaupten, dass das eine den Ersatz des anderen ausschließt. Es kann durchaus Anwendungsfälle für den einen oder anderen Typ geben, in denen der jeweils andere als Ersatz dienen kann. Das Vorhandensein einer tatsächlichen Substituierbarkeit hängt also nicht allein von den beteiligten Typen ab, sondern auch von ihrer Verwendung. Dies wiederum bedeutet (auch vor dem Hintergrund des oben Gesagten zur funktionalen Äquivalenz), dass es so etwas wie eine absolute Substituierbarkeit, die von jeder möglichen Verwendung losgelöst ist, eigentlich nicht existiert.
Wie kann man diesem Umstand begegnen? Nun, indem man nicht nur die Sichtweise der Programmiererin berücksichtigt, die die Typen erstellt und sich um deren Substituierbarkeit (sowie die darauf basierende Subtypenbeziehung) kümmert, sondern auch die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte. Nur diese Programmiererin weiß genau, welche Erwartungen sie an einen Typen (genauer gesagt, an die Objekte eines Typs) hat, und nur sie kann beurteilen, welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind.
Wie drückt aber die Programmiererin ihre Erwartungen aus? Die Antwort ist überraschend einfach: Sie definiert selbst einen Typen, dessen Definition nur die Eigenschaften umfasst, die sie benötigt. Ein solcher Typ spezifiziert gewissermaßen die Rolle, die die Objekte im Kontext der Verwendung spielen sollen. In der Regel wird dieser Typ nur einen Teil der Eigenschaften umfassen, die allgemeine Typen wie ""Set"" oder ""Bag"" spezifizieren. Im Gegenzug erweitert sich jedoch die Auswahl der Typen, deren Objekte für ihre speziellen Zwecke in Frage kommen.
Die einzige Voraussetzung dafür, dass Objekte die ihnen aus Sicht der Anwenderin zugewiesene Rolle auch tatsächlich spielen können, ist, dass sie typkonform sind.
Diese doppelte Sichtweise auf Typen, sowohl aus Sicht der Nutzerin als auch aus Sicht der Anbieterin, beginnt sich erst langsam durchzusetzen. Die Programmiersprachen Java und später auch C# bieten immerhin das Konzept von ""Interfaces als Typen"" an (siehe Kapitel 40 in Kurseinheit 4 und Abschnitt 50.4.2 in Kurseinheit 5), mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. In der Praxis wird diese Möglichkeit jedoch in beiden Sprachen selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen. Möglicherweise wird dies in Zukunft anders gehandhabt.","<answer> Man kann dem Umstand der relativen Substituierbarkeit begegnen, indem man nicht nur die Sichtweise der Person berücksichtigt, die die Typen erstellt (die Anbieterin), sondern auch die Sichtweise der Person, die die Typen für einen bestimmten Zweck verwendet (die Nutzerin). Die Nutzerin kann ihre Erwartungen an einen Typen definieren, indem sie einen eigenen Typen erstellt, der nur die benötigten Eigenschaften umfasst. Dieser Typ spezifiziert die Rolle, die die Objekte im Kontext der Verwendung spielen sollen. Die Auswahl der Typen, deren Objekte für spezielle Zwecke in Frage kommen, erweitert sich dadurch, ohne die Substituierbarkeit zu beeinträchtigen. <answer> <question> Wie kann man dem Umstand der relativen Substituierbarkeit begegnen? <question>"
"Man kann nun argumentieren, dass die Substituierbarkeit im Einzelfall von der jeweiligen Verwendung der Typen abhängt (vgl. Fußnote 86). Im Beispiel von ""Set"" und ""Bag"" kann man daher nicht grundsätzlich behaupten, dass das eine den Ersatz des anderen ausschließt. Es kann durchaus Anwendungsfälle für den einen oder anderen Typ geben, in denen der jeweils andere als Ersatz dienen kann. Das Vorhandensein einer tatsächlichen Substituierbarkeit hängt also nicht allein von den beteiligten Typen ab, sondern auch von ihrer Verwendung. Dies wiederum bedeutet (auch vor dem Hintergrund des oben Gesagten zur funktionalen Äquivalenz), dass es so etwas wie eine absolute Substituierbarkeit, die von jeder möglichen Verwendung losgelöst ist, eigentlich nicht existiert.
Wie kann man diesem Umstand begegnen? Nun, indem man nicht nur die Sichtweise der Programmiererin berücksichtigt, die die Typen erstellt und sich um deren Substituierbarkeit (sowie die darauf basierende Subtypenbeziehung) kümmert, sondern auch die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte. Nur diese Programmiererin weiß genau, welche Erwartungen sie an einen Typen (genauer gesagt, an die Objekte eines Typs) hat, und nur sie kann beurteilen, welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind.
Wie drückt aber die Programmiererin ihre Erwartungen aus? Die Antwort ist überraschend einfach: Sie definiert selbst einen Typen, dessen Definition nur die Eigenschaften umfasst, die sie benötigt. Ein solcher Typ spezifiziert gewissermaßen die Rolle, die die Objekte im Kontext der Verwendung spielen sollen. In der Regel wird dieser Typ nur einen Teil der Eigenschaften umfassen, die allgemeine Typen wie ""Set"" oder ""Bag"" spezifizieren. Im Gegenzug erweitert sich jedoch die Auswahl der Typen, deren Objekte für ihre speziellen Zwecke in Frage kommen.
Die einzige Voraussetzung dafür, dass Objekte die ihnen aus Sicht der Anwenderin zugewiesene Rolle auch tatsächlich spielen können, ist, dass sie typkonform sind.
Diese doppelte Sichtweise auf Typen, sowohl aus Sicht der Nutzerin als auch aus Sicht der Anbieterin, beginnt sich erst langsam durchzusetzen. Die Programmiersprachen Java und später auch C# bieten immerhin das Konzept von ""Interfaces als Typen"" an (siehe Kapitel 40 in Kurseinheit 4 und Abschnitt 50.4.2 in Kurseinheit 5), mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. In der Praxis wird diese Möglichkeit jedoch in beiden Sprachen selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen. Möglicherweise wird dies in Zukunft anders gehandhabt.","<answer> Die Programmiererin kann ihre Erwartungen an Typen ausdrücken, indem sie einen eigenen Typen definiert, der nur die benötigten Eigenschaften umfasst. Dieser Typ stellt gewissermaßen die Rolle dar, die die Objekte im Kontext der Verwendung spielen sollen. Durch die Definition solcher Typen kann die Programmiererin ihre Anforderungen klar ausdrücken und sicherstellen, dass die Typen ihren speziellen Zwecken entsprechen. <answer> <question> Wie kann die Programmiererin ihre Erwartungen an Typen ausdrücken? <question>"
"Man kann nun argumentieren, dass die Substituierbarkeit im Einzelfall von der jeweiligen Verwendung der Typen abhängt (vgl. Fußnote 86). Im Beispiel von ""Set"" und ""Bag"" kann man daher nicht grundsätzlich behaupten, dass das eine den Ersatz des anderen ausschließt. Es kann durchaus Anwendungsfälle für den einen oder anderen Typ geben, in denen der jeweils andere als Ersatz dienen kann. Das Vorhandensein einer tatsächlichen Substituierbarkeit hängt also nicht allein von den beteiligten Typen ab, sondern auch von ihrer Verwendung. Dies wiederum bedeutet (auch vor dem Hintergrund des oben Gesagten zur funktionalen Äquivalenz), dass es so etwas wie eine absolute Substituierbarkeit, die von jeder möglichen Verwendung losgelöst ist, eigentlich nicht existiert.
Wie kann man diesem Umstand begegnen? Nun, indem man nicht nur die Sichtweise der Programmiererin berücksichtigt, die die Typen erstellt und sich um deren Substituierbarkeit (sowie die darauf basierende Subtypenbeziehung) kümmert, sondern auch die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte. Nur diese Programmiererin weiß genau, welche Erwartungen sie an einen Typen (genauer gesagt, an die Objekte eines Typs) hat, und nur sie kann beurteilen, welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind.
Wie drückt aber die Programmiererin ihre Erwartungen aus? Die Antwort ist überraschend einfach: Sie definiert selbst einen Typen, dessen Definition nur die Eigenschaften umfasst, die sie benötigt. Ein solcher Typ spezifiziert gewissermaßen die Rolle, die die Objekte im Kontext der Verwendung spielen sollen. In der Regel wird dieser Typ nur einen Teil der Eigenschaften umfassen, die allgemeine Typen wie ""Set"" oder ""Bag"" spezifizieren. Im Gegenzug erweitert sich jedoch die Auswahl der Typen, deren Objekte für ihre speziellen Zwecke in Frage kommen.
Die einzige Voraussetzung dafür, dass Objekte die ihnen aus Sicht der Anwenderin zugewiesene Rolle auch tatsächlich spielen können, ist, dass sie typkonform sind.
Diese doppelte Sichtweise auf Typen, sowohl aus Sicht der Nutzerin als auch aus Sicht der Anbieterin, beginnt sich erst langsam durchzusetzen. Die Programmiersprachen Java und später auch C# bieten immerhin das Konzept von ""Interfaces als Typen"" an (siehe Kapitel 40 in Kurseinheit 4 und Abschnitt 50.4.2 in Kurseinheit 5), mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. In der Praxis wird diese Möglichkeit jedoch in beiden Sprachen selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen. Möglicherweise wird dies in Zukunft anders gehandhabt.","<answer> Programmiersprachen wie Java und C# bieten das Konzept von ""Interfaces als Typen"" an, mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. Dies ermöglicht es den Nutzerinnen, ihre eigenen Anforderungen als Typen zu definieren. Allerdings wird diese Möglichkeit in der Praxis oft nicht genutzt, um Anwenderinnen ihre eigenen Typen definieren zu lassen. Es wird jedoch darauf hingewiesen, dass dies in Zukunft anders gehandhabt werden könnte. <answer> <question> Welches Konzept bieten Programmiersprachen wie Java und C#, um die doppelte Sichtweise auf Typen zu unterstützen? <question>"
"Als JAVA entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht privat deklariert ist, ist zugreifbar), nach außen sind jedoch nur öffentlich deklarierte Programmelemente sichtbar.
Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.
Diese unbefriedigende Situation wurde von der JAVA-Community aufgegriffen, die mit der Open Services Gateway Initiative (OSGi) einen Standard etablierte, der die Zusammenfassung von JAVA-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation erlaubte. Dieser Standard ist unter anderem die Grundlage von Eclipse, das nicht nur eine JAVA-IDE, sondern im Kern ein Framework für die Entwicklung beliebig komplexer JAVA-Programme (sog. Rich Clients) ist.
Mit JAVA 9 wurde dann JAVA ein eigenes, über Klassen und Paketen stehendes Modulkonzept verpasst. Ein Modul ist demnach eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Eine Moduldeklaration besteht aus einem (eindeutigen) Namen des Moduls, einer Deklaration der angebotenen Schnittstelle (bislang über öffentliche Deklarationen hergestellt) und einer Deklaration der benötigten Schnittstelle (bislang ausschließlich über import-Direktiven deklariert). Neben den allgemeinen Export tritt der sog. qualifizierte Export, wie er auch in EIFFEL vorgesehen ist: Er nennt die Module, an die exportiert wird, namentlich und erlaubt so einen „privaten“ Austausch zwischen bestimmten Modulen (die somit ihre eigenen, oder privaten, Schnittstellen haben).
Das Besondere an der Moduldefinition von JAVA ist, dass die Einhaltung der damit einhergehenden Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit erzwungen wird. Außerdem kontrolliert sie auch den reflektiven Zugriff auf Programmelemente, der bislang gar nicht unterbunden werden konnte. JAVA-Programme werden dadurch erheblich sicherer.","<answer> Der ursprüngliche Ansatz von JAVA, bei dem alle Klassen eines Programms zu einem Paket zusammengefasst werden können, funktioniert nicht mehr, wenn Programme in mehrere Pakete aufgeteilt werden, weil Abhängigkeiten zwischen den Paketen öffentliche Deklarationen erfordern, die dann jedoch alle Programmelemente für jeden sichtbar machen, was die Modularität einschränkt. <answer> <question> Warum funktioniert der ursprüngliche Ansatz von JAVA, bei dem alle Klassen eines Programms zu einem Paket zusammengefasst werden können, nicht mehr, wenn Programme in mehrere Pakete aufgeteilt werden? <question>"
"Als JAVA entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht privat deklariert ist, ist zugreifbar), nach außen sind jedoch nur öffentlich deklarierte Programmelemente sichtbar.
Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.
Diese unbefriedigende Situation wurde von der JAVA-Community aufgegriffen, die mit der Open Services Gateway Initiative (OSGi) einen Standard etablierte, der die Zusammenfassung von JAVA-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation erlaubte. Dieser Standard ist unter anderem die Grundlage von Eclipse, das nicht nur eine JAVA-IDE, sondern im Kern ein Framework für die Entwicklung beliebig komplexer JAVA-Programme (sog. Rich Clients) ist.
Mit JAVA 9 wurde dann JAVA ein eigenes, über Klassen und Paketen stehendes Modulkonzept verpasst. Ein Modul ist demnach eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Eine Moduldeklaration besteht aus einem (eindeutigen) Namen des Moduls, einer Deklaration der angebotenen Schnittstelle (bislang über öffentliche Deklarationen hergestellt) und einer Deklaration der benötigten Schnittstelle (bislang ausschließlich über import-Direktiven deklariert). Neben den allgemeinen Export tritt der sog. qualifizierte Export, wie er auch in EIFFEL vorgesehen ist: Er nennt die Module, an die exportiert wird, namentlich und erlaubt so einen „privaten“ Austausch zwischen bestimmten Modulen (die somit ihre eigenen, oder privaten, Schnittstellen haben).
Das Besondere an der Moduldefinition von JAVA ist, dass die Einhaltung der damit einhergehenden Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit erzwungen wird. Außerdem kontrolliert sie auch den reflektiven Zugriff auf Programmelemente, der bislang gar nicht unterbunden werden konnte. JAVA-Programme werden dadurch erheblich sicherer.","<answer> Die JAVA-Community griff die Open Services Gateway Initiative (OSGi) auf, um die Situation mit aufgeteilten Paketen zu verbessern. OSGi ermöglichte die Zusammenfassung von JAVA-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation. <answer> <question> Welche Initiative wurde von der JAVA-Community aufgegriffen, um die Situation mit aufgeteilten Paketen zu verbessern? <question>"
"Als JAVA entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht privat deklariert ist, ist zugreifbar), nach außen sind jedoch nur öffentlich deklarierte Programmelemente sichtbar.
Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.
Diese unbefriedigende Situation wurde von der JAVA-Community aufgegriffen, die mit der Open Services Gateway Initiative (OSGi) einen Standard etablierte, der die Zusammenfassung von JAVA-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation erlaubte. Dieser Standard ist unter anderem die Grundlage von Eclipse, das nicht nur eine JAVA-IDE, sondern im Kern ein Framework für die Entwicklung beliebig komplexer JAVA-Programme (sog. Rich Clients) ist.
Mit JAVA 9 wurde dann JAVA ein eigenes, über Klassen und Paketen stehendes Modulkonzept verpasst. Ein Modul ist demnach eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Eine Moduldeklaration besteht aus einem (eindeutigen) Namen des Moduls, einer Deklaration der angebotenen Schnittstelle (bislang über öffentliche Deklarationen hergestellt) und einer Deklaration der benötigten Schnittstelle (bislang ausschließlich über import-Direktiven deklariert). Neben den allgemeinen Export tritt der sog. qualifizierte Export, wie er auch in EIFFEL vorgesehen ist: Er nennt die Module, an die exportiert wird, namentlich und erlaubt so einen „privaten“ Austausch zwischen bestimmten Modulen (die somit ihre eigenen, oder privaten, Schnittstellen haben).
Das Besondere an der Moduldefinition von JAVA ist, dass die Einhaltung der damit einhergehenden Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit erzwungen wird. Außerdem kontrolliert sie auch den reflektiven Zugriff auf Programmelemente, der bislang gar nicht unterbunden werden konnte. JAVA-Programme werden dadurch erheblich sicherer.","<answer> Mit JAVA 9 wurde ein eigenes Modulkonzept eingeführt, das über Klassen und Paketen steht. Ein Modul in JAVA 9 ist eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Die Moduldeklaration umfasst den Namen des Moduls, die angebotene Schnittstelle und die benötigte Schnittstelle. <answer> <question> Was wurde mit JAVA 9 eingeführt, um das Problem der Modularität in JAVA zu lösen? <question>"
"Als JAVA entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht privat deklariert ist, ist zugreifbar), nach außen sind jedoch nur öffentlich deklarierte Programmelemente sichtbar.
Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.
Diese unbefriedigende Situation wurde von der JAVA-Community aufgegriffen, die mit der Open Services Gateway Initiative (OSGi) einen Standard etablierte, der die Zusammenfassung von JAVA-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation erlaubte. Dieser Standard ist unter anderem die Grundlage von Eclipse, das nicht nur eine JAVA-IDE, sondern im Kern ein Framework für die Entwicklung beliebig komplexer JAVA-Programme (sog. Rich Clients) ist.
Mit JAVA 9 wurde dann JAVA ein eigenes, über Klassen und Paketen stehendes Modulkonzept verpasst. Ein Modul ist demnach eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Eine Moduldeklaration besteht aus einem (eindeutigen) Namen des Moduls, einer Deklaration der angebotenen Schnittstelle (bislang über öffentliche Deklarationen hergestellt) und einer Deklaration der benötigten Schnittstelle (bislang ausschließlich über import-Direktiven deklariert). Neben den allgemeinen Export tritt der sog. qualifizierte Export, wie er auch in EIFFEL vorgesehen ist: Er nennt die Module, an die exportiert wird, namentlich und erlaubt so einen „privaten“ Austausch zwischen bestimmten Modulen (die somit ihre eigenen, oder privaten, Schnittstellen haben).
Das Besondere an der Moduldefinition von JAVA ist, dass die Einhaltung der damit einhergehenden Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit erzwungen wird. Außerdem kontrolliert sie auch den reflektiven Zugriff auf Programmelemente, der bislang gar nicht unterbunden werden konnte. JAVA-Programme werden dadurch erheblich sicherer.","<answer> Der qualifizierte Export in der Moduldefinition von JAVA ist ähnlich wie in EIFFEL. Er nennt die Module, an die exportiert wird, namentlich und erlaubt einen ""privaten"" Austausch zwischen bestimmten Modulen, die somit ihre eigenen, privaten Schnittstellen haben. <answer> <question> Was ist der qualifizierte Export in der Moduldefinition von JAVA? <question>"
"Als JAVA entworfen wurde, ging man wohl davon aus, dass ein Programm aus mehreren Klassen besteht, die alle zu einem Paket zusammengefasst werden können. Die Klassen eines Programms gewähren sich somit untereinander privilegierten Zugriff (alles, was nicht privat deklariert ist, ist zugreifbar), nach außen sind jedoch nur öffentlich deklarierte Programmelemente sichtbar.
Dieser Ansatz funktioniert jedoch in dem Moment nicht mehr, in dem Programme auf mehrere Pakete aufgeteilt werden. Wenn zwischen den Paketen nämlich Abhängigkeiten bestehen (was, wenn die Pakete zusammen ein Programm repräsentieren, naturgemäß der Fall ist), dann sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.
Diese unbefriedigende Situation wurde von der JAVA-Community aufgegriffen, die mit der Open Services Gateway Initiative (OSGi) einen Standard etablierte, der die Zusammenfassung von JAVA-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation erlaubte. Dieser Standard ist unter anderem die Grundlage von Eclipse, das nicht nur eine JAVA-IDE, sondern im Kern ein Framework für die Entwicklung beliebig komplexer JAVA-Programme (sog. Rich Clients) ist.
Mit JAVA 9 wurde dann JAVA ein eigenes, über Klassen und Paketen stehendes Modulkonzept verpasst. Ein Modul ist demnach eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Eine Moduldeklaration besteht aus einem (eindeutigen) Namen des Moduls, einer Deklaration der angebotenen Schnittstelle (bislang über öffentliche Deklarationen hergestellt) und einer Deklaration der benötigten Schnittstelle (bislang ausschließlich über import-Direktiven deklariert). Neben den allgemeinen Export tritt der sog. qualifizierte Export, wie er auch in EIFFEL vorgesehen ist: Er nennt die Module, an die exportiert wird, namentlich und erlaubt so einen „privaten“ Austausch zwischen bestimmten Modulen (die somit ihre eigenen, oder privaten, Schnittstellen haben).
Das Besondere an der Moduldefinition von JAVA ist, dass die Einhaltung der damit einhergehenden Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit erzwungen wird. Außerdem kontrolliert sie auch den reflektiven Zugriff auf Programmelemente, der bislang gar nicht unterbunden werden konnte. JAVA-Programme werden dadurch erheblich sicherer.","<answer> Die Moduldefinition von JAVA erzwingt die Einhaltung der Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit. Sie kontrolliert auch den reflektiven Zugriff auf Programmelemente, was zu einer erheblichen Verbesserung der Sicherheit von JAVA-Programmen führt. <answer> <question> Was ist das Besondere an der Moduldefinition von JAVA in Bezug auf die Einhaltung der Schnittstellenspezifikationen? <question>"
"Jedem Objekt können eine Menge von lokalen Variablen zugeordnet werden. Aus Gründen, auf die wir noch zu sprechen kommen, heißen diese Variablen Instanzvariablen; sie werden aber manchmal auch als Felder oder Attribute (zu Attributen siehe Abschnitt 2.4) bezeichnet. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: Sie sind für andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschränkt. Außerdem ist die Existenz dieser Variablen an die Existenz (oder Lebensdauer; siehe Abschnitt 1.9) des besitzenden Objekts gebunden.
Instanzvariablen bestimmen die Struktur zusammengesetzter Objekte (die manchmal deswegen auch strukturierte Objekte genannt werden) — atomare Objekte haben keine Instanzvariablen. Jede Instanzvariable eines Objekts belegt dabei einen Teil des Speichers aus seiner Repräsentation, indem sie öffentlich zugängliche Instanzvariablen erlauben und selbst nicht verhindern, dass ein anderes Objekt der gleichen Klasse darauf zugreift. Etwas anderes ist es jedoch auch in SMALLTALK mit den Objekten, auf die die Variablen verweisen: Aufgrund möglicher Aliase kann der Zugriff nicht so leicht einem einzigen Objekt vorbehalten werden.
In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.
Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: <objekt> at: i.
Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig: Tatsächlich speichern Array-Objekte ihre Elemente in indizierten Instanzvariablen. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C# und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen (siehe Abschnitt 50.3.2 in Kurseinheit 5). Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.
Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix. Damit ist auch die Größe eines Objekts mit indizierten Instanzvariablen fest; insbesondere können Array-Objekte nicht wachsen (und wenn doch, dann nur über den in Abschnitt 1.1 erwähnten Trick mit dem Wechsel der Identität). Es müssen aber nicht alle indizierten Instanzvariablen belegt sein; die „leeren“ enthalten dann nil (siehe unten).
Es bleibt noch die Frage, wie Objekte in SMALLTALK in den Besitz von Instanzvariablen gelangen. Um das zu erklären, müsste an dieser Stelle auf das Konzept der Klasse vorgegriffen werden, was aber aus didaktischen Gründen unterbleiben soll. Gelernte PASCAL-Programmierer können sich die Instanzvariablen jedoch wie die Felder eines Records vorstellen (oder C-Programmierer wie die eines Structs), die in der Record-Definition festgelegt werden und die für jede Variable vom Typ dieses Records zur Verfügung stehen. Für alle anderen mag es reichen, sich vorzustellen, dass jedes Objekt automatisch über zwei spezielle Variablen verfügt, die die Namen und die zugewiesenen Objekte aller seiner Instanzvariablen verwalten. Wie so etwas gehen kann, wird in der nächsten Kurseinheit klarwerden.","<answer> Instanzvariablen sind lokale Variablen, die einem Objekt zugeordnet sind und dazu verwendet werden, Informationen zu speichern, die spezifisch für dieses Objekt sind. Sie bestimmen die Struktur zusammengesetzter Objekte. <answer> <question> Was sind Instanzvariablen in der objektorientierten Programmierung? <question>"
"Jedem Objekt können eine Menge von lokalen Variablen zugeordnet werden. Aus Gründen, auf die wir noch zu sprechen kommen, heißen diese Variablen Instanzvariablen; sie werden aber manchmal auch als Felder oder Attribute (zu Attributen siehe Abschnitt 2.4) bezeichnet. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: Sie sind für andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschränkt. Außerdem ist die Existenz dieser Variablen an die Existenz (oder Lebensdauer; siehe Abschnitt 1.9) des besitzenden Objekts gebunden.
Instanzvariablen bestimmen die Struktur zusammengesetzter Objekte (die manchmal deswegen auch strukturierte Objekte genannt werden) — atomare Objekte haben keine Instanzvariablen. Jede Instanzvariable eines Objekts belegt dabei einen Teil des Speichers aus seiner Repräsentation, indem sie öffentlich zugängliche Instanzvariablen erlauben und selbst nicht verhindern, dass ein anderes Objekt der gleichen Klasse darauf zugreift. Etwas anderes ist es jedoch auch in SMALLTALK mit den Objekten, auf die die Variablen verweisen: Aufgrund möglicher Aliase kann der Zugriff nicht so leicht einem einzigen Objekt vorbehalten werden.
In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.
Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: <objekt> at: i.
Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig: Tatsächlich speichern Array-Objekte ihre Elemente in indizierten Instanzvariablen. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C# und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen (siehe Abschnitt 50.3.2 in Kurseinheit 5). Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.
Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix. Damit ist auch die Größe eines Objekts mit indizierten Instanzvariablen fest; insbesondere können Array-Objekte nicht wachsen (und wenn doch, dann nur über den in Abschnitt 1.1 erwähnten Trick mit dem Wechsel der Identität). Es müssen aber nicht alle indizierten Instanzvariablen belegt sein; die „leeren“ enthalten dann nil (siehe unten).
Es bleibt noch die Frage, wie Objekte in SMALLTALK in den Besitz von Instanzvariablen gelangen. Um das zu erklären, müsste an dieser Stelle auf das Konzept der Klasse vorgegriffen werden, was aber aus didaktischen Gründen unterbleiben soll. Gelernte PASCAL-Programmierer können sich die Instanzvariablen jedoch wie die Felder eines Records vorstellen (oder C-Programmierer wie die eines Structs), die in der Record-Definition festgelegt werden und die für jede Variable vom Typ dieses Records zur Verfügung stehen. Für alle anderen mag es reichen, sich vorzustellen, dass jedes Objekt automatisch über zwei spezielle Variablen verfügt, die die Namen und die zugewiesenen Objekte aller seiner Instanzvariablen verwalten. Wie so etwas gehen kann, wird in der nächsten Kurseinheit klarwerden.",<answer> Instanzvariablen sind nur für das jeweilige besitzende Objekt sichtbar und können von anderen Objekten nicht direkt zugegriffen werden. Die Sichtbarkeit ist auf das besitzende Objekt beschränkt. <answer> <question> Wie ist die Sichtbarkeit von Instanzvariablen in SMALLTALK? <question>
"Jedem Objekt können eine Menge von lokalen Variablen zugeordnet werden. Aus Gründen, auf die wir noch zu sprechen kommen, heißen diese Variablen Instanzvariablen; sie werden aber manchmal auch als Felder oder Attribute (zu Attributen siehe Abschnitt 2.4) bezeichnet. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: Sie sind für andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschränkt. Außerdem ist die Existenz dieser Variablen an die Existenz (oder Lebensdauer; siehe Abschnitt 1.9) des besitzenden Objekts gebunden.
Instanzvariablen bestimmen die Struktur zusammengesetzter Objekte (die manchmal deswegen auch strukturierte Objekte genannt werden) — atomare Objekte haben keine Instanzvariablen. Jede Instanzvariable eines Objekts belegt dabei einen Teil des Speichers aus seiner Repräsentation, indem sie öffentlich zugängliche Instanzvariablen erlauben und selbst nicht verhindern, dass ein anderes Objekt der gleichen Klasse darauf zugreift. Etwas anderes ist es jedoch auch in SMALLTALK mit den Objekten, auf die die Variablen verweisen: Aufgrund möglicher Aliase kann der Zugriff nicht so leicht einem einzigen Objekt vorbehalten werden.
In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.
Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: <objekt> at: i.
Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig: Tatsächlich speichern Array-Objekte ihre Elemente in indizierten Instanzvariablen. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C# und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen (siehe Abschnitt 50.3.2 in Kurseinheit 5). Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.
Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix. Damit ist auch die Größe eines Objekts mit indizierten Instanzvariablen fest; insbesondere können Array-Objekte nicht wachsen (und wenn doch, dann nur über den in Abschnitt 1.1 erwähnten Trick mit dem Wechsel der Identität). Es müssen aber nicht alle indizierten Instanzvariablen belegt sein; die „leeren“ enthalten dann nil (siehe unten).
Es bleibt noch die Frage, wie Objekte in SMALLTALK in den Besitz von Instanzvariablen gelangen. Um das zu erklären, müsste an dieser Stelle auf das Konzept der Klasse vorgegriffen werden, was aber aus didaktischen Gründen unterbleiben soll. Gelernte PASCAL-Programmierer können sich die Instanzvariablen jedoch wie die Felder eines Records vorstellen (oder C-Programmierer wie die eines Structs), die in der Record-Definition festgelegt werden und die für jede Variable vom Typ dieses Records zur Verfügung stehen. Für alle anderen mag es reichen, sich vorzustellen, dass jedes Objekt automatisch über zwei spezielle Variablen verfügt, die die Namen und die zugewiesenen Objekte aller seiner Instanzvariablen verwalten. Wie so etwas gehen kann, wird in der nächsten Kurseinheit klarwerden.","<answer> Benannte Instanzvariablen sind Instanzvariablen, die jeweils auf ein bestimmtes Objekt verweisen oder es benennen. Der Name der Variablen wird zum Namen des Objekts, auf das sie verweisen. <answer> <question> Was sind benannte Instanzvariablen in SMALLTALK? <question>"
"Jedem Objekt können eine Menge von lokalen Variablen zugeordnet werden. Aus Gründen, auf die wir noch zu sprechen kommen, heißen diese Variablen Instanzvariablen; sie werden aber manchmal auch als Felder oder Attribute (zu Attributen siehe Abschnitt 2.4) bezeichnet. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: Sie sind für andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschränkt. Außerdem ist die Existenz dieser Variablen an die Existenz (oder Lebensdauer; siehe Abschnitt 1.9) des besitzenden Objekts gebunden.
Instanzvariablen bestimmen die Struktur zusammengesetzter Objekte (die manchmal deswegen auch strukturierte Objekte genannt werden) — atomare Objekte haben keine Instanzvariablen. Jede Instanzvariable eines Objekts belegt dabei einen Teil des Speichers aus seiner Repräsentation, indem sie öffentlich zugängliche Instanzvariablen erlauben und selbst nicht verhindern, dass ein anderes Objekt der gleichen Klasse darauf zugreift. Etwas anderes ist es jedoch auch in SMALLTALK mit den Objekten, auf die die Variablen verweisen: Aufgrund möglicher Aliase kann der Zugriff nicht so leicht einem einzigen Objekt vorbehalten werden.
In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.
Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: <objekt> at: i.
Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig: Tatsächlich speichern Array-Objekte ihre Elemente in indizierten Instanzvariablen. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C# und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen (siehe Abschnitt 50.3.2 in Kurseinheit 5). Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.
Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix. Damit ist auch die Größe eines Objekts mit indizierten Instanzvariablen fest; insbesondere können Array-Objekte nicht wachsen (und wenn doch, dann nur über den in Abschnitt 1.1 erwähnten Trick mit dem Wechsel der Identität). Es müssen aber nicht alle indizierten Instanzvariablen belegt sein; die „leeren“ enthalten dann nil (siehe unten).
Es bleibt noch die Frage, wie Objekte in SMALLTALK in den Besitz von Instanzvariablen gelangen. Um das zu erklären, müsste an dieser Stelle auf das Konzept der Klasse vorgegriffen werden, was aber aus didaktischen Gründen unterbleiben soll. Gelernte PASCAL-Programmierer können sich die Instanzvariablen jedoch wie die Felder eines Records vorstellen (oder C-Programmierer wie die eines Structs), die in der Record-Definition festgelegt werden und die für jede Variable vom Typ dieses Records zur Verfügung stehen. Für alle anderen mag es reichen, sich vorzustellen, dass jedes Objekt automatisch über zwei spezielle Variablen verfügt, die die Namen und die zugewiesenen Objekte aller seiner Instanzvariablen verwalten. Wie so etwas gehen kann, wird in der nächsten Kurseinheit klarwerden.","<answer> Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zum Objekt angesprochen, dem sie gehören. Der Index fungiert gewissermaßen als Name für die Instanzvariable. <answer> <question> Was sind indizierte Instanzvariablen in SMALLTALK? <question>"
"Jedem Objekt können eine Menge von lokalen Variablen zugeordnet werden. Aus Gründen, auf die wir noch zu sprechen kommen, heißen diese Variablen Instanzvariablen; sie werden aber manchmal auch als Felder oder Attribute (zu Attributen siehe Abschnitt 2.4) bezeichnet. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: Sie sind für andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschränkt. Außerdem ist die Existenz dieser Variablen an die Existenz (oder Lebensdauer; siehe Abschnitt 1.9) des besitzenden Objekts gebunden.
Instanzvariablen bestimmen die Struktur zusammengesetzter Objekte (die manchmal deswegen auch strukturierte Objekte genannt werden) — atomare Objekte haben keine Instanzvariablen. Jede Instanzvariable eines Objekts belegt dabei einen Teil des Speichers aus seiner Repräsentation, indem sie öffentlich zugängliche Instanzvariablen erlauben und selbst nicht verhindern, dass ein anderes Objekt der gleichen Klasse darauf zugreift. Etwas anderes ist es jedoch auch in SMALLTALK mit den Objekten, auf die die Variablen verweisen: Aufgrund möglicher Aliase kann der Zugriff nicht so leicht einem einzigen Objekt vorbehalten werden.
In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.
Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: <objekt> at: i.
Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig: Tatsächlich speichern Array-Objekte ihre Elemente in indizierten Instanzvariablen. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C# und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen (siehe Abschnitt 50.3.2 in Kurseinheit 5). Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.
Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix. Damit ist auch die Größe eines Objekts mit indizierten Instanzvariablen fest; insbesondere können Array-Objekte nicht wachsen (und wenn doch, dann nur über den in Abschnitt 1.1 erwähnten Trick mit dem Wechsel der Identität). Es müssen aber nicht alle indizierten Instanzvariablen belegt sein; die „leeren“ enthalten dann nil (siehe unten).
Es bleibt noch die Frage, wie Objekte in SMALLTALK in den Besitz von Instanzvariablen gelangen. Um das zu erklären, müsste an dieser Stelle auf das Konzept der Klasse vorgegriffen werden, was aber aus didaktischen Gründen unterbleiben soll. Gelernte PASCAL-Programmierer können sich die Instanzvariablen jedoch wie die Felder eines Records vorstellen (oder C-Programmierer wie die eines Structs), die in der Record-Definition festgelegt werden und die für jede Variable vom Typ dieses Records zur Verfügung stehen. Für alle anderen mag es reichen, sich vorzustellen, dass jedes Objekt automatisch über zwei spezielle Variablen verfügt, die die Namen und die zugewiesenen Objekte aller seiner Instanzvariablen verwalten. Wie so etwas gehen kann, wird in der nächsten Kurseinheit klarwerden.","<answer> C# und VISUAL BASIC sind Beispiele für Programmiersprachen, die sog. Indexer verwenden, die indizierten Instanzvariablen ähnlich sind. <answer> <question> Welche Programmiersprachen außer SMALLTALK verwenden auch indizierte Instanzvariablen? <question>"
"Jedem Objekt können eine Menge von lokalen Variablen zugeordnet werden. Aus Gründen, auf die wir noch zu sprechen kommen, heißen diese Variablen Instanzvariablen; sie werden aber manchmal auch als Felder oder Attribute (zu Attributen siehe Abschnitt 2.4) bezeichnet. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: Sie sind für andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschränkt. Außerdem ist die Existenz dieser Variablen an die Existenz (oder Lebensdauer; siehe Abschnitt 1.9) des besitzenden Objekts gebunden.
Instanzvariablen bestimmen die Struktur zusammengesetzter Objekte (die manchmal deswegen auch strukturierte Objekte genannt werden) — atomare Objekte haben keine Instanzvariablen. Jede Instanzvariable eines Objekts belegt dabei einen Teil des Speichers aus seiner Repräsentation, indem sie öffentlich zugängliche Instanzvariablen erlauben und selbst nicht verhindern, dass ein anderes Objekt der gleichen Klasse darauf zugreift. Etwas anderes ist es jedoch auch in SMALLTALK mit den Objekten, auf die die Variablen verweisen: Aufgrund möglicher Aliase kann der Zugriff nicht so leicht einem einzigen Objekt vorbehalten werden.
In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.
Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: <objekt> at: i.
Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig: Tatsächlich speichern Array-Objekte ihre Elemente in indizierten Instanzvariablen. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C# und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen (siehe Abschnitt 50.3.2 in Kurseinheit 5). Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.
Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix. Damit ist auch die Größe eines Objekts mit indizierten Instanzvariablen fest; insbesondere können Array-Objekte nicht wachsen (und wenn doch, dann nur über den in Abschnitt 1.1 erwähnten Trick mit dem Wechsel der Identität). Es müssen aber nicht alle indizierten Instanzvariablen belegt sein; die „leeren“ enthalten dann nil (siehe unten).
Es bleibt noch die Frage, wie Objekte in SMALLTALK in den Besitz von Instanzvariablen gelangen. Um das zu erklären, müsste an dieser Stelle auf das Konzept der Klasse vorgegriffen werden, was aber aus didaktischen Gründen unterbleiben soll. Gelernte PASCAL-Programmierer können sich die Instanzvariablen jedoch wie die Felder eines Records vorstellen (oder C-Programmierer wie die eines Structs), die in der Record-Definition festgelegt werden und die für jede Variable vom Typ dieses Records zur Verfügung stehen. Für alle anderen mag es reichen, sich vorzustellen, dass jedes Objekt automatisch über zwei spezielle Variablen verfügt, die die Namen und die zugewiesenen Objekte aller seiner Instanzvariablen verwalten. Wie so etwas gehen kann, wird in der nächsten Kurseinheit klarwerden.","<answer> Nein, die Anzahl der indizierten Instanzvariablen eines Objekts ist fest, und die Größe eines Objekts mit indizierten Instanzvariablen ist ebenfalls fest. Die Größe kann nicht geändert werden. <answer> <question> Können Objekte in SMALLTALK ihre indizierten Instanzvariablen vergrößern? <question>"
"Jedem Objekt können eine Menge von lokalen Variablen zugeordnet werden. Aus Gründen, auf die wir noch zu sprechen kommen, heißen diese Variablen Instanzvariablen; sie werden aber manchmal auch als Felder oder Attribute (zu Attributen siehe Abschnitt 2.4) bezeichnet. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: Sie sind für andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschränkt. Außerdem ist die Existenz dieser Variablen an die Existenz (oder Lebensdauer; siehe Abschnitt 1.9) des besitzenden Objekts gebunden.
Instanzvariablen bestimmen die Struktur zusammengesetzter Objekte (die manchmal deswegen auch strukturierte Objekte genannt werden) — atomare Objekte haben keine Instanzvariablen. Jede Instanzvariable eines Objekts belegt dabei einen Teil des Speichers aus seiner Repräsentation, indem sie öffentlich zugängliche Instanzvariablen erlauben und selbst nicht verhindern, dass ein anderes Objekt der gleichen Klasse darauf zugreift. Etwas anderes ist es jedoch auch in SMALLTALK mit den Objekten, auf die die Variablen verweisen: Aufgrund möglicher Aliase kann der Zugriff nicht so leicht einem einzigen Objekt vorbehalten werden.
In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte. Jede benannte Instanzvariable benennt (oder verweist auf) jeweils ein Objekt; der Name der Variable wird somit für die Dauer, in der die Variable auf das Objekt verweist, auch zum Namen des Objekts. Da es sich bei Instanzvariablen um lokale Variablen handelt, muss der Name einer benannten Instanzvariablen in SMALLTALK mit einem Kleinbuchstaben beginnen.
Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zu dem Objekt, zu dem sie gehören, angesprochen. Damit ist der Index gewissermaßen der Name der Instanzvariable. Der Index muss eine natürliche Zahl größer 0 sein. Um den Inhalt der indizierten Instanzvariable an der Indexposition i (genauer: an der Indexposition, die durch das Zahlobjekt bestimmt wird, auf das i verweist) zu erhalten, schreibt man: <objekt> at: i.
Wer bei indizierten Instanzvariablen an Arrays denkt, liegt richtig: Tatsächlich speichern Array-Objekte ihre Elemente in indizierten Instanzvariablen. Indizierte Instanzvariablen sind kein Unikat von SMALLTALK: So bieten beispielsweise C# und VISUAL BASIC sog. Indexer, die im Wesentlichen indizierten Instanzvariablen entsprechen (siehe Abschnitt 50.3.2 in Kurseinheit 5). Auch verfügen manche Objekte in VISUAL BASIC FOR APPLICATIONS (VBA) über eine Variable Item, deren Elemente über Indizierung des Objekts, dem sie zugeordnet ist, angesprochen werden können.
Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix. Damit ist auch die Größe eines Objekts mit indizierten Instanzvariablen fest; insbesondere können Array-Objekte nicht wachsen (und wenn doch, dann nur über den in Abschnitt 1.1 erwähnten Trick mit dem Wechsel der Identität). Es müssen aber nicht alle indizierten Instanzvariablen belegt sein; die „leeren“ enthalten dann nil (siehe unten).
Es bleibt noch die Frage, wie Objekte in SMALLTALK in den Besitz von Instanzvariablen gelangen. Um das zu erklären, müsste an dieser Stelle auf das Konzept der Klasse vorgegriffen werden, was aber aus didaktischen Gründen unterbleiben soll. Gelernte PASCAL-Programmierer können sich die Instanzvariablen jedoch wie die Felder eines Records vorstellen (oder C-Programmierer wie die eines Structs), die in der Record-Definition festgelegt werden und die für jede Variable vom Typ dieses Records zur Verfügung stehen. Für alle anderen mag es reichen, sich vorzustellen, dass jedes Objekt automatisch über zwei spezielle Variablen verfügt, die die Namen und die zugewiesenen Objekte aller seiner Instanzvariablen verwalten. Wie so etwas gehen kann, wird in der nächsten Kurseinheit klarwerden.","<answer> Dies erfordert das Konzept der Klasse, das in diesem Absatz nicht näher erläutert wird. Man kann sich jedoch vorstellen, dass jedes Objekt über spezielle Variablen verfügt, die die Namen und zugewiesenen Objekte seiner Instanzvariablen verwalten. <answer> <question> Wie gelangen Objekte in SMALLTALK in den Besitz von Instanzvariablen? <question>"
"Nicht selten möchte eine überschreibende Methode die überschriebene Methode nicht vollständig ersetzen, sondern lediglich modifizieren. Dies ist z. B. regelmäßig bei den als Konstruktoren fungierenden Klassenmethoden new und new: der Fall: Selbst wenn sie überschrieben werden, müssen sie doch das grundlegende Verhalten beibehalten, also neue Instanzen der Klasse zurückgeben. Dies geschieht am sinnvollsten, indem aus der überschreibenden Methode die überschriebene Methode aufgerufen und um die gewünschten zusätzlichen Ausdrücke ergänzt wird. Nur leider ist diese nicht mehr sichtbar — sie wurde ja gerade überschrieben. Für diesen Zweck verfügt SMALLTALK über eine weitere Pseudovariable namens „super“.
Die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der (direkten) Superklasse der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet.
Man beachte, dass die Suche anders als bei self unabhängig von der Klasse des Objekts ist, für das super steht: Obwohl super genau wie self als Objekt stets den aktuellen Nachrichtenempfänger bezeichnet, bewirkt super immer eine von der Klasse des konkreten Empfängerobjekts losgelöste Suche, die eben mit der Superklasse der Klasse, in der super verwendet wird, beginnt und nicht etwa mit der Superklasse der Klasse, von der das (durch super bezeichnete) Empfängerobjekt eine direkte Instanz ist.","<answer> Die Methode super in SMALLTALK wird verwendet, wenn eine überschreibende Methode die überschriebene Methode nicht vollständig ersetzen, sondern nur modifizieren möchte. Dies kann beispielsweise bei Konstruktoren, wie den Klassenmethoden new und new:, der Fall sein, bei denen das grundlegende Verhalten beibehalten werden muss. super ermöglicht es, die überschriebene Methode aufzurufen und sie um zusätzliche Ausdrücke zu ergänzen. <answer> <question> In welcher Situation ist es sinnvoll, die Methode super in SMALLTALK zu verwenden? <question>"
"Nicht selten möchte eine überschreibende Methode die überschriebene Methode nicht vollständig ersetzen, sondern lediglich modifizieren. Dies ist z. B. regelmäßig bei den als Konstruktoren fungierenden Klassenmethoden new und new: der Fall: Selbst wenn sie überschrieben werden, müssen sie doch das grundlegende Verhalten beibehalten, also neue Instanzen der Klasse zurückgeben. Dies geschieht am sinnvollsten, indem aus der überschreibenden Methode die überschriebene Methode aufgerufen und um die gewünschten zusätzlichen Ausdrücke ergänzt wird. Nur leider ist diese nicht mehr sichtbar — sie wurde ja gerade überschrieben. Für diesen Zweck verfügt SMALLTALK über eine weitere Pseudovariable namens „super“.
Die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der (direkten) Superklasse der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet.
Man beachte, dass die Suche anders als bei self unabhängig von der Klasse des Objekts ist, für das super steht: Obwohl super genau wie self als Objekt stets den aktuellen Nachrichtenempfänger bezeichnet, bewirkt super immer eine von der Klasse des konkreten Empfängerobjekts losgelöste Suche, die eben mit der Superklasse der Klasse, in der super verwendet wird, beginnt und nicht etwa mit der Superklasse der Klasse, von der das (durch super bezeichnete) Empfängerobjekt eine direkte Instanz ist.","<answer> Wenn super als Nachrichtenempfänger in einer Methodendefinition verwendet wird, beginnt die Suche nach der zur Nachricht passenden Methodendefinition in der (direkten) Superklasse der Klasse, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet. Anders als bei self ist die Suche unabhängig von der Klasse des Objekts, für das super steht. Das bedeutet, dass super immer eine von der Klasse des konkreten Empfängerobjekts losgelöste Suche auslöst, die in der Superklasse der Klasse beginnt, in der super verwendet wird, und nicht in der Superklasse der Klasse, von der das (durch super bezeichnete) Empfängerobjekt eine direkte Instanz ist. <answer> <question> Wie funktioniert die Verwendung von super in SMALLTALK? <question>"
"Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Die Genauigkeit dieser informellen Aussage hängt von der eher subtilen Frage ab, was einen Ausführungsfehler darstellt. Selbst wenn dies geklärt ist, ist die Typsicherheit einer Programmiersprache (das Fehlen bestimmter Ausführungsfehler in allen Programmläufen) eine nicht-triviale Eigenschaft. Eine sorgfältige Analyse ist erforderlich, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden. Als Konsequenz hat sich die Klassifikation, Beschreibung und Erforschung von Typsystemen zu einer formalen Disziplin entwickelt.
Im Gegensatz zu SMALLTALK sind die meisten objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration (siehe Kapitel 19) Typen zugeordnet werden. Ein Typ beschränkt die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache. Wenn Sie eine solche Sprache neu erlernen, würden Sie normalerweise nicht daran denken, das Typsystem von der restlichen Sprachdefinition zu trennen. Dennoch sind Typen prinzipiell für das Funktionieren eines Programms entbehrlich, und es kann sich durchaus lohnen, das Typsystem einer Sprache von ihrem Rest zu isolieren, insbesondere wenn Sie es austauschen oder verbessern möchten. Dies gilt umso mehr, da gängige Typsysteme heute entweder ziemlich schwach oder ziemlich komplex sind.
Daher führt diese Kurseinheit in Typsysteme am Beispiel von STRONGTALK ein, einer SMALLTALK-Erweiterung um ein optionales Typsystem. Sie geht dabei langsam und inkrementell vor. Wer das als zu langweilig empfindet, sei gewarnt: Es wird noch kompliziert genug, und nicht jede Leserin wird alles, was sie in diesem Kurs über Typsysteme liest, auf Anhieb verstehen. Es wäre auch eine Option, diese Kurseinheit anhand einer bekannteren Sprache mit einem obligatorischen Typsystem zu erstellen. Dies hätte jedoch den Nachteil, dass das konkrete Typsystem als gegeben angesehen werden müsste. Wenn Sie dann später eine andere Sprache kennenlernen, hätten Sie wahrscheinlich Schwierigkeiten, das Gelernte abzulegen und sich an die neuen Gegebenheiten anzupassen. Das Ziel dieser Kurseinheit ist jedoch, dass Sie Typsysteme als das verstehen, was sie sind: eine Möglichkeit zur Spezifikation redundanter Informationen, die die Qualität von Programmen erhöhen sollen.","<answer> Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Es sorgt dafür, dass Programmelemente bei ihrer Deklaration Typen zugewiesen bekommen, die die Menge der zulässigen Objekte und die erlaubten Operationen auf diesen Objekten einschränken. <answer> <question> Was ist der Zweck eines Typsystems in der objektorientierten Programmierung? <question>"
"Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Die Genauigkeit dieser informellen Aussage hängt von der eher subtilen Frage ab, was einen Ausführungsfehler darstellt. Selbst wenn dies geklärt ist, ist die Typsicherheit einer Programmiersprache (das Fehlen bestimmter Ausführungsfehler in allen Programmläufen) eine nicht-triviale Eigenschaft. Eine sorgfältige Analyse ist erforderlich, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden. Als Konsequenz hat sich die Klassifikation, Beschreibung und Erforschung von Typsystemen zu einer formalen Disziplin entwickelt.
Im Gegensatz zu SMALLTALK sind die meisten objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration (siehe Kapitel 19) Typen zugeordnet werden. Ein Typ beschränkt die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache. Wenn Sie eine solche Sprache neu erlernen, würden Sie normalerweise nicht daran denken, das Typsystem von der restlichen Sprachdefinition zu trennen. Dennoch sind Typen prinzipiell für das Funktionieren eines Programms entbehrlich, und es kann sich durchaus lohnen, das Typsystem einer Sprache von ihrem Rest zu isolieren, insbesondere wenn Sie es austauschen oder verbessern möchten. Dies gilt umso mehr, da gängige Typsysteme heute entweder ziemlich schwach oder ziemlich komplex sind.
Daher führt diese Kurseinheit in Typsysteme am Beispiel von STRONGTALK ein, einer SMALLTALK-Erweiterung um ein optionales Typsystem. Sie geht dabei langsam und inkrementell vor. Wer das als zu langweilig empfindet, sei gewarnt: Es wird noch kompliziert genug, und nicht jede Leserin wird alles, was sie in diesem Kurs über Typsysteme liest, auf Anhieb verstehen. Es wäre auch eine Option, diese Kurseinheit anhand einer bekannteren Sprache mit einem obligatorischen Typsystem zu erstellen. Dies hätte jedoch den Nachteil, dass das konkrete Typsystem als gegeben angesehen werden müsste. Wenn Sie dann später eine andere Sprache kennenlernen, hätten Sie wahrscheinlich Schwierigkeiten, das Gelernte abzulegen und sich an die neuen Gegebenheiten anzupassen. Das Ziel dieser Kurseinheit ist jedoch, dass Sie Typsysteme als das verstehen, was sie sind: eine Möglichkeit zur Spezifikation redundanter Informationen, die die Qualität von Programmen erhöhen sollen.","<answer> Typisierung in objektorientierten Programmiersprachen bedeutet, dass bei der Deklaration von Programmelementen, wie Variablen oder Funktionen, Typen zugeordnet werden. Diese Typen bestimmen, welche Arten von Objekten in diesen Programmelementen gespeichert oder verarbeitet werden können und welche Operationen auf diese Objekte angewendet werden können. <answer> <question> Was bedeutet Typisierung in objektorientierten Programmiersprachen? <question>"
"Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Die Genauigkeit dieser informellen Aussage hängt von der eher subtilen Frage ab, was einen Ausführungsfehler darstellt. Selbst wenn dies geklärt ist, ist die Typsicherheit einer Programmiersprache (das Fehlen bestimmter Ausführungsfehler in allen Programmläufen) eine nicht-triviale Eigenschaft. Eine sorgfältige Analyse ist erforderlich, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden. Als Konsequenz hat sich die Klassifikation, Beschreibung und Erforschung von Typsystemen zu einer formalen Disziplin entwickelt.
Im Gegensatz zu SMALLTALK sind die meisten objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration (siehe Kapitel 19) Typen zugeordnet werden. Ein Typ beschränkt die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache. Wenn Sie eine solche Sprache neu erlernen, würden Sie normalerweise nicht daran denken, das Typsystem von der restlichen Sprachdefinition zu trennen. Dennoch sind Typen prinzipiell für das Funktionieren eines Programms entbehrlich, und es kann sich durchaus lohnen, das Typsystem einer Sprache von ihrem Rest zu isolieren, insbesondere wenn Sie es austauschen oder verbessern möchten. Dies gilt umso mehr, da gängige Typsysteme heute entweder ziemlich schwach oder ziemlich komplex sind.
Daher führt diese Kurseinheit in Typsysteme am Beispiel von STRONGTALK ein, einer SMALLTALK-Erweiterung um ein optionales Typsystem. Sie geht dabei langsam und inkrementell vor. Wer das als zu langweilig empfindet, sei gewarnt: Es wird noch kompliziert genug, und nicht jede Leserin wird alles, was sie in diesem Kurs über Typsysteme liest, auf Anhieb verstehen. Es wäre auch eine Option, diese Kurseinheit anhand einer bekannteren Sprache mit einem obligatorischen Typsystem zu erstellen. Dies hätte jedoch den Nachteil, dass das konkrete Typsystem als gegeben angesehen werden müsste. Wenn Sie dann später eine andere Sprache kennenlernen, hätten Sie wahrscheinlich Schwierigkeiten, das Gelernte abzulegen und sich an die neuen Gegebenheiten anzupassen. Das Ziel dieser Kurseinheit ist jedoch, dass Sie Typsysteme als das verstehen, was sie sind: eine Möglichkeit zur Spezifikation redundanter Informationen, die die Qualität von Programmen erhöhen sollen.","<answer> Im Gegensatz zu SMALLTALK sind die meisten anderen objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration Typen zugeordnet werden. In SMALLTALK wird die Typisierung in der Regel erst zur Laufzeit überprüft, während in anderen Sprachen dies bereits zur Übersetzungszeit geschieht. <answer> <question> Welche Unterschiede gibt es zwischen SMALLTALK und den meisten anderen objektorientierten Programmiersprachen in Bezug auf die Typisierung? <question>"
"Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Die Genauigkeit dieser informellen Aussage hängt von der eher subtilen Frage ab, was einen Ausführungsfehler darstellt. Selbst wenn dies geklärt ist, ist die Typsicherheit einer Programmiersprache (das Fehlen bestimmter Ausführungsfehler in allen Programmläufen) eine nicht-triviale Eigenschaft. Eine sorgfältige Analyse ist erforderlich, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden. Als Konsequenz hat sich die Klassifikation, Beschreibung und Erforschung von Typsystemen zu einer formalen Disziplin entwickelt.
Im Gegensatz zu SMALLTALK sind die meisten objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration (siehe Kapitel 19) Typen zugeordnet werden. Ein Typ beschränkt die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache. Wenn Sie eine solche Sprache neu erlernen, würden Sie normalerweise nicht daran denken, das Typsystem von der restlichen Sprachdefinition zu trennen. Dennoch sind Typen prinzipiell für das Funktionieren eines Programms entbehrlich, und es kann sich durchaus lohnen, das Typsystem einer Sprache von ihrem Rest zu isolieren, insbesondere wenn Sie es austauschen oder verbessern möchten. Dies gilt umso mehr, da gängige Typsysteme heute entweder ziemlich schwach oder ziemlich komplex sind.
Daher führt diese Kurseinheit in Typsysteme am Beispiel von STRONGTALK ein, einer SMALLTALK-Erweiterung um ein optionales Typsystem. Sie geht dabei langsam und inkrementell vor. Wer das als zu langweilig empfindet, sei gewarnt: Es wird noch kompliziert genug, und nicht jede Leserin wird alles, was sie in diesem Kurs über Typsysteme liest, auf Anhieb verstehen. Es wäre auch eine Option, diese Kurseinheit anhand einer bekannteren Sprache mit einem obligatorischen Typsystem zu erstellen. Dies hätte jedoch den Nachteil, dass das konkrete Typsystem als gegeben angesehen werden müsste. Wenn Sie dann später eine andere Sprache kennenlernen, hätten Sie wahrscheinlich Schwierigkeiten, das Gelernte abzulegen und sich an die neuen Gegebenheiten anzupassen. Das Ziel dieser Kurseinheit ist jedoch, dass Sie Typsysteme als das verstehen, was sie sind: eine Möglichkeit zur Spezifikation redundanter Informationen, die die Qualität von Programmen erhöhen sollen.","<answer> Das Isolieren des Typsystems einer Programmiersprache ermöglicht es, das Typsystem auszutauschen oder zu verbessern, ohne die gesamte Sprachdefinition ändern zu müssen. Dies kann besonders nützlich sein, wenn man eine Sprache an spezifische Anforderungen anpassen möchte. <answer> <question> Warum könnte es sinnvoll sein, das Typsystem einer Programmiersprache von ihrem Rest zu isolieren? <question>"
"Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Die Genauigkeit dieser informellen Aussage hängt von der eher subtilen Frage ab, was einen Ausführungsfehler darstellt. Selbst wenn dies geklärt ist, ist die Typsicherheit einer Programmiersprache (das Fehlen bestimmter Ausführungsfehler in allen Programmläufen) eine nicht-triviale Eigenschaft. Eine sorgfältige Analyse ist erforderlich, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden. Als Konsequenz hat sich die Klassifikation, Beschreibung und Erforschung von Typsystemen zu einer formalen Disziplin entwickelt.
Im Gegensatz zu SMALLTALK sind die meisten objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration (siehe Kapitel 19) Typen zugeordnet werden. Ein Typ beschränkt die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache. Wenn Sie eine solche Sprache neu erlernen, würden Sie normalerweise nicht daran denken, das Typsystem von der restlichen Sprachdefinition zu trennen. Dennoch sind Typen prinzipiell für das Funktionieren eines Programms entbehrlich, und es kann sich durchaus lohnen, das Typsystem einer Sprache von ihrem Rest zu isolieren, insbesondere wenn Sie es austauschen oder verbessern möchten. Dies gilt umso mehr, da gängige Typsysteme heute entweder ziemlich schwach oder ziemlich komplex sind.
Daher führt diese Kurseinheit in Typsysteme am Beispiel von STRONGTALK ein, einer SMALLTALK-Erweiterung um ein optionales Typsystem. Sie geht dabei langsam und inkrementell vor. Wer das als zu langweilig empfindet, sei gewarnt: Es wird noch kompliziert genug, und nicht jede Leserin wird alles, was sie in diesem Kurs über Typsysteme liest, auf Anhieb verstehen. Es wäre auch eine Option, diese Kurseinheit anhand einer bekannteren Sprache mit einem obligatorischen Typsystem zu erstellen. Dies hätte jedoch den Nachteil, dass das konkrete Typsystem als gegeben angesehen werden müsste. Wenn Sie dann später eine andere Sprache kennenlernen, hätten Sie wahrscheinlich Schwierigkeiten, das Gelernte abzulegen und sich an die neuen Gegebenheiten anzupassen. Das Ziel dieser Kurseinheit ist jedoch, dass Sie Typsysteme als das verstehen, was sie sind: eine Möglichkeit zur Spezifikation redundanter Informationen, die die Qualität von Programmen erhöhen sollen.","<answer> Diese Kurseinheit behandelt das Typsystem am Beispiel von STRONGTALK, einer SMALLTALK-Erweiterung um ein optionales Typsystem. Dies geschieht, um die Konzepte schrittweise und verständlich einzuführen. Das Ziel ist, dass die Leserinnen und Leser Typsysteme als Möglichkeiten zur Spezifikation redundanter Informationen verstehen, die die Qualität von Programmen erhöhen sollen. <answer> <question> Warum wird in dieser Kurseinheit das Typsystem am Beispiel von STRONGTALK behandelt? <question>"
"In JAVA ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden. Anders als z. B. in PASCAL können aber über den Array-Typkonstruktor keine neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration.
In JAVA sind zwei Variablen vereinbart, wovon die erste ein Array von Fließkommazahlen zum Typ hat und die zweite ein Array von Objekten. Die alternative Schreibweise ist ebenfalls gebräuchlich. Anders als z. B. in PASCAL wird die Größe des Arrays in der Deklaration nicht festgelegt — dies geschieht erst bei der Initialisierung.
In JAVA ist es möglich, Arrays bei ihrer Deklaration zu initialisieren. Man beachte die Ähnlichkeit zu literalen Arrays in SMALLTALK (Abschnitt 1.2); allerdings müssen die Elemente der Arrays in JAVA nicht selbst Literale sein, sondern dürfen auch andere Ausdrücke sein. Die Größe des Arrays (in diesem Fall 2) wird bei der Initialisierung automatisch festgelegt; ansonsten muss dies bei der Erzeugung des Arrays mittels eines Konstruktors explizit geschehen.
Alle Elemente des Arrays enthalten danach jedoch null (JAVAs Äquivalent von SMALLTALKs nil). JAVA-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.
Beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimensionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays in JAVA auch gar nicht um mehrdimensionale Arrays, sondern um Arrays von Arrays).
Interessanterweise haben in JAVA Array-Variablen immer und unabhängig vom Basistyp Referenzsemantik. Bei der Zuweisung an die Variable f oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer darauf. Dies hat vermutlich den Hintergrund, dass Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Warum auch immer, im Ergebnis kann f an eine Variable vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit auch nicht damit zuweisungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn sie wie Klassen und Interfaces Typen bilden, außer ihrem Basistyp (also beispielsweise float oder Object) keine weiteren Definitionselemente anzugeben erlauben; insbesondere kann man für einen Array-Typen keine weiteren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die (Pseudo-)Variable length definiert, deren Inhalt die Größe des Arrays (Anzahl Elemente) angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.
Die bemerkte mangelnde Zuweisungskompatibilität von Object[] und float[] wirft natürlich sofort die Frage auf, ob denn auch die Zuweisung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] unzulässig ist. Wir hatten ja in Abschnitt 29.3 von Kurseinheit 3 am Beispiel zweier Instanzen eines parametrischen Typs bemerkt, dass dies zu einem nicht ganz offensichtlichen Problem führt, das sich analog auf Arrays übertragen lässt. Die Überraschung folgt hier auf den Fuß: Die Zuweisung ist in JAVA zulässig.
Warum aber geht man dieses Risiko ein und überträgt die Zuweisungskompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man anschließend schreibend (wie in Zeile 1046) auf das Array zugreift und dann noch mit dem falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen). Da man diese Bedingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein Laufzeittest durchgeführt. Ein klassischer Kompromiss, der diesmal zugunsten der Flexibilität beim Programmieren ausging.
Warum aber will man Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs und damit Zuweisungen wie die in Zeile 1045 unbedingt haben? Die Antwort ist einfach: weil es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern lediglich nach oben beschränken wollen. So gibt es beispielsweise in JAVA den Interfacetyp Comparable, der wie folgt definiert ist:
Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.","<answer> In JAVA ist es möglich, sowohl Arrays von primitiven (Wert-)Typen als auch von Referenztypen zu erstellen. <answer> <question> Was ermöglicht JAVA in Bezug auf Arrays in Bezug auf Wert- und Referenztypen? <question>"
"In JAVA ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden. Anders als z. B. in PASCAL können aber über den Array-Typkonstruktor keine neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration.
In JAVA sind zwei Variablen vereinbart, wovon die erste ein Array von Fließkommazahlen zum Typ hat und die zweite ein Array von Objekten. Die alternative Schreibweise ist ebenfalls gebräuchlich. Anders als z. B. in PASCAL wird die Größe des Arrays in der Deklaration nicht festgelegt — dies geschieht erst bei der Initialisierung.
In JAVA ist es möglich, Arrays bei ihrer Deklaration zu initialisieren. Man beachte die Ähnlichkeit zu literalen Arrays in SMALLTALK (Abschnitt 1.2); allerdings müssen die Elemente der Arrays in JAVA nicht selbst Literale sein, sondern dürfen auch andere Ausdrücke sein. Die Größe des Arrays (in diesem Fall 2) wird bei der Initialisierung automatisch festgelegt; ansonsten muss dies bei der Erzeugung des Arrays mittels eines Konstruktors explizit geschehen.
Alle Elemente des Arrays enthalten danach jedoch null (JAVAs Äquivalent von SMALLTALKs nil). JAVA-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.
Beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimensionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays in JAVA auch gar nicht um mehrdimensionale Arrays, sondern um Arrays von Arrays).
Interessanterweise haben in JAVA Array-Variablen immer und unabhängig vom Basistyp Referenzsemantik. Bei der Zuweisung an die Variable f oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer darauf. Dies hat vermutlich den Hintergrund, dass Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Warum auch immer, im Ergebnis kann f an eine Variable vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit auch nicht damit zuweisungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn sie wie Klassen und Interfaces Typen bilden, außer ihrem Basistyp (also beispielsweise float oder Object) keine weiteren Definitionselemente anzugeben erlauben; insbesondere kann man für einen Array-Typen keine weiteren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die (Pseudo-)Variable length definiert, deren Inhalt die Größe des Arrays (Anzahl Elemente) angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.
Die bemerkte mangelnde Zuweisungskompatibilität von Object[] und float[] wirft natürlich sofort die Frage auf, ob denn auch die Zuweisung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] unzulässig ist. Wir hatten ja in Abschnitt 29.3 von Kurseinheit 3 am Beispiel zweier Instanzen eines parametrischen Typs bemerkt, dass dies zu einem nicht ganz offensichtlichen Problem führt, das sich analog auf Arrays übertragen lässt. Die Überraschung folgt hier auf den Fuß: Die Zuweisung ist in JAVA zulässig.
Warum aber geht man dieses Risiko ein und überträgt die Zuweisungskompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man anschließend schreibend (wie in Zeile 1046) auf das Array zugreift und dann noch mit dem falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen). Da man diese Bedingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein Laufzeittest durchgeführt. Ein klassischer Kompromiss, der diesmal zugunsten der Flexibilität beim Programmieren ausging.
Warum aber will man Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs und damit Zuweisungen wie die in Zeile 1045 unbedingt haben? Die Antwort ist einfach: weil es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern lediglich nach oben beschränken wollen. So gibt es beispielsweise in JAVA den Interfacetyp Comparable, der wie folgt definiert ist:
Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.","<answer> Die Deklaration von Arrays in JAVA erfolgt implizit in Variablendeklarationen, wobei die Größe des Arrays nicht in der Deklaration festgelegt wird. <answer> <question> Wie erfolgt die Deklaration von Arrays in JAVA? <question>"
"In JAVA ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden. Anders als z. B. in PASCAL können aber über den Array-Typkonstruktor keine neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration.
In JAVA sind zwei Variablen vereinbart, wovon die erste ein Array von Fließkommazahlen zum Typ hat und die zweite ein Array von Objekten. Die alternative Schreibweise ist ebenfalls gebräuchlich. Anders als z. B. in PASCAL wird die Größe des Arrays in der Deklaration nicht festgelegt — dies geschieht erst bei der Initialisierung.
In JAVA ist es möglich, Arrays bei ihrer Deklaration zu initialisieren. Man beachte die Ähnlichkeit zu literalen Arrays in SMALLTALK (Abschnitt 1.2); allerdings müssen die Elemente der Arrays in JAVA nicht selbst Literale sein, sondern dürfen auch andere Ausdrücke sein. Die Größe des Arrays (in diesem Fall 2) wird bei der Initialisierung automatisch festgelegt; ansonsten muss dies bei der Erzeugung des Arrays mittels eines Konstruktors explizit geschehen.
Alle Elemente des Arrays enthalten danach jedoch null (JAVAs Äquivalent von SMALLTALKs nil). JAVA-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.
Beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimensionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays in JAVA auch gar nicht um mehrdimensionale Arrays, sondern um Arrays von Arrays).
Interessanterweise haben in JAVA Array-Variablen immer und unabhängig vom Basistyp Referenzsemantik. Bei der Zuweisung an die Variable f oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer darauf. Dies hat vermutlich den Hintergrund, dass Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Warum auch immer, im Ergebnis kann f an eine Variable vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit auch nicht damit zuweisungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn sie wie Klassen und Interfaces Typen bilden, außer ihrem Basistyp (also beispielsweise float oder Object) keine weiteren Definitionselemente anzugeben erlauben; insbesondere kann man für einen Array-Typen keine weiteren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die (Pseudo-)Variable length definiert, deren Inhalt die Größe des Arrays (Anzahl Elemente) angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.
Die bemerkte mangelnde Zuweisungskompatibilität von Object[] und float[] wirft natürlich sofort die Frage auf, ob denn auch die Zuweisung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] unzulässig ist. Wir hatten ja in Abschnitt 29.3 von Kurseinheit 3 am Beispiel zweier Instanzen eines parametrischen Typs bemerkt, dass dies zu einem nicht ganz offensichtlichen Problem führt, das sich analog auf Arrays übertragen lässt. Die Überraschung folgt hier auf den Fuß: Die Zuweisung ist in JAVA zulässig.
Warum aber geht man dieses Risiko ein und überträgt die Zuweisungskompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man anschließend schreibend (wie in Zeile 1046) auf das Array zugreift und dann noch mit dem falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen). Da man diese Bedingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein Laufzeittest durchgeführt. Ein klassischer Kompromiss, der diesmal zugunsten der Flexibilität beim Programmieren ausging.
Warum aber will man Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs und damit Zuweisungen wie die in Zeile 1045 unbedingt haben? Die Antwort ist einfach: weil es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern lediglich nach oben beschränken wollen. So gibt es beispielsweise in JAVA den Interfacetyp Comparable, der wie folgt definiert ist:
Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.",<answer> Arrays können in JAVA bei ihrer Deklaration initialisiert werden. Dabei wird die Größe des Arrays automatisch festgelegt. <answer> <question> Wie können Arrays in JAVA initialisiert werden? <question>
"In JAVA ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden. Anders als z. B. in PASCAL können aber über den Array-Typkonstruktor keine neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration.
In JAVA sind zwei Variablen vereinbart, wovon die erste ein Array von Fließkommazahlen zum Typ hat und die zweite ein Array von Objekten. Die alternative Schreibweise ist ebenfalls gebräuchlich. Anders als z. B. in PASCAL wird die Größe des Arrays in der Deklaration nicht festgelegt — dies geschieht erst bei der Initialisierung.
In JAVA ist es möglich, Arrays bei ihrer Deklaration zu initialisieren. Man beachte die Ähnlichkeit zu literalen Arrays in SMALLTALK (Abschnitt 1.2); allerdings müssen die Elemente der Arrays in JAVA nicht selbst Literale sein, sondern dürfen auch andere Ausdrücke sein. Die Größe des Arrays (in diesem Fall 2) wird bei der Initialisierung automatisch festgelegt; ansonsten muss dies bei der Erzeugung des Arrays mittels eines Konstruktors explizit geschehen.
Alle Elemente des Arrays enthalten danach jedoch null (JAVAs Äquivalent von SMALLTALKs nil). JAVA-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.
Beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimensionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays in JAVA auch gar nicht um mehrdimensionale Arrays, sondern um Arrays von Arrays).
Interessanterweise haben in JAVA Array-Variablen immer und unabhängig vom Basistyp Referenzsemantik. Bei der Zuweisung an die Variable f oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer darauf. Dies hat vermutlich den Hintergrund, dass Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Warum auch immer, im Ergebnis kann f an eine Variable vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit auch nicht damit zuweisungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn sie wie Klassen und Interfaces Typen bilden, außer ihrem Basistyp (also beispielsweise float oder Object) keine weiteren Definitionselemente anzugeben erlauben; insbesondere kann man für einen Array-Typen keine weiteren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die (Pseudo-)Variable length definiert, deren Inhalt die Größe des Arrays (Anzahl Elemente) angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.
Die bemerkte mangelnde Zuweisungskompatibilität von Object[] und float[] wirft natürlich sofort die Frage auf, ob denn auch die Zuweisung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] unzulässig ist. Wir hatten ja in Abschnitt 29.3 von Kurseinheit 3 am Beispiel zweier Instanzen eines parametrischen Typs bemerkt, dass dies zu einem nicht ganz offensichtlichen Problem führt, das sich analog auf Arrays übertragen lässt. Die Überraschung folgt hier auf den Fuß: Die Zuweisung ist in JAVA zulässig.
Warum aber geht man dieses Risiko ein und überträgt die Zuweisungskompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man anschließend schreibend (wie in Zeile 1046) auf das Array zugreift und dann noch mit dem falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen). Da man diese Bedingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein Laufzeittest durchgeführt. Ein klassischer Kompromiss, der diesmal zugunsten der Flexibilität beim Programmieren ausging.
Warum aber will man Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs und damit Zuweisungen wie die in Zeile 1045 unbedingt haben? Die Antwort ist einfach: weil es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern lediglich nach oben beschränken wollen. So gibt es beispielsweise in JAVA den Interfacetyp Comparable, der wie folgt definiert ist:
Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.","<answer> In JAVA können mehrdimensionale Arrays geschachtelt werden, wobei die Größen der Dimensionen nicht für jedes Element der ersten Dimension gleich sein müssen. <answer> <question> Welche Besonderheiten gibt es bei mehrdimensionalen Arrays in JAVA? <question>"
"In JAVA ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden. Anders als z. B. in PASCAL können aber über den Array-Typkonstruktor keine neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration.
In JAVA sind zwei Variablen vereinbart, wovon die erste ein Array von Fließkommazahlen zum Typ hat und die zweite ein Array von Objekten. Die alternative Schreibweise ist ebenfalls gebräuchlich. Anders als z. B. in PASCAL wird die Größe des Arrays in der Deklaration nicht festgelegt — dies geschieht erst bei der Initialisierung.
In JAVA ist es möglich, Arrays bei ihrer Deklaration zu initialisieren. Man beachte die Ähnlichkeit zu literalen Arrays in SMALLTALK (Abschnitt 1.2); allerdings müssen die Elemente der Arrays in JAVA nicht selbst Literale sein, sondern dürfen auch andere Ausdrücke sein. Die Größe des Arrays (in diesem Fall 2) wird bei der Initialisierung automatisch festgelegt; ansonsten muss dies bei der Erzeugung des Arrays mittels eines Konstruktors explizit geschehen.
Alle Elemente des Arrays enthalten danach jedoch null (JAVAs Äquivalent von SMALLTALKs nil). JAVA-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.
Beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimensionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays in JAVA auch gar nicht um mehrdimensionale Arrays, sondern um Arrays von Arrays).
Interessanterweise haben in JAVA Array-Variablen immer und unabhängig vom Basistyp Referenzsemantik. Bei der Zuweisung an die Variable f oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer darauf. Dies hat vermutlich den Hintergrund, dass Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Warum auch immer, im Ergebnis kann f an eine Variable vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit auch nicht damit zuweisungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn sie wie Klassen und Interfaces Typen bilden, außer ihrem Basistyp (also beispielsweise float oder Object) keine weiteren Definitionselemente anzugeben erlauben; insbesondere kann man für einen Array-Typen keine weiteren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die (Pseudo-)Variable length definiert, deren Inhalt die Größe des Arrays (Anzahl Elemente) angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.
Die bemerkte mangelnde Zuweisungskompatibilität von Object[] und float[] wirft natürlich sofort die Frage auf, ob denn auch die Zuweisung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] unzulässig ist. Wir hatten ja in Abschnitt 29.3 von Kurseinheit 3 am Beispiel zweier Instanzen eines parametrischen Typs bemerkt, dass dies zu einem nicht ganz offensichtlichen Problem führt, das sich analog auf Arrays übertragen lässt. Die Überraschung folgt hier auf den Fuß: Die Zuweisung ist in JAVA zulässig.
Warum aber geht man dieses Risiko ein und überträgt die Zuweisungskompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man anschließend schreibend (wie in Zeile 1046) auf das Array zugreift und dann noch mit dem falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen). Da man diese Bedingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein Laufzeittest durchgeführt. Ein klassischer Kompromiss, der diesmal zugunsten der Flexibilität beim Programmieren ausging.
Warum aber will man Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs und damit Zuweisungen wie die in Zeile 1045 unbedingt haben? Die Antwort ist einfach: weil es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern lediglich nach oben beschränken wollen. So gibt es beispielsweise in JAVA den Interfacetyp Comparable, der wie folgt definiert ist:
Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.","<answer> In JAVA haben Array-Variablen Referenzsemantik, und bei der Zuweisung wird lediglich ein Verweis auf das Array übergeben. Die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[] ist zulässig. <answer> <question> Wie funktioniert die Zuweisung von Array-Variablen in JAVA? <question>"
"In JAVA ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden. Anders als z. B. in PASCAL können aber über den Array-Typkonstruktor keine neuen Typen benannt werden; die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration.
In JAVA sind zwei Variablen vereinbart, wovon die erste ein Array von Fließkommazahlen zum Typ hat und die zweite ein Array von Objekten. Die alternative Schreibweise ist ebenfalls gebräuchlich. Anders als z. B. in PASCAL wird die Größe des Arrays in der Deklaration nicht festgelegt — dies geschieht erst bei der Initialisierung.
In JAVA ist es möglich, Arrays bei ihrer Deklaration zu initialisieren. Man beachte die Ähnlichkeit zu literalen Arrays in SMALLTALK (Abschnitt 1.2); allerdings müssen die Elemente der Arrays in JAVA nicht selbst Literale sein, sondern dürfen auch andere Ausdrücke sein. Die Größe des Arrays (in diesem Fall 2) wird bei der Initialisierung automatisch festgelegt; ansonsten muss dies bei der Erzeugung des Arrays mittels eines Konstruktors explizit geschehen.
Alle Elemente des Arrays enthalten danach jedoch null (JAVAs Äquivalent von SMALLTALKs nil). JAVA-Arrays sind übrigens 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.) Array-Initialisierer können auch geschachtelt werden und somit mehrere Dimensionen umfassen.
Beispielsweise liefert einen möglichen Anfangswert für ein zweidimensionales Array mit der Deklaration int integers[][] (also ein Array mit Elementtyp int und mit zwei Dimensionen). Wie man sieht, müssen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten (sog. Ragged oder Jagged arrays sind möglich; tatsächlich handelt es sich bei mehrdimensionalen Arrays in JAVA auch gar nicht um mehrdimensionale Arrays, sondern um Arrays von Arrays).
Interessanterweise haben in JAVA Array-Variablen immer und unabhängig vom Basistyp Referenzsemantik. Bei der Zuweisung an die Variable f oben wird also nicht ein ganzes Array als Kopie übergeben, sondern lediglich ein Pointer darauf. Dies hat vermutlich den Hintergrund, dass Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Warum auch immer, im Ergebnis kann f an eine Variable vom Typ Object zugewiesen werden. Eine Zuweisung von f an eine Variable vom Typ Object[] ist hingegen nicht zulässig — float[] ist kein Subtyp von Object[] und somit auch nicht damit zuweisungskompatibel. Man beachte übrigens, dass Arrays, selbst wenn sie wie Klassen und Interfaces Typen bilden, außer ihrem Basistyp (also beispielsweise float oder Object) keine weiteren Definitionselemente anzugeben erlauben; insbesondere kann man für einen Array-Typen keine weiteren Eigenschaften (Felder oder Methoden) definieren. Allerdings ist für jedes Array die (Pseudo-)Variable length definiert, deren Inhalt die Größe des Arrays (Anzahl Elemente) angibt. Außerdem wird die Methode clone() aus Object so überschrieben, dass sie ein Objekt gleichen Typs, also ebenfalls ein Array des Basistyps, zurückgibt.
Die bemerkte mangelnde Zuweisungskompatibilität von Object[] und float[] wirft natürlich sofort die Frage auf, ob denn auch die Zuweisung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] unzulässig ist. Wir hatten ja in Abschnitt 29.3 von Kurseinheit 3 am Beispiel zweier Instanzen eines parametrischen Typs bemerkt, dass dies zu einem nicht ganz offensichtlichen Problem führt, das sich analog auf Arrays übertragen lässt. Die Überraschung folgt hier auf den Fuß: Die Zuweisung ist in JAVA zulässig.
Warum aber geht man dieses Risiko ein und überträgt die Zuweisungskompatibilität von Typen auf Arrays von diesen Typen? Zunächst einmal kann man festhalten, dass hier auf die Möglichkeit der statischen Typprüfung, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung aus Zeile 1045 gemeldet hätte, zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet wurde. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Es ist nämlich gar nicht gesagt, dass die Zuweisung der Zeile 1045 immer zu einem Laufzeitfehler führt — nur wenn man anschließend schreibend (wie in Zeile 1046) auf das Array zugreift und dann noch mit dem falschen Typ, kommt es zu einem solchen Fehler (zu typinkorrekten Variablenbelegungen). Da man diese Bedingung aber schlecht zur Übersetzungszeit abprüfen kann, wird eben ein Laufzeittest durchgeführt. Ein klassischer Kompromiss, der diesmal zugunsten der Flexibilität beim Programmieren ausging.
Warum aber will man Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs und damit Zuweisungen wie die in Zeile 1045 unbedingt haben? Die Antwort ist einfach: weil es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern lediglich nach oben beschränken wollen. So gibt es beispielsweise in JAVA den Interfacetyp Comparable, der wie folgt definiert ist:
Die Methode compareTo soll dabei einen Wert zurückgeben, der angibt, wie der Vergleich des Empfänger- mit dem Parameterobjekt ausgegangen ist. Eine Methode mit der Signatur sort(Comparable[]) kann dann Arrays beliebiger Elementtypen zum Sortieren annehmen, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind. Da beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, kann dabei auch kein Typfehler von der Art der Zeile 1046 auftreten. Diese Methode sort ist also faktisch sicher — ein konservatives statisches Typsystem hätte ihre Verwendung jedoch nicht zugelassen. Der eingegangene Kompromiss zwischen statischer und dynamischen Typprüfung ist also durchaus vertretbar.","<answer> Diese Zuweisungskompatibilität ermöglicht eine flexiblere Programmierung, insbesondere in Situationen, in denen der statische Typ der Array-Elemente nicht genau festgelegt ist, aber nach oben beschränkt werden soll, wie im Beispiel mit dem Interface Comparable und der Methode sort. Dieser Kompromiss zwischen statischer und dynamischer Typprüfung bietet Flexibilität beim Programmieren. <answer> <question> Warum gestattet JAVA die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[]? <question>"
"In C# sind, genau wie in JAVA, alle Variablen typisiert. Anders als in JAVA wird jedoch zunächst nicht zwischen Wert- (primitiven) und Referenztypen unterschieden: Alle Typen, auch die primitiven, gelten als von Object (genauer: System.Object) abgeleitet. Da lohnt es sich, auf die Typhierarchie etwas genauer einzugehen.
Genaugenommen ist die Typhierarchie von C# gar nicht die Typhierarchie von C#, sondern die von .NET: Sie ist nämlich für alle .NET-Sprachen dieselbe. Das liegt daran, dass .NET für alle seine Sprachen ein gemeinsames Typsystem vorsieht, nämlich das Common Type System (CTS). Das CTS sorgt dafür, dass Typen, die in einer Sprache definiert wurden, auch in einer anderen Sprache verwendet werden können, und zwar ganz so, als wären sie in der anderen Sprache selbst definiert worden. Wie man sich leicht vorstellen kann, sind dafür einige Konventionen notwendig.
Das erste Merkmal des CTS ist, dass alle Typen in einer Hierarchie untergebracht sind. Anders als in JAVA gibt es also keine Ausgrenzung der primitiven Typen. Tatsächlich sind die primitiven Typen als eine von mehreren Arten von Werttypen in der Hierarchie angesiedelt. Eine weitere wichtige Form von Werttypen sind die Aufzählungstypen, die aus PASCAL bekannt sind und inzwischen auch in JAVA verwendet werden, allerdings dort als Referenztypen. Bei den Werttypen handelt es sich um Typen, die von der Programmiererin selbst angegeben werden können (im Gegensatz zu den primitiven Typen, deren Werte mit der Sprachdefinition vorgegeben sind). Werttypen können, genau wie in PASCAL oder C, mittels des Typkonstruktors ""struct"" (das C-Äquivalent von PASCALs ""record"") erzeugt werden. Diese Typen können sogar Methoden und Konstruktoren haben, sind jedoch keine Klassen und erlauben keine Typerweiterung oder Vererbung.
Eine weitere Unterscheidung ergibt sich bei den Referenztypen. Neben Klassen, Interfaces und Arrays gibt es auch Delegates, die im Wesentlichen Zeiger auf an ein Objekt gebundene einzelne Methoden sind. Delegates ersetzen die aus anderen Sprachen bekannten Funktionspointer. In JAVA bis zur Version 8 wurden sie recht umständlich über Interfaces und anonyme innere Klassen emuliert, wobei heute Lambda-Ausdrücke in JAVA anstelle davon verwendet werden können. Delegates sind für verschiedene Problemstellungen, wie z. B. Listener-Mechanismen, sehr nützlich.
Zuletzt gibt es in C# auch noch Attribut-Typen (Attributes), die im Wesentlichen den Annotationen entsprechen, die es seit Version 5 auch in JAVA gibt. Annotationen haben jedoch nichts unmittelbar mit objektorientierter Programmierung zu tun und sind daher nicht Gegenstand dieses Kurses.
Es ergibt sich die folgende grobe Einteilung der Typen in C#: Werttypen, and Referenztypen: Klassen, Interfaces, Arrays, Delegates, Attribut-Typen
Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C#. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C#, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:
Wie Ihnen sicher aufgefallen ist, sind einige der Arten von Typen aus der obigen Liste jeweils durch eine spezielle Klasse (Array, Delegate, Attribute) vertreten. Man kann dies als Hinweis darauf verstehen, dass tatsächlich alle Arten von Typen integriert sind und es keine grundsätzlichen Barrieren zwischen ihnen gibt. In C# haben alle Klassen außer System.Object, genau wie in JAVA, genau eine Superklasse. Sie können jedoch beliebig viele Interfaces implementieren. Die Tatsache, dass Werttypen als Subtypen eines Referenztypen (nämlich Object) deklariert sind, verrät außerdem, dass C# über Auto-Boxing und Unboxing verfügt.","<answer> In C# wird zunächst nicht zwischen Wert- (primitiven) und Referenztypen wie in JAVA unterschieden. Alle Typen, einschließlich der primitiven Typen, gelten als von Object (genauer: System.Object) abgeleitet. <answer> <question> Gibt es in C# einen Unterschied zwischen Wert- (primitiven) und Referenztypen wie in JAVA? <question>"
"In C# sind, genau wie in JAVA, alle Variablen typisiert. Anders als in JAVA wird jedoch zunächst nicht zwischen Wert- (primitiven) und Referenztypen unterschieden: Alle Typen, auch die primitiven, gelten als von Object (genauer: System.Object) abgeleitet. Da lohnt es sich, auf die Typhierarchie etwas genauer einzugehen.
Genaugenommen ist die Typhierarchie von C# gar nicht die Typhierarchie von C#, sondern die von .NET: Sie ist nämlich für alle .NET-Sprachen dieselbe. Das liegt daran, dass .NET für alle seine Sprachen ein gemeinsames Typsystem vorsieht, nämlich das Common Type System (CTS). Das CTS sorgt dafür, dass Typen, die in einer Sprache definiert wurden, auch in einer anderen Sprache verwendet werden können, und zwar ganz so, als wären sie in der anderen Sprache selbst definiert worden. Wie man sich leicht vorstellen kann, sind dafür einige Konventionen notwendig.
Das erste Merkmal des CTS ist, dass alle Typen in einer Hierarchie untergebracht sind. Anders als in JAVA gibt es also keine Ausgrenzung der primitiven Typen. Tatsächlich sind die primitiven Typen als eine von mehreren Arten von Werttypen in der Hierarchie angesiedelt. Eine weitere wichtige Form von Werttypen sind die Aufzählungstypen, die aus PASCAL bekannt sind und inzwischen auch in JAVA verwendet werden, allerdings dort als Referenztypen. Bei den Werttypen handelt es sich um Typen, die von der Programmiererin selbst angegeben werden können (im Gegensatz zu den primitiven Typen, deren Werte mit der Sprachdefinition vorgegeben sind). Werttypen können, genau wie in PASCAL oder C, mittels des Typkonstruktors ""struct"" (das C-Äquivalent von PASCALs ""record"") erzeugt werden. Diese Typen können sogar Methoden und Konstruktoren haben, sind jedoch keine Klassen und erlauben keine Typerweiterung oder Vererbung.
Eine weitere Unterscheidung ergibt sich bei den Referenztypen. Neben Klassen, Interfaces und Arrays gibt es auch Delegates, die im Wesentlichen Zeiger auf an ein Objekt gebundene einzelne Methoden sind. Delegates ersetzen die aus anderen Sprachen bekannten Funktionspointer. In JAVA bis zur Version 8 wurden sie recht umständlich über Interfaces und anonyme innere Klassen emuliert, wobei heute Lambda-Ausdrücke in JAVA anstelle davon verwendet werden können. Delegates sind für verschiedene Problemstellungen, wie z. B. Listener-Mechanismen, sehr nützlich.
Zuletzt gibt es in C# auch noch Attribut-Typen (Attributes), die im Wesentlichen den Annotationen entsprechen, die es seit Version 5 auch in JAVA gibt. Annotationen haben jedoch nichts unmittelbar mit objektorientierter Programmierung zu tun und sind daher nicht Gegenstand dieses Kurses.
Es ergibt sich die folgende grobe Einteilung der Typen in C#: Werttypen, and Referenztypen: Klassen, Interfaces, Arrays, Delegates, Attribut-Typen
Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C#. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C#, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:
Wie Ihnen sicher aufgefallen ist, sind einige der Arten von Typen aus der obigen Liste jeweils durch eine spezielle Klasse (Array, Delegate, Attribute) vertreten. Man kann dies als Hinweis darauf verstehen, dass tatsächlich alle Arten von Typen integriert sind und es keine grundsätzlichen Barrieren zwischen ihnen gibt. In C# haben alle Klassen außer System.Object, genau wie in JAVA, genau eine Superklasse. Sie können jedoch beliebig viele Interfaces implementieren. Die Tatsache, dass Werttypen als Subtypen eines Referenztypen (nämlich Object) deklariert sind, verrät außerdem, dass C# über Auto-Boxing und Unboxing verfügt.","<answer> Das Common Type System (CTS) ist ein Teil des .NET-Frameworks und sorgt dafür, dass Typen, die in verschiedenen .NET-Sprachen definiert wurden, gemeinsam genutzt werden können. Es stellt sicher, dass Typen in einer einheitlichen Hierarchie organisiert sind und in verschiedenen .NET-Sprachen verwendet werden können, als wären sie in der jeweiligen Sprache selbst definiert worden. Dies erleichtert die Interoperabilität zwischen verschiedenen .NET-Sprachen und ermöglicht es, Bibliotheken und Komponenten in verschiedenen Sprachen zu verwenden. <answer> <question> Was ist das Common Type System (CTS) in C# und warum ist es wichtig? <question>"
"In C# sind, genau wie in JAVA, alle Variablen typisiert. Anders als in JAVA wird jedoch zunächst nicht zwischen Wert- (primitiven) und Referenztypen unterschieden: Alle Typen, auch die primitiven, gelten als von Object (genauer: System.Object) abgeleitet. Da lohnt es sich, auf die Typhierarchie etwas genauer einzugehen.
Genaugenommen ist die Typhierarchie von C# gar nicht die Typhierarchie von C#, sondern die von .NET: Sie ist nämlich für alle .NET-Sprachen dieselbe. Das liegt daran, dass .NET für alle seine Sprachen ein gemeinsames Typsystem vorsieht, nämlich das Common Type System (CTS). Das CTS sorgt dafür, dass Typen, die in einer Sprache definiert wurden, auch in einer anderen Sprache verwendet werden können, und zwar ganz so, als wären sie in der anderen Sprache selbst definiert worden. Wie man sich leicht vorstellen kann, sind dafür einige Konventionen notwendig.
Das erste Merkmal des CTS ist, dass alle Typen in einer Hierarchie untergebracht sind. Anders als in JAVA gibt es also keine Ausgrenzung der primitiven Typen. Tatsächlich sind die primitiven Typen als eine von mehreren Arten von Werttypen in der Hierarchie angesiedelt. Eine weitere wichtige Form von Werttypen sind die Aufzählungstypen, die aus PASCAL bekannt sind und inzwischen auch in JAVA verwendet werden, allerdings dort als Referenztypen. Bei den Werttypen handelt es sich um Typen, die von der Programmiererin selbst angegeben werden können (im Gegensatz zu den primitiven Typen, deren Werte mit der Sprachdefinition vorgegeben sind). Werttypen können, genau wie in PASCAL oder C, mittels des Typkonstruktors ""struct"" (das C-Äquivalent von PASCALs ""record"") erzeugt werden. Diese Typen können sogar Methoden und Konstruktoren haben, sind jedoch keine Klassen und erlauben keine Typerweiterung oder Vererbung.
Eine weitere Unterscheidung ergibt sich bei den Referenztypen. Neben Klassen, Interfaces und Arrays gibt es auch Delegates, die im Wesentlichen Zeiger auf an ein Objekt gebundene einzelne Methoden sind. Delegates ersetzen die aus anderen Sprachen bekannten Funktionspointer. In JAVA bis zur Version 8 wurden sie recht umständlich über Interfaces und anonyme innere Klassen emuliert, wobei heute Lambda-Ausdrücke in JAVA anstelle davon verwendet werden können. Delegates sind für verschiedene Problemstellungen, wie z. B. Listener-Mechanismen, sehr nützlich.
Zuletzt gibt es in C# auch noch Attribut-Typen (Attributes), die im Wesentlichen den Annotationen entsprechen, die es seit Version 5 auch in JAVA gibt. Annotationen haben jedoch nichts unmittelbar mit objektorientierter Programmierung zu tun und sind daher nicht Gegenstand dieses Kurses.
Es ergibt sich die folgende grobe Einteilung der Typen in C#: Werttypen, and Referenztypen: Klassen, Interfaces, Arrays, Delegates, Attribut-Typen
Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C#. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C#, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:
Wie Ihnen sicher aufgefallen ist, sind einige der Arten von Typen aus der obigen Liste jeweils durch eine spezielle Klasse (Array, Delegate, Attribute) vertreten. Man kann dies als Hinweis darauf verstehen, dass tatsächlich alle Arten von Typen integriert sind und es keine grundsätzlichen Barrieren zwischen ihnen gibt. In C# haben alle Klassen außer System.Object, genau wie in JAVA, genau eine Superklasse. Sie können jedoch beliebig viele Interfaces implementieren. Die Tatsache, dass Werttypen als Subtypen eines Referenztypen (nämlich Object) deklariert sind, verrät außerdem, dass C# über Auto-Boxing und Unboxing verfügt.","<answer> In C# gibt es verschiedene Arten von Werttypen, darunter die primitiven Typen (z. B. int, bool, double), Aufzählungstypen (enum) und vom Entwickler definierte Werttypen. Werttypen werden in C# mit dem Typkonstruktor ""struct"" erstellt und können Methoden und Konstruktoren haben, jedoch erlauben sie keine Typerweiterung oder Vererbung. <answer> <question> Welche Arten von Werttypen gibt es in C#? <question>"
"In C# sind, genau wie in JAVA, alle Variablen typisiert. Anders als in JAVA wird jedoch zunächst nicht zwischen Wert- (primitiven) und Referenztypen unterschieden: Alle Typen, auch die primitiven, gelten als von Object (genauer: System.Object) abgeleitet. Da lohnt es sich, auf die Typhierarchie etwas genauer einzugehen.
Genaugenommen ist die Typhierarchie von C# gar nicht die Typhierarchie von C#, sondern die von .NET: Sie ist nämlich für alle .NET-Sprachen dieselbe. Das liegt daran, dass .NET für alle seine Sprachen ein gemeinsames Typsystem vorsieht, nämlich das Common Type System (CTS). Das CTS sorgt dafür, dass Typen, die in einer Sprache definiert wurden, auch in einer anderen Sprache verwendet werden können, und zwar ganz so, als wären sie in der anderen Sprache selbst definiert worden. Wie man sich leicht vorstellen kann, sind dafür einige Konventionen notwendig.
Das erste Merkmal des CTS ist, dass alle Typen in einer Hierarchie untergebracht sind. Anders als in JAVA gibt es also keine Ausgrenzung der primitiven Typen. Tatsächlich sind die primitiven Typen als eine von mehreren Arten von Werttypen in der Hierarchie angesiedelt. Eine weitere wichtige Form von Werttypen sind die Aufzählungstypen, die aus PASCAL bekannt sind und inzwischen auch in JAVA verwendet werden, allerdings dort als Referenztypen. Bei den Werttypen handelt es sich um Typen, die von der Programmiererin selbst angegeben werden können (im Gegensatz zu den primitiven Typen, deren Werte mit der Sprachdefinition vorgegeben sind). Werttypen können, genau wie in PASCAL oder C, mittels des Typkonstruktors ""struct"" (das C-Äquivalent von PASCALs ""record"") erzeugt werden. Diese Typen können sogar Methoden und Konstruktoren haben, sind jedoch keine Klassen und erlauben keine Typerweiterung oder Vererbung.
Eine weitere Unterscheidung ergibt sich bei den Referenztypen. Neben Klassen, Interfaces und Arrays gibt es auch Delegates, die im Wesentlichen Zeiger auf an ein Objekt gebundene einzelne Methoden sind. Delegates ersetzen die aus anderen Sprachen bekannten Funktionspointer. In JAVA bis zur Version 8 wurden sie recht umständlich über Interfaces und anonyme innere Klassen emuliert, wobei heute Lambda-Ausdrücke in JAVA anstelle davon verwendet werden können. Delegates sind für verschiedene Problemstellungen, wie z. B. Listener-Mechanismen, sehr nützlich.
Zuletzt gibt es in C# auch noch Attribut-Typen (Attributes), die im Wesentlichen den Annotationen entsprechen, die es seit Version 5 auch in JAVA gibt. Annotationen haben jedoch nichts unmittelbar mit objektorientierter Programmierung zu tun und sind daher nicht Gegenstand dieses Kurses.
Es ergibt sich die folgende grobe Einteilung der Typen in C#: Werttypen, and Referenztypen: Klassen, Interfaces, Arrays, Delegates, Attribut-Typen
Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C#. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C#, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:
Wie Ihnen sicher aufgefallen ist, sind einige der Arten von Typen aus der obigen Liste jeweils durch eine spezielle Klasse (Array, Delegate, Attribute) vertreten. Man kann dies als Hinweis darauf verstehen, dass tatsächlich alle Arten von Typen integriert sind und es keine grundsätzlichen Barrieren zwischen ihnen gibt. In C# haben alle Klassen außer System.Object, genau wie in JAVA, genau eine Superklasse. Sie können jedoch beliebig viele Interfaces implementieren. Die Tatsache, dass Werttypen als Subtypen eines Referenztypen (nämlich Object) deklariert sind, verrät außerdem, dass C# über Auto-Boxing und Unboxing verfügt.","<answer> In C# gibt es verschiedene Arten von Referenztypen, darunter Klassen, Interfaces, Arrays, Delegates und Attribut-Typen. Diese Referenztypen ermöglichen eine größere Vielfalt an Programmierkonzepten und -strukturen in C#. <answer> <question> Welche Arten von Referenztypen gibt es in C#? <question>"
"In C# sind, genau wie in JAVA, alle Variablen typisiert. Anders als in JAVA wird jedoch zunächst nicht zwischen Wert- (primitiven) und Referenztypen unterschieden: Alle Typen, auch die primitiven, gelten als von Object (genauer: System.Object) abgeleitet. Da lohnt es sich, auf die Typhierarchie etwas genauer einzugehen.
Genaugenommen ist die Typhierarchie von C# gar nicht die Typhierarchie von C#, sondern die von .NET: Sie ist nämlich für alle .NET-Sprachen dieselbe. Das liegt daran, dass .NET für alle seine Sprachen ein gemeinsames Typsystem vorsieht, nämlich das Common Type System (CTS). Das CTS sorgt dafür, dass Typen, die in einer Sprache definiert wurden, auch in einer anderen Sprache verwendet werden können, und zwar ganz so, als wären sie in der anderen Sprache selbst definiert worden. Wie man sich leicht vorstellen kann, sind dafür einige Konventionen notwendig.
Das erste Merkmal des CTS ist, dass alle Typen in einer Hierarchie untergebracht sind. Anders als in JAVA gibt es also keine Ausgrenzung der primitiven Typen. Tatsächlich sind die primitiven Typen als eine von mehreren Arten von Werttypen in der Hierarchie angesiedelt. Eine weitere wichtige Form von Werttypen sind die Aufzählungstypen, die aus PASCAL bekannt sind und inzwischen auch in JAVA verwendet werden, allerdings dort als Referenztypen. Bei den Werttypen handelt es sich um Typen, die von der Programmiererin selbst angegeben werden können (im Gegensatz zu den primitiven Typen, deren Werte mit der Sprachdefinition vorgegeben sind). Werttypen können, genau wie in PASCAL oder C, mittels des Typkonstruktors ""struct"" (das C-Äquivalent von PASCALs ""record"") erzeugt werden. Diese Typen können sogar Methoden und Konstruktoren haben, sind jedoch keine Klassen und erlauben keine Typerweiterung oder Vererbung.
Eine weitere Unterscheidung ergibt sich bei den Referenztypen. Neben Klassen, Interfaces und Arrays gibt es auch Delegates, die im Wesentlichen Zeiger auf an ein Objekt gebundene einzelne Methoden sind. Delegates ersetzen die aus anderen Sprachen bekannten Funktionspointer. In JAVA bis zur Version 8 wurden sie recht umständlich über Interfaces und anonyme innere Klassen emuliert, wobei heute Lambda-Ausdrücke in JAVA anstelle davon verwendet werden können. Delegates sind für verschiedene Problemstellungen, wie z. B. Listener-Mechanismen, sehr nützlich.
Zuletzt gibt es in C# auch noch Attribut-Typen (Attributes), die im Wesentlichen den Annotationen entsprechen, die es seit Version 5 auch in JAVA gibt. Annotationen haben jedoch nichts unmittelbar mit objektorientierter Programmierung zu tun und sind daher nicht Gegenstand dieses Kurses.
Es ergibt sich die folgende grobe Einteilung der Typen in C#: Werttypen, and Referenztypen: Klassen, Interfaces, Arrays, Delegates, Attribut-Typen
Wohlgemerkt, dies ist keine Klassenhierarchie, sondern lediglich eine Einteilung der verschiedenen Arten von Typen in C#. Die Klassenhierarchie ist wesentlich komplexer und vereinheitlicht das Typsystem von C#, indem alle Typen von System.Object abgeleitet sind. Ein Ausschnitt aus der Klassenhierarchie im Namespace System sieht etwa so aus:
Wie Ihnen sicher aufgefallen ist, sind einige der Arten von Typen aus der obigen Liste jeweils durch eine spezielle Klasse (Array, Delegate, Attribute) vertreten. Man kann dies als Hinweis darauf verstehen, dass tatsächlich alle Arten von Typen integriert sind und es keine grundsätzlichen Barrieren zwischen ihnen gibt. In C# haben alle Klassen außer System.Object, genau wie in JAVA, genau eine Superklasse. Sie können jedoch beliebig viele Interfaces implementieren. Die Tatsache, dass Werttypen als Subtypen eines Referenztypen (nämlich Object) deklariert sind, verrät außerdem, dass C# über Auto-Boxing und Unboxing verfügt.","<answer> Delegates in C# sind Zeiger auf an ein Objekt gebundene einzelne Methoden. Sie ermöglichen es, Funktionen und Methoden als Parameter an andere Funktionen oder Methoden zu übergeben, was besonders nützlich für Problemstellungen wie Listener-Mechanismen ist. Delegates ersetzen die aus anderen Sprachen bekannten Funktionszeiger oder Funktionspointer. <answer> <question> Was sind Delegates in C# und wozu dienen sie? <question>"
"In der vorangegangenen Kurseinheit haben Sie die Grundkonzepte der objektorientierten Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten. Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden. Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Programmierung nicht grundsätzlich festgelegt. Eine gewisse Anerkennung und Verbreitung erfahren haben aber drei verschiedene Ansätze: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschieden aufgebaute Objekte; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden.
Den Konstruktoransatz findet man in Sprachen wie EMERALD, den Prototypenansatz in Sprachen wie SELF oder JAVASCRIPT und den Klassenansatz in Sprachen wie SMALLTALK, C++, EIFFEL, JAVA, C#, SCALA und vielen anderen mehr. Aus verschiedenen Gründen hat sich die dritte Variante, die klassenbasierte Form der Objektorientierung (wobei die Klassen die erwähnten Vorlagen sind) gegenüber der zweiten, der prototypenbasierten Form der Objektorientierung weitgehend durchgesetzt. Die erste Variante findet im Zuge einer gewissen Ernüchterung bzgl. der objektorientierten Programmierung zunehmend Anhänger, und zwar da, wo Objekte und dynamisches Binden (s. Abschnitt 12) im Kontext traditioneller imperativer Programmierung angeboten werden sollen. Sie liegt damit aber außerhalb des Gegenstands dieses Kurstextes. Die Dominanz der klassenbasierten Form der objektorientierten Programmierung liegt vermutlich zum einen daran, dass Klassen ein klassisches, in anderen Disziplinen wie der Mathematik oder der Biologie fest etabliertes Ordnungskonzept darstellen, mit dessen Hilfe sich auch objektorientierte Programme gut strukturieren lassen, und zum anderen daran, dass Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen (also Sprachen, bei denen alle Variablen und Funktionen bei der Deklaration einen Typ zugeordnet bekommen und der Variableninhalt immer vom deklarierten Typ sein muss) übernehmen kann (der Gegenstand von Kurseinheit 3). Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann, z. B. indem sie eine Methodendefinition nur für ein einziges Objekt abzuändern erlaubt. Letzteres ist z. B. bei der Programmierung von grafischen Bedienoberflächen, bei der das Drücken verschiedener Buttons jeweils verschiedene Ereignisse auslöst (Methoden aufruft), sehr praktisch. Nicht umsonst ist JAVASCRIPT als Programmiersprache für interaktive Webseiten so erfolgreich. Auch wenn es gute Gründe für die prototypenbasierte Form der objektorientierten Programmierung gibt (und sich deswegen jedes Werk zum Thema objektorientierte Programmierung — so wie auch das Ihnen vorliegende — gemüßigt fühlt, darauf hinzuweisen, dass es sie gibt), werde ich mich im Folgenden vornehmlich Klassen als strukturbildenden Konzepten der objektorientierten Programmierung zuwenden und nur hier und da Prototypen kurz die Referenz erweisen.","<answer> Es gibt drei verschiedene Ansätze, um Objekte in der objektorientierten Programmierung zu erzeugen und ihnen Instanzvariablen und Methoden zuzuordnen: Konstruktoransatz: Bei diesem Ansatz wird der Aufbau eines Objekts in einer Methode beschrieben, die dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zuweist. Verschiedene Konstruktoren können verschiedene Varianten von Objekten erzeugen. Prototypenansatz: Hier wird ein bereits existierendes Objekt samt seiner Instanzvariablen und Methoden geklont. Ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt oder abgeändert werden. Klassenansatz: Alle Objekte werden als Instanzen von bestimmten Vorlagen (Klassen) erzeugt. Diese Klassen definieren die Struktur und das Verhalten der Objekte. <answer> <question> Welche Ansätze gibt es, um Objekte in der objektorientierten Programmierung zu erzeugen und ihnen Instanzvariablen und Methoden zuzuordnen? <question>"
"In der vorangegangenen Kurseinheit haben Sie die Grundkonzepte der objektorientierten Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten. Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden. Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Programmierung nicht grundsätzlich festgelegt. Eine gewisse Anerkennung und Verbreitung erfahren haben aber drei verschiedene Ansätze: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschieden aufgebaute Objekte; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden.
Den Konstruktoransatz findet man in Sprachen wie EMERALD, den Prototypenansatz in Sprachen wie SELF oder JAVASCRIPT und den Klassenansatz in Sprachen wie SMALLTALK, C++, EIFFEL, JAVA, C#, SCALA und vielen anderen mehr. Aus verschiedenen Gründen hat sich die dritte Variante, die klassenbasierte Form der Objektorientierung (wobei die Klassen die erwähnten Vorlagen sind) gegenüber der zweiten, der prototypenbasierten Form der Objektorientierung weitgehend durchgesetzt. Die erste Variante findet im Zuge einer gewissen Ernüchterung bzgl. der objektorientierten Programmierung zunehmend Anhänger, und zwar da, wo Objekte und dynamisches Binden (s. Abschnitt 12) im Kontext traditioneller imperativer Programmierung angeboten werden sollen. Sie liegt damit aber außerhalb des Gegenstands dieses Kurstextes. Die Dominanz der klassenbasierten Form der objektorientierten Programmierung liegt vermutlich zum einen daran, dass Klassen ein klassisches, in anderen Disziplinen wie der Mathematik oder der Biologie fest etabliertes Ordnungskonzept darstellen, mit dessen Hilfe sich auch objektorientierte Programme gut strukturieren lassen, und zum anderen daran, dass Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen (also Sprachen, bei denen alle Variablen und Funktionen bei der Deklaration einen Typ zugeordnet bekommen und der Variableninhalt immer vom deklarierten Typ sein muss) übernehmen kann (der Gegenstand von Kurseinheit 3). Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann, z. B. indem sie eine Methodendefinition nur für ein einziges Objekt abzuändern erlaubt. Letzteres ist z. B. bei der Programmierung von grafischen Bedienoberflächen, bei der das Drücken verschiedener Buttons jeweils verschiedene Ereignisse auslöst (Methoden aufruft), sehr praktisch. Nicht umsonst ist JAVASCRIPT als Programmiersprache für interaktive Webseiten so erfolgreich. Auch wenn es gute Gründe für die prototypenbasierte Form der objektorientierten Programmierung gibt (und sich deswegen jedes Werk zum Thema objektorientierte Programmierung — so wie auch das Ihnen vorliegende — gemüßigt fühlt, darauf hinzuweisen, dass es sie gibt), werde ich mich im Folgenden vornehmlich Klassen als strukturbildenden Konzepten der objektorientierten Programmierung zuwenden und nur hier und da Prototypen kurz die Referenz erweisen.",<answer> Der Konstruktoransatz findet sich in Sprachen wie EMERALD. <answer> <question> Welche Programmiersprachen nutzen den Konstruktoransatz? <question>
"In der vorangegangenen Kurseinheit haben Sie die Grundkonzepte der objektorientierten Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten. Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden. Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Programmierung nicht grundsätzlich festgelegt. Eine gewisse Anerkennung und Verbreitung erfahren haben aber drei verschiedene Ansätze: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschieden aufgebaute Objekte; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden.
Den Konstruktoransatz findet man in Sprachen wie EMERALD, den Prototypenansatz in Sprachen wie SELF oder JAVASCRIPT und den Klassenansatz in Sprachen wie SMALLTALK, C++, EIFFEL, JAVA, C#, SCALA und vielen anderen mehr. Aus verschiedenen Gründen hat sich die dritte Variante, die klassenbasierte Form der Objektorientierung (wobei die Klassen die erwähnten Vorlagen sind) gegenüber der zweiten, der prototypenbasierten Form der Objektorientierung weitgehend durchgesetzt. Die erste Variante findet im Zuge einer gewissen Ernüchterung bzgl. der objektorientierten Programmierung zunehmend Anhänger, und zwar da, wo Objekte und dynamisches Binden (s. Abschnitt 12) im Kontext traditioneller imperativer Programmierung angeboten werden sollen. Sie liegt damit aber außerhalb des Gegenstands dieses Kurstextes. Die Dominanz der klassenbasierten Form der objektorientierten Programmierung liegt vermutlich zum einen daran, dass Klassen ein klassisches, in anderen Disziplinen wie der Mathematik oder der Biologie fest etabliertes Ordnungskonzept darstellen, mit dessen Hilfe sich auch objektorientierte Programme gut strukturieren lassen, und zum anderen daran, dass Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen (also Sprachen, bei denen alle Variablen und Funktionen bei der Deklaration einen Typ zugeordnet bekommen und der Variableninhalt immer vom deklarierten Typ sein muss) übernehmen kann (der Gegenstand von Kurseinheit 3). Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann, z. B. indem sie eine Methodendefinition nur für ein einziges Objekt abzuändern erlaubt. Letzteres ist z. B. bei der Programmierung von grafischen Bedienoberflächen, bei der das Drücken verschiedener Buttons jeweils verschiedene Ereignisse auslöst (Methoden aufruft), sehr praktisch. Nicht umsonst ist JAVASCRIPT als Programmiersprache für interaktive Webseiten so erfolgreich. Auch wenn es gute Gründe für die prototypenbasierte Form der objektorientierten Programmierung gibt (und sich deswegen jedes Werk zum Thema objektorientierte Programmierung — so wie auch das Ihnen vorliegende — gemüßigt fühlt, darauf hinzuweisen, dass es sie gibt), werde ich mich im Folgenden vornehmlich Klassen als strukturbildenden Konzepten der objektorientierten Programmierung zuwenden und nur hier und da Prototypen kurz die Referenz erweisen.",<answer> Der Prototypenansatz wird in Sprachen wie SELF oder JAVASCRIPT angewendet. <answer> <question> Welche Programmiersprachen nutzen den Prototypenansatz? <question>
"In der vorangegangenen Kurseinheit haben Sie die Grundkonzepte der objektorientierten Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten. Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden. Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Programmierung nicht grundsätzlich festgelegt. Eine gewisse Anerkennung und Verbreitung erfahren haben aber drei verschiedene Ansätze: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschieden aufgebaute Objekte; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden.
Den Konstruktoransatz findet man in Sprachen wie EMERALD, den Prototypenansatz in Sprachen wie SELF oder JAVASCRIPT und den Klassenansatz in Sprachen wie SMALLTALK, C++, EIFFEL, JAVA, C#, SCALA und vielen anderen mehr. Aus verschiedenen Gründen hat sich die dritte Variante, die klassenbasierte Form der Objektorientierung (wobei die Klassen die erwähnten Vorlagen sind) gegenüber der zweiten, der prototypenbasierten Form der Objektorientierung weitgehend durchgesetzt. Die erste Variante findet im Zuge einer gewissen Ernüchterung bzgl. der objektorientierten Programmierung zunehmend Anhänger, und zwar da, wo Objekte und dynamisches Binden (s. Abschnitt 12) im Kontext traditioneller imperativer Programmierung angeboten werden sollen. Sie liegt damit aber außerhalb des Gegenstands dieses Kurstextes. Die Dominanz der klassenbasierten Form der objektorientierten Programmierung liegt vermutlich zum einen daran, dass Klassen ein klassisches, in anderen Disziplinen wie der Mathematik oder der Biologie fest etabliertes Ordnungskonzept darstellen, mit dessen Hilfe sich auch objektorientierte Programme gut strukturieren lassen, und zum anderen daran, dass Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen (also Sprachen, bei denen alle Variablen und Funktionen bei der Deklaration einen Typ zugeordnet bekommen und der Variableninhalt immer vom deklarierten Typ sein muss) übernehmen kann (der Gegenstand von Kurseinheit 3). Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann, z. B. indem sie eine Methodendefinition nur für ein einziges Objekt abzuändern erlaubt. Letzteres ist z. B. bei der Programmierung von grafischen Bedienoberflächen, bei der das Drücken verschiedener Buttons jeweils verschiedene Ereignisse auslöst (Methoden aufruft), sehr praktisch. Nicht umsonst ist JAVASCRIPT als Programmiersprache für interaktive Webseiten so erfolgreich. Auch wenn es gute Gründe für die prototypenbasierte Form der objektorientierten Programmierung gibt (und sich deswegen jedes Werk zum Thema objektorientierte Programmierung — so wie auch das Ihnen vorliegende — gemüßigt fühlt, darauf hinzuweisen, dass es sie gibt), werde ich mich im Folgenden vornehmlich Klassen als strukturbildenden Konzepten der objektorientierten Programmierung zuwenden und nur hier und da Prototypen kurz die Referenz erweisen.","<answer> Der Klassenansatz wird in Sprachen wie SMALLTALK, C++, EIFFEL, JAVA, C#, SCALA und vielen anderen mehr angewendet. <answer> <question> Welche Programmiersprachen nutzen den Klassenansatz? <question>"
"In der vorangegangenen Kurseinheit haben Sie die Grundkonzepte der objektorientierten Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten. Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden. Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Programmierung nicht grundsätzlich festgelegt. Eine gewisse Anerkennung und Verbreitung erfahren haben aber drei verschiedene Ansätze: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschieden aufgebaute Objekte; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden.
Den Konstruktoransatz findet man in Sprachen wie EMERALD, den Prototypenansatz in Sprachen wie SELF oder JAVASCRIPT und den Klassenansatz in Sprachen wie SMALLTALK, C++, EIFFEL, JAVA, C#, SCALA und vielen anderen mehr. Aus verschiedenen Gründen hat sich die dritte Variante, die klassenbasierte Form der Objektorientierung (wobei die Klassen die erwähnten Vorlagen sind) gegenüber der zweiten, der prototypenbasierten Form der Objektorientierung weitgehend durchgesetzt. Die erste Variante findet im Zuge einer gewissen Ernüchterung bzgl. der objektorientierten Programmierung zunehmend Anhänger, und zwar da, wo Objekte und dynamisches Binden (s. Abschnitt 12) im Kontext traditioneller imperativer Programmierung angeboten werden sollen. Sie liegt damit aber außerhalb des Gegenstands dieses Kurstextes. Die Dominanz der klassenbasierten Form der objektorientierten Programmierung liegt vermutlich zum einen daran, dass Klassen ein klassisches, in anderen Disziplinen wie der Mathematik oder der Biologie fest etabliertes Ordnungskonzept darstellen, mit dessen Hilfe sich auch objektorientierte Programme gut strukturieren lassen, und zum anderen daran, dass Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen (also Sprachen, bei denen alle Variablen und Funktionen bei der Deklaration einen Typ zugeordnet bekommen und der Variableninhalt immer vom deklarierten Typ sein muss) übernehmen kann (der Gegenstand von Kurseinheit 3). Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann, z. B. indem sie eine Methodendefinition nur für ein einziges Objekt abzuändern erlaubt. Letzteres ist z. B. bei der Programmierung von grafischen Bedienoberflächen, bei der das Drücken verschiedener Buttons jeweils verschiedene Ereignisse auslöst (Methoden aufruft), sehr praktisch. Nicht umsonst ist JAVASCRIPT als Programmiersprache für interaktive Webseiten so erfolgreich. Auch wenn es gute Gründe für die prototypenbasierte Form der objektorientierten Programmierung gibt (und sich deswegen jedes Werk zum Thema objektorientierte Programmierung — so wie auch das Ihnen vorliegende — gemüßigt fühlt, darauf hinzuweisen, dass es sie gibt), werde ich mich im Folgenden vornehmlich Klassen als strukturbildenden Konzepten der objektorientierten Programmierung zuwenden und nur hier und da Prototypen kurz die Referenz erweisen.","<answer> Die klassenbasierte Form der objektorientierten Programmierung hat sich vermutlich aus verschiedenen Gründen durchgesetzt. Zum einen bieten Klassen ein etabliertes Ordnungskonzept, das in anderen Disziplinen wie Mathematik und Biologie verwendet wird, und das sich gut zur Strukturierung von objektorientierten Programmen eignet. Zum anderen eignen sich Klassen als Vorlagen für Typen, was die Integration von objektorientierter Programmierung in typisierte Sprachen ermöglicht. Die prototypenbasierte Form der Objektorientierung bietet hingegen Flexibilität bei der Anpassung von einzelnen Objekten an ihren Zweck und ist besonders nützlich in interaktiven Anwendungen. <answer> <question> Warum hat sich die klassenbasierte Form der objektorientierten Programmierung gegenüber der prototypenbasierten Form durchgesetzt? <question>"
"In der vorangegangenen Kurseinheit haben Sie die Grundkonzepte der objektorientierten Programmierung mit SMALLTALK kennengelernt. Neben den Objekten selbst zählen dazu vor allem die Beziehungen zwischen diesen (durch Instanzvariablen ausgedrückt), der davon abgeleitete Zustand von Objekten sowie das in Form von Methoden definierte Verhalten. Was bislang verschwiegen wurde, ist, wie Objekte, für die es keine literale Repräsentation gibt, entstehen und wie ihnen ihre Instanzvariablen und ihre Methoden zugeordnet werden. Wie das zu geschehen hat, ist mit dem Begriff der objektorientierten Programmierung nicht grundsätzlich festgelegt. Eine gewisse Anerkennung und Verbreitung erfahren haben aber drei verschiedene Ansätze: der Konstruktoransatz, bei dem der Aufbau eines Objekts in einer Methode beschrieben wird, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden; verschiedene Konstruktoren erzeugen dann verschieden aufgebaute Objekte; der Prototypenansatz, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird; ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden; und der Klassenansatz, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden.
Den Konstruktoransatz findet man in Sprachen wie EMERALD, den Prototypenansatz in Sprachen wie SELF oder JAVASCRIPT und den Klassenansatz in Sprachen wie SMALLTALK, C++, EIFFEL, JAVA, C#, SCALA und vielen anderen mehr. Aus verschiedenen Gründen hat sich die dritte Variante, die klassenbasierte Form der Objektorientierung (wobei die Klassen die erwähnten Vorlagen sind) gegenüber der zweiten, der prototypenbasierten Form der Objektorientierung weitgehend durchgesetzt. Die erste Variante findet im Zuge einer gewissen Ernüchterung bzgl. der objektorientierten Programmierung zunehmend Anhänger, und zwar da, wo Objekte und dynamisches Binden (s. Abschnitt 12) im Kontext traditioneller imperativer Programmierung angeboten werden sollen. Sie liegt damit aber außerhalb des Gegenstands dieses Kurstextes. Die Dominanz der klassenbasierten Form der objektorientierten Programmierung liegt vermutlich zum einen daran, dass Klassen ein klassisches, in anderen Disziplinen wie der Mathematik oder der Biologie fest etabliertes Ordnungskonzept darstellen, mit dessen Hilfe sich auch objektorientierte Programme gut strukturieren lassen, und zum anderen daran, dass Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen (also Sprachen, bei denen alle Variablen und Funktionen bei der Deklaration einen Typ zugeordnet bekommen und der Variableninhalt immer vom deklarierten Typ sein muss) übernehmen kann (der Gegenstand von Kurseinheit 3). Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann, z. B. indem sie eine Methodendefinition nur für ein einziges Objekt abzuändern erlaubt. Letzteres ist z. B. bei der Programmierung von grafischen Bedienoberflächen, bei der das Drücken verschiedener Buttons jeweils verschiedene Ereignisse auslöst (Methoden aufruft), sehr praktisch. Nicht umsonst ist JAVASCRIPT als Programmiersprache für interaktive Webseiten so erfolgreich. Auch wenn es gute Gründe für die prototypenbasierte Form der objektorientierten Programmierung gibt (und sich deswegen jedes Werk zum Thema objektorientierte Programmierung — so wie auch das Ihnen vorliegende — gemüßigt fühlt, darauf hinzuweisen, dass es sie gibt), werde ich mich im Folgenden vornehmlich Klassen als strukturbildenden Konzepten der objektorientierten Programmierung zuwenden und nur hier und da Prototypen kurz die Referenz erweisen.","<answer> Ja, es gibt gute Gründe, die prototypenbasierte Form der objektorientierten Programmierung zu nutzen. Sie erlaubt eine hohe Flexibilität bei der Anpassung von Objekten an ihren jeweiligen Zweck, insbesondere in interaktiven Anwendungen. Ein Beispiel dafür ist die Programmierung von grafischen Benutzeroberflächen, bei der verschiedene Buttons verschiedene Ereignisse auslösen können. JavaScript ist eine erfolgreiche Programmiersprache für interaktive Webseiten und basiert auf dem Prototypenansatz. <answer> <question> Gibt es gute Gründe, die prototypenbasierte Form der objektorientierten Programmierung zu nutzen? <question>"
"In rein objektorientierten Programmiersprachen sind sämtliche Daten, die ein Programm verarbeiten kann, in Form von Objekten im Speicher abgelegt. Der Reiz dieses Merkmals der objektorientierten Programmierung ist, dass unser Weltbild, zumindest in weiten Teilen, auf einem ähnlichen Modell basiert: Die Welt besteht aus Objekten, die miteinander in Beziehung stehen. Dabei ist der Objektbegriff nicht auf das rein Materielle beschränkt: Nach allgemeinem Verständnis sind Personen ebenso Objekte wie Dokumente, Zahlen oder Zeichen.
Bei der Übertragung von realen (d. h., aus einer Anwendungsdomäne stammenden) Sachverhalten in ein objektorientiertes Programm ergibt sich das Problem, dass die Übertragung, aufgrund der Homogenität der Objektorientierung (alles ist ein Objekt), gewisse fundamentale Unterschiedlichkeiten der Kategorien unserer Begriffswelt ignoriert: Zahlen beispielsweise sind im Gegensatz zu Dingen Objekte ohne Identität, Zustand oder Lebensdauer (sie werden daher auch häufig als Werte bezeichnet); Mengen sind nicht weiter abgrenzbare Elemente wie z. B. 1 Liter Wasser, die gar keine Objekte im eigentlichen Sinn haben (auch sie haben keine Identität) usw. Gleichwohl kommen sie alle in objektorientierten Programmen vor und werden dort — zumindest der reinen Lehre nach — durch Objekte repräsentiert. Der Ansatz, alles trotz evidenter ontologischer Unterschiede programmiersprachlich über einen Kamm zu scheren, führt hier und da zu gewissen Inkonsistenzen im ansonsten klaren, ja puristischen objektorientierten Weltbild, mit denen wir leben müssen, wenn wir objektorientiert programmieren wollen (vgl. dazu auch Kapitel 60 in Kurseinheit 6). Es ist dies der Preis des auch als ""Ockhams Rasiermesser"" bekannten Sparsamkeitsprinzips, das auch für die objektorientierte Programmierung Leitlinie ist.
Wie bereits erwähnt, sind Objekte im Speicher abgelegte Daten. Dabei ist jedes Objekt an genau einer Stelle im Speicher abgelegt: Es wird damit durch seine Speicherstelle eindeutig identifiziert. Aufgrund dieser eindeutigen Identifizierbarkeit spricht man auch von der Identität eines Objekts; sie kann aus technischer Sicht mit der Speicherstelle, an der das Objekt abgelegt ist, gleichgesetzt werden. Da keine zwei Objekte an derselben Stelle abgelegt werden können, haben auch keine zwei Objekte dieselbe Identität.
Objekte sind grundsätzlich von Werten zu unterscheiden. Werte werden auch im Speicher abgelegt, haben aber keine Identität. Es folgt, dass derselbe Wert an verschiedenen Stellen im Speicher vorkommen kann. Viele objektorientierte Programmiersprachen (wie etwa JAVA oder C#) unterscheiden ganz offen zwischen Werten und Objekten; SMALLTALK tut dies nur hinter den Kulissen und folgt ansonsten seinem Motto ""alles ist ein Objekt"".
Die Menge des Speichers, den ein Objekt belegt, ist aus technischen Gründen konstant. Objekte können somit weder wachsen noch schrumpfen. Sollte dies trotzdem notwendig sein, bleibt nur, ein neues Objekt zu erzeugen, das an die Stelle (nicht die Speicherstelle!) des anderen tritt. Das neue Objekt hat jedoch eine andere Identität, so dass alle Stellen im Programm, die sich auf das alte Objekt beziehen, entsprechend angepasst werden müssen. Wie das geht, wird in Kurseinheit 2, Abschnitt 14.2 erläutert.","<answer> Objekte sind in der objektorientierten Programmierung Daten, die im Speicher abgelegt sind und in der Lage sind, Informationen zu speichern und Aktionen auszuführen. Sie repräsentieren Dinge aus der realen Welt und können miteinander in Beziehung stehen. <answer> <question> Was sind Objekte in der objektorientierten Programmierung? <question>"
"In rein objektorientierten Programmiersprachen sind sämtliche Daten, die ein Programm verarbeiten kann, in Form von Objekten im Speicher abgelegt. Der Reiz dieses Merkmals der objektorientierten Programmierung ist, dass unser Weltbild, zumindest in weiten Teilen, auf einem ähnlichen Modell basiert: Die Welt besteht aus Objekten, die miteinander in Beziehung stehen. Dabei ist der Objektbegriff nicht auf das rein Materielle beschränkt: Nach allgemeinem Verständnis sind Personen ebenso Objekte wie Dokumente, Zahlen oder Zeichen.
Bei der Übertragung von realen (d. h., aus einer Anwendungsdomäne stammenden) Sachverhalten in ein objektorientiertes Programm ergibt sich das Problem, dass die Übertragung, aufgrund der Homogenität der Objektorientierung (alles ist ein Objekt), gewisse fundamentale Unterschiedlichkeiten der Kategorien unserer Begriffswelt ignoriert: Zahlen beispielsweise sind im Gegensatz zu Dingen Objekte ohne Identität, Zustand oder Lebensdauer (sie werden daher auch häufig als Werte bezeichnet); Mengen sind nicht weiter abgrenzbare Elemente wie z. B. 1 Liter Wasser, die gar keine Objekte im eigentlichen Sinn haben (auch sie haben keine Identität) usw. Gleichwohl kommen sie alle in objektorientierten Programmen vor und werden dort — zumindest der reinen Lehre nach — durch Objekte repräsentiert. Der Ansatz, alles trotz evidenter ontologischer Unterschiede programmiersprachlich über einen Kamm zu scheren, führt hier und da zu gewissen Inkonsistenzen im ansonsten klaren, ja puristischen objektorientierten Weltbild, mit denen wir leben müssen, wenn wir objektorientiert programmieren wollen (vgl. dazu auch Kapitel 60 in Kurseinheit 6). Es ist dies der Preis des auch als ""Ockhams Rasiermesser"" bekannten Sparsamkeitsprinzips, das auch für die objektorientierte Programmierung Leitlinie ist.
Wie bereits erwähnt, sind Objekte im Speicher abgelegte Daten. Dabei ist jedes Objekt an genau einer Stelle im Speicher abgelegt: Es wird damit durch seine Speicherstelle eindeutig identifiziert. Aufgrund dieser eindeutigen Identifizierbarkeit spricht man auch von der Identität eines Objekts; sie kann aus technischer Sicht mit der Speicherstelle, an der das Objekt abgelegt ist, gleichgesetzt werden. Da keine zwei Objekte an derselben Stelle abgelegt werden können, haben auch keine zwei Objekte dieselbe Identität.
Objekte sind grundsätzlich von Werten zu unterscheiden. Werte werden auch im Speicher abgelegt, haben aber keine Identität. Es folgt, dass derselbe Wert an verschiedenen Stellen im Speicher vorkommen kann. Viele objektorientierte Programmiersprachen (wie etwa JAVA oder C#) unterscheiden ganz offen zwischen Werten und Objekten; SMALLTALK tut dies nur hinter den Kulissen und folgt ansonsten seinem Motto ""alles ist ein Objekt"".
Die Menge des Speichers, den ein Objekt belegt, ist aus technischen Gründen konstant. Objekte können somit weder wachsen noch schrumpfen. Sollte dies trotzdem notwendig sein, bleibt nur, ein neues Objekt zu erzeugen, das an die Stelle (nicht die Speicherstelle!) des anderen tritt. Das neue Objekt hat jedoch eine andere Identität, so dass alle Stellen im Programm, die sich auf das alte Objekt beziehen, entsprechend angepasst werden müssen. Wie das geht, wird in Kurseinheit 2, Abschnitt 14.2 erläutert.","<answer> In der objektorientierten Programmierung werden verschiedene Arten von Sachverhalten, die in der realen Welt unterschiedliche Eigenschaften haben, oft durch Objekte repräsentiert. Dies kann zu Inkonsistenzen führen, da nicht alle Sachverhalte dieselben Eigenschaften wie Objekte haben. Dies ist auf die homogene Natur der Objektorientierung zurückzuführen. <answer> <question> Warum gibt es in der objektorientierten Programmierung gewisse Inkonsistenzen bei der Repräsentation von Sachverhalten? <question>"
"In rein objektorientierten Programmiersprachen sind sämtliche Daten, die ein Programm verarbeiten kann, in Form von Objekten im Speicher abgelegt. Der Reiz dieses Merkmals der objektorientierten Programmierung ist, dass unser Weltbild, zumindest in weiten Teilen, auf einem ähnlichen Modell basiert: Die Welt besteht aus Objekten, die miteinander in Beziehung stehen. Dabei ist der Objektbegriff nicht auf das rein Materielle beschränkt: Nach allgemeinem Verständnis sind Personen ebenso Objekte wie Dokumente, Zahlen oder Zeichen.
Bei der Übertragung von realen (d. h., aus einer Anwendungsdomäne stammenden) Sachverhalten in ein objektorientiertes Programm ergibt sich das Problem, dass die Übertragung, aufgrund der Homogenität der Objektorientierung (alles ist ein Objekt), gewisse fundamentale Unterschiedlichkeiten der Kategorien unserer Begriffswelt ignoriert: Zahlen beispielsweise sind im Gegensatz zu Dingen Objekte ohne Identität, Zustand oder Lebensdauer (sie werden daher auch häufig als Werte bezeichnet); Mengen sind nicht weiter abgrenzbare Elemente wie z. B. 1 Liter Wasser, die gar keine Objekte im eigentlichen Sinn haben (auch sie haben keine Identität) usw. Gleichwohl kommen sie alle in objektorientierten Programmen vor und werden dort — zumindest der reinen Lehre nach — durch Objekte repräsentiert. Der Ansatz, alles trotz evidenter ontologischer Unterschiede programmiersprachlich über einen Kamm zu scheren, führt hier und da zu gewissen Inkonsistenzen im ansonsten klaren, ja puristischen objektorientierten Weltbild, mit denen wir leben müssen, wenn wir objektorientiert programmieren wollen (vgl. dazu auch Kapitel 60 in Kurseinheit 6). Es ist dies der Preis des auch als ""Ockhams Rasiermesser"" bekannten Sparsamkeitsprinzips, das auch für die objektorientierte Programmierung Leitlinie ist.
Wie bereits erwähnt, sind Objekte im Speicher abgelegte Daten. Dabei ist jedes Objekt an genau einer Stelle im Speicher abgelegt: Es wird damit durch seine Speicherstelle eindeutig identifiziert. Aufgrund dieser eindeutigen Identifizierbarkeit spricht man auch von der Identität eines Objekts; sie kann aus technischer Sicht mit der Speicherstelle, an der das Objekt abgelegt ist, gleichgesetzt werden. Da keine zwei Objekte an derselben Stelle abgelegt werden können, haben auch keine zwei Objekte dieselbe Identität.
Objekte sind grundsätzlich von Werten zu unterscheiden. Werte werden auch im Speicher abgelegt, haben aber keine Identität. Es folgt, dass derselbe Wert an verschiedenen Stellen im Speicher vorkommen kann. Viele objektorientierte Programmiersprachen (wie etwa JAVA oder C#) unterscheiden ganz offen zwischen Werten und Objekten; SMALLTALK tut dies nur hinter den Kulissen und folgt ansonsten seinem Motto ""alles ist ein Objekt"".
Die Menge des Speichers, den ein Objekt belegt, ist aus technischen Gründen konstant. Objekte können somit weder wachsen noch schrumpfen. Sollte dies trotzdem notwendig sein, bleibt nur, ein neues Objekt zu erzeugen, das an die Stelle (nicht die Speicherstelle!) des anderen tritt. Das neue Objekt hat jedoch eine andere Identität, so dass alle Stellen im Programm, die sich auf das alte Objekt beziehen, entsprechend angepasst werden müssen. Wie das geht, wird in Kurseinheit 2, Abschnitt 14.2 erläutert.","<answer> Objekte haben eine eindeutige Identität und sind an einer bestimmten Stelle im Speicher abgelegt, während Werte im Speicher abgelegt sind, aber keine Identität haben. Mehrere Variablen können auf denselben Wert zeigen, während keine zwei Objekte dieselbe Identität haben können. <answer> <question> Was ist der Unterschied zwischen einem Objekt und einem Wert in der Programmierung? <question>"
"In rein objektorientierten Programmiersprachen sind sämtliche Daten, die ein Programm verarbeiten kann, in Form von Objekten im Speicher abgelegt. Der Reiz dieses Merkmals der objektorientierten Programmierung ist, dass unser Weltbild, zumindest in weiten Teilen, auf einem ähnlichen Modell basiert: Die Welt besteht aus Objekten, die miteinander in Beziehung stehen. Dabei ist der Objektbegriff nicht auf das rein Materielle beschränkt: Nach allgemeinem Verständnis sind Personen ebenso Objekte wie Dokumente, Zahlen oder Zeichen.
Bei der Übertragung von realen (d. h., aus einer Anwendungsdomäne stammenden) Sachverhalten in ein objektorientiertes Programm ergibt sich das Problem, dass die Übertragung, aufgrund der Homogenität der Objektorientierung (alles ist ein Objekt), gewisse fundamentale Unterschiedlichkeiten der Kategorien unserer Begriffswelt ignoriert: Zahlen beispielsweise sind im Gegensatz zu Dingen Objekte ohne Identität, Zustand oder Lebensdauer (sie werden daher auch häufig als Werte bezeichnet); Mengen sind nicht weiter abgrenzbare Elemente wie z. B. 1 Liter Wasser, die gar keine Objekte im eigentlichen Sinn haben (auch sie haben keine Identität) usw. Gleichwohl kommen sie alle in objektorientierten Programmen vor und werden dort — zumindest der reinen Lehre nach — durch Objekte repräsentiert. Der Ansatz, alles trotz evidenter ontologischer Unterschiede programmiersprachlich über einen Kamm zu scheren, führt hier und da zu gewissen Inkonsistenzen im ansonsten klaren, ja puristischen objektorientierten Weltbild, mit denen wir leben müssen, wenn wir objektorientiert programmieren wollen (vgl. dazu auch Kapitel 60 in Kurseinheit 6). Es ist dies der Preis des auch als ""Ockhams Rasiermesser"" bekannten Sparsamkeitsprinzips, das auch für die objektorientierte Programmierung Leitlinie ist.
Wie bereits erwähnt, sind Objekte im Speicher abgelegte Daten. Dabei ist jedes Objekt an genau einer Stelle im Speicher abgelegt: Es wird damit durch seine Speicherstelle eindeutig identifiziert. Aufgrund dieser eindeutigen Identifizierbarkeit spricht man auch von der Identität eines Objekts; sie kann aus technischer Sicht mit der Speicherstelle, an der das Objekt abgelegt ist, gleichgesetzt werden. Da keine zwei Objekte an derselben Stelle abgelegt werden können, haben auch keine zwei Objekte dieselbe Identität.
Objekte sind grundsätzlich von Werten zu unterscheiden. Werte werden auch im Speicher abgelegt, haben aber keine Identität. Es folgt, dass derselbe Wert an verschiedenen Stellen im Speicher vorkommen kann. Viele objektorientierte Programmiersprachen (wie etwa JAVA oder C#) unterscheiden ganz offen zwischen Werten und Objekten; SMALLTALK tut dies nur hinter den Kulissen und folgt ansonsten seinem Motto ""alles ist ein Objekt"".
Die Menge des Speichers, den ein Objekt belegt, ist aus technischen Gründen konstant. Objekte können somit weder wachsen noch schrumpfen. Sollte dies trotzdem notwendig sein, bleibt nur, ein neues Objekt zu erzeugen, das an die Stelle (nicht die Speicherstelle!) des anderen tritt. Das neue Objekt hat jedoch eine andere Identität, so dass alle Stellen im Programm, die sich auf das alte Objekt beziehen, entsprechend angepasst werden müssen. Wie das geht, wird in Kurseinheit 2, Abschnitt 14.2 erläutert.","<answer> Die Unterscheidung zwischen Objekten und Werten ist wichtig, um die Verwendung und den Speicherbedarf von Daten effizient zu steuern. In einigen Programmiersprachen können Operationen auf Werten optimiert werden, da sie keine Identität haben und somit gleichwertig sind. Objekte hingegen haben eine eindeutige Identität, was bestimmte Operationen und Vergleiche komplexer macht. <answer> <question> Warum ist die Unterscheidung zwischen Objekten und Werten in einigen objektorientierten Programmiersprachen wichtig? <question>"
"In rein objektorientierten Programmiersprachen sind sämtliche Daten, die ein Programm verarbeiten kann, in Form von Objekten im Speicher abgelegt. Der Reiz dieses Merkmals der objektorientierten Programmierung ist, dass unser Weltbild, zumindest in weiten Teilen, auf einem ähnlichen Modell basiert: Die Welt besteht aus Objekten, die miteinander in Beziehung stehen. Dabei ist der Objektbegriff nicht auf das rein Materielle beschränkt: Nach allgemeinem Verständnis sind Personen ebenso Objekte wie Dokumente, Zahlen oder Zeichen.
Bei der Übertragung von realen (d. h., aus einer Anwendungsdomäne stammenden) Sachverhalten in ein objektorientiertes Programm ergibt sich das Problem, dass die Übertragung, aufgrund der Homogenität der Objektorientierung (alles ist ein Objekt), gewisse fundamentale Unterschiedlichkeiten der Kategorien unserer Begriffswelt ignoriert: Zahlen beispielsweise sind im Gegensatz zu Dingen Objekte ohne Identität, Zustand oder Lebensdauer (sie werden daher auch häufig als Werte bezeichnet); Mengen sind nicht weiter abgrenzbare Elemente wie z. B. 1 Liter Wasser, die gar keine Objekte im eigentlichen Sinn haben (auch sie haben keine Identität) usw. Gleichwohl kommen sie alle in objektorientierten Programmen vor und werden dort — zumindest der reinen Lehre nach — durch Objekte repräsentiert. Der Ansatz, alles trotz evidenter ontologischer Unterschiede programmiersprachlich über einen Kamm zu scheren, führt hier und da zu gewissen Inkonsistenzen im ansonsten klaren, ja puristischen objektorientierten Weltbild, mit denen wir leben müssen, wenn wir objektorientiert programmieren wollen (vgl. dazu auch Kapitel 60 in Kurseinheit 6). Es ist dies der Preis des auch als ""Ockhams Rasiermesser"" bekannten Sparsamkeitsprinzips, das auch für die objektorientierte Programmierung Leitlinie ist.
Wie bereits erwähnt, sind Objekte im Speicher abgelegte Daten. Dabei ist jedes Objekt an genau einer Stelle im Speicher abgelegt: Es wird damit durch seine Speicherstelle eindeutig identifiziert. Aufgrund dieser eindeutigen Identifizierbarkeit spricht man auch von der Identität eines Objekts; sie kann aus technischer Sicht mit der Speicherstelle, an der das Objekt abgelegt ist, gleichgesetzt werden. Da keine zwei Objekte an derselben Stelle abgelegt werden können, haben auch keine zwei Objekte dieselbe Identität.
Objekte sind grundsätzlich von Werten zu unterscheiden. Werte werden auch im Speicher abgelegt, haben aber keine Identität. Es folgt, dass derselbe Wert an verschiedenen Stellen im Speicher vorkommen kann. Viele objektorientierte Programmiersprachen (wie etwa JAVA oder C#) unterscheiden ganz offen zwischen Werten und Objekten; SMALLTALK tut dies nur hinter den Kulissen und folgt ansonsten seinem Motto ""alles ist ein Objekt"".
Die Menge des Speichers, den ein Objekt belegt, ist aus technischen Gründen konstant. Objekte können somit weder wachsen noch schrumpfen. Sollte dies trotzdem notwendig sein, bleibt nur, ein neues Objekt zu erzeugen, das an die Stelle (nicht die Speicherstelle!) des anderen tritt. Das neue Objekt hat jedoch eine andere Identität, so dass alle Stellen im Programm, die sich auf das alte Objekt beziehen, entsprechend angepasst werden müssen. Wie das geht, wird in Kurseinheit 2, Abschnitt 14.2 erläutert.","<answer> Objekte im Speicher haben eine feste Größe, die aus technischen Gründen nicht verändert werden kann. Wenn ein Objekt mehr Platz benötigt oder verkleinert werden muss, muss ein neues Objekt erzeugt werden, das an die Stelle des alten tritt. Dieses neue Objekt hat jedoch eine andere Identität, was Änderungen im Programm erfordern kann. <answer> <question> Was bedeutet es, dass Objekte im Speicher eine konstante Größe haben? <question>"
"In rein objektorientierten Programmiersprachen sind sämtliche Daten, die ein Programm verarbeiten kann, in Form von Objekten im Speicher abgelegt. Der Reiz dieses Merkmals der objektorientierten Programmierung ist, dass unser Weltbild, zumindest in weiten Teilen, auf einem ähnlichen Modell basiert: Die Welt besteht aus Objekten, die miteinander in Beziehung stehen. Dabei ist der Objektbegriff nicht auf das rein Materielle beschränkt: Nach allgemeinem Verständnis sind Personen ebenso Objekte wie Dokumente, Zahlen oder Zeichen.
Bei der Übertragung von realen (d. h., aus einer Anwendungsdomäne stammenden) Sachverhalten in ein objektorientiertes Programm ergibt sich das Problem, dass die Übertragung, aufgrund der Homogenität der Objektorientierung (alles ist ein Objekt), gewisse fundamentale Unterschiedlichkeiten der Kategorien unserer Begriffswelt ignoriert: Zahlen beispielsweise sind im Gegensatz zu Dingen Objekte ohne Identität, Zustand oder Lebensdauer (sie werden daher auch häufig als Werte bezeichnet); Mengen sind nicht weiter abgrenzbare Elemente wie z. B. 1 Liter Wasser, die gar keine Objekte im eigentlichen Sinn haben (auch sie haben keine Identität) usw. Gleichwohl kommen sie alle in objektorientierten Programmen vor und werden dort — zumindest der reinen Lehre nach — durch Objekte repräsentiert. Der Ansatz, alles trotz evidenter ontologischer Unterschiede programmiersprachlich über einen Kamm zu scheren, führt hier und da zu gewissen Inkonsistenzen im ansonsten klaren, ja puristischen objektorientierten Weltbild, mit denen wir leben müssen, wenn wir objektorientiert programmieren wollen (vgl. dazu auch Kapitel 60 in Kurseinheit 6). Es ist dies der Preis des auch als ""Ockhams Rasiermesser"" bekannten Sparsamkeitsprinzips, das auch für die objektorientierte Programmierung Leitlinie ist.
Wie bereits erwähnt, sind Objekte im Speicher abgelegte Daten. Dabei ist jedes Objekt an genau einer Stelle im Speicher abgelegt: Es wird damit durch seine Speicherstelle eindeutig identifiziert. Aufgrund dieser eindeutigen Identifizierbarkeit spricht man auch von der Identität eines Objekts; sie kann aus technischer Sicht mit der Speicherstelle, an der das Objekt abgelegt ist, gleichgesetzt werden. Da keine zwei Objekte an derselben Stelle abgelegt werden können, haben auch keine zwei Objekte dieselbe Identität.
Objekte sind grundsätzlich von Werten zu unterscheiden. Werte werden auch im Speicher abgelegt, haben aber keine Identität. Es folgt, dass derselbe Wert an verschiedenen Stellen im Speicher vorkommen kann. Viele objektorientierte Programmiersprachen (wie etwa JAVA oder C#) unterscheiden ganz offen zwischen Werten und Objekten; SMALLTALK tut dies nur hinter den Kulissen und folgt ansonsten seinem Motto ""alles ist ein Objekt"".
Die Menge des Speichers, den ein Objekt belegt, ist aus technischen Gründen konstant. Objekte können somit weder wachsen noch schrumpfen. Sollte dies trotzdem notwendig sein, bleibt nur, ein neues Objekt zu erzeugen, das an die Stelle (nicht die Speicherstelle!) des anderen tritt. Das neue Objekt hat jedoch eine andere Identität, so dass alle Stellen im Programm, die sich auf das alte Objekt beziehen, entsprechend angepasst werden müssen. Wie das geht, wird in Kurseinheit 2, Abschnitt 14.2 erläutert.","<answer> In SMALLTALK werden alle Daten als Objekte repräsentiert, unabhängig davon, ob es sich um Werte oder um komplexe Entitäten handelt. Dies ist Teil des objektorientierten Paradigmas von SMALLTALK, bei dem alles in Objekten organisiert ist. <answer> <question> Warum sagt man, dass in SMALLTALK ""alles ein Objekt"" ist? <question>"
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.
Konkret kann RTTI folgendermaßen genutzt werden: Es gibt eine Funktion namens typeid, die auf einer Referenz aufgerufen werden kann. Da diese Funktion auf Klassennamen überladen ist und eine Struktur zurückgibt, auf der == als Gleichheitstest definiert ist, kann der Typ eines Objekts ermittelt werden.
Eine weitere nützliche Funktion, die RTTI verwendet, ist dynamic_cast<T>(x). Diese Funktion nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt, andernfalls gibt sie 0 zurück.","<answer> Nein, C++ bietet keine eingebaute dynamische Typprüfung. <answer> <question> Bietet C++ eine dynamische Typprüfung wie andere Sprachen? <question>"
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.
Konkret kann RTTI folgendermaßen genutzt werden: Es gibt eine Funktion namens typeid, die auf einer Referenz aufgerufen werden kann. Da diese Funktion auf Klassennamen überladen ist und eine Struktur zurückgibt, auf der == als Gleichheitstest definiert ist, kann der Typ eines Objekts ermittelt werden.
Eine weitere nützliche Funktion, die RTTI verwendet, ist dynamic_cast<T>(x). Diese Funktion nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt, andernfalls gibt sie 0 zurück.","<answer> Einige Objekte in C++ wissen zumindest im Prinzip, von welcher Klasse sie eine Instanz sind, weil sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Diese virtuelle Funktionstabelle dient als eine Art Repräsentation der Klasse. <answer> <question> Warum wissen einige Objekte in C++, von welcher Klasse sie eine Instanz sind? <question>"
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.
Konkret kann RTTI folgendermaßen genutzt werden: Es gibt eine Funktion namens typeid, die auf einer Referenz aufgerufen werden kann. Da diese Funktion auf Klassennamen überladen ist und eine Struktur zurückgibt, auf der == als Gleichheitstest definiert ist, kann der Typ eines Objekts ermittelt werden.
Eine weitere nützliche Funktion, die RTTI verwendet, ist dynamic_cast<T>(x). Diese Funktion nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt, andernfalls gibt sie 0 zurück.","<answer> Runtime Type Information (RTTI) ist eine Funktion in C++, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. RTTI ermöglicht die Ermittlung des Typs eines Objekts zur Laufzeit. <answer> <question> Was ist Runtime Type Information (RTTI) in C++? <question>"
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.
Konkret kann RTTI folgendermaßen genutzt werden: Es gibt eine Funktion namens typeid, die auf einer Referenz aufgerufen werden kann. Da diese Funktion auf Klassennamen überladen ist und eine Struktur zurückgibt, auf der == als Gleichheitstest definiert ist, kann der Typ eines Objekts ermittelt werden.
Eine weitere nützliche Funktion, die RTTI verwendet, ist dynamic_cast<T>(x). Diese Funktion nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt, andernfalls gibt sie 0 zurück.","<answer> RTTI kann verwendet werden, indem die Funktion typeid auf eine Referenz aufgerufen wird. Diese Funktion ist auf Klassennamen überladen und gibt eine Struktur zurück, auf der == als Gleichheitstest definiert ist. Der Typ eines Objekts kann überprüft werden, indem typeid(x) == typeid(T) verwendet wird. <answer> <question> Wie kann RTTI in C++ verwendet werden, um den Typ eines Objekts zu ermitteln? <question>"
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.
Konkret kann RTTI folgendermaßen genutzt werden: Es gibt eine Funktion namens typeid, die auf einer Referenz aufgerufen werden kann. Da diese Funktion auf Klassennamen überladen ist und eine Struktur zurückgibt, auf der == als Gleichheitstest definiert ist, kann der Typ eines Objekts ermittelt werden.
Eine weitere nützliche Funktion, die RTTI verwendet, ist dynamic_cast<T>(x). Diese Funktion nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt, andernfalls gibt sie 0 zurück.","<answer> Die Funktion dynamic_cast<T>(x) in C++ nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt. Andernfalls gibt sie 0 zurück. <answer> <question> Was ist die Funktion dynamic_cast in C++? <question>"
"Die Beschreibung der dynamischen Typprüfung in C++ ist knapp: Es gibt keine. Einige Objekte in C++ wissen jedoch zumindest im Prinzip, von welcher Klasse sie eine Instanz sind. Dies liegt daran, dass sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Da diese virtuelle Funktionstabelle für alle Objekte einer Klasse gleich ist, kann sie als eine Art Repräsentation der Klasse angesehen werden. Aus diesem Grund wurde C++ schließlich eine Bibliotheksfunktion hinzugefügt, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. Diese Information wird als Runtime Type Information (RTTI) bezeichnet.
Konkret kann RTTI folgendermaßen genutzt werden: Es gibt eine Funktion namens typeid, die auf einer Referenz aufgerufen werden kann. Da diese Funktion auf Klassennamen überladen ist und eine Struktur zurückgibt, auf der == als Gleichheitstest definiert ist, kann der Typ eines Objekts ermittelt werden.
Eine weitere nützliche Funktion, die RTTI verwendet, ist dynamic_cast<T>(x). Diese Funktion nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt, andernfalls gibt sie 0 zurück.","<answer> Eine Möglichkeit, den Typ einer Klasse in C++ ohne Verwendung von typeid herauszufinden, ist die Verwendung von dynamic_cast. Man kann versuchen, das Objekt auf verschiedene Klassen zu überprüfen, und wenn das Casting erfolgreich ist, gehört das Objekt zu dieser Klasse. <answer> <question> Wie kann in C++ ohne Verwendung von typeid herausgefunden werden, welcher Klasse Instanzen aller Klassen angehören? <question>"
"Nicht alle Collections dienen der Umsetzung von :n-Beziehungen. Ein gutes Beispiel ist die Klasse ""Interval"".
Bei Instanzen der Klasse ""Interval"" handelt es sich um endliche arithmetische Folgen, also um beschränkte Folgen von Zahlen, die alle denselben Abstand zueinander haben. Die Elemente einer solchen Collection müssen deswegen nicht gespeichert, sondern können berechnet werden. Die Spezifikation eines Intervalls umfasst seinen Anfangs- und seinen Endwert sowie die Schrittweite, die auch negativ sein darf.
""5 to: 1 by: -2"" erzeugt ein Intervall, das die Zahlen 5, 3 und 1 enthält. Intervalle dienen vor allem dem Zweck, sog. ""For""-Schleifen zu emulieren.
Um der geschätzten Programmiererin auch noch die Klammern zu ersparen, wurde gleich noch die Methode ""to:by:do:"" hinzugefügt.
(Manche beachten, dass hier der Iterator in der Klasse ""Number"" und nicht in einer Collection wie ""Interval"" definiert wurde.) Wie man sieht, ist es in SMALLTALK möglich, ohne großen Aufwand neue Ausdrucksformen hinzuzufügen, ohne dazu (wie in den meisten anderen Sprachen notwendig) die Syntax ändern zu müssen.","<answer> Die Klasse ""Interval"" repräsentiert endliche arithmetische Folgen von Zahlen, bei denen alle Zahlen denselben Abstand voneinander haben. Instanzen dieser Klasse werden verwendet, um solche Intervalle zu definieren, wobei die Spezifikation eines Intervalls den Anfangs- und Endwert sowie die Schrittweite umfasst, die sogar negativ sein kann. <answer> <question> Was ist die Klasse ""Interval"" und wofür werden ihre Instanzen verwendet? <question>"
"Nicht alle Collections dienen der Umsetzung von :n-Beziehungen. Ein gutes Beispiel ist die Klasse ""Interval"".
Bei Instanzen der Klasse ""Interval"" handelt es sich um endliche arithmetische Folgen, also um beschränkte Folgen von Zahlen, die alle denselben Abstand zueinander haben. Die Elemente einer solchen Collection müssen deswegen nicht gespeichert, sondern können berechnet werden. Die Spezifikation eines Intervalls umfasst seinen Anfangs- und seinen Endwert sowie die Schrittweite, die auch negativ sein darf.
""5 to: 1 by: -2"" erzeugt ein Intervall, das die Zahlen 5, 3 und 1 enthält. Intervalle dienen vor allem dem Zweck, sog. ""For""-Schleifen zu emulieren.
Um der geschätzten Programmiererin auch noch die Klammern zu ersparen, wurde gleich noch die Methode ""to:by:do:"" hinzugefügt.
(Manche beachten, dass hier der Iterator in der Klasse ""Number"" und nicht in einer Collection wie ""Interval"" definiert wurde.) Wie man sieht, ist es in SMALLTALK möglich, ohne großen Aufwand neue Ausdrucksformen hinzuzufügen, ohne dazu (wie in den meisten anderen Sprachen notwendig) die Syntax ändern zu müssen.","<answer> Ein Intervall in Smalltalk kann mithilfe der Methode to:by: definiert werden. Zum Beispiel erzeugt 5 to: 1 by: -2 ein Intervall, das die Zahlen 5, 3 und 1 enthält. <answer> <question> Wie kann man ein Intervall in Smalltalk definieren, und welche Methode wird verwendet? <question>"
"Nicht alle Collections dienen der Umsetzung von :n-Beziehungen. Ein gutes Beispiel ist die Klasse ""Interval"".
Bei Instanzen der Klasse ""Interval"" handelt es sich um endliche arithmetische Folgen, also um beschränkte Folgen von Zahlen, die alle denselben Abstand zueinander haben. Die Elemente einer solchen Collection müssen deswegen nicht gespeichert, sondern können berechnet werden. Die Spezifikation eines Intervalls umfasst seinen Anfangs- und seinen Endwert sowie die Schrittweite, die auch negativ sein darf.
""5 to: 1 by: -2"" erzeugt ein Intervall, das die Zahlen 5, 3 und 1 enthält. Intervalle dienen vor allem dem Zweck, sog. ""For""-Schleifen zu emulieren.
Um der geschätzten Programmiererin auch noch die Klammern zu ersparen, wurde gleich noch die Methode ""to:by:do:"" hinzugefügt.
(Manche beachten, dass hier der Iterator in der Klasse ""Number"" und nicht in einer Collection wie ""Interval"" definiert wurde.) Wie man sieht, ist es in SMALLTALK möglich, ohne großen Aufwand neue Ausdrucksformen hinzuzufügen, ohne dazu (wie in den meisten anderen Sprachen notwendig) die Syntax ändern zu müssen.","<answer> Intervalle in Smalltalk dienen hauptsächlich dem Zweck, sogenannte ""For""-Schleifen zu emulieren, wie sie im Abschnitt 4.6.3 in Kurseinheit 1 beschrieben sind. <answer> <question> Wozu dienen Intervalle hauptsächlich in Smalltalk? <question>"
"Nicht alle Collections dienen der Umsetzung von :n-Beziehungen. Ein gutes Beispiel ist die Klasse ""Interval"".
Bei Instanzen der Klasse ""Interval"" handelt es sich um endliche arithmetische Folgen, also um beschränkte Folgen von Zahlen, die alle denselben Abstand zueinander haben. Die Elemente einer solchen Collection müssen deswegen nicht gespeichert, sondern können berechnet werden. Die Spezifikation eines Intervalls umfasst seinen Anfangs- und seinen Endwert sowie die Schrittweite, die auch negativ sein darf.
""5 to: 1 by: -2"" erzeugt ein Intervall, das die Zahlen 5, 3 und 1 enthält. Intervalle dienen vor allem dem Zweck, sog. ""For""-Schleifen zu emulieren.
Um der geschätzten Programmiererin auch noch die Klammern zu ersparen, wurde gleich noch die Methode ""to:by:do:"" hinzugefügt.
(Manche beachten, dass hier der Iterator in der Klasse ""Number"" und nicht in einer Collection wie ""Interval"" definiert wurde.) Wie man sieht, ist es in SMALLTALK möglich, ohne großen Aufwand neue Ausdrucksformen hinzuzufügen, ohne dazu (wie in den meisten anderen Sprachen notwendig) die Syntax ändern zu müssen.","<answer> In einer ""For""-Schleife verwendet man ein Intervall, um durch die darin enthaltenen Werte zu iterieren. Zum Beispiel bewirkt der Ausdruck 5 to: 1 by: -2 do: [:i | ""Code hier""], dass dem Laufparameter ""i"" nacheinander die Werte 5, 3 und 1 zugewiesen werden. <answer> <question> Wie funktioniert die Verwendung eines Intervalls in einer ""For""-Schleife? <question>"
"Nicht alle Collections dienen der Umsetzung von :n-Beziehungen. Ein gutes Beispiel ist die Klasse ""Interval"".
Bei Instanzen der Klasse ""Interval"" handelt es sich um endliche arithmetische Folgen, also um beschränkte Folgen von Zahlen, die alle denselben Abstand zueinander haben. Die Elemente einer solchen Collection müssen deswegen nicht gespeichert, sondern können berechnet werden. Die Spezifikation eines Intervalls umfasst seinen Anfangs- und seinen Endwert sowie die Schrittweite, die auch negativ sein darf.
""5 to: 1 by: -2"" erzeugt ein Intervall, das die Zahlen 5, 3 und 1 enthält. Intervalle dienen vor allem dem Zweck, sog. ""For""-Schleifen zu emulieren.
Um der geschätzten Programmiererin auch noch die Klammern zu ersparen, wurde gleich noch die Methode ""to:by:do:"" hinzugefügt.
(Manche beachten, dass hier der Iterator in der Klasse ""Number"" und nicht in einer Collection wie ""Interval"" definiert wurde.) Wie man sieht, ist es in SMALLTALK möglich, ohne großen Aufwand neue Ausdrucksformen hinzuzufügen, ohne dazu (wie in den meisten anderen Sprachen notwendig) die Syntax ändern zu müssen.","<answer> Ja, in der Klasse ""Number"" gibt es die Methode ""to:by:"", die ein entsprechendes Intervall zurückliefert. Dadurch kann man eine ""For""-Schleife in einer kompakteren Form schreiben, z. B. 5 to: 1 by: -2. <answer> <question> Gibt es eine Methode in der Klasse ""Number,"" die die Verwendung von Intervallen noch komfortabler macht? <question>"
"Nicht alle Collections dienen der Umsetzung von :n-Beziehungen. Ein gutes Beispiel ist die Klasse ""Interval"".
Bei Instanzen der Klasse ""Interval"" handelt es sich um endliche arithmetische Folgen, also um beschränkte Folgen von Zahlen, die alle denselben Abstand zueinander haben. Die Elemente einer solchen Collection müssen deswegen nicht gespeichert, sondern können berechnet werden. Die Spezifikation eines Intervalls umfasst seinen Anfangs- und seinen Endwert sowie die Schrittweite, die auch negativ sein darf.
""5 to: 1 by: -2"" erzeugt ein Intervall, das die Zahlen 5, 3 und 1 enthält. Intervalle dienen vor allem dem Zweck, sog. ""For""-Schleifen zu emulieren.
Um der geschätzten Programmiererin auch noch die Klammern zu ersparen, wurde gleich noch die Methode ""to:by:do:"" hinzugefügt.
(Manche beachten, dass hier der Iterator in der Klasse ""Number"" und nicht in einer Collection wie ""Interval"" definiert wurde.) Wie man sieht, ist es in SMALLTALK möglich, ohne großen Aufwand neue Ausdrucksformen hinzuzufügen, ohne dazu (wie in den meisten anderen Sprachen notwendig) die Syntax ändern zu müssen.","<answer> Die Methode ""to:by:do:"" erlaubt die kompakte Darstellung einer ""For""-Schleife und erspart die Verwendung von Klammern. Sie ermöglicht es, den Schleifenkörper in einem übersichtlichen Format anzugeben. <answer> <question> Was ist das Besondere an der Methode ""to:by:do:""? <question>"
"Nicht alle Collections dienen der Umsetzung von :n-Beziehungen. Ein gutes Beispiel ist die Klasse ""Interval"".
Bei Instanzen der Klasse ""Interval"" handelt es sich um endliche arithmetische Folgen, also um beschränkte Folgen von Zahlen, die alle denselben Abstand zueinander haben. Die Elemente einer solchen Collection müssen deswegen nicht gespeichert, sondern können berechnet werden. Die Spezifikation eines Intervalls umfasst seinen Anfangs- und seinen Endwert sowie die Schrittweite, die auch negativ sein darf.
""5 to: 1 by: -2"" erzeugt ein Intervall, das die Zahlen 5, 3 und 1 enthält. Intervalle dienen vor allem dem Zweck, sog. ""For""-Schleifen zu emulieren.
Um der geschätzten Programmiererin auch noch die Klammern zu ersparen, wurde gleich noch die Methode ""to:by:do:"" hinzugefügt.
(Manche beachten, dass hier der Iterator in der Klasse ""Number"" und nicht in einer Collection wie ""Interval"" definiert wurde.) Wie man sieht, ist es in SMALLTALK möglich, ohne großen Aufwand neue Ausdrucksformen hinzuzufügen, ohne dazu (wie in den meisten anderen Sprachen notwendig) die Syntax ändern zu müssen.","<answer> Der Iterator für Intervalle ist in der Klasse ""Number"" definiert und nicht in einer Collection-Klasse wie ""Interval."" <answer> <question> Wo ist der Iterator für Intervalle definiert? <question>"
"In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert ""nil"". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet.
Es ist jedoch nicht immer erforderlich, alle Instanzen einer Klasse auf die gleiche Weise zu initialisieren. Daher ist es möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu definieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die Klasse ""Time"" sind unten gegeben, wobei beide die Klassenmethode ""seconds:"" auf ""Time"" aufrufen (repräsentiert durch ""self""), die wiederum mit ""basicNew"" eine Instanz von ""Time"" erzeugt und anschließend initialisiert.
Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar sind, kann auch eine Klassenmethode wie ""new"" nicht auf sie zugreifen. Die Initialisierung muss daher von Instanzmethoden wie ""ticks:"" durchgeführt werden, die jedoch nicht ausschließlich der Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen werden können. Dies kann problematisch sein, wenn Instanzvariablen initialisiert werden müssen, deren Existenz nach außen verborgen werden soll (siehe Abschnitt 4.3.4). Aus diesem Grund sehen ""new"" und ""new:"" standardmäßig den Aufruf der Methode ""initialize"" vor (siehe Zeilen 307 und 309 oben), in der alle Initialisierungen vorgenommen werden können, ohne dass etwas über den Aufbau der Instanzen nach außen verraten würde.
In anderen Sprachen wie C++, JAVA oder C# sind Konstruktoren daher auch keine Klassenmethoden, sondern haben eine Art Zwitterstatus: Sie werden auf einer Klasse aufgerufen, aber sie werden wie Instanzmethoden auf der neuen Instanz ausgeführt und können somit auf die Instanzvariablen der neu erzeugten Instanz zugreifen. Beachten Sie jedoch, dass die Methode ""ticks:"" keine Informationen über die Implementierung der Instanzvariablen der Klasse ""Time"" preisgibt.
Alternativ zur obigen Konstruktion kann die Initialisierung von Instanzvariablen auch zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt werden. Dies wird als ""Lazy initialization"" bezeichnet, da die Initialisierung solange wie möglich verschoben wird. Bei der Verwendung von Lazy initialization muss jedoch vor jedem lesebasierten Zugriff auf die (faul initialisierte) Instanzvariable überprüft werden, ob ihr Wert immer noch ""nil"" ist. Wenn dies der Fall ist, muss er durch den gewünschten Anfangswert ersetzt werden, der normalerweise in der Standardinitialisierungsmethode zu finden wäre. Um das Hinzufügen von Abfragen bei jedem lesebasierten Zugriff auf die Variable im Programm zu vermeiden, empfiehlt es sich, bei der Verwendung von Lazy initialization alle Zugriffe auf Instanzvariablen, einschließlich interner Klassenzugriffe, über entsprechende Getter-Methoden durchzuführen. Diese Getter-Methoden prüfen den Inhalt der Variable, bevor sie ihn zurückgeben, und setzen ihn gegebenenfalls. Die Lazy initialization erfordert zusätzlichen Code, der bei einer Standardinitialisierung nicht erforderlich wäre. Das laufende Programm spart jedoch den Preis der Initialisierung, wenn diese nie notwendig wird, d.h., wenn der Wert der zu initialisierenden Variable im Programmablauf nie oder erst nach einer anderen Zuweisung abgefragt wird. Lazy initialization lohnt sich daher immer dann, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Ein weiterer Vorteil der Lazy initialization besteht darin, dass die Initialisierung nie vergessen werden kann. Dies ist insbesondere dann wertvoll, wenn die Initialisierung nicht wie oben beschrieben vom Konstruktor selbst, sondern von einer separaten Methode durchgeführt wird und die Benutzer der entsprechenden Klasse möglicherweise nicht klar ist, dass sie nach dem Konstruktor auch noch die Initialisierungsmethode aufrufen müssen. Konstruktoren, die wie in Zeilen 307 und 309 oben implementiert wurden, versuchen dies zu verhindern, indem sie die Initialisierungsmethode selbst aufrufen. Manchmal kann der Konstruktor jedoch nicht einfach geändert werden (siehe Abschnitt 10.3), und es wird nicht verhindert, dass ""basicNew"" direkt und ohne ""initialize"" aufgerufen wird.","<answer> In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse erstellen und zurückliefern. Ihre Aufgabe ist es, neue Objekte zu erzeugen. <answer> <question> Was sind Konstruktoren in SMALLTALK und was ist ihre Aufgabe? <question>"
"In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert ""nil"". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet.
Es ist jedoch nicht immer erforderlich, alle Instanzen einer Klasse auf die gleiche Weise zu initialisieren. Daher ist es möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu definieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die Klasse ""Time"" sind unten gegeben, wobei beide die Klassenmethode ""seconds:"" auf ""Time"" aufrufen (repräsentiert durch ""self""), die wiederum mit ""basicNew"" eine Instanz von ""Time"" erzeugt und anschließend initialisiert.
Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar sind, kann auch eine Klassenmethode wie ""new"" nicht auf sie zugreifen. Die Initialisierung muss daher von Instanzmethoden wie ""ticks:"" durchgeführt werden, die jedoch nicht ausschließlich der Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen werden können. Dies kann problematisch sein, wenn Instanzvariablen initialisiert werden müssen, deren Existenz nach außen verborgen werden soll (siehe Abschnitt 4.3.4). Aus diesem Grund sehen ""new"" und ""new:"" standardmäßig den Aufruf der Methode ""initialize"" vor (siehe Zeilen 307 und 309 oben), in der alle Initialisierungen vorgenommen werden können, ohne dass etwas über den Aufbau der Instanzen nach außen verraten würde.
In anderen Sprachen wie C++, JAVA oder C# sind Konstruktoren daher auch keine Klassenmethoden, sondern haben eine Art Zwitterstatus: Sie werden auf einer Klasse aufgerufen, aber sie werden wie Instanzmethoden auf der neuen Instanz ausgeführt und können somit auf die Instanzvariablen der neu erzeugten Instanz zugreifen. Beachten Sie jedoch, dass die Methode ""ticks:"" keine Informationen über die Implementierung der Instanzvariablen der Klasse ""Time"" preisgibt.
Alternativ zur obigen Konstruktion kann die Initialisierung von Instanzvariablen auch zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt werden. Dies wird als ""Lazy initialization"" bezeichnet, da die Initialisierung solange wie möglich verschoben wird. Bei der Verwendung von Lazy initialization muss jedoch vor jedem lesebasierten Zugriff auf die (faul initialisierte) Instanzvariable überprüft werden, ob ihr Wert immer noch ""nil"" ist. Wenn dies der Fall ist, muss er durch den gewünschten Anfangswert ersetzt werden, der normalerweise in der Standardinitialisierungsmethode zu finden wäre. Um das Hinzufügen von Abfragen bei jedem lesebasierten Zugriff auf die Variable im Programm zu vermeiden, empfiehlt es sich, bei der Verwendung von Lazy initialization alle Zugriffe auf Instanzvariablen, einschließlich interner Klassenzugriffe, über entsprechende Getter-Methoden durchzuführen. Diese Getter-Methoden prüfen den Inhalt der Variable, bevor sie ihn zurückgeben, und setzen ihn gegebenenfalls. Die Lazy initialization erfordert zusätzlichen Code, der bei einer Standardinitialisierung nicht erforderlich wäre. Das laufende Programm spart jedoch den Preis der Initialisierung, wenn diese nie notwendig wird, d.h., wenn der Wert der zu initialisierenden Variable im Programmablauf nie oder erst nach einer anderen Zuweisung abgefragt wird. Lazy initialization lohnt sich daher immer dann, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Ein weiterer Vorteil der Lazy initialization besteht darin, dass die Initialisierung nie vergessen werden kann. Dies ist insbesondere dann wertvoll, wenn die Initialisierung nicht wie oben beschrieben vom Konstruktor selbst, sondern von einer separaten Methode durchgeführt wird und die Benutzer der entsprechenden Klasse möglicherweise nicht klar ist, dass sie nach dem Konstruktor auch noch die Initialisierungsmethode aufrufen müssen. Konstruktoren, die wie in Zeilen 307 und 309 oben implementiert wurden, versuchen dies zu verhindern, indem sie die Initialisierungsmethode selbst aufrufen. Manchmal kann der Konstruktor jedoch nicht einfach geändert werden (siehe Abschnitt 10.3), und es wird nicht verhindert, dass ""basicNew"" direkt und ohne ""initialize"" aufgerufen wird.","<answer> Nach der Erzeugung einer Instanz in SMALLTALK haben alle Instanzvariablen standardmäßig den Wert ""nil"". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden, normalerweise durch Aufrufen der Methode ""initialize"". <answer> <question> Wie werden Instanzvariablen in SMALLTALK standardmäßig initialisiert, nachdem eine Instanz erzeugt wurde? <question>"
"In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert ""nil"". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet.
Es ist jedoch nicht immer erforderlich, alle Instanzen einer Klasse auf die gleiche Weise zu initialisieren. Daher ist es möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu definieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die Klasse ""Time"" sind unten gegeben, wobei beide die Klassenmethode ""seconds:"" auf ""Time"" aufrufen (repräsentiert durch ""self""), die wiederum mit ""basicNew"" eine Instanz von ""Time"" erzeugt und anschließend initialisiert.
Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar sind, kann auch eine Klassenmethode wie ""new"" nicht auf sie zugreifen. Die Initialisierung muss daher von Instanzmethoden wie ""ticks:"" durchgeführt werden, die jedoch nicht ausschließlich der Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen werden können. Dies kann problematisch sein, wenn Instanzvariablen initialisiert werden müssen, deren Existenz nach außen verborgen werden soll (siehe Abschnitt 4.3.4). Aus diesem Grund sehen ""new"" und ""new:"" standardmäßig den Aufruf der Methode ""initialize"" vor (siehe Zeilen 307 und 309 oben), in der alle Initialisierungen vorgenommen werden können, ohne dass etwas über den Aufbau der Instanzen nach außen verraten würde.
In anderen Sprachen wie C++, JAVA oder C# sind Konstruktoren daher auch keine Klassenmethoden, sondern haben eine Art Zwitterstatus: Sie werden auf einer Klasse aufgerufen, aber sie werden wie Instanzmethoden auf der neuen Instanz ausgeführt und können somit auf die Instanzvariablen der neu erzeugten Instanz zugreifen. Beachten Sie jedoch, dass die Methode ""ticks:"" keine Informationen über die Implementierung der Instanzvariablen der Klasse ""Time"" preisgibt.
Alternativ zur obigen Konstruktion kann die Initialisierung von Instanzvariablen auch zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt werden. Dies wird als ""Lazy initialization"" bezeichnet, da die Initialisierung solange wie möglich verschoben wird. Bei der Verwendung von Lazy initialization muss jedoch vor jedem lesebasierten Zugriff auf die (faul initialisierte) Instanzvariable überprüft werden, ob ihr Wert immer noch ""nil"" ist. Wenn dies der Fall ist, muss er durch den gewünschten Anfangswert ersetzt werden, der normalerweise in der Standardinitialisierungsmethode zu finden wäre. Um das Hinzufügen von Abfragen bei jedem lesebasierten Zugriff auf die Variable im Programm zu vermeiden, empfiehlt es sich, bei der Verwendung von Lazy initialization alle Zugriffe auf Instanzvariablen, einschließlich interner Klassenzugriffe, über entsprechende Getter-Methoden durchzuführen. Diese Getter-Methoden prüfen den Inhalt der Variable, bevor sie ihn zurückgeben, und setzen ihn gegebenenfalls. Die Lazy initialization erfordert zusätzlichen Code, der bei einer Standardinitialisierung nicht erforderlich wäre. Das laufende Programm spart jedoch den Preis der Initialisierung, wenn diese nie notwendig wird, d.h., wenn der Wert der zu initialisierenden Variable im Programmablauf nie oder erst nach einer anderen Zuweisung abgefragt wird. Lazy initialization lohnt sich daher immer dann, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Ein weiterer Vorteil der Lazy initialization besteht darin, dass die Initialisierung nie vergessen werden kann. Dies ist insbesondere dann wertvoll, wenn die Initialisierung nicht wie oben beschrieben vom Konstruktor selbst, sondern von einer separaten Methode durchgeführt wird und die Benutzer der entsprechenden Klasse möglicherweise nicht klar ist, dass sie nach dem Konstruktor auch noch die Initialisierungsmethode aufrufen müssen. Konstruktoren, die wie in Zeilen 307 und 309 oben implementiert wurden, versuchen dies zu verhindern, indem sie die Initialisierungsmethode selbst aufrufen. Manchmal kann der Konstruktor jedoch nicht einfach geändert werden (siehe Abschnitt 10.3), und es wird nicht verhindert, dass ""basicNew"" direkt und ohne ""initialize"" aufgerufen wird.","<answer> Es ist möglich, mehrere alternative Konstruktoren für eine Klasse in SMALLTALK zu definieren, da nicht immer alle Instanzen einer Klasse auf die gleiche Weise initialisiert werden müssen. Dies ermöglicht es, verschiedene Initialisierungsmethoden für verschiedene Anwendungsfälle anzubieten. <answer> <question> Warum ist es möglich, in SMALLTALK mehrere alternative Konstruktoren (Klassenmethoden) für eine Klasse zu definieren? <question>"
"In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert ""nil"". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet.
Es ist jedoch nicht immer erforderlich, alle Instanzen einer Klasse auf die gleiche Weise zu initialisieren. Daher ist es möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu definieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die Klasse ""Time"" sind unten gegeben, wobei beide die Klassenmethode ""seconds:"" auf ""Time"" aufrufen (repräsentiert durch ""self""), die wiederum mit ""basicNew"" eine Instanz von ""Time"" erzeugt und anschließend initialisiert.
Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar sind, kann auch eine Klassenmethode wie ""new"" nicht auf sie zugreifen. Die Initialisierung muss daher von Instanzmethoden wie ""ticks:"" durchgeführt werden, die jedoch nicht ausschließlich der Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen werden können. Dies kann problematisch sein, wenn Instanzvariablen initialisiert werden müssen, deren Existenz nach außen verborgen werden soll (siehe Abschnitt 4.3.4). Aus diesem Grund sehen ""new"" und ""new:"" standardmäßig den Aufruf der Methode ""initialize"" vor (siehe Zeilen 307 und 309 oben), in der alle Initialisierungen vorgenommen werden können, ohne dass etwas über den Aufbau der Instanzen nach außen verraten würde.
In anderen Sprachen wie C++, JAVA oder C# sind Konstruktoren daher auch keine Klassenmethoden, sondern haben eine Art Zwitterstatus: Sie werden auf einer Klasse aufgerufen, aber sie werden wie Instanzmethoden auf der neuen Instanz ausgeführt und können somit auf die Instanzvariablen der neu erzeugten Instanz zugreifen. Beachten Sie jedoch, dass die Methode ""ticks:"" keine Informationen über die Implementierung der Instanzvariablen der Klasse ""Time"" preisgibt.
Alternativ zur obigen Konstruktion kann die Initialisierung von Instanzvariablen auch zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt werden. Dies wird als ""Lazy initialization"" bezeichnet, da die Initialisierung solange wie möglich verschoben wird. Bei der Verwendung von Lazy initialization muss jedoch vor jedem lesebasierten Zugriff auf die (faul initialisierte) Instanzvariable überprüft werden, ob ihr Wert immer noch ""nil"" ist. Wenn dies der Fall ist, muss er durch den gewünschten Anfangswert ersetzt werden, der normalerweise in der Standardinitialisierungsmethode zu finden wäre. Um das Hinzufügen von Abfragen bei jedem lesebasierten Zugriff auf die Variable im Programm zu vermeiden, empfiehlt es sich, bei der Verwendung von Lazy initialization alle Zugriffe auf Instanzvariablen, einschließlich interner Klassenzugriffe, über entsprechende Getter-Methoden durchzuführen. Diese Getter-Methoden prüfen den Inhalt der Variable, bevor sie ihn zurückgeben, und setzen ihn gegebenenfalls. Die Lazy initialization erfordert zusätzlichen Code, der bei einer Standardinitialisierung nicht erforderlich wäre. Das laufende Programm spart jedoch den Preis der Initialisierung, wenn diese nie notwendig wird, d.h., wenn der Wert der zu initialisierenden Variable im Programmablauf nie oder erst nach einer anderen Zuweisung abgefragt wird. Lazy initialization lohnt sich daher immer dann, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Ein weiterer Vorteil der Lazy initialization besteht darin, dass die Initialisierung nie vergessen werden kann. Dies ist insbesondere dann wertvoll, wenn die Initialisierung nicht wie oben beschrieben vom Konstruktor selbst, sondern von einer separaten Methode durchgeführt wird und die Benutzer der entsprechenden Klasse möglicherweise nicht klar ist, dass sie nach dem Konstruktor auch noch die Initialisierungsmethode aufrufen müssen. Konstruktoren, die wie in Zeilen 307 und 309 oben implementiert wurden, versuchen dies zu verhindern, indem sie die Initialisierungsmethode selbst aufrufen. Manchmal kann der Konstruktor jedoch nicht einfach geändert werden (siehe Abschnitt 10.3), und es wird nicht verhindert, dass ""basicNew"" direkt und ohne ""initialize"" aufgerufen wird.","<answer> In SMALLTALK wird die Methode ""initialize"" standardmäßig von den Konstruktoren ""new"" und ""new:"" aufgerufen, um die Initialisierung der Instanzvariablen vorzunehmen. Dies erlaubt es, alle Initialisierungen in einer zentralen Methode durchzuführen, ohne dass etwas über den Aufbau der Instanzen nach außen verraten wird. <answer> <question> Warum wird in SMALLTALK die Methode ""initialize"" standardmäßig von den Konstruktoren ""new"" und ""new:"" aufgerufen? <question>"
"In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert ""nil"". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet.
Es ist jedoch nicht immer erforderlich, alle Instanzen einer Klasse auf die gleiche Weise zu initialisieren. Daher ist es möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu definieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die Klasse ""Time"" sind unten gegeben, wobei beide die Klassenmethode ""seconds:"" auf ""Time"" aufrufen (repräsentiert durch ""self""), die wiederum mit ""basicNew"" eine Instanz von ""Time"" erzeugt und anschließend initialisiert.
Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar sind, kann auch eine Klassenmethode wie ""new"" nicht auf sie zugreifen. Die Initialisierung muss daher von Instanzmethoden wie ""ticks:"" durchgeführt werden, die jedoch nicht ausschließlich der Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen werden können. Dies kann problematisch sein, wenn Instanzvariablen initialisiert werden müssen, deren Existenz nach außen verborgen werden soll (siehe Abschnitt 4.3.4). Aus diesem Grund sehen ""new"" und ""new:"" standardmäßig den Aufruf der Methode ""initialize"" vor (siehe Zeilen 307 und 309 oben), in der alle Initialisierungen vorgenommen werden können, ohne dass etwas über den Aufbau der Instanzen nach außen verraten würde.
In anderen Sprachen wie C++, JAVA oder C# sind Konstruktoren daher auch keine Klassenmethoden, sondern haben eine Art Zwitterstatus: Sie werden auf einer Klasse aufgerufen, aber sie werden wie Instanzmethoden auf der neuen Instanz ausgeführt und können somit auf die Instanzvariablen der neu erzeugten Instanz zugreifen. Beachten Sie jedoch, dass die Methode ""ticks:"" keine Informationen über die Implementierung der Instanzvariablen der Klasse ""Time"" preisgibt.
Alternativ zur obigen Konstruktion kann die Initialisierung von Instanzvariablen auch zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt werden. Dies wird als ""Lazy initialization"" bezeichnet, da die Initialisierung solange wie möglich verschoben wird. Bei der Verwendung von Lazy initialization muss jedoch vor jedem lesebasierten Zugriff auf die (faul initialisierte) Instanzvariable überprüft werden, ob ihr Wert immer noch ""nil"" ist. Wenn dies der Fall ist, muss er durch den gewünschten Anfangswert ersetzt werden, der normalerweise in der Standardinitialisierungsmethode zu finden wäre. Um das Hinzufügen von Abfragen bei jedem lesebasierten Zugriff auf die Variable im Programm zu vermeiden, empfiehlt es sich, bei der Verwendung von Lazy initialization alle Zugriffe auf Instanzvariablen, einschließlich interner Klassenzugriffe, über entsprechende Getter-Methoden durchzuführen. Diese Getter-Methoden prüfen den Inhalt der Variable, bevor sie ihn zurückgeben, und setzen ihn gegebenenfalls. Die Lazy initialization erfordert zusätzlichen Code, der bei einer Standardinitialisierung nicht erforderlich wäre. Das laufende Programm spart jedoch den Preis der Initialisierung, wenn diese nie notwendig wird, d.h., wenn der Wert der zu initialisierenden Variable im Programmablauf nie oder erst nach einer anderen Zuweisung abgefragt wird. Lazy initialization lohnt sich daher immer dann, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Ein weiterer Vorteil der Lazy initialization besteht darin, dass die Initialisierung nie vergessen werden kann. Dies ist insbesondere dann wertvoll, wenn die Initialisierung nicht wie oben beschrieben vom Konstruktor selbst, sondern von einer separaten Methode durchgeführt wird und die Benutzer der entsprechenden Klasse möglicherweise nicht klar ist, dass sie nach dem Konstruktor auch noch die Initialisierungsmethode aufrufen müssen. Konstruktoren, die wie in Zeilen 307 und 309 oben implementiert wurden, versuchen dies zu verhindern, indem sie die Initialisierungsmethode selbst aufrufen. Manchmal kann der Konstruktor jedoch nicht einfach geändert werden (siehe Abschnitt 10.3), und es wird nicht verhindert, dass ""basicNew"" direkt und ohne ""initialize"" aufgerufen wird.","<answer> ""Lazy initialization"" ist eine Technik, bei der die Initialisierung von Instanzvariablen zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt wird. Dies kann sinnvoll sein, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Die Initialisierung wird verschoben, um den Preis der Initialisierung im Programmablauf zu sparen, wenn sie nie notwendig wird. <answer> <question> Was ist ""Lazy initialization"" und wann kann es sinnvoll sein? <question>"
"Das Programmiermodell von C++ ist ein klassisches: Programme werden als eine Menge von Quellcode-Dateien geschrieben, die auf einer Zielmaschine direkt in ausführbaren Maschinencode übersetzt werden. Die getrennte Übersetzung von Programmteilen ist dank sogenannter Header-Dateien möglich, die die Schnittstellen der Teile enthalten. Getrennt übersetzte Programmteile müssen vor der Ausführung verknüpft werden; das dynamische (Nach-)Laden von Funktionen ist möglich, muss aber explizit (programmgesteuert) erfolgen.
C++ ist als objektorientierter Nachfolger von C konzipiert und ermöglicht so einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung. Dies ist besonders nützlich für die Migration von Altsystemen zur Objektorientierung. Infolgedessen zielt C++ auf die gleiche Klasse von Anwendungen wie C ab: maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen. Extreme Speicher- und Recheneffizienz sind dabei oft oberste Kriterien.","<answer> Das Programmiermodell von C++ ist ein klassisches Modell, bei dem Programme als eine Menge von Quellcode-Dateien geschrieben werden, die auf einer Zielmaschine direkt in ausführbaren Maschinencode übersetzt werden. <answer> <question> Welches Programmiermodell wird in C++ verwendet? <question>"
"Das Programmiermodell von C++ ist ein klassisches: Programme werden als eine Menge von Quellcode-Dateien geschrieben, die auf einer Zielmaschine direkt in ausführbaren Maschinencode übersetzt werden. Die getrennte Übersetzung von Programmteilen ist dank sogenannter Header-Dateien möglich, die die Schnittstellen der Teile enthalten. Getrennt übersetzte Programmteile müssen vor der Ausführung verknüpft werden; das dynamische (Nach-)Laden von Funktionen ist möglich, muss aber explizit (programmgesteuert) erfolgen.
C++ ist als objektorientierter Nachfolger von C konzipiert und ermöglicht so einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung. Dies ist besonders nützlich für die Migration von Altsystemen zur Objektorientierung. Infolgedessen zielt C++ auf die gleiche Klasse von Anwendungen wie C ab: maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen. Extreme Speicher- und Recheneffizienz sind dabei oft oberste Kriterien.","<answer> C++ ermöglicht die getrennte Übersetzung von Programmteilen mithilfe von Header-Dateien, die die Schnittstellen der Teile enthalten. <answer> <question> Wie ermöglicht C++ die getrennte Übersetzung von Programmteilen? <question>"
"Das Programmiermodell von C++ ist ein klassisches: Programme werden als eine Menge von Quellcode-Dateien geschrieben, die auf einer Zielmaschine direkt in ausführbaren Maschinencode übersetzt werden. Die getrennte Übersetzung von Programmteilen ist dank sogenannter Header-Dateien möglich, die die Schnittstellen der Teile enthalten. Getrennt übersetzte Programmteile müssen vor der Ausführung verknüpft werden; das dynamische (Nach-)Laden von Funktionen ist möglich, muss aber explizit (programmgesteuert) erfolgen.
C++ ist als objektorientierter Nachfolger von C konzipiert und ermöglicht so einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung. Dies ist besonders nützlich für die Migration von Altsystemen zur Objektorientierung. Infolgedessen zielt C++ auf die gleiche Klasse von Anwendungen wie C ab: maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen. Extreme Speicher- und Recheneffizienz sind dabei oft oberste Kriterien.","<answer> C++ zielt auf die gleiche Klasse von Anwendungen wie C ab, insbesondere maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen, wobei extreme Speicher- und Recheneffizienz oft oberste Kriterien sind. <answer> <question> Was ist das Ziel von C++ in Bezug auf die Art von Anwendungen, die es unterstützt? <question>"
"Wenn in dieser Kurseinheit bislang ausschließlich von Typen die Rede war und Klassen dabei ignoriert wurden, so hat das gute Gründe: Während eine Klasse die Implementierung ihrer Objekte festlegt, ist eine Typdefinition vollkommen frei von Implementierungsaspekten. Zwar können auch abstrakte Klassen (Kurseinheit 2, Abschnitt 10.3) ausschließlich aus Methodendeklarationen bestehen, also ohne jeden Implementierungsanteil, aber auch ihr Zweck ist in der Regel, zumindest eine partielle Implementierung vorzugeben, die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können. Schließlich drückt die Klassenhierarchie ja eine „genetische“ Verwandtschaft aus (s. Abschnitt 10.1 und Kapitel 11). Eine Typprüfung soll aber ohne Ansehen der Implementierung stattfinden; sie baut daher auf abstrakte Spezifikationen, eben auf Typen.
Es sind also Typen abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. Im Gegensatz dazu sind Klassen Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Da Objekte aber auch den Wertebereich von Typen ausmachen, stellt sich natürlich die Frage, welcher Art der Zusammenhang zwischen Typen und Klassen ist.
Es fällt zunächst auf, dass bestimmte Elemente einer Klassendefinition auch in einer Typdefinition auftauchen. Im Einzelnen sind dies: ein (eindeutiger) Name, ein zweiter Name, von dessen dazugehöriger Definition abgeleitet wird sowie eine Menge von Methodennamen, jeweils mit einer Anzahl formaler Parameter.
Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in JAVA oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).
Nun dient ja ein Typsystem in der objektorientierten Programmierung vor allem der Sicherstellung des Umstands, dass alle von einem Objekt aufgrund des deklarierten Typs der Variablen, die es benennt, erwarteten Eigenschaften (Methoden) bei diesem Objekt auch vorhanden sind. Dies ist aber immer dann der Fall, wenn sich die Elemente der Typdefinition in der Klassendefinition des Objekts wiederfinden, die Klassendefinition also mit der Typdefinition gewissermaßen strukturell konform ist, so dass die Zuweisung einer Instanz der Klasse an eine Variable des Typs die Anforderungen der Zuweisungskompatibilität erfüllt. Um einen Compiler diese Zuweisungskompatibilität auf einfachere Weise als die Prüfung der Strukturkonformität, die ja eine rekursive Expansion der Typdefinitionen erfordert, feststellen zu lassen, gibt es zwei Möglichkeiten (bei beiden handelt es sich gewissermaßen um Varianten einer Namenskonformität): Jede Klasse sagt explizit, mit welchen Typen sie konform ist, oder: Jede Klasse spezifiziert implizit selbst einen Typ.
Im ersten Fall müsste der Compiler noch prüfen, ob eine Klasse tatsächlich auch über alle Eigenschaften der von ihr genannten Typen verfügt; im zweiten Fall ist das automatisch der Fall, da der Typ ja gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den allermeisten typisierten, objektorientierten Programmiersprachen bevorzugt, doch auch die erste kommt in populären Sprachen vor: So kann beispielsweise in JAVA und C# jede Klasse angeben, mit Variablen welcher Interface-Typen ihre Instanzen zuweisungskompatibel sein sollen (s. Kurseinheit 4, Kapitel 40 und Kurseinheit 5, Abschnitt 50.4.2). Auch STRONGTALK stellt beide Möglichkeiten zur Verfügung.","<answer> Typen und Klassen werden getrennt behandelt, da Klassen die Implementierung von Objekten festlegen, während Typdefinitionen frei von Implementierungsaspekten sind. <answer> <question> Warum wurde in dieser Kurseinheit bisher nur über Typen gesprochen und Klassen ignoriert? <question>"
"Wenn in dieser Kurseinheit bislang ausschließlich von Typen die Rede war und Klassen dabei ignoriert wurden, so hat das gute Gründe: Während eine Klasse die Implementierung ihrer Objekte festlegt, ist eine Typdefinition vollkommen frei von Implementierungsaspekten. Zwar können auch abstrakte Klassen (Kurseinheit 2, Abschnitt 10.3) ausschließlich aus Methodendeklarationen bestehen, also ohne jeden Implementierungsanteil, aber auch ihr Zweck ist in der Regel, zumindest eine partielle Implementierung vorzugeben, die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können. Schließlich drückt die Klassenhierarchie ja eine „genetische“ Verwandtschaft aus (s. Abschnitt 10.1 und Kapitel 11). Eine Typprüfung soll aber ohne Ansehen der Implementierung stattfinden; sie baut daher auf abstrakte Spezifikationen, eben auf Typen.
Es sind also Typen abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. Im Gegensatz dazu sind Klassen Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Da Objekte aber auch den Wertebereich von Typen ausmachen, stellt sich natürlich die Frage, welcher Art der Zusammenhang zwischen Typen und Klassen ist.
Es fällt zunächst auf, dass bestimmte Elemente einer Klassendefinition auch in einer Typdefinition auftauchen. Im Einzelnen sind dies: ein (eindeutiger) Name, ein zweiter Name, von dessen dazugehöriger Definition abgeleitet wird sowie eine Menge von Methodennamen, jeweils mit einer Anzahl formaler Parameter.
Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in JAVA oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).
Nun dient ja ein Typsystem in der objektorientierten Programmierung vor allem der Sicherstellung des Umstands, dass alle von einem Objekt aufgrund des deklarierten Typs der Variablen, die es benennt, erwarteten Eigenschaften (Methoden) bei diesem Objekt auch vorhanden sind. Dies ist aber immer dann der Fall, wenn sich die Elemente der Typdefinition in der Klassendefinition des Objekts wiederfinden, die Klassendefinition also mit der Typdefinition gewissermaßen strukturell konform ist, so dass die Zuweisung einer Instanz der Klasse an eine Variable des Typs die Anforderungen der Zuweisungskompatibilität erfüllt. Um einen Compiler diese Zuweisungskompatibilität auf einfachere Weise als die Prüfung der Strukturkonformität, die ja eine rekursive Expansion der Typdefinitionen erfordert, feststellen zu lassen, gibt es zwei Möglichkeiten (bei beiden handelt es sich gewissermaßen um Varianten einer Namenskonformität): Jede Klasse sagt explizit, mit welchen Typen sie konform ist, oder: Jede Klasse spezifiziert implizit selbst einen Typ.
Im ersten Fall müsste der Compiler noch prüfen, ob eine Klasse tatsächlich auch über alle Eigenschaften der von ihr genannten Typen verfügt; im zweiten Fall ist das automatisch der Fall, da der Typ ja gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den allermeisten typisierten, objektorientierten Programmiersprachen bevorzugt, doch auch die erste kommt in populären Sprachen vor: So kann beispielsweise in JAVA und C# jede Klasse angeben, mit Variablen welcher Interface-Typen ihre Instanzen zuweisungskompatibel sein sollen (s. Kurseinheit 4, Kapitel 40 und Kurseinheit 5, Abschnitt 50.4.2). Auch STRONGTALK stellt beide Möglichkeiten zur Verfügung.","<answer> Abstrakte Klassen können ausschließlich aus Methodendeklarationen bestehen und dienen dazu, eine gemeinsame partielle Implementierung für andere Klassen, einschließlich ihrer Subklassen, vorzugeben. <answer> <question> Was ist der Zweck abstrakter Klassen, und warum enthalten sie normalerweise zumindest eine partielle Implementierung? <question>"
"Wenn in dieser Kurseinheit bislang ausschließlich von Typen die Rede war und Klassen dabei ignoriert wurden, so hat das gute Gründe: Während eine Klasse die Implementierung ihrer Objekte festlegt, ist eine Typdefinition vollkommen frei von Implementierungsaspekten. Zwar können auch abstrakte Klassen (Kurseinheit 2, Abschnitt 10.3) ausschließlich aus Methodendeklarationen bestehen, also ohne jeden Implementierungsanteil, aber auch ihr Zweck ist in der Regel, zumindest eine partielle Implementierung vorzugeben, die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können. Schließlich drückt die Klassenhierarchie ja eine „genetische“ Verwandtschaft aus (s. Abschnitt 10.1 und Kapitel 11). Eine Typprüfung soll aber ohne Ansehen der Implementierung stattfinden; sie baut daher auf abstrakte Spezifikationen, eben auf Typen.
Es sind also Typen abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. Im Gegensatz dazu sind Klassen Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Da Objekte aber auch den Wertebereich von Typen ausmachen, stellt sich natürlich die Frage, welcher Art der Zusammenhang zwischen Typen und Klassen ist.
Es fällt zunächst auf, dass bestimmte Elemente einer Klassendefinition auch in einer Typdefinition auftauchen. Im Einzelnen sind dies: ein (eindeutiger) Name, ein zweiter Name, von dessen dazugehöriger Definition abgeleitet wird sowie eine Menge von Methodennamen, jeweils mit einer Anzahl formaler Parameter.
Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in JAVA oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).
Nun dient ja ein Typsystem in der objektorientierten Programmierung vor allem der Sicherstellung des Umstands, dass alle von einem Objekt aufgrund des deklarierten Typs der Variablen, die es benennt, erwarteten Eigenschaften (Methoden) bei diesem Objekt auch vorhanden sind. Dies ist aber immer dann der Fall, wenn sich die Elemente der Typdefinition in der Klassendefinition des Objekts wiederfinden, die Klassendefinition also mit der Typdefinition gewissermaßen strukturell konform ist, so dass die Zuweisung einer Instanz der Klasse an eine Variable des Typs die Anforderungen der Zuweisungskompatibilität erfüllt. Um einen Compiler diese Zuweisungskompatibilität auf einfachere Weise als die Prüfung der Strukturkonformität, die ja eine rekursive Expansion der Typdefinitionen erfordert, feststellen zu lassen, gibt es zwei Möglichkeiten (bei beiden handelt es sich gewissermaßen um Varianten einer Namenskonformität): Jede Klasse sagt explizit, mit welchen Typen sie konform ist, oder: Jede Klasse spezifiziert implizit selbst einen Typ.
Im ersten Fall müsste der Compiler noch prüfen, ob eine Klasse tatsächlich auch über alle Eigenschaften der von ihr genannten Typen verfügt; im zweiten Fall ist das automatisch der Fall, da der Typ ja gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den allermeisten typisierten, objektorientierten Programmiersprachen bevorzugt, doch auch die erste kommt in populären Sprachen vor: So kann beispielsweise in JAVA und C# jede Klasse angeben, mit Variablen welcher Interface-Typen ihre Instanzen zuweisungskompatibel sein sollen (s. Kurseinheit 4, Kapitel 40 und Kurseinheit 5, Abschnitt 50.4.2). Auch STRONGTALK stellt beide Möglichkeiten zur Verfügung.","<answer> Typen sind abstrakte Spezifikationen, die den Wertebereich von Variablen und das Protokoll von Objekten festlegen. Klassen hingegen sind Konstrukte, die Objekte bilden und mit Implementierung versehen. <answer> <question> Was ist der Unterschied zwischen Typen und Klassen, wenn es um die Einschränkung des Wertebereichs von Variablen und die Angabe des Protokolls von Objekten geht? <question>"
"Wenn in dieser Kurseinheit bislang ausschließlich von Typen die Rede war und Klassen dabei ignoriert wurden, so hat das gute Gründe: Während eine Klasse die Implementierung ihrer Objekte festlegt, ist eine Typdefinition vollkommen frei von Implementierungsaspekten. Zwar können auch abstrakte Klassen (Kurseinheit 2, Abschnitt 10.3) ausschließlich aus Methodendeklarationen bestehen, also ohne jeden Implementierungsanteil, aber auch ihr Zweck ist in der Regel, zumindest eine partielle Implementierung vorzugeben, die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können. Schließlich drückt die Klassenhierarchie ja eine „genetische“ Verwandtschaft aus (s. Abschnitt 10.1 und Kapitel 11). Eine Typprüfung soll aber ohne Ansehen der Implementierung stattfinden; sie baut daher auf abstrakte Spezifikationen, eben auf Typen.
Es sind also Typen abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. Im Gegensatz dazu sind Klassen Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Da Objekte aber auch den Wertebereich von Typen ausmachen, stellt sich natürlich die Frage, welcher Art der Zusammenhang zwischen Typen und Klassen ist.
Es fällt zunächst auf, dass bestimmte Elemente einer Klassendefinition auch in einer Typdefinition auftauchen. Im Einzelnen sind dies: ein (eindeutiger) Name, ein zweiter Name, von dessen dazugehöriger Definition abgeleitet wird sowie eine Menge von Methodennamen, jeweils mit einer Anzahl formaler Parameter.
Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in JAVA oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).
Nun dient ja ein Typsystem in der objektorientierten Programmierung vor allem der Sicherstellung des Umstands, dass alle von einem Objekt aufgrund des deklarierten Typs der Variablen, die es benennt, erwarteten Eigenschaften (Methoden) bei diesem Objekt auch vorhanden sind. Dies ist aber immer dann der Fall, wenn sich die Elemente der Typdefinition in der Klassendefinition des Objekts wiederfinden, die Klassendefinition also mit der Typdefinition gewissermaßen strukturell konform ist, so dass die Zuweisung einer Instanz der Klasse an eine Variable des Typs die Anforderungen der Zuweisungskompatibilität erfüllt. Um einen Compiler diese Zuweisungskompatibilität auf einfachere Weise als die Prüfung der Strukturkonformität, die ja eine rekursive Expansion der Typdefinitionen erfordert, feststellen zu lassen, gibt es zwei Möglichkeiten (bei beiden handelt es sich gewissermaßen um Varianten einer Namenskonformität): Jede Klasse sagt explizit, mit welchen Typen sie konform ist, oder: Jede Klasse spezifiziert implizit selbst einen Typ.
Im ersten Fall müsste der Compiler noch prüfen, ob eine Klasse tatsächlich auch über alle Eigenschaften der von ihr genannten Typen verfügt; im zweiten Fall ist das automatisch der Fall, da der Typ ja gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den allermeisten typisierten, objektorientierten Programmiersprachen bevorzugt, doch auch die erste kommt in populären Sprachen vor: So kann beispielsweise in JAVA und C# jede Klasse angeben, mit Variablen welcher Interface-Typen ihre Instanzen zuweisungskompatibel sein sollen (s. Kurseinheit 4, Kapitel 40 und Kurseinheit 5, Abschnitt 50.4.2). Auch STRONGTALK stellt beide Möglichkeiten zur Verfügung.","<answer> In SMALLTALK enthalten Klassendefinitionen bestimmte Elemente, die auch in Typdefinitionen auftauchen, wie Namen, von denen Definitionen abgeleitet werden, und Methodennamen mit formalen Parametern. <answer> <question> Wie ist der Zusammenhang zwischen Typen und Klassen in Bezug auf schematische Klassendefinitionen in SMALLTALK? <question>"
"Wenn in dieser Kurseinheit bislang ausschließlich von Typen die Rede war und Klassen dabei ignoriert wurden, so hat das gute Gründe: Während eine Klasse die Implementierung ihrer Objekte festlegt, ist eine Typdefinition vollkommen frei von Implementierungsaspekten. Zwar können auch abstrakte Klassen (Kurseinheit 2, Abschnitt 10.3) ausschließlich aus Methodendeklarationen bestehen, also ohne jeden Implementierungsanteil, aber auch ihr Zweck ist in der Regel, zumindest eine partielle Implementierung vorzugeben, die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können. Schließlich drückt die Klassenhierarchie ja eine „genetische“ Verwandtschaft aus (s. Abschnitt 10.1 und Kapitel 11). Eine Typprüfung soll aber ohne Ansehen der Implementierung stattfinden; sie baut daher auf abstrakte Spezifikationen, eben auf Typen.
Es sind also Typen abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. Im Gegensatz dazu sind Klassen Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Da Objekte aber auch den Wertebereich von Typen ausmachen, stellt sich natürlich die Frage, welcher Art der Zusammenhang zwischen Typen und Klassen ist.
Es fällt zunächst auf, dass bestimmte Elemente einer Klassendefinition auch in einer Typdefinition auftauchen. Im Einzelnen sind dies: ein (eindeutiger) Name, ein zweiter Name, von dessen dazugehöriger Definition abgeleitet wird sowie eine Menge von Methodennamen, jeweils mit einer Anzahl formaler Parameter.
Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in JAVA oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).
Nun dient ja ein Typsystem in der objektorientierten Programmierung vor allem der Sicherstellung des Umstands, dass alle von einem Objekt aufgrund des deklarierten Typs der Variablen, die es benennt, erwarteten Eigenschaften (Methoden) bei diesem Objekt auch vorhanden sind. Dies ist aber immer dann der Fall, wenn sich die Elemente der Typdefinition in der Klassendefinition des Objekts wiederfinden, die Klassendefinition also mit der Typdefinition gewissermaßen strukturell konform ist, so dass die Zuweisung einer Instanz der Klasse an eine Variable des Typs die Anforderungen der Zuweisungskompatibilität erfüllt. Um einen Compiler diese Zuweisungskompatibilität auf einfachere Weise als die Prüfung der Strukturkonformität, die ja eine rekursive Expansion der Typdefinitionen erfordert, feststellen zu lassen, gibt es zwei Möglichkeiten (bei beiden handelt es sich gewissermaßen um Varianten einer Namenskonformität): Jede Klasse sagt explizit, mit welchen Typen sie konform ist, oder: Jede Klasse spezifiziert implizit selbst einen Typ.
Im ersten Fall müsste der Compiler noch prüfen, ob eine Klasse tatsächlich auch über alle Eigenschaften der von ihr genannten Typen verfügt; im zweiten Fall ist das automatisch der Fall, da der Typ ja gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den allermeisten typisierten, objektorientierten Programmiersprachen bevorzugt, doch auch die erste kommt in populären Sprachen vor: So kann beispielsweise in JAVA und C# jede Klasse angeben, mit Variablen welcher Interface-Typen ihre Instanzen zuweisungskompatibel sein sollen (s. Kurseinheit 4, Kapitel 40 und Kurseinheit 5, Abschnitt 50.4.2). Auch STRONGTALK stellt beide Möglichkeiten zur Verfügung.","<answer> In SMALLTALK werden keine Typen in Klassendefinitionen verwendet, und formale Parameter verwenden stattdessen Namen wie ""aString"" oder ""anInteger"", die darauf hinweisen, welcher Klasse der Wert sein sollte. Dies wird jedoch nicht überprüft. <answer> <question> Warum werden in SMALLTALKs Klassendefinitionen keine Typen verwendet, und wie werden formale Parameter in Bezug auf Typen behandelt? <question>"
"Wenn in dieser Kurseinheit bislang ausschließlich von Typen die Rede war und Klassen dabei ignoriert wurden, so hat das gute Gründe: Während eine Klasse die Implementierung ihrer Objekte festlegt, ist eine Typdefinition vollkommen frei von Implementierungsaspekten. Zwar können auch abstrakte Klassen (Kurseinheit 2, Abschnitt 10.3) ausschließlich aus Methodendeklarationen bestehen, also ohne jeden Implementierungsanteil, aber auch ihr Zweck ist in der Regel, zumindest eine partielle Implementierung vorzugeben, die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können. Schließlich drückt die Klassenhierarchie ja eine „genetische“ Verwandtschaft aus (s. Abschnitt 10.1 und Kapitel 11). Eine Typprüfung soll aber ohne Ansehen der Implementierung stattfinden; sie baut daher auf abstrakte Spezifikationen, eben auf Typen.
Es sind also Typen abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. Im Gegensatz dazu sind Klassen Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Da Objekte aber auch den Wertebereich von Typen ausmachen, stellt sich natürlich die Frage, welcher Art der Zusammenhang zwischen Typen und Klassen ist.
Es fällt zunächst auf, dass bestimmte Elemente einer Klassendefinition auch in einer Typdefinition auftauchen. Im Einzelnen sind dies: ein (eindeutiger) Name, ein zweiter Name, von dessen dazugehöriger Definition abgeleitet wird sowie eine Menge von Methodennamen, jeweils mit einer Anzahl formaler Parameter.
Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in JAVA oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).
Nun dient ja ein Typsystem in der objektorientierten Programmierung vor allem der Sicherstellung des Umstands, dass alle von einem Objekt aufgrund des deklarierten Typs der Variablen, die es benennt, erwarteten Eigenschaften (Methoden) bei diesem Objekt auch vorhanden sind. Dies ist aber immer dann der Fall, wenn sich die Elemente der Typdefinition in der Klassendefinition des Objekts wiederfinden, die Klassendefinition also mit der Typdefinition gewissermaßen strukturell konform ist, so dass die Zuweisung einer Instanz der Klasse an eine Variable des Typs die Anforderungen der Zuweisungskompatibilität erfüllt. Um einen Compiler diese Zuweisungskompatibilität auf einfachere Weise als die Prüfung der Strukturkonformität, die ja eine rekursive Expansion der Typdefinitionen erfordert, feststellen zu lassen, gibt es zwei Möglichkeiten (bei beiden handelt es sich gewissermaßen um Varianten einer Namenskonformität): Jede Klasse sagt explizit, mit welchen Typen sie konform ist, oder: Jede Klasse spezifiziert implizit selbst einen Typ.
Im ersten Fall müsste der Compiler noch prüfen, ob eine Klasse tatsächlich auch über alle Eigenschaften der von ihr genannten Typen verfügt; im zweiten Fall ist das automatisch der Fall, da der Typ ja gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den allermeisten typisierten, objektorientierten Programmiersprachen bevorzugt, doch auch die erste kommt in populären Sprachen vor: So kann beispielsweise in JAVA und C# jede Klasse angeben, mit Variablen welcher Interface-Typen ihre Instanzen zuweisungskompatibel sein sollen (s. Kurseinheit 4, Kapitel 40 und Kurseinheit 5, Abschnitt 50.4.2). Auch STRONGTALK stellt beide Möglichkeiten zur Verfügung.","<answer> In STRONGTALK sind formale Parameter in Klassendefinitionen typisiert, während in JAVA oder C++ Instanzvariablen nicht Teil einer Typdefinition sein können. <answer> <question> Wie unterscheidet sich die Verwendung von Klassendefinitionen in STRONGTALK von anderen Sprachen wie JAVA oder C++? <question>"
"Eine der vielleicht interessantesten Methoden in SMALLTALK ist die Methode become:. Sie bewirkt, dass das Empfängerobjekt die Identität des Parameterobjekts annimmt bzw. mit ihm tauscht (je nach Dialekt). Das hat unter anderem zur Folge, dass alle Variablen, die vor der Ausführung der Methode den Empfänger benannten (genauer: auf das Empfängerobjekt verwiesen), danach den Parameter benennen (auf ihn verweisen).
Eine mögliche Anwendung ist das Vergrößern von Objekten: Wenn einem Objekt der ihm zur Verfügung gestellte Speicherplatz nicht mehr ausreicht, muss es ""umziehen"", d.h., seine Repräsentation im Speicher muss an eine andere Stelle kopiert werden. Da aber alle Referenzen auf das Objekt noch auf die alte Stelle verweisen, legt man am besten die neue Stelle als entsprechend groß dimensioniertes Objekt an (beispielsweise mittels new:) und lässt dann das alte Objekt zum neuen werden. So könnte man beispielsweise eine Methode grow in der Klasse ArrayedCollection wie folgt definieren:
Eine andere mögliche Anwendung von become: ist die Durchführung eines sogenannten Rollbacks. Wenn also, nachdem an einem Objekt (oder Objektgeflecht) eine Menge von Änderungen durchgeführt worden sind, der ursprüngliche Zustand wiederhergestellt werden soll, legt man einfach vor den Änderungen eine (tiefe) Kopie des Objekts (der Wurzel des Objektgeflechts) an und ersetzt beim Rollback das ursprüngliche (und inzwischen geänderte) Objekt(geflecht) mittels become: durch die Kopie.","<answer> Die Methode become: in SMALLTALK bewirkt, dass das Empfängerobjekt die Identität des Parameterobjekts annimmt oder mit ihm tauscht. <answer> <question> Was ist die Methode become: in SMALLTALK? <question>"
"Eine der vielleicht interessantesten Methoden in SMALLTALK ist die Methode become:. Sie bewirkt, dass das Empfängerobjekt die Identität des Parameterobjekts annimmt bzw. mit ihm tauscht (je nach Dialekt). Das hat unter anderem zur Folge, dass alle Variablen, die vor der Ausführung der Methode den Empfänger benannten (genauer: auf das Empfängerobjekt verwiesen), danach den Parameter benennen (auf ihn verweisen).
Eine mögliche Anwendung ist das Vergrößern von Objekten: Wenn einem Objekt der ihm zur Verfügung gestellte Speicherplatz nicht mehr ausreicht, muss es ""umziehen"", d.h., seine Repräsentation im Speicher muss an eine andere Stelle kopiert werden. Da aber alle Referenzen auf das Objekt noch auf die alte Stelle verweisen, legt man am besten die neue Stelle als entsprechend groß dimensioniertes Objekt an (beispielsweise mittels new:) und lässt dann das alte Objekt zum neuen werden. So könnte man beispielsweise eine Methode grow in der Klasse ArrayedCollection wie folgt definieren:
Eine andere mögliche Anwendung von become: ist die Durchführung eines sogenannten Rollbacks. Wenn also, nachdem an einem Objekt (oder Objektgeflecht) eine Menge von Änderungen durchgeführt worden sind, der ursprüngliche Zustand wiederhergestellt werden soll, legt man einfach vor den Änderungen eine (tiefe) Kopie des Objekts (der Wurzel des Objektgeflechts) an und ersetzt beim Rollback das ursprüngliche (und inzwischen geänderte) Objekt(geflecht) mittels become: durch die Kopie.","<answer> Die Methode become: bewirkt, dass Variablen, die vor der Ausführung der Methode auf das Empfängerobjekt verwiesen haben, danach auf das Parameterobjekt verweisen. <answer> <question> Welche Auswirkungen hat die Methode become: auf Variablen? <question>"
"Eine der vielleicht interessantesten Methoden in SMALLTALK ist die Methode become:. Sie bewirkt, dass das Empfängerobjekt die Identität des Parameterobjekts annimmt bzw. mit ihm tauscht (je nach Dialekt). Das hat unter anderem zur Folge, dass alle Variablen, die vor der Ausführung der Methode den Empfänger benannten (genauer: auf das Empfängerobjekt verwiesen), danach den Parameter benennen (auf ihn verweisen).
Eine mögliche Anwendung ist das Vergrößern von Objekten: Wenn einem Objekt der ihm zur Verfügung gestellte Speicherplatz nicht mehr ausreicht, muss es ""umziehen"", d.h., seine Repräsentation im Speicher muss an eine andere Stelle kopiert werden. Da aber alle Referenzen auf das Objekt noch auf die alte Stelle verweisen, legt man am besten die neue Stelle als entsprechend groß dimensioniertes Objekt an (beispielsweise mittels new:) und lässt dann das alte Objekt zum neuen werden. So könnte man beispielsweise eine Methode grow in der Klasse ArrayedCollection wie folgt definieren:
Eine andere mögliche Anwendung von become: ist die Durchführung eines sogenannten Rollbacks. Wenn also, nachdem an einem Objekt (oder Objektgeflecht) eine Menge von Änderungen durchgeführt worden sind, der ursprüngliche Zustand wiederhergestellt werden soll, legt man einfach vor den Änderungen eine (tiefe) Kopie des Objekts (der Wurzel des Objektgeflechts) an und ersetzt beim Rollback das ursprüngliche (und inzwischen geänderte) Objekt(geflecht) mittels become: durch die Kopie.","<answer> Die Methode grow in der Klasse ArrayedCollection kann verwendet werden, um ein Objekt zu vergrößern, indem man eine neue Stelle als entsprechend groß dimensioniertes Objekt anlegt und dann das alte Objekt durch die neue Stelle mittels become: ersetzt. <answer> <question> Wie kann die Methode grow in der Klasse ArrayedCollection verwendet werden? <question>"
"Eine der vielleicht interessantesten Methoden in SMALLTALK ist die Methode become:. Sie bewirkt, dass das Empfängerobjekt die Identität des Parameterobjekts annimmt bzw. mit ihm tauscht (je nach Dialekt). Das hat unter anderem zur Folge, dass alle Variablen, die vor der Ausführung der Methode den Empfänger benannten (genauer: auf das Empfängerobjekt verwiesen), danach den Parameter benennen (auf ihn verweisen).
Eine mögliche Anwendung ist das Vergrößern von Objekten: Wenn einem Objekt der ihm zur Verfügung gestellte Speicherplatz nicht mehr ausreicht, muss es ""umziehen"", d.h., seine Repräsentation im Speicher muss an eine andere Stelle kopiert werden. Da aber alle Referenzen auf das Objekt noch auf die alte Stelle verweisen, legt man am besten die neue Stelle als entsprechend groß dimensioniertes Objekt an (beispielsweise mittels new:) und lässt dann das alte Objekt zum neuen werden. So könnte man beispielsweise eine Methode grow in der Klasse ArrayedCollection wie folgt definieren:
Eine andere mögliche Anwendung von become: ist die Durchführung eines sogenannten Rollbacks. Wenn also, nachdem an einem Objekt (oder Objektgeflecht) eine Menge von Änderungen durchgeführt worden sind, der ursprüngliche Zustand wiederhergestellt werden soll, legt man einfach vor den Änderungen eine (tiefe) Kopie des Objekts (der Wurzel des Objektgeflechts) an und ersetzt beim Rollback das ursprüngliche (und inzwischen geänderte) Objekt(geflecht) mittels become: durch die Kopie.","<answer> Eine weitere Anwendung von become: ist die Durchführung eines Rollbacks, um den ursprünglichen Zustand eines Objekts oder Objektgeflechts nach einer Menge von Änderungen wiederherzustellen. Dies geschieht durch Erzeugen einer Kopie des ursprünglichen Objekts und anschließendem Ersetzen des geänderten Objekts durch die Kopie mittels become:. <answer> <question> Was ist eine weitere Anwendung von become:? <question>"
"Vererbung ist nicht auf die Klassen der Ebene 1 beschränkt — in SMALLTALK können vielmehr auch Metaklassen, die ja ebenfalls Klassen sind (s. Kapitel 8), voneinander erben. Da Metaklassen aber bei der Erzeugung von Klassen automatisch angelegt werden (und auch keine eigenen Namen haben), hat die Programmiererin auch keinen direkten Einfluss auf die Vererbungshierarchie der Metaklassen. Vielmehr wird diese automatisch parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind, angelegt. Dies hat zur Folge, dass in SMALLTALK neben den Instanzvariablen und -methoden auch die Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt werden.
Da in SMALLTALK jede Klasse direkte oder indirekte Subklasse von Object ist und die Subklassenhierarchie der Metaklassen parallel zu der ihrer Klassen angelegt ist, erbt jede Metaklasse in SMALLTALK automatisch von Object class, der Metaklasse von Object. Was läge also näher, als die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen — darunter auch die beiden Standardkonstruktoren new und new: — in Object (genauer: als Instanzmethoden von Object class) zu definieren?
Nun gibt es ja schon, wie bereits in Fußnote 29 oben erwähnt, in SMALLTALK zwei Arten von Objekten, nämlich solche, die instanziierbar sind (also Klassen) und solche, die es nicht sind. Darüber hinaus gibt es auch noch eine Unterscheidung zwischen Klassen, die Metaklassen sind, und solchen, die es nicht sind — bei allen Gemeinsamkeiten von Klassen und Metaklassen muss man z. B. von Klassen neue Subklassen bilden können, von Metaklassen jedoch nicht. Diese Unterscheidungen müssen schließlich irgendwo getroffen werden. Und so kommt es, dass Object class nicht die Wurzel der Vererbungshierarchie der Metaklassen ist (kann sie sowieso nicht, denn auch sie muss eine Subklasse von Object sein!), sondern selbst von einer für diesen Zweck vorgesehenen Klasse erbt. Aus demselben Grund, aus dem die Klasse Object „Object“ und die Klasse Metaclass „Metaclass“ heißt, heißt diese Klasse „Class“: Es gilt nämlich für jede Instanz dieser Klasse, dass sie eine Klasse ist. Man beachte übrigens, dass Class, auch wenn sie die Superklasse aller Metaklassen ist, selbst keine Metaklasse ist, denn sonst müsste Class ja als Superklasse von Object class und wegen der parallelen Vererbungshierarchie von Metaklassen und Klassen die (Meta-)Klasse einer Klasse sein, die Superklasse von Object ist. Ist sie aber nicht. Außerdem ist, wie man sich leicht überzeugen kann, die Klasse von Class die Klasse Class class und erst Class class eine Metaklasse. Zugegebenermaßen etwas kompliziert.
Die Klasse Class steht in der Vererbungshierarchie SMALLTALKs neben der Klasse Metaclass. Gemeinsam erben sie von der Klasse Behavior (in SMALLTALK-80 und direkten Derivaten indirekt, über die Klasse ClassDescription), in der schließlich, neben vielen anderen Methoden, new und new: definiert sind. Man beachte, dass diese Methoden als Instanzmethoden deklariert sind; da sie aber in der Vererbungshierarchie SMALLTALKs von den Metaklassen der Klassen geerbt werden (z. B. Object class), stehen sie in den Klassen als Klassenmethoden zur Verfügung. new und new: werden also in der Praxis immer an Klassen geschickt.","<answer> In SMALLTALK können Metaklassen, die ebenfalls Klassen sind, voneinander erben. Die Vererbungshierarchie der Metaklassen wird parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind, erstellt. Dies bedeutet, dass in SMALLTALK sowohl Instanzvariablen und -methoden als auch Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt werden. Jede Metaklasse in SMALLTALK erbt automatisch von ""Object class"", der Metaklasse von ""Object"". Die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, einschließlich der Standardkonstruktoren ""new"" und ""new:"", werden in ""Object class"" (genauer gesagt als Instanzmethoden von ""Object class"") definiert. Um die Unterscheidung zwischen instanziierbaren Klassen (Klassen) und nicht instanziierbaren Klassen (Metaklassen) sowie zwischen Klassen und Metaklassen zu treffen, wird die Klasse ""Class"" verwendet. ""Class"" ist die Superklasse aller Metaklassen und stellt sicher, dass jede Instanz dieser Klasse eine Klasse ist. Obwohl ""Class"" die Superklasse aller Metaklassen ist, ist sie selbst keine Metaklasse. Die Klasse von ""Class"" ist ""Class class"", und erst ""Class class"" ist eine Metaklasse. <answer> <question> Wie ist die Vererbungshierarchie der Metaklassen in SMALLTALK organisiert? <question>"
"Vererbung ist nicht auf die Klassen der Ebene 1 beschränkt — in SMALLTALK können vielmehr auch Metaklassen, die ja ebenfalls Klassen sind (s. Kapitel 8), voneinander erben. Da Metaklassen aber bei der Erzeugung von Klassen automatisch angelegt werden (und auch keine eigenen Namen haben), hat die Programmiererin auch keinen direkten Einfluss auf die Vererbungshierarchie der Metaklassen. Vielmehr wird diese automatisch parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind, angelegt. Dies hat zur Folge, dass in SMALLTALK neben den Instanzvariablen und -methoden auch die Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt werden.
Da in SMALLTALK jede Klasse direkte oder indirekte Subklasse von Object ist und die Subklassenhierarchie der Metaklassen parallel zu der ihrer Klassen angelegt ist, erbt jede Metaklasse in SMALLTALK automatisch von Object class, der Metaklasse von Object. Was läge also näher, als die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen — darunter auch die beiden Standardkonstruktoren new und new: — in Object (genauer: als Instanzmethoden von Object class) zu definieren?
Nun gibt es ja schon, wie bereits in Fußnote 29 oben erwähnt, in SMALLTALK zwei Arten von Objekten, nämlich solche, die instanziierbar sind (also Klassen) und solche, die es nicht sind. Darüber hinaus gibt es auch noch eine Unterscheidung zwischen Klassen, die Metaklassen sind, und solchen, die es nicht sind — bei allen Gemeinsamkeiten von Klassen und Metaklassen muss man z. B. von Klassen neue Subklassen bilden können, von Metaklassen jedoch nicht. Diese Unterscheidungen müssen schließlich irgendwo getroffen werden. Und so kommt es, dass Object class nicht die Wurzel der Vererbungshierarchie der Metaklassen ist (kann sie sowieso nicht, denn auch sie muss eine Subklasse von Object sein!), sondern selbst von einer für diesen Zweck vorgesehenen Klasse erbt. Aus demselben Grund, aus dem die Klasse Object „Object“ und die Klasse Metaclass „Metaclass“ heißt, heißt diese Klasse „Class“: Es gilt nämlich für jede Instanz dieser Klasse, dass sie eine Klasse ist. Man beachte übrigens, dass Class, auch wenn sie die Superklasse aller Metaklassen ist, selbst keine Metaklasse ist, denn sonst müsste Class ja als Superklasse von Object class und wegen der parallelen Vererbungshierarchie von Metaklassen und Klassen die (Meta-)Klasse einer Klasse sein, die Superklasse von Object ist. Ist sie aber nicht. Außerdem ist, wie man sich leicht überzeugen kann, die Klasse von Class die Klasse Class class und erst Class class eine Metaklasse. Zugegebenermaßen etwas kompliziert.
Die Klasse Class steht in der Vererbungshierarchie SMALLTALKs neben der Klasse Metaclass. Gemeinsam erben sie von der Klasse Behavior (in SMALLTALK-80 und direkten Derivaten indirekt, über die Klasse ClassDescription), in der schließlich, neben vielen anderen Methoden, new und new: definiert sind. Man beachte, dass diese Methoden als Instanzmethoden deklariert sind; da sie aber in der Vererbungshierarchie SMALLTALKs von den Metaklassen der Klassen geerbt werden (z. B. Object class), stehen sie in den Klassen als Klassenmethoden zur Verfügung. new und new: werden also in der Praxis immer an Klassen geschickt.","<answer> Die Klasse ""Class"" heißt so, weil jede Instanz dieser Klasse eine Klasse ist. Die Klasse ""Metaclass"" heißt so, weil sie die Metaklassen repräsentiert, die Klassen sind, die die Klassen selbst definieren. Diese Namensgebung spiegelt die Art der Objekte wider, die von diesen Klassen repräsentiert werden. <answer> <question> Warum heißt die Klasse ""Class"" und die Klasse ""Metaclass"" in SMALLTALK so? <question>"
"Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Kapiteln dieser Kurseinheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht. Sie ist fast immer willkürlich. Im Folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt werden, das ich persönlich eher nicht als Stilfrage einstufen würde, das aber dennoch häufiger in diesem Zusammenhang genannt wird.
Wie bereits in Kurseinheit 6 und teilweise auch schon in Kurseinheit 2, Abschnitt 10.1 bemerkt, ist die Vererbung Aushängeschild und Problemkind der objektorientierten Programmierung zugleich. Es verwundert daher nicht, dass sich eine ganze Menge von Programmierrichtlinien mit genau diesem Thema beschäftigen. Die meines Erachtens gewichtigste aller Regeln zu diesem Thema ist jedoch:
Für JAVA lässt sich diese Regel auch als „deklariere jede Klasse entweder als abstrakt oder als final“ formulieren. Der Grund dafür, dass nur die Blätter der Klassenhierarchie instanziierbar sein sollen, ist einfach: Wenn man mit der Funktionalität einer Klasse bzw. genauer und in diesem Fall wichtig, der Funktionalität der Instanzen einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern. Als Programmiererin möchte man diese Änderung unabhängig von der Frage, ob davon auch andere Klassen betroffen sind, durchführen können. Deswegen wird man die Änderungen auch nur an der Klasse selbst und nicht etwa an einer ihrer Superklassen durchführen. Betrifft der Änderungswunsch eine geerbte Methode, so überschreibt man diese in der betreffenden Klasse nach seinen Vorstellungen. Nur wenn eine eingehende Analyse der Superklasse und all ihrer Subklassen ergibt, dass die gewünschte Änderung für alle sinnvoll ist und den Erwartungen der Klienten entspricht, kann man darüber nachdenken, die Änderung in der Superklasse durchzuführen.
Wenn nun aber die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, dann ist man der Freiheit beraubt, nur für sich zu entscheiden. Von jeder Änderung, die man durchführt, muss man fürchten, dass sie sich auf andere Klassen ausbreitet und den Vertrag dieser Klassen mit ihren Klienten bricht (Siehe auch das Fragile-base-class-Problem in Kapitel 55). Etwas subtiler, aber genau dasselbe Problem, ereilt die Designerin von Klassenbibliotheken, wenn sie beschließt, das Verhalten einer Klasse zu ändern. Selbst wenn sie sich sicher ist, dass dies innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, so kann sie doch nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.
Nun ist aber, wie gerade erst (Kapitel 66) erwähnt, einer der wichtigsten Gedanken der Objektorientierung, existierenden Code, vor allem Bibliotheksklassen, per Vererbung wiederzuverwenden. Wenn die Bibliotheksdesignerin aber alle relevanten Klassen (das sind üblicherweise gerade die konkreten, also die instanziierbaren) final deklariert hat, dann ist das nicht möglich. Eine einfache Konvention erlaubt jedoch, diese Beschränkung zu umgehen: In der Bibliothek wird einfach die Klasse, von der geerbt werden soll, als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die zunächst keine Änderungen (Differenzia) hinzufügt, dafür aber konkret (also instanziierbar) und auch final ist. Sollte die Bibliotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Bibliothek mit den Änderungen beglücken möchte, die Änderungen in der abstrakten Superklasse durchführen. Machen alle Superklassen abstrakt.","<answer> Die Vererbung ist ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung, weil sie einerseits ein mächtiges Konzept zur Wiederverwendung von Code und zur Erstellung von Klassenhierarchien darstellt, andererseits aber auch dazu führen kann, dass Änderungen an einer Klasse sich auf alle davon abgeleiteten Klassen auswirken. Dies kann die Wartbarkeit und Erweiterbarkeit des Codes beeinträchtigen und zu unerwartetem Verhalten führen. <answer> <question> Warum ist die Vererbung ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung? <question>"
"Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Kapiteln dieser Kurseinheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht. Sie ist fast immer willkürlich. Im Folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt werden, das ich persönlich eher nicht als Stilfrage einstufen würde, das aber dennoch häufiger in diesem Zusammenhang genannt wird.
Wie bereits in Kurseinheit 6 und teilweise auch schon in Kurseinheit 2, Abschnitt 10.1 bemerkt, ist die Vererbung Aushängeschild und Problemkind der objektorientierten Programmierung zugleich. Es verwundert daher nicht, dass sich eine ganze Menge von Programmierrichtlinien mit genau diesem Thema beschäftigen. Die meines Erachtens gewichtigste aller Regeln zu diesem Thema ist jedoch:
Für JAVA lässt sich diese Regel auch als „deklariere jede Klasse entweder als abstrakt oder als final“ formulieren. Der Grund dafür, dass nur die Blätter der Klassenhierarchie instanziierbar sein sollen, ist einfach: Wenn man mit der Funktionalität einer Klasse bzw. genauer und in diesem Fall wichtig, der Funktionalität der Instanzen einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern. Als Programmiererin möchte man diese Änderung unabhängig von der Frage, ob davon auch andere Klassen betroffen sind, durchführen können. Deswegen wird man die Änderungen auch nur an der Klasse selbst und nicht etwa an einer ihrer Superklassen durchführen. Betrifft der Änderungswunsch eine geerbte Methode, so überschreibt man diese in der betreffenden Klasse nach seinen Vorstellungen. Nur wenn eine eingehende Analyse der Superklasse und all ihrer Subklassen ergibt, dass die gewünschte Änderung für alle sinnvoll ist und den Erwartungen der Klienten entspricht, kann man darüber nachdenken, die Änderung in der Superklasse durchzuführen.
Wenn nun aber die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, dann ist man der Freiheit beraubt, nur für sich zu entscheiden. Von jeder Änderung, die man durchführt, muss man fürchten, dass sie sich auf andere Klassen ausbreitet und den Vertrag dieser Klassen mit ihren Klienten bricht (Siehe auch das Fragile-base-class-Problem in Kapitel 55). Etwas subtiler, aber genau dasselbe Problem, ereilt die Designerin von Klassenbibliotheken, wenn sie beschließt, das Verhalten einer Klasse zu ändern. Selbst wenn sie sich sicher ist, dass dies innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, so kann sie doch nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.
Nun ist aber, wie gerade erst (Kapitel 66) erwähnt, einer der wichtigsten Gedanken der Objektorientierung, existierenden Code, vor allem Bibliotheksklassen, per Vererbung wiederzuverwenden. Wenn die Bibliotheksdesignerin aber alle relevanten Klassen (das sind üblicherweise gerade die konkreten, also die instanziierbaren) final deklariert hat, dann ist das nicht möglich. Eine einfache Konvention erlaubt jedoch, diese Beschränkung zu umgehen: In der Bibliothek wird einfach die Klasse, von der geerbt werden soll, als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die zunächst keine Änderungen (Differenzia) hinzufügt, dafür aber konkret (also instanziierbar) und auch final ist. Sollte die Bibliotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Bibliothek mit den Änderungen beglücken möchte, die Änderungen in der abstrakten Superklasse durchführen. Machen alle Superklassen abstrakt.","<answer> Die gewichtigste Regel im Zusammenhang mit Vererbung besagt: ""Deklariere jede Klasse entweder als abstrakt oder als final."" Das bedeutet, dass Klassen entweder als abstrakt (nicht instanziierbar) oder als final (nicht ableitbar) deklariert werden sollten. <answer> <question> Was besagt die gewichtigste Regel im Zusammenhang mit Vererbung? <question>"
"Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Kapiteln dieser Kurseinheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht. Sie ist fast immer willkürlich. Im Folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt werden, das ich persönlich eher nicht als Stilfrage einstufen würde, das aber dennoch häufiger in diesem Zusammenhang genannt wird.
Wie bereits in Kurseinheit 6 und teilweise auch schon in Kurseinheit 2, Abschnitt 10.1 bemerkt, ist die Vererbung Aushängeschild und Problemkind der objektorientierten Programmierung zugleich. Es verwundert daher nicht, dass sich eine ganze Menge von Programmierrichtlinien mit genau diesem Thema beschäftigen. Die meines Erachtens gewichtigste aller Regeln zu diesem Thema ist jedoch:
Für JAVA lässt sich diese Regel auch als „deklariere jede Klasse entweder als abstrakt oder als final“ formulieren. Der Grund dafür, dass nur die Blätter der Klassenhierarchie instanziierbar sein sollen, ist einfach: Wenn man mit der Funktionalität einer Klasse bzw. genauer und in diesem Fall wichtig, der Funktionalität der Instanzen einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern. Als Programmiererin möchte man diese Änderung unabhängig von der Frage, ob davon auch andere Klassen betroffen sind, durchführen können. Deswegen wird man die Änderungen auch nur an der Klasse selbst und nicht etwa an einer ihrer Superklassen durchführen. Betrifft der Änderungswunsch eine geerbte Methode, so überschreibt man diese in der betreffenden Klasse nach seinen Vorstellungen. Nur wenn eine eingehende Analyse der Superklasse und all ihrer Subklassen ergibt, dass die gewünschte Änderung für alle sinnvoll ist und den Erwartungen der Klienten entspricht, kann man darüber nachdenken, die Änderung in der Superklasse durchzuführen.
Wenn nun aber die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, dann ist man der Freiheit beraubt, nur für sich zu entscheiden. Von jeder Änderung, die man durchführt, muss man fürchten, dass sie sich auf andere Klassen ausbreitet und den Vertrag dieser Klassen mit ihren Klienten bricht (Siehe auch das Fragile-base-class-Problem in Kapitel 55). Etwas subtiler, aber genau dasselbe Problem, ereilt die Designerin von Klassenbibliotheken, wenn sie beschließt, das Verhalten einer Klasse zu ändern. Selbst wenn sie sich sicher ist, dass dies innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, so kann sie doch nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.
Nun ist aber, wie gerade erst (Kapitel 66) erwähnt, einer der wichtigsten Gedanken der Objektorientierung, existierenden Code, vor allem Bibliotheksklassen, per Vererbung wiederzuverwenden. Wenn die Bibliotheksdesignerin aber alle relevanten Klassen (das sind üblicherweise gerade die konkreten, also die instanziierbaren) final deklariert hat, dann ist das nicht möglich. Eine einfache Konvention erlaubt jedoch, diese Beschränkung zu umgehen: In der Bibliothek wird einfach die Klasse, von der geerbt werden soll, als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die zunächst keine Änderungen (Differenzia) hinzufügt, dafür aber konkret (also instanziierbar) und auch final ist. Sollte die Bibliotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Bibliothek mit den Änderungen beglücken möchte, die Änderungen in der abstrakten Superklasse durchführen. Machen alle Superklassen abstrakt.","<answer> Die Blätter der Klassenhierarchie sollten instanziierbar sein, weil dies sicherstellt, dass Änderungen an einer Klasse nur Auswirkungen auf diese Klasse selbst haben und nicht auf alle davon abgeleiteten Klassen. Wenn eine Klasse in der Hierarchie geändert werden muss, können diese Änderungen in der Klasse selbst oder in ihren Subklassen vorgenommen werden, ohne die anderen Klassen in der Hierarchie zu beeinflussen. <answer> <question> Warum sollten nur die Blätter der Klassenhierarchie instanziierbar sein? <question>"
"Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Kapiteln dieser Kurseinheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht. Sie ist fast immer willkürlich. Im Folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt werden, das ich persönlich eher nicht als Stilfrage einstufen würde, das aber dennoch häufiger in diesem Zusammenhang genannt wird.
Wie bereits in Kurseinheit 6 und teilweise auch schon in Kurseinheit 2, Abschnitt 10.1 bemerkt, ist die Vererbung Aushängeschild und Problemkind der objektorientierten Programmierung zugleich. Es verwundert daher nicht, dass sich eine ganze Menge von Programmierrichtlinien mit genau diesem Thema beschäftigen. Die meines Erachtens gewichtigste aller Regeln zu diesem Thema ist jedoch:
Für JAVA lässt sich diese Regel auch als „deklariere jede Klasse entweder als abstrakt oder als final“ formulieren. Der Grund dafür, dass nur die Blätter der Klassenhierarchie instanziierbar sein sollen, ist einfach: Wenn man mit der Funktionalität einer Klasse bzw. genauer und in diesem Fall wichtig, der Funktionalität der Instanzen einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern. Als Programmiererin möchte man diese Änderung unabhängig von der Frage, ob davon auch andere Klassen betroffen sind, durchführen können. Deswegen wird man die Änderungen auch nur an der Klasse selbst und nicht etwa an einer ihrer Superklassen durchführen. Betrifft der Änderungswunsch eine geerbte Methode, so überschreibt man diese in der betreffenden Klasse nach seinen Vorstellungen. Nur wenn eine eingehende Analyse der Superklasse und all ihrer Subklassen ergibt, dass die gewünschte Änderung für alle sinnvoll ist und den Erwartungen der Klienten entspricht, kann man darüber nachdenken, die Änderung in der Superklasse durchzuführen.
Wenn nun aber die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, dann ist man der Freiheit beraubt, nur für sich zu entscheiden. Von jeder Änderung, die man durchführt, muss man fürchten, dass sie sich auf andere Klassen ausbreitet und den Vertrag dieser Klassen mit ihren Klienten bricht (Siehe auch das Fragile-base-class-Problem in Kapitel 55). Etwas subtiler, aber genau dasselbe Problem, ereilt die Designerin von Klassenbibliotheken, wenn sie beschließt, das Verhalten einer Klasse zu ändern. Selbst wenn sie sich sicher ist, dass dies innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, so kann sie doch nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.
Nun ist aber, wie gerade erst (Kapitel 66) erwähnt, einer der wichtigsten Gedanken der Objektorientierung, existierenden Code, vor allem Bibliotheksklassen, per Vererbung wiederzuverwenden. Wenn die Bibliotheksdesignerin aber alle relevanten Klassen (das sind üblicherweise gerade die konkreten, also die instanziierbaren) final deklariert hat, dann ist das nicht möglich. Eine einfache Konvention erlaubt jedoch, diese Beschränkung zu umgehen: In der Bibliothek wird einfach die Klasse, von der geerbt werden soll, als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die zunächst keine Änderungen (Differenzia) hinzufügt, dafür aber konkret (also instanziierbar) und auch final ist. Sollte die Bibliotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Bibliothek mit den Änderungen beglücken möchte, die Änderungen in der abstrakten Superklasse durchführen. Machen alle Superklassen abstrakt.","<answer> Das Deklarieren von Klassen als abstrakt oder final ermöglicht es, Änderungen an der Funktionalität der Klasse auf sichere Weise durchzuführen. Wenn eine Klasse als abstrakt deklariert ist, können Änderungen in den abgeleiteten Subklassen vorgenommen werden, ohne die anderen Klassen in der Hierarchie zu beeinflussen. Wenn eine Klasse als final deklariert ist, kann sie nicht abgeleitet werden, was bedeutet, dass ihre Funktionalität nicht geändert werden kann. Dies ermöglicht es, den Vertrag zwischen der Klasse und ihren Klienten zu schützen und unerwartete Verhaltensänderungen zu verhindern. <answer> <question> Warum ist es wichtig, Klassen als abstrakt oder final zu deklarieren, um Änderungen an der Funktionalität der Klasse zu ermöglichen? <question>"
"Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Kapiteln dieser Kurseinheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht. Sie ist fast immer willkürlich. Im Folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt werden, das ich persönlich eher nicht als Stilfrage einstufen würde, das aber dennoch häufiger in diesem Zusammenhang genannt wird.
Wie bereits in Kurseinheit 6 und teilweise auch schon in Kurseinheit 2, Abschnitt 10.1 bemerkt, ist die Vererbung Aushängeschild und Problemkind der objektorientierten Programmierung zugleich. Es verwundert daher nicht, dass sich eine ganze Menge von Programmierrichtlinien mit genau diesem Thema beschäftigen. Die meines Erachtens gewichtigste aller Regeln zu diesem Thema ist jedoch:
Für JAVA lässt sich diese Regel auch als „deklariere jede Klasse entweder als abstrakt oder als final“ formulieren. Der Grund dafür, dass nur die Blätter der Klassenhierarchie instanziierbar sein sollen, ist einfach: Wenn man mit der Funktionalität einer Klasse bzw. genauer und in diesem Fall wichtig, der Funktionalität der Instanzen einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern. Als Programmiererin möchte man diese Änderung unabhängig von der Frage, ob davon auch andere Klassen betroffen sind, durchführen können. Deswegen wird man die Änderungen auch nur an der Klasse selbst und nicht etwa an einer ihrer Superklassen durchführen. Betrifft der Änderungswunsch eine geerbte Methode, so überschreibt man diese in der betreffenden Klasse nach seinen Vorstellungen. Nur wenn eine eingehende Analyse der Superklasse und all ihrer Subklassen ergibt, dass die gewünschte Änderung für alle sinnvoll ist und den Erwartungen der Klienten entspricht, kann man darüber nachdenken, die Änderung in der Superklasse durchzuführen.
Wenn nun aber die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, dann ist man der Freiheit beraubt, nur für sich zu entscheiden. Von jeder Änderung, die man durchführt, muss man fürchten, dass sie sich auf andere Klassen ausbreitet und den Vertrag dieser Klassen mit ihren Klienten bricht (Siehe auch das Fragile-base-class-Problem in Kapitel 55). Etwas subtiler, aber genau dasselbe Problem, ereilt die Designerin von Klassenbibliotheken, wenn sie beschließt, das Verhalten einer Klasse zu ändern. Selbst wenn sie sich sicher ist, dass dies innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, so kann sie doch nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.
Nun ist aber, wie gerade erst (Kapitel 66) erwähnt, einer der wichtigsten Gedanken der Objektorientierung, existierenden Code, vor allem Bibliotheksklassen, per Vererbung wiederzuverwenden. Wenn die Bibliotheksdesignerin aber alle relevanten Klassen (das sind üblicherweise gerade die konkreten, also die instanziierbaren) final deklariert hat, dann ist das nicht möglich. Eine einfache Konvention erlaubt jedoch, diese Beschränkung zu umgehen: In der Bibliothek wird einfach die Klasse, von der geerbt werden soll, als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die zunächst keine Änderungen (Differenzia) hinzufügt, dafür aber konkret (also instanziierbar) und auch final ist. Sollte die Bibliotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Bibliothek mit den Änderungen beglücken möchte, die Änderungen in der abstrakten Superklasse durchführen. Machen alle Superklassen abstrakt.","<answer> Die Verwendung von abstrakten Klassen in Bibliotheken ermöglicht es, die Beschränkungen von finalen Klassen zu umgehen, indem sie eine Schicht der Abstraktion hinzufügen. Anstatt eine Klasse als final zu deklarieren, wird sie als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die konkret (instanziierbar) und final ist. Auf diese Weise können Klienten der Bibliothek von der abgeleiteten, finalen Klasse erben und diese verwenden, ohne die ursprüngliche Klasse ändern zu müssen. Wenn Änderungen erforderlich sind, können sie in der finalen Klasse vorgenommen werden, und nur wenn sie für alle Klienten geeignet sind, werden sie in der abstrakten Superklasse durchgeführt. Dies ermöglicht eine gewisse Flexibilität bei der Aktualisierung von Bibliotheken, ohne den Vertrag mit den Klienten zu brechen. <answer> <question> Warum ist die Verwendung von abstrakten Klassen in Bibliotheken eine Möglichkeit, die Beschränkungen von finalen Klassen zu umgehen? <question>"
"JAVA-Programme sind objektorientierte Programme. Zur Laufzeit bestehen sie aus einer Menge interagierender Objekte. Dabei ist JAVA stark typisiert: Jedes Objekt gehört zum Wertebereich eines oder mehrerer Typen. Anders als in SMALLTALK gibt es in JAVA neben Objekten auch Werte wie Zahlen, Zeichen und Wahrheitswerte, die keine Objekte sind.
In JAVA werden zunächst sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen. Von Klassen- und Interfacetypen gibt es seit JAVA 5 auch parametrisierte Varianten, die denen von STRONGTALK stark ähneln (die JAVA-Generics stammen teilweise von Autoren von STRONGTALK). Die primitiven Typen sind in der Sprachdefinition festgelegt. Es handelt sich um byte, short, int, long, float, double, boolean und char. Sie unterscheiden sich nicht wesentlich von den Typen in gängigen, statisch typgeprüften prozeduralen Sprachen.
Alle anderen Typen werden in JAVA durch Typkonstruktion mittels entsprechender Sprachkonstrukte definiert. Ein Teil dieser Typen ist jedoch in der Sprachdefinition bereits festgelegt. JAVA sieht für jeden primitiven Typ einen im Wesentlichen gleichnamigen Referenztyp vor, dessen Werte jeweils einen Wert eines entsprechenden primitiven Typs aufnehmen können. Diese Typen, nämlich Byte, Short, Integer, Long, Float, Double, Boolean und Character, nennt man deshalb Wrapper-Typen (sie verpacken gewissermaßen einen Wert eines primitiven Typs). Weitere Typen, die die JAVA-Sprachdefinition voraussetzt, sind Object, String, Throwable, Error, Exception, RuntimeException und Thread. Diese werden an entsprechenden Stellen unten weiter erläutert.
Genau wie in SMALLTALK müssen auch in JAVA die Objekte irgendwoher kommen. Neben der Instanziierung von Klassen, wie Sie sie auch schon von SMALLTALK kennen, gibt es dafür auch in JAVA Literale.","<answer> In JAVA werden die folgenden sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen. <answer> <question> Was sind die sechs Arten von Typen, die in JAVA unterschieden werden? <question>"
"JAVA-Programme sind objektorientierte Programme. Zur Laufzeit bestehen sie aus einer Menge interagierender Objekte. Dabei ist JAVA stark typisiert: Jedes Objekt gehört zum Wertebereich eines oder mehrerer Typen. Anders als in SMALLTALK gibt es in JAVA neben Objekten auch Werte wie Zahlen, Zeichen und Wahrheitswerte, die keine Objekte sind.
In JAVA werden zunächst sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen. Von Klassen- und Interfacetypen gibt es seit JAVA 5 auch parametrisierte Varianten, die denen von STRONGTALK stark ähneln (die JAVA-Generics stammen teilweise von Autoren von STRONGTALK). Die primitiven Typen sind in der Sprachdefinition festgelegt. Es handelt sich um byte, short, int, long, float, double, boolean und char. Sie unterscheiden sich nicht wesentlich von den Typen in gängigen, statisch typgeprüften prozeduralen Sprachen.
Alle anderen Typen werden in JAVA durch Typkonstruktion mittels entsprechender Sprachkonstrukte definiert. Ein Teil dieser Typen ist jedoch in der Sprachdefinition bereits festgelegt. JAVA sieht für jeden primitiven Typ einen im Wesentlichen gleichnamigen Referenztyp vor, dessen Werte jeweils einen Wert eines entsprechenden primitiven Typs aufnehmen können. Diese Typen, nämlich Byte, Short, Integer, Long, Float, Double, Boolean und Character, nennt man deshalb Wrapper-Typen (sie verpacken gewissermaßen einen Wert eines primitiven Typs). Weitere Typen, die die JAVA-Sprachdefinition voraussetzt, sind Object, String, Throwable, Error, Exception, RuntimeException und Thread. Diese werden an entsprechenden Stellen unten weiter erläutert.
Genau wie in SMALLTALK müssen auch in JAVA die Objekte irgendwoher kommen. Neben der Instanziierung von Klassen, wie Sie sie auch schon von SMALLTALK kennen, gibt es dafür auch in JAVA Literale.","<answer> In JAVA sind die folgenden primitiven Typen definiert: byte, short, int, long, float, double, boolean und char. <answer> <question> Welche primitiven Typen sind in JAVA definiert? <question>"
"JAVA-Programme sind objektorientierte Programme. Zur Laufzeit bestehen sie aus einer Menge interagierender Objekte. Dabei ist JAVA stark typisiert: Jedes Objekt gehört zum Wertebereich eines oder mehrerer Typen. Anders als in SMALLTALK gibt es in JAVA neben Objekten auch Werte wie Zahlen, Zeichen und Wahrheitswerte, die keine Objekte sind.
In JAVA werden zunächst sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen. Von Klassen- und Interfacetypen gibt es seit JAVA 5 auch parametrisierte Varianten, die denen von STRONGTALK stark ähneln (die JAVA-Generics stammen teilweise von Autoren von STRONGTALK). Die primitiven Typen sind in der Sprachdefinition festgelegt. Es handelt sich um byte, short, int, long, float, double, boolean und char. Sie unterscheiden sich nicht wesentlich von den Typen in gängigen, statisch typgeprüften prozeduralen Sprachen.
Alle anderen Typen werden in JAVA durch Typkonstruktion mittels entsprechender Sprachkonstrukte definiert. Ein Teil dieser Typen ist jedoch in der Sprachdefinition bereits festgelegt. JAVA sieht für jeden primitiven Typ einen im Wesentlichen gleichnamigen Referenztyp vor, dessen Werte jeweils einen Wert eines entsprechenden primitiven Typs aufnehmen können. Diese Typen, nämlich Byte, Short, Integer, Long, Float, Double, Boolean und Character, nennt man deshalb Wrapper-Typen (sie verpacken gewissermaßen einen Wert eines primitiven Typs). Weitere Typen, die die JAVA-Sprachdefinition voraussetzt, sind Object, String, Throwable, Error, Exception, RuntimeException und Thread. Diese werden an entsprechenden Stellen unten weiter erläutert.
Genau wie in SMALLTALK müssen auch in JAVA die Objekte irgendwoher kommen. Neben der Instanziierung von Klassen, wie Sie sie auch schon von SMALLTALK kennen, gibt es dafür auch in JAVA Literale.","<answer> Wrapper-Typen in JAVA sind Referenztypen, die jeweils einen Wert eines entsprechenden primitiven Typs aufnehmen können. Sie werden verwendet, um primitiven Typen eine Objekthülle zu geben und sie in Situationen zu verwenden, die Referenztypen erfordern. <answer> <question> Was sind Wrapper-Typen in JAVA und wofür werden sie verwendet? <question>"
"JAVA-Programme sind objektorientierte Programme. Zur Laufzeit bestehen sie aus einer Menge interagierender Objekte. Dabei ist JAVA stark typisiert: Jedes Objekt gehört zum Wertebereich eines oder mehrerer Typen. Anders als in SMALLTALK gibt es in JAVA neben Objekten auch Werte wie Zahlen, Zeichen und Wahrheitswerte, die keine Objekte sind.
In JAVA werden zunächst sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen. Von Klassen- und Interfacetypen gibt es seit JAVA 5 auch parametrisierte Varianten, die denen von STRONGTALK stark ähneln (die JAVA-Generics stammen teilweise von Autoren von STRONGTALK). Die primitiven Typen sind in der Sprachdefinition festgelegt. Es handelt sich um byte, short, int, long, float, double, boolean und char. Sie unterscheiden sich nicht wesentlich von den Typen in gängigen, statisch typgeprüften prozeduralen Sprachen.
Alle anderen Typen werden in JAVA durch Typkonstruktion mittels entsprechender Sprachkonstrukte definiert. Ein Teil dieser Typen ist jedoch in der Sprachdefinition bereits festgelegt. JAVA sieht für jeden primitiven Typ einen im Wesentlichen gleichnamigen Referenztyp vor, dessen Werte jeweils einen Wert eines entsprechenden primitiven Typs aufnehmen können. Diese Typen, nämlich Byte, Short, Integer, Long, Float, Double, Boolean und Character, nennt man deshalb Wrapper-Typen (sie verpacken gewissermaßen einen Wert eines primitiven Typs). Weitere Typen, die die JAVA-Sprachdefinition voraussetzt, sind Object, String, Throwable, Error, Exception, RuntimeException und Thread. Diese werden an entsprechenden Stellen unten weiter erläutert.
Genau wie in SMALLTALK müssen auch in JAVA die Objekte irgendwoher kommen. Neben der Instanziierung von Klassen, wie Sie sie auch schon von SMALLTALK kennen, gibt es dafür auch in JAVA Literale.","<answer> In der JAVA-Sprachdefinition sind folgende vordefinierte Typen festgelegt: Object, String, Throwable, Error, Exception, RuntimeException und Thread. <answer> <question> Welche vordefinierten Typen sind in der JAVA-Sprachdefinition bereits festgelegt? <question>"
"JAVA-Programme sind objektorientierte Programme. Zur Laufzeit bestehen sie aus einer Menge interagierender Objekte. Dabei ist JAVA stark typisiert: Jedes Objekt gehört zum Wertebereich eines oder mehrerer Typen. Anders als in SMALLTALK gibt es in JAVA neben Objekten auch Werte wie Zahlen, Zeichen und Wahrheitswerte, die keine Objekte sind.
In JAVA werden zunächst sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen. Von Klassen- und Interfacetypen gibt es seit JAVA 5 auch parametrisierte Varianten, die denen von STRONGTALK stark ähneln (die JAVA-Generics stammen teilweise von Autoren von STRONGTALK). Die primitiven Typen sind in der Sprachdefinition festgelegt. Es handelt sich um byte, short, int, long, float, double, boolean und char. Sie unterscheiden sich nicht wesentlich von den Typen in gängigen, statisch typgeprüften prozeduralen Sprachen.
Alle anderen Typen werden in JAVA durch Typkonstruktion mittels entsprechender Sprachkonstrukte definiert. Ein Teil dieser Typen ist jedoch in der Sprachdefinition bereits festgelegt. JAVA sieht für jeden primitiven Typ einen im Wesentlichen gleichnamigen Referenztyp vor, dessen Werte jeweils einen Wert eines entsprechenden primitiven Typs aufnehmen können. Diese Typen, nämlich Byte, Short, Integer, Long, Float, Double, Boolean und Character, nennt man deshalb Wrapper-Typen (sie verpacken gewissermaßen einen Wert eines primitiven Typs). Weitere Typen, die die JAVA-Sprachdefinition voraussetzt, sind Object, String, Throwable, Error, Exception, RuntimeException und Thread. Diese werden an entsprechenden Stellen unten weiter erläutert.
Genau wie in SMALLTALK müssen auch in JAVA die Objekte irgendwoher kommen. Neben der Instanziierung von Klassen, wie Sie sie auch schon von SMALLTALK kennen, gibt es dafür auch in JAVA Literale.","<answer> Literale in JAVA sind Werte wie Zahlen, Zeichen und Wahrheitswerte, die direkt in den Code geschrieben werden können, ohne sie durch Instanziierung von Klassen zu erzeugen. Literale sind eine Möglichkeit, Objekte in JAVA zu erstellen. <answer> <question> Was sind Literale in JAVA, und wie werden sie verwendet? <question>"
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, so sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.
Wenn Variablen keine Objekte enthalten, sondern lediglich auf sie verweisen, wenn sie also Verweissemantik haben, ist es möglich, dass mehrere Variablen gleichzeitig dasselbe Objekt benennen. Das nennt man Aliasing. Das Aliasing ist eines der wichtigsten Phänomene der objektorientierten Programmierung; zugleich ist es leider nur wenig als solches bekannt. Versuchen Sie trotzdem, es sich stets bewusst zu machen — es wird Sie vor manch böser Überraschung bewahren.
Aliase, also weitere Namen für ein bereits benanntes Objekt, entstehen immer bei der Zuweisung. Dazu ist es notwendig, dass die Variable auf der linken Seite Verweissemantik hat. Da in SMALLTALK die Semantik von Variablen nicht mit der Variablendeklaration (siehe Kapitel 19) festgelegt wird, sondern von der Art eines Objekts abhängt, ist nicht immer klar, bei welcher Zuweisung ein Alias entsteht. Dabei kann beides, die fälschliche Annahme von Verweissemantik bei tatsächlicher Wertsemantik und die Entstehung von Aliasen, zu erheblichen (und schwer zu findenden) Programmierfehlern führen.
Nach den beiden Zuweisungen hat das eine Objekt, das der Compiler für #Smalltalk erzeugt, zwei Namen, nämlich x und y.
Das Aliasing ist zunächst erwünscht: Da jedes Objekt nur einmal im Speicher hinterlegt werden muss, ermöglicht es die extrem effiziente Informationsverarbeitung (es ist weder ein Kopieren notwendig, wenn ein Objekt weitergereicht werden soll, noch müssen die Änderungen an den verschiedenen Kopien zusammengeführt werden, die notwendig sind, wenn die Kopien immer noch dasselbe logische Objekt bezeichnen sollen). Doch diese Effizienz hat ihren Preis.
Dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt, kann nämlich unerwünscht sein und zu einem Programmierfehler führen. So könnte man beispielsweise bei den beiden Zuweisungen lediglich bezwecken wollen, dass Peter und Paul zuerst gleich heißen, z. B. weil sie Geschwister sind. Bei einer späteren Promotion von Paula fügt sie die Zeichen $D, $r und $. in den ihren Nachnamen repräsentierenden String ein, ändert also das entsprechende Objekt. Man hat nun sicher nicht beabsichtigt, dass das auch petersNachname betrifft, aber wenn die Änderung an einer weit entfernten Stelle im Programm erfolgt, ist die Identität der von petersNachname und paulasNachname benannten Objekte nicht mehr offensichtlich. Tatsächlich hat man es dann mit einem recht subtilen und schwer zu findenden Programmierfehler zu tun. Deswegen (und aufgrund etwas überzeugenderer Beispiele, die zu verwenden aber noch mehr Vorbereitung bedarf), sind in einigen SMALLTALK-Systemen alle auf Basis literaler Repräsentationen erzeugten Objekte als unveränderlich markiert (wenn Sie es nicht schon, wie beispielsweise Zahlen, von Haus aus sind), so dass Programmierfehler dieser Art vermieden werden. Sollte wie im obigen Beispiel eine Zuweisung mit Wertsemantik benötigt werden, so schreibt man statt Zeile 28 in SMALLTALK einfach x := petersNachname copy.
Dabei sorgt das hintangestellte ""copy"" dafür, dass von dem Objekt, das durch petersNachname bezeichnet wird, eine Kopie angefertigt wird, also ein neues Objekt, das dem alten gleicht (mehr zur Syntax und dazu, wofür ""copy"" steht, folgt unten). Nicht nötig wird das Kopieren, wenn ich die Änderung durch die Zuweisung eines neuen Objekts be-werkstellige, wie das beispielsweise in Beispiel 1.20 oder gar x := ""Peter Doe"" der Fall ist (wobei das Komma hier für die String-Konkatenation steht).
Fehler dieser Art sind häufig die Folge dessen, dass sich eine Programmiererin der aliasbildenden Wirkung der Zuweisung nicht bewusst war. Das ist insbesondere bei den Programmiererinnen der Fall, die nicht mit der objektorientierten Programmierung großgeworden sind, die insbesondere bei einer Zuweisung ""y := x"" das Kopieren des Inhalts der Variablen auf der rechten Seite (x) vermuten. Tatsächlich muss man in anderen Sprachen (wie beispielsweise PASCAL oder C) eine Variable explizit als Pointervariable deklarieren, um einen Alias bilden zu können. In SMALLTALK, genau wie in JAVA und C#, ist Aliasing jedoch der Regelfall und Kopie die Ausnahme. Wer das nicht verinnerlicht hat, schreibt höchstens zufällig korrekte Programme.","<answer> Aliasing bezieht sich auf die Situation, in der mehrere Variablen gleichzeitig auf dasselbe Objekt verweisen. Das bedeutet, dass ein Objekt mehrere Namen (Aliase) haben kann. <answer> <question> Was versteht man unter dem Begriff ""Aliasing"" in der objektorientierten Programmierung? <question>"
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, so sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.
Wenn Variablen keine Objekte enthalten, sondern lediglich auf sie verweisen, wenn sie also Verweissemantik haben, ist es möglich, dass mehrere Variablen gleichzeitig dasselbe Objekt benennen. Das nennt man Aliasing. Das Aliasing ist eines der wichtigsten Phänomene der objektorientierten Programmierung; zugleich ist es leider nur wenig als solches bekannt. Versuchen Sie trotzdem, es sich stets bewusst zu machen — es wird Sie vor manch böser Überraschung bewahren.
Aliase, also weitere Namen für ein bereits benanntes Objekt, entstehen immer bei der Zuweisung. Dazu ist es notwendig, dass die Variable auf der linken Seite Verweissemantik hat. Da in SMALLTALK die Semantik von Variablen nicht mit der Variablendeklaration (siehe Kapitel 19) festgelegt wird, sondern von der Art eines Objekts abhängt, ist nicht immer klar, bei welcher Zuweisung ein Alias entsteht. Dabei kann beides, die fälschliche Annahme von Verweissemantik bei tatsächlicher Wertsemantik und die Entstehung von Aliasen, zu erheblichen (und schwer zu findenden) Programmierfehlern führen.
Nach den beiden Zuweisungen hat das eine Objekt, das der Compiler für #Smalltalk erzeugt, zwei Namen, nämlich x und y.
Das Aliasing ist zunächst erwünscht: Da jedes Objekt nur einmal im Speicher hinterlegt werden muss, ermöglicht es die extrem effiziente Informationsverarbeitung (es ist weder ein Kopieren notwendig, wenn ein Objekt weitergereicht werden soll, noch müssen die Änderungen an den verschiedenen Kopien zusammengeführt werden, die notwendig sind, wenn die Kopien immer noch dasselbe logische Objekt bezeichnen sollen). Doch diese Effizienz hat ihren Preis.
Dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt, kann nämlich unerwünscht sein und zu einem Programmierfehler führen. So könnte man beispielsweise bei den beiden Zuweisungen lediglich bezwecken wollen, dass Peter und Paul zuerst gleich heißen, z. B. weil sie Geschwister sind. Bei einer späteren Promotion von Paula fügt sie die Zeichen $D, $r und $. in den ihren Nachnamen repräsentierenden String ein, ändert also das entsprechende Objekt. Man hat nun sicher nicht beabsichtigt, dass das auch petersNachname betrifft, aber wenn die Änderung an einer weit entfernten Stelle im Programm erfolgt, ist die Identität der von petersNachname und paulasNachname benannten Objekte nicht mehr offensichtlich. Tatsächlich hat man es dann mit einem recht subtilen und schwer zu findenden Programmierfehler zu tun. Deswegen (und aufgrund etwas überzeugenderer Beispiele, die zu verwenden aber noch mehr Vorbereitung bedarf), sind in einigen SMALLTALK-Systemen alle auf Basis literaler Repräsentationen erzeugten Objekte als unveränderlich markiert (wenn Sie es nicht schon, wie beispielsweise Zahlen, von Haus aus sind), so dass Programmierfehler dieser Art vermieden werden. Sollte wie im obigen Beispiel eine Zuweisung mit Wertsemantik benötigt werden, so schreibt man statt Zeile 28 in SMALLTALK einfach x := petersNachname copy.
Dabei sorgt das hintangestellte ""copy"" dafür, dass von dem Objekt, das durch petersNachname bezeichnet wird, eine Kopie angefertigt wird, also ein neues Objekt, das dem alten gleicht (mehr zur Syntax und dazu, wofür ""copy"" steht, folgt unten). Nicht nötig wird das Kopieren, wenn ich die Änderung durch die Zuweisung eines neuen Objekts be-werkstellige, wie das beispielsweise in Beispiel 1.20 oder gar x := ""Peter Doe"" der Fall ist (wobei das Komma hier für die String-Konkatenation steht).
Fehler dieser Art sind häufig die Folge dessen, dass sich eine Programmiererin der aliasbildenden Wirkung der Zuweisung nicht bewusst war. Das ist insbesondere bei den Programmiererinnen der Fall, die nicht mit der objektorientierten Programmierung großgeworden sind, die insbesondere bei einer Zuweisung ""y := x"" das Kopieren des Inhalts der Variablen auf der rechten Seite (x) vermuten. Tatsächlich muss man in anderen Sprachen (wie beispielsweise PASCAL oder C) eine Variable explizit als Pointervariable deklarieren, um einen Alias bilden zu können. In SMALLTALK, genau wie in JAVA und C#, ist Aliasing jedoch der Regelfall und Kopie die Ausnahme. Wer das nicht verinnerlicht hat, schreibt höchstens zufällig korrekte Programme.","<answer> Aliasing kann zu Programmierfehlern führen, weil Änderungen an einem Objekt, das durch eine Variable bezeichnet wird, sich auf alle Aliase dieses Objekts auswirken. Unerwartete Veränderungen an einem Alias können schwer zu erkennen und zu debuggen sein. <answer> <question> Warum kann Aliasing in der objektorientierten Programmierung zu Programmierfehlern führen? <question>"
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, so sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.
Wenn Variablen keine Objekte enthalten, sondern lediglich auf sie verweisen, wenn sie also Verweissemantik haben, ist es möglich, dass mehrere Variablen gleichzeitig dasselbe Objekt benennen. Das nennt man Aliasing. Das Aliasing ist eines der wichtigsten Phänomene der objektorientierten Programmierung; zugleich ist es leider nur wenig als solches bekannt. Versuchen Sie trotzdem, es sich stets bewusst zu machen — es wird Sie vor manch böser Überraschung bewahren.
Aliase, also weitere Namen für ein bereits benanntes Objekt, entstehen immer bei der Zuweisung. Dazu ist es notwendig, dass die Variable auf der linken Seite Verweissemantik hat. Da in SMALLTALK die Semantik von Variablen nicht mit der Variablendeklaration (siehe Kapitel 19) festgelegt wird, sondern von der Art eines Objekts abhängt, ist nicht immer klar, bei welcher Zuweisung ein Alias entsteht. Dabei kann beides, die fälschliche Annahme von Verweissemantik bei tatsächlicher Wertsemantik und die Entstehung von Aliasen, zu erheblichen (und schwer zu findenden) Programmierfehlern führen.
Nach den beiden Zuweisungen hat das eine Objekt, das der Compiler für #Smalltalk erzeugt, zwei Namen, nämlich x und y.
Das Aliasing ist zunächst erwünscht: Da jedes Objekt nur einmal im Speicher hinterlegt werden muss, ermöglicht es die extrem effiziente Informationsverarbeitung (es ist weder ein Kopieren notwendig, wenn ein Objekt weitergereicht werden soll, noch müssen die Änderungen an den verschiedenen Kopien zusammengeführt werden, die notwendig sind, wenn die Kopien immer noch dasselbe logische Objekt bezeichnen sollen). Doch diese Effizienz hat ihren Preis.
Dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt, kann nämlich unerwünscht sein und zu einem Programmierfehler führen. So könnte man beispielsweise bei den beiden Zuweisungen lediglich bezwecken wollen, dass Peter und Paul zuerst gleich heißen, z. B. weil sie Geschwister sind. Bei einer späteren Promotion von Paula fügt sie die Zeichen $D, $r und $. in den ihren Nachnamen repräsentierenden String ein, ändert also das entsprechende Objekt. Man hat nun sicher nicht beabsichtigt, dass das auch petersNachname betrifft, aber wenn die Änderung an einer weit entfernten Stelle im Programm erfolgt, ist die Identität der von petersNachname und paulasNachname benannten Objekte nicht mehr offensichtlich. Tatsächlich hat man es dann mit einem recht subtilen und schwer zu findenden Programmierfehler zu tun. Deswegen (und aufgrund etwas überzeugenderer Beispiele, die zu verwenden aber noch mehr Vorbereitung bedarf), sind in einigen SMALLTALK-Systemen alle auf Basis literaler Repräsentationen erzeugten Objekte als unveränderlich markiert (wenn Sie es nicht schon, wie beispielsweise Zahlen, von Haus aus sind), so dass Programmierfehler dieser Art vermieden werden. Sollte wie im obigen Beispiel eine Zuweisung mit Wertsemantik benötigt werden, so schreibt man statt Zeile 28 in SMALLTALK einfach x := petersNachname copy.
Dabei sorgt das hintangestellte ""copy"" dafür, dass von dem Objekt, das durch petersNachname bezeichnet wird, eine Kopie angefertigt wird, also ein neues Objekt, das dem alten gleicht (mehr zur Syntax und dazu, wofür ""copy"" steht, folgt unten). Nicht nötig wird das Kopieren, wenn ich die Änderung durch die Zuweisung eines neuen Objekts be-werkstellige, wie das beispielsweise in Beispiel 1.20 oder gar x := ""Peter Doe"" der Fall ist (wobei das Komma hier für die String-Konkatenation steht).
Fehler dieser Art sind häufig die Folge dessen, dass sich eine Programmiererin der aliasbildenden Wirkung der Zuweisung nicht bewusst war. Das ist insbesondere bei den Programmiererinnen der Fall, die nicht mit der objektorientierten Programmierung großgeworden sind, die insbesondere bei einer Zuweisung ""y := x"" das Kopieren des Inhalts der Variablen auf der rechten Seite (x) vermuten. Tatsächlich muss man in anderen Sprachen (wie beispielsweise PASCAL oder C) eine Variable explizit als Pointervariable deklarieren, um einen Alias bilden zu können. In SMALLTALK, genau wie in JAVA und C#, ist Aliasing jedoch der Regelfall und Kopie die Ausnahme. Wer das nicht verinnerlicht hat, schreibt höchstens zufällig korrekte Programme.","<answer> Der Abschnitt erklärt Aliasing im Kontext von SMALLTALK und wie Variablen in SMALLTALK standardmäßig Verweissemantik haben, was dazu führt, dass Aliasing häufig vorkommt. <answer> <question> In welchem Zusammenhang wird Aliasing in SMALLTALK erklärt? <question>"
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, so sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.
Wenn Variablen keine Objekte enthalten, sondern lediglich auf sie verweisen, wenn sie also Verweissemantik haben, ist es möglich, dass mehrere Variablen gleichzeitig dasselbe Objekt benennen. Das nennt man Aliasing. Das Aliasing ist eines der wichtigsten Phänomene der objektorientierten Programmierung; zugleich ist es leider nur wenig als solches bekannt. Versuchen Sie trotzdem, es sich stets bewusst zu machen — es wird Sie vor manch böser Überraschung bewahren.
Aliase, also weitere Namen für ein bereits benanntes Objekt, entstehen immer bei der Zuweisung. Dazu ist es notwendig, dass die Variable auf der linken Seite Verweissemantik hat. Da in SMALLTALK die Semantik von Variablen nicht mit der Variablendeklaration (siehe Kapitel 19) festgelegt wird, sondern von der Art eines Objekts abhängt, ist nicht immer klar, bei welcher Zuweisung ein Alias entsteht. Dabei kann beides, die fälschliche Annahme von Verweissemantik bei tatsächlicher Wertsemantik und die Entstehung von Aliasen, zu erheblichen (und schwer zu findenden) Programmierfehlern führen.
Nach den beiden Zuweisungen hat das eine Objekt, das der Compiler für #Smalltalk erzeugt, zwei Namen, nämlich x und y.
Das Aliasing ist zunächst erwünscht: Da jedes Objekt nur einmal im Speicher hinterlegt werden muss, ermöglicht es die extrem effiziente Informationsverarbeitung (es ist weder ein Kopieren notwendig, wenn ein Objekt weitergereicht werden soll, noch müssen die Änderungen an den verschiedenen Kopien zusammengeführt werden, die notwendig sind, wenn die Kopien immer noch dasselbe logische Objekt bezeichnen sollen). Doch diese Effizienz hat ihren Preis.
Dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt, kann nämlich unerwünscht sein und zu einem Programmierfehler führen. So könnte man beispielsweise bei den beiden Zuweisungen lediglich bezwecken wollen, dass Peter und Paul zuerst gleich heißen, z. B. weil sie Geschwister sind. Bei einer späteren Promotion von Paula fügt sie die Zeichen $D, $r und $. in den ihren Nachnamen repräsentierenden String ein, ändert also das entsprechende Objekt. Man hat nun sicher nicht beabsichtigt, dass das auch petersNachname betrifft, aber wenn die Änderung an einer weit entfernten Stelle im Programm erfolgt, ist die Identität der von petersNachname und paulasNachname benannten Objekte nicht mehr offensichtlich. Tatsächlich hat man es dann mit einem recht subtilen und schwer zu findenden Programmierfehler zu tun. Deswegen (und aufgrund etwas überzeugenderer Beispiele, die zu verwenden aber noch mehr Vorbereitung bedarf), sind in einigen SMALLTALK-Systemen alle auf Basis literaler Repräsentationen erzeugten Objekte als unveränderlich markiert (wenn Sie es nicht schon, wie beispielsweise Zahlen, von Haus aus sind), so dass Programmierfehler dieser Art vermieden werden. Sollte wie im obigen Beispiel eine Zuweisung mit Wertsemantik benötigt werden, so schreibt man statt Zeile 28 in SMALLTALK einfach x := petersNachname copy.
Dabei sorgt das hintangestellte ""copy"" dafür, dass von dem Objekt, das durch petersNachname bezeichnet wird, eine Kopie angefertigt wird, also ein neues Objekt, das dem alten gleicht (mehr zur Syntax und dazu, wofür ""copy"" steht, folgt unten). Nicht nötig wird das Kopieren, wenn ich die Änderung durch die Zuweisung eines neuen Objekts be-werkstellige, wie das beispielsweise in Beispiel 1.20 oder gar x := ""Peter Doe"" der Fall ist (wobei das Komma hier für die String-Konkatenation steht).
Fehler dieser Art sind häufig die Folge dessen, dass sich eine Programmiererin der aliasbildenden Wirkung der Zuweisung nicht bewusst war. Das ist insbesondere bei den Programmiererinnen der Fall, die nicht mit der objektorientierten Programmierung großgeworden sind, die insbesondere bei einer Zuweisung ""y := x"" das Kopieren des Inhalts der Variablen auf der rechten Seite (x) vermuten. Tatsächlich muss man in anderen Sprachen (wie beispielsweise PASCAL oder C) eine Variable explizit als Pointervariable deklarieren, um einen Alias bilden zu können. In SMALLTALK, genau wie in JAVA und C#, ist Aliasing jedoch der Regelfall und Kopie die Ausnahme. Wer das nicht verinnerlicht hat, schreibt höchstens zufällig korrekte Programme.","<answer> Aliasing ist zunächst erwünscht, da es die Effizienz der Informationsverarbeitung erhöht. Es ermöglicht das Teilen von Objekten ohne Kopieren. Allerdings kann Aliasing auch unerwünscht sein, wenn unerwartete Seiteneffekte auftreten, die schwer zu erkennen sind. <answer> <question> Warum kann das Aliasing in SMALLTALK sowohl erwünscht als auch unerwünscht sein? <question>"
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, so sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.
Wenn Variablen keine Objekte enthalten, sondern lediglich auf sie verweisen, wenn sie also Verweissemantik haben, ist es möglich, dass mehrere Variablen gleichzeitig dasselbe Objekt benennen. Das nennt man Aliasing. Das Aliasing ist eines der wichtigsten Phänomene der objektorientierten Programmierung; zugleich ist es leider nur wenig als solches bekannt. Versuchen Sie trotzdem, es sich stets bewusst zu machen — es wird Sie vor manch böser Überraschung bewahren.
Aliase, also weitere Namen für ein bereits benanntes Objekt, entstehen immer bei der Zuweisung. Dazu ist es notwendig, dass die Variable auf der linken Seite Verweissemantik hat. Da in SMALLTALK die Semantik von Variablen nicht mit der Variablendeklaration (siehe Kapitel 19) festgelegt wird, sondern von der Art eines Objekts abhängt, ist nicht immer klar, bei welcher Zuweisung ein Alias entsteht. Dabei kann beides, die fälschliche Annahme von Verweissemantik bei tatsächlicher Wertsemantik und die Entstehung von Aliasen, zu erheblichen (und schwer zu findenden) Programmierfehlern führen.
Nach den beiden Zuweisungen hat das eine Objekt, das der Compiler für #Smalltalk erzeugt, zwei Namen, nämlich x und y.
Das Aliasing ist zunächst erwünscht: Da jedes Objekt nur einmal im Speicher hinterlegt werden muss, ermöglicht es die extrem effiziente Informationsverarbeitung (es ist weder ein Kopieren notwendig, wenn ein Objekt weitergereicht werden soll, noch müssen die Änderungen an den verschiedenen Kopien zusammengeführt werden, die notwendig sind, wenn die Kopien immer noch dasselbe logische Objekt bezeichnen sollen). Doch diese Effizienz hat ihren Preis.
Dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt, kann nämlich unerwünscht sein und zu einem Programmierfehler führen. So könnte man beispielsweise bei den beiden Zuweisungen lediglich bezwecken wollen, dass Peter und Paul zuerst gleich heißen, z. B. weil sie Geschwister sind. Bei einer späteren Promotion von Paula fügt sie die Zeichen $D, $r und $. in den ihren Nachnamen repräsentierenden String ein, ändert also das entsprechende Objekt. Man hat nun sicher nicht beabsichtigt, dass das auch petersNachname betrifft, aber wenn die Änderung an einer weit entfernten Stelle im Programm erfolgt, ist die Identität der von petersNachname und paulasNachname benannten Objekte nicht mehr offensichtlich. Tatsächlich hat man es dann mit einem recht subtilen und schwer zu findenden Programmierfehler zu tun. Deswegen (und aufgrund etwas überzeugenderer Beispiele, die zu verwenden aber noch mehr Vorbereitung bedarf), sind in einigen SMALLTALK-Systemen alle auf Basis literaler Repräsentationen erzeugten Objekte als unveränderlich markiert (wenn Sie es nicht schon, wie beispielsweise Zahlen, von Haus aus sind), so dass Programmierfehler dieser Art vermieden werden. Sollte wie im obigen Beispiel eine Zuweisung mit Wertsemantik benötigt werden, so schreibt man statt Zeile 28 in SMALLTALK einfach x := petersNachname copy.
Dabei sorgt das hintangestellte ""copy"" dafür, dass von dem Objekt, das durch petersNachname bezeichnet wird, eine Kopie angefertigt wird, also ein neues Objekt, das dem alten gleicht (mehr zur Syntax und dazu, wofür ""copy"" steht, folgt unten). Nicht nötig wird das Kopieren, wenn ich die Änderung durch die Zuweisung eines neuen Objekts be-werkstellige, wie das beispielsweise in Beispiel 1.20 oder gar x := ""Peter Doe"" der Fall ist (wobei das Komma hier für die String-Konkatenation steht).
Fehler dieser Art sind häufig die Folge dessen, dass sich eine Programmiererin der aliasbildenden Wirkung der Zuweisung nicht bewusst war. Das ist insbesondere bei den Programmiererinnen der Fall, die nicht mit der objektorientierten Programmierung großgeworden sind, die insbesondere bei einer Zuweisung ""y := x"" das Kopieren des Inhalts der Variablen auf der rechten Seite (x) vermuten. Tatsächlich muss man in anderen Sprachen (wie beispielsweise PASCAL oder C) eine Variable explizit als Pointervariable deklarieren, um einen Alias bilden zu können. In SMALLTALK, genau wie in JAVA und C#, ist Aliasing jedoch der Regelfall und Kopie die Ausnahme. Wer das nicht verinnerlicht hat, schreibt höchstens zufällig korrekte Programme.","<answer> In einigen SMALLTALK-Systemen werden auf Basis literaler Repräsentationen erzeugte Objekte als unveränderlich markiert, um Programmierfehler durch unerwartetes Aliasing zu vermeiden. Wenn eine Zuweisung mit Wertsemantik benötigt wird, kann das Kopieren des Objekts verwendet werden. <answer> <question> Wie kann man in SMALLTALK verhindern, dass Aliasing zu unerwünschten Seiteneffekten führt? <question>"
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, so sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.
Wenn Variablen keine Objekte enthalten, sondern lediglich auf sie verweisen, wenn sie also Verweissemantik haben, ist es möglich, dass mehrere Variablen gleichzeitig dasselbe Objekt benennen. Das nennt man Aliasing. Das Aliasing ist eines der wichtigsten Phänomene der objektorientierten Programmierung; zugleich ist es leider nur wenig als solches bekannt. Versuchen Sie trotzdem, es sich stets bewusst zu machen — es wird Sie vor manch böser Überraschung bewahren.
Aliase, also weitere Namen für ein bereits benanntes Objekt, entstehen immer bei der Zuweisung. Dazu ist es notwendig, dass die Variable auf der linken Seite Verweissemantik hat. Da in SMALLTALK die Semantik von Variablen nicht mit der Variablendeklaration (siehe Kapitel 19) festgelegt wird, sondern von der Art eines Objekts abhängt, ist nicht immer klar, bei welcher Zuweisung ein Alias entsteht. Dabei kann beides, die fälschliche Annahme von Verweissemantik bei tatsächlicher Wertsemantik und die Entstehung von Aliasen, zu erheblichen (und schwer zu findenden) Programmierfehlern führen.
Nach den beiden Zuweisungen hat das eine Objekt, das der Compiler für #Smalltalk erzeugt, zwei Namen, nämlich x und y.
Das Aliasing ist zunächst erwünscht: Da jedes Objekt nur einmal im Speicher hinterlegt werden muss, ermöglicht es die extrem effiziente Informationsverarbeitung (es ist weder ein Kopieren notwendig, wenn ein Objekt weitergereicht werden soll, noch müssen die Änderungen an den verschiedenen Kopien zusammengeführt werden, die notwendig sind, wenn die Kopien immer noch dasselbe logische Objekt bezeichnen sollen). Doch diese Effizienz hat ihren Preis.
Dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt, kann nämlich unerwünscht sein und zu einem Programmierfehler führen. So könnte man beispielsweise bei den beiden Zuweisungen lediglich bezwecken wollen, dass Peter und Paul zuerst gleich heißen, z. B. weil sie Geschwister sind. Bei einer späteren Promotion von Paula fügt sie die Zeichen $D, $r und $. in den ihren Nachnamen repräsentierenden String ein, ändert also das entsprechende Objekt. Man hat nun sicher nicht beabsichtigt, dass das auch petersNachname betrifft, aber wenn die Änderung an einer weit entfernten Stelle im Programm erfolgt, ist die Identität der von petersNachname und paulasNachname benannten Objekte nicht mehr offensichtlich. Tatsächlich hat man es dann mit einem recht subtilen und schwer zu findenden Programmierfehler zu tun. Deswegen (und aufgrund etwas überzeugenderer Beispiele, die zu verwenden aber noch mehr Vorbereitung bedarf), sind in einigen SMALLTALK-Systemen alle auf Basis literaler Repräsentationen erzeugten Objekte als unveränderlich markiert (wenn Sie es nicht schon, wie beispielsweise Zahlen, von Haus aus sind), so dass Programmierfehler dieser Art vermieden werden. Sollte wie im obigen Beispiel eine Zuweisung mit Wertsemantik benötigt werden, so schreibt man statt Zeile 28 in SMALLTALK einfach x := petersNachname copy.
Dabei sorgt das hintangestellte ""copy"" dafür, dass von dem Objekt, das durch petersNachname bezeichnet wird, eine Kopie angefertigt wird, also ein neues Objekt, das dem alten gleicht (mehr zur Syntax und dazu, wofür ""copy"" steht, folgt unten). Nicht nötig wird das Kopieren, wenn ich die Änderung durch die Zuweisung eines neuen Objekts be-werkstellige, wie das beispielsweise in Beispiel 1.20 oder gar x := ""Peter Doe"" der Fall ist (wobei das Komma hier für die String-Konkatenation steht).
Fehler dieser Art sind häufig die Folge dessen, dass sich eine Programmiererin der aliasbildenden Wirkung der Zuweisung nicht bewusst war. Das ist insbesondere bei den Programmiererinnen der Fall, die nicht mit der objektorientierten Programmierung großgeworden sind, die insbesondere bei einer Zuweisung ""y := x"" das Kopieren des Inhalts der Variablen auf der rechten Seite (x) vermuten. Tatsächlich muss man in anderen Sprachen (wie beispielsweise PASCAL oder C) eine Variable explizit als Pointervariable deklarieren, um einen Alias bilden zu können. In SMALLTALK, genau wie in JAVA und C#, ist Aliasing jedoch der Regelfall und Kopie die Ausnahme. Wer das nicht verinnerlicht hat, schreibt höchstens zufällig korrekte Programme.","<answer> In SMALLTALK kann das Schlüsselwort ""copy"" verwendet werden, um von einem Objekt eine Kopie anzufertigen, anstatt eine Referenz auf dasselbe Objekt zu erstellen. Dies verhindert Aliasing. <answer> <question> Welche Schlüsselwörter oder Techniken werden in SMALLTALK verwendet, um das Kopieren eines Objekts anzufordern? <question>"
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, so sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.
Wenn Variablen keine Objekte enthalten, sondern lediglich auf sie verweisen, wenn sie also Verweissemantik haben, ist es möglich, dass mehrere Variablen gleichzeitig dasselbe Objekt benennen. Das nennt man Aliasing. Das Aliasing ist eines der wichtigsten Phänomene der objektorientierten Programmierung; zugleich ist es leider nur wenig als solches bekannt. Versuchen Sie trotzdem, es sich stets bewusst zu machen — es wird Sie vor manch böser Überraschung bewahren.
Aliase, also weitere Namen für ein bereits benanntes Objekt, entstehen immer bei der Zuweisung. Dazu ist es notwendig, dass die Variable auf der linken Seite Verweissemantik hat. Da in SMALLTALK die Semantik von Variablen nicht mit der Variablendeklaration (siehe Kapitel 19) festgelegt wird, sondern von der Art eines Objekts abhängt, ist nicht immer klar, bei welcher Zuweisung ein Alias entsteht. Dabei kann beides, die fälschliche Annahme von Verweissemantik bei tatsächlicher Wertsemantik und die Entstehung von Aliasen, zu erheblichen (und schwer zu findenden) Programmierfehlern führen.
Nach den beiden Zuweisungen hat das eine Objekt, das der Compiler für #Smalltalk erzeugt, zwei Namen, nämlich x und y.
Das Aliasing ist zunächst erwünscht: Da jedes Objekt nur einmal im Speicher hinterlegt werden muss, ermöglicht es die extrem effiziente Informationsverarbeitung (es ist weder ein Kopieren notwendig, wenn ein Objekt weitergereicht werden soll, noch müssen die Änderungen an den verschiedenen Kopien zusammengeführt werden, die notwendig sind, wenn die Kopien immer noch dasselbe logische Objekt bezeichnen sollen). Doch diese Effizienz hat ihren Preis.
Dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt, kann nämlich unerwünscht sein und zu einem Programmierfehler führen. So könnte man beispielsweise bei den beiden Zuweisungen lediglich bezwecken wollen, dass Peter und Paul zuerst gleich heißen, z. B. weil sie Geschwister sind. Bei einer späteren Promotion von Paula fügt sie die Zeichen $D, $r und $. in den ihren Nachnamen repräsentierenden String ein, ändert also das entsprechende Objekt. Man hat nun sicher nicht beabsichtigt, dass das auch petersNachname betrifft, aber wenn die Änderung an einer weit entfernten Stelle im Programm erfolgt, ist die Identität der von petersNachname und paulasNachname benannten Objekte nicht mehr offensichtlich. Tatsächlich hat man es dann mit einem recht subtilen und schwer zu findenden Programmierfehler zu tun. Deswegen (und aufgrund etwas überzeugenderer Beispiele, die zu verwenden aber noch mehr Vorbereitung bedarf), sind in einigen SMALLTALK-Systemen alle auf Basis literaler Repräsentationen erzeugten Objekte als unveränderlich markiert (wenn Sie es nicht schon, wie beispielsweise Zahlen, von Haus aus sind), so dass Programmierfehler dieser Art vermieden werden. Sollte wie im obigen Beispiel eine Zuweisung mit Wertsemantik benötigt werden, so schreibt man statt Zeile 28 in SMALLTALK einfach x := petersNachname copy.
Dabei sorgt das hintangestellte ""copy"" dafür, dass von dem Objekt, das durch petersNachname bezeichnet wird, eine Kopie angefertigt wird, also ein neues Objekt, das dem alten gleicht (mehr zur Syntax und dazu, wofür ""copy"" steht, folgt unten). Nicht nötig wird das Kopieren, wenn ich die Änderung durch die Zuweisung eines neuen Objekts be-werkstellige, wie das beispielsweise in Beispiel 1.20 oder gar x := ""Peter Doe"" der Fall ist (wobei das Komma hier für die String-Konkatenation steht).
Fehler dieser Art sind häufig die Folge dessen, dass sich eine Programmiererin der aliasbildenden Wirkung der Zuweisung nicht bewusst war. Das ist insbesondere bei den Programmiererinnen der Fall, die nicht mit der objektorientierten Programmierung großgeworden sind, die insbesondere bei einer Zuweisung ""y := x"" das Kopieren des Inhalts der Variablen auf der rechten Seite (x) vermuten. Tatsächlich muss man in anderen Sprachen (wie beispielsweise PASCAL oder C) eine Variable explizit als Pointervariable deklarieren, um einen Alias bilden zu können. In SMALLTALK, genau wie in JAVA und C#, ist Aliasing jedoch der Regelfall und Kopie die Ausnahme. Wer das nicht verinnerlicht hat, schreibt höchstens zufällig korrekte Programme.","<answer> Es ist wichtig, sich der aliasbildenden Wirkung der Zuweisung bewusst zu sein, da dies in Sprachen wie SMALLTALK die Standardverhalten ist. Programmierer sollten verstehen, dass Änderungen an einem Alias alle Aliase desselben Objekts betreffen können, was zu schwer zu findenden Programmierfehlern führen kann. <answer> <question> Warum ist es wichtig, sich der aliasbildenden Wirkung der Zuweisung bewusst zu sein? <question>"
"Spätestens mit der Verfügbarkeit sogenannter Hochsprachen und den gleichzeitig immer größer werdenden Programmen kam die Frage auf, was ""gute Programmierung"" ausmacht. Eines der Hauptprobleme schlechter Programmierung war schnell identifiziert: die große Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf. Eine gute Programmiererin hatte ihre Programme so zu schreiben, dass der Programmtext und der Programmablauf einander möglichst ähnlich waren, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zuließ. Man wollte also von den Programmiererinnen Klartext.
Ebenso schnell wie das Problem wurde sein Hauptverursacher ausgemacht: die Goto-Anweisung. Sie erlaubt Sprünge von beliebigen Stellen eines Programms an beliebige andere Stellen des Programms und durchbricht dabei auf brutale Art und Weise das äußerst nützliche Lokalitätsprinzip von Programmen: Dinge, die zusammengehören, stehen im Programmtext beieinander. So, und nur so, ist bei der Inspektion des Programmtextes unmittelbar klar, wie man an eine Stelle im Programm gelangt ist und, mindestens ebenso wichtig, wie eine Variable ihren Wert bekommen hat.
Zur Veranschaulichung soll die nachfolgende Abbildung dienen, die einen Programmtext als eine Folge von Anweisungen stilisiert. Anweisungen sind durch Kreise dargestellt, die (textuelle) Folge der Anweisungen im Programmtext durch die kleinen Pfeile. Ohne besondere, den Kontrollfluss beeinflussende Anweisungen entspricht die (dynamische) Reihenfolge der Ausführung der (statischen) Folge der Anweisungen im Programmtext. Bei Betrachtung des stärker umrandeten, mittleren Kreises (der entsprechenden Anweisung), z. B. während einer Debug-Sitzung, ist daher aus dem unmittelbaren Kontext heraus (der Ellipse; Lokalitätsprinzip!) klar, welche Anweisung davor ausgeführt wurde und welche als nächstes drankommt. Alles ist in bester Ordnung.
Handelt es sich nun bei einer der Anweisungen um ein Goto, dann ist die Sachlage längst nicht mehr so klar. Man hat vielmehr die folgenden Fälle zu unterscheiden: Die betrachtete Anweisung ist selbst ein Goto: In diesem Fall ist zwar klar, woher der Programmfluss kommt, und auch, wohin er geht, letzteres aber nur mit einer gewissen Einschränkung — das Ziel ist nicht der Nachbar im Programmtext, sondern befindet sich außerhalb des gewählten Kontextes. Nun kann man den Kontext natürlich so wählen, dass er das Ziel enthält, und kurze Sprünge sind vielleicht auch so innerhalb des betrachteten Kontextes möglich; allgemein gilt jedoch, dass jede gewählte Lokalität durch einen Sprung verletzt werden kann. Immerhin lässt sich aber das Ziel des Sprungs aus dem Kontext erkennen und der Kontext entsprechend wechseln. Die betrachtete Anweisung ist Ziel eines Gotos: Hier ist die Sachlage schon schwieriger. Der Programmfluss scheint bei Betrachtung des Kontextes genau wie im ersten Beispiel zu verlaufen. Wenn man den Kontext allerdings vergrößert, lernt man, dass die dynamischen Vorgänger in der betrachteten Anweisung auch andere sein können. Der Kontext selbst gibt jedoch keinen Hinweis darauf; zwar kann das Vorhandensein eines Sprunglabels einen Hinweis darauf geben, dass die so markierte Anweisung Ziel eines Gotos sein kann, sie muss es aber nicht; in Sprachen wie BASIC beispielsweise (damals noch weit verbreitet), in denen Zeilennummern gültige Sprungziele sind, muss jede Anweisung als mit einem Label versehen betrachtet werden und kann somit Sprungziel von irgendwoher sein. Außerdem kann eine Anweisung von verschiedenen Gotos angesprungen werden, so dass unklar bleibt, welches die (zeitliche) Vorgängeranweisung war. Die betrachtete Anweisung ist unmittelbare Nachfolgerin eines Gotos: Hier ist zwar aus dem Kontext ersichtlich, dass die statischen Vorgänger nicht die dynamischen sein können, ansonsten kann man aber nur mutmaßen, dass es sich vielleicht um toten Code handeln könnte (also um Code, der niemals ausgeführt wird). Es kann nämlich die Anweisung Sprungziel von Gotos außerhalb des Kontexts sein (wie in allen anderen Fällen auch).
Fazit: Die Verwendung von Goto-Anweisungen verursacht ein hohes Maß an Nichtwissen bei der Interpretation von Quelltext. Speziell beim Debugging von Programmen ist der Blick in den Quelltext des Programms so nur sehr bedingt von Nutzen. Von daher, so der allgemeine Konsens, ist die Benutzung von Gotos zu vermeiden.
Wenn man also kein Goto benutzen darf, wie steuert man dann den Ablauf von Programmen? Die sogenannte strukturierte Programmierung sieht dafür neben der Sequenz von Anweisungen (ausgedrückt durch die unmittelbare Nachbarschaft im Programmtext) die Verzweigung, die Wiederholung und den Unterprogrammaufruf vor. Von diesen behalten die ersten beiden das Lokalitätsprinzip bei, solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife, die damit ausgedrückt wird, ausdehnt. Für den Unterprogrammaufruf gilt das jedoch nicht mehr: Schon weil ein Unterprogramm in der Regel von mehreren Stellen eines Programms aus aufgerufen werden kann und weil diese Stellen nicht automatisch denselben Kontext haben, wird hier das Lokalitätsprinzip durchbrochen. Dies ist aber unvermeidlich, und man tröstet sich damit, dass ein Unterprogramm, genauer eine Prozedur oder eine Funktion, immer genau an die Stelle zurückkehrt, von der es aufgerufen wurde.
Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger um die Return-Anweisung des aufgerufenen Unterprogramms handeln muss. Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterprogramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächliche Parameter übergeben wurden, und wenn zudem das Unterprogramm bekannte Vor- und Nachbedingungen enthält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein großer Nutzen gegenüber: Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anweisungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche Aufrufkontexte gibt (das sog. Inlining, das manche Compiler aus Optimierungsgründen durchführen). Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie getrennt untersuchen und verstehen kann.
Besonders der zweite Punkt ist wichtig: Aus Sicht der Programmiererin sollte es nämlich reichen, zu wissen, was ein Unterprogramm tut, um es korrekt benutzen zu können. Sie muss also insbesondere nicht in das Unterprogramm hineinschauen, also seine Anweisungen inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird — es reicht dann, zu wissen, mit welchen Parametern es versorgt wird, und die sind ihr per formale Parameterdeklaration bekannt. (Voraussetzung dieser Argumentation ist jedoch, dass es keine globalen Variablen gibt, die eine gegenseitige Beeinflussung von Aufrufstelle und Unterprogramm an den tatsächlichen und formalen Parametern vorbei erlauben. Diese globalen Variablen sind jedoch mindestens so sehr verpönt wie das Goto.)
Bei der objektorientierten Programmierung hat man es zunächst mit einer leicht veränderten Situation zu tun. Hier sind nämlich nicht allein das Vermeiden von doppeltem Code sowie die stufenweise Verfeinerung Kriterien für die Aufteilung in Unterprogramme, sondern auch die Disziplin, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert. Typische objektorientierte Programme teilen daher die Implementierung größerer Funktionen nicht nur in kleinere auf, sondern verteilen diese auch noch über viele Klassen. Auch wenn es sich dabei stets nur um Unterprogrammaufrufe handelt, die allen obengenannten Anforderungen genügen, so erfolgen die zum Programmverstehen notwendigen Kontextwechsel doch in so kurzer Folge, dass man schnell den Überblick darüber verliert.
Nun ergibt sich aber mit der Einführung von dynamisch gebundenen Unterprogrammaufrufen, wie sie ja für die objektorientierte Programmierung prägend sind, das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht: Wie bereits in Kurseinheit 1, Abschnitt 4.3.2 bemerkt, verbindet das dynamische Binden den Unterprogrammaufruf mit der Verzweigung.
Es ist an der Stelle der betrachteten Anweisung nicht klar, von woher der in der Anweisung zuvor angestoßene Unterprogrammaufruf zurückkehrt — es könnte von jeder Implementierung der im Gosub genannten Methode sein. Um das Sprungziel und damit die Return-Anweisung, die unmittelbarer Vorgänger war, zu identifizieren, muss man die Klasse des Empfängerobjekts kennen, also die Klasse des Werts der Variable, auf der die Methode aufgerufen wurde. Das ist aber in der Regel nur auf Basis einer vollständigen Programmanalyse bestimmbar, die sich nicht lokal durchführen lässt. Das Lokalitätsprinzip wird also durch das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein.
Dieser Umstand hat dazu geführt, dass das dynamische Binden von Skeptikerinnen und Gegnerinnen der objektorientierten Programmierung schon als eine Art Goto der 90er Jahre betrachtet wurde. Dieser Vergleich ist jedoch nicht ganz fair, weil, genau wie beim statisch gebundenen Unterprogrammaufruf, die Aufruferin ja gar nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen — es reicht zu wissen, welchen Vertrag die aufgerufene Methode (das aufgerufene Unterprogramm) erfüllt. Dies sollte nach den Regeln des Subtyping (Abschnitt 54.2) stets unabhängig vom vertragserfüllenden Objekt sein.
Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.
Es ist wohl unbestritten, dass objektorientierte Programme schwerer zu tracen und zu debuggen sind als prozedurale. Wie schon bei den statisch gebundenen Unterprogrammaufrufen (die ja ebenfalls ein Problem darstellen können) ist die Frage jedoch, ob das, was man durch das dynamische Binden hinzugewinnt, den Preis aufwiegt. Während diese Frage jede für sich selbst entscheiden muss, so scheint die Antwort für viele Programmiererinnen — weit mehr als eine Generation nach dem Aufkommen der Objektorientierung und damit vor dem Hintergrund genügend praktischer Erfahrung — überwiegend positiv zu sein. Man darf aber auch die Neinsagerinnen nicht als Ewiggestrige abstempeln — sie mögen gute Gründe haben.","<answer> Die Frage nach ""guter Programmierung"" wurde relevant, weil mit der Verfügbarkeit von Hochsprachen und immer größer werdenden Programmen die Diskrepanz zwischen dem statischen, linearen Programmtext und dem dynamischen, stark verzweigten Programmablauf immer offensichtlicher wurde. <answer> <question> Warum wurde die Frage nach ""guter Programmierung"" relevant, besonders mit der Einführung von Hochsprachen und großen Programmen? <question>"
"Spätestens mit der Verfügbarkeit sogenannter Hochsprachen und den gleichzeitig immer größer werdenden Programmen kam die Frage auf, was ""gute Programmierung"" ausmacht. Eines der Hauptprobleme schlechter Programmierung war schnell identifiziert: die große Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf. Eine gute Programmiererin hatte ihre Programme so zu schreiben, dass der Programmtext und der Programmablauf einander möglichst ähnlich waren, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zuließ. Man wollte also von den Programmiererinnen Klartext.
Ebenso schnell wie das Problem wurde sein Hauptverursacher ausgemacht: die Goto-Anweisung. Sie erlaubt Sprünge von beliebigen Stellen eines Programms an beliebige andere Stellen des Programms und durchbricht dabei auf brutale Art und Weise das äußerst nützliche Lokalitätsprinzip von Programmen: Dinge, die zusammengehören, stehen im Programmtext beieinander. So, und nur so, ist bei der Inspektion des Programmtextes unmittelbar klar, wie man an eine Stelle im Programm gelangt ist und, mindestens ebenso wichtig, wie eine Variable ihren Wert bekommen hat.
Zur Veranschaulichung soll die nachfolgende Abbildung dienen, die einen Programmtext als eine Folge von Anweisungen stilisiert. Anweisungen sind durch Kreise dargestellt, die (textuelle) Folge der Anweisungen im Programmtext durch die kleinen Pfeile. Ohne besondere, den Kontrollfluss beeinflussende Anweisungen entspricht die (dynamische) Reihenfolge der Ausführung der (statischen) Folge der Anweisungen im Programmtext. Bei Betrachtung des stärker umrandeten, mittleren Kreises (der entsprechenden Anweisung), z. B. während einer Debug-Sitzung, ist daher aus dem unmittelbaren Kontext heraus (der Ellipse; Lokalitätsprinzip!) klar, welche Anweisung davor ausgeführt wurde und welche als nächstes drankommt. Alles ist in bester Ordnung.
Handelt es sich nun bei einer der Anweisungen um ein Goto, dann ist die Sachlage längst nicht mehr so klar. Man hat vielmehr die folgenden Fälle zu unterscheiden: Die betrachtete Anweisung ist selbst ein Goto: In diesem Fall ist zwar klar, woher der Programmfluss kommt, und auch, wohin er geht, letzteres aber nur mit einer gewissen Einschränkung — das Ziel ist nicht der Nachbar im Programmtext, sondern befindet sich außerhalb des gewählten Kontextes. Nun kann man den Kontext natürlich so wählen, dass er das Ziel enthält, und kurze Sprünge sind vielleicht auch so innerhalb des betrachteten Kontextes möglich; allgemein gilt jedoch, dass jede gewählte Lokalität durch einen Sprung verletzt werden kann. Immerhin lässt sich aber das Ziel des Sprungs aus dem Kontext erkennen und der Kontext entsprechend wechseln. Die betrachtete Anweisung ist Ziel eines Gotos: Hier ist die Sachlage schon schwieriger. Der Programmfluss scheint bei Betrachtung des Kontextes genau wie im ersten Beispiel zu verlaufen. Wenn man den Kontext allerdings vergrößert, lernt man, dass die dynamischen Vorgänger in der betrachteten Anweisung auch andere sein können. Der Kontext selbst gibt jedoch keinen Hinweis darauf; zwar kann das Vorhandensein eines Sprunglabels einen Hinweis darauf geben, dass die so markierte Anweisung Ziel eines Gotos sein kann, sie muss es aber nicht; in Sprachen wie BASIC beispielsweise (damals noch weit verbreitet), in denen Zeilennummern gültige Sprungziele sind, muss jede Anweisung als mit einem Label versehen betrachtet werden und kann somit Sprungziel von irgendwoher sein. Außerdem kann eine Anweisung von verschiedenen Gotos angesprungen werden, so dass unklar bleibt, welches die (zeitliche) Vorgängeranweisung war. Die betrachtete Anweisung ist unmittelbare Nachfolgerin eines Gotos: Hier ist zwar aus dem Kontext ersichtlich, dass die statischen Vorgänger nicht die dynamischen sein können, ansonsten kann man aber nur mutmaßen, dass es sich vielleicht um toten Code handeln könnte (also um Code, der niemals ausgeführt wird). Es kann nämlich die Anweisung Sprungziel von Gotos außerhalb des Kontexts sein (wie in allen anderen Fällen auch).
Fazit: Die Verwendung von Goto-Anweisungen verursacht ein hohes Maß an Nichtwissen bei der Interpretation von Quelltext. Speziell beim Debugging von Programmen ist der Blick in den Quelltext des Programms so nur sehr bedingt von Nutzen. Von daher, so der allgemeine Konsens, ist die Benutzung von Gotos zu vermeiden.
Wenn man also kein Goto benutzen darf, wie steuert man dann den Ablauf von Programmen? Die sogenannte strukturierte Programmierung sieht dafür neben der Sequenz von Anweisungen (ausgedrückt durch die unmittelbare Nachbarschaft im Programmtext) die Verzweigung, die Wiederholung und den Unterprogrammaufruf vor. Von diesen behalten die ersten beiden das Lokalitätsprinzip bei, solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife, die damit ausgedrückt wird, ausdehnt. Für den Unterprogrammaufruf gilt das jedoch nicht mehr: Schon weil ein Unterprogramm in der Regel von mehreren Stellen eines Programms aus aufgerufen werden kann und weil diese Stellen nicht automatisch denselben Kontext haben, wird hier das Lokalitätsprinzip durchbrochen. Dies ist aber unvermeidlich, und man tröstet sich damit, dass ein Unterprogramm, genauer eine Prozedur oder eine Funktion, immer genau an die Stelle zurückkehrt, von der es aufgerufen wurde.
Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger um die Return-Anweisung des aufgerufenen Unterprogramms handeln muss. Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterprogramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächliche Parameter übergeben wurden, und wenn zudem das Unterprogramm bekannte Vor- und Nachbedingungen enthält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein großer Nutzen gegenüber: Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anweisungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche Aufrufkontexte gibt (das sog. Inlining, das manche Compiler aus Optimierungsgründen durchführen). Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie getrennt untersuchen und verstehen kann.
Besonders der zweite Punkt ist wichtig: Aus Sicht der Programmiererin sollte es nämlich reichen, zu wissen, was ein Unterprogramm tut, um es korrekt benutzen zu können. Sie muss also insbesondere nicht in das Unterprogramm hineinschauen, also seine Anweisungen inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird — es reicht dann, zu wissen, mit welchen Parametern es versorgt wird, und die sind ihr per formale Parameterdeklaration bekannt. (Voraussetzung dieser Argumentation ist jedoch, dass es keine globalen Variablen gibt, die eine gegenseitige Beeinflussung von Aufrufstelle und Unterprogramm an den tatsächlichen und formalen Parametern vorbei erlauben. Diese globalen Variablen sind jedoch mindestens so sehr verpönt wie das Goto.)
Bei der objektorientierten Programmierung hat man es zunächst mit einer leicht veränderten Situation zu tun. Hier sind nämlich nicht allein das Vermeiden von doppeltem Code sowie die stufenweise Verfeinerung Kriterien für die Aufteilung in Unterprogramme, sondern auch die Disziplin, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert. Typische objektorientierte Programme teilen daher die Implementierung größerer Funktionen nicht nur in kleinere auf, sondern verteilen diese auch noch über viele Klassen. Auch wenn es sich dabei stets nur um Unterprogrammaufrufe handelt, die allen obengenannten Anforderungen genügen, so erfolgen die zum Programmverstehen notwendigen Kontextwechsel doch in so kurzer Folge, dass man schnell den Überblick darüber verliert.
Nun ergibt sich aber mit der Einführung von dynamisch gebundenen Unterprogrammaufrufen, wie sie ja für die objektorientierte Programmierung prägend sind, das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht: Wie bereits in Kurseinheit 1, Abschnitt 4.3.2 bemerkt, verbindet das dynamische Binden den Unterprogrammaufruf mit der Verzweigung.
Es ist an der Stelle der betrachteten Anweisung nicht klar, von woher der in der Anweisung zuvor angestoßene Unterprogrammaufruf zurückkehrt — es könnte von jeder Implementierung der im Gosub genannten Methode sein. Um das Sprungziel und damit die Return-Anweisung, die unmittelbarer Vorgänger war, zu identifizieren, muss man die Klasse des Empfängerobjekts kennen, also die Klasse des Werts der Variable, auf der die Methode aufgerufen wurde. Das ist aber in der Regel nur auf Basis einer vollständigen Programmanalyse bestimmbar, die sich nicht lokal durchführen lässt. Das Lokalitätsprinzip wird also durch das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein.
Dieser Umstand hat dazu geführt, dass das dynamische Binden von Skeptikerinnen und Gegnerinnen der objektorientierten Programmierung schon als eine Art Goto der 90er Jahre betrachtet wurde. Dieser Vergleich ist jedoch nicht ganz fair, weil, genau wie beim statisch gebundenen Unterprogrammaufruf, die Aufruferin ja gar nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen — es reicht zu wissen, welchen Vertrag die aufgerufene Methode (das aufgerufene Unterprogramm) erfüllt. Dies sollte nach den Regeln des Subtyping (Abschnitt 54.2) stets unabhängig vom vertragserfüllenden Objekt sein.
Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.
Es ist wohl unbestritten, dass objektorientierte Programme schwerer zu tracen und zu debuggen sind als prozedurale. Wie schon bei den statisch gebundenen Unterprogrammaufrufen (die ja ebenfalls ein Problem darstellen können) ist die Frage jedoch, ob das, was man durch das dynamische Binden hinzugewinnt, den Preis aufwiegt. Während diese Frage jede für sich selbst entscheiden muss, so scheint die Antwort für viele Programmiererinnen — weit mehr als eine Generation nach dem Aufkommen der Objektorientierung und damit vor dem Hintergrund genügend praktischer Erfahrung — überwiegend positiv zu sein. Man darf aber auch die Neinsagerinnen nicht als Ewiggestrige abstempeln — sie mögen gute Gründe haben.","<answer> Das Hauptproblem war die große Diskrepanz zwischen dem statischen Programmtext und dem dynamischen Programmablauf. Dieses Problem wurde hauptsächlich durch die Verwendung der Goto-Anweisung identifiziert. <answer> <question> Was war das Hauptproblem, das schlechte Programmierung verursachte, und wie wurde es identifiziert? <question>"
"Spätestens mit der Verfügbarkeit sogenannter Hochsprachen und den gleichzeitig immer größer werdenden Programmen kam die Frage auf, was ""gute Programmierung"" ausmacht. Eines der Hauptprobleme schlechter Programmierung war schnell identifiziert: die große Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf. Eine gute Programmiererin hatte ihre Programme so zu schreiben, dass der Programmtext und der Programmablauf einander möglichst ähnlich waren, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zuließ. Man wollte also von den Programmiererinnen Klartext.
Ebenso schnell wie das Problem wurde sein Hauptverursacher ausgemacht: die Goto-Anweisung. Sie erlaubt Sprünge von beliebigen Stellen eines Programms an beliebige andere Stellen des Programms und durchbricht dabei auf brutale Art und Weise das äußerst nützliche Lokalitätsprinzip von Programmen: Dinge, die zusammengehören, stehen im Programmtext beieinander. So, und nur so, ist bei der Inspektion des Programmtextes unmittelbar klar, wie man an eine Stelle im Programm gelangt ist und, mindestens ebenso wichtig, wie eine Variable ihren Wert bekommen hat.
Zur Veranschaulichung soll die nachfolgende Abbildung dienen, die einen Programmtext als eine Folge von Anweisungen stilisiert. Anweisungen sind durch Kreise dargestellt, die (textuelle) Folge der Anweisungen im Programmtext durch die kleinen Pfeile. Ohne besondere, den Kontrollfluss beeinflussende Anweisungen entspricht die (dynamische) Reihenfolge der Ausführung der (statischen) Folge der Anweisungen im Programmtext. Bei Betrachtung des stärker umrandeten, mittleren Kreises (der entsprechenden Anweisung), z. B. während einer Debug-Sitzung, ist daher aus dem unmittelbaren Kontext heraus (der Ellipse; Lokalitätsprinzip!) klar, welche Anweisung davor ausgeführt wurde und welche als nächstes drankommt. Alles ist in bester Ordnung.
Handelt es sich nun bei einer der Anweisungen um ein Goto, dann ist die Sachlage längst nicht mehr so klar. Man hat vielmehr die folgenden Fälle zu unterscheiden: Die betrachtete Anweisung ist selbst ein Goto: In diesem Fall ist zwar klar, woher der Programmfluss kommt, und auch, wohin er geht, letzteres aber nur mit einer gewissen Einschränkung — das Ziel ist nicht der Nachbar im Programmtext, sondern befindet sich außerhalb des gewählten Kontextes. Nun kann man den Kontext natürlich so wählen, dass er das Ziel enthält, und kurze Sprünge sind vielleicht auch so innerhalb des betrachteten Kontextes möglich; allgemein gilt jedoch, dass jede gewählte Lokalität durch einen Sprung verletzt werden kann. Immerhin lässt sich aber das Ziel des Sprungs aus dem Kontext erkennen und der Kontext entsprechend wechseln. Die betrachtete Anweisung ist Ziel eines Gotos: Hier ist die Sachlage schon schwieriger. Der Programmfluss scheint bei Betrachtung des Kontextes genau wie im ersten Beispiel zu verlaufen. Wenn man den Kontext allerdings vergrößert, lernt man, dass die dynamischen Vorgänger in der betrachteten Anweisung auch andere sein können. Der Kontext selbst gibt jedoch keinen Hinweis darauf; zwar kann das Vorhandensein eines Sprunglabels einen Hinweis darauf geben, dass die so markierte Anweisung Ziel eines Gotos sein kann, sie muss es aber nicht; in Sprachen wie BASIC beispielsweise (damals noch weit verbreitet), in denen Zeilennummern gültige Sprungziele sind, muss jede Anweisung als mit einem Label versehen betrachtet werden und kann somit Sprungziel von irgendwoher sein. Außerdem kann eine Anweisung von verschiedenen Gotos angesprungen werden, so dass unklar bleibt, welches die (zeitliche) Vorgängeranweisung war. Die betrachtete Anweisung ist unmittelbare Nachfolgerin eines Gotos: Hier ist zwar aus dem Kontext ersichtlich, dass die statischen Vorgänger nicht die dynamischen sein können, ansonsten kann man aber nur mutmaßen, dass es sich vielleicht um toten Code handeln könnte (also um Code, der niemals ausgeführt wird). Es kann nämlich die Anweisung Sprungziel von Gotos außerhalb des Kontexts sein (wie in allen anderen Fällen auch).
Fazit: Die Verwendung von Goto-Anweisungen verursacht ein hohes Maß an Nichtwissen bei der Interpretation von Quelltext. Speziell beim Debugging von Programmen ist der Blick in den Quelltext des Programms so nur sehr bedingt von Nutzen. Von daher, so der allgemeine Konsens, ist die Benutzung von Gotos zu vermeiden.
Wenn man also kein Goto benutzen darf, wie steuert man dann den Ablauf von Programmen? Die sogenannte strukturierte Programmierung sieht dafür neben der Sequenz von Anweisungen (ausgedrückt durch die unmittelbare Nachbarschaft im Programmtext) die Verzweigung, die Wiederholung und den Unterprogrammaufruf vor. Von diesen behalten die ersten beiden das Lokalitätsprinzip bei, solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife, die damit ausgedrückt wird, ausdehnt. Für den Unterprogrammaufruf gilt das jedoch nicht mehr: Schon weil ein Unterprogramm in der Regel von mehreren Stellen eines Programms aus aufgerufen werden kann und weil diese Stellen nicht automatisch denselben Kontext haben, wird hier das Lokalitätsprinzip durchbrochen. Dies ist aber unvermeidlich, und man tröstet sich damit, dass ein Unterprogramm, genauer eine Prozedur oder eine Funktion, immer genau an die Stelle zurückkehrt, von der es aufgerufen wurde.
Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger um die Return-Anweisung des aufgerufenen Unterprogramms handeln muss. Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterprogramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächliche Parameter übergeben wurden, und wenn zudem das Unterprogramm bekannte Vor- und Nachbedingungen enthält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein großer Nutzen gegenüber: Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anweisungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche Aufrufkontexte gibt (das sog. Inlining, das manche Compiler aus Optimierungsgründen durchführen). Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie getrennt untersuchen und verstehen kann.
Besonders der zweite Punkt ist wichtig: Aus Sicht der Programmiererin sollte es nämlich reichen, zu wissen, was ein Unterprogramm tut, um es korrekt benutzen zu können. Sie muss also insbesondere nicht in das Unterprogramm hineinschauen, also seine Anweisungen inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird — es reicht dann, zu wissen, mit welchen Parametern es versorgt wird, und die sind ihr per formale Parameterdeklaration bekannt. (Voraussetzung dieser Argumentation ist jedoch, dass es keine globalen Variablen gibt, die eine gegenseitige Beeinflussung von Aufrufstelle und Unterprogramm an den tatsächlichen und formalen Parametern vorbei erlauben. Diese globalen Variablen sind jedoch mindestens so sehr verpönt wie das Goto.)
Bei der objektorientierten Programmierung hat man es zunächst mit einer leicht veränderten Situation zu tun. Hier sind nämlich nicht allein das Vermeiden von doppeltem Code sowie die stufenweise Verfeinerung Kriterien für die Aufteilung in Unterprogramme, sondern auch die Disziplin, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert. Typische objektorientierte Programme teilen daher die Implementierung größerer Funktionen nicht nur in kleinere auf, sondern verteilen diese auch noch über viele Klassen. Auch wenn es sich dabei stets nur um Unterprogrammaufrufe handelt, die allen obengenannten Anforderungen genügen, so erfolgen die zum Programmverstehen notwendigen Kontextwechsel doch in so kurzer Folge, dass man schnell den Überblick darüber verliert.
Nun ergibt sich aber mit der Einführung von dynamisch gebundenen Unterprogrammaufrufen, wie sie ja für die objektorientierte Programmierung prägend sind, das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht: Wie bereits in Kurseinheit 1, Abschnitt 4.3.2 bemerkt, verbindet das dynamische Binden den Unterprogrammaufruf mit der Verzweigung.
Es ist an der Stelle der betrachteten Anweisung nicht klar, von woher der in der Anweisung zuvor angestoßene Unterprogrammaufruf zurückkehrt — es könnte von jeder Implementierung der im Gosub genannten Methode sein. Um das Sprungziel und damit die Return-Anweisung, die unmittelbarer Vorgänger war, zu identifizieren, muss man die Klasse des Empfängerobjekts kennen, also die Klasse des Werts der Variable, auf der die Methode aufgerufen wurde. Das ist aber in der Regel nur auf Basis einer vollständigen Programmanalyse bestimmbar, die sich nicht lokal durchführen lässt. Das Lokalitätsprinzip wird also durch das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein.
Dieser Umstand hat dazu geführt, dass das dynamische Binden von Skeptikerinnen und Gegnerinnen der objektorientierten Programmierung schon als eine Art Goto der 90er Jahre betrachtet wurde. Dieser Vergleich ist jedoch nicht ganz fair, weil, genau wie beim statisch gebundenen Unterprogrammaufruf, die Aufruferin ja gar nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen — es reicht zu wissen, welchen Vertrag die aufgerufene Methode (das aufgerufene Unterprogramm) erfüllt. Dies sollte nach den Regeln des Subtyping (Abschnitt 54.2) stets unabhängig vom vertragserfüllenden Objekt sein.
Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.
Es ist wohl unbestritten, dass objektorientierte Programme schwerer zu tracen und zu debuggen sind als prozedurale. Wie schon bei den statisch gebundenen Unterprogrammaufrufen (die ja ebenfalls ein Problem darstellen können) ist die Frage jedoch, ob das, was man durch das dynamische Binden hinzugewinnt, den Preis aufwiegt. Während diese Frage jede für sich selbst entscheiden muss, so scheint die Antwort für viele Programmiererinnen — weit mehr als eine Generation nach dem Aufkommen der Objektorientierung und damit vor dem Hintergrund genügend praktischer Erfahrung — überwiegend positiv zu sein. Man darf aber auch die Neinsagerinnen nicht als Ewiggestrige abstempeln — sie mögen gute Gründe haben.","<answer> Die Goto-Anweisung erlaubt Sprünge von beliebigen Stellen eines Programms zu anderen Stellen und bricht dabei das Lokalitätsprinzip von Programmen, bei dem zusammengehörende Anweisungen im Programmtext nahe beieinander stehen. Dies führte zu einer Unübersichtlichkeit im Programmtext und erschwerte das Verstehen und Debuggen von Programmen. <answer> <question> Warum wurde die Goto-Anweisung als Hauptverursacher für schlechte Programmierung identifiziert? <question>"
"Spätestens mit der Verfügbarkeit sogenannter Hochsprachen und den gleichzeitig immer größer werdenden Programmen kam die Frage auf, was ""gute Programmierung"" ausmacht. Eines der Hauptprobleme schlechter Programmierung war schnell identifiziert: die große Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf. Eine gute Programmiererin hatte ihre Programme so zu schreiben, dass der Programmtext und der Programmablauf einander möglichst ähnlich waren, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zuließ. Man wollte also von den Programmiererinnen Klartext.
Ebenso schnell wie das Problem wurde sein Hauptverursacher ausgemacht: die Goto-Anweisung. Sie erlaubt Sprünge von beliebigen Stellen eines Programms an beliebige andere Stellen des Programms und durchbricht dabei auf brutale Art und Weise das äußerst nützliche Lokalitätsprinzip von Programmen: Dinge, die zusammengehören, stehen im Programmtext beieinander. So, und nur so, ist bei der Inspektion des Programmtextes unmittelbar klar, wie man an eine Stelle im Programm gelangt ist und, mindestens ebenso wichtig, wie eine Variable ihren Wert bekommen hat.
Zur Veranschaulichung soll die nachfolgende Abbildung dienen, die einen Programmtext als eine Folge von Anweisungen stilisiert. Anweisungen sind durch Kreise dargestellt, die (textuelle) Folge der Anweisungen im Programmtext durch die kleinen Pfeile. Ohne besondere, den Kontrollfluss beeinflussende Anweisungen entspricht die (dynamische) Reihenfolge der Ausführung der (statischen) Folge der Anweisungen im Programmtext. Bei Betrachtung des stärker umrandeten, mittleren Kreises (der entsprechenden Anweisung), z. B. während einer Debug-Sitzung, ist daher aus dem unmittelbaren Kontext heraus (der Ellipse; Lokalitätsprinzip!) klar, welche Anweisung davor ausgeführt wurde und welche als nächstes drankommt. Alles ist in bester Ordnung.
Handelt es sich nun bei einer der Anweisungen um ein Goto, dann ist die Sachlage längst nicht mehr so klar. Man hat vielmehr die folgenden Fälle zu unterscheiden: Die betrachtete Anweisung ist selbst ein Goto: In diesem Fall ist zwar klar, woher der Programmfluss kommt, und auch, wohin er geht, letzteres aber nur mit einer gewissen Einschränkung — das Ziel ist nicht der Nachbar im Programmtext, sondern befindet sich außerhalb des gewählten Kontextes. Nun kann man den Kontext natürlich so wählen, dass er das Ziel enthält, und kurze Sprünge sind vielleicht auch so innerhalb des betrachteten Kontextes möglich; allgemein gilt jedoch, dass jede gewählte Lokalität durch einen Sprung verletzt werden kann. Immerhin lässt sich aber das Ziel des Sprungs aus dem Kontext erkennen und der Kontext entsprechend wechseln. Die betrachtete Anweisung ist Ziel eines Gotos: Hier ist die Sachlage schon schwieriger. Der Programmfluss scheint bei Betrachtung des Kontextes genau wie im ersten Beispiel zu verlaufen. Wenn man den Kontext allerdings vergrößert, lernt man, dass die dynamischen Vorgänger in der betrachteten Anweisung auch andere sein können. Der Kontext selbst gibt jedoch keinen Hinweis darauf; zwar kann das Vorhandensein eines Sprunglabels einen Hinweis darauf geben, dass die so markierte Anweisung Ziel eines Gotos sein kann, sie muss es aber nicht; in Sprachen wie BASIC beispielsweise (damals noch weit verbreitet), in denen Zeilennummern gültige Sprungziele sind, muss jede Anweisung als mit einem Label versehen betrachtet werden und kann somit Sprungziel von irgendwoher sein. Außerdem kann eine Anweisung von verschiedenen Gotos angesprungen werden, so dass unklar bleibt, welches die (zeitliche) Vorgängeranweisung war. Die betrachtete Anweisung ist unmittelbare Nachfolgerin eines Gotos: Hier ist zwar aus dem Kontext ersichtlich, dass die statischen Vorgänger nicht die dynamischen sein können, ansonsten kann man aber nur mutmaßen, dass es sich vielleicht um toten Code handeln könnte (also um Code, der niemals ausgeführt wird). Es kann nämlich die Anweisung Sprungziel von Gotos außerhalb des Kontexts sein (wie in allen anderen Fällen auch).
Fazit: Die Verwendung von Goto-Anweisungen verursacht ein hohes Maß an Nichtwissen bei der Interpretation von Quelltext. Speziell beim Debugging von Programmen ist der Blick in den Quelltext des Programms so nur sehr bedingt von Nutzen. Von daher, so der allgemeine Konsens, ist die Benutzung von Gotos zu vermeiden.
Wenn man also kein Goto benutzen darf, wie steuert man dann den Ablauf von Programmen? Die sogenannte strukturierte Programmierung sieht dafür neben der Sequenz von Anweisungen (ausgedrückt durch die unmittelbare Nachbarschaft im Programmtext) die Verzweigung, die Wiederholung und den Unterprogrammaufruf vor. Von diesen behalten die ersten beiden das Lokalitätsprinzip bei, solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife, die damit ausgedrückt wird, ausdehnt. Für den Unterprogrammaufruf gilt das jedoch nicht mehr: Schon weil ein Unterprogramm in der Regel von mehreren Stellen eines Programms aus aufgerufen werden kann und weil diese Stellen nicht automatisch denselben Kontext haben, wird hier das Lokalitätsprinzip durchbrochen. Dies ist aber unvermeidlich, und man tröstet sich damit, dass ein Unterprogramm, genauer eine Prozedur oder eine Funktion, immer genau an die Stelle zurückkehrt, von der es aufgerufen wurde.
Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger um die Return-Anweisung des aufgerufenen Unterprogramms handeln muss. Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterprogramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächliche Parameter übergeben wurden, und wenn zudem das Unterprogramm bekannte Vor- und Nachbedingungen enthält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein großer Nutzen gegenüber: Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anweisungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche Aufrufkontexte gibt (das sog. Inlining, das manche Compiler aus Optimierungsgründen durchführen). Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie getrennt untersuchen und verstehen kann.
Besonders der zweite Punkt ist wichtig: Aus Sicht der Programmiererin sollte es nämlich reichen, zu wissen, was ein Unterprogramm tut, um es korrekt benutzen zu können. Sie muss also insbesondere nicht in das Unterprogramm hineinschauen, also seine Anweisungen inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird — es reicht dann, zu wissen, mit welchen Parametern es versorgt wird, und die sind ihr per formale Parameterdeklaration bekannt. (Voraussetzung dieser Argumentation ist jedoch, dass es keine globalen Variablen gibt, die eine gegenseitige Beeinflussung von Aufrufstelle und Unterprogramm an den tatsächlichen und formalen Parametern vorbei erlauben. Diese globalen Variablen sind jedoch mindestens so sehr verpönt wie das Goto.)
Bei der objektorientierten Programmierung hat man es zunächst mit einer leicht veränderten Situation zu tun. Hier sind nämlich nicht allein das Vermeiden von doppeltem Code sowie die stufenweise Verfeinerung Kriterien für die Aufteilung in Unterprogramme, sondern auch die Disziplin, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert. Typische objektorientierte Programme teilen daher die Implementierung größerer Funktionen nicht nur in kleinere auf, sondern verteilen diese auch noch über viele Klassen. Auch wenn es sich dabei stets nur um Unterprogrammaufrufe handelt, die allen obengenannten Anforderungen genügen, so erfolgen die zum Programmverstehen notwendigen Kontextwechsel doch in so kurzer Folge, dass man schnell den Überblick darüber verliert.
Nun ergibt sich aber mit der Einführung von dynamisch gebundenen Unterprogrammaufrufen, wie sie ja für die objektorientierte Programmierung prägend sind, das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht: Wie bereits in Kurseinheit 1, Abschnitt 4.3.2 bemerkt, verbindet das dynamische Binden den Unterprogrammaufruf mit der Verzweigung.
Es ist an der Stelle der betrachteten Anweisung nicht klar, von woher der in der Anweisung zuvor angestoßene Unterprogrammaufruf zurückkehrt — es könnte von jeder Implementierung der im Gosub genannten Methode sein. Um das Sprungziel und damit die Return-Anweisung, die unmittelbarer Vorgänger war, zu identifizieren, muss man die Klasse des Empfängerobjekts kennen, also die Klasse des Werts der Variable, auf der die Methode aufgerufen wurde. Das ist aber in der Regel nur auf Basis einer vollständigen Programmanalyse bestimmbar, die sich nicht lokal durchführen lässt. Das Lokalitätsprinzip wird also durch das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein.
Dieser Umstand hat dazu geführt, dass das dynamische Binden von Skeptikerinnen und Gegnerinnen der objektorientierten Programmierung schon als eine Art Goto der 90er Jahre betrachtet wurde. Dieser Vergleich ist jedoch nicht ganz fair, weil, genau wie beim statisch gebundenen Unterprogrammaufruf, die Aufruferin ja gar nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen — es reicht zu wissen, welchen Vertrag die aufgerufene Methode (das aufgerufene Unterprogramm) erfüllt. Dies sollte nach den Regeln des Subtyping (Abschnitt 54.2) stets unabhängig vom vertragserfüllenden Objekt sein.
Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.
Es ist wohl unbestritten, dass objektorientierte Programme schwerer zu tracen und zu debuggen sind als prozedurale. Wie schon bei den statisch gebundenen Unterprogrammaufrufen (die ja ebenfalls ein Problem darstellen können) ist die Frage jedoch, ob das, was man durch das dynamische Binden hinzugewinnt, den Preis aufwiegt. Während diese Frage jede für sich selbst entscheiden muss, so scheint die Antwort für viele Programmiererinnen — weit mehr als eine Generation nach dem Aufkommen der Objektorientierung und damit vor dem Hintergrund genügend praktischer Erfahrung — überwiegend positiv zu sein. Man darf aber auch die Neinsagerinnen nicht als Ewiggestrige abstempeln — sie mögen gute Gründe haben.","<answer> Man versuchte, das Problem der schlechten Tracebarkeit durch das Vermeiden von Goto-Anweisungen zu lösen. Stattdessen setzte man auf strukturierte Programmierung, die Verzweigung, Wiederholung und Unterprogrammaufrufe verwendete, um den Programmfluss zu steuern. <answer> <question> Wie versuchte man das Problem der schlechten Tracebarkeit durch Goto-Anweisungen zu lösen? <question>"
"Spätestens mit der Verfügbarkeit sogenannter Hochsprachen und den gleichzeitig immer größer werdenden Programmen kam die Frage auf, was ""gute Programmierung"" ausmacht. Eines der Hauptprobleme schlechter Programmierung war schnell identifiziert: die große Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf. Eine gute Programmiererin hatte ihre Programme so zu schreiben, dass der Programmtext und der Programmablauf einander möglichst ähnlich waren, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zuließ. Man wollte also von den Programmiererinnen Klartext.
Ebenso schnell wie das Problem wurde sein Hauptverursacher ausgemacht: die Goto-Anweisung. Sie erlaubt Sprünge von beliebigen Stellen eines Programms an beliebige andere Stellen des Programms und durchbricht dabei auf brutale Art und Weise das äußerst nützliche Lokalitätsprinzip von Programmen: Dinge, die zusammengehören, stehen im Programmtext beieinander. So, und nur so, ist bei der Inspektion des Programmtextes unmittelbar klar, wie man an eine Stelle im Programm gelangt ist und, mindestens ebenso wichtig, wie eine Variable ihren Wert bekommen hat.
Zur Veranschaulichung soll die nachfolgende Abbildung dienen, die einen Programmtext als eine Folge von Anweisungen stilisiert. Anweisungen sind durch Kreise dargestellt, die (textuelle) Folge der Anweisungen im Programmtext durch die kleinen Pfeile. Ohne besondere, den Kontrollfluss beeinflussende Anweisungen entspricht die (dynamische) Reihenfolge der Ausführung der (statischen) Folge der Anweisungen im Programmtext. Bei Betrachtung des stärker umrandeten, mittleren Kreises (der entsprechenden Anweisung), z. B. während einer Debug-Sitzung, ist daher aus dem unmittelbaren Kontext heraus (der Ellipse; Lokalitätsprinzip!) klar, welche Anweisung davor ausgeführt wurde und welche als nächstes drankommt. Alles ist in bester Ordnung.
Handelt es sich nun bei einer der Anweisungen um ein Goto, dann ist die Sachlage längst nicht mehr so klar. Man hat vielmehr die folgenden Fälle zu unterscheiden: Die betrachtete Anweisung ist selbst ein Goto: In diesem Fall ist zwar klar, woher der Programmfluss kommt, und auch, wohin er geht, letzteres aber nur mit einer gewissen Einschränkung — das Ziel ist nicht der Nachbar im Programmtext, sondern befindet sich außerhalb des gewählten Kontextes. Nun kann man den Kontext natürlich so wählen, dass er das Ziel enthält, und kurze Sprünge sind vielleicht auch so innerhalb des betrachteten Kontextes möglich; allgemein gilt jedoch, dass jede gewählte Lokalität durch einen Sprung verletzt werden kann. Immerhin lässt sich aber das Ziel des Sprungs aus dem Kontext erkennen und der Kontext entsprechend wechseln. Die betrachtete Anweisung ist Ziel eines Gotos: Hier ist die Sachlage schon schwieriger. Der Programmfluss scheint bei Betrachtung des Kontextes genau wie im ersten Beispiel zu verlaufen. Wenn man den Kontext allerdings vergrößert, lernt man, dass die dynamischen Vorgänger in der betrachteten Anweisung auch andere sein können. Der Kontext selbst gibt jedoch keinen Hinweis darauf; zwar kann das Vorhandensein eines Sprunglabels einen Hinweis darauf geben, dass die so markierte Anweisung Ziel eines Gotos sein kann, sie muss es aber nicht; in Sprachen wie BASIC beispielsweise (damals noch weit verbreitet), in denen Zeilennummern gültige Sprungziele sind, muss jede Anweisung als mit einem Label versehen betrachtet werden und kann somit Sprungziel von irgendwoher sein. Außerdem kann eine Anweisung von verschiedenen Gotos angesprungen werden, so dass unklar bleibt, welches die (zeitliche) Vorgängeranweisung war. Die betrachtete Anweisung ist unmittelbare Nachfolgerin eines Gotos: Hier ist zwar aus dem Kontext ersichtlich, dass die statischen Vorgänger nicht die dynamischen sein können, ansonsten kann man aber nur mutmaßen, dass es sich vielleicht um toten Code handeln könnte (also um Code, der niemals ausgeführt wird). Es kann nämlich die Anweisung Sprungziel von Gotos außerhalb des Kontexts sein (wie in allen anderen Fällen auch).
Fazit: Die Verwendung von Goto-Anweisungen verursacht ein hohes Maß an Nichtwissen bei der Interpretation von Quelltext. Speziell beim Debugging von Programmen ist der Blick in den Quelltext des Programms so nur sehr bedingt von Nutzen. Von daher, so der allgemeine Konsens, ist die Benutzung von Gotos zu vermeiden.
Wenn man also kein Goto benutzen darf, wie steuert man dann den Ablauf von Programmen? Die sogenannte strukturierte Programmierung sieht dafür neben der Sequenz von Anweisungen (ausgedrückt durch die unmittelbare Nachbarschaft im Programmtext) die Verzweigung, die Wiederholung und den Unterprogrammaufruf vor. Von diesen behalten die ersten beiden das Lokalitätsprinzip bei, solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife, die damit ausgedrückt wird, ausdehnt. Für den Unterprogrammaufruf gilt das jedoch nicht mehr: Schon weil ein Unterprogramm in der Regel von mehreren Stellen eines Programms aus aufgerufen werden kann und weil diese Stellen nicht automatisch denselben Kontext haben, wird hier das Lokalitätsprinzip durchbrochen. Dies ist aber unvermeidlich, und man tröstet sich damit, dass ein Unterprogramm, genauer eine Prozedur oder eine Funktion, immer genau an die Stelle zurückkehrt, von der es aufgerufen wurde.
Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger um die Return-Anweisung des aufgerufenen Unterprogramms handeln muss. Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterprogramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächliche Parameter übergeben wurden, und wenn zudem das Unterprogramm bekannte Vor- und Nachbedingungen enthält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein großer Nutzen gegenüber: Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anweisungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche Aufrufkontexte gibt (das sog. Inlining, das manche Compiler aus Optimierungsgründen durchführen). Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie getrennt untersuchen und verstehen kann.
Besonders der zweite Punkt ist wichtig: Aus Sicht der Programmiererin sollte es nämlich reichen, zu wissen, was ein Unterprogramm tut, um es korrekt benutzen zu können. Sie muss also insbesondere nicht in das Unterprogramm hineinschauen, also seine Anweisungen inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird — es reicht dann, zu wissen, mit welchen Parametern es versorgt wird, und die sind ihr per formale Parameterdeklaration bekannt. (Voraussetzung dieser Argumentation ist jedoch, dass es keine globalen Variablen gibt, die eine gegenseitige Beeinflussung von Aufrufstelle und Unterprogramm an den tatsächlichen und formalen Parametern vorbei erlauben. Diese globalen Variablen sind jedoch mindestens so sehr verpönt wie das Goto.)
Bei der objektorientierten Programmierung hat man es zunächst mit einer leicht veränderten Situation zu tun. Hier sind nämlich nicht allein das Vermeiden von doppeltem Code sowie die stufenweise Verfeinerung Kriterien für die Aufteilung in Unterprogramme, sondern auch die Disziplin, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert. Typische objektorientierte Programme teilen daher die Implementierung größerer Funktionen nicht nur in kleinere auf, sondern verteilen diese auch noch über viele Klassen. Auch wenn es sich dabei stets nur um Unterprogrammaufrufe handelt, die allen obengenannten Anforderungen genügen, so erfolgen die zum Programmverstehen notwendigen Kontextwechsel doch in so kurzer Folge, dass man schnell den Überblick darüber verliert.
Nun ergibt sich aber mit der Einführung von dynamisch gebundenen Unterprogrammaufrufen, wie sie ja für die objektorientierte Programmierung prägend sind, das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht: Wie bereits in Kurseinheit 1, Abschnitt 4.3.2 bemerkt, verbindet das dynamische Binden den Unterprogrammaufruf mit der Verzweigung.
Es ist an der Stelle der betrachteten Anweisung nicht klar, von woher der in der Anweisung zuvor angestoßene Unterprogrammaufruf zurückkehrt — es könnte von jeder Implementierung der im Gosub genannten Methode sein. Um das Sprungziel und damit die Return-Anweisung, die unmittelbarer Vorgänger war, zu identifizieren, muss man die Klasse des Empfängerobjekts kennen, also die Klasse des Werts der Variable, auf der die Methode aufgerufen wurde. Das ist aber in der Regel nur auf Basis einer vollständigen Programmanalyse bestimmbar, die sich nicht lokal durchführen lässt. Das Lokalitätsprinzip wird also durch das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein.
Dieser Umstand hat dazu geführt, dass das dynamische Binden von Skeptikerinnen und Gegnerinnen der objektorientierten Programmierung schon als eine Art Goto der 90er Jahre betrachtet wurde. Dieser Vergleich ist jedoch nicht ganz fair, weil, genau wie beim statisch gebundenen Unterprogrammaufruf, die Aufruferin ja gar nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen — es reicht zu wissen, welchen Vertrag die aufgerufene Methode (das aufgerufene Unterprogramm) erfüllt. Dies sollte nach den Regeln des Subtyping (Abschnitt 54.2) stets unabhängig vom vertragserfüllenden Objekt sein.
Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.
Es ist wohl unbestritten, dass objektorientierte Programme schwerer zu tracen und zu debuggen sind als prozedurale. Wie schon bei den statisch gebundenen Unterprogrammaufrufen (die ja ebenfalls ein Problem darstellen können) ist die Frage jedoch, ob das, was man durch das dynamische Binden hinzugewinnt, den Preis aufwiegt. Während diese Frage jede für sich selbst entscheiden muss, so scheint die Antwort für viele Programmiererinnen — weit mehr als eine Generation nach dem Aufkommen der Objektorientierung und damit vor dem Hintergrund genügend praktischer Erfahrung — überwiegend positiv zu sein. Man darf aber auch die Neinsagerinnen nicht als Ewiggestrige abstempeln — sie mögen gute Gründe haben.","<answer> Bei der Verwendung dynamisch gebundener Unterprogrammaufrufe in der objektorientierten Programmierung ergibt sich das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht. Dies führt zu einer Unsicherheit darüber, welcher Code tatsächlich ausgeführt wird, insbesondere beim Tracen oder Debuggen von Programmen. <answer> <question> Welche Probleme ergeben sich bei der Verwendung dynamisch gebundener Unterprogrammaufrufe in der objektorientierten Programmierung? <question>"
"Spätestens mit der Verfügbarkeit sogenannter Hochsprachen und den gleichzeitig immer größer werdenden Programmen kam die Frage auf, was ""gute Programmierung"" ausmacht. Eines der Hauptprobleme schlechter Programmierung war schnell identifiziert: die große Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf. Eine gute Programmiererin hatte ihre Programme so zu schreiben, dass der Programmtext und der Programmablauf einander möglichst ähnlich waren, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zuließ. Man wollte also von den Programmiererinnen Klartext.
Ebenso schnell wie das Problem wurde sein Hauptverursacher ausgemacht: die Goto-Anweisung. Sie erlaubt Sprünge von beliebigen Stellen eines Programms an beliebige andere Stellen des Programms und durchbricht dabei auf brutale Art und Weise das äußerst nützliche Lokalitätsprinzip von Programmen: Dinge, die zusammengehören, stehen im Programmtext beieinander. So, und nur so, ist bei der Inspektion des Programmtextes unmittelbar klar, wie man an eine Stelle im Programm gelangt ist und, mindestens ebenso wichtig, wie eine Variable ihren Wert bekommen hat.
Zur Veranschaulichung soll die nachfolgende Abbildung dienen, die einen Programmtext als eine Folge von Anweisungen stilisiert. Anweisungen sind durch Kreise dargestellt, die (textuelle) Folge der Anweisungen im Programmtext durch die kleinen Pfeile. Ohne besondere, den Kontrollfluss beeinflussende Anweisungen entspricht die (dynamische) Reihenfolge der Ausführung der (statischen) Folge der Anweisungen im Programmtext. Bei Betrachtung des stärker umrandeten, mittleren Kreises (der entsprechenden Anweisung), z. B. während einer Debug-Sitzung, ist daher aus dem unmittelbaren Kontext heraus (der Ellipse; Lokalitätsprinzip!) klar, welche Anweisung davor ausgeführt wurde und welche als nächstes drankommt. Alles ist in bester Ordnung.
Handelt es sich nun bei einer der Anweisungen um ein Goto, dann ist die Sachlage längst nicht mehr so klar. Man hat vielmehr die folgenden Fälle zu unterscheiden: Die betrachtete Anweisung ist selbst ein Goto: In diesem Fall ist zwar klar, woher der Programmfluss kommt, und auch, wohin er geht, letzteres aber nur mit einer gewissen Einschränkung — das Ziel ist nicht der Nachbar im Programmtext, sondern befindet sich außerhalb des gewählten Kontextes. Nun kann man den Kontext natürlich so wählen, dass er das Ziel enthält, und kurze Sprünge sind vielleicht auch so innerhalb des betrachteten Kontextes möglich; allgemein gilt jedoch, dass jede gewählte Lokalität durch einen Sprung verletzt werden kann. Immerhin lässt sich aber das Ziel des Sprungs aus dem Kontext erkennen und der Kontext entsprechend wechseln. Die betrachtete Anweisung ist Ziel eines Gotos: Hier ist die Sachlage schon schwieriger. Der Programmfluss scheint bei Betrachtung des Kontextes genau wie im ersten Beispiel zu verlaufen. Wenn man den Kontext allerdings vergrößert, lernt man, dass die dynamischen Vorgänger in der betrachteten Anweisung auch andere sein können. Der Kontext selbst gibt jedoch keinen Hinweis darauf; zwar kann das Vorhandensein eines Sprunglabels einen Hinweis darauf geben, dass die so markierte Anweisung Ziel eines Gotos sein kann, sie muss es aber nicht; in Sprachen wie BASIC beispielsweise (damals noch weit verbreitet), in denen Zeilennummern gültige Sprungziele sind, muss jede Anweisung als mit einem Label versehen betrachtet werden und kann somit Sprungziel von irgendwoher sein. Außerdem kann eine Anweisung von verschiedenen Gotos angesprungen werden, so dass unklar bleibt, welches die (zeitliche) Vorgängeranweisung war. Die betrachtete Anweisung ist unmittelbare Nachfolgerin eines Gotos: Hier ist zwar aus dem Kontext ersichtlich, dass die statischen Vorgänger nicht die dynamischen sein können, ansonsten kann man aber nur mutmaßen, dass es sich vielleicht um toten Code handeln könnte (also um Code, der niemals ausgeführt wird). Es kann nämlich die Anweisung Sprungziel von Gotos außerhalb des Kontexts sein (wie in allen anderen Fällen auch).
Fazit: Die Verwendung von Goto-Anweisungen verursacht ein hohes Maß an Nichtwissen bei der Interpretation von Quelltext. Speziell beim Debugging von Programmen ist der Blick in den Quelltext des Programms so nur sehr bedingt von Nutzen. Von daher, so der allgemeine Konsens, ist die Benutzung von Gotos zu vermeiden.
Wenn man also kein Goto benutzen darf, wie steuert man dann den Ablauf von Programmen? Die sogenannte strukturierte Programmierung sieht dafür neben der Sequenz von Anweisungen (ausgedrückt durch die unmittelbare Nachbarschaft im Programmtext) die Verzweigung, die Wiederholung und den Unterprogrammaufruf vor. Von diesen behalten die ersten beiden das Lokalitätsprinzip bei, solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife, die damit ausgedrückt wird, ausdehnt. Für den Unterprogrammaufruf gilt das jedoch nicht mehr: Schon weil ein Unterprogramm in der Regel von mehreren Stellen eines Programms aus aufgerufen werden kann und weil diese Stellen nicht automatisch denselben Kontext haben, wird hier das Lokalitätsprinzip durchbrochen. Dies ist aber unvermeidlich, und man tröstet sich damit, dass ein Unterprogramm, genauer eine Prozedur oder eine Funktion, immer genau an die Stelle zurückkehrt, von der es aufgerufen wurde.
Bei Betrachtung des textuell unmittelbaren Vorgängers der betrachteten Anweisung sieht man sofort, dass es sich beim dynamischen Vorgänger um die Return-Anweisung des aufgerufenen Unterprogramms handeln muss. Dies ist zwar nicht lokal, aber wenn man sich sicher sein kann, dass das Unterprogramm nur die Variablen manipuliert, die bei seinem Aufruf als tatsächliche Parameter übergeben wurden, und wenn zudem das Unterprogramm bekannte Vor- und Nachbedingungen enthält, dann ist das kein Problem. Selbst wenn man nicht weiß, wie die Variablen manipuliert wurden, so ist die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, im Vergleich zu der beim Goto gering. Ihr steht auf der anderen Seite ein großer Nutzen gegenüber: Man vermeidet die Duplizierung von Code, die nötig wäre, wenn man die Anweisungen des Unterprogramms im Aufrufkontext halten wollte und es mehrere solche Aufrufkontexte gibt (das sog. Inlining, das manche Compiler aus Optimierungsgründen durchführen). Man erlaubt der Programmiererin, ihre Programme in Abschnitte zu unterteilen, die sie getrennt untersuchen und verstehen kann.
Besonders der zweite Punkt ist wichtig: Aus Sicht der Programmiererin sollte es nämlich reichen, zu wissen, was ein Unterprogramm tut, um es korrekt benutzen zu können. Sie muss also insbesondere nicht in das Unterprogramm hineinschauen, also seine Anweisungen inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird — es reicht dann, zu wissen, mit welchen Parametern es versorgt wird, und die sind ihr per formale Parameterdeklaration bekannt. (Voraussetzung dieser Argumentation ist jedoch, dass es keine globalen Variablen gibt, die eine gegenseitige Beeinflussung von Aufrufstelle und Unterprogramm an den tatsächlichen und formalen Parametern vorbei erlauben. Diese globalen Variablen sind jedoch mindestens so sehr verpönt wie das Goto.)
Bei der objektorientierten Programmierung hat man es zunächst mit einer leicht veränderten Situation zu tun. Hier sind nämlich nicht allein das Vermeiden von doppeltem Code sowie die stufenweise Verfeinerung Kriterien für die Aufteilung in Unterprogramme, sondern auch die Disziplin, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert. Typische objektorientierte Programme teilen daher die Implementierung größerer Funktionen nicht nur in kleinere auf, sondern verteilen diese auch noch über viele Klassen. Auch wenn es sich dabei stets nur um Unterprogrammaufrufe handelt, die allen obengenannten Anforderungen genügen, so erfolgen die zum Programmverstehen notwendigen Kontextwechsel doch in so kurzer Folge, dass man schnell den Überblick darüber verliert.
Nun ergibt sich aber mit der Einführung von dynamisch gebundenen Unterprogrammaufrufen, wie sie ja für die objektorientierte Programmierung prägend sind, das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht: Wie bereits in Kurseinheit 1, Abschnitt 4.3.2 bemerkt, verbindet das dynamische Binden den Unterprogrammaufruf mit der Verzweigung.
Es ist an der Stelle der betrachteten Anweisung nicht klar, von woher der in der Anweisung zuvor angestoßene Unterprogrammaufruf zurückkehrt — es könnte von jeder Implementierung der im Gosub genannten Methode sein. Um das Sprungziel und damit die Return-Anweisung, die unmittelbarer Vorgänger war, zu identifizieren, muss man die Klasse des Empfängerobjekts kennen, also die Klasse des Werts der Variable, auf der die Methode aufgerufen wurde. Das ist aber in der Regel nur auf Basis einer vollständigen Programmanalyse bestimmbar, die sich nicht lokal durchführen lässt. Das Lokalitätsprinzip wird also durch das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein.
Dieser Umstand hat dazu geführt, dass das dynamische Binden von Skeptikerinnen und Gegnerinnen der objektorientierten Programmierung schon als eine Art Goto der 90er Jahre betrachtet wurde. Dieser Vergleich ist jedoch nicht ganz fair, weil, genau wie beim statisch gebundenen Unterprogrammaufruf, die Aufruferin ja gar nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen — es reicht zu wissen, welchen Vertrag die aufgerufene Methode (das aufgerufene Unterprogramm) erfüllt. Dies sollte nach den Regeln des Subtyping (Abschnitt 54.2) stets unabhängig vom vertragserfüllenden Objekt sein.
Andererseits sind die Verträge in der Praxis gar nicht im Programmtext spezifiziert, oder kennen Sie ein Programm, in dem für jede dynamisch gebundene Methode Vor- und Nachbedingungen spezifiziert wären? Daher kann es bei der Betrachtung der Aufrufstelle sehr wohl interessant sein, was denn nun genau in der aufgerufenen Methode passiert ist, z. B. weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann. In diesen Fällen wird man sich also, beim Tracen oder beim Debuggen, auch den aufgerufenen Code anschauen wollen. Das Problem ist nur, dass man gar nicht weiß, an welcher Stelle man schauen muss. Es bleibt in der Praxis also nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen oder den Programmablauf Schritt für Schritt zu verfolgen, mit all den oben beschriebenen Problemen.
Es ist wohl unbestritten, dass objektorientierte Programme schwerer zu tracen und zu debuggen sind als prozedurale. Wie schon bei den statisch gebundenen Unterprogrammaufrufen (die ja ebenfalls ein Problem darstellen können) ist die Frage jedoch, ob das, was man durch das dynamische Binden hinzugewinnt, den Preis aufwiegt. Während diese Frage jede für sich selbst entscheiden muss, so scheint die Antwort für viele Programmiererinnen — weit mehr als eine Generation nach dem Aufkommen der Objektorientierung und damit vor dem Hintergrund genügend praktischer Erfahrung — überwiegend positiv zu sein. Man darf aber auch die Neinsagerinnen nicht als Ewiggestrige abstempeln — sie mögen gute Gründe haben.","<answer> Das dynamische Binden wird manchmal als eine Art Goto der 90er Jahre betrachtet, weil es ähnliche Probleme in Bezug auf Tracebarkeit und Verständlichkeit von Programmen verursachen kann. Es erfordert, den Programmablauf im Kontext des dynamisch aufgerufenen Codes zu verstehen, was die Nachverfolgung und das Debuggen erschwert. <answer> <question> Warum wird das dynamische Binden von Skeptikern und Gegnern der objektorientierten Programmierung manchmal als eine Art Goto der 90er Jahre betrachtet? <question>"
"Viele Applikationen, insbesondere solche mit GUI, benötigen neben der direkten Kommunikation zwischen Objekten, die sich kennen (die ja durch Nachrichtenaustausch bzw., je nach Diktion, durch Methodenaufrufe bewerkstelligt wird), auch eine Kommunikation mit unbekannten. Die Problematik hatten wir im Kontext von SMALLTALK bereits besprochen (Abschnitt 14.3 in Kurseinheit 1).
Nun kommt dieses Problem so häufig vor, dass sich MICROSOFT dafür entschieden hat, es zumindest teilweise von der Ebene der Programmierung (wo es in Form eines sog. Patterns abgehandelt wird; mehr dazu in Kurs 01853) auf die Ebene der Programmiersprache zu heben (in SMALLTALK, wo diese Unterscheidung nicht so ausgeprägt ist, war das Problem ja mittels einer Implementierung der benötigten Mechanismen in der Klasse Object gelöst worden, von der alle anderen erben).
Zu diesem Zweck wurde das Konstrukt des Events (Ereignisses) eingeführt, über das sog. Event handler aktiviert werden können. Dabei handelt es sich um die in Abschnitt 50.4.1 skizzierten sog. Delegates. Leider ist die Syntax von C#, die mit Deklaration und Registrierung von Eventhandlern sowie der Verbreitung von Ereignissen verbunden ist, nach Ansicht des Autors dieses Textes komplett unleserlich geraten, so dass hier auf eine weitergehende Befassung mit dem Thema verzichtet wird.","<answer> Viele Applikationen benötigen eine Kommunikation mit unbekannten Objekten, da sie neben der direkten Kommunikation zwischen Objekten, die sich kennen, auch mit anderen Objekten kommunizieren müssen, die nicht im Voraus bekannt sind. Dies tritt insbesondere in Anwendungen mit grafischer Benutzeroberfläche (GUI) auf, wo verschiedene Elemente miteinander interagieren müssen, ohne im Voraus genau zu wissen, welche Objekte diese Interaktion benötigen. <answer> <question> Warum benötigen viele Applikationen, insbesondere solche mit GUI, eine Kommunikation mit unbekannten Objekten? <question>"
"Viele Applikationen, insbesondere solche mit GUI, benötigen neben der direkten Kommunikation zwischen Objekten, die sich kennen (die ja durch Nachrichtenaustausch bzw., je nach Diktion, durch Methodenaufrufe bewerkstelligt wird), auch eine Kommunikation mit unbekannten. Die Problematik hatten wir im Kontext von SMALLTALK bereits besprochen (Abschnitt 14.3 in Kurseinheit 1).
Nun kommt dieses Problem so häufig vor, dass sich MICROSOFT dafür entschieden hat, es zumindest teilweise von der Ebene der Programmierung (wo es in Form eines sog. Patterns abgehandelt wird; mehr dazu in Kurs 01853) auf die Ebene der Programmiersprache zu heben (in SMALLTALK, wo diese Unterscheidung nicht so ausgeprägt ist, war das Problem ja mittels einer Implementierung der benötigten Mechanismen in der Klasse Object gelöst worden, von der alle anderen erben).
Zu diesem Zweck wurde das Konstrukt des Events (Ereignisses) eingeführt, über das sog. Event handler aktiviert werden können. Dabei handelt es sich um die in Abschnitt 50.4.1 skizzierten sog. Delegates. Leider ist die Syntax von C#, die mit Deklaration und Registrierung von Eventhandlern sowie der Verbreitung von Ereignissen verbunden ist, nach Ansicht des Autors dieses Textes komplett unleserlich geraten, so dass hier auf eine weitergehende Befassung mit dem Thema verzichtet wird.","<answer> Microsoft hat versucht, das Problem der Kommunikation mit unbekannten Objekten teilweise von der Ebene der Programmierung auf die Ebene der Programmiersprache zu heben, indem sie das Konstrukt des Events (Ereignisses) eingeführt haben. Über Ereignisse können sogenannte Eventhandler aktiviert werden, die auf unerwartete Ereignisse reagieren können. Dies wurde mithilfe von Delegates realisiert, wie im Abschnitt 50.4.1 skizziert. <answer> <question> Wie hat Microsoft versucht, das Problem der Kommunikation mit unbekannten Objekten auf der Ebene der Programmiersprache zu lösen? <question>"
"Viele Applikationen, insbesondere solche mit GUI, benötigen neben der direkten Kommunikation zwischen Objekten, die sich kennen (die ja durch Nachrichtenaustausch bzw., je nach Diktion, durch Methodenaufrufe bewerkstelligt wird), auch eine Kommunikation mit unbekannten. Die Problematik hatten wir im Kontext von SMALLTALK bereits besprochen (Abschnitt 14.3 in Kurseinheit 1).
Nun kommt dieses Problem so häufig vor, dass sich MICROSOFT dafür entschieden hat, es zumindest teilweise von der Ebene der Programmierung (wo es in Form eines sog. Patterns abgehandelt wird; mehr dazu in Kurs 01853) auf die Ebene der Programmiersprache zu heben (in SMALLTALK, wo diese Unterscheidung nicht so ausgeprägt ist, war das Problem ja mittels einer Implementierung der benötigten Mechanismen in der Klasse Object gelöst worden, von der alle anderen erben).
Zu diesem Zweck wurde das Konstrukt des Events (Ereignisses) eingeführt, über das sog. Event handler aktiviert werden können. Dabei handelt es sich um die in Abschnitt 50.4.1 skizzierten sog. Delegates. Leider ist die Syntax von C#, die mit Deklaration und Registrierung von Eventhandlern sowie der Verbreitung von Ereignissen verbunden ist, nach Ansicht des Autors dieses Textes komplett unleserlich geraten, so dass hier auf eine weitergehende Befassung mit dem Thema verzichtet wird.","<answer> Der Autor bezeichnet die Syntax von C# im Zusammenhang mit Events als ""komplett unleserlich"", weil er sie als schwer verständlich oder verwirrend empfindet. Dies kann auf die Art und Weise zurückzuführen sein, wie Events deklariert, Eventhandler registriert und Ereignisse behandelt werden, was möglicherweise die Lesbarkeit des Codes beeinträchtigt. <answer> <question> Warum bezeichnet der Autor die Syntax von C# im Zusammenhang mit Events als ""komplett unleserlich""? <question>"
"Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird. In SMALLTALK gelten alle Ausdrücke, die nicht Teil anderer Ausdrücke sind, als Anweisungen. Im Gegensatz zu JAVA und C# ist in SMALLTALK kein Semikolon erforderlich.
In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt. Dieser Punkt ist ein Trennzeichen (ähnlich wie in PASCAL oder EIFFEL) und gehört nicht zur Anweisung selbst, im Gegensatz zu den von C abgeleiteten Sprachen wie JAVA oder C#. Der Punkt am Ende einer Anweisung kann also weggelassen werden, wenn keine weitere Anweisung folgt. Die Verwendung des Punktes entspricht dem Ziel von SMALLTALK, sich natürlicher Sprache anzunähern. Ähnlich ist die Wahl des Semikolons zur Kaskadierung von Nachrichtenausdrücken zu betrachten.
Die einzige andere Form der Anweisung in SMALLTALK ist die Return-Anweisung, auf die wir im nächsten Kapitel im Zusammenhang mit Methoden näher eingehen werden. In SMALLTALK besteht sie aus dem Sonderzeichen ^ (ursprünglich , jedoch auf den meisten Tastaturen nicht verfügbar), gefolgt von einem Ausdruck. Die Return-Anweisung gibt das Objekt zurück, zu dem dieser Ausdruck ausgewertet wird. Da alle anderen Anweisungen in SMALLTALK Ausdrücke sind, die zu einem Objekt ausgewertet werden, benötigen Methoden (Abschnitt 4.3) und Blöcke (Abschnitt 4.4) in SMALLTALK keine Return-Anweisungen, um ein Objekt zurückzugeben. Sie geben automatisch das Objekt zurück, zu dem die letzte Anweisung ausgewertet wird.","<answer> Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird. <answer> <question> Welche Funktion haben Anweisungen in einem Programm? <question>"
"Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird. In SMALLTALK gelten alle Ausdrücke, die nicht Teil anderer Ausdrücke sind, als Anweisungen. Im Gegensatz zu JAVA und C# ist in SMALLTALK kein Semikolon erforderlich.
In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt. Dieser Punkt ist ein Trennzeichen (ähnlich wie in PASCAL oder EIFFEL) und gehört nicht zur Anweisung selbst, im Gegensatz zu den von C abgeleiteten Sprachen wie JAVA oder C#. Der Punkt am Ende einer Anweisung kann also weggelassen werden, wenn keine weitere Anweisung folgt. Die Verwendung des Punktes entspricht dem Ziel von SMALLTALK, sich natürlicher Sprache anzunähern. Ähnlich ist die Wahl des Semikolons zur Kaskadierung von Nachrichtenausdrücken zu betrachten.
Die einzige andere Form der Anweisung in SMALLTALK ist die Return-Anweisung, auf die wir im nächsten Kapitel im Zusammenhang mit Methoden näher eingehen werden. In SMALLTALK besteht sie aus dem Sonderzeichen ^ (ursprünglich , jedoch auf den meisten Tastaturen nicht verfügbar), gefolgt von einem Ausdruck. Die Return-Anweisung gibt das Objekt zurück, zu dem dieser Ausdruck ausgewertet wird. Da alle anderen Anweisungen in SMALLTALK Ausdrücke sind, die zu einem Objekt ausgewertet werden, benötigen Methoden (Abschnitt 4.3) und Blöcke (Abschnitt 4.4) in SMALLTALK keine Return-Anweisungen, um ein Objekt zurückzugeben. Sie geben automatisch das Objekt zurück, zu dem die letzte Anweisung ausgewertet wird.",<answer> In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt. <answer> <question> Wie werden Anweisungen in SMALLTALK getrennt? <question>
"Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird. In SMALLTALK gelten alle Ausdrücke, die nicht Teil anderer Ausdrücke sind, als Anweisungen. Im Gegensatz zu JAVA und C# ist in SMALLTALK kein Semikolon erforderlich.
In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt. Dieser Punkt ist ein Trennzeichen (ähnlich wie in PASCAL oder EIFFEL) und gehört nicht zur Anweisung selbst, im Gegensatz zu den von C abgeleiteten Sprachen wie JAVA oder C#. Der Punkt am Ende einer Anweisung kann also weggelassen werden, wenn keine weitere Anweisung folgt. Die Verwendung des Punktes entspricht dem Ziel von SMALLTALK, sich natürlicher Sprache anzunähern. Ähnlich ist die Wahl des Semikolons zur Kaskadierung von Nachrichtenausdrücken zu betrachten.
Die einzige andere Form der Anweisung in SMALLTALK ist die Return-Anweisung, auf die wir im nächsten Kapitel im Zusammenhang mit Methoden näher eingehen werden. In SMALLTALK besteht sie aus dem Sonderzeichen ^ (ursprünglich , jedoch auf den meisten Tastaturen nicht verfügbar), gefolgt von einem Ausdruck. Die Return-Anweisung gibt das Objekt zurück, zu dem dieser Ausdruck ausgewertet wird. Da alle anderen Anweisungen in SMALLTALK Ausdrücke sind, die zu einem Objekt ausgewertet werden, benötigen Methoden (Abschnitt 4.3) und Blöcke (Abschnitt 4.4) in SMALLTALK keine Return-Anweisungen, um ein Objekt zurückzugeben. Sie geben automatisch das Objekt zurück, zu dem die letzte Anweisung ausgewertet wird.","<answer> Der Punkt in SMALLTALK dient als Trennzeichen für Anweisungsfolgen und trägt dazu bei, dass SMALLTALK natürlicher Sprache ähnelt. <answer> <question> Warum ist der Punkt in SMALLTALK wichtig? <question>"
"Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird. In SMALLTALK gelten alle Ausdrücke, die nicht Teil anderer Ausdrücke sind, als Anweisungen. Im Gegensatz zu JAVA und C# ist in SMALLTALK kein Semikolon erforderlich.
In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt. Dieser Punkt ist ein Trennzeichen (ähnlich wie in PASCAL oder EIFFEL) und gehört nicht zur Anweisung selbst, im Gegensatz zu den von C abgeleiteten Sprachen wie JAVA oder C#. Der Punkt am Ende einer Anweisung kann also weggelassen werden, wenn keine weitere Anweisung folgt. Die Verwendung des Punktes entspricht dem Ziel von SMALLTALK, sich natürlicher Sprache anzunähern. Ähnlich ist die Wahl des Semikolons zur Kaskadierung von Nachrichtenausdrücken zu betrachten.
Die einzige andere Form der Anweisung in SMALLTALK ist die Return-Anweisung, auf die wir im nächsten Kapitel im Zusammenhang mit Methoden näher eingehen werden. In SMALLTALK besteht sie aus dem Sonderzeichen ^ (ursprünglich , jedoch auf den meisten Tastaturen nicht verfügbar), gefolgt von einem Ausdruck. Die Return-Anweisung gibt das Objekt zurück, zu dem dieser Ausdruck ausgewertet wird. Da alle anderen Anweisungen in SMALLTALK Ausdrücke sind, die zu einem Objekt ausgewertet werden, benötigen Methoden (Abschnitt 4.3) und Blöcke (Abschnitt 4.4) in SMALLTALK keine Return-Anweisungen, um ein Objekt zurückzugeben. Sie geben automatisch das Objekt zurück, zu dem die letzte Anweisung ausgewertet wird.","<answer> Ja, in SMALLTALK gibt es eine Return-Anweisung, die durch das Sonderzeichen ^ dargestellt wird und normalerweise gefolgt von einem Ausdruck ist. <answer> <question> Gibt es in SMALLTALK eine spezielle Return-Anweisung? <question>"
"Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird. In SMALLTALK gelten alle Ausdrücke, die nicht Teil anderer Ausdrücke sind, als Anweisungen. Im Gegensatz zu JAVA und C# ist in SMALLTALK kein Semikolon erforderlich.
In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt. Dieser Punkt ist ein Trennzeichen (ähnlich wie in PASCAL oder EIFFEL) und gehört nicht zur Anweisung selbst, im Gegensatz zu den von C abgeleiteten Sprachen wie JAVA oder C#. Der Punkt am Ende einer Anweisung kann also weggelassen werden, wenn keine weitere Anweisung folgt. Die Verwendung des Punktes entspricht dem Ziel von SMALLTALK, sich natürlicher Sprache anzunähern. Ähnlich ist die Wahl des Semikolons zur Kaskadierung von Nachrichtenausdrücken zu betrachten.
Die einzige andere Form der Anweisung in SMALLTALK ist die Return-Anweisung, auf die wir im nächsten Kapitel im Zusammenhang mit Methoden näher eingehen werden. In SMALLTALK besteht sie aus dem Sonderzeichen ^ (ursprünglich , jedoch auf den meisten Tastaturen nicht verfügbar), gefolgt von einem Ausdruck. Die Return-Anweisung gibt das Objekt zurück, zu dem dieser Ausdruck ausgewertet wird. Da alle anderen Anweisungen in SMALLTALK Ausdrücke sind, die zu einem Objekt ausgewertet werden, benötigen Methoden (Abschnitt 4.3) und Blöcke (Abschnitt 4.4) in SMALLTALK keine Return-Anweisungen, um ein Objekt zurückzugeben. Sie geben automatisch das Objekt zurück, zu dem die letzte Anweisung ausgewertet wird.","<answer> Die Return-Anweisung gibt das Objekt zurück, zu dem der nachfolgende Ausdruck ausgewertet wird. Sie wird in Methoden und Blöcken verwendet, um das Ergebnis der Ausführung zurückzugeben. <answer> <question> Welche Funktion hat die Return-Anweisung in SMALLTALK? <question>"
"Methoden oder Operationen, die auf unveränderlichen Objekten ausgeführt werden, können deren Zustand naturgemäß nicht ändern. Beispielsweise ändert die Addition von Zahlen nichts an ihren Operanden, sondern liefert als Ergebnis ein anderes Objekt. Derartige Methoden (oder Operationen) sind also klassische Funktionen: Sie berechnen ein Ergebnis anhand eines oder mehrerer Argumente (wovon eines das Empfängerobjekt ist) ohne Nebenwirkungen wie Zustandsänderungen der Argumente.
Für andere Objekte wie zum Beispiel die Punktobjekte aus Abschnitt 4.3.4 ist jedoch fraglich, ob Operationen wie die Addition den Zustand des Empfängers verändern sollten oder ein neues Objekt zurückgeben sollten. Wenn eine Veränderung des Empfängers eher einer Translation entspricht, sollte die entsprechende Methode entsprechend benannt werden. Um jedoch zu zeigen, wie man neue Objekte erzeugen und zurückgeben kann, fehlt uns hier noch einiges. Wir werden darauf erst in Abschnitt 7.3 zurückkommen.","<answer> Unveränderliche oder zustandslose Objekte in SMALLTALK sind Objekte, deren Zustand nicht geändert werden kann. Operationen oder Methoden, die auf solchen Objekten ausgeführt werden, ändern nicht den Zustand des Objekts selbst, sondern erzeugen in der Regel ein neues Objekt als Ergebnis. <answer> <question> Was sind unveränderliche (zustandslose) Objekte in SMALLTALK? <question>"
"Methoden oder Operationen, die auf unveränderlichen Objekten ausgeführt werden, können deren Zustand naturgemäß nicht ändern. Beispielsweise ändert die Addition von Zahlen nichts an ihren Operanden, sondern liefert als Ergebnis ein anderes Objekt. Derartige Methoden (oder Operationen) sind also klassische Funktionen: Sie berechnen ein Ergebnis anhand eines oder mehrerer Argumente (wovon eines das Empfängerobjekt ist) ohne Nebenwirkungen wie Zustandsänderungen der Argumente.
Für andere Objekte wie zum Beispiel die Punktobjekte aus Abschnitt 4.3.4 ist jedoch fraglich, ob Operationen wie die Addition den Zustand des Empfängers verändern sollten oder ein neues Objekt zurückgeben sollten. Wenn eine Veränderung des Empfängers eher einer Translation entspricht, sollte die entsprechende Methode entsprechend benannt werden. Um jedoch zu zeigen, wie man neue Objekte erzeugen und zurückgeben kann, fehlt uns hier noch einiges. Wir werden darauf erst in Abschnitt 7.3 zurückkommen.","<answer> Klassische Funktionen sind Operationen oder Methoden, die auf unveränderlichen Objekten ausgeführt werden und deren Hauptzweck darin besteht, ein Ergebnis aufgrund der Argumente zu berechnen, ohne den Zustand der Argumente zu ändern. Diese Funktionen haben keine Nebenwirkungen und verhalten sich ähnlich wie Funktionen in der mathematischen Welt. <answer> <question> Was sind klassische Funktionen in Bezug auf Operationen auf unveränderlichen Objekten? <question>"
"Methoden oder Operationen, die auf unveränderlichen Objekten ausgeführt werden, können deren Zustand naturgemäß nicht ändern. Beispielsweise ändert die Addition von Zahlen nichts an ihren Operanden, sondern liefert als Ergebnis ein anderes Objekt. Derartige Methoden (oder Operationen) sind also klassische Funktionen: Sie berechnen ein Ergebnis anhand eines oder mehrerer Argumente (wovon eines das Empfängerobjekt ist) ohne Nebenwirkungen wie Zustandsänderungen der Argumente.
Für andere Objekte wie zum Beispiel die Punktobjekte aus Abschnitt 4.3.4 ist jedoch fraglich, ob Operationen wie die Addition den Zustand des Empfängers verändern sollten oder ein neues Objekt zurückgeben sollten. Wenn eine Veränderung des Empfängers eher einer Translation entspricht, sollte die entsprechende Methode entsprechend benannt werden. Um jedoch zu zeigen, wie man neue Objekte erzeugen und zurückgeben kann, fehlt uns hier noch einiges. Wir werden darauf erst in Abschnitt 7.3 zurückkommen.","<answer> In SMALLTALK ändert die Addition von Zahlen nichts am Zustand der Operanden (Zahlen selbst), sondern liefert ein neues Zahl-Objekt als Ergebnis. Es erfolgt keine Änderung am Zustand der Operanden selbst. Dieses Verhalten ist typisch für unveränderliche Objekte und Operationen auf ihnen. <answer> <question> Wie unterscheidet sich die Addition von Zahlen in SMALLTALK von der Änderung des Zustands eines Objekts? <question>"
"Methoden oder Operationen, die auf unveränderlichen Objekten ausgeführt werden, können deren Zustand naturgemäß nicht ändern. Beispielsweise ändert die Addition von Zahlen nichts an ihren Operanden, sondern liefert als Ergebnis ein anderes Objekt. Derartige Methoden (oder Operationen) sind also klassische Funktionen: Sie berechnen ein Ergebnis anhand eines oder mehrerer Argumente (wovon eines das Empfängerobjekt ist) ohne Nebenwirkungen wie Zustandsänderungen der Argumente.
Für andere Objekte wie zum Beispiel die Punktobjekte aus Abschnitt 4.3.4 ist jedoch fraglich, ob Operationen wie die Addition den Zustand des Empfängers verändern sollten oder ein neues Objekt zurückgeben sollten. Wenn eine Veränderung des Empfängers eher einer Translation entspricht, sollte die entsprechende Methode entsprechend benannt werden. Um jedoch zu zeigen, wie man neue Objekte erzeugen und zurückgeben kann, fehlt uns hier noch einiges. Wir werden darauf erst in Abschnitt 7.3 zurückkommen.","<answer> Die Entscheidung darüber, ob eine Methode den Zustand des Empfängers verändern oder ein neues Objekt zurückgeben sollte, hängt von der Semantik des Objekts und der Methode ab. Bei Objekten wie Punktobjekten könnte es unterschiedliche Ansichten darüber geben, ob eine Addition beispielsweise den Zustand des Punktobjekts ändern oder ein neues Punktobjekt erzeugen sollte. Diese Entscheidung kann von der beabsichtigten Anwendung und den Designüberlegungen abhängen. <answer> <question> Warum könnte die Entscheidung, ob eine Methode den Zustand eines Empfängers verändern oder ein neues Objekt zurückgeben sollte, bei bestimmten Objekten wie Punktobjekten schwierig sein? <question>"
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","<answer> Eine einfache Klassendefinition in Java besteht aus dem Klassennamen, der Angabe von Instanzvariablen (Felder) und Instanzmethoden. <answer> <question> Wie sieht eine einfache Klassendefinition in Java aus? <question>"
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","<answer> Instanzvariablen in Java sind Felder, die zur Speicherung von Daten in einer Klasse verwendet werden. Jede Instanz der Klasse hat ihre eigenen Kopien dieser Variablen. <answer> <question> Was sind Instanzvariablen in Java? <question>"
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","<answer> Instanzmethoden in Java sind Methoden, die auf Instanzen (Objekten) einer Klasse angewendet werden können. Sie definieren das Verhalten der Klasse. <answer> <question> Was sind Instanzmethoden in Java? <question>"
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","<answer> ""Member"" ist ein zusammenfassender Begriff für Felder und Methoden innerhalb einer Klassendefinition in Java. <answer> <question> Was sind ""Member"" in Bezug auf Klassendefinitionen in Java? <question>"
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","<answer> In Java können Sie auch geschachtelte Klassendefinitionen und innere Klassendefinitionen erstellen, die ebenfalls als Members der umschließenden Klasse gelten. <answer> <question> Welche weiteren Arten von Klassendefinitionen sind in Java möglich? <question>"
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","<answer> Wenn ein Member als ""static"" deklariert wird, bedeutet dies, dass er sich nicht auf Instanzen der Klasse bezieht, sondern auf die Klasse selbst. Es handelt sich um Klassenvariablen und -methoden. <answer> <question> Was bedeutet es, wenn ein Member in Java als ""static"" deklariert wird? <question>"
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","<answer> ""final""-Variablen werden in Java verwendet, um Konstanten zu deklarieren. Sie dürfen nur einmal einen Wert zugewiesen bekommen und sind dann nicht mehr änderbar. <answer> <question> Wann werden ""final""-Variablen in Java verwendet? <question>"
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","<answer> ""static""-Felder in Java sind nicht automatisch Konstanten, da sie mehrfach geändert werden können. Konstanten werden in Java stattdessen durch das Schlüsselwort ""final"" gekennzeichnet. <answer> <question> Warum sind ""static""-Felder in Java keine Konstanten? <question>"
"Genau wie in JAVA entspricht in C# zunächst jeder Klasse und jedem Interface ein Typ. Mit der Version 2.0 ist C# jedoch ebenfalls generisch geworden. Genauer gesagt erlaubt C# sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus, wobei die Syntax für unbeschränkte sich nicht von der von JAVA unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C# erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).
Auch wenn sich die Generics von C# auf den ersten Blick nicht groß von denen von JAVA zu unterscheiden scheinen, verbirgt sich hinter der Oberfläche doch ein anderer Mechanismus. Während JAVA die Typparameter grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type erasure), instanziiert C# im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Dies hat den Vorteil, dass diese Implementierungen ohne Boxing/Unboxing auskommen und vom JIT-Compiler durch Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird der Code jedoch (wie in JAVA) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C# auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.
Genau wie in JAVA gibt es in C# beim Subtyping von Containern (wie z. B. Collections) ein Varianzproblem: Collection<A> und Collection<B> sind auch dann nicht zuweisungskompatibel, wenn A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch Zuweisungskompatibilität herzustellen, sieht C# keine spezielle Annotation der Benutzung eines Typs wie in JAVA vor, sondern eine Annotation der Definition des Typs: Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen. Übrigens: Für Arrays in C# gilt dasselbe wie in JAVA: Sie sind kovariant, das Schreiben in ein Array kann jedoch zu einem Laufzeittypfehler führen, der in C# ""Array Type-Mismatch Exception"" heißt.","<answer> Generizität in C# ermöglicht es, parametrischen Polymorphismus sowohl für Klassen als auch für Methoden zu nutzen. Sie erlaubt die Definition von generischen Klassen und Interfaces, die eine Menge von Typen spezifizieren, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. <answer> <question> Was ist Generizität in C#? <question>"
"Genau wie in JAVA entspricht in C# zunächst jeder Klasse und jedem Interface ein Typ. Mit der Version 2.0 ist C# jedoch ebenfalls generisch geworden. Genauer gesagt erlaubt C# sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus, wobei die Syntax für unbeschränkte sich nicht von der von JAVA unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C# erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).
Auch wenn sich die Generics von C# auf den ersten Blick nicht groß von denen von JAVA zu unterscheiden scheinen, verbirgt sich hinter der Oberfläche doch ein anderer Mechanismus. Während JAVA die Typparameter grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type erasure), instanziiert C# im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Dies hat den Vorteil, dass diese Implementierungen ohne Boxing/Unboxing auskommen und vom JIT-Compiler durch Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird der Code jedoch (wie in JAVA) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C# auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.
Genau wie in JAVA gibt es in C# beim Subtyping von Containern (wie z. B. Collections) ein Varianzproblem: Collection<A> und Collection<B> sind auch dann nicht zuweisungskompatibel, wenn A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch Zuweisungskompatibilität herzustellen, sieht C# keine spezielle Annotation der Benutzung eines Typs wie in JAVA vor, sondern eine Annotation der Definition des Typs: Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen. Übrigens: Für Arrays in C# gilt dasselbe wie in JAVA: Sie sind kovariant, das Schreiben in ein Array kann jedoch zu einem Laufzeittypfehler führen, der in C# ""Array Type-Mismatch Exception"" heißt.","<answer> C# unterstützt sowohl beschränkte als auch unbeschränkte parametrische Polymorphismus für Klassen und Methoden. Dies bedeutet, dass Typparameter sowohl eingeschränkte (mit bestimmten Anforderungen) als auch unbeschränkte (ohne Anforderungen) Typen sein können. <answer> <question> Welche Arten von Generizität werden in C# unterstützt? <question>"
"Genau wie in JAVA entspricht in C# zunächst jeder Klasse und jedem Interface ein Typ. Mit der Version 2.0 ist C# jedoch ebenfalls generisch geworden. Genauer gesagt erlaubt C# sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus, wobei die Syntax für unbeschränkte sich nicht von der von JAVA unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C# erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).
Auch wenn sich die Generics von C# auf den ersten Blick nicht groß von denen von JAVA zu unterscheiden scheinen, verbirgt sich hinter der Oberfläche doch ein anderer Mechanismus. Während JAVA die Typparameter grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type erasure), instanziiert C# im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Dies hat den Vorteil, dass diese Implementierungen ohne Boxing/Unboxing auskommen und vom JIT-Compiler durch Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird der Code jedoch (wie in JAVA) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C# auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.
Genau wie in JAVA gibt es in C# beim Subtyping von Containern (wie z. B. Collections) ein Varianzproblem: Collection<A> und Collection<B> sind auch dann nicht zuweisungskompatibel, wenn A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch Zuweisungskompatibilität herzustellen, sieht C# keine spezielle Annotation der Benutzung eines Typs wie in JAVA vor, sondern eine Annotation der Definition des Typs: Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen. Übrigens: Für Arrays in C# gilt dasselbe wie in JAVA: Sie sind kovariant, das Schreiben in ein Array kann jedoch zu einem Laufzeittypfehler führen, der in C# ""Array Type-Mismatch Exception"" heißt.","<answer> Obwohl die Oberfläche von C# Generics der von Java ähnelt, unterscheidet sich der Mechanismus dahinter. C# instanziiert generische Klassen für Werttypen (wie int oder selbst definierte structs) für jeden verwendeten Typ, während Java Typparameter grundsätzlich immer entfernt (Type Erasure) und nur eine Implementierung erzeugt. <answer> <question> Was ist der Unterschied zwischen C# Generics und Generics in Java? <question>"
"Genau wie in JAVA entspricht in C# zunächst jeder Klasse und jedem Interface ein Typ. Mit der Version 2.0 ist C# jedoch ebenfalls generisch geworden. Genauer gesagt erlaubt C# sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus, wobei die Syntax für unbeschränkte sich nicht von der von JAVA unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C# erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).
Auch wenn sich die Generics von C# auf den ersten Blick nicht groß von denen von JAVA zu unterscheiden scheinen, verbirgt sich hinter der Oberfläche doch ein anderer Mechanismus. Während JAVA die Typparameter grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type erasure), instanziiert C# im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Dies hat den Vorteil, dass diese Implementierungen ohne Boxing/Unboxing auskommen und vom JIT-Compiler durch Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird der Code jedoch (wie in JAVA) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C# auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.
Genau wie in JAVA gibt es in C# beim Subtyping von Containern (wie z. B. Collections) ein Varianzproblem: Collection<A> und Collection<B> sind auch dann nicht zuweisungskompatibel, wenn A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch Zuweisungskompatibilität herzustellen, sieht C# keine spezielle Annotation der Benutzung eines Typs wie in JAVA vor, sondern eine Annotation der Definition des Typs: Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen. Übrigens: Für Arrays in C# gilt dasselbe wie in JAVA: Sie sind kovariant, das Schreiben in ein Array kann jedoch zu einem Laufzeittypfehler führen, der in C# ""Array Type-Mismatch Exception"" heißt.","<answer> In C# wird das Varianzproblem bei der Subtypisierung von Containern durch das Hinzufügen des Schlüsselworts ""out"" für kovariante Typparameter und ""in"" für kontravariante Typparameter bei der Definition des Typs gelöst. Dies stellt sicher, dass Zuweisungskompatibilität auch dann gegeben ist, wenn die generischen Typen verschiedene Typparameter haben. <answer> <question> Wie wird das Varianzproblem bei der Subtypisierung von Containern in C# gelöst? <question>"
"Genau wie in JAVA entspricht in C# zunächst jeder Klasse und jedem Interface ein Typ. Mit der Version 2.0 ist C# jedoch ebenfalls generisch geworden. Genauer gesagt erlaubt C# sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus, wobei die Syntax für unbeschränkte sich nicht von der von JAVA unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C# erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).
Auch wenn sich die Generics von C# auf den ersten Blick nicht groß von denen von JAVA zu unterscheiden scheinen, verbirgt sich hinter der Oberfläche doch ein anderer Mechanismus. Während JAVA die Typparameter grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type erasure), instanziiert C# im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Dies hat den Vorteil, dass diese Implementierungen ohne Boxing/Unboxing auskommen und vom JIT-Compiler durch Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird der Code jedoch (wie in JAVA) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C# auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.
Genau wie in JAVA gibt es in C# beim Subtyping von Containern (wie z. B. Collections) ein Varianzproblem: Collection<A> und Collection<B> sind auch dann nicht zuweisungskompatibel, wenn A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch Zuweisungskompatibilität herzustellen, sieht C# keine spezielle Annotation der Benutzung eines Typs wie in JAVA vor, sondern eine Annotation der Definition des Typs: Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen. Übrigens: Für Arrays in C# gilt dasselbe wie in JAVA: Sie sind kovariant, das Schreiben in ein Array kann jedoch zu einem Laufzeittypfehler führen, der in C# ""Array Type-Mismatch Exception"" heißt.","<answer> Die Typexpansion in C# ermöglicht es, generische Klassen für Werttypen ohne Boxing/Unboxing zu optimieren. Dies führt zu besserer Leistung und geringerem Overhead, da der JIT-Compiler den Code für verschiedene Typen optimieren kann. <answer> <question> Welche Vorteile bietet die Typexpansion in C# für Werttypen? <question>"
"Genau wie in JAVA entspricht in C# zunächst jeder Klasse und jedem Interface ein Typ. Mit der Version 2.0 ist C# jedoch ebenfalls generisch geworden. Genauer gesagt erlaubt C# sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus, wobei die Syntax für unbeschränkte sich nicht von der von JAVA unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C# erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).
Auch wenn sich die Generics von C# auf den ersten Blick nicht groß von denen von JAVA zu unterscheiden scheinen, verbirgt sich hinter der Oberfläche doch ein anderer Mechanismus. Während JAVA die Typparameter grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type erasure), instanziiert C# im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Dies hat den Vorteil, dass diese Implementierungen ohne Boxing/Unboxing auskommen und vom JIT-Compiler durch Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird der Code jedoch (wie in JAVA) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C# auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.
Genau wie in JAVA gibt es in C# beim Subtyping von Containern (wie z. B. Collections) ein Varianzproblem: Collection<A> und Collection<B> sind auch dann nicht zuweisungskompatibel, wenn A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch Zuweisungskompatibilität herzustellen, sieht C# keine spezielle Annotation der Benutzung eines Typs wie in JAVA vor, sondern eine Annotation der Definition des Typs: Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen. Übrigens: Für Arrays in C# gilt dasselbe wie in JAVA: Sie sind kovariant, das Schreiben in ein Array kann jedoch zu einem Laufzeittypfehler führen, der in C# ""Array Type-Mismatch Exception"" heißt.","<answer> Ja, in C# bleibt die generische Typinformation auch zur Laufzeit erhalten und kann per Reflection abgefragt werden. <answer> <question> Bleibt die generische Typinformation in C# auch zur Laufzeit erhalten? <question>"
"Genau wie in JAVA entspricht in C# zunächst jeder Klasse und jedem Interface ein Typ. Mit der Version 2.0 ist C# jedoch ebenfalls generisch geworden. Genauer gesagt erlaubt C# sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus, wobei die Syntax für unbeschränkte sich nicht von der von JAVA unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C# erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).
Auch wenn sich die Generics von C# auf den ersten Blick nicht groß von denen von JAVA zu unterscheiden scheinen, verbirgt sich hinter der Oberfläche doch ein anderer Mechanismus. Während JAVA die Typparameter grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type erasure), instanziiert C# im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Dies hat den Vorteil, dass diese Implementierungen ohne Boxing/Unboxing auskommen und vom JIT-Compiler durch Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird der Code jedoch (wie in JAVA) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C# auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.
Genau wie in JAVA gibt es in C# beim Subtyping von Containern (wie z. B. Collections) ein Varianzproblem: Collection<A> und Collection<B> sind auch dann nicht zuweisungskompatibel, wenn A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch Zuweisungskompatibilität herzustellen, sieht C# keine spezielle Annotation der Benutzung eines Typs wie in JAVA vor, sondern eine Annotation der Definition des Typs: Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen. Übrigens: Für Arrays in C# gilt dasselbe wie in JAVA: Sie sind kovariant, das Schreiben in ein Array kann jedoch zu einem Laufzeittypfehler führen, der in C# ""Array Type-Mismatch Exception"" heißt.","<answer> Ja, C# unterstützt Typparameter-Inferenz, was bedeutet, dass der Compiler den tatsächlichen Typparameter bei generischen Methodenaufrufen automatisch aus den Argumenten ableiten kann. Dies führt zu weniger Code und erhöht die Lesbarkeit. <answer> <question> Gibt es in C# eine Möglichkeit zur Typparameter-Inferenz bei generischen Methodenaufrufen? <question>"
"Weil Literale immer die gleichen Objekte repräsentieren, reichen sie zum Programmieren nicht aus. Was man vielmehr auch noch benötigt, sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können, die sogenannten Variablen.
Genau wie ein Literal steht eine Variable in einem Programm für ein Objekt. Anders als bei Literalen wird aus einer Variable jedoch kein Objekt erzeugt: Sie ist lediglich ein Name für ein bereits existierendes Objekt. Dazu kommt, dass eine Variable zu unterschiedlichen Zeitpunkten für unterschiedliche Objekte stehen kann (deshalb der Name „Variable“!). Es können zudem Variablen mit unterschiedlichen Namen für dasselbe Objekt stehen, das damit gewissermaßen verschiedene Namen hat (die sogenannten Aliase; siehe Abschnitt 1.8). Im Folgenden werden wir daher davon sprechen, dass Variablen Objekte benennen oder bezeichnen.",<answer> Weil Literale immer die gleichen Objekte repräsentieren. <answer> <question> Warum reichen Literale allein zum Programmieren nicht aus? <question>
"Weil Literale immer die gleichen Objekte repräsentieren, reichen sie zum Programmieren nicht aus. Was man vielmehr auch noch benötigt, sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können, die sogenannten Variablen.
Genau wie ein Literal steht eine Variable in einem Programm für ein Objekt. Anders als bei Literalen wird aus einer Variable jedoch kein Objekt erzeugt: Sie ist lediglich ein Name für ein bereits existierendes Objekt. Dazu kommt, dass eine Variable zu unterschiedlichen Zeitpunkten für unterschiedliche Objekte stehen kann (deshalb der Name „Variable“!). Es können zudem Variablen mit unterschiedlichen Namen für dasselbe Objekt stehen, das damit gewissermaßen verschiedene Namen hat (die sogenannten Aliase; siehe Abschnitt 1.8). Im Folgenden werden wir daher davon sprechen, dass Variablen Objekte benennen oder bezeichnen.","<answer> Variablen sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können und sind notwendig, weil Literale nicht ausreichen. <answer> <question> Was sind Variablen und warum sind sie notwendig beim Programmieren? <question>"
"Weil Literale immer die gleichen Objekte repräsentieren, reichen sie zum Programmieren nicht aus. Was man vielmehr auch noch benötigt, sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können, die sogenannten Variablen.
Genau wie ein Literal steht eine Variable in einem Programm für ein Objekt. Anders als bei Literalen wird aus einer Variable jedoch kein Objekt erzeugt: Sie ist lediglich ein Name für ein bereits existierendes Objekt. Dazu kommt, dass eine Variable zu unterschiedlichen Zeitpunkten für unterschiedliche Objekte stehen kann (deshalb der Name „Variable“!). Es können zudem Variablen mit unterschiedlichen Namen für dasselbe Objekt stehen, das damit gewissermaßen verschiedene Namen hat (die sogenannten Aliase; siehe Abschnitt 1.8). Im Folgenden werden wir daher davon sprechen, dass Variablen Objekte benennen oder bezeichnen.","<answer> Anders als bei Literalen wird aus einer Variable kein Objekt erzeugt, sie ist lediglich ein Name für ein bereits existierendes Objekt. <answer> <question> Wie unterscheiden sich Variablen von Literalen in Bezug auf die Objektrepräsentation? <question>"
"In der Klasse Object ist das Protokoll definiert, das allen Objekten gemeinsam ist, d. h., für das alle Klassen Methodendefinitionen haben, und zwar entweder eigene oder geerbte. Object gibt zu diesem Zweck Standardimplementierungen vor, die von den meisten Objekten direkt übernommen werden können (und nur von den wenigen überschrieben werden müssen). Dazu zählen z. B. die bereits mehrfach erwähnten isNil und notNil (die nur von UndefinedObject überschrieben werden) sowie zahlreiche weitere Typtests (isInteger, isFloat usw.). Daneben gibt es auch noch eine ganze Reihe anderer Methoden, deren Kenntnis sich lohnt.","<answer> Das Protokoll, das allen Objekten gemeinsam ist, ist in der Klasse ""Object"" definiert. Es ist wichtig, weil es Methodendefinitionen enthält, die von allen Klassen entweder geerbt oder in den meisten Fällen direkt übernommen werden können. Diese Methoden sind grundlegende Funktionen, die für alle Objekte verfügbar sind und von den meisten Objekten nicht überschrieben werden müssen. <answer> <question> In welcher Klasse ist das Protokoll definiert, das allen Objekten gemeinsam ist, und warum ist es wichtig? <question>"
"In der Klasse Object ist das Protokoll definiert, das allen Objekten gemeinsam ist, d. h., für das alle Klassen Methodendefinitionen haben, und zwar entweder eigene oder geerbte. Object gibt zu diesem Zweck Standardimplementierungen vor, die von den meisten Objekten direkt übernommen werden können (und nur von den wenigen überschrieben werden müssen). Dazu zählen z. B. die bereits mehrfach erwähnten isNil und notNil (die nur von UndefinedObject überschrieben werden) sowie zahlreiche weitere Typtests (isInteger, isFloat usw.). Daneben gibt es auch noch eine ganze Reihe anderer Methoden, deren Kenntnis sich lohnt.","<answer> Die Klasse ""Object"" bietet eine Vielzahl von Methoden an, die grundlegende Typtests und andere gemeinsame Operationen für Objekte ermöglichen. Dazu gehören Methoden wie isNil, notNil, isInteger, isFloat und viele andere. Diese Methoden erlauben es, Eigenschaften von Objekten abzufragen und deren Typ zu überprüfen. <answer> <question> Welche Art von Methoden bietet die Klasse ""Object"" den Objekten an? <question>"
"Die Unterscheidung zwischen lokalen und globalen Variablen aus Abschnitt 1.5.2 dient unter anderem dazu, Geheimnisse zu verbergen, was auch als Geheimnisprinzip oder Information Hiding bezeichnet wird. Genauer gesagt geht es dabei um das Verbergen von Implementationsdetails. Es ist fast immer sinnvoll, die Struktur zusammengesetzter Objekte vor den Objekten zu verbergen, die sie verwenden, damit Änderungen an dieser Struktur vorgenommen werden können, ohne dass die verwendenden (abhängigen) Objekte davon betroffen sind. Solche Änderungsabhängigkeiten werden vermieden, indem die Variablen von außen nicht zugänglich sind, was automatisch für lokale Variablen gilt, da sie von außen unsichtbar sind.
Von dieser Idee des Geheimnisprinzips zu unterscheiden ist der Begriff der Kapselung, der eng mit der objektorientierten Programmierung verknüpft ist. Hierbei geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann. Im Gegensatz zum Information Hiding handelt es sich bei der Kapselung nicht um die Veränderung der Struktur von Objekten, sondern um die Veränderung ihres Zustands. Leider lässt sich die Kapselung nicht mit denselben Mitteln wie das Geheimnisprinzip umsetzen. Aufgrund von Aliasing kann ein Objekt, dessen Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, über einen anderen Namen zugänglich sein, ohne dass der erste Name dagegen etwas unternehmen könnte. Über lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt, aber es kann nicht verhindern, dass andere Objekte diese Objekte auch kennen und ohne sein Wissen manipulieren. Aufgrund der möglichen Existenz von Aliasen ist es daher nicht möglich, dass ein Objekt seinen inneren Aufbau vor der Außenwelt vollständig abschottet, es sei denn, es trifft spezielle Vorkehrungen. Diese Vorkehrungen sind derzeit noch nicht in gängige objektorientierte Programmiersprachen integriert und müssen explizit programmiert werden. Aus diesem Grund werden wir uns in dieser Kurseinheit nicht weiter damit befassen. Eine vertiefte Betrachtung erfolgt in Kapitel 58 von Kurseinheit 6.","<answer> Das Geheimnisprinzip oder Information Hiding bezieht sich auf das Verbergen von Implementationsdetails eines Objekts, insbesondere der Struktur zusammengesetzter Objekte, vor den Objekten, die sie verwenden. Dadurch können Änderungen an der Struktur vorgenommen werden, ohne dass abhängige Objekte davon betroffen sind. <answer> <question> Was versteht man unter dem Geheimnisprinzip oder Information Hiding in der objektorientierten Programmierung? <question>"
"Die Unterscheidung zwischen lokalen und globalen Variablen aus Abschnitt 1.5.2 dient unter anderem dazu, Geheimnisse zu verbergen, was auch als Geheimnisprinzip oder Information Hiding bezeichnet wird. Genauer gesagt geht es dabei um das Verbergen von Implementationsdetails. Es ist fast immer sinnvoll, die Struktur zusammengesetzter Objekte vor den Objekten zu verbergen, die sie verwenden, damit Änderungen an dieser Struktur vorgenommen werden können, ohne dass die verwendenden (abhängigen) Objekte davon betroffen sind. Solche Änderungsabhängigkeiten werden vermieden, indem die Variablen von außen nicht zugänglich sind, was automatisch für lokale Variablen gilt, da sie von außen unsichtbar sind.
Von dieser Idee des Geheimnisprinzips zu unterscheiden ist der Begriff der Kapselung, der eng mit der objektorientierten Programmierung verknüpft ist. Hierbei geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann. Im Gegensatz zum Information Hiding handelt es sich bei der Kapselung nicht um die Veränderung der Struktur von Objekten, sondern um die Veränderung ihres Zustands. Leider lässt sich die Kapselung nicht mit denselben Mitteln wie das Geheimnisprinzip umsetzen. Aufgrund von Aliasing kann ein Objekt, dessen Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, über einen anderen Namen zugänglich sein, ohne dass der erste Name dagegen etwas unternehmen könnte. Über lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt, aber es kann nicht verhindern, dass andere Objekte diese Objekte auch kennen und ohne sein Wissen manipulieren. Aufgrund der möglichen Existenz von Aliasen ist es daher nicht möglich, dass ein Objekt seinen inneren Aufbau vor der Außenwelt vollständig abschottet, es sei denn, es trifft spezielle Vorkehrungen. Diese Vorkehrungen sind derzeit noch nicht in gängige objektorientierte Programmiersprachen integriert und müssen explizit programmiert werden. Aus diesem Grund werden wir uns in dieser Kurseinheit nicht weiter damit befassen. Eine vertiefte Betrachtung erfolgt in Kapitel 58 von Kurseinheit 6.","<answer> Der Unterschied besteht darin, dass das Geheimnisprinzip sich auf das Verbergen von Implementationsdetails und Struktur bezieht, während die Kapselung sich auf das Verbergen und die Kontrolle des Zustands eines Objekts bezieht. Die Kapselung ermöglicht es einem Objekt, seinen Zustand so zu kapseln, dass dieser nur von ihm selbst geändert werden kann. <answer> <question> Was ist der Unterschied zwischen dem Geheimnisprinzip und der Kapselung in der objektorientierten Programmierung? <question>"
"Die Unterscheidung zwischen lokalen und globalen Variablen aus Abschnitt 1.5.2 dient unter anderem dazu, Geheimnisse zu verbergen, was auch als Geheimnisprinzip oder Information Hiding bezeichnet wird. Genauer gesagt geht es dabei um das Verbergen von Implementationsdetails. Es ist fast immer sinnvoll, die Struktur zusammengesetzter Objekte vor den Objekten zu verbergen, die sie verwenden, damit Änderungen an dieser Struktur vorgenommen werden können, ohne dass die verwendenden (abhängigen) Objekte davon betroffen sind. Solche Änderungsabhängigkeiten werden vermieden, indem die Variablen von außen nicht zugänglich sind, was automatisch für lokale Variablen gilt, da sie von außen unsichtbar sind.
Von dieser Idee des Geheimnisprinzips zu unterscheiden ist der Begriff der Kapselung, der eng mit der objektorientierten Programmierung verknüpft ist. Hierbei geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann. Im Gegensatz zum Information Hiding handelt es sich bei der Kapselung nicht um die Veränderung der Struktur von Objekten, sondern um die Veränderung ihres Zustands. Leider lässt sich die Kapselung nicht mit denselben Mitteln wie das Geheimnisprinzip umsetzen. Aufgrund von Aliasing kann ein Objekt, dessen Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, über einen anderen Namen zugänglich sein, ohne dass der erste Name dagegen etwas unternehmen könnte. Über lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt, aber es kann nicht verhindern, dass andere Objekte diese Objekte auch kennen und ohne sein Wissen manipulieren. Aufgrund der möglichen Existenz von Aliasen ist es daher nicht möglich, dass ein Objekt seinen inneren Aufbau vor der Außenwelt vollständig abschottet, es sei denn, es trifft spezielle Vorkehrungen. Diese Vorkehrungen sind derzeit noch nicht in gängige objektorientierte Programmiersprachen integriert und müssen explizit programmiert werden. Aus diesem Grund werden wir uns in dieser Kurseinheit nicht weiter damit befassen. Eine vertiefte Betrachtung erfolgt in Kapitel 58 von Kurseinheit 6.","<answer> Die Kapselung kann nicht mit denselben Mitteln wie das Geheimnisprinzip umgesetzt werden, weil aufgrund von Aliasing ein Objekt, dessen Name unsichtbar ist, über einen anderen Namen zugänglich sein kann, ohne dass das erste Objekt dagegen etwas unternehmen könnte. Die Kapselung betrifft die Kontrolle des Zustands eines Objekts, während das Geheimnisprinzip sich auf die Struktur bezieht. <answer> <question> Warum kann die Kapselung nicht mit denselben Mitteln wie das Geheimnisprinzip umgesetzt werden? <question>"
"Die Unterscheidung zwischen lokalen und globalen Variablen aus Abschnitt 1.5.2 dient unter anderem dazu, Geheimnisse zu verbergen, was auch als Geheimnisprinzip oder Information Hiding bezeichnet wird. Genauer gesagt geht es dabei um das Verbergen von Implementationsdetails. Es ist fast immer sinnvoll, die Struktur zusammengesetzter Objekte vor den Objekten zu verbergen, die sie verwenden, damit Änderungen an dieser Struktur vorgenommen werden können, ohne dass die verwendenden (abhängigen) Objekte davon betroffen sind. Solche Änderungsabhängigkeiten werden vermieden, indem die Variablen von außen nicht zugänglich sind, was automatisch für lokale Variablen gilt, da sie von außen unsichtbar sind.
Von dieser Idee des Geheimnisprinzips zu unterscheiden ist der Begriff der Kapselung, der eng mit der objektorientierten Programmierung verknüpft ist. Hierbei geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann. Im Gegensatz zum Information Hiding handelt es sich bei der Kapselung nicht um die Veränderung der Struktur von Objekten, sondern um die Veränderung ihres Zustands. Leider lässt sich die Kapselung nicht mit denselben Mitteln wie das Geheimnisprinzip umsetzen. Aufgrund von Aliasing kann ein Objekt, dessen Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, über einen anderen Namen zugänglich sein, ohne dass der erste Name dagegen etwas unternehmen könnte. Über lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt, aber es kann nicht verhindern, dass andere Objekte diese Objekte auch kennen und ohne sein Wissen manipulieren. Aufgrund der möglichen Existenz von Aliasen ist es daher nicht möglich, dass ein Objekt seinen inneren Aufbau vor der Außenwelt vollständig abschottet, es sei denn, es trifft spezielle Vorkehrungen. Diese Vorkehrungen sind derzeit noch nicht in gängige objektorientierte Programmiersprachen integriert und müssen explizit programmiert werden. Aus diesem Grund werden wir uns in dieser Kurseinheit nicht weiter damit befassen. Eine vertiefte Betrachtung erfolgt in Kapitel 58 von Kurseinheit 6.","<answer> Ein Objekt kann seinen inneren Aufbau nicht vollständig vor der Außenwelt abschotten, da aufgrund der möglichen Existenz von Aliasen andere Objekte diese Objekte kennen und ohne sein Wissen manipulieren können. Die Abschottung erfordert spezielle Vorkehrungen, die derzeit nicht in gängige objektorientierte Programmiersprachen integriert sind und explizit programmiert werden müssen. <answer> <question> Warum kann ein Objekt seinen inneren Aufbau vor der Außenwelt nicht vollständig abschotten? <question>"
"Zuweisungskompatibilität unter Subtyping erlaubt also die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps. Für die statische Typprüfung ergibt sich daraus kein Problem, weil sichergestellt ist, dass die Subtypen alle Eigenschaften ihrer Supertypen erhalten, so dass keine Typfehler auftreten können. Für die Programmiererin ergibt sich aber manchmal das Problem, dass sie ein Objekt, auf das eine Variable eines Supertyps verweist, wie ein Objekt seines tatsächlichen Typs verwenden möchte, in der Regel, weil sie eine Methode darauf aufrufen möchte, die der Supertyp nicht hat. Genau diesen Methodenaufruf würde die Typprüfung aber zurückweisen.
Für diesen Zweck gibt es die Möglichkeit der Typumwandlung (engl. type cast). Eine Typumwandlung ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen konvertiert wird. Mit dem Objekt, für das der Ausdruck steht, passiert dabei gar nichts — es wird lediglich der Compiler (bzw. der Type Checker) davon überzeugt, dass der Ausdruck den bei der Umwandlung angegebenen Typ hat. Sollte sich zur Laufzeit herausstellen, dass das nicht der Fall ist, kann ein Laufzeittypsystem — soweit vorhanden — dies bei seiner dynamischen Typprüfung bemerken und ggf. einen entsprechenden Fehler melden (vgl. die Anmerkungen dazu in Kapitel 18).
Typumwandlungen können grundsätzlich in verschiedene Richtungen erfolgen: zu Supertypen, zu Subtypen oder zu solchen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Man spricht entsprechend von Upcast, Downcast oder Crosscast. Upcasts sind immer typsicher, Downcasts und Crosscasts nicht. Downcasts sind relativ häufig; sie kommen vor allem dort vor, wo kein parametrischer Polymorphismus (Kapitel 29) zur Verfügung steht oder wo ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten; in der interfacebasierten Programmierung (s. Abschnitt 28.2) stehen sie für einen Rollenwechsel eines Objekts.
Nun sind Typumwandlungen entweder überflüssig oder unsicher. Man sollte daher versuchen, auf sie zu verzichten. Wo unverzichtbar, sollten Typumwandlungen mit einem Typtest abgesichert werden. Dabei wird zur Laufzeit geprüft, ob das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat. Ist das nicht der Fall, sollten die Teile des Programms, die den bei der Typumwandlung genannten Typ voraussetzen, nicht ausgeführt werden. Sie werden in späteren Kapiteln zu den einzelnen Programmiersprachen noch Beispiele für diese Praxis zu sehen bekommen.",<answer> Die Zuweisungskompatibilität unter Subtyping erlaubt die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps. <answer> <question> Was erlaubt die Zuweisungskompatibilität unter Subtyping? <question>
"Zuweisungskompatibilität unter Subtyping erlaubt also die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps. Für die statische Typprüfung ergibt sich daraus kein Problem, weil sichergestellt ist, dass die Subtypen alle Eigenschaften ihrer Supertypen erhalten, so dass keine Typfehler auftreten können. Für die Programmiererin ergibt sich aber manchmal das Problem, dass sie ein Objekt, auf das eine Variable eines Supertyps verweist, wie ein Objekt seines tatsächlichen Typs verwenden möchte, in der Regel, weil sie eine Methode darauf aufrufen möchte, die der Supertyp nicht hat. Genau diesen Methodenaufruf würde die Typprüfung aber zurückweisen.
Für diesen Zweck gibt es die Möglichkeit der Typumwandlung (engl. type cast). Eine Typumwandlung ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen konvertiert wird. Mit dem Objekt, für das der Ausdruck steht, passiert dabei gar nichts — es wird lediglich der Compiler (bzw. der Type Checker) davon überzeugt, dass der Ausdruck den bei der Umwandlung angegebenen Typ hat. Sollte sich zur Laufzeit herausstellen, dass das nicht der Fall ist, kann ein Laufzeittypsystem — soweit vorhanden — dies bei seiner dynamischen Typprüfung bemerken und ggf. einen entsprechenden Fehler melden (vgl. die Anmerkungen dazu in Kapitel 18).
Typumwandlungen können grundsätzlich in verschiedene Richtungen erfolgen: zu Supertypen, zu Subtypen oder zu solchen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Man spricht entsprechend von Upcast, Downcast oder Crosscast. Upcasts sind immer typsicher, Downcasts und Crosscasts nicht. Downcasts sind relativ häufig; sie kommen vor allem dort vor, wo kein parametrischer Polymorphismus (Kapitel 29) zur Verfügung steht oder wo ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten; in der interfacebasierten Programmierung (s. Abschnitt 28.2) stehen sie für einen Rollenwechsel eines Objekts.
Nun sind Typumwandlungen entweder überflüssig oder unsicher. Man sollte daher versuchen, auf sie zu verzichten. Wo unverzichtbar, sollten Typumwandlungen mit einem Typtest abgesichert werden. Dabei wird zur Laufzeit geprüft, ob das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat. Ist das nicht der Fall, sollten die Teile des Programms, die den bei der Typumwandlung genannten Typ voraussetzen, nicht ausgeführt werden. Sie werden in späteren Kapiteln zu den einzelnen Programmiersprachen noch Beispiele für diese Praxis zu sehen bekommen.","<answer> Es kann problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden, da der Supertyp möglicherweise nicht alle Methoden und Eigenschaften des tatsächlichen Typs enthält, die die Programmiererin verwenden möchte. <answer> <question> Warum kann es für die Programmiererin problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden? <question>"
"Zuweisungskompatibilität unter Subtyping erlaubt also die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps. Für die statische Typprüfung ergibt sich daraus kein Problem, weil sichergestellt ist, dass die Subtypen alle Eigenschaften ihrer Supertypen erhalten, so dass keine Typfehler auftreten können. Für die Programmiererin ergibt sich aber manchmal das Problem, dass sie ein Objekt, auf das eine Variable eines Supertyps verweist, wie ein Objekt seines tatsächlichen Typs verwenden möchte, in der Regel, weil sie eine Methode darauf aufrufen möchte, die der Supertyp nicht hat. Genau diesen Methodenaufruf würde die Typprüfung aber zurückweisen.
Für diesen Zweck gibt es die Möglichkeit der Typumwandlung (engl. type cast). Eine Typumwandlung ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen konvertiert wird. Mit dem Objekt, für das der Ausdruck steht, passiert dabei gar nichts — es wird lediglich der Compiler (bzw. der Type Checker) davon überzeugt, dass der Ausdruck den bei der Umwandlung angegebenen Typ hat. Sollte sich zur Laufzeit herausstellen, dass das nicht der Fall ist, kann ein Laufzeittypsystem — soweit vorhanden — dies bei seiner dynamischen Typprüfung bemerken und ggf. einen entsprechenden Fehler melden (vgl. die Anmerkungen dazu in Kapitel 18).
Typumwandlungen können grundsätzlich in verschiedene Richtungen erfolgen: zu Supertypen, zu Subtypen oder zu solchen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Man spricht entsprechend von Upcast, Downcast oder Crosscast. Upcasts sind immer typsicher, Downcasts und Crosscasts nicht. Downcasts sind relativ häufig; sie kommen vor allem dort vor, wo kein parametrischer Polymorphismus (Kapitel 29) zur Verfügung steht oder wo ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten; in der interfacebasierten Programmierung (s. Abschnitt 28.2) stehen sie für einen Rollenwechsel eines Objekts.
Nun sind Typumwandlungen entweder überflüssig oder unsicher. Man sollte daher versuchen, auf sie zu verzichten. Wo unverzichtbar, sollten Typumwandlungen mit einem Typtest abgesichert werden. Dabei wird zur Laufzeit geprüft, ob das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat. Ist das nicht der Fall, sollten die Teile des Programms, die den bei der Typumwandlung genannten Typ voraussetzen, nicht ausgeführt werden. Sie werden in späteren Kapiteln zu den einzelnen Programmiersprachen noch Beispiele für diese Praxis zu sehen bekommen.","<answer> Eine Typumwandlung (type cast) ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen Typ konvertiert wird. Dies geschieht, um dem Compiler oder Type Checker mitzuteilen, dass der Ausdruck den angegebenen Typ hat, auch wenn dies nicht automatisch sichergestellt ist. <answer> <question> Was ist eine Typumwandlung? <question>"
"Zuweisungskompatibilität unter Subtyping erlaubt also die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps. Für die statische Typprüfung ergibt sich daraus kein Problem, weil sichergestellt ist, dass die Subtypen alle Eigenschaften ihrer Supertypen erhalten, so dass keine Typfehler auftreten können. Für die Programmiererin ergibt sich aber manchmal das Problem, dass sie ein Objekt, auf das eine Variable eines Supertyps verweist, wie ein Objekt seines tatsächlichen Typs verwenden möchte, in der Regel, weil sie eine Methode darauf aufrufen möchte, die der Supertyp nicht hat. Genau diesen Methodenaufruf würde die Typprüfung aber zurückweisen.
Für diesen Zweck gibt es die Möglichkeit der Typumwandlung (engl. type cast). Eine Typumwandlung ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen konvertiert wird. Mit dem Objekt, für das der Ausdruck steht, passiert dabei gar nichts — es wird lediglich der Compiler (bzw. der Type Checker) davon überzeugt, dass der Ausdruck den bei der Umwandlung angegebenen Typ hat. Sollte sich zur Laufzeit herausstellen, dass das nicht der Fall ist, kann ein Laufzeittypsystem — soweit vorhanden — dies bei seiner dynamischen Typprüfung bemerken und ggf. einen entsprechenden Fehler melden (vgl. die Anmerkungen dazu in Kapitel 18).
Typumwandlungen können grundsätzlich in verschiedene Richtungen erfolgen: zu Supertypen, zu Subtypen oder zu solchen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Man spricht entsprechend von Upcast, Downcast oder Crosscast. Upcasts sind immer typsicher, Downcasts und Crosscasts nicht. Downcasts sind relativ häufig; sie kommen vor allem dort vor, wo kein parametrischer Polymorphismus (Kapitel 29) zur Verfügung steht oder wo ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten; in der interfacebasierten Programmierung (s. Abschnitt 28.2) stehen sie für einen Rollenwechsel eines Objekts.
Nun sind Typumwandlungen entweder überflüssig oder unsicher. Man sollte daher versuchen, auf sie zu verzichten. Wo unverzichtbar, sollten Typumwandlungen mit einem Typtest abgesichert werden. Dabei wird zur Laufzeit geprüft, ob das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat. Ist das nicht der Fall, sollten die Teile des Programms, die den bei der Typumwandlung genannten Typ voraussetzen, nicht ausgeführt werden. Sie werden in späteren Kapiteln zu den einzelnen Programmiersprachen noch Beispiele für diese Praxis zu sehen bekommen.","<answer> Typumwandlungen können in verschiedene Richtungen erfolgen: zu Supertypen (Upcast), zu Subtypen (Downcast) oder zu Typen, die weder Supertyp noch Subtyp des Ausgangstyps sind (Crosscast). <answer> <question> Welche Richtungen von Typumwandlungen gibt es? <question>"
"Zuweisungskompatibilität unter Subtyping erlaubt also die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps. Für die statische Typprüfung ergibt sich daraus kein Problem, weil sichergestellt ist, dass die Subtypen alle Eigenschaften ihrer Supertypen erhalten, so dass keine Typfehler auftreten können. Für die Programmiererin ergibt sich aber manchmal das Problem, dass sie ein Objekt, auf das eine Variable eines Supertyps verweist, wie ein Objekt seines tatsächlichen Typs verwenden möchte, in der Regel, weil sie eine Methode darauf aufrufen möchte, die der Supertyp nicht hat. Genau diesen Methodenaufruf würde die Typprüfung aber zurückweisen.
Für diesen Zweck gibt es die Möglichkeit der Typumwandlung (engl. type cast). Eine Typumwandlung ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen konvertiert wird. Mit dem Objekt, für das der Ausdruck steht, passiert dabei gar nichts — es wird lediglich der Compiler (bzw. der Type Checker) davon überzeugt, dass der Ausdruck den bei der Umwandlung angegebenen Typ hat. Sollte sich zur Laufzeit herausstellen, dass das nicht der Fall ist, kann ein Laufzeittypsystem — soweit vorhanden — dies bei seiner dynamischen Typprüfung bemerken und ggf. einen entsprechenden Fehler melden (vgl. die Anmerkungen dazu in Kapitel 18).
Typumwandlungen können grundsätzlich in verschiedene Richtungen erfolgen: zu Supertypen, zu Subtypen oder zu solchen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Man spricht entsprechend von Upcast, Downcast oder Crosscast. Upcasts sind immer typsicher, Downcasts und Crosscasts nicht. Downcasts sind relativ häufig; sie kommen vor allem dort vor, wo kein parametrischer Polymorphismus (Kapitel 29) zur Verfügung steht oder wo ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten; in der interfacebasierten Programmierung (s. Abschnitt 28.2) stehen sie für einen Rollenwechsel eines Objekts.
Nun sind Typumwandlungen entweder überflüssig oder unsicher. Man sollte daher versuchen, auf sie zu verzichten. Wo unverzichtbar, sollten Typumwandlungen mit einem Typtest abgesichert werden. Dabei wird zur Laufzeit geprüft, ob das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat. Ist das nicht der Fall, sollten die Teile des Programms, die den bei der Typumwandlung genannten Typ voraussetzen, nicht ausgeführt werden. Sie werden in späteren Kapiteln zu den einzelnen Programmiersprachen noch Beispiele für diese Praxis zu sehen bekommen.","<answer> Upcasts sind immer typsicher, da sie von einem spezielleren Typ zu einem allgemeineren Typ erfolgen. Downcasts und Crosscasts können unsicher sein, da sie von einem allgemeineren Typ zu einem spezielleren oder nicht verwandten Typ erfolgen, was dazu führen kann, dass der Ausdruck zur Laufzeit nicht den erwarteten Typ hat. <answer> <question> Warum sind Upcasts immer typsicher, während Downcasts und Crosscasts unsicher sein können? <question>"
"Zuweisungskompatibilität unter Subtyping erlaubt also die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps. Für die statische Typprüfung ergibt sich daraus kein Problem, weil sichergestellt ist, dass die Subtypen alle Eigenschaften ihrer Supertypen erhalten, so dass keine Typfehler auftreten können. Für die Programmiererin ergibt sich aber manchmal das Problem, dass sie ein Objekt, auf das eine Variable eines Supertyps verweist, wie ein Objekt seines tatsächlichen Typs verwenden möchte, in der Regel, weil sie eine Methode darauf aufrufen möchte, die der Supertyp nicht hat. Genau diesen Methodenaufruf würde die Typprüfung aber zurückweisen.
Für diesen Zweck gibt es die Möglichkeit der Typumwandlung (engl. type cast). Eine Typumwandlung ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen konvertiert wird. Mit dem Objekt, für das der Ausdruck steht, passiert dabei gar nichts — es wird lediglich der Compiler (bzw. der Type Checker) davon überzeugt, dass der Ausdruck den bei der Umwandlung angegebenen Typ hat. Sollte sich zur Laufzeit herausstellen, dass das nicht der Fall ist, kann ein Laufzeittypsystem — soweit vorhanden — dies bei seiner dynamischen Typprüfung bemerken und ggf. einen entsprechenden Fehler melden (vgl. die Anmerkungen dazu in Kapitel 18).
Typumwandlungen können grundsätzlich in verschiedene Richtungen erfolgen: zu Supertypen, zu Subtypen oder zu solchen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Man spricht entsprechend von Upcast, Downcast oder Crosscast. Upcasts sind immer typsicher, Downcasts und Crosscasts nicht. Downcasts sind relativ häufig; sie kommen vor allem dort vor, wo kein parametrischer Polymorphismus (Kapitel 29) zur Verfügung steht oder wo ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten; in der interfacebasierten Programmierung (s. Abschnitt 28.2) stehen sie für einen Rollenwechsel eines Objekts.
Nun sind Typumwandlungen entweder überflüssig oder unsicher. Man sollte daher versuchen, auf sie zu verzichten. Wo unverzichtbar, sollten Typumwandlungen mit einem Typtest abgesichert werden. Dabei wird zur Laufzeit geprüft, ob das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat. Ist das nicht der Fall, sollten die Teile des Programms, die den bei der Typumwandlung genannten Typ voraussetzen, nicht ausgeführt werden. Sie werden in späteren Kapiteln zu den einzelnen Programmiersprachen noch Beispiele für diese Praxis zu sehen bekommen.","<answer> Typumwandlungen sollten vermieden werden, da sie potenziell unsicher sind und die Programmlogik komplexer machen können. Wenn Typumwandlungen unvermeidbar sind, sollten sie mit einem Typtest abgesichert werden, um sicherzustellen, dass das Objekt zur Laufzeit den gewünschten Typ hat. <answer> <question> Warum sollte man versuchen, Typumwandlungen zu vermeiden? <question>"
"Dictionaries repräsentieren sogenannte qualifizierte Beziehungen, bei denen jedes Element der Beziehung durch einen Qualifizierer eindeutig bestimmt wird. Der Qualifizierer heißt auch Schlüssel (engl. key; vergleichbar mit dem Primärschlüssel relationaler Datenbanken), das qualifizierte Element der Beziehung nennt man auch Wert (engl. value). Ein Element einer qualifizierten Beziehung besteht also gewissermaßen aus einer Assoziation eines Schlüssels mit einem Wert. Der Clou an der Implementierung von Dictionaries ist, dass man Werte unter ihren Schlüsseln extrem schnell (im Idealfall ohne jede Suche) auffinden kann. Das wird heute fast immer über sogenanntes Hashing erreicht.
Die Klasse Dictionary hat für die Programmierung besondere Bedeutung: Sie realisiert sogenannte Assoziativspeicher, also Speicher, bei dem auf eine Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet. So werden beispielsweise Methoden in Dictionaries hinterlegt (wobei der Nachrichtenselektor die Rolle des Schlüssels spielt und als Wertobjekt die kompilierte Methode gespeichert ist). Aber auch andere Arten von Collections lassen sich mit Hilfe von Dictionaries sehr einfach realisieren.
Dabei wird einfach die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag, solange diese nicht Null ist, in einem Dictionary unter dem Element als Schlüssel gespeichert.
Man beachte hierbei, dass Bag die Klasse Dictionary nutzt, ohne von ihr zu erben. Stattdessen hält sich jede Instanz von Bag eine Instanz von Dictionary als Sklavin, die für sie den Dienst verrichtet. Man spricht hier auch von einer Delegation; da die Delegation in den prototypenbasierten objektorientierten Programmiersprachen tatsächlich die Funktion der Vererbung übernimmt und zudem dynamisch (also nachdem eine Instanz erzeugt wurde) eingerichtet werden kann und da sie zudem von Fragen der Generalisierung/Spezialisierung völlig befreit ist, erfreut sie sich in der objektorientierten Programmierung großer Beliebtheit.
Je länger Sie in SMALLTALK programmieren, desto häufiger werden Sie feststellen, dass Sie durch Verwendung eines Dictionaries Ihren Code deutlich vereinfachen können. Tatsächlich erlauben es Dictionaries (bzw. der von ihnen realisierte Assoziativspeicher), Assoziationsketten, die Grundlage vieler menschlicher Denkprozesse sind, direkt in einem Programm nachzubilden. Fragen Sie sich also, wann immer Sie es mit einer Menge von Objekten zu tun haben, wie Sie auf die Elemente der Menge zugreifen wollen; wenn dies über einen Schlüssel erfolgt, dann ist Dictionary die Klasse Ihrer Wahl.
Es darf übrigens der Schlüssel eines in einem Dictionary gespeicherten Objekts ruhig ein Attribut (der Inhalt einer Instanzvariable) des Objekts sein; dies kommt sogar recht häufig vor. Beispielsweise wird man Personen in einem Dictionary unter ihrem Nachnamen oder einer Ausweisnummer speichern. Allerdings sollte dieses Attribut dann unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden wird.","<answer> In SMALLTALK repräsentieren Dictionaries qualifizierte Beziehungen, bei denen jedes Element der Beziehung durch einen Schlüssel (auch als Qualifizierer oder Key bezeichnet) eindeutig bestimmt wird. Ein Element einer qualifizierten Beziehung besteht aus einer Assoziation eines Schlüssels mit einem Wert (Value). Dictionaries ermöglichen es, Werte unter ihren Schlüsseln extrem schnell, idealerweise ohne Suche, zu finden. Dies wird in der Regel durch Hashing erreicht. <answer> <question> Was sind Dictionaries in SMALLTALK, und wofür werden sie verwendet? <question>"
"Dictionaries repräsentieren sogenannte qualifizierte Beziehungen, bei denen jedes Element der Beziehung durch einen Qualifizierer eindeutig bestimmt wird. Der Qualifizierer heißt auch Schlüssel (engl. key; vergleichbar mit dem Primärschlüssel relationaler Datenbanken), das qualifizierte Element der Beziehung nennt man auch Wert (engl. value). Ein Element einer qualifizierten Beziehung besteht also gewissermaßen aus einer Assoziation eines Schlüssels mit einem Wert. Der Clou an der Implementierung von Dictionaries ist, dass man Werte unter ihren Schlüsseln extrem schnell (im Idealfall ohne jede Suche) auffinden kann. Das wird heute fast immer über sogenanntes Hashing erreicht.
Die Klasse Dictionary hat für die Programmierung besondere Bedeutung: Sie realisiert sogenannte Assoziativspeicher, also Speicher, bei dem auf eine Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet. So werden beispielsweise Methoden in Dictionaries hinterlegt (wobei der Nachrichtenselektor die Rolle des Schlüssels spielt und als Wertobjekt die kompilierte Methode gespeichert ist). Aber auch andere Arten von Collections lassen sich mit Hilfe von Dictionaries sehr einfach realisieren.
Dabei wird einfach die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag, solange diese nicht Null ist, in einem Dictionary unter dem Element als Schlüssel gespeichert.
Man beachte hierbei, dass Bag die Klasse Dictionary nutzt, ohne von ihr zu erben. Stattdessen hält sich jede Instanz von Bag eine Instanz von Dictionary als Sklavin, die für sie den Dienst verrichtet. Man spricht hier auch von einer Delegation; da die Delegation in den prototypenbasierten objektorientierten Programmiersprachen tatsächlich die Funktion der Vererbung übernimmt und zudem dynamisch (also nachdem eine Instanz erzeugt wurde) eingerichtet werden kann und da sie zudem von Fragen der Generalisierung/Spezialisierung völlig befreit ist, erfreut sie sich in der objektorientierten Programmierung großer Beliebtheit.
Je länger Sie in SMALLTALK programmieren, desto häufiger werden Sie feststellen, dass Sie durch Verwendung eines Dictionaries Ihren Code deutlich vereinfachen können. Tatsächlich erlauben es Dictionaries (bzw. der von ihnen realisierte Assoziativspeicher), Assoziationsketten, die Grundlage vieler menschlicher Denkprozesse sind, direkt in einem Programm nachzubilden. Fragen Sie sich also, wann immer Sie es mit einer Menge von Objekten zu tun haben, wie Sie auf die Elemente der Menge zugreifen wollen; wenn dies über einen Schlüssel erfolgt, dann ist Dictionary die Klasse Ihrer Wahl.
Es darf übrigens der Schlüssel eines in einem Dictionary gespeicherten Objekts ruhig ein Attribut (der Inhalt einer Instanzvariable) des Objekts sein; dies kommt sogar recht häufig vor. Beispielsweise wird man Personen in einem Dictionary unter ihrem Nachnamen oder einer Ausweisnummer speichern. Allerdings sollte dieses Attribut dann unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden wird.","<answer> Die Klasse Dictionary in SMALLTALK realisiert Assoziativspeicher, bei denen auf Speicherzellen nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet, beispielsweise um Methoden in Dictionaries zu hinterlegen, wobei der Nachrichtenselektor die Rolle des Schlüssels spielt und als Wertobjekt die kompilierte Methode gespeichert ist. Dictionaries können auch verwendet werden, um andere Arten von Collections, wie z.B. die Klasse Bag, zu implementieren. <answer> <question> Welche besondere Bedeutung hat die Klasse Dictionary in SMALLTALK? <question>"
"Dictionaries repräsentieren sogenannte qualifizierte Beziehungen, bei denen jedes Element der Beziehung durch einen Qualifizierer eindeutig bestimmt wird. Der Qualifizierer heißt auch Schlüssel (engl. key; vergleichbar mit dem Primärschlüssel relationaler Datenbanken), das qualifizierte Element der Beziehung nennt man auch Wert (engl. value). Ein Element einer qualifizierten Beziehung besteht also gewissermaßen aus einer Assoziation eines Schlüssels mit einem Wert. Der Clou an der Implementierung von Dictionaries ist, dass man Werte unter ihren Schlüsseln extrem schnell (im Idealfall ohne jede Suche) auffinden kann. Das wird heute fast immer über sogenanntes Hashing erreicht.
Die Klasse Dictionary hat für die Programmierung besondere Bedeutung: Sie realisiert sogenannte Assoziativspeicher, also Speicher, bei dem auf eine Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet. So werden beispielsweise Methoden in Dictionaries hinterlegt (wobei der Nachrichtenselektor die Rolle des Schlüssels spielt und als Wertobjekt die kompilierte Methode gespeichert ist). Aber auch andere Arten von Collections lassen sich mit Hilfe von Dictionaries sehr einfach realisieren.
Dabei wird einfach die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag, solange diese nicht Null ist, in einem Dictionary unter dem Element als Schlüssel gespeichert.
Man beachte hierbei, dass Bag die Klasse Dictionary nutzt, ohne von ihr zu erben. Stattdessen hält sich jede Instanz von Bag eine Instanz von Dictionary als Sklavin, die für sie den Dienst verrichtet. Man spricht hier auch von einer Delegation; da die Delegation in den prototypenbasierten objektorientierten Programmiersprachen tatsächlich die Funktion der Vererbung übernimmt und zudem dynamisch (also nachdem eine Instanz erzeugt wurde) eingerichtet werden kann und da sie zudem von Fragen der Generalisierung/Spezialisierung völlig befreit ist, erfreut sie sich in der objektorientierten Programmierung großer Beliebtheit.
Je länger Sie in SMALLTALK programmieren, desto häufiger werden Sie feststellen, dass Sie durch Verwendung eines Dictionaries Ihren Code deutlich vereinfachen können. Tatsächlich erlauben es Dictionaries (bzw. der von ihnen realisierte Assoziativspeicher), Assoziationsketten, die Grundlage vieler menschlicher Denkprozesse sind, direkt in einem Programm nachzubilden. Fragen Sie sich also, wann immer Sie es mit einer Menge von Objekten zu tun haben, wie Sie auf die Elemente der Menge zugreifen wollen; wenn dies über einen Schlüssel erfolgt, dann ist Dictionary die Klasse Ihrer Wahl.
Es darf übrigens der Schlüssel eines in einem Dictionary gespeicherten Objekts ruhig ein Attribut (der Inhalt einer Instanzvariable) des Objekts sein; dies kommt sogar recht häufig vor. Beispielsweise wird man Personen in einem Dictionary unter ihrem Nachnamen oder einer Ausweisnummer speichern. Allerdings sollte dieses Attribut dann unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden wird.","<answer> Die Klasse Bag kann in SMALLTALK mithilfe von Dictionaries implementiert werden, indem die Anzahl der Vorkommen eines Elements der Bag in einem Dictionary unter dem Element als Schlüssel gespeichert wird. Dabei nutzt die Klasse Bag die Klasse Dictionary, ohne von ihr zu erben, sondern hält sich eine Instanz von Dictionary als Sklavin, die für sie den Dienst verrichtet. Dies wird als Delegation bezeichnet und ist in prototypenbasierten objektorientierten Programmiersprachen beliebt. <answer> <question> Wie kann die Klasse Bag in SMALLTALK mit Hilfe von Dictionaries implementiert werden? <question>"
"Dictionaries repräsentieren sogenannte qualifizierte Beziehungen, bei denen jedes Element der Beziehung durch einen Qualifizierer eindeutig bestimmt wird. Der Qualifizierer heißt auch Schlüssel (engl. key; vergleichbar mit dem Primärschlüssel relationaler Datenbanken), das qualifizierte Element der Beziehung nennt man auch Wert (engl. value). Ein Element einer qualifizierten Beziehung besteht also gewissermaßen aus einer Assoziation eines Schlüssels mit einem Wert. Der Clou an der Implementierung von Dictionaries ist, dass man Werte unter ihren Schlüsseln extrem schnell (im Idealfall ohne jede Suche) auffinden kann. Das wird heute fast immer über sogenanntes Hashing erreicht.
Die Klasse Dictionary hat für die Programmierung besondere Bedeutung: Sie realisiert sogenannte Assoziativspeicher, also Speicher, bei dem auf eine Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet. So werden beispielsweise Methoden in Dictionaries hinterlegt (wobei der Nachrichtenselektor die Rolle des Schlüssels spielt und als Wertobjekt die kompilierte Methode gespeichert ist). Aber auch andere Arten von Collections lassen sich mit Hilfe von Dictionaries sehr einfach realisieren.
Dabei wird einfach die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag, solange diese nicht Null ist, in einem Dictionary unter dem Element als Schlüssel gespeichert.
Man beachte hierbei, dass Bag die Klasse Dictionary nutzt, ohne von ihr zu erben. Stattdessen hält sich jede Instanz von Bag eine Instanz von Dictionary als Sklavin, die für sie den Dienst verrichtet. Man spricht hier auch von einer Delegation; da die Delegation in den prototypenbasierten objektorientierten Programmiersprachen tatsächlich die Funktion der Vererbung übernimmt und zudem dynamisch (also nachdem eine Instanz erzeugt wurde) eingerichtet werden kann und da sie zudem von Fragen der Generalisierung/Spezialisierung völlig befreit ist, erfreut sie sich in der objektorientierten Programmierung großer Beliebtheit.
Je länger Sie in SMALLTALK programmieren, desto häufiger werden Sie feststellen, dass Sie durch Verwendung eines Dictionaries Ihren Code deutlich vereinfachen können. Tatsächlich erlauben es Dictionaries (bzw. der von ihnen realisierte Assoziativspeicher), Assoziationsketten, die Grundlage vieler menschlicher Denkprozesse sind, direkt in einem Programm nachzubilden. Fragen Sie sich also, wann immer Sie es mit einer Menge von Objekten zu tun haben, wie Sie auf die Elemente der Menge zugreifen wollen; wenn dies über einen Schlüssel erfolgt, dann ist Dictionary die Klasse Ihrer Wahl.
Es darf übrigens der Schlüssel eines in einem Dictionary gespeicherten Objekts ruhig ein Attribut (der Inhalt einer Instanzvariable) des Objekts sein; dies kommt sogar recht häufig vor. Beispielsweise wird man Personen in einem Dictionary unter ihrem Nachnamen oder einer Ausweisnummer speichern. Allerdings sollte dieses Attribut dann unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden wird.","<answer> Dictionaries sind in SMALLTALK nützlich, da sie das schnelle Auffinden von Werten unter Schlüsseln ermöglichen. Sie sollten verwendet werden, wenn Sie auf die Elemente einer Menge von Objekten über Schlüssel zugreifen möchten. Dictionaries erlauben es, Assoziationsketten direkt in einem Programm nachzubilden und sind besonders geeignet, wenn die Zuordnung von Schlüsseln zu Werten benötigt wird. <answer> <question> Warum sind Dictionaries in SMALLTALK nützlich, und wann sollte man sie verwenden? <question>"
"Dictionaries repräsentieren sogenannte qualifizierte Beziehungen, bei denen jedes Element der Beziehung durch einen Qualifizierer eindeutig bestimmt wird. Der Qualifizierer heißt auch Schlüssel (engl. key; vergleichbar mit dem Primärschlüssel relationaler Datenbanken), das qualifizierte Element der Beziehung nennt man auch Wert (engl. value). Ein Element einer qualifizierten Beziehung besteht also gewissermaßen aus einer Assoziation eines Schlüssels mit einem Wert. Der Clou an der Implementierung von Dictionaries ist, dass man Werte unter ihren Schlüsseln extrem schnell (im Idealfall ohne jede Suche) auffinden kann. Das wird heute fast immer über sogenanntes Hashing erreicht.
Die Klasse Dictionary hat für die Programmierung besondere Bedeutung: Sie realisiert sogenannte Assoziativspeicher, also Speicher, bei dem auf eine Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet. So werden beispielsweise Methoden in Dictionaries hinterlegt (wobei der Nachrichtenselektor die Rolle des Schlüssels spielt und als Wertobjekt die kompilierte Methode gespeichert ist). Aber auch andere Arten von Collections lassen sich mit Hilfe von Dictionaries sehr einfach realisieren.
Dabei wird einfach die Anzahl der Vorkommen eines Elements (repräsentiert durch den formalen Parameter anObject) der Bag, solange diese nicht Null ist, in einem Dictionary unter dem Element als Schlüssel gespeichert.
Man beachte hierbei, dass Bag die Klasse Dictionary nutzt, ohne von ihr zu erben. Stattdessen hält sich jede Instanz von Bag eine Instanz von Dictionary als Sklavin, die für sie den Dienst verrichtet. Man spricht hier auch von einer Delegation; da die Delegation in den prototypenbasierten objektorientierten Programmiersprachen tatsächlich die Funktion der Vererbung übernimmt und zudem dynamisch (also nachdem eine Instanz erzeugt wurde) eingerichtet werden kann und da sie zudem von Fragen der Generalisierung/Spezialisierung völlig befreit ist, erfreut sie sich in der objektorientierten Programmierung großer Beliebtheit.
Je länger Sie in SMALLTALK programmieren, desto häufiger werden Sie feststellen, dass Sie durch Verwendung eines Dictionaries Ihren Code deutlich vereinfachen können. Tatsächlich erlauben es Dictionaries (bzw. der von ihnen realisierte Assoziativspeicher), Assoziationsketten, die Grundlage vieler menschlicher Denkprozesse sind, direkt in einem Programm nachzubilden. Fragen Sie sich also, wann immer Sie es mit einer Menge von Objekten zu tun haben, wie Sie auf die Elemente der Menge zugreifen wollen; wenn dies über einen Schlüssel erfolgt, dann ist Dictionary die Klasse Ihrer Wahl.
Es darf übrigens der Schlüssel eines in einem Dictionary gespeicherten Objekts ruhig ein Attribut (der Inhalt einer Instanzvariable) des Objekts sein; dies kommt sogar recht häufig vor. Beispielsweise wird man Personen in einem Dictionary unter ihrem Nachnamen oder einer Ausweisnummer speichern. Allerdings sollte dieses Attribut dann unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden wird.","<answer> Wenn ein Attribut eines in einem Dictionary gespeicherten Objekts als Schlüssel verwendet wird, sollte dieses Attribut unveränderlich sein. Dies liegt daran, dass das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel im Dictionary gespeichert ist und nur unter diesem Wert wiedergefunden wird. <answer> <question> Welche Einschränkung gibt es bei der Verwendung eines Attributs als Schlüssel in einem Dictionary? <question>"
"Klassen haben in JAVA mehrere Funktionen: Neben der offensichtlichen Funktion als Vorlage für die Erzeugung von Objekten liefern sie auch Typen für ein Programm und dienen der Modularisierung.
Pakete hingegen dienen der Sammlung von Klassen und sind zugleich Namensräume für sie (keine zwei Klassen innerhalb eines Pakets dürfen denselben Namen haben). Außerdem gelten für Klassen innerhalb eines Pakets laxere gegenseitige Zugriffsbeschränkungen als für Klassen aus verschiedenen Paketen. Zwar können Pakete hierarchisch organisiert sein, aber diese Organisation hat keine Bedeutung. Insbesondere erlauben Pakete keinen privilegierten Zugriff auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen können, bedarf es expliziter Import-Deklarationen unter Nennung der jeweiligen Paketnamen.
Die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) wird in JAVA durch sogenannte Zugriffsmodifikatoren (engl. access modifiers) eingeschränkt. Dies sind private, protected, public sowie das sogenannte ""Package local,"" für das es kein Schlüsselwort gibt und das in Klassen bei Fehlen eines der drei anderen angenommen wird (bei Interfaces wird public angenommen). Innerhalb der Klasse selbst sind alle Elemente ihrer Definition zugreifbar. Innerhalb ihrer Subklassen sind diejenigen, die public oder protected deklariert wurden, zugänglich. Innerhalb der Klassen desselben Pakets sind alle, die public, protected oder ohne Zugriffsmodifikator deklariert wurden, zugänglich, während in anderen Paketen nur noch diejenigen zugänglich sind, die public deklariert wurden. Faktisch werden Typdefinitionen somit relativ: Was ein Typ anbietet, hängt nicht nur vom Typ selbst ab, sondern auch davon, wo er verwendet wird. Konzeptionell hat die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, jedoch nichts mit dem Typ selbst zu tun, sondern ist vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.
Die Bedeutung von Klassen als Module wird ausführlicher in Kapitel 59 von Kurseinheit 6 behandelt. Hier betrachten wir noch kurz die konkreten Auswirkungen der Zugriffsbeschränkungen:
Die Sichtbarkeit bezieht sich in JAVA auf lexikalische Scopes. Sie wird durch Hiding, Shadowing und Obscuring eingeschränkt und kann bisweilen über Qualifizierer wiederhergestellt werden.
Die Verknüpfung von Typ und Zugriffsbeschränkung (Schnittstelle) ist in JAVA etabliert und kommt auch in anderen Sprachen vor (z. B. EIFFEL, C# und C++). Sie hat den Vorteil der sprachlichen Knappheit (Typ- und Schnittstellendeklaration in einem) und den Nachteil, dass die Zugriffsbeschränkungen nur grob eingestellt werden können. Insbesondere ist es nicht möglich, dass sich zwei inhaltlich eng zusammengehörende Klassen gegenseitig einen freieren Zugriff gestatten als allen anderen, es sei denn, man packt diese beiden in ein Paket. Außerdem hat sie den Nachteil, dass zwei unterschiedliche Konzepte der Programmierung zusammengeführt werden und dadurch von Programmierern u. U. nicht mehr als unterschiedlich wahrgenommen werden. JAVA-Compiler unterscheiden jedoch immerhin zwischen Typfehlern und Zugriffsfehlern (z. B. ""is undefined"" vs. ""is not visible"" in ECLIPSE, wobei letzteres freilich ""is not accessible"" hätte heißen müssen).","<answer> Klassen in JAVA dienen als Vorlagen für die Erzeugung von Objekten, liefern Typen für ein Programm und dienen der Modularisierung. <answer> <question> Welche Funktionen haben Klassen in JAVA? <question>"
"Klassen haben in JAVA mehrere Funktionen: Neben der offensichtlichen Funktion als Vorlage für die Erzeugung von Objekten liefern sie auch Typen für ein Programm und dienen der Modularisierung.
Pakete hingegen dienen der Sammlung von Klassen und sind zugleich Namensräume für sie (keine zwei Klassen innerhalb eines Pakets dürfen denselben Namen haben). Außerdem gelten für Klassen innerhalb eines Pakets laxere gegenseitige Zugriffsbeschränkungen als für Klassen aus verschiedenen Paketen. Zwar können Pakete hierarchisch organisiert sein, aber diese Organisation hat keine Bedeutung. Insbesondere erlauben Pakete keinen privilegierten Zugriff auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen können, bedarf es expliziter Import-Deklarationen unter Nennung der jeweiligen Paketnamen.
Die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) wird in JAVA durch sogenannte Zugriffsmodifikatoren (engl. access modifiers) eingeschränkt. Dies sind private, protected, public sowie das sogenannte ""Package local,"" für das es kein Schlüsselwort gibt und das in Klassen bei Fehlen eines der drei anderen angenommen wird (bei Interfaces wird public angenommen). Innerhalb der Klasse selbst sind alle Elemente ihrer Definition zugreifbar. Innerhalb ihrer Subklassen sind diejenigen, die public oder protected deklariert wurden, zugänglich. Innerhalb der Klassen desselben Pakets sind alle, die public, protected oder ohne Zugriffsmodifikator deklariert wurden, zugänglich, während in anderen Paketen nur noch diejenigen zugänglich sind, die public deklariert wurden. Faktisch werden Typdefinitionen somit relativ: Was ein Typ anbietet, hängt nicht nur vom Typ selbst ab, sondern auch davon, wo er verwendet wird. Konzeptionell hat die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, jedoch nichts mit dem Typ selbst zu tun, sondern ist vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.
Die Bedeutung von Klassen als Module wird ausführlicher in Kapitel 59 von Kurseinheit 6 behandelt. Hier betrachten wir noch kurz die konkreten Auswirkungen der Zugriffsbeschränkungen:
Die Sichtbarkeit bezieht sich in JAVA auf lexikalische Scopes. Sie wird durch Hiding, Shadowing und Obscuring eingeschränkt und kann bisweilen über Qualifizierer wiederhergestellt werden.
Die Verknüpfung von Typ und Zugriffsbeschränkung (Schnittstelle) ist in JAVA etabliert und kommt auch in anderen Sprachen vor (z. B. EIFFEL, C# und C++). Sie hat den Vorteil der sprachlichen Knappheit (Typ- und Schnittstellendeklaration in einem) und den Nachteil, dass die Zugriffsbeschränkungen nur grob eingestellt werden können. Insbesondere ist es nicht möglich, dass sich zwei inhaltlich eng zusammengehörende Klassen gegenseitig einen freieren Zugriff gestatten als allen anderen, es sei denn, man packt diese beiden in ein Paket. Außerdem hat sie den Nachteil, dass zwei unterschiedliche Konzepte der Programmierung zusammengeführt werden und dadurch von Programmierern u. U. nicht mehr als unterschiedlich wahrgenommen werden. JAVA-Compiler unterscheiden jedoch immerhin zwischen Typfehlern und Zugriffsfehlern (z. B. ""is undefined"" vs. ""is not visible"" in ECLIPSE, wobei letzteres freilich ""is not accessible"" hätte heißen müssen).",<answer> Pakete in JAVA dienen der Sammlung von Klassen und dienen gleichzeitig als Namensräume für diese. Sie ermöglichen die Organisation von Klassen und bieten zugleich laxere Zugriffsbeschränkungen für Klassen innerhalb desselben Pakets. <answer> <question> Wozu dienen Pakete in JAVA? <question>
"Klassen haben in JAVA mehrere Funktionen: Neben der offensichtlichen Funktion als Vorlage für die Erzeugung von Objekten liefern sie auch Typen für ein Programm und dienen der Modularisierung.
Pakete hingegen dienen der Sammlung von Klassen und sind zugleich Namensräume für sie (keine zwei Klassen innerhalb eines Pakets dürfen denselben Namen haben). Außerdem gelten für Klassen innerhalb eines Pakets laxere gegenseitige Zugriffsbeschränkungen als für Klassen aus verschiedenen Paketen. Zwar können Pakete hierarchisch organisiert sein, aber diese Organisation hat keine Bedeutung. Insbesondere erlauben Pakete keinen privilegierten Zugriff auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen können, bedarf es expliziter Import-Deklarationen unter Nennung der jeweiligen Paketnamen.
Die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) wird in JAVA durch sogenannte Zugriffsmodifikatoren (engl. access modifiers) eingeschränkt. Dies sind private, protected, public sowie das sogenannte ""Package local,"" für das es kein Schlüsselwort gibt und das in Klassen bei Fehlen eines der drei anderen angenommen wird (bei Interfaces wird public angenommen). Innerhalb der Klasse selbst sind alle Elemente ihrer Definition zugreifbar. Innerhalb ihrer Subklassen sind diejenigen, die public oder protected deklariert wurden, zugänglich. Innerhalb der Klassen desselben Pakets sind alle, die public, protected oder ohne Zugriffsmodifikator deklariert wurden, zugänglich, während in anderen Paketen nur noch diejenigen zugänglich sind, die public deklariert wurden. Faktisch werden Typdefinitionen somit relativ: Was ein Typ anbietet, hängt nicht nur vom Typ selbst ab, sondern auch davon, wo er verwendet wird. Konzeptionell hat die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, jedoch nichts mit dem Typ selbst zu tun, sondern ist vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.
Die Bedeutung von Klassen als Module wird ausführlicher in Kapitel 59 von Kurseinheit 6 behandelt. Hier betrachten wir noch kurz die konkreten Auswirkungen der Zugriffsbeschränkungen:
Die Sichtbarkeit bezieht sich in JAVA auf lexikalische Scopes. Sie wird durch Hiding, Shadowing und Obscuring eingeschränkt und kann bisweilen über Qualifizierer wiederhergestellt werden.
Die Verknüpfung von Typ und Zugriffsbeschränkung (Schnittstelle) ist in JAVA etabliert und kommt auch in anderen Sprachen vor (z. B. EIFFEL, C# und C++). Sie hat den Vorteil der sprachlichen Knappheit (Typ- und Schnittstellendeklaration in einem) und den Nachteil, dass die Zugriffsbeschränkungen nur grob eingestellt werden können. Insbesondere ist es nicht möglich, dass sich zwei inhaltlich eng zusammengehörende Klassen gegenseitig einen freieren Zugriff gestatten als allen anderen, es sei denn, man packt diese beiden in ein Paket. Außerdem hat sie den Nachteil, dass zwei unterschiedliche Konzepte der Programmierung zusammengeführt werden und dadurch von Programmierern u. U. nicht mehr als unterschiedlich wahrgenommen werden. JAVA-Compiler unterscheiden jedoch immerhin zwischen Typfehlern und Zugriffsfehlern (z. B. ""is undefined"" vs. ""is not visible"" in ECLIPSE, wobei letzteres freilich ""is not accessible"" hätte heißen müssen).","<answer> Zugriffsmodifikatoren (access modifiers) sind in JAVA Schlüsselwörter wie private, protected, public und ""Package local,"" die die Zugriffsbeschränkungen für Klassen, Typen und deren Elemente festlegen. Sie regeln, welche Teile einer Klasse von anderen Klassen aus zugänglich sind. <answer> <question> Was sind Zugriffsmodifikatoren in JAVA? <question>"
"Klassen haben in JAVA mehrere Funktionen: Neben der offensichtlichen Funktion als Vorlage für die Erzeugung von Objekten liefern sie auch Typen für ein Programm und dienen der Modularisierung.
Pakete hingegen dienen der Sammlung von Klassen und sind zugleich Namensräume für sie (keine zwei Klassen innerhalb eines Pakets dürfen denselben Namen haben). Außerdem gelten für Klassen innerhalb eines Pakets laxere gegenseitige Zugriffsbeschränkungen als für Klassen aus verschiedenen Paketen. Zwar können Pakete hierarchisch organisiert sein, aber diese Organisation hat keine Bedeutung. Insbesondere erlauben Pakete keinen privilegierten Zugriff auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen können, bedarf es expliziter Import-Deklarationen unter Nennung der jeweiligen Paketnamen.
Die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) wird in JAVA durch sogenannte Zugriffsmodifikatoren (engl. access modifiers) eingeschränkt. Dies sind private, protected, public sowie das sogenannte ""Package local,"" für das es kein Schlüsselwort gibt und das in Klassen bei Fehlen eines der drei anderen angenommen wird (bei Interfaces wird public angenommen). Innerhalb der Klasse selbst sind alle Elemente ihrer Definition zugreifbar. Innerhalb ihrer Subklassen sind diejenigen, die public oder protected deklariert wurden, zugänglich. Innerhalb der Klassen desselben Pakets sind alle, die public, protected oder ohne Zugriffsmodifikator deklariert wurden, zugänglich, während in anderen Paketen nur noch diejenigen zugänglich sind, die public deklariert wurden. Faktisch werden Typdefinitionen somit relativ: Was ein Typ anbietet, hängt nicht nur vom Typ selbst ab, sondern auch davon, wo er verwendet wird. Konzeptionell hat die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, jedoch nichts mit dem Typ selbst zu tun, sondern ist vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.
Die Bedeutung von Klassen als Module wird ausführlicher in Kapitel 59 von Kurseinheit 6 behandelt. Hier betrachten wir noch kurz die konkreten Auswirkungen der Zugriffsbeschränkungen:
Die Sichtbarkeit bezieht sich in JAVA auf lexikalische Scopes. Sie wird durch Hiding, Shadowing und Obscuring eingeschränkt und kann bisweilen über Qualifizierer wiederhergestellt werden.
Die Verknüpfung von Typ und Zugriffsbeschränkung (Schnittstelle) ist in JAVA etabliert und kommt auch in anderen Sprachen vor (z. B. EIFFEL, C# und C++). Sie hat den Vorteil der sprachlichen Knappheit (Typ- und Schnittstellendeklaration in einem) und den Nachteil, dass die Zugriffsbeschränkungen nur grob eingestellt werden können. Insbesondere ist es nicht möglich, dass sich zwei inhaltlich eng zusammengehörende Klassen gegenseitig einen freieren Zugriff gestatten als allen anderen, es sei denn, man packt diese beiden in ein Paket. Außerdem hat sie den Nachteil, dass zwei unterschiedliche Konzepte der Programmierung zusammengeführt werden und dadurch von Programmierern u. U. nicht mehr als unterschiedlich wahrgenommen werden. JAVA-Compiler unterscheiden jedoch immerhin zwischen Typfehlern und Zugriffsfehlern (z. B. ""is undefined"" vs. ""is not visible"" in ECLIPSE, wobei letzteres freilich ""is not accessible"" hätte heißen müssen).","<answer> Die Zugriffsbeschränkungen in JAVA regeln, welche Teile einer Klasse oder eines Typs von anderen Klassen oder Typen aus zugänglich sind. Sie beeinflussen die Sichtbarkeit von Variablen, Methoden und anderen Elementen innerhalb einer Klasse und zwischen Klassen, insbesondere in verschiedenen Paketen. <answer> <question> Welche Auswirkungen haben die Zugriffsbeschränkungen in JAVA? <question>"
"Klassen haben in JAVA mehrere Funktionen: Neben der offensichtlichen Funktion als Vorlage für die Erzeugung von Objekten liefern sie auch Typen für ein Programm und dienen der Modularisierung.
Pakete hingegen dienen der Sammlung von Klassen und sind zugleich Namensräume für sie (keine zwei Klassen innerhalb eines Pakets dürfen denselben Namen haben). Außerdem gelten für Klassen innerhalb eines Pakets laxere gegenseitige Zugriffsbeschränkungen als für Klassen aus verschiedenen Paketen. Zwar können Pakete hierarchisch organisiert sein, aber diese Organisation hat keine Bedeutung. Insbesondere erlauben Pakete keinen privilegierten Zugriff auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen können, bedarf es expliziter Import-Deklarationen unter Nennung der jeweiligen Paketnamen.
Die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) wird in JAVA durch sogenannte Zugriffsmodifikatoren (engl. access modifiers) eingeschränkt. Dies sind private, protected, public sowie das sogenannte ""Package local,"" für das es kein Schlüsselwort gibt und das in Klassen bei Fehlen eines der drei anderen angenommen wird (bei Interfaces wird public angenommen). Innerhalb der Klasse selbst sind alle Elemente ihrer Definition zugreifbar. Innerhalb ihrer Subklassen sind diejenigen, die public oder protected deklariert wurden, zugänglich. Innerhalb der Klassen desselben Pakets sind alle, die public, protected oder ohne Zugriffsmodifikator deklariert wurden, zugänglich, während in anderen Paketen nur noch diejenigen zugänglich sind, die public deklariert wurden. Faktisch werden Typdefinitionen somit relativ: Was ein Typ anbietet, hängt nicht nur vom Typ selbst ab, sondern auch davon, wo er verwendet wird. Konzeptionell hat die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, jedoch nichts mit dem Typ selbst zu tun, sondern ist vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.
Die Bedeutung von Klassen als Module wird ausführlicher in Kapitel 59 von Kurseinheit 6 behandelt. Hier betrachten wir noch kurz die konkreten Auswirkungen der Zugriffsbeschränkungen:
Die Sichtbarkeit bezieht sich in JAVA auf lexikalische Scopes. Sie wird durch Hiding, Shadowing und Obscuring eingeschränkt und kann bisweilen über Qualifizierer wiederhergestellt werden.
Die Verknüpfung von Typ und Zugriffsbeschränkung (Schnittstelle) ist in JAVA etabliert und kommt auch in anderen Sprachen vor (z. B. EIFFEL, C# und C++). Sie hat den Vorteil der sprachlichen Knappheit (Typ- und Schnittstellendeklaration in einem) und den Nachteil, dass die Zugriffsbeschränkungen nur grob eingestellt werden können. Insbesondere ist es nicht möglich, dass sich zwei inhaltlich eng zusammengehörende Klassen gegenseitig einen freieren Zugriff gestatten als allen anderen, es sei denn, man packt diese beiden in ein Paket. Außerdem hat sie den Nachteil, dass zwei unterschiedliche Konzepte der Programmierung zusammengeführt werden und dadurch von Programmierern u. U. nicht mehr als unterschiedlich wahrgenommen werden. JAVA-Compiler unterscheiden jedoch immerhin zwischen Typfehlern und Zugriffsfehlern (z. B. ""is undefined"" vs. ""is not visible"" in ECLIPSE, wobei letzteres freilich ""is not accessible"" hätte heißen müssen).","<answer> Um auf Klassen und Typen in verschiedenen Paketen zuzugreifen, müssen in JAVA explizite Import-Deklarationen verwendet werden, die die jeweiligen Paketnamen nennen. Pakete ermöglichen keinen privilegierten Zugriff auf Klassen ihrer Subpakete. <answer> <question> Wie kann auf Klassen und Typen in unterschiedlichen Paketen in JAVA zugegriffen werden? <question>"
"Klassen haben in JAVA mehrere Funktionen: Neben der offensichtlichen Funktion als Vorlage für die Erzeugung von Objekten liefern sie auch Typen für ein Programm und dienen der Modularisierung.
Pakete hingegen dienen der Sammlung von Klassen und sind zugleich Namensräume für sie (keine zwei Klassen innerhalb eines Pakets dürfen denselben Namen haben). Außerdem gelten für Klassen innerhalb eines Pakets laxere gegenseitige Zugriffsbeschränkungen als für Klassen aus verschiedenen Paketen. Zwar können Pakete hierarchisch organisiert sein, aber diese Organisation hat keine Bedeutung. Insbesondere erlauben Pakete keinen privilegierten Zugriff auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen können, bedarf es expliziter Import-Deklarationen unter Nennung der jeweiligen Paketnamen.
Die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) wird in JAVA durch sogenannte Zugriffsmodifikatoren (engl. access modifiers) eingeschränkt. Dies sind private, protected, public sowie das sogenannte ""Package local,"" für das es kein Schlüsselwort gibt und das in Klassen bei Fehlen eines der drei anderen angenommen wird (bei Interfaces wird public angenommen). Innerhalb der Klasse selbst sind alle Elemente ihrer Definition zugreifbar. Innerhalb ihrer Subklassen sind diejenigen, die public oder protected deklariert wurden, zugänglich. Innerhalb der Klassen desselben Pakets sind alle, die public, protected oder ohne Zugriffsmodifikator deklariert wurden, zugänglich, während in anderen Paketen nur noch diejenigen zugänglich sind, die public deklariert wurden. Faktisch werden Typdefinitionen somit relativ: Was ein Typ anbietet, hängt nicht nur vom Typ selbst ab, sondern auch davon, wo er verwendet wird. Konzeptionell hat die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, jedoch nichts mit dem Typ selbst zu tun, sondern ist vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.
Die Bedeutung von Klassen als Module wird ausführlicher in Kapitel 59 von Kurseinheit 6 behandelt. Hier betrachten wir noch kurz die konkreten Auswirkungen der Zugriffsbeschränkungen:
Die Sichtbarkeit bezieht sich in JAVA auf lexikalische Scopes. Sie wird durch Hiding, Shadowing und Obscuring eingeschränkt und kann bisweilen über Qualifizierer wiederhergestellt werden.
Die Verknüpfung von Typ und Zugriffsbeschränkung (Schnittstelle) ist in JAVA etabliert und kommt auch in anderen Sprachen vor (z. B. EIFFEL, C# und C++). Sie hat den Vorteil der sprachlichen Knappheit (Typ- und Schnittstellendeklaration in einem) und den Nachteil, dass die Zugriffsbeschränkungen nur grob eingestellt werden können. Insbesondere ist es nicht möglich, dass sich zwei inhaltlich eng zusammengehörende Klassen gegenseitig einen freieren Zugriff gestatten als allen anderen, es sei denn, man packt diese beiden in ein Paket. Außerdem hat sie den Nachteil, dass zwei unterschiedliche Konzepte der Programmierung zusammengeführt werden und dadurch von Programmierern u. U. nicht mehr als unterschiedlich wahrgenommen werden. JAVA-Compiler unterscheiden jedoch immerhin zwischen Typfehlern und Zugriffsfehlern (z. B. ""is undefined"" vs. ""is not visible"" in ECLIPSE, wobei letzteres freilich ""is not accessible"" hätte heißen müssen).","<answer> Die Zugriffsbeschränkungen in JAVA wirken sich auf die Sichtbarkeit von Elementen innerhalb von Klassen und zwischen Klassen aus. Sie regeln, welche Teile eines Moduls von anderen Modulen aus sichtbar sind und können durch Hiding, Shadowing und Obscuring weiter eingeschränkt werden. Die Verknüpfung von Typ und Zugriffsbeschränkung ist in JAVA etabliert und ermöglicht die Deklaration von Typen und Schnittstellen in einem. <answer> <question> Was sind die konkreten Auswirkungen der Zugriffsbeschränkungen in JAVA? <question>"
"Neben den reinen Namenskonventionen einigt man sich häufig auch auf Formatierungskonventionen (zusammen mit Namenskonventionen und anderen Richtlinien, auf Englisch oft als ""coding conventions"" bezeichnet, auf Deutsch oft auch, und etwas zu allgemein, als ""Programmierstil""). Diese regeln Dinge wie Einrückungen und an welchen Stellen Zeilenumbrüche, Leerzeilen und Leerzeichen einzufügen sind. Sie dienen ebenfalls der besseren Lesbarkeit.
Formatierungskonventionen sind jedoch nicht nur eine Richtschnur für Einzelne, die sich vielleicht unsicher sind, ob bzw. wo sie ein Leerzeichen einfügen sollen. Sie vermeiden auch den Effekt, dass jede Programmiererin im Team ihre eigenen Vorlieben pflegt. Dies kann dazu führen, dass wenn eine Programmiererin den Code einer anderen bearbeitet, sie zunächst einmal damit beginnt, diesen so zu formatieren, dass er ihren Lesegewohnheiten entspricht. Die ursprüngliche Autorin reagiert natürlich empört und wird nichts anderes tun, als dies bei nächster Gelegenheit wieder rückgängig zu machen, sprich zu ihren eigenen Vorlieben zurückzukehren. Dies ist alles andere als produktiv.
Ein wirksames Gegenmittel gegen solche Energieverschwendung sind automatische Codeformatierer, die auf Knopfdruck bestimmte Codierungs-konventionen umsetzen. Wo immer verfügbar, sollte man sich zur Angewohnheit machen, diese auch einzusetzen, selbst wenn man allein arbeitet, schon um sich mit der Entwicklung des persönlichen Programmierstils nicht zu weit von dem, was allgemein üblich ist, zu entfernen. Die Programmierung ist nicht geeignet, Individualität zum Ausdruck zu bringen, geschweige denn, sie voll auszuleben.","<answer> Formatierungskonventionen in der Programmierung sind wichtig, da sie die Lesbarkeit des Codes verbessern. Sie regeln Dinge wie Einrückungen, Zeilenumbrüche, Leerzeichen und Leerzeilen, um den Code übersichtlicher zu gestalten. <answer> <question> Warum sind Formatierungskonventionen in der Programmierung wichtig? <question>"
"Neben den reinen Namenskonventionen einigt man sich häufig auch auf Formatierungskonventionen (zusammen mit Namenskonventionen und anderen Richtlinien, auf Englisch oft als ""coding conventions"" bezeichnet, auf Deutsch oft auch, und etwas zu allgemein, als ""Programmierstil""). Diese regeln Dinge wie Einrückungen und an welchen Stellen Zeilenumbrüche, Leerzeilen und Leerzeichen einzufügen sind. Sie dienen ebenfalls der besseren Lesbarkeit.
Formatierungskonventionen sind jedoch nicht nur eine Richtschnur für Einzelne, die sich vielleicht unsicher sind, ob bzw. wo sie ein Leerzeichen einfügen sollen. Sie vermeiden auch den Effekt, dass jede Programmiererin im Team ihre eigenen Vorlieben pflegt. Dies kann dazu führen, dass wenn eine Programmiererin den Code einer anderen bearbeitet, sie zunächst einmal damit beginnt, diesen so zu formatieren, dass er ihren Lesegewohnheiten entspricht. Die ursprüngliche Autorin reagiert natürlich empört und wird nichts anderes tun, als dies bei nächster Gelegenheit wieder rückgängig zu machen, sprich zu ihren eigenen Vorlieben zurückzukehren. Dies ist alles andere als produktiv.
Ein wirksames Gegenmittel gegen solche Energieverschwendung sind automatische Codeformatierer, die auf Knopfdruck bestimmte Codierungs-konventionen umsetzen. Wo immer verfügbar, sollte man sich zur Angewohnheit machen, diese auch einzusetzen, selbst wenn man allein arbeitet, schon um sich mit der Entwicklung des persönlichen Programmierstils nicht zu weit von dem, was allgemein üblich ist, zu entfernen. Die Programmierung ist nicht geeignet, Individualität zum Ausdruck zu bringen, geschweige denn, sie voll auszuleben.","<answer> In Teamprojekten sind Formatierungskonventionen besonders wichtig, um zu verhindern, dass jede Entwicklerin im Team ihre eigenen Formatierungsvorlieben pflegt. Ohne einheitliche Konventionen kann es passieren, dass Entwicklerinnen den Code anderer Teammitglieder nach ihren eigenen Vorlieben formatieren, was zu Konflikten und ineffizienter Arbeit führen kann. <answer> <question> Warum sind Formatierungskonventionen besonders in Teamprojekten wichtig? <question>"
"Neben den reinen Namenskonventionen einigt man sich häufig auch auf Formatierungskonventionen (zusammen mit Namenskonventionen und anderen Richtlinien, auf Englisch oft als ""coding conventions"" bezeichnet, auf Deutsch oft auch, und etwas zu allgemein, als ""Programmierstil""). Diese regeln Dinge wie Einrückungen und an welchen Stellen Zeilenumbrüche, Leerzeilen und Leerzeichen einzufügen sind. Sie dienen ebenfalls der besseren Lesbarkeit.
Formatierungskonventionen sind jedoch nicht nur eine Richtschnur für Einzelne, die sich vielleicht unsicher sind, ob bzw. wo sie ein Leerzeichen einfügen sollen. Sie vermeiden auch den Effekt, dass jede Programmiererin im Team ihre eigenen Vorlieben pflegt. Dies kann dazu führen, dass wenn eine Programmiererin den Code einer anderen bearbeitet, sie zunächst einmal damit beginnt, diesen so zu formatieren, dass er ihren Lesegewohnheiten entspricht. Die ursprüngliche Autorin reagiert natürlich empört und wird nichts anderes tun, als dies bei nächster Gelegenheit wieder rückgängig zu machen, sprich zu ihren eigenen Vorlieben zurückzukehren. Dies ist alles andere als produktiv.
Ein wirksames Gegenmittel gegen solche Energieverschwendung sind automatische Codeformatierer, die auf Knopfdruck bestimmte Codierungs-konventionen umsetzen. Wo immer verfügbar, sollte man sich zur Angewohnheit machen, diese auch einzusetzen, selbst wenn man allein arbeitet, schon um sich mit der Entwicklung des persönlichen Programmierstils nicht zu weit von dem, was allgemein üblich ist, zu entfernen. Die Programmierung ist nicht geeignet, Individualität zum Ausdruck zu bringen, geschweige denn, sie voll auszuleben.","<answer> Es wird empfohlen, automatische Codeformatierer zu verwenden, die auf Knopfdruck bestimmte Formatierungskonventionen anwenden. Selbst wenn man alleine arbeitet, sollte man solche Tools nutzen, um sich an allgemein übliche Formatierungsstandards zu halten und die Entwicklung eines persönlichen Programmierstils nicht zu weit von der Norm entfernen zu lassen. Individualität in der Programmierung ist nicht geeignet, um effizienten und wartbaren Code zu produzieren. <answer> <question> Welches Mittel wird empfohlen, um unnötigen Aufwand und Konflikte in Bezug auf Formatierung zu vermeiden? <question>"
"Es stellt sich die Frage, wie der Mechanismus der Vererbung genau umgesetzt wird. Eine Möglichkeit wäre z. B., die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Das wäre zwar möglich und würde auch die Semantik der Vererbung korrekt wiedergeben, würde aber das (technische) Problem mit sich bringen, dass bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müssten.
Eine weitere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch je eine Instanz aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Diese Umsetzung der Vererbung steht jedoch im Konflikt mit dem Konzept der Identität von Objekten: Ein Objekt einer Subklasse hätte auf einmal mehrere Identitäten, und zwar eine für sich selbst und eine pro Superklasse, von der sie erbt. Auch das wäre problematisch.
Stattdessen wird die Vererbung in SMALLTALK und vielen anderen objektorientierten Programmiersprachen als ein Teilen der Klassendefinitionen realisiert: Vereinbarungen, die in einer Klasse getroffen wurden, gelten automatisch auch für alle Subklassen, es sei denn, diese spezifizieren etwas anderes. Dabei werden die Vereinbarungen nicht übertragen (wie per Kopieren und Einfügen), sondern einfach nur gemeinsam genutzt.","<answer> Es gibt verschiedene Möglichkeiten, den Mechanismus der Vererbung von Superklassen auf Subklassen umzusetzen. Zwei dieser Möglichkeiten wurden im Text angedeutet: Kopieren und Einfügen: Eine Möglichkeit wäre, die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Dies würde die Semantik der Vererbung korrekt wiedergeben, aber bei Änderungen an der Superklasse müssten auch alle Subklassen aktualisiert werden, was technisch problematisch wäre. Automatische Instanzerzeugung: Eine andere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch Instanzen aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Dies würde jedoch das Konzept der Identität von Objekten beeinträchtigen, da Objekte einer Subklasse mehrere Identitäten hätten. <answer> <question> Welche Möglichkeiten gibt es, den Mechanismus der Vererbung von Superklassen auf Subklassen umzusetzen? <question>"
"Es stellt sich die Frage, wie der Mechanismus der Vererbung genau umgesetzt wird. Eine Möglichkeit wäre z. B., die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Das wäre zwar möglich und würde auch die Semantik der Vererbung korrekt wiedergeben, würde aber das (technische) Problem mit sich bringen, dass bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müssten.
Eine weitere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch je eine Instanz aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Diese Umsetzung der Vererbung steht jedoch im Konflikt mit dem Konzept der Identität von Objekten: Ein Objekt einer Subklasse hätte auf einmal mehrere Identitäten, und zwar eine für sich selbst und eine pro Superklasse, von der sie erbt. Auch das wäre problematisch.
Stattdessen wird die Vererbung in SMALLTALK und vielen anderen objektorientierten Programmiersprachen als ein Teilen der Klassendefinitionen realisiert: Vereinbarungen, die in einer Klasse getroffen wurden, gelten automatisch auch für alle Subklassen, es sei denn, diese spezifizieren etwas anderes. Dabei werden die Vereinbarungen nicht übertragen (wie per Kopieren und Einfügen), sondern einfach nur gemeinsam genutzt.","<answer> In SMALLTALK und vielen anderen objektorientierten Programmiersprachen wird die Vererbung als ein Teilen der Klassendefinitionen realisiert. Das bedeutet, dass Vereinbarungen, die in einer Klasse getroffen wurden, automatisch auch für alle Subklassen gelten, es sei denn, diese spezifizieren etwas anderes. Die Vereinbarungen werden nicht übertragen oder kopiert, sondern einfach gemeinsam genutzt. Dies ermöglicht eine effiziente Vererbung von Eigenschaften und Verhalten, ohne die Probleme mit der Identität von Objekten oder der Notwendigkeit der Aktualisierung von Subklassen bei Änderungen in der Superklasse. <answer> <question> Wie wird die Vererbung in SMALLTALK und vielen anderen objektorientierten Programmiersprachen tatsächlich umgesetzt? <question>"
"T sei eine Typvariable. Beim Vorkommen von T im Abschnitt „Typvariablen“ handelt es sich um ihre Deklaration (Vereinbarung); beim Vorkommen im Abschnitt „Protokoll“ um ihre Verwendung.
Das für den Tatbestand der Parametrisierung wichtige an dieser Typdefinition ist, dass x: anstelle des Parameters und x anstelle des Rückgabetyps T nennt, wobei T eben kein Typ, sondern eine Typvariable ist. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen.
Wenn man nun den Typ A verwenden möchte, also z. B. eine temporäre Variable vom Typ A deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable T in der Typdefinition und damit welchen Typ die Rückgabe von x und die Eingabe von x: haben sollen.
Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen.
Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.","<answer> T wird im Abschnitt ""Typvariablen"" deklariert und im Abschnitt ""Protokoll"" verwendet. <answer> <question> Wo wird die Typvariable T deklariert, und wo wird sie verwendet? <question>"
"T sei eine Typvariable. Beim Vorkommen von T im Abschnitt „Typvariablen“ handelt es sich um ihre Deklaration (Vereinbarung); beim Vorkommen im Abschnitt „Protokoll“ um ihre Verwendung.
Das für den Tatbestand der Parametrisierung wichtige an dieser Typdefinition ist, dass x: anstelle des Parameters und x anstelle des Rückgabetyps T nennt, wobei T eben kein Typ, sondern eine Typvariable ist. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen.
Wenn man nun den Typ A verwenden möchte, also z. B. eine temporäre Variable vom Typ A deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable T in der Typdefinition und damit welchen Typ die Rückgabe von x und die Eingabe von x: haben sollen.
Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen.
Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.","<answer> Typvariablen werden traditionell mit einzelnen Großbuchstaben bezeichnet, um zu vermeiden, dass sie tatsächliche Typen verdecken. Dies ermöglicht die Verwendung beliebig vieler Typen in einer parametrischen Klassendefinition. <answer> <question> Warum verwendet man traditionell einzelne Großbuchstaben für Typvariablen? <question>"
"T sei eine Typvariable. Beim Vorkommen von T im Abschnitt „Typvariablen“ handelt es sich um ihre Deklaration (Vereinbarung); beim Vorkommen im Abschnitt „Protokoll“ um ihre Verwendung.
Das für den Tatbestand der Parametrisierung wichtige an dieser Typdefinition ist, dass x: anstelle des Parameters und x anstelle des Rückgabetyps T nennt, wobei T eben kein Typ, sondern eine Typvariable ist. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen.
Wenn man nun den Typ A verwenden möchte, also z. B. eine temporäre Variable vom Typ A deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable T in der Typdefinition und damit welchen Typ die Rückgabe von x und die Eingabe von x: haben sollen.
Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen.
Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.","<answer> Um den Typ A zu instanziiert, verwendet man eckige Klammern, um den tatsächlichen Typparameter anzugeben. Zum Beispiel: a := A[Integer] new. <answer> <question> Wie instanziiert man den Typ A mit einem konkreten Typparameter? <question>"
"T sei eine Typvariable. Beim Vorkommen von T im Abschnitt „Typvariablen“ handelt es sich um ihre Deklaration (Vereinbarung); beim Vorkommen im Abschnitt „Protokoll“ um ihre Verwendung.
Das für den Tatbestand der Parametrisierung wichtige an dieser Typdefinition ist, dass x: anstelle des Parameters und x anstelle des Rückgabetyps T nennt, wobei T eben kein Typ, sondern eine Typvariable ist. Für Typvariablen verwendet man traditionell einzelne Großbuchstaben; dies hat den nützlichen Nebeneffekt, dass man durch eine Typvariable keinen tatsächlichen Typen verdeckt, wie es sonst versehentlich passieren könnte: Man könnte die Typvariable nämlich auch beispielsweise „Integer“ nennen, aber sie wäre deswegen immer schreibend vorausgesetzt, zu einer parametrischen Klassendefinition beliebig viele Typen.
Wenn man nun den Typ A verwenden möchte, also z. B. eine temporäre Variable vom Typ A deklarieren möchte, muss man sich festlegen, welchen Wert die Typvariable T in der Typdefinition und damit welchen Typ die Rückgabe von x und die Eingabe von x: haben sollen.
Diese Typdefinition wird jedoch nirgends hingeschrieben — sie ergibt sich immer neu aus der Instanziierung der parametrischen Typdefinition mit einem konkreten Typen.
Ein und dieselbe parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.","<answer> Der konkrete Typ wird in die formale Typvariable eingesetzt, und der resultierende Typ wird zur Verwendung im Programm definiert. <answer> <question> Was passiert bei der Instanziierung eines parametrischen Typs mit einem konkreten Typen? <question>"
"Am Anfang dieses Kapitels wurde von dem Mysterium des Nachrichtenversands gesprochen. Tatsächlich ist jedoch zumindest in SMALLTALK seine Realisierung in Form von Methodenaufrufen nur ein Kompromiss zugunsten der Ausführungseffizienz. In SMALLTALK sind Nachrichten (oder genauer gesagt Nachrichtenselektoren) selbst Objekte - schließlich soll in SMALLTALK alles ein Objekt sein. Um tatsächlich als Nachrichtenobjekt an ein anderes Objekt verschickt zu werden, muss man jedoch eine spezielle Methode (genauer gesagt, einen speziellen Methodenaufruf), nämlich ""perform:"", verwenden. Diese Methode ermöglicht es, einem Empfängerobjekt eine Nachricht als Objekt (wenn auch nur als Parameter von ""perform:"") zu senden. Das Empfängerobjekt reagiert darauf, indem es die zur Nachricht passende Methode ausführt, als hätte es direkt einen entsprechenden Methodenaufruf erhalten.
Der Nachrichtenselektor ist immer ein Symbol (im gegebenen Beispiel #isNil) und darf beim ""Versand"" mittels ""perform:"" anders als beim direkten Aufruf auch in einer Variable gespeichert sein. Bei binären und höherwertigen Nachrichten werden zusätzlich Argumente (Parameter) benötigt, die an den Nachrichtenselektor angehängt werden können. Dies erfolgt durch Erweiterung von ""perform:"" zu ""perform:with:"", ""perform:with:with:"", usw.","<answer> In SMALLTALK kann man Nachrichten (oder Nachrichtenselektoren) selbst als Objekte verwenden, indem man die Methode ""perform:"" verwendet. Diese Methode ermöglicht es, einem Empfängerobjekt eine Nachricht als Objekt zu senden, und das Empfängerobjekt führt die zur Nachricht passende Methode aus, als hätte es einen entsprechenden Methodenaufruf erhalten. <answer> <question> In SMALLTALK, wie kann man Nachrichten (oder Nachrichtenselektoren) selbst als Objekte verwenden? <question>"
"Am Anfang dieses Kapitels wurde von dem Mysterium des Nachrichtenversands gesprochen. Tatsächlich ist jedoch zumindest in SMALLTALK seine Realisierung in Form von Methodenaufrufen nur ein Kompromiss zugunsten der Ausführungseffizienz. In SMALLTALK sind Nachrichten (oder genauer gesagt Nachrichtenselektoren) selbst Objekte - schließlich soll in SMALLTALK alles ein Objekt sein. Um tatsächlich als Nachrichtenobjekt an ein anderes Objekt verschickt zu werden, muss man jedoch eine spezielle Methode (genauer gesagt, einen speziellen Methodenaufruf), nämlich ""perform:"", verwenden. Diese Methode ermöglicht es, einem Empfängerobjekt eine Nachricht als Objekt (wenn auch nur als Parameter von ""perform:"") zu senden. Das Empfängerobjekt reagiert darauf, indem es die zur Nachricht passende Methode ausführt, als hätte es direkt einen entsprechenden Methodenaufruf erhalten.
Der Nachrichtenselektor ist immer ein Symbol (im gegebenen Beispiel #isNil) und darf beim ""Versand"" mittels ""perform:"" anders als beim direkten Aufruf auch in einer Variable gespeichert sein. Bei binären und höherwertigen Nachrichten werden zusätzlich Argumente (Parameter) benötigt, die an den Nachrichtenselektor angehängt werden können. Dies erfolgt durch Erweiterung von ""perform:"" zu ""perform:with:"", ""perform:with:with:"", usw.","<answer> Der Nachrichtenselektor ist der Name der Nachricht, die an ein Objekt gesendet wird. Beim Verwenden von ""perform:"" ist der Nachrichtenselektor immer ein Symbol. Der Nachrichtenselektor ist wichtig, da er angibt, welche Methode auf dem Empfängerobjekt aufgerufen werden soll. <answer> <question> Was ist der Nachrichtenselektor, und warum ist er wichtig beim Verwenden von ""perform:""? <question>"
"Am Anfang dieses Kapitels wurde von dem Mysterium des Nachrichtenversands gesprochen. Tatsächlich ist jedoch zumindest in SMALLTALK seine Realisierung in Form von Methodenaufrufen nur ein Kompromiss zugunsten der Ausführungseffizienz. In SMALLTALK sind Nachrichten (oder genauer gesagt Nachrichtenselektoren) selbst Objekte - schließlich soll in SMALLTALK alles ein Objekt sein. Um tatsächlich als Nachrichtenobjekt an ein anderes Objekt verschickt zu werden, muss man jedoch eine spezielle Methode (genauer gesagt, einen speziellen Methodenaufruf), nämlich ""perform:"", verwenden. Diese Methode ermöglicht es, einem Empfängerobjekt eine Nachricht als Objekt (wenn auch nur als Parameter von ""perform:"") zu senden. Das Empfängerobjekt reagiert darauf, indem es die zur Nachricht passende Methode ausführt, als hätte es direkt einen entsprechenden Methodenaufruf erhalten.
Der Nachrichtenselektor ist immer ein Symbol (im gegebenen Beispiel #isNil) und darf beim ""Versand"" mittels ""perform:"" anders als beim direkten Aufruf auch in einer Variable gespeichert sein. Bei binären und höherwertigen Nachrichten werden zusätzlich Argumente (Parameter) benötigt, die an den Nachrichtenselektor angehängt werden können. Dies erfolgt durch Erweiterung von ""perform:"" zu ""perform:with:"", ""perform:with:with:"", usw.","<answer> In SMALLTALK können binäre und höherwertige Nachrichten mittels ""perform:"" mit Argumenten verwendet werden, indem man die Methode ""perform:with:"", ""perform:with:with:"", usw. verwendet. Diese erweiterte Methode ermöglicht es, Argumente (Parameter) an den Nachrichtenselektor anzuhängen. <answer> <question> Wie können binäre und höherwertige Nachrichten in SMALLTALK mittels ""perform:"" mit Argumenten verwendet werden? <question>"
"Während der obige Leitspruch aus akademischer Sicht sicherlich richtig ist, können sich Praktikerinnen (und solche, die es werden wollen) diese Einstellung nicht erlauben. Stattdessen müssen sie die Programmiersprachen kennen, die auf dem Markt gefragt sind. In dieser Kurseinheit zeichnen sich die behandelten Sprachen, mit Ausnahme von EIFFEL, weniger durch revolutionäre Konzepte oder neuartige Sichtweisen aus, sondern vielmehr dadurch, dass sie in der Praxis weit verbreitet sind. Dennoch könnten einige Eigenheiten der einzelnen Sprachen Leserinnen Anlass geben, ihre bisherigen Denkweisen zu überprüfen.
Das Ziel dieser Kurseinheit besteht übrigens nicht darin, Sie zu Programmiererinnen in einer der (oder gar allen) in dieser Kurseinheit behandelten Sprachen wie C#, C++ und EIFFEL zu machen. Das Ziel ist vielmehr, Ihnen eine erste Übersicht über diese Sprachen zu geben und Ihr Verständnis für sie zu fördern. Sie sollen einen Eindruck davon bekommen, worauf Sie sich einlassen, wenn Sie sich entscheiden, Software in einer der genannten Sprachen zu entwickeln. Dazu gehört nicht, jedes Konstrukt jeder dieser Sprachen zu kennen oder sogar nur einmal gesehen zu haben. Vielmehr geht es darum, ein Verständnis dafür zu entwickeln, was die charakteristischen Eigenschaften, Stärken und Schwächen jeder einzelnen Sprache sind. Die Länge der folgenden Darstellung hängt von den Unterschieden zwischen den einzelnen Sprachen und den bereits behandelten ab.","<answer> Es ist wichtig, andere objektorientierte Programmiersprachen zu kennen, da Praktikerinnen und solche, die es werden wollen, die Programmiersprachen kennen müssen, die auf dem Markt gefragt sind. Dies ermöglicht es ihnen, in verschiedenen beruflichen Situationen flexibel zu sein und die am besten geeignete Sprache für bestimmte Aufgaben auszuwählen. <answer> <question> Warum ist es wichtig, andere objektorientierte Programmiersprachen zu kennen? <question>"
"Typen beschränken die Wertebereiche von Variablen und Methoden. Inklusionspolymorphie lockert diese Beschränkung insofern, als dadurch Wertebereiche von Typen um die von Subtypen erweitert werden können, selbst wenn diese Subtypen zum Zeitpunkt der Typdefinition noch gar nicht bekannt waren (Abschnitt 26.4). Nun ist Inklusionspolymorphie nicht die einzige Möglichkeit, den Wertebereich eines Typs variabel zu halten, ohne die statische Typprüfung aufgeben zu müssen. Eine andere ist, einen Typ mit einem oder mehreren anderen zu parametrisieren.
Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden müssen, sondern durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich. Dieser Umstand ist bei der Betrachtung von Zuweisungskompatibilität unter parametrischem Polymorphismus wichtig.
Die Idee des parametrischen Polymorphismus ist, aus einer Typdefinition durch Parametrisierung viele zu machen. Eine parametrische Typdefinition steht also nicht für einen Typ, sondern für (theoretisch) beliebig viele — sie erlaubt es gewissermaßen, Unterschiede zur Typen nach Bedarf zu generieren. Wohl deswegen bezeichnet man parametrische Typen (Typdefinitionen) auch als generische Typen (Typdefinitionen) oder kurz als Generics. Wie eben schon erwähnt, wird der Wertebereich bei einer solchen Typgeneration jeweils mitgeneriert.
Es erfolgt also die Zuweisung eines Typs zu einer Typvariable bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, beispielsweise der Deklaration einer Variable oder des Rückgabewerts einer Methode. Oberflächlich betrachtet entspricht diese Verwendung in etwa dem Aufruf einer (ja auch an einer anderen Stelle definierten) Methode oder besser (und schon aufgrund der Verwendung des Begriffs Instanziierung) eines Konstruktors; deswegen nennt man die Typvariablen, die in parametrischen Typdefinitionen vorkommen, auch formale Typparameter und die konkreten Typen, die bei der Verwendung des Typen in Deklarationen in die formalen Parameter eingesetzt werden, auch tatsächliche Typparameter. Trotz dieser Analogie zu Methoden- bzw. Konstruktoraufrufen muss man sich immer vor Augen halten, dass die Verwendung eines parametrisch definierten Typs bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen führt, man es also keineswegs mit etwas Dynamischem zu tun hat. Insbesondere müssen Typen keine Objekte sein, um Typvariablen zugewiesen werden zu können.","<answer> Der Unterschied besteht darin, dass in einer parametrischen Typdefinition andere Typen durch Platzhalter, sogenannte Typparameter, vertreten werden können, die erst bei der Verwendung des parametrisierten Typs belegt werden. Bei einer normalen Typdefinition werden die anderen Typen direkt genannt. <answer> <question> Was ist der Unterschied zwischen einer parametrischen Typdefinition und einer normalen Typdefinition? <question>"
"Typen beschränken die Wertebereiche von Variablen und Methoden. Inklusionspolymorphie lockert diese Beschränkung insofern, als dadurch Wertebereiche von Typen um die von Subtypen erweitert werden können, selbst wenn diese Subtypen zum Zeitpunkt der Typdefinition noch gar nicht bekannt waren (Abschnitt 26.4). Nun ist Inklusionspolymorphie nicht die einzige Möglichkeit, den Wertebereich eines Typs variabel zu halten, ohne die statische Typprüfung aufgeben zu müssen. Eine andere ist, einen Typ mit einem oder mehreren anderen zu parametrisieren.
Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden müssen, sondern durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich. Dieser Umstand ist bei der Betrachtung von Zuweisungskompatibilität unter parametrischem Polymorphismus wichtig.
Die Idee des parametrischen Polymorphismus ist, aus einer Typdefinition durch Parametrisierung viele zu machen. Eine parametrische Typdefinition steht also nicht für einen Typ, sondern für (theoretisch) beliebig viele — sie erlaubt es gewissermaßen, Unterschiede zur Typen nach Bedarf zu generieren. Wohl deswegen bezeichnet man parametrische Typen (Typdefinitionen) auch als generische Typen (Typdefinitionen) oder kurz als Generics. Wie eben schon erwähnt, wird der Wertebereich bei einer solchen Typgeneration jeweils mitgeneriert.
Es erfolgt also die Zuweisung eines Typs zu einer Typvariable bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, beispielsweise der Deklaration einer Variable oder des Rückgabewerts einer Methode. Oberflächlich betrachtet entspricht diese Verwendung in etwa dem Aufruf einer (ja auch an einer anderen Stelle definierten) Methode oder besser (und schon aufgrund der Verwendung des Begriffs Instanziierung) eines Konstruktors; deswegen nennt man die Typvariablen, die in parametrischen Typdefinitionen vorkommen, auch formale Typparameter und die konkreten Typen, die bei der Verwendung des Typen in Deklarationen in die formalen Parameter eingesetzt werden, auch tatsächliche Typparameter. Trotz dieser Analogie zu Methoden- bzw. Konstruktoraufrufen muss man sich immer vor Augen halten, dass die Verwendung eines parametrisch definierten Typs bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen führt, man es also keineswegs mit etwas Dynamischem zu tun hat. Insbesondere müssen Typen keine Objekte sein, um Typvariablen zugewiesen werden zu können.","<answer> Typvariablen sind Platzhalter in parametrischen Typdefinitionen, die implizit auf Typen beschränkt sind und erst bei der Verwendung eines parametrisierten Typs mit einem konkreten Typ belegt werden. <answer> <question> Was sind Typvariablen in parametrischen Typdefinitionen? <question>"
"Typen beschränken die Wertebereiche von Variablen und Methoden. Inklusionspolymorphie lockert diese Beschränkung insofern, als dadurch Wertebereiche von Typen um die von Subtypen erweitert werden können, selbst wenn diese Subtypen zum Zeitpunkt der Typdefinition noch gar nicht bekannt waren (Abschnitt 26.4). Nun ist Inklusionspolymorphie nicht die einzige Möglichkeit, den Wertebereich eines Typs variabel zu halten, ohne die statische Typprüfung aufgeben zu müssen. Eine andere ist, einen Typ mit einem oder mehreren anderen zu parametrisieren.
Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden müssen, sondern durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich. Dieser Umstand ist bei der Betrachtung von Zuweisungskompatibilität unter parametrischem Polymorphismus wichtig.
Die Idee des parametrischen Polymorphismus ist, aus einer Typdefinition durch Parametrisierung viele zu machen. Eine parametrische Typdefinition steht also nicht für einen Typ, sondern für (theoretisch) beliebig viele — sie erlaubt es gewissermaßen, Unterschiede zur Typen nach Bedarf zu generieren. Wohl deswegen bezeichnet man parametrische Typen (Typdefinitionen) auch als generische Typen (Typdefinitionen) oder kurz als Generics. Wie eben schon erwähnt, wird der Wertebereich bei einer solchen Typgeneration jeweils mitgeneriert.
Es erfolgt also die Zuweisung eines Typs zu einer Typvariable bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, beispielsweise der Deklaration einer Variable oder des Rückgabewerts einer Methode. Oberflächlich betrachtet entspricht diese Verwendung in etwa dem Aufruf einer (ja auch an einer anderen Stelle definierten) Methode oder besser (und schon aufgrund der Verwendung des Begriffs Instanziierung) eines Konstruktors; deswegen nennt man die Typvariablen, die in parametrischen Typdefinitionen vorkommen, auch formale Typparameter und die konkreten Typen, die bei der Verwendung des Typen in Deklarationen in die formalen Parameter eingesetzt werden, auch tatsächliche Typparameter. Trotz dieser Analogie zu Methoden- bzw. Konstruktoraufrufen muss man sich immer vor Augen halten, dass die Verwendung eines parametrisch definierten Typs bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen führt, man es also keineswegs mit etwas Dynamischem zu tun hat. Insbesondere müssen Typen keine Objekte sein, um Typvariablen zugewiesen werden zu können.","<answer> Die Idee des parametrischen Polymorphismus besteht darin, aus einer Typdefinition durch Parametrisierung viele verschiedene Typen zu generieren, je nachdem, welche konkreten Typen als Typparameter verwendet werden. <answer> <question> Was ist die Idee des parametrischen Polymorphismus? <question>"
"Typen beschränken die Wertebereiche von Variablen und Methoden. Inklusionspolymorphie lockert diese Beschränkung insofern, als dadurch Wertebereiche von Typen um die von Subtypen erweitert werden können, selbst wenn diese Subtypen zum Zeitpunkt der Typdefinition noch gar nicht bekannt waren (Abschnitt 26.4). Nun ist Inklusionspolymorphie nicht die einzige Möglichkeit, den Wertebereich eines Typs variabel zu halten, ohne die statische Typprüfung aufgeben zu müssen. Eine andere ist, einen Typ mit einem oder mehreren anderen zu parametrisieren.
Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden müssen, sondern durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich. Dieser Umstand ist bei der Betrachtung von Zuweisungskompatibilität unter parametrischem Polymorphismus wichtig.
Die Idee des parametrischen Polymorphismus ist, aus einer Typdefinition durch Parametrisierung viele zu machen. Eine parametrische Typdefinition steht also nicht für einen Typ, sondern für (theoretisch) beliebig viele — sie erlaubt es gewissermaßen, Unterschiede zur Typen nach Bedarf zu generieren. Wohl deswegen bezeichnet man parametrische Typen (Typdefinitionen) auch als generische Typen (Typdefinitionen) oder kurz als Generics. Wie eben schon erwähnt, wird der Wertebereich bei einer solchen Typgeneration jeweils mitgeneriert.
Es erfolgt also die Zuweisung eines Typs zu einer Typvariable bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, beispielsweise der Deklaration einer Variable oder des Rückgabewerts einer Methode. Oberflächlich betrachtet entspricht diese Verwendung in etwa dem Aufruf einer (ja auch an einer anderen Stelle definierten) Methode oder besser (und schon aufgrund der Verwendung des Begriffs Instanziierung) eines Konstruktors; deswegen nennt man die Typvariablen, die in parametrischen Typdefinitionen vorkommen, auch formale Typparameter und die konkreten Typen, die bei der Verwendung des Typen in Deklarationen in die formalen Parameter eingesetzt werden, auch tatsächliche Typparameter. Trotz dieser Analogie zu Methoden- bzw. Konstruktoraufrufen muss man sich immer vor Augen halten, dass die Verwendung eines parametrisch definierten Typs bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen führt, man es also keineswegs mit etwas Dynamischem zu tun hat. Insbesondere müssen Typen keine Objekte sein, um Typvariablen zugewiesen werden zu können.","<answer> Die Zuweisung eines Typs zu einer Typvariable erfolgt bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, z. B. der Deklaration einer Variable oder des Rückgabewerts einer Methode. Diese Verwendung entspricht oberflächlich betrachtet dem Aufruf einer Methode oder eines Konstruktors, führt aber bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen. <answer> <question> Wie erfolgt die Zuweisung eines Typs zu einer Typvariable bei der Verwendung eines parametrisch definierten Typs? <question>"
"Typen beschränken die Wertebereiche von Variablen und Methoden. Inklusionspolymorphie lockert diese Beschränkung insofern, als dadurch Wertebereiche von Typen um die von Subtypen erweitert werden können, selbst wenn diese Subtypen zum Zeitpunkt der Typdefinition noch gar nicht bekannt waren (Abschnitt 26.4). Nun ist Inklusionspolymorphie nicht die einzige Möglichkeit, den Wertebereich eines Typs variabel zu halten, ohne die statische Typprüfung aufgeben zu müssen. Eine andere ist, einen Typ mit einem oder mehreren anderen zu parametrisieren.
Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden müssen, sondern durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich. Dieser Umstand ist bei der Betrachtung von Zuweisungskompatibilität unter parametrischem Polymorphismus wichtig.
Die Idee des parametrischen Polymorphismus ist, aus einer Typdefinition durch Parametrisierung viele zu machen. Eine parametrische Typdefinition steht also nicht für einen Typ, sondern für (theoretisch) beliebig viele — sie erlaubt es gewissermaßen, Unterschiede zur Typen nach Bedarf zu generieren. Wohl deswegen bezeichnet man parametrische Typen (Typdefinitionen) auch als generische Typen (Typdefinitionen) oder kurz als Generics. Wie eben schon erwähnt, wird der Wertebereich bei einer solchen Typgeneration jeweils mitgeneriert.
Es erfolgt also die Zuweisung eines Typs zu einer Typvariable bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, beispielsweise der Deklaration einer Variable oder des Rückgabewerts einer Methode. Oberflächlich betrachtet entspricht diese Verwendung in etwa dem Aufruf einer (ja auch an einer anderen Stelle definierten) Methode oder besser (und schon aufgrund der Verwendung des Begriffs Instanziierung) eines Konstruktors; deswegen nennt man die Typvariablen, die in parametrischen Typdefinitionen vorkommen, auch formale Typparameter und die konkreten Typen, die bei der Verwendung des Typen in Deklarationen in die formalen Parameter eingesetzt werden, auch tatsächliche Typparameter. Trotz dieser Analogie zu Methoden- bzw. Konstruktoraufrufen muss man sich immer vor Augen halten, dass die Verwendung eines parametrisch definierten Typs bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen führt, man es also keineswegs mit etwas Dynamischem zu tun hat. Insbesondere müssen Typen keine Objekte sein, um Typvariablen zugewiesen werden zu können.","<answer> Parametrische Typen werden auch als generische Typen oder Generics bezeichnet, weil sie die Idee verfolgen, aus einer Typdefinition generisch (theoretisch für beliebig viele Typen) viele Typen zu erzeugen, je nach Bedarf. Sie ermöglichen eine gewisse Generizität in der Typsicherung. <answer> <question> Warum nennt man parametrische Typen auch generische Typen oder Generics? <question>"
"Typen beschränken die Wertebereiche von Variablen und Methoden. Inklusionspolymorphie lockert diese Beschränkung insofern, als dadurch Wertebereiche von Typen um die von Subtypen erweitert werden können, selbst wenn diese Subtypen zum Zeitpunkt der Typdefinition noch gar nicht bekannt waren (Abschnitt 26.4). Nun ist Inklusionspolymorphie nicht die einzige Möglichkeit, den Wertebereich eines Typs variabel zu halten, ohne die statische Typprüfung aufgeben zu müssen. Eine andere ist, einen Typ mit einem oder mehreren anderen zu parametrisieren.
Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden müssen, sondern durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich. Dieser Umstand ist bei der Betrachtung von Zuweisungskompatibilität unter parametrischem Polymorphismus wichtig.
Die Idee des parametrischen Polymorphismus ist, aus einer Typdefinition durch Parametrisierung viele zu machen. Eine parametrische Typdefinition steht also nicht für einen Typ, sondern für (theoretisch) beliebig viele — sie erlaubt es gewissermaßen, Unterschiede zur Typen nach Bedarf zu generieren. Wohl deswegen bezeichnet man parametrische Typen (Typdefinitionen) auch als generische Typen (Typdefinitionen) oder kurz als Generics. Wie eben schon erwähnt, wird der Wertebereich bei einer solchen Typgeneration jeweils mitgeneriert.
Es erfolgt also die Zuweisung eines Typs zu einer Typvariable bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, beispielsweise der Deklaration einer Variable oder des Rückgabewerts einer Methode. Oberflächlich betrachtet entspricht diese Verwendung in etwa dem Aufruf einer (ja auch an einer anderen Stelle definierten) Methode oder besser (und schon aufgrund der Verwendung des Begriffs Instanziierung) eines Konstruktors; deswegen nennt man die Typvariablen, die in parametrischen Typdefinitionen vorkommen, auch formale Typparameter und die konkreten Typen, die bei der Verwendung des Typen in Deklarationen in die formalen Parameter eingesetzt werden, auch tatsächliche Typparameter. Trotz dieser Analogie zu Methoden- bzw. Konstruktoraufrufen muss man sich immer vor Augen halten, dass die Verwendung eines parametrisch definierten Typs bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen führt, man es also keineswegs mit etwas Dynamischem zu tun hat. Insbesondere müssen Typen keine Objekte sein, um Typvariablen zugewiesen werden zu können.","<answer> Nein, die zugewiesenen Typen müssen keine Objekte sein, um Typvariablen in parametrischen Typen zu belegen. Es können auch andere Typen sein, solange sie die erforderlichen Bedingungen erfüllen. <answer> <question> Müssen die zugewiesenen Typen Objekte sein, um Typvariablen in parametrischen Typen zu belegen? <question>"
"Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Ein Beispiel für einen rekursiven Typ hatten Sie oben schon kennengelernt: Der (zur Klasse Person gehörende) Typ Person hat Methoden, die Person als Parameter- bzw. Rückgabetypen haben. Rekursive Typen sind ein wichtiges Instrument der Programmierung. Ohne sie wären dynamische Strukturen wie beispielsweise verschachtelte Listen oder Bäume kaum möglich. Rekursive Typen bringen jedoch auch bestimmte Probleme mit sich. Zum Beispiel ist die strukturelle Äquivalenz zweier rekursiver Typen nicht so leicht festzustellen, da die dazu notwendige Expansion rekursiver Typen (das Einsetzen der Struktur für jeden darin vorkommenden Typnamen; siehe Abschnitt 22.1) unendlich große Definitionen ergeben kann.
Ein weiteres Problem ergibt sich, wenn man in einer parametrischen Typdefinition den Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel halten möchte, dieser Typ jedoch der definierte Typ ist (eine binäre Methode; siehe Fußnote 21 in Kapitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.
Nun ist jedoch Number ein Subtyp von Object, so dass man die Deklaration von ""="" eigentlich aus Object übernehmen könnte, wenn der Typ des Parameters automatisch so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre man vielleicht versucht, den Gleichheitstest in Object einfach als ""= einObject <Self> ^ <Boolean>"" zu deklarieren, aber das würde, wenn die Pseudo-Typvariable Self beim Subtyping jeweils den Subtyp annimmt, zu einer kovarianten Redefinition mit den bereits bekannten Problemen führen. Auch hier bietet der parametrische Polymorphismus eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.
Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.
Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht parametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.
Genau diese Beschränkung des tatsächlichen Typparameters kann man nun mit einer stilistischen Figur erreichen, die vermutlich manch einen von Ihnen erhebliche Kopfschmerzen bereiten wird (zumindest macht sie das mir immer wieder aufs Neue): Man beschränkt den formalen Typparameter T von Equatable auf einen Subtyp von Equatable[T], wobei das Vorkommen von T in Equatable[T] eine Verwendung der gerade erst eingeführten Typvariable T darstellt.
Wenn Sie hier ein Verständnisproblem haben, trösten Sie sich. Es dauert eine Weile, bis man es verstanden hat, und noch länger, bis solche Figuren zum aktiven Repertoire gehören. Gleichwohl sollten Sie sich damit befassen. Das JAVA-Collections-Framework in der Version von JAVA 5 ist voll solcher Typdefinitionen. Nicht weil sie schön sind, sondern weil man sie braucht, um das Framework typsicher zu machen, ohne seine Flexibilität zu opfern. Auch Sie werden, wenn Sie objektorientiert programmieren, über kurz oder lang solche Konstrukte verwenden müssen.","<answer> Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren, und sie sind wichtig, um dynamische Strukturen wie verschachtelte Listen oder Bäume in der Programmierung zu ermöglichen. <answer> <question> Was sind rekursive Typen, und warum sind sie wichtig? <question>"
"Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Ein Beispiel für einen rekursiven Typ hatten Sie oben schon kennengelernt: Der (zur Klasse Person gehörende) Typ Person hat Methoden, die Person als Parameter- bzw. Rückgabetypen haben. Rekursive Typen sind ein wichtiges Instrument der Programmierung. Ohne sie wären dynamische Strukturen wie beispielsweise verschachtelte Listen oder Bäume kaum möglich. Rekursive Typen bringen jedoch auch bestimmte Probleme mit sich. Zum Beispiel ist die strukturelle Äquivalenz zweier rekursiver Typen nicht so leicht festzustellen, da die dazu notwendige Expansion rekursiver Typen (das Einsetzen der Struktur für jeden darin vorkommenden Typnamen; siehe Abschnitt 22.1) unendlich große Definitionen ergeben kann.
Ein weiteres Problem ergibt sich, wenn man in einer parametrischen Typdefinition den Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel halten möchte, dieser Typ jedoch der definierte Typ ist (eine binäre Methode; siehe Fußnote 21 in Kapitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.
Nun ist jedoch Number ein Subtyp von Object, so dass man die Deklaration von ""="" eigentlich aus Object übernehmen könnte, wenn der Typ des Parameters automatisch so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre man vielleicht versucht, den Gleichheitstest in Object einfach als ""= einObject <Self> ^ <Boolean>"" zu deklarieren, aber das würde, wenn die Pseudo-Typvariable Self beim Subtyping jeweils den Subtyp annimmt, zu einer kovarianten Redefinition mit den bereits bekannten Problemen führen. Auch hier bietet der parametrische Polymorphismus eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.
Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.
Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht parametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.
Genau diese Beschränkung des tatsächlichen Typparameters kann man nun mit einer stilistischen Figur erreichen, die vermutlich manch einen von Ihnen erhebliche Kopfschmerzen bereiten wird (zumindest macht sie das mir immer wieder aufs Neue): Man beschränkt den formalen Typparameter T von Equatable auf einen Subtyp von Equatable[T], wobei das Vorkommen von T in Equatable[T] eine Verwendung der gerade erst eingeführten Typvariable T darstellt.
Wenn Sie hier ein Verständnisproblem haben, trösten Sie sich. Es dauert eine Weile, bis man es verstanden hat, und noch länger, bis solche Figuren zum aktiven Repertoire gehören. Gleichwohl sollten Sie sich damit befassen. Das JAVA-Collections-Framework in der Version von JAVA 5 ist voll solcher Typdefinitionen. Nicht weil sie schön sind, sondern weil man sie braucht, um das Framework typsicher zu machen, ohne seine Flexibilität zu opfern. Auch Sie werden, wenn Sie objektorientiert programmieren, über kurz oder lang solche Konstrukte verwenden müssen.","<answer> Das Problem bei der strukturellen Äquivalenz von rekursiven Typen besteht darin, dass die Expansion rekursiver Typen unendlich große Definitionen ergeben kann, was die Feststellung der strukturellen Äquivalenz erschwert. <answer> <question> Welches Problem ergibt sich bei der strukturellen Äquivalenz von rekursiven Typen? <question>"
"Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Ein Beispiel für einen rekursiven Typ hatten Sie oben schon kennengelernt: Der (zur Klasse Person gehörende) Typ Person hat Methoden, die Person als Parameter- bzw. Rückgabetypen haben. Rekursive Typen sind ein wichtiges Instrument der Programmierung. Ohne sie wären dynamische Strukturen wie beispielsweise verschachtelte Listen oder Bäume kaum möglich. Rekursive Typen bringen jedoch auch bestimmte Probleme mit sich. Zum Beispiel ist die strukturelle Äquivalenz zweier rekursiver Typen nicht so leicht festzustellen, da die dazu notwendige Expansion rekursiver Typen (das Einsetzen der Struktur für jeden darin vorkommenden Typnamen; siehe Abschnitt 22.1) unendlich große Definitionen ergeben kann.
Ein weiteres Problem ergibt sich, wenn man in einer parametrischen Typdefinition den Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel halten möchte, dieser Typ jedoch der definierte Typ ist (eine binäre Methode; siehe Fußnote 21 in Kapitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.
Nun ist jedoch Number ein Subtyp von Object, so dass man die Deklaration von ""="" eigentlich aus Object übernehmen könnte, wenn der Typ des Parameters automatisch so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre man vielleicht versucht, den Gleichheitstest in Object einfach als ""= einObject <Self> ^ <Boolean>"" zu deklarieren, aber das würde, wenn die Pseudo-Typvariable Self beim Subtyping jeweils den Subtyp annimmt, zu einer kovarianten Redefinition mit den bereits bekannten Problemen führen. Auch hier bietet der parametrische Polymorphismus eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.
Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.
Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht parametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.
Genau diese Beschränkung des tatsächlichen Typparameters kann man nun mit einer stilistischen Figur erreichen, die vermutlich manch einen von Ihnen erhebliche Kopfschmerzen bereiten wird (zumindest macht sie das mir immer wieder aufs Neue): Man beschränkt den formalen Typparameter T von Equatable auf einen Subtyp von Equatable[T], wobei das Vorkommen von T in Equatable[T] eine Verwendung der gerade erst eingeführten Typvariable T darstellt.
Wenn Sie hier ein Verständnisproblem haben, trösten Sie sich. Es dauert eine Weile, bis man es verstanden hat, und noch länger, bis solche Figuren zum aktiven Repertoire gehören. Gleichwohl sollten Sie sich damit befassen. Das JAVA-Collections-Framework in der Version von JAVA 5 ist voll solcher Typdefinitionen. Nicht weil sie schön sind, sondern weil man sie braucht, um das Framework typsicher zu machen, ohne seine Flexibilität zu opfern. Auch Sie werden, wenn Sie objektorientiert programmieren, über kurz oder lang solche Konstrukte verwenden müssen.","<answer> Die direkte Deklaration des Gleichheitstests in Object wäre problematisch, da sie zu einer kovarianten Redefinition führen würde, was zu bekannten Problemen führt. <answer> <question> Warum ist die direkte Deklaration des Gleichheitstests in Object problematisch? <question>"
"Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Ein Beispiel für einen rekursiven Typ hatten Sie oben schon kennengelernt: Der (zur Klasse Person gehörende) Typ Person hat Methoden, die Person als Parameter- bzw. Rückgabetypen haben. Rekursive Typen sind ein wichtiges Instrument der Programmierung. Ohne sie wären dynamische Strukturen wie beispielsweise verschachtelte Listen oder Bäume kaum möglich. Rekursive Typen bringen jedoch auch bestimmte Probleme mit sich. Zum Beispiel ist die strukturelle Äquivalenz zweier rekursiver Typen nicht so leicht festzustellen, da die dazu notwendige Expansion rekursiver Typen (das Einsetzen der Struktur für jeden darin vorkommenden Typnamen; siehe Abschnitt 22.1) unendlich große Definitionen ergeben kann.
Ein weiteres Problem ergibt sich, wenn man in einer parametrischen Typdefinition den Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel halten möchte, dieser Typ jedoch der definierte Typ ist (eine binäre Methode; siehe Fußnote 21 in Kapitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.
Nun ist jedoch Number ein Subtyp von Object, so dass man die Deklaration von ""="" eigentlich aus Object übernehmen könnte, wenn der Typ des Parameters automatisch so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre man vielleicht versucht, den Gleichheitstest in Object einfach als ""= einObject <Self> ^ <Boolean>"" zu deklarieren, aber das würde, wenn die Pseudo-Typvariable Self beim Subtyping jeweils den Subtyp annimmt, zu einer kovarianten Redefinition mit den bereits bekannten Problemen führen. Auch hier bietet der parametrische Polymorphismus eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.
Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.
Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht parametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.
Genau diese Beschränkung des tatsächlichen Typparameters kann man nun mit einer stilistischen Figur erreichen, die vermutlich manch einen von Ihnen erhebliche Kopfschmerzen bereiten wird (zumindest macht sie das mir immer wieder aufs Neue): Man beschränkt den formalen Typparameter T von Equatable auf einen Subtyp von Equatable[T], wobei das Vorkommen von T in Equatable[T] eine Verwendung der gerade erst eingeführten Typvariable T darstellt.
Wenn Sie hier ein Verständnisproblem haben, trösten Sie sich. Es dauert eine Weile, bis man es verstanden hat, und noch länger, bis solche Figuren zum aktiven Repertoire gehören. Gleichwohl sollten Sie sich damit befassen. Das JAVA-Collections-Framework in der Version von JAVA 5 ist voll solcher Typdefinitionen. Nicht weil sie schön sind, sondern weil man sie braucht, um das Framework typsicher zu machen, ohne seine Flexibilität zu opfern. Auch Sie werden, wenn Sie objektorientiert programmieren, über kurz oder lang solche Konstrukte verwenden müssen.","<answer> Der parametrische Polymorphismus ermöglicht die Definition eines nicht parametrischen Typs als Subtyp eines parametrisierten Typs, wodurch die gewünschte Rekursion indirekt hergestellt werden kann. <answer> <question> Wie kann der parametrische Polymorphismus zur Lösung des Problems der rekursiven Typen beitragen? <question>"
"Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Ein Beispiel für einen rekursiven Typ hatten Sie oben schon kennengelernt: Der (zur Klasse Person gehörende) Typ Person hat Methoden, die Person als Parameter- bzw. Rückgabetypen haben. Rekursive Typen sind ein wichtiges Instrument der Programmierung. Ohne sie wären dynamische Strukturen wie beispielsweise verschachtelte Listen oder Bäume kaum möglich. Rekursive Typen bringen jedoch auch bestimmte Probleme mit sich. Zum Beispiel ist die strukturelle Äquivalenz zweier rekursiver Typen nicht so leicht festzustellen, da die dazu notwendige Expansion rekursiver Typen (das Einsetzen der Struktur für jeden darin vorkommenden Typnamen; siehe Abschnitt 22.1) unendlich große Definitionen ergeben kann.
Ein weiteres Problem ergibt sich, wenn man in einer parametrischen Typdefinition den Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel halten möchte, dieser Typ jedoch der definierte Typ ist (eine binäre Methode; siehe Fußnote 21 in Kapitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.
Nun ist jedoch Number ein Subtyp von Object, so dass man die Deklaration von ""="" eigentlich aus Object übernehmen könnte, wenn der Typ des Parameters automatisch so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre man vielleicht versucht, den Gleichheitstest in Object einfach als ""= einObject <Self> ^ <Boolean>"" zu deklarieren, aber das würde, wenn die Pseudo-Typvariable Self beim Subtyping jeweils den Subtyp annimmt, zu einer kovarianten Redefinition mit den bereits bekannten Problemen führen. Auch hier bietet der parametrische Polymorphismus eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.
Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.
Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht parametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.
Genau diese Beschränkung des tatsächlichen Typparameters kann man nun mit einer stilistischen Figur erreichen, die vermutlich manch einen von Ihnen erhebliche Kopfschmerzen bereiten wird (zumindest macht sie das mir immer wieder aufs Neue): Man beschränkt den formalen Typparameter T von Equatable auf einen Subtyp von Equatable[T], wobei das Vorkommen von T in Equatable[T] eine Verwendung der gerade erst eingeführten Typvariable T darstellt.
Wenn Sie hier ein Verständnisproblem haben, trösten Sie sich. Es dauert eine Weile, bis man es verstanden hat, und noch länger, bis solche Figuren zum aktiven Repertoire gehören. Gleichwohl sollten Sie sich damit befassen. Das JAVA-Collections-Framework in der Version von JAVA 5 ist voll solcher Typdefinitionen. Nicht weil sie schön sind, sondern weil man sie braucht, um das Framework typsicher zu machen, ohne seine Flexibilität zu opfern. Auch Sie werden, wenn Sie objektorientiert programmieren, über kurz oder lang solche Konstrukte verwenden müssen.","<answer> Die Beschränkung des tatsächlichen Typparameters wird erreicht, indem der formale Typparameter auf einen Subtyp beschränkt wird. <answer> <question> Wie wird die Beschränkung des tatsächlichen Typparameters in der Typdefinition erreicht? <question>"
"Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Ein Beispiel für einen rekursiven Typ hatten Sie oben schon kennengelernt: Der (zur Klasse Person gehörende) Typ Person hat Methoden, die Person als Parameter- bzw. Rückgabetypen haben. Rekursive Typen sind ein wichtiges Instrument der Programmierung. Ohne sie wären dynamische Strukturen wie beispielsweise verschachtelte Listen oder Bäume kaum möglich. Rekursive Typen bringen jedoch auch bestimmte Probleme mit sich. Zum Beispiel ist die strukturelle Äquivalenz zweier rekursiver Typen nicht so leicht festzustellen, da die dazu notwendige Expansion rekursiver Typen (das Einsetzen der Struktur für jeden darin vorkommenden Typnamen; siehe Abschnitt 22.1) unendlich große Definitionen ergeben kann.
Ein weiteres Problem ergibt sich, wenn man in einer parametrischen Typdefinition den Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel halten möchte, dieser Typ jedoch der definierte Typ ist (eine binäre Methode; siehe Fußnote 21 in Kapitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.
Nun ist jedoch Number ein Subtyp von Object, so dass man die Deklaration von ""="" eigentlich aus Object übernehmen könnte, wenn der Typ des Parameters automatisch so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre man vielleicht versucht, den Gleichheitstest in Object einfach als ""= einObject <Self> ^ <Boolean>"" zu deklarieren, aber das würde, wenn die Pseudo-Typvariable Self beim Subtyping jeweils den Subtyp annimmt, zu einer kovarianten Redefinition mit den bereits bekannten Problemen führen. Auch hier bietet der parametrische Polymorphismus eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.
Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.
Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht parametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.
Genau diese Beschränkung des tatsächlichen Typparameters kann man nun mit einer stilistischen Figur erreichen, die vermutlich manch einen von Ihnen erhebliche Kopfschmerzen bereiten wird (zumindest macht sie das mir immer wieder aufs Neue): Man beschränkt den formalen Typparameter T von Equatable auf einen Subtyp von Equatable[T], wobei das Vorkommen von T in Equatable[T] eine Verwendung der gerade erst eingeführten Typvariable T darstellt.
Wenn Sie hier ein Verständnisproblem haben, trösten Sie sich. Es dauert eine Weile, bis man es verstanden hat, und noch länger, bis solche Figuren zum aktiven Repertoire gehören. Gleichwohl sollten Sie sich damit befassen. Das JAVA-Collections-Framework in der Version von JAVA 5 ist voll solcher Typdefinitionen. Nicht weil sie schön sind, sondern weil man sie braucht, um das Framework typsicher zu machen, ohne seine Flexibilität zu opfern. Auch Sie werden, wenn Sie objektorientiert programmieren, über kurz oder lang solche Konstrukte verwenden müssen.","<answer> Solche Konstrukte sind wichtig in der objektorientierten Programmierung, da sie die Typsicherheit erhöhen und es ermöglichen, flexible Frameworks und komplexe Datenstrukturen zu erstellen. Sie sind in vielen modernen Programmiersprachen und Frameworks weit verbreitet. <answer> <question> Warum sind solche Konstrukte wichtig in der objektorientierten Programmierung? <question>"
"Wenn Objekte ihren Zustand kapseln, ist es ausschließlich ihr Verhalten, welches ihn ändert, und somit das Verhalten, das Zustandsänderungen eines Objekts herbeiführt. Umgekehrt hängt das Verhalten eines Objekts in der Regel von seinem Zustand ab. Wie aber wird das Verhalten eines Objekts beschrieben? Bevor wir uns dieser Frage zuwenden, müssen wir zuerst den Begriff des Ausdrucks klären.","<answer> Das Verhalten eines Objekts ist wichtig, wenn Objekte ihren Zustand kapseln, weil das Verhalten dafür verantwortlich ist, den Zustand eines Objekts zu ändern und die Interaktion mit diesem Objekt zu steuern. Das Verhalten bestimmt, wie ein Objekt auf Nachrichten reagiert und welche Operationen es auf seinem internen Zustand durchführt. <answer> <question> Warum ist das Verhalten eines Objekts wichtig, wenn Objekte ihren Zustand kapseln? <question>"
"Wenn Objekte ihren Zustand kapseln, ist es ausschließlich ihr Verhalten, welches ihn ändert, und somit das Verhalten, das Zustandsänderungen eines Objekts herbeiführt. Umgekehrt hängt das Verhalten eines Objekts in der Regel von seinem Zustand ab. Wie aber wird das Verhalten eines Objekts beschrieben? Bevor wir uns dieser Frage zuwenden, müssen wir zuerst den Begriff des Ausdrucks klären.","<answer> Das Verhalten eines Objekts hängt in der Regel von seinem Zustand ab, weil der Zustand eines Objekts die Informationen enthält, die benötigt werden, um die richtigen Entscheidungen zu treffen und die entsprechenden Aktionen auszuführen. Das Verhalten eines Objekts basiert auf den Daten in seinem Zustand, und diese Daten beeinflussen, wie das Objekt auf Nachrichten reagiert. <answer> <question> Warum hängt das Verhalten eines Objekts in der Regel von seinem Zustand ab? <question>"
"Sie kennen vielleicht aus anderen Programmiersprachen, dass Variablen und anderen Programmelementen bei ihrer Deklaration (Kapitel 19) ein Typ zugeordnet wird. Dieser Typ schränkt die möglichen Werte der deklarierten Elemente ein. So lassen sich beispielsweise in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zeichenketten speichern.
Typ ist ein primitiver Begriff, vergleichbar etwa mit dem Begriff der Menge in der Mengentheorie. Ein Typ hat eine Intension und eine Extension, wobei erstere der Definition des Typs entspricht, letztere seinem Wertebereich, also der Menge der Elemente (Objekte), die zu dem Typ gehören (man sagt auch, „die den Typ haben“ oder „die von dem Typ sind“). Häufig hat ein Typ auch einen Namen, den Typbezeichner. Typen sind die Grundlage von Typsystemen.
Ihnen fällt wahrscheinlich sofort die Ähnlichkeit zum Konstrukt der Klasse, wie es in der letzten Kurseinheit eingeführt wurde, auf. Tatsächlich gibt es hier auch einen Zusammenhang. Um Sie aber nicht gleich in für diese Kurseinheit eher schädliche Denkmuster verfallen zu lassen, soll dieser Zusammenhang zunächst zurückgestellt werden. Eine Aufklärung erfolgt dann in Kapitel 28.
Ein Typsystem umfasst Typausdrücke, Objekt- oder Wertausdrücke, Regeln, die Wertausdrücken Typen zuordnen, und Regeln, die von Wertausdrücken einzuhalten sind (zusammen die Typregeln). Wertausdrücke (bzw. schlicht Ausdrücke, wenn es nicht um die Abgrenzung von Typausdrücken geht) kennen Sie schon: In SMALLTALK sind es die in Kurseinheit 1, Kapitel 4.1 aufgeführten. Mit den anderen Konzepten werden Sie in den nachfolgenden Kapiteln vertraut gemacht, allerdings in weniger formaler Form, als Sie das nach dieser Definition vielleicht befürchten.
Warum aber typisiert man Variablen und andere Programmelemente? Dafür gibt es mindestens vier gute Gründe: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm.
Zu 1.: Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss. Dies ist jedoch naturgemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Programmierung, insbesondere für Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung.
Zu 2.: Wenn man weiß, dass die Werte einer Variable immer vom selben Typ sind, also alle demselben Wertebereich entstammen, dann lassen sich bestimmte Optimierungen durchführen. Wenn man z. B. aufgrund der Deklaration einer Variable x für gegeben annehmen kann, dass x nur ganze Zahlen enthält, dann kann der Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkrement-Anweisung des Prozessors verwenden. Kennt der Compiler den Typ von x hingegen nicht, dann muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist — handelt es sich um eine Fließkommazahl, so muss es zu der entsprechenden Operation verzweigen, handelt es sich womöglich um gar keine Zahl, dann muss es einen Laufzeitfehler signalisieren oder sich etwas anderes einfallen lassen. Dem kann man entgegenhalten, dass im Falle der objektorientierten Programmierung selbst bei einer Typisierung aller Variablen gelegentlich noch Laufzeittests durchgeführt (oder andernfalls schwere Programmfehler in Kauf genommen) werden müssen, und dass sich die zur Optimierung benötigte Information auch anders als über explizite Typisierung von Variablen (z. B. über die sog. Typinferenz, also die Ausnutzung impliziter Typinformation) gewinnen lässt.
Zu 3.: In der Vergangenheit hatten Variablen eher kurze, wenig selbsterklärende Namen (vgl. dazu auch Kapitel 62 in Kurseinheit 7). Es ist dann sinnvoll, wenigstens an der Stelle der ersten Erwähnung der Variablen (in der Regel deren Deklaration) einen Hinweis darauf zu haben, wofür (für welche Menge von Objekten) die Variable steht. Dies kann über einen Kommentar erfolgen, aber auch durch die Assoziation mit einem Typen, die aussagt, welcher Art die Werte der Variable sein müssen. Doch nicht nur Variablen-, auch Methodennamen können für sich genommen wenig aussagekräftig sein und durch die Verknüpfung mit Typen aussagekräftiger gemacht werden: Eine Deklaration der Methode next etwa, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, legt nahe, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren. Dem mag man freilich entgegenhalten, dass man stattdessen ja auch selbsterklärende Namen für Variablen und Methoden vergeben könnte (mehr dazu in Kurseinheit 7, Kapitel 62).
Es bleibt aber in jedem Fall Punkt 4, das Aufdecken von logischen Fehlern in einem Programm. Ohne externes Wissen, was ein Programm tun soll, verlangt das Finden von Fehlern jedoch ein gewisses Maß an Redundanz, also die mehrfache Lieferung gleicher Information, im Programm, denn nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen logischen Programmierfehler hinweisen. Die Verknüpfung von deklarierten Elementen mit Typen erlaubt aber genau die Angabe solcher redundanter Information. Die Schaffung dieser Redundanz verlangt jedoch vermehrte Denk- und Schreibarbeit und ist zudem auch noch, im Falle eines fehlerfreien Programms, überflüssig. Dem kann man allerdings entgegenhalten, dass kaum eine Programmiererin auf Anhieb korrekte Programme schreibt, und wenn eine Typisierung Fehler zu finden in der Lage ist und somit nicht minder aufwendige Tests ersetzt, dann ist das natürlich gut.
Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der heute üblichen Typsysteme ist übrigens die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt. Mehr dazu jedoch erst später (in Abschnitt 28.2).
Die der Fehlerentdeckung mittels Typsystemen zugrundeliegende These ist, dass ein guter Teil logischer Programmierfehler bereits frühzeitig daran erkannt werden kann, dass eine Variable einen Wert hat, den sie eigentlich niemals haben dürfte. So zeugt beispielsweise von einem Fehler, wenn einer Variable, die für Zahlen gedacht war, eine Zeichenkette zugewiesen wird. Wenn dann nämlich einem Ausdruck mit einer arithmetischen Operation, die Zahlen als Operanden verlangt, eine solchermaßen fehlbelegte Variable zugeführt wird, kann dieser nicht ausgewertet werden. Ohne Typprüfung würde dieser Fehler erst zur Laufzeit, also wenn der Ausdruck tatsächlich ausgewertet werden soll, in Erscheinung treten und hätte dann in aller Regel einen Programmabbruch zur Folge. Man nennt einen solchen Programmierfehler einen Typfehler.
Während ein Programmabbruch wenigstens noch eine erkennbare Reaktion auf einen Programmierfehler darstellt, ist es fast noch schlimmer, wenn ein logischer Fehler ohne solche bleibt. So kann es beispielsweise vorkommen, dass man einer Variable, deren Inhalt eine Strecke darstellen soll, eine andere zuweist, deren Inhalt eine Zeit repräsentiert. Mit beiden ließe sich gleich rechnen (dieselben Rechenoperationen durchführen), aber das Ergebnis wäre vermutlich falsch. Merken muss man das allerdings selbst, denn das Programm läuft einfach weiter.
Man kann Variablenfehlbelegungen dieser Art verhindern, indem man Variablen mit expliziten Typinvarianten versieht, die die Menge ihrer zulässigen Werte beschränken, und dann darüber wacht, dass diese Invarianten immer eingehalten werden. Eine besonders einfache Möglichkeit, solche Invarianten zu spezifizieren, erlauben sogenannte Typannotationen, also die Verbindung einer Variable mit einem Typen, wobei der Typ eine Menge von Werten festlegt, die die Variable ausschließlich haben darf. In typisierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Variablendeklaration; in nicht oder nur optional typisierten Sprachen kann sie auch (für einzelne oder alle Variablen) hergeleitet (inferiert; die Typinferenz) werden und ist dann implizit.
Ein Programm, in dem alle Variablenbelegungen immer alle Typinvarianten erfüllen, heißt typkorrekt. In einer Sprache, die durch ihr Typsystem Typkorrektheit festzustellen erlaubt, nennt man die logischen Fehler, die sich in unzulässigen Wertzuweisungen ausdrücken, auch semantische Fehler (und zwar, weil der Inhalt eines Programmelements nicht seiner intendierten Bedeutung entspricht). Dabei ist die Semantik des Programmelements im Programm zweimal, auf redundante, aber unterschiedliche Art, spezifiziert: in Form seines Typs und in Form seiner tatsächlichen Verwendung (festgelegt durch Zuweisungen und Methodenaufrufe). Lässt sich aus beiden ein Widerspruch ableiten, muss eine von beiden falsch gewesen sein.
Der einzige Weg, eine mit der Typisierung einer Variable ausgedrückte Invariante zu verletzen, also Typinkorrektheit herzustellen, ist per Wertzuweisung an die Variable. Ein Typsystem muss also lediglich alle Wertzuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu zählen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen (s. Abschnitt 4.3.2), die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind. Im Folgenden heißen Zuweisungen und Methodenaufrufe, die nicht zu typinkorrekten Programmen führen können, zulässig.
Nun kann man sich vorstellen, dass es für einen Compiler selbst in einfachen Fällen nicht leicht ist, festzustellen, ob eine Wertzuweisung eine Invariante verletzt und somit zu einem typinkorrekten Programm führt. So ist das folgende STRONGTALK-Programmfragment das zunächst eine temporäre Variable i mit dem Typ Integer (in STRONGTALK wird die Typannotation hinter der Variable in spitzen Klammern angeführt) deklariert und ihr dann, in einer Folge von Anweisungen, zunächst 0 und dann 1 (beides Werte vom Typ Integer) zuweist, zwar typkorrekt im Sinne obiger Definition, aber um das zu erschließen, muss man schon wissen, dass die Bedingung in Zeile 835 immer erfüllt ist, der False-Zweig, der zu einer Verletzung der Invariante von i (nämlich dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen) führen würde, also nie ausgeführt wird. Im gegebenen Fall ist das zwar offensichtlich (und bereits von einer recht einfachen Programmanalyse feststellbar), aber es lassen sich auch Fälle konstruieren, in denen eine automatische Programmanalyse streiken muss.
Was man jedoch immer tun kann, um Typkorrektheit zu gewährleisten, ist, dass man zur Laufzeit vor einer Variablenzuweisung prüft, ob der zuzuweisende Wert den von der Variable geforderten Typ hat. Diese sogenannte dynamische Typprüfung (engl. dynamic type checking) hat jedoch den entscheidenden Nachteil, dass sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes machen kann als einen Fehler zu signalisieren (der dann günstigenfalls durch eine dafür vorgesehene Fehlerbehandlungsmethode aufgefangen wird, der aber in der Praxis häufig nur zu einem Programmabbruch führt). Man kann jedoch argumentieren, dass auch letzteres immer noch besser ist, als mit falschen Werten weiterzuarbeiten und damit entweder einen Programmabbruch an einer anderen Stelle, die nicht mehr so leicht mit der fehlerhaften Wertzuweisung in Zusammenhang zu bringen ist, in Kauf zu nehmen oder gar einen logischen Fehler, der überhaupt nicht erkannt wird.
Man beachte übrigens, dass nach diesem Kriterium SMALLTALK — entgegen häufig zu lesenden Behauptungen — keine dynamische Typprüfung durchführt, da Typfehler erst im letztmöglichen Moment offenbar werden, nämlich wenn auf einer Variable eine Methode aufgerufen werden soll, die für das Objekt, auf das die Variable verweist, gar nicht definiert ist. Um das zu verhindern, findet man in SMALLTALK-Code gelegentlich Figuren wie (SMALLTALK EXPRESS entnommen). Dies entspricht natürlich genau einer dynamischen Typprüfung, nur dass hier Typ durch Klasse ersetzt wurde und die Prüfung eben nicht automatisch durch ein Laufzeittypsystem erfolgt, sondern ausprogrammiert werden muss.
Eine Typisierung findet in SMALLTALK gar nicht, auch nicht zur Laufzeit, statt. Außerdem ist mit dynamischer Typisierung in der Regel dynamische Typprüfung gemeint. Was ein dynamischer Typ sein soll, ist auch gar nicht klar. dynamische
Sehr viel nützlicher als die dynamische Typprüfung ist die statische Typprüfung, bei der, trotz aller theoretischen Hindernisse, die Typkorrektheit zur Übersetzungszeit gewährleistet werden soll. Die Typprüfung ist damit Aufgabe des Compilers und nicht, wie im Fall der dynamischen Typprüfung, Aufgabe des Laufzeitsystems oder gar der Programmiererin. Wie wir schon gesehen haben, bedeutet dies nicht weniger, als einen Beweis zu führen, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird. In der Praxis bedeutet dies aber, dass eine rein statische Typprüfung immer auch Programme zurückweist, die nützlich, sinnvoll und typkorrekt sind (s. obiges Beispiel der Zeilen
Zwar kann man versuchen, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen, aber wie man sich leicht vorstellen kann, wird mit steigender Genauigkeit das dazu notwendige Typsystem immer aufwendiger und schwieriger zu benutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken soll (so dass man bei auftretenden Typfehlern erst einmal prüfen muss, ob die Ursache tatsächlich in einem fehlerhaften Programm oder vielleicht nur in fehlerhaften Typannotationen liegt).
So ist die Suche nach einem guten Typsystem immer die Suche nach einem guten Kompromiss. Die meisten heute in der Praxis verwendeten Typsysteme basieren auf einem solchen: einer statischen Komponente, die möglichst viele Fehler findet, ohne dabei die Programmiererin allzu sehr einzuschränken, und einer dynamischen Komponente, die den Rest erledigt. Eine erwähnenswerte Ausnahme von diesem Muster bildet das STRONGTALK-Typsystem (s. Abschnitt 4.4.4).
Ein weiterer Kompromiss betrifft die Ausdruckskraft des Typsystems. Je ausdruckskräftiger ein Typsystem ist, desto mehr Informationen kann es in einer Typannotation unterbringen und desto mehr Typfehler lassen sich aufdecken. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass es in einem konkreten Fall notwendig ist, eine aufwändige (und unter Umständen nicht einmal terminierende) Typprüfung durchzuführen. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen (Interfaces, siehe Kapitel 62) deutlich erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können (dies ist in der objektorientierten Programmierung ein schwer wiegendes Manko, da das gemeinsame Arbeiten von Klassen aus verschiedenen Bibliotheken die Regel ist).
Die folgende Grafik zeigt, wie die Typisierung von Variablen und anderen Programmkonstrukten in den verschiedenen Phasen eines Entwicklungszyklus verwendet werden kann:
Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt.
Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben.
Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält.
Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert.
Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.
Zusammenfassend kann man sagen, dass Typisierung in der Softwareentwicklung eine wichtige Rolle spielt, um die Qualität, Sicherheit und Wartbarkeit von Programmen zu erhöhen. Sie ermöglicht es, Fehler frühzeitig zu erkennen, die Lesbarkeit des Codes zu verbessern und die Zusammenarbeit in größeren Entwicklungsprojekten zu erleichtern. Es gibt verschiedene Ansätze zur Typisierung, von dynamischer Typprüfung zur Laufzeit bis hin zu statischer Typprüfung während der Übersetzungsphase, und die Wahl des richtigen Typsystems hängt von den Anforderungen des jeweiligen Projekts ab.","<answer> Ein Typ in der Programmierung schränkt die möglichen Werte eines deklarierten Elements (z. B. einer Variable) ein. Ein Typ hat eine Intension (Definition) und eine Extension (Wertebereich), wobei er eine Menge von Elementen (Objekten) umfasst, die zu diesem Typ gehören. Typen sind die Grundlage von Typsystemen. <answer> <question> Was ist ein Typ in der Programmierung, und wie ist er definiert? <question>"
"Sie kennen vielleicht aus anderen Programmiersprachen, dass Variablen und anderen Programmelementen bei ihrer Deklaration (Kapitel 19) ein Typ zugeordnet wird. Dieser Typ schränkt die möglichen Werte der deklarierten Elemente ein. So lassen sich beispielsweise in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zeichenketten speichern.
Typ ist ein primitiver Begriff, vergleichbar etwa mit dem Begriff der Menge in der Mengentheorie. Ein Typ hat eine Intension und eine Extension, wobei erstere der Definition des Typs entspricht, letztere seinem Wertebereich, also der Menge der Elemente (Objekte), die zu dem Typ gehören (man sagt auch, „die den Typ haben“ oder „die von dem Typ sind“). Häufig hat ein Typ auch einen Namen, den Typbezeichner. Typen sind die Grundlage von Typsystemen.
Ihnen fällt wahrscheinlich sofort die Ähnlichkeit zum Konstrukt der Klasse, wie es in der letzten Kurseinheit eingeführt wurde, auf. Tatsächlich gibt es hier auch einen Zusammenhang. Um Sie aber nicht gleich in für diese Kurseinheit eher schädliche Denkmuster verfallen zu lassen, soll dieser Zusammenhang zunächst zurückgestellt werden. Eine Aufklärung erfolgt dann in Kapitel 28.
Ein Typsystem umfasst Typausdrücke, Objekt- oder Wertausdrücke, Regeln, die Wertausdrücken Typen zuordnen, und Regeln, die von Wertausdrücken einzuhalten sind (zusammen die Typregeln). Wertausdrücke (bzw. schlicht Ausdrücke, wenn es nicht um die Abgrenzung von Typausdrücken geht) kennen Sie schon: In SMALLTALK sind es die in Kurseinheit 1, Kapitel 4.1 aufgeführten. Mit den anderen Konzepten werden Sie in den nachfolgenden Kapiteln vertraut gemacht, allerdings in weniger formaler Form, als Sie das nach dieser Definition vielleicht befürchten.
Warum aber typisiert man Variablen und andere Programmelemente? Dafür gibt es mindestens vier gute Gründe: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm.
Zu 1.: Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss. Dies ist jedoch naturgemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Programmierung, insbesondere für Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung.
Zu 2.: Wenn man weiß, dass die Werte einer Variable immer vom selben Typ sind, also alle demselben Wertebereich entstammen, dann lassen sich bestimmte Optimierungen durchführen. Wenn man z. B. aufgrund der Deklaration einer Variable x für gegeben annehmen kann, dass x nur ganze Zahlen enthält, dann kann der Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkrement-Anweisung des Prozessors verwenden. Kennt der Compiler den Typ von x hingegen nicht, dann muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist — handelt es sich um eine Fließkommazahl, so muss es zu der entsprechenden Operation verzweigen, handelt es sich womöglich um gar keine Zahl, dann muss es einen Laufzeitfehler signalisieren oder sich etwas anderes einfallen lassen. Dem kann man entgegenhalten, dass im Falle der objektorientierten Programmierung selbst bei einer Typisierung aller Variablen gelegentlich noch Laufzeittests durchgeführt (oder andernfalls schwere Programmfehler in Kauf genommen) werden müssen, und dass sich die zur Optimierung benötigte Information auch anders als über explizite Typisierung von Variablen (z. B. über die sog. Typinferenz, also die Ausnutzung impliziter Typinformation) gewinnen lässt.
Zu 3.: In der Vergangenheit hatten Variablen eher kurze, wenig selbsterklärende Namen (vgl. dazu auch Kapitel 62 in Kurseinheit 7). Es ist dann sinnvoll, wenigstens an der Stelle der ersten Erwähnung der Variablen (in der Regel deren Deklaration) einen Hinweis darauf zu haben, wofür (für welche Menge von Objekten) die Variable steht. Dies kann über einen Kommentar erfolgen, aber auch durch die Assoziation mit einem Typen, die aussagt, welcher Art die Werte der Variable sein müssen. Doch nicht nur Variablen-, auch Methodennamen können für sich genommen wenig aussagekräftig sein und durch die Verknüpfung mit Typen aussagekräftiger gemacht werden: Eine Deklaration der Methode next etwa, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, legt nahe, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren. Dem mag man freilich entgegenhalten, dass man stattdessen ja auch selbsterklärende Namen für Variablen und Methoden vergeben könnte (mehr dazu in Kurseinheit 7, Kapitel 62).
Es bleibt aber in jedem Fall Punkt 4, das Aufdecken von logischen Fehlern in einem Programm. Ohne externes Wissen, was ein Programm tun soll, verlangt das Finden von Fehlern jedoch ein gewisses Maß an Redundanz, also die mehrfache Lieferung gleicher Information, im Programm, denn nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen logischen Programmierfehler hinweisen. Die Verknüpfung von deklarierten Elementen mit Typen erlaubt aber genau die Angabe solcher redundanter Information. Die Schaffung dieser Redundanz verlangt jedoch vermehrte Denk- und Schreibarbeit und ist zudem auch noch, im Falle eines fehlerfreien Programms, überflüssig. Dem kann man allerdings entgegenhalten, dass kaum eine Programmiererin auf Anhieb korrekte Programme schreibt, und wenn eine Typisierung Fehler zu finden in der Lage ist und somit nicht minder aufwendige Tests ersetzt, dann ist das natürlich gut.
Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der heute üblichen Typsysteme ist übrigens die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt. Mehr dazu jedoch erst später (in Abschnitt 28.2).
Die der Fehlerentdeckung mittels Typsystemen zugrundeliegende These ist, dass ein guter Teil logischer Programmierfehler bereits frühzeitig daran erkannt werden kann, dass eine Variable einen Wert hat, den sie eigentlich niemals haben dürfte. So zeugt beispielsweise von einem Fehler, wenn einer Variable, die für Zahlen gedacht war, eine Zeichenkette zugewiesen wird. Wenn dann nämlich einem Ausdruck mit einer arithmetischen Operation, die Zahlen als Operanden verlangt, eine solchermaßen fehlbelegte Variable zugeführt wird, kann dieser nicht ausgewertet werden. Ohne Typprüfung würde dieser Fehler erst zur Laufzeit, also wenn der Ausdruck tatsächlich ausgewertet werden soll, in Erscheinung treten und hätte dann in aller Regel einen Programmabbruch zur Folge. Man nennt einen solchen Programmierfehler einen Typfehler.
Während ein Programmabbruch wenigstens noch eine erkennbare Reaktion auf einen Programmierfehler darstellt, ist es fast noch schlimmer, wenn ein logischer Fehler ohne solche bleibt. So kann es beispielsweise vorkommen, dass man einer Variable, deren Inhalt eine Strecke darstellen soll, eine andere zuweist, deren Inhalt eine Zeit repräsentiert. Mit beiden ließe sich gleich rechnen (dieselben Rechenoperationen durchführen), aber das Ergebnis wäre vermutlich falsch. Merken muss man das allerdings selbst, denn das Programm läuft einfach weiter.
Man kann Variablenfehlbelegungen dieser Art verhindern, indem man Variablen mit expliziten Typinvarianten versieht, die die Menge ihrer zulässigen Werte beschränken, und dann darüber wacht, dass diese Invarianten immer eingehalten werden. Eine besonders einfache Möglichkeit, solche Invarianten zu spezifizieren, erlauben sogenannte Typannotationen, also die Verbindung einer Variable mit einem Typen, wobei der Typ eine Menge von Werten festlegt, die die Variable ausschließlich haben darf. In typisierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Variablendeklaration; in nicht oder nur optional typisierten Sprachen kann sie auch (für einzelne oder alle Variablen) hergeleitet (inferiert; die Typinferenz) werden und ist dann implizit.
Ein Programm, in dem alle Variablenbelegungen immer alle Typinvarianten erfüllen, heißt typkorrekt. In einer Sprache, die durch ihr Typsystem Typkorrektheit festzustellen erlaubt, nennt man die logischen Fehler, die sich in unzulässigen Wertzuweisungen ausdrücken, auch semantische Fehler (und zwar, weil der Inhalt eines Programmelements nicht seiner intendierten Bedeutung entspricht). Dabei ist die Semantik des Programmelements im Programm zweimal, auf redundante, aber unterschiedliche Art, spezifiziert: in Form seines Typs und in Form seiner tatsächlichen Verwendung (festgelegt durch Zuweisungen und Methodenaufrufe). Lässt sich aus beiden ein Widerspruch ableiten, muss eine von beiden falsch gewesen sein.
Der einzige Weg, eine mit der Typisierung einer Variable ausgedrückte Invariante zu verletzen, also Typinkorrektheit herzustellen, ist per Wertzuweisung an die Variable. Ein Typsystem muss also lediglich alle Wertzuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu zählen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen (s. Abschnitt 4.3.2), die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind. Im Folgenden heißen Zuweisungen und Methodenaufrufe, die nicht zu typinkorrekten Programmen führen können, zulässig.
Nun kann man sich vorstellen, dass es für einen Compiler selbst in einfachen Fällen nicht leicht ist, festzustellen, ob eine Wertzuweisung eine Invariante verletzt und somit zu einem typinkorrekten Programm führt. So ist das folgende STRONGTALK-Programmfragment das zunächst eine temporäre Variable i mit dem Typ Integer (in STRONGTALK wird die Typannotation hinter der Variable in spitzen Klammern angeführt) deklariert und ihr dann, in einer Folge von Anweisungen, zunächst 0 und dann 1 (beides Werte vom Typ Integer) zuweist, zwar typkorrekt im Sinne obiger Definition, aber um das zu erschließen, muss man schon wissen, dass die Bedingung in Zeile 835 immer erfüllt ist, der False-Zweig, der zu einer Verletzung der Invariante von i (nämlich dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen) führen würde, also nie ausgeführt wird. Im gegebenen Fall ist das zwar offensichtlich (und bereits von einer recht einfachen Programmanalyse feststellbar), aber es lassen sich auch Fälle konstruieren, in denen eine automatische Programmanalyse streiken muss.
Was man jedoch immer tun kann, um Typkorrektheit zu gewährleisten, ist, dass man zur Laufzeit vor einer Variablenzuweisung prüft, ob der zuzuweisende Wert den von der Variable geforderten Typ hat. Diese sogenannte dynamische Typprüfung (engl. dynamic type checking) hat jedoch den entscheidenden Nachteil, dass sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes machen kann als einen Fehler zu signalisieren (der dann günstigenfalls durch eine dafür vorgesehene Fehlerbehandlungsmethode aufgefangen wird, der aber in der Praxis häufig nur zu einem Programmabbruch führt). Man kann jedoch argumentieren, dass auch letzteres immer noch besser ist, als mit falschen Werten weiterzuarbeiten und damit entweder einen Programmabbruch an einer anderen Stelle, die nicht mehr so leicht mit der fehlerhaften Wertzuweisung in Zusammenhang zu bringen ist, in Kauf zu nehmen oder gar einen logischen Fehler, der überhaupt nicht erkannt wird.
Man beachte übrigens, dass nach diesem Kriterium SMALLTALK — entgegen häufig zu lesenden Behauptungen — keine dynamische Typprüfung durchführt, da Typfehler erst im letztmöglichen Moment offenbar werden, nämlich wenn auf einer Variable eine Methode aufgerufen werden soll, die für das Objekt, auf das die Variable verweist, gar nicht definiert ist. Um das zu verhindern, findet man in SMALLTALK-Code gelegentlich Figuren wie (SMALLTALK EXPRESS entnommen). Dies entspricht natürlich genau einer dynamischen Typprüfung, nur dass hier Typ durch Klasse ersetzt wurde und die Prüfung eben nicht automatisch durch ein Laufzeittypsystem erfolgt, sondern ausprogrammiert werden muss.
Eine Typisierung findet in SMALLTALK gar nicht, auch nicht zur Laufzeit, statt. Außerdem ist mit dynamischer Typisierung in der Regel dynamische Typprüfung gemeint. Was ein dynamischer Typ sein soll, ist auch gar nicht klar. dynamische
Sehr viel nützlicher als die dynamische Typprüfung ist die statische Typprüfung, bei der, trotz aller theoretischen Hindernisse, die Typkorrektheit zur Übersetzungszeit gewährleistet werden soll. Die Typprüfung ist damit Aufgabe des Compilers und nicht, wie im Fall der dynamischen Typprüfung, Aufgabe des Laufzeitsystems oder gar der Programmiererin. Wie wir schon gesehen haben, bedeutet dies nicht weniger, als einen Beweis zu führen, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird. In der Praxis bedeutet dies aber, dass eine rein statische Typprüfung immer auch Programme zurückweist, die nützlich, sinnvoll und typkorrekt sind (s. obiges Beispiel der Zeilen
Zwar kann man versuchen, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen, aber wie man sich leicht vorstellen kann, wird mit steigender Genauigkeit das dazu notwendige Typsystem immer aufwendiger und schwieriger zu benutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken soll (so dass man bei auftretenden Typfehlern erst einmal prüfen muss, ob die Ursache tatsächlich in einem fehlerhaften Programm oder vielleicht nur in fehlerhaften Typannotationen liegt).
So ist die Suche nach einem guten Typsystem immer die Suche nach einem guten Kompromiss. Die meisten heute in der Praxis verwendeten Typsysteme basieren auf einem solchen: einer statischen Komponente, die möglichst viele Fehler findet, ohne dabei die Programmiererin allzu sehr einzuschränken, und einer dynamischen Komponente, die den Rest erledigt. Eine erwähnenswerte Ausnahme von diesem Muster bildet das STRONGTALK-Typsystem (s. Abschnitt 4.4.4).
Ein weiterer Kompromiss betrifft die Ausdruckskraft des Typsystems. Je ausdruckskräftiger ein Typsystem ist, desto mehr Informationen kann es in einer Typannotation unterbringen und desto mehr Typfehler lassen sich aufdecken. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass es in einem konkreten Fall notwendig ist, eine aufwändige (und unter Umständen nicht einmal terminierende) Typprüfung durchzuführen. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen (Interfaces, siehe Kapitel 62) deutlich erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können (dies ist in der objektorientierten Programmierung ein schwer wiegendes Manko, da das gemeinsame Arbeiten von Klassen aus verschiedenen Bibliotheken die Regel ist).
Die folgende Grafik zeigt, wie die Typisierung von Variablen und anderen Programmkonstrukten in den verschiedenen Phasen eines Entwicklungszyklus verwendet werden kann:
Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt.
Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben.
Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält.
Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert.
Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.
Zusammenfassend kann man sagen, dass Typisierung in der Softwareentwicklung eine wichtige Rolle spielt, um die Qualität, Sicherheit und Wartbarkeit von Programmen zu erhöhen. Sie ermöglicht es, Fehler frühzeitig zu erkennen, die Lesbarkeit des Codes zu verbessern und die Zusammenarbeit in größeren Entwicklungsprojekten zu erleichtern. Es gibt verschiedene Ansätze zur Typisierung, von dynamischer Typprüfung zur Laufzeit bis hin zu statischer Typprüfung während der Übersetzungsphase, und die Wahl des richtigen Typsystems hängt von den Anforderungen des jeweiligen Projekts ab.","<answer> Ja, es gibt eine Verbindung zwischen Typen und Klassen in der objektorientierten Programmierung. Der Zusammenhang wird jedoch vorerst zurückgestellt und wird in Kapitel 28 erklärt. <answer> <question> Gibt es eine Verbindung zwischen Typen und Klassen in der objektorientierten Programmierung? <question>"
"Sie kennen vielleicht aus anderen Programmiersprachen, dass Variablen und anderen Programmelementen bei ihrer Deklaration (Kapitel 19) ein Typ zugeordnet wird. Dieser Typ schränkt die möglichen Werte der deklarierten Elemente ein. So lassen sich beispielsweise in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zeichenketten speichern.
Typ ist ein primitiver Begriff, vergleichbar etwa mit dem Begriff der Menge in der Mengentheorie. Ein Typ hat eine Intension und eine Extension, wobei erstere der Definition des Typs entspricht, letztere seinem Wertebereich, also der Menge der Elemente (Objekte), die zu dem Typ gehören (man sagt auch, „die den Typ haben“ oder „die von dem Typ sind“). Häufig hat ein Typ auch einen Namen, den Typbezeichner. Typen sind die Grundlage von Typsystemen.
Ihnen fällt wahrscheinlich sofort die Ähnlichkeit zum Konstrukt der Klasse, wie es in der letzten Kurseinheit eingeführt wurde, auf. Tatsächlich gibt es hier auch einen Zusammenhang. Um Sie aber nicht gleich in für diese Kurseinheit eher schädliche Denkmuster verfallen zu lassen, soll dieser Zusammenhang zunächst zurückgestellt werden. Eine Aufklärung erfolgt dann in Kapitel 28.
Ein Typsystem umfasst Typausdrücke, Objekt- oder Wertausdrücke, Regeln, die Wertausdrücken Typen zuordnen, und Regeln, die von Wertausdrücken einzuhalten sind (zusammen die Typregeln). Wertausdrücke (bzw. schlicht Ausdrücke, wenn es nicht um die Abgrenzung von Typausdrücken geht) kennen Sie schon: In SMALLTALK sind es die in Kurseinheit 1, Kapitel 4.1 aufgeführten. Mit den anderen Konzepten werden Sie in den nachfolgenden Kapiteln vertraut gemacht, allerdings in weniger formaler Form, als Sie das nach dieser Definition vielleicht befürchten.
Warum aber typisiert man Variablen und andere Programmelemente? Dafür gibt es mindestens vier gute Gründe: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm.
Zu 1.: Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss. Dies ist jedoch naturgemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Programmierung, insbesondere für Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung.
Zu 2.: Wenn man weiß, dass die Werte einer Variable immer vom selben Typ sind, also alle demselben Wertebereich entstammen, dann lassen sich bestimmte Optimierungen durchführen. Wenn man z. B. aufgrund der Deklaration einer Variable x für gegeben annehmen kann, dass x nur ganze Zahlen enthält, dann kann der Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkrement-Anweisung des Prozessors verwenden. Kennt der Compiler den Typ von x hingegen nicht, dann muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist — handelt es sich um eine Fließkommazahl, so muss es zu der entsprechenden Operation verzweigen, handelt es sich womöglich um gar keine Zahl, dann muss es einen Laufzeitfehler signalisieren oder sich etwas anderes einfallen lassen. Dem kann man entgegenhalten, dass im Falle der objektorientierten Programmierung selbst bei einer Typisierung aller Variablen gelegentlich noch Laufzeittests durchgeführt (oder andernfalls schwere Programmfehler in Kauf genommen) werden müssen, und dass sich die zur Optimierung benötigte Information auch anders als über explizite Typisierung von Variablen (z. B. über die sog. Typinferenz, also die Ausnutzung impliziter Typinformation) gewinnen lässt.
Zu 3.: In der Vergangenheit hatten Variablen eher kurze, wenig selbsterklärende Namen (vgl. dazu auch Kapitel 62 in Kurseinheit 7). Es ist dann sinnvoll, wenigstens an der Stelle der ersten Erwähnung der Variablen (in der Regel deren Deklaration) einen Hinweis darauf zu haben, wofür (für welche Menge von Objekten) die Variable steht. Dies kann über einen Kommentar erfolgen, aber auch durch die Assoziation mit einem Typen, die aussagt, welcher Art die Werte der Variable sein müssen. Doch nicht nur Variablen-, auch Methodennamen können für sich genommen wenig aussagekräftig sein und durch die Verknüpfung mit Typen aussagekräftiger gemacht werden: Eine Deklaration der Methode next etwa, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, legt nahe, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren. Dem mag man freilich entgegenhalten, dass man stattdessen ja auch selbsterklärende Namen für Variablen und Methoden vergeben könnte (mehr dazu in Kurseinheit 7, Kapitel 62).
Es bleibt aber in jedem Fall Punkt 4, das Aufdecken von logischen Fehlern in einem Programm. Ohne externes Wissen, was ein Programm tun soll, verlangt das Finden von Fehlern jedoch ein gewisses Maß an Redundanz, also die mehrfache Lieferung gleicher Information, im Programm, denn nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen logischen Programmierfehler hinweisen. Die Verknüpfung von deklarierten Elementen mit Typen erlaubt aber genau die Angabe solcher redundanter Information. Die Schaffung dieser Redundanz verlangt jedoch vermehrte Denk- und Schreibarbeit und ist zudem auch noch, im Falle eines fehlerfreien Programms, überflüssig. Dem kann man allerdings entgegenhalten, dass kaum eine Programmiererin auf Anhieb korrekte Programme schreibt, und wenn eine Typisierung Fehler zu finden in der Lage ist und somit nicht minder aufwendige Tests ersetzt, dann ist das natürlich gut.
Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der heute üblichen Typsysteme ist übrigens die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt. Mehr dazu jedoch erst später (in Abschnitt 28.2).
Die der Fehlerentdeckung mittels Typsystemen zugrundeliegende These ist, dass ein guter Teil logischer Programmierfehler bereits frühzeitig daran erkannt werden kann, dass eine Variable einen Wert hat, den sie eigentlich niemals haben dürfte. So zeugt beispielsweise von einem Fehler, wenn einer Variable, die für Zahlen gedacht war, eine Zeichenkette zugewiesen wird. Wenn dann nämlich einem Ausdruck mit einer arithmetischen Operation, die Zahlen als Operanden verlangt, eine solchermaßen fehlbelegte Variable zugeführt wird, kann dieser nicht ausgewertet werden. Ohne Typprüfung würde dieser Fehler erst zur Laufzeit, also wenn der Ausdruck tatsächlich ausgewertet werden soll, in Erscheinung treten und hätte dann in aller Regel einen Programmabbruch zur Folge. Man nennt einen solchen Programmierfehler einen Typfehler.
Während ein Programmabbruch wenigstens noch eine erkennbare Reaktion auf einen Programmierfehler darstellt, ist es fast noch schlimmer, wenn ein logischer Fehler ohne solche bleibt. So kann es beispielsweise vorkommen, dass man einer Variable, deren Inhalt eine Strecke darstellen soll, eine andere zuweist, deren Inhalt eine Zeit repräsentiert. Mit beiden ließe sich gleich rechnen (dieselben Rechenoperationen durchführen), aber das Ergebnis wäre vermutlich falsch. Merken muss man das allerdings selbst, denn das Programm läuft einfach weiter.
Man kann Variablenfehlbelegungen dieser Art verhindern, indem man Variablen mit expliziten Typinvarianten versieht, die die Menge ihrer zulässigen Werte beschränken, und dann darüber wacht, dass diese Invarianten immer eingehalten werden. Eine besonders einfache Möglichkeit, solche Invarianten zu spezifizieren, erlauben sogenannte Typannotationen, also die Verbindung einer Variable mit einem Typen, wobei der Typ eine Menge von Werten festlegt, die die Variable ausschließlich haben darf. In typisierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Variablendeklaration; in nicht oder nur optional typisierten Sprachen kann sie auch (für einzelne oder alle Variablen) hergeleitet (inferiert; die Typinferenz) werden und ist dann implizit.
Ein Programm, in dem alle Variablenbelegungen immer alle Typinvarianten erfüllen, heißt typkorrekt. In einer Sprache, die durch ihr Typsystem Typkorrektheit festzustellen erlaubt, nennt man die logischen Fehler, die sich in unzulässigen Wertzuweisungen ausdrücken, auch semantische Fehler (und zwar, weil der Inhalt eines Programmelements nicht seiner intendierten Bedeutung entspricht). Dabei ist die Semantik des Programmelements im Programm zweimal, auf redundante, aber unterschiedliche Art, spezifiziert: in Form seines Typs und in Form seiner tatsächlichen Verwendung (festgelegt durch Zuweisungen und Methodenaufrufe). Lässt sich aus beiden ein Widerspruch ableiten, muss eine von beiden falsch gewesen sein.
Der einzige Weg, eine mit der Typisierung einer Variable ausgedrückte Invariante zu verletzen, also Typinkorrektheit herzustellen, ist per Wertzuweisung an die Variable. Ein Typsystem muss also lediglich alle Wertzuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu zählen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen (s. Abschnitt 4.3.2), die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind. Im Folgenden heißen Zuweisungen und Methodenaufrufe, die nicht zu typinkorrekten Programmen führen können, zulässig.
Nun kann man sich vorstellen, dass es für einen Compiler selbst in einfachen Fällen nicht leicht ist, festzustellen, ob eine Wertzuweisung eine Invariante verletzt und somit zu einem typinkorrekten Programm führt. So ist das folgende STRONGTALK-Programmfragment das zunächst eine temporäre Variable i mit dem Typ Integer (in STRONGTALK wird die Typannotation hinter der Variable in spitzen Klammern angeführt) deklariert und ihr dann, in einer Folge von Anweisungen, zunächst 0 und dann 1 (beides Werte vom Typ Integer) zuweist, zwar typkorrekt im Sinne obiger Definition, aber um das zu erschließen, muss man schon wissen, dass die Bedingung in Zeile 835 immer erfüllt ist, der False-Zweig, der zu einer Verletzung der Invariante von i (nämlich dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen) führen würde, also nie ausgeführt wird. Im gegebenen Fall ist das zwar offensichtlich (und bereits von einer recht einfachen Programmanalyse feststellbar), aber es lassen sich auch Fälle konstruieren, in denen eine automatische Programmanalyse streiken muss.
Was man jedoch immer tun kann, um Typkorrektheit zu gewährleisten, ist, dass man zur Laufzeit vor einer Variablenzuweisung prüft, ob der zuzuweisende Wert den von der Variable geforderten Typ hat. Diese sogenannte dynamische Typprüfung (engl. dynamic type checking) hat jedoch den entscheidenden Nachteil, dass sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes machen kann als einen Fehler zu signalisieren (der dann günstigenfalls durch eine dafür vorgesehene Fehlerbehandlungsmethode aufgefangen wird, der aber in der Praxis häufig nur zu einem Programmabbruch führt). Man kann jedoch argumentieren, dass auch letzteres immer noch besser ist, als mit falschen Werten weiterzuarbeiten und damit entweder einen Programmabbruch an einer anderen Stelle, die nicht mehr so leicht mit der fehlerhaften Wertzuweisung in Zusammenhang zu bringen ist, in Kauf zu nehmen oder gar einen logischen Fehler, der überhaupt nicht erkannt wird.
Man beachte übrigens, dass nach diesem Kriterium SMALLTALK — entgegen häufig zu lesenden Behauptungen — keine dynamische Typprüfung durchführt, da Typfehler erst im letztmöglichen Moment offenbar werden, nämlich wenn auf einer Variable eine Methode aufgerufen werden soll, die für das Objekt, auf das die Variable verweist, gar nicht definiert ist. Um das zu verhindern, findet man in SMALLTALK-Code gelegentlich Figuren wie (SMALLTALK EXPRESS entnommen). Dies entspricht natürlich genau einer dynamischen Typprüfung, nur dass hier Typ durch Klasse ersetzt wurde und die Prüfung eben nicht automatisch durch ein Laufzeittypsystem erfolgt, sondern ausprogrammiert werden muss.
Eine Typisierung findet in SMALLTALK gar nicht, auch nicht zur Laufzeit, statt. Außerdem ist mit dynamischer Typisierung in der Regel dynamische Typprüfung gemeint. Was ein dynamischer Typ sein soll, ist auch gar nicht klar. dynamische
Sehr viel nützlicher als die dynamische Typprüfung ist die statische Typprüfung, bei der, trotz aller theoretischen Hindernisse, die Typkorrektheit zur Übersetzungszeit gewährleistet werden soll. Die Typprüfung ist damit Aufgabe des Compilers und nicht, wie im Fall der dynamischen Typprüfung, Aufgabe des Laufzeitsystems oder gar der Programmiererin. Wie wir schon gesehen haben, bedeutet dies nicht weniger, als einen Beweis zu führen, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird. In der Praxis bedeutet dies aber, dass eine rein statische Typprüfung immer auch Programme zurückweist, die nützlich, sinnvoll und typkorrekt sind (s. obiges Beispiel der Zeilen
Zwar kann man versuchen, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen, aber wie man sich leicht vorstellen kann, wird mit steigender Genauigkeit das dazu notwendige Typsystem immer aufwendiger und schwieriger zu benutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken soll (so dass man bei auftretenden Typfehlern erst einmal prüfen muss, ob die Ursache tatsächlich in einem fehlerhaften Programm oder vielleicht nur in fehlerhaften Typannotationen liegt).
So ist die Suche nach einem guten Typsystem immer die Suche nach einem guten Kompromiss. Die meisten heute in der Praxis verwendeten Typsysteme basieren auf einem solchen: einer statischen Komponente, die möglichst viele Fehler findet, ohne dabei die Programmiererin allzu sehr einzuschränken, und einer dynamischen Komponente, die den Rest erledigt. Eine erwähnenswerte Ausnahme von diesem Muster bildet das STRONGTALK-Typsystem (s. Abschnitt 4.4.4).
Ein weiterer Kompromiss betrifft die Ausdruckskraft des Typsystems. Je ausdruckskräftiger ein Typsystem ist, desto mehr Informationen kann es in einer Typannotation unterbringen und desto mehr Typfehler lassen sich aufdecken. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass es in einem konkreten Fall notwendig ist, eine aufwändige (und unter Umständen nicht einmal terminierende) Typprüfung durchzuführen. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen (Interfaces, siehe Kapitel 62) deutlich erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können (dies ist in der objektorientierten Programmierung ein schwer wiegendes Manko, da das gemeinsame Arbeiten von Klassen aus verschiedenen Bibliotheken die Regel ist).
Die folgende Grafik zeigt, wie die Typisierung von Variablen und anderen Programmkonstrukten in den verschiedenen Phasen eines Entwicklungszyklus verwendet werden kann:
Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt.
Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben.
Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält.
Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert.
Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.
Zusammenfassend kann man sagen, dass Typisierung in der Softwareentwicklung eine wichtige Rolle spielt, um die Qualität, Sicherheit und Wartbarkeit von Programmen zu erhöhen. Sie ermöglicht es, Fehler frühzeitig zu erkennen, die Lesbarkeit des Codes zu verbessern und die Zusammenarbeit in größeren Entwicklungsprojekten zu erleichtern. Es gibt verschiedene Ansätze zur Typisierung, von dynamischer Typprüfung zur Laufzeit bis hin zu statischer Typprüfung während der Übersetzungsphase, und die Wahl des richtigen Typsystems hängt von den Anforderungen des jeweiligen Projekts ab.","<answer> Es gibt mindestens vier gute Gründe für die Typisierung von Variablen und anderen Programmelementen: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm. <answer> <question> Welche Gründe gibt es, Variablen und andere Programmelemente zu typisieren? <question>"
"Sie kennen vielleicht aus anderen Programmiersprachen, dass Variablen und anderen Programmelementen bei ihrer Deklaration (Kapitel 19) ein Typ zugeordnet wird. Dieser Typ schränkt die möglichen Werte der deklarierten Elemente ein. So lassen sich beispielsweise in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zeichenketten speichern.
Typ ist ein primitiver Begriff, vergleichbar etwa mit dem Begriff der Menge in der Mengentheorie. Ein Typ hat eine Intension und eine Extension, wobei erstere der Definition des Typs entspricht, letztere seinem Wertebereich, also der Menge der Elemente (Objekte), die zu dem Typ gehören (man sagt auch, „die den Typ haben“ oder „die von dem Typ sind“). Häufig hat ein Typ auch einen Namen, den Typbezeichner. Typen sind die Grundlage von Typsystemen.
Ihnen fällt wahrscheinlich sofort die Ähnlichkeit zum Konstrukt der Klasse, wie es in der letzten Kurseinheit eingeführt wurde, auf. Tatsächlich gibt es hier auch einen Zusammenhang. Um Sie aber nicht gleich in für diese Kurseinheit eher schädliche Denkmuster verfallen zu lassen, soll dieser Zusammenhang zunächst zurückgestellt werden. Eine Aufklärung erfolgt dann in Kapitel 28.
Ein Typsystem umfasst Typausdrücke, Objekt- oder Wertausdrücke, Regeln, die Wertausdrücken Typen zuordnen, und Regeln, die von Wertausdrücken einzuhalten sind (zusammen die Typregeln). Wertausdrücke (bzw. schlicht Ausdrücke, wenn es nicht um die Abgrenzung von Typausdrücken geht) kennen Sie schon: In SMALLTALK sind es die in Kurseinheit 1, Kapitel 4.1 aufgeführten. Mit den anderen Konzepten werden Sie in den nachfolgenden Kapiteln vertraut gemacht, allerdings in weniger formaler Form, als Sie das nach dieser Definition vielleicht befürchten.
Warum aber typisiert man Variablen und andere Programmelemente? Dafür gibt es mindestens vier gute Gründe: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm.
Zu 1.: Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss. Dies ist jedoch naturgemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Programmierung, insbesondere für Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung.
Zu 2.: Wenn man weiß, dass die Werte einer Variable immer vom selben Typ sind, also alle demselben Wertebereich entstammen, dann lassen sich bestimmte Optimierungen durchführen. Wenn man z. B. aufgrund der Deklaration einer Variable x für gegeben annehmen kann, dass x nur ganze Zahlen enthält, dann kann der Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkrement-Anweisung des Prozessors verwenden. Kennt der Compiler den Typ von x hingegen nicht, dann muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist — handelt es sich um eine Fließkommazahl, so muss es zu der entsprechenden Operation verzweigen, handelt es sich womöglich um gar keine Zahl, dann muss es einen Laufzeitfehler signalisieren oder sich etwas anderes einfallen lassen. Dem kann man entgegenhalten, dass im Falle der objektorientierten Programmierung selbst bei einer Typisierung aller Variablen gelegentlich noch Laufzeittests durchgeführt (oder andernfalls schwere Programmfehler in Kauf genommen) werden müssen, und dass sich die zur Optimierung benötigte Information auch anders als über explizite Typisierung von Variablen (z. B. über die sog. Typinferenz, also die Ausnutzung impliziter Typinformation) gewinnen lässt.
Zu 3.: In der Vergangenheit hatten Variablen eher kurze, wenig selbsterklärende Namen (vgl. dazu auch Kapitel 62 in Kurseinheit 7). Es ist dann sinnvoll, wenigstens an der Stelle der ersten Erwähnung der Variablen (in der Regel deren Deklaration) einen Hinweis darauf zu haben, wofür (für welche Menge von Objekten) die Variable steht. Dies kann über einen Kommentar erfolgen, aber auch durch die Assoziation mit einem Typen, die aussagt, welcher Art die Werte der Variable sein müssen. Doch nicht nur Variablen-, auch Methodennamen können für sich genommen wenig aussagekräftig sein und durch die Verknüpfung mit Typen aussagekräftiger gemacht werden: Eine Deklaration der Methode next etwa, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, legt nahe, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren. Dem mag man freilich entgegenhalten, dass man stattdessen ja auch selbsterklärende Namen für Variablen und Methoden vergeben könnte (mehr dazu in Kurseinheit 7, Kapitel 62).
Es bleibt aber in jedem Fall Punkt 4, das Aufdecken von logischen Fehlern in einem Programm. Ohne externes Wissen, was ein Programm tun soll, verlangt das Finden von Fehlern jedoch ein gewisses Maß an Redundanz, also die mehrfache Lieferung gleicher Information, im Programm, denn nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen logischen Programmierfehler hinweisen. Die Verknüpfung von deklarierten Elementen mit Typen erlaubt aber genau die Angabe solcher redundanter Information. Die Schaffung dieser Redundanz verlangt jedoch vermehrte Denk- und Schreibarbeit und ist zudem auch noch, im Falle eines fehlerfreien Programms, überflüssig. Dem kann man allerdings entgegenhalten, dass kaum eine Programmiererin auf Anhieb korrekte Programme schreibt, und wenn eine Typisierung Fehler zu finden in der Lage ist und somit nicht minder aufwendige Tests ersetzt, dann ist das natürlich gut.
Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der heute üblichen Typsysteme ist übrigens die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt. Mehr dazu jedoch erst später (in Abschnitt 28.2).
Die der Fehlerentdeckung mittels Typsystemen zugrundeliegende These ist, dass ein guter Teil logischer Programmierfehler bereits frühzeitig daran erkannt werden kann, dass eine Variable einen Wert hat, den sie eigentlich niemals haben dürfte. So zeugt beispielsweise von einem Fehler, wenn einer Variable, die für Zahlen gedacht war, eine Zeichenkette zugewiesen wird. Wenn dann nämlich einem Ausdruck mit einer arithmetischen Operation, die Zahlen als Operanden verlangt, eine solchermaßen fehlbelegte Variable zugeführt wird, kann dieser nicht ausgewertet werden. Ohne Typprüfung würde dieser Fehler erst zur Laufzeit, also wenn der Ausdruck tatsächlich ausgewertet werden soll, in Erscheinung treten und hätte dann in aller Regel einen Programmabbruch zur Folge. Man nennt einen solchen Programmierfehler einen Typfehler.
Während ein Programmabbruch wenigstens noch eine erkennbare Reaktion auf einen Programmierfehler darstellt, ist es fast noch schlimmer, wenn ein logischer Fehler ohne solche bleibt. So kann es beispielsweise vorkommen, dass man einer Variable, deren Inhalt eine Strecke darstellen soll, eine andere zuweist, deren Inhalt eine Zeit repräsentiert. Mit beiden ließe sich gleich rechnen (dieselben Rechenoperationen durchführen), aber das Ergebnis wäre vermutlich falsch. Merken muss man das allerdings selbst, denn das Programm läuft einfach weiter.
Man kann Variablenfehlbelegungen dieser Art verhindern, indem man Variablen mit expliziten Typinvarianten versieht, die die Menge ihrer zulässigen Werte beschränken, und dann darüber wacht, dass diese Invarianten immer eingehalten werden. Eine besonders einfache Möglichkeit, solche Invarianten zu spezifizieren, erlauben sogenannte Typannotationen, also die Verbindung einer Variable mit einem Typen, wobei der Typ eine Menge von Werten festlegt, die die Variable ausschließlich haben darf. In typisierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Variablendeklaration; in nicht oder nur optional typisierten Sprachen kann sie auch (für einzelne oder alle Variablen) hergeleitet (inferiert; die Typinferenz) werden und ist dann implizit.
Ein Programm, in dem alle Variablenbelegungen immer alle Typinvarianten erfüllen, heißt typkorrekt. In einer Sprache, die durch ihr Typsystem Typkorrektheit festzustellen erlaubt, nennt man die logischen Fehler, die sich in unzulässigen Wertzuweisungen ausdrücken, auch semantische Fehler (und zwar, weil der Inhalt eines Programmelements nicht seiner intendierten Bedeutung entspricht). Dabei ist die Semantik des Programmelements im Programm zweimal, auf redundante, aber unterschiedliche Art, spezifiziert: in Form seines Typs und in Form seiner tatsächlichen Verwendung (festgelegt durch Zuweisungen und Methodenaufrufe). Lässt sich aus beiden ein Widerspruch ableiten, muss eine von beiden falsch gewesen sein.
Der einzige Weg, eine mit der Typisierung einer Variable ausgedrückte Invariante zu verletzen, also Typinkorrektheit herzustellen, ist per Wertzuweisung an die Variable. Ein Typsystem muss also lediglich alle Wertzuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu zählen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen (s. Abschnitt 4.3.2), die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind. Im Folgenden heißen Zuweisungen und Methodenaufrufe, die nicht zu typinkorrekten Programmen führen können, zulässig.
Nun kann man sich vorstellen, dass es für einen Compiler selbst in einfachen Fällen nicht leicht ist, festzustellen, ob eine Wertzuweisung eine Invariante verletzt und somit zu einem typinkorrekten Programm führt. So ist das folgende STRONGTALK-Programmfragment das zunächst eine temporäre Variable i mit dem Typ Integer (in STRONGTALK wird die Typannotation hinter der Variable in spitzen Klammern angeführt) deklariert und ihr dann, in einer Folge von Anweisungen, zunächst 0 und dann 1 (beides Werte vom Typ Integer) zuweist, zwar typkorrekt im Sinne obiger Definition, aber um das zu erschließen, muss man schon wissen, dass die Bedingung in Zeile 835 immer erfüllt ist, der False-Zweig, der zu einer Verletzung der Invariante von i (nämlich dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen) führen würde, also nie ausgeführt wird. Im gegebenen Fall ist das zwar offensichtlich (und bereits von einer recht einfachen Programmanalyse feststellbar), aber es lassen sich auch Fälle konstruieren, in denen eine automatische Programmanalyse streiken muss.
Was man jedoch immer tun kann, um Typkorrektheit zu gewährleisten, ist, dass man zur Laufzeit vor einer Variablenzuweisung prüft, ob der zuzuweisende Wert den von der Variable geforderten Typ hat. Diese sogenannte dynamische Typprüfung (engl. dynamic type checking) hat jedoch den entscheidenden Nachteil, dass sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes machen kann als einen Fehler zu signalisieren (der dann günstigenfalls durch eine dafür vorgesehene Fehlerbehandlungsmethode aufgefangen wird, der aber in der Praxis häufig nur zu einem Programmabbruch führt). Man kann jedoch argumentieren, dass auch letzteres immer noch besser ist, als mit falschen Werten weiterzuarbeiten und damit entweder einen Programmabbruch an einer anderen Stelle, die nicht mehr so leicht mit der fehlerhaften Wertzuweisung in Zusammenhang zu bringen ist, in Kauf zu nehmen oder gar einen logischen Fehler, der überhaupt nicht erkannt wird.
Man beachte übrigens, dass nach diesem Kriterium SMALLTALK — entgegen häufig zu lesenden Behauptungen — keine dynamische Typprüfung durchführt, da Typfehler erst im letztmöglichen Moment offenbar werden, nämlich wenn auf einer Variable eine Methode aufgerufen werden soll, die für das Objekt, auf das die Variable verweist, gar nicht definiert ist. Um das zu verhindern, findet man in SMALLTALK-Code gelegentlich Figuren wie (SMALLTALK EXPRESS entnommen). Dies entspricht natürlich genau einer dynamischen Typprüfung, nur dass hier Typ durch Klasse ersetzt wurde und die Prüfung eben nicht automatisch durch ein Laufzeittypsystem erfolgt, sondern ausprogrammiert werden muss.
Eine Typisierung findet in SMALLTALK gar nicht, auch nicht zur Laufzeit, statt. Außerdem ist mit dynamischer Typisierung in der Regel dynamische Typprüfung gemeint. Was ein dynamischer Typ sein soll, ist auch gar nicht klar. dynamische
Sehr viel nützlicher als die dynamische Typprüfung ist die statische Typprüfung, bei der, trotz aller theoretischen Hindernisse, die Typkorrektheit zur Übersetzungszeit gewährleistet werden soll. Die Typprüfung ist damit Aufgabe des Compilers und nicht, wie im Fall der dynamischen Typprüfung, Aufgabe des Laufzeitsystems oder gar der Programmiererin. Wie wir schon gesehen haben, bedeutet dies nicht weniger, als einen Beweis zu führen, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird. In der Praxis bedeutet dies aber, dass eine rein statische Typprüfung immer auch Programme zurückweist, die nützlich, sinnvoll und typkorrekt sind (s. obiges Beispiel der Zeilen
Zwar kann man versuchen, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen, aber wie man sich leicht vorstellen kann, wird mit steigender Genauigkeit das dazu notwendige Typsystem immer aufwendiger und schwieriger zu benutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken soll (so dass man bei auftretenden Typfehlern erst einmal prüfen muss, ob die Ursache tatsächlich in einem fehlerhaften Programm oder vielleicht nur in fehlerhaften Typannotationen liegt).
So ist die Suche nach einem guten Typsystem immer die Suche nach einem guten Kompromiss. Die meisten heute in der Praxis verwendeten Typsysteme basieren auf einem solchen: einer statischen Komponente, die möglichst viele Fehler findet, ohne dabei die Programmiererin allzu sehr einzuschränken, und einer dynamischen Komponente, die den Rest erledigt. Eine erwähnenswerte Ausnahme von diesem Muster bildet das STRONGTALK-Typsystem (s. Abschnitt 4.4.4).
Ein weiterer Kompromiss betrifft die Ausdruckskraft des Typsystems. Je ausdruckskräftiger ein Typsystem ist, desto mehr Informationen kann es in einer Typannotation unterbringen und desto mehr Typfehler lassen sich aufdecken. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass es in einem konkreten Fall notwendig ist, eine aufwändige (und unter Umständen nicht einmal terminierende) Typprüfung durchzuführen. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen (Interfaces, siehe Kapitel 62) deutlich erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können (dies ist in der objektorientierten Programmierung ein schwer wiegendes Manko, da das gemeinsame Arbeiten von Klassen aus verschiedenen Bibliotheken die Regel ist).
Die folgende Grafik zeigt, wie die Typisierung von Variablen und anderen Programmkonstrukten in den verschiedenen Phasen eines Entwicklungszyklus verwendet werden kann:
Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt.
Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben.
Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält.
Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert.
Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.
Zusammenfassend kann man sagen, dass Typisierung in der Softwareentwicklung eine wichtige Rolle spielt, um die Qualität, Sicherheit und Wartbarkeit von Programmen zu erhöhen. Sie ermöglicht es, Fehler frühzeitig zu erkennen, die Lesbarkeit des Codes zu verbessern und die Zusammenarbeit in größeren Entwicklungsprojekten zu erleichtern. Es gibt verschiedene Ansätze zur Typisierung, von dynamischer Typprüfung zur Laufzeit bis hin zu statischer Typprüfung während der Übersetzungsphase, und die Wahl des richtigen Typsystems hängt von den Anforderungen des jeweiligen Projekts ab.","<answer> Statische Typprüfung erfolgt zur Übersetzungszeit und gewährleistet, dass die Typkorrektheit eines Programms vor der Ausführung sichergestellt wird. Dynamische Typprüfung erfolgt zur Laufzeit und prüft, ob der zuzuweisende Wert den geforderten Typ hat. Statische Typprüfung erfordert Typenannotationen bei der Variablendeklaration, während dynamische Typprüfung dies zur Laufzeit überprüft. <answer> <question> Was ist der Unterschied zwischen statischer und dynamischer Typprüfung? <question>"
"Sie kennen vielleicht aus anderen Programmiersprachen, dass Variablen und anderen Programmelementen bei ihrer Deklaration (Kapitel 19) ein Typ zugeordnet wird. Dieser Typ schränkt die möglichen Werte der deklarierten Elemente ein. So lassen sich beispielsweise in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zeichenketten speichern.
Typ ist ein primitiver Begriff, vergleichbar etwa mit dem Begriff der Menge in der Mengentheorie. Ein Typ hat eine Intension und eine Extension, wobei erstere der Definition des Typs entspricht, letztere seinem Wertebereich, also der Menge der Elemente (Objekte), die zu dem Typ gehören (man sagt auch, „die den Typ haben“ oder „die von dem Typ sind“). Häufig hat ein Typ auch einen Namen, den Typbezeichner. Typen sind die Grundlage von Typsystemen.
Ihnen fällt wahrscheinlich sofort die Ähnlichkeit zum Konstrukt der Klasse, wie es in der letzten Kurseinheit eingeführt wurde, auf. Tatsächlich gibt es hier auch einen Zusammenhang. Um Sie aber nicht gleich in für diese Kurseinheit eher schädliche Denkmuster verfallen zu lassen, soll dieser Zusammenhang zunächst zurückgestellt werden. Eine Aufklärung erfolgt dann in Kapitel 28.
Ein Typsystem umfasst Typausdrücke, Objekt- oder Wertausdrücke, Regeln, die Wertausdrücken Typen zuordnen, und Regeln, die von Wertausdrücken einzuhalten sind (zusammen die Typregeln). Wertausdrücke (bzw. schlicht Ausdrücke, wenn es nicht um die Abgrenzung von Typausdrücken geht) kennen Sie schon: In SMALLTALK sind es die in Kurseinheit 1, Kapitel 4.1 aufgeführten. Mit den anderen Konzepten werden Sie in den nachfolgenden Kapiteln vertraut gemacht, allerdings in weniger formaler Form, als Sie das nach dieser Definition vielleicht befürchten.
Warum aber typisiert man Variablen und andere Programmelemente? Dafür gibt es mindestens vier gute Gründe: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm.
Zu 1.: Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss. Dies ist jedoch naturgemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Programmierung, insbesondere für Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung.
Zu 2.: Wenn man weiß, dass die Werte einer Variable immer vom selben Typ sind, also alle demselben Wertebereich entstammen, dann lassen sich bestimmte Optimierungen durchführen. Wenn man z. B. aufgrund der Deklaration einer Variable x für gegeben annehmen kann, dass x nur ganze Zahlen enthält, dann kann der Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkrement-Anweisung des Prozessors verwenden. Kennt der Compiler den Typ von x hingegen nicht, dann muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist — handelt es sich um eine Fließkommazahl, so muss es zu der entsprechenden Operation verzweigen, handelt es sich womöglich um gar keine Zahl, dann muss es einen Laufzeitfehler signalisieren oder sich etwas anderes einfallen lassen. Dem kann man entgegenhalten, dass im Falle der objektorientierten Programmierung selbst bei einer Typisierung aller Variablen gelegentlich noch Laufzeittests durchgeführt (oder andernfalls schwere Programmfehler in Kauf genommen) werden müssen, und dass sich die zur Optimierung benötigte Information auch anders als über explizite Typisierung von Variablen (z. B. über die sog. Typinferenz, also die Ausnutzung impliziter Typinformation) gewinnen lässt.
Zu 3.: In der Vergangenheit hatten Variablen eher kurze, wenig selbsterklärende Namen (vgl. dazu auch Kapitel 62 in Kurseinheit 7). Es ist dann sinnvoll, wenigstens an der Stelle der ersten Erwähnung der Variablen (in der Regel deren Deklaration) einen Hinweis darauf zu haben, wofür (für welche Menge von Objekten) die Variable steht. Dies kann über einen Kommentar erfolgen, aber auch durch die Assoziation mit einem Typen, die aussagt, welcher Art die Werte der Variable sein müssen. Doch nicht nur Variablen-, auch Methodennamen können für sich genommen wenig aussagekräftig sein und durch die Verknüpfung mit Typen aussagekräftiger gemacht werden: Eine Deklaration der Methode next etwa, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, legt nahe, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren. Dem mag man freilich entgegenhalten, dass man stattdessen ja auch selbsterklärende Namen für Variablen und Methoden vergeben könnte (mehr dazu in Kurseinheit 7, Kapitel 62).
Es bleibt aber in jedem Fall Punkt 4, das Aufdecken von logischen Fehlern in einem Programm. Ohne externes Wissen, was ein Programm tun soll, verlangt das Finden von Fehlern jedoch ein gewisses Maß an Redundanz, also die mehrfache Lieferung gleicher Information, im Programm, denn nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen logischen Programmierfehler hinweisen. Die Verknüpfung von deklarierten Elementen mit Typen erlaubt aber genau die Angabe solcher redundanter Information. Die Schaffung dieser Redundanz verlangt jedoch vermehrte Denk- und Schreibarbeit und ist zudem auch noch, im Falle eines fehlerfreien Programms, überflüssig. Dem kann man allerdings entgegenhalten, dass kaum eine Programmiererin auf Anhieb korrekte Programme schreibt, und wenn eine Typisierung Fehler zu finden in der Lage ist und somit nicht minder aufwendige Tests ersetzt, dann ist das natürlich gut.
Ein fünfter, oben nicht aufgezählter Grund zur Verwendung eines der heute üblichen Typsysteme ist übrigens die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt. Mehr dazu jedoch erst später (in Abschnitt 28.2).
Die der Fehlerentdeckung mittels Typsystemen zugrundeliegende These ist, dass ein guter Teil logischer Programmierfehler bereits frühzeitig daran erkannt werden kann, dass eine Variable einen Wert hat, den sie eigentlich niemals haben dürfte. So zeugt beispielsweise von einem Fehler, wenn einer Variable, die für Zahlen gedacht war, eine Zeichenkette zugewiesen wird. Wenn dann nämlich einem Ausdruck mit einer arithmetischen Operation, die Zahlen als Operanden verlangt, eine solchermaßen fehlbelegte Variable zugeführt wird, kann dieser nicht ausgewertet werden. Ohne Typprüfung würde dieser Fehler erst zur Laufzeit, also wenn der Ausdruck tatsächlich ausgewertet werden soll, in Erscheinung treten und hätte dann in aller Regel einen Programmabbruch zur Folge. Man nennt einen solchen Programmierfehler einen Typfehler.
Während ein Programmabbruch wenigstens noch eine erkennbare Reaktion auf einen Programmierfehler darstellt, ist es fast noch schlimmer, wenn ein logischer Fehler ohne solche bleibt. So kann es beispielsweise vorkommen, dass man einer Variable, deren Inhalt eine Strecke darstellen soll, eine andere zuweist, deren Inhalt eine Zeit repräsentiert. Mit beiden ließe sich gleich rechnen (dieselben Rechenoperationen durchführen), aber das Ergebnis wäre vermutlich falsch. Merken muss man das allerdings selbst, denn das Programm läuft einfach weiter.
Man kann Variablenfehlbelegungen dieser Art verhindern, indem man Variablen mit expliziten Typinvarianten versieht, die die Menge ihrer zulässigen Werte beschränken, und dann darüber wacht, dass diese Invarianten immer eingehalten werden. Eine besonders einfache Möglichkeit, solche Invarianten zu spezifizieren, erlauben sogenannte Typannotationen, also die Verbindung einer Variable mit einem Typen, wobei der Typ eine Menge von Werten festlegt, die die Variable ausschließlich haben darf. In typisierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Variablendeklaration; in nicht oder nur optional typisierten Sprachen kann sie auch (für einzelne oder alle Variablen) hergeleitet (inferiert; die Typinferenz) werden und ist dann implizit.
Ein Programm, in dem alle Variablenbelegungen immer alle Typinvarianten erfüllen, heißt typkorrekt. In einer Sprache, die durch ihr Typsystem Typkorrektheit festzustellen erlaubt, nennt man die logischen Fehler, die sich in unzulässigen Wertzuweisungen ausdrücken, auch semantische Fehler (und zwar, weil der Inhalt eines Programmelements nicht seiner intendierten Bedeutung entspricht). Dabei ist die Semantik des Programmelements im Programm zweimal, auf redundante, aber unterschiedliche Art, spezifiziert: in Form seines Typs und in Form seiner tatsächlichen Verwendung (festgelegt durch Zuweisungen und Methodenaufrufe). Lässt sich aus beiden ein Widerspruch ableiten, muss eine von beiden falsch gewesen sein.
Der einzige Weg, eine mit der Typisierung einer Variable ausgedrückte Invariante zu verletzen, also Typinkorrektheit herzustellen, ist per Wertzuweisung an die Variable. Ein Typsystem muss also lediglich alle Wertzuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu zählen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen (s. Abschnitt 4.3.2), die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind. Im Folgenden heißen Zuweisungen und Methodenaufrufe, die nicht zu typinkorrekten Programmen führen können, zulässig.
Nun kann man sich vorstellen, dass es für einen Compiler selbst in einfachen Fällen nicht leicht ist, festzustellen, ob eine Wertzuweisung eine Invariante verletzt und somit zu einem typinkorrekten Programm führt. So ist das folgende STRONGTALK-Programmfragment das zunächst eine temporäre Variable i mit dem Typ Integer (in STRONGTALK wird die Typannotation hinter der Variable in spitzen Klammern angeführt) deklariert und ihr dann, in einer Folge von Anweisungen, zunächst 0 und dann 1 (beides Werte vom Typ Integer) zuweist, zwar typkorrekt im Sinne obiger Definition, aber um das zu erschließen, muss man schon wissen, dass die Bedingung in Zeile 835 immer erfüllt ist, der False-Zweig, der zu einer Verletzung der Invariante von i (nämlich dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen) führen würde, also nie ausgeführt wird. Im gegebenen Fall ist das zwar offensichtlich (und bereits von einer recht einfachen Programmanalyse feststellbar), aber es lassen sich auch Fälle konstruieren, in denen eine automatische Programmanalyse streiken muss.
Was man jedoch immer tun kann, um Typkorrektheit zu gewährleisten, ist, dass man zur Laufzeit vor einer Variablenzuweisung prüft, ob der zuzuweisende Wert den von der Variable geforderten Typ hat. Diese sogenannte dynamische Typprüfung (engl. dynamic type checking) hat jedoch den entscheidenden Nachteil, dass sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes machen kann als einen Fehler zu signalisieren (der dann günstigenfalls durch eine dafür vorgesehene Fehlerbehandlungsmethode aufgefangen wird, der aber in der Praxis häufig nur zu einem Programmabbruch führt). Man kann jedoch argumentieren, dass auch letzteres immer noch besser ist, als mit falschen Werten weiterzuarbeiten und damit entweder einen Programmabbruch an einer anderen Stelle, die nicht mehr so leicht mit der fehlerhaften Wertzuweisung in Zusammenhang zu bringen ist, in Kauf zu nehmen oder gar einen logischen Fehler, der überhaupt nicht erkannt wird.
Man beachte übrigens, dass nach diesem Kriterium SMALLTALK — entgegen häufig zu lesenden Behauptungen — keine dynamische Typprüfung durchführt, da Typfehler erst im letztmöglichen Moment offenbar werden, nämlich wenn auf einer Variable eine Methode aufgerufen werden soll, die für das Objekt, auf das die Variable verweist, gar nicht definiert ist. Um das zu verhindern, findet man in SMALLTALK-Code gelegentlich Figuren wie (SMALLTALK EXPRESS entnommen). Dies entspricht natürlich genau einer dynamischen Typprüfung, nur dass hier Typ durch Klasse ersetzt wurde und die Prüfung eben nicht automatisch durch ein Laufzeittypsystem erfolgt, sondern ausprogrammiert werden muss.
Eine Typisierung findet in SMALLTALK gar nicht, auch nicht zur Laufzeit, statt. Außerdem ist mit dynamischer Typisierung in der Regel dynamische Typprüfung gemeint. Was ein dynamischer Typ sein soll, ist auch gar nicht klar. dynamische
Sehr viel nützlicher als die dynamische Typprüfung ist die statische Typprüfung, bei der, trotz aller theoretischen Hindernisse, die Typkorrektheit zur Übersetzungszeit gewährleistet werden soll. Die Typprüfung ist damit Aufgabe des Compilers und nicht, wie im Fall der dynamischen Typprüfung, Aufgabe des Laufzeitsystems oder gar der Programmiererin. Wie wir schon gesehen haben, bedeutet dies nicht weniger, als einen Beweis zu führen, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird. In der Praxis bedeutet dies aber, dass eine rein statische Typprüfung immer auch Programme zurückweist, die nützlich, sinnvoll und typkorrekt sind (s. obiges Beispiel der Zeilen
Zwar kann man versuchen, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen, aber wie man sich leicht vorstellen kann, wird mit steigender Genauigkeit das dazu notwendige Typsystem immer aufwendiger und schwieriger zu benutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken soll (so dass man bei auftretenden Typfehlern erst einmal prüfen muss, ob die Ursache tatsächlich in einem fehlerhaften Programm oder vielleicht nur in fehlerhaften Typannotationen liegt).
So ist die Suche nach einem guten Typsystem immer die Suche nach einem guten Kompromiss. Die meisten heute in der Praxis verwendeten Typsysteme basieren auf einem solchen: einer statischen Komponente, die möglichst viele Fehler findet, ohne dabei die Programmiererin allzu sehr einzuschränken, und einer dynamischen Komponente, die den Rest erledigt. Eine erwähnenswerte Ausnahme von diesem Muster bildet das STRONGTALK-Typsystem (s. Abschnitt 4.4.4).
Ein weiterer Kompromiss betrifft die Ausdruckskraft des Typsystems. Je ausdruckskräftiger ein Typsystem ist, desto mehr Informationen kann es in einer Typannotation unterbringen und desto mehr Typfehler lassen sich aufdecken. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass es in einem konkreten Fall notwendig ist, eine aufwändige (und unter Umständen nicht einmal terminierende) Typprüfung durchzuführen. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen (Interfaces, siehe Kapitel 62) deutlich erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können (dies ist in der objektorientierten Programmierung ein schwer wiegendes Manko, da das gemeinsame Arbeiten von Klassen aus verschiedenen Bibliotheken die Regel ist).
Die folgende Grafik zeigt, wie die Typisierung von Variablen und anderen Programmkonstrukten in den verschiedenen Phasen eines Entwicklungszyklus verwendet werden kann:
Entwurfsphase: In dieser Phase hilft die Typisierung, die Struktur des Programms zu definieren. Sie kann dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt.
Implementierungsphase: Während der Implementierung hilft die Typisierung, sicherzustellen, dass Variablen und Funktionen korrekt verwendet werden. Compiler und Entwicklungsumgebungen können Typfehler frühzeitig erkennen und dem Entwickler Rückmeldungen geben.
Testphase: Typisierung ermöglicht es, gezielte Tests durchzuführen, um sicherzustellen, dass das Programm die erwarteten Datentypen und Schnittstellen einhält.
Wartungsphase: Bei der Wartung eines Programms kann die Typisierung dazu beitragen, Änderungen sicherer zu gestalten, da sie potenzielle Typfehler frühzeitig identifiziert.
Dokumentation: Typinformationen dienen auch der Dokumentation des Codes, indem sie anderen Entwicklern helfen, den Code zu verstehen und korrekt zu verwenden.
Zusammenfassend kann man sagen, dass Typisierung in der Softwareentwicklung eine wichtige Rolle spielt, um die Qualität, Sicherheit und Wartbarkeit von Programmen zu erhöhen. Sie ermöglicht es, Fehler frühzeitig zu erkennen, die Lesbarkeit des Codes zu verbessern und die Zusammenarbeit in größeren Entwicklungsprojekten zu erleichtern. Es gibt verschiedene Ansätze zur Typisierung, von dynamischer Typprüfung zur Laufzeit bis hin zu statischer Typprüfung während der Übersetzungsphase, und die Wahl des richtigen Typsystems hängt von den Anforderungen des jeweiligen Projekts ab.","<answer> Die Typisierung wird in verschiedenen Phasen des Entwicklungszyklus verwendet: In der Entwurfsphase hilft sie bei der Strukturspezifikation. In der Implementierungsphase stellt sie sicher, dass Variablen und Funktionen korrekt verwendet werden. In der Testphase ermöglicht sie gezielte Tests, um die Einhaltung von Datentypen und Schnittstellen zu prüfen. In der Wartungsphase trägt sie zur sicheren Durchführung von Änderungen bei. Bei der Dokumentation hilft sie anderen Entwicklern, den Code zu verstehen und zu verwenden. <answer> <question> Welche Phase des Entwicklungszyklus verwendet die Typisierung in der Softwareentwicklung? <question>"
"In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung, die sogenannte ""Garbage Collection"". Garbage Collection ist ein Mechanismus, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr zugreifbar sind. Da in SMALLTALK auf Objekte nach ihrer Erzeugung ausschließlich über Variablen (Namen) zugegriffen werden kann, kann ein solches Objekt genau dann entfernt werden, wenn keine Variable mehr auf es verweist. Es kann entfernt werden, muss aber nicht; aus Sicht der Programmiererin ist es ausreichend, dass das Objekt nicht mehr bekannt oder benannt ist — es kann somit nicht mehr aufgefunden und durch eine Zuweisung einer Variable zugewiesen werden. Bei der Implementierung von Garbage-Collection-Algorithmen besteht daher erhebliche Freiheit.
Wenn Peter und Michaela heiraten, dann schlägt sich dies unter anderem in der Zuweisung petersNachmane := michaelasNachname nieder. Wenn 'Müller' keine Aliase (wie beispielsweise ""paulasNachname"") hatte, kann es nach der Zuweisung aus dem Speicher entfernt werden — es wäre selbst bei Bedarf nicht mehr auffindbar.
Von der automatischen Speicherbereinigung ausgenommen sind bestimmte Objekte mit eindeutiger literaler Repräsentation (wie z. B. kleine Zahlen, Zeichen und Symbole). Im Falle von Zahlen und Zeichen liegt das jedoch weniger an der Natur dieser Objekte selbst als vielmehr an der Tatsache, dass diese in der Regel nicht als Objekte im Speicher angelegt werden (so dass Variablen darauf verweisen könnten), sondern dass sie selbst, als Werte (und anstelle von Zeigern), in Variablen gespeichert werden (siehe Abschnitt 1.5.1). Sie werden ""entfernt"", indem einer Variable ein neuer Wert zugewiesen wird. Symbole werden schon deswegen nicht aus dem Speicher entfernt, weil sie in einer Symboltabelle abgelegt sind (und somit immer mindestens einmal referenziert werden; siehe Fußnote 5).
Der Mut zur Verabschiedung von der expliziten Speicherfreigabe war eine der wichtigsten Entscheidungen beim Entwurf von SMALLTALK. Man hat einfach anerkannt, dass die genaue Buchführung darüber, auf welche Objekte noch zugegriffen wird, zu schwierig ist, um die Verantwortung dafür den Anwendungsprogrammierern zu überlassen. Wer das Problem nicht unmittelbar einsichtig findet, halte sich vor Augen, dass der Ort der Erzeugung eines Objektes und seine erste Zuweisung zu einer Variable im Programm möglicherweise weit entfernt sind von der Stelle, an der dieser Variable ein anderes Objekt zugewiesen wird, es möglicherweise viele solcher Stellen gibt, von denen mal die eine, mal die andere zuerst erreicht wird, und dass in der Zwischenzeit beliebig viele Aliase auf das Objekt angelegt worden sein könnten, die alle mit berücksichtigt werden müssen, um zu entscheiden, ob das Objekt noch in Verwendung ist.
Eine vorzeitige Entfernung aus dem Speicher hingegen führt dazu, dass Variablen ins Leere zeigen (eine häufige Quelle von Programmabstürzen) oder dass, bei einer Wiederverwendung des Speichers, die Variable plötzlich auf ein anderes Objekt verweist, das ihr aber nie explizit zugewiesen wurde — ein quasi zufälliges Programmverhalten, das mit hoher Wahrscheinlichkeit zu schweren Programmfehlern führen würde. Ein anderes Beispiel entsteht, wenn in einer Verzweigung eines Programms entweder ein neues oder ein bereits vorhandenes Objekt einer Variable zugewiesen wird. Woher weiß man bei der weiteren Benutzung dieser Variable, ob das Objekt schon vorher existierte und vielleicht schon andere Variablen auf es verweisen, oder ob es gerade erst neu erzeugt wurde und damit noch unbenutzt ist? Wer ist für die Entsorgung des Objekts verantwortlich? All diese Betrachtungen kann man sich in Gegenwart der Garbage Collection ersparen.
Im objektorientierten Jargon spricht man übrigens häufig auch vom ""Lebenszyklus"" (""Life Cycle"") eines Objekts. Genaugenommen ist dies jedoch irreführend, denn das Wort ""Zyklus"" verspricht, dass das Leben nach seinem Ende wieder neu beginnt. Gerade dies ist aber, wie eben erläutert, nicht der Fall: Objekte werden nicht recycelt, sondern höchstens der Speicherplatz, den sie belegen.","<answer> Die ""Garbage Collection"" ist ein Mechanismus in SMALLTALK, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr über Variablen zugreifbar sind. <answer> <question> Was ist die ""Garbage Collection"" in SMALLTALK? <question>"
"In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung, die sogenannte ""Garbage Collection"". Garbage Collection ist ein Mechanismus, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr zugreifbar sind. Da in SMALLTALK auf Objekte nach ihrer Erzeugung ausschließlich über Variablen (Namen) zugegriffen werden kann, kann ein solches Objekt genau dann entfernt werden, wenn keine Variable mehr auf es verweist. Es kann entfernt werden, muss aber nicht; aus Sicht der Programmiererin ist es ausreichend, dass das Objekt nicht mehr bekannt oder benannt ist — es kann somit nicht mehr aufgefunden und durch eine Zuweisung einer Variable zugewiesen werden. Bei der Implementierung von Garbage-Collection-Algorithmen besteht daher erhebliche Freiheit.
Wenn Peter und Michaela heiraten, dann schlägt sich dies unter anderem in der Zuweisung petersNachmane := michaelasNachname nieder. Wenn 'Müller' keine Aliase (wie beispielsweise ""paulasNachname"") hatte, kann es nach der Zuweisung aus dem Speicher entfernt werden — es wäre selbst bei Bedarf nicht mehr auffindbar.
Von der automatischen Speicherbereinigung ausgenommen sind bestimmte Objekte mit eindeutiger literaler Repräsentation (wie z. B. kleine Zahlen, Zeichen und Symbole). Im Falle von Zahlen und Zeichen liegt das jedoch weniger an der Natur dieser Objekte selbst als vielmehr an der Tatsache, dass diese in der Regel nicht als Objekte im Speicher angelegt werden (so dass Variablen darauf verweisen könnten), sondern dass sie selbst, als Werte (und anstelle von Zeigern), in Variablen gespeichert werden (siehe Abschnitt 1.5.1). Sie werden ""entfernt"", indem einer Variable ein neuer Wert zugewiesen wird. Symbole werden schon deswegen nicht aus dem Speicher entfernt, weil sie in einer Symboltabelle abgelegt sind (und somit immer mindestens einmal referenziert werden; siehe Fußnote 5).
Der Mut zur Verabschiedung von der expliziten Speicherfreigabe war eine der wichtigsten Entscheidungen beim Entwurf von SMALLTALK. Man hat einfach anerkannt, dass die genaue Buchführung darüber, auf welche Objekte noch zugegriffen wird, zu schwierig ist, um die Verantwortung dafür den Anwendungsprogrammierern zu überlassen. Wer das Problem nicht unmittelbar einsichtig findet, halte sich vor Augen, dass der Ort der Erzeugung eines Objektes und seine erste Zuweisung zu einer Variable im Programm möglicherweise weit entfernt sind von der Stelle, an der dieser Variable ein anderes Objekt zugewiesen wird, es möglicherweise viele solcher Stellen gibt, von denen mal die eine, mal die andere zuerst erreicht wird, und dass in der Zwischenzeit beliebig viele Aliase auf das Objekt angelegt worden sein könnten, die alle mit berücksichtigt werden müssen, um zu entscheiden, ob das Objekt noch in Verwendung ist.
Eine vorzeitige Entfernung aus dem Speicher hingegen führt dazu, dass Variablen ins Leere zeigen (eine häufige Quelle von Programmabstürzen) oder dass, bei einer Wiederverwendung des Speichers, die Variable plötzlich auf ein anderes Objekt verweist, das ihr aber nie explizit zugewiesen wurde — ein quasi zufälliges Programmverhalten, das mit hoher Wahrscheinlichkeit zu schweren Programmfehlern führen würde. Ein anderes Beispiel entsteht, wenn in einer Verzweigung eines Programms entweder ein neues oder ein bereits vorhandenes Objekt einer Variable zugewiesen wird. Woher weiß man bei der weiteren Benutzung dieser Variable, ob das Objekt schon vorher existierte und vielleicht schon andere Variablen auf es verweisen, oder ob es gerade erst neu erzeugt wurde und damit noch unbenutzt ist? Wer ist für die Entsorgung des Objekts verantwortlich? All diese Betrachtungen kann man sich in Gegenwart der Garbage Collection ersparen.
Im objektorientierten Jargon spricht man übrigens häufig auch vom ""Lebenszyklus"" (""Life Cycle"") eines Objekts. Genaugenommen ist dies jedoch irreführend, denn das Wort ""Zyklus"" verspricht, dass das Leben nach seinem Ende wieder neu beginnt. Gerade dies ist aber, wie eben erläutert, nicht der Fall: Objekte werden nicht recycelt, sondern höchstens der Speicherplatz, den sie belegen.","<answer> Ein Objekt in SMALLTALK kann aus dem Speicher entfernt werden, wenn keine Variable mehr auf dieses Objekt verweist und es somit nicht mehr erreichbar ist. <answer> <question> Wie wird sichergestellt, dass ein Objekt in SMALLTALK aus dem Speicher entfernt werden kann? <question>"
"In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung, die sogenannte ""Garbage Collection"". Garbage Collection ist ein Mechanismus, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr zugreifbar sind. Da in SMALLTALK auf Objekte nach ihrer Erzeugung ausschließlich über Variablen (Namen) zugegriffen werden kann, kann ein solches Objekt genau dann entfernt werden, wenn keine Variable mehr auf es verweist. Es kann entfernt werden, muss aber nicht; aus Sicht der Programmiererin ist es ausreichend, dass das Objekt nicht mehr bekannt oder benannt ist — es kann somit nicht mehr aufgefunden und durch eine Zuweisung einer Variable zugewiesen werden. Bei der Implementierung von Garbage-Collection-Algorithmen besteht daher erhebliche Freiheit.
Wenn Peter und Michaela heiraten, dann schlägt sich dies unter anderem in der Zuweisung petersNachmane := michaelasNachname nieder. Wenn 'Müller' keine Aliase (wie beispielsweise ""paulasNachname"") hatte, kann es nach der Zuweisung aus dem Speicher entfernt werden — es wäre selbst bei Bedarf nicht mehr auffindbar.
Von der automatischen Speicherbereinigung ausgenommen sind bestimmte Objekte mit eindeutiger literaler Repräsentation (wie z. B. kleine Zahlen, Zeichen und Symbole). Im Falle von Zahlen und Zeichen liegt das jedoch weniger an der Natur dieser Objekte selbst als vielmehr an der Tatsache, dass diese in der Regel nicht als Objekte im Speicher angelegt werden (so dass Variablen darauf verweisen könnten), sondern dass sie selbst, als Werte (und anstelle von Zeigern), in Variablen gespeichert werden (siehe Abschnitt 1.5.1). Sie werden ""entfernt"", indem einer Variable ein neuer Wert zugewiesen wird. Symbole werden schon deswegen nicht aus dem Speicher entfernt, weil sie in einer Symboltabelle abgelegt sind (und somit immer mindestens einmal referenziert werden; siehe Fußnote 5).
Der Mut zur Verabschiedung von der expliziten Speicherfreigabe war eine der wichtigsten Entscheidungen beim Entwurf von SMALLTALK. Man hat einfach anerkannt, dass die genaue Buchführung darüber, auf welche Objekte noch zugegriffen wird, zu schwierig ist, um die Verantwortung dafür den Anwendungsprogrammierern zu überlassen. Wer das Problem nicht unmittelbar einsichtig findet, halte sich vor Augen, dass der Ort der Erzeugung eines Objektes und seine erste Zuweisung zu einer Variable im Programm möglicherweise weit entfernt sind von der Stelle, an der dieser Variable ein anderes Objekt zugewiesen wird, es möglicherweise viele solcher Stellen gibt, von denen mal die eine, mal die andere zuerst erreicht wird, und dass in der Zwischenzeit beliebig viele Aliase auf das Objekt angelegt worden sein könnten, die alle mit berücksichtigt werden müssen, um zu entscheiden, ob das Objekt noch in Verwendung ist.
Eine vorzeitige Entfernung aus dem Speicher hingegen führt dazu, dass Variablen ins Leere zeigen (eine häufige Quelle von Programmabstürzen) oder dass, bei einer Wiederverwendung des Speichers, die Variable plötzlich auf ein anderes Objekt verweist, das ihr aber nie explizit zugewiesen wurde — ein quasi zufälliges Programmverhalten, das mit hoher Wahrscheinlichkeit zu schweren Programmfehlern führen würde. Ein anderes Beispiel entsteht, wenn in einer Verzweigung eines Programms entweder ein neues oder ein bereits vorhandenes Objekt einer Variable zugewiesen wird. Woher weiß man bei der weiteren Benutzung dieser Variable, ob das Objekt schon vorher existierte und vielleicht schon andere Variablen auf es verweisen, oder ob es gerade erst neu erzeugt wurde und damit noch unbenutzt ist? Wer ist für die Entsorgung des Objekts verantwortlich? All diese Betrachtungen kann man sich in Gegenwart der Garbage Collection ersparen.
Im objektorientierten Jargon spricht man übrigens häufig auch vom ""Lebenszyklus"" (""Life Cycle"") eines Objekts. Genaugenommen ist dies jedoch irreführend, denn das Wort ""Zyklus"" verspricht, dass das Leben nach seinem Ende wieder neu beginnt. Gerade dies ist aber, wie eben erläutert, nicht der Fall: Objekte werden nicht recycelt, sondern höchstens der Speicherplatz, den sie belegen.","<answer> Objekte mit eindeutiger literaler Repräsentation, wie kleine Zahlen, Zeichen und Symbole, werden normalerweise nicht als separate Objekte im Speicher angelegt. Sie werden durch Werte in Variablen repräsentiert und können ""entfernt"" werden, indem einer Variable ein neuer Wert zugewiesen wird. <answer> <question> Warum sind Objekte mit eindeutiger literaler Repräsentation von der Garbage Collection ausgenommen? <question>"
"In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung, die sogenannte ""Garbage Collection"". Garbage Collection ist ein Mechanismus, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr zugreifbar sind. Da in SMALLTALK auf Objekte nach ihrer Erzeugung ausschließlich über Variablen (Namen) zugegriffen werden kann, kann ein solches Objekt genau dann entfernt werden, wenn keine Variable mehr auf es verweist. Es kann entfernt werden, muss aber nicht; aus Sicht der Programmiererin ist es ausreichend, dass das Objekt nicht mehr bekannt oder benannt ist — es kann somit nicht mehr aufgefunden und durch eine Zuweisung einer Variable zugewiesen werden. Bei der Implementierung von Garbage-Collection-Algorithmen besteht daher erhebliche Freiheit.
Wenn Peter und Michaela heiraten, dann schlägt sich dies unter anderem in der Zuweisung petersNachmane := michaelasNachname nieder. Wenn 'Müller' keine Aliase (wie beispielsweise ""paulasNachname"") hatte, kann es nach der Zuweisung aus dem Speicher entfernt werden — es wäre selbst bei Bedarf nicht mehr auffindbar.
Von der automatischen Speicherbereinigung ausgenommen sind bestimmte Objekte mit eindeutiger literaler Repräsentation (wie z. B. kleine Zahlen, Zeichen und Symbole). Im Falle von Zahlen und Zeichen liegt das jedoch weniger an der Natur dieser Objekte selbst als vielmehr an der Tatsache, dass diese in der Regel nicht als Objekte im Speicher angelegt werden (so dass Variablen darauf verweisen könnten), sondern dass sie selbst, als Werte (und anstelle von Zeigern), in Variablen gespeichert werden (siehe Abschnitt 1.5.1). Sie werden ""entfernt"", indem einer Variable ein neuer Wert zugewiesen wird. Symbole werden schon deswegen nicht aus dem Speicher entfernt, weil sie in einer Symboltabelle abgelegt sind (und somit immer mindestens einmal referenziert werden; siehe Fußnote 5).
Der Mut zur Verabschiedung von der expliziten Speicherfreigabe war eine der wichtigsten Entscheidungen beim Entwurf von SMALLTALK. Man hat einfach anerkannt, dass die genaue Buchführung darüber, auf welche Objekte noch zugegriffen wird, zu schwierig ist, um die Verantwortung dafür den Anwendungsprogrammierern zu überlassen. Wer das Problem nicht unmittelbar einsichtig findet, halte sich vor Augen, dass der Ort der Erzeugung eines Objektes und seine erste Zuweisung zu einer Variable im Programm möglicherweise weit entfernt sind von der Stelle, an der dieser Variable ein anderes Objekt zugewiesen wird, es möglicherweise viele solcher Stellen gibt, von denen mal die eine, mal die andere zuerst erreicht wird, und dass in der Zwischenzeit beliebig viele Aliase auf das Objekt angelegt worden sein könnten, die alle mit berücksichtigt werden müssen, um zu entscheiden, ob das Objekt noch in Verwendung ist.
Eine vorzeitige Entfernung aus dem Speicher hingegen führt dazu, dass Variablen ins Leere zeigen (eine häufige Quelle von Programmabstürzen) oder dass, bei einer Wiederverwendung des Speichers, die Variable plötzlich auf ein anderes Objekt verweist, das ihr aber nie explizit zugewiesen wurde — ein quasi zufälliges Programmverhalten, das mit hoher Wahrscheinlichkeit zu schweren Programmfehlern führen würde. Ein anderes Beispiel entsteht, wenn in einer Verzweigung eines Programms entweder ein neues oder ein bereits vorhandenes Objekt einer Variable zugewiesen wird. Woher weiß man bei der weiteren Benutzung dieser Variable, ob das Objekt schon vorher existierte und vielleicht schon andere Variablen auf es verweisen, oder ob es gerade erst neu erzeugt wurde und damit noch unbenutzt ist? Wer ist für die Entsorgung des Objekts verantwortlich? All diese Betrachtungen kann man sich in Gegenwart der Garbage Collection ersparen.
Im objektorientierten Jargon spricht man übrigens häufig auch vom ""Lebenszyklus"" (""Life Cycle"") eines Objekts. Genaugenommen ist dies jedoch irreführend, denn das Wort ""Zyklus"" verspricht, dass das Leben nach seinem Ende wieder neu beginnt. Gerade dies ist aber, wie eben erläutert, nicht der Fall: Objekte werden nicht recycelt, sondern höchstens der Speicherplatz, den sie belegen.","<answer> Die explizite Speicherfreigabe wurde in SMALLTALK aufgegeben, da es schwierig ist, genau zu verfolgen, welche Objekte noch referenziert werden, insbesondere in großen und komplexen Programmen. Die Verantwortung dafür den Anwendungsprogrammierern zu überlassen, würde zu vielen potenziellen Programmierfehlern führen. <answer> <question> Warum wurde in SMALLTALK die explizite Speicherfreigabe aufgegeben? <question>"
"In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung, die sogenannte ""Garbage Collection"". Garbage Collection ist ein Mechanismus, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr zugreifbar sind. Da in SMALLTALK auf Objekte nach ihrer Erzeugung ausschließlich über Variablen (Namen) zugegriffen werden kann, kann ein solches Objekt genau dann entfernt werden, wenn keine Variable mehr auf es verweist. Es kann entfernt werden, muss aber nicht; aus Sicht der Programmiererin ist es ausreichend, dass das Objekt nicht mehr bekannt oder benannt ist — es kann somit nicht mehr aufgefunden und durch eine Zuweisung einer Variable zugewiesen werden. Bei der Implementierung von Garbage-Collection-Algorithmen besteht daher erhebliche Freiheit.
Wenn Peter und Michaela heiraten, dann schlägt sich dies unter anderem in der Zuweisung petersNachmane := michaelasNachname nieder. Wenn 'Müller' keine Aliase (wie beispielsweise ""paulasNachname"") hatte, kann es nach der Zuweisung aus dem Speicher entfernt werden — es wäre selbst bei Bedarf nicht mehr auffindbar.
Von der automatischen Speicherbereinigung ausgenommen sind bestimmte Objekte mit eindeutiger literaler Repräsentation (wie z. B. kleine Zahlen, Zeichen und Symbole). Im Falle von Zahlen und Zeichen liegt das jedoch weniger an der Natur dieser Objekte selbst als vielmehr an der Tatsache, dass diese in der Regel nicht als Objekte im Speicher angelegt werden (so dass Variablen darauf verweisen könnten), sondern dass sie selbst, als Werte (und anstelle von Zeigern), in Variablen gespeichert werden (siehe Abschnitt 1.5.1). Sie werden ""entfernt"", indem einer Variable ein neuer Wert zugewiesen wird. Symbole werden schon deswegen nicht aus dem Speicher entfernt, weil sie in einer Symboltabelle abgelegt sind (und somit immer mindestens einmal referenziert werden; siehe Fußnote 5).
Der Mut zur Verabschiedung von der expliziten Speicherfreigabe war eine der wichtigsten Entscheidungen beim Entwurf von SMALLTALK. Man hat einfach anerkannt, dass die genaue Buchführung darüber, auf welche Objekte noch zugegriffen wird, zu schwierig ist, um die Verantwortung dafür den Anwendungsprogrammierern zu überlassen. Wer das Problem nicht unmittelbar einsichtig findet, halte sich vor Augen, dass der Ort der Erzeugung eines Objektes und seine erste Zuweisung zu einer Variable im Programm möglicherweise weit entfernt sind von der Stelle, an der dieser Variable ein anderes Objekt zugewiesen wird, es möglicherweise viele solcher Stellen gibt, von denen mal die eine, mal die andere zuerst erreicht wird, und dass in der Zwischenzeit beliebig viele Aliase auf das Objekt angelegt worden sein könnten, die alle mit berücksichtigt werden müssen, um zu entscheiden, ob das Objekt noch in Verwendung ist.
Eine vorzeitige Entfernung aus dem Speicher hingegen führt dazu, dass Variablen ins Leere zeigen (eine häufige Quelle von Programmabstürzen) oder dass, bei einer Wiederverwendung des Speichers, die Variable plötzlich auf ein anderes Objekt verweist, das ihr aber nie explizit zugewiesen wurde — ein quasi zufälliges Programmverhalten, das mit hoher Wahrscheinlichkeit zu schweren Programmfehlern führen würde. Ein anderes Beispiel entsteht, wenn in einer Verzweigung eines Programms entweder ein neues oder ein bereits vorhandenes Objekt einer Variable zugewiesen wird. Woher weiß man bei der weiteren Benutzung dieser Variable, ob das Objekt schon vorher existierte und vielleicht schon andere Variablen auf es verweisen, oder ob es gerade erst neu erzeugt wurde und damit noch unbenutzt ist? Wer ist für die Entsorgung des Objekts verantwortlich? All diese Betrachtungen kann man sich in Gegenwart der Garbage Collection ersparen.
Im objektorientierten Jargon spricht man übrigens häufig auch vom ""Lebenszyklus"" (""Life Cycle"") eines Objekts. Genaugenommen ist dies jedoch irreführend, denn das Wort ""Zyklus"" verspricht, dass das Leben nach seinem Ende wieder neu beginnt. Gerade dies ist aber, wie eben erläutert, nicht der Fall: Objekte werden nicht recycelt, sondern höchstens der Speicherplatz, den sie belegen.","<answer> Die Garbage Collection verhindert vorzeitige Entfernung von Objekten, die noch in Verwendung sind, und stellt sicher, dass Variablen auf gültige Objekte verweisen. Dies trägt zur Stabilität und Sicherheit von Programmen bei. <answer> <question> Welche Vorteile bietet die Garbage Collection in SMALLTALK? <question>"
"In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung, die sogenannte ""Garbage Collection"". Garbage Collection ist ein Mechanismus, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr zugreifbar sind. Da in SMALLTALK auf Objekte nach ihrer Erzeugung ausschließlich über Variablen (Namen) zugegriffen werden kann, kann ein solches Objekt genau dann entfernt werden, wenn keine Variable mehr auf es verweist. Es kann entfernt werden, muss aber nicht; aus Sicht der Programmiererin ist es ausreichend, dass das Objekt nicht mehr bekannt oder benannt ist — es kann somit nicht mehr aufgefunden und durch eine Zuweisung einer Variable zugewiesen werden. Bei der Implementierung von Garbage-Collection-Algorithmen besteht daher erhebliche Freiheit.
Wenn Peter und Michaela heiraten, dann schlägt sich dies unter anderem in der Zuweisung petersNachmane := michaelasNachname nieder. Wenn 'Müller' keine Aliase (wie beispielsweise ""paulasNachname"") hatte, kann es nach der Zuweisung aus dem Speicher entfernt werden — es wäre selbst bei Bedarf nicht mehr auffindbar.
Von der automatischen Speicherbereinigung ausgenommen sind bestimmte Objekte mit eindeutiger literaler Repräsentation (wie z. B. kleine Zahlen, Zeichen und Symbole). Im Falle von Zahlen und Zeichen liegt das jedoch weniger an der Natur dieser Objekte selbst als vielmehr an der Tatsache, dass diese in der Regel nicht als Objekte im Speicher angelegt werden (so dass Variablen darauf verweisen könnten), sondern dass sie selbst, als Werte (und anstelle von Zeigern), in Variablen gespeichert werden (siehe Abschnitt 1.5.1). Sie werden ""entfernt"", indem einer Variable ein neuer Wert zugewiesen wird. Symbole werden schon deswegen nicht aus dem Speicher entfernt, weil sie in einer Symboltabelle abgelegt sind (und somit immer mindestens einmal referenziert werden; siehe Fußnote 5).
Der Mut zur Verabschiedung von der expliziten Speicherfreigabe war eine der wichtigsten Entscheidungen beim Entwurf von SMALLTALK. Man hat einfach anerkannt, dass die genaue Buchführung darüber, auf welche Objekte noch zugegriffen wird, zu schwierig ist, um die Verantwortung dafür den Anwendungsprogrammierern zu überlassen. Wer das Problem nicht unmittelbar einsichtig findet, halte sich vor Augen, dass der Ort der Erzeugung eines Objektes und seine erste Zuweisung zu einer Variable im Programm möglicherweise weit entfernt sind von der Stelle, an der dieser Variable ein anderes Objekt zugewiesen wird, es möglicherweise viele solcher Stellen gibt, von denen mal die eine, mal die andere zuerst erreicht wird, und dass in der Zwischenzeit beliebig viele Aliase auf das Objekt angelegt worden sein könnten, die alle mit berücksichtigt werden müssen, um zu entscheiden, ob das Objekt noch in Verwendung ist.
Eine vorzeitige Entfernung aus dem Speicher hingegen führt dazu, dass Variablen ins Leere zeigen (eine häufige Quelle von Programmabstürzen) oder dass, bei einer Wiederverwendung des Speichers, die Variable plötzlich auf ein anderes Objekt verweist, das ihr aber nie explizit zugewiesen wurde — ein quasi zufälliges Programmverhalten, das mit hoher Wahrscheinlichkeit zu schweren Programmfehlern führen würde. Ein anderes Beispiel entsteht, wenn in einer Verzweigung eines Programms entweder ein neues oder ein bereits vorhandenes Objekt einer Variable zugewiesen wird. Woher weiß man bei der weiteren Benutzung dieser Variable, ob das Objekt schon vorher existierte und vielleicht schon andere Variablen auf es verweisen, oder ob es gerade erst neu erzeugt wurde und damit noch unbenutzt ist? Wer ist für die Entsorgung des Objekts verantwortlich? All diese Betrachtungen kann man sich in Gegenwart der Garbage Collection ersparen.
Im objektorientierten Jargon spricht man übrigens häufig auch vom ""Lebenszyklus"" (""Life Cycle"") eines Objekts. Genaugenommen ist dies jedoch irreführend, denn das Wort ""Zyklus"" verspricht, dass das Leben nach seinem Ende wieder neu beginnt. Gerade dies ist aber, wie eben erläutert, nicht der Fall: Objekte werden nicht recycelt, sondern höchstens der Speicherplatz, den sie belegen.","<answer> Der ""Lebenslauf"" eines Objekts in SMALLTALK beschreibt seine Erzeugung, Verwendung und Entfernung aus dem Speicher. Der Begriff ""Lebenszyklus"" würde implizieren, dass das Objekt nach seinem Ende wiederverwendet wird, was in SMALLTALK nicht der Fall ist. Objekte werden nicht recycelt, sondern nur der von ihnen belegte Speicherplatz wird möglicherweise wiederverwendet. <answer> <question> Was ist der Unterschied zwischen dem ""Lebenslauf"" und dem ""Lebenszyklus"" eines Objekts in der objektorientierten Programmierung? <question>"
"Eine Klassendefinition liefert die Intension einer Klasse. Sie besteht in SMALLTALK zunächst aus der Angabe eines nicht anderweitig verwendeten, durch ein Symbol repräsentierten Klassennamens sowie der Angabe der die Objekte der Klasse beschreibenden Instanzvariablen und Methodendefinitionen. Anders als in vielen anderen objektorientierten Programmiersprachen erfolgt in SMALLTALK die Klassendefinition nicht in einer Datei (was hätte eine Datei auch mit den Konzepten einer Programmiersprache zu tun?), sondern durch Eintragungen in eine dafür vorgesehene Datenstruktur (genauer: durch Erzeugung eines die Klasse beschreibenden Objekts). Es gibt also auch insbesondere keine Syntax für eine Klassendefinition, sondern nur ein Schema.
Alle Instanzen einer Klasse verfügen somit über den gleichen Satz von Instanzvariablen, aber nicht denselben, was so viel bedeutet wie, dass jede Instanz der Klasse (jedes Objekt, das zur Extension der Klasse gehört) diese Variablen individuell belegen kann. Im Gegensatz dazu verstehen alle Instanzen einer Klasse nicht nur dieselben Nachrichten, sie verwenden auch dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren. Instanzen einer Klasse können sich also nur insoweit in ihrem Verhalten unterscheiden, wie sich die Methodendefinitionen auf die Werte der Instanzvariablen beziehen, wie also das in den Methoden spezifizierte Verhalten vom Inhalt der Instanzvariablen abhängt. Insbesondere ist es nicht vorgesehen, dass verschiedene Instanzen einer Klasse über verschiedene Definitionen einer Methode (genauer: über verschiedene Definitionen von zu der Nachricht passenden Methoden) verfügen. Das unterscheidet die klassenbasierte von der prototypenbasierten Form der objektorientierten Programmierung.
Die beiden Einträge „indizierte Instanzvariablen“ und „atomar“ stehen übrigens dafür, ob eine Instanz der Klasse indizierte Instanzvariablen haben soll (klar) und falls ja, ob diese Variablen dann eine binäre Repräsentation (ja) oder Referenzen (nein) enthalten. Mit Hilfe von indizierten Instanzvariablen, die binäre Repräsentationen enthalten, werden z.B. Zahlen, Strings, aber auch Bitmaps wie Fensterinhalte, der Cursor oder Fonts intern dargestellt. Da man als Programmierer solche Klassen in der Regel nicht selbst anlegt, werde ich den Eintrag „atomar“ zukünftig unter den Tisch fallen lassen.
Eine Klasse (das Objekt, das die Klassen repräsentiert, nicht ihr Name) wird in SMALLTALK nach ihrer Erzeugung übrigens durch eine globale Pseudovariable repräsentiert, deren Name der Name der Klasse ist. Da die Variable global ist, muss sie (und damit auch der Name der Klasse) immer mit einem Großbuchstaben beginnen (s. Abschnitt 1.5.2 in Kurseinheit 1). Die Variable wird automatisch mit der Klassendefinition eingeführt (vereinbart); ihr „Wert“, die Klasse, auf die sie verweist, ist das Objekt, das ihr bei der Anlage der Klasse zugewiesen wird. Da Klassennamen globale Variablen sind, da sie insbesondere absolut global sind und nicht nur in Bezug auf irgendeine Programmeinheit (wie etwa eine Methodendefinition), sind sie von überall her zugreifbar. Außerdem wird jede neue Klasse in eine Art Systemwörterbuch namens „Smalltalk“ (repräsentiert von der globalen Variable Smalltalk; s. Selbsttestaufgabe 1.2) eingetragen, und ihr Name (als Symbol) in die Symboltabelle SymbolTable. Mittels einer solchen Klassendefinition ist man nun in der Lage, das SMALLTALK-System um neue, eigene Klassen zu erweitern.","<answer> Eine Klassendefinition in SMALLTALK liefert die Intension oder Beschreibung einer Klasse. Sie besteht aus dem Namen der Klasse, der Liste der benannten Instanzvariablen, Angaben zu indizierten Instanzvariablen, Informationen zur Atomarität, und einer Liste von Instanzmethoden. <answer> <question> Was ist eine Klassendefinition in SMALLTALK? <question>"
"Eine Klassendefinition liefert die Intension einer Klasse. Sie besteht in SMALLTALK zunächst aus der Angabe eines nicht anderweitig verwendeten, durch ein Symbol repräsentierten Klassennamens sowie der Angabe der die Objekte der Klasse beschreibenden Instanzvariablen und Methodendefinitionen. Anders als in vielen anderen objektorientierten Programmiersprachen erfolgt in SMALLTALK die Klassendefinition nicht in einer Datei (was hätte eine Datei auch mit den Konzepten einer Programmiersprache zu tun?), sondern durch Eintragungen in eine dafür vorgesehene Datenstruktur (genauer: durch Erzeugung eines die Klasse beschreibenden Objekts). Es gibt also auch insbesondere keine Syntax für eine Klassendefinition, sondern nur ein Schema.
Alle Instanzen einer Klasse verfügen somit über den gleichen Satz von Instanzvariablen, aber nicht denselben, was so viel bedeutet wie, dass jede Instanz der Klasse (jedes Objekt, das zur Extension der Klasse gehört) diese Variablen individuell belegen kann. Im Gegensatz dazu verstehen alle Instanzen einer Klasse nicht nur dieselben Nachrichten, sie verwenden auch dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren. Instanzen einer Klasse können sich also nur insoweit in ihrem Verhalten unterscheiden, wie sich die Methodendefinitionen auf die Werte der Instanzvariablen beziehen, wie also das in den Methoden spezifizierte Verhalten vom Inhalt der Instanzvariablen abhängt. Insbesondere ist es nicht vorgesehen, dass verschiedene Instanzen einer Klasse über verschiedene Definitionen einer Methode (genauer: über verschiedene Definitionen von zu der Nachricht passenden Methoden) verfügen. Das unterscheidet die klassenbasierte von der prototypenbasierten Form der objektorientierten Programmierung.
Die beiden Einträge „indizierte Instanzvariablen“ und „atomar“ stehen übrigens dafür, ob eine Instanz der Klasse indizierte Instanzvariablen haben soll (klar) und falls ja, ob diese Variablen dann eine binäre Repräsentation (ja) oder Referenzen (nein) enthalten. Mit Hilfe von indizierten Instanzvariablen, die binäre Repräsentationen enthalten, werden z.B. Zahlen, Strings, aber auch Bitmaps wie Fensterinhalte, der Cursor oder Fonts intern dargestellt. Da man als Programmierer solche Klassen in der Regel nicht selbst anlegt, werde ich den Eintrag „atomar“ zukünftig unter den Tisch fallen lassen.
Eine Klasse (das Objekt, das die Klassen repräsentiert, nicht ihr Name) wird in SMALLTALK nach ihrer Erzeugung übrigens durch eine globale Pseudovariable repräsentiert, deren Name der Name der Klasse ist. Da die Variable global ist, muss sie (und damit auch der Name der Klasse) immer mit einem Großbuchstaben beginnen (s. Abschnitt 1.5.2 in Kurseinheit 1). Die Variable wird automatisch mit der Klassendefinition eingeführt (vereinbart); ihr „Wert“, die Klasse, auf die sie verweist, ist das Objekt, das ihr bei der Anlage der Klasse zugewiesen wird. Da Klassennamen globale Variablen sind, da sie insbesondere absolut global sind und nicht nur in Bezug auf irgendeine Programmeinheit (wie etwa eine Methodendefinition), sind sie von überall her zugreifbar. Außerdem wird jede neue Klasse in eine Art Systemwörterbuch namens „Smalltalk“ (repräsentiert von der globalen Variable Smalltalk; s. Selbsttestaufgabe 1.2) eingetragen, und ihr Name (als Symbol) in die Symboltabelle SymbolTable. Mittels einer solchen Klassendefinition ist man nun in der Lage, das SMALLTALK-System um neue, eigene Klassen zu erweitern.","<answer> In SMALLTALK erfolgt die Klassendefinition nicht in einer separaten Datei wie in vielen anderen objektorientierten Programmiersprachen. Stattdessen werden Klassendefinitionen durch Eintragungen in eine Datenstruktur oder das Erzeugen eines Objekts repräsentiert. Es gibt keine spezielle Syntax für Klassendefinitionen, nur ein Schema. <answer> <question> Wie werden Klassendefinitionen in SMALLTALK umgesetzt, im Vergleich zu anderen objektorientierten Programmiersprachen? <question>"
"Eine Klassendefinition liefert die Intension einer Klasse. Sie besteht in SMALLTALK zunächst aus der Angabe eines nicht anderweitig verwendeten, durch ein Symbol repräsentierten Klassennamens sowie der Angabe der die Objekte der Klasse beschreibenden Instanzvariablen und Methodendefinitionen. Anders als in vielen anderen objektorientierten Programmiersprachen erfolgt in SMALLTALK die Klassendefinition nicht in einer Datei (was hätte eine Datei auch mit den Konzepten einer Programmiersprache zu tun?), sondern durch Eintragungen in eine dafür vorgesehene Datenstruktur (genauer: durch Erzeugung eines die Klasse beschreibenden Objekts). Es gibt also auch insbesondere keine Syntax für eine Klassendefinition, sondern nur ein Schema.
Alle Instanzen einer Klasse verfügen somit über den gleichen Satz von Instanzvariablen, aber nicht denselben, was so viel bedeutet wie, dass jede Instanz der Klasse (jedes Objekt, das zur Extension der Klasse gehört) diese Variablen individuell belegen kann. Im Gegensatz dazu verstehen alle Instanzen einer Klasse nicht nur dieselben Nachrichten, sie verwenden auch dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren. Instanzen einer Klasse können sich also nur insoweit in ihrem Verhalten unterscheiden, wie sich die Methodendefinitionen auf die Werte der Instanzvariablen beziehen, wie also das in den Methoden spezifizierte Verhalten vom Inhalt der Instanzvariablen abhängt. Insbesondere ist es nicht vorgesehen, dass verschiedene Instanzen einer Klasse über verschiedene Definitionen einer Methode (genauer: über verschiedene Definitionen von zu der Nachricht passenden Methoden) verfügen. Das unterscheidet die klassenbasierte von der prototypenbasierten Form der objektorientierten Programmierung.
Die beiden Einträge „indizierte Instanzvariablen“ und „atomar“ stehen übrigens dafür, ob eine Instanz der Klasse indizierte Instanzvariablen haben soll (klar) und falls ja, ob diese Variablen dann eine binäre Repräsentation (ja) oder Referenzen (nein) enthalten. Mit Hilfe von indizierten Instanzvariablen, die binäre Repräsentationen enthalten, werden z.B. Zahlen, Strings, aber auch Bitmaps wie Fensterinhalte, der Cursor oder Fonts intern dargestellt. Da man als Programmierer solche Klassen in der Regel nicht selbst anlegt, werde ich den Eintrag „atomar“ zukünftig unter den Tisch fallen lassen.
Eine Klasse (das Objekt, das die Klassen repräsentiert, nicht ihr Name) wird in SMALLTALK nach ihrer Erzeugung übrigens durch eine globale Pseudovariable repräsentiert, deren Name der Name der Klasse ist. Da die Variable global ist, muss sie (und damit auch der Name der Klasse) immer mit einem Großbuchstaben beginnen (s. Abschnitt 1.5.2 in Kurseinheit 1). Die Variable wird automatisch mit der Klassendefinition eingeführt (vereinbart); ihr „Wert“, die Klasse, auf die sie verweist, ist das Objekt, das ihr bei der Anlage der Klasse zugewiesen wird. Da Klassennamen globale Variablen sind, da sie insbesondere absolut global sind und nicht nur in Bezug auf irgendeine Programmeinheit (wie etwa eine Methodendefinition), sind sie von überall her zugreifbar. Außerdem wird jede neue Klasse in eine Art Systemwörterbuch namens „Smalltalk“ (repräsentiert von der globalen Variable Smalltalk; s. Selbsttestaufgabe 1.2) eingetragen, und ihr Name (als Symbol) in die Symboltabelle SymbolTable. Mittels einer solchen Klassendefinition ist man nun in der Lage, das SMALLTALK-System um neue, eigene Klassen zu erweitern.","<answer> Benannte Instanzvariablen sind Instanzvariablen, die einem Namen zugewiesen sind und individuell von Instanzen der Klasse belegt werden können. Alle Instanzen einer Klasse verfügen über den gleichen Satz von benannten Instanzvariablen. Indizierte Instanzvariablen sind eine spezielle Art von Instanzvariablen, die in SMALLTALK verwendet werden, um z.B. Zahlen, Strings und Bitmaps intern darzustellen. Diese Variablen können binäre Repräsentationen oder Referenzen enthalten. <answer> <question> Was sind benannte Instanzvariablen und indizierte Instanzvariablen in einer Klassendefinition? <question>"
"Eine Klassendefinition liefert die Intension einer Klasse. Sie besteht in SMALLTALK zunächst aus der Angabe eines nicht anderweitig verwendeten, durch ein Symbol repräsentierten Klassennamens sowie der Angabe der die Objekte der Klasse beschreibenden Instanzvariablen und Methodendefinitionen. Anders als in vielen anderen objektorientierten Programmiersprachen erfolgt in SMALLTALK die Klassendefinition nicht in einer Datei (was hätte eine Datei auch mit den Konzepten einer Programmiersprache zu tun?), sondern durch Eintragungen in eine dafür vorgesehene Datenstruktur (genauer: durch Erzeugung eines die Klasse beschreibenden Objekts). Es gibt also auch insbesondere keine Syntax für eine Klassendefinition, sondern nur ein Schema.
Alle Instanzen einer Klasse verfügen somit über den gleichen Satz von Instanzvariablen, aber nicht denselben, was so viel bedeutet wie, dass jede Instanz der Klasse (jedes Objekt, das zur Extension der Klasse gehört) diese Variablen individuell belegen kann. Im Gegensatz dazu verstehen alle Instanzen einer Klasse nicht nur dieselben Nachrichten, sie verwenden auch dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren. Instanzen einer Klasse können sich also nur insoweit in ihrem Verhalten unterscheiden, wie sich die Methodendefinitionen auf die Werte der Instanzvariablen beziehen, wie also das in den Methoden spezifizierte Verhalten vom Inhalt der Instanzvariablen abhängt. Insbesondere ist es nicht vorgesehen, dass verschiedene Instanzen einer Klasse über verschiedene Definitionen einer Methode (genauer: über verschiedene Definitionen von zu der Nachricht passenden Methoden) verfügen. Das unterscheidet die klassenbasierte von der prototypenbasierten Form der objektorientierten Programmierung.
Die beiden Einträge „indizierte Instanzvariablen“ und „atomar“ stehen übrigens dafür, ob eine Instanz der Klasse indizierte Instanzvariablen haben soll (klar) und falls ja, ob diese Variablen dann eine binäre Repräsentation (ja) oder Referenzen (nein) enthalten. Mit Hilfe von indizierten Instanzvariablen, die binäre Repräsentationen enthalten, werden z.B. Zahlen, Strings, aber auch Bitmaps wie Fensterinhalte, der Cursor oder Fonts intern dargestellt. Da man als Programmierer solche Klassen in der Regel nicht selbst anlegt, werde ich den Eintrag „atomar“ zukünftig unter den Tisch fallen lassen.
Eine Klasse (das Objekt, das die Klassen repräsentiert, nicht ihr Name) wird in SMALLTALK nach ihrer Erzeugung übrigens durch eine globale Pseudovariable repräsentiert, deren Name der Name der Klasse ist. Da die Variable global ist, muss sie (und damit auch der Name der Klasse) immer mit einem Großbuchstaben beginnen (s. Abschnitt 1.5.2 in Kurseinheit 1). Die Variable wird automatisch mit der Klassendefinition eingeführt (vereinbart); ihr „Wert“, die Klasse, auf die sie verweist, ist das Objekt, das ihr bei der Anlage der Klasse zugewiesen wird. Da Klassennamen globale Variablen sind, da sie insbesondere absolut global sind und nicht nur in Bezug auf irgendeine Programmeinheit (wie etwa eine Methodendefinition), sind sie von überall her zugreifbar. Außerdem wird jede neue Klasse in eine Art Systemwörterbuch namens „Smalltalk“ (repräsentiert von der globalen Variable Smalltalk; s. Selbsttestaufgabe 1.2) eingetragen, und ihr Name (als Symbol) in die Symboltabelle SymbolTable. Mittels einer solchen Klassendefinition ist man nun in der Lage, das SMALLTALK-System um neue, eigene Klassen zu erweitern.","<answer> In SMALLTALK wird jede Klasse nach ihrer Erzeugung durch eine globale Pseudovariable repräsentiert, deren Name dem Namen der Klasse entspricht. Diese globale Pseudovariable ist notwendig, um auf die Klasse und ihre Methoden zugreifen zu können. Klassennamen sind global und von überall aus im Code zugreifbar. <answer> <question> Welche Rolle spielt die globale Pseudovariable in SMALLTALK in Bezug auf Klassen? <question>"
"Eine Klassendefinition liefert die Intension einer Klasse. Sie besteht in SMALLTALK zunächst aus der Angabe eines nicht anderweitig verwendeten, durch ein Symbol repräsentierten Klassennamens sowie der Angabe der die Objekte der Klasse beschreibenden Instanzvariablen und Methodendefinitionen. Anders als in vielen anderen objektorientierten Programmiersprachen erfolgt in SMALLTALK die Klassendefinition nicht in einer Datei (was hätte eine Datei auch mit den Konzepten einer Programmiersprache zu tun?), sondern durch Eintragungen in eine dafür vorgesehene Datenstruktur (genauer: durch Erzeugung eines die Klasse beschreibenden Objekts). Es gibt also auch insbesondere keine Syntax für eine Klassendefinition, sondern nur ein Schema.
Alle Instanzen einer Klasse verfügen somit über den gleichen Satz von Instanzvariablen, aber nicht denselben, was so viel bedeutet wie, dass jede Instanz der Klasse (jedes Objekt, das zur Extension der Klasse gehört) diese Variablen individuell belegen kann. Im Gegensatz dazu verstehen alle Instanzen einer Klasse nicht nur dieselben Nachrichten, sie verwenden auch dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren. Instanzen einer Klasse können sich also nur insoweit in ihrem Verhalten unterscheiden, wie sich die Methodendefinitionen auf die Werte der Instanzvariablen beziehen, wie also das in den Methoden spezifizierte Verhalten vom Inhalt der Instanzvariablen abhängt. Insbesondere ist es nicht vorgesehen, dass verschiedene Instanzen einer Klasse über verschiedene Definitionen einer Methode (genauer: über verschiedene Definitionen von zu der Nachricht passenden Methoden) verfügen. Das unterscheidet die klassenbasierte von der prototypenbasierten Form der objektorientierten Programmierung.
Die beiden Einträge „indizierte Instanzvariablen“ und „atomar“ stehen übrigens dafür, ob eine Instanz der Klasse indizierte Instanzvariablen haben soll (klar) und falls ja, ob diese Variablen dann eine binäre Repräsentation (ja) oder Referenzen (nein) enthalten. Mit Hilfe von indizierten Instanzvariablen, die binäre Repräsentationen enthalten, werden z.B. Zahlen, Strings, aber auch Bitmaps wie Fensterinhalte, der Cursor oder Fonts intern dargestellt. Da man als Programmierer solche Klassen in der Regel nicht selbst anlegt, werde ich den Eintrag „atomar“ zukünftig unter den Tisch fallen lassen.
Eine Klasse (das Objekt, das die Klassen repräsentiert, nicht ihr Name) wird in SMALLTALK nach ihrer Erzeugung übrigens durch eine globale Pseudovariable repräsentiert, deren Name der Name der Klasse ist. Da die Variable global ist, muss sie (und damit auch der Name der Klasse) immer mit einem Großbuchstaben beginnen (s. Abschnitt 1.5.2 in Kurseinheit 1). Die Variable wird automatisch mit der Klassendefinition eingeführt (vereinbart); ihr „Wert“, die Klasse, auf die sie verweist, ist das Objekt, das ihr bei der Anlage der Klasse zugewiesen wird. Da Klassennamen globale Variablen sind, da sie insbesondere absolut global sind und nicht nur in Bezug auf irgendeine Programmeinheit (wie etwa eine Methodendefinition), sind sie von überall her zugreifbar. Außerdem wird jede neue Klasse in eine Art Systemwörterbuch namens „Smalltalk“ (repräsentiert von der globalen Variable Smalltalk; s. Selbsttestaufgabe 1.2) eingetragen, und ihr Name (als Symbol) in die Symboltabelle SymbolTable. Mittels einer solchen Klassendefinition ist man nun in der Lage, das SMALLTALK-System um neue, eigene Klassen zu erweitern.","<answer> Im Fall des Stack-Objekts ist es notwendig, indirekt auf den Inhalt der indizierten Instanzvariablen zuzugreifen, um die Repräsentation des Stack-Inhalts zu verbergen. Durch diese Indirektion können andere Objekte nicht direkt auf die Elemente des Stacks zugreifen, sondern müssen die von der Klasse definierten Methoden verwenden, um Elemente hinzuzufügen, zu entfernen oder abzurufen. Dies ermöglicht eine bessere Kontrolle über den Zustand des Stack-Objekts und verhindert unerlaubte Zugriffe von außen. <answer> <question> Warum könnte es notwendig sein, indirekt auf den Inhalt von indizierten Instanzvariablen zuzugreifen, wie im Fall des Stack-Objekts in der Klassendefinition? <question>"
"Die objektorientierte Weltsicht, die auch in diesem Kurs propagiert wird (nämlich die von den Objekten, die einander Nachrichten schicken und die auf den Empfang von Nachrichten reagieren, indem sie ihren Zustand ändern und weitere Nachrichten verschicken), legt nahe, dass Objekte aktiv sind, will sagen, dass sie über einen eigenen Rechenprozess verfügen. Doch schon in Abschnitt 4.3.2 wurde klar, dass es damit in der Realität nicht weit her ist: Es werden in der Praxis keine Nachrichten verschickt, sondern lediglich Methoden aufgerufen. Abgesehen vom dynamischen Binden dieser Methoden unterscheidet sich damit das Ausführungsmodell der objektorientierten Programmierung nicht von dem der prozeduralen Programmierung (à la PASCAL); insbesondere sind alle Objekte passiv (was soviel bedeutet, wie dass sie nur aktiv sind, solange sie gerade eine Methode ausführen).
Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.
Gleichwohl ist auch in der objektorientierten Programmierung Parallelverarbeitung möglich. Nur kommt sie (zumindest in SMALLTALK, aber auch z. B. in JAVA) nicht in Form von aktiven Objekten daher, sondern in Form von parallelen Prozessen. Jeder dieser Prozesse führt zu einer Zeit eine Methode aus; er besucht zwar mit dem Methodenaufruf die Empfängerobjekte, diese bleiben jedoch selbst passiv (haben also kein Eigenleben).
Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neuen Prozess zu starten: Man schickt einfach einem Block die Nachricht ""fork"". ""fork"" entspricht im Wesentlichen ""value"", nur dass der Block dadurch in einem eigenen, unabhängigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von ""fork"" auch nicht darauf, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zurückliefert; tatsächlich liefert sie auch nicht (wie ""value"") das Ergebnis des Blocks zurück, sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann geht dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert.
Soll ein (paralleler) Prozess nicht sofort starten, so braucht man ein Objekt, das diesen Prozess repräsentiert und dem man dann zu einem späteren Zeitpunkt die Nachricht ""resume"" schicken kann, die den Prozess startet. Ein solches Objekt erhält man, indem man dem Block ""newProcess"" schickt. Tatsächlich ist ""fork"" wie folgt implementiert:
Um einen parametrisierten Block (also einen Block mit Parametern) als Prozess zu starten, verwendet man statt ""newProcess"" ""newProcessWith:"" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält.
Mit den Nachrichten ""suspend"" und ""terminate"" kann man den Prozess dann temporär anhalten bzw. beenden. Angehaltene Prozesse können später mit ""resume"" wieder gestartet werden, beendete nicht.
Die Synchronisation von parallelen Prozessen erfolgt in SMALLTALK zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen dazu über zwei Methoden, ""wait"" und ""signal"", und eine Instanzvariable, die für jedes Empfangen von ""signal"" um 1 erhöht und für jedes Empfangen von ""wait"" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt (mittels ""suspend""). Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht ""signal"" und es gibt noch Prozesse, die schlafen (erkennbar an einem Zähler kleiner als 1), dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden (mittels ""resume"") und weitermachen.
Die Synchronisation mittels Semaphoren ist recht elementar und von aktiven Objekten noch weit entfernt. Deutlich näher rückt man mit der Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gezählt werden) Objekte aufnehmen und die eine Synchronisation über ""next"" und ""nextPut:"" erlauben. Das Protokoll sieht wie folgt aus:
Wenn man nun eine solche SharedQueue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann hat man tatsächlich „aktive Objekte, die einander Nachrichten schicken“.","<answer> Aktive Objekte sind Objekte, die über einen eigenen Rechenprozess verfügen und Nachrichten asynchron empfangen und verarbeiten können. Passive Objekte hingegen sind Objekte, die nur aktiv sind, solange sie gerade eine Methode ausführen. In der Praxis werden jedoch passive Objekte verwendet, da aktive Objekte sehr aufwendig wären. <answer> <question> Was ist der grundlegende Unterschied zwischen aktiven und passiven Objekten in der objektorientierten Programmierung? <question>"
"Die objektorientierte Weltsicht, die auch in diesem Kurs propagiert wird (nämlich die von den Objekten, die einander Nachrichten schicken und die auf den Empfang von Nachrichten reagieren, indem sie ihren Zustand ändern und weitere Nachrichten verschicken), legt nahe, dass Objekte aktiv sind, will sagen, dass sie über einen eigenen Rechenprozess verfügen. Doch schon in Abschnitt 4.3.2 wurde klar, dass es damit in der Realität nicht weit her ist: Es werden in der Praxis keine Nachrichten verschickt, sondern lediglich Methoden aufgerufen. Abgesehen vom dynamischen Binden dieser Methoden unterscheidet sich damit das Ausführungsmodell der objektorientierten Programmierung nicht von dem der prozeduralen Programmierung (à la PASCAL); insbesondere sind alle Objekte passiv (was soviel bedeutet, wie dass sie nur aktiv sind, solange sie gerade eine Methode ausführen).
Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.
Gleichwohl ist auch in der objektorientierten Programmierung Parallelverarbeitung möglich. Nur kommt sie (zumindest in SMALLTALK, aber auch z. B. in JAVA) nicht in Form von aktiven Objekten daher, sondern in Form von parallelen Prozessen. Jeder dieser Prozesse führt zu einer Zeit eine Methode aus; er besucht zwar mit dem Methodenaufruf die Empfängerobjekte, diese bleiben jedoch selbst passiv (haben also kein Eigenleben).
Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neuen Prozess zu starten: Man schickt einfach einem Block die Nachricht ""fork"". ""fork"" entspricht im Wesentlichen ""value"", nur dass der Block dadurch in einem eigenen, unabhängigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von ""fork"" auch nicht darauf, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zurückliefert; tatsächlich liefert sie auch nicht (wie ""value"") das Ergebnis des Blocks zurück, sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann geht dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert.
Soll ein (paralleler) Prozess nicht sofort starten, so braucht man ein Objekt, das diesen Prozess repräsentiert und dem man dann zu einem späteren Zeitpunkt die Nachricht ""resume"" schicken kann, die den Prozess startet. Ein solches Objekt erhält man, indem man dem Block ""newProcess"" schickt. Tatsächlich ist ""fork"" wie folgt implementiert:
Um einen parametrisierten Block (also einen Block mit Parametern) als Prozess zu starten, verwendet man statt ""newProcess"" ""newProcessWith:"" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält.
Mit den Nachrichten ""suspend"" und ""terminate"" kann man den Prozess dann temporär anhalten bzw. beenden. Angehaltene Prozesse können später mit ""resume"" wieder gestartet werden, beendete nicht.
Die Synchronisation von parallelen Prozessen erfolgt in SMALLTALK zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen dazu über zwei Methoden, ""wait"" und ""signal"", und eine Instanzvariable, die für jedes Empfangen von ""signal"" um 1 erhöht und für jedes Empfangen von ""wait"" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt (mittels ""suspend""). Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht ""signal"" und es gibt noch Prozesse, die schlafen (erkennbar an einem Zähler kleiner als 1), dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden (mittels ""resume"") und weitermachen.
Die Synchronisation mittels Semaphoren ist recht elementar und von aktiven Objekten noch weit entfernt. Deutlich näher rückt man mit der Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gezählt werden) Objekte aufnehmen und die eine Synchronisation über ""next"" und ""nextPut:"" erlauben. Das Protokoll sieht wie folgt aus:
Wenn man nun eine solche SharedQueue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann hat man tatsächlich „aktive Objekte, die einander Nachrichten schicken“.","<answer> In SMALLTALK wird Parallelverarbeitung nicht in Form von aktiven Objekten, sondern in Form von parallelen Prozessen implementiert. Jeder dieser Prozesse führt zu einem Zeitpunkt eine Methode aus, wobei die Empfängerobjekte selbst passiv bleiben. Dies liegt daran, dass aktive Objekte, die asynchron Nachrichten verarbeiten, in der Praxis sehr aufwendig wären. <answer> <question> Wie wird Parallelverarbeitung in SMALLTALK implementiert, und warum werden keine aktiven Objekte verwendet? <question>"
"Die objektorientierte Weltsicht, die auch in diesem Kurs propagiert wird (nämlich die von den Objekten, die einander Nachrichten schicken und die auf den Empfang von Nachrichten reagieren, indem sie ihren Zustand ändern und weitere Nachrichten verschicken), legt nahe, dass Objekte aktiv sind, will sagen, dass sie über einen eigenen Rechenprozess verfügen. Doch schon in Abschnitt 4.3.2 wurde klar, dass es damit in der Realität nicht weit her ist: Es werden in der Praxis keine Nachrichten verschickt, sondern lediglich Methoden aufgerufen. Abgesehen vom dynamischen Binden dieser Methoden unterscheidet sich damit das Ausführungsmodell der objektorientierten Programmierung nicht von dem der prozeduralen Programmierung (à la PASCAL); insbesondere sind alle Objekte passiv (was soviel bedeutet, wie dass sie nur aktiv sind, solange sie gerade eine Methode ausführen).
Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.
Gleichwohl ist auch in der objektorientierten Programmierung Parallelverarbeitung möglich. Nur kommt sie (zumindest in SMALLTALK, aber auch z. B. in JAVA) nicht in Form von aktiven Objekten daher, sondern in Form von parallelen Prozessen. Jeder dieser Prozesse führt zu einer Zeit eine Methode aus; er besucht zwar mit dem Methodenaufruf die Empfängerobjekte, diese bleiben jedoch selbst passiv (haben also kein Eigenleben).
Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neuen Prozess zu starten: Man schickt einfach einem Block die Nachricht ""fork"". ""fork"" entspricht im Wesentlichen ""value"", nur dass der Block dadurch in einem eigenen, unabhängigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von ""fork"" auch nicht darauf, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zurückliefert; tatsächlich liefert sie auch nicht (wie ""value"") das Ergebnis des Blocks zurück, sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann geht dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert.
Soll ein (paralleler) Prozess nicht sofort starten, so braucht man ein Objekt, das diesen Prozess repräsentiert und dem man dann zu einem späteren Zeitpunkt die Nachricht ""resume"" schicken kann, die den Prozess startet. Ein solches Objekt erhält man, indem man dem Block ""newProcess"" schickt. Tatsächlich ist ""fork"" wie folgt implementiert:
Um einen parametrisierten Block (also einen Block mit Parametern) als Prozess zu starten, verwendet man statt ""newProcess"" ""newProcessWith:"" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält.
Mit den Nachrichten ""suspend"" und ""terminate"" kann man den Prozess dann temporär anhalten bzw. beenden. Angehaltene Prozesse können später mit ""resume"" wieder gestartet werden, beendete nicht.
Die Synchronisation von parallelen Prozessen erfolgt in SMALLTALK zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen dazu über zwei Methoden, ""wait"" und ""signal"", und eine Instanzvariable, die für jedes Empfangen von ""signal"" um 1 erhöht und für jedes Empfangen von ""wait"" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt (mittels ""suspend""). Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht ""signal"" und es gibt noch Prozesse, die schlafen (erkennbar an einem Zähler kleiner als 1), dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden (mittels ""resume"") und weitermachen.
Die Synchronisation mittels Semaphoren ist recht elementar und von aktiven Objekten noch weit entfernt. Deutlich näher rückt man mit der Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gezählt werden) Objekte aufnehmen und die eine Synchronisation über ""next"" und ""nextPut:"" erlauben. Das Protokoll sieht wie folgt aus:
Wenn man nun eine solche SharedQueue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann hat man tatsächlich „aktive Objekte, die einander Nachrichten schicken“.","<answer> In SMALLTALK kann man einen neuen Prozess starten, indem man einem Block die Nachricht ""fork"" sendet. Dies führt dazu, dass der Block in einem eigenen, unabhängigen Prozess ausgeführt wird. <answer> <question> Wie startet man in SMALLTALK einen neuen Prozess? <question>"
"Die objektorientierte Weltsicht, die auch in diesem Kurs propagiert wird (nämlich die von den Objekten, die einander Nachrichten schicken und die auf den Empfang von Nachrichten reagieren, indem sie ihren Zustand ändern und weitere Nachrichten verschicken), legt nahe, dass Objekte aktiv sind, will sagen, dass sie über einen eigenen Rechenprozess verfügen. Doch schon in Abschnitt 4.3.2 wurde klar, dass es damit in der Realität nicht weit her ist: Es werden in der Praxis keine Nachrichten verschickt, sondern lediglich Methoden aufgerufen. Abgesehen vom dynamischen Binden dieser Methoden unterscheidet sich damit das Ausführungsmodell der objektorientierten Programmierung nicht von dem der prozeduralen Programmierung (à la PASCAL); insbesondere sind alle Objekte passiv (was soviel bedeutet, wie dass sie nur aktiv sind, solange sie gerade eine Methode ausführen).
Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.
Gleichwohl ist auch in der objektorientierten Programmierung Parallelverarbeitung möglich. Nur kommt sie (zumindest in SMALLTALK, aber auch z. B. in JAVA) nicht in Form von aktiven Objekten daher, sondern in Form von parallelen Prozessen. Jeder dieser Prozesse führt zu einer Zeit eine Methode aus; er besucht zwar mit dem Methodenaufruf die Empfängerobjekte, diese bleiben jedoch selbst passiv (haben also kein Eigenleben).
Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neuen Prozess zu starten: Man schickt einfach einem Block die Nachricht ""fork"". ""fork"" entspricht im Wesentlichen ""value"", nur dass der Block dadurch in einem eigenen, unabhängigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von ""fork"" auch nicht darauf, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zurückliefert; tatsächlich liefert sie auch nicht (wie ""value"") das Ergebnis des Blocks zurück, sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann geht dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert.
Soll ein (paralleler) Prozess nicht sofort starten, so braucht man ein Objekt, das diesen Prozess repräsentiert und dem man dann zu einem späteren Zeitpunkt die Nachricht ""resume"" schicken kann, die den Prozess startet. Ein solches Objekt erhält man, indem man dem Block ""newProcess"" schickt. Tatsächlich ist ""fork"" wie folgt implementiert:
Um einen parametrisierten Block (also einen Block mit Parametern) als Prozess zu starten, verwendet man statt ""newProcess"" ""newProcessWith:"" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält.
Mit den Nachrichten ""suspend"" und ""terminate"" kann man den Prozess dann temporär anhalten bzw. beenden. Angehaltene Prozesse können später mit ""resume"" wieder gestartet werden, beendete nicht.
Die Synchronisation von parallelen Prozessen erfolgt in SMALLTALK zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen dazu über zwei Methoden, ""wait"" und ""signal"", und eine Instanzvariable, die für jedes Empfangen von ""signal"" um 1 erhöht und für jedes Empfangen von ""wait"" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt (mittels ""suspend""). Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht ""signal"" und es gibt noch Prozesse, die schlafen (erkennbar an einem Zähler kleiner als 1), dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden (mittels ""resume"") und weitermachen.
Die Synchronisation mittels Semaphoren ist recht elementar und von aktiven Objekten noch weit entfernt. Deutlich näher rückt man mit der Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gezählt werden) Objekte aufnehmen und die eine Synchronisation über ""next"" und ""nextPut:"" erlauben. Das Protokoll sieht wie folgt aus:
Wenn man nun eine solche SharedQueue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann hat man tatsächlich „aktive Objekte, die einander Nachrichten schicken“.","<answer> Um einen parametrisierten Block als Prozess zu starten, verwendet man die Methode ""newProcessWith:"" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält. <answer> <question> Welche Methode wird verwendet, um einen parametrisierten Block als Prozess zu starten? <question>"
"Die objektorientierte Weltsicht, die auch in diesem Kurs propagiert wird (nämlich die von den Objekten, die einander Nachrichten schicken und die auf den Empfang von Nachrichten reagieren, indem sie ihren Zustand ändern und weitere Nachrichten verschicken), legt nahe, dass Objekte aktiv sind, will sagen, dass sie über einen eigenen Rechenprozess verfügen. Doch schon in Abschnitt 4.3.2 wurde klar, dass es damit in der Realität nicht weit her ist: Es werden in der Praxis keine Nachrichten verschickt, sondern lediglich Methoden aufgerufen. Abgesehen vom dynamischen Binden dieser Methoden unterscheidet sich damit das Ausführungsmodell der objektorientierten Programmierung nicht von dem der prozeduralen Programmierung (à la PASCAL); insbesondere sind alle Objekte passiv (was soviel bedeutet, wie dass sie nur aktiv sind, solange sie gerade eine Methode ausführen).
Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.
Gleichwohl ist auch in der objektorientierten Programmierung Parallelverarbeitung möglich. Nur kommt sie (zumindest in SMALLTALK, aber auch z. B. in JAVA) nicht in Form von aktiven Objekten daher, sondern in Form von parallelen Prozessen. Jeder dieser Prozesse führt zu einer Zeit eine Methode aus; er besucht zwar mit dem Methodenaufruf die Empfängerobjekte, diese bleiben jedoch selbst passiv (haben also kein Eigenleben).
Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neuen Prozess zu starten: Man schickt einfach einem Block die Nachricht ""fork"". ""fork"" entspricht im Wesentlichen ""value"", nur dass der Block dadurch in einem eigenen, unabhängigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von ""fork"" auch nicht darauf, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zurückliefert; tatsächlich liefert sie auch nicht (wie ""value"") das Ergebnis des Blocks zurück, sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann geht dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert.
Soll ein (paralleler) Prozess nicht sofort starten, so braucht man ein Objekt, das diesen Prozess repräsentiert und dem man dann zu einem späteren Zeitpunkt die Nachricht ""resume"" schicken kann, die den Prozess startet. Ein solches Objekt erhält man, indem man dem Block ""newProcess"" schickt. Tatsächlich ist ""fork"" wie folgt implementiert:
Um einen parametrisierten Block (also einen Block mit Parametern) als Prozess zu starten, verwendet man statt ""newProcess"" ""newProcessWith:"" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält.
Mit den Nachrichten ""suspend"" und ""terminate"" kann man den Prozess dann temporär anhalten bzw. beenden. Angehaltene Prozesse können später mit ""resume"" wieder gestartet werden, beendete nicht.
Die Synchronisation von parallelen Prozessen erfolgt in SMALLTALK zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen dazu über zwei Methoden, ""wait"" und ""signal"", und eine Instanzvariable, die für jedes Empfangen von ""signal"" um 1 erhöht und für jedes Empfangen von ""wait"" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt (mittels ""suspend""). Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht ""signal"" und es gibt noch Prozesse, die schlafen (erkennbar an einem Zähler kleiner als 1), dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden (mittels ""resume"") und weitermachen.
Die Synchronisation mittels Semaphoren ist recht elementar und von aktiven Objekten noch weit entfernt. Deutlich näher rückt man mit der Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gezählt werden) Objekte aufnehmen und die eine Synchronisation über ""next"" und ""nextPut:"" erlauben. Das Protokoll sieht wie folgt aus:
Wenn man nun eine solche SharedQueue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann hat man tatsächlich „aktive Objekte, die einander Nachrichten schicken“.","<answer> Die Synchronisation von parallelen Prozessen in SMALLTALK erfolgt zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen über Methoden wie ""wait"" und ""signal"", um die Ausführung von Prozessen zu steuern. Semaphore-Objekte zählen die Anzahl der Signale und können Prozesse in den Schlaf versetzen oder aufwecken, abhängig von ihrem aktuellen Zustand. Die Synchronisation kann auch über die Klasse SharedQueue erfolgen, die Objekte aufnimmt und Synchronisation über ""next"" und ""nextPut:"" ermöglicht. <answer> <question> Wie erfolgt die Synchronisation von parallelen Prozessen in SMALLTALK? <question>"
"EIFFEL nimmt unter den hier behandelten Sprachen eine Sonderstellung ein. Es soll nämlich mehrere Dinge auf einmal sein: eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache.
Das herausragende Merkmal, das EIFFEL zu dieser Multifunktion qualifiziert, ist die Integration von Zusicherungen (die Formulierung von Vorbedingungen, Nachbedingungen und Klasseninvarianten), die als Verträge zwischen dienstanbietenden und dienstnehmenden Klassen interpretiert werden können. Dies erlaubt, das ""Was"" einer Software zumindest teilweise unabhängig vom ""Wie"" zu spezifizieren. Die Typsysteme, die Sie in den vorangegangenen Kapiteln kennengelernt haben und von denen auch EIFFEL eines besitzt, erlauben zwar auch schon, Zusicherungen auszudrücken, aber diese beziehen sich jeweils auf die möglichen Werte einer Variable und bleiben dabei sowohl voneinander als auch von der Zeit unabhängig. EIFFEL erlaubt darüber hinaus, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können.
EIFFEL tritt in vielerlei Hinsicht in die Fußstapfen von PASCAL: Es ist nicht nur syntaktisch ähnlich, sondern ist auch um Sparsamkeit, Klarheit und Orthogonalität der Konzepte bemüht. Viele Dinge sind in EIFFEL ein klein bisschen anders als in anderen Sprachen, weswegen man meinen könnte, es sei aus Prinzip anders; die meisten Abweichungen sind jedoch wohlbegründet und vermitteln mitunter eine angenehm andere Perspektive auf vertraute Dinge. So ist es eigentlich nur folgerichtig, dass der Erschaffer von EIFFEL, BERTRAND MEYER, Nachfolger von NIKLAUS WIRTH auf dessen Lehrstuhl an der ETH Zürich wurde.
Es ist mir nicht ganz klar, warum EIFFEL kein größerer Erfolg beschieden ist. Es mag zum einen an der über Jahre absolut unzureichenden Implementierung der Werkzeuge liegen, insbesondere des Compilers. Anfangs wurde er noch nach C übersetzt, was beim Debuggen sicherlich keine Freude für Programmierende war. Zum anderen könnte es an der Natur von BERTRAND MEYER liegen, der sich mit seiner Kompromisslosigkeit nicht nur Freunde gemacht hat. Eine Rolle spielt sicherlich auch das unmögliche, aber trotzdem angestrebte Spagat zwischen kommerzieller Einsetzbarkeit und akademischer Eignung. Viele Programmierweisen, die in der Praxis üblich sind und auf die kaum eine Entwicklerin verzichten will, sind akademisch verpönt. Das Typsystem von EIFFEL trägt, wie Sie sich in Abschnitt 52.5 selbst vergewissern können, auch nicht unbedingt zur Akzeptanz bei. Auf der anderen Seite hat EIFFEL neben SMALLTALK noch am ehesten das Format und die Art, wie man über das Programmieren denkt, zu beeinflussen.","<answer> EIFFEL nimmt eine besondere Position unter den behandelten Sprachen ein, da es mehrere Funktionen erfüllt: Es dient als Sprache für objektorientierte Analyse und Design, für kommerzielle Programmierung und als akademische Lehrsprache. <answer> <question> Welche Rolle nimmt EIFFEL unter den behandelten Sprachen ein? <question>"
"EIFFEL nimmt unter den hier behandelten Sprachen eine Sonderstellung ein. Es soll nämlich mehrere Dinge auf einmal sein: eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache.
Das herausragende Merkmal, das EIFFEL zu dieser Multifunktion qualifiziert, ist die Integration von Zusicherungen (die Formulierung von Vorbedingungen, Nachbedingungen und Klasseninvarianten), die als Verträge zwischen dienstanbietenden und dienstnehmenden Klassen interpretiert werden können. Dies erlaubt, das ""Was"" einer Software zumindest teilweise unabhängig vom ""Wie"" zu spezifizieren. Die Typsysteme, die Sie in den vorangegangenen Kapiteln kennengelernt haben und von denen auch EIFFEL eines besitzt, erlauben zwar auch schon, Zusicherungen auszudrücken, aber diese beziehen sich jeweils auf die möglichen Werte einer Variable und bleiben dabei sowohl voneinander als auch von der Zeit unabhängig. EIFFEL erlaubt darüber hinaus, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können.
EIFFEL tritt in vielerlei Hinsicht in die Fußstapfen von PASCAL: Es ist nicht nur syntaktisch ähnlich, sondern ist auch um Sparsamkeit, Klarheit und Orthogonalität der Konzepte bemüht. Viele Dinge sind in EIFFEL ein klein bisschen anders als in anderen Sprachen, weswegen man meinen könnte, es sei aus Prinzip anders; die meisten Abweichungen sind jedoch wohlbegründet und vermitteln mitunter eine angenehm andere Perspektive auf vertraute Dinge. So ist es eigentlich nur folgerichtig, dass der Erschaffer von EIFFEL, BERTRAND MEYER, Nachfolger von NIKLAUS WIRTH auf dessen Lehrstuhl an der ETH Zürich wurde.
Es ist mir nicht ganz klar, warum EIFFEL kein größerer Erfolg beschieden ist. Es mag zum einen an der über Jahre absolut unzureichenden Implementierung der Werkzeuge liegen, insbesondere des Compilers. Anfangs wurde er noch nach C übersetzt, was beim Debuggen sicherlich keine Freude für Programmierende war. Zum anderen könnte es an der Natur von BERTRAND MEYER liegen, der sich mit seiner Kompromisslosigkeit nicht nur Freunde gemacht hat. Eine Rolle spielt sicherlich auch das unmögliche, aber trotzdem angestrebte Spagat zwischen kommerzieller Einsetzbarkeit und akademischer Eignung. Viele Programmierweisen, die in der Praxis üblich sind und auf die kaum eine Entwicklerin verzichten will, sind akademisch verpönt. Das Typsystem von EIFFEL trägt, wie Sie sich in Abschnitt 52.5 selbst vergewissern können, auch nicht unbedingt zur Akzeptanz bei. Auf der anderen Seite hat EIFFEL neben SMALLTALK noch am ehesten das Format und die Art, wie man über das Programmieren denkt, zu beeinflussen.","<answer> Das herausragende Merkmal von EIFFEL ist die Integration von Zusicherungen (Vorbedingungen, Nachbedingungen und Klasseninvarianten), die als Verträge zwischen Klassen dienen können. Dies ermöglicht eine Spezifikation des ""Was"" einer Software unabhängig vom ""Wie"". Es erlaubt, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sich auf andere Werte und den zeitlichen Verlauf beziehen können. Diese Funktion trägt zu seiner Multifunktion bei, da sie verschiedene Anwendungsbereiche unterstützt. <answer> <question> Was ist das herausragende Merkmal von EIFFEL und wie trägt es zu seiner Multifunktion bei? <question>"
"EIFFEL nimmt unter den hier behandelten Sprachen eine Sonderstellung ein. Es soll nämlich mehrere Dinge auf einmal sein: eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache.
Das herausragende Merkmal, das EIFFEL zu dieser Multifunktion qualifiziert, ist die Integration von Zusicherungen (die Formulierung von Vorbedingungen, Nachbedingungen und Klasseninvarianten), die als Verträge zwischen dienstanbietenden und dienstnehmenden Klassen interpretiert werden können. Dies erlaubt, das ""Was"" einer Software zumindest teilweise unabhängig vom ""Wie"" zu spezifizieren. Die Typsysteme, die Sie in den vorangegangenen Kapiteln kennengelernt haben und von denen auch EIFFEL eines besitzt, erlauben zwar auch schon, Zusicherungen auszudrücken, aber diese beziehen sich jeweils auf die möglichen Werte einer Variable und bleiben dabei sowohl voneinander als auch von der Zeit unabhängig. EIFFEL erlaubt darüber hinaus, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können.
EIFFEL tritt in vielerlei Hinsicht in die Fußstapfen von PASCAL: Es ist nicht nur syntaktisch ähnlich, sondern ist auch um Sparsamkeit, Klarheit und Orthogonalität der Konzepte bemüht. Viele Dinge sind in EIFFEL ein klein bisschen anders als in anderen Sprachen, weswegen man meinen könnte, es sei aus Prinzip anders; die meisten Abweichungen sind jedoch wohlbegründet und vermitteln mitunter eine angenehm andere Perspektive auf vertraute Dinge. So ist es eigentlich nur folgerichtig, dass der Erschaffer von EIFFEL, BERTRAND MEYER, Nachfolger von NIKLAUS WIRTH auf dessen Lehrstuhl an der ETH Zürich wurde.
Es ist mir nicht ganz klar, warum EIFFEL kein größerer Erfolg beschieden ist. Es mag zum einen an der über Jahre absolut unzureichenden Implementierung der Werkzeuge liegen, insbesondere des Compilers. Anfangs wurde er noch nach C übersetzt, was beim Debuggen sicherlich keine Freude für Programmierende war. Zum anderen könnte es an der Natur von BERTRAND MEYER liegen, der sich mit seiner Kompromisslosigkeit nicht nur Freunde gemacht hat. Eine Rolle spielt sicherlich auch das unmögliche, aber trotzdem angestrebte Spagat zwischen kommerzieller Einsetzbarkeit und akademischer Eignung. Viele Programmierweisen, die in der Praxis üblich sind und auf die kaum eine Entwicklerin verzichten will, sind akademisch verpönt. Das Typsystem von EIFFEL trägt, wie Sie sich in Abschnitt 52.5 selbst vergewissern können, auch nicht unbedingt zur Akzeptanz bei. Auf der anderen Seite hat EIFFEL neben SMALLTALK noch am ehesten das Format und die Art, wie man über das Programmieren denkt, zu beeinflussen.","<answer> Obwohl EIFFEL syntaktisch Ähnlichkeiten zu anderen Sprachen wie PASCAL aufweist, gibt es einige Abweichungen. Diese Abweichungen sind jedoch gut begründet und bieten eine alternative Perspektive auf vertraute Konzepte. Sie tragen dazu bei, klarere und orthogonalere Konzepte zu schaffen. <answer> <question> Welche Abweichungen gibt es in EIFFEL im Vergleich zu anderen Sprachen, und warum sind sie vorhanden? <question>"
"EIFFEL nimmt unter den hier behandelten Sprachen eine Sonderstellung ein. Es soll nämlich mehrere Dinge auf einmal sein: eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache.
Das herausragende Merkmal, das EIFFEL zu dieser Multifunktion qualifiziert, ist die Integration von Zusicherungen (die Formulierung von Vorbedingungen, Nachbedingungen und Klasseninvarianten), die als Verträge zwischen dienstanbietenden und dienstnehmenden Klassen interpretiert werden können. Dies erlaubt, das ""Was"" einer Software zumindest teilweise unabhängig vom ""Wie"" zu spezifizieren. Die Typsysteme, die Sie in den vorangegangenen Kapiteln kennengelernt haben und von denen auch EIFFEL eines besitzt, erlauben zwar auch schon, Zusicherungen auszudrücken, aber diese beziehen sich jeweils auf die möglichen Werte einer Variable und bleiben dabei sowohl voneinander als auch von der Zeit unabhängig. EIFFEL erlaubt darüber hinaus, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können.
EIFFEL tritt in vielerlei Hinsicht in die Fußstapfen von PASCAL: Es ist nicht nur syntaktisch ähnlich, sondern ist auch um Sparsamkeit, Klarheit und Orthogonalität der Konzepte bemüht. Viele Dinge sind in EIFFEL ein klein bisschen anders als in anderen Sprachen, weswegen man meinen könnte, es sei aus Prinzip anders; die meisten Abweichungen sind jedoch wohlbegründet und vermitteln mitunter eine angenehm andere Perspektive auf vertraute Dinge. So ist es eigentlich nur folgerichtig, dass der Erschaffer von EIFFEL, BERTRAND MEYER, Nachfolger von NIKLAUS WIRTH auf dessen Lehrstuhl an der ETH Zürich wurde.
Es ist mir nicht ganz klar, warum EIFFEL kein größerer Erfolg beschieden ist. Es mag zum einen an der über Jahre absolut unzureichenden Implementierung der Werkzeuge liegen, insbesondere des Compilers. Anfangs wurde er noch nach C übersetzt, was beim Debuggen sicherlich keine Freude für Programmierende war. Zum anderen könnte es an der Natur von BERTRAND MEYER liegen, der sich mit seiner Kompromisslosigkeit nicht nur Freunde gemacht hat. Eine Rolle spielt sicherlich auch das unmögliche, aber trotzdem angestrebte Spagat zwischen kommerzieller Einsetzbarkeit und akademischer Eignung. Viele Programmierweisen, die in der Praxis üblich sind und auf die kaum eine Entwicklerin verzichten will, sind akademisch verpönt. Das Typsystem von EIFFEL trägt, wie Sie sich in Abschnitt 52.5 selbst vergewissern können, auch nicht unbedingt zur Akzeptanz bei. Auf der anderen Seite hat EIFFEL neben SMALLTALK noch am ehesten das Format und die Art, wie man über das Programmieren denkt, zu beeinflussen.","<answer> Es gibt mehrere mögliche Gründe für den begrenzten Erfolg von EIFFEL. Dies könnte auf unzureichende Implementierungen der Werkzeuge, die Kompromisslosigkeit des Schöpfers BERTRAND MEYER und den Spagat zwischen kommerzieller Anwendbarkeit und akademischer Eignung zurückzuführen sein. Auch das Typsystem von EIFFEL und akademische Vorbehalte gegenüber bestimmten Programmierweisen könnten eine Rolle spielen. Trotzdem hat EIFFEL Einfluss auf die Art und Weise, wie über das Programmieren nachgedacht wird. <answer> <question> Warum könnte EIFFEL trotz seiner Funktionen kein größerer Erfolg geworden sein? <question>"
"Die einfache Verzweigung wird in SMALLTALK durch das Versenden einer Nachricht, die die bedingt auszuführenden Anweisungen in Form eines Blocks als Parameter enthält, an einen Wahrheitswert realisiert. Zum Beispiel gibt die Meldung „x > 5“ genau dann auf der Konsole aus, wenn x > 5 zu true auswertet.
Um zu verstehen, wie das funktioniert, sehen wir uns zunächst die Implementierung der Verzweigung mittels ifTrue: an. Sie wird durch eine Methode ifTrue: aBlock realisiert, die als Parameter einen Block, also eine Folge von Anweisungen, erhält. Diese Methode wird der Bedeutung von ""If"" entsprechend entweder ausgeführt oder eben nicht. Sie ist jeweils unterschiedlich implementiert für die beiden Objekte true und false (genauer: für die beiden Objekte, die die Pseudovariablen true und false benennen; siehe Abschnitt 1.7).
Aufgrund der Continuation bei Blöcken (siehe Abschnitt 4.4.2) ist es möglich, aus einer Methode mittels ifTrue: bedingt zurückzukehren.
Eigentlich ist dies viel zu banal, um es zu erwähnen, aber da es nur ein einziges Mal gemacht werden muss und dabei so etwas Fundamentales wie die Verzweigung realisiert wird, kann man sich auch darüber freuen.
Falls Sie dies dennoch für einen unwichtigen ""Budenzauber"" halten, dann haben Sie zumindest nicht völlig unrecht: Die Verzweigung ist nämlich gar nicht wirklich aus dem Sprachkern verschwunden, sie ist nur an einer Stelle versteckt, an der Sie sie vielleicht nicht vermuten: an der Stelle der Auswahl der Methode, die in Reaktion auf den Empfang einer Nachricht ausgeführt wird (also beim dynamischen Binden).","<answer> In SMALLTALK wird die einfache Verzweigung durch das Versenden einer Nachricht an einen Wahrheitswert realisiert. Diese Nachricht enthält die bedingt auszuführenden Anweisungen in Form eines Blocks als Parameter. Zum Beispiel wird die Meldung ""x > 5"" aufgerufen, wenn x größer als 5 ist. <answer> <question> Wie wird die einfache Verzweigung in SMALLTALK realisiert? <question>"
"Die einfache Verzweigung wird in SMALLTALK durch das Versenden einer Nachricht, die die bedingt auszuführenden Anweisungen in Form eines Blocks als Parameter enthält, an einen Wahrheitswert realisiert. Zum Beispiel gibt die Meldung „x > 5“ genau dann auf der Konsole aus, wenn x > 5 zu true auswertet.
Um zu verstehen, wie das funktioniert, sehen wir uns zunächst die Implementierung der Verzweigung mittels ifTrue: an. Sie wird durch eine Methode ifTrue: aBlock realisiert, die als Parameter einen Block, also eine Folge von Anweisungen, erhält. Diese Methode wird der Bedeutung von ""If"" entsprechend entweder ausgeführt oder eben nicht. Sie ist jeweils unterschiedlich implementiert für die beiden Objekte true und false (genauer: für die beiden Objekte, die die Pseudovariablen true und false benennen; siehe Abschnitt 1.7).
Aufgrund der Continuation bei Blöcken (siehe Abschnitt 4.4.2) ist es möglich, aus einer Methode mittels ifTrue: bedingt zurückzukehren.
Eigentlich ist dies viel zu banal, um es zu erwähnen, aber da es nur ein einziges Mal gemacht werden muss und dabei so etwas Fundamentales wie die Verzweigung realisiert wird, kann man sich auch darüber freuen.
Falls Sie dies dennoch für einen unwichtigen ""Budenzauber"" halten, dann haben Sie zumindest nicht völlig unrecht: Die Verzweigung ist nämlich gar nicht wirklich aus dem Sprachkern verschwunden, sie ist nur an einer Stelle versteckt, an der Sie sie vielleicht nicht vermuten: an der Stelle der Auswahl der Methode, die in Reaktion auf den Empfang einer Nachricht ausgeführt wird (also beim dynamischen Binden).","<answer> Die Methode ifTrue: in SMALLTALK wird so implementiert, dass sie als Parameter einen Block (eine Folge von Anweisungen) erhält. Diese Methode wird je nach Wahrheitswert (true oder false) unterschiedlich ausgeführt und führt den übergebenen Block aus, wenn die Bedingung erfüllt ist. Es ist möglich, aus einer Methode mittels ifTrue: bedingt zurückzukehren, aufgrund der Continuation bei Blöcken. <answer> <question> Wie wird die Methode ifTrue: in SMALLTALK implementiert? <question>"
"Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem Interface veröffentlichten noch weitere öffentliche (public deklarierte) Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces einer Klasse unterschiedliche Methodenmengen zur Verfügung stellen können. Da auf eine Variable, die mit einem Interfacetyp deklariert wurde, aber immer nur die Methoden aufgerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgreichen Prüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten können), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. So kann beispielsweise ein Ein- und Ausgabestrom als Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben:
Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.
Umgangen werden kann diese Zugriffsbeschränkung über Interfaces in JAVA immer dann, wenn die Klasse, von der das verwendete Objekt eine Instanz ist, ebenfalls als Typ zur Verfügung steht. Man kann in Variablendeklarationen dann genauso gut die Klasse als Typ verwenden. So könnte man sowohl in ""WillNurLesen"" die Variable ""eingabe"" als auch in ""WillNurSchreiben"" die Variable ""ausgabe"" mit dem Typ ""IOStream"" deklarieren, hätte damit jedoch keine syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr. C# geht hier einen Schritt weiter und ermöglicht Klassendefinitionen zumindest, ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen (s. Kurseinheit 5, Abschnitt 50.4.2). Seit JAVA 8 kann man allerdings in Interfaces auch statische Methoden definieren, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff mehr auf die Klassen, die deswegen als package local deklariert und die somit vollständig hinter dem Interface als Schnittstelle verborgen werden können.
Interfaces dienen aber nicht nur der Beschränkung des Zugriffs wie im obigen Beispiel — sie dienen auch der besseren Austauschbarkeit von Klassen. Und das bringt uns zurück zum eingangs in Kapitel 43 benutzten Beispiel (Zeile 1051 ff.): Dadurch, dass die Variable ""liste"" mit dem Typ ""List"" (ein Interface) und nicht ""ArrayList"" (eine Klasse) deklariert wurde, können ihr auch Instanzen anderer Klassen als ""ArrayList"" zugewiesen werden, solange sie nur dasselbe Interface implementieren. Das Interface als Typ der Variable verlangt lediglich, dass alle in ihm versammelten Methoden von den Objekten, auf die die Variable per Typsystem verweisen darf, auch angeboten werden, und das wird dadurch sichergestellt, dass der Typ der rechten Seite aller Zuweisungen zur Variablen konform zum Typ der linken Seite sein muss. Die Zuweisungskompatibilität ist in JAVA also an die Typkonformität gebunden, und zwar an die nominale.
Eine weitere, vergleichsweise häufig verwendete Möglichkeit des Einsatzes von Interfaces ist die als sog. Tagging oder Marker interfaces. Ein Tagging oder Marker Interface hat in der Regel keine eigenen Methodendeklarationen, sondern dient lediglich der Filterung von Variablenwerten. ""Serializable"" wäre ein solches Interface. Da in JAVA die vom Compiler statisch geprüfte Zuweisungskompatibilität ja Namenskonformität verlangt, kann die Typisierung einer Variable mit dem Interface ""Markiert"" erzwingen, dass dieser Variable nur Instanzen solcher Klassen zugewiesen werden, die das Interface ""Markiert"" zu implementieren deklarieren. Da das Interface aber keine Auflagen macht (keine Methodendeklarationen vorgibt, die von der Klasse mit Definitionen versehen werden müssen), ist die Implementierung des Interfaces für die Klasse zunächst ohne Konsequenzen. Die durch das Interface erfolgte Markierung der Klassen (bzw. deren Instanzen) kann jedoch zur Übersetzungszeit vom Compiler (s. o.) und zur Laufzeit durch einen Typtest (s. Abschnitt 44.2) überprüft werden.
Ein konkretes Beispiel für ein Marker-Interface in JAVA ist das Interface ""Serializable"", mit dessen Implementierung eine Klasse deklariert, dass ihre Instanzen serialisiert werden können. Die Serialisierung wird aber nicht von der Klasse selbst vorgenommen, sondern von einer anderen; die Klasse muss also zu ihrer Serialisierung nichts weiter beitragen. Seit JAVA 5 würde man allerdings solche Marker-Interfaces eher durch Metadaten (auch Annotationen genannt; s. Abschnitt 47.4) ersetzen, so wie das in C# schon länger gehandhabt wird (s. Abschnitt 50.4 in Kurseinheit 5). Interfaces erhöhen
JAVAs Interface-als-Typ-Konzept ist ziemlich interessant und vielleicht sogar der größte einzelne Beitrag JAVAs zur objektorientierten Programmierung. In der Programmierpraxis scheint es jedoch, sieht man einmal von großen Frameworks ab, nur langsam anzukommen. Das mag zum einen an der schlechten Verkaufsstrategie liegen („Ersatz für Mehrfachvererbung“ — jede Anfängerin merkt nach fünf Minuten, dass das nicht stimmt), zum anderen aber auch an der Vergrößerung des Programmumfangs, die der parallelen Definition von Klassen und Interfaces geschuldet ist (die auch den Wartungsaufwand erhöhen kann, obwohl ja Interfaces eigentlich die Wartung vereinfachen sollen). Für so manche Programmiererin scheinen die Möglichkeiten, die Schnittstelle einer Klasse mittels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, völlig auszureichen. Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Klienten sowie eine (häufig vorschnelle) Festlegung von Variablen auf Instanzen einer Klasse.","<answer> Die Verwendung von Interfaces in Java ermöglicht die Bereitstellung verschiedener Sichten auf Objekte, die von Klassen implementiert werden. Dies kann dazu beitragen, den Zugriff auf die Methoden eines Objekts zu beschränken oder die Austauschbarkeit von Klassen zu verbessern. <answer> <question> Welche Vorteile bietet die Verwendung von Interfaces in Java? <question>"
"Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem Interface veröffentlichten noch weitere öffentliche (public deklarierte) Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces einer Klasse unterschiedliche Methodenmengen zur Verfügung stellen können. Da auf eine Variable, die mit einem Interfacetyp deklariert wurde, aber immer nur die Methoden aufgerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgreichen Prüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten können), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. So kann beispielsweise ein Ein- und Ausgabestrom als Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben:
Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.
Umgangen werden kann diese Zugriffsbeschränkung über Interfaces in JAVA immer dann, wenn die Klasse, von der das verwendete Objekt eine Instanz ist, ebenfalls als Typ zur Verfügung steht. Man kann in Variablendeklarationen dann genauso gut die Klasse als Typ verwenden. So könnte man sowohl in ""WillNurLesen"" die Variable ""eingabe"" als auch in ""WillNurSchreiben"" die Variable ""ausgabe"" mit dem Typ ""IOStream"" deklarieren, hätte damit jedoch keine syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr. C# geht hier einen Schritt weiter und ermöglicht Klassendefinitionen zumindest, ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen (s. Kurseinheit 5, Abschnitt 50.4.2). Seit JAVA 8 kann man allerdings in Interfaces auch statische Methoden definieren, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff mehr auf die Klassen, die deswegen als package local deklariert und die somit vollständig hinter dem Interface als Schnittstelle verborgen werden können.
Interfaces dienen aber nicht nur der Beschränkung des Zugriffs wie im obigen Beispiel — sie dienen auch der besseren Austauschbarkeit von Klassen. Und das bringt uns zurück zum eingangs in Kapitel 43 benutzten Beispiel (Zeile 1051 ff.): Dadurch, dass die Variable ""liste"" mit dem Typ ""List"" (ein Interface) und nicht ""ArrayList"" (eine Klasse) deklariert wurde, können ihr auch Instanzen anderer Klassen als ""ArrayList"" zugewiesen werden, solange sie nur dasselbe Interface implementieren. Das Interface als Typ der Variable verlangt lediglich, dass alle in ihm versammelten Methoden von den Objekten, auf die die Variable per Typsystem verweisen darf, auch angeboten werden, und das wird dadurch sichergestellt, dass der Typ der rechten Seite aller Zuweisungen zur Variablen konform zum Typ der linken Seite sein muss. Die Zuweisungskompatibilität ist in JAVA also an die Typkonformität gebunden, und zwar an die nominale.
Eine weitere, vergleichsweise häufig verwendete Möglichkeit des Einsatzes von Interfaces ist die als sog. Tagging oder Marker interfaces. Ein Tagging oder Marker Interface hat in der Regel keine eigenen Methodendeklarationen, sondern dient lediglich der Filterung von Variablenwerten. ""Serializable"" wäre ein solches Interface. Da in JAVA die vom Compiler statisch geprüfte Zuweisungskompatibilität ja Namenskonformität verlangt, kann die Typisierung einer Variable mit dem Interface ""Markiert"" erzwingen, dass dieser Variable nur Instanzen solcher Klassen zugewiesen werden, die das Interface ""Markiert"" zu implementieren deklarieren. Da das Interface aber keine Auflagen macht (keine Methodendeklarationen vorgibt, die von der Klasse mit Definitionen versehen werden müssen), ist die Implementierung des Interfaces für die Klasse zunächst ohne Konsequenzen. Die durch das Interface erfolgte Markierung der Klassen (bzw. deren Instanzen) kann jedoch zur Übersetzungszeit vom Compiler (s. o.) und zur Laufzeit durch einen Typtest (s. Abschnitt 44.2) überprüft werden.
Ein konkretes Beispiel für ein Marker-Interface in JAVA ist das Interface ""Serializable"", mit dessen Implementierung eine Klasse deklariert, dass ihre Instanzen serialisiert werden können. Die Serialisierung wird aber nicht von der Klasse selbst vorgenommen, sondern von einer anderen; die Klasse muss also zu ihrer Serialisierung nichts weiter beitragen. Seit JAVA 5 würde man allerdings solche Marker-Interfaces eher durch Metadaten (auch Annotationen genannt; s. Abschnitt 47.4) ersetzen, so wie das in C# schon länger gehandhabt wird (s. Abschnitt 50.4 in Kurseinheit 5). Interfaces erhöhen
JAVAs Interface-als-Typ-Konzept ist ziemlich interessant und vielleicht sogar der größte einzelne Beitrag JAVAs zur objektorientierten Programmierung. In der Programmierpraxis scheint es jedoch, sieht man einmal von großen Frameworks ab, nur langsam anzukommen. Das mag zum einen an der schlechten Verkaufsstrategie liegen („Ersatz für Mehrfachvererbung“ — jede Anfängerin merkt nach fünf Minuten, dass das nicht stimmt), zum anderen aber auch an der Vergrößerung des Programmumfangs, die der parallelen Definition von Klassen und Interfaces geschuldet ist (die auch den Wartungsaufwand erhöhen kann, obwohl ja Interfaces eigentlich die Wartung vereinfachen sollen). Für so manche Programmiererin scheinen die Möglichkeiten, die Schnittstelle einer Klasse mittels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, völlig auszureichen. Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Klienten sowie eine (häufig vorschnelle) Festlegung von Variablen auf Instanzen einer Klasse.","<answer> Tagging oder Marker-Interfaces in Java sind Schnittstellen, die in der Regel keine eigenen Methoden deklarieren, sondern dazu verwendet werden, Klassen zu markieren oder zu ""taggen"". Sie dienen der Filterung von Variablenwerten und können beispielsweise dazu verwendet werden, bestimmte Eigenschaften oder Fähigkeiten von Klassen oder Objekten zu kennzeichnen. Ein Beispiel ist das Marker-Interface ""Serializable"", das angibt, dass Instanzen einer Klasse serialisierbar sind. <answer> <question> Was sind Tagging oder Marker-Interfaces in Java und wofür werden sie verwendet? <question>"
"Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem Interface veröffentlichten noch weitere öffentliche (public deklarierte) Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces einer Klasse unterschiedliche Methodenmengen zur Verfügung stellen können. Da auf eine Variable, die mit einem Interfacetyp deklariert wurde, aber immer nur die Methoden aufgerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgreichen Prüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten können), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. So kann beispielsweise ein Ein- und Ausgabestrom als Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben:
Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.
Umgangen werden kann diese Zugriffsbeschränkung über Interfaces in JAVA immer dann, wenn die Klasse, von der das verwendete Objekt eine Instanz ist, ebenfalls als Typ zur Verfügung steht. Man kann in Variablendeklarationen dann genauso gut die Klasse als Typ verwenden. So könnte man sowohl in ""WillNurLesen"" die Variable ""eingabe"" als auch in ""WillNurSchreiben"" die Variable ""ausgabe"" mit dem Typ ""IOStream"" deklarieren, hätte damit jedoch keine syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr. C# geht hier einen Schritt weiter und ermöglicht Klassendefinitionen zumindest, ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen (s. Kurseinheit 5, Abschnitt 50.4.2). Seit JAVA 8 kann man allerdings in Interfaces auch statische Methoden definieren, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff mehr auf die Klassen, die deswegen als package local deklariert und die somit vollständig hinter dem Interface als Schnittstelle verborgen werden können.
Interfaces dienen aber nicht nur der Beschränkung des Zugriffs wie im obigen Beispiel — sie dienen auch der besseren Austauschbarkeit von Klassen. Und das bringt uns zurück zum eingangs in Kapitel 43 benutzten Beispiel (Zeile 1051 ff.): Dadurch, dass die Variable ""liste"" mit dem Typ ""List"" (ein Interface) und nicht ""ArrayList"" (eine Klasse) deklariert wurde, können ihr auch Instanzen anderer Klassen als ""ArrayList"" zugewiesen werden, solange sie nur dasselbe Interface implementieren. Das Interface als Typ der Variable verlangt lediglich, dass alle in ihm versammelten Methoden von den Objekten, auf die die Variable per Typsystem verweisen darf, auch angeboten werden, und das wird dadurch sichergestellt, dass der Typ der rechten Seite aller Zuweisungen zur Variablen konform zum Typ der linken Seite sein muss. Die Zuweisungskompatibilität ist in JAVA also an die Typkonformität gebunden, und zwar an die nominale.
Eine weitere, vergleichsweise häufig verwendete Möglichkeit des Einsatzes von Interfaces ist die als sog. Tagging oder Marker interfaces. Ein Tagging oder Marker Interface hat in der Regel keine eigenen Methodendeklarationen, sondern dient lediglich der Filterung von Variablenwerten. ""Serializable"" wäre ein solches Interface. Da in JAVA die vom Compiler statisch geprüfte Zuweisungskompatibilität ja Namenskonformität verlangt, kann die Typisierung einer Variable mit dem Interface ""Markiert"" erzwingen, dass dieser Variable nur Instanzen solcher Klassen zugewiesen werden, die das Interface ""Markiert"" zu implementieren deklarieren. Da das Interface aber keine Auflagen macht (keine Methodendeklarationen vorgibt, die von der Klasse mit Definitionen versehen werden müssen), ist die Implementierung des Interfaces für die Klasse zunächst ohne Konsequenzen. Die durch das Interface erfolgte Markierung der Klassen (bzw. deren Instanzen) kann jedoch zur Übersetzungszeit vom Compiler (s. o.) und zur Laufzeit durch einen Typtest (s. Abschnitt 44.2) überprüft werden.
Ein konkretes Beispiel für ein Marker-Interface in JAVA ist das Interface ""Serializable"", mit dessen Implementierung eine Klasse deklariert, dass ihre Instanzen serialisiert werden können. Die Serialisierung wird aber nicht von der Klasse selbst vorgenommen, sondern von einer anderen; die Klasse muss also zu ihrer Serialisierung nichts weiter beitragen. Seit JAVA 5 würde man allerdings solche Marker-Interfaces eher durch Metadaten (auch Annotationen genannt; s. Abschnitt 47.4) ersetzen, so wie das in C# schon länger gehandhabt wird (s. Abschnitt 50.4 in Kurseinheit 5). Interfaces erhöhen
JAVAs Interface-als-Typ-Konzept ist ziemlich interessant und vielleicht sogar der größte einzelne Beitrag JAVAs zur objektorientierten Programmierung. In der Programmierpraxis scheint es jedoch, sieht man einmal von großen Frameworks ab, nur langsam anzukommen. Das mag zum einen an der schlechten Verkaufsstrategie liegen („Ersatz für Mehrfachvererbung“ — jede Anfängerin merkt nach fünf Minuten, dass das nicht stimmt), zum anderen aber auch an der Vergrößerung des Programmumfangs, die der parallelen Definition von Klassen und Interfaces geschuldet ist (die auch den Wartungsaufwand erhöhen kann, obwohl ja Interfaces eigentlich die Wartung vereinfachen sollen). Für so manche Programmiererin scheinen die Möglichkeiten, die Schnittstelle einer Klasse mittels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, völlig auszureichen. Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Klienten sowie eine (häufig vorschnelle) Festlegung von Variablen auf Instanzen einer Klasse.","<answer> Interfaces ermöglichen es, verschiedene Implementierungen eines Interfaces zu verwenden, ohne den zugrunde liegenden Klassentyp zu spezifizieren. Dies verbessert die Austauschbarkeit von Klassen, da verschiedene Klassen, die dasselbe Interface implementieren, in derselben Weise verwendet werden können. <answer> <question> Wie können Interfaces in Java dazu beitragen, die Austauschbarkeit von Klassen zu verbessern? <question>"
"Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem Interface veröffentlichten noch weitere öffentliche (public deklarierte) Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces einer Klasse unterschiedliche Methodenmengen zur Verfügung stellen können. Da auf eine Variable, die mit einem Interfacetyp deklariert wurde, aber immer nur die Methoden aufgerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgreichen Prüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten können), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. So kann beispielsweise ein Ein- und Ausgabestrom als Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben:
Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.
Umgangen werden kann diese Zugriffsbeschränkung über Interfaces in JAVA immer dann, wenn die Klasse, von der das verwendete Objekt eine Instanz ist, ebenfalls als Typ zur Verfügung steht. Man kann in Variablendeklarationen dann genauso gut die Klasse als Typ verwenden. So könnte man sowohl in ""WillNurLesen"" die Variable ""eingabe"" als auch in ""WillNurSchreiben"" die Variable ""ausgabe"" mit dem Typ ""IOStream"" deklarieren, hätte damit jedoch keine syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr. C# geht hier einen Schritt weiter und ermöglicht Klassendefinitionen zumindest, ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen (s. Kurseinheit 5, Abschnitt 50.4.2). Seit JAVA 8 kann man allerdings in Interfaces auch statische Methoden definieren, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff mehr auf die Klassen, die deswegen als package local deklariert und die somit vollständig hinter dem Interface als Schnittstelle verborgen werden können.
Interfaces dienen aber nicht nur der Beschränkung des Zugriffs wie im obigen Beispiel — sie dienen auch der besseren Austauschbarkeit von Klassen. Und das bringt uns zurück zum eingangs in Kapitel 43 benutzten Beispiel (Zeile 1051 ff.): Dadurch, dass die Variable ""liste"" mit dem Typ ""List"" (ein Interface) und nicht ""ArrayList"" (eine Klasse) deklariert wurde, können ihr auch Instanzen anderer Klassen als ""ArrayList"" zugewiesen werden, solange sie nur dasselbe Interface implementieren. Das Interface als Typ der Variable verlangt lediglich, dass alle in ihm versammelten Methoden von den Objekten, auf die die Variable per Typsystem verweisen darf, auch angeboten werden, und das wird dadurch sichergestellt, dass der Typ der rechten Seite aller Zuweisungen zur Variablen konform zum Typ der linken Seite sein muss. Die Zuweisungskompatibilität ist in JAVA also an die Typkonformität gebunden, und zwar an die nominale.
Eine weitere, vergleichsweise häufig verwendete Möglichkeit des Einsatzes von Interfaces ist die als sog. Tagging oder Marker interfaces. Ein Tagging oder Marker Interface hat in der Regel keine eigenen Methodendeklarationen, sondern dient lediglich der Filterung von Variablenwerten. ""Serializable"" wäre ein solches Interface. Da in JAVA die vom Compiler statisch geprüfte Zuweisungskompatibilität ja Namenskonformität verlangt, kann die Typisierung einer Variable mit dem Interface ""Markiert"" erzwingen, dass dieser Variable nur Instanzen solcher Klassen zugewiesen werden, die das Interface ""Markiert"" zu implementieren deklarieren. Da das Interface aber keine Auflagen macht (keine Methodendeklarationen vorgibt, die von der Klasse mit Definitionen versehen werden müssen), ist die Implementierung des Interfaces für die Klasse zunächst ohne Konsequenzen. Die durch das Interface erfolgte Markierung der Klassen (bzw. deren Instanzen) kann jedoch zur Übersetzungszeit vom Compiler (s. o.) und zur Laufzeit durch einen Typtest (s. Abschnitt 44.2) überprüft werden.
Ein konkretes Beispiel für ein Marker-Interface in JAVA ist das Interface ""Serializable"", mit dessen Implementierung eine Klasse deklariert, dass ihre Instanzen serialisiert werden können. Die Serialisierung wird aber nicht von der Klasse selbst vorgenommen, sondern von einer anderen; die Klasse muss also zu ihrer Serialisierung nichts weiter beitragen. Seit JAVA 5 würde man allerdings solche Marker-Interfaces eher durch Metadaten (auch Annotationen genannt; s. Abschnitt 47.4) ersetzen, so wie das in C# schon länger gehandhabt wird (s. Abschnitt 50.4 in Kurseinheit 5). Interfaces erhöhen
JAVAs Interface-als-Typ-Konzept ist ziemlich interessant und vielleicht sogar der größte einzelne Beitrag JAVAs zur objektorientierten Programmierung. In der Programmierpraxis scheint es jedoch, sieht man einmal von großen Frameworks ab, nur langsam anzukommen. Das mag zum einen an der schlechten Verkaufsstrategie liegen („Ersatz für Mehrfachvererbung“ — jede Anfängerin merkt nach fünf Minuten, dass das nicht stimmt), zum anderen aber auch an der Vergrößerung des Programmumfangs, die der parallelen Definition von Klassen und Interfaces geschuldet ist (die auch den Wartungsaufwand erhöhen kann, obwohl ja Interfaces eigentlich die Wartung vereinfachen sollen). Für so manche Programmiererin scheinen die Möglichkeiten, die Schnittstelle einer Klasse mittels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, völlig auszureichen. Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Klienten sowie eine (häufig vorschnelle) Festlegung von Variablen auf Instanzen einer Klasse.","<answer> Interfaces können dazu verwendet werden, den Zugriff auf Methoden zu beschränken, da nur die im Interface definierten Methoden aufgerufen werden können. Dies ermöglicht es, verschiedene Sichten auf ein Objekt zu gewähren und den Zugriff auf bestimmte Methoden zu kontrollieren. <answer> <question> Welche Rolle spielen Interfaces bei der Einschränkung des Zugriffs auf Methoden in Java? <question>"
"Oben hatten wir ja bereits erwähnt, dass eine Klasse neben den in ihrem Interface veröffentlichten noch weitere öffentliche (public deklarierte) Methoden haben kann. Daraus folgt, dass unterschiedliche Interfaces einer Klasse unterschiedliche Methodenmengen zur Verfügung stellen können. Da auf eine Variable, die mit einem Interfacetyp deklariert wurde, aber immer nur die Methoden aufgerufen werden dürfen, die der Interfacetyp veröffentlicht (sonst könnte aus der erfolgreichen Prüfung der Zuweisungskompatibilität eines Programms nicht abgeleitet werden, dass auch keine Laufzeitfehler der Art, dass eine Methode nicht vorhanden ist, auftreten können), können mit Hilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. So kann beispielsweise ein Ein- und Ausgabestrom als Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben:
Verschiedene Klienten von Instanzen dieser Klasse könnten dann jeweils entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, und zwar abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.
Umgangen werden kann diese Zugriffsbeschränkung über Interfaces in JAVA immer dann, wenn die Klasse, von der das verwendete Objekt eine Instanz ist, ebenfalls als Typ zur Verfügung steht. Man kann in Variablendeklarationen dann genauso gut die Klasse als Typ verwenden. So könnte man sowohl in ""WillNurLesen"" die Variable ""eingabe"" als auch in ""WillNurSchreiben"" die Variable ""ausgabe"" mit dem Typ ""IOStream"" deklarieren, hätte damit jedoch keine syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr. C# geht hier einen Schritt weiter und ermöglicht Klassendefinitionen zumindest, ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen (s. Kurseinheit 5, Abschnitt 50.4.2). Seit JAVA 8 kann man allerdings in Interfaces auch statische Methoden definieren, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff mehr auf die Klassen, die deswegen als package local deklariert und die somit vollständig hinter dem Interface als Schnittstelle verborgen werden können.
Interfaces dienen aber nicht nur der Beschränkung des Zugriffs wie im obigen Beispiel — sie dienen auch der besseren Austauschbarkeit von Klassen. Und das bringt uns zurück zum eingangs in Kapitel 43 benutzten Beispiel (Zeile 1051 ff.): Dadurch, dass die Variable ""liste"" mit dem Typ ""List"" (ein Interface) und nicht ""ArrayList"" (eine Klasse) deklariert wurde, können ihr auch Instanzen anderer Klassen als ""ArrayList"" zugewiesen werden, solange sie nur dasselbe Interface implementieren. Das Interface als Typ der Variable verlangt lediglich, dass alle in ihm versammelten Methoden von den Objekten, auf die die Variable per Typsystem verweisen darf, auch angeboten werden, und das wird dadurch sichergestellt, dass der Typ der rechten Seite aller Zuweisungen zur Variablen konform zum Typ der linken Seite sein muss. Die Zuweisungskompatibilität ist in JAVA also an die Typkonformität gebunden, und zwar an die nominale.
Eine weitere, vergleichsweise häufig verwendete Möglichkeit des Einsatzes von Interfaces ist die als sog. Tagging oder Marker interfaces. Ein Tagging oder Marker Interface hat in der Regel keine eigenen Methodendeklarationen, sondern dient lediglich der Filterung von Variablenwerten. ""Serializable"" wäre ein solches Interface. Da in JAVA die vom Compiler statisch geprüfte Zuweisungskompatibilität ja Namenskonformität verlangt, kann die Typisierung einer Variable mit dem Interface ""Markiert"" erzwingen, dass dieser Variable nur Instanzen solcher Klassen zugewiesen werden, die das Interface ""Markiert"" zu implementieren deklarieren. Da das Interface aber keine Auflagen macht (keine Methodendeklarationen vorgibt, die von der Klasse mit Definitionen versehen werden müssen), ist die Implementierung des Interfaces für die Klasse zunächst ohne Konsequenzen. Die durch das Interface erfolgte Markierung der Klassen (bzw. deren Instanzen) kann jedoch zur Übersetzungszeit vom Compiler (s. o.) und zur Laufzeit durch einen Typtest (s. Abschnitt 44.2) überprüft werden.
Ein konkretes Beispiel für ein Marker-Interface in JAVA ist das Interface ""Serializable"", mit dessen Implementierung eine Klasse deklariert, dass ihre Instanzen serialisiert werden können. Die Serialisierung wird aber nicht von der Klasse selbst vorgenommen, sondern von einer anderen; die Klasse muss also zu ihrer Serialisierung nichts weiter beitragen. Seit JAVA 5 würde man allerdings solche Marker-Interfaces eher durch Metadaten (auch Annotationen genannt; s. Abschnitt 47.4) ersetzen, so wie das in C# schon länger gehandhabt wird (s. Abschnitt 50.4 in Kurseinheit 5). Interfaces erhöhen
JAVAs Interface-als-Typ-Konzept ist ziemlich interessant und vielleicht sogar der größte einzelne Beitrag JAVAs zur objektorientierten Programmierung. In der Programmierpraxis scheint es jedoch, sieht man einmal von großen Frameworks ab, nur langsam anzukommen. Das mag zum einen an der schlechten Verkaufsstrategie liegen („Ersatz für Mehrfachvererbung“ — jede Anfängerin merkt nach fünf Minuten, dass das nicht stimmt), zum anderen aber auch an der Vergrößerung des Programmumfangs, die der parallelen Definition von Klassen und Interfaces geschuldet ist (die auch den Wartungsaufwand erhöhen kann, obwohl ja Interfaces eigentlich die Wartung vereinfachen sollen). Für so manche Programmiererin scheinen die Möglichkeiten, die Schnittstelle einer Klasse mittels der Zugriffsmodifikatoren innerhalb der Klasse selbst zu definieren, völlig auszureichen. Der Preis dafür ist eine mangelnde Differenzierbarkeit des Zugriffs nach verschiedenen Klienten sowie eine (häufig vorschnelle) Festlegung von Variablen auf Instanzen einer Klasse.","<answer> Marker-Interfaces werden in Java manchmal durch Metadaten (Annotationen) ersetzt, da Metadaten eine flexiblere Möglichkeit bieten, Informationen über Klassen oder Methoden zu kennzeichnen, ohne zusätzliche Schnittstellen zu definieren. Annotations können zur Laufzeit oder zur Übersetzungszeit gelesen und interpretiert werden, während Marker-Interfaces nur zur Übersetzungszeit überprüft werden können. Dies bietet mehr Flexibilität und ermöglicht es, zusätzliche Informationen zu annotieren, ohne die Klassenhierarchie zu ändern. <answer> <question> Warum werden Marker-Interfaces in Java manchmal durch Metadaten (Annotationen) ersetzt? <question>"
"Ein weiteres Kennzeichen der objektorientierten Programmierung ist, dass Klassen nicht ins Uferlose wachsen sollten. Wenn der Methodenumfang einer Klasse immer weiter ansteigt, wird die erfahrene objektorientierte Programmiererin bald den Verdacht schöpfen, dass es sich bei der Klasse in Wirklichkeit nicht um eine, sondern um mehrere handelt. Dafür gibt es zwei Erklärungen: Die Klasse steht nicht nur für eine Abstraktion der Anwendungsdomäne, sondern für mehrere. In diesem Fall sollte die Aufteilung der Klasse in mehrere Teilklassen – eine für jede Abstraktion – leicht fallen: Sie ordnen zunächst die Daten den Abstraktionen (Allgemeinbegriffen) zu und lassen dann die Methoden den Daten folgen. Die Klasse steht zwar für eine Abstraktion der Anwendungsdomäne, aber dies auf einem höheren Abstraktionsniveau als das der Implementierung, die Sie gerade betrachten. Dafür gibt es wiederum mindestens zwei mögliche Erklärungen: a. Die Abstraktion ist eine Generalisierung (s. Kurseinheit 1, Abschnitt 9.1), und Sie haben alle ihre Spezialisierungen in einer Klasse zusammengefasst. In diesem Fall müssen Sie lediglich die unterschiedlichen Spezialisierungen identifizieren und die jeweils darauf bezogenen (dafür charakteristischen) Daten und Funktionen in neu zu schaffende Subklassen verlagern. Lediglich das allen Fällen gemeinsame Protokoll verbleibt dann in der (idealerweise abstrakten) neuen Superklasse. Ein guter Indikator für diesen Fall ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen (vgl. dazu auch das sog. ""Replace-conditional-with-polymorphism-Refactoring""). b. Die Abstraktion ist eine Aggregation (oder Komposition, s. Kurseinheit 1, Abschnitt 2.3), also eine Zusammensetzung eines Ganzen aus mehreren Teilen. In diesem Fall müssen Sie die Teile als logische Einheiten identifizieren und dafür neue Klassen formulieren. Falls diese neuen Klassen außerhalb der Abstraktion keine Bedeutung haben, können Sie in Erwägung ziehen, sie als innere Klassen zu deklarieren (sofern Ihre Programmiersprache dies erlaubt), um den Namensraum nicht unnötig zu überfrachten und die von anderen wahrgenommene Anzahl der Klassen nicht unnötig zu erhöhen.","<answer> Ein wichtiges Merkmal der objektorientierten Programmierung ist, dass Klassen nicht ins Uferlose wachsen sollten. Wenn der Methodenumfang einer Klasse zu groß wird, deutet dies darauf hin, dass die Klasse möglicherweise mehrere Abstraktionen repräsentiert oder auf einem höheren Abstraktionsniveau steht als die aktuelle Implementierung. <answer> <question> Was ist ein wichtiges Merkmal der objektorientierten Programmierung in Bezug auf die Größe von Klassen? <question>"
"Ein weiteres Kennzeichen der objektorientierten Programmierung ist, dass Klassen nicht ins Uferlose wachsen sollten. Wenn der Methodenumfang einer Klasse immer weiter ansteigt, wird die erfahrene objektorientierte Programmiererin bald den Verdacht schöpfen, dass es sich bei der Klasse in Wirklichkeit nicht um eine, sondern um mehrere handelt. Dafür gibt es zwei Erklärungen: Die Klasse steht nicht nur für eine Abstraktion der Anwendungsdomäne, sondern für mehrere. In diesem Fall sollte die Aufteilung der Klasse in mehrere Teilklassen – eine für jede Abstraktion – leicht fallen: Sie ordnen zunächst die Daten den Abstraktionen (Allgemeinbegriffen) zu und lassen dann die Methoden den Daten folgen. Die Klasse steht zwar für eine Abstraktion der Anwendungsdomäne, aber dies auf einem höheren Abstraktionsniveau als das der Implementierung, die Sie gerade betrachten. Dafür gibt es wiederum mindestens zwei mögliche Erklärungen: a. Die Abstraktion ist eine Generalisierung (s. Kurseinheit 1, Abschnitt 9.1), und Sie haben alle ihre Spezialisierungen in einer Klasse zusammengefasst. In diesem Fall müssen Sie lediglich die unterschiedlichen Spezialisierungen identifizieren und die jeweils darauf bezogenen (dafür charakteristischen) Daten und Funktionen in neu zu schaffende Subklassen verlagern. Lediglich das allen Fällen gemeinsame Protokoll verbleibt dann in der (idealerweise abstrakten) neuen Superklasse. Ein guter Indikator für diesen Fall ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen (vgl. dazu auch das sog. ""Replace-conditional-with-polymorphism-Refactoring""). b. Die Abstraktion ist eine Aggregation (oder Komposition, s. Kurseinheit 1, Abschnitt 2.3), also eine Zusammensetzung eines Ganzen aus mehreren Teilen. In diesem Fall müssen Sie die Teile als logische Einheiten identifizieren und dafür neue Klassen formulieren. Falls diese neuen Klassen außerhalb der Abstraktion keine Bedeutung haben, können Sie in Erwägung ziehen, sie als innere Klassen zu deklarieren (sofern Ihre Programmiersprache dies erlaubt), um den Namensraum nicht unnötig zu überfrachten und die von anderen wahrgenommene Anzahl der Klassen nicht unnötig zu erhöhen.","<answer> Es gibt zwei mögliche Gründe, warum eine Klasse in der objektorientierten Programmierung zu groß werden kann: Die Klasse repräsentiert nicht nur eine Abstraktion der Anwendungsdomäne, sondern mehrere. In diesem Fall sollte die Klasse in mehrere Teilklassen aufgeteilt werden, wobei jede Teilklassen eine Abstraktion darstellt, und die Daten und Methoden entsprechend zugeordnet werden. Die Klasse repräsentiert eine Abstraktion der Anwendungsdomäne auf einem höheren Abstraktionsniveau als die aktuelle Implementierung. Dies kann entweder bedeuten, dass die Klasse eine Generalisierung darstellt und alle Spezialisierungen in einer Klasse zusammengefasst sind oder dass die Klasse eine Aggregation oder Komposition darstellt und Teile als logische Einheiten identifiziert werden müssen. <answer> <question> Welche Gründe können dazu führen, dass eine Klasse in der objektorientierten Programmierung zu groß wird? <question>"
"Ein weiteres Kennzeichen der objektorientierten Programmierung ist, dass Klassen nicht ins Uferlose wachsen sollten. Wenn der Methodenumfang einer Klasse immer weiter ansteigt, wird die erfahrene objektorientierte Programmiererin bald den Verdacht schöpfen, dass es sich bei der Klasse in Wirklichkeit nicht um eine, sondern um mehrere handelt. Dafür gibt es zwei Erklärungen: Die Klasse steht nicht nur für eine Abstraktion der Anwendungsdomäne, sondern für mehrere. In diesem Fall sollte die Aufteilung der Klasse in mehrere Teilklassen – eine für jede Abstraktion – leicht fallen: Sie ordnen zunächst die Daten den Abstraktionen (Allgemeinbegriffen) zu und lassen dann die Methoden den Daten folgen. Die Klasse steht zwar für eine Abstraktion der Anwendungsdomäne, aber dies auf einem höheren Abstraktionsniveau als das der Implementierung, die Sie gerade betrachten. Dafür gibt es wiederum mindestens zwei mögliche Erklärungen: a. Die Abstraktion ist eine Generalisierung (s. Kurseinheit 1, Abschnitt 9.1), und Sie haben alle ihre Spezialisierungen in einer Klasse zusammengefasst. In diesem Fall müssen Sie lediglich die unterschiedlichen Spezialisierungen identifizieren und die jeweils darauf bezogenen (dafür charakteristischen) Daten und Funktionen in neu zu schaffende Subklassen verlagern. Lediglich das allen Fällen gemeinsame Protokoll verbleibt dann in der (idealerweise abstrakten) neuen Superklasse. Ein guter Indikator für diesen Fall ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen (vgl. dazu auch das sog. ""Replace-conditional-with-polymorphism-Refactoring""). b. Die Abstraktion ist eine Aggregation (oder Komposition, s. Kurseinheit 1, Abschnitt 2.3), also eine Zusammensetzung eines Ganzen aus mehreren Teilen. In diesem Fall müssen Sie die Teile als logische Einheiten identifizieren und dafür neue Klassen formulieren. Falls diese neuen Klassen außerhalb der Abstraktion keine Bedeutung haben, können Sie in Erwägung ziehen, sie als innere Klassen zu deklarieren (sofern Ihre Programmiersprache dies erlaubt), um den Namensraum nicht unnötig zu überfrachten und die von anderen wahrgenommene Anzahl der Klassen nicht unnötig zu erhöhen.","<answer> Wenn eine Klasse zu groß wird, sollten die folgenden Schritte unternommen werden, abhängig von der Ursache der Größe: Wenn die Klasse mehrere Abstraktionen repräsentiert, sollte die Klasse in mehrere Teilklassen aufgeteilt werden, wobei jede Teilklassen eine Abstraktion darstellt, und die Daten und Methoden entsprechend zugeordnet werden. Wenn die Klasse eine Generalisierung darstellt, sollten die unterschiedlichen Spezialisierungen identifiziert und die jeweils darauf bezogenen Daten und Funktionen in neu zu schaffende Subklassen verlagert werden. Das gemeinsame Protokoll sollte idealerweise in der neuen Superklasse verbleiben. Wenn die Klasse eine Aggregation oder Komposition darstellt, sollten die Teile als logische Einheiten identifiziert und neue Klassen formuliert werden. Falls diese neuen Klassen außerhalb der Abstraktion keine Bedeutung haben, kann in Erwägung gezogen werden, sie als innere Klassen zu deklarieren, um den Namensraum nicht unnötig zu überfrachten und die Anzahl der wahrgenommenen Klassen nicht unnötig zu erhöhen. <answer> <question> Welche Schritte sollten unternommen werden, wenn eine Klasse zu groß wird? <question>"
"Wir kommen nun zu einer der wichtigsten Ausprägungen des ""Alles-ist-ein-Objekt""-Mottos von SMALLTALK: den Blöcken. Genau wie eine Methode ist ein Block eine abgegrenzte Sequenz oder Folge von Anweisungen. Anders als eine Methode ist ein Block jedoch nicht benannt, kann aber benannt werden, indem er einer Variable zugewiesen wird.
Um auszudrücken, dass eine Sequenz von Ausdrücken ein Block ist, wird die Sequenz mit eckigen Klammern markiert. So ist die Definition eines Blocks, der aus der Deklaration der Variable ""temp"" und drei Zuweisungen besteht. Die Variablen ""x"" und ""y"" sind dabei außerhalb des Blocks im Kontext des Blocks deklariert. Der Kontext des Blocks ist die Methode, in der er definiert wurde.
Bei der Ausführung des obigen Blocks wird ein neues Blockobjekt erzeugt. Mittels := wird der Block einer Variable ""swap"" zugewiesen. Die Anweisungen, die den Block ausmachen, werden dabei nicht ausgeführt, selbst dann nicht, wenn der Block (wie in Zeile 175) isoliert steht und ausgeführt wird (das dabei erzeugte Objekt bleibt namenlos und wird von der Speicherbereinigung wieder entfernt).
Um die Anweisungen, die einen Block ausmachen, zur Ausführung zu bringen, muss man ihn auswerten. Dazu schickt man ihm die Nachricht ""value"". Der Ausdruck ""swap value"" bewirkt, dass die Variablen ""x"" und ""y"" aus dem Kontext des Blocks ihren Wert tauschen. Das Objekt, zu dem ""swap value"" ausgewertet wird, ist das Objekt, zu dem die letzte Anweisung auswertet (siehe Abschnitt 4.2). Im obigen Beispiel ist es also der Inhalt von ""temp,"" der derselbe ist wie der von ""x"" aus dem Kontext.
Der Rückgabewert der Methode ""value"" ist zunächst immer das Objekt, zu dem der letzte Ausdruck eines Blocks auswertet, im obigen Beispiel also das durch ""temp"" benannte Objekt.","<answer> Ein Block in SMALLTALK ist eine abgegrenzte Sequenz oder Folge von Anweisungen. Anders als eine Methode ist ein Block nicht benannt, kann aber einer Variable zugewiesen werden. <answer> <question> Was ist ein Block in SMALLTALK? <question>"
"Wir kommen nun zu einer der wichtigsten Ausprägungen des ""Alles-ist-ein-Objekt""-Mottos von SMALLTALK: den Blöcken. Genau wie eine Methode ist ein Block eine abgegrenzte Sequenz oder Folge von Anweisungen. Anders als eine Methode ist ein Block jedoch nicht benannt, kann aber benannt werden, indem er einer Variable zugewiesen wird.
Um auszudrücken, dass eine Sequenz von Ausdrücken ein Block ist, wird die Sequenz mit eckigen Klammern markiert. So ist die Definition eines Blocks, der aus der Deklaration der Variable ""temp"" und drei Zuweisungen besteht. Die Variablen ""x"" und ""y"" sind dabei außerhalb des Blocks im Kontext des Blocks deklariert. Der Kontext des Blocks ist die Methode, in der er definiert wurde.
Bei der Ausführung des obigen Blocks wird ein neues Blockobjekt erzeugt. Mittels := wird der Block einer Variable ""swap"" zugewiesen. Die Anweisungen, die den Block ausmachen, werden dabei nicht ausgeführt, selbst dann nicht, wenn der Block (wie in Zeile 175) isoliert steht und ausgeführt wird (das dabei erzeugte Objekt bleibt namenlos und wird von der Speicherbereinigung wieder entfernt).
Um die Anweisungen, die einen Block ausmachen, zur Ausführung zu bringen, muss man ihn auswerten. Dazu schickt man ihm die Nachricht ""value"". Der Ausdruck ""swap value"" bewirkt, dass die Variablen ""x"" und ""y"" aus dem Kontext des Blocks ihren Wert tauschen. Das Objekt, zu dem ""swap value"" ausgewertet wird, ist das Objekt, zu dem die letzte Anweisung auswertet (siehe Abschnitt 4.2). Im obigen Beispiel ist es also der Inhalt von ""temp,"" der derselbe ist wie der von ""x"" aus dem Kontext.
Der Rückgabewert der Methode ""value"" ist zunächst immer das Objekt, zu dem der letzte Ausdruck eines Blocks auswertet, im obigen Beispiel also das durch ""temp"" benannte Objekt.","<answer> Um auszudrücken, dass eine Sequenz von Ausdrücken ein Block ist, wird die Sequenz mit eckigen Klammern markiert, z. B. [ ... ]. <answer> <question> Wie kennzeichnet man in SMALLTALK eine Sequenz von Ausdrücken als Block? <question>"
"Wir kommen nun zu einer der wichtigsten Ausprägungen des ""Alles-ist-ein-Objekt""-Mottos von SMALLTALK: den Blöcken. Genau wie eine Methode ist ein Block eine abgegrenzte Sequenz oder Folge von Anweisungen. Anders als eine Methode ist ein Block jedoch nicht benannt, kann aber benannt werden, indem er einer Variable zugewiesen wird.
Um auszudrücken, dass eine Sequenz von Ausdrücken ein Block ist, wird die Sequenz mit eckigen Klammern markiert. So ist die Definition eines Blocks, der aus der Deklaration der Variable ""temp"" und drei Zuweisungen besteht. Die Variablen ""x"" und ""y"" sind dabei außerhalb des Blocks im Kontext des Blocks deklariert. Der Kontext des Blocks ist die Methode, in der er definiert wurde.
Bei der Ausführung des obigen Blocks wird ein neues Blockobjekt erzeugt. Mittels := wird der Block einer Variable ""swap"" zugewiesen. Die Anweisungen, die den Block ausmachen, werden dabei nicht ausgeführt, selbst dann nicht, wenn der Block (wie in Zeile 175) isoliert steht und ausgeführt wird (das dabei erzeugte Objekt bleibt namenlos und wird von der Speicherbereinigung wieder entfernt).
Um die Anweisungen, die einen Block ausmachen, zur Ausführung zu bringen, muss man ihn auswerten. Dazu schickt man ihm die Nachricht ""value"". Der Ausdruck ""swap value"" bewirkt, dass die Variablen ""x"" und ""y"" aus dem Kontext des Blocks ihren Wert tauschen. Das Objekt, zu dem ""swap value"" ausgewertet wird, ist das Objekt, zu dem die letzte Anweisung auswertet (siehe Abschnitt 4.2). Im obigen Beispiel ist es also der Inhalt von ""temp,"" der derselbe ist wie der von ""x"" aus dem Kontext.
Der Rückgabewert der Methode ""value"" ist zunächst immer das Objekt, zu dem der letzte Ausdruck eines Blocks auswertet, im obigen Beispiel also das durch ""temp"" benannte Objekt.","<answer> Um die Anweisungen, die einen Block ausmachen, zur Ausführung zu bringen, muss man ihn auswerten, indem man ihm die Nachricht ""value"" sendet. <answer> <question> Wie werden Blöcke in SMALLTALK ausgeführt? <question>"
"Wir kommen nun zu einer der wichtigsten Ausprägungen des ""Alles-ist-ein-Objekt""-Mottos von SMALLTALK: den Blöcken. Genau wie eine Methode ist ein Block eine abgegrenzte Sequenz oder Folge von Anweisungen. Anders als eine Methode ist ein Block jedoch nicht benannt, kann aber benannt werden, indem er einer Variable zugewiesen wird.
Um auszudrücken, dass eine Sequenz von Ausdrücken ein Block ist, wird die Sequenz mit eckigen Klammern markiert. So ist die Definition eines Blocks, der aus der Deklaration der Variable ""temp"" und drei Zuweisungen besteht. Die Variablen ""x"" und ""y"" sind dabei außerhalb des Blocks im Kontext des Blocks deklariert. Der Kontext des Blocks ist die Methode, in der er definiert wurde.
Bei der Ausführung des obigen Blocks wird ein neues Blockobjekt erzeugt. Mittels := wird der Block einer Variable ""swap"" zugewiesen. Die Anweisungen, die den Block ausmachen, werden dabei nicht ausgeführt, selbst dann nicht, wenn der Block (wie in Zeile 175) isoliert steht und ausgeführt wird (das dabei erzeugte Objekt bleibt namenlos und wird von der Speicherbereinigung wieder entfernt).
Um die Anweisungen, die einen Block ausmachen, zur Ausführung zu bringen, muss man ihn auswerten. Dazu schickt man ihm die Nachricht ""value"". Der Ausdruck ""swap value"" bewirkt, dass die Variablen ""x"" und ""y"" aus dem Kontext des Blocks ihren Wert tauschen. Das Objekt, zu dem ""swap value"" ausgewertet wird, ist das Objekt, zu dem die letzte Anweisung auswertet (siehe Abschnitt 4.2). Im obigen Beispiel ist es also der Inhalt von ""temp,"" der derselbe ist wie der von ""x"" aus dem Kontext.
Der Rückgabewert der Methode ""value"" ist zunächst immer das Objekt, zu dem der letzte Ausdruck eines Blocks auswertet, im obigen Beispiel also das durch ""temp"" benannte Objekt.","<answer> Der Rückgabewert der Methode ""value"" ist zunächst immer das Objekt, zu dem der letzte Ausdruck eines Blocks auswertet. <answer> <question> Was ist der Rückgabewert der Methode ""value"" bei der Ausführung eines Blocks? <question>"
"Wenn Sie If und While schon kennen, kennen Sie sicher auch For. Die klassische Form der For-Schleife verwendet eine Zählvariable, einen Anfangswert, ein Inkrement (das auch negativ, also ein Dekrement sein kann) sowie einen Endwert. Solche For-Schleifen gibt es in SMALLTALK auch. Zum Beispiel gibt der Transcript die Folge „531“ aus.
Wir schauen uns den Ausdruck aus Zeile 219 einmal genauer an. Dem Objekt 5 wird offenbar eine Nachricht to:by:do: gesendet, wobei 5 der Startwert ist, 1 der Parameter zu to:, -2 der Endwert zu by:, und ein Block für do: angegeben wird. Der Block stellt offenbar, ähnlich wie bei der Realisierung der While-Schleife in SMALLTALK, den Schleifenrumpf dar. Er hat einen Parameter i, der anscheinend als Zählvariable fungiert. Tatsächlich wird die Methode to:by:do: in SMALLTALK EXPRESS wie folgt implementiert:
Hier interessiert uns aber vor allem eine Form der Iteration, die nicht einer einfachen Zählschleife entspricht, sondern über eine Menge von beliebigen Objekten geht. Solche Mengen sind uns ja schon begegnet, wenn auch nur in Gestalt von literalen Arrays.
Anders als in vielen anderen Sprachen kann man in SMALLTALK über die Elemente eines Arrays direkt, also ohne die Verwendung einer Zählschleife, deren Laufvariable als Index in das Array dient, iterieren. So hat die Auswertung des Ausdrucks genau das gleiche Ergebnis wie die des Ausdrucks aus Zeile 219, nämlich die Ausgabe von „531“ auf dem Transcript. i ist aber diesmal keine Zählvariable, da hier nichts gezählt wird; es ist vielmehr eine Laufvariable, der der Reihe nach die Elemente des literalen Arrays #(5) zugewiesen werden. do: ersetzt also ganz offensichtlich das aus manchen anderen Sprachen (seit der Version 5.0 auch aus JAVA) bekannte For-each-Konstrukt.
Wie wir gleich sehen werden, ist die Iteration, also das Fortschalten der Elemente und die Überprüfung der Abbruchbedingung, in der Collection, über die iteriert wird, implementiert. Deshalb nennt man dieses Verfahren auch interne Iteration (im Gegensatz zur herkömmlichen externen Iteration, bei der die Laufvariable selbst gesetzt und abgefragt werden muss).
Die Implementierung der Kontrollstruktur erfolgt wiederum selbst in SMALLTALK und ist ziemlich einfach. Dabei ist to:do: für Ganzahlen analog zu dem bereits erwähnten to:by:do implementiert. Die Zählvariable index des Blocks in Zeile 238 läuft von 1 bis zur Anzahl der indizierten Instanzvariablen des Empfängers von do: (im obigen Beispiel ein Array). Diese Anzahl wird über den Aufruf von size auf dem Empfänger (repräsentiert durch self) abgefragt. Der Inhalt der indizierten Instanzvariable n des Empfängers wird dann der Reihe nach als Parameter mittels value: an den Block aBlock zur Auswertung geschickt.","<answer> Die Iteration in SMALLTALK erfolgt durch eine Form der internen Iteration, bei der die Steuerstruktur für das Fortschreiten durch Elemente und die Überprüfung der Abbruchbedingung innerhalb der Sammlung erfolgt, über die iteriert wird. Dies unterscheidet sich von der traditionellen externen Iteration, bei der Sie manuell eine Schleifenvariable als Index in die Sammlung verwalten müssen. In SMALLTALK können Sie direkt über die Elemente eines Arrays iterieren, und der Prozess des Fortschreitens durch die Elemente wird von der Sammlung selbst intern verwaltet. <answer> <question> Wie wird die Iteration in SMALLTALK implementiert, und was ist der Unterschied zwischen interner Iteration und traditioneller externer Iteration? <question>"
"Wenn Sie If und While schon kennen, kennen Sie sicher auch For. Die klassische Form der For-Schleife verwendet eine Zählvariable, einen Anfangswert, ein Inkrement (das auch negativ, also ein Dekrement sein kann) sowie einen Endwert. Solche For-Schleifen gibt es in SMALLTALK auch. Zum Beispiel gibt der Transcript die Folge „531“ aus.
Wir schauen uns den Ausdruck aus Zeile 219 einmal genauer an. Dem Objekt 5 wird offenbar eine Nachricht to:by:do: gesendet, wobei 5 der Startwert ist, 1 der Parameter zu to:, -2 der Endwert zu by:, und ein Block für do: angegeben wird. Der Block stellt offenbar, ähnlich wie bei der Realisierung der While-Schleife in SMALLTALK, den Schleifenrumpf dar. Er hat einen Parameter i, der anscheinend als Zählvariable fungiert. Tatsächlich wird die Methode to:by:do: in SMALLTALK EXPRESS wie folgt implementiert:
Hier interessiert uns aber vor allem eine Form der Iteration, die nicht einer einfachen Zählschleife entspricht, sondern über eine Menge von beliebigen Objekten geht. Solche Mengen sind uns ja schon begegnet, wenn auch nur in Gestalt von literalen Arrays.
Anders als in vielen anderen Sprachen kann man in SMALLTALK über die Elemente eines Arrays direkt, also ohne die Verwendung einer Zählschleife, deren Laufvariable als Index in das Array dient, iterieren. So hat die Auswertung des Ausdrucks genau das gleiche Ergebnis wie die des Ausdrucks aus Zeile 219, nämlich die Ausgabe von „531“ auf dem Transcript. i ist aber diesmal keine Zählvariable, da hier nichts gezählt wird; es ist vielmehr eine Laufvariable, der der Reihe nach die Elemente des literalen Arrays #(5) zugewiesen werden. do: ersetzt also ganz offensichtlich das aus manchen anderen Sprachen (seit der Version 5.0 auch aus JAVA) bekannte For-each-Konstrukt.
Wie wir gleich sehen werden, ist die Iteration, also das Fortschalten der Elemente und die Überprüfung der Abbruchbedingung, in der Collection, über die iteriert wird, implementiert. Deshalb nennt man dieses Verfahren auch interne Iteration (im Gegensatz zur herkömmlichen externen Iteration, bei der die Laufvariable selbst gesetzt und abgefragt werden muss).
Die Implementierung der Kontrollstruktur erfolgt wiederum selbst in SMALLTALK und ist ziemlich einfach. Dabei ist to:do: für Ganzahlen analog zu dem bereits erwähnten to:by:do implementiert. Die Zählvariable index des Blocks in Zeile 238 läuft von 1 bis zur Anzahl der indizierten Instanzvariablen des Empfängers von do: (im obigen Beispiel ein Array). Diese Anzahl wird über den Aufruf von size auf dem Empfänger (repräsentiert durch self) abgefragt. Der Inhalt der indizierten Instanzvariable n des Empfängers wird dann der Reihe nach als Parameter mittels value: an den Block aBlock zur Auswertung geschickt.","<answer> In SMALLTALK wird die Methode to:do: für Ganzzahlen verwendet, um eine Schleife zu erstellen, die über einen Bereich von Ganzzahlen iteriert. Sie nimmt zwei Argumente entgegen: einen Endwert und einen Block-Code, der während jeder Iteration ausgeführt werden soll. Die Schleifenvariable, die durch den Parameter i im Block repräsentiert wird, nimmt sequenziell Ganzzahlenwerte von 1 bis zum angegebenen Endwert an. Diese Methode simuliert eine Zählschleife, die den traditionellen for-Schleifen ähnelt, die in anderen Sprachen zu finden sind. Der wesentliche Unterschied besteht darin, dass in SMALLTALK die Steuerstruktur und der Schleifenmechanismus von der Methode to:do: selbst bereitgestellt werden, die die Iteration intern verwaltet. Im Gegensatz dazu müssen Sie in Sprachen mit traditionellen for-Schleifen in der Regel eine Schleifenvariable als Index in die Sammlung definieren und verwalten. <answer> <question> Können Sie erklären, wie die Methode to:do: für Ganzzahlen in SMALLTALK funktioniert und wie sie sich zu traditionellen for-Schleifen in anderen Sprachen verhält? <question>"
"Wer sich den Quellcode objektorientierter Programme ansieht, wird feststellen, dass die Methoden im Durchschnitt ziemlich kurz sind. Wie bereits in Kurseinheit 6, Kapitel 56 erwähnt, ist dies eine Folge des Umstandes, dass in der objektorientierten Programmierung die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Sobald eine Funktion verschiedene Arten von Daten manipuliert (also Objekte, die Instanzen verschiedener Klassen sind), ist es wahrscheinlich, dass diese Funktion nicht vollständig in einer Methode implementiert wird.
Was zunächst wie eine unmittelbare Folge des objektorientierten Paradigmas erscheint, hat sich zu einem objektorientierten Stil weiterentwickelt: Eine typische objektorientierte Programmiererin scheut sich nicht davor, Methoden zu schreiben, die nur aus einer Zeile bestehen (oder die nur eine Anweisung, wenn auch mit geschachtelten Ausdrücken, enthalten) – im Gegenteil, sie fühlt sich sogar gut dabei, denn was sie gerade produziert, gilt als objektorientierter Stil. So ist es sogar üblich, Teile einer Methode in eine neue auszulagern (das ""Extract-method""-Refactoring, das einige vielleicht aus ECLIPSE und ähnlichen Entwicklungsumgebungen kennen), auch wenn dieser Teil (zunächst) ausschließlich von seiner ursprünglichen Position aus aufgerufen wird, wenn es nur der besseren Lesbarkeit dient (insbesondere Wiederverwendung spielt keine Rolle). Ein positiver Nebeneffekt dieser starken Zerlegung von Funktionalität ist die hohe Dichte an Bezeichnern in objektorientierten Programmen: Da jede Teilfunktion, die in eine Methode ausgelagert wird, einen eigenen, eindeutigen Namen haben muss (bis auf Überladen/Überschreiben), wird die Programmiererin dazu gezwungen, sich ständig (in Form der Namenswahl für Bezeichner) dazu zu äußern, was sie gerade tut.","<answer> Die Methoden in objektorientierten Programmen sind im Durchschnitt ziemlich kurz, weil in der objektorientierten Programmierung die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Wenn eine Funktion verschiedene Arten von Daten manipuliert, wird die Funktionalität wahrscheinlich nicht vollständig in einer Methode implementiert. <answer> <question> Warum sind die Methoden in objektorientierten Programmen im Durchschnitt ziemlich kurz? <question>"
"Wer sich den Quellcode objektorientierter Programme ansieht, wird feststellen, dass die Methoden im Durchschnitt ziemlich kurz sind. Wie bereits in Kurseinheit 6, Kapitel 56 erwähnt, ist dies eine Folge des Umstandes, dass in der objektorientierten Programmierung die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Sobald eine Funktion verschiedene Arten von Daten manipuliert (also Objekte, die Instanzen verschiedener Klassen sind), ist es wahrscheinlich, dass diese Funktion nicht vollständig in einer Methode implementiert wird.
Was zunächst wie eine unmittelbare Folge des objektorientierten Paradigmas erscheint, hat sich zu einem objektorientierten Stil weiterentwickelt: Eine typische objektorientierte Programmiererin scheut sich nicht davor, Methoden zu schreiben, die nur aus einer Zeile bestehen (oder die nur eine Anweisung, wenn auch mit geschachtelten Ausdrücken, enthalten) – im Gegenteil, sie fühlt sich sogar gut dabei, denn was sie gerade produziert, gilt als objektorientierter Stil. So ist es sogar üblich, Teile einer Methode in eine neue auszulagern (das ""Extract-method""-Refactoring, das einige vielleicht aus ECLIPSE und ähnlichen Entwicklungsumgebungen kennen), auch wenn dieser Teil (zunächst) ausschließlich von seiner ursprünglichen Position aus aufgerufen wird, wenn es nur der besseren Lesbarkeit dient (insbesondere Wiederverwendung spielt keine Rolle). Ein positiver Nebeneffekt dieser starken Zerlegung von Funktionalität ist die hohe Dichte an Bezeichnern in objektorientierten Programmen: Da jede Teilfunktion, die in eine Methode ausgelagert wird, einen eigenen, eindeutigen Namen haben muss (bis auf Überladen/Überschreiben), wird die Programmiererin dazu gezwungen, sich ständig (in Form der Namenswahl für Bezeichner) dazu zu äußern, was sie gerade tut.","<answer> Kurze Methoden in der objektorientierten Programmierung fördern die Lesbarkeit und den objektorientierten Stil. Sie erlauben es, Teile einer Methode in separate, klar benannte Methoden auszulagern, was die Lesbarkeit und Wartbarkeit des Codes verbessert. Dieser Stil fördert auch die Verwendung von aussagekräftigen Bezeichnern und trägt zur besseren Dokumentation des Codes bei. <answer> <question> Welche Vorteile ergeben sich aus kurzen Methoden in der objektorientierten Programmierung? <question>"
"Wer sich den Quellcode objektorientierter Programme ansieht, wird feststellen, dass die Methoden im Durchschnitt ziemlich kurz sind. Wie bereits in Kurseinheit 6, Kapitel 56 erwähnt, ist dies eine Folge des Umstandes, dass in der objektorientierten Programmierung die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Sobald eine Funktion verschiedene Arten von Daten manipuliert (also Objekte, die Instanzen verschiedener Klassen sind), ist es wahrscheinlich, dass diese Funktion nicht vollständig in einer Methode implementiert wird.
Was zunächst wie eine unmittelbare Folge des objektorientierten Paradigmas erscheint, hat sich zu einem objektorientierten Stil weiterentwickelt: Eine typische objektorientierte Programmiererin scheut sich nicht davor, Methoden zu schreiben, die nur aus einer Zeile bestehen (oder die nur eine Anweisung, wenn auch mit geschachtelten Ausdrücken, enthalten) – im Gegenteil, sie fühlt sich sogar gut dabei, denn was sie gerade produziert, gilt als objektorientierter Stil. So ist es sogar üblich, Teile einer Methode in eine neue auszulagern (das ""Extract-method""-Refactoring, das einige vielleicht aus ECLIPSE und ähnlichen Entwicklungsumgebungen kennen), auch wenn dieser Teil (zunächst) ausschließlich von seiner ursprünglichen Position aus aufgerufen wird, wenn es nur der besseren Lesbarkeit dient (insbesondere Wiederverwendung spielt keine Rolle). Ein positiver Nebeneffekt dieser starken Zerlegung von Funktionalität ist die hohe Dichte an Bezeichnern in objektorientierten Programmen: Da jede Teilfunktion, die in eine Methode ausgelagert wird, einen eigenen, eindeutigen Namen haben muss (bis auf Überladen/Überschreiben), wird die Programmiererin dazu gezwungen, sich ständig (in Form der Namenswahl für Bezeichner) dazu zu äußern, was sie gerade tut.","<answer> Das ""Extract-method""-Refactoring-Verfahren wird häufig angewendet, um Teile einer Methode in separate Methoden auszulagern. Dieses Verfahren ermöglicht es, Teile des Codes in neue Methoden auszulagern, selbst wenn diese Teile vorerst nur von ihrer ursprünglichen Position aus aufgerufen werden, um die Lesbarkeit zu verbessern. Es handelt sich um eine gängige Praxis in der objektorientierten Programmierung. <answer> <question> Welches Refactoring-Verfahren wird häufig angewendet, um Teile einer Methode in separate Methoden auszulagern? <question>"
"Die Sequenz als Kontrollstruktur besagt lediglich, dass textuell aufeinanderfolgende Anweisungen eines Programms (einer Methode) auch zeitlich nacheinander ausgeführt werden. Die zeitliche Sequenz aufeinanderfolgender Anweisungen kann lediglich durch andere Kontrollstrukturen (in SMALLTALK nur durch den Methodenaufruf; siehe unten) unterbrochen werden. Dies gilt auch für parallele Ausführung, die man sich wie die gleichzeitige Abarbeitung zweier sequentieller Programme auf denselben Objekten vorstellen kann (siehe Kapitel 16).","<answer> Die Sequenz als Kontrollstruktur besagt lediglich, dass textuell aufeinanderfolgende Anweisungen eines Programms (einer Methode) auch zeitlich nacheinander ausgeführt werden. Die zeitliche Sequenz aufeinanderfolgender Anweisungen kann lediglich durch andere Kontrollstrukturen unterbrochen werden. <answer> <question> Was besagt die Sequenz als Kontrollstruktur in SMALLTALK? <question>"
"Die Sequenz als Kontrollstruktur besagt lediglich, dass textuell aufeinanderfolgende Anweisungen eines Programms (einer Methode) auch zeitlich nacheinander ausgeführt werden. Die zeitliche Sequenz aufeinanderfolgender Anweisungen kann lediglich durch andere Kontrollstrukturen (in SMALLTALK nur durch den Methodenaufruf; siehe unten) unterbrochen werden. Dies gilt auch für parallele Ausführung, die man sich wie die gleichzeitige Abarbeitung zweier sequentieller Programme auf denselben Objekten vorstellen kann (siehe Kapitel 16).",<answer> In SMALLTALK kann die zeitliche Sequenz von aufeinanderfolgenden Anweisungen nur durch den Methodenaufruf unterbrochen werden. <answer> <question> Welche Kontrollstrukturen können die zeitliche Sequenz von aufeinanderfolgenden Anweisungen unterbrechen? <question>
"Genau wie unparametrisierte (nicht generische) Typen in JAVA nicht aus eigenständigen Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces einhergehen, so werden auch parametrische (generische) Typen nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Da aber die formalen Typparameter einer Klassen- bzw. Interfacedefinition durch verschiedene Typen ersetzt werden können, wird die alte 1:1-Beziehung zwischen Klassen und Typen aufgebrochen: Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbesondere führt die „Instanziierung“68 einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Deswegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen den Typparameter als Typ verwenden und sich insofern unterscheiden.
Die klassische Anwendung generischer Typen findet man bei Collections: Genauso, wie man in JAVA Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt JAVA ähnlich wie SMALLTALK über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die JAVA-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition JAVAs, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen. Da es vor JAVA 5 keine Möglichkeit gab, bei der Deklaration einer Variable mit einer Collection als Typ anzugeben, welchen Typ die Elemente der Collection haben sollen, wurde implizit davon ausgegangen, dass diese vom Typ Object sind. So hatte z. B. die Klasse ArrayList ein (privates) Feld elementData vom Typ Object[], in dem die Elemente gespeichert wurden. Da Object der Supertyp aller Referenztypen in JAVA ist, konnten auch Instanzen aller Referenztypen in elementData und somit in Instanzen von ArrayList gespeichert werden.
Dank der generischen Typen ist es aber möglich, bei der Deklaration einer Variable vom Typ einer Collection — in Analogie zur Deklaration einer Variable vom Typ eines Arrays über einen Elementtyp — den Elementtyp mit anzugeben. Um beispielsweise eine Liste von Integern zu deklarieren und zu initialisieren, muss man lediglich List<Integer> liste = new ArrayList<>(); schreiben.
Dabei ist das in spitzen Klammern stehende E der (formale) Typparameter der Definition von ArrayList. Die bereits in Abschnitt 29.1 erwähnte Konvention, einzelne Großbuchstaben für Typparameter zu wählen, wurde auch in JAVA übernommen, ganz einfach, um Typparameter von Klassen- und Variablennamen im Programmtext besser unterscheiden zu können. So steht E üblicherweise für den Elementtyp von Containern, wie es die Collections sind. Durch die Sprachdefinition erzwungen wird das jedoch nicht.
Die Zuweisung von Zeile 1051 ist übrigens nur gültig, wenn der (parametrisierte) Typ ArrayList<Integer> Subtyp von List<Integer> ist. Dies wird, in JAVA-Syntax, durch die Deklaration List<Integer> liste; (nominales Subtyping) sichergestellt. Man beachte, dass die Variable E hier eine logische Bedingung ausdrückt, nämlich die, dass ein bei der Verwendung von ArrayList<E> angegebener tatsächlicher Typparameter auch in die Definition von List<E> eingesetzt werden muss.
Der Compiler weiß nun aufgrund der Ersetzung des formalen Parameters E mit dem tatsächlichen Parameter Integer in Zeile 1051, dass die Elemente der Variable liste alle vom Typ Integer sind und dass eine Zuweisung der Form get(0) = 42; typkorrekt ist. Um das zu überprüfen, muss er nämlich nur den Wert des Typparameters in der Deklaration von liste, Integer, in die Variable E der Implementierung von get einsetzen. Er kann dann feststellen, dass der Rückgabetyp des Ausdrucks mit der Variable zuweisungskompatibel ist. Man beachte, dass ohne Typparameter in Zeile 1064 eine Typumwandlung von Object auf Integer (Downcast) notwendig wäre, die aber zu einem Laufzeitfehler führen kann (s. Abschnitt 44.1). Die Einführung von Generics erhöht hingegen die Typsicherheit statisch, also zur Übersetzungszeit, ein fundamentaler Gewinn.
Nun wissen Sie ja bereits aus der Schilderung aus Kapitel 41, dass List<Integer> nicht unbedingt ein Subtyp von List<Object> sein sollte, selbst wenn Integer ein Subtyp von Object ist. Man hat den oben diskutierten Kompromiss offenbar nicht weiter fortführen wollen.","<answer> Parametrische (generische) Typen in Java werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Die formalen Typparameter in der Klassendefinition können durch verschiedene Typen ersetzt werden. <answer> <question> Wie werden parametrische (generische) Typen in Java definiert? <question>"
"Genau wie unparametrisierte (nicht generische) Typen in JAVA nicht aus eigenständigen Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces einhergehen, so werden auch parametrische (generische) Typen nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Da aber die formalen Typparameter einer Klassen- bzw. Interfacedefinition durch verschiedene Typen ersetzt werden können, wird die alte 1:1-Beziehung zwischen Klassen und Typen aufgebrochen: Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbesondere führt die „Instanziierung“68 einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Deswegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen den Typparameter als Typ verwenden und sich insofern unterscheiden.
Die klassische Anwendung generischer Typen findet man bei Collections: Genauso, wie man in JAVA Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt JAVA ähnlich wie SMALLTALK über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die JAVA-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition JAVAs, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen. Da es vor JAVA 5 keine Möglichkeit gab, bei der Deklaration einer Variable mit einer Collection als Typ anzugeben, welchen Typ die Elemente der Collection haben sollen, wurde implizit davon ausgegangen, dass diese vom Typ Object sind. So hatte z. B. die Klasse ArrayList ein (privates) Feld elementData vom Typ Object[], in dem die Elemente gespeichert wurden. Da Object der Supertyp aller Referenztypen in JAVA ist, konnten auch Instanzen aller Referenztypen in elementData und somit in Instanzen von ArrayList gespeichert werden.
Dank der generischen Typen ist es aber möglich, bei der Deklaration einer Variable vom Typ einer Collection — in Analogie zur Deklaration einer Variable vom Typ eines Arrays über einen Elementtyp — den Elementtyp mit anzugeben. Um beispielsweise eine Liste von Integern zu deklarieren und zu initialisieren, muss man lediglich List<Integer> liste = new ArrayList<>(); schreiben.
Dabei ist das in spitzen Klammern stehende E der (formale) Typparameter der Definition von ArrayList. Die bereits in Abschnitt 29.1 erwähnte Konvention, einzelne Großbuchstaben für Typparameter zu wählen, wurde auch in JAVA übernommen, ganz einfach, um Typparameter von Klassen- und Variablennamen im Programmtext besser unterscheiden zu können. So steht E üblicherweise für den Elementtyp von Containern, wie es die Collections sind. Durch die Sprachdefinition erzwungen wird das jedoch nicht.
Die Zuweisung von Zeile 1051 ist übrigens nur gültig, wenn der (parametrisierte) Typ ArrayList<Integer> Subtyp von List<Integer> ist. Dies wird, in JAVA-Syntax, durch die Deklaration List<Integer> liste; (nominales Subtyping) sichergestellt. Man beachte, dass die Variable E hier eine logische Bedingung ausdrückt, nämlich die, dass ein bei der Verwendung von ArrayList<E> angegebener tatsächlicher Typparameter auch in die Definition von List<E> eingesetzt werden muss.
Der Compiler weiß nun aufgrund der Ersetzung des formalen Parameters E mit dem tatsächlichen Parameter Integer in Zeile 1051, dass die Elemente der Variable liste alle vom Typ Integer sind und dass eine Zuweisung der Form get(0) = 42; typkorrekt ist. Um das zu überprüfen, muss er nämlich nur den Wert des Typparameters in der Deklaration von liste, Integer, in die Variable E der Implementierung von get einsetzen. Er kann dann feststellen, dass der Rückgabetyp des Ausdrucks mit der Variable zuweisungskompatibel ist. Man beachte, dass ohne Typparameter in Zeile 1064 eine Typumwandlung von Object auf Integer (Downcast) notwendig wäre, die aber zu einem Laufzeitfehler führen kann (s. Abschnitt 44.1). Die Einführung von Generics erhöht hingegen die Typsicherheit statisch, also zur Übersetzungszeit, ein fundamentaler Gewinn.
Nun wissen Sie ja bereits aus der Schilderung aus Kapitel 41, dass List<Integer> nicht unbedingt ein Subtyp von List<Object> sein sollte, selbst wenn Integer ein Subtyp von Object ist. Man hat den oben diskutierten Kompromiss offenbar nicht weiter fortführen wollen.","<answer> Eine Hauptanwendung generischer Typen in Java ist die Arbeit mit Collections, um den Typ der Elemente in der Collection anzugeben und so die Typsicherheit zu erhöhen. <answer> <question> Was ist die Hauptanwendung generischer Typen in Java? <question>"
"Genau wie unparametrisierte (nicht generische) Typen in JAVA nicht aus eigenständigen Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces einhergehen, so werden auch parametrische (generische) Typen nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Da aber die formalen Typparameter einer Klassen- bzw. Interfacedefinition durch verschiedene Typen ersetzt werden können, wird die alte 1:1-Beziehung zwischen Klassen und Typen aufgebrochen: Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbesondere führt die „Instanziierung“68 einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Deswegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen den Typparameter als Typ verwenden und sich insofern unterscheiden.
Die klassische Anwendung generischer Typen findet man bei Collections: Genauso, wie man in JAVA Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt JAVA ähnlich wie SMALLTALK über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die JAVA-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition JAVAs, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen. Da es vor JAVA 5 keine Möglichkeit gab, bei der Deklaration einer Variable mit einer Collection als Typ anzugeben, welchen Typ die Elemente der Collection haben sollen, wurde implizit davon ausgegangen, dass diese vom Typ Object sind. So hatte z. B. die Klasse ArrayList ein (privates) Feld elementData vom Typ Object[], in dem die Elemente gespeichert wurden. Da Object der Supertyp aller Referenztypen in JAVA ist, konnten auch Instanzen aller Referenztypen in elementData und somit in Instanzen von ArrayList gespeichert werden.
Dank der generischen Typen ist es aber möglich, bei der Deklaration einer Variable vom Typ einer Collection — in Analogie zur Deklaration einer Variable vom Typ eines Arrays über einen Elementtyp — den Elementtyp mit anzugeben. Um beispielsweise eine Liste von Integern zu deklarieren und zu initialisieren, muss man lediglich List<Integer> liste = new ArrayList<>(); schreiben.
Dabei ist das in spitzen Klammern stehende E der (formale) Typparameter der Definition von ArrayList. Die bereits in Abschnitt 29.1 erwähnte Konvention, einzelne Großbuchstaben für Typparameter zu wählen, wurde auch in JAVA übernommen, ganz einfach, um Typparameter von Klassen- und Variablennamen im Programmtext besser unterscheiden zu können. So steht E üblicherweise für den Elementtyp von Containern, wie es die Collections sind. Durch die Sprachdefinition erzwungen wird das jedoch nicht.
Die Zuweisung von Zeile 1051 ist übrigens nur gültig, wenn der (parametrisierte) Typ ArrayList<Integer> Subtyp von List<Integer> ist. Dies wird, in JAVA-Syntax, durch die Deklaration List<Integer> liste; (nominales Subtyping) sichergestellt. Man beachte, dass die Variable E hier eine logische Bedingung ausdrückt, nämlich die, dass ein bei der Verwendung von ArrayList<E> angegebener tatsächlicher Typparameter auch in die Definition von List<E> eingesetzt werden muss.
Der Compiler weiß nun aufgrund der Ersetzung des formalen Parameters E mit dem tatsächlichen Parameter Integer in Zeile 1051, dass die Elemente der Variable liste alle vom Typ Integer sind und dass eine Zuweisung der Form get(0) = 42; typkorrekt ist. Um das zu überprüfen, muss er nämlich nur den Wert des Typparameters in der Deklaration von liste, Integer, in die Variable E der Implementierung von get einsetzen. Er kann dann feststellen, dass der Rückgabetyp des Ausdrucks mit der Variable zuweisungskompatibel ist. Man beachte, dass ohne Typparameter in Zeile 1064 eine Typumwandlung von Object auf Integer (Downcast) notwendig wäre, die aber zu einem Laufzeitfehler führen kann (s. Abschnitt 44.1). Die Einführung von Generics erhöht hingegen die Typsicherheit statisch, also zur Übersetzungszeit, ein fundamentaler Gewinn.
Nun wissen Sie ja bereits aus der Schilderung aus Kapitel 41, dass List<Integer> nicht unbedingt ein Subtyp von List<Object> sein sollte, selbst wenn Integer ein Subtyp von Object ist. Man hat den oben diskutierten Kompromiss offenbar nicht weiter fortführen wollen.","<answer> Eine häufig verwendete Konvention ist es, einzelne Großbuchstaben für Typparameter zu wählen. Zum Beispiel steht ""E"" üblicherweise für den Elementtyp von Containern wie Collections. <answer> <question> Welche Konvention wird häufig verwendet, um Typparameter von Klassen- und Variablennamen zu unterscheiden? <question>"
"Genau wie unparametrisierte (nicht generische) Typen in JAVA nicht aus eigenständigen Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces einhergehen, so werden auch parametrische (generische) Typen nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Da aber die formalen Typparameter einer Klassen- bzw. Interfacedefinition durch verschiedene Typen ersetzt werden können, wird die alte 1:1-Beziehung zwischen Klassen und Typen aufgebrochen: Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbesondere führt die „Instanziierung“68 einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Deswegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen den Typparameter als Typ verwenden und sich insofern unterscheiden.
Die klassische Anwendung generischer Typen findet man bei Collections: Genauso, wie man in JAVA Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt JAVA ähnlich wie SMALLTALK über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die JAVA-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition JAVAs, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen. Da es vor JAVA 5 keine Möglichkeit gab, bei der Deklaration einer Variable mit einer Collection als Typ anzugeben, welchen Typ die Elemente der Collection haben sollen, wurde implizit davon ausgegangen, dass diese vom Typ Object sind. So hatte z. B. die Klasse ArrayList ein (privates) Feld elementData vom Typ Object[], in dem die Elemente gespeichert wurden. Da Object der Supertyp aller Referenztypen in JAVA ist, konnten auch Instanzen aller Referenztypen in elementData und somit in Instanzen von ArrayList gespeichert werden.
Dank der generischen Typen ist es aber möglich, bei der Deklaration einer Variable vom Typ einer Collection — in Analogie zur Deklaration einer Variable vom Typ eines Arrays über einen Elementtyp — den Elementtyp mit anzugeben. Um beispielsweise eine Liste von Integern zu deklarieren und zu initialisieren, muss man lediglich List<Integer> liste = new ArrayList<>(); schreiben.
Dabei ist das in spitzen Klammern stehende E der (formale) Typparameter der Definition von ArrayList. Die bereits in Abschnitt 29.1 erwähnte Konvention, einzelne Großbuchstaben für Typparameter zu wählen, wurde auch in JAVA übernommen, ganz einfach, um Typparameter von Klassen- und Variablennamen im Programmtext besser unterscheiden zu können. So steht E üblicherweise für den Elementtyp von Containern, wie es die Collections sind. Durch die Sprachdefinition erzwungen wird das jedoch nicht.
Die Zuweisung von Zeile 1051 ist übrigens nur gültig, wenn der (parametrisierte) Typ ArrayList<Integer> Subtyp von List<Integer> ist. Dies wird, in JAVA-Syntax, durch die Deklaration List<Integer> liste; (nominales Subtyping) sichergestellt. Man beachte, dass die Variable E hier eine logische Bedingung ausdrückt, nämlich die, dass ein bei der Verwendung von ArrayList<E> angegebener tatsächlicher Typparameter auch in die Definition von List<E> eingesetzt werden muss.
Der Compiler weiß nun aufgrund der Ersetzung des formalen Parameters E mit dem tatsächlichen Parameter Integer in Zeile 1051, dass die Elemente der Variable liste alle vom Typ Integer sind und dass eine Zuweisung der Form get(0) = 42; typkorrekt ist. Um das zu überprüfen, muss er nämlich nur den Wert des Typparameters in der Deklaration von liste, Integer, in die Variable E der Implementierung von get einsetzen. Er kann dann feststellen, dass der Rückgabetyp des Ausdrucks mit der Variable zuweisungskompatibel ist. Man beachte, dass ohne Typparameter in Zeile 1064 eine Typumwandlung von Object auf Integer (Downcast) notwendig wäre, die aber zu einem Laufzeitfehler führen kann (s. Abschnitt 44.1). Die Einführung von Generics erhöht hingegen die Typsicherheit statisch, also zur Übersetzungszeit, ein fundamentaler Gewinn.
Nun wissen Sie ja bereits aus der Schilderung aus Kapitel 41, dass List<Integer> nicht unbedingt ein Subtyp von List<Object> sein sollte, selbst wenn Integer ein Subtyp von Object ist. Man hat den oben diskutierten Kompromiss offenbar nicht weiter fortführen wollen.","<answer> Die Zuweisung von List<Integer> zu List<Object> führt zu einem statischen Typfehler in Java, weil bei generischen Typen nicht automatisch eine Zuweisungskompatibilität zwischen unterschiedlichen generischen Typen besteht, selbst wenn die Typen, die sie parametrisieren, zueinander in Beziehung stehen. Dies erhöht die Typsicherheit zur Übersetzungszeit. <answer> <question> Warum führt die Zuweisung von List<Integer> zu List<Object> zu einem statischen Typfehler in Java? <question>"
"Wie Sie bereits in den Anweisungen in Kapitel 38 gesehen haben, bietet JAVA ein sogenanntes Exception Handling. Beim Exception Handling handelt es sich um eine Möglichkeit, bei der Spezifikation des Kontrollflusses eines Programms zunächst mögliche Ausnahmesituationen und deren Behandlung unberücksichtigt zu lassen und so zu tun, als würde immer alles gutgehen. Da dies normalerweise der Fall sein sollte, erlaubt es sowohl der Autorin als auch dem Leser eines Programms, sich auf die Hauptfunktion zu konzentrieren, mit dem Motto ""Zu den Ausnahmen kommen wir später!""
Die möglichen Ausnahmesituationen eines Programms werden in JAVA in Klassen unterteilt, deren Instanzen jeweils eine konkrete Ausnahmesituation während des Programmablaufs repräsentieren. Wenn beispielsweise in einem Programm auf ein Element eines Arrays zugegriffen werden soll, dessen Index außerhalb der Grenzen des Arrays liegt, erzeugt die JVM, die über die Einhaltung der Array-Grenzen wacht, eine Instanz der Klasse ArrayIndexOutOfBoundsException und wirft diese. Das Werfen einer Exception (genauer gesagt, einer Instanz einer Exception-Klasse) bedeutet, dass der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt wird, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist. Dies erfordert, dass der Codeabschnitt, in dem die Exception auftreten kann, in einen Try-Catch-Block eingefasst wird.
Wenn der Typ der geworfenen Exception nicht in einer der Catch-Klauseln aufgeführt ist, wird die Exception als unbehandelt betrachtet, und die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung (""Exception in thread ..."").
Ausnahmesituationen können jedoch auch vom Programm selbst erkannt und gemeldet werden, indem die bereits erwähnte Throw-Anweisung verwendet wird, um eine entsprechende Exception-Klasse zu instanziieren. Dies ermöglicht es, die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.
Try-Catch-Anweisungen in JAVA werden, wie fast alle Anweisungen, im Körper von Methoden platziert. Wenn eine Methode eine bestimmte Exception wirft, ohne sie selbst abzufangen (d. h., wenn die Throw-Anweisung nicht innerhalb eines Try-Catch-Blocks verwendet wird, der eine passende Catch-Klausel enthält), muss die Methode dies deklarieren. Dies geschieht durch Hinzufügen einer Throws-Klausel zur Methodendeklaration.
Eine Methode, die die obige Methode aufruft, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft.
Diese Praxis kann zwar zu erheblichem Schreibaufwand führen, stellt jedoch die einzige Möglichkeit dar, sicherzustellen, dass die Programmierer sich der möglichen Ausnahmesituationen bewusst sind, ohne die Kontrollflussspezifikation übermäßig zu belasten. Exceptions, die eine Deklaration im Methodenkopf erfordern oder innerhalb der Methode behandelt werden müssen, werden als Checked Exceptions bezeichnet.
Es gibt jedoch auch Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Im Gegensatz zu Checked Exceptions können Unchecked Exceptions in der Praxis überall auftreten. Ein prominentes Beispiel ist die ""Out of Memory Exception"", die auftritt, wenn eine Speicheranforderung des Programms von der JVM nicht erfüllt werden kann. Eine weitere häufige, aber programmatisch vermeidbare Exception ist die ""Null Pointer Exception"", die auftritt, wenn ein Ausdruck, auf dem auf ein Feld oder eine Methode zugegriffen wird, zu null ausgewertet wird. In dieselbe Kategorie fällt auch die ""Array Index Out of Bounds Exception"", die durch sorgfältiges Programmieren vermieden werden könnte, aber dennoch häufig vorkommt.
Es wäre äußerst mühsam, jede Anweisung, bei der eine solche Exception auftreten könnte, mit einem Try-Catch-Block abzusichern. Daher gibt es in JAVA Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Die Unterscheidung, ob eine Exception als Checked oder Unchecked gilt, liegt nicht in der Hand der Programmiererin, die sie wirft, sondern erfolgt anhand der Vererbungshierarchie der Exception-Klassen. Alle Exceptions, die von der Klasse RuntimeException abgeleitet sind, werden per Definition als Unchecked betrachtet. RuntimeException selbst ist eine Subklasse der Klasse Exception, die wiederum eine Subklasse von Throwable ist. Throwable ist die Superklasse aller Klassen, die in Throw-Anweisungen, Catch-Zweigen und Throws-Klauseln verwendet werden dürfen. Mit RuntimeException wird also ein Zweig der Exception-Klassenhierarchie eingeleitet, dessen Elemente alle als Unchecked gelten.
Neben Exception ist auch Error eine Subklasse von Throwable. Errors sollten jedoch nicht abgefangen werden und führen zu einem sofortigen Programmabbruch. Auslassungszeichen stehen für die Formulierung einer Invariante, wurde früher zur Emulation der mittlerweile vorhandenen Assert-Anweisung verwendet. Auch heute sollte man Errors eigentlich nur während der Testphase eines Programms einsetzen. Genauso wie Exceptions der Sorte RuntimeException sind Errors unchecked.","<answer> Exception Handling ist eine Möglichkeit in JAVA, mögliche Ausnahmesituationen und deren Behandlung bei der Spezifikation des Kontrollflusses eines Programms vorübergehend zu vernachlässigen und so zu tun, als würde immer alles gutgehen. Ausnahmesituationen werden in JAVA in Form von Exception-Klassen dargestellt. <answer> <question> Was ist Exception Handling in JAVA? <question>"
"Wie Sie bereits in den Anweisungen in Kapitel 38 gesehen haben, bietet JAVA ein sogenanntes Exception Handling. Beim Exception Handling handelt es sich um eine Möglichkeit, bei der Spezifikation des Kontrollflusses eines Programms zunächst mögliche Ausnahmesituationen und deren Behandlung unberücksichtigt zu lassen und so zu tun, als würde immer alles gutgehen. Da dies normalerweise der Fall sein sollte, erlaubt es sowohl der Autorin als auch dem Leser eines Programms, sich auf die Hauptfunktion zu konzentrieren, mit dem Motto ""Zu den Ausnahmen kommen wir später!""
Die möglichen Ausnahmesituationen eines Programms werden in JAVA in Klassen unterteilt, deren Instanzen jeweils eine konkrete Ausnahmesituation während des Programmablaufs repräsentieren. Wenn beispielsweise in einem Programm auf ein Element eines Arrays zugegriffen werden soll, dessen Index außerhalb der Grenzen des Arrays liegt, erzeugt die JVM, die über die Einhaltung der Array-Grenzen wacht, eine Instanz der Klasse ArrayIndexOutOfBoundsException und wirft diese. Das Werfen einer Exception (genauer gesagt, einer Instanz einer Exception-Klasse) bedeutet, dass der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt wird, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist. Dies erfordert, dass der Codeabschnitt, in dem die Exception auftreten kann, in einen Try-Catch-Block eingefasst wird.
Wenn der Typ der geworfenen Exception nicht in einer der Catch-Klauseln aufgeführt ist, wird die Exception als unbehandelt betrachtet, und die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung (""Exception in thread ..."").
Ausnahmesituationen können jedoch auch vom Programm selbst erkannt und gemeldet werden, indem die bereits erwähnte Throw-Anweisung verwendet wird, um eine entsprechende Exception-Klasse zu instanziieren. Dies ermöglicht es, die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.
Try-Catch-Anweisungen in JAVA werden, wie fast alle Anweisungen, im Körper von Methoden platziert. Wenn eine Methode eine bestimmte Exception wirft, ohne sie selbst abzufangen (d. h., wenn die Throw-Anweisung nicht innerhalb eines Try-Catch-Blocks verwendet wird, der eine passende Catch-Klausel enthält), muss die Methode dies deklarieren. Dies geschieht durch Hinzufügen einer Throws-Klausel zur Methodendeklaration.
Eine Methode, die die obige Methode aufruft, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft.
Diese Praxis kann zwar zu erheblichem Schreibaufwand führen, stellt jedoch die einzige Möglichkeit dar, sicherzustellen, dass die Programmierer sich der möglichen Ausnahmesituationen bewusst sind, ohne die Kontrollflussspezifikation übermäßig zu belasten. Exceptions, die eine Deklaration im Methodenkopf erfordern oder innerhalb der Methode behandelt werden müssen, werden als Checked Exceptions bezeichnet.
Es gibt jedoch auch Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Im Gegensatz zu Checked Exceptions können Unchecked Exceptions in der Praxis überall auftreten. Ein prominentes Beispiel ist die ""Out of Memory Exception"", die auftritt, wenn eine Speicheranforderung des Programms von der JVM nicht erfüllt werden kann. Eine weitere häufige, aber programmatisch vermeidbare Exception ist die ""Null Pointer Exception"", die auftritt, wenn ein Ausdruck, auf dem auf ein Feld oder eine Methode zugegriffen wird, zu null ausgewertet wird. In dieselbe Kategorie fällt auch die ""Array Index Out of Bounds Exception"", die durch sorgfältiges Programmieren vermieden werden könnte, aber dennoch häufig vorkommt.
Es wäre äußerst mühsam, jede Anweisung, bei der eine solche Exception auftreten könnte, mit einem Try-Catch-Block abzusichern. Daher gibt es in JAVA Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Die Unterscheidung, ob eine Exception als Checked oder Unchecked gilt, liegt nicht in der Hand der Programmiererin, die sie wirft, sondern erfolgt anhand der Vererbungshierarchie der Exception-Klassen. Alle Exceptions, die von der Klasse RuntimeException abgeleitet sind, werden per Definition als Unchecked betrachtet. RuntimeException selbst ist eine Subklasse der Klasse Exception, die wiederum eine Subklasse von Throwable ist. Throwable ist die Superklasse aller Klassen, die in Throw-Anweisungen, Catch-Zweigen und Throws-Klauseln verwendet werden dürfen. Mit RuntimeException wird also ein Zweig der Exception-Klassenhierarchie eingeleitet, dessen Elemente alle als Unchecked gelten.
Neben Exception ist auch Error eine Subklasse von Throwable. Errors sollten jedoch nicht abgefangen werden und führen zu einem sofortigen Programmabbruch. Auslassungszeichen stehen für die Formulierung einer Invariante, wurde früher zur Emulation der mittlerweile vorhandenen Assert-Anweisung verwendet. Auch heute sollte man Errors eigentlich nur während der Testphase eines Programms einsetzen. Genauso wie Exceptions der Sorte RuntimeException sind Errors unchecked.","<answer> Wenn der Typ der geworfenen Exception nicht in einer Catch-Klausel aufgeführt ist, wird die Exception als unbehandelt betrachtet. Die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung (""Exception in thread ...""). <answer> <question> Was passiert, wenn der Typ der geworfenen Exception nicht in einer Catch-Klausel aufgeführt ist? <question>"
"Wie Sie bereits in den Anweisungen in Kapitel 38 gesehen haben, bietet JAVA ein sogenanntes Exception Handling. Beim Exception Handling handelt es sich um eine Möglichkeit, bei der Spezifikation des Kontrollflusses eines Programms zunächst mögliche Ausnahmesituationen und deren Behandlung unberücksichtigt zu lassen und so zu tun, als würde immer alles gutgehen. Da dies normalerweise der Fall sein sollte, erlaubt es sowohl der Autorin als auch dem Leser eines Programms, sich auf die Hauptfunktion zu konzentrieren, mit dem Motto ""Zu den Ausnahmen kommen wir später!""
Die möglichen Ausnahmesituationen eines Programms werden in JAVA in Klassen unterteilt, deren Instanzen jeweils eine konkrete Ausnahmesituation während des Programmablaufs repräsentieren. Wenn beispielsweise in einem Programm auf ein Element eines Arrays zugegriffen werden soll, dessen Index außerhalb der Grenzen des Arrays liegt, erzeugt die JVM, die über die Einhaltung der Array-Grenzen wacht, eine Instanz der Klasse ArrayIndexOutOfBoundsException und wirft diese. Das Werfen einer Exception (genauer gesagt, einer Instanz einer Exception-Klasse) bedeutet, dass der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt wird, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist. Dies erfordert, dass der Codeabschnitt, in dem die Exception auftreten kann, in einen Try-Catch-Block eingefasst wird.
Wenn der Typ der geworfenen Exception nicht in einer der Catch-Klauseln aufgeführt ist, wird die Exception als unbehandelt betrachtet, und die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung (""Exception in thread ..."").
Ausnahmesituationen können jedoch auch vom Programm selbst erkannt und gemeldet werden, indem die bereits erwähnte Throw-Anweisung verwendet wird, um eine entsprechende Exception-Klasse zu instanziieren. Dies ermöglicht es, die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.
Try-Catch-Anweisungen in JAVA werden, wie fast alle Anweisungen, im Körper von Methoden platziert. Wenn eine Methode eine bestimmte Exception wirft, ohne sie selbst abzufangen (d. h., wenn die Throw-Anweisung nicht innerhalb eines Try-Catch-Blocks verwendet wird, der eine passende Catch-Klausel enthält), muss die Methode dies deklarieren. Dies geschieht durch Hinzufügen einer Throws-Klausel zur Methodendeklaration.
Eine Methode, die die obige Methode aufruft, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft.
Diese Praxis kann zwar zu erheblichem Schreibaufwand führen, stellt jedoch die einzige Möglichkeit dar, sicherzustellen, dass die Programmierer sich der möglichen Ausnahmesituationen bewusst sind, ohne die Kontrollflussspezifikation übermäßig zu belasten. Exceptions, die eine Deklaration im Methodenkopf erfordern oder innerhalb der Methode behandelt werden müssen, werden als Checked Exceptions bezeichnet.
Es gibt jedoch auch Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Im Gegensatz zu Checked Exceptions können Unchecked Exceptions in der Praxis überall auftreten. Ein prominentes Beispiel ist die ""Out of Memory Exception"", die auftritt, wenn eine Speicheranforderung des Programms von der JVM nicht erfüllt werden kann. Eine weitere häufige, aber programmatisch vermeidbare Exception ist die ""Null Pointer Exception"", die auftritt, wenn ein Ausdruck, auf dem auf ein Feld oder eine Methode zugegriffen wird, zu null ausgewertet wird. In dieselbe Kategorie fällt auch die ""Array Index Out of Bounds Exception"", die durch sorgfältiges Programmieren vermieden werden könnte, aber dennoch häufig vorkommt.
Es wäre äußerst mühsam, jede Anweisung, bei der eine solche Exception auftreten könnte, mit einem Try-Catch-Block abzusichern. Daher gibt es in JAVA Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Die Unterscheidung, ob eine Exception als Checked oder Unchecked gilt, liegt nicht in der Hand der Programmiererin, die sie wirft, sondern erfolgt anhand der Vererbungshierarchie der Exception-Klassen. Alle Exceptions, die von der Klasse RuntimeException abgeleitet sind, werden per Definition als Unchecked betrachtet. RuntimeException selbst ist eine Subklasse der Klasse Exception, die wiederum eine Subklasse von Throwable ist. Throwable ist die Superklasse aller Klassen, die in Throw-Anweisungen, Catch-Zweigen und Throws-Klauseln verwendet werden dürfen. Mit RuntimeException wird also ein Zweig der Exception-Klassenhierarchie eingeleitet, dessen Elemente alle als Unchecked gelten.
Neben Exception ist auch Error eine Subklasse von Throwable. Errors sollten jedoch nicht abgefangen werden und führen zu einem sofortigen Programmabbruch. Auslassungszeichen stehen für die Formulierung einer Invariante, wurde früher zur Emulation der mittlerweile vorhandenen Assert-Anweisung verwendet. Auch heute sollte man Errors eigentlich nur während der Testphase eines Programms einsetzen. Genauso wie Exceptions der Sorte RuntimeException sind Errors unchecked.","<answer> Checked Exceptions sind Ausnahmesituationen, bei denen die Programmierer sich der möglichen Ausnahmesituationen bewusst sein müssen. Sie erfordern eine Deklaration im Methodenkopf oder müssen innerhalb der Methode behandelt werden. Diese Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind. <answer> <question> Was sind Checked Exceptions in JAVA? <question>"
"Wie Sie bereits in den Anweisungen in Kapitel 38 gesehen haben, bietet JAVA ein sogenanntes Exception Handling. Beim Exception Handling handelt es sich um eine Möglichkeit, bei der Spezifikation des Kontrollflusses eines Programms zunächst mögliche Ausnahmesituationen und deren Behandlung unberücksichtigt zu lassen und so zu tun, als würde immer alles gutgehen. Da dies normalerweise der Fall sein sollte, erlaubt es sowohl der Autorin als auch dem Leser eines Programms, sich auf die Hauptfunktion zu konzentrieren, mit dem Motto ""Zu den Ausnahmen kommen wir später!""
Die möglichen Ausnahmesituationen eines Programms werden in JAVA in Klassen unterteilt, deren Instanzen jeweils eine konkrete Ausnahmesituation während des Programmablaufs repräsentieren. Wenn beispielsweise in einem Programm auf ein Element eines Arrays zugegriffen werden soll, dessen Index außerhalb der Grenzen des Arrays liegt, erzeugt die JVM, die über die Einhaltung der Array-Grenzen wacht, eine Instanz der Klasse ArrayIndexOutOfBoundsException und wirft diese. Das Werfen einer Exception (genauer gesagt, einer Instanz einer Exception-Klasse) bedeutet, dass der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt wird, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist. Dies erfordert, dass der Codeabschnitt, in dem die Exception auftreten kann, in einen Try-Catch-Block eingefasst wird.
Wenn der Typ der geworfenen Exception nicht in einer der Catch-Klauseln aufgeführt ist, wird die Exception als unbehandelt betrachtet, und die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung (""Exception in thread ..."").
Ausnahmesituationen können jedoch auch vom Programm selbst erkannt und gemeldet werden, indem die bereits erwähnte Throw-Anweisung verwendet wird, um eine entsprechende Exception-Klasse zu instanziieren. Dies ermöglicht es, die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.
Try-Catch-Anweisungen in JAVA werden, wie fast alle Anweisungen, im Körper von Methoden platziert. Wenn eine Methode eine bestimmte Exception wirft, ohne sie selbst abzufangen (d. h., wenn die Throw-Anweisung nicht innerhalb eines Try-Catch-Blocks verwendet wird, der eine passende Catch-Klausel enthält), muss die Methode dies deklarieren. Dies geschieht durch Hinzufügen einer Throws-Klausel zur Methodendeklaration.
Eine Methode, die die obige Methode aufruft, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft.
Diese Praxis kann zwar zu erheblichem Schreibaufwand führen, stellt jedoch die einzige Möglichkeit dar, sicherzustellen, dass die Programmierer sich der möglichen Ausnahmesituationen bewusst sind, ohne die Kontrollflussspezifikation übermäßig zu belasten. Exceptions, die eine Deklaration im Methodenkopf erfordern oder innerhalb der Methode behandelt werden müssen, werden als Checked Exceptions bezeichnet.
Es gibt jedoch auch Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Im Gegensatz zu Checked Exceptions können Unchecked Exceptions in der Praxis überall auftreten. Ein prominentes Beispiel ist die ""Out of Memory Exception"", die auftritt, wenn eine Speicheranforderung des Programms von der JVM nicht erfüllt werden kann. Eine weitere häufige, aber programmatisch vermeidbare Exception ist die ""Null Pointer Exception"", die auftritt, wenn ein Ausdruck, auf dem auf ein Feld oder eine Methode zugegriffen wird, zu null ausgewertet wird. In dieselbe Kategorie fällt auch die ""Array Index Out of Bounds Exception"", die durch sorgfältiges Programmieren vermieden werden könnte, aber dennoch häufig vorkommt.
Es wäre äußerst mühsam, jede Anweisung, bei der eine solche Exception auftreten könnte, mit einem Try-Catch-Block abzusichern. Daher gibt es in JAVA Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Die Unterscheidung, ob eine Exception als Checked oder Unchecked gilt, liegt nicht in der Hand der Programmiererin, die sie wirft, sondern erfolgt anhand der Vererbungshierarchie der Exception-Klassen. Alle Exceptions, die von der Klasse RuntimeException abgeleitet sind, werden per Definition als Unchecked betrachtet. RuntimeException selbst ist eine Subklasse der Klasse Exception, die wiederum eine Subklasse von Throwable ist. Throwable ist die Superklasse aller Klassen, die in Throw-Anweisungen, Catch-Zweigen und Throws-Klauseln verwendet werden dürfen. Mit RuntimeException wird also ein Zweig der Exception-Klassenhierarchie eingeleitet, dessen Elemente alle als Unchecked gelten.
Neben Exception ist auch Error eine Subklasse von Throwable. Errors sollten jedoch nicht abgefangen werden und führen zu einem sofortigen Programmabbruch. Auslassungszeichen stehen für die Formulierung einer Invariante, wurde früher zur Emulation der mittlerweile vorhandenen Assert-Anweisung verwendet. Auch heute sollte man Errors eigentlich nur während der Testphase eines Programms einsetzen. Genauso wie Exceptions der Sorte RuntimeException sind Errors unchecked.","<answer> Unchecked Exceptions sind Ausnahmesituationen, die in der Praxis überall auftreten können. Sie erfordern keine explizite Deklaration im Methodenkopf und können überall auftreten. Unchecked Exceptions werden von Exception-Klassen abgeleitet, die von RuntimeException abgeleitet sind. <answer> <question> Was sind Unchecked Exceptions in JAVA? <question>"
"Wie Sie bereits in den Anweisungen in Kapitel 38 gesehen haben, bietet JAVA ein sogenanntes Exception Handling. Beim Exception Handling handelt es sich um eine Möglichkeit, bei der Spezifikation des Kontrollflusses eines Programms zunächst mögliche Ausnahmesituationen und deren Behandlung unberücksichtigt zu lassen und so zu tun, als würde immer alles gutgehen. Da dies normalerweise der Fall sein sollte, erlaubt es sowohl der Autorin als auch dem Leser eines Programms, sich auf die Hauptfunktion zu konzentrieren, mit dem Motto ""Zu den Ausnahmen kommen wir später!""
Die möglichen Ausnahmesituationen eines Programms werden in JAVA in Klassen unterteilt, deren Instanzen jeweils eine konkrete Ausnahmesituation während des Programmablaufs repräsentieren. Wenn beispielsweise in einem Programm auf ein Element eines Arrays zugegriffen werden soll, dessen Index außerhalb der Grenzen des Arrays liegt, erzeugt die JVM, die über die Einhaltung der Array-Grenzen wacht, eine Instanz der Klasse ArrayIndexOutOfBoundsException und wirft diese. Das Werfen einer Exception (genauer gesagt, einer Instanz einer Exception-Klasse) bedeutet, dass der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt wird, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist. Dies erfordert, dass der Codeabschnitt, in dem die Exception auftreten kann, in einen Try-Catch-Block eingefasst wird.
Wenn der Typ der geworfenen Exception nicht in einer der Catch-Klauseln aufgeführt ist, wird die Exception als unbehandelt betrachtet, und die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung (""Exception in thread ..."").
Ausnahmesituationen können jedoch auch vom Programm selbst erkannt und gemeldet werden, indem die bereits erwähnte Throw-Anweisung verwendet wird, um eine entsprechende Exception-Klasse zu instanziieren. Dies ermöglicht es, die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.
Try-Catch-Anweisungen in JAVA werden, wie fast alle Anweisungen, im Körper von Methoden platziert. Wenn eine Methode eine bestimmte Exception wirft, ohne sie selbst abzufangen (d. h., wenn die Throw-Anweisung nicht innerhalb eines Try-Catch-Blocks verwendet wird, der eine passende Catch-Klausel enthält), muss die Methode dies deklarieren. Dies geschieht durch Hinzufügen einer Throws-Klausel zur Methodendeklaration.
Eine Methode, die die obige Methode aufruft, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft.
Diese Praxis kann zwar zu erheblichem Schreibaufwand führen, stellt jedoch die einzige Möglichkeit dar, sicherzustellen, dass die Programmierer sich der möglichen Ausnahmesituationen bewusst sind, ohne die Kontrollflussspezifikation übermäßig zu belasten. Exceptions, die eine Deklaration im Methodenkopf erfordern oder innerhalb der Methode behandelt werden müssen, werden als Checked Exceptions bezeichnet.
Es gibt jedoch auch Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Im Gegensatz zu Checked Exceptions können Unchecked Exceptions in der Praxis überall auftreten. Ein prominentes Beispiel ist die ""Out of Memory Exception"", die auftritt, wenn eine Speicheranforderung des Programms von der JVM nicht erfüllt werden kann. Eine weitere häufige, aber programmatisch vermeidbare Exception ist die ""Null Pointer Exception"", die auftritt, wenn ein Ausdruck, auf dem auf ein Feld oder eine Methode zugegriffen wird, zu null ausgewertet wird. In dieselbe Kategorie fällt auch die ""Array Index Out of Bounds Exception"", die durch sorgfältiges Programmieren vermieden werden könnte, aber dennoch häufig vorkommt.
Es wäre äußerst mühsam, jede Anweisung, bei der eine solche Exception auftreten könnte, mit einem Try-Catch-Block abzusichern. Daher gibt es in JAVA Exceptions, bei denen dies nicht erforderlich ist, die sogenannten Unchecked Exceptions. Die Unterscheidung, ob eine Exception als Checked oder Unchecked gilt, liegt nicht in der Hand der Programmiererin, die sie wirft, sondern erfolgt anhand der Vererbungshierarchie der Exception-Klassen. Alle Exceptions, die von der Klasse RuntimeException abgeleitet sind, werden per Definition als Unchecked betrachtet. RuntimeException selbst ist eine Subklasse der Klasse Exception, die wiederum eine Subklasse von Throwable ist. Throwable ist die Superklasse aller Klassen, die in Throw-Anweisungen, Catch-Zweigen und Throws-Klauseln verwendet werden dürfen. Mit RuntimeException wird also ein Zweig der Exception-Klassenhierarchie eingeleitet, dessen Elemente alle als Unchecked gelten.
Neben Exception ist auch Error eine Subklasse von Throwable. Errors sollten jedoch nicht abgefangen werden und führen zu einem sofortigen Programmabbruch. Auslassungszeichen stehen für die Formulierung einer Invariante, wurde früher zur Emulation der mittlerweile vorhandenen Assert-Anweisung verwendet. Auch heute sollte man Errors eigentlich nur während der Testphase eines Programms einsetzen. Genauso wie Exceptions der Sorte RuntimeException sind Errors unchecked.","<answer> Der Hauptunterschied besteht darin, dass Checked Exceptions eine explizite Deklaration im Methodenkopf oder eine Behandlung innerhalb der Methode erfordern, während Unchecked Exceptions dies nicht tun. Checked Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind, während Unchecked Exceptions von Exception-Klassen abgeleitet werden, die von RuntimeException abgeleitet sind. Checked Exceptions sollen den Programmierer auf mögliche Ausnahmesituationen hinweisen, während Unchecked Exceptions oft schwer vorhersehbar sind und überall auftreten können. <answer> <question> Was ist der Unterschied zwischen Checked und Unchecked Exceptions in JAVA? <question>"
"Neben in Typdefinitionen können Typvariablen (formale Typparameter) auch in Methodendefinitionen eingeführt (deklariert) werden. In diesem Fall ist die Sichtbarkeit der Typparameter auf die jeweilige Methode beschränkt. Es lassen sich damit variable Über- und Rückgabeparametertypen für eine Methode deklarieren. Die Belegung der Typparameter mit konkreten Typen als Werten erfolgt dann bei der Bindung eines Methodenaufrufs zur Übersetzungszeit. Der tatsächliche Typparameter muss dabei nicht angegeben werden, wenn er sich aus dem Kontext eindeutig ergibt (sog. Typinferenz).
Beim Aufruf einer parametrischen Methode muss der tatsächliche Typparameter angegeben werden. Allerdings erlaubt der Java-Compiler, diesen wegzulassen, wenn er sich aus dem Aufruf erschließen lässt (die oben erwähnte Typinferenz).
Der (formale) Typparameter einer generischen Methode kann zunächst an jeden beliebigen Typ gebunden werden. Genau wie bei generischen Klassen reduziert dies jedoch entweder die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode unbekannt ist. Es ist also, wieder genau wie bei generischen Klassen, möglich, den Typparameter mit extends zu beschränken.
Nicht selten wird der Typparameter (nicht die mit ihm deklarierten Parameter!) innerhalb der Methode nicht mehr verwendet. Eine Variable, die nur einmal vorkommt, kann man aber auch weglassen oder zumindest unbenannt lassen. Und so ist es in diesen Fällen gute Praxis, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard zu verwenden.",<answer> Typvariablen können sowohl in Typdefinitionen als auch in Methodendefinitionen in Java verwendet werden. <answer> <question> Wo können Typvariablen (formale Typparameter) in Java verwendet werden? <question>
"Neben in Typdefinitionen können Typvariablen (formale Typparameter) auch in Methodendefinitionen eingeführt (deklariert) werden. In diesem Fall ist die Sichtbarkeit der Typparameter auf die jeweilige Methode beschränkt. Es lassen sich damit variable Über- und Rückgabeparametertypen für eine Methode deklarieren. Die Belegung der Typparameter mit konkreten Typen als Werten erfolgt dann bei der Bindung eines Methodenaufrufs zur Übersetzungszeit. Der tatsächliche Typparameter muss dabei nicht angegeben werden, wenn er sich aus dem Kontext eindeutig ergibt (sog. Typinferenz).
Beim Aufruf einer parametrischen Methode muss der tatsächliche Typparameter angegeben werden. Allerdings erlaubt der Java-Compiler, diesen wegzulassen, wenn er sich aus dem Aufruf erschließen lässt (die oben erwähnte Typinferenz).
Der (formale) Typparameter einer generischen Methode kann zunächst an jeden beliebigen Typ gebunden werden. Genau wie bei generischen Klassen reduziert dies jedoch entweder die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode unbekannt ist. Es ist also, wieder genau wie bei generischen Klassen, möglich, den Typparameter mit extends zu beschränken.
Nicht selten wird der Typparameter (nicht die mit ihm deklarierten Parameter!) innerhalb der Methode nicht mehr verwendet. Eine Variable, die nur einmal vorkommt, kann man aber auch weglassen oder zumindest unbenannt lassen. Und so ist es in diesen Fällen gute Praxis, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard zu verwenden.",<answer> Die Sichtbarkeit von Typparametern in Methodendefinitionen ist auf die jeweilige Methode beschränkt. <answer> <question> Was ist die Sichtbarkeit von Typparametern in Methodendefinitionen? <question>
"Neben in Typdefinitionen können Typvariablen (formale Typparameter) auch in Methodendefinitionen eingeführt (deklariert) werden. In diesem Fall ist die Sichtbarkeit der Typparameter auf die jeweilige Methode beschränkt. Es lassen sich damit variable Über- und Rückgabeparametertypen für eine Methode deklarieren. Die Belegung der Typparameter mit konkreten Typen als Werten erfolgt dann bei der Bindung eines Methodenaufrufs zur Übersetzungszeit. Der tatsächliche Typparameter muss dabei nicht angegeben werden, wenn er sich aus dem Kontext eindeutig ergibt (sog. Typinferenz).
Beim Aufruf einer parametrischen Methode muss der tatsächliche Typparameter angegeben werden. Allerdings erlaubt der Java-Compiler, diesen wegzulassen, wenn er sich aus dem Aufruf erschließen lässt (die oben erwähnte Typinferenz).
Der (formale) Typparameter einer generischen Methode kann zunächst an jeden beliebigen Typ gebunden werden. Genau wie bei generischen Klassen reduziert dies jedoch entweder die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode unbekannt ist. Es ist also, wieder genau wie bei generischen Klassen, möglich, den Typparameter mit extends zu beschränken.
Nicht selten wird der Typparameter (nicht die mit ihm deklarierten Parameter!) innerhalb der Methode nicht mehr verwendet. Eine Variable, die nur einmal vorkommt, kann man aber auch weglassen oder zumindest unbenannt lassen. Und so ist es in diesen Fällen gute Praxis, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard zu verwenden.","<answer> Typinferenz in Bezug auf generische Methoden bezieht sich auf die Fähigkeit des Java-Compilers, den tatsächlichen Typparameter wegzulassen, wenn er sich aus dem Kontext des Methodenaufrufs ableiten kann. <answer> <question> Was ist Typinferenz in Bezug auf generische Methoden? <question>"
"Neben in Typdefinitionen können Typvariablen (formale Typparameter) auch in Methodendefinitionen eingeführt (deklariert) werden. In diesem Fall ist die Sichtbarkeit der Typparameter auf die jeweilige Methode beschränkt. Es lassen sich damit variable Über- und Rückgabeparametertypen für eine Methode deklarieren. Die Belegung der Typparameter mit konkreten Typen als Werten erfolgt dann bei der Bindung eines Methodenaufrufs zur Übersetzungszeit. Der tatsächliche Typparameter muss dabei nicht angegeben werden, wenn er sich aus dem Kontext eindeutig ergibt (sog. Typinferenz).
Beim Aufruf einer parametrischen Methode muss der tatsächliche Typparameter angegeben werden. Allerdings erlaubt der Java-Compiler, diesen wegzulassen, wenn er sich aus dem Aufruf erschließen lässt (die oben erwähnte Typinferenz).
Der (formale) Typparameter einer generischen Methode kann zunächst an jeden beliebigen Typ gebunden werden. Genau wie bei generischen Klassen reduziert dies jedoch entweder die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode unbekannt ist. Es ist also, wieder genau wie bei generischen Klassen, möglich, den Typparameter mit extends zu beschränken.
Nicht selten wird der Typparameter (nicht die mit ihm deklarierten Parameter!) innerhalb der Methode nicht mehr verwendet. Eine Variable, die nur einmal vorkommt, kann man aber auch weglassen oder zumindest unbenannt lassen. Und so ist es in diesen Fällen gute Praxis, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard zu verwenden.","<answer> Die Verwendung von Typinferenz bei generischen Methoden erleichtert die Verwendung, da der tatsächliche Typparameter nicht immer explizit angegeben werden muss, was den Code lesbarer macht. <answer> <question> Welche Vorteile bietet die Verwendung von Typinferenz bei generischen Methoden? <question>"
"Neben in Typdefinitionen können Typvariablen (formale Typparameter) auch in Methodendefinitionen eingeführt (deklariert) werden. In diesem Fall ist die Sichtbarkeit der Typparameter auf die jeweilige Methode beschränkt. Es lassen sich damit variable Über- und Rückgabeparametertypen für eine Methode deklarieren. Die Belegung der Typparameter mit konkreten Typen als Werten erfolgt dann bei der Bindung eines Methodenaufrufs zur Übersetzungszeit. Der tatsächliche Typparameter muss dabei nicht angegeben werden, wenn er sich aus dem Kontext eindeutig ergibt (sog. Typinferenz).
Beim Aufruf einer parametrischen Methode muss der tatsächliche Typparameter angegeben werden. Allerdings erlaubt der Java-Compiler, diesen wegzulassen, wenn er sich aus dem Aufruf erschließen lässt (die oben erwähnte Typinferenz).
Der (formale) Typparameter einer generischen Methode kann zunächst an jeden beliebigen Typ gebunden werden. Genau wie bei generischen Klassen reduziert dies jedoch entweder die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode unbekannt ist. Es ist also, wieder genau wie bei generischen Klassen, möglich, den Typparameter mit extends zu beschränken.
Nicht selten wird der Typparameter (nicht die mit ihm deklarierten Parameter!) innerhalb der Methode nicht mehr verwendet. Eine Variable, die nur einmal vorkommt, kann man aber auch weglassen oder zumindest unbenannt lassen. Und so ist es in diesen Fällen gute Praxis, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard zu verwenden.","<answer> Das Beschränken des Typparameters einer generischen Methode mit ""extends"" kann sinnvoll sein, um die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte zu erhöhen, da deren Typ innerhalb der Methode bekannter ist. <answer> <question> Warum könnte es sinnvoll sein, den Typparameter einer generischen Methode mit ""extends"" zu beschränken? <question>"
"Neben in Typdefinitionen können Typvariablen (formale Typparameter) auch in Methodendefinitionen eingeführt (deklariert) werden. In diesem Fall ist die Sichtbarkeit der Typparameter auf die jeweilige Methode beschränkt. Es lassen sich damit variable Über- und Rückgabeparametertypen für eine Methode deklarieren. Die Belegung der Typparameter mit konkreten Typen als Werten erfolgt dann bei der Bindung eines Methodenaufrufs zur Übersetzungszeit. Der tatsächliche Typparameter muss dabei nicht angegeben werden, wenn er sich aus dem Kontext eindeutig ergibt (sog. Typinferenz).
Beim Aufruf einer parametrischen Methode muss der tatsächliche Typparameter angegeben werden. Allerdings erlaubt der Java-Compiler, diesen wegzulassen, wenn er sich aus dem Aufruf erschließen lässt (die oben erwähnte Typinferenz).
Der (formale) Typparameter einer generischen Methode kann zunächst an jeden beliebigen Typ gebunden werden. Genau wie bei generischen Klassen reduziert dies jedoch entweder die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode unbekannt ist. Es ist also, wieder genau wie bei generischen Klassen, möglich, den Typparameter mit extends zu beschränken.
Nicht selten wird der Typparameter (nicht die mit ihm deklarierten Parameter!) innerhalb der Methode nicht mehr verwendet. Eine Variable, die nur einmal vorkommt, kann man aber auch weglassen oder zumindest unbenannt lassen. Und so ist es in diesen Fällen gute Praxis, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard zu verwenden.","<answer> In einigen Fällen, in denen der Typparameter innerhalb der Methode nicht verwendet wird, kann es sinnvoll sein, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard in der generischen Methode zu verwenden, um den Code einfacher und lesbarer zu gestalten. <answer> <question> Warum könnte es in einigen Fällen sinnvoll sein, ein Typ-Wildcard anstelle eines Typparameters in einer generischen Methode zu verwenden? <question>"
"Da Blöcke Objekte sind, denen Variablen zugewiesen werden können, können sie auch an andere Methoden übergeben werden. Werden sie dort (mittels value) ausgewertet, findet die Ausführung in einem anderen Kontext statt. In diesem Kontext sind die ""freien"" Variablen des Blocks (also diejenigen, die nicht selbst als lokale Variablen deklariert wurden; x und y in Zeile 175) nicht zugreifbar. Der Block nimmt deshalb seinen Kontext mit (oder, genauer gesagt, der Kontext ist im Block enthalten). Den Kontext, in dem ein Block definiert wurde (in dem das ihn repräsentierende Objekt erzeugt wurde), nennt man seinen Home Context. Die Auswertung eines Blocks erfolgt stets in seinem Home Context, auch dann, wenn ihm value in einem anderen Kontext gesendet wurde.
Dass ein Block aus seinem Home Context herausgelöst und in einem anderen gespeichert werden kann, beinhaltet das Problem, dass die lokalen Variablen des Home Contexts schon verschwunden sein können, wenn der Block ausgewertet wird. Die durch den Block ""eingefangenen"" lokalen Variablen (einschließlich der formalen Parameter) müssen daher unabhängig von der Ausführung der Methoden, die sie definieren, weiterleben. Die Umsetzung von Blöcken durch den SMALLTALK-Compiler ist alles andere als trivial, und verschiedene SMALLTALK-Systeme unterscheiden sich darin teilweise erheblich voneinander, was sich (leider) auch in unterschiedlichem Verhalten äußert.
Die Blöcke in SMALLTALK werden in anderen Sprachen übrigens als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können. Dabei unterscheiden sich die Sprachen erheblich darin, was alles in eine Closure einbezogen werden kann. Zum Beispiel können die lokalen Namen (Variablen) auf Konstanten eingeschränkt werden, um zu verhindern, dass temporäre Variablen weiterleben müssen, nur weil sie in einer Closure enthalten sind.","<answer> Der Home Context eines Blocks in SMALLTALK ist der Kontext, in dem der Block definiert wurde oder genauer gesagt, in dem das ihn repräsentierende Objekt erzeugt wurde. Dieser Kontext enthält Informationen über die lokalen Variablen und formalen Parameter, die der Block ""einfängt"". Die Ausführung eines Blocks erfolgt immer in seinem Home Context, selbst wenn der Block in einem anderen Kontext ausgewertet wird. <answer> <question> Was ist der Home Context eines Blocks in SMALLTALK? <question>"
"Da Blöcke Objekte sind, denen Variablen zugewiesen werden können, können sie auch an andere Methoden übergeben werden. Werden sie dort (mittels value) ausgewertet, findet die Ausführung in einem anderen Kontext statt. In diesem Kontext sind die ""freien"" Variablen des Blocks (also diejenigen, die nicht selbst als lokale Variablen deklariert wurden; x und y in Zeile 175) nicht zugreifbar. Der Block nimmt deshalb seinen Kontext mit (oder, genauer gesagt, der Kontext ist im Block enthalten). Den Kontext, in dem ein Block definiert wurde (in dem das ihn repräsentierende Objekt erzeugt wurde), nennt man seinen Home Context. Die Auswertung eines Blocks erfolgt stets in seinem Home Context, auch dann, wenn ihm value in einem anderen Kontext gesendet wurde.
Dass ein Block aus seinem Home Context herausgelöst und in einem anderen gespeichert werden kann, beinhaltet das Problem, dass die lokalen Variablen des Home Contexts schon verschwunden sein können, wenn der Block ausgewertet wird. Die durch den Block ""eingefangenen"" lokalen Variablen (einschließlich der formalen Parameter) müssen daher unabhängig von der Ausführung der Methoden, die sie definieren, weiterleben. Die Umsetzung von Blöcken durch den SMALLTALK-Compiler ist alles andere als trivial, und verschiedene SMALLTALK-Systeme unterscheiden sich darin teilweise erheblich voneinander, was sich (leider) auch in unterschiedlichem Verhalten äußert.
Die Blöcke in SMALLTALK werden in anderen Sprachen übrigens als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können. Dabei unterscheiden sich die Sprachen erheblich darin, was alles in eine Closure einbezogen werden kann. Zum Beispiel können die lokalen Namen (Variablen) auf Konstanten eingeschränkt werden, um zu verhindern, dass temporäre Variablen weiterleben müssen, nur weil sie in einer Closure enthalten sind.","<answer> ""Freie"" Variablen in Bezug auf Blöcke in SMALLTALK sind Variablen, die im Block verwendet werden, aber nicht im Block selbst deklariert wurden. Das bedeutet, dass diese Variablen aus dem Home Context des Blocks stammen und vom Block ""eingefangen"" wurden. Diese freien Variablen können im Kontext, in dem der Block ausgewertet wird, nicht direkt zugegriffen werden. <answer> <question> Was sind ""freie"" Variablen in Bezug auf Blöcke in SMALLTALK? <question>"
"Da Blöcke Objekte sind, denen Variablen zugewiesen werden können, können sie auch an andere Methoden übergeben werden. Werden sie dort (mittels value) ausgewertet, findet die Ausführung in einem anderen Kontext statt. In diesem Kontext sind die ""freien"" Variablen des Blocks (also diejenigen, die nicht selbst als lokale Variablen deklariert wurden; x und y in Zeile 175) nicht zugreifbar. Der Block nimmt deshalb seinen Kontext mit (oder, genauer gesagt, der Kontext ist im Block enthalten). Den Kontext, in dem ein Block definiert wurde (in dem das ihn repräsentierende Objekt erzeugt wurde), nennt man seinen Home Context. Die Auswertung eines Blocks erfolgt stets in seinem Home Context, auch dann, wenn ihm value in einem anderen Kontext gesendet wurde.
Dass ein Block aus seinem Home Context herausgelöst und in einem anderen gespeichert werden kann, beinhaltet das Problem, dass die lokalen Variablen des Home Contexts schon verschwunden sein können, wenn der Block ausgewertet wird. Die durch den Block ""eingefangenen"" lokalen Variablen (einschließlich der formalen Parameter) müssen daher unabhängig von der Ausführung der Methoden, die sie definieren, weiterleben. Die Umsetzung von Blöcken durch den SMALLTALK-Compiler ist alles andere als trivial, und verschiedene SMALLTALK-Systeme unterscheiden sich darin teilweise erheblich voneinander, was sich (leider) auch in unterschiedlichem Verhalten äußert.
Die Blöcke in SMALLTALK werden in anderen Sprachen übrigens als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können. Dabei unterscheiden sich die Sprachen erheblich darin, was alles in eine Closure einbezogen werden kann. Zum Beispiel können die lokalen Namen (Variablen) auf Konstanten eingeschränkt werden, um zu verhindern, dass temporäre Variablen weiterleben müssen, nur weil sie in einer Closure enthalten sind.","<answer> Die durch einen Block ""eingefangenen"" lokalen Variablen müssen weiterleben, da der Block in einem anderen Kontext ausgewertet werden kann, in dem die ursprünglichen lokalen Variablen möglicherweise nicht mehr existieren. Um sicherzustellen, dass der Block korrekt funktioniert, müssen die im Block verwendeten Variablen weiterhin zugänglich sein, auch wenn der ursprüngliche Kontext, in dem sie definiert wurden, nicht mehr existiert. <answer> <question> Warum müssen die durch einen Block ""eingefangenen"" lokalen Variablen weiterleben, unabhängig von der Ausführung der Methoden, die sie definieren? <question>"
"Da Blöcke Objekte sind, denen Variablen zugewiesen werden können, können sie auch an andere Methoden übergeben werden. Werden sie dort (mittels value) ausgewertet, findet die Ausführung in einem anderen Kontext statt. In diesem Kontext sind die ""freien"" Variablen des Blocks (also diejenigen, die nicht selbst als lokale Variablen deklariert wurden; x und y in Zeile 175) nicht zugreifbar. Der Block nimmt deshalb seinen Kontext mit (oder, genauer gesagt, der Kontext ist im Block enthalten). Den Kontext, in dem ein Block definiert wurde (in dem das ihn repräsentierende Objekt erzeugt wurde), nennt man seinen Home Context. Die Auswertung eines Blocks erfolgt stets in seinem Home Context, auch dann, wenn ihm value in einem anderen Kontext gesendet wurde.
Dass ein Block aus seinem Home Context herausgelöst und in einem anderen gespeichert werden kann, beinhaltet das Problem, dass die lokalen Variablen des Home Contexts schon verschwunden sein können, wenn der Block ausgewertet wird. Die durch den Block ""eingefangenen"" lokalen Variablen (einschließlich der formalen Parameter) müssen daher unabhängig von der Ausführung der Methoden, die sie definieren, weiterleben. Die Umsetzung von Blöcken durch den SMALLTALK-Compiler ist alles andere als trivial, und verschiedene SMALLTALK-Systeme unterscheiden sich darin teilweise erheblich voneinander, was sich (leider) auch in unterschiedlichem Verhalten äußert.
Die Blöcke in SMALLTALK werden in anderen Sprachen übrigens als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können. Dabei unterscheiden sich die Sprachen erheblich darin, was alles in eine Closure einbezogen werden kann. Zum Beispiel können die lokalen Namen (Variablen) auf Konstanten eingeschränkt werden, um zu verhindern, dass temporäre Variablen weiterleben müssen, nur weil sie in einer Closure enthalten sind.","<answer> Blöcke in SMALLTALK werden in anderen Programmiersprachen oft als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, die anonyme Funktionen repräsentieren und als Objekte oder Werte behandelt werden können. Closures erlauben es, Funktionen aus ihrem Kontext herauszulösen und in andere Kontexte zu übertragen. Die Verwendung und das Verhalten von Closures können sich jedoch zwischen verschiedenen Programmiersprachen erheblich unterscheiden. <answer> <question> Wie werden Blöcke in anderen Programmiersprachen oft genannt, und wofür werden sie verwendet? <question>"
"JAVA ist eine stark typisierte Sprache: Alle Ausdrücke haben einen Typ. Das gilt auch für Variablen, deren Typ bei ihrer Deklaration angegeben werden muss. In JAVA gibt es Variablen mit Referenz- und Wertsemantik. Welche Semantik eine Variable hat, richtet sich nach ihrem Typ. Typen, die zu Variablen mit Wertsemantik führen, sind die oben genannten primitiven, nämlich byte, short, int, long, float, double, boolean und char. Variablen, die mit einem anderen Typ deklariert werden, haben Referenzsemantik.
Variablen werden in JAVA genauso wie in SMALLTALK explizit per Zuweisungsoperator ""="" und implizit per Methodenaufruf Werte zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten.
In JAVA ist es nicht möglich, Pointervariablen explizit zu deklarieren. Daher gibt es insbesondere beim Methodenaufruf (und den damit verbundenen impliziten Zuweisungen) kein ""Call by reference"" in JAVA, sondern nur ein ""Call by value"". Dies ändert sich auch nicht, wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben. Weitere Informationen finden Sie auch in den Bemerkungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.
Seit JAVA 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" bzw. ""Auto unboxing"". Dabei können jedoch, ähnlich wie bei der Handhabung bestimmter Werte als Objekte in SMALLTALK (siehe Abschnitt 1.4 in Kurseinheit 1), unerwartete Phänomene auftreten: Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, in JAVA sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte. Andernfalls können schwer zu findende Programmierfehler auftreten.","<answer> JAVA ist eine stark typisierte Sprache, was bedeutet, dass alle Ausdrücke einen Typ haben und Variablen bei ihrer Deklaration einen Typ angeben müssen. <answer> <question> Was bedeutet es, dass JAVA eine stark typisierte Sprache ist? <question>"
"JAVA ist eine stark typisierte Sprache: Alle Ausdrücke haben einen Typ. Das gilt auch für Variablen, deren Typ bei ihrer Deklaration angegeben werden muss. In JAVA gibt es Variablen mit Referenz- und Wertsemantik. Welche Semantik eine Variable hat, richtet sich nach ihrem Typ. Typen, die zu Variablen mit Wertsemantik führen, sind die oben genannten primitiven, nämlich byte, short, int, long, float, double, boolean und char. Variablen, die mit einem anderen Typ deklariert werden, haben Referenzsemantik.
Variablen werden in JAVA genauso wie in SMALLTALK explizit per Zuweisungsoperator ""="" und implizit per Methodenaufruf Werte zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten.
In JAVA ist es nicht möglich, Pointervariablen explizit zu deklarieren. Daher gibt es insbesondere beim Methodenaufruf (und den damit verbundenen impliziten Zuweisungen) kein ""Call by reference"" in JAVA, sondern nur ein ""Call by value"". Dies ändert sich auch nicht, wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben. Weitere Informationen finden Sie auch in den Bemerkungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.
Seit JAVA 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" bzw. ""Auto unboxing"". Dabei können jedoch, ähnlich wie bei der Handhabung bestimmter Werte als Objekte in SMALLTALK (siehe Abschnitt 1.4 in Kurseinheit 1), unerwartete Phänomene auftreten: Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, in JAVA sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte. Andernfalls können schwer zu findende Programmierfehler auftreten.","<answer> Variablen in JAVA haben entweder Referenzsemantik oder Wertsemantik, je nach ihrem Typ. Primitive Typen wie byte, short, int, usw., haben Wertsemantik. Andere Typen haben Referenzsemantik. <answer> <question> Welche Semantik haben Variablen in JAVA, und wie wird dies bestimmt? <question>"
"JAVA ist eine stark typisierte Sprache: Alle Ausdrücke haben einen Typ. Das gilt auch für Variablen, deren Typ bei ihrer Deklaration angegeben werden muss. In JAVA gibt es Variablen mit Referenz- und Wertsemantik. Welche Semantik eine Variable hat, richtet sich nach ihrem Typ. Typen, die zu Variablen mit Wertsemantik führen, sind die oben genannten primitiven, nämlich byte, short, int, long, float, double, boolean und char. Variablen, die mit einem anderen Typ deklariert werden, haben Referenzsemantik.
Variablen werden in JAVA genauso wie in SMALLTALK explizit per Zuweisungsoperator ""="" und implizit per Methodenaufruf Werte zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten.
In JAVA ist es nicht möglich, Pointervariablen explizit zu deklarieren. Daher gibt es insbesondere beim Methodenaufruf (und den damit verbundenen impliziten Zuweisungen) kein ""Call by reference"" in JAVA, sondern nur ein ""Call by value"". Dies ändert sich auch nicht, wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben. Weitere Informationen finden Sie auch in den Bemerkungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.
Seit JAVA 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" bzw. ""Auto unboxing"". Dabei können jedoch, ähnlich wie bei der Handhabung bestimmter Werte als Objekte in SMALLTALK (siehe Abschnitt 1.4 in Kurseinheit 1), unerwartete Phänomene auftreten: Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, in JAVA sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte. Andernfalls können schwer zu findende Programmierfehler auftreten.","<answer> In JAVA werden Werte Variablen sowohl explizit per Zuweisungsoperator ""="" als auch implizit per Methodenaufruf zugewiesen. <answer> <question> Wie werden Werte Variablen in JAVA zugewiesen? <question>"
"JAVA ist eine stark typisierte Sprache: Alle Ausdrücke haben einen Typ. Das gilt auch für Variablen, deren Typ bei ihrer Deklaration angegeben werden muss. In JAVA gibt es Variablen mit Referenz- und Wertsemantik. Welche Semantik eine Variable hat, richtet sich nach ihrem Typ. Typen, die zu Variablen mit Wertsemantik führen, sind die oben genannten primitiven, nämlich byte, short, int, long, float, double, boolean und char. Variablen, die mit einem anderen Typ deklariert werden, haben Referenzsemantik.
Variablen werden in JAVA genauso wie in SMALLTALK explizit per Zuweisungsoperator ""="" und implizit per Methodenaufruf Werte zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten.
In JAVA ist es nicht möglich, Pointervariablen explizit zu deklarieren. Daher gibt es insbesondere beim Methodenaufruf (und den damit verbundenen impliziten Zuweisungen) kein ""Call by reference"" in JAVA, sondern nur ein ""Call by value"". Dies ändert sich auch nicht, wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben. Weitere Informationen finden Sie auch in den Bemerkungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.
Seit JAVA 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" bzw. ""Auto unboxing"". Dabei können jedoch, ähnlich wie bei der Handhabung bestimmter Werte als Objekte in SMALLTALK (siehe Abschnitt 1.4 in Kurseinheit 1), unerwartete Phänomene auftreten: Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, in JAVA sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte. Andernfalls können schwer zu findende Programmierfehler auftreten.","<answer> Bei der Wertzuweisung wird der tatsächliche Wert einer Variable kopiert, während bei der Zuweisung von Referenzen nur die Referenz auf das Objekt kopiert wird. <answer> <question> Was ist der Unterschied zwischen der Wertzuweisung und der Zuweisung von Referenzen in JAVA? <question>"
"JAVA ist eine stark typisierte Sprache: Alle Ausdrücke haben einen Typ. Das gilt auch für Variablen, deren Typ bei ihrer Deklaration angegeben werden muss. In JAVA gibt es Variablen mit Referenz- und Wertsemantik. Welche Semantik eine Variable hat, richtet sich nach ihrem Typ. Typen, die zu Variablen mit Wertsemantik führen, sind die oben genannten primitiven, nämlich byte, short, int, long, float, double, boolean und char. Variablen, die mit einem anderen Typ deklariert werden, haben Referenzsemantik.
Variablen werden in JAVA genauso wie in SMALLTALK explizit per Zuweisungsoperator ""="" und implizit per Methodenaufruf Werte zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten.
In JAVA ist es nicht möglich, Pointervariablen explizit zu deklarieren. Daher gibt es insbesondere beim Methodenaufruf (und den damit verbundenen impliziten Zuweisungen) kein ""Call by reference"" in JAVA, sondern nur ein ""Call by value"". Dies ändert sich auch nicht, wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben. Weitere Informationen finden Sie auch in den Bemerkungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.
Seit JAVA 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" bzw. ""Auto unboxing"". Dabei können jedoch, ähnlich wie bei der Handhabung bestimmter Werte als Objekte in SMALLTALK (siehe Abschnitt 1.4 in Kurseinheit 1), unerwartete Phänomene auftreten: Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, in JAVA sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte. Andernfalls können schwer zu findende Programmierfehler auftreten.","<answer> Nein, in JAVA gibt es kein ""Call by reference"", sondern nur ""Call by value"". Auch wenn Variablen Referenztypen haben, wird bei Methodenaufrufen immer eine Kopie des Zeigers an die formalen Parameter übergeben. <answer> <question> Gibt es in JAVA ""Call by reference""? <question>"
"JAVA ist eine stark typisierte Sprache: Alle Ausdrücke haben einen Typ. Das gilt auch für Variablen, deren Typ bei ihrer Deklaration angegeben werden muss. In JAVA gibt es Variablen mit Referenz- und Wertsemantik. Welche Semantik eine Variable hat, richtet sich nach ihrem Typ. Typen, die zu Variablen mit Wertsemantik führen, sind die oben genannten primitiven, nämlich byte, short, int, long, float, double, boolean und char. Variablen, die mit einem anderen Typ deklariert werden, haben Referenzsemantik.
Variablen werden in JAVA genauso wie in SMALLTALK explizit per Zuweisungsoperator ""="" und implizit per Methodenaufruf Werte zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten.
In JAVA ist es nicht möglich, Pointervariablen explizit zu deklarieren. Daher gibt es insbesondere beim Methodenaufruf (und den damit verbundenen impliziten Zuweisungen) kein ""Call by reference"" in JAVA, sondern nur ein ""Call by value"". Dies ändert sich auch nicht, wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben. Weitere Informationen finden Sie auch in den Bemerkungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.
Seit JAVA 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" bzw. ""Auto unboxing"". Dabei können jedoch, ähnlich wie bei der Handhabung bestimmter Werte als Objekte in SMALLTALK (siehe Abschnitt 1.4 in Kurseinheit 1), unerwartete Phänomene auftreten: Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, in JAVA sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte. Andernfalls können schwer zu findende Programmierfehler auftreten.","<answer> Seit JAVA 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" für das Verpacken in Wrapper-Typen und ""Auto unboxing"" für das Entpacken. <answer> <question> Was ist ""Auto boxing"" und ""Auto unboxing"" in JAVA? <question>"
"JAVA ist eine stark typisierte Sprache: Alle Ausdrücke haben einen Typ. Das gilt auch für Variablen, deren Typ bei ihrer Deklaration angegeben werden muss. In JAVA gibt es Variablen mit Referenz- und Wertsemantik. Welche Semantik eine Variable hat, richtet sich nach ihrem Typ. Typen, die zu Variablen mit Wertsemantik führen, sind die oben genannten primitiven, nämlich byte, short, int, long, float, double, boolean und char. Variablen, die mit einem anderen Typ deklariert werden, haben Referenzsemantik.
Variablen werden in JAVA genauso wie in SMALLTALK explizit per Zuweisungsoperator ""="" und implizit per Methodenaufruf Werte zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten.
In JAVA ist es nicht möglich, Pointervariablen explizit zu deklarieren. Daher gibt es insbesondere beim Methodenaufruf (und den damit verbundenen impliziten Zuweisungen) kein ""Call by reference"" in JAVA, sondern nur ein ""Call by value"". Dies ändert sich auch nicht, wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben. Weitere Informationen finden Sie auch in den Bemerkungen in Abschnitt 4.3.2 (Kurseinheit 1) und Kapitel 37.
Seit JAVA 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man ""Auto boxing"" bzw. ""Auto unboxing"". Dabei können jedoch, ähnlich wie bei der Handhabung bestimmter Werte als Objekte in SMALLTALK (siehe Abschnitt 1.4 in Kurseinheit 1), unerwartete Phänomene auftreten: Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, in JAVA sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte. Andernfalls können schwer zu findende Programmierfehler auftreten.","<answer> Bei ""Auto boxing"" und ""Auto unboxing"" in JAVA ist Vorsicht geboten, da unerwartete Ergebnisse auftreten können. Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte, um Programmierfehler zu vermeiden. <answer> <question> Welche Vorsichtsmaßnahmen müssen bei ""Auto boxing"" und ""Auto unboxing"" in JAVA getroffen werden? <question>"
"Das obige Beispiel hat gezeigt, dass die einfache Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich ist. Da die Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den Typ implementierenden Klassen) keine Aussagen über den Typ treffen. Außerhalb, bei der Verwendung (Instanziierung) der Typdefinition, ist das hingegen möglich, da hier die Typvariable durch einen Typ ersetzt ist.
Was man jedoch gerne hätte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist, und zwar derart, dass man bei den als Werte zulässigen Typen ein bestimmtes, benötigtes Protokoll voraussetzen kann. Die tatsächlichen Typparameter sind dann nicht mehr beliebig wählbar, sondern nur noch aus solchen Typen, die die Einschränkungen erfüllen. Eine Möglichkeit, dies zu erzielen, wäre die Einführung von Metatypen, deren Wertebereiche Typen mit von den Metatypen vorgegebenen Eigenschaften sind. Diese Möglichkeit wird jedoch in der Praxis nicht genutzt.
Stattdessen verwendet man eine Art der Beschränkung des Wertebereichs von Typvariablen, die auf Subtyping beruht. Wenn man nämlich erzwingen kann, dass ein tatsächlicher Typparameter (also der Wert der Typvariable) ein Subtyp eines bestimmten Typs ist, der die benötigten Eigenschaften (Methoden) umfasst, dann ist damit alles erreicht, was man benötigt. Aufgrund der Regeln des Subtyping hat jeder solche Typ die Eigenschaften des Supertyps (siehe Kapitel 26).
Der Rest der Definition geht wie oben. Der Ausdruck ""E < Number"" im Abschnitt ""Typvariablen"" ist Deklaration und Beschränkung zugleich. Die Beschränkung ist jedoch, wie bereits erwähnt, keine Typisierung wie in normalen Variablendeklarationen. Sie drückt vielmehr aus, dass die Typen, die als Werte für E eingesetzt werden dürfen, Subtypen von Number sein müssen. Die Deklaration aus Zeile 951 wird damit unzulässig und führt zu einem entsprechenden Typfehler während der statischen Typprüfung. Die Deklaration aus Zeile 952 ist hingegen in Ordnung.","<answer> Die einfache Form des parametrischen Polymorphismus ist nur teilweise nützlich, da die Typvariablen selbst nicht typisiert sind, und somit innerhalb der Typdefinition keine Aussagen über den Typ getroffen werden können. <answer> <question> Warum ist die einfache Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich? <question>"
"Das obige Beispiel hat gezeigt, dass die einfache Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich ist. Da die Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den Typ implementierenden Klassen) keine Aussagen über den Typ treffen. Außerhalb, bei der Verwendung (Instanziierung) der Typdefinition, ist das hingegen möglich, da hier die Typvariable durch einen Typ ersetzt ist.
Was man jedoch gerne hätte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist, und zwar derart, dass man bei den als Werte zulässigen Typen ein bestimmtes, benötigtes Protokoll voraussetzen kann. Die tatsächlichen Typparameter sind dann nicht mehr beliebig wählbar, sondern nur noch aus solchen Typen, die die Einschränkungen erfüllen. Eine Möglichkeit, dies zu erzielen, wäre die Einführung von Metatypen, deren Wertebereiche Typen mit von den Metatypen vorgegebenen Eigenschaften sind. Diese Möglichkeit wird jedoch in der Praxis nicht genutzt.
Stattdessen verwendet man eine Art der Beschränkung des Wertebereichs von Typvariablen, die auf Subtyping beruht. Wenn man nämlich erzwingen kann, dass ein tatsächlicher Typparameter (also der Wert der Typvariable) ein Subtyp eines bestimmten Typs ist, der die benötigten Eigenschaften (Methoden) umfasst, dann ist damit alles erreicht, was man benötigt. Aufgrund der Regeln des Subtyping hat jeder solche Typ die Eigenschaften des Supertyps (siehe Kapitel 26).
Der Rest der Definition geht wie oben. Der Ausdruck ""E < Number"" im Abschnitt ""Typvariablen"" ist Deklaration und Beschränkung zugleich. Die Beschränkung ist jedoch, wie bereits erwähnt, keine Typisierung wie in normalen Variablendeklarationen. Sie drückt vielmehr aus, dass die Typen, die als Werte für E eingesetzt werden dürfen, Subtypen von Number sein müssen. Die Deklaration aus Zeile 951 wird damit unzulässig und führt zu einem entsprechenden Typfehler während der statischen Typprüfung. Die Deklaration aus Zeile 952 ist hingegen in Ordnung.","<answer> Mit dem beschränkten parametrischen Polymorphismus möchte man sicherstellen, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist und nur bestimmte, benötigte Protokolle für die als Werte zulässigen Typen erlaubt. <answer> <question> Welches Problem möchte man mit dem beschränkten parametrischen Polymorphismus lösen? <question>"
"Das obige Beispiel hat gezeigt, dass die einfache Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich ist. Da die Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den Typ implementierenden Klassen) keine Aussagen über den Typ treffen. Außerhalb, bei der Verwendung (Instanziierung) der Typdefinition, ist das hingegen möglich, da hier die Typvariable durch einen Typ ersetzt ist.
Was man jedoch gerne hätte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist, und zwar derart, dass man bei den als Werte zulässigen Typen ein bestimmtes, benötigtes Protokoll voraussetzen kann. Die tatsächlichen Typparameter sind dann nicht mehr beliebig wählbar, sondern nur noch aus solchen Typen, die die Einschränkungen erfüllen. Eine Möglichkeit, dies zu erzielen, wäre die Einführung von Metatypen, deren Wertebereiche Typen mit von den Metatypen vorgegebenen Eigenschaften sind. Diese Möglichkeit wird jedoch in der Praxis nicht genutzt.
Stattdessen verwendet man eine Art der Beschränkung des Wertebereichs von Typvariablen, die auf Subtyping beruht. Wenn man nämlich erzwingen kann, dass ein tatsächlicher Typparameter (also der Wert der Typvariable) ein Subtyp eines bestimmten Typs ist, der die benötigten Eigenschaften (Methoden) umfasst, dann ist damit alles erreicht, was man benötigt. Aufgrund der Regeln des Subtyping hat jeder solche Typ die Eigenschaften des Supertyps (siehe Kapitel 26).
Der Rest der Definition geht wie oben. Der Ausdruck ""E < Number"" im Abschnitt ""Typvariablen"" ist Deklaration und Beschränkung zugleich. Die Beschränkung ist jedoch, wie bereits erwähnt, keine Typisierung wie in normalen Variablendeklarationen. Sie drückt vielmehr aus, dass die Typen, die als Werte für E eingesetzt werden dürfen, Subtypen von Number sein müssen. Die Deklaration aus Zeile 951 wird damit unzulässig und führt zu einem entsprechenden Typfehler während der statischen Typprüfung. Die Deklaration aus Zeile 952 ist hingegen in Ordnung.","<answer> Die Einführung von Metatypen, deren Wertebereiche Typen mit von den Metatypen vorgegebenen Eigenschaften sind, wird in der Praxis nicht genutzt. <answer> <question> Welche Möglichkeit zur Beschränkung des Wertebereichs von Typvariablen wird in der Praxis nicht genutzt? <question>"
"Gemäß der SMALLTALK-Philosophie müssen auch Metaklassen (als Objekte) Instanzen von Klassen sein. Es erscheint jedoch nicht mehr sinnvoll, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen. Daher ist es nicht notwendig, dass jede Metaklasse (als Klasse) ihre eigene Meta-Metaklasse (als Metaklasse der Klasse) hat. Für die Praxis reicht es aus, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind. In Übereinstimmung mit der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz ""<eine Instanz> ist ein <Klassenname>"" korrekt ergänzen, wird diese Klasse als ""Metaclass"" bezeichnet, da alle ihre Instanzen Metaklassen sind.
Die Frage ergibt sich sofort, von welcher Klasse die Klasse ""Metaclass"" eine Instanz ist. Tatsächlich muss laut der SMALLTALK-Philosophie, nach der Klassen Objekte und jedes Objekt Instanz einer Klasse ist, auch die ""Metaclass"" eine Instanz einer Klasse sein. Um diese Hierarchie nicht ins Unendliche fortsetzen zu müssen, wurde in SMALLTALK zu einem einfachen Trick gegriffen: Die Klasse ""Metaclass"" von ""Metaclass"" wird selbst nur als einfache Metaklasse betrachtet (obwohl sie eigentlich eine Meta-Meta-Metaklasse ist). Genau wie alle anderen Metaklassen ist sie eine Instanz von ""Metaclass"". Für ""Metaclass"" gilt daher: Metaclass ist eine Instanz von Metaclass.
Das folgende Diagramm veranschaulicht die Zusammenhänge. Beachten Sie, dass alle Objekte außerhalb der Ebene 0 gleichzeitig Klassen und Instanzen sind. Der gestrichelte Pfeil stellt die ""Ist-eine-Instanz-von""-Beziehung dar (in UML-Notation).
Die aufmerksame Leserin wird sofort bemerken, dass dieser Kunstgriff, die Hierarchie zu beenden, die Interpretation von Klassen als Mengen von Objekten und deren Instanzen als Elemente dieser Mengen im Sinne von Abschnitt 7.3 verhindert. Andernfalls wäre die Menge von Objekten, die zu ""Metaclass"" gehört, indirekt ein Element von sich selbst, was nicht möglich ist. Dies hat jedoch keine praktischen Auswirkungen.
In SMALLTALK haben wir es also mit einem mehrstufigen Zusammenspiel von Klassen und Instanzen zu tun. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht.
Die Klassen der Ebene 1 sind selbst Objekte und daher Instanzen von Klassen, die auf Ebene 2 stehen. Die Klassen der Ebene 2, die Metaklassen, definieren die Klassen auf Ebene 1. Da es nicht sinnvoll ist, mehrere Instanzen derselben Klasse der Ebene 1 zu haben, die alle über dieselbe Definition verfügen, hat jede Metaklasse genau eine Instanz. Es besteht also eine 1:1-Beziehung zwischen Metaklassen und ihren Instanzen, den Klassen der Ebene 1, die die Objekte der Anwendung beschreiben.
Auf Ebene 3 erhalten alle Metaklassen eine gemeinsame Klasse, von der sie Instanzen sind, nämlich die Klasse ""Metaclass"". Beachten Sie, dass hier wieder eine 1: n-Beziehung vorliegt. Anders als auf Ebene 2, auf der verschiedene Konzepte jeweils eine eigene Klasse haben, wird auf Ebene 3 die Vielfalt auf genau eine Klasse reduziert. Diese Klasse hat dann wieder genau eine Metaklasse.","<answer> Es ist nicht notwendig, dass jede Metaklasse in SMALLTALK ihre eigene Meta-Metaklasse hat, da es in der Praxis ausreicht, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind. <answer> <question> Warum ist es nicht notwendig, dass jede Metaklasse in SMALLTALK ihre eigene Meta-Metaklasse hat? <question>"
"Gemäß der SMALLTALK-Philosophie müssen auch Metaklassen (als Objekte) Instanzen von Klassen sein. Es erscheint jedoch nicht mehr sinnvoll, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen. Daher ist es nicht notwendig, dass jede Metaklasse (als Klasse) ihre eigene Meta-Metaklasse (als Metaklasse der Klasse) hat. Für die Praxis reicht es aus, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind. In Übereinstimmung mit der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz ""<eine Instanz> ist ein <Klassenname>"" korrekt ergänzen, wird diese Klasse als ""Metaclass"" bezeichnet, da alle ihre Instanzen Metaklassen sind.
Die Frage ergibt sich sofort, von welcher Klasse die Klasse ""Metaclass"" eine Instanz ist. Tatsächlich muss laut der SMALLTALK-Philosophie, nach der Klassen Objekte und jedes Objekt Instanz einer Klasse ist, auch die ""Metaclass"" eine Instanz einer Klasse sein. Um diese Hierarchie nicht ins Unendliche fortsetzen zu müssen, wurde in SMALLTALK zu einem einfachen Trick gegriffen: Die Klasse ""Metaclass"" von ""Metaclass"" wird selbst nur als einfache Metaklasse betrachtet (obwohl sie eigentlich eine Meta-Meta-Metaklasse ist). Genau wie alle anderen Metaklassen ist sie eine Instanz von ""Metaclass"". Für ""Metaclass"" gilt daher: Metaclass ist eine Instanz von Metaclass.
Das folgende Diagramm veranschaulicht die Zusammenhänge. Beachten Sie, dass alle Objekte außerhalb der Ebene 0 gleichzeitig Klassen und Instanzen sind. Der gestrichelte Pfeil stellt die ""Ist-eine-Instanz-von""-Beziehung dar (in UML-Notation).
Die aufmerksame Leserin wird sofort bemerken, dass dieser Kunstgriff, die Hierarchie zu beenden, die Interpretation von Klassen als Mengen von Objekten und deren Instanzen als Elemente dieser Mengen im Sinne von Abschnitt 7.3 verhindert. Andernfalls wäre die Menge von Objekten, die zu ""Metaclass"" gehört, indirekt ein Element von sich selbst, was nicht möglich ist. Dies hat jedoch keine praktischen Auswirkungen.
In SMALLTALK haben wir es also mit einem mehrstufigen Zusammenspiel von Klassen und Instanzen zu tun. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht.
Die Klassen der Ebene 1 sind selbst Objekte und daher Instanzen von Klassen, die auf Ebene 2 stehen. Die Klassen der Ebene 2, die Metaklassen, definieren die Klassen auf Ebene 1. Da es nicht sinnvoll ist, mehrere Instanzen derselben Klasse der Ebene 1 zu haben, die alle über dieselbe Definition verfügen, hat jede Metaklasse genau eine Instanz. Es besteht also eine 1:1-Beziehung zwischen Metaklassen und ihren Instanzen, den Klassen der Ebene 1, die die Objekte der Anwendung beschreiben.
Auf Ebene 3 erhalten alle Metaklassen eine gemeinsame Klasse, von der sie Instanzen sind, nämlich die Klasse ""Metaclass"". Beachten Sie, dass hier wieder eine 1: n-Beziehung vorliegt. Anders als auf Ebene 2, auf der verschiedene Konzepte jeweils eine eigene Klasse haben, wird auf Ebene 3 die Vielfalt auf genau eine Klasse reduziert. Diese Klasse hat dann wieder genau eine Metaklasse.","<answer> Die Klasse ""Metaclass"" wird in SMALLTALK als ""Metaclass"" bezeichnet, weil alle ihre Instanzen Metaklassen sind. Dies folgt der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz ""<eine Instanz> ist ein <Klassenname>"" korrekt ergänzen. <answer> <question> Wie wird die Klasse ""Metaclass"" in SMALLTALK bezeichnet und warum? <question>"
"Gemäß der SMALLTALK-Philosophie müssen auch Metaklassen (als Objekte) Instanzen von Klassen sein. Es erscheint jedoch nicht mehr sinnvoll, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen. Daher ist es nicht notwendig, dass jede Metaklasse (als Klasse) ihre eigene Meta-Metaklasse (als Metaklasse der Klasse) hat. Für die Praxis reicht es aus, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind. In Übereinstimmung mit der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz ""<eine Instanz> ist ein <Klassenname>"" korrekt ergänzen, wird diese Klasse als ""Metaclass"" bezeichnet, da alle ihre Instanzen Metaklassen sind.
Die Frage ergibt sich sofort, von welcher Klasse die Klasse ""Metaclass"" eine Instanz ist. Tatsächlich muss laut der SMALLTALK-Philosophie, nach der Klassen Objekte und jedes Objekt Instanz einer Klasse ist, auch die ""Metaclass"" eine Instanz einer Klasse sein. Um diese Hierarchie nicht ins Unendliche fortsetzen zu müssen, wurde in SMALLTALK zu einem einfachen Trick gegriffen: Die Klasse ""Metaclass"" von ""Metaclass"" wird selbst nur als einfache Metaklasse betrachtet (obwohl sie eigentlich eine Meta-Meta-Metaklasse ist). Genau wie alle anderen Metaklassen ist sie eine Instanz von ""Metaclass"". Für ""Metaclass"" gilt daher: Metaclass ist eine Instanz von Metaclass.
Das folgende Diagramm veranschaulicht die Zusammenhänge. Beachten Sie, dass alle Objekte außerhalb der Ebene 0 gleichzeitig Klassen und Instanzen sind. Der gestrichelte Pfeil stellt die ""Ist-eine-Instanz-von""-Beziehung dar (in UML-Notation).
Die aufmerksame Leserin wird sofort bemerken, dass dieser Kunstgriff, die Hierarchie zu beenden, die Interpretation von Klassen als Mengen von Objekten und deren Instanzen als Elemente dieser Mengen im Sinne von Abschnitt 7.3 verhindert. Andernfalls wäre die Menge von Objekten, die zu ""Metaclass"" gehört, indirekt ein Element von sich selbst, was nicht möglich ist. Dies hat jedoch keine praktischen Auswirkungen.
In SMALLTALK haben wir es also mit einem mehrstufigen Zusammenspiel von Klassen und Instanzen zu tun. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht.
Die Klassen der Ebene 1 sind selbst Objekte und daher Instanzen von Klassen, die auf Ebene 2 stehen. Die Klassen der Ebene 2, die Metaklassen, definieren die Klassen auf Ebene 1. Da es nicht sinnvoll ist, mehrere Instanzen derselben Klasse der Ebene 1 zu haben, die alle über dieselbe Definition verfügen, hat jede Metaklasse genau eine Instanz. Es besteht also eine 1:1-Beziehung zwischen Metaklassen und ihren Instanzen, den Klassen der Ebene 1, die die Objekte der Anwendung beschreiben.
Auf Ebene 3 erhalten alle Metaklassen eine gemeinsame Klasse, von der sie Instanzen sind, nämlich die Klasse ""Metaclass"". Beachten Sie, dass hier wieder eine 1: n-Beziehung vorliegt. Anders als auf Ebene 2, auf der verschiedene Konzepte jeweils eine eigene Klasse haben, wird auf Ebene 3 die Vielfalt auf genau eine Klasse reduziert. Diese Klasse hat dann wieder genau eine Metaklasse.","<answer> Die Klasse ""Metaclass"" von ""Metaclass"" wird selbst als einfache Metaklasse betrachtet, obwohl sie eigentlich eine Meta-Meta-Metaklasse ist. Genau wie alle anderen Metaklassen ist sie eine Instanz von ""Metaclass"". Daher gilt für ""Metaclass"": Metaclass ist eine Instanz von Metaclass. <answer> <question> Was ist die Beziehung zwischen der Klasse ""Metaclass"" und ihrer eigenen Meta-Metaklasse? <question>"
"Gemäß der SMALLTALK-Philosophie müssen auch Metaklassen (als Objekte) Instanzen von Klassen sein. Es erscheint jedoch nicht mehr sinnvoll, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen. Daher ist es nicht notwendig, dass jede Metaklasse (als Klasse) ihre eigene Meta-Metaklasse (als Metaklasse der Klasse) hat. Für die Praxis reicht es aus, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind. In Übereinstimmung mit der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz ""<eine Instanz> ist ein <Klassenname>"" korrekt ergänzen, wird diese Klasse als ""Metaclass"" bezeichnet, da alle ihre Instanzen Metaklassen sind.
Die Frage ergibt sich sofort, von welcher Klasse die Klasse ""Metaclass"" eine Instanz ist. Tatsächlich muss laut der SMALLTALK-Philosophie, nach der Klassen Objekte und jedes Objekt Instanz einer Klasse ist, auch die ""Metaclass"" eine Instanz einer Klasse sein. Um diese Hierarchie nicht ins Unendliche fortsetzen zu müssen, wurde in SMALLTALK zu einem einfachen Trick gegriffen: Die Klasse ""Metaclass"" von ""Metaclass"" wird selbst nur als einfache Metaklasse betrachtet (obwohl sie eigentlich eine Meta-Meta-Metaklasse ist). Genau wie alle anderen Metaklassen ist sie eine Instanz von ""Metaclass"". Für ""Metaclass"" gilt daher: Metaclass ist eine Instanz von Metaclass.
Das folgende Diagramm veranschaulicht die Zusammenhänge. Beachten Sie, dass alle Objekte außerhalb der Ebene 0 gleichzeitig Klassen und Instanzen sind. Der gestrichelte Pfeil stellt die ""Ist-eine-Instanz-von""-Beziehung dar (in UML-Notation).
Die aufmerksame Leserin wird sofort bemerken, dass dieser Kunstgriff, die Hierarchie zu beenden, die Interpretation von Klassen als Mengen von Objekten und deren Instanzen als Elemente dieser Mengen im Sinne von Abschnitt 7.3 verhindert. Andernfalls wäre die Menge von Objekten, die zu ""Metaclass"" gehört, indirekt ein Element von sich selbst, was nicht möglich ist. Dies hat jedoch keine praktischen Auswirkungen.
In SMALLTALK haben wir es also mit einem mehrstufigen Zusammenspiel von Klassen und Instanzen zu tun. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht.
Die Klassen der Ebene 1 sind selbst Objekte und daher Instanzen von Klassen, die auf Ebene 2 stehen. Die Klassen der Ebene 2, die Metaklassen, definieren die Klassen auf Ebene 1. Da es nicht sinnvoll ist, mehrere Instanzen derselben Klasse der Ebene 1 zu haben, die alle über dieselbe Definition verfügen, hat jede Metaklasse genau eine Instanz. Es besteht also eine 1:1-Beziehung zwischen Metaklassen und ihren Instanzen, den Klassen der Ebene 1, die die Objekte der Anwendung beschreiben.
Auf Ebene 3 erhalten alle Metaklassen eine gemeinsame Klasse, von der sie Instanzen sind, nämlich die Klasse ""Metaclass"". Beachten Sie, dass hier wieder eine 1: n-Beziehung vorliegt. Anders als auf Ebene 2, auf der verschiedene Konzepte jeweils eine eigene Klasse haben, wird auf Ebene 3 die Vielfalt auf genau eine Klasse reduziert. Diese Klasse hat dann wieder genau eine Metaklasse.","<answer> In SMALLTALK gibt es mehrere Ebenen im Zusammenhang mit Klassen und Instanzen: Ebene 0: Konkrete Objekte, die nicht instanziierbar sind und Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Ebene 1: Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Ebene 2: Metaklassen, die die Klassen auf Ebene 1 definieren. Jede Metaklasse hat genau eine Instanz. Ebene 3: Die Klasse ""Metaclass"", von der alle Metaklassen Instanzen sind. <answer> <question> Welche Ebenen gibt es in SMALLTALK im Zusammenhang mit Klassen und Instanzen? <question>"
"Gemäß der SMALLTALK-Philosophie müssen auch Metaklassen (als Objekte) Instanzen von Klassen sein. Es erscheint jedoch nicht mehr sinnvoll, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen. Daher ist es nicht notwendig, dass jede Metaklasse (als Klasse) ihre eigene Meta-Metaklasse (als Metaklasse der Klasse) hat. Für die Praxis reicht es aus, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind. In Übereinstimmung mit der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz ""<eine Instanz> ist ein <Klassenname>"" korrekt ergänzen, wird diese Klasse als ""Metaclass"" bezeichnet, da alle ihre Instanzen Metaklassen sind.
Die Frage ergibt sich sofort, von welcher Klasse die Klasse ""Metaclass"" eine Instanz ist. Tatsächlich muss laut der SMALLTALK-Philosophie, nach der Klassen Objekte und jedes Objekt Instanz einer Klasse ist, auch die ""Metaclass"" eine Instanz einer Klasse sein. Um diese Hierarchie nicht ins Unendliche fortsetzen zu müssen, wurde in SMALLTALK zu einem einfachen Trick gegriffen: Die Klasse ""Metaclass"" von ""Metaclass"" wird selbst nur als einfache Metaklasse betrachtet (obwohl sie eigentlich eine Meta-Meta-Metaklasse ist). Genau wie alle anderen Metaklassen ist sie eine Instanz von ""Metaclass"". Für ""Metaclass"" gilt daher: Metaclass ist eine Instanz von Metaclass.
Das folgende Diagramm veranschaulicht die Zusammenhänge. Beachten Sie, dass alle Objekte außerhalb der Ebene 0 gleichzeitig Klassen und Instanzen sind. Der gestrichelte Pfeil stellt die ""Ist-eine-Instanz-von""-Beziehung dar (in UML-Notation).
Die aufmerksame Leserin wird sofort bemerken, dass dieser Kunstgriff, die Hierarchie zu beenden, die Interpretation von Klassen als Mengen von Objekten und deren Instanzen als Elemente dieser Mengen im Sinne von Abschnitt 7.3 verhindert. Andernfalls wäre die Menge von Objekten, die zu ""Metaclass"" gehört, indirekt ein Element von sich selbst, was nicht möglich ist. Dies hat jedoch keine praktischen Auswirkungen.
In SMALLTALK haben wir es also mit einem mehrstufigen Zusammenspiel von Klassen und Instanzen zu tun. Auf der untersten Stufe, Ebene 0, befinden sich konkrete Objekte, die nicht instanziierbar sind und in der Regel Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Eine Stufe darüber, auf Ebene 1, stehen die Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Diese Klassen repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. In der Regel werden mehrere Objekte der Ebene 0 zu jeder Klasse der Ebene 1 erstellt, wodurch eine 1: n-Beziehung zwischen ihnen entsteht.
Die Klassen der Ebene 1 sind selbst Objekte und daher Instanzen von Klassen, die auf Ebene 2 stehen. Die Klassen der Ebene 2, die Metaklassen, definieren die Klassen auf Ebene 1. Da es nicht sinnvoll ist, mehrere Instanzen derselben Klasse der Ebene 1 zu haben, die alle über dieselbe Definition verfügen, hat jede Metaklasse genau eine Instanz. Es besteht also eine 1:1-Beziehung zwischen Metaklassen und ihren Instanzen, den Klassen der Ebene 1, die die Objekte der Anwendung beschreiben.
Auf Ebene 3 erhalten alle Metaklassen eine gemeinsame Klasse, von der sie Instanzen sind, nämlich die Klasse ""Metaclass"". Beachten Sie, dass hier wieder eine 1: n-Beziehung vorliegt. Anders als auf Ebene 2, auf der verschiedene Konzepte jeweils eine eigene Klasse haben, wird auf Ebene 3 die Vielfalt auf genau eine Klasse reduziert. Diese Klasse hat dann wieder genau eine Metaklasse.","<answer> Die Klassen der Ebene 1 repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. Die Metaklassen der Ebene 2 definieren die Klassen auf Ebene 1, wobei jede Metaklasse genau eine Instanz auf Ebene 1 hat. <answer> <question> Was repräsentieren die Klassen der Ebene 1 und was repräsentieren die Metaklassen der Ebene 2? <question>"
"Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.
Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.
Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C#) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.
Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie JAVA oder C#; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.
Obwohl die Zuweisungskompatibilität in C++ wie in JAVA über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C#) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.
Bei virtuellen Methoden wird hingegen wie in JAVA zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und JAVA-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In JAVA hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C# hat man diese Entscheidung nicht nachvollzogen (s. Abschnitt 50.2).
In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu JAVA (und genau wie z. B. in ADA) werden aus Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expandiert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer Template) ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.
Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in JAVA oder C# wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden (s. Abschnitt 51.5.2) – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen:
""Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup
Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften JAVAs gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.","<answer> Das Ziel des Typsystems von C++ ist, objektorientierte Programmierung mit starker Typsicherheit zu ermöglichen, während gleichzeitig die volle Freiheit der Programmiererin erhalten bleibt und der Laufzeit-Overhead minimiert wird. <answer> <question> Was ist das Ziel des Typsystems von C++? <question>"
"Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.
Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.
Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C#) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.
Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie JAVA oder C#; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.
Obwohl die Zuweisungskompatibilität in C++ wie in JAVA über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C#) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.
Bei virtuellen Methoden wird hingegen wie in JAVA zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und JAVA-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In JAVA hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C# hat man diese Entscheidung nicht nachvollzogen (s. Abschnitt 50.2).
In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu JAVA (und genau wie z. B. in ADA) werden aus Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expandiert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer Template) ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.
Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in JAVA oder C# wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden (s. Abschnitt 51.5.2) – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen:
""Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup
Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften JAVAs gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.","<answer> In C++ gibt es primitive Datentypen wie int, bool, etc. Diese Datentypen sind genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. <answer> <question> Welche primitive Datentypen gibt es in C++? <question>"
"Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.
Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.
Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C#) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.
Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie JAVA oder C#; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.
Obwohl die Zuweisungskompatibilität in C++ wie in JAVA über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C#) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.
Bei virtuellen Methoden wird hingegen wie in JAVA zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und JAVA-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In JAVA hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C# hat man diese Entscheidung nicht nachvollzogen (s. Abschnitt 50.2).
In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu JAVA (und genau wie z. B. in ADA) werden aus Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expandiert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer Template) ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.
Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in JAVA oder C# wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden (s. Abschnitt 51.5.2) – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen:
""Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup
Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften JAVAs gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.","<answer> Mehrfachvererbung in C++ ermöglicht es, eine Klasse von mehreren anderen abzuleiten. Dadurch kann eine Klasse mehrere direkte Supertypen haben, einen pro direkte Superklasse. <answer> <question> Was ermöglicht Mehrfachvererbung in C++? <question>"
"Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.
Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.
Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C#) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.
Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie JAVA oder C#; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.
Obwohl die Zuweisungskompatibilität in C++ wie in JAVA über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C#) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.
Bei virtuellen Methoden wird hingegen wie in JAVA zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und JAVA-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In JAVA hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C# hat man diese Entscheidung nicht nachvollzogen (s. Abschnitt 50.2).
In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu JAVA (und genau wie z. B. in ADA) werden aus Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expandiert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer Template) ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.
Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in JAVA oder C# wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden (s. Abschnitt 51.5.2) – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen:
""Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup
Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften JAVAs gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.","<answer> Standardmäßig erfolgt die Methodenbindung (Methodenaufruf) in C++ statisch. Das bedeutet, dass die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable hat. <answer> <question> Wie erfolgt die Methodenbindung in C++ standardmäßig? <question>"
"Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.
Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.
Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C#) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.
Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie JAVA oder C#; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.
Obwohl die Zuweisungskompatibilität in C++ wie in JAVA über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C#) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.
Bei virtuellen Methoden wird hingegen wie in JAVA zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und JAVA-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In JAVA hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C# hat man diese Entscheidung nicht nachvollzogen (s. Abschnitt 50.2).
In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu JAVA (und genau wie z. B. in ADA) werden aus Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expandiert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer Template) ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.
Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in JAVA oder C# wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden (s. Abschnitt 51.5.2) – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen:
""Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup
Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften JAVAs gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.","<answer> In C++ werden Methoden zur Laufzeit dynamisch gebunden, wenn sie mit dem Schlüsselwort virtual deklariert sind. Bei virtuellen Methoden wird zur Laufzeit überprüft, welchen Typs das Objekt ist, und zur entsprechenden Methodenimplementierung verzweigt. <answer> <question> Wann werden Methoden in C++ zur Laufzeit dynamisch gebunden? <question>"
"Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.
Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.
Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C#) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.
Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie JAVA oder C#; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.
Obwohl die Zuweisungskompatibilität in C++ wie in JAVA über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C#) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.
Bei virtuellen Methoden wird hingegen wie in JAVA zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und JAVA-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In JAVA hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C# hat man diese Entscheidung nicht nachvollzogen (s. Abschnitt 50.2).
In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu JAVA (und genau wie z. B. in ADA) werden aus Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expandiert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer Template) ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.
Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in JAVA oder C# wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden (s. Abschnitt 51.5.2) – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen:
""Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup
Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften JAVAs gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.","<answer> Generizität in C++ wird mit Hilfe von Templates erreicht. Ein Template ist ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Tatsächlich werden aus Templates neue Typen erzeugt, und für jede Instanz eines generischen Typs wird ein neuer Typ erzeugt und kompiliert. <answer> <question> Wie wird Generizität in C++ implementiert? <question>"
"Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.
Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.
Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C#) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.
Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie JAVA oder C#; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.
Obwohl die Zuweisungskompatibilität in C++ wie in JAVA über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C#) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.
Bei virtuellen Methoden wird hingegen wie in JAVA zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und JAVA-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In JAVA hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C# hat man diese Entscheidung nicht nachvollzogen (s. Abschnitt 50.2).
In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu JAVA (und genau wie z. B. in ADA) werden aus Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expandiert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer Template) ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.
Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in JAVA oder C# wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden (s. Abschnitt 51.5.2) – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen:
""Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup
Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften JAVAs gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.","<answer> Eine Typumwandlung (Type cast) in C++ ist ein Ausdruck der Form <Typ> <Ausdruck>, der den Compiler davon überzeugt, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Diese Umwandlung wird vom Compiler überwacht, und die Zulässigkeit wird zur Laufzeit überprüft. <answer> <question> Was ist ein Typumwandlung (Type cast) in C++? <question>"
"Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.
Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.
Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C#) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.
Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie JAVA oder C#; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.
Obwohl die Zuweisungskompatibilität in C++ wie in JAVA über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C#) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.
Bei virtuellen Methoden wird hingegen wie in JAVA zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und JAVA-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In JAVA hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C# hat man diese Entscheidung nicht nachvollzogen (s. Abschnitt 50.2).
In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu JAVA (und genau wie z. B. in ADA) werden aus Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expandiert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer Template) ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.
Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in JAVA oder C# wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden (s. Abschnitt 51.5.2) – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen:
""Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right."" Margaret A. Ellis und Bjarne Stroustrup
Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften JAVAs gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.","<answer> Die Zulässigkeit von Typumwandlungen in C++ wird zur Laufzeit überprüft, und sie kann nicht zur Kompilierzeit überprüft werden. Typumwandlungen sollten vermieden werden, da sie die Typsicherheit untergraben können. <answer> <question> Wie wird die Zulässigkeit von Typumwandlungen in C++ überprüft? <question>"
"Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Bei der Behandlung von JAVA sind wir bereits auf die Assert-Anweisung gestoßen, die es erlaubte, Zusicherungen zur Laufzeit auszuwerten und das Programm bei einer Verletzung ggf. abzubrechen. Da es sich jedoch um eine Anweisung handelte, gab es keine von der Sprachdefinition vorgesehenen Orte, an denen solche Zusicherungen auftreten sollten — ihre Platzierung lag ganz im Ermessen der Programmiererin. In EIFFEL ist dies anders.
Die Syntax zur Definition einer Methode in EIFFEL sieht zwei Schlüsselwörter vor, ""require"" und ""ensure"", von denen das erste vor der Implementierung der Methode (dem Methodenrumpf) und das zweite danach auftreten kann. Beiden Schlüsselwörtern folgen Boolesche Ausdrücke, die alle zu ""wahr"" ausgewertet werden müssen. Die Idee hinter einer ""Require""-Klausel ist, dass die darin ausgedrückten Bedingungen erfüllt sein müssen, damit die betreffende Methode ordnungsgemäß funktionieren kann. Zum Beispiel macht es Sinn, für die Methode ""pop"" in der Klasse ""STACK"" zu verlangen, dass der Stapel, auf dem die Methode aufgerufen wird, nicht leer ist. Die Idee hinter einer ""Ensure""-Klausel ist, dass eine Methode, deren ""Require""-Klausel erfüllt war, im Gegenzug garantieren muss, dass die in der ""Ensure""-Klausel ausgedrückten Bedingungen erfüllt sind. Im Fall des Stacks bedeutet das beispielsweise, dass nach einem ""push"" das übergebene Element tatsächlich oben auf dem Stapel liegt, sodass die Methode ""top"" beispielsweise das soeben auf den Stapel gelegte Element zurückgeben kann. Um ihre Bedingungen zu formulieren, dürfen die Ausdrücke in beiden Klauseln auf Abfragen (queries) der Klasse zurückgreifen. Diese sollten jedoch tunlichst nebenwirkungsfrei sein, zum einen, weil die ""Ensure""-Klausel sonst nicht garantieren kann, dass eine geprüfte Bedingung auch nach ihrer vollständigen Auswertung immer noch wahr ist (man stelle sich vor, was passieren würde, wenn die ""Ensure""-Klausel in ""push"" die Methode ""pop"" aufrufen würde!), zum anderen, weil in EIFFEL (wie in JAVA) die Überprüfung der Zusicherungen zur Laufzeit deaktiviert werden kann (wodurch das Programm bei Überprüfung der Zusicherungen eine andere Semantik hätte als ohne; vergleiche die Anmerkungen zur Assert-Anweisung in JAVA in Kurseinheit 4, Kapitel 38).
Neben der Möglichkeit, Vor- und Nachbedingungen zu formulieren, gibt es in EIFFEL auch die Möglichkeit, sog. Klasseninvarianten (Schlüsselwort ""invariant"") zu deklarieren. Klasseninvarianten müssen jederzeit zwischen zwei Methodenaufrufen gelten; man kann sich vorstellen, dass sie jeder Vor- und Nachbedingung per Konjunktion hinzugefügt werden. Auf die etwas subtilen Probleme, die das Aliasing in Zusammenhang mit Zusicherungen schafft, wollen wir an dieser Stelle nicht eingehen; dies wird ausführlicher in Kurs 01853 behandelt.
Zusicherungen werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen auch Vor- und Nachbedingungen angepasst werden. Allerdings gilt hierbei, dass die Vorbedingung nur abgeschwächt und die Nachbedingung nur verschärft werden darf. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.","<answer> Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Anders als in Java, wo Zusicherungen flexibel platziert werden können, gibt es in EIFFEL spezielle vorgesehene Stellen für diese Zusicherungen. <answer> <question> Was ist ein herausragendes Merkmal von EIFFEL in Bezug auf Zusicherungen (Assertions)? <question>"
"Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Bei der Behandlung von JAVA sind wir bereits auf die Assert-Anweisung gestoßen, die es erlaubte, Zusicherungen zur Laufzeit auszuwerten und das Programm bei einer Verletzung ggf. abzubrechen. Da es sich jedoch um eine Anweisung handelte, gab es keine von der Sprachdefinition vorgesehenen Orte, an denen solche Zusicherungen auftreten sollten — ihre Platzierung lag ganz im Ermessen der Programmiererin. In EIFFEL ist dies anders.
Die Syntax zur Definition einer Methode in EIFFEL sieht zwei Schlüsselwörter vor, ""require"" und ""ensure"", von denen das erste vor der Implementierung der Methode (dem Methodenrumpf) und das zweite danach auftreten kann. Beiden Schlüsselwörtern folgen Boolesche Ausdrücke, die alle zu ""wahr"" ausgewertet werden müssen. Die Idee hinter einer ""Require""-Klausel ist, dass die darin ausgedrückten Bedingungen erfüllt sein müssen, damit die betreffende Methode ordnungsgemäß funktionieren kann. Zum Beispiel macht es Sinn, für die Methode ""pop"" in der Klasse ""STACK"" zu verlangen, dass der Stapel, auf dem die Methode aufgerufen wird, nicht leer ist. Die Idee hinter einer ""Ensure""-Klausel ist, dass eine Methode, deren ""Require""-Klausel erfüllt war, im Gegenzug garantieren muss, dass die in der ""Ensure""-Klausel ausgedrückten Bedingungen erfüllt sind. Im Fall des Stacks bedeutet das beispielsweise, dass nach einem ""push"" das übergebene Element tatsächlich oben auf dem Stapel liegt, sodass die Methode ""top"" beispielsweise das soeben auf den Stapel gelegte Element zurückgeben kann. Um ihre Bedingungen zu formulieren, dürfen die Ausdrücke in beiden Klauseln auf Abfragen (queries) der Klasse zurückgreifen. Diese sollten jedoch tunlichst nebenwirkungsfrei sein, zum einen, weil die ""Ensure""-Klausel sonst nicht garantieren kann, dass eine geprüfte Bedingung auch nach ihrer vollständigen Auswertung immer noch wahr ist (man stelle sich vor, was passieren würde, wenn die ""Ensure""-Klausel in ""push"" die Methode ""pop"" aufrufen würde!), zum anderen, weil in EIFFEL (wie in JAVA) die Überprüfung der Zusicherungen zur Laufzeit deaktiviert werden kann (wodurch das Programm bei Überprüfung der Zusicherungen eine andere Semantik hätte als ohne; vergleiche die Anmerkungen zur Assert-Anweisung in JAVA in Kurseinheit 4, Kapitel 38).
Neben der Möglichkeit, Vor- und Nachbedingungen zu formulieren, gibt es in EIFFEL auch die Möglichkeit, sog. Klasseninvarianten (Schlüsselwort ""invariant"") zu deklarieren. Klasseninvarianten müssen jederzeit zwischen zwei Methodenaufrufen gelten; man kann sich vorstellen, dass sie jeder Vor- und Nachbedingung per Konjunktion hinzugefügt werden. Auf die etwas subtilen Probleme, die das Aliasing in Zusammenhang mit Zusicherungen schafft, wollen wir an dieser Stelle nicht eingehen; dies wird ausführlicher in Kurs 01853 behandelt.
Zusicherungen werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen auch Vor- und Nachbedingungen angepasst werden. Allerdings gilt hierbei, dass die Vorbedingung nur abgeschwächt und die Nachbedingung nur verschärft werden darf. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.","<answer> In EIFFEL werden die Schlüsselwörter ""require"" (vor der Implementierung der Methode) und ""ensure"" (nach der Implementierung der Methode) verwendet, um Vor- und Nachbedingungen für Methoden zu definieren. <answer> <question> Welche Schlüsselwörter werden in EIFFEL verwendet, um Vor- und Nachbedingungen für Methoden zu definieren? <question>"
"Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Bei der Behandlung von JAVA sind wir bereits auf die Assert-Anweisung gestoßen, die es erlaubte, Zusicherungen zur Laufzeit auszuwerten und das Programm bei einer Verletzung ggf. abzubrechen. Da es sich jedoch um eine Anweisung handelte, gab es keine von der Sprachdefinition vorgesehenen Orte, an denen solche Zusicherungen auftreten sollten — ihre Platzierung lag ganz im Ermessen der Programmiererin. In EIFFEL ist dies anders.
Die Syntax zur Definition einer Methode in EIFFEL sieht zwei Schlüsselwörter vor, ""require"" und ""ensure"", von denen das erste vor der Implementierung der Methode (dem Methodenrumpf) und das zweite danach auftreten kann. Beiden Schlüsselwörtern folgen Boolesche Ausdrücke, die alle zu ""wahr"" ausgewertet werden müssen. Die Idee hinter einer ""Require""-Klausel ist, dass die darin ausgedrückten Bedingungen erfüllt sein müssen, damit die betreffende Methode ordnungsgemäß funktionieren kann. Zum Beispiel macht es Sinn, für die Methode ""pop"" in der Klasse ""STACK"" zu verlangen, dass der Stapel, auf dem die Methode aufgerufen wird, nicht leer ist. Die Idee hinter einer ""Ensure""-Klausel ist, dass eine Methode, deren ""Require""-Klausel erfüllt war, im Gegenzug garantieren muss, dass die in der ""Ensure""-Klausel ausgedrückten Bedingungen erfüllt sind. Im Fall des Stacks bedeutet das beispielsweise, dass nach einem ""push"" das übergebene Element tatsächlich oben auf dem Stapel liegt, sodass die Methode ""top"" beispielsweise das soeben auf den Stapel gelegte Element zurückgeben kann. Um ihre Bedingungen zu formulieren, dürfen die Ausdrücke in beiden Klauseln auf Abfragen (queries) der Klasse zurückgreifen. Diese sollten jedoch tunlichst nebenwirkungsfrei sein, zum einen, weil die ""Ensure""-Klausel sonst nicht garantieren kann, dass eine geprüfte Bedingung auch nach ihrer vollständigen Auswertung immer noch wahr ist (man stelle sich vor, was passieren würde, wenn die ""Ensure""-Klausel in ""push"" die Methode ""pop"" aufrufen würde!), zum anderen, weil in EIFFEL (wie in JAVA) die Überprüfung der Zusicherungen zur Laufzeit deaktiviert werden kann (wodurch das Programm bei Überprüfung der Zusicherungen eine andere Semantik hätte als ohne; vergleiche die Anmerkungen zur Assert-Anweisung in JAVA in Kurseinheit 4, Kapitel 38).
Neben der Möglichkeit, Vor- und Nachbedingungen zu formulieren, gibt es in EIFFEL auch die Möglichkeit, sog. Klasseninvarianten (Schlüsselwort ""invariant"") zu deklarieren. Klasseninvarianten müssen jederzeit zwischen zwei Methodenaufrufen gelten; man kann sich vorstellen, dass sie jeder Vor- und Nachbedingung per Konjunktion hinzugefügt werden. Auf die etwas subtilen Probleme, die das Aliasing in Zusammenhang mit Zusicherungen schafft, wollen wir an dieser Stelle nicht eingehen; dies wird ausführlicher in Kurs 01853 behandelt.
Zusicherungen werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen auch Vor- und Nachbedingungen angepasst werden. Allerdings gilt hierbei, dass die Vorbedingung nur abgeschwächt und die Nachbedingung nur verschärft werden darf. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.","<answer> Vor- und Nachbedingungen in EIFFEL werden als Boolesche Ausdrücke formuliert, die immer als ""wahr"" ausgewertet werden müssen. Die ""require""-Klausel stellt Bedingungen dar, die vor dem Aufruf der Methode erfüllt sein müssen, während die ""ensure""-Klausel Bedingungen darstellt, die nach dem Aufruf der Methode garantiert erfüllt sind. <answer> <question> Wie werden Vor- und Nachbedingungen in EIFFEL formuliert? <question>"
"Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Bei der Behandlung von JAVA sind wir bereits auf die Assert-Anweisung gestoßen, die es erlaubte, Zusicherungen zur Laufzeit auszuwerten und das Programm bei einer Verletzung ggf. abzubrechen. Da es sich jedoch um eine Anweisung handelte, gab es keine von der Sprachdefinition vorgesehenen Orte, an denen solche Zusicherungen auftreten sollten — ihre Platzierung lag ganz im Ermessen der Programmiererin. In EIFFEL ist dies anders.
Die Syntax zur Definition einer Methode in EIFFEL sieht zwei Schlüsselwörter vor, ""require"" und ""ensure"", von denen das erste vor der Implementierung der Methode (dem Methodenrumpf) und das zweite danach auftreten kann. Beiden Schlüsselwörtern folgen Boolesche Ausdrücke, die alle zu ""wahr"" ausgewertet werden müssen. Die Idee hinter einer ""Require""-Klausel ist, dass die darin ausgedrückten Bedingungen erfüllt sein müssen, damit die betreffende Methode ordnungsgemäß funktionieren kann. Zum Beispiel macht es Sinn, für die Methode ""pop"" in der Klasse ""STACK"" zu verlangen, dass der Stapel, auf dem die Methode aufgerufen wird, nicht leer ist. Die Idee hinter einer ""Ensure""-Klausel ist, dass eine Methode, deren ""Require""-Klausel erfüllt war, im Gegenzug garantieren muss, dass die in der ""Ensure""-Klausel ausgedrückten Bedingungen erfüllt sind. Im Fall des Stacks bedeutet das beispielsweise, dass nach einem ""push"" das übergebene Element tatsächlich oben auf dem Stapel liegt, sodass die Methode ""top"" beispielsweise das soeben auf den Stapel gelegte Element zurückgeben kann. Um ihre Bedingungen zu formulieren, dürfen die Ausdrücke in beiden Klauseln auf Abfragen (queries) der Klasse zurückgreifen. Diese sollten jedoch tunlichst nebenwirkungsfrei sein, zum einen, weil die ""Ensure""-Klausel sonst nicht garantieren kann, dass eine geprüfte Bedingung auch nach ihrer vollständigen Auswertung immer noch wahr ist (man stelle sich vor, was passieren würde, wenn die ""Ensure""-Klausel in ""push"" die Methode ""pop"" aufrufen würde!), zum anderen, weil in EIFFEL (wie in JAVA) die Überprüfung der Zusicherungen zur Laufzeit deaktiviert werden kann (wodurch das Programm bei Überprüfung der Zusicherungen eine andere Semantik hätte als ohne; vergleiche die Anmerkungen zur Assert-Anweisung in JAVA in Kurseinheit 4, Kapitel 38).
Neben der Möglichkeit, Vor- und Nachbedingungen zu formulieren, gibt es in EIFFEL auch die Möglichkeit, sog. Klasseninvarianten (Schlüsselwort ""invariant"") zu deklarieren. Klasseninvarianten müssen jederzeit zwischen zwei Methodenaufrufen gelten; man kann sich vorstellen, dass sie jeder Vor- und Nachbedingung per Konjunktion hinzugefügt werden. Auf die etwas subtilen Probleme, die das Aliasing in Zusammenhang mit Zusicherungen schafft, wollen wir an dieser Stelle nicht eingehen; dies wird ausführlicher in Kurs 01853 behandelt.
Zusicherungen werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen auch Vor- und Nachbedingungen angepasst werden. Allerdings gilt hierbei, dass die Vorbedingung nur abgeschwächt und die Nachbedingung nur verschärft werden darf. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.","<answer> Klasseninvarianten in EIFFEL sind Bedingungen, die zwischen zwei Methodenaufrufen in einer Klasse immer gelten müssen. Sie werden mit dem Schlüsselwort ""invariant"" deklariert und sind sozusagen eine Zusammenfassung von Vor- und Nachbedingungen, die für die Klasse als Ganzes gelten. <answer> <question> Was sind Klasseninvarianten in EIFFEL? <question>"
"Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Bei der Behandlung von JAVA sind wir bereits auf die Assert-Anweisung gestoßen, die es erlaubte, Zusicherungen zur Laufzeit auszuwerten und das Programm bei einer Verletzung ggf. abzubrechen. Da es sich jedoch um eine Anweisung handelte, gab es keine von der Sprachdefinition vorgesehenen Orte, an denen solche Zusicherungen auftreten sollten — ihre Platzierung lag ganz im Ermessen der Programmiererin. In EIFFEL ist dies anders.
Die Syntax zur Definition einer Methode in EIFFEL sieht zwei Schlüsselwörter vor, ""require"" und ""ensure"", von denen das erste vor der Implementierung der Methode (dem Methodenrumpf) und das zweite danach auftreten kann. Beiden Schlüsselwörtern folgen Boolesche Ausdrücke, die alle zu ""wahr"" ausgewertet werden müssen. Die Idee hinter einer ""Require""-Klausel ist, dass die darin ausgedrückten Bedingungen erfüllt sein müssen, damit die betreffende Methode ordnungsgemäß funktionieren kann. Zum Beispiel macht es Sinn, für die Methode ""pop"" in der Klasse ""STACK"" zu verlangen, dass der Stapel, auf dem die Methode aufgerufen wird, nicht leer ist. Die Idee hinter einer ""Ensure""-Klausel ist, dass eine Methode, deren ""Require""-Klausel erfüllt war, im Gegenzug garantieren muss, dass die in der ""Ensure""-Klausel ausgedrückten Bedingungen erfüllt sind. Im Fall des Stacks bedeutet das beispielsweise, dass nach einem ""push"" das übergebene Element tatsächlich oben auf dem Stapel liegt, sodass die Methode ""top"" beispielsweise das soeben auf den Stapel gelegte Element zurückgeben kann. Um ihre Bedingungen zu formulieren, dürfen die Ausdrücke in beiden Klauseln auf Abfragen (queries) der Klasse zurückgreifen. Diese sollten jedoch tunlichst nebenwirkungsfrei sein, zum einen, weil die ""Ensure""-Klausel sonst nicht garantieren kann, dass eine geprüfte Bedingung auch nach ihrer vollständigen Auswertung immer noch wahr ist (man stelle sich vor, was passieren würde, wenn die ""Ensure""-Klausel in ""push"" die Methode ""pop"" aufrufen würde!), zum anderen, weil in EIFFEL (wie in JAVA) die Überprüfung der Zusicherungen zur Laufzeit deaktiviert werden kann (wodurch das Programm bei Überprüfung der Zusicherungen eine andere Semantik hätte als ohne; vergleiche die Anmerkungen zur Assert-Anweisung in JAVA in Kurseinheit 4, Kapitel 38).
Neben der Möglichkeit, Vor- und Nachbedingungen zu formulieren, gibt es in EIFFEL auch die Möglichkeit, sog. Klasseninvarianten (Schlüsselwort ""invariant"") zu deklarieren. Klasseninvarianten müssen jederzeit zwischen zwei Methodenaufrufen gelten; man kann sich vorstellen, dass sie jeder Vor- und Nachbedingung per Konjunktion hinzugefügt werden. Auf die etwas subtilen Probleme, die das Aliasing in Zusammenhang mit Zusicherungen schafft, wollen wir an dieser Stelle nicht eingehen; dies wird ausführlicher in Kurs 01853 behandelt.
Zusicherungen werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen auch Vor- und Nachbedingungen angepasst werden. Allerdings gilt hierbei, dass die Vorbedingung nur abgeschwächt und die Nachbedingung nur verschärft werden darf. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.","<answer> Zusicherungen, einschließlich Vor- und Nachbedingungen, werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen die Zusicherungen angepasst werden, jedoch mit bestimmten Einschränkungen. Die Vorbedingung darf nur abgeschwächt und die Nachbedingung nur verschärft werden, und die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingungen eingehalten werden. <answer> <question> Wie werden Zusicherungen in EIFFEL vererbt, insbesondere wenn eine Methode redefiniert wird? <question>"
"Nicht zuletzt werden auch ganz banale Arrays häufig verwendet, insbesondere wegen der (bereits in Abschnitt 1.2 vorgestellten) Möglichkeit der einfachen literalen Definition. So kann man ohne viel Aufwand über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung iterieren. Beispielsweise weist der Laufparameter des Blocks, ""element"", nacheinander die Elemente des literalen Arrays zu.
Der wesentliche Nachteil von Arrays ist, dass ihre Größe beschränkt ist. Benötigt man eine geordnete Collection, die beliebig wachsen kann, der also am Anfang, am Ende oder an einer beliebigen Position dazwischen Elemente hinzugefügt werden können, dann kann man auf Instanzen der Klasse ""OrderedCollection"" zurückgreifen. Diese eignen sich aufgrund des angebotenen Methodensatzes und ihres Protokolls speziell für die Implementierung von Stapeln (Stacks) und Puffern (Queues).","<answer> Arrays werden in SMALLTALK häufig verwendet, insbesondere aufgrund ihrer einfachen literalen Definitionsmöglichkeiten. Sie ermöglichen es, über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung zu iterieren, ohne viel Aufwand betreiben zu müssen. <answer> <question> Warum werden Arrays in SMALLTALK häufig verwendet? <question>"
"Nicht zuletzt werden auch ganz banale Arrays häufig verwendet, insbesondere wegen der (bereits in Abschnitt 1.2 vorgestellten) Möglichkeit der einfachen literalen Definition. So kann man ohne viel Aufwand über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung iterieren. Beispielsweise weist der Laufparameter des Blocks, ""element"", nacheinander die Elemente des literalen Arrays zu.
Der wesentliche Nachteil von Arrays ist, dass ihre Größe beschränkt ist. Benötigt man eine geordnete Collection, die beliebig wachsen kann, der also am Anfang, am Ende oder an einer beliebigen Position dazwischen Elemente hinzugefügt werden können, dann kann man auf Instanzen der Klasse ""OrderedCollection"" zurückgreifen. Diese eignen sich aufgrund des angebotenen Methodensatzes und ihres Protokolls speziell für die Implementierung von Stapeln (Stacks) und Puffern (Queues).","<answer> Der wesentliche Nachteil von Arrays in SMALLTALK ist, dass ihre Größe beschränkt ist. Das bedeutet, dass die Anzahl der Elemente in einem Array begrenzt ist, und es schwierig oder teuer sein kann, die Größe eines Arrays dynamisch zu ändern, um mehr Elemente aufzunehmen. <answer> <question> Was ist der wesentliche Nachteil von Arrays in SMALLTALK? <question>"
"Nicht zuletzt werden auch ganz banale Arrays häufig verwendet, insbesondere wegen der (bereits in Abschnitt 1.2 vorgestellten) Möglichkeit der einfachen literalen Definition. So kann man ohne viel Aufwand über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung iterieren. Beispielsweise weist der Laufparameter des Blocks, ""element"", nacheinander die Elemente des literalen Arrays zu.
Der wesentliche Nachteil von Arrays ist, dass ihre Größe beschränkt ist. Benötigt man eine geordnete Collection, die beliebig wachsen kann, der also am Anfang, am Ende oder an einer beliebigen Position dazwischen Elemente hinzugefügt werden können, dann kann man auf Instanzen der Klasse ""OrderedCollection"" zurückgreifen. Diese eignen sich aufgrund des angebotenen Methodensatzes und ihres Protokolls speziell für die Implementierung von Stapeln (Stacks) und Puffern (Queues).","<answer> Für geordnete Collections, die beliebig wachsen können und bei denen am Anfang, am Ende oder an einer beliebigen Position dazwischen Elemente hinzugefügt werden können, eignet sich die Klasse ""OrderedCollection"" besser als Arrays. OrderedCollections bieten einen geeigneten Methodensatz und ein Protokoll für die Implementierung von Stapeln (Stacks) und Puffern (Queues). Sie sind flexibler und können dynamisch wachsen, was Arrays nicht können. <answer> <question> Welche SMALLTALK-Klasse eignet sich besser für geordnete Collections, die beliebig wachsen können, und warum? <question>"
"C# unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von JAVA. Es ist in C# allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C# besitzt dafür das Schlüsselwort ""operator"", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:
Außerdem ist es in C# Konvention, Methodennamen mit einem Großbuchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C#, Call by reference nach dem Vorbild von PASCAL (also ohne explizite Pointer; s. o.) zu erlauben und damit Funktionen wie das Vertauschen von Variableninhalten (die Methode ""swap"") sicher zu programmieren:
Allerdings muss ""ref"" — anders als in PASCAL ""var"" — auch an der Aufrufstelle verwendet werden. Formale Parameter können auch mit ""out"" modifiziert werden (wobei für die Aufrufstelle dasselbe gilt wie für ""ref""):
Der Unterschied ist der, dass bei Verwendung von ""ref"" die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekommen haben) muss, während dies bei ""out"" nicht der Fall ist. Dafür muss bei ""out"" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Dass ""ref"" und ""out"" in C# anders als ""var"" in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil, dass die Programmiererin weiß, dass ihre die tatsächlichen Parameter liefernden Variablen nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer Zuweisung in beide Richtungen (hin und zurück) aus.
Sowohl ""ref"" als auch ""out"" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Da diese Möglichkeit in JAVA und SMALLTALK fehlt, findet man in diesen Sprachen häufig Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt 52.7).
Nun verdient C# im Kontext von Methodenaufrufen nicht nur lobende Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C# keine ""Throws""-Klauseln in Methodendeklarationen gibt — die aus JAVA bekannte Unterscheidung von Checked exceptions und Unchecked exceptions (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions. Das bedeutet, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzudenken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass bei einer stark geschichteten Architektur (beispielsweise beim Einsatz von Middleware) das Wissen um Exceptions auf der ganzen Wegstrecke von der Exception-Quelle bis zum Exception handler vorhanden sein muss, obwohl die mittleren Schichten naturgemäß an Art und Auftreten von Ausnahmen keinerlei Interesse haben. Das mit JAVA Version 1.4 eingeführte sog. ""Exception chaining"" erlaubt, eine Checked exception in einer Unchecked exception zu verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut zu werfen). Das sog. ""Exception tunneling"" bietet ebenfalls Abhilfe.
Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Unterschied bei Methoden ergibt sich im Zusammenhang mit dem Überschreiben: Während in JAVA alle Methoden im Prinzip überschrieben werden können (es sei denn, ihre Definition trägt den Zusatz ""final""), so dass der Compiler zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C#, der Tradition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort ""virtual"". Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort ""override"" deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts ""new"" bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanzgründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern auch gewichtige programmiertechnische: Man markiert alle Stellen im Programm, an denen das sog. ""Fragile-base-class-Problem"" (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. Keine Deklaration.
Einige Sprachkonstrukte verwenden in C# andere Schlüsselwörter als JAVA, so ""lock"" anstatt ""synchronized"" sowie ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer Bedeutung leicht von denen JAVAs ab: So sind auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen (in JAVA erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anweisung enthält, muss mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen werden. Außerdem hat C# eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. All dies hat allerdings nichts mit Objektorientierung zu tun.","<answer> C# und JAVA weisen in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen viele Gemeinsamkeiten auf. Die grundlegende Syntax und Struktur der beiden Sprachen sind ähnlich. In beiden Sprachen werden Klassen verwendet, um Objekte zu erstellen, Variablen und Ausdrücke zu definieren, Anweisungen auszuführen und Kontrollstrukturen zu steuern. <answer> <question> Welche Gemeinsamkeiten gibt es zwischen C# und JAVA in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen? <question>"
"C# unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von JAVA. Es ist in C# allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C# besitzt dafür das Schlüsselwort ""operator"", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:
Außerdem ist es in C# Konvention, Methodennamen mit einem Großbuchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C#, Call by reference nach dem Vorbild von PASCAL (also ohne explizite Pointer; s. o.) zu erlauben und damit Funktionen wie das Vertauschen von Variableninhalten (die Methode ""swap"") sicher zu programmieren:
Allerdings muss ""ref"" — anders als in PASCAL ""var"" — auch an der Aufrufstelle verwendet werden. Formale Parameter können auch mit ""out"" modifiziert werden (wobei für die Aufrufstelle dasselbe gilt wie für ""ref""):
Der Unterschied ist der, dass bei Verwendung von ""ref"" die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekommen haben) muss, während dies bei ""out"" nicht der Fall ist. Dafür muss bei ""out"" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Dass ""ref"" und ""out"" in C# anders als ""var"" in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil, dass die Programmiererin weiß, dass ihre die tatsächlichen Parameter liefernden Variablen nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer Zuweisung in beide Richtungen (hin und zurück) aus.
Sowohl ""ref"" als auch ""out"" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Da diese Möglichkeit in JAVA und SMALLTALK fehlt, findet man in diesen Sprachen häufig Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt 52.7).
Nun verdient C# im Kontext von Methodenaufrufen nicht nur lobende Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C# keine ""Throws""-Klauseln in Methodendeklarationen gibt — die aus JAVA bekannte Unterscheidung von Checked exceptions und Unchecked exceptions (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions. Das bedeutet, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzudenken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass bei einer stark geschichteten Architektur (beispielsweise beim Einsatz von Middleware) das Wissen um Exceptions auf der ganzen Wegstrecke von der Exception-Quelle bis zum Exception handler vorhanden sein muss, obwohl die mittleren Schichten naturgemäß an Art und Auftreten von Ausnahmen keinerlei Interesse haben. Das mit JAVA Version 1.4 eingeführte sog. ""Exception chaining"" erlaubt, eine Checked exception in einer Unchecked exception zu verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut zu werfen). Das sog. ""Exception tunneling"" bietet ebenfalls Abhilfe.
Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Unterschied bei Methoden ergibt sich im Zusammenhang mit dem Überschreiben: Während in JAVA alle Methoden im Prinzip überschrieben werden können (es sei denn, ihre Definition trägt den Zusatz ""final""), so dass der Compiler zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C#, der Tradition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort ""virtual"". Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort ""override"" deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts ""new"" bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanzgründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern auch gewichtige programmiertechnische: Man markiert alle Stellen im Programm, an denen das sog. ""Fragile-base-class-Problem"" (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. Keine Deklaration.
Einige Sprachkonstrukte verwenden in C# andere Schlüsselwörter als JAVA, so ""lock"" anstatt ""synchronized"" sowie ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer Bedeutung leicht von denen JAVAs ab: So sind auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen (in JAVA erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anweisung enthält, muss mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen werden. Außerdem hat C# eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. All dies hat allerdings nichts mit Objektorientierung zu tun.","<answer> In C# ist es möglich, Operatoren wie +, -, == usw. zu überladen. Dies wird durch das Schlüsselwort ""operator"" ermöglicht, das in einer Operatordefinition vorangestellt wird. Die Überladung von Operatoren erfolgt ähnlich wie die Definition von Methoden, aber anstelle von Methodennamen werden die Operatorzeichen verwendet. <answer> <question> Welche Besonderheit gibt es in C# in Bezug auf die Überladung von Operatoren, und wie wird sie umgesetzt? <question>"
"C# unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von JAVA. Es ist in C# allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C# besitzt dafür das Schlüsselwort ""operator"", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:
Außerdem ist es in C# Konvention, Methodennamen mit einem Großbuchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C#, Call by reference nach dem Vorbild von PASCAL (also ohne explizite Pointer; s. o.) zu erlauben und damit Funktionen wie das Vertauschen von Variableninhalten (die Methode ""swap"") sicher zu programmieren:
Allerdings muss ""ref"" — anders als in PASCAL ""var"" — auch an der Aufrufstelle verwendet werden. Formale Parameter können auch mit ""out"" modifiziert werden (wobei für die Aufrufstelle dasselbe gilt wie für ""ref""):
Der Unterschied ist der, dass bei Verwendung von ""ref"" die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekommen haben) muss, während dies bei ""out"" nicht der Fall ist. Dafür muss bei ""out"" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Dass ""ref"" und ""out"" in C# anders als ""var"" in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil, dass die Programmiererin weiß, dass ihre die tatsächlichen Parameter liefernden Variablen nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer Zuweisung in beide Richtungen (hin und zurück) aus.
Sowohl ""ref"" als auch ""out"" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Da diese Möglichkeit in JAVA und SMALLTALK fehlt, findet man in diesen Sprachen häufig Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt 52.7).
Nun verdient C# im Kontext von Methodenaufrufen nicht nur lobende Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C# keine ""Throws""-Klauseln in Methodendeklarationen gibt — die aus JAVA bekannte Unterscheidung von Checked exceptions und Unchecked exceptions (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions. Das bedeutet, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzudenken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass bei einer stark geschichteten Architektur (beispielsweise beim Einsatz von Middleware) das Wissen um Exceptions auf der ganzen Wegstrecke von der Exception-Quelle bis zum Exception handler vorhanden sein muss, obwohl die mittleren Schichten naturgemäß an Art und Auftreten von Ausnahmen keinerlei Interesse haben. Das mit JAVA Version 1.4 eingeführte sog. ""Exception chaining"" erlaubt, eine Checked exception in einer Unchecked exception zu verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut zu werfen). Das sog. ""Exception tunneling"" bietet ebenfalls Abhilfe.
Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Unterschied bei Methoden ergibt sich im Zusammenhang mit dem Überschreiben: Während in JAVA alle Methoden im Prinzip überschrieben werden können (es sei denn, ihre Definition trägt den Zusatz ""final""), so dass der Compiler zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C#, der Tradition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort ""virtual"". Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort ""override"" deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts ""new"" bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanzgründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern auch gewichtige programmiertechnische: Man markiert alle Stellen im Programm, an denen das sog. ""Fragile-base-class-Problem"" (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. Keine Deklaration.
Einige Sprachkonstrukte verwenden in C# andere Schlüsselwörter als JAVA, so ""lock"" anstatt ""synchronized"" sowie ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer Bedeutung leicht von denen JAVAs ab: So sind auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen (in JAVA erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anweisung enthält, muss mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen werden. Außerdem hat C# eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. All dies hat allerdings nichts mit Objektorientierung zu tun.","<answer> In C# ermöglicht ""Call by reference"" (auch als ""ref"" und ""out"" bekannt) das Übergeben von Argumenten an Methoden, bei denen die Änderungen an den Parametern innerhalb der Methode auf die ursprünglichen Argumente außerhalb der Methode angewendet werden. Im Gegensatz dazu verwendet ""Call by value"" Kopien der Argumente, und Änderungen innerhalb der Methode haben keine Auswirkungen auf die ursprünglichen Argumente. <answer> <question> Was ist ""Call by reference"" in C#, und wie unterscheidet es sich von ""Call by value""? <question>"
"C# unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von JAVA. Es ist in C# allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C# besitzt dafür das Schlüsselwort ""operator"", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:
Außerdem ist es in C# Konvention, Methodennamen mit einem Großbuchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C#, Call by reference nach dem Vorbild von PASCAL (also ohne explizite Pointer; s. o.) zu erlauben und damit Funktionen wie das Vertauschen von Variableninhalten (die Methode ""swap"") sicher zu programmieren:
Allerdings muss ""ref"" — anders als in PASCAL ""var"" — auch an der Aufrufstelle verwendet werden. Formale Parameter können auch mit ""out"" modifiziert werden (wobei für die Aufrufstelle dasselbe gilt wie für ""ref""):
Der Unterschied ist der, dass bei Verwendung von ""ref"" die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekommen haben) muss, während dies bei ""out"" nicht der Fall ist. Dafür muss bei ""out"" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Dass ""ref"" und ""out"" in C# anders als ""var"" in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil, dass die Programmiererin weiß, dass ihre die tatsächlichen Parameter liefernden Variablen nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer Zuweisung in beide Richtungen (hin und zurück) aus.
Sowohl ""ref"" als auch ""out"" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Da diese Möglichkeit in JAVA und SMALLTALK fehlt, findet man in diesen Sprachen häufig Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt 52.7).
Nun verdient C# im Kontext von Methodenaufrufen nicht nur lobende Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C# keine ""Throws""-Klauseln in Methodendeklarationen gibt — die aus JAVA bekannte Unterscheidung von Checked exceptions und Unchecked exceptions (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions. Das bedeutet, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzudenken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass bei einer stark geschichteten Architektur (beispielsweise beim Einsatz von Middleware) das Wissen um Exceptions auf der ganzen Wegstrecke von der Exception-Quelle bis zum Exception handler vorhanden sein muss, obwohl die mittleren Schichten naturgemäß an Art und Auftreten von Ausnahmen keinerlei Interesse haben. Das mit JAVA Version 1.4 eingeführte sog. ""Exception chaining"" erlaubt, eine Checked exception in einer Unchecked exception zu verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut zu werfen). Das sog. ""Exception tunneling"" bietet ebenfalls Abhilfe.
Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Unterschied bei Methoden ergibt sich im Zusammenhang mit dem Überschreiben: Während in JAVA alle Methoden im Prinzip überschrieben werden können (es sei denn, ihre Definition trägt den Zusatz ""final""), so dass der Compiler zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C#, der Tradition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort ""virtual"". Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort ""override"" deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts ""new"" bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanzgründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern auch gewichtige programmiertechnische: Man markiert alle Stellen im Programm, an denen das sog. ""Fragile-base-class-Problem"" (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. Keine Deklaration.
Einige Sprachkonstrukte verwenden in C# andere Schlüsselwörter als JAVA, so ""lock"" anstatt ""synchronized"" sowie ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer Bedeutung leicht von denen JAVAs ab: So sind auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen (in JAVA erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anweisung enthält, muss mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen werden. Außerdem hat C# eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. All dies hat allerdings nichts mit Objektorientierung zu tun.","<answer> In C# werden ""ref"" und ""out"" verwendet, um formale Parameter zu kennzeichnen, die durch den Methodenaufruf modifiziert werden können. Der Hauptunterschied besteht darin, dass bei ""ref"" die übergebene Variable vor dem Aufruf initialisiert sein muss, während bei ""out"" dies nicht erforderlich ist. Bei ""out"" muss jedoch die formale Parameter in der Methode selbst einen Wert zugewiesen bekommen. Beide ermöglichen mehrere Rückgabewerte für Methoden. <answer> <question> Was sind die Unterschiede zwischen ""ref"" und ""out"" in Bezug auf Methodenparameter in C#? <question>"
"C# unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von JAVA. Es ist in C# allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C# besitzt dafür das Schlüsselwort ""operator"", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:
Außerdem ist es in C# Konvention, Methodennamen mit einem Großbuchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C#, Call by reference nach dem Vorbild von PASCAL (also ohne explizite Pointer; s. o.) zu erlauben und damit Funktionen wie das Vertauschen von Variableninhalten (die Methode ""swap"") sicher zu programmieren:
Allerdings muss ""ref"" — anders als in PASCAL ""var"" — auch an der Aufrufstelle verwendet werden. Formale Parameter können auch mit ""out"" modifiziert werden (wobei für die Aufrufstelle dasselbe gilt wie für ""ref""):
Der Unterschied ist der, dass bei Verwendung von ""ref"" die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekommen haben) muss, während dies bei ""out"" nicht der Fall ist. Dafür muss bei ""out"" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Dass ""ref"" und ""out"" in C# anders als ""var"" in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil, dass die Programmiererin weiß, dass ihre die tatsächlichen Parameter liefernden Variablen nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer Zuweisung in beide Richtungen (hin und zurück) aus.
Sowohl ""ref"" als auch ""out"" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Da diese Möglichkeit in JAVA und SMALLTALK fehlt, findet man in diesen Sprachen häufig Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt 52.7).
Nun verdient C# im Kontext von Methodenaufrufen nicht nur lobende Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C# keine ""Throws""-Klauseln in Methodendeklarationen gibt — die aus JAVA bekannte Unterscheidung von Checked exceptions und Unchecked exceptions (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions. Das bedeutet, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzudenken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass bei einer stark geschichteten Architektur (beispielsweise beim Einsatz von Middleware) das Wissen um Exceptions auf der ganzen Wegstrecke von der Exception-Quelle bis zum Exception handler vorhanden sein muss, obwohl die mittleren Schichten naturgemäß an Art und Auftreten von Ausnahmen keinerlei Interesse haben. Das mit JAVA Version 1.4 eingeführte sog. ""Exception chaining"" erlaubt, eine Checked exception in einer Unchecked exception zu verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut zu werfen). Das sog. ""Exception tunneling"" bietet ebenfalls Abhilfe.
Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Unterschied bei Methoden ergibt sich im Zusammenhang mit dem Überschreiben: Während in JAVA alle Methoden im Prinzip überschrieben werden können (es sei denn, ihre Definition trägt den Zusatz ""final""), so dass der Compiler zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C#, der Tradition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort ""virtual"". Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort ""override"" deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts ""new"" bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanzgründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern auch gewichtige programmiertechnische: Man markiert alle Stellen im Programm, an denen das sog. ""Fragile-base-class-Problem"" (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. Keine Deklaration.
Einige Sprachkonstrukte verwenden in C# andere Schlüsselwörter als JAVA, so ""lock"" anstatt ""synchronized"" sowie ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer Bedeutung leicht von denen JAVAs ab: So sind auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen (in JAVA erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anweisung enthält, muss mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen werden. Außerdem hat C# eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. All dies hat allerdings nichts mit Objektorientierung zu tun.","<answer> C# verzichtet auf ""Throws""-Klauseln in Methodendeklarationen, die in JAVA zur Unterscheidung von Checked Exceptions und Unchecked Exceptions verwendet werden. Stattdessen gibt es in C# nur Unchecked Exceptions. Diese Entscheidung wurde getroffen, um die Programmierer nicht dazu zu zwingen, im Voraus zu wissen, was in jeder Methode schief gehen kann. Es gibt jedoch Möglichkeiten, Exception-Handling in C# durch ""Exception chaining"" und ""Exception tunneling"" zu implementieren. <answer> <question> Warum gibt es in C# keine ""Throws""-Klauseln in Methodendeklarationen, wie sie in JAVA existieren? <question>"
"C# unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von JAVA. Es ist in C# allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C# besitzt dafür das Schlüsselwort ""operator"", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:
Außerdem ist es in C# Konvention, Methodennamen mit einem Großbuchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C#, Call by reference nach dem Vorbild von PASCAL (also ohne explizite Pointer; s. o.) zu erlauben und damit Funktionen wie das Vertauschen von Variableninhalten (die Methode ""swap"") sicher zu programmieren:
Allerdings muss ""ref"" — anders als in PASCAL ""var"" — auch an der Aufrufstelle verwendet werden. Formale Parameter können auch mit ""out"" modifiziert werden (wobei für die Aufrufstelle dasselbe gilt wie für ""ref""):
Der Unterschied ist der, dass bei Verwendung von ""ref"" die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekommen haben) muss, während dies bei ""out"" nicht der Fall ist. Dafür muss bei ""out"" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Dass ""ref"" und ""out"" in C# anders als ""var"" in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil, dass die Programmiererin weiß, dass ihre die tatsächlichen Parameter liefernden Variablen nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer Zuweisung in beide Richtungen (hin und zurück) aus.
Sowohl ""ref"" als auch ""out"" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Da diese Möglichkeit in JAVA und SMALLTALK fehlt, findet man in diesen Sprachen häufig Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt 52.7).
Nun verdient C# im Kontext von Methodenaufrufen nicht nur lobende Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C# keine ""Throws""-Klauseln in Methodendeklarationen gibt — die aus JAVA bekannte Unterscheidung von Checked exceptions und Unchecked exceptions (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions. Das bedeutet, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzudenken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass bei einer stark geschichteten Architektur (beispielsweise beim Einsatz von Middleware) das Wissen um Exceptions auf der ganzen Wegstrecke von der Exception-Quelle bis zum Exception handler vorhanden sein muss, obwohl die mittleren Schichten naturgemäß an Art und Auftreten von Ausnahmen keinerlei Interesse haben. Das mit JAVA Version 1.4 eingeführte sog. ""Exception chaining"" erlaubt, eine Checked exception in einer Unchecked exception zu verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut zu werfen). Das sog. ""Exception tunneling"" bietet ebenfalls Abhilfe.
Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Unterschied bei Methoden ergibt sich im Zusammenhang mit dem Überschreiben: Während in JAVA alle Methoden im Prinzip überschrieben werden können (es sei denn, ihre Definition trägt den Zusatz ""final""), so dass der Compiler zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C#, der Tradition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort ""virtual"". Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort ""override"" deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts ""new"" bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanzgründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern auch gewichtige programmiertechnische: Man markiert alle Stellen im Programm, an denen das sog. ""Fragile-base-class-Problem"" (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. Keine Deklaration.
Einige Sprachkonstrukte verwenden in C# andere Schlüsselwörter als JAVA, so ""lock"" anstatt ""synchronized"" sowie ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer Bedeutung leicht von denen JAVAs ab: So sind auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen (in JAVA erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anweisung enthält, muss mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen werden. Außerdem hat C# eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. All dies hat allerdings nichts mit Objektorientierung zu tun.","<answer> In C# müssen dynamisch zu bindende Methoden als ""virtual"" deklariert werden, und überschreibende Methoden müssen mit ""override"" gekennzeichnet sein. Wenn eine Methode in einer Subklasse neu eingeführt werden soll, wird ""new"" verwendet. Dies unterscheidet sich von JAVA, wo Methoden standardmäßig überschrieben werden können, es sei denn, sie sind als ""final"" deklariert. Diese Unterschiede sollen das sogenannte ""Fragile-base-class-Problem"" verhindern und die Programmiererin darüber informieren, welche Methoden dynamisch gebunden werden und welche nicht. <answer> <question> Welche Unterschiede gibt es zwischen der Überschreibung von Methoden in C# im Vergleich zu JAVA? <question>"
"C# unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von JAVA. Es ist in C# allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C# besitzt dafür das Schlüsselwort ""operator"", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:
Außerdem ist es in C# Konvention, Methodennamen mit einem Großbuchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C#, Call by reference nach dem Vorbild von PASCAL (also ohne explizite Pointer; s. o.) zu erlauben und damit Funktionen wie das Vertauschen von Variableninhalten (die Methode ""swap"") sicher zu programmieren:
Allerdings muss ""ref"" — anders als in PASCAL ""var"" — auch an der Aufrufstelle verwendet werden. Formale Parameter können auch mit ""out"" modifiziert werden (wobei für die Aufrufstelle dasselbe gilt wie für ""ref""):
Der Unterschied ist der, dass bei Verwendung von ""ref"" die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekommen haben) muss, während dies bei ""out"" nicht der Fall ist. Dafür muss bei ""out"" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Dass ""ref"" und ""out"" in C# anders als ""var"" in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil, dass die Programmiererin weiß, dass ihre die tatsächlichen Parameter liefernden Variablen nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer Zuweisung in beide Richtungen (hin und zurück) aus.
Sowohl ""ref"" als auch ""out"" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Da diese Möglichkeit in JAVA und SMALLTALK fehlt, findet man in diesen Sprachen häufig Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt 52.7).
Nun verdient C# im Kontext von Methodenaufrufen nicht nur lobende Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C# keine ""Throws""-Klauseln in Methodendeklarationen gibt — die aus JAVA bekannte Unterscheidung von Checked exceptions und Unchecked exceptions (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions. Das bedeutet, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzudenken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass bei einer stark geschichteten Architektur (beispielsweise beim Einsatz von Middleware) das Wissen um Exceptions auf der ganzen Wegstrecke von der Exception-Quelle bis zum Exception handler vorhanden sein muss, obwohl die mittleren Schichten naturgemäß an Art und Auftreten von Ausnahmen keinerlei Interesse haben. Das mit JAVA Version 1.4 eingeführte sog. ""Exception chaining"" erlaubt, eine Checked exception in einer Unchecked exception zu verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut zu werfen). Das sog. ""Exception tunneling"" bietet ebenfalls Abhilfe.
Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Unterschied bei Methoden ergibt sich im Zusammenhang mit dem Überschreiben: Während in JAVA alle Methoden im Prinzip überschrieben werden können (es sei denn, ihre Definition trägt den Zusatz ""final""), so dass der Compiler zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C#, der Tradition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort ""virtual"". Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort ""override"" deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts ""new"" bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanzgründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern auch gewichtige programmiertechnische: Man markiert alle Stellen im Programm, an denen das sog. ""Fragile-base-class-Problem"" (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. Keine Deklaration.
Einige Sprachkonstrukte verwenden in C# andere Schlüsselwörter als JAVA, so ""lock"" anstatt ""synchronized"" sowie ""foreach"" anstatt ""for"" für die zweite Form von ""For""-Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer Bedeutung leicht von denen JAVAs ab: So sind auch ""Strings"" als Basis einer ""Switch""-Anweisung zugelassen (in JAVA erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anweisung enthält, muss mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen werden. Außerdem hat C# eine ""Goto""-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. All dies hat allerdings nichts mit Objektorientierung zu tun.","<answer> Einige Unterschiede und Konventionen zwischen C# und JAVA umfassen die Verwendung von ""lock"" anstelle von ""synchronized"" für die Synchronisation, die Verwendung von ""foreach"" anstelle von ""for"" für bestimmte Schleifen, die Möglichkeit, ""Strings"" als Basis einer ""Switch""-Anweisung zu verwenden, und die Anforderung, dass jeder Zweig (case) einer ""Switch""-Anweisung mit einer expliziten Kontrollflussanweisung (""break"", ""goto"", ""return"" oder ""throw"") abgeschlossen sein muss. C# verfügt auch über eine ""Goto""-Anweisung, die jedoch nicht in Blöcke springen kann. <answer> <question> Welche anderen Unterschiede und Konventionen gibt es zwischen C# und JAVA in Bezug auf Sprachkonstrukte? <question>"
"Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit immer dann fraglich ist, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies soll nun etwas genauer beleuchtet werden.
In Java ist die Klasse Stack als Subklasse der Klasse Vector definiert, wobei Vector kein Vektor im mathematischen Sinne ist, sondern eher ein dynamisches Array, das in seiner Größe wachsen kann. Dies führt jedoch dazu, dass an Stellen im Programm, an denen eine indizierte Sammlung von Objekten mit wahlfreiem Zugriff erwartet wird (also ein Objekt vom Typ Vector), ein Objekt vom Typ Stack auftauchen kann. Obwohl Stack intern möglicherweise auf einem dynamischen Array ähnlich Vector aufbaut (und daher von Vector erbt), muss es an seiner öffentlich zugänglichen Schnittstelle die Funktionen für den wahlfreien Zugriff unterdrücken. In Java ist dies jedoch nicht möglich. Sollte das Programm also, in Erwartung einer indizierten Sammlung, auf ein Element zugreifen und stattdessen einen Stack vorfinden, kann das Programm nicht fortgesetzt werden, es sei denn, es findet vor dem Zugriff eine entsprechende Prüfung (und möglicherweise eine Verzweigung zu alternativen Verfahren) statt. Eine solche Prüfung muss jedoch zur Laufzeit erfolgen, und wenn sie vergessen wird (nicht implementiert), kann dies zu einem schwerwiegenden Programmierfehler führen. Solche Fehler lassen sich einfach vermeiden, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.
Eine schwächere Variante, die jedoch ähnlich katastrophale Folgen haben kann und deren Vorliegen nur schwer festzustellen ist, tritt auf, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht. Dies ist beispielsweise bei den beiden Typen Set (Menge) und Bag (Multimenge) der Fall. Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist. Die Funktionen ""Hinzufügen eines Elements"", ""Entfernen eines Elements"" sowie die Angabe der Größe und der Test auf das Vorhandensein eines Elements werden von Set genauso unterstützt wie von Bag. Der einzige Unterschied scheint zu sein, dass das Hinzufügen eines bereits vorhandenen Elements in der Menge von Set keine Veränderung bewirkt.
Bei genauerer Betrachtung ergibt sich jedoch das Problem, dass Set durch seine Eigenheit mehrere charakteristische Eigenschaften von Multimengen verletzt. Zum Beispiel gilt für Sets nicht wie für Bags, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden; doppelte Einfügungen werden von Set einfach ignoriert. Ein Programm, das auf die Eigenschaften von Bags setzt und stattdessen mit einem Set arbeiten muss, funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.
Umgekehrt würde, wenn man Bag als Subtyp von Set annähme, die für Set charakteristische Eigenschaft verletzt, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden.
Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des jeweils anderen implizieren, und dass sie sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" bilden, wobei die Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird. Dies entspricht jedoch genau der Definition des Subtypings aus Kurseinheit 3, Abschnitt 26.1. Tatsächlich ist es mehr oder weniger eine Frage der Interpretation, ob die in Kapitel 26 genannten syntaktischen Bedingungen, insbesondere die Ko- und Kontravarianz, für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen.
In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren in Form der Prüfung der Typkonformität immer nur angenähert. Tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen werden, wenn mangelnde Typkonformität vorliegt. Dennoch werden entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet jedoch Typkonformität nicht automatisch auch Substituierbarkeit. Dazu ist auch eine Betrachtung des Verhaltens notwendig.","<answer> Die Substituierbarkeit ist fraglich, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies führt zu Problemen, wenn Objekte eines Subtyps an Stellen verwendet werden, an denen Objekte des Supertyps erwartet werden. <answer> <question> Warum ist die Substituierbarkeit fraglich, wenn keine Typerweiterung vorliegt? <question>"
"Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit immer dann fraglich ist, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies soll nun etwas genauer beleuchtet werden.
In Java ist die Klasse Stack als Subklasse der Klasse Vector definiert, wobei Vector kein Vektor im mathematischen Sinne ist, sondern eher ein dynamisches Array, das in seiner Größe wachsen kann. Dies führt jedoch dazu, dass an Stellen im Programm, an denen eine indizierte Sammlung von Objekten mit wahlfreiem Zugriff erwartet wird (also ein Objekt vom Typ Vector), ein Objekt vom Typ Stack auftauchen kann. Obwohl Stack intern möglicherweise auf einem dynamischen Array ähnlich Vector aufbaut (und daher von Vector erbt), muss es an seiner öffentlich zugänglichen Schnittstelle die Funktionen für den wahlfreien Zugriff unterdrücken. In Java ist dies jedoch nicht möglich. Sollte das Programm also, in Erwartung einer indizierten Sammlung, auf ein Element zugreifen und stattdessen einen Stack vorfinden, kann das Programm nicht fortgesetzt werden, es sei denn, es findet vor dem Zugriff eine entsprechende Prüfung (und möglicherweise eine Verzweigung zu alternativen Verfahren) statt. Eine solche Prüfung muss jedoch zur Laufzeit erfolgen, und wenn sie vergessen wird (nicht implementiert), kann dies zu einem schwerwiegenden Programmierfehler führen. Solche Fehler lassen sich einfach vermeiden, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.
Eine schwächere Variante, die jedoch ähnlich katastrophale Folgen haben kann und deren Vorliegen nur schwer festzustellen ist, tritt auf, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht. Dies ist beispielsweise bei den beiden Typen Set (Menge) und Bag (Multimenge) der Fall. Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist. Die Funktionen ""Hinzufügen eines Elements"", ""Entfernen eines Elements"" sowie die Angabe der Größe und der Test auf das Vorhandensein eines Elements werden von Set genauso unterstützt wie von Bag. Der einzige Unterschied scheint zu sein, dass das Hinzufügen eines bereits vorhandenen Elements in der Menge von Set keine Veränderung bewirkt.
Bei genauerer Betrachtung ergibt sich jedoch das Problem, dass Set durch seine Eigenheit mehrere charakteristische Eigenschaften von Multimengen verletzt. Zum Beispiel gilt für Sets nicht wie für Bags, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden; doppelte Einfügungen werden von Set einfach ignoriert. Ein Programm, das auf die Eigenschaften von Bags setzt und stattdessen mit einem Set arbeiten muss, funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.
Umgekehrt würde, wenn man Bag als Subtyp von Set annähme, die für Set charakteristische Eigenschaft verletzt, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden.
Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des jeweils anderen implizieren, und dass sie sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" bilden, wobei die Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird. Dies entspricht jedoch genau der Definition des Subtypings aus Kurseinheit 3, Abschnitt 26.1. Tatsächlich ist es mehr oder weniger eine Frage der Interpretation, ob die in Kapitel 26 genannten syntaktischen Bedingungen, insbesondere die Ko- und Kontravarianz, für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen.
In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren in Form der Prüfung der Typkonformität immer nur angenähert. Tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen werden, wenn mangelnde Typkonformität vorliegt. Dennoch werden entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet jedoch Typkonformität nicht automatisch auch Substituierbarkeit. Dazu ist auch eine Betrachtung des Verhaltens notwendig.","<answer> In Java ist die Unterdrückung von Eigenschaften bei abgeleiteten Typen problematisch, da sie dazu führen kann, dass an Stellen im Programm, an denen ein Objekt des Supertyps erwartet wird, ein Objekt des Subtyps auftaucht. Dies kann zu schwerwiegenden Programmierfehlern führen, da die erwarteten Funktionen des Supertyps möglicherweise nicht verfügbar sind. <answer> <question> Warum kann die Unterdrückung von Eigenschaften bei abgeleiteten Typen in Java problematisch sein? <question>"
"Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit immer dann fraglich ist, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies soll nun etwas genauer beleuchtet werden.
In Java ist die Klasse Stack als Subklasse der Klasse Vector definiert, wobei Vector kein Vektor im mathematischen Sinne ist, sondern eher ein dynamisches Array, das in seiner Größe wachsen kann. Dies führt jedoch dazu, dass an Stellen im Programm, an denen eine indizierte Sammlung von Objekten mit wahlfreiem Zugriff erwartet wird (also ein Objekt vom Typ Vector), ein Objekt vom Typ Stack auftauchen kann. Obwohl Stack intern möglicherweise auf einem dynamischen Array ähnlich Vector aufbaut (und daher von Vector erbt), muss es an seiner öffentlich zugänglichen Schnittstelle die Funktionen für den wahlfreien Zugriff unterdrücken. In Java ist dies jedoch nicht möglich. Sollte das Programm also, in Erwartung einer indizierten Sammlung, auf ein Element zugreifen und stattdessen einen Stack vorfinden, kann das Programm nicht fortgesetzt werden, es sei denn, es findet vor dem Zugriff eine entsprechende Prüfung (und möglicherweise eine Verzweigung zu alternativen Verfahren) statt. Eine solche Prüfung muss jedoch zur Laufzeit erfolgen, und wenn sie vergessen wird (nicht implementiert), kann dies zu einem schwerwiegenden Programmierfehler führen. Solche Fehler lassen sich einfach vermeiden, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.
Eine schwächere Variante, die jedoch ähnlich katastrophale Folgen haben kann und deren Vorliegen nur schwer festzustellen ist, tritt auf, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht. Dies ist beispielsweise bei den beiden Typen Set (Menge) und Bag (Multimenge) der Fall. Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist. Die Funktionen ""Hinzufügen eines Elements"", ""Entfernen eines Elements"" sowie die Angabe der Größe und der Test auf das Vorhandensein eines Elements werden von Set genauso unterstützt wie von Bag. Der einzige Unterschied scheint zu sein, dass das Hinzufügen eines bereits vorhandenen Elements in der Menge von Set keine Veränderung bewirkt.
Bei genauerer Betrachtung ergibt sich jedoch das Problem, dass Set durch seine Eigenheit mehrere charakteristische Eigenschaften von Multimengen verletzt. Zum Beispiel gilt für Sets nicht wie für Bags, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden; doppelte Einfügungen werden von Set einfach ignoriert. Ein Programm, das auf die Eigenschaften von Bags setzt und stattdessen mit einem Set arbeiten muss, funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.
Umgekehrt würde, wenn man Bag als Subtyp von Set annähme, die für Set charakteristische Eigenschaft verletzt, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden.
Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des jeweils anderen implizieren, und dass sie sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" bilden, wobei die Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird. Dies entspricht jedoch genau der Definition des Subtypings aus Kurseinheit 3, Abschnitt 26.1. Tatsächlich ist es mehr oder weniger eine Frage der Interpretation, ob die in Kapitel 26 genannten syntaktischen Bedingungen, insbesondere die Ko- und Kontravarianz, für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen.
In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren in Form der Prüfung der Typkonformität immer nur angenähert. Tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen werden, wenn mangelnde Typkonformität vorliegt. Dennoch werden entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet jedoch Typkonformität nicht automatisch auch Substituierbarkeit. Dazu ist auch eine Betrachtung des Verhaltens notwendig.","<answer> Das Beispiel betrifft die Substituierbarkeit zwischen den Typen Set (Menge) und Bag (Multimenge). Wenn Set als Subtyp von Bag angesehen wird, gibt es Probleme, da Sets einige charakteristische Eigenschaften von Multimengen verletzen, wie die Größenänderung nach dem Hinzufügen eines Elements. Wenn Bag als Subtyp von Set angesehen wird, wird die charakteristische Eigenschaft verletzt, dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. <answer> <question> Welches Beispiel wird gegeben, um das Problem der Substituierbarkeit zwischen den Typen Set (Menge) und Bag (Multimenge) zu erklären? <question>"
"Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit immer dann fraglich ist, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies soll nun etwas genauer beleuchtet werden.
In Java ist die Klasse Stack als Subklasse der Klasse Vector definiert, wobei Vector kein Vektor im mathematischen Sinne ist, sondern eher ein dynamisches Array, das in seiner Größe wachsen kann. Dies führt jedoch dazu, dass an Stellen im Programm, an denen eine indizierte Sammlung von Objekten mit wahlfreiem Zugriff erwartet wird (also ein Objekt vom Typ Vector), ein Objekt vom Typ Stack auftauchen kann. Obwohl Stack intern möglicherweise auf einem dynamischen Array ähnlich Vector aufbaut (und daher von Vector erbt), muss es an seiner öffentlich zugänglichen Schnittstelle die Funktionen für den wahlfreien Zugriff unterdrücken. In Java ist dies jedoch nicht möglich. Sollte das Programm also, in Erwartung einer indizierten Sammlung, auf ein Element zugreifen und stattdessen einen Stack vorfinden, kann das Programm nicht fortgesetzt werden, es sei denn, es findet vor dem Zugriff eine entsprechende Prüfung (und möglicherweise eine Verzweigung zu alternativen Verfahren) statt. Eine solche Prüfung muss jedoch zur Laufzeit erfolgen, und wenn sie vergessen wird (nicht implementiert), kann dies zu einem schwerwiegenden Programmierfehler führen. Solche Fehler lassen sich einfach vermeiden, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.
Eine schwächere Variante, die jedoch ähnlich katastrophale Folgen haben kann und deren Vorliegen nur schwer festzustellen ist, tritt auf, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht. Dies ist beispielsweise bei den beiden Typen Set (Menge) und Bag (Multimenge) der Fall. Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist. Die Funktionen ""Hinzufügen eines Elements"", ""Entfernen eines Elements"" sowie die Angabe der Größe und der Test auf das Vorhandensein eines Elements werden von Set genauso unterstützt wie von Bag. Der einzige Unterschied scheint zu sein, dass das Hinzufügen eines bereits vorhandenen Elements in der Menge von Set keine Veränderung bewirkt.
Bei genauerer Betrachtung ergibt sich jedoch das Problem, dass Set durch seine Eigenheit mehrere charakteristische Eigenschaften von Multimengen verletzt. Zum Beispiel gilt für Sets nicht wie für Bags, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden; doppelte Einfügungen werden von Set einfach ignoriert. Ein Programm, das auf die Eigenschaften von Bags setzt und stattdessen mit einem Set arbeiten muss, funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.
Umgekehrt würde, wenn man Bag als Subtyp von Set annähme, die für Set charakteristische Eigenschaft verletzt, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden.
Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des jeweils anderen implizieren, und dass sie sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" bilden, wobei die Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird. Dies entspricht jedoch genau der Definition des Subtypings aus Kurseinheit 3, Abschnitt 26.1. Tatsächlich ist es mehr oder weniger eine Frage der Interpretation, ob die in Kapitel 26 genannten syntaktischen Bedingungen, insbesondere die Ko- und Kontravarianz, für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen.
In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren in Form der Prüfung der Typkonformität immer nur angenähert. Tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen werden, wenn mangelnde Typkonformität vorliegt. Dennoch werden entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet jedoch Typkonformität nicht automatisch auch Substituierbarkeit. Dazu ist auch eine Betrachtung des Verhaltens notwendig.","<answer> Es können keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" gebildet werden, wenn X (Bag oder Set) als Subtyp von Y (dem jeweils anderen Typ) betrachtet wird, da die charakteristischen Eigenschaften der beiden Typen im Widerspruch zueinander stehen. Dies entspricht nicht der Definition des Subtypings, da die Bedingungen der Ko- und Kontravarianz nicht erfüllt sind. <answer> <question> Warum können keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" gebildet werden, wenn X (Bag oder Set) als Subtyp von Y (dem jeweils anderen Typ) betrachtet wird? <question>"
"Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit immer dann fraglich ist, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies soll nun etwas genauer beleuchtet werden.
In Java ist die Klasse Stack als Subklasse der Klasse Vector definiert, wobei Vector kein Vektor im mathematischen Sinne ist, sondern eher ein dynamisches Array, das in seiner Größe wachsen kann. Dies führt jedoch dazu, dass an Stellen im Programm, an denen eine indizierte Sammlung von Objekten mit wahlfreiem Zugriff erwartet wird (also ein Objekt vom Typ Vector), ein Objekt vom Typ Stack auftauchen kann. Obwohl Stack intern möglicherweise auf einem dynamischen Array ähnlich Vector aufbaut (und daher von Vector erbt), muss es an seiner öffentlich zugänglichen Schnittstelle die Funktionen für den wahlfreien Zugriff unterdrücken. In Java ist dies jedoch nicht möglich. Sollte das Programm also, in Erwartung einer indizierten Sammlung, auf ein Element zugreifen und stattdessen einen Stack vorfinden, kann das Programm nicht fortgesetzt werden, es sei denn, es findet vor dem Zugriff eine entsprechende Prüfung (und möglicherweise eine Verzweigung zu alternativen Verfahren) statt. Eine solche Prüfung muss jedoch zur Laufzeit erfolgen, und wenn sie vergessen wird (nicht implementiert), kann dies zu einem schwerwiegenden Programmierfehler führen. Solche Fehler lassen sich einfach vermeiden, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.
Eine schwächere Variante, die jedoch ähnlich katastrophale Folgen haben kann und deren Vorliegen nur schwer festzustellen ist, tritt auf, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht. Dies ist beispielsweise bei den beiden Typen Set (Menge) und Bag (Multimenge) der Fall. Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist. Die Funktionen ""Hinzufügen eines Elements"", ""Entfernen eines Elements"" sowie die Angabe der Größe und der Test auf das Vorhandensein eines Elements werden von Set genauso unterstützt wie von Bag. Der einzige Unterschied scheint zu sein, dass das Hinzufügen eines bereits vorhandenen Elements in der Menge von Set keine Veränderung bewirkt.
Bei genauerer Betrachtung ergibt sich jedoch das Problem, dass Set durch seine Eigenheit mehrere charakteristische Eigenschaften von Multimengen verletzt. Zum Beispiel gilt für Sets nicht wie für Bags, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden; doppelte Einfügungen werden von Set einfach ignoriert. Ein Programm, das auf die Eigenschaften von Bags setzt und stattdessen mit einem Set arbeiten muss, funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.
Umgekehrt würde, wenn man Bag als Subtyp von Set annähme, die für Set charakteristische Eigenschaft verletzt, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden.
Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des jeweils anderen implizieren, und dass sie sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" bilden, wobei die Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird. Dies entspricht jedoch genau der Definition des Subtypings aus Kurseinheit 3, Abschnitt 26.1. Tatsächlich ist es mehr oder weniger eine Frage der Interpretation, ob die in Kapitel 26 genannten syntaktischen Bedingungen, insbesondere die Ko- und Kontravarianz, für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen.
In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren in Form der Prüfung der Typkonformität immer nur angenähert. Tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen werden, wenn mangelnde Typkonformität vorliegt. Dennoch werden entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet jedoch Typkonformität nicht automatisch auch Substituierbarkeit. Dazu ist auch eine Betrachtung des Verhaltens notwendig.","<answer> Die Typkonformität allein reicht nicht aus, um Substituierbarkeit sicherzustellen, da auch das Verhalten der Objekte betrachtet werden muss. Typkonformität bedeutet nicht automatisch Substituierbarkeit. Substituierbarkeit erfordert eine Betrachtung des Verhaltens der Objekte. <answer> <question> Warum reicht die Typkonformität allein nicht aus, um Substituierbarkeit sicherzustellen? <question>"
"Das Beispiel von Aktion und Speichern legte bereits nahe, dass die Substituierbarkeit immer dann fraglich ist, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies soll nun etwas genauer beleuchtet werden.
In Java ist die Klasse Stack als Subklasse der Klasse Vector definiert, wobei Vector kein Vektor im mathematischen Sinne ist, sondern eher ein dynamisches Array, das in seiner Größe wachsen kann. Dies führt jedoch dazu, dass an Stellen im Programm, an denen eine indizierte Sammlung von Objekten mit wahlfreiem Zugriff erwartet wird (also ein Objekt vom Typ Vector), ein Objekt vom Typ Stack auftauchen kann. Obwohl Stack intern möglicherweise auf einem dynamischen Array ähnlich Vector aufbaut (und daher von Vector erbt), muss es an seiner öffentlich zugänglichen Schnittstelle die Funktionen für den wahlfreien Zugriff unterdrücken. In Java ist dies jedoch nicht möglich. Sollte das Programm also, in Erwartung einer indizierten Sammlung, auf ein Element zugreifen und stattdessen einen Stack vorfinden, kann das Programm nicht fortgesetzt werden, es sei denn, es findet vor dem Zugriff eine entsprechende Prüfung (und möglicherweise eine Verzweigung zu alternativen Verfahren) statt. Eine solche Prüfung muss jedoch zur Laufzeit erfolgen, und wenn sie vergessen wird (nicht implementiert), kann dies zu einem schwerwiegenden Programmierfehler führen. Solche Fehler lassen sich einfach vermeiden, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.
Eine schwächere Variante, die jedoch ähnlich katastrophale Folgen haben kann und deren Vorliegen nur schwer festzustellen ist, tritt auf, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht. Dies ist beispielsweise bei den beiden Typen Set (Menge) und Bag (Multimenge) der Fall. Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist. Die Funktionen ""Hinzufügen eines Elements"", ""Entfernen eines Elements"" sowie die Angabe der Größe und der Test auf das Vorhandensein eines Elements werden von Set genauso unterstützt wie von Bag. Der einzige Unterschied scheint zu sein, dass das Hinzufügen eines bereits vorhandenen Elements in der Menge von Set keine Veränderung bewirkt.
Bei genauerer Betrachtung ergibt sich jedoch das Problem, dass Set durch seine Eigenheit mehrere charakteristische Eigenschaften von Multimengen verletzt. Zum Beispiel gilt für Sets nicht wie für Bags, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht. Auch gilt nicht, dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden; doppelte Einfügungen werden von Set einfach ignoriert. Ein Programm, das auf die Eigenschaften von Bags setzt und stattdessen mit einem Set arbeiten muss, funktioniert mit hoher Wahrscheinlichkeit nicht mehr korrekt.
Umgekehrt würde, wenn man Bag als Subtyp von Set annähme, die für Set charakteristische Eigenschaft verletzt, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden.
Wenn man versucht, der Ursache des Fehlers auf den Grund zu gehen, kommt man schnell zu der Einsicht, dass die charakteristischen Eigenschaften keiner der beiden Typen die des jeweils anderen implizieren, und dass sie sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen wie ""Für alle Objekte vom Typ X gilt..."" bilden, wobei die Objekte vom Typ X (Bag oder Set) immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird. Dies entspricht jedoch genau der Definition des Subtypings aus Kurseinheit 3, Abschnitt 26.1. Tatsächlich ist es mehr oder weniger eine Frage der Interpretation, ob die in Kapitel 26 genannten syntaktischen Bedingungen, insbesondere die Ko- und Kontravarianz, für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen.
In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren in Form der Prüfung der Typkonformität immer nur angenähert. Tatsächlich kann nicht einmal eine Substituierbarkeit ausgeschlossen werden, wenn mangelnde Typkonformität vorliegt. Dennoch werden entsprechende Zuweisungen nicht zugelassen. Umgekehrt bedeutet jedoch Typkonformität nicht automatisch auch Substituierbarkeit. Dazu ist auch eine Betrachtung des Verhaltens notwendig.","<answer> In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren, insbesondere die Prüfung der Typkonformität, angenähert. Dabei wird jedoch betont, dass nicht einmal eine Substituierbarkeit ausgeschlossen werden kann, wenn mangelnde Typkonformität vorliegt. Substituierbarkeit erfordert auch eine Betrachtung des Verhaltens der Objekte. <answer> <question> Wie wird die Prüfung der Substituierbarkeit in der Praxis durchgeführt? <question>"
"Klassendefinitionen bilden also eine Art Vorlage für Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht — sie ist gewissermaßen die Umkehrung der Klassifikation, also des Übergangs vom Individuum zu seiner Klasse (wobei die Klassifikation, anders als die Instanziierung, in der Programmierung kein Vorgang ist). Vom erzeugten Objekt sagt man dann, es sei Instanz dieser Klasse. Tatsächlich spricht man in SMALLTALK, da ja auch Klassen Objekte sind, häufig von Instanzen anstelle von Objekten, wenn keine Klassen gemeint sind. Wie wir schon im nächsten Kapitel sehen werden, sind in SMALLTALK jedoch auch Klassen Instanzen. So gesehen handelt es sich bei den Begriffen Instanz und Klasse also eher um Rollen von Objekten, die im Verhältnis der Instanziierung zueinander stehen. Die Begriffsbildung der objektorientierten Programmierung ist an dieser Stelle aber leider nicht besonders gelungen.
In SMALLTALK ist jedes Objekt Instanz genau einer Klasse. (Genaugenommen ist es direkte Instanz genau einer Klasse, aber zum Unterschied zu indirekten Instanzen kommen wir erst in Abschnitt 9.1.) Dabei weiß jedes Objekt, von welcher Klasse es eine Instanz ist; diese Information lässt sich dem Objekt durch Senden der Nachricht class entlocken; der entsprechende Ausdruck liefert das Objekt, das die Klasse repräsentiert, zurück.
Mit der Instanziierung wird der Extension einer Klasse ein neues Element hinzugefügt. Das Elementsein auf Mengenebene entspricht also in etwa dem Instanzsein auf programmiersprachlicher Ebene (in UML wie im obigen Diagramm durch einen gestrichelten Pfeil angedeutet). Wir werden noch öfter auf diese mengentheoretische Interpretation zurückkommen.
Die Objekte, die wir in Kurseinheit 1 kennengelernt haben, wurden sämtlich durch Literale repräsentiert; diese Objekte sind, da sie vom Compiler erzeugt werden, aus Sicht des Programms „schon da“, wenn es ausgeführt wird. Mittels Instanziierung und Klassen hat man nun die Möglichkeit, neue — und neuartige — Objekte programmatisch, also per Programmausführung, zu erzeugen. Dies geschieht standardmäßig, indem man der Klasse, von der man eine Instanz haben möchte, die Nachricht new (für Klassen ohne indizierte Instanzvariablen) oder new: (für Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems; s. Abschnitt 4.3.7) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert. Der Parameter der Nachricht von Objekten, nämlich solche, die instanziierbar sind, und solche, die es nicht sind. Instanziierbare Objekte sind immer (auch) Klassen; für solche, die es nicht sind, gibt es leider keine spezielle Bezeichnung. Man könnte sie jedoch, wie wir in Abschnitt 8.5 sehen werden, Ebene-0-Objekte nennen.
new: muss immer eine natürliche Zahl sein und legt die Anzahl der indizierten Instanzvariablen fest, über die ein Objekt verfügt. Hat ein Objekt (per Klassendefinition; s. Abschnitt 7.2) keine indizierten Instanzvariablen, führt new: zu einem Laufzeitfehler.
Einen neuen Stack mit Platz für 100 Elemente erhält man, indem man, bei obiger erster Klassendefinition von Stack, den Ausdruck Stack new: 100 auswertet. Dabei ist Stack wie gesagt eine Pseudovariable, die den Klassennamen trägt, die auf das Objekt verweist, das die Klasse repräsentiert, und der ihr Wert beim Anlegen der Klasse vom System zugewiesen wurde. In der zweiten Form der Implementierung wäre eben dieser Ausdruck verboten: Stattdessen dürfte der Ausdruck dann nur noch Stack new: 100 heißen. Dass der Stack dann trotzdem 100 Elemente halten kann, muss in diesem Fall bei der Instanziierung des Zwischenobjekts, auf das die Variable stackcontent verweist, mittels eines entsprechenden New-Ausdrucks angegeben werden. Diese Instanziierung hatten wir jedoch oben unterschlagen; wo und wie sie durchgeführt wird, wird Gegenstand des nächsten Kapitels sein, wenn es um Konstruktoren und Initialisierung geht.
Eine Alternative zum Instanziieren ist übrigens das Klonen. Beim Klonen wird ein neues Objekt auf der Basis eines bereits existierenden erzeugt. Der Klon stellt also eine Kopie dar. Beim Klonvorgang ist festzulegen, wie weit (tief) das Kopieren gehen soll, also ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht (auf die die Instanzvariablen verweisen; s. Kapitel 2 in Kurseinheit 1) kopiert werden sollen. Während in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse ja nicht kennen, Klonen die einzige Möglichkeit ist, neue Objekte zu erstellen, müssen bei Programmiersprachen mit Klassen, in denen jedes Objekt Instanz einer Klasse sein muss, Klone in der Regel durch Instanziierung und Übertragung der Inhalte der Instanzvariablen erzeugt werden. Da wir hier aber die klassenbasierte Linie verfolgen und auf klassenlose objektorientierte Programmiersprachen nur eingehen, wo dies interessant erscheint, werden wir das Klonen, das in klassenbasierten objektorientierten Programmiersprachen eine untergeordnete Rolle spielt, erst in Abschnitt 14.1 vertiefen.","<answer> Instanziierung in SMALLTALK ist der Prozess, bei dem ein neues Objekt einer bestimmten Klasse erstellt wird. Das neue Objekt wird eine Instanz dieser Klasse genannt und hat die Eigenschaften (Instanzvariablen und Methoden), die durch die Definition (Intension) der Klasse festgelegt sind. <answer> <question> Was ist Instanziierung in SMALLTALK? <question>"
"Klassendefinitionen bilden also eine Art Vorlage für Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht — sie ist gewissermaßen die Umkehrung der Klassifikation, also des Übergangs vom Individuum zu seiner Klasse (wobei die Klassifikation, anders als die Instanziierung, in der Programmierung kein Vorgang ist). Vom erzeugten Objekt sagt man dann, es sei Instanz dieser Klasse. Tatsächlich spricht man in SMALLTALK, da ja auch Klassen Objekte sind, häufig von Instanzen anstelle von Objekten, wenn keine Klassen gemeint sind. Wie wir schon im nächsten Kapitel sehen werden, sind in SMALLTALK jedoch auch Klassen Instanzen. So gesehen handelt es sich bei den Begriffen Instanz und Klasse also eher um Rollen von Objekten, die im Verhältnis der Instanziierung zueinander stehen. Die Begriffsbildung der objektorientierten Programmierung ist an dieser Stelle aber leider nicht besonders gelungen.
In SMALLTALK ist jedes Objekt Instanz genau einer Klasse. (Genaugenommen ist es direkte Instanz genau einer Klasse, aber zum Unterschied zu indirekten Instanzen kommen wir erst in Abschnitt 9.1.) Dabei weiß jedes Objekt, von welcher Klasse es eine Instanz ist; diese Information lässt sich dem Objekt durch Senden der Nachricht class entlocken; der entsprechende Ausdruck liefert das Objekt, das die Klasse repräsentiert, zurück.
Mit der Instanziierung wird der Extension einer Klasse ein neues Element hinzugefügt. Das Elementsein auf Mengenebene entspricht also in etwa dem Instanzsein auf programmiersprachlicher Ebene (in UML wie im obigen Diagramm durch einen gestrichelten Pfeil angedeutet). Wir werden noch öfter auf diese mengentheoretische Interpretation zurückkommen.
Die Objekte, die wir in Kurseinheit 1 kennengelernt haben, wurden sämtlich durch Literale repräsentiert; diese Objekte sind, da sie vom Compiler erzeugt werden, aus Sicht des Programms „schon da“, wenn es ausgeführt wird. Mittels Instanziierung und Klassen hat man nun die Möglichkeit, neue — und neuartige — Objekte programmatisch, also per Programmausführung, zu erzeugen. Dies geschieht standardmäßig, indem man der Klasse, von der man eine Instanz haben möchte, die Nachricht new (für Klassen ohne indizierte Instanzvariablen) oder new: (für Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems; s. Abschnitt 4.3.7) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert. Der Parameter der Nachricht von Objekten, nämlich solche, die instanziierbar sind, und solche, die es nicht sind. Instanziierbare Objekte sind immer (auch) Klassen; für solche, die es nicht sind, gibt es leider keine spezielle Bezeichnung. Man könnte sie jedoch, wie wir in Abschnitt 8.5 sehen werden, Ebene-0-Objekte nennen.
new: muss immer eine natürliche Zahl sein und legt die Anzahl der indizierten Instanzvariablen fest, über die ein Objekt verfügt. Hat ein Objekt (per Klassendefinition; s. Abschnitt 7.2) keine indizierten Instanzvariablen, führt new: zu einem Laufzeitfehler.
Einen neuen Stack mit Platz für 100 Elemente erhält man, indem man, bei obiger erster Klassendefinition von Stack, den Ausdruck Stack new: 100 auswertet. Dabei ist Stack wie gesagt eine Pseudovariable, die den Klassennamen trägt, die auf das Objekt verweist, das die Klasse repräsentiert, und der ihr Wert beim Anlegen der Klasse vom System zugewiesen wurde. In der zweiten Form der Implementierung wäre eben dieser Ausdruck verboten: Stattdessen dürfte der Ausdruck dann nur noch Stack new: 100 heißen. Dass der Stack dann trotzdem 100 Elemente halten kann, muss in diesem Fall bei der Instanziierung des Zwischenobjekts, auf das die Variable stackcontent verweist, mittels eines entsprechenden New-Ausdrucks angegeben werden. Diese Instanziierung hatten wir jedoch oben unterschlagen; wo und wie sie durchgeführt wird, wird Gegenstand des nächsten Kapitels sein, wenn es um Konstruktoren und Initialisierung geht.
Eine Alternative zum Instanziieren ist übrigens das Klonen. Beim Klonen wird ein neues Objekt auf der Basis eines bereits existierenden erzeugt. Der Klon stellt also eine Kopie dar. Beim Klonvorgang ist festzulegen, wie weit (tief) das Kopieren gehen soll, also ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht (auf die die Instanzvariablen verweisen; s. Kapitel 2 in Kurseinheit 1) kopiert werden sollen. Während in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse ja nicht kennen, Klonen die einzige Möglichkeit ist, neue Objekte zu erstellen, müssen bei Programmiersprachen mit Klassen, in denen jedes Objekt Instanz einer Klasse sein muss, Klone in der Regel durch Instanziierung und Übertragung der Inhalte der Instanzvariablen erzeugt werden. Da wir hier aber die klassenbasierte Linie verfolgen und auf klassenlose objektorientierte Programmiersprachen nur eingehen, wo dies interessant erscheint, werden wir das Klonen, das in klassenbasierten objektorientierten Programmiersprachen eine untergeordnete Rolle spielt, erst in Abschnitt 14.1 vertiefen.","<answer> Durch Senden der Nachricht ""class"" an ein Objekt kann man erfahren, von welcher Klasse das Objekt eine Instanz ist. Dies liefert das Objekt, das die Klasse repräsentiert, zurück. <answer> <question> Welche Information kann einem Objekt durch Senden der Nachricht ""class"" entlockt werden? <question>"
"Klassendefinitionen bilden also eine Art Vorlage für Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht — sie ist gewissermaßen die Umkehrung der Klassifikation, also des Übergangs vom Individuum zu seiner Klasse (wobei die Klassifikation, anders als die Instanziierung, in der Programmierung kein Vorgang ist). Vom erzeugten Objekt sagt man dann, es sei Instanz dieser Klasse. Tatsächlich spricht man in SMALLTALK, da ja auch Klassen Objekte sind, häufig von Instanzen anstelle von Objekten, wenn keine Klassen gemeint sind. Wie wir schon im nächsten Kapitel sehen werden, sind in SMALLTALK jedoch auch Klassen Instanzen. So gesehen handelt es sich bei den Begriffen Instanz und Klasse also eher um Rollen von Objekten, die im Verhältnis der Instanziierung zueinander stehen. Die Begriffsbildung der objektorientierten Programmierung ist an dieser Stelle aber leider nicht besonders gelungen.
In SMALLTALK ist jedes Objekt Instanz genau einer Klasse. (Genaugenommen ist es direkte Instanz genau einer Klasse, aber zum Unterschied zu indirekten Instanzen kommen wir erst in Abschnitt 9.1.) Dabei weiß jedes Objekt, von welcher Klasse es eine Instanz ist; diese Information lässt sich dem Objekt durch Senden der Nachricht class entlocken; der entsprechende Ausdruck liefert das Objekt, das die Klasse repräsentiert, zurück.
Mit der Instanziierung wird der Extension einer Klasse ein neues Element hinzugefügt. Das Elementsein auf Mengenebene entspricht also in etwa dem Instanzsein auf programmiersprachlicher Ebene (in UML wie im obigen Diagramm durch einen gestrichelten Pfeil angedeutet). Wir werden noch öfter auf diese mengentheoretische Interpretation zurückkommen.
Die Objekte, die wir in Kurseinheit 1 kennengelernt haben, wurden sämtlich durch Literale repräsentiert; diese Objekte sind, da sie vom Compiler erzeugt werden, aus Sicht des Programms „schon da“, wenn es ausgeführt wird. Mittels Instanziierung und Klassen hat man nun die Möglichkeit, neue — und neuartige — Objekte programmatisch, also per Programmausführung, zu erzeugen. Dies geschieht standardmäßig, indem man der Klasse, von der man eine Instanz haben möchte, die Nachricht new (für Klassen ohne indizierte Instanzvariablen) oder new: (für Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems; s. Abschnitt 4.3.7) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert. Der Parameter der Nachricht von Objekten, nämlich solche, die instanziierbar sind, und solche, die es nicht sind. Instanziierbare Objekte sind immer (auch) Klassen; für solche, die es nicht sind, gibt es leider keine spezielle Bezeichnung. Man könnte sie jedoch, wie wir in Abschnitt 8.5 sehen werden, Ebene-0-Objekte nennen.
new: muss immer eine natürliche Zahl sein und legt die Anzahl der indizierten Instanzvariablen fest, über die ein Objekt verfügt. Hat ein Objekt (per Klassendefinition; s. Abschnitt 7.2) keine indizierten Instanzvariablen, führt new: zu einem Laufzeitfehler.
Einen neuen Stack mit Platz für 100 Elemente erhält man, indem man, bei obiger erster Klassendefinition von Stack, den Ausdruck Stack new: 100 auswertet. Dabei ist Stack wie gesagt eine Pseudovariable, die den Klassennamen trägt, die auf das Objekt verweist, das die Klasse repräsentiert, und der ihr Wert beim Anlegen der Klasse vom System zugewiesen wurde. In der zweiten Form der Implementierung wäre eben dieser Ausdruck verboten: Stattdessen dürfte der Ausdruck dann nur noch Stack new: 100 heißen. Dass der Stack dann trotzdem 100 Elemente halten kann, muss in diesem Fall bei der Instanziierung des Zwischenobjekts, auf das die Variable stackcontent verweist, mittels eines entsprechenden New-Ausdrucks angegeben werden. Diese Instanziierung hatten wir jedoch oben unterschlagen; wo und wie sie durchgeführt wird, wird Gegenstand des nächsten Kapitels sein, wenn es um Konstruktoren und Initialisierung geht.
Eine Alternative zum Instanziieren ist übrigens das Klonen. Beim Klonen wird ein neues Objekt auf der Basis eines bereits existierenden erzeugt. Der Klon stellt also eine Kopie dar. Beim Klonvorgang ist festzulegen, wie weit (tief) das Kopieren gehen soll, also ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht (auf die die Instanzvariablen verweisen; s. Kapitel 2 in Kurseinheit 1) kopiert werden sollen. Während in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse ja nicht kennen, Klonen die einzige Möglichkeit ist, neue Objekte zu erstellen, müssen bei Programmiersprachen mit Klassen, in denen jedes Objekt Instanz einer Klasse sein muss, Klone in der Regel durch Instanziierung und Übertragung der Inhalte der Instanzvariablen erzeugt werden. Da wir hier aber die klassenbasierte Linie verfolgen und auf klassenlose objektorientierte Programmiersprachen nur eingehen, wo dies interessant erscheint, werden wir das Klonen, das in klassenbasierten objektorientierten Programmiersprachen eine untergeordnete Rolle spielt, erst in Abschnitt 14.1 vertiefen.","<answer> In SMALLTALK wird normalerweise die Instanziierung eines Objekts durch Senden der Nachricht ""new"" (für Klassen ohne indizierte Instanzvariablen) oder ""new:"" (für Klassen mit indizierten Instanzvariablen) an die Klasse durchgeführt. Das neue Objekt wird im Speicher angelegt, und seine Instanzvariablen werden alle mit ""nil"" initialisiert. <answer> <question> Wie wird in SMALLTALK normalerweise die Instanziierung eines Objekts durchgeführt? <question>"
"Klassendefinitionen bilden also eine Art Vorlage für Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht — sie ist gewissermaßen die Umkehrung der Klassifikation, also des Übergangs vom Individuum zu seiner Klasse (wobei die Klassifikation, anders als die Instanziierung, in der Programmierung kein Vorgang ist). Vom erzeugten Objekt sagt man dann, es sei Instanz dieser Klasse. Tatsächlich spricht man in SMALLTALK, da ja auch Klassen Objekte sind, häufig von Instanzen anstelle von Objekten, wenn keine Klassen gemeint sind. Wie wir schon im nächsten Kapitel sehen werden, sind in SMALLTALK jedoch auch Klassen Instanzen. So gesehen handelt es sich bei den Begriffen Instanz und Klasse also eher um Rollen von Objekten, die im Verhältnis der Instanziierung zueinander stehen. Die Begriffsbildung der objektorientierten Programmierung ist an dieser Stelle aber leider nicht besonders gelungen.
In SMALLTALK ist jedes Objekt Instanz genau einer Klasse. (Genaugenommen ist es direkte Instanz genau einer Klasse, aber zum Unterschied zu indirekten Instanzen kommen wir erst in Abschnitt 9.1.) Dabei weiß jedes Objekt, von welcher Klasse es eine Instanz ist; diese Information lässt sich dem Objekt durch Senden der Nachricht class entlocken; der entsprechende Ausdruck liefert das Objekt, das die Klasse repräsentiert, zurück.
Mit der Instanziierung wird der Extension einer Klasse ein neues Element hinzugefügt. Das Elementsein auf Mengenebene entspricht also in etwa dem Instanzsein auf programmiersprachlicher Ebene (in UML wie im obigen Diagramm durch einen gestrichelten Pfeil angedeutet). Wir werden noch öfter auf diese mengentheoretische Interpretation zurückkommen.
Die Objekte, die wir in Kurseinheit 1 kennengelernt haben, wurden sämtlich durch Literale repräsentiert; diese Objekte sind, da sie vom Compiler erzeugt werden, aus Sicht des Programms „schon da“, wenn es ausgeführt wird. Mittels Instanziierung und Klassen hat man nun die Möglichkeit, neue — und neuartige — Objekte programmatisch, also per Programmausführung, zu erzeugen. Dies geschieht standardmäßig, indem man der Klasse, von der man eine Instanz haben möchte, die Nachricht new (für Klassen ohne indizierte Instanzvariablen) oder new: (für Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems; s. Abschnitt 4.3.7) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert. Der Parameter der Nachricht von Objekten, nämlich solche, die instanziierbar sind, und solche, die es nicht sind. Instanziierbare Objekte sind immer (auch) Klassen; für solche, die es nicht sind, gibt es leider keine spezielle Bezeichnung. Man könnte sie jedoch, wie wir in Abschnitt 8.5 sehen werden, Ebene-0-Objekte nennen.
new: muss immer eine natürliche Zahl sein und legt die Anzahl der indizierten Instanzvariablen fest, über die ein Objekt verfügt. Hat ein Objekt (per Klassendefinition; s. Abschnitt 7.2) keine indizierten Instanzvariablen, führt new: zu einem Laufzeitfehler.
Einen neuen Stack mit Platz für 100 Elemente erhält man, indem man, bei obiger erster Klassendefinition von Stack, den Ausdruck Stack new: 100 auswertet. Dabei ist Stack wie gesagt eine Pseudovariable, die den Klassennamen trägt, die auf das Objekt verweist, das die Klasse repräsentiert, und der ihr Wert beim Anlegen der Klasse vom System zugewiesen wurde. In der zweiten Form der Implementierung wäre eben dieser Ausdruck verboten: Stattdessen dürfte der Ausdruck dann nur noch Stack new: 100 heißen. Dass der Stack dann trotzdem 100 Elemente halten kann, muss in diesem Fall bei der Instanziierung des Zwischenobjekts, auf das die Variable stackcontent verweist, mittels eines entsprechenden New-Ausdrucks angegeben werden. Diese Instanziierung hatten wir jedoch oben unterschlagen; wo und wie sie durchgeführt wird, wird Gegenstand des nächsten Kapitels sein, wenn es um Konstruktoren und Initialisierung geht.
Eine Alternative zum Instanziieren ist übrigens das Klonen. Beim Klonen wird ein neues Objekt auf der Basis eines bereits existierenden erzeugt. Der Klon stellt also eine Kopie dar. Beim Klonvorgang ist festzulegen, wie weit (tief) das Kopieren gehen soll, also ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht (auf die die Instanzvariablen verweisen; s. Kapitel 2 in Kurseinheit 1) kopiert werden sollen. Während in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse ja nicht kennen, Klonen die einzige Möglichkeit ist, neue Objekte zu erstellen, müssen bei Programmiersprachen mit Klassen, in denen jedes Objekt Instanz einer Klasse sein muss, Klone in der Regel durch Instanziierung und Übertragung der Inhalte der Instanzvariablen erzeugt werden. Da wir hier aber die klassenbasierte Linie verfolgen und auf klassenlose objektorientierte Programmiersprachen nur eingehen, wo dies interessant erscheint, werden wir das Klonen, das in klassenbasierten objektorientierten Programmiersprachen eine untergeordnete Rolle spielt, erst in Abschnitt 14.1 vertiefen.","<answer> Der Unterschied zwischen ""new"" und ""new:"" liegt in der Anzahl der indizierten Instanzvariablen, die bei der Instanziierung festgelegt werden. ""new"" wird für Klassen ohne indizierte Instanzvariablen verwendet, während ""new:"" für Klassen mit indizierten Instanzvariablen verwendet wird. Der Parameter von ""new:"" muss immer eine natürliche Zahl sein und legt die Anzahl der indizierten Instanzvariablen fest, über die ein Objekt verfügt. <answer> <question> Was ist der Unterschied zwischen ""new"" und ""new:"" in Bezug auf die Instanziierung von Objekten in SMALLTALK? <question>"
"Klassendefinitionen bilden also eine Art Vorlage für Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht — sie ist gewissermaßen die Umkehrung der Klassifikation, also des Übergangs vom Individuum zu seiner Klasse (wobei die Klassifikation, anders als die Instanziierung, in der Programmierung kein Vorgang ist). Vom erzeugten Objekt sagt man dann, es sei Instanz dieser Klasse. Tatsächlich spricht man in SMALLTALK, da ja auch Klassen Objekte sind, häufig von Instanzen anstelle von Objekten, wenn keine Klassen gemeint sind. Wie wir schon im nächsten Kapitel sehen werden, sind in SMALLTALK jedoch auch Klassen Instanzen. So gesehen handelt es sich bei den Begriffen Instanz und Klasse also eher um Rollen von Objekten, die im Verhältnis der Instanziierung zueinander stehen. Die Begriffsbildung der objektorientierten Programmierung ist an dieser Stelle aber leider nicht besonders gelungen.
In SMALLTALK ist jedes Objekt Instanz genau einer Klasse. (Genaugenommen ist es direkte Instanz genau einer Klasse, aber zum Unterschied zu indirekten Instanzen kommen wir erst in Abschnitt 9.1.) Dabei weiß jedes Objekt, von welcher Klasse es eine Instanz ist; diese Information lässt sich dem Objekt durch Senden der Nachricht class entlocken; der entsprechende Ausdruck liefert das Objekt, das die Klasse repräsentiert, zurück.
Mit der Instanziierung wird der Extension einer Klasse ein neues Element hinzugefügt. Das Elementsein auf Mengenebene entspricht also in etwa dem Instanzsein auf programmiersprachlicher Ebene (in UML wie im obigen Diagramm durch einen gestrichelten Pfeil angedeutet). Wir werden noch öfter auf diese mengentheoretische Interpretation zurückkommen.
Die Objekte, die wir in Kurseinheit 1 kennengelernt haben, wurden sämtlich durch Literale repräsentiert; diese Objekte sind, da sie vom Compiler erzeugt werden, aus Sicht des Programms „schon da“, wenn es ausgeführt wird. Mittels Instanziierung und Klassen hat man nun die Möglichkeit, neue — und neuartige — Objekte programmatisch, also per Programmausführung, zu erzeugen. Dies geschieht standardmäßig, indem man der Klasse, von der man eine Instanz haben möchte, die Nachricht new (für Klassen ohne indizierte Instanzvariablen) oder new: (für Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems; s. Abschnitt 4.3.7) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert. Der Parameter der Nachricht von Objekten, nämlich solche, die instanziierbar sind, und solche, die es nicht sind. Instanziierbare Objekte sind immer (auch) Klassen; für solche, die es nicht sind, gibt es leider keine spezielle Bezeichnung. Man könnte sie jedoch, wie wir in Abschnitt 8.5 sehen werden, Ebene-0-Objekte nennen.
new: muss immer eine natürliche Zahl sein und legt die Anzahl der indizierten Instanzvariablen fest, über die ein Objekt verfügt. Hat ein Objekt (per Klassendefinition; s. Abschnitt 7.2) keine indizierten Instanzvariablen, führt new: zu einem Laufzeitfehler.
Einen neuen Stack mit Platz für 100 Elemente erhält man, indem man, bei obiger erster Klassendefinition von Stack, den Ausdruck Stack new: 100 auswertet. Dabei ist Stack wie gesagt eine Pseudovariable, die den Klassennamen trägt, die auf das Objekt verweist, das die Klasse repräsentiert, und der ihr Wert beim Anlegen der Klasse vom System zugewiesen wurde. In der zweiten Form der Implementierung wäre eben dieser Ausdruck verboten: Stattdessen dürfte der Ausdruck dann nur noch Stack new: 100 heißen. Dass der Stack dann trotzdem 100 Elemente halten kann, muss in diesem Fall bei der Instanziierung des Zwischenobjekts, auf das die Variable stackcontent verweist, mittels eines entsprechenden New-Ausdrucks angegeben werden. Diese Instanziierung hatten wir jedoch oben unterschlagen; wo und wie sie durchgeführt wird, wird Gegenstand des nächsten Kapitels sein, wenn es um Konstruktoren und Initialisierung geht.
Eine Alternative zum Instanziieren ist übrigens das Klonen. Beim Klonen wird ein neues Objekt auf der Basis eines bereits existierenden erzeugt. Der Klon stellt also eine Kopie dar. Beim Klonvorgang ist festzulegen, wie weit (tief) das Kopieren gehen soll, also ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht (auf die die Instanzvariablen verweisen; s. Kapitel 2 in Kurseinheit 1) kopiert werden sollen. Während in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse ja nicht kennen, Klonen die einzige Möglichkeit ist, neue Objekte zu erstellen, müssen bei Programmiersprachen mit Klassen, in denen jedes Objekt Instanz einer Klasse sein muss, Klone in der Regel durch Instanziierung und Übertragung der Inhalte der Instanzvariablen erzeugt werden. Da wir hier aber die klassenbasierte Linie verfolgen und auf klassenlose objektorientierte Programmiersprachen nur eingehen, wo dies interessant erscheint, werden wir das Klonen, das in klassenbasierten objektorientierten Programmiersprachen eine untergeordnete Rolle spielt, erst in Abschnitt 14.1 vertiefen.","<answer> Das Klonen in SMALLTALK ist ein Prozess, bei dem ein neues Objekt auf der Basis eines bereits existierenden Objekts erstellt wird. Der Klon ist eine Kopie des Originalobjekts. Beim Klonen muss festgelegt werden, wie tief die Kopie gehen soll, dh ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht, kopiert werden sollen. Eine Alternative zur Instanziierung ist das Klonen. Während das Klonen in klassenbasierten objektorientierten Programmiersprachen in der Regel durch Instanziierung und Übertragung von Inhaltsdaten der Instanzvariablen erzeugt wird, erfolgt das Klonen in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse nicht kennen, durch einfaches Kopieren. In SMALLTALK wird die Instanziierung normalerweise bevorzugt, da es sich um eine klassenbasierte Sprache handelt. <answer> <question> Was ist Klonen in SMALLTALK, und welche Alternative gibt es zur Instanziierung? <question>"
"In SMALLTALK sind Konstruktoren ganz normale Klassenmethoden und daher an keine besonderen Konventionen gebunden. Insbesondere müssen sie nicht zwingend ein neues Objekt genau der Klasse zurückgeben, zu der sie gehören. Dies ermöglicht die Verwendung sogenannter Factory-Methoden.
Eine Factory-Methode ist eine Methode, die ähnlich wie ein Konstruktor eine neue Instanz liefert. Allerdings macht sie die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode gehört, abhängig. Zum Beispiel könnte eine Klasse ""Number"" eine Klassenmethode ""fromString:"" bereitstellen, die anhand eines zu analysierenden Strings entweder eine Instanz der Klasse ""Integer"" oder eine Instanz der Klasse ""Float"" zurückgibt. Die Implementierung solcher Factory-Methoden ist in SMALLTALK einfach möglich und sie unterscheiden sich formal nicht von Konstruktoren – es handelt sich einfach um Klassenmethoden.
Diese Factory-Methode ""fromString:"" in der Klasse ""Number"" analysiert den übergebenen String. Wenn der Parameter ""aString"" einen Dezimalpunkt enthält, wird eine neue Fließkommazahl zurückgegeben (mittels der Methode ""asFloat"", die in der Klasse ""String"" implementiert ist und eine Instanz der Klasse ""Float"" zurückliefert). Andernfalls wird eine Ganzzahl zurückgegeben.
Diese Art von Factory-Methoden ermöglicht eine flexible Instanziierung von Objekten abhängig von den gegebenen Eingaben.","<answer> Factory-Methoden in SMALLTALK sind spezielle Klassenmethoden, die ähnlich wie Konstruktoren neue Instanzen erstellen. Allerdings können sie die Klasse der Instanz basierend auf anderen Faktoren als nur der Klasse, zu der die Methode gehört, festlegen. <answer> <question> Was sind Factory-Methoden in SMALLTALK? <question>"
"In SMALLTALK sind Konstruktoren ganz normale Klassenmethoden und daher an keine besonderen Konventionen gebunden. Insbesondere müssen sie nicht zwingend ein neues Objekt genau der Klasse zurückgeben, zu der sie gehören. Dies ermöglicht die Verwendung sogenannter Factory-Methoden.
Eine Factory-Methode ist eine Methode, die ähnlich wie ein Konstruktor eine neue Instanz liefert. Allerdings macht sie die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode gehört, abhängig. Zum Beispiel könnte eine Klasse ""Number"" eine Klassenmethode ""fromString:"" bereitstellen, die anhand eines zu analysierenden Strings entweder eine Instanz der Klasse ""Integer"" oder eine Instanz der Klasse ""Float"" zurückgibt. Die Implementierung solcher Factory-Methoden ist in SMALLTALK einfach möglich und sie unterscheiden sich formal nicht von Konstruktoren – es handelt sich einfach um Klassenmethoden.
Diese Factory-Methode ""fromString:"" in der Klasse ""Number"" analysiert den übergebenen String. Wenn der Parameter ""aString"" einen Dezimalpunkt enthält, wird eine neue Fließkommazahl zurückgegeben (mittels der Methode ""asFloat"", die in der Klasse ""String"" implementiert ist und eine Instanz der Klasse ""Float"" zurückliefert). Andernfalls wird eine Ganzzahl zurückgegeben.
Diese Art von Factory-Methoden ermöglicht eine flexible Instanziierung von Objekten abhängig von den gegebenen Eingaben.","<answer> Formal unterscheiden sich Factory-Methoden in SMALLTALK nicht von Konstruktoren; sie sind ebenfalls Klassenmethoden. Der Unterschied besteht darin, dass Factory-Methoden die Klasse der Instanz basierend auf anderen Faktoren festlegen können, während Konstruktoren normalerweise Instanzen derselben Klasse erstellen. <answer> <question> Wie unterscheiden sich Factory-Methoden formal von Konstruktoren in SMALLTALK? <question>"
"Es stellt sich nun die Frage, wann ein Typ mit einem anderen zuweisungskompatibel ist. Offensichtlich ist dies der Fall, wenn die Typen identisch sind. Wie bereits oben erwähnt, ist dies jedoch keine notwendige Voraussetzung für die Zuweisungskompatibilität. Es ist nämlich auch möglich, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind. Man spricht in diesen Fällen von einer Typäquivalenz.
Von der Typäquivalenz gibt es zwei Arten: die nominale (sich auf den Namen beziehende) Typäquivalenz, auch Namensäquivalenz genannt, und die strukturelle Typäquivalenz, auch als Strukturäquivalenz bezeichnet. Während die nominale Typäquivalenz verlangt, dass zwei Deklarationen (beispielsweise von Variablen) dieselben Typen angeben, damit Zuweisungskompatibilität vorliegt, kommt es bei der strukturellen Typäquivalenz lediglich darauf an, dass die Typen paarweise gleich definiert sind (also die gleichen Eigenschaften von ihren Werten verlangen). Die Typen müssen sich also in ihrer Struktur, aber nicht unbedingt in ihren Namen gleichen.
Typäquivalenz ist eine symmetrische Eigenschaft: Wenn ein Typ A (nominal oder strukturell) äquivalent zu einem Typ B ist, dann ist B genauso äquivalent zu A. Die Reflexivität der Typäquivalenz, also dass jeder Typ äquivalent zu sich selbst ist, ergibt sich von selbst. Außerdem ist Typäquivalenz transitiv: Wenn A (nominal oder strukturell) äquivalent zu B ist und B in der gleichen Art äquivalent zu C ist, dann ist auch A äquivalent zu C (und, aufgrund der Symmetrie, C äquivalent zu A).","<answer> Zwei Typen sind zuweisungskompatibel, wenn sie identisch sind oder eine bestimmte Form der Typäquivalenz aufweisen. <answer> <question> Wann sind zwei Typen zuweisungskompatibel? <question>"
"Es stellt sich nun die Frage, wann ein Typ mit einem anderen zuweisungskompatibel ist. Offensichtlich ist dies der Fall, wenn die Typen identisch sind. Wie bereits oben erwähnt, ist dies jedoch keine notwendige Voraussetzung für die Zuweisungskompatibilität. Es ist nämlich auch möglich, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind. Man spricht in diesen Fällen von einer Typäquivalenz.
Von der Typäquivalenz gibt es zwei Arten: die nominale (sich auf den Namen beziehende) Typäquivalenz, auch Namensäquivalenz genannt, und die strukturelle Typäquivalenz, auch als Strukturäquivalenz bezeichnet. Während die nominale Typäquivalenz verlangt, dass zwei Deklarationen (beispielsweise von Variablen) dieselben Typen angeben, damit Zuweisungskompatibilität vorliegt, kommt es bei der strukturellen Typäquivalenz lediglich darauf an, dass die Typen paarweise gleich definiert sind (also die gleichen Eigenschaften von ihren Werten verlangen). Die Typen müssen sich also in ihrer Struktur, aber nicht unbedingt in ihren Namen gleichen.
Typäquivalenz ist eine symmetrische Eigenschaft: Wenn ein Typ A (nominal oder strukturell) äquivalent zu einem Typ B ist, dann ist B genauso äquivalent zu A. Die Reflexivität der Typäquivalenz, also dass jeder Typ äquivalent zu sich selbst ist, ergibt sich von selbst. Außerdem ist Typäquivalenz transitiv: Wenn A (nominal oder strukturell) äquivalent zu B ist und B in der gleichen Art äquivalent zu C ist, dann ist auch A äquivalent zu C (und, aufgrund der Symmetrie, C äquivalent zu A).","<answer> Typäquivalenz ist eine Eigenschaft, die die Zuweisungskompatibilität von Typen beschreibt. Sie bezieht sich darauf, ob Typen in bestimmten Aspekten gleich oder äquivalent sind, ohne unbedingt identisch zu sein. <answer> <question> Was ist Typäquivalenz, und wie wird sie in Bezug auf die Zuweisungskompatibilität von Typen verwendet? <question>"
"Es stellt sich nun die Frage, wann ein Typ mit einem anderen zuweisungskompatibel ist. Offensichtlich ist dies der Fall, wenn die Typen identisch sind. Wie bereits oben erwähnt, ist dies jedoch keine notwendige Voraussetzung für die Zuweisungskompatibilität. Es ist nämlich auch möglich, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind. Man spricht in diesen Fällen von einer Typäquivalenz.
Von der Typäquivalenz gibt es zwei Arten: die nominale (sich auf den Namen beziehende) Typäquivalenz, auch Namensäquivalenz genannt, und die strukturelle Typäquivalenz, auch als Strukturäquivalenz bezeichnet. Während die nominale Typäquivalenz verlangt, dass zwei Deklarationen (beispielsweise von Variablen) dieselben Typen angeben, damit Zuweisungskompatibilität vorliegt, kommt es bei der strukturellen Typäquivalenz lediglich darauf an, dass die Typen paarweise gleich definiert sind (also die gleichen Eigenschaften von ihren Werten verlangen). Die Typen müssen sich also in ihrer Struktur, aber nicht unbedingt in ihren Namen gleichen.
Typäquivalenz ist eine symmetrische Eigenschaft: Wenn ein Typ A (nominal oder strukturell) äquivalent zu einem Typ B ist, dann ist B genauso äquivalent zu A. Die Reflexivität der Typäquivalenz, also dass jeder Typ äquivalent zu sich selbst ist, ergibt sich von selbst. Außerdem ist Typäquivalenz transitiv: Wenn A (nominal oder strukturell) äquivalent zu B ist und B in der gleichen Art äquivalent zu C ist, dann ist auch A äquivalent zu C (und, aufgrund der Symmetrie, C äquivalent zu A).","<answer> Es gibt zwei Arten von Typäquivalenz: die nominale (Namensäquivalenz) und die strukturelle (Strukturäquivalenz) Typäquivalenz. Die nominale Typäquivalenz erfordert, dass zwei Deklarationen denselben Typnamen angeben, um Zuweisungskompatibilität zu haben. Die strukturelle Typäquivalenz hingegen erfordert nur, dass die Typen paarweise gleich definiert sind, unabhängig von ihren Namen. <answer> <question> Welche Arten von Typäquivalenz gibt es, und wie unterscheiden sie sich? <question>"
"Es stellt sich nun die Frage, wann ein Typ mit einem anderen zuweisungskompatibel ist. Offensichtlich ist dies der Fall, wenn die Typen identisch sind. Wie bereits oben erwähnt, ist dies jedoch keine notwendige Voraussetzung für die Zuweisungskompatibilität. Es ist nämlich auch möglich, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind. Man spricht in diesen Fällen von einer Typäquivalenz.
Von der Typäquivalenz gibt es zwei Arten: die nominale (sich auf den Namen beziehende) Typäquivalenz, auch Namensäquivalenz genannt, und die strukturelle Typäquivalenz, auch als Strukturäquivalenz bezeichnet. Während die nominale Typäquivalenz verlangt, dass zwei Deklarationen (beispielsweise von Variablen) dieselben Typen angeben, damit Zuweisungskompatibilität vorliegt, kommt es bei der strukturellen Typäquivalenz lediglich darauf an, dass die Typen paarweise gleich definiert sind (also die gleichen Eigenschaften von ihren Werten verlangen). Die Typen müssen sich also in ihrer Struktur, aber nicht unbedingt in ihren Namen gleichen.
Typäquivalenz ist eine symmetrische Eigenschaft: Wenn ein Typ A (nominal oder strukturell) äquivalent zu einem Typ B ist, dann ist B genauso äquivalent zu A. Die Reflexivität der Typäquivalenz, also dass jeder Typ äquivalent zu sich selbst ist, ergibt sich von selbst. Außerdem ist Typäquivalenz transitiv: Wenn A (nominal oder strukturell) äquivalent zu B ist und B in der gleichen Art äquivalent zu C ist, dann ist auch A äquivalent zu C (und, aufgrund der Symmetrie, C äquivalent zu A).","<answer> Typäquivalenz ist eine symmetrische Eigenschaft, was bedeutet, dass wenn Typ A äquivalent zu Typ B ist, dann ist auch Typ B äquivalent zu Typ A. <answer> <question> Wie verhält sich die Typäquivalenz in Bezug auf Symmetrie? <question>"
"Es stellt sich nun die Frage, wann ein Typ mit einem anderen zuweisungskompatibel ist. Offensichtlich ist dies der Fall, wenn die Typen identisch sind. Wie bereits oben erwähnt, ist dies jedoch keine notwendige Voraussetzung für die Zuweisungskompatibilität. Es ist nämlich auch möglich, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind. Man spricht in diesen Fällen von einer Typäquivalenz.
Von der Typäquivalenz gibt es zwei Arten: die nominale (sich auf den Namen beziehende) Typäquivalenz, auch Namensäquivalenz genannt, und die strukturelle Typäquivalenz, auch als Strukturäquivalenz bezeichnet. Während die nominale Typäquivalenz verlangt, dass zwei Deklarationen (beispielsweise von Variablen) dieselben Typen angeben, damit Zuweisungskompatibilität vorliegt, kommt es bei der strukturellen Typäquivalenz lediglich darauf an, dass die Typen paarweise gleich definiert sind (also die gleichen Eigenschaften von ihren Werten verlangen). Die Typen müssen sich also in ihrer Struktur, aber nicht unbedingt in ihren Namen gleichen.
Typäquivalenz ist eine symmetrische Eigenschaft: Wenn ein Typ A (nominal oder strukturell) äquivalent zu einem Typ B ist, dann ist B genauso äquivalent zu A. Die Reflexivität der Typäquivalenz, also dass jeder Typ äquivalent zu sich selbst ist, ergibt sich von selbst. Außerdem ist Typäquivalenz transitiv: Wenn A (nominal oder strukturell) äquivalent zu B ist und B in der gleichen Art äquivalent zu C ist, dann ist auch A äquivalent zu C (und, aufgrund der Symmetrie, C äquivalent zu A).","<answer> Die Typäquivalenz ist reflexiv, was bedeutet, dass jeder Typ zu sich selbst äquivalent ist. Sie ist auch transitiv, was bedeutet, dass wenn A äquivalent zu B ist und B äquivalent zu C ist, dann ist auch A äquivalent zu C. <answer> <question> Welche weiteren Eigenschaften gelten für die Typäquivalenz? <question>"
"Grundsätzlich sollte eine Klassenbibliothek mit den Mitteln der Sprache programmiert werden, aber von der Sprachdefinition unabhängig und somit austauschbar sein. Dies gilt natürlich genauso für die Prozeduren in imperativen Sprachen: Auch diese sollten nicht Teil der Sprache sein, sondern lediglich darin geschrieben werden. Nun hat man sich aber schon bei den edelsten imperativen Sprachen nicht daran gehalten (in PASCAL beispielsweise sind read und write Bestandteil der Sprache, und der Compiler weiß, dass ihnen — als einzige Prozeduren — beliebig viele Parameter übergeben werden dürfen, wobei jeder einzelne Parameter in seinem Typ nicht festgelegt ist); bei den objektorientierten Sprachen tut man es erst recht nicht. So sind in JAVA einige Klassen von der Sprache fest vorgegeben und können nicht beliebig ersetzt werden.","<answer> Klassenbibliotheken sollten unabhängig von der Sprachdefinition sein und austauschbar sein, um die Flexibilität und Portabilität von Software zu gewährleisten. Wenn Klassenbibliotheken eng an die Sprachdefinition gebunden sind, könnte dies dazu führen, dass eine Software nur auf einer bestimmten Plattform oder mit einer bestimmten Sprachversion funktioniert. Durch die Unabhängigkeit von der Sprachdefinition können Klassenbibliotheken in verschiedenen Umgebungen verwendet werden und die Softwareentwicklung erleichtern. <answer> <question> Warum sollten Klassenbibliotheken unabhängig von der Sprachdefinition sein und austauschbar sein? <question>"
"Grundsätzlich sollte eine Klassenbibliothek mit den Mitteln der Sprache programmiert werden, aber von der Sprachdefinition unabhängig und somit austauschbar sein. Dies gilt natürlich genauso für die Prozeduren in imperativen Sprachen: Auch diese sollten nicht Teil der Sprache sein, sondern lediglich darin geschrieben werden. Nun hat man sich aber schon bei den edelsten imperativen Sprachen nicht daran gehalten (in PASCAL beispielsweise sind read und write Bestandteil der Sprache, und der Compiler weiß, dass ihnen — als einzige Prozeduren — beliebig viele Parameter übergeben werden dürfen, wobei jeder einzelne Parameter in seinem Typ nicht festgelegt ist); bei den objektorientierten Sprachen tut man es erst recht nicht. So sind in JAVA einige Klassen von der Sprache fest vorgegeben und können nicht beliebig ersetzt werden.","<answer> In JAVA sind einige Klassen von der Sprache fest vorgegeben, um die grundlegende Funktionalität der Sprache sicherzustellen und um sicherzustellen, dass bestimmte wichtige Aufgaben immer erfüllt werden können. Zum Beispiel sind Klassen wie Object und String integraler Bestandteil der JAVA-Sprache und können nicht ersetzt werden, da sie grundlegende Funktionen wie die Objekterstellung und Zeichenkettenmanipulation ermöglichen. Diese Klassen stellen die Grundlage für die Entwicklung von JAVA-Programmen dar und sind daher unverzichtbar. <answer> <question> Warum sind einige Klassen in JAVA von der Sprache fest vorgegeben und können nicht beliebig ersetzt werden? <question>"
"Die Bedeutung der Subklassenbeziehung variiert von Sprache zu Sprache. Wie Sie sich vielleicht schon gedacht haben, kann man die Subklassenbeziehung mit der Spezialisierungsbeziehung gleichsetzen oder auch mit der Vererbung; es sind aber auch noch andere Definitionen möglich. Tatsächlich wird die hier eingeführte Beziehung zwischen Klassen, die als Subklassenbeziehung bezeichnet wird, nicht immer so genannt. Entsprechend heißen dann die Rollen auch nicht Sub- und Superklasse, sondern z. B. abgeleitete Klassen und Basisklassen. Im Englischen sind hierfür neben Derived class und Base class auch die Begriffe Child class bzw. Parent class in Gebrauch.
In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Eine Subklasse erbt demnach alle Instanzvariablen und Methoden ihrer Superklasse. Dass sie darüber hinaus auch noch ihre Klassenvariablen und -methoden erbt, ist nicht selbstverständlich; dies wird in Abschnitt 11.4 noch genauer beleuchtet. Wichtig ist hier, festzuhalten, dass durch eine existierende Subklassenbeziehung zwischen zwei Klassen nicht ausgedrückt wird, dass die Subklasse eine Spezialisierung der Superklasse ist oder gar die Superklasse eine Generalisierung der Subklasse. Dies sicherzustellen obliegt der Verantwortung des Programmierers.
Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet. Eine dazugehörige Methode haben Sie bereits in Abschnitt 8.4 gesehen.
Damit eine Subklassenbeziehung zwischen zwei Klassen zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden. Entsprechende Regeln in anderen Programmiersprachen können teilweise erheblich komplexer sein.
Da die Subklassenbeziehung auch in SMALLTALK nicht reflexiv ist, muss es mindestens eine Klasse geben, die keine Subklasse ist (und entsprechend keine Superklasse hat). Dies ist die Klasse ""Object"", die oberste aller Superklassen. In ihr sind die Definitionen angelegt, die den Instanzen aller Klassen zugutekommen sollen (z. B. die Methode ""printString""). Diese Methoden werden per Vererbung auf alle anderen Klassen übertragen, wodurch sie deren Instanzen zur Verfügung stehen. Eine ganze Reihe nützlicher Methoden, die in ""Object"" definiert sind, werden wir in Kapitel 14 kennenlernen.","<answer> In der objektorientierten Programmierung werden neben der Subklassenbeziehung und den Begriffen Subklasse und Superklasse auch Begriffe wie ""abgeleitete Klassen"" und ""Basisklassen"" verwendet. Im Englischen sind auch die Begriffe ""Derived class"" und ""Base class"" gebräuchlich. Es kann je nach Programmiersprache und Konvention unterschiedliche Bezeichnungen geben. <answer> <question> Welche Bezeichnungen werden alternativ zur Subklassenbeziehung und den Begriffen Subklasse und Superklasse in der objektorientierten Programmierung verwendet? <question>"
"Die Bedeutung der Subklassenbeziehung variiert von Sprache zu Sprache. Wie Sie sich vielleicht schon gedacht haben, kann man die Subklassenbeziehung mit der Spezialisierungsbeziehung gleichsetzen oder auch mit der Vererbung; es sind aber auch noch andere Definitionen möglich. Tatsächlich wird die hier eingeführte Beziehung zwischen Klassen, die als Subklassenbeziehung bezeichnet wird, nicht immer so genannt. Entsprechend heißen dann die Rollen auch nicht Sub- und Superklasse, sondern z. B. abgeleitete Klassen und Basisklassen. Im Englischen sind hierfür neben Derived class und Base class auch die Begriffe Child class bzw. Parent class in Gebrauch.
In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Eine Subklasse erbt demnach alle Instanzvariablen und Methoden ihrer Superklasse. Dass sie darüber hinaus auch noch ihre Klassenvariablen und -methoden erbt, ist nicht selbstverständlich; dies wird in Abschnitt 11.4 noch genauer beleuchtet. Wichtig ist hier, festzuhalten, dass durch eine existierende Subklassenbeziehung zwischen zwei Klassen nicht ausgedrückt wird, dass die Subklasse eine Spezialisierung der Superklasse ist oder gar die Superklasse eine Generalisierung der Subklasse. Dies sicherzustellen obliegt der Verantwortung des Programmierers.
Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet. Eine dazugehörige Methode haben Sie bereits in Abschnitt 8.4 gesehen.
Damit eine Subklassenbeziehung zwischen zwei Klassen zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden. Entsprechende Regeln in anderen Programmiersprachen können teilweise erheblich komplexer sein.
Da die Subklassenbeziehung auch in SMALLTALK nicht reflexiv ist, muss es mindestens eine Klasse geben, die keine Subklasse ist (und entsprechend keine Superklasse hat). Dies ist die Klasse ""Object"", die oberste aller Superklassen. In ihr sind die Definitionen angelegt, die den Instanzen aller Klassen zugutekommen sollen (z. B. die Methode ""printString""). Diese Methoden werden per Vererbung auf alle anderen Klassen übertragen, wodurch sie deren Instanzen zur Verfügung stehen. Eine ganze Reihe nützlicher Methoden, die in ""Object"" definiert sind, werden wir in Kapitel 14 kennenlernen.","<answer> In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Das bedeutet, dass eine Subklasse alle Instanzvariablen und Methoden ihrer Superklasse erbt. Es ist jedoch wichtig zu beachten, dass die Subklassenbeziehung allein nicht ausdrückt, dass die Subklasse eine Spezialisierung der Superklasse ist oder umgekehrt. Diese Beziehung muss vom Programmierer explizit definiert und dokumentiert werden. <answer> <question> Was bedeutet die Subklassenbeziehung in SMALLTALK? <question>"
"Die Bedeutung der Subklassenbeziehung variiert von Sprache zu Sprache. Wie Sie sich vielleicht schon gedacht haben, kann man die Subklassenbeziehung mit der Spezialisierungsbeziehung gleichsetzen oder auch mit der Vererbung; es sind aber auch noch andere Definitionen möglich. Tatsächlich wird die hier eingeführte Beziehung zwischen Klassen, die als Subklassenbeziehung bezeichnet wird, nicht immer so genannt. Entsprechend heißen dann die Rollen auch nicht Sub- und Superklasse, sondern z. B. abgeleitete Klassen und Basisklassen. Im Englischen sind hierfür neben Derived class und Base class auch die Begriffe Child class bzw. Parent class in Gebrauch.
In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Eine Subklasse erbt demnach alle Instanzvariablen und Methoden ihrer Superklasse. Dass sie darüber hinaus auch noch ihre Klassenvariablen und -methoden erbt, ist nicht selbstverständlich; dies wird in Abschnitt 11.4 noch genauer beleuchtet. Wichtig ist hier, festzuhalten, dass durch eine existierende Subklassenbeziehung zwischen zwei Klassen nicht ausgedrückt wird, dass die Subklasse eine Spezialisierung der Superklasse ist oder gar die Superklasse eine Generalisierung der Subklasse. Dies sicherzustellen obliegt der Verantwortung des Programmierers.
Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet. Eine dazugehörige Methode haben Sie bereits in Abschnitt 8.4 gesehen.
Damit eine Subklassenbeziehung zwischen zwei Klassen zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden. Entsprechende Regeln in anderen Programmiersprachen können teilweise erheblich komplexer sein.
Da die Subklassenbeziehung auch in SMALLTALK nicht reflexiv ist, muss es mindestens eine Klasse geben, die keine Subklasse ist (und entsprechend keine Superklasse hat). Dies ist die Klasse ""Object"", die oberste aller Superklassen. In ihr sind die Definitionen angelegt, die den Instanzen aller Klassen zugutekommen sollen (z. B. die Methode ""printString""). Diese Methoden werden per Vererbung auf alle anderen Klassen übertragen, wodurch sie deren Instanzen zur Verfügung stehen. Eine ganze Reihe nützlicher Methoden, die in ""Object"" definiert sind, werden wir in Kapitel 14 kennenlernen.","<answer> In SMALLTALK wird eine neue Klasse erstellt, indem man einer Superklasse eine entsprechende Nachricht sendet. Es gibt kein spezielles Schlüsselwort wie ""extends"" in anderen Programmiersprachen. Stattdessen erfolgt die Klassenerstellung in einem speziellen Browser durch Senden einer Nachricht an die Superklasse. <answer> <question> Wie wird in SMALLTALK eine neue Klasse erstellt und eine Superklasse angegeben? <question>"
"Die Bedeutung der Subklassenbeziehung variiert von Sprache zu Sprache. Wie Sie sich vielleicht schon gedacht haben, kann man die Subklassenbeziehung mit der Spezialisierungsbeziehung gleichsetzen oder auch mit der Vererbung; es sind aber auch noch andere Definitionen möglich. Tatsächlich wird die hier eingeführte Beziehung zwischen Klassen, die als Subklassenbeziehung bezeichnet wird, nicht immer so genannt. Entsprechend heißen dann die Rollen auch nicht Sub- und Superklasse, sondern z. B. abgeleitete Klassen und Basisklassen. Im Englischen sind hierfür neben Derived class und Base class auch die Begriffe Child class bzw. Parent class in Gebrauch.
In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Eine Subklasse erbt demnach alle Instanzvariablen und Methoden ihrer Superklasse. Dass sie darüber hinaus auch noch ihre Klassenvariablen und -methoden erbt, ist nicht selbstverständlich; dies wird in Abschnitt 11.4 noch genauer beleuchtet. Wichtig ist hier, festzuhalten, dass durch eine existierende Subklassenbeziehung zwischen zwei Klassen nicht ausgedrückt wird, dass die Subklasse eine Spezialisierung der Superklasse ist oder gar die Superklasse eine Generalisierung der Subklasse. Dies sicherzustellen obliegt der Verantwortung des Programmierers.
Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet. Eine dazugehörige Methode haben Sie bereits in Abschnitt 8.4 gesehen.
Damit eine Subklassenbeziehung zwischen zwei Klassen zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden. Entsprechende Regeln in anderen Programmiersprachen können teilweise erheblich komplexer sein.
Da die Subklassenbeziehung auch in SMALLTALK nicht reflexiv ist, muss es mindestens eine Klasse geben, die keine Subklasse ist (und entsprechend keine Superklasse hat). Dies ist die Klasse ""Object"", die oberste aller Superklassen. In ihr sind die Definitionen angelegt, die den Instanzen aller Klassen zugutekommen sollen (z. B. die Methode ""printString""). Diese Methoden werden per Vererbung auf alle anderen Klassen übertragen, wodurch sie deren Instanzen zur Verfügung stehen. Eine ganze Reihe nützlicher Methoden, die in ""Object"" definiert sind, werden wir in Kapitel 14 kennenlernen.","<answer> Damit eine Subklassenbeziehung zwischen zwei Klassen in SMALLTALK zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen: Benannte Instanz- und Klassenvariablen dürfen nicht dieselben Namen haben wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Wenn die Superklasse indizierte Instanzvariablen hat, müssen diese auch in der Subklasse vorhanden sein. Methodendefinitionen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden. <answer> <question> Welche Bedingungen müssen erfüllt sein, damit eine Subklassenbeziehung zwischen zwei Klassen in SMALLTALK zulässig ist? <question>"
"Die Bedeutung der Subklassenbeziehung variiert von Sprache zu Sprache. Wie Sie sich vielleicht schon gedacht haben, kann man die Subklassenbeziehung mit der Spezialisierungsbeziehung gleichsetzen oder auch mit der Vererbung; es sind aber auch noch andere Definitionen möglich. Tatsächlich wird die hier eingeführte Beziehung zwischen Klassen, die als Subklassenbeziehung bezeichnet wird, nicht immer so genannt. Entsprechend heißen dann die Rollen auch nicht Sub- und Superklasse, sondern z. B. abgeleitete Klassen und Basisklassen. Im Englischen sind hierfür neben Derived class und Base class auch die Begriffe Child class bzw. Parent class in Gebrauch.
In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Eine Subklasse erbt demnach alle Instanzvariablen und Methoden ihrer Superklasse. Dass sie darüber hinaus auch noch ihre Klassenvariablen und -methoden erbt, ist nicht selbstverständlich; dies wird in Abschnitt 11.4 noch genauer beleuchtet. Wichtig ist hier, festzuhalten, dass durch eine existierende Subklassenbeziehung zwischen zwei Klassen nicht ausgedrückt wird, dass die Subklasse eine Spezialisierung der Superklasse ist oder gar die Superklasse eine Generalisierung der Subklasse. Dies sicherzustellen obliegt der Verantwortung des Programmierers.
Jede neue Klasse, die in einem SMALLTALK-System angelegt wird, muss direkt von einer Superklasse erben — es ist deshalb notwendig, dass beim Erzeugen einer neuen Klasse die Superklasse angegeben wird. Da, wie bereits mehrfach erwähnt, die SMALLTALK-Programmierung nicht dateibasiert ist, sondern mittels eines dafür vorgesehenen Browsers erfolgt, gibt es zum Zweck der Angabe der Superklasse auch kein spezielles Schlüsselwort wie beispielsweise ""extends"", das die Subklassenbeziehung ausdrückt. Man legt vielmehr eine neue Klasse an, indem man ihrer Superklasse eine entsprechende Nachricht sendet. Eine dazugehörige Methode haben Sie bereits in Abschnitt 8.4 gesehen.
Damit eine Subklassenbeziehung zwischen zwei Klassen zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden. Entsprechende Regeln in anderen Programmiersprachen können teilweise erheblich komplexer sein.
Da die Subklassenbeziehung auch in SMALLTALK nicht reflexiv ist, muss es mindestens eine Klasse geben, die keine Subklasse ist (und entsprechend keine Superklasse hat). Dies ist die Klasse ""Object"", die oberste aller Superklassen. In ihr sind die Definitionen angelegt, die den Instanzen aller Klassen zugutekommen sollen (z. B. die Methode ""printString""). Diese Methoden werden per Vererbung auf alle anderen Klassen übertragen, wodurch sie deren Instanzen zur Verfügung stehen. Eine ganze Reihe nützlicher Methoden, die in ""Object"" definiert sind, werden wir in Kapitel 14 kennenlernen.","<answer> In SMALLTALK ist die Subklassenbeziehung nicht reflexiv, was bedeutet, dass jede Klasse mindestens eine Superklasse haben muss. Diese oberste Superklasse ist die Klasse ""Object"". In ""Object"" sind Definitionen enthalten, die den Instanzen aller Klassen zugutekommen sollen, und diese Methoden werden per Vererbung auf alle anderen Klassen übertragen. <answer> <question> Warum gibt es in SMALLTALK mindestens eine Klasse, die keine Subklasse ist? <question>"
"Eine gängige Namenskonvention ist beispielsweise, Namen von Interfacetypen mit einem großen ""I"" beginnen zu lassen. Andere Namenskonventionen verlangen, dass Bezeichner, die für ein Objekt oder einen Wert stehen (also Variablen und Funktionsnamen), den Typ dieses Objekts oder Werts widerspiegeln — die sog. ungarische Notation, von der es allerdings verschiedene Auslegungen gibt. Nach einer eher unklugen Auslegung müssen beispielsweise alle Variablen, die Strings bezeichnen, mit ""str"" beginnen (eine Information, die Compiler und IDE ohnehin bereithalten und die deswegen nicht noch den Namen belasten muss). Nach einer sinnvolleren Auslegung sollten Variablen um die Verwendung ihres so bezeichneten Inhalts ergänzt werden. Das bedeutet, die Funktion des durch sie bezeichneten Objekts oder Werts innerhalb des Kontextes, in dem die Variable gültig ist, anzugeben. Diese kontextbezogene Funktion kann in der objektorientierten Programmierung jedoch auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt und somit auch vom Compiler überprüft werden.","<answer> Eine gängige Namenskonvention ist, Namen von Interfacetypen mit einem großen ""I"" beginnen zu lassen. Zum Beispiel könnte ein Interface ""Auto"" als ""IAuto"" benannt werden. <answer> <question> Was ist eine gängige Namenskonvention in Bezug auf Interfacetypen? <question>"
"Eine gängige Namenskonvention ist beispielsweise, Namen von Interfacetypen mit einem großen ""I"" beginnen zu lassen. Andere Namenskonventionen verlangen, dass Bezeichner, die für ein Objekt oder einen Wert stehen (also Variablen und Funktionsnamen), den Typ dieses Objekts oder Werts widerspiegeln — die sog. ungarische Notation, von der es allerdings verschiedene Auslegungen gibt. Nach einer eher unklugen Auslegung müssen beispielsweise alle Variablen, die Strings bezeichnen, mit ""str"" beginnen (eine Information, die Compiler und IDE ohnehin bereithalten und die deswegen nicht noch den Namen belasten muss). Nach einer sinnvolleren Auslegung sollten Variablen um die Verwendung ihres so bezeichneten Inhalts ergänzt werden. Das bedeutet, die Funktion des durch sie bezeichneten Objekts oder Werts innerhalb des Kontextes, in dem die Variable gültig ist, anzugeben. Diese kontextbezogene Funktion kann in der objektorientierten Programmierung jedoch auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt und somit auch vom Compiler überprüft werden.","<answer> Die ungarische Notation ist eine Namenskonvention, bei der Bezeichner, die für ein Objekt oder einen Wert stehen (wie Variablen und Funktionsnamen), den Typ dieses Objekts oder Werts widerspiegeln. Es gibt verschiedene Auslegungen der ungarischen Notation. <answer> <question> Was ist die ungarische Notation in Bezug auf Namenskonventionen? <question>"
"Eine gängige Namenskonvention ist beispielsweise, Namen von Interfacetypen mit einem großen ""I"" beginnen zu lassen. Andere Namenskonventionen verlangen, dass Bezeichner, die für ein Objekt oder einen Wert stehen (also Variablen und Funktionsnamen), den Typ dieses Objekts oder Werts widerspiegeln — die sog. ungarische Notation, von der es allerdings verschiedene Auslegungen gibt. Nach einer eher unklugen Auslegung müssen beispielsweise alle Variablen, die Strings bezeichnen, mit ""str"" beginnen (eine Information, die Compiler und IDE ohnehin bereithalten und die deswegen nicht noch den Namen belasten muss). Nach einer sinnvolleren Auslegung sollten Variablen um die Verwendung ihres so bezeichneten Inhalts ergänzt werden. Das bedeutet, die Funktion des durch sie bezeichneten Objekts oder Werts innerhalb des Kontextes, in dem die Variable gültig ist, anzugeben. Diese kontextbezogene Funktion kann in der objektorientierten Programmierung jedoch auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt und somit auch vom Compiler überprüft werden.","<answer> Eine mögliche Auslegung der ungarischen Notation verlangt, dass Variablen, die Strings bezeichnen, mit ""str"" beginnen. Diese Auslegung kann jedoch als weniger sinnvoll angesehen werden, da Compiler und IDE bereits Informationen über den Typ der Variablen bereitstellen und diese Information den Namen der Variablen nicht zusätzlich belasten sollte. <answer> <question> Was ist eine mögliche Auslegung der ungarischen Notation? <question>"
"Eine gängige Namenskonvention ist beispielsweise, Namen von Interfacetypen mit einem großen ""I"" beginnen zu lassen. Andere Namenskonventionen verlangen, dass Bezeichner, die für ein Objekt oder einen Wert stehen (also Variablen und Funktionsnamen), den Typ dieses Objekts oder Werts widerspiegeln — die sog. ungarische Notation, von der es allerdings verschiedene Auslegungen gibt. Nach einer eher unklugen Auslegung müssen beispielsweise alle Variablen, die Strings bezeichnen, mit ""str"" beginnen (eine Information, die Compiler und IDE ohnehin bereithalten und die deswegen nicht noch den Namen belasten muss). Nach einer sinnvolleren Auslegung sollten Variablen um die Verwendung ihres so bezeichneten Inhalts ergänzt werden. Das bedeutet, die Funktion des durch sie bezeichneten Objekts oder Werts innerhalb des Kontextes, in dem die Variable gültig ist, anzugeben. Diese kontextbezogene Funktion kann in der objektorientierten Programmierung jedoch auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt und somit auch vom Compiler überprüft werden.","<answer> Eine sinnvollere Auslegung der ungarischen Notation schlägt vor, Variablen um die Verwendung ihres Inhalts zu ergänzen. Das bedeutet, die Funktion des durch die Variable bezeichneten Objekts oder Werts innerhalb des Kontextes anzugeben, in dem die Variable gültig ist. Dies ermöglicht es, die Funktion kontextbezogen auszudrücken, ohne den Namen der Variable mit redundanten Informationen zu belasten. In der objektorientierten Programmierung kann diese kontextbezogene Funktion oft auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt werden, was vom Compiler überprüft werden kann. <answer> <question> Welche sinnvollere Auslegung der ungarischen Notation wird vorgeschlagen? <question>"
"In Kapitel 26 sind wir bereits ausführlich auf den Begriff des Subtypings eingegangen. Subtyping sollte die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen, dh. erlauben, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Dies führt nun zu dem Problem, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat.82 Gemäß den Regeln gängiger objektorientierter Programmiersprachen zur Zuweisungskompatibilität wissen wir lediglich, dass es sich beim Typ des Empfängerobjekts e um einen Subtyp von T handeln muss83, jedoch wissen wir nicht genau, um welchen Subtyp es sich handelt. In einer statischen, lokalen Betrachtung84, also bei mangelnder Kenntnis des Typs des von e bezeichneten Objekts sowie aller infrage kommenden Subtypen von T, befinden wir uns in einem Zustand völliger Unsicherheit. Da die Erweiterung um Subklassen bzw. Subtypen jedoch eine der Errungenschaften der objektorientierten Programmierung ist, handelt es sich hierbei um ein echtes Problem.
Das Problem lässt sich als ein Problem der formalen Programmverifikation ausdrücken: Wie kann bewiesen werden, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts gebunden werden können? Es handelt sich um die Beziehung P {e m} Q (54.1), bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse darüber, was der Methodenaufruf tatsächlich bewirkt oder vielmehr, welchen Effekt er hat. Dafür ist die Kenntnis der Implementierung der Methode erforderlich. Andererseits ist es wichtig für die Pflege und Weiterentwicklung eines Programms zu wissen, unter welchen Bedingungen die Methoden einer neu eingeführten Klasse in das bestehende Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert. Die Bedingungen müssen bekannt sein, um sicherzustellen, dass die neue Implementierung sich in den Kanon der bereits bestehenden einordnet und kein unerwartetes Verhalten hervorruft. Nur wenn diese Zusicherungen in Form von (54.1) für alle Aufrufe erfüllt sind, ist das Funktionieren des Programms nicht gefährdet. Andernfalls könnte es beeinträchtigt sein. Daher müssen die Bedingungen bekannt sein.
Die Frage, wie der Effekt aller Implementierungen von m für Subtypen von T (einschließlich T selbst) erfasst werden kann, steht im Raum. Eine naive Antwort auf diese Frage würde vorschlagen, dass man sich alle diese Implementierungen ansieht und auf dieser Grundlage eine Fallunterscheidung präsentiert: Wenn das Objekt e vom Typ T ist, dann hat m den und den Effekt, wenn es von Subtyp T1 ist, dann hat m den und den Effekt, usw. Die Zusammenfassung dieser Fallunterscheidungen würde dann alle Effekte logisch mit einem Oder verknüpfen. Diese Möglichkeit hat jedoch den Nachteil der Unhandlichkeit und berücksichtigt nicht vorhandene Implementierungen nicht. Was man stattdessen möchte, ist die Gewissheit, dass eine lokale, ""modulare"" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte. Genau das soll der Begriff der Substituierbarkeit ermöglichen.","<answer> Das Problem besteht darin, dass aufgrund des dynamischen Bindens von Methodenaufrufen nicht vorhergesagt werden kann, welchen Effekt ein Aufruf der Methode in einem bestimmten Programmfragment haben wird, selbst wenn der Typ des Empfängerobjekts bekannt ist. Es ist schwer zu bestimmen, welcher Subtyp des Typs des Empfängerobjekts tatsächlich betroffen ist. <answer> <question> Was ist das Problem, das im Zusammenhang mit Subtyping und dynamischem Methodenaufruf auftritt? <question>"
"In Kapitel 26 sind wir bereits ausführlich auf den Begriff des Subtypings eingegangen. Subtyping sollte die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen, dh. erlauben, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Dies führt nun zu dem Problem, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat.82 Gemäß den Regeln gängiger objektorientierter Programmiersprachen zur Zuweisungskompatibilität wissen wir lediglich, dass es sich beim Typ des Empfängerobjekts e um einen Subtyp von T handeln muss83, jedoch wissen wir nicht genau, um welchen Subtyp es sich handelt. In einer statischen, lokalen Betrachtung84, also bei mangelnder Kenntnis des Typs des von e bezeichneten Objekts sowie aller infrage kommenden Subtypen von T, befinden wir uns in einem Zustand völliger Unsicherheit. Da die Erweiterung um Subklassen bzw. Subtypen jedoch eine der Errungenschaften der objektorientierten Programmierung ist, handelt es sich hierbei um ein echtes Problem.
Das Problem lässt sich als ein Problem der formalen Programmverifikation ausdrücken: Wie kann bewiesen werden, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts gebunden werden können? Es handelt sich um die Beziehung P {e m} Q (54.1), bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse darüber, was der Methodenaufruf tatsächlich bewirkt oder vielmehr, welchen Effekt er hat. Dafür ist die Kenntnis der Implementierung der Methode erforderlich. Andererseits ist es wichtig für die Pflege und Weiterentwicklung eines Programms zu wissen, unter welchen Bedingungen die Methoden einer neu eingeführten Klasse in das bestehende Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert. Die Bedingungen müssen bekannt sein, um sicherzustellen, dass die neue Implementierung sich in den Kanon der bereits bestehenden einordnet und kein unerwartetes Verhalten hervorruft. Nur wenn diese Zusicherungen in Form von (54.1) für alle Aufrufe erfüllt sind, ist das Funktionieren des Programms nicht gefährdet. Andernfalls könnte es beeinträchtigt sein. Daher müssen die Bedingungen bekannt sein.
Die Frage, wie der Effekt aller Implementierungen von m für Subtypen von T (einschließlich T selbst) erfasst werden kann, steht im Raum. Eine naive Antwort auf diese Frage würde vorschlagen, dass man sich alle diese Implementierungen ansieht und auf dieser Grundlage eine Fallunterscheidung präsentiert: Wenn das Objekt e vom Typ T ist, dann hat m den und den Effekt, wenn es von Subtyp T1 ist, dann hat m den und den Effekt, usw. Die Zusammenfassung dieser Fallunterscheidungen würde dann alle Effekte logisch mit einem Oder verknüpfen. Diese Möglichkeit hat jedoch den Nachteil der Unhandlichkeit und berücksichtigt nicht vorhandene Implementierungen nicht. Was man stattdessen möchte, ist die Gewissheit, dass eine lokale, ""modulare"" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte. Genau das soll der Begriff der Substituierbarkeit ermöglichen.","<answer> Das Problem kann als ein Problem der formalen Programmverifikation ausgedrückt werden. Es geht darum, wie bewiesen werden kann, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts korrekt gebunden werden können. Dies erfordert genaue Kenntnisse darüber, welchen Effekt der Methodenaufruf hat, was die Kenntnis der Implementierung der Methode erfordert. <answer> <question> Wie kann das Problem des dynamischen Bindens und der Unsicherheit bei Methodenaufrufen in Bezug auf Subtyping ausgedrückt werden? <question>"
"In Kapitel 26 sind wir bereits ausführlich auf den Begriff des Subtypings eingegangen. Subtyping sollte die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen, dh. erlauben, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Dies führt nun zu dem Problem, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat.82 Gemäß den Regeln gängiger objektorientierter Programmiersprachen zur Zuweisungskompatibilität wissen wir lediglich, dass es sich beim Typ des Empfängerobjekts e um einen Subtyp von T handeln muss83, jedoch wissen wir nicht genau, um welchen Subtyp es sich handelt. In einer statischen, lokalen Betrachtung84, also bei mangelnder Kenntnis des Typs des von e bezeichneten Objekts sowie aller infrage kommenden Subtypen von T, befinden wir uns in einem Zustand völliger Unsicherheit. Da die Erweiterung um Subklassen bzw. Subtypen jedoch eine der Errungenschaften der objektorientierten Programmierung ist, handelt es sich hierbei um ein echtes Problem.
Das Problem lässt sich als ein Problem der formalen Programmverifikation ausdrücken: Wie kann bewiesen werden, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts gebunden werden können? Es handelt sich um die Beziehung P {e m} Q (54.1), bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse darüber, was der Methodenaufruf tatsächlich bewirkt oder vielmehr, welchen Effekt er hat. Dafür ist die Kenntnis der Implementierung der Methode erforderlich. Andererseits ist es wichtig für die Pflege und Weiterentwicklung eines Programms zu wissen, unter welchen Bedingungen die Methoden einer neu eingeführten Klasse in das bestehende Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert. Die Bedingungen müssen bekannt sein, um sicherzustellen, dass die neue Implementierung sich in den Kanon der bereits bestehenden einordnet und kein unerwartetes Verhalten hervorruft. Nur wenn diese Zusicherungen in Form von (54.1) für alle Aufrufe erfüllt sind, ist das Funktionieren des Programms nicht gefährdet. Andernfalls könnte es beeinträchtigt sein. Daher müssen die Bedingungen bekannt sein.
Die Frage, wie der Effekt aller Implementierungen von m für Subtypen von T (einschließlich T selbst) erfasst werden kann, steht im Raum. Eine naive Antwort auf diese Frage würde vorschlagen, dass man sich alle diese Implementierungen ansieht und auf dieser Grundlage eine Fallunterscheidung präsentiert: Wenn das Objekt e vom Typ T ist, dann hat m den und den Effekt, wenn es von Subtyp T1 ist, dann hat m den und den Effekt, usw. Die Zusammenfassung dieser Fallunterscheidungen würde dann alle Effekte logisch mit einem Oder verknüpfen. Diese Möglichkeit hat jedoch den Nachteil der Unhandlichkeit und berücksichtigt nicht vorhandene Implementierungen nicht. Was man stattdessen möchte, ist die Gewissheit, dass eine lokale, ""modulare"" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte. Genau das soll der Begriff der Substituierbarkeit ermöglichen.","<answer> Es ist wichtig zu wissen, wie Methoden einer neu eingeführten Klasse in ein bestehendes Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert und keine unerwarteten Verhaltensänderungen auftreten. Dies ist notwendig, um sicherzustellen, dass die neuen Implementierungen sich nahtlos in das bestehende Programm einfügen und die Programmfunktionalität nicht gefährden. <answer> <question> Warum ist es wichtig zu wissen, wie Methoden einer neu eingeführten Klasse in ein bestehendes Programm integriert werden können? <question>"
"In Kapitel 26 sind wir bereits ausführlich auf den Begriff des Subtypings eingegangen. Subtyping sollte die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen, dh. erlauben, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Dies führt nun zu dem Problem, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat.82 Gemäß den Regeln gängiger objektorientierter Programmiersprachen zur Zuweisungskompatibilität wissen wir lediglich, dass es sich beim Typ des Empfängerobjekts e um einen Subtyp von T handeln muss83, jedoch wissen wir nicht genau, um welchen Subtyp es sich handelt. In einer statischen, lokalen Betrachtung84, also bei mangelnder Kenntnis des Typs des von e bezeichneten Objekts sowie aller infrage kommenden Subtypen von T, befinden wir uns in einem Zustand völliger Unsicherheit. Da die Erweiterung um Subklassen bzw. Subtypen jedoch eine der Errungenschaften der objektorientierten Programmierung ist, handelt es sich hierbei um ein echtes Problem.
Das Problem lässt sich als ein Problem der formalen Programmverifikation ausdrücken: Wie kann bewiesen werden, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts gebunden werden können? Es handelt sich um die Beziehung P {e m} Q (54.1), bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse darüber, was der Methodenaufruf tatsächlich bewirkt oder vielmehr, welchen Effekt er hat. Dafür ist die Kenntnis der Implementierung der Methode erforderlich. Andererseits ist es wichtig für die Pflege und Weiterentwicklung eines Programms zu wissen, unter welchen Bedingungen die Methoden einer neu eingeführten Klasse in das bestehende Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert. Die Bedingungen müssen bekannt sein, um sicherzustellen, dass die neue Implementierung sich in den Kanon der bereits bestehenden einordnet und kein unerwartetes Verhalten hervorruft. Nur wenn diese Zusicherungen in Form von (54.1) für alle Aufrufe erfüllt sind, ist das Funktionieren des Programms nicht gefährdet. Andernfalls könnte es beeinträchtigt sein. Daher müssen die Bedingungen bekannt sein.
Die Frage, wie der Effekt aller Implementierungen von m für Subtypen von T (einschließlich T selbst) erfasst werden kann, steht im Raum. Eine naive Antwort auf diese Frage würde vorschlagen, dass man sich alle diese Implementierungen ansieht und auf dieser Grundlage eine Fallunterscheidung präsentiert: Wenn das Objekt e vom Typ T ist, dann hat m den und den Effekt, wenn es von Subtyp T1 ist, dann hat m den und den Effekt, usw. Die Zusammenfassung dieser Fallunterscheidungen würde dann alle Effekte logisch mit einem Oder verknüpfen. Diese Möglichkeit hat jedoch den Nachteil der Unhandlichkeit und berücksichtigt nicht vorhandene Implementierungen nicht. Was man stattdessen möchte, ist die Gewissheit, dass eine lokale, ""modulare"" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte. Genau das soll der Begriff der Substituierbarkeit ermöglichen.","<answer> Das Konzept der Substituierbarkeit zielt darauf ab, sicherzustellen, dass eine lokale, ""modulare"" Betrachtung ausreicht, um zu verstehen, welchen Effekt ein Methodenaufruf haben wird, ohne eine umfassende Analyse des gesamten Programms durchführen zu müssen. Substituierbarkeit soll sicherstellen, dass die Bedingungen, unter denen die Methodenaufrufe korrekt sind, bekannt sind, und dass die Implementierungen von Methoden für Subtypen eines bestimmten Typs korrekt verwendet werden können. <answer> <question> Wie kann das Problem der Substituierbarkeit dazu beitragen, das Problem des dynamischen Bindens und der Unsicherheit bei Methodenaufrufen zu lösen? <question>"
"In SMALLTALK ist das Interface eines Objekts die Menge der Nachrichten, die es versteht. Dieses Interface wird in Form der sogenannten Protokollbeschreibung oder kurz des Protokolls spezifiziert. Es besteht aus den Methodensignaturen und den Kommentaren der zu den Nachrichten passenden Methoden, und es steht in Kontrast zur Implementierung, also der Liste der Methodenrümpfe, sowie den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Dieses Geheimnis bleibt hinter seiner Protokollbeschreibung, also dem Interface, verborgen. Die Kommentare dürfen übrigens, wie in den meisten anderen Sprachen auch, als eine Art schwacher Ersatz für eine formale Spezifikation des Verhaltens angesehen werden, das in einer Methode implementiert wird (siehe dazu Abschnitt 5.6 in Kurseinheit 5).
Um die Programmierung zu erleichtern, wird das Protokoll von Objekten in den meisten SMALLTALK-Systemen in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien tragen jeweils einen Namen, der die in der Kategorie enthaltenen Methodennamen zusammenfasst. Da jede Methode genau in eine Nachrichtenkategorie fallen muss, stellen diese Kategorien eine Partitionierung des Interfaces eines Objekts dar. Einige dieser Kategorien können das Wort „private“ enthalten, was darauf hinweist, dass deren Methoden vorzugsweise nur vom Objekt selbst (über self) aufgerufen werden sollten. Beachten Sie jedoch, dass dies nicht vom Compiler erzwungen wird. Nachrichtenkategorien haben darüber hinaus keine weitere Bedeutung für die Programmausführung und dienen lediglich der besseren Lesbarkeit.
Wie Sie in der nächsten Kurseinheit erfahren werden, werden Protokolle in SMALLTALK nicht auf Objektebene, sondern auf Klassenebene spezifiziert. In STRONGTALK, einer Erweiterung von SMALLTALK um ein (optionales) Typsystem, werden Protokolle zu Typen erhoben (siehe Kurseinheit 3, Kapitel 20). Da Protokolle nur Methoden enthalten, sind sie den Interfaces in JAVA sehr ähnlich. Tatsächlich werden Protokolle in STRONGTALK manchmal auch Interfaces genannt.","<answer> In SMALLTALK ist das Protokoll eines Objekts die Menge der Nachrichten, die es versteht. Es wird in Form der Protokollbeschreibung spezifiziert und besteht aus den Methodensignaturen und den dazugehörigen Kommentaren der Methoden. Das Protokoll beschreibt das Interface eines Objekts. <answer> <question> Was ist das Protokoll in SMALLTALK? <question>"
"In SMALLTALK ist das Interface eines Objekts die Menge der Nachrichten, die es versteht. Dieses Interface wird in Form der sogenannten Protokollbeschreibung oder kurz des Protokolls spezifiziert. Es besteht aus den Methodensignaturen und den Kommentaren der zu den Nachrichten passenden Methoden, und es steht in Kontrast zur Implementierung, also der Liste der Methodenrümpfe, sowie den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Dieses Geheimnis bleibt hinter seiner Protokollbeschreibung, also dem Interface, verborgen. Die Kommentare dürfen übrigens, wie in den meisten anderen Sprachen auch, als eine Art schwacher Ersatz für eine formale Spezifikation des Verhaltens angesehen werden, das in einer Methode implementiert wird (siehe dazu Abschnitt 5.6 in Kurseinheit 5).
Um die Programmierung zu erleichtern, wird das Protokoll von Objekten in den meisten SMALLTALK-Systemen in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien tragen jeweils einen Namen, der die in der Kategorie enthaltenen Methodennamen zusammenfasst. Da jede Methode genau in eine Nachrichtenkategorie fallen muss, stellen diese Kategorien eine Partitionierung des Interfaces eines Objekts dar. Einige dieser Kategorien können das Wort „private“ enthalten, was darauf hinweist, dass deren Methoden vorzugsweise nur vom Objekt selbst (über self) aufgerufen werden sollten. Beachten Sie jedoch, dass dies nicht vom Compiler erzwungen wird. Nachrichtenkategorien haben darüber hinaus keine weitere Bedeutung für die Programmausführung und dienen lediglich der besseren Lesbarkeit.
Wie Sie in der nächsten Kurseinheit erfahren werden, werden Protokolle in SMALLTALK nicht auf Objektebene, sondern auf Klassenebene spezifiziert. In STRONGTALK, einer Erweiterung von SMALLTALK um ein (optionales) Typsystem, werden Protokolle zu Typen erhoben (siehe Kurseinheit 3, Kapitel 20). Da Protokolle nur Methoden enthalten, sind sie den Interfaces in JAVA sehr ähnlich. Tatsächlich werden Protokolle in STRONGTALK manchmal auch Interfaces genannt.","<answer> Das Protokoll von Objekten in SMALLTALK wird oft in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien haben Namen, die die enthaltenen Methodennamen zusammenfassen. Nachrichtenkategorien dienen der besseren Lesbarkeit und partitionieren das Interface eines Objekts. Einige Kategorien können das Wort ""private"" enthalten, um anzuzeigen, dass die darin enthaltenen Methoden vorzugsweise nur vom Objekt selbst aufgerufen werden sollten. <answer> <question> Wie wird das Protokoll in SMALLTALK organisiert? <question>"
"In SMALLTALK ist das Interface eines Objekts die Menge der Nachrichten, die es versteht. Dieses Interface wird in Form der sogenannten Protokollbeschreibung oder kurz des Protokolls spezifiziert. Es besteht aus den Methodensignaturen und den Kommentaren der zu den Nachrichten passenden Methoden, und es steht in Kontrast zur Implementierung, also der Liste der Methodenrümpfe, sowie den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Dieses Geheimnis bleibt hinter seiner Protokollbeschreibung, also dem Interface, verborgen. Die Kommentare dürfen übrigens, wie in den meisten anderen Sprachen auch, als eine Art schwacher Ersatz für eine formale Spezifikation des Verhaltens angesehen werden, das in einer Methode implementiert wird (siehe dazu Abschnitt 5.6 in Kurseinheit 5).
Um die Programmierung zu erleichtern, wird das Protokoll von Objekten in den meisten SMALLTALK-Systemen in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien tragen jeweils einen Namen, der die in der Kategorie enthaltenen Methodennamen zusammenfasst. Da jede Methode genau in eine Nachrichtenkategorie fallen muss, stellen diese Kategorien eine Partitionierung des Interfaces eines Objekts dar. Einige dieser Kategorien können das Wort „private“ enthalten, was darauf hinweist, dass deren Methoden vorzugsweise nur vom Objekt selbst (über self) aufgerufen werden sollten. Beachten Sie jedoch, dass dies nicht vom Compiler erzwungen wird. Nachrichtenkategorien haben darüber hinaus keine weitere Bedeutung für die Programmausführung und dienen lediglich der besseren Lesbarkeit.
Wie Sie in der nächsten Kurseinheit erfahren werden, werden Protokolle in SMALLTALK nicht auf Objektebene, sondern auf Klassenebene spezifiziert. In STRONGTALK, einer Erweiterung von SMALLTALK um ein (optionales) Typsystem, werden Protokolle zu Typen erhoben (siehe Kurseinheit 3, Kapitel 20). Da Protokolle nur Methoden enthalten, sind sie den Interfaces in JAVA sehr ähnlich. Tatsächlich werden Protokolle in STRONGTALK manchmal auch Interfaces genannt.","<answer> Das Protokoll beschreibt das Interface eines Objekts und umfasst die Methodensignaturen und dazugehörigen Kommentare. Die Implementierung hingegen besteht aus den tatsächlichen Methodenrümpfen und den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Das Protokoll dient dazu, das Verhalten eines Objekts zu beschreiben, während die Implementierung die Details der Umsetzung enthält. <answer> <question> Was ist der Unterschied zwischen Protokoll und Implementierung in SMALLTALK? <question>"
"In SMALLTALK ist das Interface eines Objekts die Menge der Nachrichten, die es versteht. Dieses Interface wird in Form der sogenannten Protokollbeschreibung oder kurz des Protokolls spezifiziert. Es besteht aus den Methodensignaturen und den Kommentaren der zu den Nachrichten passenden Methoden, und es steht in Kontrast zur Implementierung, also der Liste der Methodenrümpfe, sowie den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Dieses Geheimnis bleibt hinter seiner Protokollbeschreibung, also dem Interface, verborgen. Die Kommentare dürfen übrigens, wie in den meisten anderen Sprachen auch, als eine Art schwacher Ersatz für eine formale Spezifikation des Verhaltens angesehen werden, das in einer Methode implementiert wird (siehe dazu Abschnitt 5.6 in Kurseinheit 5).
Um die Programmierung zu erleichtern, wird das Protokoll von Objekten in den meisten SMALLTALK-Systemen in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien tragen jeweils einen Namen, der die in der Kategorie enthaltenen Methodennamen zusammenfasst. Da jede Methode genau in eine Nachrichtenkategorie fallen muss, stellen diese Kategorien eine Partitionierung des Interfaces eines Objekts dar. Einige dieser Kategorien können das Wort „private“ enthalten, was darauf hinweist, dass deren Methoden vorzugsweise nur vom Objekt selbst (über self) aufgerufen werden sollten. Beachten Sie jedoch, dass dies nicht vom Compiler erzwungen wird. Nachrichtenkategorien haben darüber hinaus keine weitere Bedeutung für die Programmausführung und dienen lediglich der besseren Lesbarkeit.
Wie Sie in der nächsten Kurseinheit erfahren werden, werden Protokolle in SMALLTALK nicht auf Objektebene, sondern auf Klassenebene spezifiziert. In STRONGTALK, einer Erweiterung von SMALLTALK um ein (optionales) Typsystem, werden Protokolle zu Typen erhoben (siehe Kurseinheit 3, Kapitel 20). Da Protokolle nur Methoden enthalten, sind sie den Interfaces in JAVA sehr ähnlich. Tatsächlich werden Protokolle in STRONGTALK manchmal auch Interfaces genannt.","<answer> In SMALLTALK werden Protokolle nicht auf Objektebene, sondern auf Klassenebene spezifiziert. Dies bedeutet, dass eine Klasse ein bestimmtes Protokoll implementiert und die Objekte dieser Klasse dieses Protokoll erben. In STRONGTALK, einer Erweiterung von SMALLTALK, werden Protokolle zu Typen erhoben und ähneln Interfaces in JAVA. <answer> <question> Wie werden Protokolle in SMALLTALK spezifiziert? <question>"
"Properties sind gewissermaßen die Umkehrung von Zugriffsmethoden (Settern und Gettern; s. Abschnitt 4.3.4 in Kurseinheit 1): Anstatt auf ein Feld eines Objektes über Methoden (lesend und schreibend) zuzugreifen, ruft man Methoden über das auf, was syntaktisch wie ein Feldzugriff aussieht. Dies erlaubt es, (lesende und schreibende) Feldzugriffe mit Nebeneffekten zu versehen (wie z. B. einer dynamischen Typprüfung bei schreibendem Zugriff, wenn man kovariante Redefinition imitieren will). Dabei sind ""get"" und ""set"" Schlüsselwörter von C#, und ""value"" ist eine spezielle Variable (vergleichbar mit ""this""), die den Eingabewert eines Setters hält. Um einem Punkt seine Koordinaten zuzuweisen bzw. darauf zuzugreifen, kann man dann die Properties X, Y, Winkel und Radius wie Felder verwenden. Keine große Sache, aber es macht den Code auf der Aufruferinnenseite knapper und besser lesbar. Den Getter oder den Setter kann man wahlweise auch weglassen; auf diese Weise lassen sich Felder mit Nur-Lese- bzw. Nur-Schreib-Zugriff simulieren.","<answer> Properties in C# sind eine Möglichkeit, auf die Felder eines Objekts zuzugreifen, indem Methoden aufgerufen werden, die wie Feldzugriffe aussehen. Sie sind die Umkehrung von Zugriffsmethoden (Settern und Gettern) und ermöglichen es, Feldzugriffe mit Nebeneffekten zu versehen. In C# werden die Schlüsselwörter ""get"" und ""set"" verwendet, wobei ""get"" für den Lesezugriff und ""set"" für den Schreibzugriff verwendet wird. Die Variable ""value"" wird verwendet, um den Eingabewert eines Setters zu halten. <answer> <question> Was sind Properties in C# und wie unterscheiden sie sich von Zugriffsmethoden (Settern und Gettern)? <question>"
"Properties sind gewissermaßen die Umkehrung von Zugriffsmethoden (Settern und Gettern; s. Abschnitt 4.3.4 in Kurseinheit 1): Anstatt auf ein Feld eines Objektes über Methoden (lesend und schreibend) zuzugreifen, ruft man Methoden über das auf, was syntaktisch wie ein Feldzugriff aussieht. Dies erlaubt es, (lesende und schreibende) Feldzugriffe mit Nebeneffekten zu versehen (wie z. B. einer dynamischen Typprüfung bei schreibendem Zugriff, wenn man kovariante Redefinition imitieren will). Dabei sind ""get"" und ""set"" Schlüsselwörter von C#, und ""value"" ist eine spezielle Variable (vergleichbar mit ""this""), die den Eingabewert eines Setters hält. Um einem Punkt seine Koordinaten zuzuweisen bzw. darauf zuzugreifen, kann man dann die Properties X, Y, Winkel und Radius wie Felder verwenden. Keine große Sache, aber es macht den Code auf der Aufruferinnenseite knapper und besser lesbar. Den Getter oder den Setter kann man wahlweise auch weglassen; auf diese Weise lassen sich Felder mit Nur-Lese- bzw. Nur-Schreib-Zugriff simulieren.","<answer> Properties in C# bieten den Vorteil, dass sie Feldzugriffe mit zusätzlicher Logik und Validierung versehen können. Sie machen den Code auf der Aufruferinnenseite knapper und besser lesbar, da sie wie Feldzugriffe aussehen und die Details der Implementierung verbergen. Außerdem ermöglichen sie die Simulation von Feldern mit Nur-Lese- oder Nur-Schreib-Zugriff, indem entweder der Getter oder der Setter weggelassen wird. <answer> <question> Welche Vorteile bieten Properties in C# im Vergleich zu direktem Feldzugriff? <question>"
"Properties sind gewissermaßen die Umkehrung von Zugriffsmethoden (Settern und Gettern; s. Abschnitt 4.3.4 in Kurseinheit 1): Anstatt auf ein Feld eines Objektes über Methoden (lesend und schreibend) zuzugreifen, ruft man Methoden über das auf, was syntaktisch wie ein Feldzugriff aussieht. Dies erlaubt es, (lesende und schreibende) Feldzugriffe mit Nebeneffekten zu versehen (wie z. B. einer dynamischen Typprüfung bei schreibendem Zugriff, wenn man kovariante Redefinition imitieren will). Dabei sind ""get"" und ""set"" Schlüsselwörter von C#, und ""value"" ist eine spezielle Variable (vergleichbar mit ""this""), die den Eingabewert eines Setters hält. Um einem Punkt seine Koordinaten zuzuweisen bzw. darauf zuzugreifen, kann man dann die Properties X, Y, Winkel und Radius wie Felder verwenden. Keine große Sache, aber es macht den Code auf der Aufruferinnenseite knapper und besser lesbar. Den Getter oder den Setter kann man wahlweise auch weglassen; auf diese Weise lassen sich Felder mit Nur-Lese- bzw. Nur-Schreib-Zugriff simulieren.","<answer> Die spezielle Variable ""value"" in einem Property-Setter enthält den Eingabewert, der beim Setzen des Property-Werts übergeben wurde. Sie ermöglicht es, den neuen Wert zu verarbeiten und in das entsprechende Feld oder die entsprechende Variable zu schreiben. Dies ist besonders nützlich, um Validierungen oder Transformationen beim Schreibzugriff durchzuführen. <answer> <question> Was ist die spezielle Variable ""value"" in einem Property-Setter? <question>"
"Um :n-Beziehungen zu pflegen, also Objekte zu einer Beziehung hinzuzufügen und wieder zu entfernen, sieht SMALLTALK standardmäßig die Methoden add: und remove: vor, die beide jeweils das Argumentobjekt zurückliefern. Beide sind in der abstrakten Klasse Collection definiert, die Wurzel einer Hierarchie von Klassen, den Collection-Klassen, ist, die allesamt der Verwirklichung von : n-Beziehungen dienen. Unsere Zwischenobjekte, die diese Beziehungen repräsentieren, sind also alle indirekte Instanzen von Collection.
Die Methoden add: und remove: bleiben zunächst (in Collection) abstrakt. Da sie von der tatsächlichen Realisierung einer Collection abhängen, können sie erst in den entsprechenden Subklassen (durch Überschreiben) realisiert werden.
Beim Entfernen eines Objektes aus einer Collection43 mittels remove: gibt es zwei Sonderfälle zu berücksichtigen: Das Objekt ist nicht vorhanden oder das Objekt ist mehrfach vorhanden. Im ersten Fall wird ein Fehler gemeldet, während im zweiten Fall nur ein Vorkommen des Objekts aus der Collection entfernt wird (das erste, wie auch immer die Reihenfolge festgelegt ist). Da es immer vorkommen kann, dass ein zu entfernendes Objekt gar nicht vorhanden ist, und ein entsprechender vorheriger Test auf Vorhandensein (siehe unten) wieder eine stereotype Handlung ist, bietet SMALLTALK eine Variante von remove:, die einem genau das erspart: remove: anObject ifAbsent: anExceptionBlock. Sollte das zu entfernende Objekt fehlen, wird stattdessen anExceptionBlock ausgeführt, und dessen Ergebnis wird zurückgeliefert. Will man, dass beim Versuch, ein nicht vorhandenes Objekt zu entfernen, nichts passiert, so gibt man einfach den leeren Block [] für anExceptionBlock an. Sollen mehrere Objekte auf einmal einer Beziehung hinzugefügt bzw. daraus entfernt werden, so stehen hierfür die Methoden addAll: aCollection bzw. removeAll: aCollection zur Verfügung, die jeweils eine Collection als Parameter erwarten.
Es ist wichtig zu beachten, dass es sich bei den entsprechenden Instanzen prinzipiell um eigenständige Objekte handelt, die hier lediglich die Funktion eines Zwischenobjektes haben, um die Beziehungen zu realisieren. Subklassen von Collection müssen also die Methoden add: und remove:ifAbsent: überschreiben. Dabei offenbart sich gleich ein Charakterzug von SMALLTALK: Da seine Klassenhierarchie keine Generalisierungshierarchie ist, kommt es vor, dass Subklassen die Methoden add:, remove: und remove:ifAbsent: löschen. Während beispielsweise in der Klasse OrderedCollection add: und remove:ifAbsent: überschrieben werden, werden sie in der Klasse FixedSizeCollection, die ebenfalls eine Subklasse von Collection ist, gelöscht.
Die Methoden add: und remove: werden durch die Methoden addAll: und removeAll: komplettiert; die Implementierung von addAll: können Sie den Zeilen 427–431 oben (Abschnitt 10.3) entnehmen, removeAll: verläuft im Prinzip analog (warum SMALLTALK EXPRESS hier eine Kopie zurückgibt, weiß ich nicht). Die Methode addAll: wird dazu benutzt, eine Collection in eine andere zu konvertieren:
Dabei ist addAll: nur einmal, nämlich in Collection, definiert. Man beachte, dass dabei ein Objekt nicht seine Klasse wechselt, sondern lediglich der Inhalt einer Collection in eine neue übertragen wird. Diese Übertragung ist immer dann sinnvoll, wenn die Klasse der neuen Collection Eigenschaften hat, die man gern nutzen möchte. Ein Beispiel hierfür finden Sie in Zeile 525 unten. Die Nachricht yourself (von Object geerbt) liefert übrigens ihren Empfänger zurück; sie wird am Ende von kaskadierten Nachrichtenausdrücken in Return-Anweisungen verwendet, um den Empfänger zurückzuliefern.
Zum Pflegen seiner Beziehungen ist es manchmal vorteilhaft, zu wissen, mit wie vielen Objekten man in Beziehung steht und mit welchen. Die Klasse Collection sieht dafür die Methoden size, isEmpty und notEmpty, includes: sowie occurencesOf: vor, die jeweils die naheliegende Bedeutung haben.","<answer> In SMALLTALK werden :n-Beziehungen standardmäßig mit den Methoden add: und remove: gepflegt. Diese Methoden sind in der abstrakten Klasse Collection definiert, und alle Klassen, die : n-Beziehungen repräsentieren, sind indirekte Instanzen von Collection. Diese Methoden bleiben zunächst abstrakt und müssen in den entsprechenden Subklassen implementiert werden. <answer> <question> Wie können :n-Beziehungen in SMALLTALK gepflegt werden, und welche Methoden werden standardmäßig verwendet? <question>"
"Um :n-Beziehungen zu pflegen, also Objekte zu einer Beziehung hinzuzufügen und wieder zu entfernen, sieht SMALLTALK standardmäßig die Methoden add: und remove: vor, die beide jeweils das Argumentobjekt zurückliefern. Beide sind in der abstrakten Klasse Collection definiert, die Wurzel einer Hierarchie von Klassen, den Collection-Klassen, ist, die allesamt der Verwirklichung von : n-Beziehungen dienen. Unsere Zwischenobjekte, die diese Beziehungen repräsentieren, sind also alle indirekte Instanzen von Collection.
Die Methoden add: und remove: bleiben zunächst (in Collection) abstrakt. Da sie von der tatsächlichen Realisierung einer Collection abhängen, können sie erst in den entsprechenden Subklassen (durch Überschreiben) realisiert werden.
Beim Entfernen eines Objektes aus einer Collection43 mittels remove: gibt es zwei Sonderfälle zu berücksichtigen: Das Objekt ist nicht vorhanden oder das Objekt ist mehrfach vorhanden. Im ersten Fall wird ein Fehler gemeldet, während im zweiten Fall nur ein Vorkommen des Objekts aus der Collection entfernt wird (das erste, wie auch immer die Reihenfolge festgelegt ist). Da es immer vorkommen kann, dass ein zu entfernendes Objekt gar nicht vorhanden ist, und ein entsprechender vorheriger Test auf Vorhandensein (siehe unten) wieder eine stereotype Handlung ist, bietet SMALLTALK eine Variante von remove:, die einem genau das erspart: remove: anObject ifAbsent: anExceptionBlock. Sollte das zu entfernende Objekt fehlen, wird stattdessen anExceptionBlock ausgeführt, und dessen Ergebnis wird zurückgeliefert. Will man, dass beim Versuch, ein nicht vorhandenes Objekt zu entfernen, nichts passiert, so gibt man einfach den leeren Block [] für anExceptionBlock an. Sollen mehrere Objekte auf einmal einer Beziehung hinzugefügt bzw. daraus entfernt werden, so stehen hierfür die Methoden addAll: aCollection bzw. removeAll: aCollection zur Verfügung, die jeweils eine Collection als Parameter erwarten.
Es ist wichtig zu beachten, dass es sich bei den entsprechenden Instanzen prinzipiell um eigenständige Objekte handelt, die hier lediglich die Funktion eines Zwischenobjektes haben, um die Beziehungen zu realisieren. Subklassen von Collection müssen also die Methoden add: und remove:ifAbsent: überschreiben. Dabei offenbart sich gleich ein Charakterzug von SMALLTALK: Da seine Klassenhierarchie keine Generalisierungshierarchie ist, kommt es vor, dass Subklassen die Methoden add:, remove: und remove:ifAbsent: löschen. Während beispielsweise in der Klasse OrderedCollection add: und remove:ifAbsent: überschrieben werden, werden sie in der Klasse FixedSizeCollection, die ebenfalls eine Subklasse von Collection ist, gelöscht.
Die Methoden add: und remove: werden durch die Methoden addAll: und removeAll: komplettiert; die Implementierung von addAll: können Sie den Zeilen 427–431 oben (Abschnitt 10.3) entnehmen, removeAll: verläuft im Prinzip analog (warum SMALLTALK EXPRESS hier eine Kopie zurückgibt, weiß ich nicht). Die Methode addAll: wird dazu benutzt, eine Collection in eine andere zu konvertieren:
Dabei ist addAll: nur einmal, nämlich in Collection, definiert. Man beachte, dass dabei ein Objekt nicht seine Klasse wechselt, sondern lediglich der Inhalt einer Collection in eine neue übertragen wird. Diese Übertragung ist immer dann sinnvoll, wenn die Klasse der neuen Collection Eigenschaften hat, die man gern nutzen möchte. Ein Beispiel hierfür finden Sie in Zeile 525 unten. Die Nachricht yourself (von Object geerbt) liefert übrigens ihren Empfänger zurück; sie wird am Ende von kaskadierten Nachrichtenausdrücken in Return-Anweisungen verwendet, um den Empfänger zurückzuliefern.
Zum Pflegen seiner Beziehungen ist es manchmal vorteilhaft, zu wissen, mit wie vielen Objekten man in Beziehung steht und mit welchen. Die Klasse Collection sieht dafür die Methoden size, isEmpty und notEmpty, includes: sowie occurencesOf: vor, die jeweils die naheliegende Bedeutung haben.","<answer> Beim Entfernen eines Objekts aus einer Collection gibt es zwei Sonderfälle zu berücksichtigen: Das Objekt ist nicht vorhanden oder das Objekt ist mehrfach vorhanden. Im ersten Fall wird ein Fehler gemeldet, während im zweiten Fall nur ein Vorkommen des Objekts aus der Collection entfernt wird. SMALLTALK bietet eine Variante von remove: namens remove: anObject ifAbsent: anExceptionBlock, die es ermöglicht, das Verhalten beim Fehlen des zu entfernenden Objekts zu steuern. Wenn das Objekt fehlt, wird anExceptionBlock ausgeführt, und dessen Ergebnis wird zurückgeliefert. <answer> <question> Welche Besonderheiten gibt es beim Entfernen eines Objekts aus einer Collection in SMALLTALK? <question>"
"Um :n-Beziehungen zu pflegen, also Objekte zu einer Beziehung hinzuzufügen und wieder zu entfernen, sieht SMALLTALK standardmäßig die Methoden add: und remove: vor, die beide jeweils das Argumentobjekt zurückliefern. Beide sind in der abstrakten Klasse Collection definiert, die Wurzel einer Hierarchie von Klassen, den Collection-Klassen, ist, die allesamt der Verwirklichung von : n-Beziehungen dienen. Unsere Zwischenobjekte, die diese Beziehungen repräsentieren, sind also alle indirekte Instanzen von Collection.
Die Methoden add: und remove: bleiben zunächst (in Collection) abstrakt. Da sie von der tatsächlichen Realisierung einer Collection abhängen, können sie erst in den entsprechenden Subklassen (durch Überschreiben) realisiert werden.
Beim Entfernen eines Objektes aus einer Collection43 mittels remove: gibt es zwei Sonderfälle zu berücksichtigen: Das Objekt ist nicht vorhanden oder das Objekt ist mehrfach vorhanden. Im ersten Fall wird ein Fehler gemeldet, während im zweiten Fall nur ein Vorkommen des Objekts aus der Collection entfernt wird (das erste, wie auch immer die Reihenfolge festgelegt ist). Da es immer vorkommen kann, dass ein zu entfernendes Objekt gar nicht vorhanden ist, und ein entsprechender vorheriger Test auf Vorhandensein (siehe unten) wieder eine stereotype Handlung ist, bietet SMALLTALK eine Variante von remove:, die einem genau das erspart: remove: anObject ifAbsent: anExceptionBlock. Sollte das zu entfernende Objekt fehlen, wird stattdessen anExceptionBlock ausgeführt, und dessen Ergebnis wird zurückgeliefert. Will man, dass beim Versuch, ein nicht vorhandenes Objekt zu entfernen, nichts passiert, so gibt man einfach den leeren Block [] für anExceptionBlock an. Sollen mehrere Objekte auf einmal einer Beziehung hinzugefügt bzw. daraus entfernt werden, so stehen hierfür die Methoden addAll: aCollection bzw. removeAll: aCollection zur Verfügung, die jeweils eine Collection als Parameter erwarten.
Es ist wichtig zu beachten, dass es sich bei den entsprechenden Instanzen prinzipiell um eigenständige Objekte handelt, die hier lediglich die Funktion eines Zwischenobjektes haben, um die Beziehungen zu realisieren. Subklassen von Collection müssen also die Methoden add: und remove:ifAbsent: überschreiben. Dabei offenbart sich gleich ein Charakterzug von SMALLTALK: Da seine Klassenhierarchie keine Generalisierungshierarchie ist, kommt es vor, dass Subklassen die Methoden add:, remove: und remove:ifAbsent: löschen. Während beispielsweise in der Klasse OrderedCollection add: und remove:ifAbsent: überschrieben werden, werden sie in der Klasse FixedSizeCollection, die ebenfalls eine Subklasse von Collection ist, gelöscht.
Die Methoden add: und remove: werden durch die Methoden addAll: und removeAll: komplettiert; die Implementierung von addAll: können Sie den Zeilen 427–431 oben (Abschnitt 10.3) entnehmen, removeAll: verläuft im Prinzip analog (warum SMALLTALK EXPRESS hier eine Kopie zurückgibt, weiß ich nicht). Die Methode addAll: wird dazu benutzt, eine Collection in eine andere zu konvertieren:
Dabei ist addAll: nur einmal, nämlich in Collection, definiert. Man beachte, dass dabei ein Objekt nicht seine Klasse wechselt, sondern lediglich der Inhalt einer Collection in eine neue übertragen wird. Diese Übertragung ist immer dann sinnvoll, wenn die Klasse der neuen Collection Eigenschaften hat, die man gern nutzen möchte. Ein Beispiel hierfür finden Sie in Zeile 525 unten. Die Nachricht yourself (von Object geerbt) liefert übrigens ihren Empfänger zurück; sie wird am Ende von kaskadierten Nachrichtenausdrücken in Return-Anweisungen verwendet, um den Empfänger zurückzuliefern.
Zum Pflegen seiner Beziehungen ist es manchmal vorteilhaft, zu wissen, mit wie vielen Objekten man in Beziehung steht und mit welchen. Die Klasse Collection sieht dafür die Methoden size, isEmpty und notEmpty, includes: sowie occurencesOf: vor, die jeweils die naheliegende Bedeutung haben.","<answer> Um mehrere Objekte auf einmal einer Beziehung hinzuzufügen oder daraus zu entfernen, stehen die Methoden addAll: aCollection und removeAll: aCollection zur Verfügung. Beide Methoden akzeptieren eine Collection als Parameter und führen die entsprechenden Aktionen für jedes Objekt in der übergebenen Collection aus. <answer> <question> Wie können mehrere Objekte auf einmal einer Beziehung in SMALLTALK hinzugefügt oder daraus entfernt werden? <question>"
"Wie bereits zu Beginn erwähnt (in Abschnitt 7.1), entspricht die Klassifikation sprachlich der ""Ist-ein-Abstraktionsbeziehung"" zwischen Individuen und ihren Klassen: ""Peter ist ein Mensch,"" ""SMALLTALK ist eine Programmiersprache,"" usw. sind alles Beispiele für eine Art der Abstraktion, bei der man von einem Individuum zu seinem Allgemeinbegriff übergeht. Es gibt jedoch eine zweite Form der Ist-ein-Abstraktion, die sich von der ersten grundlegend unterscheidet, aber ebenfalls eine charakteristische Rolle in der objektorientierten Programmierung spielt: die Generalisierung. Sprachlich zeigt sich diese Form in Sätzen wie ""Ein Mensch ist ein Säugetier,"" ""Ein Säugetier ist ein Lebewesen"" oder ""Eine Programmiersprache ist ein Werkzeug."" Der Unterschied zur ersten Form der Abstraktion liegt offensichtlich darin, dass hier zwei Allgemeinbegriffe miteinander in Beziehung gesetzt werden, anstelle eines Individuums und eines Allgemeinbegriffs. Ein weiterer, etwas subtilerer, aber sehr wesentlicher Unterschied besteht darin, dass die Klassifikation nicht transitiv ist, während die Generalisierung es ist. So ergibt sich aus ""Ein Mensch ist ein Säugetier"" und ""Ein Säugetier ist ein Lebewesen"" logischerweise ""Ein Mensch ist ein Lebewesen,"" aber aus ""Peter ist ein Mensch"" und ""Mensch ist eine Art"" ergibt sich nicht ""Peter ist eine Art.""
Im Prozess der Generalisierung werden mehrere Klassen, deren Definitionen inhaltlich verwandt sind, zusammengefasst. Das Ergebnis dieser Generalisierung, auch als Generalisierungsklasse bezeichnet, enthält nur diejenigen Elemente der Definitionen der generalisierten Klassen, die allen gemeinsam sind. So lässt sich beispielsweise aus den beiden ähnlichen, aber nicht identischen Klassen Mensch und Vogel per Generalisierung die Klasse Zweibeiner herausarbeiten. Diese Klasse Zweibeiner enthält die gemeinsamen Eigenschaften (Instanzvariablen und Methoden) der Klassen Mensch und Vogel.
Da die Eigenschaften, die einer Generalisierung als Klasse zugeordnet sind, per Definition automatisch auch für alle Klassen gelten, von denen die Generalisierung abstrahiert (denn das war ja die Bedingung für die Konstruktion der Generalisierung), müssen diese Klassen die Eigenschaften nicht wiederholen, sondern nur auf ihre Generalisierung verweisen. Diese Klassen müssen dann nur noch die Unterschiede definieren, die sie von der Klasse Zweibeiner sowie voneinander unterscheiden.
Diese zweite Form der Abstraktion, die Generalisierung, ist also genau wie die Klassifikation Bestandteil der klassenbasierten objektorientierten Programmierung. Anders als bei der Klassifikation ist bei der Generalisierung jedoch die Höhe der Abstraktionshierarchie nicht durch praktische Überlegungen beschränkt, sondern kann von der Programmiererin nach Belieben festgelegt werden. Sprachphilosophisch betrachtet sind Generalisierungen ebenfalls Allgemeinbegriffe, nur noch allgemeiner. Generalisierungen können selbst wiederum Generalisierungen haben, und so weiter. Wie es für eine Abstraktionshierarchie typisch ist, werden die Definitionen, die Intensionen, dabei immer präziser. Gleichzeitig wächst jedoch die Extension (das bereits in Abschnitt 7.1 erwähnte Prinzip vom inversen Zusammenhang der beiden).
Übrigens stammt das Prinzip der Generalisierung von Aristoteles' Prinzip von Genus et differentia ab, das gemeinsame Abstammung und Unterschiede betrifft. Das Genus ist die nächst allgemeinere Kategorie, unter die die Objekte der zu generalisierenden Klassen (der Spezies) fallen, und die Differentia sind die Kriterien, anhand derer sich die Objekte aufgrund ihrer Natur unterscheiden, wie sie in den verschiedenen Klassendefinitionen festgelegt sind (und nicht etwa durch spezielle Werte von Instanzvariablen). So haben die Klassen Mensch und Vogel beispielsweise das gemeinsame Genus Zweibeiner als (biologisch nicht ganz korrekte) Generalisierung, in der festgelegt ist, dass alle Exemplare von Zweibeinern (und damit auch von Menschen und Vögeln) ein linkes und ein rechtes Bein sowie einen Aufenthaltsort haben. Die Unterschiede (Differentia) sind dann in den jeweiligen Klassen ausgearbeitet. Beachten Sie, dass Genera keine eigenen Individuen haben, das heißt, es gibt keine Zweibeiner, die nicht entweder Mensch oder Vogel sind.
Wie die Klassifikation hat auch das Ordnungsprinzip der Generalisierung eine einfache mengentheoretische Interpretation. Demnach enthält die Menge der Instanzen einer Generalisierung alle Instanzen der Klassen, von denen sie eine Generalisierung ist. Wenn also Mensch und Vogel Ausgangsklassen einer Generalisierung namens Zweibeiner sind, dann ist die Menge der Instanzen, die Zweibeiner repräsentiert (für die Zweibeiner den Allgemeinbegriff bereitstellen), eine Obermenge der Vereinigung der Menge der Instanzen von Mensch und Vogel. Die Menge der Instanzen von Zweibeiner ist eine echte Obermenge, wenn Zweibeiner auch eigene Instanzen haben (also Instanzen, die nicht Instanzen von Mensch und Vogel sind; im Kontext der Instanziierung spricht man von direkten Instanzen; siehe Abschnitt 7.3). Andernfalls ist sie nur eine unechte Obermenge (genau gleich der Vereinigung). Die folgende Grafik zeigt diese Beziehung (wobei schwarze Punkte die Instanzen und Ellipsen die Klassen darstellen sollen).
In der Praxis ist es gute Praxis (wie bereits angedeutet), wenn Generalisierungen keine eigenen, direkten Instanzen haben, sondern Genera im oben beschriebenen Sinne sind. Dies ist jedoch in der objektorientierten Praxis (leider) nicht immer selbstverständlich, wie sich im nächsten Kapitel noch zeigen wird (siehe auch Kapitel 69 in Kurseinheit 7).
Die mengentheoretische Interpretation der Generalisierung als Obermengenbildung legt nahe, dass Instanzen von Mensch und Vogel (als Elemente der entsprechenden Extensionen) auch Instanzen von Zweibeiner sind. Wenn man das so betrachten möchte, sollte man jedoch zur notwendigen Unterscheidung von indirekten Instanzen (anstelle von direkten Instanzen; siehe Abschnitt 7.3) sprechen.
Bei der Generalisierung können also Eigenschaften, die verschiedene, aber ähnliche Klassen unterscheiden, weggelassen (oder ""abstrahiert"") werden. Das Weglassen ist jedoch nicht die einzige Form der Generalisierung. Es können auch Eigenschaften generalisiert werden, wobei dann der Begriff der Generalisierung rekursiv angewendet wird. Unter der Generalisierung von Attributen (oder allgemeiner von Instanzvariablen; siehe Abschnitt 2.4) versteht man, dass ihr Wertebereich von einem spezielleren (kleineren) zu einem allgemeineren (größeren) erweitert wird. Zum Beispiel würde das Attribut ""Aufenthaltsort,"" das mit (Instanzen der) Klasse Mensch assoziiert ist, bei der Generalisierung zu Zweibeiner von Punkten auf der Erdoberfläche zu Punkten einschließlich des Luftraums darüber generalisiert, um auch den Wertebereich für Vögel abzudecken. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen. Wie Sie später sehen werden, erlauben die meisten Programmiersprachen, die die Möglichkeit der Wertebeschränkung von Variablen bieten, aus guten Gründen nicht, Attributwertebereiche bei der Generalisierung ebenfalls zu generalisieren (die sogenannte kovariante Redefinition; siehe dazu auch die Kapitel 25 und Abschnitt 26.3 in Kurseinheit 3).
Obwohl bisher so getan wurde, als ob die Generalisierung eine inhärente Eigenschaft des betrachteten Objekts sei, gibt es in der Praxis oft verschiedene Perspektiven, nach denen Generalisierungen durchgeführt werden können. Die Generalisierung von Vogel und Mensch zu Zweibeiner ist also nicht die einzige (und sicherlich nicht die einzige sinnvolle) Möglichkeit. Es könnte durchaus mehrere unabhängige Generalisierungshierarchien geben, in denen dieselben Klassen auftreten. In der Praxis führt dies jedoch dazu, dass die strenge Hierarchieform der Generalisierung verloren geht (da sich mehrere Hierarchien überlappen), es sei denn, es wird erlaubt, verschiedene Arten der Generalisierung voneinander zu unterscheiden. Beide Ansätze bringen jedoch Komplikationen mit sich, daher werden wir hier nicht auf ""mehrfache Generalisierungen"" eingehen.","<answer> In der objektorientierten Programmierung entspricht die Klassifikation der ""Ist-ein-Abstraktionsbeziehung"" zwischen Individuen und ihren Klassen, während die Generalisierung eine Form der Abstraktion ist, bei der Allgemeinbegriffe miteinander in Beziehung gesetzt werden. Klassifikation bezieht sich auf die Zuordnung eines Individuums zu einer Klasse, während Generalisierung die Beziehung zwischen verschiedenen Klassen beschreibt, bei der eine Klasse eine Verallgemeinerung (Generalisierung) einer anderen ist. <answer> <question> Was ist der Unterschied zwischen Klassifikation und Generalisierung in der objektorientierten Programmierung? <question>"
"Wie bereits zu Beginn erwähnt (in Abschnitt 7.1), entspricht die Klassifikation sprachlich der ""Ist-ein-Abstraktionsbeziehung"" zwischen Individuen und ihren Klassen: ""Peter ist ein Mensch,"" ""SMALLTALK ist eine Programmiersprache,"" usw. sind alles Beispiele für eine Art der Abstraktion, bei der man von einem Individuum zu seinem Allgemeinbegriff übergeht. Es gibt jedoch eine zweite Form der Ist-ein-Abstraktion, die sich von der ersten grundlegend unterscheidet, aber ebenfalls eine charakteristische Rolle in der objektorientierten Programmierung spielt: die Generalisierung. Sprachlich zeigt sich diese Form in Sätzen wie ""Ein Mensch ist ein Säugetier,"" ""Ein Säugetier ist ein Lebewesen"" oder ""Eine Programmiersprache ist ein Werkzeug."" Der Unterschied zur ersten Form der Abstraktion liegt offensichtlich darin, dass hier zwei Allgemeinbegriffe miteinander in Beziehung gesetzt werden, anstelle eines Individuums und eines Allgemeinbegriffs. Ein weiterer, etwas subtilerer, aber sehr wesentlicher Unterschied besteht darin, dass die Klassifikation nicht transitiv ist, während die Generalisierung es ist. So ergibt sich aus ""Ein Mensch ist ein Säugetier"" und ""Ein Säugetier ist ein Lebewesen"" logischerweise ""Ein Mensch ist ein Lebewesen,"" aber aus ""Peter ist ein Mensch"" und ""Mensch ist eine Art"" ergibt sich nicht ""Peter ist eine Art.""
Im Prozess der Generalisierung werden mehrere Klassen, deren Definitionen inhaltlich verwandt sind, zusammengefasst. Das Ergebnis dieser Generalisierung, auch als Generalisierungsklasse bezeichnet, enthält nur diejenigen Elemente der Definitionen der generalisierten Klassen, die allen gemeinsam sind. So lässt sich beispielsweise aus den beiden ähnlichen, aber nicht identischen Klassen Mensch und Vogel per Generalisierung die Klasse Zweibeiner herausarbeiten. Diese Klasse Zweibeiner enthält die gemeinsamen Eigenschaften (Instanzvariablen und Methoden) der Klassen Mensch und Vogel.
Da die Eigenschaften, die einer Generalisierung als Klasse zugeordnet sind, per Definition automatisch auch für alle Klassen gelten, von denen die Generalisierung abstrahiert (denn das war ja die Bedingung für die Konstruktion der Generalisierung), müssen diese Klassen die Eigenschaften nicht wiederholen, sondern nur auf ihre Generalisierung verweisen. Diese Klassen müssen dann nur noch die Unterschiede definieren, die sie von der Klasse Zweibeiner sowie voneinander unterscheiden.
Diese zweite Form der Abstraktion, die Generalisierung, ist also genau wie die Klassifikation Bestandteil der klassenbasierten objektorientierten Programmierung. Anders als bei der Klassifikation ist bei der Generalisierung jedoch die Höhe der Abstraktionshierarchie nicht durch praktische Überlegungen beschränkt, sondern kann von der Programmiererin nach Belieben festgelegt werden. Sprachphilosophisch betrachtet sind Generalisierungen ebenfalls Allgemeinbegriffe, nur noch allgemeiner. Generalisierungen können selbst wiederum Generalisierungen haben, und so weiter. Wie es für eine Abstraktionshierarchie typisch ist, werden die Definitionen, die Intensionen, dabei immer präziser. Gleichzeitig wächst jedoch die Extension (das bereits in Abschnitt 7.1 erwähnte Prinzip vom inversen Zusammenhang der beiden).
Übrigens stammt das Prinzip der Generalisierung von Aristoteles' Prinzip von Genus et differentia ab, das gemeinsame Abstammung und Unterschiede betrifft. Das Genus ist die nächst allgemeinere Kategorie, unter die die Objekte der zu generalisierenden Klassen (der Spezies) fallen, und die Differentia sind die Kriterien, anhand derer sich die Objekte aufgrund ihrer Natur unterscheiden, wie sie in den verschiedenen Klassendefinitionen festgelegt sind (und nicht etwa durch spezielle Werte von Instanzvariablen). So haben die Klassen Mensch und Vogel beispielsweise das gemeinsame Genus Zweibeiner als (biologisch nicht ganz korrekte) Generalisierung, in der festgelegt ist, dass alle Exemplare von Zweibeinern (und damit auch von Menschen und Vögeln) ein linkes und ein rechtes Bein sowie einen Aufenthaltsort haben. Die Unterschiede (Differentia) sind dann in den jeweiligen Klassen ausgearbeitet. Beachten Sie, dass Genera keine eigenen Individuen haben, das heißt, es gibt keine Zweibeiner, die nicht entweder Mensch oder Vogel sind.
Wie die Klassifikation hat auch das Ordnungsprinzip der Generalisierung eine einfache mengentheoretische Interpretation. Demnach enthält die Menge der Instanzen einer Generalisierung alle Instanzen der Klassen, von denen sie eine Generalisierung ist. Wenn also Mensch und Vogel Ausgangsklassen einer Generalisierung namens Zweibeiner sind, dann ist die Menge der Instanzen, die Zweibeiner repräsentiert (für die Zweibeiner den Allgemeinbegriff bereitstellen), eine Obermenge der Vereinigung der Menge der Instanzen von Mensch und Vogel. Die Menge der Instanzen von Zweibeiner ist eine echte Obermenge, wenn Zweibeiner auch eigene Instanzen haben (also Instanzen, die nicht Instanzen von Mensch und Vogel sind; im Kontext der Instanziierung spricht man von direkten Instanzen; siehe Abschnitt 7.3). Andernfalls ist sie nur eine unechte Obermenge (genau gleich der Vereinigung). Die folgende Grafik zeigt diese Beziehung (wobei schwarze Punkte die Instanzen und Ellipsen die Klassen darstellen sollen).
In der Praxis ist es gute Praxis (wie bereits angedeutet), wenn Generalisierungen keine eigenen, direkten Instanzen haben, sondern Genera im oben beschriebenen Sinne sind. Dies ist jedoch in der objektorientierten Praxis (leider) nicht immer selbstverständlich, wie sich im nächsten Kapitel noch zeigen wird (siehe auch Kapitel 69 in Kurseinheit 7).
Die mengentheoretische Interpretation der Generalisierung als Obermengenbildung legt nahe, dass Instanzen von Mensch und Vogel (als Elemente der entsprechenden Extensionen) auch Instanzen von Zweibeiner sind. Wenn man das so betrachten möchte, sollte man jedoch zur notwendigen Unterscheidung von indirekten Instanzen (anstelle von direkten Instanzen; siehe Abschnitt 7.3) sprechen.
Bei der Generalisierung können also Eigenschaften, die verschiedene, aber ähnliche Klassen unterscheiden, weggelassen (oder ""abstrahiert"") werden. Das Weglassen ist jedoch nicht die einzige Form der Generalisierung. Es können auch Eigenschaften generalisiert werden, wobei dann der Begriff der Generalisierung rekursiv angewendet wird. Unter der Generalisierung von Attributen (oder allgemeiner von Instanzvariablen; siehe Abschnitt 2.4) versteht man, dass ihr Wertebereich von einem spezielleren (kleineren) zu einem allgemeineren (größeren) erweitert wird. Zum Beispiel würde das Attribut ""Aufenthaltsort,"" das mit (Instanzen der) Klasse Mensch assoziiert ist, bei der Generalisierung zu Zweibeiner von Punkten auf der Erdoberfläche zu Punkten einschließlich des Luftraums darüber generalisiert, um auch den Wertebereich für Vögel abzudecken. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen. Wie Sie später sehen werden, erlauben die meisten Programmiersprachen, die die Möglichkeit der Wertebeschränkung von Variablen bieten, aus guten Gründen nicht, Attributwertebereiche bei der Generalisierung ebenfalls zu generalisieren (die sogenannte kovariante Redefinition; siehe dazu auch die Kapitel 25 und Abschnitt 26.3 in Kurseinheit 3).
Obwohl bisher so getan wurde, als ob die Generalisierung eine inhärente Eigenschaft des betrachteten Objekts sei, gibt es in der Praxis oft verschiedene Perspektiven, nach denen Generalisierungen durchgeführt werden können. Die Generalisierung von Vogel und Mensch zu Zweibeiner ist also nicht die einzige (und sicherlich nicht die einzige sinnvolle) Möglichkeit. Es könnte durchaus mehrere unabhängige Generalisierungshierarchien geben, in denen dieselben Klassen auftreten. In der Praxis führt dies jedoch dazu, dass die strenge Hierarchieform der Generalisierung verloren geht (da sich mehrere Hierarchien überlappen), es sei denn, es wird erlaubt, verschiedene Arten der Generalisierung voneinander zu unterscheiden. Beide Ansätze bringen jedoch Komplikationen mit sich, daher werden wir hier nicht auf ""mehrfache Generalisierungen"" eingehen.","<answer> Die Generalisierung ermöglicht es, mehrere Klassen, deren Definitionen inhaltlich verwandt sind, zu abstrahieren und zusammenzufassen. Dies führt zur Bildung einer Generalisierungsklasse, die die gemeinsamen Eigenschaften (Instanzvariablen und Methoden) der generalisierten Klassen enthält. Die Generalisierung erlaubt es, Gemeinsamkeiten zwischen Klassen auf höherer Abstraktionsebene darzustellen und die Wiederverwendung von Code zu fördern. <answer> <question> Welche Bedeutung hat die Generalisierung in der objektorientierten Programmierung? <question>"
"Wie bereits zu Beginn erwähnt (in Abschnitt 7.1), entspricht die Klassifikation sprachlich der ""Ist-ein-Abstraktionsbeziehung"" zwischen Individuen und ihren Klassen: ""Peter ist ein Mensch,"" ""SMALLTALK ist eine Programmiersprache,"" usw. sind alles Beispiele für eine Art der Abstraktion, bei der man von einem Individuum zu seinem Allgemeinbegriff übergeht. Es gibt jedoch eine zweite Form der Ist-ein-Abstraktion, die sich von der ersten grundlegend unterscheidet, aber ebenfalls eine charakteristische Rolle in der objektorientierten Programmierung spielt: die Generalisierung. Sprachlich zeigt sich diese Form in Sätzen wie ""Ein Mensch ist ein Säugetier,"" ""Ein Säugetier ist ein Lebewesen"" oder ""Eine Programmiersprache ist ein Werkzeug."" Der Unterschied zur ersten Form der Abstraktion liegt offensichtlich darin, dass hier zwei Allgemeinbegriffe miteinander in Beziehung gesetzt werden, anstelle eines Individuums und eines Allgemeinbegriffs. Ein weiterer, etwas subtilerer, aber sehr wesentlicher Unterschied besteht darin, dass die Klassifikation nicht transitiv ist, während die Generalisierung es ist. So ergibt sich aus ""Ein Mensch ist ein Säugetier"" und ""Ein Säugetier ist ein Lebewesen"" logischerweise ""Ein Mensch ist ein Lebewesen,"" aber aus ""Peter ist ein Mensch"" und ""Mensch ist eine Art"" ergibt sich nicht ""Peter ist eine Art.""
Im Prozess der Generalisierung werden mehrere Klassen, deren Definitionen inhaltlich verwandt sind, zusammengefasst. Das Ergebnis dieser Generalisierung, auch als Generalisierungsklasse bezeichnet, enthält nur diejenigen Elemente der Definitionen der generalisierten Klassen, die allen gemeinsam sind. So lässt sich beispielsweise aus den beiden ähnlichen, aber nicht identischen Klassen Mensch und Vogel per Generalisierung die Klasse Zweibeiner herausarbeiten. Diese Klasse Zweibeiner enthält die gemeinsamen Eigenschaften (Instanzvariablen und Methoden) der Klassen Mensch und Vogel.
Da die Eigenschaften, die einer Generalisierung als Klasse zugeordnet sind, per Definition automatisch auch für alle Klassen gelten, von denen die Generalisierung abstrahiert (denn das war ja die Bedingung für die Konstruktion der Generalisierung), müssen diese Klassen die Eigenschaften nicht wiederholen, sondern nur auf ihre Generalisierung verweisen. Diese Klassen müssen dann nur noch die Unterschiede definieren, die sie von der Klasse Zweibeiner sowie voneinander unterscheiden.
Diese zweite Form der Abstraktion, die Generalisierung, ist also genau wie die Klassifikation Bestandteil der klassenbasierten objektorientierten Programmierung. Anders als bei der Klassifikation ist bei der Generalisierung jedoch die Höhe der Abstraktionshierarchie nicht durch praktische Überlegungen beschränkt, sondern kann von der Programmiererin nach Belieben festgelegt werden. Sprachphilosophisch betrachtet sind Generalisierungen ebenfalls Allgemeinbegriffe, nur noch allgemeiner. Generalisierungen können selbst wiederum Generalisierungen haben, und so weiter. Wie es für eine Abstraktionshierarchie typisch ist, werden die Definitionen, die Intensionen, dabei immer präziser. Gleichzeitig wächst jedoch die Extension (das bereits in Abschnitt 7.1 erwähnte Prinzip vom inversen Zusammenhang der beiden).
Übrigens stammt das Prinzip der Generalisierung von Aristoteles' Prinzip von Genus et differentia ab, das gemeinsame Abstammung und Unterschiede betrifft. Das Genus ist die nächst allgemeinere Kategorie, unter die die Objekte der zu generalisierenden Klassen (der Spezies) fallen, und die Differentia sind die Kriterien, anhand derer sich die Objekte aufgrund ihrer Natur unterscheiden, wie sie in den verschiedenen Klassendefinitionen festgelegt sind (und nicht etwa durch spezielle Werte von Instanzvariablen). So haben die Klassen Mensch und Vogel beispielsweise das gemeinsame Genus Zweibeiner als (biologisch nicht ganz korrekte) Generalisierung, in der festgelegt ist, dass alle Exemplare von Zweibeinern (und damit auch von Menschen und Vögeln) ein linkes und ein rechtes Bein sowie einen Aufenthaltsort haben. Die Unterschiede (Differentia) sind dann in den jeweiligen Klassen ausgearbeitet. Beachten Sie, dass Genera keine eigenen Individuen haben, das heißt, es gibt keine Zweibeiner, die nicht entweder Mensch oder Vogel sind.
Wie die Klassifikation hat auch das Ordnungsprinzip der Generalisierung eine einfache mengentheoretische Interpretation. Demnach enthält die Menge der Instanzen einer Generalisierung alle Instanzen der Klassen, von denen sie eine Generalisierung ist. Wenn also Mensch und Vogel Ausgangsklassen einer Generalisierung namens Zweibeiner sind, dann ist die Menge der Instanzen, die Zweibeiner repräsentiert (für die Zweibeiner den Allgemeinbegriff bereitstellen), eine Obermenge der Vereinigung der Menge der Instanzen von Mensch und Vogel. Die Menge der Instanzen von Zweibeiner ist eine echte Obermenge, wenn Zweibeiner auch eigene Instanzen haben (also Instanzen, die nicht Instanzen von Mensch und Vogel sind; im Kontext der Instanziierung spricht man von direkten Instanzen; siehe Abschnitt 7.3). Andernfalls ist sie nur eine unechte Obermenge (genau gleich der Vereinigung). Die folgende Grafik zeigt diese Beziehung (wobei schwarze Punkte die Instanzen und Ellipsen die Klassen darstellen sollen).
In der Praxis ist es gute Praxis (wie bereits angedeutet), wenn Generalisierungen keine eigenen, direkten Instanzen haben, sondern Genera im oben beschriebenen Sinne sind. Dies ist jedoch in der objektorientierten Praxis (leider) nicht immer selbstverständlich, wie sich im nächsten Kapitel noch zeigen wird (siehe auch Kapitel 69 in Kurseinheit 7).
Die mengentheoretische Interpretation der Generalisierung als Obermengenbildung legt nahe, dass Instanzen von Mensch und Vogel (als Elemente der entsprechenden Extensionen) auch Instanzen von Zweibeiner sind. Wenn man das so betrachten möchte, sollte man jedoch zur notwendigen Unterscheidung von indirekten Instanzen (anstelle von direkten Instanzen; siehe Abschnitt 7.3) sprechen.
Bei der Generalisierung können also Eigenschaften, die verschiedene, aber ähnliche Klassen unterscheiden, weggelassen (oder ""abstrahiert"") werden. Das Weglassen ist jedoch nicht die einzige Form der Generalisierung. Es können auch Eigenschaften generalisiert werden, wobei dann der Begriff der Generalisierung rekursiv angewendet wird. Unter der Generalisierung von Attributen (oder allgemeiner von Instanzvariablen; siehe Abschnitt 2.4) versteht man, dass ihr Wertebereich von einem spezielleren (kleineren) zu einem allgemeineren (größeren) erweitert wird. Zum Beispiel würde das Attribut ""Aufenthaltsort,"" das mit (Instanzen der) Klasse Mensch assoziiert ist, bei der Generalisierung zu Zweibeiner von Punkten auf der Erdoberfläche zu Punkten einschließlich des Luftraums darüber generalisiert, um auch den Wertebereich für Vögel abzudecken. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen. Wie Sie später sehen werden, erlauben die meisten Programmiersprachen, die die Möglichkeit der Wertebeschränkung von Variablen bieten, aus guten Gründen nicht, Attributwertebereiche bei der Generalisierung ebenfalls zu generalisieren (die sogenannte kovariante Redefinition; siehe dazu auch die Kapitel 25 und Abschnitt 26.3 in Kurseinheit 3).
Obwohl bisher so getan wurde, als ob die Generalisierung eine inhärente Eigenschaft des betrachteten Objekts sei, gibt es in der Praxis oft verschiedene Perspektiven, nach denen Generalisierungen durchgeführt werden können. Die Generalisierung von Vogel und Mensch zu Zweibeiner ist also nicht die einzige (und sicherlich nicht die einzige sinnvolle) Möglichkeit. Es könnte durchaus mehrere unabhängige Generalisierungshierarchien geben, in denen dieselben Klassen auftreten. In der Praxis führt dies jedoch dazu, dass die strenge Hierarchieform der Generalisierung verloren geht (da sich mehrere Hierarchien überlappen), es sei denn, es wird erlaubt, verschiedene Arten der Generalisierung voneinander zu unterscheiden. Beide Ansätze bringen jedoch Komplikationen mit sich, daher werden wir hier nicht auf ""mehrfache Generalisierungen"" eingehen.","<answer> Ja, die Generalisierung ist in der objektorientierten Programmierung transitiv. Wenn eine Klasse A eine Generalisierung einer Klasse B ist und Klasse B wiederum eine Generalisierung einer Klasse C ist, ergibt sich logischerweise, dass Klasse A eine Generalisierung von Klasse C ist. <answer> <question> Ist die Generalisierung in der objektorientierten Programmierung transitiv? <question>"
"Wie bereits zu Beginn erwähnt (in Abschnitt 7.1), entspricht die Klassifikation sprachlich der ""Ist-ein-Abstraktionsbeziehung"" zwischen Individuen und ihren Klassen: ""Peter ist ein Mensch,"" ""SMALLTALK ist eine Programmiersprache,"" usw. sind alles Beispiele für eine Art der Abstraktion, bei der man von einem Individuum zu seinem Allgemeinbegriff übergeht. Es gibt jedoch eine zweite Form der Ist-ein-Abstraktion, die sich von der ersten grundlegend unterscheidet, aber ebenfalls eine charakteristische Rolle in der objektorientierten Programmierung spielt: die Generalisierung. Sprachlich zeigt sich diese Form in Sätzen wie ""Ein Mensch ist ein Säugetier,"" ""Ein Säugetier ist ein Lebewesen"" oder ""Eine Programmiersprache ist ein Werkzeug."" Der Unterschied zur ersten Form der Abstraktion liegt offensichtlich darin, dass hier zwei Allgemeinbegriffe miteinander in Beziehung gesetzt werden, anstelle eines Individuums und eines Allgemeinbegriffs. Ein weiterer, etwas subtilerer, aber sehr wesentlicher Unterschied besteht darin, dass die Klassifikation nicht transitiv ist, während die Generalisierung es ist. So ergibt sich aus ""Ein Mensch ist ein Säugetier"" und ""Ein Säugetier ist ein Lebewesen"" logischerweise ""Ein Mensch ist ein Lebewesen,"" aber aus ""Peter ist ein Mensch"" und ""Mensch ist eine Art"" ergibt sich nicht ""Peter ist eine Art.""
Im Prozess der Generalisierung werden mehrere Klassen, deren Definitionen inhaltlich verwandt sind, zusammengefasst. Das Ergebnis dieser Generalisierung, auch als Generalisierungsklasse bezeichnet, enthält nur diejenigen Elemente der Definitionen der generalisierten Klassen, die allen gemeinsam sind. So lässt sich beispielsweise aus den beiden ähnlichen, aber nicht identischen Klassen Mensch und Vogel per Generalisierung die Klasse Zweibeiner herausarbeiten. Diese Klasse Zweibeiner enthält die gemeinsamen Eigenschaften (Instanzvariablen und Methoden) der Klassen Mensch und Vogel.
Da die Eigenschaften, die einer Generalisierung als Klasse zugeordnet sind, per Definition automatisch auch für alle Klassen gelten, von denen die Generalisierung abstrahiert (denn das war ja die Bedingung für die Konstruktion der Generalisierung), müssen diese Klassen die Eigenschaften nicht wiederholen, sondern nur auf ihre Generalisierung verweisen. Diese Klassen müssen dann nur noch die Unterschiede definieren, die sie von der Klasse Zweibeiner sowie voneinander unterscheiden.
Diese zweite Form der Abstraktion, die Generalisierung, ist also genau wie die Klassifikation Bestandteil der klassenbasierten objektorientierten Programmierung. Anders als bei der Klassifikation ist bei der Generalisierung jedoch die Höhe der Abstraktionshierarchie nicht durch praktische Überlegungen beschränkt, sondern kann von der Programmiererin nach Belieben festgelegt werden. Sprachphilosophisch betrachtet sind Generalisierungen ebenfalls Allgemeinbegriffe, nur noch allgemeiner. Generalisierungen können selbst wiederum Generalisierungen haben, und so weiter. Wie es für eine Abstraktionshierarchie typisch ist, werden die Definitionen, die Intensionen, dabei immer präziser. Gleichzeitig wächst jedoch die Extension (das bereits in Abschnitt 7.1 erwähnte Prinzip vom inversen Zusammenhang der beiden).
Übrigens stammt das Prinzip der Generalisierung von Aristoteles' Prinzip von Genus et differentia ab, das gemeinsame Abstammung und Unterschiede betrifft. Das Genus ist die nächst allgemeinere Kategorie, unter die die Objekte der zu generalisierenden Klassen (der Spezies) fallen, und die Differentia sind die Kriterien, anhand derer sich die Objekte aufgrund ihrer Natur unterscheiden, wie sie in den verschiedenen Klassendefinitionen festgelegt sind (und nicht etwa durch spezielle Werte von Instanzvariablen). So haben die Klassen Mensch und Vogel beispielsweise das gemeinsame Genus Zweibeiner als (biologisch nicht ganz korrekte) Generalisierung, in der festgelegt ist, dass alle Exemplare von Zweibeinern (und damit auch von Menschen und Vögeln) ein linkes und ein rechtes Bein sowie einen Aufenthaltsort haben. Die Unterschiede (Differentia) sind dann in den jeweiligen Klassen ausgearbeitet. Beachten Sie, dass Genera keine eigenen Individuen haben, das heißt, es gibt keine Zweibeiner, die nicht entweder Mensch oder Vogel sind.
Wie die Klassifikation hat auch das Ordnungsprinzip der Generalisierung eine einfache mengentheoretische Interpretation. Demnach enthält die Menge der Instanzen einer Generalisierung alle Instanzen der Klassen, von denen sie eine Generalisierung ist. Wenn also Mensch und Vogel Ausgangsklassen einer Generalisierung namens Zweibeiner sind, dann ist die Menge der Instanzen, die Zweibeiner repräsentiert (für die Zweibeiner den Allgemeinbegriff bereitstellen), eine Obermenge der Vereinigung der Menge der Instanzen von Mensch und Vogel. Die Menge der Instanzen von Zweibeiner ist eine echte Obermenge, wenn Zweibeiner auch eigene Instanzen haben (also Instanzen, die nicht Instanzen von Mensch und Vogel sind; im Kontext der Instanziierung spricht man von direkten Instanzen; siehe Abschnitt 7.3). Andernfalls ist sie nur eine unechte Obermenge (genau gleich der Vereinigung). Die folgende Grafik zeigt diese Beziehung (wobei schwarze Punkte die Instanzen und Ellipsen die Klassen darstellen sollen).
In der Praxis ist es gute Praxis (wie bereits angedeutet), wenn Generalisierungen keine eigenen, direkten Instanzen haben, sondern Genera im oben beschriebenen Sinne sind. Dies ist jedoch in der objektorientierten Praxis (leider) nicht immer selbstverständlich, wie sich im nächsten Kapitel noch zeigen wird (siehe auch Kapitel 69 in Kurseinheit 7).
Die mengentheoretische Interpretation der Generalisierung als Obermengenbildung legt nahe, dass Instanzen von Mensch und Vogel (als Elemente der entsprechenden Extensionen) auch Instanzen von Zweibeiner sind. Wenn man das so betrachten möchte, sollte man jedoch zur notwendigen Unterscheidung von indirekten Instanzen (anstelle von direkten Instanzen; siehe Abschnitt 7.3) sprechen.
Bei der Generalisierung können also Eigenschaften, die verschiedene, aber ähnliche Klassen unterscheiden, weggelassen (oder ""abstrahiert"") werden. Das Weglassen ist jedoch nicht die einzige Form der Generalisierung. Es können auch Eigenschaften generalisiert werden, wobei dann der Begriff der Generalisierung rekursiv angewendet wird. Unter der Generalisierung von Attributen (oder allgemeiner von Instanzvariablen; siehe Abschnitt 2.4) versteht man, dass ihr Wertebereich von einem spezielleren (kleineren) zu einem allgemeineren (größeren) erweitert wird. Zum Beispiel würde das Attribut ""Aufenthaltsort,"" das mit (Instanzen der) Klasse Mensch assoziiert ist, bei der Generalisierung zu Zweibeiner von Punkten auf der Erdoberfläche zu Punkten einschließlich des Luftraums darüber generalisiert, um auch den Wertebereich für Vögel abzudecken. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen. Wie Sie später sehen werden, erlauben die meisten Programmiersprachen, die die Möglichkeit der Wertebeschränkung von Variablen bieten, aus guten Gründen nicht, Attributwertebereiche bei der Generalisierung ebenfalls zu generalisieren (die sogenannte kovariante Redefinition; siehe dazu auch die Kapitel 25 und Abschnitt 26.3 in Kurseinheit 3).
Obwohl bisher so getan wurde, als ob die Generalisierung eine inhärente Eigenschaft des betrachteten Objekts sei, gibt es in der Praxis oft verschiedene Perspektiven, nach denen Generalisierungen durchgeführt werden können. Die Generalisierung von Vogel und Mensch zu Zweibeiner ist also nicht die einzige (und sicherlich nicht die einzige sinnvolle) Möglichkeit. Es könnte durchaus mehrere unabhängige Generalisierungshierarchien geben, in denen dieselben Klassen auftreten. In der Praxis führt dies jedoch dazu, dass die strenge Hierarchieform der Generalisierung verloren geht (da sich mehrere Hierarchien überlappen), es sei denn, es wird erlaubt, verschiedene Arten der Generalisierung voneinander zu unterscheiden. Beide Ansätze bringen jedoch Komplikationen mit sich, daher werden wir hier nicht auf ""mehrfache Generalisierungen"" eingehen.","<answer> In der mengentheoretischen Interpretation der Generalisierung ist die Menge der Instanzen einer Generalisierung eine Obermenge der Vereinigung der Mengen der Instanzen von generalisierten Klassen. Dies bedeutet, dass Instanzen von generalisierten Klassen auch Instanzen der Generalisierung sind. <answer> <question> Was ist die mengentheoretische Interpretation der Generalisierung? <question>"
"In JAVA, wie auch in SMALLTALK, ist vorgesehen, dass alle Klassen außer Object von bereits existierenden Klassen ableiten können. JAVA verwendet dazu das Schlüsselwort ""extends."" Dadurch wird das Bestehen einer Subklassenbeziehung zwischen B und A deklariert. Die Verwendung von ""extends"" legt nahe, dass es sich dabei um eine Typerweiterung handelt, aus der (gemäß Kapitel 23) Zuweisungskompatibilität folgt, was tatsächlich der Fall ist.
Durch die Angabe einer ""extends""-Klausel gibt eine Klasse an, von welcher anderen Klasse sie die nicht als ""static"" deklarierten Member erbt. Da die erbende Klasse, auch in JAVA als Subklasse bezeichnet, die geerbten Methoden nur invariant überschreiben darf (und geerbte Felder in ihrer Sichtbarkeit nicht reduziert werden dürfen; s. Abschnitt 39.1), ist ihr Typ automatisch ein Subtyp des Typs der Klasse, von der sie erbt.
Wie in SMALLTALK gibt es in JAVA abstrakte Klassen. Anders als in SMALLTALK verwendet JAVA jedoch das Schlüsselwort ""abstract,"" mit dem man eine Klasse als abstrakt und damit als nicht instanziierbar deklarieren kann.
Das bedeutet, dass von einer solchen Klasse keine Instanzen mehr gebildet werden dürfen (vgl. Abschnitt 10.3). Dieses Verbot, dessen Einhaltung vom Compiler überprüft wird, gilt unabhängig davon, ob von der Klasse Instanzen erstellt werden könnten. Selbst wenn alles, was für das Funktionieren der Instanzen benötigt wird, in der Klasse vorhanden ist (einschließlich Konstruktoren), darf sie nicht instanziiert werden. Häufiger fehlt jedoch in der Klasse die Implementierung von einer oder mehreren (bis hin zu allen) benötigten Methoden. Diese Methoden werden dann in der Klasse lediglich deklariert, und zwar ebenfalls mit dem Schlüsselwort ""abstract.""
Man gibt dann hinter der Methodensignatur (also dem Namen und den Parametern) keine Implementierung (in geschweiften Klammern) an, sondern lediglich ein abschließendes Semikolon. Im Gegensatz dazu muss in SMALLTALK eine abstrakte Methode durch einen Aufruf von ""implementedBySubclass"" o. ä. gekennzeichnet werden (s. Abschnitt 10.3 in Kurseinheit 2).
Die Aufforderung, eine abstrakte Methode in einer Subklasse zu implementieren, gibt es in JAVA ebenfalls, jedoch nicht als Laufzeitfehler auf der Programmausführungsebene, sondern auf der Compiler-Ebene. Wenn man von einer abstrakten Klasse (per ""extends"") ableitet, dann muss die abgeleitete Klasse entweder selbst als abstrakt deklariert sein, oder man muss alle abstrakten Methoden der Klasse, von der sie ableitet, mit Implementierungen versehen. Tut man das nicht, erhält man vom Compiler eine entsprechende Aufforderung.
Komplementär zur ""abstract""-Deklaration gibt es in JAVA auch die Möglichkeit, zu verhindern, dass von einer Klasse abgeleitet wird. Man verwendet dafür einfach das Schlüsselwort ""final."" Das Gleiche gilt für einzelne Methoden, deren Überschreiben in einer Subklasse durch eine ""final""-Deklaration verhindert werden kann. Eine einfache, goldene Regel der objektorientierten Programmierung besagt übrigens, dass man alle Klassen entweder als abstrakt oder als final deklarieren sollte. Dies fördert das Prinzip der abstrakten Generalisierung und vermeidet die Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien (Kapitel 9 in Kurseinheit 2 und 69 in Kurseinheit 6).","<answer> JAVA verwendet das Schlüsselwort ""extends,"" um die Bestehen einer Subklassenbeziehung zwischen zwei Klassen zu deklarieren. <answer> <question> Welches Schlüsselwort verwendet JAVA, um die Bestehen einer Subklassenbeziehung zwischen zwei Klassen zu deklarieren? <question>"
"In JAVA, wie auch in SMALLTALK, ist vorgesehen, dass alle Klassen außer Object von bereits existierenden Klassen ableiten können. JAVA verwendet dazu das Schlüsselwort ""extends."" Dadurch wird das Bestehen einer Subklassenbeziehung zwischen B und A deklariert. Die Verwendung von ""extends"" legt nahe, dass es sich dabei um eine Typerweiterung handelt, aus der (gemäß Kapitel 23) Zuweisungskompatibilität folgt, was tatsächlich der Fall ist.
Durch die Angabe einer ""extends""-Klausel gibt eine Klasse an, von welcher anderen Klasse sie die nicht als ""static"" deklarierten Member erbt. Da die erbende Klasse, auch in JAVA als Subklasse bezeichnet, die geerbten Methoden nur invariant überschreiben darf (und geerbte Felder in ihrer Sichtbarkeit nicht reduziert werden dürfen; s. Abschnitt 39.1), ist ihr Typ automatisch ein Subtyp des Typs der Klasse, von der sie erbt.
Wie in SMALLTALK gibt es in JAVA abstrakte Klassen. Anders als in SMALLTALK verwendet JAVA jedoch das Schlüsselwort ""abstract,"" mit dem man eine Klasse als abstrakt und damit als nicht instanziierbar deklarieren kann.
Das bedeutet, dass von einer solchen Klasse keine Instanzen mehr gebildet werden dürfen (vgl. Abschnitt 10.3). Dieses Verbot, dessen Einhaltung vom Compiler überprüft wird, gilt unabhängig davon, ob von der Klasse Instanzen erstellt werden könnten. Selbst wenn alles, was für das Funktionieren der Instanzen benötigt wird, in der Klasse vorhanden ist (einschließlich Konstruktoren), darf sie nicht instanziiert werden. Häufiger fehlt jedoch in der Klasse die Implementierung von einer oder mehreren (bis hin zu allen) benötigten Methoden. Diese Methoden werden dann in der Klasse lediglich deklariert, und zwar ebenfalls mit dem Schlüsselwort ""abstract.""
Man gibt dann hinter der Methodensignatur (also dem Namen und den Parametern) keine Implementierung (in geschweiften Klammern) an, sondern lediglich ein abschließendes Semikolon. Im Gegensatz dazu muss in SMALLTALK eine abstrakte Methode durch einen Aufruf von ""implementedBySubclass"" o. ä. gekennzeichnet werden (s. Abschnitt 10.3 in Kurseinheit 2).
Die Aufforderung, eine abstrakte Methode in einer Subklasse zu implementieren, gibt es in JAVA ebenfalls, jedoch nicht als Laufzeitfehler auf der Programmausführungsebene, sondern auf der Compiler-Ebene. Wenn man von einer abstrakten Klasse (per ""extends"") ableitet, dann muss die abgeleitete Klasse entweder selbst als abstrakt deklariert sein, oder man muss alle abstrakten Methoden der Klasse, von der sie ableitet, mit Implementierungen versehen. Tut man das nicht, erhält man vom Compiler eine entsprechende Aufforderung.
Komplementär zur ""abstract""-Deklaration gibt es in JAVA auch die Möglichkeit, zu verhindern, dass von einer Klasse abgeleitet wird. Man verwendet dafür einfach das Schlüsselwort ""final."" Das Gleiche gilt für einzelne Methoden, deren Überschreiben in einer Subklasse durch eine ""final""-Deklaration verhindert werden kann. Eine einfache, goldene Regel der objektorientierten Programmierung besagt übrigens, dass man alle Klassen entweder als abstrakt oder als final deklarieren sollte. Dies fördert das Prinzip der abstrakten Generalisierung und vermeidet die Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien (Kapitel 9 in Kurseinheit 2 und 69 in Kurseinheit 6).","<answer> Wenn eine Klasse in JAVA als abstrakt deklariert wird, bedeutet dies, dass sie nicht instanziierbar ist. Es können keine Objekte dieser Klasse erstellt werden. <answer> <question> Was bedeutet es, wenn eine Klasse in JAVA als abstrakt deklariert wird? <question>"
"In JAVA, wie auch in SMALLTALK, ist vorgesehen, dass alle Klassen außer Object von bereits existierenden Klassen ableiten können. JAVA verwendet dazu das Schlüsselwort ""extends."" Dadurch wird das Bestehen einer Subklassenbeziehung zwischen B und A deklariert. Die Verwendung von ""extends"" legt nahe, dass es sich dabei um eine Typerweiterung handelt, aus der (gemäß Kapitel 23) Zuweisungskompatibilität folgt, was tatsächlich der Fall ist.
Durch die Angabe einer ""extends""-Klausel gibt eine Klasse an, von welcher anderen Klasse sie die nicht als ""static"" deklarierten Member erbt. Da die erbende Klasse, auch in JAVA als Subklasse bezeichnet, die geerbten Methoden nur invariant überschreiben darf (und geerbte Felder in ihrer Sichtbarkeit nicht reduziert werden dürfen; s. Abschnitt 39.1), ist ihr Typ automatisch ein Subtyp des Typs der Klasse, von der sie erbt.
Wie in SMALLTALK gibt es in JAVA abstrakte Klassen. Anders als in SMALLTALK verwendet JAVA jedoch das Schlüsselwort ""abstract,"" mit dem man eine Klasse als abstrakt und damit als nicht instanziierbar deklarieren kann.
Das bedeutet, dass von einer solchen Klasse keine Instanzen mehr gebildet werden dürfen (vgl. Abschnitt 10.3). Dieses Verbot, dessen Einhaltung vom Compiler überprüft wird, gilt unabhängig davon, ob von der Klasse Instanzen erstellt werden könnten. Selbst wenn alles, was für das Funktionieren der Instanzen benötigt wird, in der Klasse vorhanden ist (einschließlich Konstruktoren), darf sie nicht instanziiert werden. Häufiger fehlt jedoch in der Klasse die Implementierung von einer oder mehreren (bis hin zu allen) benötigten Methoden. Diese Methoden werden dann in der Klasse lediglich deklariert, und zwar ebenfalls mit dem Schlüsselwort ""abstract.""
Man gibt dann hinter der Methodensignatur (also dem Namen und den Parametern) keine Implementierung (in geschweiften Klammern) an, sondern lediglich ein abschließendes Semikolon. Im Gegensatz dazu muss in SMALLTALK eine abstrakte Methode durch einen Aufruf von ""implementedBySubclass"" o. ä. gekennzeichnet werden (s. Abschnitt 10.3 in Kurseinheit 2).
Die Aufforderung, eine abstrakte Methode in einer Subklasse zu implementieren, gibt es in JAVA ebenfalls, jedoch nicht als Laufzeitfehler auf der Programmausführungsebene, sondern auf der Compiler-Ebene. Wenn man von einer abstrakten Klasse (per ""extends"") ableitet, dann muss die abgeleitete Klasse entweder selbst als abstrakt deklariert sein, oder man muss alle abstrakten Methoden der Klasse, von der sie ableitet, mit Implementierungen versehen. Tut man das nicht, erhält man vom Compiler eine entsprechende Aufforderung.
Komplementär zur ""abstract""-Deklaration gibt es in JAVA auch die Möglichkeit, zu verhindern, dass von einer Klasse abgeleitet wird. Man verwendet dafür einfach das Schlüsselwort ""final."" Das Gleiche gilt für einzelne Methoden, deren Überschreiben in einer Subklasse durch eine ""final""-Deklaration verhindert werden kann. Eine einfache, goldene Regel der objektorientierten Programmierung besagt übrigens, dass man alle Klassen entweder als abstrakt oder als final deklarieren sollte. Dies fördert das Prinzip der abstrakten Generalisierung und vermeidet die Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien (Kapitel 9 in Kurseinheit 2 und 69 in Kurseinheit 6).","<answer> Abstrakte Methoden in JAVA werden deklariert, indem man hinter der Methodensignatur ein abschließendes Semikolon setzt, anstatt eine Implementierung anzugeben. In Subklassen müssen abstrakte Methoden mit Implementierungen versehen werden, andernfalls gibt der Compiler eine Fehlermeldung aus. <answer> <question> Wie werden abstrakte Methoden in JAVA deklariert, und wie werden sie in Subklassen implementiert? <question>"
"In JAVA, wie auch in SMALLTALK, ist vorgesehen, dass alle Klassen außer Object von bereits existierenden Klassen ableiten können. JAVA verwendet dazu das Schlüsselwort ""extends."" Dadurch wird das Bestehen einer Subklassenbeziehung zwischen B und A deklariert. Die Verwendung von ""extends"" legt nahe, dass es sich dabei um eine Typerweiterung handelt, aus der (gemäß Kapitel 23) Zuweisungskompatibilität folgt, was tatsächlich der Fall ist.
Durch die Angabe einer ""extends""-Klausel gibt eine Klasse an, von welcher anderen Klasse sie die nicht als ""static"" deklarierten Member erbt. Da die erbende Klasse, auch in JAVA als Subklasse bezeichnet, die geerbten Methoden nur invariant überschreiben darf (und geerbte Felder in ihrer Sichtbarkeit nicht reduziert werden dürfen; s. Abschnitt 39.1), ist ihr Typ automatisch ein Subtyp des Typs der Klasse, von der sie erbt.
Wie in SMALLTALK gibt es in JAVA abstrakte Klassen. Anders als in SMALLTALK verwendet JAVA jedoch das Schlüsselwort ""abstract,"" mit dem man eine Klasse als abstrakt und damit als nicht instanziierbar deklarieren kann.
Das bedeutet, dass von einer solchen Klasse keine Instanzen mehr gebildet werden dürfen (vgl. Abschnitt 10.3). Dieses Verbot, dessen Einhaltung vom Compiler überprüft wird, gilt unabhängig davon, ob von der Klasse Instanzen erstellt werden könnten. Selbst wenn alles, was für das Funktionieren der Instanzen benötigt wird, in der Klasse vorhanden ist (einschließlich Konstruktoren), darf sie nicht instanziiert werden. Häufiger fehlt jedoch in der Klasse die Implementierung von einer oder mehreren (bis hin zu allen) benötigten Methoden. Diese Methoden werden dann in der Klasse lediglich deklariert, und zwar ebenfalls mit dem Schlüsselwort ""abstract.""
Man gibt dann hinter der Methodensignatur (also dem Namen und den Parametern) keine Implementierung (in geschweiften Klammern) an, sondern lediglich ein abschließendes Semikolon. Im Gegensatz dazu muss in SMALLTALK eine abstrakte Methode durch einen Aufruf von ""implementedBySubclass"" o. ä. gekennzeichnet werden (s. Abschnitt 10.3 in Kurseinheit 2).
Die Aufforderung, eine abstrakte Methode in einer Subklasse zu implementieren, gibt es in JAVA ebenfalls, jedoch nicht als Laufzeitfehler auf der Programmausführungsebene, sondern auf der Compiler-Ebene. Wenn man von einer abstrakten Klasse (per ""extends"") ableitet, dann muss die abgeleitete Klasse entweder selbst als abstrakt deklariert sein, oder man muss alle abstrakten Methoden der Klasse, von der sie ableitet, mit Implementierungen versehen. Tut man das nicht, erhält man vom Compiler eine entsprechende Aufforderung.
Komplementär zur ""abstract""-Deklaration gibt es in JAVA auch die Möglichkeit, zu verhindern, dass von einer Klasse abgeleitet wird. Man verwendet dafür einfach das Schlüsselwort ""final."" Das Gleiche gilt für einzelne Methoden, deren Überschreiben in einer Subklasse durch eine ""final""-Deklaration verhindert werden kann. Eine einfache, goldene Regel der objektorientierten Programmierung besagt übrigens, dass man alle Klassen entweder als abstrakt oder als final deklarieren sollte. Dies fördert das Prinzip der abstrakten Generalisierung und vermeidet die Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien (Kapitel 9 in Kurseinheit 2 und 69 in Kurseinheit 6).","<answer> In JAVA kann verhindert werden, dass von einer Klasse abgeleitet wird, indem man das Schlüsselwort ""final"" vor der Klassendefinition verwendet. <answer> <question> Wie kann in JAVA verhindert werden, dass von einer Klasse abgeleitet wird? <question>"
"In JAVA, wie auch in SMALLTALK, ist vorgesehen, dass alle Klassen außer Object von bereits existierenden Klassen ableiten können. JAVA verwendet dazu das Schlüsselwort ""extends."" Dadurch wird das Bestehen einer Subklassenbeziehung zwischen B und A deklariert. Die Verwendung von ""extends"" legt nahe, dass es sich dabei um eine Typerweiterung handelt, aus der (gemäß Kapitel 23) Zuweisungskompatibilität folgt, was tatsächlich der Fall ist.
Durch die Angabe einer ""extends""-Klausel gibt eine Klasse an, von welcher anderen Klasse sie die nicht als ""static"" deklarierten Member erbt. Da die erbende Klasse, auch in JAVA als Subklasse bezeichnet, die geerbten Methoden nur invariant überschreiben darf (und geerbte Felder in ihrer Sichtbarkeit nicht reduziert werden dürfen; s. Abschnitt 39.1), ist ihr Typ automatisch ein Subtyp des Typs der Klasse, von der sie erbt.
Wie in SMALLTALK gibt es in JAVA abstrakte Klassen. Anders als in SMALLTALK verwendet JAVA jedoch das Schlüsselwort ""abstract,"" mit dem man eine Klasse als abstrakt und damit als nicht instanziierbar deklarieren kann.
Das bedeutet, dass von einer solchen Klasse keine Instanzen mehr gebildet werden dürfen (vgl. Abschnitt 10.3). Dieses Verbot, dessen Einhaltung vom Compiler überprüft wird, gilt unabhängig davon, ob von der Klasse Instanzen erstellt werden könnten. Selbst wenn alles, was für das Funktionieren der Instanzen benötigt wird, in der Klasse vorhanden ist (einschließlich Konstruktoren), darf sie nicht instanziiert werden. Häufiger fehlt jedoch in der Klasse die Implementierung von einer oder mehreren (bis hin zu allen) benötigten Methoden. Diese Methoden werden dann in der Klasse lediglich deklariert, und zwar ebenfalls mit dem Schlüsselwort ""abstract.""
Man gibt dann hinter der Methodensignatur (also dem Namen und den Parametern) keine Implementierung (in geschweiften Klammern) an, sondern lediglich ein abschließendes Semikolon. Im Gegensatz dazu muss in SMALLTALK eine abstrakte Methode durch einen Aufruf von ""implementedBySubclass"" o. ä. gekennzeichnet werden (s. Abschnitt 10.3 in Kurseinheit 2).
Die Aufforderung, eine abstrakte Methode in einer Subklasse zu implementieren, gibt es in JAVA ebenfalls, jedoch nicht als Laufzeitfehler auf der Programmausführungsebene, sondern auf der Compiler-Ebene. Wenn man von einer abstrakten Klasse (per ""extends"") ableitet, dann muss die abgeleitete Klasse entweder selbst als abstrakt deklariert sein, oder man muss alle abstrakten Methoden der Klasse, von der sie ableitet, mit Implementierungen versehen. Tut man das nicht, erhält man vom Compiler eine entsprechende Aufforderung.
Komplementär zur ""abstract""-Deklaration gibt es in JAVA auch die Möglichkeit, zu verhindern, dass von einer Klasse abgeleitet wird. Man verwendet dafür einfach das Schlüsselwort ""final."" Das Gleiche gilt für einzelne Methoden, deren Überschreiben in einer Subklasse durch eine ""final""-Deklaration verhindert werden kann. Eine einfache, goldene Regel der objektorientierten Programmierung besagt übrigens, dass man alle Klassen entweder als abstrakt oder als final deklarieren sollte. Dies fördert das Prinzip der abstrakten Generalisierung und vermeidet die Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien (Kapitel 9 in Kurseinheit 2 und 69 in Kurseinheit 6).","<answer> Es ist eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren, um das Prinzip der abstrakten Generalisierung zu fördern und Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien zu vermeiden. <answer> <question> Warum ist es eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren? <question>"
"Durch die Zuordnung von Individuen oder Objekten zu Allgemeinbegriffen oder Klassen findet eine Klassifikation statt. Diese Klassifikation erlaubt eine Ordnung oder Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen nur noch für die Klassen getroffen werden müssen und nicht mehr für jedes einzelne Objekt. Anstatt also, wie in der vorangegangenen Kurseinheit, Instanzvariablen und Methoden direkt Objekten zuzuordnen, verbindet man sie mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse gehören, beschreiben.
In diesem Zusammenhang ist es sinnvoll, die Unterscheidung von Extension und Intension eines Begriffs ins Spiel zu bringen. Unter der Extension (Ausdehnung oder Erstreckung) eines (Allgemein-)Begriffs versteht man die Menge der Objekte, die darunterfallen. Im Fall von ""Person"" etwa ist das die Menge aller Personen, im Fall von ""Dokument"" die Menge aller Dokumente. Die Intension (nicht zu verwechseln mit Intention!) eines (Allgemein-)Begriffs hingegen ist die Summe der Merkmale, die den Begriff ausmachen und die die Objekte, die darunter fallen, charakterisieren. Sie ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die zu einem beliebigen Element entscheidet, ob es unter den Begriff fällt. Schon Aristoteles fiel auf, dass Intension und Extension in einem inversen Größenverhältnis zueinander stehen: Mit wachsender Intension schrumpft die Extension und umgekehrt. Dies ist freilich nicht weiter verwunderlich: Je umfangreicher die Charakterisierung einer Menge von Objekten ist, d.h., je strenger die Bedingungen sind, die ein Objekt erfüllen muss, um dazuzugehören, desto weniger Objekte erfüllen diese Bedingungen, und desto kleiner ist entsprechend die Menge. Wir werden in Kapitel 9 noch einmal darauf zurückkommen.
Allgemeinbegriffe sind die Vorbilder für Klassen in der objektorientierten Programmierung. Interessanterweise bildet eine wichtige philosophische Abweichung vom Glauben an die Adäquatheit von Allgemeinbegriffen, die Idee der Familienähnlichkeiten, wie sie von Ludwig Wittgenstein in seiner späten Philosophie entworfen wurde, die Grundlage für die schon erwähnte Alternative zu den Klassen, nämlich die Prototypen. Die Idee Wittgensteins, wie auch der prototypenbasierten Programmierung, ist, dass ein Allgemeinbegriff (eine Klasse) niemals eine adäquate Beschreibung aller Individuen (Objekte) sein kann, die man mit dem Begriff verbindet. Wittgenstein verwendet dafür das Beispiel vom ""Spiel"": Auch wenn es Spiele gibt, die einander stark ähneln, so ist der Begriff vom ""Spiel"" doch nicht so scharf gefasst, dass es eine Grenze gäbe, innerhalb derer etwas ein Spiel wie alle anderen, außerhalb derer es aber kein Spiel mehr ist. Vielmehr gibt es, nach Wittgenstein, mehr oder weniger ""spielhafte"" Spiele, also prototypische Spiele und solche, die diesen mehr oder weniger gleichen.
Zwar gibt es Anwendungsdomänen, in denen Wittgensteins Familienähnlichkeiten die Sachlage besser beschreiben als die traditionellen Allgemeinbegriffe (man denke z.B. an Musik, in der es zwar Töne und Noten gibt, aber dennoch zwei Töne selten genau gleich klingen sollen und die Notenzeichen entsprechend vielfältig variieren), aber insgesamt sind die üblichen Anwendungen doch eher der Natur, dass es von einigen wenigen Sorten eine große Menge von Objekten gibt, die alle mehr oder weniger gleich zu behandeln sind. Und so vereinfachen Allgemeinbegriffe oder Klassen unsere Weltsicht ganz erheblich und damit auch die Programme, die wir schreiben, um unsere Weltsicht zu reflektieren.
Nachdem wir uns also auf Klassen festgelegt haben, können wir nun endlich zur Lüftung des Geheimnisses kommen, wo in einem SMALLTALK-Programm die Instanzvariablen und Methoden, die Objekte ihr eigen nennen, vereinbart (deklariert) und im Falle der Methoden auch definiert (mit Inhalt versehen) werden: in Klassen.","<answer> In SMALLTALK findet eine Klassifikation statt, indem Individuen oder Objekte bestimmten Allgemeinbegriffen oder Klassen zugeordnet werden. Diese Klassifikation ermöglicht eine Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen und Eigenschaften nur noch für die Klassen im Allgemeinen getroffen werden müssen, anstatt für jedes einzelne Objekt. Statt also Eigenschaften und Methoden direkt Objekten zuzuweisen, verbindet man sie mit Klassen und legt fest, dass sie die einzelnen Objekte, die zu dieser Klasse gehören, beschreiben. <answer> <question> Was versteht man unter Klassifikation in SMALLTALK? <question>"
"Durch die Zuordnung von Individuen oder Objekten zu Allgemeinbegriffen oder Klassen findet eine Klassifikation statt. Diese Klassifikation erlaubt eine Ordnung oder Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen nur noch für die Klassen getroffen werden müssen und nicht mehr für jedes einzelne Objekt. Anstatt also, wie in der vorangegangenen Kurseinheit, Instanzvariablen und Methoden direkt Objekten zuzuordnen, verbindet man sie mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse gehören, beschreiben.
In diesem Zusammenhang ist es sinnvoll, die Unterscheidung von Extension und Intension eines Begriffs ins Spiel zu bringen. Unter der Extension (Ausdehnung oder Erstreckung) eines (Allgemein-)Begriffs versteht man die Menge der Objekte, die darunterfallen. Im Fall von ""Person"" etwa ist das die Menge aller Personen, im Fall von ""Dokument"" die Menge aller Dokumente. Die Intension (nicht zu verwechseln mit Intention!) eines (Allgemein-)Begriffs hingegen ist die Summe der Merkmale, die den Begriff ausmachen und die die Objekte, die darunter fallen, charakterisieren. Sie ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die zu einem beliebigen Element entscheidet, ob es unter den Begriff fällt. Schon Aristoteles fiel auf, dass Intension und Extension in einem inversen Größenverhältnis zueinander stehen: Mit wachsender Intension schrumpft die Extension und umgekehrt. Dies ist freilich nicht weiter verwunderlich: Je umfangreicher die Charakterisierung einer Menge von Objekten ist, d.h., je strenger die Bedingungen sind, die ein Objekt erfüllen muss, um dazuzugehören, desto weniger Objekte erfüllen diese Bedingungen, und desto kleiner ist entsprechend die Menge. Wir werden in Kapitel 9 noch einmal darauf zurückkommen.
Allgemeinbegriffe sind die Vorbilder für Klassen in der objektorientierten Programmierung. Interessanterweise bildet eine wichtige philosophische Abweichung vom Glauben an die Adäquatheit von Allgemeinbegriffen, die Idee der Familienähnlichkeiten, wie sie von Ludwig Wittgenstein in seiner späten Philosophie entworfen wurde, die Grundlage für die schon erwähnte Alternative zu den Klassen, nämlich die Prototypen. Die Idee Wittgensteins, wie auch der prototypenbasierten Programmierung, ist, dass ein Allgemeinbegriff (eine Klasse) niemals eine adäquate Beschreibung aller Individuen (Objekte) sein kann, die man mit dem Begriff verbindet. Wittgenstein verwendet dafür das Beispiel vom ""Spiel"": Auch wenn es Spiele gibt, die einander stark ähneln, so ist der Begriff vom ""Spiel"" doch nicht so scharf gefasst, dass es eine Grenze gäbe, innerhalb derer etwas ein Spiel wie alle anderen, außerhalb derer es aber kein Spiel mehr ist. Vielmehr gibt es, nach Wittgenstein, mehr oder weniger ""spielhafte"" Spiele, also prototypische Spiele und solche, die diesen mehr oder weniger gleichen.
Zwar gibt es Anwendungsdomänen, in denen Wittgensteins Familienähnlichkeiten die Sachlage besser beschreiben als die traditionellen Allgemeinbegriffe (man denke z.B. an Musik, in der es zwar Töne und Noten gibt, aber dennoch zwei Töne selten genau gleich klingen sollen und die Notenzeichen entsprechend vielfältig variieren), aber insgesamt sind die üblichen Anwendungen doch eher der Natur, dass es von einigen wenigen Sorten eine große Menge von Objekten gibt, die alle mehr oder weniger gleich zu behandeln sind. Und so vereinfachen Allgemeinbegriffe oder Klassen unsere Weltsicht ganz erheblich und damit auch die Programme, die wir schreiben, um unsere Weltsicht zu reflektieren.
Nachdem wir uns also auf Klassen festgelegt haben, können wir nun endlich zur Lüftung des Geheimnisses kommen, wo in einem SMALLTALK-Programm die Instanzvariablen und Methoden, die Objekte ihr eigen nennen, vereinbart (deklariert) und im Falle der Methoden auch definiert (mit Inhalt versehen) werden: in Klassen.","<answer> In Bezug auf einen Begriff oder eine Klasse: Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören. Zum Beispiel ist die Extension von ""Person"" die Menge aller Personen. Oder: Die Intension ist die Summe der Merkmale oder Eigenschaften, die den Begriff ausmachen und die die Objekte charakterisieren, die zu dieser Klasse gehören. Die Intension ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die entscheidet, ob ein beliebiges Element unter den Begriff fällt. Mit steigender Intension wird die Extension kleiner, und umgekehrt. <answer> <question> Was ist der Unterschied zwischen Extension und Intension eines Begriffs? <question>"
"Durch die Zuordnung von Individuen oder Objekten zu Allgemeinbegriffen oder Klassen findet eine Klassifikation statt. Diese Klassifikation erlaubt eine Ordnung oder Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen nur noch für die Klassen getroffen werden müssen und nicht mehr für jedes einzelne Objekt. Anstatt also, wie in der vorangegangenen Kurseinheit, Instanzvariablen und Methoden direkt Objekten zuzuordnen, verbindet man sie mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse gehören, beschreiben.
In diesem Zusammenhang ist es sinnvoll, die Unterscheidung von Extension und Intension eines Begriffs ins Spiel zu bringen. Unter der Extension (Ausdehnung oder Erstreckung) eines (Allgemein-)Begriffs versteht man die Menge der Objekte, die darunterfallen. Im Fall von ""Person"" etwa ist das die Menge aller Personen, im Fall von ""Dokument"" die Menge aller Dokumente. Die Intension (nicht zu verwechseln mit Intention!) eines (Allgemein-)Begriffs hingegen ist die Summe der Merkmale, die den Begriff ausmachen und die die Objekte, die darunter fallen, charakterisieren. Sie ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die zu einem beliebigen Element entscheidet, ob es unter den Begriff fällt. Schon Aristoteles fiel auf, dass Intension und Extension in einem inversen Größenverhältnis zueinander stehen: Mit wachsender Intension schrumpft die Extension und umgekehrt. Dies ist freilich nicht weiter verwunderlich: Je umfangreicher die Charakterisierung einer Menge von Objekten ist, d.h., je strenger die Bedingungen sind, die ein Objekt erfüllen muss, um dazuzugehören, desto weniger Objekte erfüllen diese Bedingungen, und desto kleiner ist entsprechend die Menge. Wir werden in Kapitel 9 noch einmal darauf zurückkommen.
Allgemeinbegriffe sind die Vorbilder für Klassen in der objektorientierten Programmierung. Interessanterweise bildet eine wichtige philosophische Abweichung vom Glauben an die Adäquatheit von Allgemeinbegriffen, die Idee der Familienähnlichkeiten, wie sie von Ludwig Wittgenstein in seiner späten Philosophie entworfen wurde, die Grundlage für die schon erwähnte Alternative zu den Klassen, nämlich die Prototypen. Die Idee Wittgensteins, wie auch der prototypenbasierten Programmierung, ist, dass ein Allgemeinbegriff (eine Klasse) niemals eine adäquate Beschreibung aller Individuen (Objekte) sein kann, die man mit dem Begriff verbindet. Wittgenstein verwendet dafür das Beispiel vom ""Spiel"": Auch wenn es Spiele gibt, die einander stark ähneln, so ist der Begriff vom ""Spiel"" doch nicht so scharf gefasst, dass es eine Grenze gäbe, innerhalb derer etwas ein Spiel wie alle anderen, außerhalb derer es aber kein Spiel mehr ist. Vielmehr gibt es, nach Wittgenstein, mehr oder weniger ""spielhafte"" Spiele, also prototypische Spiele und solche, die diesen mehr oder weniger gleichen.
Zwar gibt es Anwendungsdomänen, in denen Wittgensteins Familienähnlichkeiten die Sachlage besser beschreiben als die traditionellen Allgemeinbegriffe (man denke z.B. an Musik, in der es zwar Töne und Noten gibt, aber dennoch zwei Töne selten genau gleich klingen sollen und die Notenzeichen entsprechend vielfältig variieren), aber insgesamt sind die üblichen Anwendungen doch eher der Natur, dass es von einigen wenigen Sorten eine große Menge von Objekten gibt, die alle mehr oder weniger gleich zu behandeln sind. Und so vereinfachen Allgemeinbegriffe oder Klassen unsere Weltsicht ganz erheblich und damit auch die Programme, die wir schreiben, um unsere Weltsicht zu reflektieren.
Nachdem wir uns also auf Klassen festgelegt haben, können wir nun endlich zur Lüftung des Geheimnisses kommen, wo in einem SMALLTALK-Programm die Instanzvariablen und Methoden, die Objekte ihr eigen nennen, vereinbart (deklariert) und im Falle der Methoden auch definiert (mit Inhalt versehen) werden: in Klassen.","<answer> In SMALLTALK werden Allgemeinbegriffe in Form von Klassen repräsentiert. Klassen sind die Vorbilder für Objekte in der objektorientierten Programmierung. Jede Klasse kann Instanzvariablen und Methoden haben, die das Verhalten und die Eigenschaften der Objekte beschreiben, die zu dieser Klasse gehören. <answer> <question> Wie werden Allgemeinbegriffe in SMALLTALK repräsentiert? <question>"
"Durch die Zuordnung von Individuen oder Objekten zu Allgemeinbegriffen oder Klassen findet eine Klassifikation statt. Diese Klassifikation erlaubt eine Ordnung oder Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen nur noch für die Klassen getroffen werden müssen und nicht mehr für jedes einzelne Objekt. Anstatt also, wie in der vorangegangenen Kurseinheit, Instanzvariablen und Methoden direkt Objekten zuzuordnen, verbindet man sie mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse gehören, beschreiben.
In diesem Zusammenhang ist es sinnvoll, die Unterscheidung von Extension und Intension eines Begriffs ins Spiel zu bringen. Unter der Extension (Ausdehnung oder Erstreckung) eines (Allgemein-)Begriffs versteht man die Menge der Objekte, die darunterfallen. Im Fall von ""Person"" etwa ist das die Menge aller Personen, im Fall von ""Dokument"" die Menge aller Dokumente. Die Intension (nicht zu verwechseln mit Intention!) eines (Allgemein-)Begriffs hingegen ist die Summe der Merkmale, die den Begriff ausmachen und die die Objekte, die darunter fallen, charakterisieren. Sie ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die zu einem beliebigen Element entscheidet, ob es unter den Begriff fällt. Schon Aristoteles fiel auf, dass Intension und Extension in einem inversen Größenverhältnis zueinander stehen: Mit wachsender Intension schrumpft die Extension und umgekehrt. Dies ist freilich nicht weiter verwunderlich: Je umfangreicher die Charakterisierung einer Menge von Objekten ist, d.h., je strenger die Bedingungen sind, die ein Objekt erfüllen muss, um dazuzugehören, desto weniger Objekte erfüllen diese Bedingungen, und desto kleiner ist entsprechend die Menge. Wir werden in Kapitel 9 noch einmal darauf zurückkommen.
Allgemeinbegriffe sind die Vorbilder für Klassen in der objektorientierten Programmierung. Interessanterweise bildet eine wichtige philosophische Abweichung vom Glauben an die Adäquatheit von Allgemeinbegriffen, die Idee der Familienähnlichkeiten, wie sie von Ludwig Wittgenstein in seiner späten Philosophie entworfen wurde, die Grundlage für die schon erwähnte Alternative zu den Klassen, nämlich die Prototypen. Die Idee Wittgensteins, wie auch der prototypenbasierten Programmierung, ist, dass ein Allgemeinbegriff (eine Klasse) niemals eine adäquate Beschreibung aller Individuen (Objekte) sein kann, die man mit dem Begriff verbindet. Wittgenstein verwendet dafür das Beispiel vom ""Spiel"": Auch wenn es Spiele gibt, die einander stark ähneln, so ist der Begriff vom ""Spiel"" doch nicht so scharf gefasst, dass es eine Grenze gäbe, innerhalb derer etwas ein Spiel wie alle anderen, außerhalb derer es aber kein Spiel mehr ist. Vielmehr gibt es, nach Wittgenstein, mehr oder weniger ""spielhafte"" Spiele, also prototypische Spiele und solche, die diesen mehr oder weniger gleichen.
Zwar gibt es Anwendungsdomänen, in denen Wittgensteins Familienähnlichkeiten die Sachlage besser beschreiben als die traditionellen Allgemeinbegriffe (man denke z.B. an Musik, in der es zwar Töne und Noten gibt, aber dennoch zwei Töne selten genau gleich klingen sollen und die Notenzeichen entsprechend vielfältig variieren), aber insgesamt sind die üblichen Anwendungen doch eher der Natur, dass es von einigen wenigen Sorten eine große Menge von Objekten gibt, die alle mehr oder weniger gleich zu behandeln sind. Und so vereinfachen Allgemeinbegriffe oder Klassen unsere Weltsicht ganz erheblich und damit auch die Programme, die wir schreiben, um unsere Weltsicht zu reflektieren.
Nachdem wir uns also auf Klassen festgelegt haben, können wir nun endlich zur Lüftung des Geheimnisses kommen, wo in einem SMALLTALK-Programm die Instanzvariablen und Methoden, die Objekte ihr eigen nennen, vereinbart (deklariert) und im Falle der Methoden auch definiert (mit Inhalt versehen) werden: in Klassen.","<answer> Die Idee der Familienähnlichkeiten, wie sie von Ludwig Wittgenstein in seiner späten Philosophie entwickelt wurde, beeinflusst die Verwendung von Klassen in der objektorientierten Programmierung. Wittgenstein argumentierte, dass Allgemeinbegriffe (Klassen) niemals eine adäquate Beschreibung aller Individuen (Objekte) sein können, die mit dem Begriff verknüpft sind. Stattdessen gibt es mehr oder weniger ""spielhafte"" Ähnlichkeiten zwischen Objekten, die zu einer Klasse gehören. Dies führte zur Entwicklung des Konzepts der Prototypen in der prototypenbasierten Programmierung, bei der Klassen flexibler und weniger starr definiert sind. <answer> <question> Welche philosophische Idee beeinflusst die Verwendung von Klassen in der objektorientierten Programmierung? <question>"
"Durch die Zuordnung von Individuen oder Objekten zu Allgemeinbegriffen oder Klassen findet eine Klassifikation statt. Diese Klassifikation erlaubt eine Ordnung oder Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen nur noch für die Klassen getroffen werden müssen und nicht mehr für jedes einzelne Objekt. Anstatt also, wie in der vorangegangenen Kurseinheit, Instanzvariablen und Methoden direkt Objekten zuzuordnen, verbindet man sie mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse gehören, beschreiben.
In diesem Zusammenhang ist es sinnvoll, die Unterscheidung von Extension und Intension eines Begriffs ins Spiel zu bringen. Unter der Extension (Ausdehnung oder Erstreckung) eines (Allgemein-)Begriffs versteht man die Menge der Objekte, die darunterfallen. Im Fall von ""Person"" etwa ist das die Menge aller Personen, im Fall von ""Dokument"" die Menge aller Dokumente. Die Intension (nicht zu verwechseln mit Intention!) eines (Allgemein-)Begriffs hingegen ist die Summe der Merkmale, die den Begriff ausmachen und die die Objekte, die darunter fallen, charakterisieren. Sie ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die zu einem beliebigen Element entscheidet, ob es unter den Begriff fällt. Schon Aristoteles fiel auf, dass Intension und Extension in einem inversen Größenverhältnis zueinander stehen: Mit wachsender Intension schrumpft die Extension und umgekehrt. Dies ist freilich nicht weiter verwunderlich: Je umfangreicher die Charakterisierung einer Menge von Objekten ist, d.h., je strenger die Bedingungen sind, die ein Objekt erfüllen muss, um dazuzugehören, desto weniger Objekte erfüllen diese Bedingungen, und desto kleiner ist entsprechend die Menge. Wir werden in Kapitel 9 noch einmal darauf zurückkommen.
Allgemeinbegriffe sind die Vorbilder für Klassen in der objektorientierten Programmierung. Interessanterweise bildet eine wichtige philosophische Abweichung vom Glauben an die Adäquatheit von Allgemeinbegriffen, die Idee der Familienähnlichkeiten, wie sie von Ludwig Wittgenstein in seiner späten Philosophie entworfen wurde, die Grundlage für die schon erwähnte Alternative zu den Klassen, nämlich die Prototypen. Die Idee Wittgensteins, wie auch der prototypenbasierten Programmierung, ist, dass ein Allgemeinbegriff (eine Klasse) niemals eine adäquate Beschreibung aller Individuen (Objekte) sein kann, die man mit dem Begriff verbindet. Wittgenstein verwendet dafür das Beispiel vom ""Spiel"": Auch wenn es Spiele gibt, die einander stark ähneln, so ist der Begriff vom ""Spiel"" doch nicht so scharf gefasst, dass es eine Grenze gäbe, innerhalb derer etwas ein Spiel wie alle anderen, außerhalb derer es aber kein Spiel mehr ist. Vielmehr gibt es, nach Wittgenstein, mehr oder weniger ""spielhafte"" Spiele, also prototypische Spiele und solche, die diesen mehr oder weniger gleichen.
Zwar gibt es Anwendungsdomänen, in denen Wittgensteins Familienähnlichkeiten die Sachlage besser beschreiben als die traditionellen Allgemeinbegriffe (man denke z.B. an Musik, in der es zwar Töne und Noten gibt, aber dennoch zwei Töne selten genau gleich klingen sollen und die Notenzeichen entsprechend vielfältig variieren), aber insgesamt sind die üblichen Anwendungen doch eher der Natur, dass es von einigen wenigen Sorten eine große Menge von Objekten gibt, die alle mehr oder weniger gleich zu behandeln sind. Und so vereinfachen Allgemeinbegriffe oder Klassen unsere Weltsicht ganz erheblich und damit auch die Programme, die wir schreiben, um unsere Weltsicht zu reflektieren.
Nachdem wir uns also auf Klassen festgelegt haben, können wir nun endlich zur Lüftung des Geheimnisses kommen, wo in einem SMALLTALK-Programm die Instanzvariablen und Methoden, die Objekte ihr eigen nennen, vereinbart (deklariert) und im Falle der Methoden auch definiert (mit Inhalt versehen) werden: in Klassen.","<answer> Allgemeinbegriffe oder Klassen vereinfachen die Strukturierung von Objekten und die Beschreibung von Eigenschaften und Verhalten in der Programmierung. Sie erlauben es, bestimmte Aussagen und Methoden für eine Klasse im Allgemeinen zu definieren, anstatt sie für jedes einzelne Objekt wiederholen zu müssen. Dies erleichtert die Organisation von Code und trägt zur Abstraktion und Wiederverwendbarkeit von Software bei. <answer> <question> Warum sind Allgemeinbegriffe oder Klassen in der objektorientierten Programmierung hilfreich? <question>"
"Nun können Typen neben ihrer formalen Funktion, Fehler zu vermeiden, noch eine inhaltliche Funktion erfüllen, nämlich eine Filterfunktion. Diese setzt jedoch voraus, dass dem Typ auch eine Bedeutung, die über seine bloße Struktur (seine Syntax) hinausgeht, beigemessen werden kann. Dies geschieht heute vor allem durch die Benennung des Typs, die dann, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität, verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Eine Zuweisung einer Wohnung an ein Büro oder umgekehrt ist dann, trotz im obigen Beispiel strukturell gleich definierter Typen und deswegen ausbleibenden Typfehlern, aufgrund fehlender Namensgleichheit ausgeschlossen. Dies ist auch sinnvoll, da es sich dabei mit hoher Wahrscheinlichkeit um einen logischen Programmierfehler handelt, der auf mechanische Art sonst kaum zu entdecken wäre. Die Filterfunktion, die die geforderte Namensäquivalenz verlangt, drückt also eher eine Absicht der Programmiererin aus als eine technische Notwendigkeit. Die Bedeutung gerade dieser Funktion sollte man jedoch nicht unterschätzen, da nur wenige Möglichkeiten, Fehler in einem Programm aufzudecken bzw. zu vermeiden, so einfach zu handhaben sind.
Ein Prinzip, das der Typprüfung per Namensäquivalenz ähnelt, findet übrigens auch in der Physik Anwendung: Bei ihren Berechnungen führen Physikerinnen stets eine Art Typprüfung durch, indem sie nicht nur mit den Beträgen der physikalischen Größen, sondern auch mit deren Einheiten rechnen. Wenn Physikerinnen also beispielsweise eine Geschwindigkeit berechnen und bei der Behandlung der Einheiten etwas anderes als m/s herauskommt, dann steckt im Rechenvorgang ein Fehler — das Ergebnis hat nicht den richtigen Typ (die richtige Einheit) und ist deswegen mit hoher Wahrscheinlichkeit falsch.
Namensäquivalenz hat jedoch auch einen entscheidenden Nachteil: Sie setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen (also da, wo Objekte ausgetauscht werden) dieselben Typen verwenden. Dies kann für die Interoperabilität von getrennt voneinander entwickelten Programmen (wie z. B. Web Services) ein echtes Hindernis sein.
Strukturelle Typäquivalenz bietet mehr Flexibilität als nominale: Sie erlaubt Äquivalenz von Typen, bei deren Definition man vom jeweils anderen nichts wusste. Die erhöhte Flexibilität hat jedoch ihren Preis: Zufällige strukturelle Übereinstimmungen können zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Type branding führt in solchen Fällen optional eine Namensäquivalenz durch die Hintertür ein, mit dem Vorteil, dass diese optional ist.","<answer> Typen können in der Programmierung neben ihrer formalen Rolle, Fehler zu vermeiden, auch eine inhaltliche Funktion erfüllen. Diese inhaltliche Funktion wird vor allem durch die Benennung des Typs hergestellt, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität. Sie verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. <answer> <question> Was ist die inhaltliche Funktion, die Typen neben ihrer formalen Rolle erfüllen können, und wie wird sie in der Programmierung hergestellt? <question>"
"Nun können Typen neben ihrer formalen Funktion, Fehler zu vermeiden, noch eine inhaltliche Funktion erfüllen, nämlich eine Filterfunktion. Diese setzt jedoch voraus, dass dem Typ auch eine Bedeutung, die über seine bloße Struktur (seine Syntax) hinausgeht, beigemessen werden kann. Dies geschieht heute vor allem durch die Benennung des Typs, die dann, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität, verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Eine Zuweisung einer Wohnung an ein Büro oder umgekehrt ist dann, trotz im obigen Beispiel strukturell gleich definierter Typen und deswegen ausbleibenden Typfehlern, aufgrund fehlender Namensgleichheit ausgeschlossen. Dies ist auch sinnvoll, da es sich dabei mit hoher Wahrscheinlichkeit um einen logischen Programmierfehler handelt, der auf mechanische Art sonst kaum zu entdecken wäre. Die Filterfunktion, die die geforderte Namensäquivalenz verlangt, drückt also eher eine Absicht der Programmiererin aus als eine technische Notwendigkeit. Die Bedeutung gerade dieser Funktion sollte man jedoch nicht unterschätzen, da nur wenige Möglichkeiten, Fehler in einem Programm aufzudecken bzw. zu vermeiden, so einfach zu handhaben sind.
Ein Prinzip, das der Typprüfung per Namensäquivalenz ähnelt, findet übrigens auch in der Physik Anwendung: Bei ihren Berechnungen führen Physikerinnen stets eine Art Typprüfung durch, indem sie nicht nur mit den Beträgen der physikalischen Größen, sondern auch mit deren Einheiten rechnen. Wenn Physikerinnen also beispielsweise eine Geschwindigkeit berechnen und bei der Behandlung der Einheiten etwas anderes als m/s herauskommt, dann steckt im Rechenvorgang ein Fehler — das Ergebnis hat nicht den richtigen Typ (die richtige Einheit) und ist deswegen mit hoher Wahrscheinlichkeit falsch.
Namensäquivalenz hat jedoch auch einen entscheidenden Nachteil: Sie setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen (also da, wo Objekte ausgetauscht werden) dieselben Typen verwenden. Dies kann für die Interoperabilität von getrennt voneinander entwickelten Programmen (wie z. B. Web Services) ein echtes Hindernis sein.
Strukturelle Typäquivalenz bietet mehr Flexibilität als nominale: Sie erlaubt Äquivalenz von Typen, bei deren Definition man vom jeweils anderen nichts wusste. Die erhöhte Flexibilität hat jedoch ihren Preis: Zufällige strukturelle Übereinstimmungen können zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Type branding führt in solchen Fällen optional eine Namensäquivalenz durch die Hintertür ein, mit dem Vorteil, dass diese optional ist.","<answer> Die Namensäquivalenz ist wichtig, da sie sicherstellt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Sie verhindert Zuweisungen zwischen Typen, die zwar strukturell gleich sind, aber unterschiedliche Bedeutungen haben. Dies ist entscheidend, um logische Programmierfehler zu vermeiden, die sonst schwer zu entdecken wären. <answer> <question> Warum ist die Namensäquivalenz als Bedingung der Zuweisungskompatibilität wichtig? <question>"
"Nun können Typen neben ihrer formalen Funktion, Fehler zu vermeiden, noch eine inhaltliche Funktion erfüllen, nämlich eine Filterfunktion. Diese setzt jedoch voraus, dass dem Typ auch eine Bedeutung, die über seine bloße Struktur (seine Syntax) hinausgeht, beigemessen werden kann. Dies geschieht heute vor allem durch die Benennung des Typs, die dann, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität, verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Eine Zuweisung einer Wohnung an ein Büro oder umgekehrt ist dann, trotz im obigen Beispiel strukturell gleich definierter Typen und deswegen ausbleibenden Typfehlern, aufgrund fehlender Namensgleichheit ausgeschlossen. Dies ist auch sinnvoll, da es sich dabei mit hoher Wahrscheinlichkeit um einen logischen Programmierfehler handelt, der auf mechanische Art sonst kaum zu entdecken wäre. Die Filterfunktion, die die geforderte Namensäquivalenz verlangt, drückt also eher eine Absicht der Programmiererin aus als eine technische Notwendigkeit. Die Bedeutung gerade dieser Funktion sollte man jedoch nicht unterschätzen, da nur wenige Möglichkeiten, Fehler in einem Programm aufzudecken bzw. zu vermeiden, so einfach zu handhaben sind.
Ein Prinzip, das der Typprüfung per Namensäquivalenz ähnelt, findet übrigens auch in der Physik Anwendung: Bei ihren Berechnungen führen Physikerinnen stets eine Art Typprüfung durch, indem sie nicht nur mit den Beträgen der physikalischen Größen, sondern auch mit deren Einheiten rechnen. Wenn Physikerinnen also beispielsweise eine Geschwindigkeit berechnen und bei der Behandlung der Einheiten etwas anderes als m/s herauskommt, dann steckt im Rechenvorgang ein Fehler — das Ergebnis hat nicht den richtigen Typ (die richtige Einheit) und ist deswegen mit hoher Wahrscheinlichkeit falsch.
Namensäquivalenz hat jedoch auch einen entscheidenden Nachteil: Sie setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen (also da, wo Objekte ausgetauscht werden) dieselben Typen verwenden. Dies kann für die Interoperabilität von getrennt voneinander entwickelten Programmen (wie z. B. Web Services) ein echtes Hindernis sein.
Strukturelle Typäquivalenz bietet mehr Flexibilität als nominale: Sie erlaubt Äquivalenz von Typen, bei deren Definition man vom jeweils anderen nichts wusste. Die erhöhte Flexibilität hat jedoch ihren Preis: Zufällige strukturelle Übereinstimmungen können zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Type branding führt in solchen Fällen optional eine Namensäquivalenz durch die Hintertür ein, mit dem Vorteil, dass diese optional ist.","<answer> Die Filterfunktion, die durch die Namensäquivalenz verlangt wird, drückt die Absicht der Programmiererin aus, Werte nur gleicher Bedeutung zuzuweisen. Sie ermöglicht es, Fehler in einem Programm auf einfache Weise zu erkennen und zu vermeiden. <answer> <question> Welche Bedeutung hat die Filterfunktion, die durch die Namensäquivalenz verlangt wird? <question>"
"Nun können Typen neben ihrer formalen Funktion, Fehler zu vermeiden, noch eine inhaltliche Funktion erfüllen, nämlich eine Filterfunktion. Diese setzt jedoch voraus, dass dem Typ auch eine Bedeutung, die über seine bloße Struktur (seine Syntax) hinausgeht, beigemessen werden kann. Dies geschieht heute vor allem durch die Benennung des Typs, die dann, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität, verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Eine Zuweisung einer Wohnung an ein Büro oder umgekehrt ist dann, trotz im obigen Beispiel strukturell gleich definierter Typen und deswegen ausbleibenden Typfehlern, aufgrund fehlender Namensgleichheit ausgeschlossen. Dies ist auch sinnvoll, da es sich dabei mit hoher Wahrscheinlichkeit um einen logischen Programmierfehler handelt, der auf mechanische Art sonst kaum zu entdecken wäre. Die Filterfunktion, die die geforderte Namensäquivalenz verlangt, drückt also eher eine Absicht der Programmiererin aus als eine technische Notwendigkeit. Die Bedeutung gerade dieser Funktion sollte man jedoch nicht unterschätzen, da nur wenige Möglichkeiten, Fehler in einem Programm aufzudecken bzw. zu vermeiden, so einfach zu handhaben sind.
Ein Prinzip, das der Typprüfung per Namensäquivalenz ähnelt, findet übrigens auch in der Physik Anwendung: Bei ihren Berechnungen führen Physikerinnen stets eine Art Typprüfung durch, indem sie nicht nur mit den Beträgen der physikalischen Größen, sondern auch mit deren Einheiten rechnen. Wenn Physikerinnen also beispielsweise eine Geschwindigkeit berechnen und bei der Behandlung der Einheiten etwas anderes als m/s herauskommt, dann steckt im Rechenvorgang ein Fehler — das Ergebnis hat nicht den richtigen Typ (die richtige Einheit) und ist deswegen mit hoher Wahrscheinlichkeit falsch.
Namensäquivalenz hat jedoch auch einen entscheidenden Nachteil: Sie setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen (also da, wo Objekte ausgetauscht werden) dieselben Typen verwenden. Dies kann für die Interoperabilität von getrennt voneinander entwickelten Programmen (wie z. B. Web Services) ein echtes Hindernis sein.
Strukturelle Typäquivalenz bietet mehr Flexibilität als nominale: Sie erlaubt Äquivalenz von Typen, bei deren Definition man vom jeweils anderen nichts wusste. Die erhöhte Flexibilität hat jedoch ihren Preis: Zufällige strukturelle Übereinstimmungen können zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Type branding führt in solchen Fällen optional eine Namensäquivalenz durch die Hintertür ein, mit dem Vorteil, dass diese optional ist.","<answer> Ein ähnliches Prinzip wie die Typprüfung per Namensäquivalenz wird in der Physik angewendet. Bei physikalischen Berechnungen prüfen Physikerinnen nicht nur die Beträge der physikalischen Größen, sondern auch deren Einheiten. Wenn die Einheiten nicht korrekt behandelt werden und das Ergebnis etwas anderes als erwartet ergibt, liegt ein Fehler im Rechenvorgang vor. <answer> <question> Welches Prinzip in der Physik ähnelt der Typprüfung per Namensäquivalenz, und wie wird es angewendet? <question>"
"Nun können Typen neben ihrer formalen Funktion, Fehler zu vermeiden, noch eine inhaltliche Funktion erfüllen, nämlich eine Filterfunktion. Diese setzt jedoch voraus, dass dem Typ auch eine Bedeutung, die über seine bloße Struktur (seine Syntax) hinausgeht, beigemessen werden kann. Dies geschieht heute vor allem durch die Benennung des Typs, die dann, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität, verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Eine Zuweisung einer Wohnung an ein Büro oder umgekehrt ist dann, trotz im obigen Beispiel strukturell gleich definierter Typen und deswegen ausbleibenden Typfehlern, aufgrund fehlender Namensgleichheit ausgeschlossen. Dies ist auch sinnvoll, da es sich dabei mit hoher Wahrscheinlichkeit um einen logischen Programmierfehler handelt, der auf mechanische Art sonst kaum zu entdecken wäre. Die Filterfunktion, die die geforderte Namensäquivalenz verlangt, drückt also eher eine Absicht der Programmiererin aus als eine technische Notwendigkeit. Die Bedeutung gerade dieser Funktion sollte man jedoch nicht unterschätzen, da nur wenige Möglichkeiten, Fehler in einem Programm aufzudecken bzw. zu vermeiden, so einfach zu handhaben sind.
Ein Prinzip, das der Typprüfung per Namensäquivalenz ähnelt, findet übrigens auch in der Physik Anwendung: Bei ihren Berechnungen führen Physikerinnen stets eine Art Typprüfung durch, indem sie nicht nur mit den Beträgen der physikalischen Größen, sondern auch mit deren Einheiten rechnen. Wenn Physikerinnen also beispielsweise eine Geschwindigkeit berechnen und bei der Behandlung der Einheiten etwas anderes als m/s herauskommt, dann steckt im Rechenvorgang ein Fehler — das Ergebnis hat nicht den richtigen Typ (die richtige Einheit) und ist deswegen mit hoher Wahrscheinlichkeit falsch.
Namensäquivalenz hat jedoch auch einen entscheidenden Nachteil: Sie setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen (also da, wo Objekte ausgetauscht werden) dieselben Typen verwenden. Dies kann für die Interoperabilität von getrennt voneinander entwickelten Programmen (wie z. B. Web Services) ein echtes Hindernis sein.
Strukturelle Typäquivalenz bietet mehr Flexibilität als nominale: Sie erlaubt Äquivalenz von Typen, bei deren Definition man vom jeweils anderen nichts wusste. Die erhöhte Flexibilität hat jedoch ihren Preis: Zufällige strukturelle Übereinstimmungen können zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Type branding führt in solchen Fällen optional eine Namensäquivalenz durch die Hintertür ein, mit dem Vorteil, dass diese optional ist.","<answer> Die Namensäquivalenz setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen dieselben Typen verwenden. Dies kann ein Hindernis für die Interoperabilität von solchen Programmen, wie zum Beispiel Web Services, darstellen. <answer> <question> Welchen Nachteil hat die Namensäquivalenz in Bezug auf die Interoperabilität von getrennt voneinander entwickelten Programmen? <question>"
"Nun können Typen neben ihrer formalen Funktion, Fehler zu vermeiden, noch eine inhaltliche Funktion erfüllen, nämlich eine Filterfunktion. Diese setzt jedoch voraus, dass dem Typ auch eine Bedeutung, die über seine bloße Struktur (seine Syntax) hinausgeht, beigemessen werden kann. Dies geschieht heute vor allem durch die Benennung des Typs, die dann, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität, verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Eine Zuweisung einer Wohnung an ein Büro oder umgekehrt ist dann, trotz im obigen Beispiel strukturell gleich definierter Typen und deswegen ausbleibenden Typfehlern, aufgrund fehlender Namensgleichheit ausgeschlossen. Dies ist auch sinnvoll, da es sich dabei mit hoher Wahrscheinlichkeit um einen logischen Programmierfehler handelt, der auf mechanische Art sonst kaum zu entdecken wäre. Die Filterfunktion, die die geforderte Namensäquivalenz verlangt, drückt also eher eine Absicht der Programmiererin aus als eine technische Notwendigkeit. Die Bedeutung gerade dieser Funktion sollte man jedoch nicht unterschätzen, da nur wenige Möglichkeiten, Fehler in einem Programm aufzudecken bzw. zu vermeiden, so einfach zu handhaben sind.
Ein Prinzip, das der Typprüfung per Namensäquivalenz ähnelt, findet übrigens auch in der Physik Anwendung: Bei ihren Berechnungen führen Physikerinnen stets eine Art Typprüfung durch, indem sie nicht nur mit den Beträgen der physikalischen Größen, sondern auch mit deren Einheiten rechnen. Wenn Physikerinnen also beispielsweise eine Geschwindigkeit berechnen und bei der Behandlung der Einheiten etwas anderes als m/s herauskommt, dann steckt im Rechenvorgang ein Fehler — das Ergebnis hat nicht den richtigen Typ (die richtige Einheit) und ist deswegen mit hoher Wahrscheinlichkeit falsch.
Namensäquivalenz hat jedoch auch einen entscheidenden Nachteil: Sie setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen (also da, wo Objekte ausgetauscht werden) dieselben Typen verwenden. Dies kann für die Interoperabilität von getrennt voneinander entwickelten Programmen (wie z. B. Web Services) ein echtes Hindernis sein.
Strukturelle Typäquivalenz bietet mehr Flexibilität als nominale: Sie erlaubt Äquivalenz von Typen, bei deren Definition man vom jeweils anderen nichts wusste. Die erhöhte Flexibilität hat jedoch ihren Preis: Zufällige strukturelle Übereinstimmungen können zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Type branding führt in solchen Fällen optional eine Namensäquivalenz durch die Hintertür ein, mit dem Vorteil, dass diese optional ist.","<answer> Strukturelle Typäquivalenz bietet mehr Flexibilität als Namensäquivalenz, da sie die Äquivalenz von Typen erlaubt, deren Definition voneinander unabhängig ist. Allerdings können zufällige strukturelle Übereinstimmungen zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Um diesen Nachteil zu vermeiden, kann optional eine Namensäquivalenz durch Type branding eingeführt werden. <answer> <question> Was sind die Unterschiede zwischen struktureller Typäquivalenz und Namensäquivalenz in Bezug auf Flexibilität und Semantik? <question>"
"Wie Sie gesehen haben, hat das Typsystem JAVAs eine starke statische Komponente. Gleichwohl können nicht alle Typprüfungen zur Übersetzungszeit durchgeführt werden. Während man die dynamischen Typprüfungen bei Arrays (Kapitel 41) noch durch die Einführung von Wildcards hätte vermeiden können, gilt das nicht für die gelegentlich notwendigen Typumwandlungen (Type casts; zumindest nicht für alle).",<answer> Java kann zur Übersetzungszeit statische Typprüfungen durchführen. <answer> <question> Welche Art von Typprüfungen kann Java zur Übersetzungszeit durchführen? <question>
"Wie Sie gesehen haben, hat das Typsystem JAVAs eine starke statische Komponente. Gleichwohl können nicht alle Typprüfungen zur Übersetzungszeit durchgeführt werden. Während man die dynamischen Typprüfungen bei Arrays (Kapitel 41) noch durch die Einführung von Wildcards hätte vermeiden können, gilt das nicht für die gelegentlich notwendigen Typumwandlungen (Type casts; zumindest nicht für alle).","<answer> Nicht alle Typprüfungen können in Java zur Übersetzungszeit durchgeführt werden, da einige Typprüfungen erst zur Laufzeit notwendig sind und nicht im Voraus bekannt sind. <answer> <question> Warum können nicht alle Typprüfungen in Java zur Übersetzungszeit durchgeführt werden? <question>"
"Wie Sie gesehen haben, hat das Typsystem JAVAs eine starke statische Komponente. Gleichwohl können nicht alle Typprüfungen zur Übersetzungszeit durchgeführt werden. Während man die dynamischen Typprüfungen bei Arrays (Kapitel 41) noch durch die Einführung von Wildcards hätte vermeiden können, gilt das nicht für die gelegentlich notwendigen Typumwandlungen (Type casts; zumindest nicht für alle).","<answer> Gelegentliche Typprüfungen, die dynamische Typprüfungen in Java erfordern, sind insbesondere Typumwandlungen (Type casts). <answer> <question> Welche gelegentlichen Typprüfungen erfordern dynamische Typprüfungen in Java? <question>"
"Analog zur Einführung von parametrisierten Typen in Kapitel 29 von Kurseinheit 3 abstrahieren die generischen Typen von Java von Typen, indem sie die Referenzierung eines oder mehrerer Typen innerhalb einer Typdefinition durch Typvariablen ersetzen. Anders als in STRONGTALK stehen die Typvariablen in Java jedoch nicht in eckigen, sondern in spitzen Klammern. Da es dadurch zu Verwechselungen mit metasyntaktischen Variablen kommen kann, werden wir in diesem Kapitel keine mehr verwenden.","<answer> Generische Typen in Java sind Typdefinitionen, die Typvariablen verwenden, um die Referenzierung eines oder mehrerer Typen innerhalb der Definition zu abstrahieren. <answer> <question> Was sind generische Typen in Java? <question>"
"Analog zur Einführung von parametrisierten Typen in Kapitel 29 von Kurseinheit 3 abstrahieren die generischen Typen von Java von Typen, indem sie die Referenzierung eines oder mehrerer Typen innerhalb einer Typdefinition durch Typvariablen ersetzen. Anders als in STRONGTALK stehen die Typvariablen in Java jedoch nicht in eckigen, sondern in spitzen Klammern. Da es dadurch zu Verwechselungen mit metasyntaktischen Variablen kommen kann, werden wir in diesem Kapitel keine mehr verwenden.",<answer> In Java werden Typvariablen in generischen Typen in spitzen Klammern dargestellt. <answer> <question> Wie werden Typvariablen in Java generischen Typen dargestellt? <question>
"Analog zur Einführung von parametrisierten Typen in Kapitel 29 von Kurseinheit 3 abstrahieren die generischen Typen von Java von Typen, indem sie die Referenzierung eines oder mehrerer Typen innerhalb einer Typdefinition durch Typvariablen ersetzen. Anders als in STRONGTALK stehen die Typvariablen in Java jedoch nicht in eckigen, sondern in spitzen Klammern. Da es dadurch zu Verwechselungen mit metasyntaktischen Variablen kommen kann, werden wir in diesem Kapitel keine mehr verwenden.",<answer> Metasyntaktische Variablen könnten aufgrund der Verwendung von spitzen Klammern für Typvariablen in Java zu Verwechselungen führen. Daher werden in diesem Kapitel keine metasyntaktischen Variablen verwendet. <answer> <question> Warum werden in diesem Kapitel keine metasyntaktischen Variablen verwendet? <question>
"JAVA ist in vielerlei Hinsicht (und vor allem im Vergleich zu SMALLTALK) eine konventionelle Programmiersprache. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die - jede für sich - immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist jedoch kein direkt ausführbarer Maschinencode, sondern ein sogenannter Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Das sonst übliche Linken der einzelnen Klassen (genauer: des zu den Klassen gehörenden Bytecodes, die sogenannten Class Files) wird dabei durch das Class Loading der JVM ersetzt. Vorteile des Ganzen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit: JAVA-Programme können, soweit sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen (man denke z. B. an die unterschiedliche Handhabung von Groß-/Kleinschreibung - JAVA ist case sensitive, Windows nicht!), auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt.
Während JAVA als Programmiersprache anfangs noch recht klein und überschaubar war (zumindest im Vergleich zu C++, einem ihrer Hauptkonkurrenten), so ist die Sprachdefinition heute ein Moloch. Mit dem wachsenden Nutzerkreis sind auch die Anforderungen an die Sprache gewachsen, und mit dem JAVA Community Process wurde aktiven Entwicklern die Möglichkeit eingeräumt, Vorschläge zur Spracherweiterung zu machen. Dabei ist jedoch - aufgrund der mittlerweile riesigen Menge an Software, die in JAVA geschrieben ist - stets auf Rückwärtskompatibilität zu achten, so dass revolutionäre Verbesserungen kaum möglich sind; stattdessen wird hinzugefügt. Das unterliegende Programmiermodell ist so immer dasselbe geblieben - und wird es wohl auch immer bleiben.
Die grundlegenden Werkzeuge der JAVA-Programmierung sind neben dem Editor der JAVA-Compiler javac, die JVM, die JAVA-Klassenbibliothek (das sogenannte Application Programming Interface, API) und natürlich die Dokumentation (API-Dokumentation und Sprachdefinition). Gerade für die JAVA-Programmierung gibt es jedoch zahlreiche integrierte Entwicklungsumgebungen (IDEs), und es ist niemandem zu raten, diese Werkzeuge links liegen zu lassen. Diejenigen, die einmal einen Teil ihrer wertvollen Lebenszeit mit dem richtigen Setzen des sogenannten Class Path verbracht haben, wissen, wovon ich rede. Auf der anderen Seite sind diese IDEs sehr komplex und erschlagen gerade Anfänger mit ihrem Funktionsumfang. Das ist auch der Grund, warum in diesem Kurs keine JAVA-Installation von Ihnen verlangt wird. Wer es aber wissen möchte und mit JAVA experimentieren möchte, den will ich keinesfalls davon abhalten.
Um ein JAVA-Programm, bestehend aus einer Menge von Class Files, auszuführen, muss man eine Klasse angeben, die eine Startmethode besitzt. Diese Startmethode heißt immer gleich; ihre Signatur hat die leicht zu merkende und immer wieder gerne eingetippte Form.
Dabei ist ""main"" der Name der Methode; was die anderen Elemente bedeuten, werden Sie im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann einfach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter. Klassen werden in JAVA wie in SMALLTALK per Konvention immer großgeschrieben.
Ein letztes, wichtiges Merkmal des Programmiermodells von JAVA ist die Art des Deployment, also wie in JAVA programmierte Anwendungen in die Anwendung gehen. Während früher alle namhaften Web-Browser (per Plug-in) den Start von in Webseiten eingebetteten JAVA-Anwendungen erlaubten, bleibt heute praktisch nur noch die Verteilung per sogenanntem JAVA Archive (einer .jar-Datei). Zu deren Ausführung ist jedoch eine Installation der JVM nötig.","<answer> Die Java Virtual Machine (JVM) interpretiert den Bytecode, der das Ergebnis der Übersetzung von JAVA-Programmen ist. Sie spielt eine entscheidende Rolle bei der Ausführung von JAVA-Programmen. <answer> <question> Welche Rolle spielt die Java Virtual Machine (JVM) in JAVA-Programmen? <question>"
"JAVA ist in vielerlei Hinsicht (und vor allem im Vergleich zu SMALLTALK) eine konventionelle Programmiersprache. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die - jede für sich - immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist jedoch kein direkt ausführbarer Maschinencode, sondern ein sogenannter Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Das sonst übliche Linken der einzelnen Klassen (genauer: des zu den Klassen gehörenden Bytecodes, die sogenannten Class Files) wird dabei durch das Class Loading der JVM ersetzt. Vorteile des Ganzen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit: JAVA-Programme können, soweit sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen (man denke z. B. an die unterschiedliche Handhabung von Groß-/Kleinschreibung - JAVA ist case sensitive, Windows nicht!), auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt.
Während JAVA als Programmiersprache anfangs noch recht klein und überschaubar war (zumindest im Vergleich zu C++, einem ihrer Hauptkonkurrenten), so ist die Sprachdefinition heute ein Moloch. Mit dem wachsenden Nutzerkreis sind auch die Anforderungen an die Sprache gewachsen, und mit dem JAVA Community Process wurde aktiven Entwicklern die Möglichkeit eingeräumt, Vorschläge zur Spracherweiterung zu machen. Dabei ist jedoch - aufgrund der mittlerweile riesigen Menge an Software, die in JAVA geschrieben ist - stets auf Rückwärtskompatibilität zu achten, so dass revolutionäre Verbesserungen kaum möglich sind; stattdessen wird hinzugefügt. Das unterliegende Programmiermodell ist so immer dasselbe geblieben - und wird es wohl auch immer bleiben.
Die grundlegenden Werkzeuge der JAVA-Programmierung sind neben dem Editor der JAVA-Compiler javac, die JVM, die JAVA-Klassenbibliothek (das sogenannte Application Programming Interface, API) und natürlich die Dokumentation (API-Dokumentation und Sprachdefinition). Gerade für die JAVA-Programmierung gibt es jedoch zahlreiche integrierte Entwicklungsumgebungen (IDEs), und es ist niemandem zu raten, diese Werkzeuge links liegen zu lassen. Diejenigen, die einmal einen Teil ihrer wertvollen Lebenszeit mit dem richtigen Setzen des sogenannten Class Path verbracht haben, wissen, wovon ich rede. Auf der anderen Seite sind diese IDEs sehr komplex und erschlagen gerade Anfänger mit ihrem Funktionsumfang. Das ist auch der Grund, warum in diesem Kurs keine JAVA-Installation von Ihnen verlangt wird. Wer es aber wissen möchte und mit JAVA experimentieren möchte, den will ich keinesfalls davon abhalten.
Um ein JAVA-Programm, bestehend aus einer Menge von Class Files, auszuführen, muss man eine Klasse angeben, die eine Startmethode besitzt. Diese Startmethode heißt immer gleich; ihre Signatur hat die leicht zu merkende und immer wieder gerne eingetippte Form.
Dabei ist ""main"" der Name der Methode; was die anderen Elemente bedeuten, werden Sie im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann einfach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter. Klassen werden in JAVA wie in SMALLTALK per Konvention immer großgeschrieben.
Ein letztes, wichtiges Merkmal des Programmiermodells von JAVA ist die Art des Deployment, also wie in JAVA programmierte Anwendungen in die Anwendung gehen. Während früher alle namhaften Web-Browser (per Plug-in) den Start von in Webseiten eingebetteten JAVA-Anwendungen erlaubten, bleibt heute praktisch nur noch die Verteilung per sogenanntem JAVA Archive (einer .jar-Datei). Zu deren Ausführung ist jedoch eine Installation der JVM nötig.","<answer> JAVA-Programme sind weitgehend plattformunabhängig, da sie in Form von Bytecode vorliegen und von der JVM interpretiert werden. Solange eine JVM für ein bestimmtes Betriebssystem verfügbar ist, können JAVA-Programme auf jedem Rechner und Betriebssystem ausgeführt werden, für das es eine JVM gibt. <answer> <question> Warum sind JAVA-Programme weitgehend plattformunabhängig? <question>"
"JAVA ist in vielerlei Hinsicht (und vor allem im Vergleich zu SMALLTALK) eine konventionelle Programmiersprache. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die - jede für sich - immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist jedoch kein direkt ausführbarer Maschinencode, sondern ein sogenannter Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Das sonst übliche Linken der einzelnen Klassen (genauer: des zu den Klassen gehörenden Bytecodes, die sogenannten Class Files) wird dabei durch das Class Loading der JVM ersetzt. Vorteile des Ganzen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit: JAVA-Programme können, soweit sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen (man denke z. B. an die unterschiedliche Handhabung von Groß-/Kleinschreibung - JAVA ist case sensitive, Windows nicht!), auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt.
Während JAVA als Programmiersprache anfangs noch recht klein und überschaubar war (zumindest im Vergleich zu C++, einem ihrer Hauptkonkurrenten), so ist die Sprachdefinition heute ein Moloch. Mit dem wachsenden Nutzerkreis sind auch die Anforderungen an die Sprache gewachsen, und mit dem JAVA Community Process wurde aktiven Entwicklern die Möglichkeit eingeräumt, Vorschläge zur Spracherweiterung zu machen. Dabei ist jedoch - aufgrund der mittlerweile riesigen Menge an Software, die in JAVA geschrieben ist - stets auf Rückwärtskompatibilität zu achten, so dass revolutionäre Verbesserungen kaum möglich sind; stattdessen wird hinzugefügt. Das unterliegende Programmiermodell ist so immer dasselbe geblieben - und wird es wohl auch immer bleiben.
Die grundlegenden Werkzeuge der JAVA-Programmierung sind neben dem Editor der JAVA-Compiler javac, die JVM, die JAVA-Klassenbibliothek (das sogenannte Application Programming Interface, API) und natürlich die Dokumentation (API-Dokumentation und Sprachdefinition). Gerade für die JAVA-Programmierung gibt es jedoch zahlreiche integrierte Entwicklungsumgebungen (IDEs), und es ist niemandem zu raten, diese Werkzeuge links liegen zu lassen. Diejenigen, die einmal einen Teil ihrer wertvollen Lebenszeit mit dem richtigen Setzen des sogenannten Class Path verbracht haben, wissen, wovon ich rede. Auf der anderen Seite sind diese IDEs sehr komplex und erschlagen gerade Anfänger mit ihrem Funktionsumfang. Das ist auch der Grund, warum in diesem Kurs keine JAVA-Installation von Ihnen verlangt wird. Wer es aber wissen möchte und mit JAVA experimentieren möchte, den will ich keinesfalls davon abhalten.
Um ein JAVA-Programm, bestehend aus einer Menge von Class Files, auszuführen, muss man eine Klasse angeben, die eine Startmethode besitzt. Diese Startmethode heißt immer gleich; ihre Signatur hat die leicht zu merkende und immer wieder gerne eingetippte Form.
Dabei ist ""main"" der Name der Methode; was die anderen Elemente bedeuten, werden Sie im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann einfach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter. Klassen werden in JAVA wie in SMALLTALK per Konvention immer großgeschrieben.
Ein letztes, wichtiges Merkmal des Programmiermodells von JAVA ist die Art des Deployment, also wie in JAVA programmierte Anwendungen in die Anwendung gehen. Während früher alle namhaften Web-Browser (per Plug-in) den Start von in Webseiten eingebetteten JAVA-Anwendungen erlaubten, bleibt heute praktisch nur noch die Verteilung per sogenanntem JAVA Archive (einer .jar-Datei). Zu deren Ausführung ist jedoch eine Installation der JVM nötig.","<answer> Es wird darauf hingewiesen, dass JAVA-Programmierung oft in integrierten Entwicklungsumgebungen (IDEs) stattfindet, da diese Werkzeuge die Entwicklung erleichtern. Allerdings können IDEs aufgrund ihrer Komplexität Anfänger überwältigen. <answer> <question> Warum wird darauf hingewiesen, dass JAVA-Programmierung oft in integrierten Entwicklungsumgebungen (IDEs) stattfindet? <question>"
"JAVA ist in vielerlei Hinsicht (und vor allem im Vergleich zu SMALLTALK) eine konventionelle Programmiersprache. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die - jede für sich - immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist jedoch kein direkt ausführbarer Maschinencode, sondern ein sogenannter Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Das sonst übliche Linken der einzelnen Klassen (genauer: des zu den Klassen gehörenden Bytecodes, die sogenannten Class Files) wird dabei durch das Class Loading der JVM ersetzt. Vorteile des Ganzen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit: JAVA-Programme können, soweit sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen (man denke z. B. an die unterschiedliche Handhabung von Groß-/Kleinschreibung - JAVA ist case sensitive, Windows nicht!), auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt.
Während JAVA als Programmiersprache anfangs noch recht klein und überschaubar war (zumindest im Vergleich zu C++, einem ihrer Hauptkonkurrenten), so ist die Sprachdefinition heute ein Moloch. Mit dem wachsenden Nutzerkreis sind auch die Anforderungen an die Sprache gewachsen, und mit dem JAVA Community Process wurde aktiven Entwicklern die Möglichkeit eingeräumt, Vorschläge zur Spracherweiterung zu machen. Dabei ist jedoch - aufgrund der mittlerweile riesigen Menge an Software, die in JAVA geschrieben ist - stets auf Rückwärtskompatibilität zu achten, so dass revolutionäre Verbesserungen kaum möglich sind; stattdessen wird hinzugefügt. Das unterliegende Programmiermodell ist so immer dasselbe geblieben - und wird es wohl auch immer bleiben.
Die grundlegenden Werkzeuge der JAVA-Programmierung sind neben dem Editor der JAVA-Compiler javac, die JVM, die JAVA-Klassenbibliothek (das sogenannte Application Programming Interface, API) und natürlich die Dokumentation (API-Dokumentation und Sprachdefinition). Gerade für die JAVA-Programmierung gibt es jedoch zahlreiche integrierte Entwicklungsumgebungen (IDEs), und es ist niemandem zu raten, diese Werkzeuge links liegen zu lassen. Diejenigen, die einmal einen Teil ihrer wertvollen Lebenszeit mit dem richtigen Setzen des sogenannten Class Path verbracht haben, wissen, wovon ich rede. Auf der anderen Seite sind diese IDEs sehr komplex und erschlagen gerade Anfänger mit ihrem Funktionsumfang. Das ist auch der Grund, warum in diesem Kurs keine JAVA-Installation von Ihnen verlangt wird. Wer es aber wissen möchte und mit JAVA experimentieren möchte, den will ich keinesfalls davon abhalten.
Um ein JAVA-Programm, bestehend aus einer Menge von Class Files, auszuführen, muss man eine Klasse angeben, die eine Startmethode besitzt. Diese Startmethode heißt immer gleich; ihre Signatur hat die leicht zu merkende und immer wieder gerne eingetippte Form.
Dabei ist ""main"" der Name der Methode; was die anderen Elemente bedeuten, werden Sie im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann einfach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter. Klassen werden in JAVA wie in SMALLTALK per Konvention immer großgeschrieben.
Ein letztes, wichtiges Merkmal des Programmiermodells von JAVA ist die Art des Deployment, also wie in JAVA programmierte Anwendungen in die Anwendung gehen. Während früher alle namhaften Web-Browser (per Plug-in) den Start von in Webseiten eingebetteten JAVA-Anwendungen erlaubten, bleibt heute praktisch nur noch die Verteilung per sogenanntem JAVA Archive (einer .jar-Datei). Zu deren Ausführung ist jedoch eine Installation der JVM nötig.","<answer> Die typische Methode, um ein JAVA-Programm auszuführen, ist die ""main""-Methode mit der Signatur ""public static void main(String[] args)"". Dies ist die Startmethode für JAVA-Anwendungen. <answer> <question> Was ist die typische Methode, um ein JAVA-Programm auszuführen, und wie lautet ihre Signatur? <question>"
"JAVA ist in vielerlei Hinsicht (und vor allem im Vergleich zu SMALLTALK) eine konventionelle Programmiersprache. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die - jede für sich - immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist jedoch kein direkt ausführbarer Maschinencode, sondern ein sogenannter Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Das sonst übliche Linken der einzelnen Klassen (genauer: des zu den Klassen gehörenden Bytecodes, die sogenannten Class Files) wird dabei durch das Class Loading der JVM ersetzt. Vorteile des Ganzen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit: JAVA-Programme können, soweit sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen (man denke z. B. an die unterschiedliche Handhabung von Groß-/Kleinschreibung - JAVA ist case sensitive, Windows nicht!), auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt.
Während JAVA als Programmiersprache anfangs noch recht klein und überschaubar war (zumindest im Vergleich zu C++, einem ihrer Hauptkonkurrenten), so ist die Sprachdefinition heute ein Moloch. Mit dem wachsenden Nutzerkreis sind auch die Anforderungen an die Sprache gewachsen, und mit dem JAVA Community Process wurde aktiven Entwicklern die Möglichkeit eingeräumt, Vorschläge zur Spracherweiterung zu machen. Dabei ist jedoch - aufgrund der mittlerweile riesigen Menge an Software, die in JAVA geschrieben ist - stets auf Rückwärtskompatibilität zu achten, so dass revolutionäre Verbesserungen kaum möglich sind; stattdessen wird hinzugefügt. Das unterliegende Programmiermodell ist so immer dasselbe geblieben - und wird es wohl auch immer bleiben.
Die grundlegenden Werkzeuge der JAVA-Programmierung sind neben dem Editor der JAVA-Compiler javac, die JVM, die JAVA-Klassenbibliothek (das sogenannte Application Programming Interface, API) und natürlich die Dokumentation (API-Dokumentation und Sprachdefinition). Gerade für die JAVA-Programmierung gibt es jedoch zahlreiche integrierte Entwicklungsumgebungen (IDEs), und es ist niemandem zu raten, diese Werkzeuge links liegen zu lassen. Diejenigen, die einmal einen Teil ihrer wertvollen Lebenszeit mit dem richtigen Setzen des sogenannten Class Path verbracht haben, wissen, wovon ich rede. Auf der anderen Seite sind diese IDEs sehr komplex und erschlagen gerade Anfänger mit ihrem Funktionsumfang. Das ist auch der Grund, warum in diesem Kurs keine JAVA-Installation von Ihnen verlangt wird. Wer es aber wissen möchte und mit JAVA experimentieren möchte, den will ich keinesfalls davon abhalten.
Um ein JAVA-Programm, bestehend aus einer Menge von Class Files, auszuführen, muss man eine Klasse angeben, die eine Startmethode besitzt. Diese Startmethode heißt immer gleich; ihre Signatur hat die leicht zu merkende und immer wieder gerne eingetippte Form.
Dabei ist ""main"" der Name der Methode; was die anderen Elemente bedeuten, werden Sie im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann einfach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter. Klassen werden in JAVA wie in SMALLTALK per Konvention immer großgeschrieben.
Ein letztes, wichtiges Merkmal des Programmiermodells von JAVA ist die Art des Deployment, also wie in JAVA programmierte Anwendungen in die Anwendung gehen. Während früher alle namhaften Web-Browser (per Plug-in) den Start von in Webseiten eingebetteten JAVA-Anwendungen erlaubten, bleibt heute praktisch nur noch die Verteilung per sogenanntem JAVA Archive (einer .jar-Datei). Zu deren Ausführung ist jedoch eine Installation der JVM nötig.","<answer> Die Ausführung eines JAVA-Programms auf Betriebssystemebene erfolgt, indem man der JVM den Namen der Klasse als Parameter übergibt. Zum Beispiel: ""java MeineKlasse"". <answer> <question> Wie erfolgt die Ausführung eines JAVA-Programms auf Betriebssystemebene? <question>"
"JAVA ist in vielerlei Hinsicht (und vor allem im Vergleich zu SMALLTALK) eine konventionelle Programmiersprache. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die - jede für sich - immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist jedoch kein direkt ausführbarer Maschinencode, sondern ein sogenannter Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Das sonst übliche Linken der einzelnen Klassen (genauer: des zu den Klassen gehörenden Bytecodes, die sogenannten Class Files) wird dabei durch das Class Loading der JVM ersetzt. Vorteile des Ganzen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit: JAVA-Programme können, soweit sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen (man denke z. B. an die unterschiedliche Handhabung von Groß-/Kleinschreibung - JAVA ist case sensitive, Windows nicht!), auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt.
Während JAVA als Programmiersprache anfangs noch recht klein und überschaubar war (zumindest im Vergleich zu C++, einem ihrer Hauptkonkurrenten), so ist die Sprachdefinition heute ein Moloch. Mit dem wachsenden Nutzerkreis sind auch die Anforderungen an die Sprache gewachsen, und mit dem JAVA Community Process wurde aktiven Entwicklern die Möglichkeit eingeräumt, Vorschläge zur Spracherweiterung zu machen. Dabei ist jedoch - aufgrund der mittlerweile riesigen Menge an Software, die in JAVA geschrieben ist - stets auf Rückwärtskompatibilität zu achten, so dass revolutionäre Verbesserungen kaum möglich sind; stattdessen wird hinzugefügt. Das unterliegende Programmiermodell ist so immer dasselbe geblieben - und wird es wohl auch immer bleiben.
Die grundlegenden Werkzeuge der JAVA-Programmierung sind neben dem Editor der JAVA-Compiler javac, die JVM, die JAVA-Klassenbibliothek (das sogenannte Application Programming Interface, API) und natürlich die Dokumentation (API-Dokumentation und Sprachdefinition). Gerade für die JAVA-Programmierung gibt es jedoch zahlreiche integrierte Entwicklungsumgebungen (IDEs), und es ist niemandem zu raten, diese Werkzeuge links liegen zu lassen. Diejenigen, die einmal einen Teil ihrer wertvollen Lebenszeit mit dem richtigen Setzen des sogenannten Class Path verbracht haben, wissen, wovon ich rede. Auf der anderen Seite sind diese IDEs sehr komplex und erschlagen gerade Anfänger mit ihrem Funktionsumfang. Das ist auch der Grund, warum in diesem Kurs keine JAVA-Installation von Ihnen verlangt wird. Wer es aber wissen möchte und mit JAVA experimentieren möchte, den will ich keinesfalls davon abhalten.
Um ein JAVA-Programm, bestehend aus einer Menge von Class Files, auszuführen, muss man eine Klasse angeben, die eine Startmethode besitzt. Diese Startmethode heißt immer gleich; ihre Signatur hat die leicht zu merkende und immer wieder gerne eingetippte Form.
Dabei ist ""main"" der Name der Methode; was die anderen Elemente bedeuten, werden Sie im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann einfach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter. Klassen werden in JAVA wie in SMALLTALK per Konvention immer großgeschrieben.
Ein letztes, wichtiges Merkmal des Programmiermodells von JAVA ist die Art des Deployment, also wie in JAVA programmierte Anwendungen in die Anwendung gehen. Während früher alle namhaften Web-Browser (per Plug-in) den Start von in Webseiten eingebetteten JAVA-Anwendungen erlaubten, bleibt heute praktisch nur noch die Verteilung per sogenanntem JAVA Archive (einer .jar-Datei). Zu deren Ausführung ist jedoch eine Installation der JVM nötig.","<answer> Ein wichtiges Merkmal des Programmiermodells von JAVA ist, dass Klassennamen immer großgeschrieben werden sollen. <answer> <question> Was ist ein wichtiges Merkmal des Programmiermodells von JAVA in Bezug auf die Namenskonvention von Klassen? <question>"
"JAVA ist in vielerlei Hinsicht (und vor allem im Vergleich zu SMALLTALK) eine konventionelle Programmiersprache. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die - jede für sich - immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist jedoch kein direkt ausführbarer Maschinencode, sondern ein sogenannter Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Das sonst übliche Linken der einzelnen Klassen (genauer: des zu den Klassen gehörenden Bytecodes, die sogenannten Class Files) wird dabei durch das Class Loading der JVM ersetzt. Vorteile des Ganzen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit: JAVA-Programme können, soweit sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen (man denke z. B. an die unterschiedliche Handhabung von Groß-/Kleinschreibung - JAVA ist case sensitive, Windows nicht!), auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt.
Während JAVA als Programmiersprache anfangs noch recht klein und überschaubar war (zumindest im Vergleich zu C++, einem ihrer Hauptkonkurrenten), so ist die Sprachdefinition heute ein Moloch. Mit dem wachsenden Nutzerkreis sind auch die Anforderungen an die Sprache gewachsen, und mit dem JAVA Community Process wurde aktiven Entwicklern die Möglichkeit eingeräumt, Vorschläge zur Spracherweiterung zu machen. Dabei ist jedoch - aufgrund der mittlerweile riesigen Menge an Software, die in JAVA geschrieben ist - stets auf Rückwärtskompatibilität zu achten, so dass revolutionäre Verbesserungen kaum möglich sind; stattdessen wird hinzugefügt. Das unterliegende Programmiermodell ist so immer dasselbe geblieben - und wird es wohl auch immer bleiben.
Die grundlegenden Werkzeuge der JAVA-Programmierung sind neben dem Editor der JAVA-Compiler javac, die JVM, die JAVA-Klassenbibliothek (das sogenannte Application Programming Interface, API) und natürlich die Dokumentation (API-Dokumentation und Sprachdefinition). Gerade für die JAVA-Programmierung gibt es jedoch zahlreiche integrierte Entwicklungsumgebungen (IDEs), und es ist niemandem zu raten, diese Werkzeuge links liegen zu lassen. Diejenigen, die einmal einen Teil ihrer wertvollen Lebenszeit mit dem richtigen Setzen des sogenannten Class Path verbracht haben, wissen, wovon ich rede. Auf der anderen Seite sind diese IDEs sehr komplex und erschlagen gerade Anfänger mit ihrem Funktionsumfang. Das ist auch der Grund, warum in diesem Kurs keine JAVA-Installation von Ihnen verlangt wird. Wer es aber wissen möchte und mit JAVA experimentieren möchte, den will ich keinesfalls davon abhalten.
Um ein JAVA-Programm, bestehend aus einer Menge von Class Files, auszuführen, muss man eine Klasse angeben, die eine Startmethode besitzt. Diese Startmethode heißt immer gleich; ihre Signatur hat die leicht zu merkende und immer wieder gerne eingetippte Form.
Dabei ist ""main"" der Name der Methode; was die anderen Elemente bedeuten, werden Sie im Laufe dieser Kurseinheit noch lernen. Auf Betriebssystemebene übergibt man dann einfach der JVM bei ihrem Aufruf den Namen der Klasse als Parameter. Klassen werden in JAVA wie in SMALLTALK per Konvention immer großgeschrieben.
Ein letztes, wichtiges Merkmal des Programmiermodells von JAVA ist die Art des Deployment, also wie in JAVA programmierte Anwendungen in die Anwendung gehen. Während früher alle namhaften Web-Browser (per Plug-in) den Start von in Webseiten eingebetteten JAVA-Anwendungen erlaubten, bleibt heute praktisch nur noch die Verteilung per sogenanntem JAVA Archive (einer .jar-Datei). Zu deren Ausführung ist jedoch eine Installation der JVM nötig.",<answer> In JAVA erfolgt das Deployment von Anwendungen oft durch die Verteilung von sogenannten JAVA Archiven (.jar-Dateien). Zur Ausführung ist jedoch eine Installation der JVM erforderlich. <answer> <question> Wie erfolgt in JAVA das Deployment von Anwendungen? <question>
"JAVA ist (wie SMALLTALK und alle in der nächsten Kurseinheit behandelten Sprachen) klassenbasiert und nicht prototypenbasiert. Das bedeutet, dass man programmieren kann, indem man Klassendefinitionen angibt. Wie bereits in Kapitel 34 erwähnt, gibt es in JAVA keine Anweisungen außerhalb von Klassen (abgesehen von Import-Anweisungen).
Wie ebenfalls bereits erwähnt wurde, besteht in JAVA ein relativ enger Zusammenhang zwischen Klassen und Dateien. Jede Datei enthält die Definition einer Klasse, die den Dateinamen (ohne Erweiterung) als Namen trägt. Eine Datei (oder Compilation Unit) kann auch mehrere Klassen enthalten, die dann natürlich verschiedene Namen haben müssen. Es darf jedoch keine dieser Klassen als ""public"" deklariert werden. Dies liegt zum Teil daran, dass die meisten integrierten Entwicklungsumgebungen für JAVA heute auf Dateibasis arbeiten und Dateien die Grundlage vieler Versionsverwaltungssysteme bilden. Daher ist es wenig üblich, mehrere Klassen in einer Datei zu definieren, es sei denn, es handelt sich um innere Klassen (siehe unten).
Bereits in Kurseinheit 3, Kapitel 28, haben wir gesagt, dass Klassen und Typen zunächst zwei verschiedene Konzepte sind, aber eine Typdefinition aus einer Klassendefinition abgeleitet werden kann. Genau das trifft auf JAVA zu: Jede Klasse definiert ihren eigenen Typ. Genauer gesagt, spezifiziert jede Klasse einen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält.
Beachten Sie, dass im Gegensatz zu STRONGTALK in JAVA der Typ bei Deklarationen ohne spitze Klammern vorangestellt wird, in Anlehnung an die Tradition von C und C++. Die spitzen Klammern in Zeile 985 kennzeichnen lediglich metasyntaktische Variablen.","<answer> JAVA ist klassenbasiert, was bedeutet, dass Programmierung durch die Definition von Klassen erfolgt. Im Gegensatz dazu sind prototypenbasierte Sprachen wie SMALLTALK auf Prototypenobjekten aufgebaut, und es gibt keine strikten Klassendefinitionen. <answer> <question> Was bedeutet es, dass JAVA eine klassenbasierte Programmiersprache ist, und wie unterscheidet sich dies von prototypenbasierten Sprachen? <question>"
"JAVA ist (wie SMALLTALK und alle in der nächsten Kurseinheit behandelten Sprachen) klassenbasiert und nicht prototypenbasiert. Das bedeutet, dass man programmieren kann, indem man Klassendefinitionen angibt. Wie bereits in Kapitel 34 erwähnt, gibt es in JAVA keine Anweisungen außerhalb von Klassen (abgesehen von Import-Anweisungen).
Wie ebenfalls bereits erwähnt wurde, besteht in JAVA ein relativ enger Zusammenhang zwischen Klassen und Dateien. Jede Datei enthält die Definition einer Klasse, die den Dateinamen (ohne Erweiterung) als Namen trägt. Eine Datei (oder Compilation Unit) kann auch mehrere Klassen enthalten, die dann natürlich verschiedene Namen haben müssen. Es darf jedoch keine dieser Klassen als ""public"" deklariert werden. Dies liegt zum Teil daran, dass die meisten integrierten Entwicklungsumgebungen für JAVA heute auf Dateibasis arbeiten und Dateien die Grundlage vieler Versionsverwaltungssysteme bilden. Daher ist es wenig üblich, mehrere Klassen in einer Datei zu definieren, es sei denn, es handelt sich um innere Klassen (siehe unten).
Bereits in Kurseinheit 3, Kapitel 28, haben wir gesagt, dass Klassen und Typen zunächst zwei verschiedene Konzepte sind, aber eine Typdefinition aus einer Klassendefinition abgeleitet werden kann. Genau das trifft auf JAVA zu: Jede Klasse definiert ihren eigenen Typ. Genauer gesagt, spezifiziert jede Klasse einen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält.
Beachten Sie, dass im Gegensatz zu STRONGTALK in JAVA der Typ bei Deklarationen ohne spitze Klammern vorangestellt wird, in Anlehnung an die Tradition von C und C++. Die spitzen Klammern in Zeile 985 kennzeichnen lediglich metasyntaktische Variablen.","<answer> In JAVA entspricht normalerweise jede Datei der Definition einer Klasse mit dem gleichen Namen wie der Dateiname (ohne Erweiterung). Es ist möglich, mehrere Klassen in einer Datei zu definieren, aber keine dieser Klassen darf als ""public"" deklariert werden. Dies liegt an Konventionen, die die meisten integrierten Entwicklungsumgebungen und Versionsverwaltungssysteme unterstützen. In der Regel sollte jede Datei eine öffentliche Klasse mit demselben Namen enthalten. <answer> <question> Welchen Zusammenhang gibt es zwischen Klassen und Dateien in JAVA, und warum dürfen mehrere Klassen nicht als ""public"" deklariert werden? <question>"
"JAVA ist (wie SMALLTALK und alle in der nächsten Kurseinheit behandelten Sprachen) klassenbasiert und nicht prototypenbasiert. Das bedeutet, dass man programmieren kann, indem man Klassendefinitionen angibt. Wie bereits in Kapitel 34 erwähnt, gibt es in JAVA keine Anweisungen außerhalb von Klassen (abgesehen von Import-Anweisungen).
Wie ebenfalls bereits erwähnt wurde, besteht in JAVA ein relativ enger Zusammenhang zwischen Klassen und Dateien. Jede Datei enthält die Definition einer Klasse, die den Dateinamen (ohne Erweiterung) als Namen trägt. Eine Datei (oder Compilation Unit) kann auch mehrere Klassen enthalten, die dann natürlich verschiedene Namen haben müssen. Es darf jedoch keine dieser Klassen als ""public"" deklariert werden. Dies liegt zum Teil daran, dass die meisten integrierten Entwicklungsumgebungen für JAVA heute auf Dateibasis arbeiten und Dateien die Grundlage vieler Versionsverwaltungssysteme bilden. Daher ist es wenig üblich, mehrere Klassen in einer Datei zu definieren, es sei denn, es handelt sich um innere Klassen (siehe unten).
Bereits in Kurseinheit 3, Kapitel 28, haben wir gesagt, dass Klassen und Typen zunächst zwei verschiedene Konzepte sind, aber eine Typdefinition aus einer Klassendefinition abgeleitet werden kann. Genau das trifft auf JAVA zu: Jede Klasse definiert ihren eigenen Typ. Genauer gesagt, spezifiziert jede Klasse einen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält.
Beachten Sie, dass im Gegensatz zu STRONGTALK in JAVA der Typ bei Deklarationen ohne spitze Klammern vorangestellt wird, in Anlehnung an die Tradition von C und C++. Die spitzen Klammern in Zeile 985 kennzeichnen lediglich metasyntaktische Variablen.",<answer> In JAVA spezifiziert jede Klasse ihren eigenen Typ. Der Typ trägt denselben Namen wie die Klasse und enthält Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften. <answer> <question> Wie wird ein Typ in JAVA aus einer Klassendefinition abgeleitet? <question>
"JAVA ist (wie SMALLTALK und alle in der nächsten Kurseinheit behandelten Sprachen) klassenbasiert und nicht prototypenbasiert. Das bedeutet, dass man programmieren kann, indem man Klassendefinitionen angibt. Wie bereits in Kapitel 34 erwähnt, gibt es in JAVA keine Anweisungen außerhalb von Klassen (abgesehen von Import-Anweisungen).
Wie ebenfalls bereits erwähnt wurde, besteht in JAVA ein relativ enger Zusammenhang zwischen Klassen und Dateien. Jede Datei enthält die Definition einer Klasse, die den Dateinamen (ohne Erweiterung) als Namen trägt. Eine Datei (oder Compilation Unit) kann auch mehrere Klassen enthalten, die dann natürlich verschiedene Namen haben müssen. Es darf jedoch keine dieser Klassen als ""public"" deklariert werden. Dies liegt zum Teil daran, dass die meisten integrierten Entwicklungsumgebungen für JAVA heute auf Dateibasis arbeiten und Dateien die Grundlage vieler Versionsverwaltungssysteme bilden. Daher ist es wenig üblich, mehrere Klassen in einer Datei zu definieren, es sei denn, es handelt sich um innere Klassen (siehe unten).
Bereits in Kurseinheit 3, Kapitel 28, haben wir gesagt, dass Klassen und Typen zunächst zwei verschiedene Konzepte sind, aber eine Typdefinition aus einer Klassendefinition abgeleitet werden kann. Genau das trifft auf JAVA zu: Jede Klasse definiert ihren eigenen Typ. Genauer gesagt, spezifiziert jede Klasse einen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält.
Beachten Sie, dass im Gegensatz zu STRONGTALK in JAVA der Typ bei Deklarationen ohne spitze Klammern vorangestellt wird, in Anlehnung an die Tradition von C und C++. Die spitzen Klammern in Zeile 985 kennzeichnen lediglich metasyntaktische Variablen.","<answer> In JAVA wird der Typ bei Deklarationen ohne spitze Klammern vorangestellt. Dies unterscheidet sich von STRONGTALK, bei dem die spitzen Klammern in Deklarationen verwendet werden. In JAVA folgt die Typangabe der Tradition von C und C++. <answer> <question> Welche Konvention wird in JAVA verwendet, um den Typ bei Deklarationen anzugeben, und wie unterscheidet sich dies von STRONGTALK? <question>"
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).",<answer> Eine Variable bezeichnet ein Objekt. <answer> <question> Was bezeichnet eine Variable in der Programmierung? <question>
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).",<answer> Die Zugriffsbeschränkung auf Variablen und Objekte erfolgt durch die Definition der Sichtbarkeit und entsprechende Regeln für die Sichtbarkeit von Variablen. <answer> <question> Warum sind nicht alle Variablen und Objekte in einem Programm von überall her zugreifbar? <question>
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).","<answer> Die Sichtbarkeit einer Variable bezieht sich immer auf einen Abschnitt des Programmcodes, in dem der Variablenname verwendet werden kann und damit Zugriff auf das von diesem Namen bezeichnete Objekt besteht. <answer> <question> Wie wird die Sichtbarkeit einer Variable definiert? <question>"
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).","<answer> Globale Variablen sind außerhalb des aktuellen Programmabschnitts sichtbar, während lokale Variablen auf den aktuellen Sichtbarkeitsbereich (Abschnitt) beschränkt sind. <answer> <question> Was sind die Unterschiede zwischen globalen und lokalen Variablen? <question>"
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).",<answer> In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. <answer> <question> Wie werden globale Variablen in SMALLTALK gekennzeichnet? <question>
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).","<answer> Nein. In SMALLTALK gibt es keinen relativen Unterschied zwischen globalen und lokalen Variablen, es gibt nur zwei verschiedene Programmabschnitte in Bezug auf die Sichtbarkeit von Variablen. <answer> <question> Gibt es in SMALLTALK eine relative Unterscheidung zwischen globalen und lokalen Variablen? <question>"
"Als man mit der objektorientierten Programmierung begann, war man glücklich, weil man glaubte, mit dem Konzept der Klassen eine natürliche Form der Kapselung (engl. encapsulation) gefunden zu haben, die zudem noch mit der hochangesehenen Theorie der abstrakten Datentypen in Einklang steht (zumindest einigermaßen): Klassen ergeben sich auf natürliche Weise aus der Anwendungsdomäne (als Repräsentanten von Allgemeinbegriffen; siehe Kurseinheit 1, Kapitel 7), und Daten sowie Implementierungsdetails lassen sich hinter der Klassenschnittstelle (dem Protokoll der Objekte) verbergen.
Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls gefeierte Vererbung die Kapselung von Klassen auf unangenehme Weise aufbrach: Wie in Kapitel 55 bemerkt, erzeugt die Vererbung starke Abhängigkeiten (auch zwischen den Implementierungsdetails!) von Klassen und ihren Subklassen. Diese Abhängigkeiten explizit zu machen kann zwar vor Programmierfehlern schützen, sie kann aber die Abhängigkeiten nicht beseitigen, sondern lediglich dokumentieren. Die Abhängigkeiten zu beschränken bedeutet wiederum, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das nun einmal: Alles hat seinen Preis.
Sehr viel dramatischer (und sehr viel weniger in aller Munde) ist jedoch ein ganz anderes Problem, das die gesamten bisherigen Bemühungen der Objektorientierung um Kapselung aushebeln kann: das Aliasing-Problem. Wenn nämlich ein Objekt, das durch ein anderes Objekt gekapselt wird, indem das andere es in einer seiner Instanzvariablen hält, einen (weiteren) Alias besitzt, der nicht selbst dem kapselnden Objekt gehört, dann nützt es nichts, wenn diese Instanzvariable von außen unzugreifbar ist91 — sie wird nämlich gar nicht gebraucht, um auf das gekapselte Objekt zuzugreifen. Man bedient sich einfach des Aliases.
In SMALLTALK wird das Problem in folgendem Beispiel klar: Hier soll ein neues Objekt der Klasse A erzeugt werden und die Erzeugungszeit in einer entsprechenden Instanzvariable des Objekts festgehalten werden. Die Variable ""jetzt"" hält aber einen Alias auf das Objekt, das diese Zeit repräsentiert; ändert man dieses Zeitobjekt (wie in Zeile 1534), dann betrifft dies auch die Erzeugungszeit des Objekts ""a"".92 Nun könnte man meinen, es genügte, man ersparte sich einfach den (offensichtlichen) Alias ""jetzt"" und schriebe stattdessen:
Woher weiß man aber, dass die Methode ""now"" in der Klasse ""Time"" nicht einen Alias auf jedes neu erzeugte Objekt anlegt (beispielsweise weil ""Time"" Buch darüber führt, welche Instanzen es von ihr gibt) und diesen Alias nicht herausgibt oder selbst verwendet, um die Objekte zu manipulieren? Auch die alternative scheinbare Lösung, ""Erzeugungsdatum"" funktioniert aus gleichem Grunde nicht zuverlässig, denn auch ""copy"" kann sich (heimlich) Aliase anlegen.
Ein anderes Beispiel, bei dem Aliase fehlerhaft eingesetzt werden, ist das folgende. Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Das ist hier aber gar nicht der Punkt. Umgehung der
Sie haben zwei Klassen, ""Ampel"" und ""Leuchte"", und bauen Ihre Objekte. Wenn Sie nun einem Fußgänger per ""grünes Licht"" geben wollen, gehen leider mit der einen gleich alle vier grünen Leuchten an. War das in Ihrem Sinn?
Man nennt Objekte, die die Implementierung eines Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen, ""Repräsentationsobjekte"". Die Leuchten des obigen Beispiels sind allesamt Repräsentationsobjekte; sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen. Insbesondere gibt es in obigem Beispiel keine Verwendung einer Leuchte losgelöst von einer Ampel. Dies muss aber nicht für alle Leuchten der Fall sein — es ist durchaus denkbar, dass Leuchtenobjekte in anderen oder sogar im selben Programm auch ein unabhängiges Leben (außerhalb von Ampeln) führen. Aber selbst das ist gar nicht notwendig — im gegebenen Beispiel wäre es auch denkbar, dass mit Leuchten noch einiges gemacht wird, bevor sie in eine Ampel eingebaut werden, so dass man das Aliasing-Problem weder pauschal an die Klasse ""Leuchte"" noch an deren Verwendung als Lieferant für Repräsentationsobjekte knüpfen kann.
Wenn Aliase also schlecht sind, könnte man sie ja auch einfach verbieten. Tatsächlich bieten einige Programmiersprachen wie C#, C++ und EIFFEL die Möglichkeit, Klassen als Werttypen zu definieren, sodass bei Zuweisungen nicht automatisch Aliase entstehen. Aber durch eine derart einfache Lösung schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein, wie das folgende Beispiel zeigt:
Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.
Nachdem das Problem nun hinreichend klar geworden sein sollte, was kann man dagegen tun? Zunächst einmal muss noch einmal klargestellt werden, dass die Deklaration von Instanzvariablen als von außen unzugreifbar (private) lediglich Namen verbirgt — man kann über die Schnittstelle des Objekts nicht herausfinden, wie es intern aufgebaut ist. Dieser Namensschutz (engl. name protection) ist das, was man landläufig (mit dem Wissen vom Aliasing-Problem) mit Geheimnisprinzip (engl. information hiding) verbindet: Es verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, so dass diese problemlos geändert (z. B. umbenannt oder entfernt) werden können.
Das Geheimnisprinzip vermag jedoch nicht zu verhindern, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen. Dies kann z. B. immer dann der Fall sein (und ist vom Objekt, das sein Implementationsgeheimnis wahren will, kaum zu verhindern), wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt (genau so, wie das in den obigen Beispielen in den Zeilen 1533, 1535 und 1540 der Fall war). Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter, aber das wäre dann vom „verbergenden“ Objekt selbst zu verantworten (und zu verhindern gewesen).
Sobald also die Möglichkeit des Aliasing besteht, ist eine echte Kapselung über das Geheimnisprinzip allein nicht mehr zu gewährleisten. Man muss also das Aliasing irgendwie kontrollieren. Die Frage ist nur: Wie?
Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5 genannten Programmiersprachen ist das jedoch nur in C#, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.
Vor diesem Hintergrund scheint der in Abschnitt 52.5.2 dargelegte Umgang EIFFELs mit Referenz- und Wertvariablen ziemlich schlau ausgedacht zu sein. Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei. Dumm ist nur, wenn man innerhalb der Kapsel Aliase auf Wertobjekte braucht. Weitergehende Mechanismen zur Aliaskontrolle in objektorientierten Programmiersprachen befinden sich derzeit alle noch in der Vorschlags- und Erprobungsphase und sollen hier deswegen nicht weiter behandelt werden.","<answer> Anfangs glaubte man, dass die objektorientierte Programmierung durch das Konzept der Klassen eine natürliche Form der Kapselung gefunden hatte. Dies wurde auch mit der Theorie der abstrakten Datentypen in Einklang gebracht. Klassen sollten natürliche Repräsentanten von Allgemeinbegriffen sein, und Daten sowie Implementierungsdetails sollten hinter der Klassenschnittstelle verborgen werden. <answer> <question> Was war die anfängliche Erwartung in Bezug auf Kapselung in der objektorientierten Programmierung, und warum? <question>"
"Als man mit der objektorientierten Programmierung begann, war man glücklich, weil man glaubte, mit dem Konzept der Klassen eine natürliche Form der Kapselung (engl. encapsulation) gefunden zu haben, die zudem noch mit der hochangesehenen Theorie der abstrakten Datentypen in Einklang steht (zumindest einigermaßen): Klassen ergeben sich auf natürliche Weise aus der Anwendungsdomäne (als Repräsentanten von Allgemeinbegriffen; siehe Kurseinheit 1, Kapitel 7), und Daten sowie Implementierungsdetails lassen sich hinter der Klassenschnittstelle (dem Protokoll der Objekte) verbergen.
Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls gefeierte Vererbung die Kapselung von Klassen auf unangenehme Weise aufbrach: Wie in Kapitel 55 bemerkt, erzeugt die Vererbung starke Abhängigkeiten (auch zwischen den Implementierungsdetails!) von Klassen und ihren Subklassen. Diese Abhängigkeiten explizit zu machen kann zwar vor Programmierfehlern schützen, sie kann aber die Abhängigkeiten nicht beseitigen, sondern lediglich dokumentieren. Die Abhängigkeiten zu beschränken bedeutet wiederum, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das nun einmal: Alles hat seinen Preis.
Sehr viel dramatischer (und sehr viel weniger in aller Munde) ist jedoch ein ganz anderes Problem, das die gesamten bisherigen Bemühungen der Objektorientierung um Kapselung aushebeln kann: das Aliasing-Problem. Wenn nämlich ein Objekt, das durch ein anderes Objekt gekapselt wird, indem das andere es in einer seiner Instanzvariablen hält, einen (weiteren) Alias besitzt, der nicht selbst dem kapselnden Objekt gehört, dann nützt es nichts, wenn diese Instanzvariable von außen unzugreifbar ist91 — sie wird nämlich gar nicht gebraucht, um auf das gekapselte Objekt zuzugreifen. Man bedient sich einfach des Aliases.
In SMALLTALK wird das Problem in folgendem Beispiel klar: Hier soll ein neues Objekt der Klasse A erzeugt werden und die Erzeugungszeit in einer entsprechenden Instanzvariable des Objekts festgehalten werden. Die Variable ""jetzt"" hält aber einen Alias auf das Objekt, das diese Zeit repräsentiert; ändert man dieses Zeitobjekt (wie in Zeile 1534), dann betrifft dies auch die Erzeugungszeit des Objekts ""a"".92 Nun könnte man meinen, es genügte, man ersparte sich einfach den (offensichtlichen) Alias ""jetzt"" und schriebe stattdessen:
Woher weiß man aber, dass die Methode ""now"" in der Klasse ""Time"" nicht einen Alias auf jedes neu erzeugte Objekt anlegt (beispielsweise weil ""Time"" Buch darüber führt, welche Instanzen es von ihr gibt) und diesen Alias nicht herausgibt oder selbst verwendet, um die Objekte zu manipulieren? Auch die alternative scheinbare Lösung, ""Erzeugungsdatum"" funktioniert aus gleichem Grunde nicht zuverlässig, denn auch ""copy"" kann sich (heimlich) Aliase anlegen.
Ein anderes Beispiel, bei dem Aliase fehlerhaft eingesetzt werden, ist das folgende. Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Das ist hier aber gar nicht der Punkt. Umgehung der
Sie haben zwei Klassen, ""Ampel"" und ""Leuchte"", und bauen Ihre Objekte. Wenn Sie nun einem Fußgänger per ""grünes Licht"" geben wollen, gehen leider mit der einen gleich alle vier grünen Leuchten an. War das in Ihrem Sinn?
Man nennt Objekte, die die Implementierung eines Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen, ""Repräsentationsobjekte"". Die Leuchten des obigen Beispiels sind allesamt Repräsentationsobjekte; sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen. Insbesondere gibt es in obigem Beispiel keine Verwendung einer Leuchte losgelöst von einer Ampel. Dies muss aber nicht für alle Leuchten der Fall sein — es ist durchaus denkbar, dass Leuchtenobjekte in anderen oder sogar im selben Programm auch ein unabhängiges Leben (außerhalb von Ampeln) führen. Aber selbst das ist gar nicht notwendig — im gegebenen Beispiel wäre es auch denkbar, dass mit Leuchten noch einiges gemacht wird, bevor sie in eine Ampel eingebaut werden, so dass man das Aliasing-Problem weder pauschal an die Klasse ""Leuchte"" noch an deren Verwendung als Lieferant für Repräsentationsobjekte knüpfen kann.
Wenn Aliase also schlecht sind, könnte man sie ja auch einfach verbieten. Tatsächlich bieten einige Programmiersprachen wie C#, C++ und EIFFEL die Möglichkeit, Klassen als Werttypen zu definieren, sodass bei Zuweisungen nicht automatisch Aliase entstehen. Aber durch eine derart einfache Lösung schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein, wie das folgende Beispiel zeigt:
Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.
Nachdem das Problem nun hinreichend klar geworden sein sollte, was kann man dagegen tun? Zunächst einmal muss noch einmal klargestellt werden, dass die Deklaration von Instanzvariablen als von außen unzugreifbar (private) lediglich Namen verbirgt — man kann über die Schnittstelle des Objekts nicht herausfinden, wie es intern aufgebaut ist. Dieser Namensschutz (engl. name protection) ist das, was man landläufig (mit dem Wissen vom Aliasing-Problem) mit Geheimnisprinzip (engl. information hiding) verbindet: Es verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, so dass diese problemlos geändert (z. B. umbenannt oder entfernt) werden können.
Das Geheimnisprinzip vermag jedoch nicht zu verhindern, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen. Dies kann z. B. immer dann der Fall sein (und ist vom Objekt, das sein Implementationsgeheimnis wahren will, kaum zu verhindern), wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt (genau so, wie das in den obigen Beispielen in den Zeilen 1533, 1535 und 1540 der Fall war). Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter, aber das wäre dann vom „verbergenden“ Objekt selbst zu verantworten (und zu verhindern gewesen).
Sobald also die Möglichkeit des Aliasing besteht, ist eine echte Kapselung über das Geheimnisprinzip allein nicht mehr zu gewährleisten. Man muss also das Aliasing irgendwie kontrollieren. Die Frage ist nur: Wie?
Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5 genannten Programmiersprachen ist das jedoch nur in C#, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.
Vor diesem Hintergrund scheint der in Abschnitt 52.5.2 dargelegte Umgang EIFFELs mit Referenz- und Wertvariablen ziemlich schlau ausgedacht zu sein. Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei. Dumm ist nur, wenn man innerhalb der Kapsel Aliase auf Wertobjekte braucht. Weitergehende Mechanismen zur Aliaskontrolle in objektorientierten Programmiersprachen befinden sich derzeit alle noch in der Vorschlags- und Erprobungsphase und sollen hier deswegen nicht weiter behandelt werden.","<answer> Die Enttäuschung trat auf, als man feststellte, dass die Vererbung in der objektorientierten Programmierung die Kapselung von Klassen auf unangenehme Weise beeinträchtigte. Vererbung führte zu starken Abhängigkeiten zwischen Klassen und ihren Subklassen, einschließlich der Implementierungsdetails. Diese Abhängigkeiten konnten dokumentiert, aber nicht beseitigt werden, und sie führten dazu, dass Teile der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufgegeben werden mussten. <answer> <question> Welche Enttäuschung trat auf, die die Kapselung von Klassen beeinflusste? <question>"
"Als man mit der objektorientierten Programmierung begann, war man glücklich, weil man glaubte, mit dem Konzept der Klassen eine natürliche Form der Kapselung (engl. encapsulation) gefunden zu haben, die zudem noch mit der hochangesehenen Theorie der abstrakten Datentypen in Einklang steht (zumindest einigermaßen): Klassen ergeben sich auf natürliche Weise aus der Anwendungsdomäne (als Repräsentanten von Allgemeinbegriffen; siehe Kurseinheit 1, Kapitel 7), und Daten sowie Implementierungsdetails lassen sich hinter der Klassenschnittstelle (dem Protokoll der Objekte) verbergen.
Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls gefeierte Vererbung die Kapselung von Klassen auf unangenehme Weise aufbrach: Wie in Kapitel 55 bemerkt, erzeugt die Vererbung starke Abhängigkeiten (auch zwischen den Implementierungsdetails!) von Klassen und ihren Subklassen. Diese Abhängigkeiten explizit zu machen kann zwar vor Programmierfehlern schützen, sie kann aber die Abhängigkeiten nicht beseitigen, sondern lediglich dokumentieren. Die Abhängigkeiten zu beschränken bedeutet wiederum, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das nun einmal: Alles hat seinen Preis.
Sehr viel dramatischer (und sehr viel weniger in aller Munde) ist jedoch ein ganz anderes Problem, das die gesamten bisherigen Bemühungen der Objektorientierung um Kapselung aushebeln kann: das Aliasing-Problem. Wenn nämlich ein Objekt, das durch ein anderes Objekt gekapselt wird, indem das andere es in einer seiner Instanzvariablen hält, einen (weiteren) Alias besitzt, der nicht selbst dem kapselnden Objekt gehört, dann nützt es nichts, wenn diese Instanzvariable von außen unzugreifbar ist91 — sie wird nämlich gar nicht gebraucht, um auf das gekapselte Objekt zuzugreifen. Man bedient sich einfach des Aliases.
In SMALLTALK wird das Problem in folgendem Beispiel klar: Hier soll ein neues Objekt der Klasse A erzeugt werden und die Erzeugungszeit in einer entsprechenden Instanzvariable des Objekts festgehalten werden. Die Variable ""jetzt"" hält aber einen Alias auf das Objekt, das diese Zeit repräsentiert; ändert man dieses Zeitobjekt (wie in Zeile 1534), dann betrifft dies auch die Erzeugungszeit des Objekts ""a"".92 Nun könnte man meinen, es genügte, man ersparte sich einfach den (offensichtlichen) Alias ""jetzt"" und schriebe stattdessen:
Woher weiß man aber, dass die Methode ""now"" in der Klasse ""Time"" nicht einen Alias auf jedes neu erzeugte Objekt anlegt (beispielsweise weil ""Time"" Buch darüber führt, welche Instanzen es von ihr gibt) und diesen Alias nicht herausgibt oder selbst verwendet, um die Objekte zu manipulieren? Auch die alternative scheinbare Lösung, ""Erzeugungsdatum"" funktioniert aus gleichem Grunde nicht zuverlässig, denn auch ""copy"" kann sich (heimlich) Aliase anlegen.
Ein anderes Beispiel, bei dem Aliase fehlerhaft eingesetzt werden, ist das folgende. Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Das ist hier aber gar nicht der Punkt. Umgehung der
Sie haben zwei Klassen, ""Ampel"" und ""Leuchte"", und bauen Ihre Objekte. Wenn Sie nun einem Fußgänger per ""grünes Licht"" geben wollen, gehen leider mit der einen gleich alle vier grünen Leuchten an. War das in Ihrem Sinn?
Man nennt Objekte, die die Implementierung eines Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen, ""Repräsentationsobjekte"". Die Leuchten des obigen Beispiels sind allesamt Repräsentationsobjekte; sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen. Insbesondere gibt es in obigem Beispiel keine Verwendung einer Leuchte losgelöst von einer Ampel. Dies muss aber nicht für alle Leuchten der Fall sein — es ist durchaus denkbar, dass Leuchtenobjekte in anderen oder sogar im selben Programm auch ein unabhängiges Leben (außerhalb von Ampeln) führen. Aber selbst das ist gar nicht notwendig — im gegebenen Beispiel wäre es auch denkbar, dass mit Leuchten noch einiges gemacht wird, bevor sie in eine Ampel eingebaut werden, so dass man das Aliasing-Problem weder pauschal an die Klasse ""Leuchte"" noch an deren Verwendung als Lieferant für Repräsentationsobjekte knüpfen kann.
Wenn Aliase also schlecht sind, könnte man sie ja auch einfach verbieten. Tatsächlich bieten einige Programmiersprachen wie C#, C++ und EIFFEL die Möglichkeit, Klassen als Werttypen zu definieren, sodass bei Zuweisungen nicht automatisch Aliase entstehen. Aber durch eine derart einfache Lösung schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein, wie das folgende Beispiel zeigt:
Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.
Nachdem das Problem nun hinreichend klar geworden sein sollte, was kann man dagegen tun? Zunächst einmal muss noch einmal klargestellt werden, dass die Deklaration von Instanzvariablen als von außen unzugreifbar (private) lediglich Namen verbirgt — man kann über die Schnittstelle des Objekts nicht herausfinden, wie es intern aufgebaut ist. Dieser Namensschutz (engl. name protection) ist das, was man landläufig (mit dem Wissen vom Aliasing-Problem) mit Geheimnisprinzip (engl. information hiding) verbindet: Es verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, so dass diese problemlos geändert (z. B. umbenannt oder entfernt) werden können.
Das Geheimnisprinzip vermag jedoch nicht zu verhindern, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen. Dies kann z. B. immer dann der Fall sein (und ist vom Objekt, das sein Implementationsgeheimnis wahren will, kaum zu verhindern), wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt (genau so, wie das in den obigen Beispielen in den Zeilen 1533, 1535 und 1540 der Fall war). Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter, aber das wäre dann vom „verbergenden“ Objekt selbst zu verantworten (und zu verhindern gewesen).
Sobald also die Möglichkeit des Aliasing besteht, ist eine echte Kapselung über das Geheimnisprinzip allein nicht mehr zu gewährleisten. Man muss also das Aliasing irgendwie kontrollieren. Die Frage ist nur: Wie?
Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5 genannten Programmiersprachen ist das jedoch nur in C#, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.
Vor diesem Hintergrund scheint der in Abschnitt 52.5.2 dargelegte Umgang EIFFELs mit Referenz- und Wertvariablen ziemlich schlau ausgedacht zu sein. Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei. Dumm ist nur, wenn man innerhalb der Kapsel Aliase auf Wertobjekte braucht. Weitergehende Mechanismen zur Aliaskontrolle in objektorientierten Programmiersprachen befinden sich derzeit alle noch in der Vorschlags- und Erprobungsphase und sollen hier deswegen nicht weiter behandelt werden.","<answer> Das Aliasing-Problem tritt auf, wenn ein Objekt, das von einem anderen Objekt gekapselt wird, auch einen Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dies bedeutet, dass von außen auf das gekapselte Objekt zugegriffen werden kann, indem man den Alias verwendet. Dies stellt eine Herausforderung für die Kapselung dar, da es die Geheimhaltung der Implementierung durchbrechen kann. <answer> <question> Was ist das Aliasing-Problem, und warum stellt es eine Herausforderung für die Kapselung dar? <question>"
"Als man mit der objektorientierten Programmierung begann, war man glücklich, weil man glaubte, mit dem Konzept der Klassen eine natürliche Form der Kapselung (engl. encapsulation) gefunden zu haben, die zudem noch mit der hochangesehenen Theorie der abstrakten Datentypen in Einklang steht (zumindest einigermaßen): Klassen ergeben sich auf natürliche Weise aus der Anwendungsdomäne (als Repräsentanten von Allgemeinbegriffen; siehe Kurseinheit 1, Kapitel 7), und Daten sowie Implementierungsdetails lassen sich hinter der Klassenschnittstelle (dem Protokoll der Objekte) verbergen.
Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls gefeierte Vererbung die Kapselung von Klassen auf unangenehme Weise aufbrach: Wie in Kapitel 55 bemerkt, erzeugt die Vererbung starke Abhängigkeiten (auch zwischen den Implementierungsdetails!) von Klassen und ihren Subklassen. Diese Abhängigkeiten explizit zu machen kann zwar vor Programmierfehlern schützen, sie kann aber die Abhängigkeiten nicht beseitigen, sondern lediglich dokumentieren. Die Abhängigkeiten zu beschränken bedeutet wiederum, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das nun einmal: Alles hat seinen Preis.
Sehr viel dramatischer (und sehr viel weniger in aller Munde) ist jedoch ein ganz anderes Problem, das die gesamten bisherigen Bemühungen der Objektorientierung um Kapselung aushebeln kann: das Aliasing-Problem. Wenn nämlich ein Objekt, das durch ein anderes Objekt gekapselt wird, indem das andere es in einer seiner Instanzvariablen hält, einen (weiteren) Alias besitzt, der nicht selbst dem kapselnden Objekt gehört, dann nützt es nichts, wenn diese Instanzvariable von außen unzugreifbar ist91 — sie wird nämlich gar nicht gebraucht, um auf das gekapselte Objekt zuzugreifen. Man bedient sich einfach des Aliases.
In SMALLTALK wird das Problem in folgendem Beispiel klar: Hier soll ein neues Objekt der Klasse A erzeugt werden und die Erzeugungszeit in einer entsprechenden Instanzvariable des Objekts festgehalten werden. Die Variable ""jetzt"" hält aber einen Alias auf das Objekt, das diese Zeit repräsentiert; ändert man dieses Zeitobjekt (wie in Zeile 1534), dann betrifft dies auch die Erzeugungszeit des Objekts ""a"".92 Nun könnte man meinen, es genügte, man ersparte sich einfach den (offensichtlichen) Alias ""jetzt"" und schriebe stattdessen:
Woher weiß man aber, dass die Methode ""now"" in der Klasse ""Time"" nicht einen Alias auf jedes neu erzeugte Objekt anlegt (beispielsweise weil ""Time"" Buch darüber führt, welche Instanzen es von ihr gibt) und diesen Alias nicht herausgibt oder selbst verwendet, um die Objekte zu manipulieren? Auch die alternative scheinbare Lösung, ""Erzeugungsdatum"" funktioniert aus gleichem Grunde nicht zuverlässig, denn auch ""copy"" kann sich (heimlich) Aliase anlegen.
Ein anderes Beispiel, bei dem Aliase fehlerhaft eingesetzt werden, ist das folgende. Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Das ist hier aber gar nicht der Punkt. Umgehung der
Sie haben zwei Klassen, ""Ampel"" und ""Leuchte"", und bauen Ihre Objekte. Wenn Sie nun einem Fußgänger per ""grünes Licht"" geben wollen, gehen leider mit der einen gleich alle vier grünen Leuchten an. War das in Ihrem Sinn?
Man nennt Objekte, die die Implementierung eines Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen, ""Repräsentationsobjekte"". Die Leuchten des obigen Beispiels sind allesamt Repräsentationsobjekte; sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen. Insbesondere gibt es in obigem Beispiel keine Verwendung einer Leuchte losgelöst von einer Ampel. Dies muss aber nicht für alle Leuchten der Fall sein — es ist durchaus denkbar, dass Leuchtenobjekte in anderen oder sogar im selben Programm auch ein unabhängiges Leben (außerhalb von Ampeln) führen. Aber selbst das ist gar nicht notwendig — im gegebenen Beispiel wäre es auch denkbar, dass mit Leuchten noch einiges gemacht wird, bevor sie in eine Ampel eingebaut werden, so dass man das Aliasing-Problem weder pauschal an die Klasse ""Leuchte"" noch an deren Verwendung als Lieferant für Repräsentationsobjekte knüpfen kann.
Wenn Aliase also schlecht sind, könnte man sie ja auch einfach verbieten. Tatsächlich bieten einige Programmiersprachen wie C#, C++ und EIFFEL die Möglichkeit, Klassen als Werttypen zu definieren, sodass bei Zuweisungen nicht automatisch Aliase entstehen. Aber durch eine derart einfache Lösung schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein, wie das folgende Beispiel zeigt:
Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.
Nachdem das Problem nun hinreichend klar geworden sein sollte, was kann man dagegen tun? Zunächst einmal muss noch einmal klargestellt werden, dass die Deklaration von Instanzvariablen als von außen unzugreifbar (private) lediglich Namen verbirgt — man kann über die Schnittstelle des Objekts nicht herausfinden, wie es intern aufgebaut ist. Dieser Namensschutz (engl. name protection) ist das, was man landläufig (mit dem Wissen vom Aliasing-Problem) mit Geheimnisprinzip (engl. information hiding) verbindet: Es verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, so dass diese problemlos geändert (z. B. umbenannt oder entfernt) werden können.
Das Geheimnisprinzip vermag jedoch nicht zu verhindern, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen. Dies kann z. B. immer dann der Fall sein (und ist vom Objekt, das sein Implementationsgeheimnis wahren will, kaum zu verhindern), wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt (genau so, wie das in den obigen Beispielen in den Zeilen 1533, 1535 und 1540 der Fall war). Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter, aber das wäre dann vom „verbergenden“ Objekt selbst zu verantworten (und zu verhindern gewesen).
Sobald also die Möglichkeit des Aliasing besteht, ist eine echte Kapselung über das Geheimnisprinzip allein nicht mehr zu gewährleisten. Man muss also das Aliasing irgendwie kontrollieren. Die Frage ist nur: Wie?
Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5 genannten Programmiersprachen ist das jedoch nur in C#, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.
Vor diesem Hintergrund scheint der in Abschnitt 52.5.2 dargelegte Umgang EIFFELs mit Referenz- und Wertvariablen ziemlich schlau ausgedacht zu sein. Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei. Dumm ist nur, wenn man innerhalb der Kapsel Aliase auf Wertobjekte braucht. Weitergehende Mechanismen zur Aliaskontrolle in objektorientierten Programmiersprachen befinden sich derzeit alle noch in der Vorschlags- und Erprobungsphase und sollen hier deswegen nicht weiter behandelt werden.","<answer> Private Instanzvariablen können allein das Aliasing-Problem nicht lösen, da sie lediglich Namen verbergen und nicht verhindern können, dass Repräsentationsobjekte (Implementierungsdetails) Aliasen ausgesetzt sind. <answer> <question> Warum können private Instanzvariablen allein das Aliasing-Problem nicht lösen? <question>"
"Als man mit der objektorientierten Programmierung begann, war man glücklich, weil man glaubte, mit dem Konzept der Klassen eine natürliche Form der Kapselung (engl. encapsulation) gefunden zu haben, die zudem noch mit der hochangesehenen Theorie der abstrakten Datentypen in Einklang steht (zumindest einigermaßen): Klassen ergeben sich auf natürliche Weise aus der Anwendungsdomäne (als Repräsentanten von Allgemeinbegriffen; siehe Kurseinheit 1, Kapitel 7), und Daten sowie Implementierungsdetails lassen sich hinter der Klassenschnittstelle (dem Protokoll der Objekte) verbergen.
Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls gefeierte Vererbung die Kapselung von Klassen auf unangenehme Weise aufbrach: Wie in Kapitel 55 bemerkt, erzeugt die Vererbung starke Abhängigkeiten (auch zwischen den Implementierungsdetails!) von Klassen und ihren Subklassen. Diese Abhängigkeiten explizit zu machen kann zwar vor Programmierfehlern schützen, sie kann aber die Abhängigkeiten nicht beseitigen, sondern lediglich dokumentieren. Die Abhängigkeiten zu beschränken bedeutet wiederum, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das nun einmal: Alles hat seinen Preis.
Sehr viel dramatischer (und sehr viel weniger in aller Munde) ist jedoch ein ganz anderes Problem, das die gesamten bisherigen Bemühungen der Objektorientierung um Kapselung aushebeln kann: das Aliasing-Problem. Wenn nämlich ein Objekt, das durch ein anderes Objekt gekapselt wird, indem das andere es in einer seiner Instanzvariablen hält, einen (weiteren) Alias besitzt, der nicht selbst dem kapselnden Objekt gehört, dann nützt es nichts, wenn diese Instanzvariable von außen unzugreifbar ist91 — sie wird nämlich gar nicht gebraucht, um auf das gekapselte Objekt zuzugreifen. Man bedient sich einfach des Aliases.
In SMALLTALK wird das Problem in folgendem Beispiel klar: Hier soll ein neues Objekt der Klasse A erzeugt werden und die Erzeugungszeit in einer entsprechenden Instanzvariable des Objekts festgehalten werden. Die Variable ""jetzt"" hält aber einen Alias auf das Objekt, das diese Zeit repräsentiert; ändert man dieses Zeitobjekt (wie in Zeile 1534), dann betrifft dies auch die Erzeugungszeit des Objekts ""a"".92 Nun könnte man meinen, es genügte, man ersparte sich einfach den (offensichtlichen) Alias ""jetzt"" und schriebe stattdessen:
Woher weiß man aber, dass die Methode ""now"" in der Klasse ""Time"" nicht einen Alias auf jedes neu erzeugte Objekt anlegt (beispielsweise weil ""Time"" Buch darüber führt, welche Instanzen es von ihr gibt) und diesen Alias nicht herausgibt oder selbst verwendet, um die Objekte zu manipulieren? Auch die alternative scheinbare Lösung, ""Erzeugungsdatum"" funktioniert aus gleichem Grunde nicht zuverlässig, denn auch ""copy"" kann sich (heimlich) Aliase anlegen.
Ein anderes Beispiel, bei dem Aliase fehlerhaft eingesetzt werden, ist das folgende. Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Das ist hier aber gar nicht der Punkt. Umgehung der
Sie haben zwei Klassen, ""Ampel"" und ""Leuchte"", und bauen Ihre Objekte. Wenn Sie nun einem Fußgänger per ""grünes Licht"" geben wollen, gehen leider mit der einen gleich alle vier grünen Leuchten an. War das in Ihrem Sinn?
Man nennt Objekte, die die Implementierung eines Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen, ""Repräsentationsobjekte"". Die Leuchten des obigen Beispiels sind allesamt Repräsentationsobjekte; sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen. Insbesondere gibt es in obigem Beispiel keine Verwendung einer Leuchte losgelöst von einer Ampel. Dies muss aber nicht für alle Leuchten der Fall sein — es ist durchaus denkbar, dass Leuchtenobjekte in anderen oder sogar im selben Programm auch ein unabhängiges Leben (außerhalb von Ampeln) führen. Aber selbst das ist gar nicht notwendig — im gegebenen Beispiel wäre es auch denkbar, dass mit Leuchten noch einiges gemacht wird, bevor sie in eine Ampel eingebaut werden, so dass man das Aliasing-Problem weder pauschal an die Klasse ""Leuchte"" noch an deren Verwendung als Lieferant für Repräsentationsobjekte knüpfen kann.
Wenn Aliase also schlecht sind, könnte man sie ja auch einfach verbieten. Tatsächlich bieten einige Programmiersprachen wie C#, C++ und EIFFEL die Möglichkeit, Klassen als Werttypen zu definieren, sodass bei Zuweisungen nicht automatisch Aliase entstehen. Aber durch eine derart einfache Lösung schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein, wie das folgende Beispiel zeigt:
Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.
Nachdem das Problem nun hinreichend klar geworden sein sollte, was kann man dagegen tun? Zunächst einmal muss noch einmal klargestellt werden, dass die Deklaration von Instanzvariablen als von außen unzugreifbar (private) lediglich Namen verbirgt — man kann über die Schnittstelle des Objekts nicht herausfinden, wie es intern aufgebaut ist. Dieser Namensschutz (engl. name protection) ist das, was man landläufig (mit dem Wissen vom Aliasing-Problem) mit Geheimnisprinzip (engl. information hiding) verbindet: Es verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, so dass diese problemlos geändert (z. B. umbenannt oder entfernt) werden können.
Das Geheimnisprinzip vermag jedoch nicht zu verhindern, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen. Dies kann z. B. immer dann der Fall sein (und ist vom Objekt, das sein Implementationsgeheimnis wahren will, kaum zu verhindern), wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt (genau so, wie das in den obigen Beispielen in den Zeilen 1533, 1535 und 1540 der Fall war). Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter, aber das wäre dann vom „verbergenden“ Objekt selbst zu verantworten (und zu verhindern gewesen).
Sobald also die Möglichkeit des Aliasing besteht, ist eine echte Kapselung über das Geheimnisprinzip allein nicht mehr zu gewährleisten. Man muss also das Aliasing irgendwie kontrollieren. Die Frage ist nur: Wie?
Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5 genannten Programmiersprachen ist das jedoch nur in C#, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.
Vor diesem Hintergrund scheint der in Abschnitt 52.5.2 dargelegte Umgang EIFFELs mit Referenz- und Wertvariablen ziemlich schlau ausgedacht zu sein. Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei. Dumm ist nur, wenn man innerhalb der Kapsel Aliase auf Wertobjekte braucht. Weitergehende Mechanismen zur Aliaskontrolle in objektorientierten Programmiersprachen befinden sich derzeit alle noch in der Vorschlags- und Erprobungsphase und sollen hier deswegen nicht weiter behandelt werden.","<answer> Das Verbot von Aliasing in einigen Programmiersprachen kann nicht immer eine geeignete Lösung sein, da es zahlreiche Anwendungsfälle gibt, in denen die Verwendung von Aliasing notwendig oder sinnvoll ist. Zum Beispiel können bestimmte Datenstrukturen oder Container von Natur aus Aliase erfordern, um effizient zu arbeiten. <answer> <question> Warum kann das Verbot von Aliasing in einigen Programmiersprachen nicht immer eine geeignete Lösung sein? <question>"
"Als man mit der objektorientierten Programmierung begann, war man glücklich, weil man glaubte, mit dem Konzept der Klassen eine natürliche Form der Kapselung (engl. encapsulation) gefunden zu haben, die zudem noch mit der hochangesehenen Theorie der abstrakten Datentypen in Einklang steht (zumindest einigermaßen): Klassen ergeben sich auf natürliche Weise aus der Anwendungsdomäne (als Repräsentanten von Allgemeinbegriffen; siehe Kurseinheit 1, Kapitel 7), und Daten sowie Implementierungsdetails lassen sich hinter der Klassenschnittstelle (dem Protokoll der Objekte) verbergen.
Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls gefeierte Vererbung die Kapselung von Klassen auf unangenehme Weise aufbrach: Wie in Kapitel 55 bemerkt, erzeugt die Vererbung starke Abhängigkeiten (auch zwischen den Implementierungsdetails!) von Klassen und ihren Subklassen. Diese Abhängigkeiten explizit zu machen kann zwar vor Programmierfehlern schützen, sie kann aber die Abhängigkeiten nicht beseitigen, sondern lediglich dokumentieren. Die Abhängigkeiten zu beschränken bedeutet wiederum, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das nun einmal: Alles hat seinen Preis.
Sehr viel dramatischer (und sehr viel weniger in aller Munde) ist jedoch ein ganz anderes Problem, das die gesamten bisherigen Bemühungen der Objektorientierung um Kapselung aushebeln kann: das Aliasing-Problem. Wenn nämlich ein Objekt, das durch ein anderes Objekt gekapselt wird, indem das andere es in einer seiner Instanzvariablen hält, einen (weiteren) Alias besitzt, der nicht selbst dem kapselnden Objekt gehört, dann nützt es nichts, wenn diese Instanzvariable von außen unzugreifbar ist91 — sie wird nämlich gar nicht gebraucht, um auf das gekapselte Objekt zuzugreifen. Man bedient sich einfach des Aliases.
In SMALLTALK wird das Problem in folgendem Beispiel klar: Hier soll ein neues Objekt der Klasse A erzeugt werden und die Erzeugungszeit in einer entsprechenden Instanzvariable des Objekts festgehalten werden. Die Variable ""jetzt"" hält aber einen Alias auf das Objekt, das diese Zeit repräsentiert; ändert man dieses Zeitobjekt (wie in Zeile 1534), dann betrifft dies auch die Erzeugungszeit des Objekts ""a"".92 Nun könnte man meinen, es genügte, man ersparte sich einfach den (offensichtlichen) Alias ""jetzt"" und schriebe stattdessen:
Woher weiß man aber, dass die Methode ""now"" in der Klasse ""Time"" nicht einen Alias auf jedes neu erzeugte Objekt anlegt (beispielsweise weil ""Time"" Buch darüber führt, welche Instanzen es von ihr gibt) und diesen Alias nicht herausgibt oder selbst verwendet, um die Objekte zu manipulieren? Auch die alternative scheinbare Lösung, ""Erzeugungsdatum"" funktioniert aus gleichem Grunde nicht zuverlässig, denn auch ""copy"" kann sich (heimlich) Aliase anlegen.
Ein anderes Beispiel, bei dem Aliase fehlerhaft eingesetzt werden, ist das folgende. Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Das ist hier aber gar nicht der Punkt. Umgehung der
Sie haben zwei Klassen, ""Ampel"" und ""Leuchte"", und bauen Ihre Objekte. Wenn Sie nun einem Fußgänger per ""grünes Licht"" geben wollen, gehen leider mit der einen gleich alle vier grünen Leuchten an. War das in Ihrem Sinn?
Man nennt Objekte, die die Implementierung eines Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen, ""Repräsentationsobjekte"". Die Leuchten des obigen Beispiels sind allesamt Repräsentationsobjekte; sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen. Insbesondere gibt es in obigem Beispiel keine Verwendung einer Leuchte losgelöst von einer Ampel. Dies muss aber nicht für alle Leuchten der Fall sein — es ist durchaus denkbar, dass Leuchtenobjekte in anderen oder sogar im selben Programm auch ein unabhängiges Leben (außerhalb von Ampeln) führen. Aber selbst das ist gar nicht notwendig — im gegebenen Beispiel wäre es auch denkbar, dass mit Leuchten noch einiges gemacht wird, bevor sie in eine Ampel eingebaut werden, so dass man das Aliasing-Problem weder pauschal an die Klasse ""Leuchte"" noch an deren Verwendung als Lieferant für Repräsentationsobjekte knüpfen kann.
Wenn Aliase also schlecht sind, könnte man sie ja auch einfach verbieten. Tatsächlich bieten einige Programmiersprachen wie C#, C++ und EIFFEL die Möglichkeit, Klassen als Werttypen zu definieren, sodass bei Zuweisungen nicht automatisch Aliase entstehen. Aber durch eine derart einfache Lösung schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein, wie das folgende Beispiel zeigt:
Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.
Nachdem das Problem nun hinreichend klar geworden sein sollte, was kann man dagegen tun? Zunächst einmal muss noch einmal klargestellt werden, dass die Deklaration von Instanzvariablen als von außen unzugreifbar (private) lediglich Namen verbirgt — man kann über die Schnittstelle des Objekts nicht herausfinden, wie es intern aufgebaut ist. Dieser Namensschutz (engl. name protection) ist das, was man landläufig (mit dem Wissen vom Aliasing-Problem) mit Geheimnisprinzip (engl. information hiding) verbindet: Es verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, so dass diese problemlos geändert (z. B. umbenannt oder entfernt) werden können.
Das Geheimnisprinzip vermag jedoch nicht zu verhindern, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen. Dies kann z. B. immer dann der Fall sein (und ist vom Objekt, das sein Implementationsgeheimnis wahren will, kaum zu verhindern), wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt (genau so, wie das in den obigen Beispielen in den Zeilen 1533, 1535 und 1540 der Fall war). Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter, aber das wäre dann vom „verbergenden“ Objekt selbst zu verantworten (und zu verhindern gewesen).
Sobald also die Möglichkeit des Aliasing besteht, ist eine echte Kapselung über das Geheimnisprinzip allein nicht mehr zu gewährleisten. Man muss also das Aliasing irgendwie kontrollieren. Die Frage ist nur: Wie?
Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in Kurseinheit 4 und Kurseinheit 5 genannten Programmiersprachen ist das jedoch nur in C#, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per ""struct"" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.
Vor diesem Hintergrund scheint der in Abschnitt 52.5.2 dargelegte Umgang EIFFELs mit Referenz- und Wertvariablen ziemlich schlau ausgedacht zu sein. Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei. Dumm ist nur, wenn man innerhalb der Kapsel Aliase auf Wertobjekte braucht. Weitergehende Mechanismen zur Aliaskontrolle in objektorientierten Programmiersprachen befinden sich derzeit alle noch in der Vorschlags- und Erprobungsphase und sollen hier deswegen nicht weiter behandelt werden.","<answer> Es gibt verschiedene Ansätze zur Kontrolle von Aliasing in objektorientierten Programmiersprachen. Ein Ansatz besteht darin, die Teil-Ganzes-Beziehung zwischen Repräsentationsobjekten und dem Objekt zu definieren, sodass die Teile dem Ganzen gehören und nicht gleichzeitig Teile anderer Objekte sein können. Ein anderer Ansatz ist die Verwendung von Wertobjekten, die keine Referenzen auf andere Objekte zulassen. Ein dritter Ansatz besteht darin, Mechanismen zur Aliaskontrolle in die Programmiersprache zu integrieren, wobei viele dieser Mechanismen noch in der Entwicklung sind. <answer> <question> Welche Möglichkeiten zur Kontrolle von Aliasing werden in objektorientierten Programmiersprachen diskutiert? <question>"
"Zwar ist SMALLTALK über weite Teile in sich selbst definiert, was sich darin äußert, dass praktisch die gesamte Sprachdefinition in Form von Methoden hinterlegt ist und somit für die Programmiererin nicht nur sichtbar, sondern auch änderbar ist. Dennoch greift SMALLTALK für einige grundlegende Operationen auf native Implementierungen zurück. Dazu zählt beispielsweise die Addition (+) für kleine Integer oder der Zugriff auf indizierte Variablen mittels at: und at:put:.
Dabei stehen die in spitzen Klammern stehenden Ausdrücke jeweils für Aufrufe von primitiven Methoden, die, da sie von Programmierern nicht selbst verwendet werden sollen, nur durch Nummern identifiziert wurden. Die Anweisungen nach den Aufrufen der primitiven Methoden werden nur ausgeführt, wenn die primitive Methode nicht erfolgreich war. Dieses Verhalten ermöglicht es, aus einer primitiven Methode mittels Return direkt zurückzuspringen, und zwar zu dem Ort, an dem die Methode +, at: oder at:put: aufgerufen wurde. Dieses Verhalten, das auf den ersten Blick ungewöhnlich erscheinen mag, wird uns im Zusammenhang mit Blöcken (siehe Abschnitt 4.4) wieder begegnen.","<answer> Primitive Methoden in SMALLTALK sind grundlegende Operationen, die auf native Implementierungen zurückgreifen. Diese Methoden sind durch Nummern identifiziert und sollen normalerweise nicht direkt von Programmierern verwendet werden. <answer> <question> Was sind primitive Methoden in SMALLTALK? <question>"
"Zwar ist SMALLTALK über weite Teile in sich selbst definiert, was sich darin äußert, dass praktisch die gesamte Sprachdefinition in Form von Methoden hinterlegt ist und somit für die Programmiererin nicht nur sichtbar, sondern auch änderbar ist. Dennoch greift SMALLTALK für einige grundlegende Operationen auf native Implementierungen zurück. Dazu zählt beispielsweise die Addition (+) für kleine Integer oder der Zugriff auf indizierte Variablen mittels at: und at:put:.
Dabei stehen die in spitzen Klammern stehenden Ausdrücke jeweils für Aufrufe von primitiven Methoden, die, da sie von Programmierern nicht selbst verwendet werden sollen, nur durch Nummern identifiziert wurden. Die Anweisungen nach den Aufrufen der primitiven Methoden werden nur ausgeführt, wenn die primitive Methode nicht erfolgreich war. Dieses Verhalten ermöglicht es, aus einer primitiven Methode mittels Return direkt zurückzuspringen, und zwar zu dem Ort, an dem die Methode +, at: oder at:put: aufgerufen wurde. Dieses Verhalten, das auf den ersten Blick ungewöhnlich erscheinen mag, wird uns im Zusammenhang mit Blöcken (siehe Abschnitt 4.4) wieder begegnen.","<answer> Primitive Methoden werden verwendet, um grundlegende und oft hardwarenahe Operationen effizient auszuführen. Sie ermöglichen es, bestimmte Operationen schneller und effizienter durchzuführen, indem sie auf native Implementierungen zurückgreifen. <answer> <question> Warum werden primitive Methoden in SMALLTALK verwendet? <question>"
"Zwar ist SMALLTALK über weite Teile in sich selbst definiert, was sich darin äußert, dass praktisch die gesamte Sprachdefinition in Form von Methoden hinterlegt ist und somit für die Programmiererin nicht nur sichtbar, sondern auch änderbar ist. Dennoch greift SMALLTALK für einige grundlegende Operationen auf native Implementierungen zurück. Dazu zählt beispielsweise die Addition (+) für kleine Integer oder der Zugriff auf indizierte Variablen mittels at: und at:put:.
Dabei stehen die in spitzen Klammern stehenden Ausdrücke jeweils für Aufrufe von primitiven Methoden, die, da sie von Programmierern nicht selbst verwendet werden sollen, nur durch Nummern identifiziert wurden. Die Anweisungen nach den Aufrufen der primitiven Methoden werden nur ausgeführt, wenn die primitive Methode nicht erfolgreich war. Dieses Verhalten ermöglicht es, aus einer primitiven Methode mittels Return direkt zurückzuspringen, und zwar zu dem Ort, an dem die Methode +, at: oder at:put: aufgerufen wurde. Dieses Verhalten, das auf den ersten Blick ungewöhnlich erscheinen mag, wird uns im Zusammenhang mit Blöcken (siehe Abschnitt 4.4) wieder begegnen.","<answer> Wenn eine primitive Methode erfolgreich ist, wird der Rest des Codes nach dem Aufruf der primitiven Methode nicht ausgeführt. Dieses Verhalten ermöglicht es, direkt zu dem Ort zurückzuspringen, an dem die Methode aufgerufen wurde. <answer> <question> Was passiert, wenn eine primitive Methode erfolgreich ist? <question>"
"Klassen sind die Module der objektorientierten Programmierung. Die Menge der Module und damit das Programm werden durch die Vererbungshierarchie weiter strukturiert. Parallel dazu (und weitgehend, bis auf die Vererbung von Beziehungen unabhängig) gibt es noch eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen (genauer: das Bestehen der Möglichkeit von Beziehungen zwischen Objekten der Klassen; s. Kapitel 2 in Kurseinheit 1) geprägt ist. Diese ist jedoch nicht hierarchisch und insgesamt eher unorganisiert, weshalb sie sich nicht zur systematischen Programmorganisation eignet. Außerdem besteht ein gewisser Konflikt zwischen der Hierarchie der Subklassenbeziehung und den Beziehungen zwischen Objekten: Wenn man einen Teilbaum der Vererbungshierarchie herauslöst, trennt man damit praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen. Die Klassenhierarchie stellt also insbesondere keine Form der hierarchischen Modularisierung dar.
Insbesondere bei größeren Programmen kann leicht das Bedürfnis aufkommen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren. Dies kann beispielsweise verschiedene Vererbungshierarchien betreffen. So, wie man in der Biologie eine Taxonomie der Arten nach Herkunft (Genetik) und nach Merkmalen erstellen kann und da beide ihren Nutzen haben, man weder auf die eine noch auf die andere ohne Not verzichten möchte, so kann man ein Programm beispielsweise unter dem Gesichtspunkt der Vererbung von Funktionalität und von Daten alternativ strukturieren wollen. Voraussetzung hierfür ist allerdings, dass die verschiedenen Darstellungen getrennt voneinander gepflegt werden und dass durch sie weder Inkonsistenzen im Code noch ungewollte Interferenzen entstehen können.
Ein Nachteil der objektorientierten Programmierung (wie auch aller anderen heute bekannten Programmierparadigmen) ist sicherlich, dass die sog. Trennung der Belange, besser bekannt als die Separation of Concerns, nur unzureichend unterstützt wird. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar hoch gehandelt, sind aber dennoch nicht im Mainstream angekommen. Die Gründe dafür mögen vielfältig sein, aber letztlich ist es wohl immer illusorisch zu versprechen, man könne die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen. Insbesondere die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten: Wie so oft muss das Ganze mehr sein als die Summe seiner Teile, um seinen Zweck zu erfüllen. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen.","<answer> Klassen sind die Module der objektorientierten Programmierung. Programme werden durch die Vererbungshierarchie weiter strukturiert, was bedeutet, dass Klassen in einer hierarchischen Beziehung zueinander stehen. <answer> <question> Welche Rolle spielen Klassen in der objektorientierten Programmierung, und wie werden Programme weiter strukturiert? <question>"
"Klassen sind die Module der objektorientierten Programmierung. Die Menge der Module und damit das Programm werden durch die Vererbungshierarchie weiter strukturiert. Parallel dazu (und weitgehend, bis auf die Vererbung von Beziehungen unabhängig) gibt es noch eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen (genauer: das Bestehen der Möglichkeit von Beziehungen zwischen Objekten der Klassen; s. Kapitel 2 in Kurseinheit 1) geprägt ist. Diese ist jedoch nicht hierarchisch und insgesamt eher unorganisiert, weshalb sie sich nicht zur systematischen Programmorganisation eignet. Außerdem besteht ein gewisser Konflikt zwischen der Hierarchie der Subklassenbeziehung und den Beziehungen zwischen Objekten: Wenn man einen Teilbaum der Vererbungshierarchie herauslöst, trennt man damit praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen. Die Klassenhierarchie stellt also insbesondere keine Form der hierarchischen Modularisierung dar.
Insbesondere bei größeren Programmen kann leicht das Bedürfnis aufkommen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren. Dies kann beispielsweise verschiedene Vererbungshierarchien betreffen. So, wie man in der Biologie eine Taxonomie der Arten nach Herkunft (Genetik) und nach Merkmalen erstellen kann und da beide ihren Nutzen haben, man weder auf die eine noch auf die andere ohne Not verzichten möchte, so kann man ein Programm beispielsweise unter dem Gesichtspunkt der Vererbung von Funktionalität und von Daten alternativ strukturieren wollen. Voraussetzung hierfür ist allerdings, dass die verschiedenen Darstellungen getrennt voneinander gepflegt werden und dass durch sie weder Inkonsistenzen im Code noch ungewollte Interferenzen entstehen können.
Ein Nachteil der objektorientierten Programmierung (wie auch aller anderen heute bekannten Programmierparadigmen) ist sicherlich, dass die sog. Trennung der Belange, besser bekannt als die Separation of Concerns, nur unzureichend unterstützt wird. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar hoch gehandelt, sind aber dennoch nicht im Mainstream angekommen. Die Gründe dafür mögen vielfältig sein, aber letztlich ist es wohl immer illusorisch zu versprechen, man könne die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen. Insbesondere die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten: Wie so oft muss das Ganze mehr sein als die Summe seiner Teile, um seinen Zweck zu erfüllen. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen.","<answer> Parallel zur Vererbungshierarchie gibt es eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen bzw. Objekten geprägt ist. Diese Struktur ist nicht hierarchisch und eher unorganisiert, weshalb sie sich nicht zur systematischen Programmorganisation eignet. <answer> <question> Welche Art von Struktur gibt es parallel zur Vererbungshierarchie, die jedoch nicht hierarchisch ist und sich nicht zur systematischen Programmorganisation eignet? <question>"
"Klassen sind die Module der objektorientierten Programmierung. Die Menge der Module und damit das Programm werden durch die Vererbungshierarchie weiter strukturiert. Parallel dazu (und weitgehend, bis auf die Vererbung von Beziehungen unabhängig) gibt es noch eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen (genauer: das Bestehen der Möglichkeit von Beziehungen zwischen Objekten der Klassen; s. Kapitel 2 in Kurseinheit 1) geprägt ist. Diese ist jedoch nicht hierarchisch und insgesamt eher unorganisiert, weshalb sie sich nicht zur systematischen Programmorganisation eignet. Außerdem besteht ein gewisser Konflikt zwischen der Hierarchie der Subklassenbeziehung und den Beziehungen zwischen Objekten: Wenn man einen Teilbaum der Vererbungshierarchie herauslöst, trennt man damit praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen. Die Klassenhierarchie stellt also insbesondere keine Form der hierarchischen Modularisierung dar.
Insbesondere bei größeren Programmen kann leicht das Bedürfnis aufkommen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren. Dies kann beispielsweise verschiedene Vererbungshierarchien betreffen. So, wie man in der Biologie eine Taxonomie der Arten nach Herkunft (Genetik) und nach Merkmalen erstellen kann und da beide ihren Nutzen haben, man weder auf die eine noch auf die andere ohne Not verzichten möchte, so kann man ein Programm beispielsweise unter dem Gesichtspunkt der Vererbung von Funktionalität und von Daten alternativ strukturieren wollen. Voraussetzung hierfür ist allerdings, dass die verschiedenen Darstellungen getrennt voneinander gepflegt werden und dass durch sie weder Inkonsistenzen im Code noch ungewollte Interferenzen entstehen können.
Ein Nachteil der objektorientierten Programmierung (wie auch aller anderen heute bekannten Programmierparadigmen) ist sicherlich, dass die sog. Trennung der Belange, besser bekannt als die Separation of Concerns, nur unzureichend unterstützt wird. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar hoch gehandelt, sind aber dennoch nicht im Mainstream angekommen. Die Gründe dafür mögen vielfältig sein, aber letztlich ist es wohl immer illusorisch zu versprechen, man könne die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen. Insbesondere die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten: Wie so oft muss das Ganze mehr sein als die Summe seiner Teile, um seinen Zweck zu erfüllen. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen.","<answer> Die Klassenhierarchie stellt keine Form der hierarchischen Modularisierung dar, da das Herauslösen eines Teilbaums der Vererbungshierarchie praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen trennt. Somit werden Beziehungen zwischen Klassenmitgliedern gestört. <answer> <question> Warum stellt die Klassenhierarchie keine Form der hierarchischen Modularisierung dar? <question>"
"Klassen sind die Module der objektorientierten Programmierung. Die Menge der Module und damit das Programm werden durch die Vererbungshierarchie weiter strukturiert. Parallel dazu (und weitgehend, bis auf die Vererbung von Beziehungen unabhängig) gibt es noch eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen (genauer: das Bestehen der Möglichkeit von Beziehungen zwischen Objekten der Klassen; s. Kapitel 2 in Kurseinheit 1) geprägt ist. Diese ist jedoch nicht hierarchisch und insgesamt eher unorganisiert, weshalb sie sich nicht zur systematischen Programmorganisation eignet. Außerdem besteht ein gewisser Konflikt zwischen der Hierarchie der Subklassenbeziehung und den Beziehungen zwischen Objekten: Wenn man einen Teilbaum der Vererbungshierarchie herauslöst, trennt man damit praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen. Die Klassenhierarchie stellt also insbesondere keine Form der hierarchischen Modularisierung dar.
Insbesondere bei größeren Programmen kann leicht das Bedürfnis aufkommen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren. Dies kann beispielsweise verschiedene Vererbungshierarchien betreffen. So, wie man in der Biologie eine Taxonomie der Arten nach Herkunft (Genetik) und nach Merkmalen erstellen kann und da beide ihren Nutzen haben, man weder auf die eine noch auf die andere ohne Not verzichten möchte, so kann man ein Programm beispielsweise unter dem Gesichtspunkt der Vererbung von Funktionalität und von Daten alternativ strukturieren wollen. Voraussetzung hierfür ist allerdings, dass die verschiedenen Darstellungen getrennt voneinander gepflegt werden und dass durch sie weder Inkonsistenzen im Code noch ungewollte Interferenzen entstehen können.
Ein Nachteil der objektorientierten Programmierung (wie auch aller anderen heute bekannten Programmierparadigmen) ist sicherlich, dass die sog. Trennung der Belange, besser bekannt als die Separation of Concerns, nur unzureichend unterstützt wird. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar hoch gehandelt, sind aber dennoch nicht im Mainstream angekommen. Die Gründe dafür mögen vielfältig sein, aber letztlich ist es wohl immer illusorisch zu versprechen, man könne die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen. Insbesondere die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten: Wie so oft muss das Ganze mehr sein als die Summe seiner Teile, um seinen Zweck zu erfüllen. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen.","<answer> Bei größeren Programmen kann das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren, da verschiedene Vererbungshierarchien oder andere Strukturierungskriterien gleichzeitig relevant sein können, ähnlich wie in der Biologie, wo Arten nach verschiedenen Gesichtspunkten klassifiziert werden. Dies erfordert jedoch, dass die verschiedenen Darstellungen getrennt gepflegt werden und keine Inkonsistenzen oder ungewollten Interferenzen entstehen. <answer> <question> Warum kann bei größeren Programmen das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren? <question>"
"Klassen sind die Module der objektorientierten Programmierung. Die Menge der Module und damit das Programm werden durch die Vererbungshierarchie weiter strukturiert. Parallel dazu (und weitgehend, bis auf die Vererbung von Beziehungen unabhängig) gibt es noch eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen (genauer: das Bestehen der Möglichkeit von Beziehungen zwischen Objekten der Klassen; s. Kapitel 2 in Kurseinheit 1) geprägt ist. Diese ist jedoch nicht hierarchisch und insgesamt eher unorganisiert, weshalb sie sich nicht zur systematischen Programmorganisation eignet. Außerdem besteht ein gewisser Konflikt zwischen der Hierarchie der Subklassenbeziehung und den Beziehungen zwischen Objekten: Wenn man einen Teilbaum der Vererbungshierarchie herauslöst, trennt man damit praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen. Die Klassenhierarchie stellt also insbesondere keine Form der hierarchischen Modularisierung dar.
Insbesondere bei größeren Programmen kann leicht das Bedürfnis aufkommen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren. Dies kann beispielsweise verschiedene Vererbungshierarchien betreffen. So, wie man in der Biologie eine Taxonomie der Arten nach Herkunft (Genetik) und nach Merkmalen erstellen kann und da beide ihren Nutzen haben, man weder auf die eine noch auf die andere ohne Not verzichten möchte, so kann man ein Programm beispielsweise unter dem Gesichtspunkt der Vererbung von Funktionalität und von Daten alternativ strukturieren wollen. Voraussetzung hierfür ist allerdings, dass die verschiedenen Darstellungen getrennt voneinander gepflegt werden und dass durch sie weder Inkonsistenzen im Code noch ungewollte Interferenzen entstehen können.
Ein Nachteil der objektorientierten Programmierung (wie auch aller anderen heute bekannten Programmierparadigmen) ist sicherlich, dass die sog. Trennung der Belange, besser bekannt als die Separation of Concerns, nur unzureichend unterstützt wird. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar hoch gehandelt, sind aber dennoch nicht im Mainstream angekommen. Die Gründe dafür mögen vielfältig sein, aber letztlich ist es wohl immer illusorisch zu versprechen, man könne die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen. Insbesondere die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten: Wie so oft muss das Ganze mehr sein als die Summe seiner Teile, um seinen Zweck zu erfüllen. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen.","<answer> Die Trennung der Belange, auch als Separation of Concerns bekannt, wird in der objektorientierten Programmierung als unzureichend unterstützt angesehen, da es schwer ist, verschiedene Aspekte eines Systems sauber voneinander zu trennen. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar diskutiert, haben jedoch keine breite Akzeptanz gefunden. Die Gründe dafür können vielfältig sein, aber letztendlich ist es schwierig, die essentielle Komplexität eines Problems durch programmiersprachliche Mittel vollständig zu beseitigen. <answer> <question> Warum wird die Trennung der Belange in der objektorientierten Programmierung als unzureichend unterstützt angesehen? <question>"
"Klassen sind die Module der objektorientierten Programmierung. Die Menge der Module und damit das Programm werden durch die Vererbungshierarchie weiter strukturiert. Parallel dazu (und weitgehend, bis auf die Vererbung von Beziehungen unabhängig) gibt es noch eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen (genauer: das Bestehen der Möglichkeit von Beziehungen zwischen Objekten der Klassen; s. Kapitel 2 in Kurseinheit 1) geprägt ist. Diese ist jedoch nicht hierarchisch und insgesamt eher unorganisiert, weshalb sie sich nicht zur systematischen Programmorganisation eignet. Außerdem besteht ein gewisser Konflikt zwischen der Hierarchie der Subklassenbeziehung und den Beziehungen zwischen Objekten: Wenn man einen Teilbaum der Vererbungshierarchie herauslöst, trennt man damit praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen. Die Klassenhierarchie stellt also insbesondere keine Form der hierarchischen Modularisierung dar.
Insbesondere bei größeren Programmen kann leicht das Bedürfnis aufkommen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren. Dies kann beispielsweise verschiedene Vererbungshierarchien betreffen. So, wie man in der Biologie eine Taxonomie der Arten nach Herkunft (Genetik) und nach Merkmalen erstellen kann und da beide ihren Nutzen haben, man weder auf die eine noch auf die andere ohne Not verzichten möchte, so kann man ein Programm beispielsweise unter dem Gesichtspunkt der Vererbung von Funktionalität und von Daten alternativ strukturieren wollen. Voraussetzung hierfür ist allerdings, dass die verschiedenen Darstellungen getrennt voneinander gepflegt werden und dass durch sie weder Inkonsistenzen im Code noch ungewollte Interferenzen entstehen können.
Ein Nachteil der objektorientierten Programmierung (wie auch aller anderen heute bekannten Programmierparadigmen) ist sicherlich, dass die sog. Trennung der Belange, besser bekannt als die Separation of Concerns, nur unzureichend unterstützt wird. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar hoch gehandelt, sind aber dennoch nicht im Mainstream angekommen. Die Gründe dafür mögen vielfältig sein, aber letztlich ist es wohl immer illusorisch zu versprechen, man könne die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen. Insbesondere die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten: Wie so oft muss das Ganze mehr sein als die Summe seiner Teile, um seinen Zweck zu erfüllen. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen.","<answer> Softwaresysteme werden als die kompliziertesten technischen Artefakte bezeichnet, die die Menschheit jemals hervorgebracht hat, weil sie eine immense Komplexität aufweisen. Die Trennung der Belange und die Bewältigung dieser Komplexität sind nach wie vor große Herausforderungen in der Softwareentwicklung. Daher wird darauf hingewiesen, dass Einfachheit in diesem Kontext schwer zu erreichen ist. <answer> <question> Warum werden Softwaresysteme als die kompliziertesten technischen Artefakte bezeichnet, die die Menschheit jemals hervorgebracht hat? <question>"
"Objekte, die keine literale Repräsentation haben, müssen in JAVA (wie in SMALLTALK) explizit als Instanzen von Klassen erzeugt werden. Dafür gibt es in JAVA eine spezielle Kategorie von Methoden, die als Konstruktoren bezeichnet werden. Im Unterschied zu SMALLTALK sind Konstruktoren in JAVA keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne kann man Konstruktoren als Instanzmethoden betrachten, die auf der neu erzeugten Instanz aufgerufen werden.
Konstruktoren können somit alle Anweisungen enthalten, die in SMALLTALK durch die spezielle Methode ""initialize"" notwendig waren (vgl. Abschnitt 8.2 in Kurseinheit 2). Allerdings sind Konstruktoren auch wie Klassenmethoden, da sie nicht auf einer Instanz, sondern auf der Klasse aufgerufen werden. In JAVA wird dafür jedoch kein spezieller Methodenname wie ""new"" wie in SMALLTALK verwendet, sondern der Klassennamen selbst.
Im Vergleich zu anderen Methoden erlauben Konstruktordefinitionen in JAVA keine Angabe eines Rückgabetyps. Da die erzeugte Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist, ist der Typ festgelegt. Die Angabe des Rückgabetyps in Zeile 1006 ist daher nicht erforderlich.
Wenn kein Konstruktor definiert wird, verwendet JAVA standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse. Konstruktoren werden nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen. Um dieses Verhalten zu überschreiben, kann man innerhalb eines Konstruktors einen Konstruktor der Superklasse mittels ""super"" aufrufen. Dabei werden die in ""super"" aufgerufenen Methoden dynamisch gebunden, was dazu führen kann, dass auf noch nicht initialisierte Variablen zugegriffen wird. Die gesamte Thematik rund um Konstruktoren und die Initialisierung von Variablen in JAVA ist recht komplex. Da Instanziierung und Initialisierung grundlegende und für jedes Programm unverzichtbare Vorgänge sind, ist JAVA möglicherweise nicht die ideale Programmiersprache für Anfänger.
In JAVA ist es übrigens auch möglich, Konstruktoren für die Objekterzeugung mit Klassenmethoden zu verwenden, wie es in Zeile 998 gezeigt wird. In diesem Fall muss die Klassenmethode im Rumpf einen Konstruktor aufrufen, wie es in Zeile 1006 geschieht. Solche Klassenmethoden werden auch als Factory-Methoden bezeichnet (vgl. Abschnitt 8.3 in Kurseinheit 2). Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben.","<answer> Konstruktoren in JAVA sind spezielle Methoden, die zur Erzeugung von Objekten verwendet werden. Im Gegensatz zu SMALLTALK sind Konstruktoren in JAVA keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Sie verhalten sich wie Instanzmethoden und können auf alle Felder und Methoden der neu erzeugten Instanz zugreifen. <answer> <question> Was sind Konstruktoren in JAVA, und wie verhalten sie sich im Vergleich zu SMALLTALK? <question>"
"Objekte, die keine literale Repräsentation haben, müssen in JAVA (wie in SMALLTALK) explizit als Instanzen von Klassen erzeugt werden. Dafür gibt es in JAVA eine spezielle Kategorie von Methoden, die als Konstruktoren bezeichnet werden. Im Unterschied zu SMALLTALK sind Konstruktoren in JAVA keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne kann man Konstruktoren als Instanzmethoden betrachten, die auf der neu erzeugten Instanz aufgerufen werden.
Konstruktoren können somit alle Anweisungen enthalten, die in SMALLTALK durch die spezielle Methode ""initialize"" notwendig waren (vgl. Abschnitt 8.2 in Kurseinheit 2). Allerdings sind Konstruktoren auch wie Klassenmethoden, da sie nicht auf einer Instanz, sondern auf der Klasse aufgerufen werden. In JAVA wird dafür jedoch kein spezieller Methodenname wie ""new"" wie in SMALLTALK verwendet, sondern der Klassennamen selbst.
Im Vergleich zu anderen Methoden erlauben Konstruktordefinitionen in JAVA keine Angabe eines Rückgabetyps. Da die erzeugte Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist, ist der Typ festgelegt. Die Angabe des Rückgabetyps in Zeile 1006 ist daher nicht erforderlich.
Wenn kein Konstruktor definiert wird, verwendet JAVA standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse. Konstruktoren werden nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen. Um dieses Verhalten zu überschreiben, kann man innerhalb eines Konstruktors einen Konstruktor der Superklasse mittels ""super"" aufrufen. Dabei werden die in ""super"" aufgerufenen Methoden dynamisch gebunden, was dazu führen kann, dass auf noch nicht initialisierte Variablen zugegriffen wird. Die gesamte Thematik rund um Konstruktoren und die Initialisierung von Variablen in JAVA ist recht komplex. Da Instanziierung und Initialisierung grundlegende und für jedes Programm unverzichtbare Vorgänge sind, ist JAVA möglicherweise nicht die ideale Programmiersprache für Anfänger.
In JAVA ist es übrigens auch möglich, Konstruktoren für die Objekterzeugung mit Klassenmethoden zu verwenden, wie es in Zeile 998 gezeigt wird. In diesem Fall muss die Klassenmethode im Rumpf einen Konstruktor aufrufen, wie es in Zeile 1006 geschieht. Solche Klassenmethoden werden auch als Factory-Methoden bezeichnet (vgl. Abschnitt 8.3 in Kurseinheit 2). Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben.","<answer> In JAVA werden Konstruktoren aufgerufen, indem der Klassenname gefolgt von den Konstruktorargumenten verwendet wird, z.B., ""new MeineKlasse(argumente)"". <answer> <question> Wie werden Konstruktoren in JAVA aufgerufen? <question>"
"Objekte, die keine literale Repräsentation haben, müssen in JAVA (wie in SMALLTALK) explizit als Instanzen von Klassen erzeugt werden. Dafür gibt es in JAVA eine spezielle Kategorie von Methoden, die als Konstruktoren bezeichnet werden. Im Unterschied zu SMALLTALK sind Konstruktoren in JAVA keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne kann man Konstruktoren als Instanzmethoden betrachten, die auf der neu erzeugten Instanz aufgerufen werden.
Konstruktoren können somit alle Anweisungen enthalten, die in SMALLTALK durch die spezielle Methode ""initialize"" notwendig waren (vgl. Abschnitt 8.2 in Kurseinheit 2). Allerdings sind Konstruktoren auch wie Klassenmethoden, da sie nicht auf einer Instanz, sondern auf der Klasse aufgerufen werden. In JAVA wird dafür jedoch kein spezieller Methodenname wie ""new"" wie in SMALLTALK verwendet, sondern der Klassennamen selbst.
Im Vergleich zu anderen Methoden erlauben Konstruktordefinitionen in JAVA keine Angabe eines Rückgabetyps. Da die erzeugte Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist, ist der Typ festgelegt. Die Angabe des Rückgabetyps in Zeile 1006 ist daher nicht erforderlich.
Wenn kein Konstruktor definiert wird, verwendet JAVA standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse. Konstruktoren werden nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen. Um dieses Verhalten zu überschreiben, kann man innerhalb eines Konstruktors einen Konstruktor der Superklasse mittels ""super"" aufrufen. Dabei werden die in ""super"" aufgerufenen Methoden dynamisch gebunden, was dazu führen kann, dass auf noch nicht initialisierte Variablen zugegriffen wird. Die gesamte Thematik rund um Konstruktoren und die Initialisierung von Variablen in JAVA ist recht komplex. Da Instanziierung und Initialisierung grundlegende und für jedes Programm unverzichtbare Vorgänge sind, ist JAVA möglicherweise nicht die ideale Programmiersprache für Anfänger.
In JAVA ist es übrigens auch möglich, Konstruktoren für die Objekterzeugung mit Klassenmethoden zu verwenden, wie es in Zeile 998 gezeigt wird. In diesem Fall muss die Klassenmethode im Rumpf einen Konstruktor aufrufen, wie es in Zeile 1006 geschieht. Solche Klassenmethoden werden auch als Factory-Methoden bezeichnet (vgl. Abschnitt 8.3 in Kurseinheit 2). Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben.","<answer> Wenn kein Konstruktor in JAVA definiert wird, verwendet JAVA standardmäßig den impliziten Standardkonstruktor, der parameterlos ist und eine neue Instanz der Klasse erzeugt. <answer> <question> Was passiert, wenn kein Konstruktor in JAVA definiert wird? <question>"
"Objekte, die keine literale Repräsentation haben, müssen in JAVA (wie in SMALLTALK) explizit als Instanzen von Klassen erzeugt werden. Dafür gibt es in JAVA eine spezielle Kategorie von Methoden, die als Konstruktoren bezeichnet werden. Im Unterschied zu SMALLTALK sind Konstruktoren in JAVA keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne kann man Konstruktoren als Instanzmethoden betrachten, die auf der neu erzeugten Instanz aufgerufen werden.
Konstruktoren können somit alle Anweisungen enthalten, die in SMALLTALK durch die spezielle Methode ""initialize"" notwendig waren (vgl. Abschnitt 8.2 in Kurseinheit 2). Allerdings sind Konstruktoren auch wie Klassenmethoden, da sie nicht auf einer Instanz, sondern auf der Klasse aufgerufen werden. In JAVA wird dafür jedoch kein spezieller Methodenname wie ""new"" wie in SMALLTALK verwendet, sondern der Klassennamen selbst.
Im Vergleich zu anderen Methoden erlauben Konstruktordefinitionen in JAVA keine Angabe eines Rückgabetyps. Da die erzeugte Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist, ist der Typ festgelegt. Die Angabe des Rückgabetyps in Zeile 1006 ist daher nicht erforderlich.
Wenn kein Konstruktor definiert wird, verwendet JAVA standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse. Konstruktoren werden nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen. Um dieses Verhalten zu überschreiben, kann man innerhalb eines Konstruktors einen Konstruktor der Superklasse mittels ""super"" aufrufen. Dabei werden die in ""super"" aufgerufenen Methoden dynamisch gebunden, was dazu führen kann, dass auf noch nicht initialisierte Variablen zugegriffen wird. Die gesamte Thematik rund um Konstruktoren und die Initialisierung von Variablen in JAVA ist recht komplex. Da Instanziierung und Initialisierung grundlegende und für jedes Programm unverzichtbare Vorgänge sind, ist JAVA möglicherweise nicht die ideale Programmiersprache für Anfänger.
In JAVA ist es übrigens auch möglich, Konstruktoren für die Objekterzeugung mit Klassenmethoden zu verwenden, wie es in Zeile 998 gezeigt wird. In diesem Fall muss die Klassenmethode im Rumpf einen Konstruktor aufrufen, wie es in Zeile 1006 geschieht. Solche Klassenmethoden werden auch als Factory-Methoden bezeichnet (vgl. Abschnitt 8.3 in Kurseinheit 2). Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben.","<answer> Nein, Konstruktoren werden in JAVA nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse automatisch aufgerufen, wenn eine Instanz einer ihrer Subklassen erzeugt wird. <answer> <question> Werden Konstruktoren in JAVA vererbt? <question>"
"Objekte, die keine literale Repräsentation haben, müssen in JAVA (wie in SMALLTALK) explizit als Instanzen von Klassen erzeugt werden. Dafür gibt es in JAVA eine spezielle Kategorie von Methoden, die als Konstruktoren bezeichnet werden. Im Unterschied zu SMALLTALK sind Konstruktoren in JAVA keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne kann man Konstruktoren als Instanzmethoden betrachten, die auf der neu erzeugten Instanz aufgerufen werden.
Konstruktoren können somit alle Anweisungen enthalten, die in SMALLTALK durch die spezielle Methode ""initialize"" notwendig waren (vgl. Abschnitt 8.2 in Kurseinheit 2). Allerdings sind Konstruktoren auch wie Klassenmethoden, da sie nicht auf einer Instanz, sondern auf der Klasse aufgerufen werden. In JAVA wird dafür jedoch kein spezieller Methodenname wie ""new"" wie in SMALLTALK verwendet, sondern der Klassennamen selbst.
Im Vergleich zu anderen Methoden erlauben Konstruktordefinitionen in JAVA keine Angabe eines Rückgabetyps. Da die erzeugte Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist, ist der Typ festgelegt. Die Angabe des Rückgabetyps in Zeile 1006 ist daher nicht erforderlich.
Wenn kein Konstruktor definiert wird, verwendet JAVA standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse. Konstruktoren werden nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen. Um dieses Verhalten zu überschreiben, kann man innerhalb eines Konstruktors einen Konstruktor der Superklasse mittels ""super"" aufrufen. Dabei werden die in ""super"" aufgerufenen Methoden dynamisch gebunden, was dazu führen kann, dass auf noch nicht initialisierte Variablen zugegriffen wird. Die gesamte Thematik rund um Konstruktoren und die Initialisierung von Variablen in JAVA ist recht komplex. Da Instanziierung und Initialisierung grundlegende und für jedes Programm unverzichtbare Vorgänge sind, ist JAVA möglicherweise nicht die ideale Programmiersprache für Anfänger.
In JAVA ist es übrigens auch möglich, Konstruktoren für die Objekterzeugung mit Klassenmethoden zu verwenden, wie es in Zeile 998 gezeigt wird. In diesem Fall muss die Klassenmethode im Rumpf einen Konstruktor aufrufen, wie es in Zeile 1006 geschieht. Solche Klassenmethoden werden auch als Factory-Methoden bezeichnet (vgl. Abschnitt 8.3 in Kurseinheit 2). Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben.","<answer> Factory-Methoden sind Klassenmethoden in JAVA, die zur Erzeugung von Objekten verwendet werden können. Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben. Factory-Methoden ermöglichen eine flexible Objekterzeugung und werden oft in Bibliotheken und Frameworks eingesetzt. <answer> <question> Was sind Factory-Methoden in JAVA, und wie werden sie verwendet? <question>"
"Obwohl C# das Konzept der Interface-Implementierung aus JAVA übernommen hat, wurde seine Rolle hier deutlich gestärkt. In C# ist es möglich, dass eine Klasse dieselbe Methodendeklaration, die von verschiedenen Interfaces ""geerbt"" wurde, getrennt voneinander implementiert. Dies wird mithilfe von sogenannten expliziten Interfaceimplementierungen erreicht, wie im folgenden Beispiel dargestellt (beachten Sie, dass in C# der Doppelpunkt die Schlüsselwörter ""extends"" und ""implements"" aus JAVA ersetzt).
Der Nutzen der expliziten Interfaceimplementierung liegt darin, dass die Methode gibTelefonnummer() je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Der Typ der Variable (oder des Ausdrucks), die als Empfänger fungiert, gibt gewissermaßen die Rolle vor, in der das Objekt angesprochen wird (hier: Angestellte oder Privatperson). Es ist weder vorgesehen noch möglich, etwas wie x.Angestellte.gibTelefonnummer() an der Aufrufstelle zu schreiben (wobei x das Objekt bezeichnet); stattdessen steht einfach x.gibTelefonnummer(). Falls die Methodendeklaration Telefonnummer gibTelefonnummer() von einem gemeinsamen Superinterface von Angestellte und Privatperson, z. B. Erreichbar, geerbt würde, wäre das Programm ungültig. Es muss immer der tatsächlich deklarierende Typ als Qualifizierer angegeben werden.
Falls im obigen Beispiel für die beiden expliziten Interfaceimplementierungen von gibTelefonnummer() nicht wie in JAVA der Zugriffsmodifikator ""public"" angegeben wurde, geschah dies nicht ohne Grund. In C# ist es nämlich möglich, Methoden nicht als ""public"" zu deklarieren und dennoch per Interfaceimplementierung von außen darauf zuzugreifen. Allerdings ist dies an die explizite Interfaceimplementierung gebunden. Die sogenannte implizite Interfaceimplementierung, bei der manchmal nicht klar ist, welcher der aufgelisteten Supertypen ein Interface und welcher eine Superklasse ist, wird durch eine Namenskonvention aufgelöst: Im Common Type System von .NET sollten alle Interfacenamen mit einem ""I"" beginnen. Dies steht in der Tradition der bei MICROSOFT weit verbreiteten und nach dem früheren Mitarbeiter CHARLES SIMONYI benannten ungarischen Notation.
Explizite Interfaceimplementierungen können nicht überschrieben werden und dürfen nicht als ""virtual"" deklariert sein. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut. Es ist jedoch wichtig zu beachten, dass diese erneute explizite Implementierung keine Überschreibung darstellt. Insbesondere findet bei Aufruf der explizit implementierten Methode kein dynamisches Binden statt.","<answer> Explizite Interfaceimplementierungen in C# ermöglichen es einer Klasse, die gleiche Methodendeklaration von verschiedenen Interfaces getrennt voneinander zu implementieren. Dies wird durch die Angabe des Interfacequalifikators vor der Methode erreicht. <answer> <question> Was sind explizite Interfaceimplementierungen in C#? <question>"
"Obwohl C# das Konzept der Interface-Implementierung aus JAVA übernommen hat, wurde seine Rolle hier deutlich gestärkt. In C# ist es möglich, dass eine Klasse dieselbe Methodendeklaration, die von verschiedenen Interfaces ""geerbt"" wurde, getrennt voneinander implementiert. Dies wird mithilfe von sogenannten expliziten Interfaceimplementierungen erreicht, wie im folgenden Beispiel dargestellt (beachten Sie, dass in C# der Doppelpunkt die Schlüsselwörter ""extends"" und ""implements"" aus JAVA ersetzt).
Der Nutzen der expliziten Interfaceimplementierung liegt darin, dass die Methode gibTelefonnummer() je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Der Typ der Variable (oder des Ausdrucks), die als Empfänger fungiert, gibt gewissermaßen die Rolle vor, in der das Objekt angesprochen wird (hier: Angestellte oder Privatperson). Es ist weder vorgesehen noch möglich, etwas wie x.Angestellte.gibTelefonnummer() an der Aufrufstelle zu schreiben (wobei x das Objekt bezeichnet); stattdessen steht einfach x.gibTelefonnummer(). Falls die Methodendeklaration Telefonnummer gibTelefonnummer() von einem gemeinsamen Superinterface von Angestellte und Privatperson, z. B. Erreichbar, geerbt würde, wäre das Programm ungültig. Es muss immer der tatsächlich deklarierende Typ als Qualifizierer angegeben werden.
Falls im obigen Beispiel für die beiden expliziten Interfaceimplementierungen von gibTelefonnummer() nicht wie in JAVA der Zugriffsmodifikator ""public"" angegeben wurde, geschah dies nicht ohne Grund. In C# ist es nämlich möglich, Methoden nicht als ""public"" zu deklarieren und dennoch per Interfaceimplementierung von außen darauf zuzugreifen. Allerdings ist dies an die explizite Interfaceimplementierung gebunden. Die sogenannte implizite Interfaceimplementierung, bei der manchmal nicht klar ist, welcher der aufgelisteten Supertypen ein Interface und welcher eine Superklasse ist, wird durch eine Namenskonvention aufgelöst: Im Common Type System von .NET sollten alle Interfacenamen mit einem ""I"" beginnen. Dies steht in der Tradition der bei MICROSOFT weit verbreiteten und nach dem früheren Mitarbeiter CHARLES SIMONYI benannten ungarischen Notation.
Explizite Interfaceimplementierungen können nicht überschrieben werden und dürfen nicht als ""virtual"" deklariert sein. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut. Es ist jedoch wichtig zu beachten, dass diese erneute explizite Implementierung keine Überschreibung darstellt. Insbesondere findet bei Aufruf der explizit implementierten Methode kein dynamisches Binden statt.","<answer> Der Nutzen von expliziten Interfaceimplementierungen liegt darin, dass die Methode je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Dies ermöglicht es, verschiedene Verhaltensweisen für denselben Methodennamen in verschiedenen Kontexten zu definieren. <answer> <question> Welchen Nutzen haben explizite Interfaceimplementierungen in C#? <question>"
"Obwohl C# das Konzept der Interface-Implementierung aus JAVA übernommen hat, wurde seine Rolle hier deutlich gestärkt. In C# ist es möglich, dass eine Klasse dieselbe Methodendeklaration, die von verschiedenen Interfaces ""geerbt"" wurde, getrennt voneinander implementiert. Dies wird mithilfe von sogenannten expliziten Interfaceimplementierungen erreicht, wie im folgenden Beispiel dargestellt (beachten Sie, dass in C# der Doppelpunkt die Schlüsselwörter ""extends"" und ""implements"" aus JAVA ersetzt).
Der Nutzen der expliziten Interfaceimplementierung liegt darin, dass die Methode gibTelefonnummer() je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Der Typ der Variable (oder des Ausdrucks), die als Empfänger fungiert, gibt gewissermaßen die Rolle vor, in der das Objekt angesprochen wird (hier: Angestellte oder Privatperson). Es ist weder vorgesehen noch möglich, etwas wie x.Angestellte.gibTelefonnummer() an der Aufrufstelle zu schreiben (wobei x das Objekt bezeichnet); stattdessen steht einfach x.gibTelefonnummer(). Falls die Methodendeklaration Telefonnummer gibTelefonnummer() von einem gemeinsamen Superinterface von Angestellte und Privatperson, z. B. Erreichbar, geerbt würde, wäre das Programm ungültig. Es muss immer der tatsächlich deklarierende Typ als Qualifizierer angegeben werden.
Falls im obigen Beispiel für die beiden expliziten Interfaceimplementierungen von gibTelefonnummer() nicht wie in JAVA der Zugriffsmodifikator ""public"" angegeben wurde, geschah dies nicht ohne Grund. In C# ist es nämlich möglich, Methoden nicht als ""public"" zu deklarieren und dennoch per Interfaceimplementierung von außen darauf zuzugreifen. Allerdings ist dies an die explizite Interfaceimplementierung gebunden. Die sogenannte implizite Interfaceimplementierung, bei der manchmal nicht klar ist, welcher der aufgelisteten Supertypen ein Interface und welcher eine Superklasse ist, wird durch eine Namenskonvention aufgelöst: Im Common Type System von .NET sollten alle Interfacenamen mit einem ""I"" beginnen. Dies steht in der Tradition der bei MICROSOFT weit verbreiteten und nach dem früheren Mitarbeiter CHARLES SIMONYI benannten ungarischen Notation.
Explizite Interfaceimplementierungen können nicht überschrieben werden und dürfen nicht als ""virtual"" deklariert sein. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut. Es ist jedoch wichtig zu beachten, dass diese erneute explizite Implementierung keine Überschreibung darstellt. Insbesondere findet bei Aufruf der explizit implementierten Methode kein dynamisches Binden statt.","<answer> In C# ist es möglich, Methoden von expliziten Interfaceimplementierungen mit Zugriffsmodifikatoren, die nicht ""public"" sind, von außen aufzurufen. Dies ist jedoch an die explizite Implementierung gebunden und erfordert die Verwendung des richtigen Interfacequalifikators. <answer> <question> Was passiert, wenn man versucht, eine explizite Interfaceimplementierung mit einem anderen Zugriffsmodifikator als ""public"" zu deklarieren? <question>"
"Obwohl C# das Konzept der Interface-Implementierung aus JAVA übernommen hat, wurde seine Rolle hier deutlich gestärkt. In C# ist es möglich, dass eine Klasse dieselbe Methodendeklaration, die von verschiedenen Interfaces ""geerbt"" wurde, getrennt voneinander implementiert. Dies wird mithilfe von sogenannten expliziten Interfaceimplementierungen erreicht, wie im folgenden Beispiel dargestellt (beachten Sie, dass in C# der Doppelpunkt die Schlüsselwörter ""extends"" und ""implements"" aus JAVA ersetzt).
Der Nutzen der expliziten Interfaceimplementierung liegt darin, dass die Methode gibTelefonnummer() je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Der Typ der Variable (oder des Ausdrucks), die als Empfänger fungiert, gibt gewissermaßen die Rolle vor, in der das Objekt angesprochen wird (hier: Angestellte oder Privatperson). Es ist weder vorgesehen noch möglich, etwas wie x.Angestellte.gibTelefonnummer() an der Aufrufstelle zu schreiben (wobei x das Objekt bezeichnet); stattdessen steht einfach x.gibTelefonnummer(). Falls die Methodendeklaration Telefonnummer gibTelefonnummer() von einem gemeinsamen Superinterface von Angestellte und Privatperson, z. B. Erreichbar, geerbt würde, wäre das Programm ungültig. Es muss immer der tatsächlich deklarierende Typ als Qualifizierer angegeben werden.
Falls im obigen Beispiel für die beiden expliziten Interfaceimplementierungen von gibTelefonnummer() nicht wie in JAVA der Zugriffsmodifikator ""public"" angegeben wurde, geschah dies nicht ohne Grund. In C# ist es nämlich möglich, Methoden nicht als ""public"" zu deklarieren und dennoch per Interfaceimplementierung von außen darauf zuzugreifen. Allerdings ist dies an die explizite Interfaceimplementierung gebunden. Die sogenannte implizite Interfaceimplementierung, bei der manchmal nicht klar ist, welcher der aufgelisteten Supertypen ein Interface und welcher eine Superklasse ist, wird durch eine Namenskonvention aufgelöst: Im Common Type System von .NET sollten alle Interfacenamen mit einem ""I"" beginnen. Dies steht in der Tradition der bei MICROSOFT weit verbreiteten und nach dem früheren Mitarbeiter CHARLES SIMONYI benannten ungarischen Notation.
Explizite Interfaceimplementierungen können nicht überschrieben werden und dürfen nicht als ""virtual"" deklariert sein. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut. Es ist jedoch wichtig zu beachten, dass diese erneute explizite Implementierung keine Überschreibung darstellt. Insbesondere findet bei Aufruf der explizit implementierten Methode kein dynamisches Binden statt.","<answer> In C# muss der tatsächliche deklarierende Typ des Objekts als Qualifikator für den Methodenaufruf angegeben werden, um sicherzustellen, dass die richtige explizite Interfaceimplementierung aufgerufen wird. <answer> <question> Wie wird in C# sichergestellt, dass explizite Interfaceimplementierungen von außen aufgerufen werden? <question>"
"Obwohl C# das Konzept der Interface-Implementierung aus JAVA übernommen hat, wurde seine Rolle hier deutlich gestärkt. In C# ist es möglich, dass eine Klasse dieselbe Methodendeklaration, die von verschiedenen Interfaces ""geerbt"" wurde, getrennt voneinander implementiert. Dies wird mithilfe von sogenannten expliziten Interfaceimplementierungen erreicht, wie im folgenden Beispiel dargestellt (beachten Sie, dass in C# der Doppelpunkt die Schlüsselwörter ""extends"" und ""implements"" aus JAVA ersetzt).
Der Nutzen der expliziten Interfaceimplementierung liegt darin, dass die Methode gibTelefonnummer() je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Der Typ der Variable (oder des Ausdrucks), die als Empfänger fungiert, gibt gewissermaßen die Rolle vor, in der das Objekt angesprochen wird (hier: Angestellte oder Privatperson). Es ist weder vorgesehen noch möglich, etwas wie x.Angestellte.gibTelefonnummer() an der Aufrufstelle zu schreiben (wobei x das Objekt bezeichnet); stattdessen steht einfach x.gibTelefonnummer(). Falls die Methodendeklaration Telefonnummer gibTelefonnummer() von einem gemeinsamen Superinterface von Angestellte und Privatperson, z. B. Erreichbar, geerbt würde, wäre das Programm ungültig. Es muss immer der tatsächlich deklarierende Typ als Qualifizierer angegeben werden.
Falls im obigen Beispiel für die beiden expliziten Interfaceimplementierungen von gibTelefonnummer() nicht wie in JAVA der Zugriffsmodifikator ""public"" angegeben wurde, geschah dies nicht ohne Grund. In C# ist es nämlich möglich, Methoden nicht als ""public"" zu deklarieren und dennoch per Interfaceimplementierung von außen darauf zuzugreifen. Allerdings ist dies an die explizite Interfaceimplementierung gebunden. Die sogenannte implizite Interfaceimplementierung, bei der manchmal nicht klar ist, welcher der aufgelisteten Supertypen ein Interface und welcher eine Superklasse ist, wird durch eine Namenskonvention aufgelöst: Im Common Type System von .NET sollten alle Interfacenamen mit einem ""I"" beginnen. Dies steht in der Tradition der bei MICROSOFT weit verbreiteten und nach dem früheren Mitarbeiter CHARLES SIMONYI benannten ungarischen Notation.
Explizite Interfaceimplementierungen können nicht überschrieben werden und dürfen nicht als ""virtual"" deklariert sein. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut. Es ist jedoch wichtig zu beachten, dass diese erneute explizite Implementierung keine Überschreibung darstellt. Insbesondere findet bei Aufruf der explizit implementierten Methode kein dynamisches Binden statt.","<answer> Nein, explizite Interfaceimplementierungen können nicht überschrieben werden. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut. <answer> <question> Können explizite Interfaceimplementierungen in C# überschrieben werden? <question>"
"Obwohl C# das Konzept der Interface-Implementierung aus JAVA übernommen hat, wurde seine Rolle hier deutlich gestärkt. In C# ist es möglich, dass eine Klasse dieselbe Methodendeklaration, die von verschiedenen Interfaces ""geerbt"" wurde, getrennt voneinander implementiert. Dies wird mithilfe von sogenannten expliziten Interfaceimplementierungen erreicht, wie im folgenden Beispiel dargestellt (beachten Sie, dass in C# der Doppelpunkt die Schlüsselwörter ""extends"" und ""implements"" aus JAVA ersetzt).
Der Nutzen der expliziten Interfaceimplementierung liegt darin, dass die Methode gibTelefonnummer() je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Der Typ der Variable (oder des Ausdrucks), die als Empfänger fungiert, gibt gewissermaßen die Rolle vor, in der das Objekt angesprochen wird (hier: Angestellte oder Privatperson). Es ist weder vorgesehen noch möglich, etwas wie x.Angestellte.gibTelefonnummer() an der Aufrufstelle zu schreiben (wobei x das Objekt bezeichnet); stattdessen steht einfach x.gibTelefonnummer(). Falls die Methodendeklaration Telefonnummer gibTelefonnummer() von einem gemeinsamen Superinterface von Angestellte und Privatperson, z. B. Erreichbar, geerbt würde, wäre das Programm ungültig. Es muss immer der tatsächlich deklarierende Typ als Qualifizierer angegeben werden.
Falls im obigen Beispiel für die beiden expliziten Interfaceimplementierungen von gibTelefonnummer() nicht wie in JAVA der Zugriffsmodifikator ""public"" angegeben wurde, geschah dies nicht ohne Grund. In C# ist es nämlich möglich, Methoden nicht als ""public"" zu deklarieren und dennoch per Interfaceimplementierung von außen darauf zuzugreifen. Allerdings ist dies an die explizite Interfaceimplementierung gebunden. Die sogenannte implizite Interfaceimplementierung, bei der manchmal nicht klar ist, welcher der aufgelisteten Supertypen ein Interface und welcher eine Superklasse ist, wird durch eine Namenskonvention aufgelöst: Im Common Type System von .NET sollten alle Interfacenamen mit einem ""I"" beginnen. Dies steht in der Tradition der bei MICROSOFT weit verbreiteten und nach dem früheren Mitarbeiter CHARLES SIMONYI benannten ungarischen Notation.
Explizite Interfaceimplementierungen können nicht überschrieben werden und dürfen nicht als ""virtual"" deklariert sein. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut. Es ist jedoch wichtig zu beachten, dass diese erneute explizite Implementierung keine Überschreibung darstellt. Insbesondere findet bei Aufruf der explizit implementierten Methode kein dynamisches Binden statt.","<answer> Ja, im Common Type System von .NET sollten alle Interfacenamen mit einem ""I"" beginnen. Dies dient zur Unterscheidung von Interface- und Klassennamen und folgt der Tradition der ungarischen Notation bei Microsoft. <answer> <question> Gibt es eine Namenskonvention für Interfaces in C#? <question>"
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.","<answer> Pseudovariablen in SMALLTALK sind Variablen wie ""true"", ""false"", ""nil"", ""self"", ""super"" und formale Parameter von Methoden sowie Klassennamen, denen der Programmierer keinen Wert zuweisen kann. Sie werden als Pseudovariablen bezeichnet, da sie ihren Wert entweder nicht ändern können oder ihren Wert vom System erhalten. <answer> <question> Was sind in SMALLTALK Pseudovariablen, und warum werden sie als solche bezeichnet? <question>"
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.","<answer> Die Zuweisung für Pseudovariablen wie ""true"", ""false"" und ""nil"" ist in SMALLTALK nicht zulässig, da sie auf Objekte von spezifischer Bedeutung verweisen und diese Bedeutung nicht verändert werden sollte. <answer> <question> Warum ist die Zuweisung für Pseudovariablen wie ""true"", ""false"" und ""nil"" in SMALLTALK nicht zulässig? <question>"
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.","<answer> Es ist wichtig zu wissen, dass diese Variablen Pseudovariablen sind, da sie spezielle Bedeutungen und Einschränkungen in SMALLTALK haben. Programmierer sollten sich bewusst sein, dass sie nicht denselben Regeln unterliegen wie normale Variablen. <answer> <question> Warum ist es wichtig zu wissen, dass diese Variablen Pseudovariablen sind? <question>"
"Genau wie in SMALLTALK werden in JAVA Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Anders als in SMALLTALK gibt es in JAVA jedoch eine Vielzahl von Schlüsselwörtern, die Anweisungen einleiten. Dennoch ist es auch in JAVA möglich, bestimmte Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden Ausdruck durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen (siehe Kapitel 37) direkt zu Anweisungen. Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK, das Semikolon in JAVA kein Trennzeichen ist, sondern Teil der Anweisung.
Nahezu alle Anweisungen finden sich in JAVA-Programmen innerhalb von Methoden. Blöcke sind in JAVA lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt JAVA erst seit Version 8, mit der Einführung der Lambda-Ausdrücke.
Es sind also Variablendeklarationen, Methodenaufrufe (inklusive der Konstruktoraufrufe) und Zuweisungen Anweisungen. Alle anderen Anweisungen werden durch Schlüsselwörter eingeleitet und realisieren Kontrollstrukturen, die den Kontrollfluss eines Programms dazu bringen, von der normalen, sequentiellen Ausführung abzuweichen. Im Einzelnen sind dies:
die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet;
die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst;
die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen);
die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet;
die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement);
die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C.
die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss;
die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde;
die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler);
die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen);
die Synchronized-Anweisung der Form synchronized (<Ausdruck>) <Block>, die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem <Ausdruck> ausgewertet wird, verbundene Lock dies zulässt (siehe Abschnitt 47.3);
die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden);
die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt;
die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.
Bemerkungen: Das Weglassen von break; am Ende einer Liste von Anweisungen in einem Case-Zweig der Switch-Anweisung wird als ""Fall durch"" bezeichnet und bewirkt, dass mit den Anweisungen des nächsten Case-Zweigs fortgefahren wird. Dies ermöglicht das Zusammenführen mehrerer Fälle, ist jedoch eines der fehlerträchtigsten Konstrukte C-artiger Sprachen.
Die Assert-Anweisung kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen. Wenn der Ablauf des Programms von diesen Werten abhängt, macht es einen Unterschied, ob ein Programm mit oder ohne Prüfung der Assertions ausgeführt wird. Das ist ein starkes Stück.
Assert-Anweisungen sind ein erster zarter Versuch, in JAVA auch noch andere Invarianten als die Typinvarianten unterzubringen. Dabei findet die Überprüfung dieser mittels assert eingebrachten Invarianten im Gegensatz zum Großteil der Typprüfung erst zur Laufzeit statt, indem die entsprechenden Statements ausgeführt werden. Dabei beziehen sich die Bedingungen, die die Invarianten formulieren, häufig auf Methoden des Programms, für die die Invarianten angegeben werden sollen. Da diese Methoden aber auch den Zustand des Programms ändern können, kann man einer Zusicherung mit assert nicht ansehen, ob sie seiteneffektfrei ist. Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden nicht als Anweisungen formuliert, sondern als Quellcodeannotationen und stellen zudem sicher, dass alle Zugriffe auf Programmelemente, die zur Laufzeit notwendig sind, den Zustand des Programms nicht verändern.","<answer> In JAVA gibt es verschiedene Arten von Anweisungen, darunter Variablendeklarationen, Wertzuweisungen, Methodenaufrufe, Klasseninstanziierungen und Kontrollstrukturen wie If-Anweisungen, Schleifen, Switch-Anweisungen, Try-Anweisungen und mehr. <answer> <question> Welche Arten von Anweisungen gibt es in JAVA? <question>"
"Genau wie in SMALLTALK werden in JAVA Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Anders als in SMALLTALK gibt es in JAVA jedoch eine Vielzahl von Schlüsselwörtern, die Anweisungen einleiten. Dennoch ist es auch in JAVA möglich, bestimmte Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden Ausdruck durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen (siehe Kapitel 37) direkt zu Anweisungen. Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK, das Semikolon in JAVA kein Trennzeichen ist, sondern Teil der Anweisung.
Nahezu alle Anweisungen finden sich in JAVA-Programmen innerhalb von Methoden. Blöcke sind in JAVA lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt JAVA erst seit Version 8, mit der Einführung der Lambda-Ausdrücke.
Es sind also Variablendeklarationen, Methodenaufrufe (inklusive der Konstruktoraufrufe) und Zuweisungen Anweisungen. Alle anderen Anweisungen werden durch Schlüsselwörter eingeleitet und realisieren Kontrollstrukturen, die den Kontrollfluss eines Programms dazu bringen, von der normalen, sequentiellen Ausführung abzuweichen. Im Einzelnen sind dies:
die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet;
die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst;
die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen);
die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet;
die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement);
die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C.
die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss;
die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde;
die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler);
die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen);
die Synchronized-Anweisung der Form synchronized (<Ausdruck>) <Block>, die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem <Ausdruck> ausgewertet wird, verbundene Lock dies zulässt (siehe Abschnitt 47.3);
die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden);
die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt;
die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.
Bemerkungen: Das Weglassen von break; am Ende einer Liste von Anweisungen in einem Case-Zweig der Switch-Anweisung wird als ""Fall durch"" bezeichnet und bewirkt, dass mit den Anweisungen des nächsten Case-Zweigs fortgefahren wird. Dies ermöglicht das Zusammenführen mehrerer Fälle, ist jedoch eines der fehlerträchtigsten Konstrukte C-artiger Sprachen.
Die Assert-Anweisung kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen. Wenn der Ablauf des Programms von diesen Werten abhängt, macht es einen Unterschied, ob ein Programm mit oder ohne Prüfung der Assertions ausgeführt wird. Das ist ein starkes Stück.
Assert-Anweisungen sind ein erster zarter Versuch, in JAVA auch noch andere Invarianten als die Typinvarianten unterzubringen. Dabei findet die Überprüfung dieser mittels assert eingebrachten Invarianten im Gegensatz zum Großteil der Typprüfung erst zur Laufzeit statt, indem die entsprechenden Statements ausgeführt werden. Dabei beziehen sich die Bedingungen, die die Invarianten formulieren, häufig auf Methoden des Programms, für die die Invarianten angegeben werden sollen. Da diese Methoden aber auch den Zustand des Programms ändern können, kann man einer Zusicherung mit assert nicht ansehen, ob sie seiteneffektfrei ist. Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden nicht als Anweisungen formuliert, sondern als Quellcodeannotationen und stellen zudem sicher, dass alle Zugriffe auf Programmelemente, die zur Laufzeit notwendig sind, den Zustand des Programms nicht verändern.","<answer> In JAVA können Ausdrücke zu Anweisungen gemacht werden, indem sie einfach durch ein Semikolon abgeschlossen werden. Dies gilt insbesondere für Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen. <answer> <question> Wie können Ausdrücke zu Anweisungen in JAVA gemacht werden? <question>"
"Genau wie in SMALLTALK werden in JAVA Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Anders als in SMALLTALK gibt es in JAVA jedoch eine Vielzahl von Schlüsselwörtern, die Anweisungen einleiten. Dennoch ist es auch in JAVA möglich, bestimmte Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden Ausdruck durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen (siehe Kapitel 37) direkt zu Anweisungen. Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK, das Semikolon in JAVA kein Trennzeichen ist, sondern Teil der Anweisung.
Nahezu alle Anweisungen finden sich in JAVA-Programmen innerhalb von Methoden. Blöcke sind in JAVA lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt JAVA erst seit Version 8, mit der Einführung der Lambda-Ausdrücke.
Es sind also Variablendeklarationen, Methodenaufrufe (inklusive der Konstruktoraufrufe) und Zuweisungen Anweisungen. Alle anderen Anweisungen werden durch Schlüsselwörter eingeleitet und realisieren Kontrollstrukturen, die den Kontrollfluss eines Programms dazu bringen, von der normalen, sequentiellen Ausführung abzuweichen. Im Einzelnen sind dies:
die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet;
die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst;
die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen);
die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet;
die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement);
die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C.
die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss;
die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde;
die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler);
die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen);
die Synchronized-Anweisung der Form synchronized (<Ausdruck>) <Block>, die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem <Ausdruck> ausgewertet wird, verbundene Lock dies zulässt (siehe Abschnitt 47.3);
die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden);
die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt;
die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.
Bemerkungen: Das Weglassen von break; am Ende einer Liste von Anweisungen in einem Case-Zweig der Switch-Anweisung wird als ""Fall durch"" bezeichnet und bewirkt, dass mit den Anweisungen des nächsten Case-Zweigs fortgefahren wird. Dies ermöglicht das Zusammenführen mehrerer Fälle, ist jedoch eines der fehlerträchtigsten Konstrukte C-artiger Sprachen.
Die Assert-Anweisung kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen. Wenn der Ablauf des Programms von diesen Werten abhängt, macht es einen Unterschied, ob ein Programm mit oder ohne Prüfung der Assertions ausgeführt wird. Das ist ein starkes Stück.
Assert-Anweisungen sind ein erster zarter Versuch, in JAVA auch noch andere Invarianten als die Typinvarianten unterzubringen. Dabei findet die Überprüfung dieser mittels assert eingebrachten Invarianten im Gegensatz zum Großteil der Typprüfung erst zur Laufzeit statt, indem die entsprechenden Statements ausgeführt werden. Dabei beziehen sich die Bedingungen, die die Invarianten formulieren, häufig auf Methoden des Programms, für die die Invarianten angegeben werden sollen. Da diese Methoden aber auch den Zustand des Programms ändern können, kann man einer Zusicherung mit assert nicht ansehen, ob sie seiteneffektfrei ist. Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden nicht als Anweisungen formuliert, sondern als Quellcodeannotationen und stellen zudem sicher, dass alle Zugriffe auf Programmelemente, die zur Laufzeit notwendig sind, den Zustand des Programms nicht verändern.","<answer> JAVA unterstützt While-Schleifen, Do-Schleifen, For-Schleifen und die erweiterte For-Schleife. Dabei wird While-Schleife verwendet, um Anweisungen solange auszuführen, wie eine Bedingung wahr ist. Do-Schleife ist ähnlich, aber die Bedingung wird erst nach der Ausführung überprüft. For-Schleifen ermöglichen die explizite Initialisierung, Bedingung und Veränderung der Schleifenvariable. Die erweiterte For-Schleife iteriert über die Elemente eines Arrays oder Objekts, das Iterable implementiert. <answer> <question> Welche Arten von Schleifen werden in JAVA unterstützt? <question>"
"Genau wie in SMALLTALK werden in JAVA Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Anders als in SMALLTALK gibt es in JAVA jedoch eine Vielzahl von Schlüsselwörtern, die Anweisungen einleiten. Dennoch ist es auch in JAVA möglich, bestimmte Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden Ausdruck durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen (siehe Kapitel 37) direkt zu Anweisungen. Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK, das Semikolon in JAVA kein Trennzeichen ist, sondern Teil der Anweisung.
Nahezu alle Anweisungen finden sich in JAVA-Programmen innerhalb von Methoden. Blöcke sind in JAVA lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt JAVA erst seit Version 8, mit der Einführung der Lambda-Ausdrücke.
Es sind also Variablendeklarationen, Methodenaufrufe (inklusive der Konstruktoraufrufe) und Zuweisungen Anweisungen. Alle anderen Anweisungen werden durch Schlüsselwörter eingeleitet und realisieren Kontrollstrukturen, die den Kontrollfluss eines Programms dazu bringen, von der normalen, sequentiellen Ausführung abzuweichen. Im Einzelnen sind dies:
die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet;
die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst;
die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen);
die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet;
die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement);
die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C.
die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss;
die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde;
die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler);
die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen);
die Synchronized-Anweisung der Form synchronized (<Ausdruck>) <Block>, die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem <Ausdruck> ausgewertet wird, verbundene Lock dies zulässt (siehe Abschnitt 47.3);
die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden);
die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt;
die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.
Bemerkungen: Das Weglassen von break; am Ende einer Liste von Anweisungen in einem Case-Zweig der Switch-Anweisung wird als ""Fall durch"" bezeichnet und bewirkt, dass mit den Anweisungen des nächsten Case-Zweigs fortgefahren wird. Dies ermöglicht das Zusammenführen mehrerer Fälle, ist jedoch eines der fehlerträchtigsten Konstrukte C-artiger Sprachen.
Die Assert-Anweisung kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen. Wenn der Ablauf des Programms von diesen Werten abhängt, macht es einen Unterschied, ob ein Programm mit oder ohne Prüfung der Assertions ausgeführt wird. Das ist ein starkes Stück.
Assert-Anweisungen sind ein erster zarter Versuch, in JAVA auch noch andere Invarianten als die Typinvarianten unterzubringen. Dabei findet die Überprüfung dieser mittels assert eingebrachten Invarianten im Gegensatz zum Großteil der Typprüfung erst zur Laufzeit statt, indem die entsprechenden Statements ausgeführt werden. Dabei beziehen sich die Bedingungen, die die Invarianten formulieren, häufig auf Methoden des Programms, für die die Invarianten angegeben werden sollen. Da diese Methoden aber auch den Zustand des Programms ändern können, kann man einer Zusicherung mit assert nicht ansehen, ob sie seiteneffektfrei ist. Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden nicht als Anweisungen formuliert, sondern als Quellcodeannotationen und stellen zudem sicher, dass alle Zugriffe auf Programmelemente, die zur Laufzeit notwendig sind, den Zustand des Programms nicht verändern.","<answer> Die Break-Anweisung in JAVA bewirkt, dass eine Schleife oder ein Switch-Statement sofort verlassen wird. Sie kann optional mit einem Label versehen werden, um eine äußere Schleife oder ein äußeres Switch-Statement zu verlassen. <answer> <question> Was bewirkt die Break-Anweisung in JAVA? <question>"
"Genau wie in SMALLTALK werden in JAVA Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Anders als in SMALLTALK gibt es in JAVA jedoch eine Vielzahl von Schlüsselwörtern, die Anweisungen einleiten. Dennoch ist es auch in JAVA möglich, bestimmte Ausdrücke zu Anweisungen zu machen: Man schließt einfach einen betreffenden Ausdruck durch ein Semikolon ab. Insbesondere werden so Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen (siehe Kapitel 37) direkt zu Anweisungen. Man beachte, dass, anders als das Semikolon in PASCAL oder der Punkt in SMALLTALK, das Semikolon in JAVA kein Trennzeichen ist, sondern Teil der Anweisung.
Nahezu alle Anweisungen finden sich in JAVA-Programmen innerhalb von Methoden. Blöcke sind in JAVA lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt JAVA erst seit Version 8, mit der Einführung der Lambda-Ausdrücke.
Es sind also Variablendeklarationen, Methodenaufrufe (inklusive der Konstruktoraufrufe) und Zuweisungen Anweisungen. Alle anderen Anweisungen werden durch Schlüsselwörter eingeleitet und realisieren Kontrollstrukturen, die den Kontrollfluss eines Programms dazu bringen, von der normalen, sequentiellen Ausführung abzuweichen. Im Einzelnen sind dies:
die If-Anweisung der Form if (<Boolescher Ausdruck>) <Statement>, bei der <Statement> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet;
die If-else-Anweisung der Form if (<Boolescher Ausdruck>) <Statement 1> else <Statement 2>, bei der <Statement 1> genau dann ausgeführt wird, wenn <Boolescher Ausdruck> zu true auswertet, und <Statement 2> sonst;
die Switch-Anweisung der Form: switch (<Ausdruck>) { case <Literal 1>: <Anweisungsliste 1> case <Literal 2>: <Anweisungsliste 2> default: <Anweisungsliste> } wobei <Ausdruck> sowie <Literal 1>, <Literal 2> usw. vom Typ char, byte, short, int (bzw. einem der dazugehörigen Wrapper-Typen), String oder von einem Aufzählungstyp sein müssen, und <Anweisungsliste 1> usw. für Folgen von Anweisungen stehen können, die jeweils mit einem break; abgeschlossen werden können (aber nicht müssen);
die While-Anweisung der Form while (<Boolescher Ausdruck>) <Statement>, die im Wesentlichen der If-Anweisung entspricht, mit dem Unterschied, dass <Statement> nicht nur einmal ausgeführt wird, sondern solange, bis <Boolescher Ausdruck> zu false auswertet;
die Do-Anweisung der Form do <Statement> while (<Boolescher Ausdruck>), die im Wesentlichen dem While-Statement entspricht, mit dem Unterschied, dass <Boolescher Ausdruck> immer erst nach Ausführung von <Statement> ausgewertet wird (man beachte, dass <Statement> kein Block sein muss; das abschließende Semikolon wirkt dann etwas deplaziert, so wie das vor else beim If-Statement);
die For-Anweisung in der Form: for (<Initialisierungsausdruck>; <Boolescher Ausdruck>; <Veränderungsausdruck>) <Statement> Gleichwohl können in einem der drei Segmente innerhalb der Klammern auch mehrere Ausdrücke erscheinen, die dann aber durch Kommata getrennt werden. All diese syntaktischen Inkonsequenzen sind Erbe von C.
die erweiterte For-Anweisung in der Form for (<Variable> : <Ausdruck>) <Statement>, die <Statement> für alle Werte, die <Ausdruck> liefert, einmal ausführt, und zwar mit dem jeweiligen Wert als Inhalt der Variable. <Ausdruck> zu diesem Zweck muss entweder vom Typ eines Arrays sein oder das Interface Iterable implementieren muss, was bedeutet, dass das Objekt, zu dem <Ausdruck> ausgewertet wird, die Methoden hasNext() und next() anbieten muss;
die Break-Anweisung der Form break; bzw. break <Label>;, die innerhalb von Schleifen oder Switch-Statements dazu führt, dass diese sofort verlassen werden, wobei <Label> sich auf ein Label bezieht, das einer äußeren Schleife oder einem äußeren Switch-Statement vorangestellt wurde;
die Continue-Anweisung der Form continue; bzw. continue <Label>;, die innerhalb von Schleifen dazu führt, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird (Continue-Anweisungen außerhalb von Schleifen bzw. mit einer Nicht-Schleife als Label sind ein Syntaxfehler);
die Return-Anweisung der Form return; bzw. return <Ausdruck>;, die bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird (return; darf auch in einem Konstruktor vorkommen);
die Synchronized-Anweisung der Form synchronized (<Ausdruck>) <Block>, die dafür sorgt, dass der durch <Block> bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem <Ausdruck> ausgewertet wird, verbundene Lock dies zulässt (siehe Abschnitt 47.3);
die Try-Anweisung der Form: try <Try-Block> catch (<formaler Parameter 1>) <Catch-Block 1> catch (<formaler Parameter 2>) <Catch-Block 2> finally <Finally-Block> wobei <Try-Block> für einen Block steht, von dessen Ausführung man weiß, dass sie durch einen Laufzeitfehler abgebrochen werden kann, wobei mit den Sequenzen catch (<formaler Parameter 1>) <Catch-Block 1> usw. für verschiedene Arten von Laufzeitfehlern verschiedene Behandlungsblöcke angegeben werden können, und wobei finally <Finally-Block> einen Block spezifiziert, der immer ausgeführt wird, nachdem alle anderen Blöcke ausgeführt oder abgebrochen wurden (kann auch weggelassen werden);
die Throw-Anweisung der Form throw <Exception>;, die das Programm eine Exception werfen lässt;
die Assert-Anweisung der Form assert <Ausdruck 1>; oder assert <Ausdruck 1> : <Ausdruck 2>;, wobei <Ausdruck 1> ein Boolescher Ausdruck und <Ausdruck 2> von beliebigem Typ außer void sein muss. Diese Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn <Ausdruck 1> zu false auswertet, wobei ggf. das Ergebnis von <Ausdruck 2> mit der Fehlermeldung ausgegeben wird. Außerdem ist die leere Anweisung, bestehend aus einem einzelnen Semikolon, eine Anweisung.
Bemerkungen: Das Weglassen von break; am Ende einer Liste von Anweisungen in einem Case-Zweig der Switch-Anweisung wird als ""Fall durch"" bezeichnet und bewirkt, dass mit den Anweisungen des nächsten Case-Zweigs fortgefahren wird. Dies ermöglicht das Zusammenführen mehrerer Fälle, ist jedoch eines der fehlerträchtigsten Konstrukte C-artiger Sprachen.
Die Assert-Anweisung kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen. Wenn der Ablauf des Programms von diesen Werten abhängt, macht es einen Unterschied, ob ein Programm mit oder ohne Prüfung der Assertions ausgeführt wird. Das ist ein starkes Stück.
Assert-Anweisungen sind ein erster zarter Versuch, in JAVA auch noch andere Invarianten als die Typinvarianten unterzubringen. Dabei findet die Überprüfung dieser mittels assert eingebrachten Invarianten im Gegensatz zum Großteil der Typprüfung erst zur Laufzeit statt, indem die entsprechenden Statements ausgeführt werden. Dabei beziehen sich die Bedingungen, die die Invarianten formulieren, häufig auf Methoden des Programms, für die die Invarianten angegeben werden sollen. Da diese Methoden aber auch den Zustand des Programms ändern können, kann man einer Zusicherung mit assert nicht ansehen, ob sie seiteneffektfrei ist. Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden nicht als Anweisungen formuliert, sondern als Quellcodeannotationen und stellen zudem sicher, dass alle Zugriffe auf Programmelemente, die zur Laufzeit notwendig sind, den Zustand des Programms nicht verändern.","<answer> Die Assert-Anweisung in JAVA dient dazu, bestimmte Bedingungen im Programm zu überprüfen. Wenn die Bedingung zu false ausgewertet wird, wird das Programm mit einer entsprechenden Fehlermeldung abgebrochen. Die Assert-Anweisung kann auch ein optionales Ergebnis liefern, das in der Fehlermeldung angezeigt wird. Sie eignet sich zur Überprüfung von Invarianten zur Laufzeit. <answer> <question> Was ist der Zweck der Assert-Anweisung in JAVA? <question>"
"Man könnte nun versucht sein, den Zusammenhang von Klassen und Typen auch unter Vererbung bzw. Subtyping beizubehalten und damit zu erwarten, dass eine Instanz einer Subklasse einer Klasse dem Wertebereich des zur Superklasse gehörenden Typs angehört. Das ist jedoch dann nicht der Fall, wenn in der Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, also z. B. Methoden gelöscht oder inkompatibel redefiniert werden. Die meisten objektorientierten Programmiersprachen verbieten das jedoch, so dass sich die Subklassenbeziehung tatsächlich auf eine parallele Subtypenbeziehung übertragen lässt.","<answer> Eine Instanz einer Subklasse gehört nicht zwangsläufig zum Wertebereich des zur Superklasse gehörenden Typs, da in der Subklasse Änderungen vorgenommen werden können, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben können. Zum Beispiel können Methoden gelöscht oder inkompatibel redefiniert werden. <answer> <question> Warum gehört eine Instanz einer Subklasse nicht zwangsläufig zum Wertebereich des zur Superklasse gehörenden Typs? <question>"
"Man könnte nun versucht sein, den Zusammenhang von Klassen und Typen auch unter Vererbung bzw. Subtyping beizubehalten und damit zu erwarten, dass eine Instanz einer Subklasse einer Klasse dem Wertebereich des zur Superklasse gehörenden Typs angehört. Das ist jedoch dann nicht der Fall, wenn in der Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, also z. B. Methoden gelöscht oder inkompatibel redefiniert werden. Die meisten objektorientierten Programmiersprachen verbieten das jedoch, so dass sich die Subklassenbeziehung tatsächlich auf eine parallele Subtypenbeziehung übertragen lässt.","<answer> Die Konsequenz daraus ist, dass die Beziehung von Subklassen und Subtypen in den meisten objektorientierten Programmiersprachen auf eine parallele Subtypenbeziehung übertragen werden kann. Das bedeutet, dass eine Instanz einer Subklasse auch als Instanz des zur Superklasse gehörenden Typs betrachtet werden kann, sofern die Subklassenbeziehung die Typkonformität nicht aufhebt. <answer> <question> Welche Konsequenz ergibt sich daraus für die Beziehung von Subklassen und Subtypen? <question>"
"Einen Typ, dessen Definition alle deklarierten Elemente der Definition eines anderen Typen enthält, nennt man mit dem anderen typkonform. So ist InternationalesBüro im obigen Beispiel mit Büro typkonform. Typkonformität ist in vielen Sprachen eine notwendige und hinreichende Voraussetzung für die Zuweisungskompatibilität: Es darf dann ein Objekt vom Typ InternationalesBüro einer Variable vom Typ Büro zugewiesen werden.
Typkonformität ist aber reflexiv, d.h., jeder Typ ist konform zu sich selbst. Sie ist weiterhin transitiv: Wenn A typkonform zu B ist und B typkonform zu C, dann ist auch A typkonform zu C. Wie man sich leicht denken kann, ist die Typkonformität jedoch im Gegensatz zur Typäquivalenz nicht symmetrisch: Aus der Tatsache, dass ein Typ B typkonform zu einem Typ A ist, folgt nicht, dass auch A typkonform zu B ist. Vielmehr ist dies mit einer kleinen Ausnahme sogar zwingend nicht der Fall: Typkonformität ist meistens antisymmetrisch, was bedeutet, dass wenn B zu A und A zu B typkonform ist, dann müssen A und B identisch sein.
Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.
Für die nominale Konformität muss zusätzlich und explizit die Erweiterung eines (oder Ableitung von einem) anderen Typ angegeben werden: die Definition von InternationalesBüro aus Kapitel 23 ist also mit Büro nicht nur strukturell, sondern auch nominal konform. Da bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben, folgt die Konformität aus der Erweiterung.
Nun ist die Teilmengenbeziehung reflexiv, was auf die Typerweiterung übertragen bedeutet, dass ein Typ eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.
Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.
Genau wie bei der Typäquivalenz hat die nominale Typkonformität zusätzlich zur Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von Typfehlern (die ja auch bei einer strukturellen Typkonformität schon gegeben wäre) eine Filterfunktion: Es sind nur Objekte von solchen Typen Variablen zuweisbar, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorgesehen hat. Auf diese Filterfunktion werden wir später im Zusammenhang mit sogenannten Tagging oder Marker Interfaces (in Kurseinheit 4, Kapitel 45) noch zurückkommen.
Da die Typkonformität bei Nennung des Typs, von dem ein neuer per Erweiterung abgeleitet wird, automatisch gegeben ist (und so keine aufwendigen, fallweisen Konformitätstests durchgeführt werden müssen), setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität. Interessanterweise wurde STRONGTALK, das ursprünglich ein auf struktureller Konformität beruhendes Typsystem (inkl. Type branding) hatte, inzwischen auf nominale Typkonformität umgestellt. Als Begründung wurde angeführt, dass ein strukturelles Typsystem, insbesondere eines, bei dem Typen nicht explizit benannt werden, es der Programmiererin nicht erlaubt, ihre Absicht (intendierte Semantik, die obengenannte Filterfunktion) auszudrücken, was Programme schwerer zu lesen und zu debuggen macht, und dass die Fehlermeldungen, die eine strukturelle Typprüfung produziert, sich oft nicht auf die eigentliche Fehlerquelle beziehen und sehr schwer zu verstehen sind [STRONGTALK 2.0].
Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.","<answer> Ein Typ wird als ""typkonform"" bezeichnet, wenn seine Definition alle deklarierten Elemente der Definition eines anderen Typen enthält. <answer> <question> Was bedeutet es, wenn ein Typ als ""typkonform"" bezeichnet wird? <question>"
"Einen Typ, dessen Definition alle deklarierten Elemente der Definition eines anderen Typen enthält, nennt man mit dem anderen typkonform. So ist InternationalesBüro im obigen Beispiel mit Büro typkonform. Typkonformität ist in vielen Sprachen eine notwendige und hinreichende Voraussetzung für die Zuweisungskompatibilität: Es darf dann ein Objekt vom Typ InternationalesBüro einer Variable vom Typ Büro zugewiesen werden.
Typkonformität ist aber reflexiv, d.h., jeder Typ ist konform zu sich selbst. Sie ist weiterhin transitiv: Wenn A typkonform zu B ist und B typkonform zu C, dann ist auch A typkonform zu C. Wie man sich leicht denken kann, ist die Typkonformität jedoch im Gegensatz zur Typäquivalenz nicht symmetrisch: Aus der Tatsache, dass ein Typ B typkonform zu einem Typ A ist, folgt nicht, dass auch A typkonform zu B ist. Vielmehr ist dies mit einer kleinen Ausnahme sogar zwingend nicht der Fall: Typkonformität ist meistens antisymmetrisch, was bedeutet, dass wenn B zu A und A zu B typkonform ist, dann müssen A und B identisch sein.
Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.
Für die nominale Konformität muss zusätzlich und explizit die Erweiterung eines (oder Ableitung von einem) anderen Typ angegeben werden: die Definition von InternationalesBüro aus Kapitel 23 ist also mit Büro nicht nur strukturell, sondern auch nominal konform. Da bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben, folgt die Konformität aus der Erweiterung.
Nun ist die Teilmengenbeziehung reflexiv, was auf die Typerweiterung übertragen bedeutet, dass ein Typ eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.
Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.
Genau wie bei der Typäquivalenz hat die nominale Typkonformität zusätzlich zur Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von Typfehlern (die ja auch bei einer strukturellen Typkonformität schon gegeben wäre) eine Filterfunktion: Es sind nur Objekte von solchen Typen Variablen zuweisbar, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorgesehen hat. Auf diese Filterfunktion werden wir später im Zusammenhang mit sogenannten Tagging oder Marker Interfaces (in Kurseinheit 4, Kapitel 45) noch zurückkommen.
Da die Typkonformität bei Nennung des Typs, von dem ein neuer per Erweiterung abgeleitet wird, automatisch gegeben ist (und so keine aufwendigen, fallweisen Konformitätstests durchgeführt werden müssen), setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität. Interessanterweise wurde STRONGTALK, das ursprünglich ein auf struktureller Konformität beruhendes Typsystem (inkl. Type branding) hatte, inzwischen auf nominale Typkonformität umgestellt. Als Begründung wurde angeführt, dass ein strukturelles Typsystem, insbesondere eines, bei dem Typen nicht explizit benannt werden, es der Programmiererin nicht erlaubt, ihre Absicht (intendierte Semantik, die obengenannte Filterfunktion) auszudrücken, was Programme schwerer zu lesen und zu debuggen macht, und dass die Fehlermeldungen, die eine strukturelle Typprüfung produziert, sich oft nicht auf die eigentliche Fehlerquelle beziehen und sehr schwer zu verstehen sind [STRONGTALK 2.0].
Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.","<answer> Typkonformität ist in vielen Sprachen eine notwendige Voraussetzung für die Zuweisungskompatibilität. Das bedeutet, dass ein Objekt eines typkonformen Typs einer Variable eines anderen, typgleichen Typs zugewiesen werden darf. <answer> <question> Welche Bedeutung hat die Typkonformität in Bezug auf die Zuweisungskompatibilität? <question>"
"Einen Typ, dessen Definition alle deklarierten Elemente der Definition eines anderen Typen enthält, nennt man mit dem anderen typkonform. So ist InternationalesBüro im obigen Beispiel mit Büro typkonform. Typkonformität ist in vielen Sprachen eine notwendige und hinreichende Voraussetzung für die Zuweisungskompatibilität: Es darf dann ein Objekt vom Typ InternationalesBüro einer Variable vom Typ Büro zugewiesen werden.
Typkonformität ist aber reflexiv, d.h., jeder Typ ist konform zu sich selbst. Sie ist weiterhin transitiv: Wenn A typkonform zu B ist und B typkonform zu C, dann ist auch A typkonform zu C. Wie man sich leicht denken kann, ist die Typkonformität jedoch im Gegensatz zur Typäquivalenz nicht symmetrisch: Aus der Tatsache, dass ein Typ B typkonform zu einem Typ A ist, folgt nicht, dass auch A typkonform zu B ist. Vielmehr ist dies mit einer kleinen Ausnahme sogar zwingend nicht der Fall: Typkonformität ist meistens antisymmetrisch, was bedeutet, dass wenn B zu A und A zu B typkonform ist, dann müssen A und B identisch sein.
Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.
Für die nominale Konformität muss zusätzlich und explizit die Erweiterung eines (oder Ableitung von einem) anderen Typ angegeben werden: die Definition von InternationalesBüro aus Kapitel 23 ist also mit Büro nicht nur strukturell, sondern auch nominal konform. Da bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben, folgt die Konformität aus der Erweiterung.
Nun ist die Teilmengenbeziehung reflexiv, was auf die Typerweiterung übertragen bedeutet, dass ein Typ eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.
Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.
Genau wie bei der Typäquivalenz hat die nominale Typkonformität zusätzlich zur Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von Typfehlern (die ja auch bei einer strukturellen Typkonformität schon gegeben wäre) eine Filterfunktion: Es sind nur Objekte von solchen Typen Variablen zuweisbar, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorgesehen hat. Auf diese Filterfunktion werden wir später im Zusammenhang mit sogenannten Tagging oder Marker Interfaces (in Kurseinheit 4, Kapitel 45) noch zurückkommen.
Da die Typkonformität bei Nennung des Typs, von dem ein neuer per Erweiterung abgeleitet wird, automatisch gegeben ist (und so keine aufwendigen, fallweisen Konformitätstests durchgeführt werden müssen), setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität. Interessanterweise wurde STRONGTALK, das ursprünglich ein auf struktureller Konformität beruhendes Typsystem (inkl. Type branding) hatte, inzwischen auf nominale Typkonformität umgestellt. Als Begründung wurde angeführt, dass ein strukturelles Typsystem, insbesondere eines, bei dem Typen nicht explizit benannt werden, es der Programmiererin nicht erlaubt, ihre Absicht (intendierte Semantik, die obengenannte Filterfunktion) auszudrücken, was Programme schwerer zu lesen und zu debuggen macht, und dass die Fehlermeldungen, die eine strukturelle Typprüfung produziert, sich oft nicht auf die eigentliche Fehlerquelle beziehen und sehr schwer zu verstehen sind [STRONGTALK 2.0].
Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.","<answer> Typkonformität ist reflexiv, da jeder Typ konform zu sich selbst ist. Sie ist transitiv, sodass wenn Typ A konform zu Typ B ist und Typ B konform zu Typ C ist, dann ist auch Typ A konform zu Typ C. Im Gegensatz zur Typäquivalenz ist Typkonformität nicht symmetrisch. Es gilt jedoch meistens die Antisymmetrie, was bedeutet, dass wenn Typ B zu Typ A und Typ A zu Typ B konform ist, dann müssen A und B identisch sein. <answer> <question> Wie verhält sich die Typkonformität in Bezug auf Reflexivität, Transitivität und Symmetrie? <question>"
"Einen Typ, dessen Definition alle deklarierten Elemente der Definition eines anderen Typen enthält, nennt man mit dem anderen typkonform. So ist InternationalesBüro im obigen Beispiel mit Büro typkonform. Typkonformität ist in vielen Sprachen eine notwendige und hinreichende Voraussetzung für die Zuweisungskompatibilität: Es darf dann ein Objekt vom Typ InternationalesBüro einer Variable vom Typ Büro zugewiesen werden.
Typkonformität ist aber reflexiv, d.h., jeder Typ ist konform zu sich selbst. Sie ist weiterhin transitiv: Wenn A typkonform zu B ist und B typkonform zu C, dann ist auch A typkonform zu C. Wie man sich leicht denken kann, ist die Typkonformität jedoch im Gegensatz zur Typäquivalenz nicht symmetrisch: Aus der Tatsache, dass ein Typ B typkonform zu einem Typ A ist, folgt nicht, dass auch A typkonform zu B ist. Vielmehr ist dies mit einer kleinen Ausnahme sogar zwingend nicht der Fall: Typkonformität ist meistens antisymmetrisch, was bedeutet, dass wenn B zu A und A zu B typkonform ist, dann müssen A und B identisch sein.
Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.
Für die nominale Konformität muss zusätzlich und explizit die Erweiterung eines (oder Ableitung von einem) anderen Typ angegeben werden: die Definition von InternationalesBüro aus Kapitel 23 ist also mit Büro nicht nur strukturell, sondern auch nominal konform. Da bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben, folgt die Konformität aus der Erweiterung.
Nun ist die Teilmengenbeziehung reflexiv, was auf die Typerweiterung übertragen bedeutet, dass ein Typ eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.
Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.
Genau wie bei der Typäquivalenz hat die nominale Typkonformität zusätzlich zur Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von Typfehlern (die ja auch bei einer strukturellen Typkonformität schon gegeben wäre) eine Filterfunktion: Es sind nur Objekte von solchen Typen Variablen zuweisbar, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorgesehen hat. Auf diese Filterfunktion werden wir später im Zusammenhang mit sogenannten Tagging oder Marker Interfaces (in Kurseinheit 4, Kapitel 45) noch zurückkommen.
Da die Typkonformität bei Nennung des Typs, von dem ein neuer per Erweiterung abgeleitet wird, automatisch gegeben ist (und so keine aufwendigen, fallweisen Konformitätstests durchgeführt werden müssen), setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität. Interessanterweise wurde STRONGTALK, das ursprünglich ein auf struktureller Konformität beruhendes Typsystem (inkl. Type branding) hatte, inzwischen auf nominale Typkonformität umgestellt. Als Begründung wurde angeführt, dass ein strukturelles Typsystem, insbesondere eines, bei dem Typen nicht explizit benannt werden, es der Programmiererin nicht erlaubt, ihre Absicht (intendierte Semantik, die obengenannte Filterfunktion) auszudrücken, was Programme schwerer zu lesen und zu debuggen macht, und dass die Fehlermeldungen, die eine strukturelle Typprüfung produziert, sich oft nicht auf die eigentliche Fehlerquelle beziehen und sehr schwer zu verstehen sind [STRONGTALK 2.0].
Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.","<answer> Es gibt strukturelle Typkonformität und nominale Typkonformität. Bei struktureller Typkonformität müssen alle Elemente des konformen Typs im konformen Typ enthalten sein. Bei nominaler Typkonformität muss zusätzlich die Erweiterung eines anderen Typs explizit angegeben werden. <answer> <question> Welche beiden Varianten der Typkonformität gibt es, und wie unterscheiden sie sich? <question>"
"Einen Typ, dessen Definition alle deklarierten Elemente der Definition eines anderen Typen enthält, nennt man mit dem anderen typkonform. So ist InternationalesBüro im obigen Beispiel mit Büro typkonform. Typkonformität ist in vielen Sprachen eine notwendige und hinreichende Voraussetzung für die Zuweisungskompatibilität: Es darf dann ein Objekt vom Typ InternationalesBüro einer Variable vom Typ Büro zugewiesen werden.
Typkonformität ist aber reflexiv, d.h., jeder Typ ist konform zu sich selbst. Sie ist weiterhin transitiv: Wenn A typkonform zu B ist und B typkonform zu C, dann ist auch A typkonform zu C. Wie man sich leicht denken kann, ist die Typkonformität jedoch im Gegensatz zur Typäquivalenz nicht symmetrisch: Aus der Tatsache, dass ein Typ B typkonform zu einem Typ A ist, folgt nicht, dass auch A typkonform zu B ist. Vielmehr ist dies mit einer kleinen Ausnahme sogar zwingend nicht der Fall: Typkonformität ist meistens antisymmetrisch, was bedeutet, dass wenn B zu A und A zu B typkonform ist, dann müssen A und B identisch sein.
Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.
Für die nominale Konformität muss zusätzlich und explizit die Erweiterung eines (oder Ableitung von einem) anderen Typ angegeben werden: die Definition von InternationalesBüro aus Kapitel 23 ist also mit Büro nicht nur strukturell, sondern auch nominal konform. Da bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben, folgt die Konformität aus der Erweiterung.
Nun ist die Teilmengenbeziehung reflexiv, was auf die Typerweiterung übertragen bedeutet, dass ein Typ eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.
Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.
Genau wie bei der Typäquivalenz hat die nominale Typkonformität zusätzlich zur Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von Typfehlern (die ja auch bei einer strukturellen Typkonformität schon gegeben wäre) eine Filterfunktion: Es sind nur Objekte von solchen Typen Variablen zuweisbar, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorgesehen hat. Auf diese Filterfunktion werden wir später im Zusammenhang mit sogenannten Tagging oder Marker Interfaces (in Kurseinheit 4, Kapitel 45) noch zurückkommen.
Da die Typkonformität bei Nennung des Typs, von dem ein neuer per Erweiterung abgeleitet wird, automatisch gegeben ist (und so keine aufwendigen, fallweisen Konformitätstests durchgeführt werden müssen), setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität. Interessanterweise wurde STRONGTALK, das ursprünglich ein auf struktureller Konformität beruhendes Typsystem (inkl. Type branding) hatte, inzwischen auf nominale Typkonformität umgestellt. Als Begründung wurde angeführt, dass ein strukturelles Typsystem, insbesondere eines, bei dem Typen nicht explizit benannt werden, es der Programmiererin nicht erlaubt, ihre Absicht (intendierte Semantik, die obengenannte Filterfunktion) auszudrücken, was Programme schwerer zu lesen und zu debuggen macht, und dass die Fehlermeldungen, die eine strukturelle Typprüfung produziert, sich oft nicht auf die eigentliche Fehlerquelle beziehen und sehr schwer zu verstehen sind [STRONGTALK 2.0].
Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.","<answer> Nominale Typkonformität bietet die Vorteile der Zuweisungskompatibilität und Abwesenheit von Typfehlern. Sie dient auch als Filterfunktion, da nur Objekte von solchen Typen Variablen zugewiesen werden können, für die die Programmiererin dies aus semantischen Überlegungen heraus ausdrücklich vorgesehen hat. <answer> <question> Welche Vorteile bietet nominale Typkonformität gegenüber struktureller Typkonformität? <question>"
"Einen Typ, dessen Definition alle deklarierten Elemente der Definition eines anderen Typen enthält, nennt man mit dem anderen typkonform. So ist InternationalesBüro im obigen Beispiel mit Büro typkonform. Typkonformität ist in vielen Sprachen eine notwendige und hinreichende Voraussetzung für die Zuweisungskompatibilität: Es darf dann ein Objekt vom Typ InternationalesBüro einer Variable vom Typ Büro zugewiesen werden.
Typkonformität ist aber reflexiv, d.h., jeder Typ ist konform zu sich selbst. Sie ist weiterhin transitiv: Wenn A typkonform zu B ist und B typkonform zu C, dann ist auch A typkonform zu C. Wie man sich leicht denken kann, ist die Typkonformität jedoch im Gegensatz zur Typäquivalenz nicht symmetrisch: Aus der Tatsache, dass ein Typ B typkonform zu einem Typ A ist, folgt nicht, dass auch A typkonform zu B ist. Vielmehr ist dies mit einer kleinen Ausnahme sogar zwingend nicht der Fall: Typkonformität ist meistens antisymmetrisch, was bedeutet, dass wenn B zu A und A zu B typkonform ist, dann müssen A und B identisch sein.
Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.
Für die nominale Konformität muss zusätzlich und explizit die Erweiterung eines (oder Ableitung von einem) anderen Typ angegeben werden: die Definition von InternationalesBüro aus Kapitel 23 ist also mit Büro nicht nur strukturell, sondern auch nominal konform. Da bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben, folgt die Konformität aus der Erweiterung.
Nun ist die Teilmengenbeziehung reflexiv, was auf die Typerweiterung übertragen bedeutet, dass ein Typ eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.
Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.
Genau wie bei der Typäquivalenz hat die nominale Typkonformität zusätzlich zur Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von Typfehlern (die ja auch bei einer strukturellen Typkonformität schon gegeben wäre) eine Filterfunktion: Es sind nur Objekte von solchen Typen Variablen zuweisbar, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorgesehen hat. Auf diese Filterfunktion werden wir später im Zusammenhang mit sogenannten Tagging oder Marker Interfaces (in Kurseinheit 4, Kapitel 45) noch zurückkommen.
Da die Typkonformität bei Nennung des Typs, von dem ein neuer per Erweiterung abgeleitet wird, automatisch gegeben ist (und so keine aufwendigen, fallweisen Konformitätstests durchgeführt werden müssen), setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität. Interessanterweise wurde STRONGTALK, das ursprünglich ein auf struktureller Konformität beruhendes Typsystem (inkl. Type branding) hatte, inzwischen auf nominale Typkonformität umgestellt. Als Begründung wurde angeführt, dass ein strukturelles Typsystem, insbesondere eines, bei dem Typen nicht explizit benannt werden, es der Programmiererin nicht erlaubt, ihre Absicht (intendierte Semantik, die obengenannte Filterfunktion) auszudrücken, was Programme schwerer zu lesen und zu debuggen macht, und dass die Fehlermeldungen, die eine strukturelle Typprüfung produziert, sich oft nicht auf die eigentliche Fehlerquelle beziehen und sehr schwer zu verstehen sind [STRONGTALK 2.0].
Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.","<answer> Die meisten Programmiersprachen setzen auf nominale Typkonformität, da sie automatisch gegeben ist, wenn der Typ, von dem ein neuer per Erweiterung abgeleitet wird, genannt wird. Dies vermeidet aufwendige, fallweise Konformitätstests. Strukturelle Typsysteme, insbesondere solche ohne explizite Benennung von Typen, erschweren die Ausdrücklichkeit der Programmiererin bei der Definition ihrer Absicht (intendierte Semantik) und können Programme schwerer lesbar und debugbar machen. Fehlermeldungen aus strukturellen Typprüfungen sind oft schwer zu verstehen und beziehen sich nicht immer auf die eigentliche Fehlerquelle. <answer> <question> Warum setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität? <question>"
"Ähnlich wie in SMALLTALK erlaubt auch JAVA das Programmieren von parallelen Ausführungssträngen. Diese werden in JAVA jedoch als Threads und nicht als Prozesse bezeichnet. Threads sind im Gegensatz zu den Prozessen eines Betriebssystems leichtgewichtig, was bedeutet, dass Threads keine separate Allokation von Ressourcen wie Hauptspeicher erfordern und alle auf denselben Ressourcen arbeiten. Daher können mehrere Threads innerhalb eines Prozesses ausgeführt werden. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst implementiert werden müssen, während sie bei Prozessen über die Inter-Prozess-Kommunikation des Betriebssystems geregelt sind. (Bei den ""Prozessen"" in SMALLTALK handelt es sich also eher um Threads als um Prozesse im oben beschriebenen Sinn.)
In JAVA wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.
Die Frage ist nun, was dieser Thread tun soll. Die Klasse Thread enthält eine Methode namens run(), die von start() aufgerufen wird. Diese Methode ist jedoch standardmäßig leer, sodass der Thread sofort beendet wird. Um sicherzustellen, dass ein neuer Thread sinnvolle Aufgaben ausführt, gibt es zwei Möglichkeiten: Man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen oder zumindest anzustoßen. Man lässt eine Klasse das Interface Runnable implementieren, implementiert dann in der Klasse die vom Interface geforderte Methode run(), erzeugt eine Instanz dieser Klasse und startet deren Methode run() mit (new Thread(i)).start(), wobei i die Instanz darstellt.
Auch im zweiten Fall wird eine Instanz der Klasse Thread erzeugt, die den neuen Thread repräsentiert. Es ist jedoch wichtig zu beachten, dass diese Instanz nicht selbst der Thread ist. Der Thread ist, wie bereits erwähnt, ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Aktive Objekte, die ihren eigenen Ausführungsstrang haben und behalten (wie im Kapitel 16 beschrieben), müssen in JAVA genauso wie in SMALLTALK simuliert werden. Jeder Thread hat jedoch ein Thread-Objekt, das ihn repräsentiert und spezifische Daten wie den Namen des Threads und seine Priorität speichert. Dieses Objekt kann mit Thread.currentThread() abgefragt werden.
Die Threads in JAVA erfordern daher eine explizite Synchronisation. Ähnlich wie bei den Prozessen in SMALLTALK funktioniert dies mit Semaphoren, die in JAVA als Monitore bezeichnet werden. Jeder Monitor ist mit einem Objekt verknüpft (und jedes Objekt mit einem Monitor). Wenn ein Thread einen Monitor eines Objekts sperrt (""lockt""), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.
Es gibt zwei Möglichkeiten, die Synchronisation von Threads zu erzwingen. Die erste Möglichkeit erfolgt durch die Verwendung der synchronized-Anweisung, die Sie bereits kurz kennengelernt haben. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden. Häufig ist dies das Schlüsselwort this, das auf das Objekt im Kontext des Blocks verweist.
Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren. Wenn es sich um eine Instanzmethode handelt, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird. Wenn es sich um eine Klassenmethode (also eine static deklarierte Methode) handelt, wird die Sperre auf das Objekt angewendet, das die Klasse repräsentiert. Beachten Sie jedoch, dass Felder nicht als synchronized deklariert werden können.","<answer> Threads in JAVA sind parallele Ausführungsstränge, während Prozesse in der Regel eigenständige Programme mit separater Ressourcenallokation sind. Threads sind leichtgewichtiger und teilen sich Ressourcen innerhalb eines Prozesses. Bei Threads müssen die Synchronisationsmechanismen selbst implementiert werden, während Prozesse in Betriebssystemen über die Inter-Prozess-Kommunikation reguliert werden. <answer> <question> Was sind Threads in JAVA und wie unterscheiden sie sich von Prozessen? <question>"
"Ähnlich wie in SMALLTALK erlaubt auch JAVA das Programmieren von parallelen Ausführungssträngen. Diese werden in JAVA jedoch als Threads und nicht als Prozesse bezeichnet. Threads sind im Gegensatz zu den Prozessen eines Betriebssystems leichtgewichtig, was bedeutet, dass Threads keine separate Allokation von Ressourcen wie Hauptspeicher erfordern und alle auf denselben Ressourcen arbeiten. Daher können mehrere Threads innerhalb eines Prozesses ausgeführt werden. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst implementiert werden müssen, während sie bei Prozessen über die Inter-Prozess-Kommunikation des Betriebssystems geregelt sind. (Bei den ""Prozessen"" in SMALLTALK handelt es sich also eher um Threads als um Prozesse im oben beschriebenen Sinn.)
In JAVA wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.
Die Frage ist nun, was dieser Thread tun soll. Die Klasse Thread enthält eine Methode namens run(), die von start() aufgerufen wird. Diese Methode ist jedoch standardmäßig leer, sodass der Thread sofort beendet wird. Um sicherzustellen, dass ein neuer Thread sinnvolle Aufgaben ausführt, gibt es zwei Möglichkeiten: Man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen oder zumindest anzustoßen. Man lässt eine Klasse das Interface Runnable implementieren, implementiert dann in der Klasse die vom Interface geforderte Methode run(), erzeugt eine Instanz dieser Klasse und startet deren Methode run() mit (new Thread(i)).start(), wobei i die Instanz darstellt.
Auch im zweiten Fall wird eine Instanz der Klasse Thread erzeugt, die den neuen Thread repräsentiert. Es ist jedoch wichtig zu beachten, dass diese Instanz nicht selbst der Thread ist. Der Thread ist, wie bereits erwähnt, ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Aktive Objekte, die ihren eigenen Ausführungsstrang haben und behalten (wie im Kapitel 16 beschrieben), müssen in JAVA genauso wie in SMALLTALK simuliert werden. Jeder Thread hat jedoch ein Thread-Objekt, das ihn repräsentiert und spezifische Daten wie den Namen des Threads und seine Priorität speichert. Dieses Objekt kann mit Thread.currentThread() abgefragt werden.
Die Threads in JAVA erfordern daher eine explizite Synchronisation. Ähnlich wie bei den Prozessen in SMALLTALK funktioniert dies mit Semaphoren, die in JAVA als Monitore bezeichnet werden. Jeder Monitor ist mit einem Objekt verknüpft (und jedes Objekt mit einem Monitor). Wenn ein Thread einen Monitor eines Objekts sperrt (""lockt""), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.
Es gibt zwei Möglichkeiten, die Synchronisation von Threads zu erzwingen. Die erste Möglichkeit erfolgt durch die Verwendung der synchronized-Anweisung, die Sie bereits kurz kennengelernt haben. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden. Häufig ist dies das Schlüsselwort this, das auf das Objekt im Kontext des Blocks verweist.
Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren. Wenn es sich um eine Instanzmethode handelt, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird. Wenn es sich um eine Klassenmethode (also eine static deklarierte Methode) handelt, wird die Sperre auf das Objekt angewendet, das die Klasse repräsentiert. Beachten Sie jedoch, dass Felder nicht als synchronized deklariert werden können.","<answer> Einen neuen Thread in JAVA startet man, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft. <answer> <question> Wie startet man einen neuen Thread in JAVA? <question>"
"Ähnlich wie in SMALLTALK erlaubt auch JAVA das Programmieren von parallelen Ausführungssträngen. Diese werden in JAVA jedoch als Threads und nicht als Prozesse bezeichnet. Threads sind im Gegensatz zu den Prozessen eines Betriebssystems leichtgewichtig, was bedeutet, dass Threads keine separate Allokation von Ressourcen wie Hauptspeicher erfordern und alle auf denselben Ressourcen arbeiten. Daher können mehrere Threads innerhalb eines Prozesses ausgeführt werden. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst implementiert werden müssen, während sie bei Prozessen über die Inter-Prozess-Kommunikation des Betriebssystems geregelt sind. (Bei den ""Prozessen"" in SMALLTALK handelt es sich also eher um Threads als um Prozesse im oben beschriebenen Sinn.)
In JAVA wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.
Die Frage ist nun, was dieser Thread tun soll. Die Klasse Thread enthält eine Methode namens run(), die von start() aufgerufen wird. Diese Methode ist jedoch standardmäßig leer, sodass der Thread sofort beendet wird. Um sicherzustellen, dass ein neuer Thread sinnvolle Aufgaben ausführt, gibt es zwei Möglichkeiten: Man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen oder zumindest anzustoßen. Man lässt eine Klasse das Interface Runnable implementieren, implementiert dann in der Klasse die vom Interface geforderte Methode run(), erzeugt eine Instanz dieser Klasse und startet deren Methode run() mit (new Thread(i)).start(), wobei i die Instanz darstellt.
Auch im zweiten Fall wird eine Instanz der Klasse Thread erzeugt, die den neuen Thread repräsentiert. Es ist jedoch wichtig zu beachten, dass diese Instanz nicht selbst der Thread ist. Der Thread ist, wie bereits erwähnt, ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Aktive Objekte, die ihren eigenen Ausführungsstrang haben und behalten (wie im Kapitel 16 beschrieben), müssen in JAVA genauso wie in SMALLTALK simuliert werden. Jeder Thread hat jedoch ein Thread-Objekt, das ihn repräsentiert und spezifische Daten wie den Namen des Threads und seine Priorität speichert. Dieses Objekt kann mit Thread.currentThread() abgefragt werden.
Die Threads in JAVA erfordern daher eine explizite Synchronisation. Ähnlich wie bei den Prozessen in SMALLTALK funktioniert dies mit Semaphoren, die in JAVA als Monitore bezeichnet werden. Jeder Monitor ist mit einem Objekt verknüpft (und jedes Objekt mit einem Monitor). Wenn ein Thread einen Monitor eines Objekts sperrt (""lockt""), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.
Es gibt zwei Möglichkeiten, die Synchronisation von Threads zu erzwingen. Die erste Möglichkeit erfolgt durch die Verwendung der synchronized-Anweisung, die Sie bereits kurz kennengelernt haben. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden. Häufig ist dies das Schlüsselwort this, das auf das Objekt im Kontext des Blocks verweist.
Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren. Wenn es sich um eine Instanzmethode handelt, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird. Wenn es sich um eine Klassenmethode (also eine static deklarierte Methode) handelt, wird die Sperre auf das Objekt angewendet, das die Klasse repräsentiert. Beachten Sie jedoch, dass Felder nicht als synchronized deklariert werden können.","<answer> Standardmäßig führt ein Thread in JAVA keine spezifischen Aufgaben aus und endet sofort. Dies geschieht, weil die Methode run() in der Klasse Thread standardmäßig leer ist. <answer> <question> Was passiert standardmäßig, wenn man einen neuen Thread in JAVA startet? <question>"
"Ähnlich wie in SMALLTALK erlaubt auch JAVA das Programmieren von parallelen Ausführungssträngen. Diese werden in JAVA jedoch als Threads und nicht als Prozesse bezeichnet. Threads sind im Gegensatz zu den Prozessen eines Betriebssystems leichtgewichtig, was bedeutet, dass Threads keine separate Allokation von Ressourcen wie Hauptspeicher erfordern und alle auf denselben Ressourcen arbeiten. Daher können mehrere Threads innerhalb eines Prozesses ausgeführt werden. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst implementiert werden müssen, während sie bei Prozessen über die Inter-Prozess-Kommunikation des Betriebssystems geregelt sind. (Bei den ""Prozessen"" in SMALLTALK handelt es sich also eher um Threads als um Prozesse im oben beschriebenen Sinn.)
In JAVA wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.
Die Frage ist nun, was dieser Thread tun soll. Die Klasse Thread enthält eine Methode namens run(), die von start() aufgerufen wird. Diese Methode ist jedoch standardmäßig leer, sodass der Thread sofort beendet wird. Um sicherzustellen, dass ein neuer Thread sinnvolle Aufgaben ausführt, gibt es zwei Möglichkeiten: Man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen oder zumindest anzustoßen. Man lässt eine Klasse das Interface Runnable implementieren, implementiert dann in der Klasse die vom Interface geforderte Methode run(), erzeugt eine Instanz dieser Klasse und startet deren Methode run() mit (new Thread(i)).start(), wobei i die Instanz darstellt.
Auch im zweiten Fall wird eine Instanz der Klasse Thread erzeugt, die den neuen Thread repräsentiert. Es ist jedoch wichtig zu beachten, dass diese Instanz nicht selbst der Thread ist. Der Thread ist, wie bereits erwähnt, ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Aktive Objekte, die ihren eigenen Ausführungsstrang haben und behalten (wie im Kapitel 16 beschrieben), müssen in JAVA genauso wie in SMALLTALK simuliert werden. Jeder Thread hat jedoch ein Thread-Objekt, das ihn repräsentiert und spezifische Daten wie den Namen des Threads und seine Priorität speichert. Dieses Objekt kann mit Thread.currentThread() abgefragt werden.
Die Threads in JAVA erfordern daher eine explizite Synchronisation. Ähnlich wie bei den Prozessen in SMALLTALK funktioniert dies mit Semaphoren, die in JAVA als Monitore bezeichnet werden. Jeder Monitor ist mit einem Objekt verknüpft (und jedes Objekt mit einem Monitor). Wenn ein Thread einen Monitor eines Objekts sperrt (""lockt""), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.
Es gibt zwei Möglichkeiten, die Synchronisation von Threads zu erzwingen. Die erste Möglichkeit erfolgt durch die Verwendung der synchronized-Anweisung, die Sie bereits kurz kennengelernt haben. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden. Häufig ist dies das Schlüsselwort this, das auf das Objekt im Kontext des Blocks verweist.
Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren. Wenn es sich um eine Instanzmethode handelt, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird. Wenn es sich um eine Klassenmethode (also eine static deklarierte Methode) handelt, wird die Sperre auf das Objekt angewendet, das die Klasse repräsentiert. Beachten Sie jedoch, dass Felder nicht als synchronized deklariert werden können.","<answer> Es gibt zwei Möglichkeiten, sicherzustellen, dass ein neuer Thread in JAVA sinnvolle Aufgaben ausführt. Entweder man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen, oder man lässt eine Klasse das Interface Runnable implementieren und implementiert die Methode run() in dieser Klasse. Dann erzeugt man eine Instanz dieser Klasse und startet deren Methode run(). <answer> <question> Wie stellt man sicher, dass ein neuer Thread in JAVA sinnvolle Aufgaben ausführt? <question>"
"Ähnlich wie in SMALLTALK erlaubt auch JAVA das Programmieren von parallelen Ausführungssträngen. Diese werden in JAVA jedoch als Threads und nicht als Prozesse bezeichnet. Threads sind im Gegensatz zu den Prozessen eines Betriebssystems leichtgewichtig, was bedeutet, dass Threads keine separate Allokation von Ressourcen wie Hauptspeicher erfordern und alle auf denselben Ressourcen arbeiten. Daher können mehrere Threads innerhalb eines Prozesses ausgeführt werden. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst implementiert werden müssen, während sie bei Prozessen über die Inter-Prozess-Kommunikation des Betriebssystems geregelt sind. (Bei den ""Prozessen"" in SMALLTALK handelt es sich also eher um Threads als um Prozesse im oben beschriebenen Sinn.)
In JAVA wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.
Die Frage ist nun, was dieser Thread tun soll. Die Klasse Thread enthält eine Methode namens run(), die von start() aufgerufen wird. Diese Methode ist jedoch standardmäßig leer, sodass der Thread sofort beendet wird. Um sicherzustellen, dass ein neuer Thread sinnvolle Aufgaben ausführt, gibt es zwei Möglichkeiten: Man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen oder zumindest anzustoßen. Man lässt eine Klasse das Interface Runnable implementieren, implementiert dann in der Klasse die vom Interface geforderte Methode run(), erzeugt eine Instanz dieser Klasse und startet deren Methode run() mit (new Thread(i)).start(), wobei i die Instanz darstellt.
Auch im zweiten Fall wird eine Instanz der Klasse Thread erzeugt, die den neuen Thread repräsentiert. Es ist jedoch wichtig zu beachten, dass diese Instanz nicht selbst der Thread ist. Der Thread ist, wie bereits erwähnt, ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Aktive Objekte, die ihren eigenen Ausführungsstrang haben und behalten (wie im Kapitel 16 beschrieben), müssen in JAVA genauso wie in SMALLTALK simuliert werden. Jeder Thread hat jedoch ein Thread-Objekt, das ihn repräsentiert und spezifische Daten wie den Namen des Threads und seine Priorität speichert. Dieses Objekt kann mit Thread.currentThread() abgefragt werden.
Die Threads in JAVA erfordern daher eine explizite Synchronisation. Ähnlich wie bei den Prozessen in SMALLTALK funktioniert dies mit Semaphoren, die in JAVA als Monitore bezeichnet werden. Jeder Monitor ist mit einem Objekt verknüpft (und jedes Objekt mit einem Monitor). Wenn ein Thread einen Monitor eines Objekts sperrt (""lockt""), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.
Es gibt zwei Möglichkeiten, die Synchronisation von Threads zu erzwingen. Die erste Möglichkeit erfolgt durch die Verwendung der synchronized-Anweisung, die Sie bereits kurz kennengelernt haben. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden. Häufig ist dies das Schlüsselwort this, das auf das Objekt im Kontext des Blocks verweist.
Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren. Wenn es sich um eine Instanzmethode handelt, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird. Wenn es sich um eine Klassenmethode (also eine static deklarierte Methode) handelt, wird die Sperre auf das Objekt angewendet, das die Klasse repräsentiert. Beachten Sie jedoch, dass Felder nicht als synchronized deklariert werden können.","<answer> Ein Monitor in Bezug auf Threads in JAVA ist ein Mechanismus, der dazu dient, die Synchronisation von Threads zu ermöglichen. Jedes Objekt in JAVA ist mit einem Monitor verknüpft. Wenn ein Thread einen Monitor eines Objekts sperrt (""lockt""), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird. <answer> <question> Was ist ein Monitor in Bezug auf Threads in JAVA? <question>"
"Ähnlich wie in SMALLTALK erlaubt auch JAVA das Programmieren von parallelen Ausführungssträngen. Diese werden in JAVA jedoch als Threads und nicht als Prozesse bezeichnet. Threads sind im Gegensatz zu den Prozessen eines Betriebssystems leichtgewichtig, was bedeutet, dass Threads keine separate Allokation von Ressourcen wie Hauptspeicher erfordern und alle auf denselben Ressourcen arbeiten. Daher können mehrere Threads innerhalb eines Prozesses ausgeführt werden. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst implementiert werden müssen, während sie bei Prozessen über die Inter-Prozess-Kommunikation des Betriebssystems geregelt sind. (Bei den ""Prozessen"" in SMALLTALK handelt es sich also eher um Threads als um Prozesse im oben beschriebenen Sinn.)
In JAVA wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.
Die Frage ist nun, was dieser Thread tun soll. Die Klasse Thread enthält eine Methode namens run(), die von start() aufgerufen wird. Diese Methode ist jedoch standardmäßig leer, sodass der Thread sofort beendet wird. Um sicherzustellen, dass ein neuer Thread sinnvolle Aufgaben ausführt, gibt es zwei Möglichkeiten: Man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen oder zumindest anzustoßen. Man lässt eine Klasse das Interface Runnable implementieren, implementiert dann in der Klasse die vom Interface geforderte Methode run(), erzeugt eine Instanz dieser Klasse und startet deren Methode run() mit (new Thread(i)).start(), wobei i die Instanz darstellt.
Auch im zweiten Fall wird eine Instanz der Klasse Thread erzeugt, die den neuen Thread repräsentiert. Es ist jedoch wichtig zu beachten, dass diese Instanz nicht selbst der Thread ist. Der Thread ist, wie bereits erwähnt, ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Aktive Objekte, die ihren eigenen Ausführungsstrang haben und behalten (wie im Kapitel 16 beschrieben), müssen in JAVA genauso wie in SMALLTALK simuliert werden. Jeder Thread hat jedoch ein Thread-Objekt, das ihn repräsentiert und spezifische Daten wie den Namen des Threads und seine Priorität speichert. Dieses Objekt kann mit Thread.currentThread() abgefragt werden.
Die Threads in JAVA erfordern daher eine explizite Synchronisation. Ähnlich wie bei den Prozessen in SMALLTALK funktioniert dies mit Semaphoren, die in JAVA als Monitore bezeichnet werden. Jeder Monitor ist mit einem Objekt verknüpft (und jedes Objekt mit einem Monitor). Wenn ein Thread einen Monitor eines Objekts sperrt (""lockt""), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.
Es gibt zwei Möglichkeiten, die Synchronisation von Threads zu erzwingen. Die erste Möglichkeit erfolgt durch die Verwendung der synchronized-Anweisung, die Sie bereits kurz kennengelernt haben. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden. Häufig ist dies das Schlüsselwort this, das auf das Objekt im Kontext des Blocks verweist.
Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren. Wenn es sich um eine Instanzmethode handelt, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird. Wenn es sich um eine Klassenmethode (also eine static deklarierte Methode) handelt, wird die Sperre auf das Objekt angewendet, das die Klasse repräsentiert. Beachten Sie jedoch, dass Felder nicht als synchronized deklariert werden können.","<answer> Die Synchronisation von Threads in JAVA kann auf zwei Arten erzwungen werden. Die erste Möglichkeit ist die Verwendung der synchronized-Anweisung, um einen synchronisierten Block zu erstellen. Die Anweisungen innerhalb dieses Blocks können nur von einem Thread gleichzeitig ausgeführt werden. Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren, wodurch die Sperre auf das zugehörige Objekt angewendet wird. Es ist wichtig zu beachten, dass Felder nicht als synchronized deklariert werden können. <answer> <question> Wie kann die Synchronisation von Threads in JAVA erzwungen werden? <question>"
"Ein Modul ist eine Einheit von Programmelementen, die (bzw. deren Funktion) von außen (also z. B. von anderen Modulen) nur über die Schnittstelle des Moduls zugänglich sind. Damit behält ein Modul einen Teil seiner Implementierung für sich — es hütet quasi ein Implementationsgeheimnis. Der Teil, den es (über seine Schnittstelle) nach außen trägt, gilt gemeinhin als öffentlich. Die „Öffentlichkeit“ kann dabei durchaus beschränkt sein (siehe dazu auch Abschnitt 52.2 in Kurseinheit 5).
Ein wesentlicher Grund, zwischen öffentlichen und nicht öffentlichen — privaten — Teilen eines Moduls zu unterscheiden, ist, dass die Programmierer eines Moduls die Hoheit darüber behalten wollen, wie sie das Modul programmieren. Indem sie sich auf eine Schnittstelle festlegen und alles andere hinter der Schnittstelle verbergen, ist es ihnen möglich, jederzeit die verborgenen Teile zu ändern, ohne dass irgendjemand davon in Kenntnis gesetzt werden muss — weil die privaten Teile von außen unsichtbar sind, hängt auch niemand davon ab, und insofern ist auch niemand davon betroffen, wenn an einem Modul eine Änderung durchgeführt wird, die die Schnittstellen unberührt lässt.
In JAVA wurden bis Version 8 Module durch Klassen und Pakete (engl. packages) mehr oder weniger gut simuliert. Mit JAVA 9 wurde schließlich — nach langer Vorbereitungszeit — ein Modulbegriff eingeführt, der diesen Namen auch verdient.","<answer> Ein Modul ist eine Einheit von Programmelementen, deren Funktion von außen, z. B. von anderen Modulen, nur über die Schnittstelle des Moduls zugänglich ist. Die Schnittstelle definiert, welche Teile des Moduls öffentlich sichtbar sind. <answer> <question> Was ist ein Modul in der Programmierung und wie ist seine Schnittstelle definiert? <question>"
"Ein Modul ist eine Einheit von Programmelementen, die (bzw. deren Funktion) von außen (also z. B. von anderen Modulen) nur über die Schnittstelle des Moduls zugänglich sind. Damit behält ein Modul einen Teil seiner Implementierung für sich — es hütet quasi ein Implementationsgeheimnis. Der Teil, den es (über seine Schnittstelle) nach außen trägt, gilt gemeinhin als öffentlich. Die „Öffentlichkeit“ kann dabei durchaus beschränkt sein (siehe dazu auch Abschnitt 52.2 in Kurseinheit 5).
Ein wesentlicher Grund, zwischen öffentlichen und nicht öffentlichen — privaten — Teilen eines Moduls zu unterscheiden, ist, dass die Programmierer eines Moduls die Hoheit darüber behalten wollen, wie sie das Modul programmieren. Indem sie sich auf eine Schnittstelle festlegen und alles andere hinter der Schnittstelle verbergen, ist es ihnen möglich, jederzeit die verborgenen Teile zu ändern, ohne dass irgendjemand davon in Kenntnis gesetzt werden muss — weil die privaten Teile von außen unsichtbar sind, hängt auch niemand davon ab, und insofern ist auch niemand davon betroffen, wenn an einem Modul eine Änderung durchgeführt wird, die die Schnittstellen unberührt lässt.
In JAVA wurden bis Version 8 Module durch Klassen und Pakete (engl. packages) mehr oder weniger gut simuliert. Mit JAVA 9 wurde schließlich — nach langer Vorbereitungszeit — ein Modulbegriff eingeführt, der diesen Namen auch verdient.","<answer> Es ist wichtig, zwischen öffentlichen und privaten Teilen eines Moduls zu unterscheiden, damit die Programmierer die Kontrolle über die Implementierung des Moduls behalten können. Indem sie sich auf eine Schnittstelle festlegen und private Teile hinter der Schnittstelle verbergen, können sie Änderungen an den verborgenen Teilen vornehmen, ohne andere Benutzer des Moduls zu beeinträchtigen. <answer> <question> Warum ist es wichtig, zwischen öffentlichen und nicht öffentlichen (privaten) Teilen eines Moduls zu unterscheiden? <question>"
"Ein Modul ist eine Einheit von Programmelementen, die (bzw. deren Funktion) von außen (also z. B. von anderen Modulen) nur über die Schnittstelle des Moduls zugänglich sind. Damit behält ein Modul einen Teil seiner Implementierung für sich — es hütet quasi ein Implementationsgeheimnis. Der Teil, den es (über seine Schnittstelle) nach außen trägt, gilt gemeinhin als öffentlich. Die „Öffentlichkeit“ kann dabei durchaus beschränkt sein (siehe dazu auch Abschnitt 52.2 in Kurseinheit 5).
Ein wesentlicher Grund, zwischen öffentlichen und nicht öffentlichen — privaten — Teilen eines Moduls zu unterscheiden, ist, dass die Programmierer eines Moduls die Hoheit darüber behalten wollen, wie sie das Modul programmieren. Indem sie sich auf eine Schnittstelle festlegen und alles andere hinter der Schnittstelle verbergen, ist es ihnen möglich, jederzeit die verborgenen Teile zu ändern, ohne dass irgendjemand davon in Kenntnis gesetzt werden muss — weil die privaten Teile von außen unsichtbar sind, hängt auch niemand davon ab, und insofern ist auch niemand davon betroffen, wenn an einem Modul eine Änderung durchgeführt wird, die die Schnittstellen unberührt lässt.
In JAVA wurden bis Version 8 Module durch Klassen und Pakete (engl. packages) mehr oder weniger gut simuliert. Mit JAVA 9 wurde schließlich — nach langer Vorbereitungszeit — ein Modulbegriff eingeführt, der diesen Namen auch verdient.",<answer> In JAVA wurden Module bis zur Version 8 mehr oder weniger gut durch Klassen und Pakete simuliert. <answer> <question> Wie wurden Module in JAVA bis zur Version 8 simuliert? <question>
"Ein Modul ist eine Einheit von Programmelementen, die (bzw. deren Funktion) von außen (also z. B. von anderen Modulen) nur über die Schnittstelle des Moduls zugänglich sind. Damit behält ein Modul einen Teil seiner Implementierung für sich — es hütet quasi ein Implementationsgeheimnis. Der Teil, den es (über seine Schnittstelle) nach außen trägt, gilt gemeinhin als öffentlich. Die „Öffentlichkeit“ kann dabei durchaus beschränkt sein (siehe dazu auch Abschnitt 52.2 in Kurseinheit 5).
Ein wesentlicher Grund, zwischen öffentlichen und nicht öffentlichen — privaten — Teilen eines Moduls zu unterscheiden, ist, dass die Programmierer eines Moduls die Hoheit darüber behalten wollen, wie sie das Modul programmieren. Indem sie sich auf eine Schnittstelle festlegen und alles andere hinter der Schnittstelle verbergen, ist es ihnen möglich, jederzeit die verborgenen Teile zu ändern, ohne dass irgendjemand davon in Kenntnis gesetzt werden muss — weil die privaten Teile von außen unsichtbar sind, hängt auch niemand davon ab, und insofern ist auch niemand davon betroffen, wenn an einem Modul eine Änderung durchgeführt wird, die die Schnittstellen unberührt lässt.
In JAVA wurden bis Version 8 Module durch Klassen und Pakete (engl. packages) mehr oder weniger gut simuliert. Mit JAVA 9 wurde schließlich — nach langer Vorbereitungszeit — ein Modulbegriff eingeführt, der diesen Namen auch verdient.","<answer> Ein Modulbegriff, der den Namen verdient, wurde mit JAVA 9 eingeführt, nach langer Vorbereitungszeit. <answer> <question> Ab welcher Version von JAVA wurde ein Modulbegriff eingeführt, der diesen Namen verdient? <question>"
"EIFFEL besitzt ein einheitliches Typsystem (keine separaten Referenz- und Werttypen) und unterscheidet auch nicht (wie JAVA) zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden: Die Operation + auf Integern beispielsweise ist (wie in SMALLTALK) nichts weiter als eine syntaktische Variante einer Methode ""plus"" definiert in einer Klasse ""INTEGER"" mit gleichem Parametertyp (EIFFEL verwendet per Konvention für Klassen und Typen vollständige Großschreibung; allerdings ist EIFFEL — wie PASCAL — nicht case-sensitive). Die Einheitlichkeit des Typsystems von EIFFEL geht dabei über die von C# insofern hinaus, als es keine an bestimmte Typkonstruktoren gebundene Unterscheidung von Wert- und Referenztypen gibt; gleichzeitig unterscheidet es sich aber von SMALLTALK (das sich zumindest dem Anschein nach vollständig auf Referenztypen festgelegt hat) insofern, als es auch Werttypen zulässt. Mehr dazu gleich.
Zu den prominentesten Eigenschaften des Typsystems von EIFFEL zählen: Mehrfachvererbung. Generizität (genauer: beschränkter parametrischer Polymorphismus; siehe Abschnitt 29.4 in Kurseinheit 3). Das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden; siehe dazu auch Abschnitt 11.3 in Kurseinheit 1). Kovariante Redefinition, unterstützt durch sog. ""verankerte Typen"" (engl. ""anchored types""; so gut wie ein Alleinstellungsmerkmal von EIFFEL).
In gewisser Weise kann man das Unterdrücken von Methoden eines Typs in seinen Subtypen in EIFFEL als einen Spezialfall der kovarianten Redefinition ansehen, nämlich einen, in dem die Menge der möglichen Parameterobjekte auf die leere Menge eingeschränkt wird, so dass es keinen gültigen Aufruf gibt (vgl. Kapitel in Kurseinheit 3). Auch sind die Probleme, die kovariante Redefinition und Unterdrückung verursachen, ähnlich. Deshalb beschränken wir uns bei der Motivation (der Erklärung, warum EIFFEL über diese Eigenschaften verfügt), auf ein Beispiel für kovariante Redefinition.","<answer> Im Gegensatz zu JAVA besitzt EIFFEL ein einheitliches Typsystem, bei dem keine separaten Referenz- und Werttypen unterschieden werden. EIFFEL unterscheidet auch nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden. Alle Operationen, einschließlich derer auf eingebauten Typen wie Integern, werden als Methoden behandelt. <answer> <question> Welche Unterschiede gibt es im Typsystem von EIFFEL im Vergleich zu anderen Sprachen wie JAVA? <question>"
"EIFFEL besitzt ein einheitliches Typsystem (keine separaten Referenz- und Werttypen) und unterscheidet auch nicht (wie JAVA) zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden: Die Operation + auf Integern beispielsweise ist (wie in SMALLTALK) nichts weiter als eine syntaktische Variante einer Methode ""plus"" definiert in einer Klasse ""INTEGER"" mit gleichem Parametertyp (EIFFEL verwendet per Konvention für Klassen und Typen vollständige Großschreibung; allerdings ist EIFFEL — wie PASCAL — nicht case-sensitive). Die Einheitlichkeit des Typsystems von EIFFEL geht dabei über die von C# insofern hinaus, als es keine an bestimmte Typkonstruktoren gebundene Unterscheidung von Wert- und Referenztypen gibt; gleichzeitig unterscheidet es sich aber von SMALLTALK (das sich zumindest dem Anschein nach vollständig auf Referenztypen festgelegt hat) insofern, als es auch Werttypen zulässt. Mehr dazu gleich.
Zu den prominentesten Eigenschaften des Typsystems von EIFFEL zählen: Mehrfachvererbung. Generizität (genauer: beschränkter parametrischer Polymorphismus; siehe Abschnitt 29.4 in Kurseinheit 3). Das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden; siehe dazu auch Abschnitt 11.3 in Kurseinheit 1). Kovariante Redefinition, unterstützt durch sog. ""verankerte Typen"" (engl. ""anchored types""; so gut wie ein Alleinstellungsmerkmal von EIFFEL).
In gewisser Weise kann man das Unterdrücken von Methoden eines Typs in seinen Subtypen in EIFFEL als einen Spezialfall der kovarianten Redefinition ansehen, nämlich einen, in dem die Menge der möglichen Parameterobjekte auf die leere Menge eingeschränkt wird, so dass es keinen gültigen Aufruf gibt (vgl. Kapitel in Kurseinheit 3). Auch sind die Probleme, die kovariante Redefinition und Unterdrückung verursachen, ähnlich. Deshalb beschränken wir uns bei der Motivation (der Erklärung, warum EIFFEL über diese Eigenschaften verfügt), auf ein Beispiel für kovariante Redefinition.","<answer> Ein herausragendes Merkmal des Typsystems von EIFFEL ist die Unterstützung von Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden), sowie kovariante Redefinitionen, die durch ""verankerte Typen"" ermöglicht werden. <answer> <question> Was ist ein herausragendes Merkmal des Typsystems von EIFFEL? <question>"
"EIFFEL besitzt ein einheitliches Typsystem (keine separaten Referenz- und Werttypen) und unterscheidet auch nicht (wie JAVA) zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden: Die Operation + auf Integern beispielsweise ist (wie in SMALLTALK) nichts weiter als eine syntaktische Variante einer Methode ""plus"" definiert in einer Klasse ""INTEGER"" mit gleichem Parametertyp (EIFFEL verwendet per Konvention für Klassen und Typen vollständige Großschreibung; allerdings ist EIFFEL — wie PASCAL — nicht case-sensitive). Die Einheitlichkeit des Typsystems von EIFFEL geht dabei über die von C# insofern hinaus, als es keine an bestimmte Typkonstruktoren gebundene Unterscheidung von Wert- und Referenztypen gibt; gleichzeitig unterscheidet es sich aber von SMALLTALK (das sich zumindest dem Anschein nach vollständig auf Referenztypen festgelegt hat) insofern, als es auch Werttypen zulässt. Mehr dazu gleich.
Zu den prominentesten Eigenschaften des Typsystems von EIFFEL zählen: Mehrfachvererbung. Generizität (genauer: beschränkter parametrischer Polymorphismus; siehe Abschnitt 29.4 in Kurseinheit 3). Das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden; siehe dazu auch Abschnitt 11.3 in Kurseinheit 1). Kovariante Redefinition, unterstützt durch sog. ""verankerte Typen"" (engl. ""anchored types""; so gut wie ein Alleinstellungsmerkmal von EIFFEL).
In gewisser Weise kann man das Unterdrücken von Methoden eines Typs in seinen Subtypen in EIFFEL als einen Spezialfall der kovarianten Redefinition ansehen, nämlich einen, in dem die Menge der möglichen Parameterobjekte auf die leere Menge eingeschränkt wird, so dass es keinen gültigen Aufruf gibt (vgl. Kapitel in Kurseinheit 3). Auch sind die Probleme, die kovariante Redefinition und Unterdrückung verursachen, ähnlich. Deshalb beschränken wir uns bei der Motivation (der Erklärung, warum EIFFEL über diese Eigenschaften verfügt), auf ein Beispiel für kovariante Redefinition.","<answer> ""Verankerte Typen"" (engl. ""anchored types"") spielen im Kontext von kovarianten Redefinitionen in EIFFEL eine wichtige Rolle. Sie ermöglichen es, die Kovarianz bei der Redefinition von Methoden zu unterstützen und sind eine besondere Eigenschaft von EIFFEL. <answer> <question> Welche Bedeutung haben ""verankerte Typen"" im Kontext von kovarianten Redefinitionen in EIFFEL? <question>"
"EIFFEL besitzt ein einheitliches Typsystem (keine separaten Referenz- und Werttypen) und unterscheidet auch nicht (wie JAVA) zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden: Die Operation + auf Integern beispielsweise ist (wie in SMALLTALK) nichts weiter als eine syntaktische Variante einer Methode ""plus"" definiert in einer Klasse ""INTEGER"" mit gleichem Parametertyp (EIFFEL verwendet per Konvention für Klassen und Typen vollständige Großschreibung; allerdings ist EIFFEL — wie PASCAL — nicht case-sensitive). Die Einheitlichkeit des Typsystems von EIFFEL geht dabei über die von C# insofern hinaus, als es keine an bestimmte Typkonstruktoren gebundene Unterscheidung von Wert- und Referenztypen gibt; gleichzeitig unterscheidet es sich aber von SMALLTALK (das sich zumindest dem Anschein nach vollständig auf Referenztypen festgelegt hat) insofern, als es auch Werttypen zulässt. Mehr dazu gleich.
Zu den prominentesten Eigenschaften des Typsystems von EIFFEL zählen: Mehrfachvererbung. Generizität (genauer: beschränkter parametrischer Polymorphismus; siehe Abschnitt 29.4 in Kurseinheit 3). Das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden; siehe dazu auch Abschnitt 11.3 in Kurseinheit 1). Kovariante Redefinition, unterstützt durch sog. ""verankerte Typen"" (engl. ""anchored types""; so gut wie ein Alleinstellungsmerkmal von EIFFEL).
In gewisser Weise kann man das Unterdrücken von Methoden eines Typs in seinen Subtypen in EIFFEL als einen Spezialfall der kovarianten Redefinition ansehen, nämlich einen, in dem die Menge der möglichen Parameterobjekte auf die leere Menge eingeschränkt wird, so dass es keinen gültigen Aufruf gibt (vgl. Kapitel in Kurseinheit 3). Auch sind die Probleme, die kovariante Redefinition und Unterdrückung verursachen, ähnlich. Deshalb beschränken wir uns bei der Motivation (der Erklärung, warum EIFFEL über diese Eigenschaften verfügt), auf ein Beispiel für kovariante Redefinition.","<answer> Einige der prominenten Eigenschaften des Typsystems von EIFFEL sind Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen sowie die Unterstützung kovarianter Redefinitionen durch ""verankerte Typen"". <answer> <question> Was sind einige der Eigenschaften des Typsystems von EIFFEL? <question>"
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in JAVA (besser gesagt, in JAVA ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als JAVA).
BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.","<answer> EIFFEL erlaubt Mehrfachvererbung, was bedeutet, dass eine Klasse von mehreren anderen Klassen erben kann. <answer> <question> Welche Arten von Vererbung erlaubt EIFFEL? <question>"
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in JAVA (besser gesagt, in JAVA ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als JAVA).
BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.","<answer> In EIFFEL werden überschriebene Methoden als ""Redefinition"" bezeichnet. <answer> <question> Wie werden in EIFFEL überschriebene Methoden bezeichnet? <question>"
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in JAVA (besser gesagt, in JAVA ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als JAVA).
BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.","<answer> In EIFFEL wird das Schlüsselwort ""deferred"" anstelle von ""abstract"" für abstrakte Klassen verwendet. <answer> <question> Welches Schlüsselwort wird in EIFFEL für abstrakte Klassen verwendet? <question>"
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in JAVA (besser gesagt, in JAVA ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als JAVA).
BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.","<answer> In EIFFEL ist es nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. <answer> <question> Was ist in EIFFEL nicht erlaubt, was das Überladen von Methoden betrifft? <question>"
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in JAVA (besser gesagt, in JAVA ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als JAVA).
BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.","<answer> In EIFFEL ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben, solange diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen. Wenn die Methoden gleiche oder kovariant redefinierte Parameter haben, handelt es sich nicht um Überladung, sondern um Überschreibung. <answer> <question> Wie können in EIFFEL Methoden mit demselben Namen in verschiedenen Klassen behandelt werden? <question>"
"EIFFEL erlaubt Mehrfachvererbung und gestattet sowohl das Überschreiben (in EIFFEL als ""Redefinition"" bezeichnet) als auch das Löschen von Methoden. Auf der positiven Seite steht dabei, dass zu Beginn einer Klassendefinition deklariert werden muss, welche Methoden in der Klasse überschrieben werden (""welche 'Features redefiniert' werden""). Natürlich unterstützt EIFFEL auch abstrakte Klassen; das entsprechende Schlüsselwort lautet jedoch ""deferred"" anstelle von ""abstract"". Andernfalls ist alles ähnlich wie in JAVA (besser gesagt, in JAVA ist alles ähnlich wie in EIFFEL - EIFFEL ist etwa zehn Jahre älter als JAVA).
BERTRAND MEYER ist ein entschiedener Gegner des Überladens. In EIFFEL ist es daher nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt. Gleichwohl ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben - jedoch dürfen diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen, es sei denn, die Methoden haben gleiche oder kovariant redefinierte Parameter. In diesem Fall handelt es sich nicht um Überladung, sondern um Überschreibung (was jedoch durch eine ""Redefine""-Deklaration angezeigt werden muss). Es ist jedoch nicht immer möglich sicherzustellen, dass zwei Klassen, von denen Sie erben möchten, keine Methoden mit demselben Namen verwenden. Anstatt auf die Vererbung zu verzichten, ermöglicht es EIFFEL, geerbte Features umzubenennen. Hierzu gibt es eine ""Rename""-Klausel, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen. Es ist zu beachten, dass dies das dynamische Binden nicht beeinflusst: Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.","<answer> EIFFEL ermöglicht es, geerbte Features umzubenennen, indem eine ""Rename""-Klausel verwendet wird. Diese Klausel erlaubt es, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen, ohne das dynamische Binden zu beeinflussen. <answer> <question> Wie kann in EIFFEL sichergestellt werden, dass geerbte Features mit demselben Namen unterschiedlich benannt werden? <question>"
"Unabhängig davon, wie formal sie sind, sind Programmiersprachen Sprachen und ermöglichen es einer Autorin, sich auf eine persönliche Art und Weise auszudrücken. Die Ausdrucksweise bestimmt dabei nicht den Inhalt des Programms (seine Funktion), sondern seine Qualität. Zum Beispiel, wie effizient ein gegebenes Problem gelöst wird oder wie verständlich die Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat viel mit Schreibstil zu tun, aber auch andere Faktoren spielen in Stilfragen eine Rolle, wie Mode und Ästhetik (Eleganz).
Es hat zweifellos in den letzten Jahrzehnten einen Wandel in Stilfragen gegeben, weg von einem mathematisch prägnanten Stil hin zu einem prosaisch-verbosen Stil.
Es handelt sich dabei um ein PASCAL-Programm zur Lösung des Problems der stabilen Heirat. Ein bedeutender Anteil aller Variablen in Programmen trägt oft den Namen ""i"". In diesem Beispiel sind die Variablen jedoch als ""r"", ""m"", ""w"" usw. benannt. Das grundlegende Problem bleibt jedoch dasselbe: Man muss sich vertieft in das Programm und den dazugehörigen Text einarbeiten, um zu verstehen, wofür die Variablen stehen.
Heute ist es üblich, Bezeichner (Namen für Module, Typen, Variablen, Prozeduren und Funktionen) in einem Programm so zu wählen, dass Kommentare zur Bedeutung der jeweiligen Programmelemente unnötig sind, da die Bezeichner ihre Bedeutung bereits im Kontext ausdrücken. Es wird sogar argumentiert, dass ein gut geschriebenes objektorientiertes Programm keine Kommentare benötigt. Trotzdem gibt es Fälle, in denen eine Lösung, auch wenn sie in ihrer verständlichsten Form vorliegt, weniger elegant ist als eine raffinierte Variante, die nicht jedem sofort ersichtlich ist. In solchen Situationen ist die Versuchung groß, die geistreichere Lösung zu wählen und sie mit einem erklärenden Kommentar zu versehen, für diejenigen Leserinnen, die nicht sofort folgen können. Einige der berühmtesten Algorithmen sind nicht offensichtlich und haben ihren Autoren zu Ruhm verholfen.","<answer> Programmiersprachen ermöglichen es einer Autorin, sich auf eine persönliche Art und Weise auszudrücken. Die Qualität eines Programms wird nicht durch die Ausdrucksweise bestimmt, sondern durch Faktoren wie Effizienz und Verständlichkeit. Der Programmierstil, der sich ausdrückt, spielt eine entscheidende Rolle für die Verständlichkeit und Qualität eines Programms. Weitere Faktoren wie Mode und Ästhetik (Eleganz) können ebenfalls den Programmierstil beeinflussen. <answer> <question> Welche Faktoren beeinflussen den Programmierstil in der Softwareentwicklung? <question>"
"Unabhängig davon, wie formal sie sind, sind Programmiersprachen Sprachen und ermöglichen es einer Autorin, sich auf eine persönliche Art und Weise auszudrücken. Die Ausdrucksweise bestimmt dabei nicht den Inhalt des Programms (seine Funktion), sondern seine Qualität. Zum Beispiel, wie effizient ein gegebenes Problem gelöst wird oder wie verständlich die Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat viel mit Schreibstil zu tun, aber auch andere Faktoren spielen in Stilfragen eine Rolle, wie Mode und Ästhetik (Eleganz).
Es hat zweifellos in den letzten Jahrzehnten einen Wandel in Stilfragen gegeben, weg von einem mathematisch prägnanten Stil hin zu einem prosaisch-verbosen Stil.
Es handelt sich dabei um ein PASCAL-Programm zur Lösung des Problems der stabilen Heirat. Ein bedeutender Anteil aller Variablen in Programmen trägt oft den Namen ""i"". In diesem Beispiel sind die Variablen jedoch als ""r"", ""m"", ""w"" usw. benannt. Das grundlegende Problem bleibt jedoch dasselbe: Man muss sich vertieft in das Programm und den dazugehörigen Text einarbeiten, um zu verstehen, wofür die Variablen stehen.
Heute ist es üblich, Bezeichner (Namen für Module, Typen, Variablen, Prozeduren und Funktionen) in einem Programm so zu wählen, dass Kommentare zur Bedeutung der jeweiligen Programmelemente unnötig sind, da die Bezeichner ihre Bedeutung bereits im Kontext ausdrücken. Es wird sogar argumentiert, dass ein gut geschriebenes objektorientiertes Programm keine Kommentare benötigt. Trotzdem gibt es Fälle, in denen eine Lösung, auch wenn sie in ihrer verständlichsten Form vorliegt, weniger elegant ist als eine raffinierte Variante, die nicht jedem sofort ersichtlich ist. In solchen Situationen ist die Versuchung groß, die geistreichere Lösung zu wählen und sie mit einem erklärenden Kommentar zu versehen, für diejenigen Leserinnen, die nicht sofort folgen können. Einige der berühmtesten Algorithmen sind nicht offensichtlich und haben ihren Autoren zu Ruhm verholfen.","<answer> In den letzten Jahrzehnten gab es einen Wandel im Programmierstil weg von einem mathematisch prägnanten Stil hin zu einem prosaisch-verbosen Stil. Früher wurden oft kurze und kryptische Bezeichner für Variablen verwendet, während heute der Trend zu aussagekräftigen und selbstdokumentierenden Bezeichnern geht. Ein Beispiel zeigt den Unterschied zwischen den beiden Stilen: Früher wurden Variablen oft als ""i"" bezeichnet, während heute aussagekräftigere Namen verwendet werden, die im Kontext ihre Bedeutung klar machen. <answer> <question> Wie hat sich der Programmierstil im Laufe der Zeit entwickelt? <question>"
"Unabhängig davon, wie formal sie sind, sind Programmiersprachen Sprachen und ermöglichen es einer Autorin, sich auf eine persönliche Art und Weise auszudrücken. Die Ausdrucksweise bestimmt dabei nicht den Inhalt des Programms (seine Funktion), sondern seine Qualität. Zum Beispiel, wie effizient ein gegebenes Problem gelöst wird oder wie verständlich die Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat viel mit Schreibstil zu tun, aber auch andere Faktoren spielen in Stilfragen eine Rolle, wie Mode und Ästhetik (Eleganz).
Es hat zweifellos in den letzten Jahrzehnten einen Wandel in Stilfragen gegeben, weg von einem mathematisch prägnanten Stil hin zu einem prosaisch-verbosen Stil.
Es handelt sich dabei um ein PASCAL-Programm zur Lösung des Problems der stabilen Heirat. Ein bedeutender Anteil aller Variablen in Programmen trägt oft den Namen ""i"". In diesem Beispiel sind die Variablen jedoch als ""r"", ""m"", ""w"" usw. benannt. Das grundlegende Problem bleibt jedoch dasselbe: Man muss sich vertieft in das Programm und den dazugehörigen Text einarbeiten, um zu verstehen, wofür die Variablen stehen.
Heute ist es üblich, Bezeichner (Namen für Module, Typen, Variablen, Prozeduren und Funktionen) in einem Programm so zu wählen, dass Kommentare zur Bedeutung der jeweiligen Programmelemente unnötig sind, da die Bezeichner ihre Bedeutung bereits im Kontext ausdrücken. Es wird sogar argumentiert, dass ein gut geschriebenes objektorientiertes Programm keine Kommentare benötigt. Trotzdem gibt es Fälle, in denen eine Lösung, auch wenn sie in ihrer verständlichsten Form vorliegt, weniger elegant ist als eine raffinierte Variante, die nicht jedem sofort ersichtlich ist. In solchen Situationen ist die Versuchung groß, die geistreichere Lösung zu wählen und sie mit einem erklärenden Kommentar zu versehen, für diejenigen Leserinnen, die nicht sofort folgen können. Einige der berühmtesten Algorithmen sind nicht offensichtlich und haben ihren Autoren zu Ruhm verholfen.","<answer> Die Verwendung von aussagekräftigen Bezeichnern in Programmen trägt zur Verständlichkeit des Codes bei. Gut gewählte Bezeichner drücken im Kontext ihre Bedeutung aus, sodass Kommentare zur Erklärung der Programmelemente oft unnötig werden. Dies erleichtert anderen Entwicklerinnen das Verständnis des Codes und erhöht die Lesbarkeit und Wartbarkeit des Programms. <answer> <question> Warum ist es wichtig, aussagekräftige Bezeichner in Programmen zu verwenden? <question>"
"Unabhängig davon, wie formal sie sind, sind Programmiersprachen Sprachen und ermöglichen es einer Autorin, sich auf eine persönliche Art und Weise auszudrücken. Die Ausdrucksweise bestimmt dabei nicht den Inhalt des Programms (seine Funktion), sondern seine Qualität. Zum Beispiel, wie effizient ein gegebenes Problem gelöst wird oder wie verständlich die Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat viel mit Schreibstil zu tun, aber auch andere Faktoren spielen in Stilfragen eine Rolle, wie Mode und Ästhetik (Eleganz).
Es hat zweifellos in den letzten Jahrzehnten einen Wandel in Stilfragen gegeben, weg von einem mathematisch prägnanten Stil hin zu einem prosaisch-verbosen Stil.
Es handelt sich dabei um ein PASCAL-Programm zur Lösung des Problems der stabilen Heirat. Ein bedeutender Anteil aller Variablen in Programmen trägt oft den Namen ""i"". In diesem Beispiel sind die Variablen jedoch als ""r"", ""m"", ""w"" usw. benannt. Das grundlegende Problem bleibt jedoch dasselbe: Man muss sich vertieft in das Programm und den dazugehörigen Text einarbeiten, um zu verstehen, wofür die Variablen stehen.
Heute ist es üblich, Bezeichner (Namen für Module, Typen, Variablen, Prozeduren und Funktionen) in einem Programm so zu wählen, dass Kommentare zur Bedeutung der jeweiligen Programmelemente unnötig sind, da die Bezeichner ihre Bedeutung bereits im Kontext ausdrücken. Es wird sogar argumentiert, dass ein gut geschriebenes objektorientiertes Programm keine Kommentare benötigt. Trotzdem gibt es Fälle, in denen eine Lösung, auch wenn sie in ihrer verständlichsten Form vorliegt, weniger elegant ist als eine raffinierte Variante, die nicht jedem sofort ersichtlich ist. In solchen Situationen ist die Versuchung groß, die geistreichere Lösung zu wählen und sie mit einem erklärenden Kommentar zu versehen, für diejenigen Leserinnen, die nicht sofort folgen können. Einige der berühmtesten Algorithmen sind nicht offensichtlich und haben ihren Autoren zu Ruhm verholfen.","<answer> In einigen Fällen könnte eine Lösung, auch wenn sie in ihrer verständlichsten Form vorliegt, weniger elegant sein als eine raffinierte Variante, die nicht jedem sofort ersichtlich ist. In solchen Situationen kann die Versuchung groß sein, die geistreichere Lösung zu wählen und sie mit einem erklärenden Kommentar zu versehen, um sicherzustellen, dass auch weniger erfahrene Entwicklerinnen den Code nachvollziehen können. Dies ermöglicht es, komplexe Algorithmen oder unkonventionelle Ansätze zu dokumentieren und zu erläutern. <answer> <question> Warum könnte es in einigen Fällen sinnvoll sein, eine geistreichere Lösung mit einem erklärenden Kommentar zu versehen? <question>"
"Getreu seinem Motto, alle Freiheit in die Hand der Programmiererin zu legen und ihr nicht mit einer gouvernantenhaften ""Du-kannst-das-bestimmt-nicht""-Attitüde zu begegnen, bietet C++ (im Gegensatz zu SMALLTALK, JAVA und C#) uneingeschränkte Mehrfachvererbung. Das kann aus verschiedenen Gründen sinnvoll erscheinen: Eine Klasse, die von mehreren vollständig abstrakten (also mit keinerlei Implementierung versehenen) Klassen erbt, implementiert damit faktisch mehrere Interfaces. Der einzige Nachteil ist, dass die Programmiererin nicht in Mitteln der Sprache ausdrücken kann, ob eine abstrakte Klasse die Funktion eines Interfaces oder die einer Generalisierung (von der man Implementierung erben kann; vgl. Abschnitt 9.1) haben soll – dazu sind dann schon Namenskonventionen notwendig. Nicht selten ergibt sich aus der Aufgabenstellung, dass eine Klasse Eigenschaften von mehreren anderen gebrauchen könnte. In Sprachen mit Einfachvererbung muss man sich dann für eine Klasse als Superklasse entscheiden und den Beitrag der anderen Klassen wiederholen, also erneut implementieren oder per Delegation bzw. Forwarding einbinden. Mehrfachvererbung erlaubt im Gegensatz dazu, sich alles zusammenzuerben, was man benötigt.
Da das Erben jedoch nicht selektiv (im Sinne, dass man sich aussuchen könnte, was man von einer Klasse erbt) erfolgt und das Löschen von geerbten Membern in C++ nicht möglich ist, fühlt man sich häufig bemüßigt, die Klassen, von denen man erbt, in viele kleine Teile aufzusplitten und nur die zu beerben, deren Eigenschaften man braucht, um sich von unnötigem Ballast freizuhalten. Mehrfachvererbung ist etwas, das sich Programmiererinnen gerne wünschen. Sie bringt jedoch einige praktische Probleme mit sich, unter anderem die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements (Feld oder Methode) erbt. Da die Klasse sich dann für eine der beiden Definitionen entscheiden muss, geht die der anderen verloren. Dies kann, insbesondere im Zusammenhang mit dynamischem Binden und offener Rekursion, zu unerwartetem Verhalten führen. Darüber hinaus führt die Mehrfachvererbung noch zu zahlreichen weiteren Problemen, die hier nicht weiter ausgeführt werden sollen.","<answer> C++ bietet uneingeschränkte Mehrfachvererbung, was bedeutet, dass eine Klasse von mehreren anderen Klassen erben kann. <answer> <question> Welche Art der Vererbung bietet C++ in Bezug auf Mehrfachvererbung? <question>"
"Getreu seinem Motto, alle Freiheit in die Hand der Programmiererin zu legen und ihr nicht mit einer gouvernantenhaften ""Du-kannst-das-bestimmt-nicht""-Attitüde zu begegnen, bietet C++ (im Gegensatz zu SMALLTALK, JAVA und C#) uneingeschränkte Mehrfachvererbung. Das kann aus verschiedenen Gründen sinnvoll erscheinen: Eine Klasse, die von mehreren vollständig abstrakten (also mit keinerlei Implementierung versehenen) Klassen erbt, implementiert damit faktisch mehrere Interfaces. Der einzige Nachteil ist, dass die Programmiererin nicht in Mitteln der Sprache ausdrücken kann, ob eine abstrakte Klasse die Funktion eines Interfaces oder die einer Generalisierung (von der man Implementierung erben kann; vgl. Abschnitt 9.1) haben soll – dazu sind dann schon Namenskonventionen notwendig. Nicht selten ergibt sich aus der Aufgabenstellung, dass eine Klasse Eigenschaften von mehreren anderen gebrauchen könnte. In Sprachen mit Einfachvererbung muss man sich dann für eine Klasse als Superklasse entscheiden und den Beitrag der anderen Klassen wiederholen, also erneut implementieren oder per Delegation bzw. Forwarding einbinden. Mehrfachvererbung erlaubt im Gegensatz dazu, sich alles zusammenzuerben, was man benötigt.
Da das Erben jedoch nicht selektiv (im Sinne, dass man sich aussuchen könnte, was man von einer Klasse erbt) erfolgt und das Löschen von geerbten Membern in C++ nicht möglich ist, fühlt man sich häufig bemüßigt, die Klassen, von denen man erbt, in viele kleine Teile aufzusplitten und nur die zu beerben, deren Eigenschaften man braucht, um sich von unnötigem Ballast freizuhalten. Mehrfachvererbung ist etwas, das sich Programmiererinnen gerne wünschen. Sie bringt jedoch einige praktische Probleme mit sich, unter anderem die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements (Feld oder Methode) erbt. Da die Klasse sich dann für eine der beiden Definitionen entscheiden muss, geht die der anderen verloren. Dies kann, insbesondere im Zusammenhang mit dynamischem Binden und offener Rekursion, zu unerwartetem Verhalten führen. Darüber hinaus führt die Mehrfachvererbung noch zu zahlreichen weiteren Problemen, die hier nicht weiter ausgeführt werden sollen.","<answer> Mehrfachvererbung kann aus verschiedenen Gründen sinnvoll sein: Eine Klasse kann von mehreren vollständig abstrakten Klassen erben und damit mehrere Interfaces implementieren. In Aufgabenstellungen, in denen eine Klasse Eigenschaften von mehreren anderen Klassen benötigt, erlaubt Mehrfachvererbung, alle benötigten Eigenschaften zu erben, anstatt sich für eine einzige Superklasse entscheiden zu müssen. <answer> <question> Warum kann Mehrfachvererbung in C++ sinnvoll sein? <question>"
"Getreu seinem Motto, alle Freiheit in die Hand der Programmiererin zu legen und ihr nicht mit einer gouvernantenhaften ""Du-kannst-das-bestimmt-nicht""-Attitüde zu begegnen, bietet C++ (im Gegensatz zu SMALLTALK, JAVA und C#) uneingeschränkte Mehrfachvererbung. Das kann aus verschiedenen Gründen sinnvoll erscheinen: Eine Klasse, die von mehreren vollständig abstrakten (also mit keinerlei Implementierung versehenen) Klassen erbt, implementiert damit faktisch mehrere Interfaces. Der einzige Nachteil ist, dass die Programmiererin nicht in Mitteln der Sprache ausdrücken kann, ob eine abstrakte Klasse die Funktion eines Interfaces oder die einer Generalisierung (von der man Implementierung erben kann; vgl. Abschnitt 9.1) haben soll – dazu sind dann schon Namenskonventionen notwendig. Nicht selten ergibt sich aus der Aufgabenstellung, dass eine Klasse Eigenschaften von mehreren anderen gebrauchen könnte. In Sprachen mit Einfachvererbung muss man sich dann für eine Klasse als Superklasse entscheiden und den Beitrag der anderen Klassen wiederholen, also erneut implementieren oder per Delegation bzw. Forwarding einbinden. Mehrfachvererbung erlaubt im Gegensatz dazu, sich alles zusammenzuerben, was man benötigt.
Da das Erben jedoch nicht selektiv (im Sinne, dass man sich aussuchen könnte, was man von einer Klasse erbt) erfolgt und das Löschen von geerbten Membern in C++ nicht möglich ist, fühlt man sich häufig bemüßigt, die Klassen, von denen man erbt, in viele kleine Teile aufzusplitten und nur die zu beerben, deren Eigenschaften man braucht, um sich von unnötigem Ballast freizuhalten. Mehrfachvererbung ist etwas, das sich Programmiererinnen gerne wünschen. Sie bringt jedoch einige praktische Probleme mit sich, unter anderem die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements (Feld oder Methode) erbt. Da die Klasse sich dann für eine der beiden Definitionen entscheiden muss, geht die der anderen verloren. Dies kann, insbesondere im Zusammenhang mit dynamischem Binden und offener Rekursion, zu unerwartetem Verhalten führen. Darüber hinaus führt die Mehrfachvererbung noch zu zahlreichen weiteren Problemen, die hier nicht weiter ausgeführt werden sollen.","<answer> Ein Nachteil der Mehrfachvererbung in C++ ist, dass das Erben nicht selektiv erfolgt, und das Löschen von geerbten Membern nicht möglich ist. Dies führt oft dazu, dass Klassen in viele kleine Teile aufgespalten werden, um unnötigen Ballast zu vermeiden. <answer> <question> Was ist ein Nachteil der Mehrfachvererbung in C++? <question>"
"Getreu seinem Motto, alle Freiheit in die Hand der Programmiererin zu legen und ihr nicht mit einer gouvernantenhaften ""Du-kannst-das-bestimmt-nicht""-Attitüde zu begegnen, bietet C++ (im Gegensatz zu SMALLTALK, JAVA und C#) uneingeschränkte Mehrfachvererbung. Das kann aus verschiedenen Gründen sinnvoll erscheinen: Eine Klasse, die von mehreren vollständig abstrakten (also mit keinerlei Implementierung versehenen) Klassen erbt, implementiert damit faktisch mehrere Interfaces. Der einzige Nachteil ist, dass die Programmiererin nicht in Mitteln der Sprache ausdrücken kann, ob eine abstrakte Klasse die Funktion eines Interfaces oder die einer Generalisierung (von der man Implementierung erben kann; vgl. Abschnitt 9.1) haben soll – dazu sind dann schon Namenskonventionen notwendig. Nicht selten ergibt sich aus der Aufgabenstellung, dass eine Klasse Eigenschaften von mehreren anderen gebrauchen könnte. In Sprachen mit Einfachvererbung muss man sich dann für eine Klasse als Superklasse entscheiden und den Beitrag der anderen Klassen wiederholen, also erneut implementieren oder per Delegation bzw. Forwarding einbinden. Mehrfachvererbung erlaubt im Gegensatz dazu, sich alles zusammenzuerben, was man benötigt.
Da das Erben jedoch nicht selektiv (im Sinne, dass man sich aussuchen könnte, was man von einer Klasse erbt) erfolgt und das Löschen von geerbten Membern in C++ nicht möglich ist, fühlt man sich häufig bemüßigt, die Klassen, von denen man erbt, in viele kleine Teile aufzusplitten und nur die zu beerben, deren Eigenschaften man braucht, um sich von unnötigem Ballast freizuhalten. Mehrfachvererbung ist etwas, das sich Programmiererinnen gerne wünschen. Sie bringt jedoch einige praktische Probleme mit sich, unter anderem die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements (Feld oder Methode) erbt. Da die Klasse sich dann für eine der beiden Definitionen entscheiden muss, geht die der anderen verloren. Dies kann, insbesondere im Zusammenhang mit dynamischem Binden und offener Rekursion, zu unerwartetem Verhalten führen. Darüber hinaus führt die Mehrfachvererbung noch zu zahlreichen weiteren Problemen, die hier nicht weiter ausgeführt werden sollen.","<answer> Wenn eine Klasse in C++ von mehreren anderen Klassen verschiedene Definitionen desselben Elements (z. B. eines Feldes oder einer Methode) erbt, muss die Klasse sich für eine der beiden Definitionen entscheiden, und die andere geht verloren. Dies kann zu unerwartetem Verhalten führen, insbesondere im Zusammenhang mit dynamischem Binden und offener Rekursion. <answer> <question> Welches Problem kann auftreten, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements erbt? <question>"
"Getreu seinem Motto, alle Freiheit in die Hand der Programmiererin zu legen und ihr nicht mit einer gouvernantenhaften ""Du-kannst-das-bestimmt-nicht""-Attitüde zu begegnen, bietet C++ (im Gegensatz zu SMALLTALK, JAVA und C#) uneingeschränkte Mehrfachvererbung. Das kann aus verschiedenen Gründen sinnvoll erscheinen: Eine Klasse, die von mehreren vollständig abstrakten (also mit keinerlei Implementierung versehenen) Klassen erbt, implementiert damit faktisch mehrere Interfaces. Der einzige Nachteil ist, dass die Programmiererin nicht in Mitteln der Sprache ausdrücken kann, ob eine abstrakte Klasse die Funktion eines Interfaces oder die einer Generalisierung (von der man Implementierung erben kann; vgl. Abschnitt 9.1) haben soll – dazu sind dann schon Namenskonventionen notwendig. Nicht selten ergibt sich aus der Aufgabenstellung, dass eine Klasse Eigenschaften von mehreren anderen gebrauchen könnte. In Sprachen mit Einfachvererbung muss man sich dann für eine Klasse als Superklasse entscheiden und den Beitrag der anderen Klassen wiederholen, also erneut implementieren oder per Delegation bzw. Forwarding einbinden. Mehrfachvererbung erlaubt im Gegensatz dazu, sich alles zusammenzuerben, was man benötigt.
Da das Erben jedoch nicht selektiv (im Sinne, dass man sich aussuchen könnte, was man von einer Klasse erbt) erfolgt und das Löschen von geerbten Membern in C++ nicht möglich ist, fühlt man sich häufig bemüßigt, die Klassen, von denen man erbt, in viele kleine Teile aufzusplitten und nur die zu beerben, deren Eigenschaften man braucht, um sich von unnötigem Ballast freizuhalten. Mehrfachvererbung ist etwas, das sich Programmiererinnen gerne wünschen. Sie bringt jedoch einige praktische Probleme mit sich, unter anderem die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements (Feld oder Methode) erbt. Da die Klasse sich dann für eine der beiden Definitionen entscheiden muss, geht die der anderen verloren. Dies kann, insbesondere im Zusammenhang mit dynamischem Binden und offener Rekursion, zu unerwartetem Verhalten führen. Darüber hinaus führt die Mehrfachvererbung noch zu zahlreichen weiteren Problemen, die hier nicht weiter ausgeführt werden sollen.","<answer> Die Mehrfachvererbung in C++ kann zu zahlreichen praktischen Problemen führen, darunter die Auswahl von geerbten Definitionen, Konflikte bei gleichen Elementen in verschiedenen Elternklassen und unerwartetes Verhalten im Zusammenhang mit dynamischem Binden. Weitere Probleme können auftreten, sind jedoch in diesem Abschnitt nicht näher erläutert. <answer> <question> Welche praktischen Probleme können sich aus der Mehrfachvererbung in C++ ergeben? <question>"
"Wenn Sie bereits in anderen Programmiersprachen wie z. B. PASCAL, C oder JAVA programmiert haben, kennen Sie sicherlich Schlüsselwörter wie if, else, for und while. Diese Schlüsselwörter repräsentieren Kontrollstrukturen, feste Bestandteile der Sprache, die dazu dienen, den Ablauf eines Programms durch die Programmiererin zu steuern. Es wurde bereits vor langer Zeit (im Rahmen der Diskussion zur sogenannten strukturierten Programmierung) festgelegt, dass jede Programmiersprache über die Kontrollstrukturen Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf verfügen sollte. Während die einfache Sequenz von Anweisungen während der Ausführung durch die lineare Reihenfolge der Anweisungen im Programmtext festgelegt ist, wurden für Abweichungen vom linearen Kontrollfluss, wie Verzweigungen, Wiederholungen und Aufrufe, spezielle Flusssteuerungskonstrukte entwickelt. Das Goto gehört übrigens nicht dazu; es wird seit dem Aufkommen der strukturierten Programmierung als unerwünscht angesehen.
In SMALLTALK wurden die durch die Syntax der Sprache vorgegebenen Kontrollstrukturen auf Sequenz und Aufruf, letzteres ausgedrückt durch das Versenden einer Nachricht an ein Objekt, beschränkt. Alle anderen Kontrollstrukturen müssen mithilfe der Sprache simuliert werden. Was anfangs wie eine erhebliche Einschränkung erscheinen mag, erweist sich in der Praxis als bedeutender Vorteil: Die Programmiererin kann nämlich selbst, wenn sie es wünscht, neue Kontrollstrukturen einführen.","<answer> In anderen Programmiersprachen wie PASCAL, C oder JAVA repräsentieren Schlüsselwörter wie if, else, for und while Kontrollstrukturen. In diesem Abschnitt in SMALLTALK wird auf diese Schlüsselwörter und die damit verbundenen Kontrollstrukturen Bezug genommen. <answer> <question> Welche Schlüsselwörter repräsentieren in anderen Programmiersprachen Kontrollstrukturen, und welche sind in diesem Abschnitt gemeint? <question>"
"Wenn Sie bereits in anderen Programmiersprachen wie z. B. PASCAL, C oder JAVA programmiert haben, kennen Sie sicherlich Schlüsselwörter wie if, else, for und while. Diese Schlüsselwörter repräsentieren Kontrollstrukturen, feste Bestandteile der Sprache, die dazu dienen, den Ablauf eines Programms durch die Programmiererin zu steuern. Es wurde bereits vor langer Zeit (im Rahmen der Diskussion zur sogenannten strukturierten Programmierung) festgelegt, dass jede Programmiersprache über die Kontrollstrukturen Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf verfügen sollte. Während die einfache Sequenz von Anweisungen während der Ausführung durch die lineare Reihenfolge der Anweisungen im Programmtext festgelegt ist, wurden für Abweichungen vom linearen Kontrollfluss, wie Verzweigungen, Wiederholungen und Aufrufe, spezielle Flusssteuerungskonstrukte entwickelt. Das Goto gehört übrigens nicht dazu; es wird seit dem Aufkommen der strukturierten Programmierung als unerwünscht angesehen.
In SMALLTALK wurden die durch die Syntax der Sprache vorgegebenen Kontrollstrukturen auf Sequenz und Aufruf, letzteres ausgedrückt durch das Versenden einer Nachricht an ein Objekt, beschränkt. Alle anderen Kontrollstrukturen müssen mithilfe der Sprache simuliert werden. Was anfangs wie eine erhebliche Einschränkung erscheinen mag, erweist sich in der Praxis als bedeutender Vorteil: Die Programmiererin kann nämlich selbst, wenn sie es wünscht, neue Kontrollstrukturen einführen.","<answer> Gemäß den Prinzipien der strukturierten Programmierung sollten in einer Programmiersprache die vier grundlegenden Kontrollstrukturen vorhanden sein: Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf. <answer> <question> Welche vier grundlegenden Kontrollstrukturen sollten in einer Programmiersprache vorhanden sein, gemäß den Prinzipien der strukturierten Programmierung? <question>"
"Wenn Sie bereits in anderen Programmiersprachen wie z. B. PASCAL, C oder JAVA programmiert haben, kennen Sie sicherlich Schlüsselwörter wie if, else, for und while. Diese Schlüsselwörter repräsentieren Kontrollstrukturen, feste Bestandteile der Sprache, die dazu dienen, den Ablauf eines Programms durch die Programmiererin zu steuern. Es wurde bereits vor langer Zeit (im Rahmen der Diskussion zur sogenannten strukturierten Programmierung) festgelegt, dass jede Programmiersprache über die Kontrollstrukturen Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf verfügen sollte. Während die einfache Sequenz von Anweisungen während der Ausführung durch die lineare Reihenfolge der Anweisungen im Programmtext festgelegt ist, wurden für Abweichungen vom linearen Kontrollfluss, wie Verzweigungen, Wiederholungen und Aufrufe, spezielle Flusssteuerungskonstrukte entwickelt. Das Goto gehört übrigens nicht dazu; es wird seit dem Aufkommen der strukturierten Programmierung als unerwünscht angesehen.
In SMALLTALK wurden die durch die Syntax der Sprache vorgegebenen Kontrollstrukturen auf Sequenz und Aufruf, letzteres ausgedrückt durch das Versenden einer Nachricht an ein Objekt, beschränkt. Alle anderen Kontrollstrukturen müssen mithilfe der Sprache simuliert werden. Was anfangs wie eine erhebliche Einschränkung erscheinen mag, erweist sich in der Praxis als bedeutender Vorteil: Die Programmiererin kann nämlich selbst, wenn sie es wünscht, neue Kontrollstrukturen einführen.","<answer> Das Goto wird in der strukturierten Programmierung als unerwünscht angesehen, weil es dazu neigt, den Programmfluss unübersichtlich und schwer nachvollziehbar zu machen. Es ermöglicht Sprünge im Code, die schwer zu verfolgen sind und zu fehleranfälligem Code führen können. Strukturierte Programmierung fördert klarere, besser verständliche und wartbarere Programme, indem sie auf Kontrollstrukturen setzt, die den Programmfluss auf eine geordnete und nachvollziehbare Weise steuern. <answer> <question> Warum wird das Goto in der strukturierten Programmierung als unerwünscht angesehen? <question>"
"Wenn Sie bereits in anderen Programmiersprachen wie z. B. PASCAL, C oder JAVA programmiert haben, kennen Sie sicherlich Schlüsselwörter wie if, else, for und while. Diese Schlüsselwörter repräsentieren Kontrollstrukturen, feste Bestandteile der Sprache, die dazu dienen, den Ablauf eines Programms durch die Programmiererin zu steuern. Es wurde bereits vor langer Zeit (im Rahmen der Diskussion zur sogenannten strukturierten Programmierung) festgelegt, dass jede Programmiersprache über die Kontrollstrukturen Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf verfügen sollte. Während die einfache Sequenz von Anweisungen während der Ausführung durch die lineare Reihenfolge der Anweisungen im Programmtext festgelegt ist, wurden für Abweichungen vom linearen Kontrollfluss, wie Verzweigungen, Wiederholungen und Aufrufe, spezielle Flusssteuerungskonstrukte entwickelt. Das Goto gehört übrigens nicht dazu; es wird seit dem Aufkommen der strukturierten Programmierung als unerwünscht angesehen.
In SMALLTALK wurden die durch die Syntax der Sprache vorgegebenen Kontrollstrukturen auf Sequenz und Aufruf, letzteres ausgedrückt durch das Versenden einer Nachricht an ein Objekt, beschränkt. Alle anderen Kontrollstrukturen müssen mithilfe der Sprache simuliert werden. Was anfangs wie eine erhebliche Einschränkung erscheinen mag, erweist sich in der Praxis als bedeutender Vorteil: Die Programmiererin kann nämlich selbst, wenn sie es wünscht, neue Kontrollstrukturen einführen.","<answer> In SMALLTALK sind von der Syntax her nur Sequenz und Aufruf als Kontrollstrukturen vorgegeben. Alle anderen Kontrollstrukturen, einschließlich Verzweigung und Wiederholung, müssen mithilfe der Sprache simuliert werden. <answer> <question> Welche Kontrollstrukturen sind in SMALLTALK von der Syntax her vorgegeben, und welche müssen mithilfe der Sprache simuliert werden? <question>"
"Wenn Sie bereits in anderen Programmiersprachen wie z. B. PASCAL, C oder JAVA programmiert haben, kennen Sie sicherlich Schlüsselwörter wie if, else, for und while. Diese Schlüsselwörter repräsentieren Kontrollstrukturen, feste Bestandteile der Sprache, die dazu dienen, den Ablauf eines Programms durch die Programmiererin zu steuern. Es wurde bereits vor langer Zeit (im Rahmen der Diskussion zur sogenannten strukturierten Programmierung) festgelegt, dass jede Programmiersprache über die Kontrollstrukturen Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf verfügen sollte. Während die einfache Sequenz von Anweisungen während der Ausführung durch die lineare Reihenfolge der Anweisungen im Programmtext festgelegt ist, wurden für Abweichungen vom linearen Kontrollfluss, wie Verzweigungen, Wiederholungen und Aufrufe, spezielle Flusssteuerungskonstrukte entwickelt. Das Goto gehört übrigens nicht dazu; es wird seit dem Aufkommen der strukturierten Programmierung als unerwünscht angesehen.
In SMALLTALK wurden die durch die Syntax der Sprache vorgegebenen Kontrollstrukturen auf Sequenz und Aufruf, letzteres ausgedrückt durch das Versenden einer Nachricht an ein Objekt, beschränkt. Alle anderen Kontrollstrukturen müssen mithilfe der Sprache simuliert werden. Was anfangs wie eine erhebliche Einschränkung erscheinen mag, erweist sich in der Praxis als bedeutender Vorteil: Die Programmiererin kann nämlich selbst, wenn sie es wünscht, neue Kontrollstrukturen einführen.","<answer> In SMALLTALK wird es als bedeutender Vorteil angesehen, dass Programmierer neue Kontrollstrukturen einführen können, weil dies die Sprache extrem flexibel macht. Programmierer haben die Freiheit, Kontrollstrukturen zu erstellen, die speziell auf ihre Anforderungen zugeschnitten sind, und auf diese Weise den Code besser organisieren und lesbarer gestalten können. Dies ermöglicht es, abstrakte Konzepte und spezifische Anwendungsfälle auf eine natürlichere Weise auszudrücken. <answer> <question> Warum wird es in SMALLTALK als bedeutender Vorteil angesehen, dass Programmierer neue Kontrollstrukturen einführen können? <question>"
"Auch wenn es in großen Teilen recht ähnlich aussieht, weicht das Typsystem von C# in mehreren wesentlichen Punkten von dem von JAVA ab: der Art der Unterscheidung von Wert- und Referenztypen, den angebotenen Typkonstruktoren für Wert- und Referenztypen und dem Umgang mit Interfaces als Typen.
Darüber hinaus hat C# noch eine ganze Reihe weiterer Verbesserungen, die mit dem Typsystem in Verbindung gebracht werden können; auf sie wird hier aber nur am Rande eingegangen.","<answer> Das Typsystem von C# unterscheidet sich von Java in mehreren wesentlichen Punkten, darunter die Art der Unterscheidung von Wert- und Referenztypen, die angebotenen Typkonstruktoren für Wert- und Referenztypen und den Umgang mit Interfaces als Typen. <answer> <question> In welchen wesentlichen Punkten unterscheidet sich das Typsystem von C# von dem von Java? <question>"
"Auch wenn es in großen Teilen recht ähnlich aussieht, weicht das Typsystem von C# in mehreren wesentlichen Punkten von dem von JAVA ab: der Art der Unterscheidung von Wert- und Referenztypen, den angebotenen Typkonstruktoren für Wert- und Referenztypen und dem Umgang mit Interfaces als Typen.
Darüber hinaus hat C# noch eine ganze Reihe weiterer Verbesserungen, die mit dem Typsystem in Verbindung gebracht werden können; auf sie wird hier aber nur am Rande eingegangen.","<answer> Im Text werden die folgenden Unterschiede im Typsystem von C# im Vergleich zu Java erwähnt: Die Unterscheidung von Wert- und Referenztypen. Die verschiedenen Typkonstruktoren für Wert- und Referenztypen. Der Umgang mit Interfaces als Typen. <answer> <question> Was sind einige der Unterschiede im Typsystem von C#, die im Text erwähnt werden? <question>"
"Auch wenn es in großen Teilen recht ähnlich aussieht, weicht das Typsystem von C# in mehreren wesentlichen Punkten von dem von JAVA ab: der Art der Unterscheidung von Wert- und Referenztypen, den angebotenen Typkonstruktoren für Wert- und Referenztypen und dem Umgang mit Interfaces als Typen.
Darüber hinaus hat C# noch eine ganze Reihe weiterer Verbesserungen, die mit dem Typsystem in Verbindung gebracht werden können; auf sie wird hier aber nur am Rande eingegangen.","<answer> Im Text wird erwähnt, dass C# noch eine ganze Reihe weiterer Verbesserungen im Zusammenhang mit dem Typsystem aufweist, jedoch wird auf diese Verbesserungen hier nur am Rande eingegangen, ohne sie im Detail zu erläutern. <answer> <question> Welche weiteren Verbesserungen im Zusammenhang mit dem Typsystem von C# werden im Text erwähnt? <question>"
"Gegen die Verwendung langer, sprechender Bezeichner kann man einwenden, dass der Programmtext dadurch übermäßig lang wird. Anweisungen, die sonst in eine Zeile gepasst hätten, müssen u. U. mehrfach umgebrochen werden, was die Lesbarkeit nicht gerade erhöht. Auch hört man hier und da, dass lange Namen für die Programmiererin zusätzliche Schreibarbeit bedeuten. Letzteres Argument kann man jedoch kaum gelten lassen, da die meisten Entwicklungsumgebungen über eine automatische Vervollständigungsfunktion verfügen, die einem das Tippen abnimmt (und damit auch Tippfehler aufdeckt oder vermeidet).
Das erste Argument ist schon schwieriger zu entkräften: Natürlich sind prägnante Namen geschwätzigen vorzuziehen, und auch in der Programmierung liegt die Würze in der Kürze. Insbesondere sind lange Namen, die sich nur geringfügig unterscheiden (und das auch noch wenig offensichtlich), zu vermeiden. Als Faustregel ist ein Name dann gut gewählt, wenn man alle Ausdrücke, in denen er vorkommt, schnell verstehen kann (und nicht nur, aufgrund falscher Assoziationen und Vermutungen, zu verstehen glaubt). Eine sorgfältige Programmiererin wird sich also häufiger dabei beobachten, wie sie über einen passenden Namen für ein Programmelement länger nachsinnt. Diese Zeit ist jedoch gut investiert.","<answer> Die Verwendung langer, sprechender Bezeichner kann in der Programmierung problematisch sein, da der Programmtext dadurch übermäßig lang wird. Anweisungen, die normalerweise in eine Zeile passen würden, müssen möglicherweise mehrfach umgebrochen werden, was die Lesbarkeit beeinträchtigen kann. Außerdem hört man gelegentlich das Argument, dass lange Namen zusätzliche Schreibarbeit für die Entwicklerin bedeuten. Dieses Argument wird jedoch in der Regel nicht akzeptiert, da die meisten Entwicklungsumgebungen über automatische Vervollständigungsfunktionen verfügen, die das Tippen erleichtern. <answer> <question> Warum könnte die Verwendung langer, sprechender Bezeichner in der Programmierung problematisch sein? <question>"
"Gegen die Verwendung langer, sprechender Bezeichner kann man einwenden, dass der Programmtext dadurch übermäßig lang wird. Anweisungen, die sonst in eine Zeile gepasst hätten, müssen u. U. mehrfach umgebrochen werden, was die Lesbarkeit nicht gerade erhöht. Auch hört man hier und da, dass lange Namen für die Programmiererin zusätzliche Schreibarbeit bedeuten. Letzteres Argument kann man jedoch kaum gelten lassen, da die meisten Entwicklungsumgebungen über eine automatische Vervollständigungsfunktion verfügen, die einem das Tippen abnimmt (und damit auch Tippfehler aufdeckt oder vermeidet).
Das erste Argument ist schon schwieriger zu entkräften: Natürlich sind prägnante Namen geschwätzigen vorzuziehen, und auch in der Programmierung liegt die Würze in der Kürze. Insbesondere sind lange Namen, die sich nur geringfügig unterscheiden (und das auch noch wenig offensichtlich), zu vermeiden. Als Faustregel ist ein Name dann gut gewählt, wenn man alle Ausdrücke, in denen er vorkommt, schnell verstehen kann (und nicht nur, aufgrund falscher Assoziationen und Vermutungen, zu verstehen glaubt). Eine sorgfältige Programmiererin wird sich also häufiger dabei beobachten, wie sie über einen passenden Namen für ein Programmelement länger nachsinnt. Diese Zeit ist jedoch gut investiert.","<answer> Als Faustregel wird genannt, dass ein Name dann gut gewählt ist, wenn man alle Ausdrücke, in denen er vorkommt, schnell und klar verstehen kann. Ein gut gewählter Name sollte keine falschen Assoziationen oder Vermutungen hervorrufen und sollte somit leicht verständlich sein. Es ist ratsam, sich Zeit für die Auswahl eines passenden Namens zu nehmen, da dies eine sorgfältige Überlegung erfordert und die Lesbarkeit des Codes erheblich verbessern kann. <answer> <question> Welche Faustregel wird genannt, um einen guten Namen für ein Programmelement auszuwählen? <question>"
"Häufig findet man in einzelnen Projekten und nicht selten in ganzen Firmen Namenskonventionen vor, an die sich alle halten sollten. Namenskonventionen erleichtern nicht nur die Bezeichnerwahl. Indem die Programmiererin sich an bestimmte Regeln halten kann, wird ihre schöpferische Freiheit eingeschränkt, was man durchaus auch als Entlastung empfinden kann. Sie erleichtern auch das Lesen, weil die Leserin, die die Konventionen kennt, die Bedeutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter entschlüsseln kann und sich somit schneller zurechtfindet. Allerdings ist es dazu notwendig, dass die Namenskonventionen genau festgeschrieben sind und dass sich alle darauf einigen. Wenn nämlich jede ihre individuelle Auslegung der Regel hat, dann kann eine (vermeintliche) Namenskonvention mehr Verwirrung stiften als nutzen.
""It would be a mistake to protest against the rules … on the grounds that they limit developer creativity. A consistent style favors rather than hampers creativity by channeling it to where it matters. A large part of the effort of producing software is spent reading existing software and making others read what is being written. Individual vagaries benefit no one; common conventions help everyone."" - Bertrand Meyer","<answer> Namenskonventionen in der Programmierung haben mehrere Vorteile. Sie erleichtern die Bezeichnerwahl, begrenzen die schöpferische Freiheit der Programmiererin, was als Entlastung empfunden werden kann, und machen das Lesen von Code einfacher, da Entwicklerinnen, die die Konventionen kennen, die Bedeutung der Bezeichner schneller entschlüsseln können und sich somit schneller zurechtfinden. <answer> <question> Welche Vorteile haben Namenskonventionen in der Programmierung? <question>"
"Häufig findet man in einzelnen Projekten und nicht selten in ganzen Firmen Namenskonventionen vor, an die sich alle halten sollten. Namenskonventionen erleichtern nicht nur die Bezeichnerwahl. Indem die Programmiererin sich an bestimmte Regeln halten kann, wird ihre schöpferische Freiheit eingeschränkt, was man durchaus auch als Entlastung empfinden kann. Sie erleichtern auch das Lesen, weil die Leserin, die die Konventionen kennt, die Bedeutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter entschlüsseln kann und sich somit schneller zurechtfindet. Allerdings ist es dazu notwendig, dass die Namenskonventionen genau festgeschrieben sind und dass sich alle darauf einigen. Wenn nämlich jede ihre individuelle Auslegung der Regel hat, dann kann eine (vermeintliche) Namenskonvention mehr Verwirrung stiften als nutzen.
""It would be a mistake to protest against the rules … on the grounds that they limit developer creativity. A consistent style favors rather than hampers creativity by channeling it to where it matters. A large part of the effort of producing software is spent reading existing software and making others read what is being written. Individual vagaries benefit no one; common conventions help everyone."" - Bertrand Meyer","<answer> Es ist wichtig, dass Namenskonventionen genau festgeschrieben sind und von allen akzeptiert werden, da andernfalls individuelle Auslegungen der Regeln Verwirrung stiften können. Wenn jede Person ihre eigene Auslegung hat, verliert die Namenskonvention ihren Nutzen und kann sogar zu mehr Verwirrung führen. <answer> <question> Warum ist es wichtig, dass Namenskonventionen genau festgeschrieben sind und von allen akzeptiert werden? <question>"
"Häufig findet man in einzelnen Projekten und nicht selten in ganzen Firmen Namenskonventionen vor, an die sich alle halten sollten. Namenskonventionen erleichtern nicht nur die Bezeichnerwahl. Indem die Programmiererin sich an bestimmte Regeln halten kann, wird ihre schöpferische Freiheit eingeschränkt, was man durchaus auch als Entlastung empfinden kann. Sie erleichtern auch das Lesen, weil die Leserin, die die Konventionen kennt, die Bedeutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter entschlüsseln kann und sich somit schneller zurechtfindet. Allerdings ist es dazu notwendig, dass die Namenskonventionen genau festgeschrieben sind und dass sich alle darauf einigen. Wenn nämlich jede ihre individuelle Auslegung der Regel hat, dann kann eine (vermeintliche) Namenskonvention mehr Verwirrung stiften als nutzen.
""It would be a mistake to protest against the rules … on the grounds that they limit developer creativity. A consistent style favors rather than hampers creativity by channeling it to where it matters. A large part of the effort of producing software is spent reading existing software and making others read what is being written. Individual vagaries benefit no one; common conventions help everyone."" - Bertrand Meyer","<answer> Die Einhaltung von Namenskonventionen kann die Kreativität der Entwicklerinnen fördern, indem sie die schöpferische Energie auf die relevanten Aspekte lenkt. Durch die Festlegung bestimmter Regeln wird die Entwicklerin in ihrer kreativen Gestaltung eingeschränkt, was jedoch dazu führen kann, dass die Kreativität gezielter eingesetzt wird und besser zur Geltung kommt. <answer> <question> Wie kann die Einhaltung von Namenskonventionen die Kreativität der Entwicklerinnen fördern? <question>"
"Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean: Alle seine Operationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergebnis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte externe Formalismen abzubilden. Im Beispiel von Boolean ist dies natürlich die boolesche Algebra. Jeder, der die boolesche Algebra kennt und akzeptiert, wird auch den Typ Boolean sofort verstehen und akzeptieren (sofern er den Erwartungen entsprechend definiert ist). Entsprechend lässt sich ein Typ Fraction mit den Operationen +, –, *, und / definieren, der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-gleichsoperationen wie =, >, <, etc. hinzufügen, ohne in Interpretationsprobleme zu geraten. Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition rekursiv auf solche Typen zurückgeführt werden können, kann man ""induktiv über deren Aufbau"" eine Bedeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeutung eine denotationale Semantik. Eine andere, für die praktische Programmierung relevantere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten oder realen, Hauptsache gut spezifizierten) Maschine abzubilden. Die Abbildung für Basistypen wie Rational oder Boolean ist in der Programmiersprache bzw. deren Compiler gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann dies hingegen nicht der Fall sein; deren Bedeutung kann aber vom Compiler, wiederum ""induktiv über deren Aufbau"", aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Man nennt dies dann auch eine operationale Semantik. Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht ""hart verdrahtet"" ist, sondern auf dynamisches Binden abgewälzt wird, so sind dennoch mindestens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und Float (nicht jedoch Fraction!) sind ""fest verdrahtet"", inklusive der Vergleichsrelationen (die ja die Wahrheitswerte zum Ergebnis haben). Wenn Sie Kurs 01661 (""Datenstrukturen"") bereits belegt haben oder ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen. Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrieben, deren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs: 1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte keinen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die Operationen ausgeführt werden, nicht ihren Zustand wechseln. Stattdessen geben Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also gewissermaßen alle unveränderlich (vgl. Kurseinheit 1, Abschnitt 4.3.5). 2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar vom Typ des Datentyps selbst. Dieses Argument entspricht in der objektorientierten Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self. Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Programmiersprache mit einer Semantik zu versehen.","<answer> Typen, die sich ausschließlich auf sich selbst beziehen, sind solche, deren Bedeutung nicht von anderen Typen abhängt. Ein Beispiel dafür ist der Typ ""Boolean"". Sie können Bedeutung erhalten, indem sie auf bekannte externe Formalismen abgebildet werden, wie die boolesche Algebra. <answer> <question> Was sind Typen, die sich ausschließlich auf sich selbst beziehen, und wie erhalten sie Bedeutung? <question>"
"Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean: Alle seine Operationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergebnis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte externe Formalismen abzubilden. Im Beispiel von Boolean ist dies natürlich die boolesche Algebra. Jeder, der die boolesche Algebra kennt und akzeptiert, wird auch den Typ Boolean sofort verstehen und akzeptieren (sofern er den Erwartungen entsprechend definiert ist). Entsprechend lässt sich ein Typ Fraction mit den Operationen +, –, *, und / definieren, der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-gleichsoperationen wie =, >, <, etc. hinzufügen, ohne in Interpretationsprobleme zu geraten. Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition rekursiv auf solche Typen zurückgeführt werden können, kann man ""induktiv über deren Aufbau"" eine Bedeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeutung eine denotationale Semantik. Eine andere, für die praktische Programmierung relevantere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten oder realen, Hauptsache gut spezifizierten) Maschine abzubilden. Die Abbildung für Basistypen wie Rational oder Boolean ist in der Programmiersprache bzw. deren Compiler gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann dies hingegen nicht der Fall sein; deren Bedeutung kann aber vom Compiler, wiederum ""induktiv über deren Aufbau"", aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Man nennt dies dann auch eine operationale Semantik. Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht ""hart verdrahtet"" ist, sondern auf dynamisches Binden abgewälzt wird, so sind dennoch mindestens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und Float (nicht jedoch Fraction!) sind ""fest verdrahtet"", inklusive der Vergleichsrelationen (die ja die Wahrheitswerte zum Ergebnis haben). Wenn Sie Kurs 01661 (""Datenstrukturen"") bereits belegt haben oder ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen. Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrieben, deren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs: 1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte keinen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die Operationen ausgeführt werden, nicht ihren Zustand wechseln. Stattdessen geben Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also gewissermaßen alle unveränderlich (vgl. Kurseinheit 1, Abschnitt 4.3.5). 2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar vom Typ des Datentyps selbst. Dieses Argument entspricht in der objektorientierten Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self. Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Programmiersprache mit einer Semantik zu versehen.","<answer> Eine denotationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf bekannte externe Formalismen abgebildet werden. Dies kann beispielsweise bedeuten, dass die Operationen eines Typs auf mathematische oder logische Konzepte abgebildet werden, die in der Programmierung verwendet werden. <answer> <question> Was ist eine denotationale Semantik in Bezug auf die Bedeutung von Typen? <question>"
"Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean: Alle seine Operationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergebnis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte externe Formalismen abzubilden. Im Beispiel von Boolean ist dies natürlich die boolesche Algebra. Jeder, der die boolesche Algebra kennt und akzeptiert, wird auch den Typ Boolean sofort verstehen und akzeptieren (sofern er den Erwartungen entsprechend definiert ist). Entsprechend lässt sich ein Typ Fraction mit den Operationen +, –, *, und / definieren, der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-gleichsoperationen wie =, >, <, etc. hinzufügen, ohne in Interpretationsprobleme zu geraten. Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition rekursiv auf solche Typen zurückgeführt werden können, kann man ""induktiv über deren Aufbau"" eine Bedeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeutung eine denotationale Semantik. Eine andere, für die praktische Programmierung relevantere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten oder realen, Hauptsache gut spezifizierten) Maschine abzubilden. Die Abbildung für Basistypen wie Rational oder Boolean ist in der Programmiersprache bzw. deren Compiler gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann dies hingegen nicht der Fall sein; deren Bedeutung kann aber vom Compiler, wiederum ""induktiv über deren Aufbau"", aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Man nennt dies dann auch eine operationale Semantik. Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht ""hart verdrahtet"" ist, sondern auf dynamisches Binden abgewälzt wird, so sind dennoch mindestens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und Float (nicht jedoch Fraction!) sind ""fest verdrahtet"", inklusive der Vergleichsrelationen (die ja die Wahrheitswerte zum Ergebnis haben). Wenn Sie Kurs 01661 (""Datenstrukturen"") bereits belegt haben oder ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen. Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrieben, deren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs: 1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte keinen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die Operationen ausgeführt werden, nicht ihren Zustand wechseln. Stattdessen geben Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also gewissermaßen alle unveränderlich (vgl. Kurseinheit 1, Abschnitt 4.3.5). 2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar vom Typ des Datentyps selbst. Dieses Argument entspricht in der objektorientierten Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self. Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Programmiersprache mit einer Semantik zu versehen.","<answer> Eine operationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf Anweisungen einer (gedachten oder realen) Maschine abgebildet werden. Dies bedeutet, dass die Operationen eines Typs auf die Ausführung von Maschinenbefehlen oder anderen niedrigstufigen Operationen abgebildet werden. <answer> <question> Was ist eine operationale Semantik in Bezug auf die Bedeutung von Typen? <question>"
"Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean: Alle seine Operationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergebnis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte externe Formalismen abzubilden. Im Beispiel von Boolean ist dies natürlich die boolesche Algebra. Jeder, der die boolesche Algebra kennt und akzeptiert, wird auch den Typ Boolean sofort verstehen und akzeptieren (sofern er den Erwartungen entsprechend definiert ist). Entsprechend lässt sich ein Typ Fraction mit den Operationen +, –, *, und / definieren, der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-gleichsoperationen wie =, >, <, etc. hinzufügen, ohne in Interpretationsprobleme zu geraten. Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition rekursiv auf solche Typen zurückgeführt werden können, kann man ""induktiv über deren Aufbau"" eine Bedeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeutung eine denotationale Semantik. Eine andere, für die praktische Programmierung relevantere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten oder realen, Hauptsache gut spezifizierten) Maschine abzubilden. Die Abbildung für Basistypen wie Rational oder Boolean ist in der Programmiersprache bzw. deren Compiler gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann dies hingegen nicht der Fall sein; deren Bedeutung kann aber vom Compiler, wiederum ""induktiv über deren Aufbau"", aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Man nennt dies dann auch eine operationale Semantik. Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht ""hart verdrahtet"" ist, sondern auf dynamisches Binden abgewälzt wird, so sind dennoch mindestens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und Float (nicht jedoch Fraction!) sind ""fest verdrahtet"", inklusive der Vergleichsrelationen (die ja die Wahrheitswerte zum Ergebnis haben). Wenn Sie Kurs 01661 (""Datenstrukturen"") bereits belegt haben oder ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen. Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrieben, deren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs: 1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte keinen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die Operationen ausgeführt werden, nicht ihren Zustand wechseln. Stattdessen geben Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also gewissermaßen alle unveränderlich (vgl. Kurseinheit 1, Abschnitt 4.3.5). 2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar vom Typ des Datentyps selbst. Dieses Argument entspricht in der objektorientierten Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self. Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Programmiersprache mit einer Semantik zu versehen.","<answer> Nein, es gibt keine vollständig in sich selbst definierten Typsysteme, die vollständig unabhängig von externen Einflüssen sind. Selbst in Typsystemen wie SMALLTALK oder STRONGTALK sind mindestens einige grundlegende Typen oder Konzepte, wie Wahrheitswerte oder Ganzzahlen, von externen Formalismen oder vorgegebenen Semantiken abhängig. <answer> <question> Gibt es vollständig in sich selbst definierte Typsysteme, die von externen Einflüssen unabhängig sind? <question>"
"Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean: Alle seine Operationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergebnis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte externe Formalismen abzubilden. Im Beispiel von Boolean ist dies natürlich die boolesche Algebra. Jeder, der die boolesche Algebra kennt und akzeptiert, wird auch den Typ Boolean sofort verstehen und akzeptieren (sofern er den Erwartungen entsprechend definiert ist). Entsprechend lässt sich ein Typ Fraction mit den Operationen +, –, *, und / definieren, der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-gleichsoperationen wie =, >, <, etc. hinzufügen, ohne in Interpretationsprobleme zu geraten. Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition rekursiv auf solche Typen zurückgeführt werden können, kann man ""induktiv über deren Aufbau"" eine Bedeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeutung eine denotationale Semantik. Eine andere, für die praktische Programmierung relevantere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten oder realen, Hauptsache gut spezifizierten) Maschine abzubilden. Die Abbildung für Basistypen wie Rational oder Boolean ist in der Programmiersprache bzw. deren Compiler gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann dies hingegen nicht der Fall sein; deren Bedeutung kann aber vom Compiler, wiederum ""induktiv über deren Aufbau"", aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Man nennt dies dann auch eine operationale Semantik. Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht ""hart verdrahtet"" ist, sondern auf dynamisches Binden abgewälzt wird, so sind dennoch mindestens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und Float (nicht jedoch Fraction!) sind ""fest verdrahtet"", inklusive der Vergleichsrelationen (die ja die Wahrheitswerte zum Ergebnis haben). Wenn Sie Kurs 01661 (""Datenstrukturen"") bereits belegt haben oder ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen. Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrieben, deren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs: 1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte keinen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die Operationen ausgeführt werden, nicht ihren Zustand wechseln. Stattdessen geben Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also gewissermaßen alle unveränderlich (vgl. Kurseinheit 1, Abschnitt 4.3.5). 2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar vom Typ des Datentyps selbst. Dieses Argument entspricht in der objektorientierten Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self. Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Programmiersprache mit einer Semantik zu versehen.","<answer> Es gibt mindestens zwei wichtige Unterschiede: Abstrakte Datentypen sind nicht objektorientiert, während STRONGTALK-Typen objektorientiert sind und Objekte Zustand haben können. Abstrakte Datentypen haben Funktionen mit einem Argument mehr, das dem Typ des Datentyps selbst entspricht. In objektorientierten Sprachen entspricht dies dem Nachrichtenempfänger, dem impliziten Parameter ""self"". <answer> <question> Was sind die Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs? <question>"
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.","<answer> Atomare Objekte sind grundsätzlich nicht veränderbar, da es keinen Sinn ergibt, sie zu verändern. Zum Beispiel macht es keinen Sinn, aus einer ""1"" eine ""2"" zu machen. <answer> <question> Warum sind atomare Objekte grundsätzlich nicht veränderbar? <question>"
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.","<answer> Zusammengesetzte Objekte wie Arrays könnten veränderbar sein, da es sinnvoll sein kann, in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. <answer> <question> Warum könnten zusammengesetzte Objekte wie Arrays veränderbar sein? <question>"
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.","<answer> Die Frage, ob Array-Objekte, die aus Literalen erzeugt wurden, veränderbar sein sollen, ist ansichtssache und wird von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. <answer> <question> Gilt die Veränderbarkeit von Array-Objekten auch für solche, die aus Literalen erzeugt wurden? <question>"
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.","<answer> Objekte, die aus Symbolliteralen hervorgegangen sind, sollten nie veränderbar sein, um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen. <answer> <question> Warum sollten Objekte, die aus Symbolliteralen hervorgegangen sind, nie veränderbar sein? <question>"
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.","<answer> Zusammengesetzte Objekte sind in SMALLTALK grundsätzlich veränderbar, da dies eine Voraussetzung dafür ist, dass Objekte einen Zustand haben können, was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. <answer> <question> Warum sind zusammengesetzte Objekte in SMALLTALK grundsätzlich veränderbar? <question>"
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.","<answer> Immer mehr Sprachen bieten unveränderliche Objekte an aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung, wie beispielsweise SCALA. <answer> <question> Welche Einflüsse führen dazu, dass immer mehr Sprachen unveränderliche Objekte anbieten? <question>"
"In Abschnitt 7.3 hatten wir bereits die Instanziierung als den hauptsächlichen Weg kennengelernt, wie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Kopierens hingewiesen. Darauf wollen wir nun wieder zurückkommen.
Die einfachste Form des Kopierens eines Objekts erzeugt ein Objekt gleicher Klasse mit gleichen Variablenbelegungen. Dazu gibt es in SMALLTALK die Methode shallowCopy.
Diese Methode liefert eine neue Instanz der Klasse des Empfängers, die in denselben Beziehungen zu denselben anderen Objekten steht wie das Original. Insbesondere werden die Objekte, die die Instanzvariablen des Originals benennen, nicht selbst kopiert. Deswegen nennt man die Kopie flach. Sie erfolgt einfach durch Zuweisung aller Instanzvariablen des Originals an die Instanzvariablen des neuen Objekts, das damit zur Kopie wird. Die Implementierung in SMALLTALK EXPRESS ist die folgende:
isVariable unterscheidet dabei zwischen Klassen mit indizierten Instanzvariablen und solchen ohne; isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.
Nun ist eine flache Kopie aber häufig nicht genug. Es gibt daher noch eine zweite Methode deepCopy.
Wie der Name nahelegt, unterscheidet sich die Methode deepCopy von shallowCopy darin, dass auch die in Beziehung stehenden (durch die Instanzvariablen benannten) Objekte kopiert werden. Statt einzelner Objekte wird also ein Objektgeflecht kopiert — die Kopie ist tief. Es muss dazu an die beiden tatsächlichen Parameter von put: (Zeilen 566 und 570) lediglich eine Nachricht zum Kopieren der Parameter angehängt werden. Dabei ist jedoch flaches Kopieren Vorsicht geboten: Wenn es sich dabei ebenfalls um ein tiefes Kopieren handelt, dann kann der Kopiervorgang leicht in eine Endlosrekursion geraten.
Nun ist die Festlegung, ob die Kopien ihrer Instanzen tiefe oder flache sein sollen, gelegentlich ein Charakteristikum der Klasse selbst. Jede Klasse erbt deswegen von Object eine Methode copy, die standardmäßig (also in Object) einfach shallowCopy aufruft (warum es nicht deepCopy aufruft, sollte klar sein) und die die erbende Klasse entsprechend ihren eigenen Konditionen überschreiben kann. Es ist so möglich, die Kopiertiefe von Objektstrukturen selbst zu bestimmen, indem man copy für manche Klassen deepCopy aufrufen lässt und das tiefe Kopieren durch Instanzen terminiert, deren Klassen shallowCopy aufrufen lassen.
Manchmal darf bei Kopier- oder Konvertieroperationen kein Objekt des gleichen Typs zurückgegeben werden. In diesen Fällen sollte statt self class (Zeile 554) self species aufgerufen werden:
Die Methode species war uns schon einmal begegnet, und zwar in Kurseinheit 1, Abschnitt 4.6.4, Zeile 244. Sie gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist z. B. bei der Methode collect:, ausgeführt auf einer Instanz von Interval, sinnvoll, da collect: hier kein Intervall zurückgeben kann. So kann beispielsweise die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. Entsprechend ist in der Klasse Interval die Methode species als implementiert.","<answer> Die einfachste Form des Kopierens eines Objekts in SMALLTALK ist das Erzeugen eines Objekts derselben Klasse mit denselben Variablenbelegungen. Dies wird durch die Methode ""shallowCopy"" ermöglicht. <answer> <question> Was ist die einfachste Form des Kopierens eines Objekts in SMALLTALK? <question>"
"In Abschnitt 7.3 hatten wir bereits die Instanziierung als den hauptsächlichen Weg kennengelernt, wie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Kopierens hingewiesen. Darauf wollen wir nun wieder zurückkommen.
Die einfachste Form des Kopierens eines Objekts erzeugt ein Objekt gleicher Klasse mit gleichen Variablenbelegungen. Dazu gibt es in SMALLTALK die Methode shallowCopy.
Diese Methode liefert eine neue Instanz der Klasse des Empfängers, die in denselben Beziehungen zu denselben anderen Objekten steht wie das Original. Insbesondere werden die Objekte, die die Instanzvariablen des Originals benennen, nicht selbst kopiert. Deswegen nennt man die Kopie flach. Sie erfolgt einfach durch Zuweisung aller Instanzvariablen des Originals an die Instanzvariablen des neuen Objekts, das damit zur Kopie wird. Die Implementierung in SMALLTALK EXPRESS ist die folgende:
isVariable unterscheidet dabei zwischen Klassen mit indizierten Instanzvariablen und solchen ohne; isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.
Nun ist eine flache Kopie aber häufig nicht genug. Es gibt daher noch eine zweite Methode deepCopy.
Wie der Name nahelegt, unterscheidet sich die Methode deepCopy von shallowCopy darin, dass auch die in Beziehung stehenden (durch die Instanzvariablen benannten) Objekte kopiert werden. Statt einzelner Objekte wird also ein Objektgeflecht kopiert — die Kopie ist tief. Es muss dazu an die beiden tatsächlichen Parameter von put: (Zeilen 566 und 570) lediglich eine Nachricht zum Kopieren der Parameter angehängt werden. Dabei ist jedoch flaches Kopieren Vorsicht geboten: Wenn es sich dabei ebenfalls um ein tiefes Kopieren handelt, dann kann der Kopiervorgang leicht in eine Endlosrekursion geraten.
Nun ist die Festlegung, ob die Kopien ihrer Instanzen tiefe oder flache sein sollen, gelegentlich ein Charakteristikum der Klasse selbst. Jede Klasse erbt deswegen von Object eine Methode copy, die standardmäßig (also in Object) einfach shallowCopy aufruft (warum es nicht deepCopy aufruft, sollte klar sein) und die die erbende Klasse entsprechend ihren eigenen Konditionen überschreiben kann. Es ist so möglich, die Kopiertiefe von Objektstrukturen selbst zu bestimmen, indem man copy für manche Klassen deepCopy aufrufen lässt und das tiefe Kopieren durch Instanzen terminiert, deren Klassen shallowCopy aufrufen lassen.
Manchmal darf bei Kopier- oder Konvertieroperationen kein Objekt des gleichen Typs zurückgegeben werden. In diesen Fällen sollte statt self class (Zeile 554) self species aufgerufen werden:
Die Methode species war uns schon einmal begegnet, und zwar in Kurseinheit 1, Abschnitt 4.6.4, Zeile 244. Sie gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist z. B. bei der Methode collect:, ausgeführt auf einer Instanz von Interval, sinnvoll, da collect: hier kein Intervall zurückgeben kann. So kann beispielsweise die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. Entsprechend ist in der Klasse Interval die Methode species als implementiert.","<answer> ""shallowCopy"" erstellt eine flache Kopie eines Objekts, bei der die in Beziehung stehenden Objekte nicht kopiert werden, während ""deepCopy"" eine tiefe Kopie erstellt, bei der auch die in Beziehung stehenden Objekte kopiert werden. <answer> <question> Was ist der Unterschied zwischen ""shallowCopy"" und ""deepCopy""? <question>"
"In Abschnitt 7.3 hatten wir bereits die Instanziierung als den hauptsächlichen Weg kennengelernt, wie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Kopierens hingewiesen. Darauf wollen wir nun wieder zurückkommen.
Die einfachste Form des Kopierens eines Objekts erzeugt ein Objekt gleicher Klasse mit gleichen Variablenbelegungen. Dazu gibt es in SMALLTALK die Methode shallowCopy.
Diese Methode liefert eine neue Instanz der Klasse des Empfängers, die in denselben Beziehungen zu denselben anderen Objekten steht wie das Original. Insbesondere werden die Objekte, die die Instanzvariablen des Originals benennen, nicht selbst kopiert. Deswegen nennt man die Kopie flach. Sie erfolgt einfach durch Zuweisung aller Instanzvariablen des Originals an die Instanzvariablen des neuen Objekts, das damit zur Kopie wird. Die Implementierung in SMALLTALK EXPRESS ist die folgende:
isVariable unterscheidet dabei zwischen Klassen mit indizierten Instanzvariablen und solchen ohne; isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.
Nun ist eine flache Kopie aber häufig nicht genug. Es gibt daher noch eine zweite Methode deepCopy.
Wie der Name nahelegt, unterscheidet sich die Methode deepCopy von shallowCopy darin, dass auch die in Beziehung stehenden (durch die Instanzvariablen benannten) Objekte kopiert werden. Statt einzelner Objekte wird also ein Objektgeflecht kopiert — die Kopie ist tief. Es muss dazu an die beiden tatsächlichen Parameter von put: (Zeilen 566 und 570) lediglich eine Nachricht zum Kopieren der Parameter angehängt werden. Dabei ist jedoch flaches Kopieren Vorsicht geboten: Wenn es sich dabei ebenfalls um ein tiefes Kopieren handelt, dann kann der Kopiervorgang leicht in eine Endlosrekursion geraten.
Nun ist die Festlegung, ob die Kopien ihrer Instanzen tiefe oder flache sein sollen, gelegentlich ein Charakteristikum der Klasse selbst. Jede Klasse erbt deswegen von Object eine Methode copy, die standardmäßig (also in Object) einfach shallowCopy aufruft (warum es nicht deepCopy aufruft, sollte klar sein) und die die erbende Klasse entsprechend ihren eigenen Konditionen überschreiben kann. Es ist so möglich, die Kopiertiefe von Objektstrukturen selbst zu bestimmen, indem man copy für manche Klassen deepCopy aufrufen lässt und das tiefe Kopieren durch Instanzen terminiert, deren Klassen shallowCopy aufrufen lassen.
Manchmal darf bei Kopier- oder Konvertieroperationen kein Objekt des gleichen Typs zurückgegeben werden. In diesen Fällen sollte statt self class (Zeile 554) self species aufgerufen werden:
Die Methode species war uns schon einmal begegnet, und zwar in Kurseinheit 1, Abschnitt 4.6.4, Zeile 244. Sie gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist z. B. bei der Methode collect:, ausgeführt auf einer Instanz von Interval, sinnvoll, da collect: hier kein Intervall zurückgeben kann. So kann beispielsweise die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. Entsprechend ist in der Klasse Interval die Methode species als implementiert.","<answer> Bei flachem Kopieren, das selbst ein tiefes Kopieren enthält, kann der Kopiervorgang leicht in eine Endlosrekursion geraten. <answer> <question> Welche Herausforderung kann bei flachem Kopieren auftreten, wenn es sich um ein tiefes Kopieren handelt? <question>"
"In Abschnitt 7.3 hatten wir bereits die Instanziierung als den hauptsächlichen Weg kennengelernt, wie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Kopierens hingewiesen. Darauf wollen wir nun wieder zurückkommen.
Die einfachste Form des Kopierens eines Objekts erzeugt ein Objekt gleicher Klasse mit gleichen Variablenbelegungen. Dazu gibt es in SMALLTALK die Methode shallowCopy.
Diese Methode liefert eine neue Instanz der Klasse des Empfängers, die in denselben Beziehungen zu denselben anderen Objekten steht wie das Original. Insbesondere werden die Objekte, die die Instanzvariablen des Originals benennen, nicht selbst kopiert. Deswegen nennt man die Kopie flach. Sie erfolgt einfach durch Zuweisung aller Instanzvariablen des Originals an die Instanzvariablen des neuen Objekts, das damit zur Kopie wird. Die Implementierung in SMALLTALK EXPRESS ist die folgende:
isVariable unterscheidet dabei zwischen Klassen mit indizierten Instanzvariablen und solchen ohne; isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.
Nun ist eine flache Kopie aber häufig nicht genug. Es gibt daher noch eine zweite Methode deepCopy.
Wie der Name nahelegt, unterscheidet sich die Methode deepCopy von shallowCopy darin, dass auch die in Beziehung stehenden (durch die Instanzvariablen benannten) Objekte kopiert werden. Statt einzelner Objekte wird also ein Objektgeflecht kopiert — die Kopie ist tief. Es muss dazu an die beiden tatsächlichen Parameter von put: (Zeilen 566 und 570) lediglich eine Nachricht zum Kopieren der Parameter angehängt werden. Dabei ist jedoch flaches Kopieren Vorsicht geboten: Wenn es sich dabei ebenfalls um ein tiefes Kopieren handelt, dann kann der Kopiervorgang leicht in eine Endlosrekursion geraten.
Nun ist die Festlegung, ob die Kopien ihrer Instanzen tiefe oder flache sein sollen, gelegentlich ein Charakteristikum der Klasse selbst. Jede Klasse erbt deswegen von Object eine Methode copy, die standardmäßig (also in Object) einfach shallowCopy aufruft (warum es nicht deepCopy aufruft, sollte klar sein) und die die erbende Klasse entsprechend ihren eigenen Konditionen überschreiben kann. Es ist so möglich, die Kopiertiefe von Objektstrukturen selbst zu bestimmen, indem man copy für manche Klassen deepCopy aufrufen lässt und das tiefe Kopieren durch Instanzen terminiert, deren Klassen shallowCopy aufrufen lassen.
Manchmal darf bei Kopier- oder Konvertieroperationen kein Objekt des gleichen Typs zurückgegeben werden. In diesen Fällen sollte statt self class (Zeile 554) self species aufgerufen werden:
Die Methode species war uns schon einmal begegnet, und zwar in Kurseinheit 1, Abschnitt 4.6.4, Zeile 244. Sie gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist z. B. bei der Methode collect:, ausgeführt auf einer Instanz von Interval, sinnvoll, da collect: hier kein Intervall zurückgeben kann. So kann beispielsweise die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. Entsprechend ist in der Klasse Interval die Methode species als implementiert.","<answer> Um eine rekursive tiefe Kopie in den Griff zu bekommen, können Sie eine Methode implementieren, die überprüft, ob ein Objekt bereits kopiert wurde, und es nur dann kopiert, wenn es noch nicht kopiert wurde. Dadurch wird die Endlosrekursion vermieden. <answer> <question> Wie können Sie technisch eine rekursive tiefe Kopie in den Griff bekommen? <question>"
"In Abschnitt 7.3 hatten wir bereits die Instanziierung als den hauptsächlichen Weg kennengelernt, wie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Kopierens hingewiesen. Darauf wollen wir nun wieder zurückkommen.
Die einfachste Form des Kopierens eines Objekts erzeugt ein Objekt gleicher Klasse mit gleichen Variablenbelegungen. Dazu gibt es in SMALLTALK die Methode shallowCopy.
Diese Methode liefert eine neue Instanz der Klasse des Empfängers, die in denselben Beziehungen zu denselben anderen Objekten steht wie das Original. Insbesondere werden die Objekte, die die Instanzvariablen des Originals benennen, nicht selbst kopiert. Deswegen nennt man die Kopie flach. Sie erfolgt einfach durch Zuweisung aller Instanzvariablen des Originals an die Instanzvariablen des neuen Objekts, das damit zur Kopie wird. Die Implementierung in SMALLTALK EXPRESS ist die folgende:
isVariable unterscheidet dabei zwischen Klassen mit indizierten Instanzvariablen und solchen ohne; isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.
Nun ist eine flache Kopie aber häufig nicht genug. Es gibt daher noch eine zweite Methode deepCopy.
Wie der Name nahelegt, unterscheidet sich die Methode deepCopy von shallowCopy darin, dass auch die in Beziehung stehenden (durch die Instanzvariablen benannten) Objekte kopiert werden. Statt einzelner Objekte wird also ein Objektgeflecht kopiert — die Kopie ist tief. Es muss dazu an die beiden tatsächlichen Parameter von put: (Zeilen 566 und 570) lediglich eine Nachricht zum Kopieren der Parameter angehängt werden. Dabei ist jedoch flaches Kopieren Vorsicht geboten: Wenn es sich dabei ebenfalls um ein tiefes Kopieren handelt, dann kann der Kopiervorgang leicht in eine Endlosrekursion geraten.
Nun ist die Festlegung, ob die Kopien ihrer Instanzen tiefe oder flache sein sollen, gelegentlich ein Charakteristikum der Klasse selbst. Jede Klasse erbt deswegen von Object eine Methode copy, die standardmäßig (also in Object) einfach shallowCopy aufruft (warum es nicht deepCopy aufruft, sollte klar sein) und die die erbende Klasse entsprechend ihren eigenen Konditionen überschreiben kann. Es ist so möglich, die Kopiertiefe von Objektstrukturen selbst zu bestimmen, indem man copy für manche Klassen deepCopy aufrufen lässt und das tiefe Kopieren durch Instanzen terminiert, deren Klassen shallowCopy aufrufen lassen.
Manchmal darf bei Kopier- oder Konvertieroperationen kein Objekt des gleichen Typs zurückgegeben werden. In diesen Fällen sollte statt self class (Zeile 554) self species aufgerufen werden:
Die Methode species war uns schon einmal begegnet, und zwar in Kurseinheit 1, Abschnitt 4.6.4, Zeile 244. Sie gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist z. B. bei der Methode collect:, ausgeführt auf einer Instanz von Interval, sinnvoll, da collect: hier kein Intervall zurückgeben kann. So kann beispielsweise die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. Entsprechend ist in der Klasse Interval die Methode species als implementiert.","<answer> Die Festlegung, ob Kopien tiefe oder flache Kopien sein sollen, ist gelegentlich ein Charakteristikum der Klasse selbst, da jede Klasse die Methode ""copy"" von ""Object"" erbt und diese Methode standardmäßig ""shallowCopy"" aufruft. Die erbende Klasse kann ""copy"" entsprechend ihren eigenen Konditionen überschreiben und somit die Kopiertiefe von Objektstrukturen selbst bestimmen. <answer> <question> Warum ist die Festlegung, ob Kopien tiefe oder flache Kopien sein sollen, gelegentlich ein Charakteristikum der Klasse selbst? <question>"
"In Abschnitt 7.3 hatten wir bereits die Instanziierung als den hauptsächlichen Weg kennengelernt, wie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Kopierens hingewiesen. Darauf wollen wir nun wieder zurückkommen.
Die einfachste Form des Kopierens eines Objekts erzeugt ein Objekt gleicher Klasse mit gleichen Variablenbelegungen. Dazu gibt es in SMALLTALK die Methode shallowCopy.
Diese Methode liefert eine neue Instanz der Klasse des Empfängers, die in denselben Beziehungen zu denselben anderen Objekten steht wie das Original. Insbesondere werden die Objekte, die die Instanzvariablen des Originals benennen, nicht selbst kopiert. Deswegen nennt man die Kopie flach. Sie erfolgt einfach durch Zuweisung aller Instanzvariablen des Originals an die Instanzvariablen des neuen Objekts, das damit zur Kopie wird. Die Implementierung in SMALLTALK EXPRESS ist die folgende:
isVariable unterscheidet dabei zwischen Klassen mit indizierten Instanzvariablen und solchen ohne; isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.
Nun ist eine flache Kopie aber häufig nicht genug. Es gibt daher noch eine zweite Methode deepCopy.
Wie der Name nahelegt, unterscheidet sich die Methode deepCopy von shallowCopy darin, dass auch die in Beziehung stehenden (durch die Instanzvariablen benannten) Objekte kopiert werden. Statt einzelner Objekte wird also ein Objektgeflecht kopiert — die Kopie ist tief. Es muss dazu an die beiden tatsächlichen Parameter von put: (Zeilen 566 und 570) lediglich eine Nachricht zum Kopieren der Parameter angehängt werden. Dabei ist jedoch flaches Kopieren Vorsicht geboten: Wenn es sich dabei ebenfalls um ein tiefes Kopieren handelt, dann kann der Kopiervorgang leicht in eine Endlosrekursion geraten.
Nun ist die Festlegung, ob die Kopien ihrer Instanzen tiefe oder flache sein sollen, gelegentlich ein Charakteristikum der Klasse selbst. Jede Klasse erbt deswegen von Object eine Methode copy, die standardmäßig (also in Object) einfach shallowCopy aufruft (warum es nicht deepCopy aufruft, sollte klar sein) und die die erbende Klasse entsprechend ihren eigenen Konditionen überschreiben kann. Es ist so möglich, die Kopiertiefe von Objektstrukturen selbst zu bestimmen, indem man copy für manche Klassen deepCopy aufrufen lässt und das tiefe Kopieren durch Instanzen terminiert, deren Klassen shallowCopy aufrufen lassen.
Manchmal darf bei Kopier- oder Konvertieroperationen kein Objekt des gleichen Typs zurückgegeben werden. In diesen Fällen sollte statt self class (Zeile 554) self species aufgerufen werden:
Die Methode species war uns schon einmal begegnet, und zwar in Kurseinheit 1, Abschnitt 4.6.4, Zeile 244. Sie gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist z. B. bei der Methode collect:, ausgeführt auf einer Instanz von Interval, sinnvoll, da collect: hier kein Intervall zurückgeben kann. So kann beispielsweise die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. Entsprechend ist in der Klasse Interval die Methode species als implementiert.","<answer> Die Methode ""species"" gibt standardmäßig die Klasse des Empfängerobjekts zurück. Sie kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist nützlich, wenn bei Kopier- oder Konvertieroperationen ein Objekt eines anderen Typs als das ursprüngliche zurückgegeben werden soll. <answer> <question> Was gibt die Methode ""species"" standardmäßig zurück, und wie kann sie überschrieben werden? <question>"
"Eine Klasse liefert eine Implementierung. Nach gängigen Prinzipien der objektorientierten Programmierung sind Implementierungen jedoch hinter Schnittstellen (oder Interfaces) zu verbergen: Nur die Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind, sollen durch die Schnittstelle nach außen getragen werden – der Rest soll verborgen bleiben (das sog. Geheimnisprinzip).
In Programmiersprachen wie JAVA, C++, usw. gibt es spezielle Schlüsselwörter, die einem Element einer Klassendefinition (beispielsweise einer Methode) vorangestellt seine Zugreifbarkeit festlegen. Diese sogenannten Zugriffsmodifikatoren (engl. access modifier) legen gemeinsam mit der Klassendefinition, die ihre vollständige Implementierung beinhaltet, auch die Schnittstelle der Klasse fest. Je nach Sprache ist diese Schnittstelle für alle Benutzer der Klasse gleich oder unterscheidet sich nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse. Im ersten Fall könnte man von einer absoluten Schnittstelle sprechen; um sie zu spezifizieren, reicht es, zwischen sichtbar und unsichtbar zu unterscheiden. Im zweiten Fall ist die Schnittstelle relativ.
Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nämlich nur aus Deklarationen von Methoden. Die gemachte Einschränkung ist notwendig, weil manche Sprachen, so z. B. JAVA und C++, die Instanzvariablen ihrer Objekte in die Schnittstelle der Klassen aufzunehmen erlauben. Mit den Instanzvariablen wird jedoch die Repräsentation der Objekte nach außen sichtbar, was dem Gedanken des Geheimnisprinzips widerspricht.
Wenn man nun eine Variable mit einem solchen die Schnittstelle repräsentierenden Typ deklariert und eine Typprüfung erfolgreich durchgeführt hat, dann ist sichergestellt, dass über diese Variable nur auf die Elemente einer Klasse zugegriffen wird, die auch Bestandteil des Interfaces der Klasse sind. Wenn jede Instanz dieser Klasse ausschließlich über typisierte Variablen ansprechbar ist, ist damit die Wahrung des Geheimnisprinzips garantiert. Typen dienen damit einem weiteren Zweck, den man zunächst einmal nicht mit ihnen assoziieren würde, nämlich der Wahrung des Implementationsgeheimnisses und Einhaltung der Schnittstellen durch den Compiler. Dieser überaus nützliche Zusammenhang zwischen Klassen, ihren Schnittstellen und Typen wurde erst relativ spät, nämlich mit der Programmiersprache JAVA und ihrem Interface-als-Typ-Konzept, so weiterentwickelt, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle zugleich Typen der Klasse (außer: Supertypen des der Klasse entsprechenden Typs) sind. Die damit ermöglichte interfacebasierte Programmierung, die in Kurs 01853 ausführlich behandelt wird, betrachte ich persönlich als den wichtigsten Beitrag JAVAs zur Disziplin der objektorientierten Programmierung (s. a. Kurseinheit 4, Kapitel 45).","<answer> Das Verbergen von Implementierungen hinter Schnittstellen ist wichtig, um das Geheimnisprinzip zu wahren und sicherzustellen, dass nur die für Benutzer einer Klasse vorgesehenen Elemente sichtbar sind. <answer> <question> Warum ist es nach den Prinzipien der objektorientierten Programmierung wichtig, Implementierungen von Klassen hinter Schnittstellen zu verbergen? <question>"
"Eine Klasse liefert eine Implementierung. Nach gängigen Prinzipien der objektorientierten Programmierung sind Implementierungen jedoch hinter Schnittstellen (oder Interfaces) zu verbergen: Nur die Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind, sollen durch die Schnittstelle nach außen getragen werden – der Rest soll verborgen bleiben (das sog. Geheimnisprinzip).
In Programmiersprachen wie JAVA, C++, usw. gibt es spezielle Schlüsselwörter, die einem Element einer Klassendefinition (beispielsweise einer Methode) vorangestellt seine Zugreifbarkeit festlegen. Diese sogenannten Zugriffsmodifikatoren (engl. access modifier) legen gemeinsam mit der Klassendefinition, die ihre vollständige Implementierung beinhaltet, auch die Schnittstelle der Klasse fest. Je nach Sprache ist diese Schnittstelle für alle Benutzer der Klasse gleich oder unterscheidet sich nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse. Im ersten Fall könnte man von einer absoluten Schnittstelle sprechen; um sie zu spezifizieren, reicht es, zwischen sichtbar und unsichtbar zu unterscheiden. Im zweiten Fall ist die Schnittstelle relativ.
Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nämlich nur aus Deklarationen von Methoden. Die gemachte Einschränkung ist notwendig, weil manche Sprachen, so z. B. JAVA und C++, die Instanzvariablen ihrer Objekte in die Schnittstelle der Klassen aufzunehmen erlauben. Mit den Instanzvariablen wird jedoch die Repräsentation der Objekte nach außen sichtbar, was dem Gedanken des Geheimnisprinzips widerspricht.
Wenn man nun eine Variable mit einem solchen die Schnittstelle repräsentierenden Typ deklariert und eine Typprüfung erfolgreich durchgeführt hat, dann ist sichergestellt, dass über diese Variable nur auf die Elemente einer Klasse zugegriffen wird, die auch Bestandteil des Interfaces der Klasse sind. Wenn jede Instanz dieser Klasse ausschließlich über typisierte Variablen ansprechbar ist, ist damit die Wahrung des Geheimnisprinzips garantiert. Typen dienen damit einem weiteren Zweck, den man zunächst einmal nicht mit ihnen assoziieren würde, nämlich der Wahrung des Implementationsgeheimnisses und Einhaltung der Schnittstellen durch den Compiler. Dieser überaus nützliche Zusammenhang zwischen Klassen, ihren Schnittstellen und Typen wurde erst relativ spät, nämlich mit der Programmiersprache JAVA und ihrem Interface-als-Typ-Konzept, so weiterentwickelt, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle zugleich Typen der Klasse (außer: Supertypen des der Klasse entsprechenden Typs) sind. Die damit ermöglichte interfacebasierte Programmierung, die in Kurs 01853 ausführlich behandelt wird, betrachte ich persönlich als den wichtigsten Beitrag JAVAs zur Disziplin der objektorientierten Programmierung (s. a. Kurseinheit 4, Kapitel 45).","<answer> Zugriffsmodifikatoren legen fest, welche Elemente einer Klassendefinition für Benutzer sichtbar sind und somit die Schnittstelle der Klasse beeinflussen. Sie regeln die Zugriffsberechtigungen auf Methoden und Instanzvariablen. <answer> <question> Welche Rolle spielen Zugriffsmodifikatoren in Programmiersprachen wie JAVA und C++ bei der Festlegung der Schnittstelle einer Klasse? <question>"
"Eine Klasse liefert eine Implementierung. Nach gängigen Prinzipien der objektorientierten Programmierung sind Implementierungen jedoch hinter Schnittstellen (oder Interfaces) zu verbergen: Nur die Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind, sollen durch die Schnittstelle nach außen getragen werden – der Rest soll verborgen bleiben (das sog. Geheimnisprinzip).
In Programmiersprachen wie JAVA, C++, usw. gibt es spezielle Schlüsselwörter, die einem Element einer Klassendefinition (beispielsweise einer Methode) vorangestellt seine Zugreifbarkeit festlegen. Diese sogenannten Zugriffsmodifikatoren (engl. access modifier) legen gemeinsam mit der Klassendefinition, die ihre vollständige Implementierung beinhaltet, auch die Schnittstelle der Klasse fest. Je nach Sprache ist diese Schnittstelle für alle Benutzer der Klasse gleich oder unterscheidet sich nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse. Im ersten Fall könnte man von einer absoluten Schnittstelle sprechen; um sie zu spezifizieren, reicht es, zwischen sichtbar und unsichtbar zu unterscheiden. Im zweiten Fall ist die Schnittstelle relativ.
Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nämlich nur aus Deklarationen von Methoden. Die gemachte Einschränkung ist notwendig, weil manche Sprachen, so z. B. JAVA und C++, die Instanzvariablen ihrer Objekte in die Schnittstelle der Klassen aufzunehmen erlauben. Mit den Instanzvariablen wird jedoch die Repräsentation der Objekte nach außen sichtbar, was dem Gedanken des Geheimnisprinzips widerspricht.
Wenn man nun eine Variable mit einem solchen die Schnittstelle repräsentierenden Typ deklariert und eine Typprüfung erfolgreich durchgeführt hat, dann ist sichergestellt, dass über diese Variable nur auf die Elemente einer Klasse zugegriffen wird, die auch Bestandteil des Interfaces der Klasse sind. Wenn jede Instanz dieser Klasse ausschließlich über typisierte Variablen ansprechbar ist, ist damit die Wahrung des Geheimnisprinzips garantiert. Typen dienen damit einem weiteren Zweck, den man zunächst einmal nicht mit ihnen assoziieren würde, nämlich der Wahrung des Implementationsgeheimnisses und Einhaltung der Schnittstellen durch den Compiler. Dieser überaus nützliche Zusammenhang zwischen Klassen, ihren Schnittstellen und Typen wurde erst relativ spät, nämlich mit der Programmiersprache JAVA und ihrem Interface-als-Typ-Konzept, so weiterentwickelt, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle zugleich Typen der Klasse (außer: Supertypen des der Klasse entsprechenden Typs) sind. Die damit ermöglichte interfacebasierte Programmierung, die in Kurs 01853 ausführlich behandelt wird, betrachte ich persönlich als den wichtigsten Beitrag JAVAs zur Disziplin der objektorientierten Programmierung (s. a. Kurseinheit 4, Kapitel 45).",<answer> Eine absolute Schnittstelle verrät keinerlei Implementierungsdetails und besteht nur aus Methodendeklarationen. Eine relative Schnittstelle kann sich je nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse unterscheiden und gibt mehr Einblicke in die Implementierung. <answer> <question> Was ist der Unterschied zwischen einer absoluten und einer relativ spezifizierten Schnittstelle einer Klasse? <question>
"Eine Klasse liefert eine Implementierung. Nach gängigen Prinzipien der objektorientierten Programmierung sind Implementierungen jedoch hinter Schnittstellen (oder Interfaces) zu verbergen: Nur die Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind, sollen durch die Schnittstelle nach außen getragen werden – der Rest soll verborgen bleiben (das sog. Geheimnisprinzip).
In Programmiersprachen wie JAVA, C++, usw. gibt es spezielle Schlüsselwörter, die einem Element einer Klassendefinition (beispielsweise einer Methode) vorangestellt seine Zugreifbarkeit festlegen. Diese sogenannten Zugriffsmodifikatoren (engl. access modifier) legen gemeinsam mit der Klassendefinition, die ihre vollständige Implementierung beinhaltet, auch die Schnittstelle der Klasse fest. Je nach Sprache ist diese Schnittstelle für alle Benutzer der Klasse gleich oder unterscheidet sich nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse. Im ersten Fall könnte man von einer absoluten Schnittstelle sprechen; um sie zu spezifizieren, reicht es, zwischen sichtbar und unsichtbar zu unterscheiden. Im zweiten Fall ist die Schnittstelle relativ.
Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nämlich nur aus Deklarationen von Methoden. Die gemachte Einschränkung ist notwendig, weil manche Sprachen, so z. B. JAVA und C++, die Instanzvariablen ihrer Objekte in die Schnittstelle der Klassen aufzunehmen erlauben. Mit den Instanzvariablen wird jedoch die Repräsentation der Objekte nach außen sichtbar, was dem Gedanken des Geheimnisprinzips widerspricht.
Wenn man nun eine Variable mit einem solchen die Schnittstelle repräsentierenden Typ deklariert und eine Typprüfung erfolgreich durchgeführt hat, dann ist sichergestellt, dass über diese Variable nur auf die Elemente einer Klasse zugegriffen wird, die auch Bestandteil des Interfaces der Klasse sind. Wenn jede Instanz dieser Klasse ausschließlich über typisierte Variablen ansprechbar ist, ist damit die Wahrung des Geheimnisprinzips garantiert. Typen dienen damit einem weiteren Zweck, den man zunächst einmal nicht mit ihnen assoziieren würde, nämlich der Wahrung des Implementationsgeheimnisses und Einhaltung der Schnittstellen durch den Compiler. Dieser überaus nützliche Zusammenhang zwischen Klassen, ihren Schnittstellen und Typen wurde erst relativ spät, nämlich mit der Programmiersprache JAVA und ihrem Interface-als-Typ-Konzept, so weiterentwickelt, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle zugleich Typen der Klasse (außer: Supertypen des der Klasse entsprechenden Typs) sind. Die damit ermöglichte interfacebasierte Programmierung, die in Kurs 01853 ausführlich behandelt wird, betrachte ich persönlich als den wichtigsten Beitrag JAVAs zur Disziplin der objektorientierten Programmierung (s. a. Kurseinheit 4, Kapitel 45).","<answer> Das Beschränken von Instanzvariablen in der Schnittstelle dient dazu, die Repräsentation der Objekte nach außen nicht sichtbar zu machen, um das Geheimnisprinzip zu wahren und Implementierungsdetails zu verbergen. <answer> <question> Warum beschränken einige Sprachen, wie JAVA und C++, die Instanzvariablen ihrer Klassen in der Schnittstelle? <question>"
"Eine Klasse liefert eine Implementierung. Nach gängigen Prinzipien der objektorientierten Programmierung sind Implementierungen jedoch hinter Schnittstellen (oder Interfaces) zu verbergen: Nur die Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind, sollen durch die Schnittstelle nach außen getragen werden – der Rest soll verborgen bleiben (das sog. Geheimnisprinzip).
In Programmiersprachen wie JAVA, C++, usw. gibt es spezielle Schlüsselwörter, die einem Element einer Klassendefinition (beispielsweise einer Methode) vorangestellt seine Zugreifbarkeit festlegen. Diese sogenannten Zugriffsmodifikatoren (engl. access modifier) legen gemeinsam mit der Klassendefinition, die ihre vollständige Implementierung beinhaltet, auch die Schnittstelle der Klasse fest. Je nach Sprache ist diese Schnittstelle für alle Benutzer der Klasse gleich oder unterscheidet sich nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse. Im ersten Fall könnte man von einer absoluten Schnittstelle sprechen; um sie zu spezifizieren, reicht es, zwischen sichtbar und unsichtbar zu unterscheiden. Im zweiten Fall ist die Schnittstelle relativ.
Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nämlich nur aus Deklarationen von Methoden. Die gemachte Einschränkung ist notwendig, weil manche Sprachen, so z. B. JAVA und C++, die Instanzvariablen ihrer Objekte in die Schnittstelle der Klassen aufzunehmen erlauben. Mit den Instanzvariablen wird jedoch die Repräsentation der Objekte nach außen sichtbar, was dem Gedanken des Geheimnisprinzips widerspricht.
Wenn man nun eine Variable mit einem solchen die Schnittstelle repräsentierenden Typ deklariert und eine Typprüfung erfolgreich durchgeführt hat, dann ist sichergestellt, dass über diese Variable nur auf die Elemente einer Klasse zugegriffen wird, die auch Bestandteil des Interfaces der Klasse sind. Wenn jede Instanz dieser Klasse ausschließlich über typisierte Variablen ansprechbar ist, ist damit die Wahrung des Geheimnisprinzips garantiert. Typen dienen damit einem weiteren Zweck, den man zunächst einmal nicht mit ihnen assoziieren würde, nämlich der Wahrung des Implementationsgeheimnisses und Einhaltung der Schnittstellen durch den Compiler. Dieser überaus nützliche Zusammenhang zwischen Klassen, ihren Schnittstellen und Typen wurde erst relativ spät, nämlich mit der Programmiersprache JAVA und ihrem Interface-als-Typ-Konzept, so weiterentwickelt, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle zugleich Typen der Klasse (außer: Supertypen des der Klasse entsprechenden Typs) sind. Die damit ermöglichte interfacebasierte Programmierung, die in Kurs 01853 ausführlich behandelt wird, betrachte ich persönlich als den wichtigsten Beitrag JAVAs zur Disziplin der objektorientierten Programmierung (s. a. Kurseinheit 4, Kapitel 45).","<answer> Die Verwendung von Typen stellt sicher, dass über Variablen nur auf die Elemente einer Klasse zugegriffen wird, die Teil der Schnittstelle sind. Dadurch wird das Geheimnisprinzip gewahrt, und die Einhaltung von Schnittstellen wird durch den Compiler sichergestellt. <answer> <question> Wie gewährleistet die Verwendung von Typen die Wahrung des Geheimnisprinzips und die Einhaltung von Schnittstellen in der objektorientierten Programmierung? <question>"
"Eine Klasse liefert eine Implementierung. Nach gängigen Prinzipien der objektorientierten Programmierung sind Implementierungen jedoch hinter Schnittstellen (oder Interfaces) zu verbergen: Nur die Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind, sollen durch die Schnittstelle nach außen getragen werden – der Rest soll verborgen bleiben (das sog. Geheimnisprinzip).
In Programmiersprachen wie JAVA, C++, usw. gibt es spezielle Schlüsselwörter, die einem Element einer Klassendefinition (beispielsweise einer Methode) vorangestellt seine Zugreifbarkeit festlegen. Diese sogenannten Zugriffsmodifikatoren (engl. access modifier) legen gemeinsam mit der Klassendefinition, die ihre vollständige Implementierung beinhaltet, auch die Schnittstelle der Klasse fest. Je nach Sprache ist diese Schnittstelle für alle Benutzer der Klasse gleich oder unterscheidet sich nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse. Im ersten Fall könnte man von einer absoluten Schnittstelle sprechen; um sie zu spezifizieren, reicht es, zwischen sichtbar und unsichtbar zu unterscheiden. Im zweiten Fall ist die Schnittstelle relativ.
Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nämlich nur aus Deklarationen von Methoden. Die gemachte Einschränkung ist notwendig, weil manche Sprachen, so z. B. JAVA und C++, die Instanzvariablen ihrer Objekte in die Schnittstelle der Klassen aufzunehmen erlauben. Mit den Instanzvariablen wird jedoch die Repräsentation der Objekte nach außen sichtbar, was dem Gedanken des Geheimnisprinzips widerspricht.
Wenn man nun eine Variable mit einem solchen die Schnittstelle repräsentierenden Typ deklariert und eine Typprüfung erfolgreich durchgeführt hat, dann ist sichergestellt, dass über diese Variable nur auf die Elemente einer Klasse zugegriffen wird, die auch Bestandteil des Interfaces der Klasse sind. Wenn jede Instanz dieser Klasse ausschließlich über typisierte Variablen ansprechbar ist, ist damit die Wahrung des Geheimnisprinzips garantiert. Typen dienen damit einem weiteren Zweck, den man zunächst einmal nicht mit ihnen assoziieren würde, nämlich der Wahrung des Implementationsgeheimnisses und Einhaltung der Schnittstellen durch den Compiler. Dieser überaus nützliche Zusammenhang zwischen Klassen, ihren Schnittstellen und Typen wurde erst relativ spät, nämlich mit der Programmiersprache JAVA und ihrem Interface-als-Typ-Konzept, so weiterentwickelt, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle zugleich Typen der Klasse (außer: Supertypen des der Klasse entsprechenden Typs) sind. Die damit ermöglichte interfacebasierte Programmierung, die in Kurs 01853 ausführlich behandelt wird, betrachte ich persönlich als den wichtigsten Beitrag JAVAs zur Disziplin der objektorientierten Programmierung (s. a. Kurseinheit 4, Kapitel 45).","<answer> Das Interface-als-Typ-Konzept in JAVA ermöglicht es, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle als Typen der Klasse dienen. Dies erleichtert die interfacebasierte Programmierung und wird als einer der wichtigsten Beiträge von JAVA zur objektorientierten Programmierung angesehen. <answer> <question> Was ermöglicht das Interface-als-Typ-Konzept in JAVA, und warum wird es als bedeutend für die objektorientierte Programmierung angesehen? <question>"
