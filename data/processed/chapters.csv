paragraph,question,answer
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.",Frage: Was sind Zugriffsmethoden in EIFFEL und wofür werden sie verwendet?,"Antwort: Zugriffsmethoden in EIFFEL sind Methoden, die verwendet werden, um auf private Instanzvariablen (Attribute) zuzugreifen. Sie dienen dazu, den Zugriff auf diese Variablen zu kontrollieren und bieten die Möglichkeit, Vor- und Nachbedingungen festzulegen."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.",Frage: Wie werden Zugriffsmethoden in EIFFEL syntaktisch dargestellt?,"Antwort: Zugriffsmethoden in EIFFEL sehen syntaktisch aus wie Variablen, können jedoch Funktionen (Setter) oder Funktionen (Getter) sein. Sie können verwendet werden, um Werte zu setzen oder zu lesen."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.",Frage: Welche Aufgaben können Zugriffsmethoden in EIFFEL erfüllen?,"Antwort: Neben dem Lesen und Setzen von Instanzvariablen können Zugriffsmethoden in EIFFEL auch andere Aufgaben erfüllen, wie das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.",Frage: Wie werden in EIFFEL Abfragen und Befehle logisch unterteilt?,"Antwort: In EIFFEL werden Methoden einer Klasse als ""Abfragen"" (queries) und ""Befehle"" (commands) logisch unterteilt. Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.",Frage: Was sind Features in EIFFEL und wie werden sie zusammengefasst?,"Antwort: In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als ""Features"" bezeichnet. Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.",Frage: Gibt es in EIFFEL Zugriffsmodifikatoren wie in JAVA oder C++?,"Antwort: Nein, es gibt in EIFFEL keine Zugriffsmodifikatoren wie in JAVA oder C++. Alle Features sind standardmäßig öffentlich zugänglich."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.",Frage: Wie wird der Zugriff auf Features in EIFFEL kontrolliert?,"Antwort: In EIFFEL wird der Zugriff auf Features durch die gezielte Veröffentlichung (Export) von Features gesteuert. Klassen, die auf diese Features zugreifen sollen, werden explizit genannt."
"In EIFFEL sind Klassen hauptsächlich ein Mittel zur Datenkapselung (""Information hiding""). Alle Instanzvariablen oder Felder, in EIFFEL als Attribute bezeichnet, sind privat (deshalb werden keine Zugriffsmodifikatoren angegeben). Um dennoch von außen auf sie zugreifen zu können, sind Zugriffsmethoden in EIFFEL notwendig. Diese Zugriffsmethoden nehmen jedoch, ähnlich wie Properties in C#, syntaktisch die Form von Variablen an:
Eine Funktion (Setter) wird mit dem Parameter y aufgerufen. Eine Funktion (Getter) wird aufgerufen, um einen Wert zurückzugeben (kompatibel mit y-Zuweisungen).
Normalerweise dienen Zugriffsmethoden dazu, Instanzvariablen zu setzen oder zu lesen, können aber auch andere Aufgaben erfüllen (siehe Abschnitt 50.3.1). Dies ermöglicht insbesondere das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen (siehe Abschnitt 52.6). Es bietet auch die Freiheit, etwas, das wie eine Instanzvariable aussieht, nach außen hin anzubieten, ohne sich auf eine tatsächliche Instanzvariable festzulegen (sogenannte Repräsentationsunabhängigkeit), ähnlich wie bei C#. Beachten Sie, dass es in EIFFEL auch Indexer gibt.
Die Methoden einer Klasse in EIFFEL werden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.
In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet (analog zu den Members in von C++ abgeleiteten Sprachen). Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL. Insbesondere gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).
In EIFFEL gibt es keine Zugriffsmodifikatoren wie in JAVA/C#/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt (im Sinne der Belegung von Instanzvariablen, siehe Kurseinheit 1, Kapitel 3). Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.
Die Definition einer Schnittstelle (der Export von Features) in EIFFEL ist jedoch recht unspezifisch. Alle Klienten einer Klasse hätten das gleiche Bild von ihr, ähnlich wie in SMALLTALK. Dies ist für größere Projekte jedoch nicht sinnvoll. Statt Zugriff an Pakete zu binden (wie in JAVA und C#) oder an Freunde (Friends in C++), bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (zu exportieren), indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren. Das Wissen über die Abhängigkeit ist also in EIFFEL genau umgekehrt zu dem in anderen Sprachen. Der dedizierte Export in EIFFEL entspricht in etwa dem qualifizierten Export in JAVA, wobei er in JAVA nur für Module und nicht für Klassen definiert ist.",Frage: Was ist das Besondere an der Definition einer Schnittstelle in EIFFEL?,"Antwort: Die Definition einer Schnittstelle in EIFFEL ist recht unspezifisch. Alle Klienten einer Klasse haben standardmäßig das gleiche Bild von ihr. Statt den Zugriff an Pakete oder Freunde zu binden, bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (exportieren)."
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.","Frage: Was wird mit ""Inhalt"" eines Objekts oder einer Variable gemeint?","Antwort: Der ""Inhalt"" eines Objekts oder einer Variable bezieht sich auf das Objekt, das von der Variable bezeichnet wird."
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.","Frage: Welche Semantik wird verwendet, wenn Variablen Verweise auf Objekte haben?","Antwort: Variablen mit Verweissemantik haben Verweise (auch Referenzen oder Pointer genannt) auf Objekte, anstatt den Inhalt selbst zu speichern."
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.",Frage: Wie unterscheiden sich Verweissemantik und Wertsemantik von Variablen?,"Antwort: Unter Wertsemantik können zwei Variablen niemals dasselbe Objekt bezeichnen, während Verweissemantik erlaubt, dass mehrere Variablen auf dasselbe Objekt verweisen."
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.",Frage: Warum wird in der objektorientierten Programmierung in der Regel Verweissemantik verwendet?,"Antwort: Verweissemantik wird in der objektorientierten Programmierung häufig verwendet, da sie einen effizienteren Umgang mit Objekten ermöglicht und unterschiedliche Objekte unterschiedlich viel Speicherplatz belegen."
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.","Frage: In welchen objektorientierten Programmiersprachen können Programmierer festlegen, ob Variablen Wert- oder Verweissemantik haben sollen?","Antwort: In einigen objektorientierten Sprachen wie C++ und EIFFEL können Programmierer festlegen, ob Variablen Wert- oder Verweissemantik haben sollen."
"Das bezeichnete Objekt wird manchmal auch als ""Wert"" oder ""Inhalt"" der Variable bezeichnet (und die Variable selbst als Platzhalter des Objekts). Besonders die Verwendung von ""Inhalt"" ist jedoch gefährlich, da sie nahelegt, dass ein Objekt zu einem Zeitpunkt nur von genau einer Variable bezeichnet werden kann, ähnlich wie ein Gegenstand zu einer Zeit immer nur Inhalt eines Behälters sein kann. Tatsächlich können aber mehrere Variablen gleichzeitig auf ein und dasselbe Objekt verweisen – die Variablen haben nämlich nur Verweise (auch Referenzen oder Pointer genannt) auf Objekte (genauer gesagt auf die Speicherstellen, an denen die Objekte abgelegt sind; siehe oben) und nicht den Inhalt selbst. Man spricht deshalb von einer Verweis- oder Referenzsemantik von Variablen, im Gegensatz zur Wertsemantik, bei der das bezeichnete Objekt tatsächlich auch den Inhalt der Variable ausmacht.
Aus technischer Sicht entspricht einer Variable einer Stelle im Speicher. Bei Variablen mit Verweissemantik steht an dieser Stelle jedoch nicht das Objekt, das sie bezeichnet, sondern lediglich ein Verweis auf die Speicherstelle, an der das Objekt gespeichert ist. Es handelt sich also bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen, wie man sie auch aus nicht objektorientierten Programmiersprachen wie Pascal oder C kennt.
Verweis- und Wertsemantik von Variablen unterscheiden sich fundamental: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird jedoch nur den wenigsten Programmierproblemen gerecht. Da zudem die Verweissemantik einen wesentlich speicher- und recheneffizienteren Umgang mit Objekten erlaubt und da unterschiedliche Objekte wie oben beschrieben unterschiedlich viel Speicherplatz belegen, so dass man im Vorfeld nicht immer weiß, wie viel davon man für eine Variable vorsehen muss, ist sie in der objektorientierten Programmierung vorherrschend. In manchen Sprachen, die neben Objekten auch Werte kennen, haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik (z. B. JAVA); andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll (so z. B. C++ und EIFFEL).
Nun ist besonders für unveränderliche Objekte, deren interne Repräsentation klein ist (die also wenig Speicherplatz belegt), die Forderung nach der Speicherung eines Objektes an genau einem Ort und Speicherung von Wert- und Verweisen in Variablen (also die Speicherung in Variablen mit Verweissemantik) ineffizient. Welchen Sinn hätte es beispielsweise, allen Zeichen eine Identität zu geben, an der mit der jeweiligen Identität verbundenen Stelle im Speicher die internen Repräsentationen zu hinterlegen und dann in Variablen die Speicherstelle (Identität) zu speichern, wenn der Verweis mehr Speicher belegt als das Zeichenobjekt, auf das verwiesen wird? Das Gleiche gilt auch für Zahlen bis zu einer gewissen Größe.
In den meisten SMALLTALK-Implementationen wurde dieses Problem so gelöst, dass Variablen, die Zeichen, kleine Zahlen und die booleschen Werte true und false bezeichnen, Wertsemantik haben. Die Objekte können damit tatsächlich an mehreren Stellen im Speicher gespeichert werden, was einen Widerspruch zur reinen Lehre darstellt. Zwar geht damit der Begriff der Identität für diese Objekte verloren, aber für die Programmiererin ist die damit verbundene mehrfache Existenz identischer Objekte im Speicher insofern ohne größere Bedeutung, als hier Gleichheit problemlos an die Stelle der Identität treten kann. Der Preis für diese Flexibilität ist jedoch, dass man den Variablen nicht mehr fix Wert- oder Verweissemantik zuordnen kann – diese hängt vielmehr jeweils von der Art der Objekte ab, die sie gerade bezeichnen. In diesem Fall würde man Wert- bzw. Verweissemantik eher als eine Eigenschaft des Objekts denn der Variable ansehen; das ist jedoch ziemlich SMALLTALK-spezifisch.","Frage: Warum haben in den meisten SMALLTALK-Implementationen Variablen, die Zeichen, kleine Zahlen und boolesche Werte bezeichnen, Wertsemantik?","Antwort: In den meisten SMALLTALK-Implementationen haben diese Variablen Wertsemantik, um Speicherplatz zu sparen, obwohl der Begriff der Identität für diese Objekte verloren geht. Die mehrfache Existenz identischer Objekte im Speicher hat in der Regel keine große Bedeutung, da Gleichheit an die Stelle der Identität treten kann."
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!","Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.","Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat."
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!","Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.","Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?"
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!",Frage: Was ist der Unterschied zwischen Gleichheit und Identität von Objekten?,"Antwort: Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten und wird in SMALLTALK durch den Gleichheitsoperator = getestet. Identität wird in SMALLTALK durch == getestet und bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren."
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!",Frage: Wie werden die Gleichheit und die Identität von Objekten in SMALLTALK getestet?,"Antwort: Die Gleichheit von Objekten wird in SMALLTALK durch den Gleichheitsoperator = getestet, während die Identität zweier Objekte durch == getestet wird."
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!",Frage: Warum können syntaktisch gleiche String-Literale in SMALLTALK unterschiedliche Identitäten haben?,"Antwort: Syntaktisch gleiche String-Literale können in SMALLTALK unterschiedliche Identitäten haben, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen."
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!",Frage: Warum werden gleiche Zahlen in SMALLTALK manchmal als identisch behandelt und manchmal nicht?,"Antwort: In SMALLTALK werden gleiche Zahlen manchmal als identisch behandelt und manchmal nicht, abhängig von ihrer Größe und technischen Gründen."
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!","Frage: Warum ist die Unterscheidung zwischen ""das gleiche"" und ""dasselbe"" wichtig in der objektorientierten Programmierung?","Antwort: In der objektorientierten Programmierung sind ""das gleiche"" und ""dasselbe"" nicht dasselbe. Zwei Objekte können gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins."
"Wie oben schon zur Unterscheidung von String- und Symbolliteralen angedeutet wurde, wird durch das Vorkommen desselben Literals an mehreren Stellen eines Programms nicht notwendigerweise dasselbe, also identische, Objekt repräsentiert. Es kann auch sein, dass die erzeugten Objekte nur gleich sind. Das wirft natürlich sofort die Frage auf, was der Unterschied zwischen Gleichheit und Identität bei Objekten ist und wie überhaupt Objekte unterschieden werden können.
Die Gleichheit von Objekten ist Definitionssache und orientiert sich in der Regel an ihrem Erscheinungsbild oder ihrer Bedeutung. Gleichheit wird in SMALLTALK durch den Gleichheitsoperator = getestet. So liefern alle true. Aber auch liefert true: Obwohl die beiden Zahl-Literale verschieden sind (und für verschiedene Objekte stehen), bezeichnen sie doch (aus mathematischer Sicht) die gleiche Zahl, sodass man sie in SMALLTALK als gleich definiert hat.
Die Identität zweier Objekte (alternativ: die gleiche Identität zweier Objekte) wird in SMALLTALK durch == getestet. So liefern erwartungsgemäß true, kann hingegen zu false auswerten. Zwei syntaktisch gleiche String-Literale können also zwei Objekte mit verschiedener Identität repräsentieren. Dies ist zumindest dann sinnvoll, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen. Übrigens: Phrasen wie ""zwei identische Objekte"" sind strenggenommen Unsinn, denn es handelt sich bei vorliegender Identität definitionsgemäß nicht um zwei, sondern nur um ein Objekt. Die Frage nach der Identität von Objekten ist nur dann sinnvoll, wenn die Objekte durch Namen (oder Variablen) repräsentiert werden. Mehr dazu in Abschnitt 1.5.
Während man sich unter der Identität einer Person oder eines Dokuments leicht etwas vorstellen kann, scheint der Begriff der Identität für manche andere Objekte merkwürdig. Was hat man sich beispielsweise unter der Identität der Zahl ""1"" vorzustellen? Und wenn ""1"" tatsächlich ein Objekt mit Identität ist, was macht dieses Objekt zur Eins? Oder ist die 1 vielleicht die Identität des Objekts ""1"", sind also das Objekt und seine Identität dasselbe?
Im Falle atomarer (also nicht zusammengesetzter) Objekte könnte man versucht sein, die Identität zweier Objekte mit der Gleichheit ihrer Erscheinungen gleichzusetzen: Es erscheint wenig sinnvoll, zwei immer gleiche Objekte mit unterschiedlicher Identität zu haben. So kann man sich beispielsweise fragen, warum man mehrere ""1"" mit unterschiedlicher Identität in einem System haben sollte. Tatsächlich würde es wohl kaum auffallen, wenn zwei solche gleichen, aber sich dennoch aufgrund ihrer Identität unterscheidenden Objekte zu einem verschmelzen würden. Ganz anders ist das bei veränderlichen Objekten: Aufgrund ihrer Veränderlichkeit können sie sich auch nur vorübergehend gleichen, müssen aber selbst während dieser vorübergehenden Gleichheit voneinander zu unterscheiden sein, da sie sich hinterher wieder auseinanderentwickeln können und man dann nicht mehr wüsste, welches welches war. Da dies aber für unveränderliche Objekte nicht der Fall sein kann, ist es durchaus berechtigt, zu fragen, warum sie sich nur aufgrund ihrer Identität unterscheiden sollten.
Die Antwort ist vor allem technischer Natur. Wenn sich ein unveränderliches Objekt wie beispielsweise eine Zahl nicht aus einem Literal, sondern aus einer Operation (einer Rechenoperation) ergibt, dann müsste, für eine Zusammenlegung gleicher Objekte zu einem, immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Da dies Programme stark verlangsamen würde, nimmt man lieber in Kauf, mehrere gleiche, aber nicht identische Objekte zu haben. Aber warum sind dann gleiche Zahlen manchmal identisch, manchmal nicht? Die Antwort ist noch technischer: Sie hat etwas mit der Repräsentation von Objekten im Speicher zu tun und wird im nächsten Abschnitt gegeben. Und so werden in SMALLTALK bestimmte Objekte eben anders behandelt als der Rest: Ganze Zahlen (Integer) bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind — für den Rest (mit Ausnahme der Symbole!) gilt das nicht.
""Das gleiche"" und ""dasselbe"" sind in der objektorientierten Programmierung nicht dasselbe. Zwei Objekte können zwar gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins!",Frage: Warum ist die Identität von Objekten in der objektorientierten Programmierung wichtig?,"Antwort: Die Identität von Objekten ist wichtig, um festzustellen, ob zwei Namen oder Variablen dasselbe Objekt repräsentieren oder nicht."
"Damit eine Variable ein Objekt bezeichnet, muss dieses ihr durch eine sogenannte Zuweisung, in anderen Kontexten auch als Wertzuweisung bezeichnet, zugeordnet werden. Ursprünglich wurde als Zuweisungsoperator das Symbol „“ gewählt; aufgrund der mangelnden Verfügbarkeit auf Tastaturen wurde es jedoch in den meisten SMALLTALK-Implementierungen durch das aus ALGOL und PASCAL bekannte := (englisch als „becomes“ gelesen) ersetzt.7 Die Variable ""lieblingszahl"" bezeichnet also in Folge der Zuweisung ein Objekt „2“ (in der Zuweisung repräsentiert durch das Literal 2).
Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.
Lokale und globale Variablen ""x"" und ""y"" bezeichnen möglicherweise dasselbe Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.
Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.
Nach den drei Zuweisungen bezeichnen ""x"" und ""y"" beide die „3“. Wäre die letzte Zuweisung jedoch ""y := x"" gewesen, bezeichneten ""x"" und ""y"" beide „5“.
Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben der expliziten Zuweisung durch den Zuweisungsoperator kommt auch eine implizite Zuweisung (bei Methodenaufrufen) vor; diese wird jedoch erst in Abschnitt 4.3.2 behandelt.
Der oben geschilderte Unterschied zwischen Wert- und Verweissemantik von Variablen hat erhebliche Konsequenzen für die Zuweisung: Bei einer Zuweisung unter Wertsemantik muss eine Kopie angefertigt werden, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist), und ein Objekt nicht in zwei Variablen gespeichert sein kann. Das hat zur Folge, dass die beiden Variablen ""x"" und ""y"" nach der Zuweisung aus Zeile 21 nicht dasselbe (identische) Objekt bezeichnen (was unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), sodass z. B. Änderungen am in ""x"" gespeicherten Objekt das in ""y"" gespeicherte Objekt nicht betreffen. Bei einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite kopiert und in der Variablen auf der linken Seite gespeichert. Wenn die Variablen auf der linken und der rechten Seite unterschiedliche Semantiken haben, dann liegt entweder eine unzulässige Zuweisung (siehe Kapitel 18) vor, oder es muss, je nach Art der Variable auf der linken Seite, eine Kopie eines Objekts oder ein Verweis auf ein Objekt angefertigt werden (siehe dazu auch Abschnitt 52.5.2 in Kurseinheit 5).",Frage: Was ist eine Zuweisung in der Programmierung?,"Antwort: Eine Zuweisung ist der Vorgang, bei dem einer Variable ein Objekt zugewiesen wird, damit sie dieses Objekt bezeichnet."
"Damit eine Variable ein Objekt bezeichnet, muss dieses ihr durch eine sogenannte Zuweisung, in anderen Kontexten auch als Wertzuweisung bezeichnet, zugeordnet werden. Ursprünglich wurde als Zuweisungsoperator das Symbol „“ gewählt; aufgrund der mangelnden Verfügbarkeit auf Tastaturen wurde es jedoch in den meisten SMALLTALK-Implementierungen durch das aus ALGOL und PASCAL bekannte := (englisch als „becomes“ gelesen) ersetzt.7 Die Variable ""lieblingszahl"" bezeichnet also in Folge der Zuweisung ein Objekt „2“ (in der Zuweisung repräsentiert durch das Literal 2).
Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.
Lokale und globale Variablen ""x"" und ""y"" bezeichnen möglicherweise dasselbe Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.
Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.
Nach den drei Zuweisungen bezeichnen ""x"" und ""y"" beide die „3“. Wäre die letzte Zuweisung jedoch ""y := x"" gewesen, bezeichneten ""x"" und ""y"" beide „5“.
Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben der expliziten Zuweisung durch den Zuweisungsoperator kommt auch eine implizite Zuweisung (bei Methodenaufrufen) vor; diese wird jedoch erst in Abschnitt 4.3.2 behandelt.
Der oben geschilderte Unterschied zwischen Wert- und Verweissemantik von Variablen hat erhebliche Konsequenzen für die Zuweisung: Bei einer Zuweisung unter Wertsemantik muss eine Kopie angefertigt werden, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist), und ein Objekt nicht in zwei Variablen gespeichert sein kann. Das hat zur Folge, dass die beiden Variablen ""x"" und ""y"" nach der Zuweisung aus Zeile 21 nicht dasselbe (identische) Objekt bezeichnen (was unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), sodass z. B. Änderungen am in ""x"" gespeicherten Objekt das in ""y"" gespeicherte Objekt nicht betreffen. Bei einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite kopiert und in der Variablen auf der linken Seite gespeichert. Wenn die Variablen auf der linken und der rechten Seite unterschiedliche Semantiken haben, dann liegt entweder eine unzulässige Zuweisung (siehe Kapitel 18) vor, oder es muss, je nach Art der Variable auf der linken Seite, eine Kopie eines Objekts oder ein Verweis auf ein Objekt angefertigt werden (siehe dazu auch Abschnitt 52.5.2 in Kurseinheit 5).","Frage: Warum kann die Verwechslung von ""="" für die Zuweisung mit dem Test auf Gleichheit zu schwerwiegenden Fehlern in der Programmierung führen?","Antwort: Die Verwechslung von ""="" für die Zuweisung mit dem Test auf Gleichheit kann zu fehlerhaftem Verhalten führen, da es zu unerwarteten Änderungen in Variablenwerten führen kann."
"Damit eine Variable ein Objekt bezeichnet, muss dieses ihr durch eine sogenannte Zuweisung, in anderen Kontexten auch als Wertzuweisung bezeichnet, zugeordnet werden. Ursprünglich wurde als Zuweisungsoperator das Symbol „“ gewählt; aufgrund der mangelnden Verfügbarkeit auf Tastaturen wurde es jedoch in den meisten SMALLTALK-Implementierungen durch das aus ALGOL und PASCAL bekannte := (englisch als „becomes“ gelesen) ersetzt.7 Die Variable ""lieblingszahl"" bezeichnet also in Folge der Zuweisung ein Objekt „2“ (in der Zuweisung repräsentiert durch das Literal 2).
Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.
Lokale und globale Variablen ""x"" und ""y"" bezeichnen möglicherweise dasselbe Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.
Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.
Nach den drei Zuweisungen bezeichnen ""x"" und ""y"" beide die „3“. Wäre die letzte Zuweisung jedoch ""y := x"" gewesen, bezeichneten ""x"" und ""y"" beide „5“.
Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben der expliziten Zuweisung durch den Zuweisungsoperator kommt auch eine implizite Zuweisung (bei Methodenaufrufen) vor; diese wird jedoch erst in Abschnitt 4.3.2 behandelt.
Der oben geschilderte Unterschied zwischen Wert- und Verweissemantik von Variablen hat erhebliche Konsequenzen für die Zuweisung: Bei einer Zuweisung unter Wertsemantik muss eine Kopie angefertigt werden, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist), und ein Objekt nicht in zwei Variablen gespeichert sein kann. Das hat zur Folge, dass die beiden Variablen ""x"" und ""y"" nach der Zuweisung aus Zeile 21 nicht dasselbe (identische) Objekt bezeichnen (was unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), sodass z. B. Änderungen am in ""x"" gespeicherten Objekt das in ""y"" gespeicherte Objekt nicht betreffen. Bei einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite kopiert und in der Variablen auf der linken Seite gespeichert. Wenn die Variablen auf der linken und der rechten Seite unterschiedliche Semantiken haben, dann liegt entweder eine unzulässige Zuweisung (siehe Kapitel 18) vor, oder es muss, je nach Art der Variable auf der linken Seite, eine Kopie eines Objekts oder ein Verweis auf ein Objekt angefertigt werden (siehe dazu auch Abschnitt 52.5.2 in Kurseinheit 5).",Frage: Unterscheidet sich die Zuweisung in SMALLTALK von typisierten Sprachen hinsichtlich der Art der zugewiesenen Werte?,"Antwort: In SMALLTALK gibt es keine Einschränkungen hinsichtlich der Art der zugewiesenen Werte. Variablen können Zeichen, Zahlen, Arrays und mehr zugewiesen werden."
"Damit eine Variable ein Objekt bezeichnet, muss dieses ihr durch eine sogenannte Zuweisung, in anderen Kontexten auch als Wertzuweisung bezeichnet, zugeordnet werden. Ursprünglich wurde als Zuweisungsoperator das Symbol „“ gewählt; aufgrund der mangelnden Verfügbarkeit auf Tastaturen wurde es jedoch in den meisten SMALLTALK-Implementierungen durch das aus ALGOL und PASCAL bekannte := (englisch als „becomes“ gelesen) ersetzt.7 Die Variable ""lieblingszahl"" bezeichnet also in Folge der Zuweisung ein Objekt „2“ (in der Zuweisung repräsentiert durch das Literal 2).
Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.
Lokale und globale Variablen ""x"" und ""y"" bezeichnen möglicherweise dasselbe Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.
Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.
Nach den drei Zuweisungen bezeichnen ""x"" und ""y"" beide die „3“. Wäre die letzte Zuweisung jedoch ""y := x"" gewesen, bezeichneten ""x"" und ""y"" beide „5“.
Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben der expliziten Zuweisung durch den Zuweisungsoperator kommt auch eine implizite Zuweisung (bei Methodenaufrufen) vor; diese wird jedoch erst in Abschnitt 4.3.2 behandelt.
Der oben geschilderte Unterschied zwischen Wert- und Verweissemantik von Variablen hat erhebliche Konsequenzen für die Zuweisung: Bei einer Zuweisung unter Wertsemantik muss eine Kopie angefertigt werden, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist), und ein Objekt nicht in zwei Variablen gespeichert sein kann. Das hat zur Folge, dass die beiden Variablen ""x"" und ""y"" nach der Zuweisung aus Zeile 21 nicht dasselbe (identische) Objekt bezeichnen (was unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), sodass z. B. Änderungen am in ""x"" gespeicherten Objekt das in ""y"" gespeicherte Objekt nicht betreffen. Bei einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite kopiert und in der Variablen auf der linken Seite gespeichert. Wenn die Variablen auf der linken und der rechten Seite unterschiedliche Semantiken haben, dann liegt entweder eine unzulässige Zuweisung (siehe Kapitel 18) vor, oder es muss, je nach Art der Variable auf der linken Seite, eine Kopie eines Objekts oder ein Verweis auf ein Objekt angefertigt werden (siehe dazu auch Abschnitt 52.5.2 in Kurseinheit 5).",Frage: Warum ist die Zuweisung kommutativ?,"Antwort: Die Zuweisung ist nicht kommutativ, da ""x := y"" und ""y := x"" unterschiedliche Bedeutungen haben, es sei denn, ""x"" und ""y"" hatten bereits denselben Wert vor der jeweiligen Zuweisung."
"Damit eine Variable ein Objekt bezeichnet, muss dieses ihr durch eine sogenannte Zuweisung, in anderen Kontexten auch als Wertzuweisung bezeichnet, zugeordnet werden. Ursprünglich wurde als Zuweisungsoperator das Symbol „“ gewählt; aufgrund der mangelnden Verfügbarkeit auf Tastaturen wurde es jedoch in den meisten SMALLTALK-Implementierungen durch das aus ALGOL und PASCAL bekannte := (englisch als „becomes“ gelesen) ersetzt.7 Die Variable ""lieblingszahl"" bezeichnet also in Folge der Zuweisung ein Objekt „2“ (in der Zuweisung repräsentiert durch das Literal 2).
Die Verwechslung von = für die Zuweisung mit dem Test auf Gleichheit ist eine der Tragödien in der Geschichte der Programmiersprachen. Ich möchte nicht wissen, wie viele fatale Fehler auf die dadurch provozierte Verwechselung von Test auf Gleichheit und Zuweisung zurückzuführen sind.
Lokale und globale Variablen ""x"" und ""y"" bezeichnen möglicherweise dasselbe Objekt (genau welches ist hier nicht ersichtlich). Ob sie auch dasselbe bezeichnen, hängt von der Semantik der Variablen ab. Man beachte, dass in SMALLTALK (anders als in typisierten Sprachen) aus Sicht des Compilers nichts dagegen spricht, der Variable ""x"" erst eine Zahl und dann einen String zuzuweisen. Auch Array-Literale können jeder beliebigen Variable zugewiesen werden.
Man beachte weiterhin, dass die Zuweisung (anders als der Test auf Gleichheit = oder Identität ==) nicht kommutativ ist: ""x := y"" hat nur dann dieselbe Bedeutung wie ""y := x"", wenn ""x"" und ""y"" schon vor der jeweiligen Zuweisung denselben Wert hatten. Zur besseren sprachlichen Unterscheidung der Seite, der zugewiesen wird, und der, die zugewiesen wird, spricht man häufig von der linken und der rechten Seite einer Zuweisung.
Nach den drei Zuweisungen bezeichnen ""x"" und ""y"" beide die „3“. Wäre die letzte Zuweisung jedoch ""y := x"" gewesen, bezeichneten ""x"" und ""y"" beide „5“.
Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung sowie der Programmierung überhaupt. Nur die wenigsten Sprachen kommen ohne sie aus. Neben der expliziten Zuweisung durch den Zuweisungsoperator kommt auch eine implizite Zuweisung (bei Methodenaufrufen) vor; diese wird jedoch erst in Abschnitt 4.3.2 behandelt.
Der oben geschilderte Unterschied zwischen Wert- und Verweissemantik von Variablen hat erhebliche Konsequenzen für die Zuweisung: Bei einer Zuweisung unter Wertsemantik muss eine Kopie angefertigt werden, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist), und ein Objekt nicht in zwei Variablen gespeichert sein kann. Das hat zur Folge, dass die beiden Variablen ""x"" und ""y"" nach der Zuweisung aus Zeile 21 nicht dasselbe (identische) Objekt bezeichnen (was unter Wertsemantik, wie oben bereits gesagt, auch gar nicht geht), sodass z. B. Änderungen am in ""x"" gespeicherten Objekt das in ""y"" gespeicherte Objekt nicht betreffen. Bei einer Zuweisung unter Verweissemantik wird jedoch nur der Verweis der rechten Seite kopiert und in der Variablen auf der linken Seite gespeichert. Wenn die Variablen auf der linken und der rechten Seite unterschiedliche Semantiken haben, dann liegt entweder eine unzulässige Zuweisung (siehe Kapitel 18) vor, oder es muss, je nach Art der Variable auf der linken Seite, eine Kopie eines Objekts oder ein Verweis auf ein Objekt angefertigt werden (siehe dazu auch Abschnitt 52.5.2 in Kurseinheit 5).",Frage: Welchen Unterschied gibt es zwischen Zuweisungen unter Wertsemantik und Verweissemantik hinsichtlich des Kopierens von Objekten?,"Antwort: Bei Zuweisungen unter Wertsemantik muss eine Kopie des Objekts angefertigt werden, da die Variable das Objekt selbst speichert. Bei Zuweisungen unter Verweissemantik wird nur der Verweis auf das Objekt kopiert und in der Variable gespeichert. Dies hat Auswirkungen darauf, ob Änderungen an einem Objekt in einer Variable sich auf dasselbe Objekt in einer anderen Variable auswirken."
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).","String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.","Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen."
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).",Frage: Was sind Literale in der Programmierung?,"Antwort: Ein Literal ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten."
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).",Frage: Wie unterscheiden sich Literale von objekterzeugenden Anweisungen in einem Programm?,"Antwort: Der Compiler erzeugt bei der Übersetzung eines Literals das entsprechende Objekt im Speicher, während objekterzeugende Anweisungen erst zur Laufzeit des Programms ausgeführt werden."
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).","Frage: Warum repräsentieren Literale Objekte, aber sind selbst keine Objekte?","Antwort: Literale repräsentieren Objekte, sind jedoch selbst keine Objekte, da sie textuelle Spezifikationen von Objekten sind."
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).",Frage: Was repräsentieren die einfachsten Literale in SMALLTALK?,Antwort: Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten) und Zahl-Literale.
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).",Frage: Was sind Symbole in SMALLTALK und wie unterscheiden sie sich von Strings?,"Antwort: Symbole sind eine weitere Art von Objekten mit literaler Repräsentation in SMALLTALK. Sie dienen dazu, sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen. Symbole dürfen im Gegensatz zu Strings keine Leerzeichen enthalten."
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).",Frage: Welche Herausforderungen können bei der Verwendung von identischen Symbolliteralen auftreten?,Antwort: Bei der Verwendung identischer Symbolliterale kann es durch sogenanntes Aliasing zu unerwarteten Ergebnissen führen.
"Ein Literal (von lat. littera, der Buchstabe) ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten. Wenn der Compiler ein Literal übersetzt, erzeugt er bei der Übersetzung das entsprechende Objekt im Speicher. Dies unterscheidet sich von objekterzeugenden Anweisungen in einem Programm, da diese erst zur Laufzeit des Programms ausgeführt werden. Obwohl wir uns in der nächsten Kurseinheit ausführlicher mit der programmgesteuerten Erzeugung von Objekten befassen werden, müssen wir vorerst mit Objekten zufrieden sein, die eine literale Repräsentation haben. Beachten Sie, dass Literale Objekte repräsentieren, aber nicht selbst Objekte sind.
Die einfachsten Literale repräsentieren Zeichen (mit Ausnahme von Zeichenobjekten). In SMALLTALK wird diesen Literalen ein $-Zeichen vorangestellt, um sie von anderen Zeichen im Programm zu unterscheiden. Zum Beispiel bezeichnet das Literal $a das Zeichenobjekt ""a"". Dieses Objekt ist atomar, das heißt, es besteht nicht aus anderen Objekten. In anderen Programmiersprachen sind Zeichen in der Regel auch Werte.
Eine weitere Art von Literalen, die atomare Objekte repräsentieren, sind Zahl-Literale. Zum Beispiel ist 1 ein Literal, das das Objekt ""1"" bezeichnet. Zahl-Literale bezeichnen ebenfalls atomare Objekte, sie sind in anderen Programmiersprachen in der Regel ebenfalls Werte, jedoch nicht für sehr große Zahlen mit beliebiger Genauigkeit, die in anderen objektorientierten Sprachen durch Objekte repräsentiert werden.
Die in anderen Programmiersprachen vorhandenen Literale (oder Schlüsselwörter), wie true, false und nil (oder null), die ebenfalls atomare Objekte repräsentieren, sind in SMALLTALK nicht vorhanden. Damit sind sie nicht Literale, sondern sogenannte Pseudo-Variablen (siehe Abschnitt 1.7). Der Grund dafür scheint pragmatischer Natur zu sein: SMALLTALK hat keine Schlüsselwörter, und indem true, false und nil als Pseudo-Variablen betrachtet werden, müssen sie vom Compiler nicht syntaktisch von Variablen (siehe Abschnitt 1.5) unterschieden werden. Sie repräsentieren jeweils ein entsprechendes Objekt, das in anderen Sprachen wiederum Werte sind.
Wenn es atomare Objekte gibt, müssen auch zusammengesetzte Objekte existieren. Zum Beispiel können Zeichen zu Zeichenketten, den sogenannten Strings, zusammengesetzt werden, die ebenfalls Objekte sind. Ein String kann selbst wiederum durch ein Literal bezeichnet werden. Zum Beispiel steht in SMALLTALK das Literal 'Smalltalk' für ein String-Objekt mit dem Inhalt ""Smalltalk"". Dieses Objekt setzt sich aus Zeichenobjekten zusammen, die durch die Zeichenliterale $S, $m, $a, $l, $l, $t, $a, $l und $k repräsentiert werden. Die Details zur Zusammensetzung von Objekten und wie sie funktioniert, werden in den Abschnitten 2.1 und 2.3 genauer erläutert.
String-Literale repräsentieren also zusammengesetzte Objekte. Dies wirft die Frage auf, ob zwei identische String-Literale dasselbe Objekt im Speicher repräsentieren. Dies ist nicht grundsätzlich der Fall, wie wir später sehen werden.
Um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen, bietet SMALLTALK sogenannte Symbole als weitere Art von Objekten mit literaler Repräsentation. Zum Beispiel ist #Smalltalk die literale Repräsentation eines Objekts. Es bezeichnet bei jedem Vorkommen im Programm dasselbe Symbolobjekt ""Smalltalk"" (nicht zu verwechseln mit dem obigen String-Objekt). Symbole dürfen im Gegensatz zu Strings nicht alle Zeichen enthalten, beispielsweise keine Leerzeichen.
Da gleiche Symbolliterale immer dasselbe Objekt repräsentieren, ist die Erzeugung eines solchen Objekts technisch aufwendiger als beispielsweise die Erzeugung anhand eines String-Literals. Der Compiler muss vor der Erzeugung prüfen, ob das Literal bereits irgendwo zuvor vorkommt. Falls dies der Fall ist, wird kein neues Objekt erzeugt, sondern das bereits vorhandene verwendet. Dies erfordert eine entsprechende Verwaltung aller Symbolliterale und zugehöriger Objekte durch den Compiler. Wie leicht vorstellbar ist, wäre dieser Ansatz für die allgemein und in großer Anzahl verwendeten Strings sehr zeitaufwendig.
Abschließend versuchen einige SMALLTALK-Compiler, identische Literale, die zusammen kompiliert werden, auf dasselbe Objekt abzubilden. Dies führt manchmal durch sogenanntes Aliasing (siehe Abschnitt 1.8) zu unerwarteten Ergebnissen bei der Verwendung dieser Literale.
Die letzte wichtige Kategorie von Literalen in SMALLTALK sind Array-Literale. Die von ihnen repräsentierten Objekte sind wie Strings zusammengesetzt, bestehen jedoch nicht nur aus Zeichen, sondern aus einer Folge beliebiger Objekte, die wiederum durch Literale repräsentiert werden können. Ein Array-Literal wird in SMALLTALK durch das #-Zeichen und eine öffnende Klammer eingeleitet, gefolgt von den durch Leerzeichen getrennten Literalen und abgeschlossen durch eine schließende Klammer.
Ein solches Array-Literal wie #(1 2 3) ist ein Beispiel, während ein anderes Beispiel #('Smalltalk' #(4 5 6)) wäre. Array-Literale können ineinander verschachtelt sein, wobei das #-Zeichen bei allen inneren Arrays weggelassen wird. In diesem Fall würde das String-Literal 'Smalltalk' in Zeile 8 durch ein gleichbedeutendes Array-Literal ersetzt, das aus Zeichen-Literalen besteht.
Für Array-Literale gelten im Wesentlichen die gleichen Regeln wie für String-Literale: Das Vorhandensein von zwei syntaktisch identischen Literalen bedeutet nicht zwangsläufig, dass sie dasselbe Objekt erzeugen (oder korrekterweise, dass nur ein Objekt erzeugt wird).",Frage: Was sind Array-Literale in SMALLTALK ?,"Antwort: Array-Literale repräsentieren Objekte, die aus einer Folge beliebiger anderer Objekte bestehen."
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.",Frage: Wie sieht eine einfache Klassendefinition in Java aus?,"Antwort: Eine einfache Klassendefinition in Java besteht aus dem Klassennamen, der Angabe von Instanzvariablen (Felder) und Instanzmethoden."
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.",Frage: Was sind Instanzvariablen in Java?,"Antwort: Instanzvariablen in Java sind Felder, die zur Speicherung von Daten in einer Klasse verwendet werden. Jede Instanz der Klasse hat ihre eigenen Kopien dieser Variablen."
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.",Frage: Was sind Instanzmethoden in Java?,"Antwort: Instanzmethoden in Java sind Methoden, die auf Instanzen (Objekten) einer Klasse angewendet werden können. Sie definieren das Verhalten der Klasse."
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","Frage: Was sind ""Member"" in Bezug auf Klassendefinitionen in Java?","Antwort: ""Member"" ist ein zusammenfassender Begriff für Felder und Methoden innerhalb einer Klassendefinition in Java."
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.",Frage: Welche weiteren Arten von Klassendefinitionen sind in Java möglich?,"Antwort: In Java können Sie auch geschachtelte Klassendefinitionen und innere Klassendefinitionen erstellen, die ebenfalls als Members der umschließenden Klasse gelten."
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","Frage: Was bedeutet es, wenn ein Member in Java als ""static"" deklariert wird?","Antwort: Wenn ein Member als ""static"" deklariert wird, bedeutet dies, dass er sich nicht auf Instanzen der Klasse bezieht, sondern auf die Klasse selbst. Es handelt sich um Klassenvariablen und -methoden."
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","Frage: Wann werden ""final""-Variablen in Java verwendet?","Antwort: ""final""-Variablen werden in Java verwendet, um Konstanten zu deklarieren. Sie dürfen nur einmal einen Wert zugewiesen bekommen und sind dann nicht mehr änderbar."
"Eine einfache Klassendefinition in Java sieht wie folgt aus:
class <Klassenname> {
    <Typ 1> <feld1>;
    <Rückgabetyp 1> <methode1>(<Parametertyp 1> <parameter 1>, …) {…}
    // ...
}
Die geschweiften Klammern sind in Java (wie auch in C und allen syntaktisch davon abgeleiteten Sprachen) Begrenzer für Definitionen und Blöcke; sie entsprechen den Schlüsselwörtern ""begin"" und ""end"" von Pascal. Die spitzen Klammern kennzeichnen auch hier metasyntaktische Variablen (Platzhalter für richtige Namen).
Die oben gezeigte Klassendefinition gliedert sich in die Angabe von Instanzvariablen, die in Java als Felder bezeichnet werden, und Instanzmethoden. Beide werden, der Tradition von C++ folgend, zusammenfassend auch als ""Member"" bezeichnet. Der Begriff ""Member"" (das englische Wort für ein Element einer Menge) bezieht sich auf die Klassendefinition. Konstruktoren zählen nicht zu den Members; sie werden in Abschnitt 36.3 behandelt.
Neben Feldern und Methoden kann eine Klassendefinition in Java auch geschachtelte sowie sogenannte innere Klassendefinitionen besitzen. Diese Klassendefinitionen gelten ebenfalls als Members der umschließenden Klasse. Sie sind vor allem dann sinnvoll, wenn ausgedrückt werden soll, dass die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Beispielsweise ist es üblich, wenn verknüpfte Listen implementiert werden, die Klasse der Listenelemente innerhalb der Klasse der Liste zu definieren. Denn diese Listenelemente werden kaum außerhalb einer Liste verwendet und ihre Klasse wird nicht benötigt. Innere Klassen werden immer im Kontext von Instanzen ihrer äußeren Klasse(n) instanziiert. Instanzen innerer Klassen liegen somit ""innerhalb"" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt ""Outer this"" auf diese zugreifen.
Members können auch als ""static"" deklariert werden. Dabei bedeutet ""static"", dass sich so deklarierte Felder und Methoden nicht auf Objekte, sondern auf die Klasse selbst beziehen, in der sie definiert sind. Es handelt sich also um Klassenvariablen und -methoden. Da in Java im Gegensatz zu Smalltalk Klassen selbst keine Objekte sind, sondern während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können, werden als ""static"" deklarierte Members auch nicht dynamisch gebunden.
Achtung: Im Fall von ""static"" deklarierten Feldern könnte man meinen, dass diese zu Konstanten werden. Das ist jedoch nicht der Fall. In Java dient das Schlüsselwort ""final"" dazu, Variablen als Konstanten zu deklarieren. ""final"" bedeutet, dass einer Variable genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in dem schlüsselwortlosen Smalltalk konstante Methoden für Konstanten (siehe Abschnitt 4.3.6). Auf Methoden angewandt bedeutet ""final"", dass diese in Subklassen nicht überschrieben werden dürfen. Mehr dazu im nächsten Abschnitt.","Frage: Warum sind ""static""-Felder in Java keine Konstanten?","Antwort: ""static""-Felder in Java sind nicht automatisch Konstanten, da sie mehrfach geändert werden können. Konstanten werden in Java stattdessen durch das Schlüsselwort ""final"" gekennzeichnet."
"Weil Literale immer die gleichen Objekte repräsentieren, reichen sie zum Programmieren nicht aus. Was man vielmehr auch noch benötigt, sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können, die sogenannten Variablen.
Genau wie ein Literal steht eine Variable in einem Programm für ein Objekt. Anders als bei Literalen wird aus einer Variable jedoch kein Objekt erzeugt: Sie ist lediglich ein Name für ein bereits existierendes Objekt. Dazu kommt, dass eine Variable zu unterschiedlichen Zeitpunkten für unterschiedliche Objekte stehen kann (deshalb der Name „Variable“!). Es können zudem Variablen mit unterschiedlichen Namen für dasselbe Objekt stehen, das damit gewissermaßen verschiedene Namen hat (die sogenannten Aliase; siehe Abschnitt 1.8). Im Folgenden werden wir daher davon sprechen, dass Variablen Objekte benennen oder bezeichnen.",Frage: Warum reichen Literale allein zum Programmieren nicht aus?,Antwort: Weil Literale immer die gleichen Objekte repräsentieren.
"Weil Literale immer die gleichen Objekte repräsentieren, reichen sie zum Programmieren nicht aus. Was man vielmehr auch noch benötigt, sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können, die sogenannten Variablen.
Genau wie ein Literal steht eine Variable in einem Programm für ein Objekt. Anders als bei Literalen wird aus einer Variable jedoch kein Objekt erzeugt: Sie ist lediglich ein Name für ein bereits existierendes Objekt. Dazu kommt, dass eine Variable zu unterschiedlichen Zeitpunkten für unterschiedliche Objekte stehen kann (deshalb der Name „Variable“!). Es können zudem Variablen mit unterschiedlichen Namen für dasselbe Objekt stehen, das damit gewissermaßen verschiedene Namen hat (die sogenannten Aliase; siehe Abschnitt 1.8). Im Folgenden werden wir daher davon sprechen, dass Variablen Objekte benennen oder bezeichnen.",Frage: Was sind Variablen und warum sind sie notwendig beim Programmieren?,"Antwort: Variablen sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können und sind notwendig, weil Literale nicht ausreichen."
"Weil Literale immer die gleichen Objekte repräsentieren, reichen sie zum Programmieren nicht aus. Was man vielmehr auch noch benötigt, sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können, die sogenannten Variablen.
Genau wie ein Literal steht eine Variable in einem Programm für ein Objekt. Anders als bei Literalen wird aus einer Variable jedoch kein Objekt erzeugt: Sie ist lediglich ein Name für ein bereits existierendes Objekt. Dazu kommt, dass eine Variable zu unterschiedlichen Zeitpunkten für unterschiedliche Objekte stehen kann (deshalb der Name „Variable“!). Es können zudem Variablen mit unterschiedlichen Namen für dasselbe Objekt stehen, das damit gewissermaßen verschiedene Namen hat (die sogenannten Aliase; siehe Abschnitt 1.8). Im Folgenden werden wir daher davon sprechen, dass Variablen Objekte benennen oder bezeichnen.",Frage: Wie unterscheiden sich Variablen von Literalen in Bezug auf die Objektrepräsentation?,Antwort: Anders als bei Literalen wird aus einer Variable kein Objekt erzeugt; sie ist lediglich ein Name für ein bereits existierendes Objekt.
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).",Frage: Was bezeichnet eine Variable in der Programmierung?,Antwort: Eine Variable bezeichnet ein Objekt.
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).",Frage: Warum sind nicht alle Variablen und Objekte in einem Programm von überall her zugreifbar?,Antwort: Die Zugriffsbeschränkung auf Variablen und Objekte erfolgt durch die Definition der Sichtbarkeit und entsprechende Regeln für die Sichtbarkeit von Variablen.
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).",Frage: Wie wird die Sichtbarkeit einer Variable definiert?,"Antwort: Die Sichtbarkeit einer Variable bezieht sich immer auf einen Abschnitt des Programmcodes, in dem der Variablenname verwendet werden kann und damit Zugriff auf das von diesem Namen bezeichnete Objekt besteht."
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).",Frage: Was sind die Unterschiede zwischen globalen und lokalen Variablen?,"Antwort: Globale Variablen sind außerhalb des aktuellen Programmabschnitts sichtbar, während lokale Variablen auf den aktuellen Sichtbarkeitsbereich (Abschnitt) beschränkt sind."
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).",Frage: Wie werden globale Variablen in SMALLTALK gekennzeichnet?,Antwort: In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen.
"Eine Variable bezeichnet also ein Objekt. Wer auf eine Variable zugreifen kann, kann damit automatisch auch auf das Objekt zugreifen, das die Variable bezeichnet. Tatsächlich sind alle Objekte, für die es keine eindeutige literale Repräsentation gibt (wie sie Zeichen, manche Zahlen und Symbole haben), nach ihrer Erzeugung nur noch über Variablen zugreifbar. Die einzige Ausnahme bilden hier die sogenannten konstanten Methoden, die jedoch erst in Abschnitt 4.3.6 behandelt werden.
Nun ist es nicht sinnvoll, dass in einem Programm alle Variablen (und damit auch alle Objekte) von überall her zugreifbar sind. Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen. Kurzgefasst ist die Sichtbarkeit einer Variable gleichbedeutend damit, dass man ihren Namen verwenden kann (und damit auch Zugriff auf das von diesem Namen bezeichnete Objekt hat). Dabei bezieht sich die Sichtbarkeit immer auf einen Abschnitt von Programmcode: Wenn eine Variable in einem Abschnitt sichtbar ist, dann entspricht jedes Vorkommen des Variablennamens in diesem Abschnitt einer ihrer Verwendungen.
Die einzelnen Programmiersprachen unterscheiden sich teilweise deutlich in der Definition ihrer Sichtbarkeitsregeln. Häufig wird jedoch zwischen sogenannten globalen und lokalen Variablen unterschieden. Dabei sind beide Begriffe relativ zu verstehen: Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht (sowie gegebenenfalls auf dessen Unterabschnitte). Globale Variablen sind auch außerhalb davon (insbesondere in übergeordneten Abschnitten) sichtbar. Variablen, die überall sichtbar sind, sind also immer (relativ zu jedem Programmabschnitt) global. Wenn eine Variable außerhalb eines bestimmten Programmabschnitts, aber nicht überall sichtbar ist, sagt man auch, sie sei global zu dem Programmabschnitt; sie ist dann lokal zu einem übergeordneten (umschließenden) Programmabschnitt. Lokale Variablen überdecken übrigens immer globale Variablen gleichen Namens; man spricht dann auch von ""Hiding"".
In SMALLTALK müssen globale Variablen mit einem Großbuchstaben beginnen. Smalltalk und Transcript sind zwei prominente Beispiele für globale Variablen. Lokale Variablen hingegen beginnen mit einem Kleinbuchstaben und sind auf den Sichtbarkeitsbereich eines Objekts (oder auch nur Teilen davon) beschränkt. Für die genaue Angabe der Sichtbarkeitsregeln in SMALLTALK fehlt uns noch einiges; wir werden daher erst in den folgenden Abschnitten darauf eingehen; wir können aber schon hier schlussfolgern, dass in SMALLTALK der Unterschied zwischen lokal und global nicht relativ ist (es also nur zwei verschiedene Programmabschnitte gibt).",Frage: Gibt es in SMALLTALK eine relative Unterscheidung zwischen globalen und lokalen Variablen?,Antwort: Nein. In SMALLTALK gibt es keinen relativen Unterschied zwischen globalen und lokalen Variablen; es gibt nur zwei verschiedene Programmabschnitte in Bezug auf die Sichtbarkeit von Variablen.
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.","Frage: Was sind in SMALLTALK Pseudovariablen, und warum werden sie als solche bezeichnet?","Antwort: Pseudovariablen in SMALLTALK sind Variablen wie ""true"", ""false"", ""nil"", ""self"", ""super"" und formale Parameter von Methoden sowie Klassennamen, denen der Programmierer keinen Wert zuweisen kann. Sie werden als Pseudovariablen bezeichnet, da sie ihren Wert entweder nicht ändern können oder ihren Wert vom System erhalten."
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.","Frage: Warum ist die Zuweisung für Pseudovariablen wie ""true"", ""false"" und ""nil"" in SMALLTALK nicht zulässig?","Antwort: Die Zuweisung für Pseudovariablen wie ""true"", ""false"" und ""nil"" ist in SMALLTALK nicht zulässig, da sie auf Objekte von spezifischer Bedeutung verweisen und diese Bedeutung nicht verändert werden sollte."
"Während es für Variablen charakteristisch ist, dass sich ihr Wert ändern kann, sieht SMALLTALK dennoch einige vor, für die das nicht der Fall ist. Hier sind vor allem die Variablen mit den Namen ""true"", ""false"" und ""nil"" zu nennen, die auf Objekte entsprechender Bedeutung verweisen.8 Für diese Variablen ist die Zuweisung nicht zulässig.
Eine ganze Reihe weiterer Variablen kann zwar ihren Wert ändern (also zu unterschiedlichen Zeiten auf verschiedene Objekte verweisen), jedoch erhalten sie ihren Wert vom System; auch diesen kann durch den Zuweisungsoperator := kein Wert zugewiesen werden. Dies sind z. B. die Variablen mit den Namen ""self"" und ""super"", sowie alle formalen Parameter von Methoden (siehe Abschnitt 4.3). Nicht zuletzt sind auch alle Klassennamen (siehe Kurseinheit 2) Variablen, denen man als Programmierer nichts explizit zuweisen kann. All diese Variablen werden in SMALLTALK einheitlich Pseudovariablen genannt.","Frage: Warum ist es wichtig zu wissen, dass diese Variablen Pseudovariablen sind?","Antwort: Es ist wichtig zu wissen, dass diese Variablen Pseudovariablen sind, da sie spezielle Bedeutungen und Einschränkungen in SMALLTALK haben. Programmierer sollten sich bewusst sein, dass sie nicht denselben Regeln unterliegen wie normale Variablen."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.","Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.","Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.",Frage: Warum sind atomare Objekte grundsätzlich nicht veränderbar?,"Antwort: Atomare Objekte sind grundsätzlich nicht veränderbar, da es keinen Sinn ergibt, sie zu verändern. Zum Beispiel macht es keinen Sinn, aus einer ""1"" eine ""2"" zu machen."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.",Frage: Warum könnten zusammengesetzte Objekte wie Arrays veränderbar sein?,"Antwort: Zusammengesetzte Objekte wie Arrays könnten veränderbar sein, da es sinnvoll sein kann, in einem Array-Objekt eine Komponente durch eine andere zu ersetzen."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.","Frage: Gilt die Veränderbarkeit von Array-Objekten auch für solche, die aus Literalen erzeugt wurden?","Antwort: Die Frage, ob Array-Objekte, die aus Literalen erzeugt wurden, veränderbar sein sollen, ist ansichtssache und wird von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.","Antwort: Die Frage, ob Array-Objekte, die aus Literalen erzeugt wurden, veränderbar sein sollen, ist ansichtssache und wird von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt.",
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.","Frage: Warum sollten Objekte, die aus Symbolliteralen hervorgegangen sind, nie veränderbar sein?","Antwort: Objekte, die aus Symbolliteralen hervorgegangen sind, sollten nie veränderbar sein, um sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.",Frage: Warum sind zusammengesetzte Objekte in SMALLTALK grundsätzlich veränderbar?,"Antwort: Zusammengesetzte Objekte sind in SMALLTALK grundsätzlich veränderbar, da dies eine Voraussetzung dafür ist, dass Objekte einen Zustand haben können, was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht."
"Während atomare Objekte grundsätzlich nicht veränderbar sind (welchen Sinn hätte es beispielsweise, aus einer ""1"" eine ""2"" zu machen oder aus einem ""a"" ein ""b""?), gilt das zunächst nicht für zusammengesetzte Objekte. Es ist leicht vorstellbar (und auch grundsätzlich sinnvoll), in einem Array-Objekt eine Komponente durch eine andere zu ersetzen. Die Frage ist jedoch, ob dies auch für Array-Objekte gilt, die aus Literalen erzeugt wurden. Soll es erlaubt sein, dass das zusammengesetzte Objekt, das aus dem Array-Literal #(1 2 3) hervorgegangen ist, durch ein Programm so verändert wird, dass es nicht mehr seiner (ursprünglichen) literalen Repräsentation im Programm entspricht? Dies ist Ansichtssache und wird zumindest für String- und Array-Literale von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt. Objekte, die aus Symbolliteralen hervorgegangen sind, sollten dagegen nie veränderbar sein.
Grundsätzlich sind zusammengesetzte Objekte in SMALLTALK jedoch veränderbar. Dies ist eine Voraussetzung dafür, dass Objekte einen Zustand haben können (siehe Kapitel 3), was wiederum die objektorientierte Programmierung zu einer Form der imperativen Programmierung macht. Aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung findet man jedoch auch immer mehr Sprachen, die unveränderliche Objekte anbieten, wie beispielsweise SCALA.","Frage: Welche Einflüsse führen dazu, dass immer mehr Sprachen unveränderliche Objekte anbieten?","Antwort: Immer mehr Sprachen bieten unveränderliche Objekte an aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung, wie beispielsweise SCALA."
