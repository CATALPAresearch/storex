50.2 Gemeinsamkeiten mit und kleinere Unterschiede zu JAVA

C# unterscheidet sich, was Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen angeht, nicht großartig von JAVA. Es ist in C# allerdings möglich, Operatoren (also z. B. +, –, == etc., aber nicht new, ( ), ||, &&, =) zu überladen. C# besitzt dafür das Schlüsselwort "operator", das in einer Operatordefinition (die ansonsten so aussieht wie eine Methodendefinition) vorangestellt wird:
Außerdem ist es in C# Konvention, Methodennamen mit einem Großbuchstaben beginnen zu lassen, aber das ist wie gesagt nur Konvention. Wichtiger (und für viele Programmierprobleme von unschätzbarem Wert) ist da schon die Möglichkeit von C#, Call by reference nach dem Vorbild von PASCAL (also ohne explizite Pointer; s. o.) zu erlauben und damit Funktionen wie das Vertauschen von Variableninhalten (die Methode "swap") sicher zu programmieren:
Allerdings muss "ref" — anders als in PASCAL "var" — auch an der Aufrufstelle verwendet werden. Formale Parameter können auch mit "out" modifiziert werden (wobei für die Aufrufstelle dasselbe gilt wie für "ref"):
Der Unterschied ist der, dass bei Verwendung von "ref" die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein (einen Wert zugewiesen bekommen haben) muss, während dies bei "out" nicht der Fall ist. Dafür muss bei "out" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Dass "ref" und "out" in C# anders als "var" in PASCAL an der Aufrufstelle wiederholt werden müssen, hat den Vorteil, dass die Programmiererin weiß, dass ihre die tatsächlichen Parameter liefernden Variablen nach dem Aufruf andere Werte haben können. Sie drücken also das Vorhandensein einer Zuweisung in beide Richtungen (hin und zurück) aus.
Sowohl "ref" als auch "out" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Da diese Möglichkeit in JAVA und SMALLTALK fehlt, findet man in diesen Sprachen häufig Klassen vor, die einzig dem Zweck dienen, mehrere Rückgabewerte in einem Objekt zu verpacken. Da sie an der Aufrufstelle aber wieder ausgepackt werden müssen, ist das eine ziemlich umständliche Lösung. Eine elegantere Alternative sind die Tupel EIFFELs (s. Abschnitt 52.7).
Nun verdient C# im Kontext von Methodenaufrufen nicht nur lobende Erwähnung. Die wohl bedeutendste Unterlassung ist, dass es in C# keine "Throws"-Klauseln in Methodendeklarationen gibt — die aus JAVA bekannte Unterscheidung von Checked exceptions und Unchecked exceptions (Abschnitt 47.2 in Kurseinheit 4) entfällt also und es gibt nur Unchecked exceptions. Das bedeutet, dass die Aufruferin einer Methode nicht gezwungen wird, darüber nachzudenken, was zu tun ist, wenn die Methode nicht korrekt ausgeführt werden kann; ja sie weiß nicht einmal bei Betrachten der Schnittstelle, dass die Methode auch abgebrochen werden kann. Das ist natürlich debattierbar, soll aber dem Umstand Rechnung tragen, dass bei einer stark geschichteten Architektur (beispielsweise beim Einsatz von Middleware) das Wissen um Exceptions auf der ganzen Wegstrecke von der Exception-Quelle bis zum Exception handler vorhanden sein muss, obwohl die mittleren Schichten naturgemäß an Art und Auftreten von Ausnahmen keinerlei Interesse haben. Das mit JAVA Version 1.4 eingeführte sog. "Exception chaining" erlaubt, eine Checked exception in einer Unchecked exception zu verpacken und später, z. B. nach Durchlaufen der Middleware, wieder auszupacken (erneut zu werfen). Das sog. "Exception tunneling" bietet ebenfalls Abhilfe.
Ein weiterer, für die Programmierpraxis nicht weniger bedeutsamer Unterschied bei Methoden ergibt sich im Zusammenhang mit dem Überschreiben: Während in JAVA alle Methoden im Prinzip überschrieben werden können (es sei denn, ihre Definition trägt den Zusatz "final"), so dass der Compiler zunächst von einer dynamischen Bindung der Aufrufe ausgehen muss, sind in C#, der Tradition von C++ folgend, dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort "virtual". Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort "override" deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts "new" bekanntzugeben. Anders als landläufig angenommen hat dies nicht nur Performanzgründe (es vermindert die Zahl der dynamischen Bindungen in einem Programm), sondern auch gewichtige programmiertechnische: Man markiert alle Stellen im Programm, an denen das sog. "Fragile-base-class-Problem" (Thema von Kapitel 55 in Kurseinheit 6) auftreten kann. Keine Deklaration.
Einige Sprachkonstrukte verwenden in C# andere Schlüsselwörter als JAVA, so "lock" anstatt "synchronized" sowie "foreach" anstatt "for" für die zweite Form von "For"-Schleifen (s. Kapitel 38 in Kurseinheit 4). Andere weichen in ihrer Bedeutung leicht von denen JAVAs ab: So sind auch "Strings" als Basis einer "Switch"-Anweisung zugelassen (in JAVA erst seit Version 7!) und jeder Zweig (case), der mindestens eine Anweisung enthält, muss mit einer expliziten Kontrollflussanweisung ("break", "goto", "return" oder "throw") abgeschlossen werden. Außerdem hat C# eine "Goto"-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. All dies hat allerdings nichts mit Objektorientierung zu tun.

Frage: Welche Gemeinsamkeiten gibt es zwischen C# und JAVA in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen?
Antwort: C# und JAVA weisen in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen viele Gemeinsamkeiten auf. Die grundlegende Syntax und Struktur der beiden Sprachen sind ähnlich. In beiden Sprachen werden Klassen verwendet, um Objekte zu erstellen, Variablen und Ausdrücke zu definieren, Anweisungen auszuführen und Kontrollstrukturen zu steuern.

Frage: Welche Besonderheit gibt es in C# in Bezug auf die Überladung von Operatoren, und wie wird sie umgesetzt?
Antwort: In C# ist es möglich, Operatoren wie +, -, == usw. zu überladen. Dies wird durch das Schlüsselwort "operator" ermöglicht, das in einer Operatordefinition vorangestellt wird. Die Überladung von Operatoren erfolgt ähnlich wie die Definition von Methoden, aber anstelle von Methodennamen werden die Operatorzeichen verwendet.

Frage: Was ist "Call by reference" in C#, und wie unterscheidet es sich von "Call by value"?
Antwort: In C# ermöglicht "Call by reference" (auch als "ref" und "out" bekannt) das Übergeben von Argumenten an Methoden, bei denen die Änderungen an den Parametern innerhalb der Methode auf die ursprünglichen Argumente außerhalb der Methode angewendet werden. Im Gegensatz dazu verwendet "Call by value" Kopien der Argumente, und Änderungen innerhalb der Methode haben keine Auswirkungen auf die ursprünglichen Argumente.

Frage: Was sind die Unterschiede zwischen "ref" und "out" in Bezug auf Methodenparameter in C#?
Antwort: In C# werden "ref" und "out" verwendet, um formale Parameter zu kennzeichnen, die durch den Methodenaufruf modifiziert werden können. Der Hauptunterschied besteht darin, dass bei "ref" die übergebene Variable vor dem Aufruf initialisiert sein muss, während bei "out" dies nicht erforderlich ist. Bei "out" muss jedoch die formale Parameter in der Methode selbst einen Wert zugewiesen bekommen. Beide ermöglichen mehrere Rückgabewerte für Methoden.

Frage: Warum gibt es in C# keine "Throws"-Klauseln in Methodendeklarationen, wie sie in JAVA existieren?
Antwort: C# verzichtet auf "Throws"-Klauseln in Methodendeklarationen, die in JAVA zur Unterscheidung von Checked Exceptions und Unchecked Exceptions verwendet werden. Stattdessen gibt es in C# nur Unchecked Exceptions. Diese Entscheidung wurde getroffen, um die Programmierer nicht dazu zu zwingen, im Voraus zu wissen, was in jeder Methode schief gehen kann. Es gibt jedoch Möglichkeiten, Exception-Handling in C# durch "Exception chaining" und "Exception tunneling" zu implementieren.

Frage: Welche Unterschiede gibt es zwischen der Überschreibung von Methoden in C# im Vergleich zu JAVA?
Antwort: In C# müssen dynamisch zu bindende Methoden als "virtual" deklariert werden, und überschreibende Methoden müssen mit "override" gekennzeichnet sein. Wenn eine Methode in einer Subklasse neu eingeführt werden soll, wird "new" verwendet. Dies unterscheidet sich von JAVA, wo Methoden standardmäßig überschrieben werden können, es sei denn, sie sind als "final" deklariert. Diese Unterschiede sollen das sogenannte "Fragile-base-class-Problem" verhindern und die Programmiererin darüber informieren, welche Methoden dynamisch gebunden werden und welche nicht.

Frage: Welche anderen Unterschiede und Konventionen gibt es zwischen C# und JAVA in Bezug auf Sprachkonstrukte?
Antwort: Einige Unterschiede und Konventionen zwischen C# und JAVA umfassen die Verwendung von "lock" anstelle von "synchronized" für die Synchronisation, die Verwendung von "foreach" anstelle von "for" für bestimmte Schleifen, die Möglichkeit, "Strings" als Basis einer "Switch"-Anweisung zu verwenden, und die Anforderung, dass jeder Zweig (case) einer "Switch"-Anweisung mit einer expliziten Kontrollflussanweisung ("break", "goto", "return" oder "throw") abgeschlossen sein muss. C# verfügt auch über eine "Goto"-Anweisung, die jedoch nicht in Blöcke springen kann.