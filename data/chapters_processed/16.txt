16 Parallelität: aktive und passive Objekte

Die objektorientierte Weltsicht, die auch in diesem Kurs propagiert wird (nämlich die von den Objekten, die einander Nachrichten schicken und die auf den Empfang von Nachrichten reagieren, indem sie ihren Zustand ändern und weitere Nachrichten verschicken), legt nahe, dass Objekte aktiv sind, will sagen, dass sie über einen eigenen Rechenprozess verfügen. Doch schon in Abschnitt 4.3.2 wurde klar, dass es damit in der Realität nicht weit her ist: Es werden in der Praxis keine Nachrichten verschickt, sondern lediglich Methoden aufgerufen. Abgesehen vom dynamischen Binden dieser Methoden unterscheidet sich damit das Ausführungsmodell der objektorientierten Programmierung nicht von dem der prozeduralen Programmierung (à la PASCAL); insbesondere sind alle Objekte passiv (was soviel bedeutet, wie dass sie nur aktiv sind, solange sie gerade eine Methode ausführen).


Frage: Sind Objekte in der objektorientierten Programmierung aktiv oder passiv?
Antwort: Objekte in der objektorientierten Programmierung sind passiv, was bedeutet, dass sie nur aktiv sind, solange sie gerade eine Methode ausführen.

Frage: Was bedeutet es, dass Objekte passiv sind?
Antwort: Objekte sind passiv, was bedeutet, dass sie nur aktiv sind, solange sie gerade eine Methode ausführen. Im Wesentlichen sind Objekte in der objektorientierten Programmierung nicht anders als Variablen in prozeduralen Programmiersprachen. Sie enthalten Daten und können auf diese Daten zugreifen, aber sie können nicht von sich aus Aktionen ausführen. Stattdessen müssen ihnen Nachrichten gesendet werden, um sie zu aktivieren und sie dazu zu bringen, eine Methode auszuführen.


Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.


Frage: Was sind aktive Objekte?
Antwort: Aktive Objekte sind Objekte, die über einen eigenen Prozess verfügen, der nur die eigenen Methoden ausführt. Sie arbeiten Nachrichten ab, sobald sie die Zeit dazu haben, was zu einem asynchronen Kommunikationsablauf führt.

Frage: Was ist der Unterschied zwischen aktiven Objekten und passiven Objekten?
Antwort: Aktive Objekte verfügen über einen eigenen Prozess, während passive Objekte keinen eigenen Prozess haben. Aktive Objekte arbeiten Nachrichten asynchron ab, während passive Objekte dies synchron tun.

Frage: Warum werden in der objektorientierten Programmierung in der Praxis eher passive Objekte verwendet?
Antwort: Aktive Objekte sind sehr aufwendig, weshalb in der objektorientierten Programmierung in der Praxis eher passive Objekte verwendet werden.

Frage: Wie würden aktive Objekte kommunizieren?
Antwort: Aktive Objekte würden asynchron kommunizieren, indem sie Nachrichten (Methodenaufrufe) ohne Prozess empfangen und dann abarbeiten, wenn sie die Zeit dazu haben.

Frage: Warum werden aktive Objekte in der objektorientierten Programmierung in der Praxis nicht eingesetzt?
Antwort: Aktive Objekte sind sehr aufwendig, daher werden in der objektorientierten Programmierung in der Praxis passive Objekte eingesetzt, die synchron kommunizieren.


Gleichwohl ist auch in der objektorientierten Programmierung Parallelverarbeitung möglich. Nur kommt sie (zumindest in SMALLTALK, aber auch z. B. in Java) nicht in Form von aktiven Objekten daher, sondern in Form von parallelen Prozessen. Jeder dieser Prozesse führt zu einer Zeit eine Methode aus; er besucht zwar mit dem Methodenaufruf die Empfängerobjekte, diese bleiben jedoch selbst passiv (haben also kein Eigenleben).


Frage: Kann es in der objektorientierten Programmierung Parallelverarbeitung geben?
Antwort: Ja, in der objektorientierten Programmierung ist Parallelverarbeitung möglich, jedoch nicht in Form von aktiven Objekten, sondern in Form von parallelen Prozessen, die jeweils eine Methode ausführen.

Frage: Wie wird Parallelverarbeitung in Smalltalk und Java umgesetzt?
Antwort: In Smalltalk und Java wird Parallelverarbeitung durch parallele Prozesse umgesetzt, die zu einer Zeit eine Methode ausführen. Diese Prozesse besuchen mit dem Methodenaufruf die Empfängerobjekte, die jedoch selbst passiv bleiben und kein Eigenleben haben.


Nun gibt es in SMALLTALK eine einfache Möglichkeit, einen neuen Prozess zu starten: Man schickt einfach einem Block die Nachricht "fork". "fork" entspricht im Wesentlichen "value", nur dass der Block dadurch in einem eigenen, unabhängigen Prozess ausgeführt wird. Entsprechend wartet die Ausführung von "fork" auch nicht darauf, dass die Ausführung des Blocks beendet wurde, bevor sie selbst ein Ergebnis zurückliefert; tatsächlich liefert sie auch nicht (wie "value") das Ergebnis des Blocks zurück, sondern den Block selbst (als Objekt). Wenn der Block also ein Ergebnis hat, dann geht dieses verloren; aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert.


Frage: Wie kann man in SMALLTALK einen neuen Prozess starten?
Antwort: In SMALLTALK kann man einen neuen Prozess starten, indem man einem Block die Nachricht "fork" sendet. Diese entspricht im Wesentlichen "value", nur dass der Block in einem eigenen, unabhängigen Prozess ausgeführt wird.

Frage: Was passiert, wenn man einem Block in SMALLTALK die Nachricht "fork" schickt?
Antwort: Wenn man einem Block in SMALLTALK die Nachricht "fork" schickt, wird ein neuer Prozess gestartet, in dem der Block unabhängig ausgeführt wird. Die Ausführung von "fork" liefert den Block selbst (als Objekt) zurück und wartet nicht darauf, dass die Ausführung des Blocks beendet wird. Wenn der Block ein Ergebnis hat, geht dieses verloren, und der Aufrufer kann nur die Seiteneffekte der Ausführung des Blocks sehen, wie z.B. Änderungen am Zustand eines Objekts, das im Block vorkommt.

Frage: Was passiert, wenn ein Block ein Ergebnis hat und mit fork aufgerufen wird?
Antwort: Wenn ein Block ein Ergebnis hat und mit fork aufgerufen wird, dann geht dieses Ergebnis verloren und aus Sicht des Aufrufers bleiben nur die Seiteneffekte der Ausführung des Blocks, also z. B., wenn sich der Zustand eines der in dem Block vorkommenden Objekte ändert.


Soll ein (paralleler) Prozess nicht sofort starten, so braucht man ein Objekt, das diesen Prozess repräsentiert und dem man dann zu einem späteren Zeitpunkt die Nachricht "resume" schicken kann, die den Prozess startet. Ein solches Objekt erhält man, indem man dem Block "newProcess" schickt.
Um einen parametrisierten Block (also einen Block mit Parametern) als Prozess zu starten, verwendet man statt "newProcess" "newProcessWith:" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält.


Frage: Wie startet man einen parametrisierten Block als Prozess?
Antwort: Um einen parametrisierten Block als Prozess zu starten, verwendet man "newProcessWith:" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält.


Mit den Nachrichten "suspend" und "terminate" kann man den Prozess dann temporär anhalten bzw. beenden. Angehaltene Prozesse können später mit "resume" wieder gestartet werden, beendete nicht.


Frage: Was bewirken die Nachrichten "suspend" und "terminate" in Bezug auf einen Prozess?
Antwort: Mit der Nachricht "suspend" kann ein Prozess temporär angehalten werden, während er mit "terminate" beendet wird. Ein angehaltener Prozess kann später mit "resume" wieder gestartet werden, während ein beendeter Prozess nicht wieder gestartet werden kann.


Die Synchronisation von parallelen Prozessen erfolgt in SMALLTALK zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen dazu über zwei Methoden, "wait" und "signal", und eine Instanzvariable, die für jedes Empfangen von "signal" um 1 erhöht und für jedes Empfangen von "wait" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt (mittels "suspend"). Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht "signal" und es gibt noch Prozesse, die schlafen (erkennbar an einem Zähler kleiner als 1), dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden (mittels "resume") und weitermachen.


Frage: Was sind Semaphoren in SMALLTALK und wie werden sie verwendet?
Antwort: Semaphoren in SMALLTALK sind Objekte, die zur Synchronisation von parallelen Prozessen verwendet werden. Sie verfügen über zwei Methoden, "wait" und "signal", und eine Instanzvariable, die für jedes Empfangen von "signal" um 1 erhöht und für jedes Empfangen von "wait" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt. Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht "signal" und es gibt noch Prozesse, die schlafen, dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden und weitermachen.

Frage: Wie erfolgt die Synchronisation von parallelen Prozessen in SMALLTALK?
Antwort: In SMALLTALK erfolgt die Synchronisation von parallelen Prozessen zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen über zwei Methoden, "wait" und "signal", und eine Instanzvariable, die für jedes Empfangen von "signal" um 1 erhöht und für jedes Empfangen von "wait" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt. Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht "signal" und es gibt noch Prozesse, die schlafen, dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden und weitermachen.


Die Synchronisation mittels Semaphoren ist recht elementar und von aktiven Objekten noch weit entfernt. Deutlich näher rückt man mit der Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gezählt werden) Objekte aufnehmen und die eine Synchronisation über "next" und "nextPut:" erlauben. Das Protokoll sieht wie folgt aus:

Frage: Was ist eine SharedQueue?
Antwort: SharedQueue ist eine Unterklasse von OrderedCollection, die Objekte aufnimmt und eine Synchronisation über "next" und "nextPut:" erlaubt.


Die Instanzvariable "queue" ist eine Warteschlange, die auf die Objekte wartet, die in die Instanz von SharedQueue eingefügt werden sollen. Die Methode "next" gibt das nächste Objekt aus der Warteschlange zurück, während "nextPut:" ein Objekt in die Warteschlange einfügt.


Frage: Was ist die Funktion der Instanzvariable "queue" in der Klasse SharedQueue?
Antwort: Die Instanzvariable "queue" in der Klasse SharedQueue ist eine Warteschlange, die auf die Objekte wartet, die in die Instanz von SharedQueue eingefügt werden sollen.


Wenn man nun eine solche SharedQueue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann hat man tatsächlich „aktive Objekte, die einander Nachrichten schicken“.


Frage: Was sind aktive Objekte im Kontext von SharedQueue?
Antwort: Aktive Objekte sind Objekte, die einander Nachrichten schicken, indem sie Nachrichten in eine SharedQueue einstellen und diese von einem anderen Objekt ausgelesen werden, das in einer Endlosschleife läuft.
