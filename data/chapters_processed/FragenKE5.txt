Weitere Fragen zu KE5

Frage: Welche Strukturen bietet C++ im Bereich der objektorientierten Programmierung?
Antwort: C++ bietet sowohl Strukturen (structs) als auch Klassen (classes) im Bereich der objektorientierten Programmierung.

Frage: Welche Besonderheiten gibt es bei Zuweisungen von Pointervariablen in C++?
Antwort: Bei Zuweisungen von Pointervariablen muss man sich in C++ genau überlegen, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen möchte. C++ verwendet standardmäßig "Call by value" für Methodenaufrufe, was bedeutet, dass Kopien von Parametern übergeben werden.

Frage: Was ist die Grundlage für die Übertragung von Parametern in C++-Methodenaufrufen?
Antwort: In C++-Methodenaufrufen erfolgt die Übertragung von Parametern standardmäßig durch "Call by value", was bedeutet, dass Kopien der Parameter übergeben werden.

Frage: Was ist Generizität in C-Sharp?
Antwort: Generizität in C-Sharp ermöglicht es, parametrischen Polymorphismus sowohl für Klassen als auch für Methoden zu nutzen. Sie erlaubt die Definition von generischen Klassen und Interfaces, die eine Menge von Typen spezifizieren, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen.

Frage: Welche Arten von Generizität werden in C-Sharp unterstützt?
Antwort: C-Sharp unterstützt sowohl beschränkte als auch unbeschränkte parametrische Polymorphismus für Klassen und Methoden. Dies bedeutet, dass Typparameter sowohl eingeschränkte (mit bestimmten Anforderungen) als auch unbeschränkte (ohne Anforderungen) Typen sein können.

Frage: Welche Vorteile bietet die Typexpansion in C-Sharp für Werttypen?
Antwort: Die Typexpansion in C-Sharp ermöglicht es, generische Klassen für Werttypen ohne Boxing/Unboxing zu optimieren. Dies führt zu besserer Leistung und geringerem Overhead, da der JIT-Compiler den Code für verschiedene Typen optimieren kann.

Frage: Welche Freiheit bietet der Präprozessor in C++?
Antwort: Der Präprozessor in C++ bietet die Freiheit, die Syntax der Sprache durch Hinzufügen einer neuen Syntax zu verändern. Dies ermöglicht es, Code in einer für Entwickler verständlicheren Weise zu schreiben, wenn gewünscht.

Frage: Was sind explizite Interfaceimplementierungen in C-Sharp?
Antwort: Explizite Interfaceimplementierungen in C-Sharp ermöglichen es einer Klasse, die gleiche Methodendeklaration von verschiedenen Interfaces getrennt voneinander zu implementieren. Dies wird durch die Angabe des Interfacequalifikators vor der Methode erreicht.

Frage: Welchen Nutzen haben explizite Interfaceimplementierungen in C-Sharp?
Antwort: Der Nutzen von expliziten Interfaceimplementierungen liegt darin, dass die Methode je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Dies ermöglicht es, verschiedene Verhaltensweisen für denselben Methodennamen in verschiedenen Kontexten zu definieren.

Frage: Welche Arten von Vererbung erlaubt EIFFEL?
Antwort: EIFFEL erlaubt Mehrfachvererbung, was bedeutet, dass eine Klasse von mehreren anderen Klassen erben kann.

Frage: Welches Schlüsselwort wird in EIFFEL für abstrakte Klassen verwendet?
Antwort: In EIFFEL wird das Schlüsselwort "deferred" anstelle von "abstract" für abstrakte Klassen verwendet.

Frage: Was ist in EIFFEL nicht erlaubt, was das Überladen von Methoden betrifft?
Antwort: In EIFFEL ist es nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt.

Frage: Was ist die Just-in-time-(JIT-)Kompilierung in C-Sharp und wie unterscheidet sie sich von Java?
Antwort: In C-Sharp ist die Just-in-time-(JIT-)Kompilierung die Standardmethode zur Übersetzung des CIL-Codes in Maschinencode. Dieser Vorgang erfolgt unmittelbar vor der Ausführung und nur dann, wenn der Code tatsächlich ausgeführt wird. Im Gegensatz dazu verwendet Java normalerweise den Ahead-of-time-(AOT-)Kompilierungsansatz, bei dem der Bytecode vor der Ausführung in nativen Maschinencode übersetzt wird. Die JIT-Kompilierung in C-Sharp ermöglicht eine feinere Granularität, da sie bis auf die Ebene einzelner Methoden herabgeht.

Frage: Welche Unterschiede gibt es in Bezug auf die Garbage Collection zwischen C-Sharp und Java?
Antwort: In C-Sharp haben Entwickler die Möglichkeit, den Speicherplatz für Objekte, die mit "new" erstellt wurden, manuell freizugeben. Dies kann jedoch zu Speicherlecks führen, wenn Entwickler vergessen, den Speicher freizugeben, oder zu Problemen, wenn auf freigegebene Objekte weiterhin Referenzen vorhanden sind. Im Gegensatz dazu verwendet Java normalerweise eine automatische Garbage Collection, bei der nicht mehr benötigte Objekte automatisch erkannt und freigegeben werden.

Frage: Welche Spracherweiterungen, die später in Java eingeführt wurden, gab es bereits in C-Sharp?
Antwort: In C-Sharp gab es von Anfang an sogenannte "Attributes" (Attribute), die in Java in der Version 5 als "Annotationen" Einzug hielten. C-Sharp führte auch bereits ab Version 3.0 Lambda-Ausdrücke ein, während Java erst mit Version 8 nachzog.

Frage: Was ist ein herausragendes Merkmal von EIFFEL in Bezug auf Zusicherungen (Assertions)?
Antwort: Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Anders als in Java, wo Zusicherungen flexibel platziert werden können, gibt es in EIFFEL spezielle vorgesehene Stellen für diese Zusicherungen.

Frage: Welche Schlüsselwörter werden in EIFFEL verwendet, um Vor- und Nachbedingungen für Methoden zu definieren?
Antwort: In EIFFEL werden die Schlüsselwörter "require" (vor der Implementierung der Methode) und "ensure" (nach der Implementierung der Methode) verwendet, um Vor- und Nachbedingungen für Methoden zu definieren.

Frage: Was sind Klasseninvarianten in EIFFEL?
Antwort: Klasseninvarianten in EIFFEL sind Bedingungen, die zwischen zwei Methodenaufrufen in einer Klasse immer gelten müssen. Sie werden mit dem Schlüsselwort "invariant" deklariert und sind sozusagen eine Zusammenfassung von Vor- und Nachbedingungen, die für die Klasse als Ganzes gelten.

Frage: Welche Rolle nimmt EIFFEL unter den behandelten Sprachen ein?
Antwort: EIFFEL nimmt eine besondere Position unter den behandelten Sprachen ein, da es mehrere Funktionen erfüllt: Es dient als Sprache für objektorientierte Analyse und Design, für kommerzielle Programmierung und als akademische Lehrsprache.

Frage: Was ist das herausragende Merkmal von EIFFEL und wie trägt es zu seiner Multifunktion bei?
Antwort: Das herausragende Merkmal von EIFFEL ist die Integration von Zusicherungen (Vorbedingungen, Nachbedingungen und Klasseninvarianten), die als Verträge zwischen Klassen dienen können. Dies ermöglicht eine Spezifikation des "Was" einer Software unabhängig vom "Wie". Es erlaubt, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sich auf andere Werte und den zeitlichen Verlauf beziehen können. Diese Funktion trägt zu seiner Multifunktion bei, da sie verschiedene Anwendungsbereiche unterstützt.

Frage: Welche Abweichungen gibt es in EIFFEL im Vergleich zu anderen Sprachen, und warum sind sie vorhanden?
Antwort: Obwohl EIFFEL syntaktisch Ähnlichkeiten zu anderen Sprachen wie PASCAL aufweist, gibt es einige Abweichungen. Diese Abweichungen sind jedoch gut begründet und bieten eine alternative Perspektive auf vertraute Konzepte. Sie tragen dazu bei, klarere und orthogonalere Konzepte zu schaffen.

Frage: Was ist das Common Type System (CTS) in C-Sharp und warum ist es wichtig?
Antwort: Das Common Type System (CTS) ist ein Teil des .NET-Frameworks und sorgt dafür, dass Typen, die in verschiedenen .NET-Sprachen definiert wurden, gemeinsam genutzt werden können. Es stellt sicher, dass Typen in einer einheitlichen Hierarchie organisiert sind und in verschiedenen .NET-Sprachen verwendet werden können, als wären sie in der jeweiligen Sprache selbst definiert worden. Dies erleichtert die Interoperabilität zwischen verschiedenen .NET-Sprachen und ermöglicht es, Bibliotheken und Komponenten in verschiedenen Sprachen zu verwenden.

Frage: Welche Arten von Werttypen gibt es in C-Sharp?
Antwort: In C-Sharp gibt es verschiedene Arten von Werttypen, darunter die primitiven Typen (z. B. int, bool, double), Aufzählungstypen (enum) und vom Entwickler definierte Werttypen. Werttypen werden in C-Sharp mit dem Typkonstruktor "struct" erstellt und können Methoden und Konstruktoren haben, jedoch erlauben sie keine Typerweiterung oder Vererbung.

Frage: Welche Arten von Referenztypen gibt es in C-Sharp?
Antwort: In C-Sharp gibt es verschiedene Arten von Referenztypen, darunter Klassen, Interfaces, Arrays, Delegates und Attribut-Typen. Diese Referenztypen ermöglichen eine größere Vielfalt an Programmierkonzepten und -strukturen in C-Sharp.

Frage: Was sind Delegates in C-Sharp und wozu dienen sie?
Antwort: Delegates in C-Sharp sind Zeiger auf an ein Objekt gebundene einzelne Methoden. Sie ermöglichen es, Funktionen und Methoden als Parameter an andere Funktionen oder Methoden zu übergeben, was besonders nützlich für Problemstellungen wie Listener-Mechanismen ist. Delegates ersetzen die aus anderen Sprachen bekannten Funktionszeiger oder Funktionspointer.

Frage: Was ist Runtime Type Information (RTTI) in C++?
Antwort: Runtime Type Information (RTTI) ist eine Funktion in C++, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. RTTI ermöglicht die Ermittlung des Typs eines Objekts zur Laufzeit.

Frage: Was ist die Funktion dynamic_cast in C++?
Antwort: Die Funktion dynamic_cast<T>(x) in C++ nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt. Andernfalls gibt sie 0 zurück.

Frage: Was sind Zugriffsmethoden in EIFFEL und wofür werden sie verwendet?
Antwort: Zugriffsmethoden in EIFFEL sind Methoden, die verwendet werden, um auf private Instanzvariablen (Attribute) zuzugreifen. Sie dienen dazu, den Zugriff auf diese Variablen zu kontrollieren und bieten die Möglichkeit, Vor- und Nachbedingungen festzulegen.

Frage: Welche Aufgaben können Zugriffsmethoden in EIFFEL erfüllen?
Antwort: Neben dem Lesen und Setzen von Instanzvariablen können Zugriffsmethoden in EIFFEL auch andere Aufgaben erfüllen, wie das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen.

Frage: Was sind Features in EIFFEL und wie werden sie zusammengefasst?
Antwort: In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als "Features" bezeichnet. Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL.

Frage: Was ist das Besondere an der Definition einer Schnittstelle in EIFFEL?
Antwort: Die Definition einer Schnittstelle in EIFFEL ist recht unspezifisch. Alle Klienten einer Klasse haben standardmäßig das gleiche Bild von ihr. Statt den Zugriff an Pakete oder Freunde zu binden, bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (exportieren).

Frage: Was ist das Programmiermodell von EIFFEL?
Antwort: Das Programmiermodell von EIFFEL ist rein objektorientiert, bei dem der gesamte Code in Klassen organisiert ist. Diese Klassen können separat übersetzt werden, und die Ausführung erfolgt direkt auf der Zielmaschine.

Frage: Welche Methode verwendet EIFFEL zur Speicherfreigabe?
Antwort: EIFFEL verwendet Garbage Collection zur Speicherfreigabe.

Frage: Welche Art der Vererbung bietet C++ in Bezug auf Mehrfachvererbung?
Antwort: C++ bietet uneingeschränkte Mehrfachvererbung, was bedeutet, dass eine Klasse von mehreren anderen Klassen erben kann.

Frage: Was ist ein Nachteil der Mehrfachvererbung in C++?
Antwort: Ein Nachteil der Mehrfachvererbung in C++ ist, dass das Erben nicht selektiv erfolgt, und das Löschen von geerbten Membern nicht möglich ist. Dies führt oft dazu, dass Klassen in viele kleine Teile aufgespalten werden, um unnötigen Ballast zu vermeiden.

Frage: Welches Problem kann auftreten, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements erbt?
Antwort: Wenn eine Klasse in C++ von mehreren anderen Klassen verschiedene Definitionen desselben Elements (z. B. eines Feldes oder einer Methode) erbt, muss die Klasse sich für eine der beiden Definitionen entscheiden, und die andere geht verloren. Dies kann zu unerwartetem Verhalten führen, insbesondere im Zusammenhang mit dynamischem Binden und offener Rekursion.

Frage: Welche praktischen Probleme können sich aus der Mehrfachvererbung in C++ ergeben?
Antwort: Die Mehrfachvererbung in C++ kann zu zahlreichen praktischen Problemen führen, darunter die Auswahl von geerbten Definitionen, Konflikte bei gleichen Elementen in verschiedenen Elternklassen und unerwartetes Verhalten im Zusammenhang mit dynamischem Binden. Weitere Probleme können auftreten, sind jedoch in diesem Abschnitt nicht näher erläutert.

Frage: Welche Gemeinsamkeiten gibt es zwischen C-Sharp und Java in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen?
Antwort: C-Sharp und Java weisen in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen viele Gemeinsamkeiten auf. Die grundlegende Syntax und Struktur der beiden Sprachen sind ähnlich. In beiden Sprachen werden Klassen verwendet, um Objekte zu erstellen, Variablen und Ausdrücke zu definieren, Anweisungen auszuführen und Kontrollstrukturen zu steuern.

Frage: Welche Besonderheit gibt es in C-Sharp in Bezug auf die Überladung von Operatoren, und wie wird sie umgesetzt?
Antwort: In C-Sharp ist es möglich, Operatoren wie +, -, == usw. zu überladen. Dies wird durch das Schlüsselwort "operator" ermöglicht, das in einer Operatordefinition vorangestellt wird. Die Überladung von Operatoren erfolgt ähnlich wie die Definition von Methoden, aber anstelle von Methodennamen werden die Operatorzeichen verwendet.

Frage: Was ist "Call by reference" in C-Sharp, und wie unterscheidet es sich von "Call by value"?
Antwort: In C-Sharp ermöglicht "Call by reference" (auch als "ref" und "out" bekannt) das Übergeben von Argumenten an Methoden, bei denen die Änderungen an den Parametern innerhalb der Methode auf die ursprünglichen Argumente außerhalb der Methode angewendet werden. Im Gegensatz dazu verwendet "Call by value" Kopien der Argumente, und Änderungen innerhalb der Methode haben keine Auswirkungen auf die ursprünglichen Argumente.

Frage: Was sind die Unterschiede zwischen "ref" und "out" in Bezug auf Methodenparameter in C-Sharp?
Antwort: In C-Sharp werden "ref" und "out" verwendet, um formale Parameter zu kennzeichnen, die durch den Methodenaufruf modifiziert werden können. Der Hauptunterschied besteht darin, dass bei "ref" die übergebene Variable vor dem Aufruf initialisiert sein muss, während bei "out" dies nicht erforderlich ist. Bei "out" muss jedoch die formale Parameter in der Methode selbst einen Wert zugewiesen bekommen. Beide ermöglichen mehrere Rückgabewerte für Methoden.

Frage: Welche Unterschiede gibt es zwischen der Überschreibung von Methoden in C-Sharp im Vergleich zu Java?
Antwort: In C-Sharp müssen dynamisch zu bindende Methoden als "virtual" deklariert werden, und überschreibende Methoden müssen mit "override" gekennzeichnet sein. Wenn eine Methode in einer Subklasse neu eingeführt werden soll, wird "new" verwendet. Dies unterscheidet sich von Java, wo Methoden standardmäßig überschrieben werden können, es sei denn, sie sind als "final" deklariert. Diese Unterschiede sollen das sogenannte "Fragile-base-class-Problem" verhindern und die Programmiererin darüber informieren, welche Methoden dynamisch gebunden werden und welche nicht.

Frage: Welche anderen Unterschiede und Konventionen gibt es zwischen C-Sharp und Java in Bezug auf Sprachkonstrukte?
Antwort: Einige Unterschiede und Konventionen zwischen C-Sharp und Java umfassen die Verwendung von "lock" anstelle von "synchronized" für die Synchronisation, die Verwendung von "foreach" anstelle von "for" für bestimmte Schleifen, die Möglichkeit, "Strings" als Basis einer "Switch"-Anweisung zu verwenden, und die Anforderung, dass jeder Zweig (case) einer "Switch"-Anweisung mit einer expliziten Kontrollflussanweisung ("break", "goto", "return" oder "throw") abgeschlossen sein muss. C-Sharp verfügt auch über eine "Goto"-Anweisung, die jedoch nicht in Blöcke springen kann.

Frage: Was sind Indexer in C-Sharp und wie ähneln sie Properties?
Antwort: Indexer in C-Sharp sind eine Möglichkeit, auf indizierte Instanzvariablen zuzugreifen, ähnlich dem Konzept der indizierten Instanzvariablen in SMALLTALK. Jede Instanz einer Klasse mit einem Indexer hat eine Menge von indizierten Instanzvariablen, auf die über einen Index zugegriffen werden kann. Indexer verwenden Get- und Set-Methoden, um den Zugriff auf diese indizierten Variablen zu ermöglichen. Sie ähneln Properties insofern, als der Zugriff über einen Index mithilfe von Get- und Set-Abbildungen auf eine benannte Instanzvariable übertragen wird.

Frage: Welche Schwierigkeit ergibt sich aus der kovarianten Redefinition?
Antwort: Durch die kovariante Redefinition wird bei einem Funktionsaufruf von "share" dynamische Bindung verwendet, was dazu führt, dass ein Objekt vom Typ "GIRL" einem "BOY" zugewiesen wird. Dies führt zu einem Programmfehler, da das Programm nicht mehr typkorrekt ist.

Frage: Welche Unterschiede gibt es im Typsystem von EIFFEL im Vergleich zu anderen Sprachen wie Java?
Antwort: Im Gegensatz zu Java besitzt EIFFEL ein einheitliches Typsystem, bei dem keine separaten Referenz- und Werttypen unterschieden werden. EIFFEL unterscheidet auch nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden. Alle Operationen, einschließlich derer auf eingebauten Typen wie Integern, werden als Methoden behandelt.

Frage: Was ist ein herausragendes Merkmal des Typsystems von EIFFEL?
Antwort: Ein herausragendes Merkmal des Typsystems von EIFFEL ist die Unterstützung von Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden), sowie kovariante Redefinitionen, die durch "verankerte Typen" ermöglicht werden.

Frage: Welche Bedeutung haben "verankerte Typen" im Kontext von kovarianten Redefinitionen in EIFFEL?
Antwort: "Verankerte Typen" (engl. "anchored types") spielen im Kontext von kovarianten Redefinitionen in EIFFEL eine wichtige Rolle. Sie ermöglichen es, die Kovarianz bei der Redefinition von Methoden zu unterstützen und sind eine besondere Eigenschaft von EIFFEL.

Frage: Was sind einige der Eigenschaften des Typsystems von EIFFEL?
Antwort: Einige der prominenten Eigenschaften des Typsystems von EIFFEL sind Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen sowie die Unterstützung kovarianter Redefinitionen durch "verankerte Typen".

Frage: Welche Arten von Anweisungen gibt es in EIFFEL?
Antwort: In EIFFEL gibt es Anweisungen, die aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung bestehen.

Frage: Welche Prinzipien der Programmierung werden von EIFFEL strikt eingehalten?
Antwort: EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat.

Frage: Welche Besonderheit bietet das Exception Handling in EIFFEL?
Antwort: EIFFEL bietet ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet, insbesondere erlaubt es ein "Retry", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss.

Frage: Was ist die Besonderheit bezüglich der Verwendung des Semikolons in EIFFEL?
Antwort: In EIFFEL dient das Semikolon als Trennzeichen und ist kein Bestandteil einer Anweisung. Darüber hinaus kann es am Ende einer Zeile auch weggelassen werden, was dazu führt, dass kleine EIFFEL-Programme optisch aufgeräumt wirken.

Frage: Was sind Properties in C-Sharp und wie unterscheiden sie sich von Zugriffsmethoden (Settern und Gettern)?
Antwort: Properties in C-Sharp sind eine Möglichkeit, auf die Felder eines Objekts zuzugreifen, indem Methoden aufgerufen werden, die wie Feldzugriffe aussehen. Sie sind die Umkehrung von Zugriffsmethoden (Settern und Gettern) und ermöglichen es, Feldzugriffe mit Nebeneffekten zu versehen. In C-Sharp werden die Schlüsselwörter "get" und "set" verwendet, wobei "get" für den Lesezugriff und "set" für den Schreibzugriff verwendet wird. Die Variable "value" wird verwendet, um den Eingabewert eines Setters zu halten.

Frage: Welche Vorteile bieten Properties in C-Sharp im Vergleich zu direktem Feldzugriff?
Antwort: Properties in C-Sharp bieten den Vorteil, dass sie Feldzugriffe mit zusätzlicher Logik und Validierung versehen können. Sie machen den Code auf der Aufruferinnenseite knapper und besser lesbar, da sie wie Feldzugriffe aussehen und die Details der Implementierung verbergen. Außerdem ermöglichen sie die Simulation von Feldern mit Nur-Lese- oder Nur-Schreib-Zugriff, indem entweder der Getter oder der Setter weggelassen wird.

Frage: Was ist die spezielle Variable "value" in einem Property-Setter?
Antwort: Die spezielle Variable "value" in einem Property-Setter enthält den Eingabewert, der beim Setzen des Property-Werts übergeben wurde. Sie ermöglicht es, den neuen Wert zu verarbeiten und in das entsprechende Feld oder die entsprechende Variable zu schreiben. Dies ist besonders nützlich, um Validierungen oder Transformationen beim Schreibzugriff durchzuführen.

Frage: Welche Rolle spielt der Zuweisungsversuch bei kovarianten Redefinitionen in EIFFEL?
Antwort: Der Zuweisungsversuch spielt eine Rolle bei kovarianten Redefinitionen in EIFFEL, da er verwendet wird, um dynamische Bindungen programmatisch zu emulieren. Da EIFFEL polymorphe CAT-Calls verbietet, werden Zuweisungsversuche genutzt, um das dynamische Binden zu ermöglichen.

Frage: Welche Unterschiede gibt es zwischen Zuweisungsversuchen in EIFFEL und Downcasts in Java?
Antwort: Ein Unterschied besteht darin, dass Zuweisungsversuche in EIFFEL keinen Laufzeitfehler verursachen können, im Gegensatz zu Downcasts in Java. Allerdings kann "void" in einer Variable in EIFFEL zur Laufzeit eine Nullzeiger-Ausnahme auslösen.

Frage: Welche Rolle spielt die kovariante Redefinition in EIFFEL?
Antwort: In EIFFEL kann die kovariante Redefinition verwendet werden, um den Typ von Variablen automatisch mit dem Typ eines anderen, bereits typisierten Programms zu verknüpfen. Dies ermöglicht die automatische Anpassung von Typen bei Vererbung.

Frage: Welche Probleme ergeben sich aus der Verwendung von kovarianten Redefinitionen in EIFFEL?
Antwort: Die Verwendung von kovarianten Redefinitionen in EIFFEL kann zu Problemen führen, insbesondere wenn dynamische Bindungen auftreten. Dies kann dazu führen, dass Typen inkonsistent werden und unerwartetes Verhalten auftritt.

Frage: Welche Rolle spielen verankerte Typdeklarationen in EIFFEL?
Antwort: Verankerte Typdeklarationen in EIFFEL ermöglichen es, den Typ von Variablen automatisch an den Typ eines bereits typisierten Programms zu binden. Dies erleichtert die Verwendung von kovarianten Redefinitionen.

Frage: Was sind Tupel in EIFFEL und wofür werden sie verwendet?
Antwort: Tupel sind in EIFFEL eine relativ neue Funktion, die es ermöglicht, mehrere Objekte ohne die Notwendigkeit der Definition einer eigenen Klasse zu gruppieren. Sie sind besonders nützlich, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugewiesen wird. Tupel werden oft verwendet, wenn Methoden mehrere Werte zurückgeben sollen.

Frage: Welche Rolle spielen die Positionen und Positionsnamen in Tupeln?
Antwort: In Tupeln spielen die Positionen und gegebenenfalls die Positionsnamen eine wichtige Rolle. Sie dienen dazu, die Struktur des Tupels festzulegen und die Werte den richtigen Positionen zuzuordnen. Die Zuordnung eines Tupels zu einem Tupeltyp erfolgt durch den Abgleich der vorhandenen Positionen mit den deklarierten Positionstypen sowie gegebenenfalls den Positionsnamen.

Frage: Was ist das Friends-Konzept in C++?
Antwort: Das Friends-Konzept in C++ ermöglicht es, dass bestimmte Klassen auf private Elemente einer anderen Klasse zugreifen können, ohne direkte Mitglieder dieser Klasse zu sein.

Frage: Welchen Nachteil hat die Verwendung von Paketen in Java für die Zusammenarbeit von Klassen?
Antwort: In Java hatte man bis zur Version 8 die Möglichkeit, Klassen in ein Paket zu verfrachten, um die Zusammenarbeit von Klassen zu ermöglichen. Der Nachteil dabei ist, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben, was die Aufteilung der Klassen auf Pakete einschränken kann.

Frage: Was sind einige der zusätzlichen Merkmale von C-Sharp, die es im Vergleich zu Java enthält?
Antwort: C-Sharp enthält einige zusätzliche Merkmale von C++ sowie von Microsofts hauseigener Sprache, Visual Basic.

Frage: Was sind einige der Unterschiede im Typsystem von C-Sharp, die im Text erwähnt werden?
Antwort: Im Text werden die folgenden Unterschiede im Typsystem von C-Sharp im Vergleich zu Java erwähnt: Die Unterscheidung von Wert- und Referenztypen. Die verschiedenen Typkonstruktoren für Wert- und Referenztypen. Der Umgang mit Interfaces als Typen.

Frage: Welche weiteren Verbesserungen im Zusammenhang mit dem Typsystem von C-Sharp werden im Text erwähnt?
Antwort: Im Text wird erwähnt, dass C-Sharp noch eine ganze Reihe weiterer Verbesserungen im Zusammenhang mit dem Typsystem aufweist, jedoch wird auf diese Verbesserungen hier nur am Rande eingegangen, ohne sie im Detail zu erläutern.

Frage: Welches Programmiermodell wird in C++ verwendet?
Antwort: Das Programmiermodell von C++ ist ein klassisches Modell, bei dem Programme als eine Menge von Quellcode-Dateien geschrieben werden, die auf einer Zielmaschine direkt in ausführbaren Maschinencode übersetzt werden.

Frage: Was ist das Ziel von C++ in Bezug auf die Art von Anwendungen, die es unterstützt?
Antwort: C++ zielt auf die gleiche Klasse von Anwendungen wie C ab, insbesondere maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen, wobei extreme Speicher- und Recheneffizienz oft oberste Kriterien sind.

Frage: Was ist das Ziel des Typsystems von C++?
Antwort: Das Ziel des Typsystems von C++ ist, objektorientierte Programmierung mit starker Typsicherheit zu ermöglichen, während gleichzeitig die volle Freiheit der Programmiererin erhalten bleibt und der Laufzeit-Overhead minimiert wird.

Frage: Welche primitive Datentypen gibt es in C++?
Antwort: In C++ gibt es primitive Datentypen wie int, bool, etc. Diese Datentypen sind genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik.

Frage: Was ist ein Typumwandlung (Type cast) in C++?
Antwort: Eine Typumwandlung (Type cast) in C++ ist ein Ausdruck der Form <Typ> <Ausdruck>, der den Compiler davon überzeugt, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Diese Umwandlung wird vom Compiler überwacht, und die Zulässigkeit wird zur Laufzeit überprüft.

Frage: Welche Eigenschaften sollte eine typsichere Sprache haben?
Antwort: Eine typsichere Sprache wie C-Sharp soll strikte Typprüfungen durchführen, um sicherzustellen, dass Variablen nur Werte akzeptieren, die ihrem deklarierten Typ entsprechen.

Frage: Welcher Operator in C-Sharp entspricht dem instanceof-Operator in Java?
Antwort: In C-Sharp entspricht der Operator is dem instanceof-Operator in Java. Er prüft, ob das Ergebnis der Auswertung eines Ausdrucks mit einem gegebenen Typ T zuweisungskompatibel ist.

Frage: Wie werden Klassenfelder und -methoden in C++ deklariert?
Antwort: Klassenfelder und -methoden werden in C++ mit dem Schlüsselwort "static" in einer Klasse eingeführt, ähnlich wie in Java.

Frage: Wie erfolgt die Erzeugung von Objekten in C++ im Vergleich zu Java?
Antwort: In C++ erfolgt die Erzeugung von Objekten oft ohne "new". Der benötigte Speicherplatz wird bei der Deklaration reserviert, und es entstehen Werte (Objekte) mit Wertsemantik, im Gegensatz zu Java, wo "new" verwendet wird.

Frage: Wie erzeugt man in C++ Objekte mit Identität?
Antwort: Um in C++ Objekte mit Identität zu erzeugen, muss man Zeigervariablen (Pointer) verwenden und eine Klasse mit dem "new"-Operator instanziieren.

Frage: Wie sieht die Dereferenzierung eines Zeigers auf ein Objekt in C++ aus?
Antwort: In C++ erfolgt die Dereferenzierung eines Zeigers auf ein Objekt mit "->", z.B., "a->x" oder "a->f(x)" für ein Feld oder eine Methode der Klasse.

Frage: Wie kann in C++ "Call by reference" erreicht werden?
Antwort: In C++ kann "Call by reference" erreicht werden, indem man den Zeigeroperator "&" verwendet und die formalen Parameter so deklariert, dass sie Zeiger auf Zeiger aufnehmen können.

Frage: Wie wird das Varianzproblem bei der Subtypisierung von Containern in C-Sharp gelöst?
Antwort: In C-Sharp wird das Varianzproblem bei der Subtypisierung von Containern durch das Hinzufügen des Schlüsselworts "out" für kovariante Typparameter und "in" für kontravariante Typparameter bei der Definition des Typs gelöst. Dies stellt sicher, dass Zuweisungskompatibilität auch dann gegeben ist, wenn die generischen Typen verschiedene Typparameter haben.

Frage: Wie hat Microsoft versucht, das Problem der Kommunikation mit unbekannten Objekten auf der Ebene der Programmiersprache zu lösen?
Antwort: Microsoft hat versucht, das Problem der Kommunikation mit unbekannten Objekten teilweise von der Ebene der Programmierung auf die Ebene der Programmiersprache zu heben, indem sie das Konstrukt des Events (Ereignisses) eingeführt haben. Über Ereignisse können sogenannte Eventhandler aktiviert werden, die auf unerwartete Ereignisse reagieren können. Dies wurde mithilfe von Delegates realisiert, wie im Abschnitt 50.4.1 skizziert.

Frage: Wie wird in C-Sharp sichergestellt, dass explizite Interfaceimplementierungen von außen aufgerufen werden?
Antwort: In C-Sharp muss der tatsächliche deklarierende Typ des Objekts als Qualifikator für den Methodenaufruf angegeben werden, um sicherzustellen, dass die richtige explizite Interfaceimplementierung aufgerufen wird.

Frage: Wie werden in EIFFEL überschriebene Methoden bezeichnet?
Antwort: In EIFFEL werden überschriebene Methoden als "Redefinition" bezeichnet.

Frage: Wie können in EIFFEL Methoden mit demselben Namen in verschiedenen Klassen behandelt werden?
Antwort: In EIFFEL ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben, solange diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen. Wenn die Methoden gleiche oder kovariant redefinierte Parameter haben, handelt es sich nicht um Überladung, sondern um Überschreibung.

Frage: Wie kann in EIFFEL sichergestellt werden, dass geerbte Features mit demselben Namen unterschiedlich benannt werden?
Antwort: EIFFEL ermöglicht es, geerbte Features umzubenennen, indem eine "Rename"-Klausel verwendet wird. Diese Klausel erlaubt es, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen, ohne das dynamische Binden zu beeinflussen.

Frage: Wie unterscheidet sich das Programmiermodell von C-Sharp von dem von Java?
Antwort: Das Programmiermodell von C-Sharp weist zunächst einige Ähnlichkeiten mit dem von Java auf, da es ebenfalls auf Klassen basiert und der Code in einzelnen Klassen organisiert ist. Die Klassen in C-Sharp können jedoch in lockererem Verhältnis zu Dateien stehen, und Klassen können anders benannt werden als ihre Dateien. Ein wesentlicher Unterschied besteht darin, dass der Bytecode von C-Sharp und die zugehörige virtuelle Maschine, Common Intermediate Language (CIL) genannt, für alle .NET-Sprachen entwickelt wurden und nicht exklusiv für C-Sharp. Die CIL gilt als menschenlesbar.

Frage: Wie werden Vor- und Nachbedingungen in EIFFEL formuliert?
Antwort: Vor- und Nachbedingungen in EIFFEL werden als Boolesche Ausdrücke formuliert, die immer als "wahr" ausgewertet werden müssen. Die "require"-Klausel stellt Bedingungen dar, die vor dem Aufruf der Methode erfüllt sein müssen, während die "ensure"-Klausel Bedingungen darstellt, die nach dem Aufruf der Methode garantiert erfüllt sind.

Frage: Wie werden Zusicherungen in EIFFEL vererbt, insbesondere wenn eine Methode redefiniert wird?
Antwort: Zusicherungen, einschließlich Vor- und Nachbedingungen, werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen die Zusicherungen angepasst werden, jedoch mit bestimmten Einschränkungen. Die Vorbedingung darf nur abgeschwächt und die Nachbedingung nur verschärft werden, und die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingungen eingehalten werden.

Frage: Wie kann RTTI in C++ verwendet werden, um den Typ eines Objekts zu ermitteln?
Antwort: RTTI kann verwendet werden, indem die Funktion typeid auf eine Referenz aufgerufen wird. Diese Funktion ist auf Klassennamen überladen und gibt eine Struktur zurück, auf der == als Gleichheitstest definiert ist. Der Typ eines Objekts kann überprüft werden, indem typeid(x) == typeid(T) verwendet wird.

Frage: Wie kann in C++ ohne Verwendung von typeid herausgefunden werden, welcher Klasse Instanzen aller Klassen angehören?
Antwort: Eine Möglichkeit, den Typ einer Klasse in C++ ohne Verwendung von typeid herauszufinden, ist die Verwendung von dynamic_cast. Man kann versuchen, das Objekt auf verschiedene Klassen zu überprüfen, und wenn das Casting erfolgreich ist, gehört das Objekt zu dieser Klasse.

Frage: Wie werden Zugriffsmethoden in EIFFEL syntaktisch dargestellt?
Antwort: Zugriffsmethoden in EIFFEL sehen syntaktisch aus wie Variablen, können jedoch Funktionen (Setter) oder Funktionen (Getter) sein. Sie können verwendet werden, um Werte zu setzen oder zu lesen.

Frage: Wie werden in EIFFEL Abfragen und Befehle logisch unterteilt?
Antwort: In EIFFEL werden Methoden einer Klasse als "Abfragen" (queries) und "Befehle" (commands) logisch unterteilt. Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern.

Frage: Wie wird der Zugriff auf Features in EIFFEL kontrolliert?
Antwort: In EIFFEL wird der Zugriff auf Features durch die gezielte Veröffentlichung (Export) von Features gesteuert. Klassen, die auf diese Features zugreifen sollen, werden explizit genannt.

Frage: Wie unterscheidet sich EIFFEL von C++ in Bezug auf die Ausführungsumgebung?
Antwort: Im Gegensatz zu C++ führt EIFFEL den Code nicht auf einer virtuellen Maschine aus, sondern direkt auf der Zielmaschine. Es gibt jedoch auch eine Version von EIFFEL für .NET, die in CIL übersetzt und dann in Maschinencode ausgeführt wird.

Frage: Wie wird EIFFEL als Sprache häufig charakterisiert?
Antwort: EIFFEL wird als eine akademische Sprache charakterisiert, was bedeutet, dass sie in erster Linie in der akademischen Welt verwendet wird und möglicherweise weniger in kommerziellen Anwendungen anzutreffen ist.

Frage: Wie wird in EIFFEL ein Typtest durchgeführt?
Antwort: In EIFFEL wird ein Typtest mithilfe eines "Zuweisungsversuchs" (engl. "assignment attempt") durchgeführt. Wenn es keine Zuweisungskompatibilität zwischen den Typen gibt, wird "void" (entsprechend "nil" in SMALLTALK oder "null" in Java) zugewiesen. Die Programmiererin muss dann den Typ von "a" nach der Zuweisung überprüfen.

Frage: Wie definiert EIFFEL unparametrisierte und parametrisierte Klassen?
Antwort: In EIFFEL definiert jede unparametrisierte Klasse einen Typ, während jede parametrisierte Klasse eine (generische) Menge von Typen definiert.

Frage: Wie wird in EIFFEL zwischen Wert- und Referenztypen unterschieden?
Antwort: In EIFFEL kann bei der Deklaration angegeben werden, ob Variablen eines Typs Wertsemantik oder Referenzsemantik haben sollen. Dies kann für alle Variablen eines Typs oder nur für bestimmte Variablen festgelegt werden.

Frage: Wie könnte man die Kovarianzprobleme in EIFFEL verhindern?
Antwort: Es gibt verschiedene Ansätze, um die Kovarianzprobleme in EIFFEL zu verhindern, darunter die Beschränkung der Zuweisungskompatibilität, die Durchführung einer Typinferenz für das gesamte Programm und das Verbot dynamisch gebundener Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen ändern. Jede dieser Methoden hat jedoch ihre eigenen Einschränkungen und Herausforderungen.

Frage: Wie werden Tupeltypen in EIFFEL deklariert?
Antwort: Tupeltypen in EIFFEL werden deklariert, indem für jede Position im Tupel ein Typ angegeben wird. Konkrete Werte eines Tupels werden in eckigen Klammern notiert, wobei die Positionen optional auch Namen erhalten können.

Frage: Wie wird in C++ festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen?
Antwort: In C++ wird festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen, indem man die betreffenden Klassen mit dem Schlüsselwort "friend" in der Zielsklasse deklariert. Zum Beispiel: friend class B; und friend class C;

Frage: Wie wird das Friends-Konzept in Java angenähert?
Antwort: Das Friends-Konzept wird in Java durch die Verwendung von Modulen und den dedizierten (qualifizierten) Export auf Ebene der Pakete angenähert. Dies ermöglicht eine kontrollierte Freigabe von Elementen an bestimmte Pakete.

Frage: Wie ermöglicht C++ die getrennte Übersetzung von Programmteilen?
Antwort: C++ ermöglicht die getrennte Übersetzung von Programmteilen mithilfe von Header-Dateien, die die Schnittstellen der Teile enthalten.

Frage: Wie erfolgt die Methodenbindung in C++ standardmäßig?
Antwort: Standardmäßig erfolgt die Methodenbindung (Methodenaufruf) in C++ statisch. Das bedeutet, dass die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable hat.

Frage: Wann werden Methoden in C++ zur Laufzeit dynamisch gebunden?
Antwort: In C++ werden Methoden zur Laufzeit dynamisch gebunden, wenn sie mit dem Schlüsselwort virtual deklariert sind. Bei virtuellen Methoden wird zur Laufzeit überprüft, welchen Typs das Objekt ist, und zur entsprechenden Methodenimplementierung verzweigt.

Frage: Wie wird Generizität in C++ implementiert?
Antwort: Generizität in C++ wird mit Hilfe von Templates erreicht. Ein Template ist ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Tatsächlich werden aus Templates neue Typen erzeugt, und für jede Instanz eines generischen Typs wird ein neuer Typ erzeugt und kompiliert.

Frage: Wie wird die Zulässigkeit von Typumwandlungen in C++ überprüft?
Antwort: Die Zulässigkeit von Typumwandlungen in C++ wird zur Laufzeit überprüft, und sie kann nicht zur Kompilierzeit überprüft werden. Typumwandlungen sollten vermieden werden, da sie die Typsicherheit untergraben können.

Frage: Wie kann in C-Sharp eine Typumwandlung (Casting) durchgeführt werden?
Antwort: In C-Sharp kann eine Typumwandlung mithilfe von Casts durchgeführt werden. Die Syntax dafür ist (T)a;, wobei T der Zieltyp ist und a der Ausdruck, der umgewandelt werden soll.

Frage: Wie wird in C-Sharp sichergestellt, dass ein Cast sicher ist?
Antwort: In C-Sharp wird ein Cast sicher gemacht, indem der is-Operator verwendet wird, um zu prüfen, ob die Zuweisung kompatibel ist. Zusätzlich kann der as-Operator verwendet werden, der bei fehlschlagender Zuweisung null zurückgibt.

Frage: Was enthält eine C++ Klasse neben Feldern (Instanzvariablen)?
Antwort: Eine C++ Klasse enthält neben Feldern (Instanzvariablen) auch Methoden.

Frage: Gibt es in C++ die Möglichkeit, "Call by reference" ohne Verwendung des Zeigeroperators "&" zu erreichen?
Antwort: Ja, in C++ gibt es die Möglichkeit, "Call by reference" ohne Verwendung des Zeigeroperators "&" zu erreichen, ähnlich wie in Pascal. Hierbei bleiben die Aufrufstellen unverändert.

Frage: Was unterscheidet Generics in C-Sharp und Generics in Java?
Antwort: Obwohl die Oberfläche von C-Sharp Generics der von Java ähnelt, unterscheidet sich der Mechanismus dahinter. C-Sharp instanziiert generische Klassen für Werttypen (wie int oder selbst definierte structs) für jeden verwendeten Typ, während Java Typparameter grundsätzlich immer entfernt (Type Erasure) und nur eine Implementierung erzeugt.

Frage: Bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten?
Antwort: Ja, in C-Sharp bleibt die generische Typinformation auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.

Frage: Gibt es in C-Sharp eine Möglichkeit zur Typparameter-Inferenz bei generischen Methodenaufrufen?
Antwort: Ja, C-Sharp unterstützt Typparameter-Inferenz, was bedeutet, dass der Compiler den tatsächlichen Typparameter bei generischen Methodenaufrufen automatisch aus den Argumenten ableiten kann. Dies führt zu weniger Code und erhöht die Lesbarkeit.

Frage: Warum wird C++ als "sofortige Legacy"-Sprache bezeichnet?
Antwort: C++ wird als "sofortige Legacy"-Sprache bezeichnet, weil sie eine Erweiterung von C ist und eine chaotische Syntax hat, die es schwer macht, den Code zu verstehen oder zurückzuentwickeln. Außerdem gibt es viele große Projekte, die bereits in veralteten C++-Dialekten geschrieben wurden.

Frage: Warum wird darauf hingewiesen, dass C++ eine Erweiterung von C ist?
Antwort: Es wird darauf hingewiesen, dass C++ eine Erweiterung von C ist, um zu betonen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist. Dies bedeutet, dass C++-Code mit C-Code kombiniert werden kann und C++-Programmierer auf bestehende C-Bibliotheken zugreifen können.

Frage: Warum wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann?
Antwort: Es wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann, um zu betonen, dass die Lesbarkeit des Codes in C++ stark von der Programmierpraxis abhängt. C++ bietet die Flexibilität, Code auf unterschiedliche Weisen zu schreiben, von sehr lesbar bis hin zu sehr unlesbar, je nach den Entscheidungen der Entwickler.

Frage: Warum benötigen viele Applikationen, insbesondere solche mit GUI, eine Kommunikation mit unbekannten Objekten?
Antwort: Viele Applikationen benötigen eine Kommunikation mit unbekannten Objekten, da sie neben der direkten Kommunikation zwischen Objekten, die sich kennen, auch mit anderen Objekten kommunizieren müssen, die nicht im Voraus bekannt sind. Dies tritt insbesondere in Anwendungen mit grafischer Benutzeroberfläche (GUI) auf, wo verschiedene Elemente miteinander interagieren müssen, ohne im Voraus genau zu wissen, welche Objekte diese Interaktion benötigen.

Frage: Was passiert, wenn man versucht, eine explizite Interfaceimplementierung mit einem anderen Zugriffsmodifikator als "public" zu deklarieren?
Antwort: In C-Sharp ist es möglich, Methoden von expliziten Interfaceimplementierungen mit Zugriffsmodifikatoren, die nicht "public" sind, von außen aufzurufen. Dies ist jedoch an die explizite Implementierung gebunden und erfordert die Verwendung des richtigen Interfacequalifikators.

Frage: Können explizite Interfaceimplementierungen in C-Sharp überschrieben werden?
Antwort: Nein, explizite Interfaceimplementierungen können nicht überschrieben werden. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut.

Frage: Gibt es eine Namenskonvention für Interfaces in C-Sharp?
Antwort: Ja, im Common Type System von .NET sollten alle Interfacenamen mit einem "I" beginnen. Dies dient zur Unterscheidung von Interface- und Klassennamen und folgt der Tradition der ungarischen Notation bei Microsoft.

Frage: Warum wurde in C-Sharp das Hantieren mit Pointern wieder eingeführt, und wie werden unsichere Bereiche behandelt?
Antwort: In C-Sharp wurde das Hantieren mit Pointern in unsichere Bereiche verbannt, weil es in systemnahen Programmierungen und beim Zugriff auf das Betriebssystem notwendig ist. Der Modifikator "unsafe" kennzeichnet solche unsicheren Bereiche und wird verwendet, um den Einsatz von Pointern zu ermöglichen. In unsicheren Bereichen können Zeiger auf Typen deklariert werden, und die Dereferenzierung eines Zeigers erfolgt mit einem Stern (*). Dies ermöglicht das Hantieren mit Pointern in einem begrenzten und kontrollierten Umfeld.

Frage: Warum wird C++ als eine sehr komplexe Sprache beschrieben?
Antwort: C++ wird als eine sehr komplexe Sprache beschrieben, weil ihre Beherrschung Jahre dauern kann, selbst bei täglichem Umgang mit ihr. Die eigentliche Komplexität ergibt sich aus der kombinierten Verwendung ihrer zahlreichen Konstrukte, und die Möglichkeiten sind vielfältig.

Frage: Warum ist es schwer, C++ zu lehren?
Antwort: Es ist schwer, C++ zu lehren, weil die Sprache sehr komplex ist und die Kombinatorik ihrer Konstrukte zu einer hohen Zahl von Möglichkeiten führt. Die Vielzahl von Idiomen (Wendungen) in C++ trägt ebenfalls zur Komplexität bei.

Frage: Warum ist es schwierig, die Komplexität von C++ von der Objektorientierung zu trennen?
Antwort: Es ist schwierig, die Komplexität von C++ von der Objektorientierung zu trennen, weil viele Beiträge zur Komplexität von C++ in Zusammenhang mit der Objektorientierung stehen. Die Kombination von objektorientierten Konzepten und anderen Sprachmerkmalen macht C++ zu einer komplexen Sprache.

Frage: Was wird als mögliche Gefahr hinsichtlich der Entwicklung von C-Sharp und Java erwähnt?
Antwort: Als mögliche Gefahr wird erwähnt, dass die beiden Sprachen sich gegenseitig übertrumpfen könnten. Es besteht die Möglichkeit, dass jemand auf die Idee kommt, die besten Eigenschaften beider Sprachen zu kombinieren und eine neue Sprache zu entwickeln. Dies könnte auch eine Gelegenheit sein, sich von den Syntax-Erben aus der C-Welt zu verabschieden.

Frage: Warum könnte EIFFEL trotz seiner Funktionen kein größerer Erfolg geworden sein?
Antwort: Es gibt mehrere mögliche Gründe für den begrenzten Erfolg von EIFFEL. Dies könnte auf unzureichende Implementierungen der Werkzeuge, die Kompromisslosigkeit des Schöpfers BERTRAND MEYER und den Spagat zwischen kommerzieller Anwendbarkeit und akademischer Eignung zurückzuführen sein. Auch das Typsystem von EIFFEL und akademische Vorbehalte gegenüber bestimmten Programmierweisen könnten eine Rolle spielen. Trotzdem hat EIFFEL Einfluss auf die Art und Weise, wie über das Programmieren nachgedacht wird.

Frage: Gibt es in C-Sharp einen Unterschied zwischen Wert- (primitiven) und Referenztypen wie in Java?
Antwort: In C-Sharp wird zunächst nicht zwischen Wert- (primitiven) und Referenztypen wie in Java unterschieden. Alle Typen, einschließlich der primitiven Typen, gelten als von Object (genauer: System.Object) abgeleitet.

Frage: Bietet C++ eine dynamische Typprüfung wie andere Sprachen?
Antwort: Nein, C++ bietet keine eingebaute dynamische Typprüfung.

Frage: Warum wissen einige Objekte in C++, von welcher Klasse sie eine Instanz sind?
Antwort: Einige Objekte in C++ wissen zumindest im Prinzip, von welcher Klasse sie eine Instanz sind, weil sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Diese virtuelle Funktionstabelle dient als eine Art Repräsentation der Klasse.

Frage: Gibt es in EIFFEL Zugriffsmodifikatoren wie in Java oder C++?
Antwort: Nein, es gibt in EIFFEL keine Zugriffsmodifikatoren wie in Java oder C++. Alle Features sind standardmäßig öffentlich zugänglich.

Frage: Bietet EIFFEL spezielle Konstrukte zur Leistungsoptimierung?
Antwort: Nein, EIFFEL sieht keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Die Performance-Verbesserungen werden vollständig einem optimierenden Compiler überlassen.

Frage: Warum kann Mehrfachvererbung in C++ sinnvoll sein?
Antwort: Mehrfachvererbung kann aus verschiedenen Gründen sinnvoll sein: Eine Klasse kann von mehreren vollständig abstrakten Klassen erben und damit mehrere Interfaces implementieren. In Aufgabenstellungen, in denen eine Klasse Eigenschaften von mehreren anderen Klassen benötigt, erlaubt Mehrfachvererbung, alle benötigten Eigenschaften zu erben, anstatt sich für eine einzige Superklasse entscheiden zu müssen.

Frage: Warum gibt es in C-Sharp keine "Throws"-Klauseln in Methodendeklarationen, wie sie in Java existieren?
Antwort: C-Sharp verzichtet auf "Throws"-Klauseln in Methodendeklarationen, die in Java zur Unterscheidung von Checked Exceptions und Unchecked Exceptions verwendet werden. Stattdessen gibt es in C-Sharp nur Unchecked Exceptions. Diese Entscheidung wurde getroffen, um die Programmierer nicht dazu zu zwingen, im Voraus zu wissen, was in jeder Methode schief gehen kann. Es gibt jedoch Möglichkeiten, Exception-Handling in C-Sharp durch "Exception chaining" und "Exception tunneling" zu implementieren.

Frage: Können Indexer in C-Sharp überladen werden und mehrere indizierte Instanzvariablen simulieren?
Antwort: Ja, Indexer in C-Sharp können überladen werden, um mehrere indizierte Instanzvariablen zu simulieren. Dies ermöglicht einem Objekt, mehrere indizierte Variablen mit unterschiedlichen Indexen zu haben. Die Einschränkung dabei ist, dass der Rückgabetyp (Elementtyp) beim Überladen gleich bleiben muss. Indexer können auch berechnete Werte zurückgeben, ohne auf interne Instanzvariablen zuzugreifen, ähnlich wie Properties.

Frage: Warum wird in EIFFEL eine kovariante Redefinition benötigt?
Antwort: In EIFFEL wird eine kovariante Redefinition benötigt, um die Unterkunft der jungen Skifahrerinnen nach Geschlechtern getrennt zu organisieren. Dies ermöglicht es, Mädchen und Jungen unterschiedliche Typen für "roommate" zuzuweisen.

Frage: Warum führt die implizite Allquantifizierung einer Deklaration zu einem Fehler?
Antwort: Die implizite Allquantifizierung einer Deklaration wie "SKIER.share(SKIER)" bedeutet nicht, dass alle Skifahrerinnen (beider Geschlechter) ihr Zimmer mit allen Skifahrerinnen teilen können. Dies ist aufgrund von Faktoren wie Krankheit nicht immer möglich. Die statische Typisierung kann solche situativen Unterschiede nicht abbilden.

Frage: Warum sind Typtests in EIFFEL manchmal notwendig?
Antwort: Typtests in EIFFEL sind manchmal notwendig, um festzustellen, welchen genauen Typ ein Element hat, das in einen Container (eine Variable oder eine Collection) ungleichen Typs gelegt wurde. Dadurch kann das Element entsprechend seines Typs verwendet werden.

Frage: Gibt es in EIFFEL explizite Typumwandlungen wie in anderen Sprachen?
Antwort: In EIFFEL gibt es keine expliziten Typumwandlungen wie in einigen anderen Sprachen. Die Typumwandlung erfolgt immer in Verbindung mit einer Zuweisung.

Frage: Was unterscheidet Werttypen und Referenztypen in EIFFEL?
Antwort: Anders als in C-Sharp unterscheidet EIFFEL nicht zwischen Wert- und Referenztypen auf der Ebene von Typkonstruktoren. Stattdessen kann es für jeden Typ sowohl Wertsemantik als auch Referenzsemantik geben.

Frage: Warum ist das Friends-Konzept in C++ nützlich?
Antwort: Das Friends-Konzept ist nützlich, wenn ein Teilproblem in der Programmierung nicht von einer einzelnen Klasse gelöst werden kann, sondern die Zusammenarbeit mehrerer Klassen erfordert. Es ermöglicht, dass diese Klassen eng zusammenarbeiten können, ohne dass alle Klassen dieselbe Schnittstelle haben müssen.

Frage: Gibt es in C++ die Möglichkeit, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren?
Antwort: Nein, in C++ ist es nicht möglich, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren. Stattdessen erlaubt das Friends-Konzept, dass bestimmte Klassen auf alle privaten Elemente einer anderen Klasse zugreifen können.

Frage: Warum wurde C-Sharp entwickelt?
Antwort: Die Entwicklung von C-Sharp wurde weniger als Versuch betrachtet, mit Microsofts Marktmacht einen proprietären Standard durchzusetzen, sondern war vielmehr dem Umstand geschuldet, dass Java keine volle Kontrolle über Hardware und Betriebssystem bietet und somit nicht für jede kommerzielle Softwareentwicklung geeignet ist.

Frage: In welchen wesentlichen Punkten unterscheidet sich das Typsystem von C-Sharp von dem von Java?
Antwort: Das Typsystem von C-Sharp unterscheidet sich von Java in mehreren wesentlichen Punkten, darunter die Art der Unterscheidung von Wert- und Referenztypen, die angebotenen Typkonstruktoren für Wert- und Referenztypen und den Umgang mit Interfaces als Typen.

Frage: Warum ist es wichtig, verschiedene objektorientierte Programmiersprachen zu kennen?
Antwort: Es ist wichtig, verschiedene objektorientierte Programmiersprachen zu kennen, da Praktikerinnen und solche, die es werden wollen, die Programmiersprachen kennen müssen, die auf dem Markt gefragt sind. Dies ermöglicht es ihnen, in verschiedenen beruflichen Situationen flexibel zu sein und die am besten geeignete Sprache für bestimmte Aufgaben auszuwählen.

Frage: Was ermöglicht Mehrfachvererbung in C++?
Antwort: Mehrfachvererbung in C++ ermöglicht es, eine Klasse von mehreren anderen abzuleiten. Dadurch kann eine Klasse mehrere direkte Supertypen haben, einen pro direkte Superklasse.

Frage: Was passiert, wenn eine Typumwandlung in C-Sharp nicht möglich ist?
Antwort: Wenn eine Typumwandlung in C-Sharp nicht möglich ist, weil der tatsächliche Typ des Ausdrucks a kein Subtyp von T ist oder keine entsprechende Typumwandlung definiert ist, führt dies zu einem Laufzeitfehler.
