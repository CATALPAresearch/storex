13.1 Pflegen von Zu-n-Beziehungen

Um Zu-n-Beziehungen zu pflegen, also Objekte zu einer Beziehung hinzuzufügen und wieder zu entfernen, sieht SMALLTALK standardmäßig die Methoden add: und remove: vor, die beide jeweils das Argumentobjekt zurückliefern. Beide sind in der abstrakten Klasse Collection definiert, die Wurzel einer Hierarchie von Klassen, den Collection-Klassen, ist, die allesamt der Verwirklichung von : n-Beziehungen dienen. Unsere Zwischenobjekte, die diese Beziehungen repräsentieren, sind also alle indirekte Instanzen von Collection. Die Methoden add: und remove: bleiben zunächst (in Collection) abstrakt. Da sie von der tatsächlichen Realisierung einer Collection abhängen, können sie erst in den entsprechenden Subklassen (durch Überschreiben) realisiert werden.


Frage: Wofür werden die Methoden add: und remove: in SMALLTALK verwendet?
Antwort: Die Methoden add: und remove: werden in SMALLTALK verwendet, um Zu-n-Beziehungen zu pflegen, also Objekte zu einer Beziehung hinzuzufügen und wieder zu entfernen. Beide Methoden geben das Argumentobjekt zurück.

Beim Entfernen eines Objektes aus einer Collection mittels remove: gibt es zwei Sonderfälle zu berücksichtigen: Das Objekt ist nicht vorhanden oder das Objekt ist mehrfach vorhanden. Im ersten Fall wird ein Fehler gemeldet, während im zweiten Fall nur ein Vorkommen des Objekts aus der Collection entfernt wird (das erste, wie auch immer die Reihenfolge festgelegt ist). Da es immer vorkommen kann, dass ein zu entfernendes Objekt gar nicht vorhanden ist, und ein entsprechender vorheriger Test auf Vorhandensein (siehe unten) wieder eine stereotype Handlung ist, bietet SMALLTALK eine Variante von remove:, die einem genau das erspart: remove: anObject ifAbsent: anExceptionBlock. Sollte das zu entfernende Objekt fehlen, wird stattdessen anExceptionBlock ausgeführt, und dessen Ergebnis wird zurückgeliefert. Will man, dass beim Versuch, ein nicht vorhandenes Objekt zu entfernen, nichts passiert, so gibt man einfach den leeren Block [] für anExceptionBlock an. Sollen mehrere Objekte auf einmal einer Beziehung hinzugefügt bzw. daraus entfernt werden, so stehen hierfür die Methoden addAll: aCollection bzw. removeAll: aCollection zur Verfügung, die jeweils eine Collection als Parameter erwarten.


Frage: Was passiert, wenn man versucht, ein nicht vorhandenes Objekt aus einer Collection zu entfernen?
Antwort: Wenn man versucht, ein nicht vorhandenes Objekt aus einer Collection zu entfernen, wird ein Fehler gemeldet.

Frage: Was ist die Lösung für das Problem, dass beim Entfernen eines Objekts aus einer Collection ein Fehler gemeldet wird, wenn das Objekt nicht vorhanden ist?
Antwort: Die Lösung ist die Verwendung der Methode remove: anObject ifAbsent: anExceptionBlock, die einen Block ausführt, wenn das zu entfernende Objekt nicht vorhanden ist.


Es ist wichtig zu beachten, dass es sich bei den entsprechenden Instanzen prinzipiell um eigenständige Objekte handelt, die hier lediglich die Funktion eines Zwischenobjektes haben, um die Beziehungen zu realisieren. Subklassen von Collection müssen also die Methoden add: und remove:ifAbsent: überschreiben. Dabei offenbart sich gleich ein Charakterzug von SMALLTALK: Da seine Klassenhierarchie keine Generalisierungshierarchie ist, kommt es vor, dass Subklassen die Methoden add:, remove: und remove:ifAbsent: löschen. Während beispielsweise in der Klasse OrderedCollection add: und remove:ifAbsent: überschrieben werden, werden sie in der Klasse FixedSizeCollection, die ebenfalls eine Subklasse von Collection ist, gelöscht.


Frage: Was ist der Charakterzug von SMALLTALK, der sich in der Klassenhierarchie zeigt?
Antwort: Der Charakterzug von SMALLTALK ist, dass seine Klassenhierarchie keine Generalisierungshierarchie ist. Das bedeutet, dass Subklassen die Methoden add:, remove: und remove:ifAbsent: löschen können, obwohl sie in der Oberklasse Collection definiert sind.

Frage: Warum können Subklassen von Collection in Smalltalk Methoden löschen?
Antwort: In Smalltalk ist die Klassenhierarchie keine Generalisierungshierarchie, was bedeutet, dass Subklassen nicht verpflichtet sind, die Methoden ihrer Superklassen zu implementieren. Sie können sie sogar löschen, wenn sie dies für nicht notwendig erachten. Dies ist beispielsweise in der Klasse FixedSizeCollection der Fall, die Methoden add:, remove: und remove:ifAbsent: löscht, die in der Klasse Collection definiert sind.


Die Methoden add: und remove: werden durch die Methoden addAll: und removeAll: komplettiert; die Implementierung von addAll: können Sie den Zeilen 427–431 oben entnehmen, removeAll: verläuft im Prinzip analog (warum SMALLTALK EXPRESS hier eine Kopie zurückgibt, weiß ich nicht). Die Methode addAll: wird dazu benutzt, eine Collection in eine andere zu konvertieren. Dabei ist addAll: nur einmal, nämlich in Collection, definiert. Man beachte, dass dabei ein Objekt nicht seine Klasse wechselt, sondern lediglich der Inhalt einer Collection in eine neue übertragen wird. Diese Übertragung ist immer dann sinnvoll, wenn die Klasse der neuen Collection Eigenschaften hat, die man gern nutzen möchte. Ein Beispiel hierfür finden Sie in Zeile 525 unten. Die Nachricht yourself (von Object geerbt) liefert übrigens ihren Empfänger zurück; sie wird am Ende von kaskadierten Nachrichtenausdrücken in Return-Anweisungen verwendet, um den Empfänger zurückzuliefern.


Frage: Was macht die Nachricht addAll:?
Antwort: Die Nachricht addAll: fügt alle Elemente einer Collection zu einer anderen Collection hinzu. Sie ist nur in der Klasse Collection definiert.


Zum Pflegen seiner Beziehungen ist es manchmal vorteilhaft, zu wissen, mit wie vielen Objekten man in Beziehung steht und mit welchen. Die Klasse Collection sieht dafür die Methoden size, isEmpty und notEmpty, includes: sowie occurencesOf: vor, die jeweils die naheliegende Bedeutung haben.


Frage: Was können die Methoden size, isEmpty und notEmpty, includes: sowie occurencesOf: in der Klasse Collection tun?
Antwort: Diese Methoden können verwendet werden, um die Anzahl der Objekte in einer Kollektion zu ermitteln, zu überprüfen, ob eine Kollektion leer ist oder nicht, zu überprüfen, ob ein bestimmtes Objekt in der Kollektion enthalten ist, und die Anzahl der Vorkommen eines bestimmten Objekts in der Kollektion zu ermitteln.
