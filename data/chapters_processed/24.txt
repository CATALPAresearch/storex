24 Typkonformität

Einen Typ, dessen Definition alle deklarierten Elemente der Definition eines anderen Typen enthält, nennt man mit dem anderen typkonform. So ist InternationalesBüro im obigen Beispiel mit Büro typkonform. Typkonformität ist in vielen Sprachen eine notwendige und hinreichende Voraussetzung für die Zuweisungskompatibilität: Es darf dann ein Objekt vom Typ InternationalesBüro einer Variable vom Typ Büro zugewiesen werden.


Frage: Was bedeutet es, wenn ein Typ mit einem anderen typkonform ist?
Antwort: Wenn ein Typ mit einem anderen typkonform ist, bedeutet das, dass die Definition dieses Typs alle deklarierten Elemente der Definition des anderen Typs enthält.

Frage: Was ist Typkonformität?
Antwort: Typkonformität ist eine Beziehung zwischen zwei Typen, bei der die Definition des einen Typs alle deklarierten Elemente der Definition des anderen Typs enthält. In vielen Programmiersprachen ist Typkonformität eine notwendige und hinreichende Voraussetzung für die Zuweisungskompatibilität.


Typkonformität ist aber reflexiv, d.h., jeder Typ ist konform zu sich selbst. Sie ist weiterhin transitiv: Wenn A typkonform zu B ist und B typkonform zu C, dann ist auch A typkonform zu C. Wie man sich leicht denken kann, ist die Typkonformität jedoch im Gegensatz zur Typäquivalenz nicht symmetrisch: Aus der Tatsache, dass ein Typ B typkonform zu einem Typ A ist, folgt nicht, dass auch A typkonform zu B ist. Vielmehr ist dies mit einer kleinen Ausnahme sogar zwingend nicht der Fall: Typkonformität ist meistens antisymmetrisch, was bedeutet, dass wenn B zu A und A zu B typkonform ist, dann müssen A und B identisch sein.


Frage: Was ist Typkonformität?
Antwort: Typkonformität ist ein Begriff in der Typentheorie, der angibt, dass ein Typ A zu einem anderen Typ B konform ist, wenn ein Wert vom Typ A in einem Kontext, in dem ein Wert vom Typ B erwartet wird, verwendet werden kann, ohne dass es zu einer Typenverletzung kommt. Typkonformität ist reflexiv und transitiv, aber nicht symmetrisch. Sie ist meistens antisymmetrisch, was bedeutet, dass wenn B zu A und A zu B typkonform ist, dann müssen A und B identisch sein.

Frage: Was bedeutet die Antisymmetrie der Typkonformität?
Antwort: Die Antisymmetrie der Typkonformität bedeutet, dass wenn ein Typ B typkonform zu einem Typ A ist und A zu B typkonform ist, dann müssen A und B identisch sein. Das heißt, dass es keine zwei verschiedenen Typen geben kann, die beide typkonform zu einander sind.


Von der Typkonformität gibt es, genau wie von der Typäquivalenz, zwei Varianten, nämlich eine strukturelle Typkonformität und eine namensgebundene (nominale) Typkonformität. Zur strukturellen Typkonformität reicht es aus, wenn der konforme Typ wie oben alle Elemente des Typs, zu dem er konform sein soll, enthält.


Frage: Was ist strukturelle Typkonformität?
Antwort: Strukturelle Typkonformität bedeutet, dass der konforme Typ alle Elemente des Typs, zu dem er konform sein soll, enthält.

Frage: Was ist namensgebundene Typkonformität?
Antwort: Namensgebundene Typkonformität bedeutet, dass der konforme Typ nicht nur die Elemente des Typs, zu dem er konform sein soll, enthält, sondern dass er auch ausdrücklich als konform zu diesem Typ erklärt wurde.

Frage: Wie wird Typkonformität in der objektorientierten Programmierung gehandhabt?
Antwort: In der objektorientierten Programmierung wird die Typkonformität in der Regel namensgebunden gehandhabt.

Frage: Warum ist strukturelle Typkonformität in der objektorientierten Programmierung weniger gebräuchlich?
Antwort: Strukturelle Typkonformität ist in der objektorientierten Programmierung weniger gebräuchlich, weil sie die statische Typisierung untergraben würde.

Frage: Was ist statische Typisierung?
Antwort: Statische Typisierung ist eine Eigenschaft von Sprachen, die die

Frage: Was ist der Unterschied zwischen struktureller Typkonformität und namensgebundener Typkonformität?
Antwort: Strukturelle Typkonformität besteht, wenn der konforme Typ alle Elemente des Typs, zu dem er konform sein soll, enthält. Nominale Typkonformität hingegen bezieht sich auf die Übereinstimmung von Typnamen, unabhängig davon, ob die Typen strukturell identisch sind oder nicht.


Für die nominale Konformität muss zusätzlich und explizit die Erweiterung eines (oder Ableitung von einem) anderen Typ angegeben werden. Da bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben, folgt die Konformität aus der Erweiterung.


Frage: Was bedeutet nominale Konformität?
Antwort: Nominale Konformität bedeutet, dass für die Konformität einer Erweiterung nicht nur die Struktur, sondern auch der Name des Typs, der erweitert wird, explizit angegeben werden muss.

Frage: Warum folgt die Konformität aus der Erweiterung?
Antwort: Die Konformität folgt aus der Erweiterung, weil bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben.


Nun ist die Teilmengenbeziehung reflexiv, was auf die Typerweiterung übertragen bedeutet, dass ein Typ eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.


Frage: Was bedeutet es, wenn ein Typ reflexiv ist?
Antwort: Wenn ein Typ reflexiv ist, bedeutet das, dass er eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.

Frage: Was bedeutet es, wenn ein Typ eine Erweiterung eines anderen ist, ohne tatsächlich etwas hinzuzufügen?
Antwort: In diesem Fall spricht man von Typerweiterung, bei der ein Typ eine Untermenge eines anderen Typs ist und somit alle Eigenschaften und Methoden des übergeordneten Typs besitzt, aber keine zusätzlichen Eigenschaften oder Methoden hinzufügt. Dies ist eine reflexive Beziehung, was bedeutet, dass ein Typ auch sich selbst als Untertyp haben kann.


Typäquivalenz impliziert übrigens, jeweils für die nominale und die strukturelle Form getrennt, Typkonformität: Zwei äquivalente Typen sind auch immer konform. Das Umgekehrte ist jedoch meistens nicht der Fall: Zwar ist ein Typ, der angibt, einen anderen zu erweitern, ohne jedoch etwas hinzuzufügen, zu dem anderen strukturell äquivalent, aber nominal schon nicht mehr; sobald etwa hinzugefügt wird, ist es mit der Äquivalenz sowieso vorbei.


Frage: Was bedeutet Typäquivalenz?
Antwort: Typäquivalenz bedeutet, dass zwei Typen in ihrer nominalen oder strukturellen Form übereinstimmen und somit Typkonformität implizieren, also austauschbar sind.

Frage: Was ist der Unterschied zwischen nominaler und struktureller Typäquivalenz?
Antwort: Nominale Typäquivalenz bezieht sich auf die Übereinstimmung von Typnamen, während strukturelle Typäquivalenz die Übereinstimmung der Typstruktur betrifft.

Frage: Was bedeutet Typkonformität?
Antwort: Typkonformität bedeutet, dass ein Typ mit einem anderen kompatibel ist und somit als Argument für eine Funktion oder Methode verwendet werden kann, die den anderen Typ erwartet.

Frage: Ist Typäquivalenz gleichbedeutend mit Typkonformität?
Antwort: Nein, Typäquivalenz impliziert Typkonformität, aber nicht umgekehrt. Zwei äquivalente Typen sind auch immer konform, aber ein konformer Typ ist nicht unbedingt äquivalent zu einem anderen Typ.

Frage: Was bedeutet Typäquivalenz?
Antwort: Typäquivalenz ist ein Begriff in der Typentheorie, der angibt, dass zwei Typen gleichwertig sind. Es gibt zwei Formen von Typäquivalenz: nominale und strukturelle. Nominale Typäquivalenz bedeutet, dass zwei Typen den gleichen Namen haben, während strukturelle Typäquivalenz bedeutet, dass zwei Typen die gleiche Struktur haben, unabhängig von ihrem Namen. Typäquivalenz impliziert Typkonformität, d.h. zwei äquivalente Typen sind auch immer konform.


Genau wie bei der Typäquivalenz hat die nominale Typkonformität zusätzlich zur Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von Typfehlern (die ja auch bei einer strukturellen Typkonformität schon gegeben wäre) eine Filterfunktion: Es sind nur Objekte von solchen Typen Variablen zuweisbar, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorgesehen hat. Auf diese Filterfunktion werden wir später im Zusammenhang mit sogenanntem Tagging oder Marker Interfaces noch zurückkommen.


Frage: Was ist die Filterfunktion der nominalen Typkonformität?
Antwort: Die nominale Typkonformität hat neben der Gewährleistung der Zuweisungskompatibilität und somit der Abwesenheit von Typfehlern eine Filterfunktion. Diese Filterfunktion ermöglicht es, dass nur Objekte von solchen Typen Variablen zugewiesen werden können, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich vorgesehen hat.

Frage: Was ist die Filterfunktion der nominalen Typkonformität?
Antwort: Die Filterfunktion der nominalen Typkonformität besteht darin, dass nur Objekte von solchen Typen Variablen zugewiesen werden können, für die die Programmiererin aufgrund semantischer (inhaltlicher) Überlegungen ausdrücklich so vorgesehen hat.


Da die Typkonformität bei Nennung des Typs, von dem ein neuer per Erweiterung abgeleitet wird, automatisch gegeben ist (und so keine aufwendigen, fallweisen Konformitätstests durchgeführt werden müssen), setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität. Interessanterweise wurde STRONGTALK, das ursprünglich ein auf struktureller Konformität beruhendes Typsystem (inkl. Type branding) hatte, inzwischen auf nominale Typkonformität umgestellt. Als Begründung wurde angeführt, dass ein strukturelles Typsystem, insbesondere eines, bei dem Typen nicht explizit benannt werden, es der Programmiererin nicht erlaubt, ihre Absicht (intendierte Semantik, die obengenannte Filterfunktion) auszudrücken, was Programme schwerer zu lesen und zu debuggen macht, und dass die Fehlermeldungen, die eine strukturelle Typprüfung produziert, sich oft nicht auf die eigentliche Fehlerquelle beziehen und sehr schwer zu verstehen sind [STRONGTALK 2.0].


Frage: Was ist der Unterschied zwischen nominaler und struktureller Typkonformität?
Antwort: Nominale Typkonformität ist eine Bedingung für die Zuweisungskompatibilität, bei der die Typkonformität gegeben ist, wenn der Typ namentlich angegeben wird. Strukturelle Typkonformität ist dagegen gegeben, wenn die Struktur des Typs übereinstimmt, unabhängig davon, wie er benannt ist. STRONGTALK hat ursprünglich ein strukturelles Typsystem verwendet, das später durch ein nominales Typsystem ersetzt wurde, da die strukturelle Typprüfung es schwieriger macht, die Absicht der Programmiererin auszudrücken und Fehlermeldungen sind oft schwer zu verstehen.

Frage: Was ist der Unterschied zwischen nominaler und struktureller Typkonformität?
Antwort: Nominale Typkonformität bezieht sich auf die Übereinstimmung der Typnamen, während strukturelle Typkonformität die Übereinstimmung der Typstruktur betrifft. In anderen Worten, bei nominaler Typkonformität muss der Typ explizit benannt werden, während bei struktureller Typkonformität die Übereinstimmung der Typstruktur ausreicht.


Fragen der Zuweisungskompatibilität unter Typerweiterung spielen übrigens auch bei Funktionsaufrufen, bei denen ja implizite Zuweisungen auftreten (s. Abschnitt 4.3.2), eine wichtige Rolle.


Frage: Was sind Zuweisungskompatibilität unter Typerweiterung und Funktionsaufrufe?
Antwort: Zuweisungskompatibilität unter Typerweiterung bezieht sich auf die Möglichkeit, Werte verschiedener Typen einander zuzuweisen, wenn der Zieltyp eine Erweiterung des Quelltyps ist. Funktionsaufrufe sind Anweisungen, die eine Funktion mit bestimmten Argumenten aufrufen. Wenn eine Funktion aufgerufen wird, werden implizite Zuweisungen durchgeführt, bei denen die Typen der Argumente mit den Parametern der Funktion kompatibel sein müssen. Diese Zuweisungskompatibilität spielt auch bei Funktionsaufrufen eine wichtige Rolle.

Frage: Was sind Zuweisungskompatibilität unter Typerweiterung und wann spielen sie eine wichtige Rolle?
Antwort: Zuweisungskompatibilität unter Typerweiterung bezieht sich auf die Möglichkeit, Werte von Variablen mit einem bestimmten Typ einer Variablen mit einem erweiterten Typ zuzuweisen. Sie spielen eine wichtige Rolle bei Funktionsaufrufen, bei denen implizite Zuweisungen auftreten, wie in Abschnitt 4.3.2 beschrieben.

Frage: Was sind implizite Zuweisungen?
Antwort: Implizite Zuweisungen treten bei Funktionsaufrufen auf, bei denen die Funktion eine Kopie des Objekts erhält, auf das die Funktionsargument-Variable verweist.

Frage: Was sind Funktionsaufrufe?
Antwort: Funktionsaufrufe sind Anweisungen, die eine Funktion aufrufen und deren Ergebnis berechnen. Sie werden verwendet, um Werte zu berechnen, Objekte zu manipulieren oder die Kontrolle in einem Programm zu übertragen.

Frage: Was ist Typerweiterung?
Antwort: Typerweiterung ist ein Konzept in der objektorientierten Programmierung, bei dem eine Unterklasse eine Oberklasse erweitert, indem sie neue Attribute und Methoden hinzufügt oder bestehende Methoden überschreibt.

Frage: Was sind Zuweisungskompatibilität?
Antwort: Zuweisungskompatibilität bezieht sich darauf, ob ein Wert einer Variablen zugewiesen werden kann, ohne dass eine Kompatibilitätsprüfung fehlschlägt. In der objektorientierten Programmierung ist dies oft abhängig von der Typhierarchie und der Zuweisungskompatibilität von Unter- und Oberklassen.
