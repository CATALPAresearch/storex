12.3 Double Dispatch

Es ist Ihnen vielleicht aufgefallen, dass im oben beschriebenen Verfahren zum Auffinden der auszuführenden Methode nur das Empfängerobjekt, jedoch nicht die Parameterobjekte berücksichtigt wurden. Das erscheint zunächst natürlich. Manchmal hängt jedoch die Auswahl einer geeigneten Methode auch von den tatsächlichen Parametern ab.


Frage: Wann wird das Empfängerobjekt und die Parameterobjekte bei der Auswahl einer Methode berücksichtigt?
Antwort: Das Empfängerobjekt und die Parameterobjekte werden bei der Auswahl einer Methode berücksichtigt, wenn die Auswahl der geeigneten Methode von den tatsächlichen Parametern abhängt.

Frage: Wann hängt die Auswahl einer Methode von den tatsächlichen Parametern ab?
Antwort: Manchmal hängt die Auswahl einer geeigneten Methode nicht nur vom Empfängerobjekt, sondern auch von den tatsächlichen Parametern ab.

Frage: Was ist Parametrische Polymorphie?
Antwort: Parametrische Polymorphie ist eine Art der Polymorphie, bei der die Auswahl einer Methode von den tatsächlichen Parametern abhängt. Wenn die Methode, die für eine bestimmte Nachricht vorgesehen ist, nicht für alle möglichen Parameter geeignet ist, muss eine alternative Methode ausgewählt werden, die besser zu den tatsächlichen Parametern passt.

Frage: Wie wird die Parametrische Polymorphie in der objektorientierten Programmierung implementiert?
Antwort: In der objektorientierten Programmierung wird Parametrische Polymorphie in der Regel durch Überladen von Methoden implementiert. Dabei werden mehrere Methoden mit dem gleichen Namen, aber unterschiedlichen Parametern definiert. Wenn eine Nachricht gesendet wird, wird die Methode mit den passenden Parametern ausgewählt und ausgeführt.


Typische Fälle, in denen auch die tatsächlichen Parameter eine Rolle bei der Methodenauswahl spielen, sind arithmetische Operatoren wie +, –, *, und /. Diese sind nämlich sowohl für Ganzzahlen als auch für Brüche und Gleitkommazahlen definiert, wobei die Implementierung einer Operation von der Art der Operanden abhängt. Nehmen wir beispielsweise an, es gäbe zwei primitive Methoden für die Addition, und zwar eine effiziente für die Integer-Addition (IAdd) und eine weniger effiziente für die Float-Addition (FAdd), und man möchte Additionen für beliebige Kombinationen von Summanden möglichst effizient durchführen können.


Frage: Wann spielen die tatsächlichen Parameter eine Rolle bei der Methodenauswahl?
Antwort: Die tatsächlichen Parameter spielen eine Rolle bei der Methodenauswahl, wenn eine Methode für verschiedene Datentypen unterschiedlich implementiert ist, wie zum Beispiel bei arithmetischen Operatoren.

Frage: Wie können arithmetische Operatoren wie +, –, *, und / effizient implementiert werden?
Antwort: Durch die Verwendung von zwei primitive Methoden für die Addition, eine effiziente für die Integer-Addition (IAdd) und eine weniger effiziente für die Float-Addition (FAdd), und durch die Möglichkeit, Additionen für beliebige Kombinationen von Summanden möglichst effizient durchzuführen. Die Implementierung einer Operation hängt von der Art der Operanden ab.


Während die Unterscheidung nach Empfängerobjekten vom dynamischen Binden und damit dem Laufzeitsystem vorgenommen wird, bleibt die Frage, wie man die Unterscheidung nach den Parameterobjekten vornimmt: Zumindest die Implementation der Addition in der Klasse Integer muss ja danach unterscheiden, ob der Parameter auch ein Integer oder vielleicht ein Float ist. Anstatt nun diese Fallunterscheidung (mittels entsprechender Methoden wie isInteger bzw. isFloat) explizit zu machen, kann man sich eines einfachen Tricks bedienen: Man ruft im Rumpf einer Methode dieselbe Methode einfach noch einmal auf und vertauscht dabei Empfänger (self) und Parameter. Damit es dabei nicht zu unendlichen Rekursionen kommt, kodiert man die Klasse des Empfängers im Nachrichtenselektor der neu aufgerufenen Methode42, also z. B. plusFloat: anstelle von nur plus:.


Frage: Wie kann man die Unterscheidung nach den Parameterobjekten in Smalltalk vornehmen?
Antwort: Statt die Fallunterscheidung explizit zu machen, kann man sich eines Tricks bedienen, bei dem man im Rumpf einer Methode dieselbe Methode erneut aufruft und Empfänger und Parameter vertauscht. Dabei kodiert man die Klasse des Empfängers im Nachrichtenselektor der neu aufgerufenen Methode, z. B. plusFloat: anstelle von plus:.


Diese Technik, nämlich eine Methode gleicher Bedeutung unter Vertauschung von Sender und Empfänger aufzurufen, nennt man "Double Dispatch", und zwar deshalb, weil die dynamische Bindung (auch Method oder Message dispatching genannt) zweimal, und zwar unmittelbar hintereinander, erfolgt. Die Technik des Double Dispatch wurde übrigens von DAN INGALLS am Beispiel von SMALLTALK erstmals beschrieben; sie findet auch in anderen Sprachen mit Single Dispatch (wie Java und C-Sharp) verbreitet Anwendung. Double Dispatch wird in Sprachen, bei denen bei der (dynamischen) Methodenauswahl von Haus aus die Parametertypen mit berücksichtigt werden (die sog. Multi Dispatch -Sprachen), naturgemäß nicht benötigt.


Frage: Was ist Double Dispatch und wofür wird es verwendet?
Antwort: Double Dispatch ist eine Technik, bei der eine Methode gleicher Bedeutung unter Vertauschung von Sender und Empfänger aufgerufen wird. Diese Technik wird verwendet, um die dynamische Bindung zweimal hintereinander durchzuführen. Double Dispatch wurde erstmals von Dan Ingalls am Beispiel von Smalltalk beschrieben und findet auch in anderen Sprachen mit Single Dispatch Anwendung. In Sprachen, bei denen bei der dynamischen Methodenauswahl die Parametertypen berücksichtigt werden, wird Double Dispatch nicht benötigt.
