20 Typdefinitionen und deren Verwendung

Damit durch ein Typsystem Fehler ausgeschlossen werden können, die auf der Voraussetzung von Eigenschaften von Objekten beruhen, die diese gar nicht haben (beispielsweise der Verwendung von Nicht-Zahlen in arithmetischen Ausdrücken), muss bekannt sein, welche Eigenschaften einem Typ und damit seinen Elementen zugeordnet sind. Im Fall von SMALLTALK sind die Eigenschaften, die mit einem Objekt verbunden werden können, schnell gefasst: Es handelt sich einfach um die Menge der Methoden, die es versteht, also um sein Protokoll (s. Abschnitt 4.3.8 in Kurseinheit 1). Ein solches Protokoll definiert einen Typ: Er umfasst die Menge der Objekte, die über das Protokoll verfügen.
Wenn man nun eine Variable mit einem solchen Protokoll als Typ typisiert und das Programm typkorrekt ist, dann ist garantiert, dass jede Methode, die im Protokoll enthalten ist und die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist. Typfehler, also Fehler der Sorte „does not understand“ (s. Abschnitt 4.3.2 in Kurseinheit 1), treten dann nicht mehr auf.
Nun kommen in Protokollen aber selbst Variablen vor, nämlich die formalen Parameter der Methoden, die das Protokoll ausmachen. Außerdem ist eine Methode ein Programmelement, das für ein Objekt steht (mit der Ausführung ein Objekt liefert) und deswegen selbst, genau wie Variablen, typisiert werden sollte. Protokolle definieren also nicht nur Typen, sie verwenden auch selbst welche, nämlich indem sie die Typen der Ein- und Ausgabeobjekte spezifizieren. Ein einfaches Beispiel für eine Typdefinition, die selbst Typen verwendet, ist die folgende:
Wie schon bei einer temporären Variable, stehen die Typannotationen von formalen Parametern in STRONGTALK in spitzen Klammern dahinter. Diese Schreibweise sollten Sie nicht allzu sehr verinnerlichen, da andere Programmiersprachen die spitzen Klammern zur Kennzeichnung von Typvariablen (in Kapitel 29 behandelt) verwenden. Der Rückgabetyp einer Methode wird durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter. Da es in SMALLTALK keine Methoden gibt, die nichts zurückgeben (eine Methode ohne explizite Rückgabeanweisung gibt in SMALLTALK ja immer das Empfängerobjekt zurück), muss auch immer ein Rückgabetyp angegeben werden. Ist dies der Typ selbst, kann der Name Self verwendet werden. Es handelt sich dabei gewissermaßen um eine Pseudo-Typvariable (entsprechend der Pseudovariable self, deren Typ sie darstellt).
Falls Sie sich wundern, dass obige Zeilen kein Schlüsselwort zur Einleitung der Typdefinition beinhalten: STRONGTALK ist, genau wie SMALLTALK, ein interaktives, browsergestütztes System, in dem Typen in Formulare eingetragen und nicht in Textdateien spezifiziert werden. Gleichwohl fällt auf, dass innerhalb der Typdefinition in Typen als Teile von den spitzen Klammern (also da, wo Typen stehen sollen) keine Typdefinition auftauchen, sondern Namen. Und tatsächlich wird in STRONGTALK jeder Typ benannt (in seiner Typdefinition mit einem Namen versehen). Im folgenden werden Typen, ähnlich wie Klassen, in tabellarischer Form notiert.
In STRONGTALK ist die Protokollbildung der einzige sogenannte Typkonstruktor, d. h., das einzige Sprachkonstrukt, mit dem man neue Typen definieren kann. Andere Programmiersprachen sehen ein reichhaltigeres Angebot vor: In PASCAL beispielsweise gibt es die Typkonstruktoren record, array of, set of, file of, Zeiger auf (^) sowie Aufzählungen (enumerations) und Teilbereiche (ranges). In C++ gibt es u. a. class und struct (entsprechend record in PASCAL), JAVA, C# und EIFFEL bieten auch jeweils verschiedene Typkonstruktoren an. Für eine puristische Sprache wie SMALLTALK bzw. STRONGTALK reicht jedoch einer vollkommen aus.
Wie man leicht einsieht, gibt es in STRONGTALK keine primitiven Typen, also keine Typen, deren Definitionen nicht selbst auf einen oder mehrere Typen zurückgeführt werden müssten. Daran rührt auch die Optionalität der Annotierung nichts: Selbst wenn man eine Typannotation weglässt (was immer erlaubt ist), hat die entsprechende Variable bzw. der Rückgabewert der Methode einen Typ, nur wird er an dieser Stelle nicht angegeben. Das wirft natürlich die Frage auf, wie man Typen unter zwangsläufiger Selbstbezüglichkeit überhaupt eine Bedeutung beimessen kann.

Frage: Warum ist es wichtig, die Eigenschaften eines Typs und seiner Elemente in einem Typsystem zu kennen?
Antwort: Es ist wichtig, die Eigenschaften eines Typs und seiner Elemente in einem Typsystem zu kennen, um Fehler im Programm zu vermeiden, die auf der Annahme von Eigenschaften beruhen, die Objekte möglicherweise nicht haben. Ein Typsystem definiert, welche Methoden auf einem Objekt aufgerufen werden können, und stellt sicher, dass diese Methoden auch für das Objekt definiert sind.

Frage: Wie werden Typfehler in STRONGTALK vermieden?
Antwort: In STRONGTALK werden Typfehler vermieden, indem Variablen mit einem Protokoll als Typ typisiert werden. Wenn das Programm typkorrekt ist, bedeutet dies, dass jede Methode im Protokoll, die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist.

Frage: Warum müssen Protokolle in STRONGTALK selbst Typen verwenden?
Antwort: Protokolle in STRONGTALK verwenden selbst Typen, da sie die Typen der Eingabe- und Ausgabeobjekte in den Methoden spezifizieren. Dies gewährleistet, dass die Typen der Objekte, die mit den Methoden interagieren, kompatibel sind.

Frage: Wie werden formale Parameter in STRONGTALK typisiert?
Antwort: Formale Parameter in STRONGTALK werden durch Typannotationen in spitzen Klammern hinter den Parametern typisiert.

Frage: Wie kennzeichnet man in STRONGTALK den Rückgabetyp einer Methode?
Antwort: In STRONGTALK wird der Rückgabetyp einer Methode durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter der Methode.

Frage: Warum gibt es in STRONGTALK keine primitiven Typen?
Antwort: In STRONGTALK gibt es keine primitiven Typen, da alle Typen in STRONGTALK auf andere Typen zurückgeführt werden können. Selbst wenn eine Typannotation weggelassen wird, hat die entsprechende Variable bzw. der Rückgabewert der Methode immer einen impliziten Typ. Dies ermöglicht es, Typen mit zwangsläufiger Selbstbezüglichkeit eine Bedeutung zuzuweisen.