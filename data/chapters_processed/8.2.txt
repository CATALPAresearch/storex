8.2 Initialisierung

In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert "nil". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet.


Frage: Was ist die Funktion von Konstruktoren in SMALLTALK?
Antwort: Konstruktoren in SMALLTALK sind Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert "nil". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet.

Frage: Was ist der Unterschied zwischen Konstruktoren und Initialisierung in Smalltalk?
Antwort: In Smalltalk sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert "nil". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet. Somit ist der Unterschied, dass Konstruktor ein Klassenmethode ist, die eine neue Instanz erzeugt, während Initialisierung ein Vorgang ist, bei dem Instanzvariablen sinnvolle Anfangswerte zugewiesen bekommen.


Es ist jedoch nicht immer erforderlich, alle Instanzen einer Klasse auf die gleiche Weise zu initialisieren. Daher ist es möglich, für eine Klasse mehrere alternative Konstruktoren (als Klassenmethoden) zu definieren, die die neuen Objekte jeweils unterschiedlich initialisieren. Zwei Beispiele für die Klasse "Time" sind unten gegeben, wobei beide die Klassenmethode "seconds:" auf "Time" aufrufen (repräsentiert durch "self"), die wiederum mit "basicNew" eine Instanz von "Time" erzeugt und anschließend initialisiert.


Frage: Was sind alternative Konstruktoren in der objektorientierten Programmierung?
Antwort: Alternative Konstruktoren sind Klassenmethoden, die die neuen Objekte einer Klasse jeweils unterschiedlich initialisieren. Sie ermöglichen es, Instanzen einer Klasse auf verschiedene Weise zu initialisieren.

Frage: Was ist der Zweck von Konstruktoren in der objektorientierten Programmierung?
Antwort: Konstruktoren sind spezielle Methoden in der objektorientierten Programmierung, die verwendet werden, um neue Objekte einer Klasse zu initialisieren. Sie werden aufgerufen, wenn ein neues Objekt erstellt wird und werden verwendet, um die Anfangswerte der Attribute des Objekts festzulegen. In dem gegebenen Beispiel, werden zwei alternative Konstruktoren für die Klasse "Time" definiert, die die neuen Objekte jeweils unterschiedlich initialisieren.


Da die Instanzvariablen eines Objekts nur für die Instanzen des Objekts selbst zugreifbar sind, kann auch eine Klassenmethode wie "new" nicht auf sie zugreifen. Die Initialisierung muss daher von Instanzmethoden wie "ticks:" durchgeführt werden, die jedoch nicht ausschließlich der Initialisierung vorbehalten sind, sondern jederzeit auf Instanzen der Klasse aufgerufen werden können. Dies kann problematisch sein, wenn Instanzvariablen initialisiert werden müssen, deren Existenz nach außen verborgen werden soll. Aus diesem Grund sehen "new" und "new:" standardmäßig den Aufruf der Methode "initialize" vor (siehe Zeilen 307 und 309 oben), in der alle Initialisierungen vorgenommen werden können, ohne dass etwas über den Aufbau der Instanzen nach außen verraten würde.


Frage: Wozu dient die Methode "initialize" in diesem Kontext?
Antwort: Die Methode "initialize" dient dazu, Initialisierungen von Instanzvariablen durchzuführen, ohne dass etwas über den Aufbau der Instanzen nach außen verraten wird. Diese Methode wird standardmäßig von "new" und "new:" aufgerufen.

Frage: Wie können Instanzvariablen in einer Klasse initialisiert werden?
Antwort: Instanzvariablen können in einer Klasse durch den Aufruf der Methode "initialize" initialisiert werden, die standardmäßig von den Methoden "new" und "new:" aufgerufen wird.

Frage: Wie wird die Initialisierung von Instanzvariablen in Smalltalk durchgeführt?
Antwort: In Smalltalk wird die Initialisierung von Instanzvariablen durchgeführt, indem die Methode "initialize" aufgerufen wird, die standardmäßig von den Methoden "new" und "new:" vorgesehen ist. Diese Methode kann alle Initialisierungen vornehmen, ohne dass etwas über den Aufbau der Instanzen nach außen verraten wird.


In anderen Sprachen wie C++, Java oder C-Sharp sind Konstruktoren daher auch keine Klassenmethoden, sondern haben eine Art Zwitterstatus: Sie werden auf einer Klasse aufgerufen, aber sie werden wie Instanzmethoden auf der neuen Instanz ausgeführt und können somit auf die Instanzvariablen der neu erzeugten Instanz zugreifen. Beachten Sie jedoch, dass die Methode "ticks:" keine Informationen über die Implementierung der Instanzvariablen der Klasse "Time" preisgibt.


Frage: Was ist der Unterschied zwischen Konstruktoren in SMALLTALK und Konstruktoren in Sprachen wie C++, Java oder C-Sharp?
Antwort: In SMALLTALK sind Konstruktoren Klassenmethoden, während sie in Sprachen wie C++, Java oder C-Sharp eine Art Zwitterstatus haben und sowohl auf der Klasse als auch auf der neuen Instanz aufgerufen werden können. SMALLTALK-Konstruktoren können nicht auf die Instanzvariablen der neu erzeugten Instanz zugreifen, während Konstruktoren in C++, Java oder C-Sharp dies können.


Alternativ zur obigen Konstruktion kann die Initialisierung von Instanzvariablen auch zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt werden. Dies wird als "Lazy initialization" bezeichnet, da die Initialisierung solange wie möglich verschoben wird. Bei der Verwendung von Lazy initialization muss jedoch vor jedem lesebasierten Zugriff auf die (faul initialisierte) Instanzvariable überprüft werden, ob ihr Wert immer noch "nil" ist. Wenn dies der Fall ist, muss er durch den gewünschten Anfangswert ersetzt werden, der normalerweise in der Standardinitialisierungsmethode zu finden wäre. Um das Hinzufügen von Abfragen bei jedem lesebasierten Zugriff auf die Variable im Programm zu vermeiden, empfiehlt es sich, bei der Verwendung von Lazy initialization alle Zugriffe auf Instanzvariablen, einschließlich interner Klassenzugriffe, über entsprechende Getter-Methoden durchzuführen. Diese Getter-Methoden prüfen den Inhalt der Variable, bevor sie ihn zurückgeben, und setzen ihn gegebenenfalls. Die Lazy initialization erfordert zusätzlichen Code, der bei einer Standardinitialisierung nicht erforderlich wäre. Das laufende Programm spart jedoch den Preis der Initialisierung, wenn diese nie notwendig wird, d.h., wenn der Wert der zu initialisierenden Variable im Programmablauf nie oder erst nach einer anderen Zuweisung abgefragt wird. Lazy initialization lohnt sich daher immer dann, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Ein weiterer Vorteil der Lazy initialization besteht darin, dass die Initialisierung nie vergessen werden kann. Dies ist insbesondere dann wertvoll, wenn die Initialisierung nicht wie oben beschrieben vom Konstruktor selbst, sondern von einer separaten Methode durchgeführt wird und die Benutzer der entsprechenden Klasse möglicherweise nicht klar ist, dass sie nach dem Konstruktor auch noch die Initialisierungsmethode aufrufen müssen. Konstruktoren, die wie in Zeilen 307 und 309 oben implementiert wurden, versuchen dies zu verhindern, indem sie die Initialisierungsmethode selbst aufrufen. Manchmal kann der Konstruktor jedoch nicht einfach geändert werden, und es wird nicht verhindert, dass "basicNew" direkt und ohne "initialize" aufgerufen wird.


Frage: Was ist "Lazy initialization" und wann wird sie angewendet?
Antwort: "Lazy initialization" ist eine Technik, bei der die Initialisierung von Instanzvariablen zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt wird. Sie wird angewendet, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Dadurch wird verhindert, dass die Initialisierung vergessen wird und der Preis der Initialisierung gespart, wenn sie nie notwendig wird.
