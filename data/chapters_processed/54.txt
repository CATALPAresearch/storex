54 Das Problem der Substituierbarkeit

In Kapitel 26 sind wir bereits ausführlich auf den Begriff des Subtypings eingegangen. Subtyping sollte die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen, dh. erlauben, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Dies führt nun zu dem Problem, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat.82 Gemäß den Regeln gängiger objektorientierter Programmiersprachen zur Zuweisungskompatibilität wissen wir lediglich, dass es sich beim Typ des Empfängerobjekts e um einen Subtyp von T handeln muss83, jedoch wissen wir nicht genau, um welchen Subtyp es sich handelt. In einer statischen, lokalen Betrachtung84, also bei mangelnder Kenntnis des Typs des von e bezeichneten Objekts sowie aller infrage kommenden Subtypen von T, befinden wir uns in einem Zustand völliger Unsicherheit. Da die Erweiterung um Subklassen bzw. Subtypen jedoch eine der Errungenschaften der objektorientierten Programmierung ist, handelt es sich hierbei um ein echtes Problem.


Frage: Was ist Subtyping in der objektorientierten Programmierung?
Antwort: Subtyping ist ein Konzept in der objektorientierten Programmierung, das die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen soll. Es erlaubt, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Dadurch wird die Erweiterung um Subklassen oder Subtypen ermöglicht.

Frage: Was ist Subtyping und welches Problem ergibt sich daraus?
Antwort: Subtyping ist ein Begriff in der objektorientierten Programmierung, der die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen soll. Das bedeutet, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Das Problem, das sich daraus ergibt, ist, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat. In einer statischen, lokalen Betrachtung befinden wir uns in einem Zustand völliger Unsicherheit.


Das Problem lässt sich als ein Problem der formalen Programmverifikation ausdrücken: Wie kann bewiesen werden, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts gebunden werden können? Es handelt sich um die Beziehung P {e m} Q (54.1), bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse darüber, was der Methodenaufruf tatsächlich bewirkt oder vielmehr, welchen Effekt er hat. Dafür ist die Kenntnis der Implementierung der Methode erforderlich. Andererseits ist es wichtig für die Pflege und Weiterentwicklung eines Programms zu wissen, unter welchen Bedingungen die Methoden einer neu eingeführten Klasse in das bestehende Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert. Die Bedingungen müssen bekannt sein, um sicherzustellen, dass die neue Implementierung sich in den Kanon der bereits bestehenden einordnet und kein unerwartetes Verhalten hervorruft. Nur wenn diese Zusicherungen in Form von (54.1) für alle Aufrufe erfüllt sind, ist das Funktionieren des Programms nicht gefährdet. Andernfalls könnte es beeinträchtigt sein. Daher müssen die Bedingungen bekannt sein.


Frage: Was ist das Problem der formalen Programmverifikation?
Antwort: Das Problem der formalen Programmverifikation ist die Beziehung P {e m} Q, bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse über die Implementierung der Methode.

Frage: Warum ist es wichtig, die Bedingungen zu kennen, unter denen Methoden in ein bestehendes Programm integriert werden können?
Antwort: Es ist wichtig, die Bedingungen zu kennen, unter denen Methoden in ein bestehendes Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert und kein unerwartetes Verhalten hervorruft. Nur wenn diese Zusicherungen in Form von (54.1) für alle Aufrufe erfüllt sind, ist das Funktionieren des Programms nicht gefährdet.


Die Frage, wie der Effekt aller Implementierungen von m für Subtypen von T (einschließlich T selbst) erfasst werden kann, steht im Raum. Eine naive Antwort auf diese Frage würde vorschlagen, dass man sich alle diese Implementierungen ansieht und auf dieser Grundlage eine Fallunterscheidung präsentiert: Wenn das Objekt e vom Typ T ist, dann hat m den und den Effekt, wenn es von Subtyp T1 ist, dann hat m den und den Effekt, usw. Die Zusammenfassung dieser Fallunterscheidungen würde dann alle Effekte logisch mit einem Oder verknüpfen. Diese Möglichkeit hat jedoch den Nachteil der Unhandlichkeit und berücksichtigt nicht vorhandene Implementierungen nicht. Was man stattdessen möchte, ist die Gewissheit, dass eine lokale, "modulare" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte. Genau das soll der Begriff der Substituierbarkeit ermöglichen.


Frage: Was ist der Begriff der Substituierbarkeit?
Antwort: Der Begriff der Substituierbarkeit ermöglicht eine lokale, "modulare" Betrachtung bei der Analyse von Methodenaufrufen, indem er die Gewissheit bietet, dass man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte.

Frage: Was ist der Zweck der Substituierbarkeit?
Antwort: Der Zweck der Substituierbarkeit in der objektorientierten Programmierung ist es, die Gewissheit zu haben, dass eine lokale, "modulare" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte.
