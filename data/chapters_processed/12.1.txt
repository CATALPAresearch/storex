12.1 Nachrichten an self

In SMALLTALK muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. So kann also insbesondere self nicht (wie beispielsweise this in Java) weggelassen werden, wenn ein Objekt eine Nachricht an sich selbst senden möchte. Wie bereits in Abschnitt 4.3.1 erwähnt, bezeichnet die Pseudovariable self immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind. (Die einzige Ausnahme hiervon bilden Blöcke, in denen self sich auf den Empfänger des Home-Kontexts bezieht; siehe Abschnitt 4.4.1 in Kurseinheit 1).


Frage: Wie wird das Empfängerobjekt eines Nachrichtenversands in SMALLTALK angegeben?
Antwort: In SMALLTALK muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. So kann also insbesondere self nicht weggelassen werden, wenn ein Objekt eine Nachricht an sich selbst senden möchte.

Frage: Was ist die Rolle von self in Smalltalk?
Antwort: In Smalltalk muss das Empfängerobjekt eines Nachrichtenversands immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. self bezeichnet immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind.

Frage: Was bezeichnet die Pseudovariable self in Smalltalk?
Antwort: Die Pseudovariable self bezeichnet immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird, und dessen Instanzvariablen zugreifbar sind.


Dabei ist allerdings zu beachten, dass die Klasse des durch self bezeichneten Objekts nicht unbedingt dieselbe sein muss, in der die gerade ausgeführte Methode (in der auch das self steht) definiert ist, denn das kann ja aufgrund von Vererbung durchaus eine Superklasse sein. Das hat eine fundamentale Auswirkung: Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden, nämlich dann, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde.


Frage: Was ist die Bedeutung von self in Smalltalk?
Antwort: In Smalltalk bezieht sich self auf das Objekt, auf das die gerade ausgeführte Methode angewendet wird. Die Klasse des durch self bezeichneten Objekts muss nicht unbedingt dieselbe sein, in der die Methode definiert ist, sondern kann durchaus eine Superklasse sein. Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden.

Frage: Was passiert, wenn an self eine Nachricht geschickt wird?
Antwort: Wenn an self eine Nachricht geschickt wird, wird die zu dieser Nachricht passende Methode gesucht. Die Suche beginnt in der Klasse, in der die gerade ausgeführte Methode definiert ist. Wenn die Methode nicht in dieser Klasse gefunden wird, wird die Suche in der Kette der Superklassen fortgesetzt, bis die Methode gefunden wird.

Frage: Was passiert, wenn an self eine Nachricht geschickt wird, die in der Klasse des Objekts nicht definiert ist?
Antwort: Wenn an self eine Nachricht geschickt wird, die in der Klasse des Objekts nicht definiert ist, wird die Suche nach der passenden Methode in der Kette der Superklassen fortgesetzt, bis die Methode gefunden wird.


Man beachte, dass Vererbung tatsächlich eine Kopieren-und-Einfügen-Semantik hat, wie in Abschnitt 11.2 bereits nahegelegt: Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.


Frage: Wie funktioniert die Vererbung in SMALLTALK?
Antwort: In SMALLTALK hat Vererbung eine Kopieren-und-Einfügen-Semantik, d.h. wenn man die Implementierung einer Methode aus der Superklasse in die Subklasse wiederholt, erhält man das gleiche Ergebnis.

Frage: Was bedeutet die Vererbung in der objektorientierten Programmierung?
Antwort: In der objektorientierten Programmierung hat Vererbung eine Kopieren-und-Einfügen-Semantik, was bedeutet, dass wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.

Frage: Was versteht man unter Kopieren-und-Einfügen-Semantik bei Vererbung?
Antwort: Bei der Kopieren-und-Einfügen-Semantik bei Vererbung wird die Implementierung der übergeordneten Klasse in die Unterklasse kopiert und kann dann in der Unterklasse gegebenenfalls angepasst werden. Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.


Während offene Rekursion im gegebenen Beispiel durchaus erwünscht ist und ihr Effekt wohl auch den Erwartungen der Programmiererin entspricht, ergeben sich doch immer wieder Konstellationen, in denen man unangenehm überrascht wird. Das Problem ist unter dem Namen "Fragile-base-class-Problem" bekannt geworden; es wird in Kapitel 55 (Kurseinheit 6) ausführlicher behandelt. Fragile-base-class-Probleme entstehen durch die Möglichkeit der offenen Rekursion.


Frage: Wann sollte man offene Rekursion nicht verwenden?
Antwort: Man sollte offene Rekursion nicht verwenden, wenn sie zu Problemen führen kann, die als "Fragile-base-class-Problem" bekannt sind.
