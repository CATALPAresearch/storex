43.1 Einfache parametrische Typdefinitionen

Genau wie unparametrisierte (nicht generische) Typen in Java nicht aus eigenständigen Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces einhergehen, so werden auch parametrische (generische) Typen nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Da aber die formalen Typparameter einer Klassen- bzw. Interfacedefinition durch verschiedene Typen ersetzt werden können, wird die alte 1-zu-1-Beziehung zwischen Klassen und Typen aufgebrochen: Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbesondere führt die „Instanziierung“68 einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Deswegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen den Typparameter als Typ verwenden und sich insofern unterscheiden.


Frage: Wie werden parametrische Typen definiert?
Antwort: Parametrische Typen werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Die Instanziierung einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter führt nur zu einem neuen Typ, aber nicht zu einer neuen Klasse.

Frage: Was ist der Unterschied zwischen parametrischen und unparametrischen Typen in Java?
Antwort: Unparametrisierte Typen in Java werden nicht aus eigenständigen Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces einhergehen. Parametrische Typen hingegen werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbesondere führt die „Instanziierung“ einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Deswegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen den Typparameter als Typ verwenden und sich insofern unterscheiden.


Die klassische Anwendung generischer Typen findet man bei Collections: Genauso, wie man in Java Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt Java ähnlich wie SMALLTALK über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die Java-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition Javas, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen. Da es vor Java 5 keine Möglichkeit gab, bei der Deklaration einer Variable mit einer Collection als Typ anzugeben, welchen Typ die Elemente der Collection haben sollen, wurde implizit davon ausgegangen, dass diese vom Typ Object sind. So hatte z. B. die Klasse ArrayList ein (privates) Feld elementData vom Typ Object[], in dem die Elemente gespeichert wurden. Da Object der Supertyp aller Referenztypen in Java ist, konnten auch Instanzen aller Referenztypen in elementData und somit in Instanzen von ArrayList gespeichert werden.


Frage: Was ist der Supertyp aller Referenztypen in Java?
Antwort: Object ist der Supertyp aller Referenztypen in Java.

Frage: Was sind die klassischen Anwendungsfälle generischer Typen?
Antwort: Die klassische Anwendung generischer Typen findet man bei Collections. Genauso, wie man in Java Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt Java über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die Java-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition Javas, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen.

Frage: Warum können in Java Arrays über einen bestimmten Elementtyp gebildet werden?
Antwort: In Java können Arrays über einen bestimmten Elementtyp gebildet werden, weil es in Java eine Sprachdefinition für Arrays gibt, die eine solche Möglichkeit vorsieht. Dies ermöglicht eine bessere Typsicherheit und Effizienz, da die Elemente eines Arrays alle vom gleichen Typ sind und somit keine Typumwandlung bei der Zuweisung oder beim Zugriff notwendig ist.


Dank der generischen Typen ist es aber möglich, bei der Deklaration einer Variable vom Typ einer Collection — in Analogie zur Deklaration einer Variable vom Typ eines Arrays über einen Elementtyp — den Elementtyp mit anzugeben. Um beispielsweise eine Liste von Integern zu deklarieren und zu initialisieren, muss man lediglich List<Integer> liste = new ArrayList<>(); schreiben.


Frage: Was ist der Zweck der generischen Typen bei der Deklaration einer Variablen?
Antwort: Dank der generischen Typen ist es möglich, bei der Deklaration einer Variablen vom Typ einer Collection den Elementtyp mit anzugeben. Dadurch wird eine Liste von Integern beispielsweise durch List<Integer> liste = new ArrayList<>(); deklariert und initialisiert.

Frage: Was ist der Vorteil von generischen Typen?
Antwort: Der Vorteil von generischen Typen ist, dass sie es ermöglichen, bei der Deklaration einer Variablen den Elementtyp mit anzugeben, was die Typsicherheit erhöht und die Notwendigkeit von expliziten Typumwandlungen verringert.


Dabei ist das in spitzen Klammern stehende E der (formale) Typparameter der Definition von ArrayList. Die bereits in Abschnitt 29.1 erwähnte Konvention, einzelne Großbuchstaben für Typparameter zu wählen, wurde auch in Java übernommen, ganz einfach, um Typparameter von Klassen- und Variablennamen im Programmtext besser unterscheiden zu können. So steht E üblicherweise für den Elementtyp von Containern, wie es die Collections sind. Durch die Sprachdefinition erzwungen wird das jedoch nicht.


Frage: Was bedeuten spitze Klammern in Java?
Antwort: Spitze Klammern < > werden in Java verwendet, um Typparameter in generischen Klassen oder Methoden zu definieren. Sie werden auch als Diamant-Operator bezeichnet.


Die Zuweisung von Zeile 1051 ist übrigens nur gültig, wenn der (parametrisierte) Typ ArrayList<Integer> Subtyp von List<Integer> ist. Dies wird, in Java-Syntax, durch die Deklaration List<Integer> liste; (nominales Subtyping) sichergestellt. Man beachte, dass die Variable E hier eine logische Bedingung ausdrückt, nämlich die, dass ein bei der Verwendung von ArrayList<E> angegebener tatsächlicher Typparameter auch in die Definition von List<E> eingesetzt werden muss.


Frage: Was bedeutet nominales Subtyping?
Antwort: Nominales Subtyping bedeutet, dass eine Variable eines bestimmten Typs auch einem Untertyp dieses Typs zugewiesen werden kann. In Java-Syntax wird dies durch die Deklaration List<Integer> liste; sichergestellt, wodurch die Variable liste auch mit einem ArrayList<Integer>-Objekt initialisiert werden kann.


Der Compiler weiß nun aufgrund der Ersetzung des formalen Parameters E mit dem tatsächlichen Parameter Integer in Zeile 1051, dass die Elemente der Variable liste alle vom Typ Integer sind und dass eine Zuweisung der Form get(0) = 42; typkorrekt ist. Um das zu überprüfen, muss er nämlich nur den Wert des Typparameters in der Deklaration von liste, Integer, in die Variable E der Implementierung von get einsetzen. Er kann dann feststellen, dass der Rückgabetyp des Ausdrucks mit der Variable zuweisungskompatibel ist. Man beachte, dass ohne Typparameter in Zeile 1064 eine Typumwandlung von Object auf Integer (Downcast) notwendig wäre, die aber zu einem Laufzeitfehler führen kann. Die Einführung von Generics erhöht hingegen die Typsicherheit statisch, also zur Übersetzungszeit, ein fundamentaler Gewinn.


Frage: Was ist der Zweck von Typparametern in Programmierung?
Antwort: Typparameter werden in Programmierung eingesetzt, um die Typsicherheit zu erhöhen und die Überprüfung der Typkompatibilität zur Übersetzungszeit durchzuführen. Ohne Typparameter müsste eine Typumwandlung zur Laufzeit erfolgen, was zu Laufzeitfehlern führen kann.

Frage: Was ist der Zweck von Typparametern in Generics?
Antwort: Typparameter in Generics erhöhen die Typsicherheit statisch, also zur Übersetzungszeit, was einen fundamentalen Gewinn darstellt. Ohne Typparameter müsste eine Typumwandlung von Object auf Integer (Downcast) durchgeführt werden, was zu einem Laufzeitfehler führen kann.

Frage: Was ist der Zweck der Verwendung von Generics in Java?
Antwort: Der Zweck der Verwendung von Generics in Java ist es, die Typsicherheit statisch, also zur Übersetzungszeit, zu erhöhen und die Notwendigkeit von Typumwandlungen (Downcast) zu verringern, die zu Laufzeitfehlern führen können.


Nun wissen Sie ja bereits, dass List<Integer> nicht unbedingt ein Subtyp von List<Object> sein sollte, selbst wenn Integer ein Subtyp von Object ist. Man hat den oben diskutierten Kompromiss offenbar nicht weiter fortführen wollen.


Frage: Warum sollte List<Integer> nicht unbedingt ein Subtyp von List<Object> sein?
Antwort: Der Kompromiss, dass List<Integer> ein Subtyp von List<Object> sein sollte, wurde offenbar nicht weiter fortgeführt, weil Integer ein Subtyp von Object ist. Das liegt daran, dass dies zu inkonsistenten Typzuweisungen führen könnte, was die Typsicherheit des Programms beeinträchtigen würde.
