43.1 Einfache parametrische Typdefinitionen

Genau wie unparametrisierte (nicht generische) Typen in JAVA nicht aus eigenständigen Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces einhergehen, so werden auch parametrische (generische) Typen nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Da aber die formalen Typparameter einer Klassen- bzw. Interfacedefinition durch verschiedene Typen ersetzt werden können, wird die alte 1:1-Beziehung zwischen Klassen und Typen aufgebrochen: Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbesondere führt die „Instanziierung“68 einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Deswegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen den Typparameter als Typ verwenden und sich insofern unterscheiden.
Die klassische Anwendung generischer Typen findet man bei Collections: Genauso, wie man in JAVA Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt JAVA ähnlich wie SMALLTALK über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die JAVA-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition JAVAs, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen. Da es vor JAVA 5 keine Möglichkeit gab, bei der Deklaration einer Variable mit einer Collection als Typ anzugeben, welchen Typ die Elemente der Collection haben sollen, wurde implizit davon ausgegangen, dass diese vom Typ Object sind. So hatte z. B. die Klasse ArrayList ein (privates) Feld elementData vom Typ Object[], in dem die Elemente gespeichert wurden. Da Object der Supertyp aller Referenztypen in JAVA ist, konnten auch Instanzen aller Referenztypen in elementData und somit in Instanzen von ArrayList gespeichert werden.
Dank der generischen Typen ist es aber möglich, bei der Deklaration einer Variable vom Typ einer Collection — in Analogie zur Deklaration einer Variable vom Typ eines Arrays über einen Elementtyp — den Elementtyp mit anzugeben. Um beispielsweise eine Liste von Integern zu deklarieren und zu initialisieren, muss man lediglich List<Integer> liste = new ArrayList<>(); schreiben.
Dabei ist das in spitzen Klammern stehende E der (formale) Typparameter der Definition von ArrayList. Die bereits in Abschnitt 29.1 erwähnte Konvention, einzelne Großbuchstaben für Typparameter zu wählen, wurde auch in JAVA übernommen, ganz einfach, um Typparameter von Klassen- und Variablennamen im Programmtext besser unterscheiden zu können. So steht E üblicherweise für den Elementtyp von Containern, wie es die Collections sind. Durch die Sprachdefinition erzwungen wird das jedoch nicht.
Die Zuweisung von Zeile 1051 ist übrigens nur gültig, wenn der (parametrisierte) Typ ArrayList<Integer> Subtyp von List<Integer> ist. Dies wird, in JAVA-Syntax, durch die Deklaration List<Integer> liste; (nominales Subtyping) sichergestellt. Man beachte, dass die Variable E hier eine logische Bedingung ausdrückt, nämlich die, dass ein bei der Verwendung von ArrayList<E> angegebener tatsächlicher Typparameter auch in die Definition von List<E> eingesetzt werden muss.
Der Compiler weiß nun aufgrund der Ersetzung des formalen Parameters E mit dem tatsächlichen Parameter Integer in Zeile 1051, dass die Elemente der Variable liste alle vom Typ Integer sind und dass eine Zuweisung der Form get(0) = 42; typkorrekt ist. Um das zu überprüfen, muss er nämlich nur den Wert des Typparameters in der Deklaration von liste, Integer, in die Variable E der Implementierung von get einsetzen. Er kann dann feststellen, dass der Rückgabetyp des Ausdrucks mit der Variable zuweisungskompatibel ist. Man beachte, dass ohne Typparameter in Zeile 1064 eine Typumwandlung von Object auf Integer (Downcast) notwendig wäre, die aber zu einem Laufzeitfehler führen kann (s. Abschnitt 44.1). Die Einführung von Generics erhöht hingegen die Typsicherheit statisch, also zur Übersetzungszeit, ein fundamentaler Gewinn.
Nun wissen Sie ja bereits aus der Schilderung aus Kapitel 41, dass List<Integer> nicht unbedingt ein Subtyp von List<Object> sein sollte, selbst wenn Integer ein Subtyp von Object ist. Man hat den oben diskutierten Kompromiss offenbar nicht weiter fortführen wollen.

Frage: Wie werden parametrische (generische) Typen in Java definiert?
Antwort: Parametrische (generische) Typen in Java werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Die formalen Typparameter in der Klassendefinition können durch verschiedene Typen ersetzt werden.

Frage: Was ist die Hauptanwendung generischer Typen in Java?
Antwort: Eine Hauptanwendung generischer Typen in Java ist die Arbeit mit Collections, um den Typ der Elemente in der Collection anzugeben und so die Typsicherheit zu erhöhen.

Frage: Welche Konvention wird häufig verwendet, um Typparameter von Klassen- und Variablennamen zu unterscheiden?
Antwort: Eine häufig verwendete Konvention ist es, einzelne Großbuchstaben für Typparameter zu wählen. Zum Beispiel steht "E" üblicherweise für den Elementtyp von Containern wie Collections.

Frage: Warum führt die Zuweisung von List<Integer> zu List<Object> zu einem statischen Typfehler in Java?
Antwort: Die Zuweisung von List<Integer> zu List<Object> führt zu einem statischen Typfehler in Java, weil bei generischen Typen nicht automatisch eine Zuweisungskompatibilität zwischen unterschiedlichen generischen Typen besteht, selbst wenn die Typen, die sie parametrisieren, zueinander in Beziehung stehen. Dies erhöht die Typsicherheit zur Übersetzungszeit.