28 Der Zusammenhang von Typen und Klassen

Wenn in dieser Kurseinheit bislang ausschließlich von Typen die Rede war und Klassen dabei ignoriert wurden, so hat das gute Gründe: Während eine Klasse die Implementierung ihrer Objekte festlegt, ist eine Typdefinition vollkommen frei von Implementierungsaspekten. Zwar können auch abstrakte Klassen (Kurseinheit 2, Abschnitt 10.3) ausschließlich aus Methodendeklarationen bestehen, also ohne jeden Implementierungsanteil, aber auch ihr Zweck ist in der Regel, zumindest eine partielle Implementierung vorzugeben, die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können. Schließlich drückt die Klassenhierarchie ja eine „genetische“ Verwandtschaft aus (s. Abschnitt 10.1 und Kapitel 11). Eine Typprüfung soll aber ohne Ansehen der Implementierung stattfinden; sie baut daher auf abstrakte Spezifikationen, eben auf Typen.
Es sind also Typen abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben. Im Gegensatz dazu sind Klassen Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Da Objekte aber auch den Wertebereich von Typen ausmachen, stellt sich natürlich die Frage, welcher Art der Zusammenhang zwischen Typen und Klassen ist.
Es fällt zunächst auf, dass bestimmte Elemente einer Klassendefinition auch in einer Typdefinition auftauchen. Im Einzelnen sind dies: ein (eindeutiger) Name, ein zweiter Name, von dessen dazugehöriger Definition abgeleitet wird sowie eine Menge von Methodennamen, jeweils mit einer Anzahl formaler Parameter.
Nun werden in SMALLTALKs Klassendefinitionen anders als bei den Typdefinitionen STRONGTALKs keine Typen verwendet — wie auch, denn in SMALLTALK gibt es ja schließlich keine Typen. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht. In STRONGTALK hingegen ist die Ähnlichkeit von Klassendefinitionen mit Typdefinitionen noch größer: Hier sind auch die formalen Parameter der Methoden in den Klassendefinitionen typisiert (s. Kapitel 20). Man beachte, dass in STRONGTALK, anders als z. B. in JAVA oder C++, Instanzvariablen kein Bestandteil einer Typdefinition sein können (vgl. dazu Fußnote 50).
Nun dient ja ein Typsystem in der objektorientierten Programmierung vor allem der Sicherstellung des Umstands, dass alle von einem Objekt aufgrund des deklarierten Typs der Variablen, die es benennt, erwarteten Eigenschaften (Methoden) bei diesem Objekt auch vorhanden sind. Dies ist aber immer dann der Fall, wenn sich die Elemente der Typdefinition in der Klassendefinition des Objekts wiederfinden, die Klassendefinition also mit der Typdefinition gewissermaßen strukturell konform ist, so dass die Zuweisung einer Instanz der Klasse an eine Variable des Typs die Anforderungen der Zuweisungskompatibilität erfüllt. Um einen Compiler diese Zuweisungskompatibilität auf einfachere Weise als die Prüfung der Strukturkonformität, die ja eine rekursive Expansion der Typdefinitionen erfordert, feststellen zu lassen, gibt es zwei Möglichkeiten (bei beiden handelt es sich gewissermaßen um Varianten einer Namenskonformität): Jede Klasse sagt explizit, mit welchen Typen sie konform ist, oder: Jede Klasse spezifiziert implizit selbst einen Typ.
Im ersten Fall müsste der Compiler noch prüfen, ob eine Klasse tatsächlich auch über alle Eigenschaften der von ihr genannten Typen verfügt; im zweiten Fall ist das automatisch der Fall, da der Typ ja gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den allermeisten typisierten, objektorientierten Programmiersprachen bevorzugt, doch auch die erste kommt in populären Sprachen vor: So kann beispielsweise in JAVA und C# jede Klasse angeben, mit Variablen welcher Interface-Typen ihre Instanzen zuweisungskompatibel sein sollen (s. Kurseinheit 4, Kapitel 40 und Kurseinheit 5, Abschnitt 50.4.2). Auch STRONGTALK stellt beide Möglichkeiten zur Verfügung.

Frage: Warum wurde in dieser Kurseinheit bisher nur über Typen gesprochen und Klassen ignoriert?
Antwort: Typen und Klassen werden getrennt behandelt, da Klassen die Implementierung von Objekten festlegen, während Typdefinitionen frei von Implementierungsaspekten sind.

Frage: Was ist der Zweck abstrakter Klassen, und warum enthalten sie normalerweise zumindest eine partielle Implementierung?
Antwort: Abstrakte Klassen können ausschließlich aus Methodendeklarationen bestehen und dienen dazu, eine gemeinsame partielle Implementierung für andere Klassen, einschließlich ihrer Subklassen, vorzugeben.

Frage: Was ist der Unterschied zwischen Typen und Klassen, wenn es um die Einschränkung des Wertebereichs von Variablen und die Angabe des Protokolls von Objekten geht?
Antwort: Typen sind abstrakte Spezifikationen, die den Wertebereich von Variablen und das Protokoll von Objekten festlegen. Klassen hingegen sind Konstrukte, die Objekte bilden und mit Implementierung versehen.

Frage: Wie ist der Zusammenhang zwischen Typen und Klassen in Bezug auf schematische Klassendefinitionen in SMALLTALK?
Antwort: In SMALLTALK enthalten Klassendefinitionen bestimmte Elemente, die auch in Typdefinitionen auftauchen, wie Namen, von denen Definitionen abgeleitet werden, und Methodennamen mit formalen Parametern.

Frage: Warum werden in SMALLTALKs Klassendefinitionen keine Typen verwendet, und wie werden formale Parameter in Bezug auf Typen behandelt?
Antwort: In SMALLTALK werden keine Typen in Klassendefinitionen verwendet, und formale Parameter verwenden stattdessen Namen wie "aString" oder "anInteger", die darauf hinweisen, welcher Klasse der Wert sein sollte. Dies wird jedoch nicht überprüft.

Frage: Wie unterscheidet sich die Verwendung von Klassendefinitionen in STRONGTALK von anderen Sprachen wie JAVA oder C++?
Antwort: In STRONGTALK sind formale Parameter in Klassendefinitionen typisiert, während in JAVA oder C++ Instanzvariablen nicht Teil einer Typdefinition sein können.