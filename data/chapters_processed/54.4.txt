54.4 Das Liskov-Substitutionsprinzip

In Bezug auf verhaltensbasiertes Subtyping haben die Arbeiten von Barbara Liskov und Jeannette Wing die größte Bekanntheit erlangt. Tatsächlich ist das sogenannte Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) eines der am häufigsten diskutierten Themen im Zusammenhang mit Subtyping, daher sollte es hier ebenfalls behandelt werden. Ohne die Verdienste der beiden schmälern zu wollen, sollte jedoch beachtet werden, dass die Anerkennung dieser Prinzipien nicht ausschließlich auf ihre Arbeit beschränkt ist. Es gab frühere Arbeiten, die ebenfalls Anerkennung verdienen, und außerdem ist das LSP, wie Sie noch sehen werden, zu streng formuliert und schließt nützliche und praxisrelevante Fälle des verhaltensbasierten Subtypings aus.


Frage: Was ist Liskov-Substitutionsprinzip (LSP)?
Antwort: Das Liskov-Substitutionsprinzip (LSP) ist ein Prinzip im Zusammenhang mit verhaltensbasiertem Subtyping. Es besagt, dass ein Objekt der Unterklasse eines anderen Objekts der Oberklasse ohne Einschränkung der Korrektheit des Programms ersetzt werden kann. Es ist eines der am häufigsten diskutierten Themen im Zusammenhang mit Subtyping.


Der historische Hintergrund des Liskov-Substitutionsprinzips bestand darin, eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen zu finden. Wie wir bereits in Kapitel 26 (Einheit 3) festgestellt hatten, reicht es in den meisten Programmiersprachen aus, wenn ein Typ B deklariert, ein Subtyp eines Typs A zu sein, damit die Zuweisungskompatibilität von B nach A festgestellt werden kann. Hierbei war es jedoch erforderlich, dass die Eigenschaften von A auf B übertragen (vererbt) wurden und dabei die Regeln für die ko- bzw. kontravariante Neudeklaration von Parametertypen eingehalten wurden. Dies wird im Allgemeinen durch die Sprachdefinition und den Compiler sichergestellt.


Frage: Was ist das Liskov-Substitutionsprinzip?
Antwort: Das Liskov-Substitutionsprinzip ist eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen. Es besagt, dass ein Typ B, der als Subtyp eines Typs A deklariert ist, in einem Programm an allen Stellen, an denen ein Objekt vom Typ A erwartet wird, durch ein Objekt vom Typ B ersetzt werden kann, ohne dass das Programm dadurch in seiner Funktionalität beeinträchtigt wird.


Das verhaltensbezogene Subtyping geht über die syntaktische Subtypenbeziehung hinaus, die sich auf die Kontrolle der Parametertypen beschränkt, und fordert stattdessen, dass sich Objekte eines Subtyps und seines Supertyps gleich verhalten sollten. Dies sollte für jeden erkennbar sein, der das Objekt oder ein beliebiges Programm, das es verwendet, betrachtet. Diese Forderung kulminiert in der Regel als "Subtype Requirement": "Lassen Sie φ(x) eine über Objekte x des Typs T bewiesene Eigenschaft sein. Dann sollte φ(y) für Objekte y des Typs S wahr sein, wobei S ein Subtyp von T ist." Eine deutsche Paraphrase dieser Idee wurde bereits im Abschnitt 26.1 gegeben.


Frage: Was ist verhaltensbezogenes Subtyping?
Antwort: Verhaltensbezogenes Subtyping geht über die syntaktische Subtypenbeziehung hinaus und fordert, dass sich Objekte eines Subtyps und seines Supertyps gleich verhalten sollten. Diese Forderung wird als "Subtype Requirement" bezeichnet und besagt, dass eine Eigenschaft, die für Objekte eines Typs gilt, auch für Objekte eines Subtyps gelten sollte.


Diese Definition weist mehrere problematische Aspekte auf: Da sie die Subtypenbeziehung definiert, wird davon ausgegangen, dass x genau vom Typ T und y genau vom Typ S ist. Dies bedeutet insbesondere, dass x und y keine Objekte von Subtypen von T bzw. S sein können. Daher ist diese Definition nicht auf abstrakte Typen und Interfaces anwendbar. Die Aussage ist unabhängig von einem konkreten Gebrauch der Objekte. Wie im Abschnitt 54.5 näher erläutert wird, kann Substituierbarkeit in einem bestimmten Kontext durchaus existieren, selbst wenn die Typen nach obiger Definition nicht substituierbar sind. In einem solchen Fall könnten die Anforderungen in einem Interfacetypen festgehalten werden, der nur die im Kontext benötigten Eigenschaften spezifiziert. Dieser Typ hat jedoch (gemäß Punkt 1) keine Objekte x. Die Aussage bezieht sich implizit auf alle möglichen Eigenschaften (Prädikate) φ, was bedeutet, dass alle Eigenschaften von T auch für S gelten sollen. Dies stellt die Idee des Subtypings in Frage, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Dies steht im Widerspruch zur eigentlichen Absicht des Subtypings: Wenn ein Objekt keine zusätzlichen Funktionen bietet, warum sollte man es dann überhaupt verwenden?


Frage: Was ist die Subtypenbeziehung?
Antwort: Die Subtypenbeziehung ist eine Beziehung zwischen zwei Typen, bei der der Untertyp alle Eigenschaften des Obertyps erfüllt. Das bedeutet, dass ein Objekt des Untertyps auch als Objekt des Obertyps behandelt werden kann. Diese Beziehung wird oft durch eine Hierarchie von Klassen dargestellt, bei der eine Unterklasse eine spezifischere Version einer Oberklasse ist.


Es ist jedoch zu beachten, dass die Bedingung in Punkt 3 möglicherweise abgeschwächt werden kann, indem sie sich auf das Verhalten des Programms bezieht und sicherstellt, dass es immer noch seinen beabsichtigten Zweck erfüllt, d.h., seiner Spezifikation genügt. Dies unterscheidet sich jedoch von dem, was im Prinzip ausgedrückt wird.


Frage: Was ist der Unterschied zwischen Verhalten des Programms und seiner Spezifikation?
Antwort: Die Spezifikation eines Programms beschreibt, was das Programm tun soll, während das Verhalten des Programms beschreibt, was das Programm tatsächlich tut. Die Spezifikation ist eine Art Blaupause oder Anleitung für das Programm, während das Verhalten das Ergebnis der Ausführung des Programms ist.


Liskov und Wing definieren zunächst eine Subtypenbeziehung zwischen S und T, die das oben genannte Subtype Requirement erfüllt. Diese Beziehung wird durch folgende Regeln beschrieben: Überschreibende Methoden in S übernehmen das Verhalten der überschriebenen Methoden in T. Dies umfasst: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode (die Typen der geworfenen Ausnahmen sind entweder Subtypen der Typen der Ausnahmen der überschriebenen Methode oder es werden überhaupt keine Ausnahmen ausgelöst; es dürfen keine zusätzlichen Ausnahmen auftreten). d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T.


Frage: Was definiert die Subtypenbeziehung zwischen S und T?
Antwort: Die Subtypenbeziehung zwischen S und T wird durch das Subtype Requirement definiert, das durch die folgenden Regeln beschrieben wird: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode. d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T.

Frage: Was besagt die Kontravarianz der Argumenttypen der überschreibenden Methode?
Antwort: Die Kontravarianz der Argumenttypen der überschreibenden Methode besagt, dass der Typ des Arguments der überschreibenden Methode ein Subtyp des Arguments der überschriebenen Methode sein muss.


Es ist zu beachten, dass die semantischen Regeln 1.d und 1.e die syntaktischen Regeln 1.a bis 1.c implizieren. In typlosen Sprachen wie Smalltalk würden die entsprechenden Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert, und die Menge der ausgelösten Ausnahmen wäre Teil der Nachbedingungen.


Frage: Was sind Vor- und Nachbedingungen in typlosen Sprachen?
Antwort: In typlosen Sprachen wie Smalltalk werden die Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert. Vorbedingungen beschreiben die Bedingungen, die vor der Ausführung einer Methode erfüllt sein müssen, während Nachbedingungen die Bedingungen beschreiben, die nach der Ausführung der Methode erfüllt sein müssen. Die Menge der ausgelösten Ausnahmen ist Teil der Nachbedingungen.


Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.


Frage: Was bedeutet Substituierbarkeit in diesem Kontext?
Antwort: In diesem Kontext bedeutet Substituierbarkeit, dass ein Objekt eines Untertyps an jeder Stelle, an der ein Objekt des Obertyps erwartet wird, verwendet werden kann, ohne dass die Korrektheit des Programms beeinträchtigt wird.

Frage: Was bedeutet die Wirksamkeit der Bedingungen in diesem Kontext?
Antwort: Die Wirksamkeit der Bedingungen bedeutet, dass die Subtypenregeln und die Korrektheit der überschreibenden Methode in S die gewünschte Substituierbarkeit gewährleisten.

Frage: Was bedeuten die Subtypenregeln und die Korrektheit der überschreibenden Methode in S für die Substituierbarkeit?
Antwort: Die Subtypenregeln und die Korrektheit der überschreibenden Methode in S bedeuten, dass die Unterklasse S die Bedingungen erfüllt, um eine Substitutionsinstanz der Oberklasse zu sein. Das heißt, dass ein Objekt der Unterklasse S an jeder Stelle, an der ein Objekt der Oberklasse erwartet wird, verwendet werden kann, ohne dass die Korrektheit des Programms beeinträchtigt wird.


Dennoch bleibt das zu Beginn beschriebene Problem mit Aliasbildung und der Möglichkeit zusätzlicher Methodenaufrufe bestehen. Liskov und Wing identifizieren zwei Lösungen: 1. Die erste Lösung besteht darin, die Aliasbildung zu vermeiden, indem man die Objekte, die als Argumente übergeben werden, kopiert. Dadurch wird sichergestellt, dass die Methode nur auf eine Kopie des Objekts zugreift und nicht auf das Original. Diese Lösung ist jedoch nicht immer möglich, da sie nur für kleine Objekte sinnvoll ist, die schnell kopiert werden können. 2. Die zweite Lösung besteht darin, die Aliasbildung zuzulassen, aber die Methodenaufrufe zu begrenzen. Das bedeutet, dass die Methode nur auf die Objekte zugreifen kann, die ihr als Argumente übergeben werden, und nicht auf die Objekte, auf die diese Objekte verweisen. Diese Lösung ist einfacher zu implementieren, da keine Kopien erstellt werden müssen, und sie ist auch für größere Objekte geeignet.

Frage: Wie kann das Problem der Aliasbildung bei der Übergabe von Objekten als Argumente gelöst werden?
Antwort: Das Problem der Aliasbildung kann durch zwei Lösungen gelöst werden: Die Aliasbildung wird vermieden, indem die Objekte, die als Argumente übergeben werden, kopiert werden. Dadurch wird sichergestellt, dass die Methode nur auf eine Kopie des Objekts zugreift und nicht auf das Original. Oder die Aliasbildung wird zugelassen, aber die Methodenaufrufe werden begrenzt, was bedeutet, dass die Methode nur auf die Objekte zugreifen kann, die ihr als Argumente übergeben werden, und nicht auf die Objekte, auf die diese Objekte verweisen.

Frage: Wie kann das Problem der Aliasbildung gelöst werden?
Antwort: Das Problem der Aliasbildung kann durch die Verwendung von lokalen Variablen gelöst werden, die eine Kopie des Objekts enthalten, oder durch die Verwendung von lokalen Prozeduren, die das Objekt manipulieren, ohne dass es zu einer Aliasbildung kommt.


Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existiert (oder deren überschriebene, verhaltenskonforme Varianten), die denselben Effekt wie die zusätzliche Methode hat und vom Klienten des Objekts selbst oder von einem anderen Klienten, der jedoch das Objekt als denselben Typ sieht, durchgeführt werden kann. Diese Bedingung ist ziemlich restriktiv, da sie im Wesentlichen besagt, dass ein Subtyp lediglich Makros hinzufügen darf. Auf der anderen Seite ist die Einhaltung dieser Bedingung, wenn auch nicht automatisch, zumindest intuitiv einfacher nachzuweisen, was in der Praxis von großer Bedeutung ist.


Frage: Was bedeutet es, wenn das Verhalten eines Subtyps mit dem des Supertyps kompatibel ist?
Antwort: Das Verhalten eines Subtyps ist mit dem des Supertyps kompatibel, wenn sämtliches zusätzliches Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Das bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existiert, die denselben Effekt wie die zusätzliche Methode hat und vom Klienten des Objekts selbst oder von einem anderen Klienten, der jedoch das Objekt als denselben Typ sieht, durchgeführt werden kann.


Die zweite Lösung ist weniger restriktiv, aber in der Praxis schwerer nachzuweisen. Sie erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden (einschließlich der üblichen Vor- und Nachbedingungen) die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet. Dazu wäre eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Das Problem dabei ist jedoch, dass die Zustände eines Objekts nicht abstrakt existieren, sondern sich in der Belegung von Instanzvariablen manifestieren. Daher ergibt sich der Zustandsraum kombinatorisch (abzüglich der funktionalen Abhängigkeiten der Attribute). Um dies zu umgehen, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss.


Frage: Was sind Zustandswechselinvarianten?
Antwort: Zustandswechselinvarianten sind Verlaufseigenschaften, die die möglichen Zustandsänderungen von Objekten betreffen. Sie werden benötigt, um eine weniger restriktive Lösung für die Spezifikation von Methoden zu ermöglichen, die neben Vor- und Nachbedingungen auch die Zustandsänderungen von Objekten berücksichtigt. Dazu ist eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Um den Zustandsraum kombinatorisch zu vermeiden, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss.


Es ist wichtig zu beachten, dass die Einhaltung der ersten Lösung die Einhaltung der zweiten Lösung impliziert: Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.


Frage: Wie hängen historische Invarianten und Zustandswechselinvarianten zusammen?
Antwort: Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.

Frage: Was sind historische Invarianten und Zustandswechselinvarianten?
Antwort: Historische Invarianten sind Bedingungen, die für den Zustand eines Objekts während seiner gesamten Lebensdauer gelten. Zustandswechselinvarianten sind Bedingungen, die für den Zustand eines Objekts während eines Zustandsübergangs gelten. Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.


Obwohl das Liskov-Substitutionsprinzip gut begründet ist, erweist es sich in der Praxis als zu restriktiv. Zum Beispiel könnte in einem Typ T eine Methode "echo: i <Integer> ^Integer" definiert werden, die den Eingabeparameter einfach ausgibt (die sogenannte Identitätsfunktion). In einem Subtyp S könnte diese Methode so überschrieben werden, dass sie beliebige Objekte entgegennimmt und sie unverändert zurückgibt: "echo: i <Object> ^ Object". Die Methode ist daher in ihrem Eingabeparameter kontravariant, aber nicht kovariant im Ausgabeparameter. Sie erfüllt somit nicht die Bedingungen des LSP. Dennoch kann "echo:" auf einem Objekt vom Typ S überall dort aufgerufen werden, wo es auf einem Objekt vom Typ T aufgerufen werden kann, ohne dass die Kovarianzregel des Ausgabeparameters verletzt wird. Das Liskov-Substitutionsprinzip stellt daher eine Typüberprüfung dar, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.


Frage: Was ist der Nachteil des Liskov-Substitutionsprinzips?
Antwort: Der Nachteil des Liskov-Substitutionsprinzips ist, dass es in der Praxis als zu restriktiv erweist und eine Typüberprüfung darstellt, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.

Frage: Warum erweist sich das Liskov-Substitutionsprinzip in der Praxis als zu restriktiv?
Antwort: Das Liskov-Substitutionsprinzip erweist sich in der Praxis als zu restriktiv, weil es eine Typüberprüfung darstellt, die gültige Programme ablehnt. Zum Beispiel, wenn eine Methode in einem Subtyp kontravariant im Eingabeparameter und nicht kovariant im Ausgabeparameter ist, erfüllt sie nicht die Bedingungen des LSP, aber sie kann trotzdem an jeder Stelle, an der die Methode im Basistyp erwartet wird, ohne Probleme verwendet werden. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.
