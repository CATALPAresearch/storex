54.4 Das Liskov-Substitutionsprinzip

In Bezug auf verhaltensbasiertes Subtyping haben die Arbeiten von Barbara Liskov und Jeannette Wing die größte Bekanntheit erlangt. Tatsächlich ist das sogenannte Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) eines der am häufigsten diskutierten Themen im Zusammenhang mit Subtyping, daher sollte es hier ebenfalls behandelt werden. Ohne die Verdienste der beiden schmälern zu wollen, sollte jedoch beachtet werden, dass die Anerkennung dieser Prinzipien nicht ausschließlich auf ihre Arbeit beschränkt ist. Es gab frühere Arbeiten, die ebenfalls Anerkennung verdienen, und außerdem ist das LSP, wie Sie noch sehen werden, zu streng formuliert und schließt nützliche und praxisrelevante Fälle des verhaltensbasierten Subtypings aus.
Der historische Hintergrund des Liskov-Substitutionsprinzips bestand darin, eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen zu finden. Wie wir bereits in Kapitel 26 (Einheit 3) festgestellt hatten, reicht es in den meisten Programmiersprachen aus, wenn ein Typ B deklariert, ein Subtyp eines Typs A zu sein, damit die Zuweisungskompatibilität von B nach A festgestellt werden kann. Hierbei war es jedoch erforderlich, dass die Eigenschaften von A auf B übertragen (vererbt) wurden und dabei die Regeln für die ko- bzw. kontravariante Neudeklaration von Parametertypen eingehalten wurden. Dies wird im Allgemeinen durch die Sprachdefinition und den Compiler sichergestellt.
Das verhaltensbezogene Subtyping geht über die syntaktische Subtypenbeziehung hinaus, die sich auf die Kontrolle der Parametertypen beschränkt, und fordert stattdessen, dass sich Objekte eines Subtyps und seines Supertyps gleich verhalten sollten. Dies sollte für jeden erkennbar sein, der das Objekt oder ein beliebiges Programm, das es verwendet, betrachtet. Diese Forderung kulminiert in der Regel als "Subtype Requirement": "Lassen Sie φ(x) eine über Objekte x des Typs T bewiesene Eigenschaft sein. Dann sollte φ(y) für Objekte y des Typs S wahr sein, wobei S ein Subtyp von T ist." Eine deutsche Paraphrase dieser Idee wurde bereits im Abschnitt 26.1 gegeben.
Diese Definition weist mehrere problematische Aspekte auf: Da sie die Subtypenbeziehung definiert, wird davon ausgegangen, dass x genau vom Typ T und y genau vom Typ S ist. Dies bedeutet insbesondere, dass x und y keine Objekte von Subtypen von T bzw. S sein können. Daher ist diese Definition nicht auf abstrakte Typen und Interfaces anwendbar. Die Aussage ist unabhängig von einem konkreten Gebrauch der Objekte. Wie im Abschnitt 54.5 näher erläutert wird, kann Substituierbarkeit in einem bestimmten Kontext durchaus existieren, selbst wenn die Typen nach obiger Definition nicht substituierbar sind. In einem solchen Fall könnten die Anforderungen in einem Interfacetypen festgehalten werden, der nur die im Kontext benötigten Eigenschaften spezifiziert. Dieser Typ hat jedoch (gemäß Punkt 1) keine Objekte x. Die Aussage bezieht sich implizit auf alle möglichen Eigenschaften (Prädikate) φ, was bedeutet, dass alle Eigenschaften von T auch für S gelten sollen. Dies stellt die Idee des Subtypings in Frage, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Dies steht im Widerspruch zur eigentlichen Absicht des Subtypings: Wenn ein Objekt keine zusätzlichen Funktionen bietet, warum sollte man es dann überhaupt verwenden?
Es ist jedoch zu beachten, dass die Bedingung in Punkt 3 möglicherweise abgeschwächt werden kann, indem sie sich auf das Verhalten des Programms bezieht und sicherstellt, dass es immer noch seinen beabsichtigten Zweck erfüllt, d.h., seiner Spezifikation genügt. Dies unterscheidet sich jedoch von dem, was im Prinzip ausgedrückt wird.
Liskov und Wing definieren zunächst eine Subtypenbeziehung zwischen S und T, die das oben genannte Subtype Requirement erfüllt. Diese Beziehung wird durch folgende Regeln beschrieben: Überschreibende Methoden in S übernehmen das Verhalten der überschriebenen Methoden in T. Dies umfasst: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode (die Typen der geworfenen Ausnahmen sind entweder Subtypen der Typen der Ausnahmen der überschriebenen Methode oder es werden überhaupt keine Ausnahmen ausgelöst; es dürfen keine zusätzlichen Ausnahmen auftreten). d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T.
Es ist zu beachten, dass die semantischen Regeln 1.d und 1.e die syntaktischen Regeln 1.a bis 1.c implizieren. In typlosen Sprachen wie Smalltalk würden die entsprechenden Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert, und die Menge der ausgelösten Ausnahmen wäre Teil der Nachbedingungen.
Die Wirksamkeit dieser Bedingungen kann wie folgt erklärt werden: Aus den oben genannten Subtypenregeln und der Korrektheit der überschreibenden Methode in S ergibt sich die gewünschte Substituierbarkeit.
Dennoch bleibt das zu Beginn beschriebene Problem mit Aliasbildung und der Möglichkeit zusätzlicher Methodenaufrufe bestehen. Liskov und Wing identifizieren zwei Lösungen:
Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existiert (oder deren überschriebene, verhaltenskonforme Varianten), die denselben Effekt wie die zusätzliche Methode hat und vom Klienten des Objekts selbst oder von einem anderen Klienten, der jedoch das Objekt als denselben Typ sieht, durchgeführt werden kann. Diese Bedingung ist ziemlich restriktiv, da sie im Wesentlichen besagt, dass ein Subtyp lediglich Makros hinzufügen darf. Auf der anderen Seite ist die Einhaltung dieser Bedingung, wenn auch nicht automatisch, zumindest intuitiv einfacher nachzuweisen, was in der Praxis von großer Bedeutung ist.
Die zweite Lösung ist weniger restriktiv, aber in der Praxis schwerer nachzuweisen. Sie erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden (einschließlich der üblichen Vor- und Nachbedingungen) die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet. Dazu wäre eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Das Problem dabei ist jedoch, dass die Zustände eines Objekts nicht abstrakt existieren, sondern sich in der Belegung von Instanzvariablen manifestieren. Daher ergibt sich der Zustandsraum kombinatorisch (abzüglich der funktionalen Abhängigkeiten der Attribute). Um dies zu umgehen, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss.
Es ist wichtig zu beachten, dass die Einhaltung der ersten Lösung die Einhaltung der zweiten Lösung impliziert: Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.
Obwohl das Liskov-Substitutionsprinzip gut begründet ist, erweist es sich in der Praxis als zu restriktiv. Zum Beispiel könnte in einem Typ T eine Methode "echo: i <Integer> ^Integer" definiert werden, die den Eingabeparameter einfach ausgibt (die sogenannte Identitätsfunktion). In einem Subtyp S könnte diese Methode so überschrieben werden, dass sie beliebige Objekte entgegennimmt und sie unverändert zurückgibt: "echo: i <Object> ^ Object". Die Methode ist daher in ihrem Eingabeparameter kontravariant, aber nicht kovariant im Ausgabeparameter. Sie erfüllt somit nicht die Bedingungen des LSP. Dennoch kann "echo:" auf einem Objekt vom Typ S überall dort aufgerufen werden, wo es auf einem Objekt vom Typ T aufgerufen werden kann, ohne dass die Kovarianzregel des Ausgabeparameters verletzt wird. Das Liskov-Substitutionsprinzip stellt daher eine Typüberprüfung dar, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.

Frage: Was ist das Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) und warum ist es wichtig?
Antwort: Das Liskov-Substitutionsprinzip (LSP) ist ein Prinzip im Zusammenhang mit Subtyping, das von Barbara Liskov und Jeannette Wing entwickelt wurde. Es besagt, dass ein Subtyp (z. B. eine abgeleitete Klasse) eines Typs (z. B. eine Basisklasse) sich so verhalten sollte, dass er anstelle des Supertyps (der Basisklasse) in jedem Programm oder Kontext verwendet werden kann, ohne die Korrektheit des Programms zu gefährden. Das LSP ist wichtig, um sicherzustellen, dass Subtypen die Spezifikationen und das Verhalten des Supertyps beibehalten und korrekt verwenden.

Frage: Warum wird darauf hingewiesen, dass das Liskov-Substitutionsprinzip nicht ausschließlich auf die Arbeiten von Barbara Liskov und Jeannette Wing beschränkt ist?
Antwort: Es wird darauf hingewiesen, dass das Liskov-Substitutionsprinzip nicht ausschließlich auf die Arbeiten von Barbara Liskov und Jeannette Wing beschränkt ist, um anzuerkennen, dass es frühere Arbeiten gab, die ebenfalls zur Entwicklung dieses Prinzips beigetragen haben. Das Prinzip selbst ist eine wichtige Konzeption in Bezug auf Subtyping und geht über die Beiträge einzelner Personen hinaus.

Frage: Warum ist das Liskov-Substitutionsprinzip möglicherweise zu streng formuliert?
Antwort: Das Liskov-Substitutionsprinzip (LSP) könnte zu streng formuliert sein, da es einige problematische Aspekte aufweist. Zum Beispiel geht es davon aus, dass Objekte genau die Typen T oder S haben, was nicht auf abstrakte Typen und Interfaces anwendbar ist. Außerdem verlangt es, dass alle Eigenschaften von T auch für S gelten, was im Widerspruch zur eigentlichen Absicht des Subtypings steht, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Daher könnte eine weniger strenge Formulierung des Prinzips notwendig sein.

Frage: Welche beiden Lösungen werden vorgeschlagen, um das Problem der Aliasbildung und zusätzlicher Methodenaufrufe zu lösen?
Antwort: Es werden zwei Lösungen vorgeschlagen, um das Problem der Aliasbildung und zusätzlicher Methodenaufrufe zu lösen: Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existieren muss, die denselben Effekt wie die zusätzliche Methode hat. Die zweite Lösung erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet und erfordern eine Art Spezifikation endlicher Automaten, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt.

Frage: Warum könnte das Liskov-Substitutionsprinzip in der Praxis als zu restriktiv angesehen werden?
Antwort: Das Liskov-Substitutionsprinzip (LSP) könnte in der Praxis als zu restriktiv angesehen werden, da es strengere Anforderungen an die Subtypen stellt und einige gültige Programme ablehnt. Zum Beispiel kann es vorkommen, dass ein Subtyp spezifische Methodenaufrufe erlaubt, die nicht im Supertyp vorhanden sind, aber dennoch in bestimmten Kontexten korrekt und sicher sind. Das LSP kann diese Fälle nicht berücksichtigen, was zu einer unnötigen Ablehnung von gültigen Programmen führen kann.