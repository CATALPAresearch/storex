29.5 Rekursiv beschränkter parametrischer Polymorphismus

Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Ein Beispiel für einen rekursiven Typ hatten Sie oben schon kennengelernt: Der (zur Klasse Person gehörende) Typ Person hat Methoden, die Person als Parameter- bzw. Rückgabetypen haben. Rekursive Typen sind ein wichtiges Instrument der Programmierung. Ohne sie wären dynamische Strukturen wie beispielsweise verschachtelte Listen oder Bäume kaum möglich. Rekursive Typen bringen jedoch auch bestimmte Probleme mit sich. Zum Beispiel ist die strukturelle Äquivalenz zweier rekursiver Typen nicht so leicht festzustellen, da die dazu notwendige Expansion rekursiver Typen (das Einsetzen der Struktur für jeden darin vorkommenden Typnamen; siehe Abschnitt 22.1) unendlich große Definitionen ergeben kann.
Ein weiteres Problem ergibt sich, wenn man in einer parametrischen Typdefinition den Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel halten möchte, dieser Typ jedoch der definierte Typ ist (eine binäre Methode; siehe Fußnote 21 in Kapitel 4.3). So möchte man beispielsweise den Test auf Gleichheit so definieren, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.
Nun ist jedoch Number ein Subtyp von Object, so dass man die Deklaration von "=" eigentlich aus Object übernehmen könnte, wenn der Typ des Parameters automatisch so angepasst würde, dass er dem definierten Typ entspricht. In einem ersten Ansatz wäre man vielleicht versucht, den Gleichheitstest in Object einfach als "= einObject <Self> ^ <Boolean>" zu deklarieren, aber das würde, wenn die Pseudo-Typvariable Self beim Subtyping jeweils den Subtyp annimmt, zu einer kovarianten Redefinition mit den bereits bekannten Problemen führen. Auch hier bietet der parametrische Polymorphismus eine Alternative, wenn auch nicht ganz so, wie vielleicht erwartet.
Man ersetzt dazu zunächst den Typ des Parameters durch eine Typvariable T. Was man machen kann, ist, einen allgemeinen parametrischen Typ zu definieren, der nur dem Zweck des Gleichheitstests dient und den Parametertyp des Tests variabel hält.
Man kann dann die gewünschte Rekursion indirekt, nämlich per Definition eines nicht parametrischen Typs als Subtyp des parametrisierten Typs Equatable herstellen, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.
Genau diese Beschränkung des tatsächlichen Typparameters kann man nun mit einer stilistischen Figur erreichen, die vermutlich manch einen von Ihnen erhebliche Kopfschmerzen bereiten wird (zumindest macht sie das mir immer wieder aufs Neue): Man beschränkt den formalen Typparameter T von Equatable auf einen Subtyp von Equatable[T], wobei das Vorkommen von T in Equatable[T] eine Verwendung der gerade erst eingeführten Typvariable T darstellt.
Wenn Sie hier ein Verständnisproblem haben, trösten Sie sich. Es dauert eine Weile, bis man es verstanden hat, und noch länger, bis solche Figuren zum aktiven Repertoire gehören. Gleichwohl sollten Sie sich damit befassen. Das JAVA-Collections-Framework in der Version von JAVA 5 ist voll solcher Typdefinitionen. Nicht weil sie schön sind, sondern weil man sie braucht, um das Framework typsicher zu machen, ohne seine Flexibilität zu opfern. Auch Sie werden, wenn Sie objektorientiert programmieren, über kurz oder lang solche Konstrukte verwenden müssen.

Frage: Was sind rekursive Typen, und warum sind sie wichtig?
Antwort: Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren, und sie sind wichtig, um dynamische Strukturen wie verschachtelte Listen oder Bäume in der Programmierung zu ermöglichen.

Frage: Welches Problem ergibt sich bei der strukturellen Äquivalenz von rekursiven Typen?
Antwort: Das Problem bei der strukturellen Äquivalenz von rekursiven Typen besteht darin, dass die Expansion rekursiver Typen unendlich große Definitionen ergeben kann, was die Feststellung der strukturellen Äquivalenz erschwert.

Frage: Warum ist die direkte Deklaration des Gleichheitstests in Object problematisch?
Antwort: Die direkte Deklaration des Gleichheitstests in Object wäre problematisch, da sie zu einer kovarianten Redefinition führen würde, was zu bekannten Problemen führt.

Frage: Wie kann der parametrische Polymorphismus zur Lösung des Problems der rekursiven Typen beitragen?
Antwort: Der parametrische Polymorphismus ermöglicht die Definition eines nicht parametrischen Typs als Subtyp eines parametrisierten Typs, wodurch die gewünschte Rekursion indirekt hergestellt werden kann.

Frage: Wie wird die Beschränkung des tatsächlichen Typparameters in der Typdefinition erreicht?
Antwort: Die Beschränkung des tatsächlichen Typparameters wird erreicht, indem der formale Typparameter auf einen Subtyp beschränkt wird.

Frage: Warum sind solche Konstrukte wichtig in der objektorientierten Programmierung?
Antwort: Solche Konstrukte sind wichtig in der objektorientierten Programmierung, da sie die Typsicherheit erhöhen und es ermöglichen, flexible Frameworks und komplexe Datenstrukturen zu erstellen. Sie sind in vielen modernen Programmiersprachen und Frameworks weit verbreitet.