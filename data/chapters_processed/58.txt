58 Das Problem der mangelnden Kapselung

Als man mit der objektorientierten Programmierung begann, war man glücklich, weil man glaubte, mit dem Konzept der Klassen eine natürliche Form der Kapselung (engl. encapsulation) gefunden zu haben, die zudem noch mit der hochangesehenen Theorie der abstrakten Datentypen in Einklang steht (zumindest einigermaßen): Klassen ergeben sich auf natürliche Weise aus der Anwendungsdomäne (als Repräsentanten von Allgemeinbegriffen), und Daten sowie Implementierungsdetails lassen sich hinter der Klassenschnittstelle (dem Protokoll der Objekte) verbergen.


Frage: Was ist die Bedeutung der Kapselung in der objektorientierten Programmierung?
Antwort: Die Kapselung ist ein Konzept in der objektorientierten Programmierung, bei dem Daten und Implementierungsdetails hinter der Klassenschnittstelle verbergen werden können. Das Konzept der Kapselung ermöglicht es, Klassen auf natürliche Weise aus der Anwendungsdomäne abzuleiten und trägt zur besseren Organisation und Strukturierung des Codes bei.

Frage: Was ist Kapselung in der objektorientierten Programmierung?
Antwort: Kapselung in der objektorientierten Programmierung ist ein Konzept, bei dem Daten und Implementierungsdetails in einer Klasse verborgen werden und nur über eine Schnittstelle (das Protokoll der Objekte) zugänglich sind. Dies ermöglicht es, die Komplexität von Systemen zu reduzieren und die Wartbarkeit und Erweiterbarkeit von Code zu verbessern.


Die erste große Enttäuschung kam, als man merkte, dass die ebenfalls gefeierte Vererbung die Kapselung von Klassen auf unangenehme Weise aufbrach: Wie bereits bemerkt, erzeugt die Vererbung starke Abhängigkeiten (auch zwischen den Implementierungsdetails!) von Klassen und ihren Subklassen. Diese Abhängigkeiten explizit zu machen kann zwar vor Programmierfehlern schützen, sie kann aber die Abhängigkeiten nicht beseitigen, sondern lediglich dokumentieren. Die Abhängigkeiten zu beschränken bedeutet wiederum, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben, aber so ist das nun einmal: Alles hat seinen Preis.


Frage: Wie wirkt sich Vererbung auf die Kapselung von Klassen aus?
Antwort: Vererbung kann die Kapselung von Klassen auf unangenehme Weise aufbrechen, indem sie starke Abhängigkeiten zwischen Klassen und ihren Subklassen erzeugt. Diese Abhängigkeiten explizit zu machen, kann zwar vor Programmierfehlern schützen, aber die Abhängigkeiten nicht beseitigen. Die Abhängigkeiten zu beschränken, bedeutet, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben.

Frage: Was sind die Nachteile der Vererbung in objektorientierter Programmierung?
Antwort: Die Vererbung in objektorientierter Programmierung kann die Kapselung von Klassen auf unangenehme Weise aufbrechen und starke Abhängigkeiten zwischen Klassen und ihren Subklassen erzeugen. Diese Abhängigkeiten explizit zu machen, kann zwar vor Programmierfehlern schützen, aber sie nicht beseitigen. Die Abhängigkeiten zu beschränken, bedeutet, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben.


Sehr viel dramatischer (und sehr viel weniger in aller Munde) ist jedoch ein ganz anderes Problem, das die gesamten bisherigen Bemühungen der Objektorientierung um Kapselung aushebeln kann: das Aliasing-Problem. Wenn nämlich ein Objekt, das durch ein anderes Objekt gekapselt wird, indem das andere es in einer seiner Instanzvariablen hält, einen (weiteren) Alias besitzt, der nicht selbst dem kapselnden Objekt gehört, dann nützt es nichts, wenn diese Instanzvariable von außen unzugreifbar ist91 — sie wird nämlich gar nicht gebraucht, um auf das gekapselte Objekt zuzugreifen. Man bedient sich einfach des Aliases.


Frage: Was ist das Aliasing-Problem in der Objektorientierung?
Antwort: Das Aliasing-Problem ist ein Problem in der Objektorientierung, bei dem ein Objekt, das durch ein anderes Objekt gekapselt wird, einen weiteren Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dadurch kann man auf das gekapselte Objekt zugegriffen werden, auch wenn die Instanzvariable von außen unzugreifbar ist.


In SMALLTALK wird das Problem in folgendem Beispiel klar: Hier soll ein neues Objekt der Klasse A erzeugt werden und die Erzeugungszeit in einer entsprechenden Instanzvariable des Objekts festgehalten werden. Die Variable "jetzt" hält aber einen Alias auf das Objekt, das diese Zeit repräsentiert; ändert man dieses Zeitobjekt (wie in Zeile 1534), dann betrifft dies auch die Erzeugungszeit des Objekts "a".92 Nun könnte man meinen, es genügte, man ersparte sich einfach den (offensichtlichen) Alias "jetzt". Dies ist aber nicht möglich, weil "Time now" ein Ausdruck ist, der zur Laufzeit ausgewertet wird, während die Instanzvariable "erzeugungsZeit" zur Erzeugungszeit initialisiert werden muss. Dies führt aber zu einem anderen Problem: Die Variable "a" ist eine Verweisvariable, d.h. sie enthält nicht den Wert des Objekts, sondern einen Verweis auf das Objekt. Die Zuweisung in Zeile 1535 erzeugt daher keinen neuen Zeitpunkt, sondern verändert den bestehenden. Dies führt aber zu einem noch unerwarteteren Ergebnis: Die Variable "a" enthält einen Verweis auf ein neues Objekt, aber die Instanzvariable "erzeugungsZeit" des Objekts enthält den Wert der Instanzvariable "erzeugungsZeit" des alten Objekts.

Frage: Was ist der Unterschied zwischen Verweisvariablen und Wertvariablen?
Antwort: Verweisvariablen enthalten einen Verweis auf ein Objekt, während Wertvariablen den Wert des Objekts enthalten.

Frage: Was ist der Unterschied zwischen einem Alias und einem Wert?
Antwort: Ein Alias ist eine Referenz auf ein Objekt, während ein Wert eine eigene Kopie des Objekts ist. Wenn man einen Alias ändert, dann ändert man das Originalobjekt, während man bei einem Wert nur die Kopie ändert. Im Beispiel von "jetzt" und "Time now" sind beide Alias auf das gleiche Zeitobjekt, und wenn man das Zeitobjekt ändert, dann ändert sich auch die Erzeugungszeit von "a".


Woher weiß man aber, dass die Methode "now" in der Klasse "Time" nicht einen Alias auf jedes neu erzeugte Objekt anlegt (beispielsweise weil "Time" Buch darüber führt, welche Instanzen es von ihr gibt) und diesen Alias nicht herausgibt oder selbst verwendet, um die Objekte zu manipulieren? Auch die alternative scheinbare Lösung, "Erzeugungsdatum" funktioniert aus gleichem Grunde nicht zuverlässig, denn auch "copy" kann sich (heimlich) Aliase anlegen.


Frage: Wie kann man sicherstellen, dass eine Methode in einer Klasse keine Aliase anlegt und verwendet?
Antwort: Um sicherzustellen, dass eine Methode in einer Klasse keine Aliase anlegt und verwendet, kann man die Implementierung der Klasse überprüfen und sicherstellen, dass sie keine Aliase erstellt oder verwendet. Zusätzlich kann man die Sprache und die Laufzeitumgebung überprüfen, um sicherzustellen, dass sie keine Aliase automatisch erzeugen.


Ein anderes Beispiel, bei dem Aliase fehlerhaft eingesetzt werden, ist das folgende. Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Das ist hier aber gar nicht der Punkt.


Frage: Was ist ein Beispiel für fehlerhafte Verwendung von Aliase?
Antwort: Ein Beispiel für fehlerhafte Verwendung von Aliase ist das folgende: Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Wenn man Aliase fehlerhaft einsetzt, kann es passieren, dass eine Änderung an einer Leuchte sich auf andere Leuchten auswirkt, obwohl dies nicht beabsichtigt war.


Man nennt Objekte, die die Implementierung eines Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen, "Repräsentationsobjekte". Die Leuchten des obigen Beispiels sind allesamt Repräsentationsobjekte; sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen. Insbesondere gibt es in obigem Beispiel keine Verwendung einer Leuchte losgelöst von einer Ampel. Dies muss aber nicht für alle Leuchten der Fall sein — es ist durchaus denkbar, dass Leuchtenobjekte in anderen oder sogar im selben Programm auch ein unabhängiges Leben (außerhalb von Ampeln) führen. Aber selbst das ist gar nicht notwendig — im gegebenen Beispiel wäre es auch denkbar, dass mit Leuchten noch einiges gemacht wird, bevor sie in eine Ampel eingebaut werden, so dass man das Aliasing-Problem weder pauschal an die Klasse "Leuchte" noch an deren Verwendung als Lieferant für Repräsentationsobjekte knüpfen kann.


Frage: Was sind Repräsentationsobjekte?
Antwort: Repräsentationsobjekte sind Objekte, die die Implementierung eines anderen Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen. Sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen.


Wenn Aliase also schlecht sind, könnte man sie ja auch einfach verbieten. Tatsächlich bieten einige Programmiersprachen wie C-Sharp, C++ und EIFFEL die Möglichkeit, Klassen als Werttypen zu definieren, sodass bei Zuweisungen nicht automatisch Aliase entstehen. Aber durch eine derart einfache Lösung schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein, wie das folgende Beispiel zeigt:

Frage: Was sind die Nachteile, wenn Aliase in Programmiersprachen verboten werden?
Antwort: Wenn Aliase in Programmiersprachen verboten werden, schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein. Ein Beispiel dafür ist die Verwendung von Klassen als Werttypen in Programmiersprachen wie C-Sharp, C++ und EIFFEL, bei der bei Zuweisungen nicht automatisch Aliase entstehen.

Frage: Warum können Aliase ein Problem sein?
Antwort: Aliase sind Variablen, die auf das gleiche Objekt verweisen. Sie können schlecht sein, weil sie zu unerwarteten Nebenwirkungen führen können, wenn man nicht vorsichtig ist. Wenn man beispielsweise den Zustand eines Objekts über eine Variable ändert, kann dies auch den Zustand über eine andere Variable beeinflussen, die auf dasselbe Objekt verweist. Dies kann zu Verwirrung und Fehlern führen. Einige Programmiersprachen bieten die Möglichkeit, Klassen als Werttypen zu definieren, um das Entstehen von Aliase zu vermeiden.


Es ist gerade der Sinn eines Dictionaries (bzw. allgemeiner eines Containers wie einer Collection), dass keine Kopie, sondern das originale Objekt — also ein Zeiger darauf — gespeichert wird! In einer Sprache ohne Referenzsemantik wäre das jedoch nicht möglich. Man braucht also die Möglichkeit, fallweise zu unterscheiden, ob ein Objekt Aliase haben darf. Das obige Beispiel stellt insofern kein großes Problem dar, als der fehlerhafte Umgang mit dem Aliasing durch unerwartetes Programmverhalten auffällt. Ein viel größeres Problem entsteht, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, die Existenz von Aliasen also mit der Spezifikation nicht vereinbar wäre. Dies ist bei allen sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Gibt es dann Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger, dann ist die Spezifikation nicht erfüllt. Am Programmverhalten ist dies jedoch nicht zu erkennen.


Frage: Was ist der Unterschied zwischen einer Kopie und einem Zeiger in Bezug auf Objekte?
Antwort: In Bezug auf Objekte ist eine Kopie eine unabhängige Instanz des Objekts, während ein Zeiger auf das originale Objekt verweist. In Sprachen ohne Referenzsemantik ist es nicht möglich, Zeiger zu verwenden, während Sprachen mit Referenzsemantik dies ermöglichen.

Frage: Was ist Aliasing und wie kann es bei der Spezifikation von sicherheitskritischen Anwendungen problematisch sein?
Antwort: Aliasing bedeutet, dass mehrere Variablen auf das gleiche Objekt verweisen. Bei der Spezifikation von sicherheitskritischen Anwendungen kann Aliasing problematisch sein, da es mit der Spezifikation nicht vereinbar wäre, wenn es von außen auf geheime Daten- oder Funktionsträger gibt. Am Programmverhalten ist dies jedoch nicht zu erkennen.

Frage: Warum können Aliase ein Problem bei sicherheitskritischen Anwendungen darstellen?
Antwort: Aliase können ein Problem bei sicherheitskritischen Anwendungen darstellen, da sie mit der Spezifikation nicht vereinbar wären. Wenn es Aliase von außen auf geheime Daten- oder Funktionsträger gibt, ist die Spezifikation nicht erfüllt.

Frage: Was ist Aliasing und wie kann es zu Problemen führen?
Antwort: Aliasing bedeutet, dass mehrere Variablen auf das gleiche Objekt verweisen. Dies kann zu Problemen führen, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, da Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger zugreifen können. Dies ist bei sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Am Programmverhalten ist dies jedoch nicht zu erkennen.


Nachdem das Problem nun hinreichend klar geworden sein sollte, was kann man dagegen tun? Zunächst einmal muss noch einmal klargestellt werden, dass die Deklaration von Instanzvariablen als von außen unzugreifbar (private) lediglich Namen verbirgt — man kann über die Schnittstelle des Objekts nicht herausfinden, wie es intern aufgebaut ist. Dieser Namensschutz (engl. name protection) ist das, was man landläufig (mit dem Wissen vom Aliasing-Problem) mit Geheimnisprinzip (engl. information hiding) verbindet: Es verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, so dass diese problemlos geändert (z. B. umbenannt oder entfernt) werden können.


Frage: Was ist der Unterschied zwischen Namensschutz und Geheimnisprinzip?
Antwort: Namensschutz (name protection) verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, indem es ihre Namen verbirgt. Das Geheimnisprinzip (information hiding) hingegen verhindert, dass andere Klassen von der Implementierung eines Objekts abhängen, indem es die Möglichkeit schafft, die Implementierung ohne Auswirkungen auf andere Klassen zu ändern.

Frage: Was wird durch den Namensschutz verhindert?
Antwort: Der Namensschutz verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, sodass diese problemlos geändert werden können.


Das Geheimnisprinzip vermag jedoch nicht zu verhindern, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen. Dies kann z. B. immer dann der Fall sein (und ist vom Objekt, das sein Implementationsgeheimnis wahren will, kaum zu verhindern), wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt (genau so, wie das in den obigen Beispielen in den Zeilen 1533, 1535 und 1540 der Fall war). Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter, aber das wäre dann vom „verbergenden“ Objekt selbst zu verantworten (und zu verhindern gewesen).


Frage: Was besagt das Geheimnisprinzip?
Antwort: Das Geheimnisprinzip besagt, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen können, z.B. wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt. Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter.

Frage: Wie kann das Geheimnisprinzip umgangen werden?
Antwort: Das Geheimnisprinzip kann umgangen werden, indem Repräsentationsobjekte, deren Namen verborgen werden sollen, noch andere Namen besitzen, zum Beispiel wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt oder wenn das Objekt selbst eine Referenz auf ein Repräsentationsobjekt herausgibt, beispielsweise durch einen Getter.


Sobald also die Möglichkeit des Aliasing besteht, ist eine echte Kapselung über das Geheimnisprinzip allein nicht mehr zu gewährleisten. Man muss also das Aliasing irgendwie kontrollieren. Die Frage ist nur: Wie?


Frage: Was ist Aliasing und wie kann es kontrolliert werden?
Antwort: Aliasing bedeutet, dass mehrere Variablen auf ein und dasselbe Objekt verweisen. Um Aliasing zu kontrollieren, muss man sicherstellen, dass dies nicht geschieht oder dass es bei der Ausführung des Programms keine negativen Auswirkungen hat. Dies kann durch verschiedene Methoden erreicht werden, wie zum Beispiel durch die Verwendung von lokalen Variablen oder durch Kopien von Objekten anstelle von Referenzen.


Eine Möglichkeit hatten wir bereits mehrfach angesprochen. Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Von den in genannten Programmiersprachen ist das jedoch nur in C-Sharp, und da auch nur im Safe mode, möglich, nämlich wenn die „Klasse“ der Teil-Objekte per "struct" definiert wurde. Abgesehen von dieser Einschränkung ist eine solche Vorgehensweise nur selten ohne unerwünschte Nebenwirkungen — sie bedeutet nämlich immer auch, dass alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was aber die Anwendungsdomäne in der Regel nicht korrekt abbildet.


Frage: Wie kann man die Teil-Ganzes-Beziehung zwischen Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, in Programmierung verstehen?
Antwort: Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können.

Frage: Wie kann man verhindern, dass Objekte von anderen Objekten referenziert werden können?
Antwort: Eine Möglichkeit, dies zu verhindern, ist, aus den Objekten Wertobjekte zu machen und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Dies ist jedoch nur in einigen Programmiersprachen möglich, wie zum Beispiel in C-Sharp im Safe mode, wenn die „Klasse“ der Teil-Objekte per "struct" definiert wurde. Diese Vorgehensweise ist jedoch nur selten ohne unerwünschte Nebenwirkungen, da alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was die Anwendungsdomäne in der Regel nicht korrekt abbildet.

Frage: Warum verhindert die Verwendung von Wertobjekten in C-Sharp, dass die Objekte referenziert werden können?
Antwort: In C-Sharp können, wenn die „Klasse“ der Teil-Objekte per "struct" definiert wurde, keine Zeiger auf Wertobjekte erstellt werden, was bedeutet, dass die Objekte nicht von anderen Objekten referenziert werden können.


Vor diesem Hintergrund scheint der in Abschnitt 52.5.2 dargelegte Umgang EIFFELs mit Referenz- und Wertvariablen ziemlich schlau ausgedacht zu sein. Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei. Dumm ist nur, wenn man innerhalb der Kapsel Aliase auf Wertobjekte braucht. Weitergehende Mechanismen zur Aliaskontrolle in objektorientierten Programmiersprachen befinden sich derzeit alle noch in der Vorschlags- und Erprobungsphase und sollen hier deswegen nicht weiter behandelt werden.


Frage: Wie geht EIFFEL mit Referenz- und Wertvariablen um?
Antwort: EIFFEL erlaubt, auf Wertobjekte Referenzen zu haben, aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Somit sind Wertobjekte in EIFFEL aliasfrei.
