22 Typäquivalenz

Es stellt sich nun die Frage, wann ein Typ mit einem anderen zuweisungskompatibel ist. Offensichtlich ist dies der Fall, wenn die Typen identisch sind. Wie bereits oben erwähnt, ist dies jedoch keine notwendige Voraussetzung für die Zuweisungskompatibilität. Es ist nämlich auch möglich, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind. Man spricht in diesen Fällen von einer Typäquivalenz.


Frage: Was ist Typäquivalenz?
Antwort: Typäquivalenz bedeutet, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind.

Frage: Wann sind zwei Typen zuweisungskompatibel?
Antwort: Zwei Typen sind zuweisungskompatibel, wenn sie identisch sind oder wenn sie eine Typäquivalenz aufweisen, d.h. wenn sie bis auf ihre Namen gleich sind.

Frage: Was ist die Voraussetzung für die Zuweisungskompatibilität von zwei Typen?
Antwort: Die Voraussetzung für die Zuweisungskompatibilität von zwei Typen ist, dass sie identisch sind oder eine Typäquivalenz aufweisen, d.h. sich die Typdefinitionen bis auf ihre Namen gleichen.


Von der Typäquivalenz gibt es zwei Arten: die nominale (sich auf den Namen beziehende) Typäquivalenz, auch Namensäquivalenz genannt, und die strukturelle Typäquivalenz, auch als Strukturäquivalenz bezeichnet. Während die nominale Typäquivalenz verlangt, dass zwei Deklarationen (beispielsweise von Variablen) dieselben Typen angeben, damit Zuweisungskompatibilität vorliegt, kommt es bei der strukturellen Typäquivalenz lediglich darauf an, dass die Typen paarweise gleich definiert sind (also die gleichen Eigenschaften von ihren Werten verlangen). Die Typen müssen sich also in ihrer Struktur, aber nicht unbedingt in ihren Namen gleichen.


Frage: Was ist der Unterschied zwischen nominaler und struktureller Typäquivalenz?
Antwort: Nominale Typäquivalenz bezieht sich auf den Namen von Typen, während strukturelle Typäquivalenz auf die Struktur von Typen abzielt. Bei nominaler Typäquivalenz müssen zwei Deklarationen denselben Typnamen haben, während bei struktureller Typäquivalenz die Typen paarweise gleich definiert sein müssen, d.h. sie müssen die gleichen Eigenschaften von ihren Werten verlangen.


Typäquivalenz ist eine symmetrische Eigenschaft: Wenn ein Typ A (nominal oder strukturell) äquivalent zu einem Typ B ist, dann ist B genauso äquivalent zu A. Die Reflexivität der Typäquivalenz, also dass jeder Typ äquivalent zu sich selbst ist, ergibt sich von selbst. Außerdem ist Typäquivalenz transitiv: Wenn A (nominal oder strukturell) äquivalent zu B ist und B in der gleichen Art äquivalent zu C ist, dann ist auch A äquivalent zu C (und, aufgrund der Symmetrie, C äquivalent zu A).


Frage: Was ist Typäquivalenz?
Antwort: Typäquivalenz ist eine Eigenschaft, die angibt, ob zwei Typen gleichwertig sind. Sie ist symmetrisch, reflexiv und transitiv. Das bedeutet, dass wenn Typ A äquivalent zu Typ B ist, dann ist auch Typ B äquivalent zu Typ A, Typ A äquivalent zu sich selbst und wenn Typ A äquivalent zu Typ B und Typ B äquivalent zu Typ C, dann ist auch Typ A äquivalent zu Typ C.

Frage: Was ist Typäquivalenz und welche Eigenschaften hat sie?
Antwort: Typäquivalenz ist eine Eigenschaft, die angibt, ob zwei Typen gleichwertig sind. Sie ist symmetrisch, reflexiv und transitiv. Das bedeutet, wenn Typ A äquivalent zu Typ B ist, dann ist auch B äquivalent zu A, jeder Typ ist äquivalent zu sich selbst und wenn A äquivalent zu B ist und B äquivalent zu C, dann ist auch A äquivalent zu C.

Frage: Was ist die Transitivität der Typäquivalenz?
Antwort: Die Transitivität der Typäquivalenz bedeutet, dass wenn ein Typ A äquivalent zu einem Typ B ist und Typ B wiederum äquivalent zu einem Typ C ist, dann ist auch Typ A äquivalent zu Typ C. Diese Eigenschaft ist wichtig, um sicherzustellen, dass die Typäquivalenz konsistent ist und dass die Typisierung von Ausdrücken und Variablen in einem Programm konsistent bleibt.
