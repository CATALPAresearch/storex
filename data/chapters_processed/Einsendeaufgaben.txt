Einsendeaufgaben

Frage: Warum sind identische Objekte immer gleich, gleiche Objekte aber nicht identisch?
Antwort: Objekte sind Stellen im Speicher, an denen die Daten, die ein Objekt ausmachen, hinterlegt sind. Die Identität eines Objekts ist mit der Speicherstelle gleichzusetzen. Das erklärt auf technische Weise, warum identische Objekte immer gleich, gleiche Objekte aber nicht identisch sind und warum die Veränderung (der Eigenschaften) eines Objekts seine Identität nicht berührt.

Frage: Welchen Sinn hat es, den Programmierenden zu erlauben für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll? 
Antwort: Unter Wertsemantik können, solange jedes Objekt seine eigene Identität hat, zwei Variablen niemals dasselbe Objekt bezeichnen. Dies wird für die objektorientierte Programmierung eher als Nachteil angesehen. Manche Programmiersprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll. Auf diesem Weg kann man Aliase vermeiden. Dies sollte man dann tun, wenn man verhindern möchte, dass die Veränderung des durch eine Variable bezeichneten Objekts zugleich die Veränderung der durch all seine Aliase bezeichneten Objekte (die ja alle dieselben sind) bewirkt. Bei einer Zuweisung unter Wertsemantik muss, da die Variable das Objekt zum Inhalt hat (also in der Variable gespeichert ist) und ein Objekt nicht in zwei Variablen gespeichert sein kann, eine Kopie angefertigt werden.

Frage: Was sind Instanzvariablen?
Antwort: Jedem Objekt kann eine Menge von lokalen Variablen zugeordnet werden, die Instanzvariablen. Die Instanzvariablen eines Objekts sind in gewisser Weise in seinem Besitz: In SMALLTALK sind sie für andere Objekte nicht sichtbar und damit auch nicht zugreifbar. Die Sichtbarkeit ist also auf das jeweils besitzende Objekt eingeschränkt. 

Frage: Wie gelangen in SMALLTALK Objekte in den Besitz von Instanzvariablen?
Antwort: Man verbindet die Instanzvariablen mit Klassen und vereinbart, dass alle mit einer Klasse verbundenen Eigenschaften und Verhaltensspezifikationen nicht die Klasse in ihrer Gesamtheit, sondern die einzelnen Objekte, die zu der Klasse gehören, beschreiben. Klassendefinitionen bilden also eine Art Vorlage für Objekte. Um nun von einer solchen Vorlage Objekte mit Eigenschaften (Instanzvariablen und Methoden), wie sie durch die Definition (Intension) festgelegt sind, zu erzeugen, muss man sie instanziieren. Die Instanziierung ist ein Vorgang, bei dem ein neues Objekt entsteht. Mittels Instanziierung und Klassen hat man nun die Möglichkeit, neue - und neuartige - Objekte programmatisch, also per Programmausführung, zu erzeugen. Dies geschieht standardmäßig, indem man der Klasse, von der man eine Instanz haben möchte, die Nachricht new (für Klassen ohne indizierte Instanzvariablen) oder new: (für Klassen mit indizierten Instanzvariablen) schickt. Das neue Objekt wird in Reaktion auf die Nachricht (durch eine entsprechende primitive Methode des SMALLTALK-Systems) im Speicher angelegt und seine Instanzvariablen werden alle mit nil initialisiert.

Frage: Wie werden Beziehungen eines Objekts zu einem anderen in SMALLTALK realisiert?
Antwort: Die Beziehung eines Objekts zu einem anderen wird auf natürliche Weise durch eine benannte Instanzvariable ausgedrückt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung trägt. Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren andern stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die Namen der Gegenüber sind einfach Indizes: 1, 2, 3 usw. 

Frage: Wie werden Beziehungen eines Objekts zu mehreren anderen in SMALLTALK realisiert?
Antwort: Die Beziehung eines Objekts zu einem anderen wird auf natürliche Weise durch eine benannte Instanzvariable ausgedrückt, wobei die Instanzvariable den Namen der Beziehung oder, besser noch, den Namen der Rolle des von der Variablen referenzierten Objektes in der Beziehung trägt. Ein Objekt kann, und wird häufig, in derselben Beziehung zu mehreren andern stehen. Genau dafür sind aber die indizierten Instanzvariablen wie geschaffen: Sie erlauben es, von einem Objekt zu beliebig vielen anderen Objekten zu navigieren, ohne für jedes andere eine eigene (jeweils anders) benannte Instanzvariable vorsehen zu müssen. Die Namen der Gegenüber sind einfach Indizes: 1, 2, 3 usw. 

Frage: Wie kann man die Komposition in objektorientierten Programmiersprachen umsetzen?
Antwort: Die meisten (objektorientierten) Programmiersprachen bieten leider überhaupt kein Sprachkonstrukt an, das speziell für die Teil-Ganzes-Beziehung gedacht wäre. Gleichwohl kann man die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik, falls vorhanden, dazu nutzen, um zumindest eine spezielle Form der Teil-Ganzes-Beziehung abzubilden: Da bei Wertsemantik mit der Entfernung eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt werden, kann man hier tatsächlich von der Umsetzung einer bestimmten Form von Teil- Ganzes-Beziehung sprechen, nämlich einer solchen, bei der die Existenz der Teile von der Existenz des Ganzen abhängt (in der UML auch Komposition genannt). 

Frage: Was macht den Zustand eines Objektes aus?
Antwort: Der Zustand eines Objektes ist die Summe der Belegungen seiner Instanzvariablen - er wird ausschließlich durch die Verknüpfung mit anderen Objekten definiert. Es folgt, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, der über die Zuweisung von Instanzvariablen ist. 

Frage: Wie verändert man den Zustand eines Objektes?
Antwort: Der Zustand eines Objektes ist die Summe der Belegungen seiner Instanzvariablen - er wird ausschließlich durch die Verknüpfung mit anderen Objekten definiert. Es folgt, dass die einzige Möglichkeit, den Zustand eines Objekts zu ändern, der über die Zuweisung von Instanzvariablen ist. 

Frage: Welche beiden Formen von Ausdrücken sind wichtige Ausdrucksformen für die objektorientierte Programmierung?
Antwort: Die Zuweisungen und die Nachrichtenausdrücke sind wichtig. Zuweisungen bewirken als einzige Ausdrücke den Zustandswechsel von Objekten. Die Nachrichtenausdrücke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand ändern. Nachrichtenausdrücke werden ausgewertet, in dem die Nachricht an das Empfängerobjekt mit den Parametern gesendet und das Empfängerobjekt als Ergebnis der Nachricht ein Objekt zurückliefert.

Frage: Warum sind Zuweisungen wichtige Ausdrucksformen?
Antwort: Die Zuweisungen und die Nachrichtenausdrücke sind wichtig. Zuweisungen bewirken als einzige Ausdrücke den Zustandswechsel von Objekten. Die Nachrichtenausdrücke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand ändern. Nachrichtenausdrücke werden ausgewertet, in dem die Nachricht an das Empfängerobjekt mit den Parametern gesendet und das Empfängerobjekt als Ergebnis der Nachricht ein Objekt zurückliefert.

Frage: Warum sind Nachrichtenausdrücke wichtige Ausdrucksformen?
Antwort: Die Zuweisungen und die Nachrichtenausdrücke sind wichtig. Zuweisungen bewirken als einzige Ausdrücke den Zustandswechsel von Objekten. Die Nachrichtenausdrücke sind wichtig, weil ja das Weltbild der objektorientierten Programmierung umgesetzt werden muss: Es gibt Objekte, die einander Nachrichten schicken und die in Reaktion auf diese Nachrichten ihren Zustand ändern. Nachrichtenausdrücke werden ausgewertet, in dem die Nachricht an das Empfängerobjekt mit den Parametern gesendet und das Empfängerobjekt als Ergebnis der Nachricht ein Objekt zurückliefert.

Frage: Was beschreiben Methodendefinitionen? 
Antwort: Methodendefinitionen beschreiben, was ein Objekt in Reaktion auf den Erhalt einer entsprechenden Nachricht tun soll. 

Frage: Wie funktioniert das Versenden von Nachrichten in SMALLTALK? 
Antwort: Aus Effizienzgründen wird in SMALLTALK ein Nachrichtenausdruck in einen Methodenaufruf übersetzt. Wann immer ein Objekt eine Nachricht an ein Empfängerobjekt verschickt, wechselt der Kontrollfluss damit zum Empfängerobjekt, genauer zu der Methode des Empfängerobjekts, das zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung der Methode kehrt der Kontrollfluss an das sendende Objekt (genauer: zu der Methode, aus der die Nachricht versandt wurde) zurück und setzt seine Arbeit dort fort. Bei der Rückkehr wird auch das Ergebnis der Methode, (eine Referenz auf) ein Objekt, geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Es gibt aber auch die Variante mittels perform:. In SMALLTALK sind auch Nachrichten Objekte. Um tatsächlich als Nachrichtenobjekt an ein Objekt verschickt zu werden, muss man sich eines speziellen Methodenaufrufs, perform:, bedienen, der es erlaubt, einem Empfängerobjekt eine Nachricht als Objekt (wenn auch nur als Parameter von perform:) zu senden. Das Empfängerobjekt reagiert darauf mit der Abarbeitung der zur Nachricht passenden Methode ganz so, als hätte es direkt einen entsprechenden Methodenaufruf erhalten.

Frage: Was ist der Unterschied von Methodenaufrufen in der objektorientierten Programmierung zum gewöhnlichen Prozeduraufruf
Antwort: Methodenaufrufe in der objektorientierten Programmierung werden oft mit Funktionsaufrufen in der prozeduralen Programmierung verglichen. Der Unterschied besteht in der Abhängigkeit vom Empfängerobjekt: Die Entscheidung, welche Methode in Reaktion auf einen Nachrichtenversand aufgerufen und abgearbeitet wird, hängt nicht von dem Nachrichtenselektor allein ab, sondern auch von dem Objekt, an das die Nachricht geschickt wird. Es ist nämlich durchaus üblich, dass verschiedene Objekte mit gleichen Methodensignaturen unterschiedliche Methodenimplementierungen verbinden; so implementieren beispielsweise Zahlen und Symbole die Methode printString jeweils anders. Aus der Abhängigkeit des Methodenaufrufs vom Empfängerobjekt folgt, dass nicht immer schon zur übersetzungszeit entschieden werden kann, welche Methodenimplementierung bei einem Methodenaufruf ausgewählt werden muss. Wenn nämlich das Empfängerobjekt durch eine Variable benannt oder von einem Ausdruck geliefert wird, kann die Zuordnung einer Methodendefinition zu einem Nachrichtenausdruck erst zum Zeitpunkt der Auswertung des Nachrichtenausdrucks und damit erst zur Laufzeit erfolgen (dynamisches Binden).

Frage: Was unterscheidet die klassenbasierte von der prototypenbasierten Form der objektorientierten Programmierung?
Antwort: Es ist bei der klassenbasierten Form nicht vorgesehen, dass verschiedene Instanzen einer Klasse über verschiedene Definitionen einer Methode (genauer: über verschiedene Definitionen von zu der Nachricht passenden Methoden) verfügen. Die prototypenbasierte Form der Objektorientierung kann sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen, z.B. indem sie eine Methodendefinition nur für ein einziges Objekt abzuändern erlaubt. Letzteres ist z.B. bei der Programmierung von grafschen Bedienoberflächen, bei der das Drücken verschiedener Buttons jeweils verschiedene Ereignisse auslöst (Methoden aufruft), sehr praktisch. 

Frage: Warum ist es sinnvoll, dass zu jeder Klasse des SMALLTALK-Systems genau eine Metaklasse gehört?
Antwort: Die Programmierpraxis hat gezeigt, dass es günstig ist, wenn jede Klasse (als Instanz) ihre eigenen Instanzvariablen und Methoden besitzt und wenn die Programmiererin diese jeweils frei bestimmen kann, ohne dabei gleichzeitig an andere Klassen denken zu müssen. Um dies zu ermöglichen, muss aber jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können. Und genau das ist in SMALLTALK der Fall. Zu jeder Klasse des SMALLTALK-Systems gehört nämlich genau eine Klasse, von der erstere (und nur diese) eine Instanz ist. Diese zweite Klasse wird Metaklasse der ersten genannt.

Frage: Was ist ein Konstruktor?
Antwort: Ein Konstruktor ist eine Methode, die, auf einer Klasse aufgerufen, eine neue Instanz dieser Klasse zurückgibt (es handelt sich also aus Sicht der erzeugten Instanz um eine Klassenmethode). 

Frage: Was sind Factory-Methoden?
Antwort: Eine Factory-Methode ist eine Methode, die wie ein Konstruktor eine neue Instanz liefert, die aber die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode gehört, abhängig macht. Zum Beispiel könnte eine Klasse Number eine (Klassen-)Methode fromString: vorsehen, die anhand eines zu analysierenden Strings entweder eine Instanz der Klasse Integer oder eine der Klasse Float zurückgibt. Da in SMALLTALK Konstruktoren ganz normale Klassenmethoden sind, sind sie an keine besonderen Konventionen gebunden. Sie müssen also insbesondere nicht ein neues Objekt genau der Klasse, der sie angehören, zurückgeben. Die Factory-Methoden sind dann solche Klassenmethoden. 

Frage: Was geschieht bei der Generalisierung/Spezialisierung?
Antwort: Während die Generalisierung Eigenschaften weglässt oder generalisiert (Abstraktion), fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene.

Frage: Was versteht man in der objektorientierten Programmierung unter Vererbung?
Antwort: Unter Vererbung versteht man in der objektorientierten Programmierung die übertragung der Definition von Eigenschaften und Verhalten (Intension) von einer Klasse auf eine andere. Vererbung dient vor allem der Wiederverwendung von Code und damit der ökonomie in der Softwareentwicklung.

Frage: Wie hängen Generalisierung/Spezialisierung und Vererbung zusammen?
Antwort: Wenn man das Prinzip von Generalisierung und Spezialisierung vor Augen hat, dann ist die Vererbung eigentlich nur noch ein Mechanismus, der Definitionen von einer Klasse auf eine andere überträgt. So wird jede benannte Instanzvariable, die in einer Generalisierung deklariert ist, nicht nur für Instanzen dieser Generalisierung (so sie denn welche hat) angelegt, sondern auch für die Instanzen all ihrer Spezialisierungen. Analog stehen Methoden, die in einer Generalisierung definiert werden, auch ihren Spezialisierungen zur Verfügung, und zwar beinahe so, als wären sie in den Spezialisierungen definiert. Verwendet man Vererbung zur Ausnutzung von ähnlichkeiten, so ist nicht sichergestellt, dass auch eine Spezialisierungs- bzw. Generalisierungsbeziehung besteht.

Frage: Was versteht man unter offener Rekursion?
Antwort: Der Aufruf einer abstrakten, d. h. in der Klasse nicht implementierten Methode aus der Klasse selbst heraus ist ein gängiges Muster der objektorientierten Programmierung. Man nennt es auch offene Rekursion, da der Aufruf auf dem Objekt selbst erfolgt (also gewissermaßen rekursiv ist), aber an der aufrufenden Stelle noch nicht klar (offen) ist, welche (erbende) Klasse die Implementierung liefert.

Frage: Wie geht (in SMALLTALK) das dynamische Binden von Methodenaufrufen vonstatten?
Antwort: Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Wird die Methode gefunden, dann wird sie ausgeführt. Wird sie nicht gefunden, wird zunächst in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument.

Frage: Was versteht man unter aktiven Objekten?
Antwort: Unter aktiven Objekten würde man sich vorstellen, dass sie über einen Prozess verfügen, der nur die eigenen Methoden ausführt. Erhält ein aktives Objekt eine Nachricht, dann nimmt es diese an und arbeitet sie ab, sobald es die Zeit dazu hat. Die Kommunikation aktiver Objekte würde nämlich asynchron ablaufen, wenn mit der Nachricht (dem Methodenaufruf) nicht auch ein Prozess verbunden ist (was ja dem klassischen Prozeduraufruf entspräche). Aktive Objekte wären aber sehr aufwendig und deswegen setzt die objektorientierte Programmierung in der Praxis auf passive.

Frage: Wie kann man parallele Prozesse synchronisieren?
Antwort: Man synchronisiert parallele Prozesse mittels geteilter Warteschlangen: Man verwendet die Klasse SharedQueue, deren Instanzen anstelle von Signalen (die ja einfach nur gezählt werden) Objekte aufnehmen und die eine Synchronisation über next und nextPut: erlauben. Wenn man nun eine solche Shared queue einem Objekt zuordnet und von anderen Objekten verlangt, dass sie Nachrichten, anstatt sie dem Objekt zu schicken (und damit eine Methode des Objekts im eigenen Prozess aufzurufen), in diese Queue einstellen, und dann das Objekt mit einem Prozess, der in einer Endlosschleife läuft, diese Queue auslesen lässt, dann hat man tatsächlich "aktive Objekte, die einander Nachrichten schicken".

Frage: Was sind Typen?
Antwort: Typen sind abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben.

Frage: Warum typisiert man Variablen und Programmelemente?
Antwort: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm. Durch das Typsystem entsteht eine Modularisierung des Programms, wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt. Typen dienen damit der Wahrung des Implementationsgeheimnisses / Einhaltung der Schnittstellen durch den Compiler. Der Compiler kann anhand des Typs einer Variable bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss. Dies ist jedoch naturgemäß nur für Variablen mit Wertsemantik relevant und daher für die objektorientierte Programmierung, insbesondere für Sprachen wie SMALLTALK (in denen Referenzsemantik vorherrscht), von untergeordneter Bedeutung. 

Frage: Was muss ein Typsystem überprüfen, um in einem Programm Freiheit von semantischen Fehlern zu garantieren?
Antwort: Ein Typsystem muss lediglich alle Wertzuweisungen in einem Programm überprüfen, um Freiheit von semantischen Fehlern zu garantieren. Dazu zählen allerdings auch die impliziten Zuweisungen bei Methodenaufrufen, die, auch wegen des dynamischen Bindens, nicht immer alle offensichtlich sind.

Frage: Was versteht man unter dynamischer Typprüfung?
Antwort: Bei der dynamischen Typprüfung prüft man zur Laufzeit vor einer Variablenzuweisung, ob der zuzuweisende Wert den von der Variable geforderten Typ hat.

Frage: Führt SMALLTALK dynamische Typprüfung durch?
Antwort: SMALLTALK führt keine dynamische Typprüfung durchführt, da Typfehler erst im letztmöglichen Moment offenbar werden, nämlich wenn auf einer Variable eine Methode aufgerufen werden soll, die für das Objekt, auf das die Variable verweist, gar nicht definiert ist.

Frage: Was versteht man unter statischer Typprüfung?
Antwort: Bei der statischen Typprüfung soll die Typkorrektheit zur übersetzungszeit gewährleistet werden. Die Typprüfung ist Aufgabe des Compilers. Nachteil der rein statischen Typprüfung ist, dass sie auch Programme zurückweist, die nützlich, sinnvoll und typkorrekt sind.

Frage: Was versteht man unter statischer Typprüfung?
Antwort: Bei der statischen Typprüfung soll die Typkorrektheit zur übersetzungszeit gewährleistet werden. Die Typprüfung ist Aufgabe des Compilers. Nachteil der rein statischen Typprüfung ist, dass sie auch Programme zurückweist, die nützlich, sinnvoll und typkorrekt sind.

Frage: Was ist ein Suptyp?
Antwort: Ein Subtyp ist als ein Typ definiert, dessen Werte oder Objekte überall da auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp steht dabei nicht für eine besondere Art von Typ, sondern vielmehr für eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung. Die Gegenrolle heißt Supertyp. Ein Subtyp ist also mit seinem Supertyp per Definition zuweisungskompatibel. Es gilt die folgende Regel: "Wenn ein Typ Y ein Subtyp eines Typs X ist, dann müssen alle Bedingungen, die für Objekte des Typs X erfüllt sind, auch für Objekte des Typs Y erfüllt sein."

Frage: Wann verzichtet man auf die statische Typprüfung zugunsten einer dynamischen Typprüfung?
Antwort: In Java ist das Array Loewe[ ] Subtyp des Katzen-Array Katze[ ], wenn Loewe Subtyp von Katze ist. Man hat hier auf die statische Typprüfung zugunsten einer dynamischen Typprüfung mit möglicher Meldung eines Laufzeitfehlers verzichtet. Dies tut man immer dann, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies jedoch vom Compiler garantiert werden könnte. Beispiele dafür sind Programme, die Prozeduren verwenden, die auf einer Menge von Objekten durchgeführt werden können sollen, die aber nicht verlangen, dass die Elemente alle vom gleichen Typ sind, sondern statt dessen gestatten, dass auch Elemente von Subtypen darunter vorkommen.

Frage: Was versteht man unter Inklusionspolymorphie?
Antwort: Unter Inklusionspolymorphie versteht man im Wesentlichen dasselbe wie unter Subtyping: Wo Objekte eines Typs erwartet werden, können Objekte anderer Typen erscheinen, weil der erste Typ die anderen subsumiert (inkludiert). Der Begriff ist vor allem in Abgrenzung zum parametrischen Polymorphismus gebräuchlich; sonst redet man eher von Subtyping. 

Frage: Warum hält eine Klassendefinition in der Regel sinnvollerweise auch als Typdefinition her?
Antwort: Klassen dienen der Angabe von Implementierungen und damit als Container von ausführbarem Code; Typen dienen der Formulierung von Invarianten, die für Variablenbelegungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmierfehler hinweist. Da beide im Wesentlichen über die gleichen Elemente verfügen, lässt sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausführung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen läßt (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann.

Frage: Wo manifestiert sich der Unterschied der beiden Konzepte Klasse und Typ?
Antwort: Klassen dienen der Angabe von Implementierungen und damit als Container von ausführbarem Code; Typen dienen der Formulierung von Invarianten, die für Variablenbelegungen gelten müssen und deren Verletzung auf einen (logischen oder semantischen) Programmierfehler hinweist. Da beide im Wesentlichen über die gleichen Elemente verfügen, lässt sich die Definition beider in einem Sprachkonstrukt zusammenfassen. Der Unterschied der beiden Konzepte Klasse und Typ manifestiert sich auch darin, welche Rolle sie zur Laufzeit eines Programms spielen: Typinformation beeinflusst die Ausführung eines laufenden Programms insofern, als sie ein Programm bei Verletzung einer Invariante abbrechen läßt (durch einen dynamischen Typtest) und damit einem anderen, schwieriger zuordenbaren Fehler zuvorkommt. Klasseninformation beeinflusst die Ausführung des laufenden Programms insofern, als sie Grundlage des dynamischen Bindens ist und in einem Programm als Eigenschaft von Objekten abgefragt werden kann.

Frage: Was versteht man unter Instanziierung des parametrischen Typs?
Antwort: Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen nicht genannt (referenziert) werden müssen, sondern durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit (also ohne entsprechende Deklaration) auf Typen beschränkt ist; man nennt sie auch Typvariablen. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt. Man spricht bei dieser Wertzuweisung an eine Typvariable von einer Instanziierung des parametrischen Typs; erst bei ihr entsteht ein konkreter Wertebereich, der dann dem deklarierten Programmelement zugeordnet wird. Insbesondere hat ein parametrischer Typ, bei dem Typvariablen nicht belegt sind, keinen konkreten Wertebereich.

Frage: Zu welchem Zeitpunkt führt die Verwendung eines parametrisch definierten Typs zu einer Zuweisung an die Typvariable?
Antwort: Die Verwendung eines parametrisch definierten Typs führt bereits zur übersetzungszeit zu einer Zuweisung an die Typvariablen.

Frage: Welche Klassen sind ein Standardanwendungsfall für parametrischen Polymorphismus?
Antwort: Dies sind Collections mit Typvariablen E und Dictionary mit den Typvariablen S und E.

Frage: Warum benötigt man den einfachen parametrischen Polymorphismus?
Antwort: Zur Vermeidung einer Sicherheitslücke in der statischen Typprüfung: Collections sind das typische Beispiel für die Verwendung des parametrschen Polymorphismus. Man könnte die Collections aber auch als Collections von Object definieren. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. Wenn ein solches Objekt von einem Subtyp von Object ist, muss man eine Typumwandlung durchführen, wenn man spezielle Subtypeigenschaften dieses Objektes nutzen will. Die Zulässigkeit dieses Down cast ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.

Frage: Welche Unzulänglichkeiten hat der einfache parametrische Polymorphismus?
Antwort: Auch beim einfachen parametrischen Polymorphismus kann man nicht vollständig auf Typumwandlungen verzichten, weil eine Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ speichern kann. Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft s. den Beispieltyp MyCollection, dessen Werte solche Collections sein sollen, deren Elemente sortiert und nummeriert werden können. Dieser Typ sei ein Subtyp von Collection und verfüge weiterhin über entsprechende Methoden sortieren und summieren. Intuitiv verlangt die Sortierbarkeit der Objekte vom Typ MyCollection, dass auf den Elementen eine Vergleichsfunktion definiert ist. Dies ist aber nicht für alle Typen und somit auch nicht für alle möglichen Belegungen der Typvariable E der Fall. Auch verlangt die Methode summieren, dass sich aus den Elementen einer solchen Collection ein Wert aggregieren läßt, der vom Typ Number oder einem Subtypen davon ist. Man kann daraus schließen, dass die Elemente ebenfalls vom Typ Number sein oder zumindest Methoden besitzen müssen, die einen solchen Wert zurückliefern. Nun kann aber die Definition des parametrischen Typs MyCollection nicht wissen, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.

Frage: Wozu benötigt man den beschränkten parametrischen Polymorphismus?
Antwort: Da die Typvariablen selbst nicht typisiert sind, kann man innerhalb der Typdefinition (und der den Typ implementierenden Klassen) keine Aussagen über den Typ machen. Außerhalb, bei der Verwendung (Instanziierung) der Typdefinition, geht das schon, da hier die Typvariable durch einen Typ ersetzt ist. Was man also gern hätte, ist, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist, und zwar derart, dass man bei den als Werte zulässigen Typen ein bestimmtes, benötigtes Protokoll voraussetzen kann. Die aktuellen Typparameter sind dann nicht mehr beliebig zu wählen, sondern nur noch aus solchen Typen, die die Einschränkungen erfüllen. Um dies zu erreichen, wählt man Supertypen als Schranken.

Frage: Was ist der Unterschied zwischen überschreiben und überladen?
Antwort: überschreiben bedeutet, dass eine Methode mit der gleichen Signatur (bestehend aus Methodenname und formalen Parametertypen) noch einmal definiert werden kann, und zwar mit geänderter Implementierung. Auch darf die Methode den Rückgabetyp kovariant, also nach unten, abändern. Nun kann man in JAVA auch Methoden mit gleichem Namen, aber verschiedenen Parametertypen in derselben oder einer Subklasse haben. Diese Methoden nennt man dann überladen. In JAVA sind überladen und überschreiben zwei grundverschiedene Dinge, obwohl man in beiden Fällen nichts weiter tut als eine Methode mit bereits vorhandenem Namen noch einmal zu definieren: Beim überladen wird eine neue Methode eingeführt, beim überschreiben wird eine bereits bestehende redefiniert.

Frage: Wie kann die Regel "Wenn ein Typ Y ein Subtyp eines Typs X ist, dann müssen alle Bedingungen, die für Objekte des Typs X erfüllt sind, auch für Objekte des Typs Y erfüllt sein" überprüft werden?
Antwort: Das Liskov-Substitutionsprinzip lautet: überschreibende Methoden in S erhalten das Verhalten der überschriebenen Methoden in T. Dazu gehört die Kontravarianz der Argumenttypen der überschreibenden Methode, die Kovarianz des Ergebnistyps der überschreibenden Methode, die Kovarianz der Ausnahmen der überschreibenden Methode (die Typen der geworfenen Exceptions sind entweder Subtypen von den Typen der Exceptions der überschriebenen Methode oder die Exceptions werden gar nicht geworfen; keinesfalls kommen Exceptions hinzu), die Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden und die Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Das Liskov-Substitutionsprinzip lautet weiter: Die Invarianten von S implizieren die von T.

Frage: Was unternimmt C#, um das Fragile-base-class-Problem zu vermeiden?
Antwort: In C# sind dynamisch zu bindende Methoden unbedingt als solche zu deklarieren, und zwar mit dem Schlüsselwort virtual. Entsprechend muss eine überschreibende Methode mit dem Schlüsselwort override deklariert werden. Soll hingegen eine Methode gleicher Signatur in einer Subklasse neu eingeführt (und nicht anstelle der, die sie überschreibt, dynamisch gebunden) werden, dann ist dies durch Verwendung des Schlüsselworts new bekanntzugeben. Dadurch markiert man alle Stellen im Programm, an denen das sog. Fragile-base-class-Problem auftreten kann.

Frage: Wie kann ein Objekt verbergen, welche Objekte es kennt?
Antwort: Es kann dies über lokale Instanzvariablen tun.

Frage: Welchen Schutz bietet die mangelnde Sichtbarkeit von Variablen vor unerwünschtem Zugriff auf Objekte?
Antwort: Aufgrund des Aliasing kann ein Objekt, dessen einer Name (beispielsweise aufgrund des Geheimnisprinzips) unsichtbar ist, über einen anderen zugreifbar sein, ohne dass der erste Name etwas dagegen machen könnte. über lokale Instanzvariablen kann ein Objekt also verbergen, welche Objekte es kennt; es kann aber nicht verhindern, dass andere Objekte diese Objekte schon kennen und, ohne sein Wissen, manipulieren. Es ist somit wegen der etwaigen Existenz von Aliasen nicht möglich, dass ein Objekt seinen inneren Aufbau vor der Außenwelt abkapselt, es sein denn, es hat ganz spezielle Vorkehrungen dafür getroffen.

Frage: Welchen einen starken konzeptuellen Hintergrund hat die Unterscheidung von Wert- und Referenztypen einer Klasse in EIFFEL?
Antwort: Die Unterscheidung von Wert- und Referenztypen einer Klasse unterstützt die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten, nämlich der, die das Enthaltensein von Objekten in anderen ausdrückt. Nun ist es in der Realität so, dass nicht alle Instanzen einer Klasse immer entweder Komponenten (also in anderen Objekten enthalten) oder freie Objekte (also nirgends enthalten) sind. EIFFEL wird dem gerecht, indem es erlaubt, von einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) zu haben.

Frage: Wie funktionieren in EIFFEL Zuweisungen zwischen Variablen, die unterschiedliche Semantik haben?
Antwort: Bei der Zuweisung zwischen zwei Variablen mit Wertsemantik wird der Wert der einen Variable in die andere Variable kopiert. Bei der Zuweisung zwischen zwei Variablen mit Referenzsemantik wird lediglich der Zeiger kopiert. Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik reicht es jedoch nicht, einen Zeiger zu kopieren, denn die Zielvariable hat keinen Platz für einen Zeiger, sondern für die Attributwerte - statt dessen wird hier das Objekt, auf das der Zeiger verweist, kopiert (genauer: es werden die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert). Wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt und eine Referenz auf diesen Klon übergeben.

Frage: Was sind Repräsentationsobjekte?
Antwort: Dies sind Objekte, die die Implementierung eines Objektes ausmachen und die hinter der Schnittstelle des Objektes verborgen werden sollen.

Frage: Welchen Lösungsansatz gibt es für das Problem der mangelnden Kapselung?
Antwort: Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes- Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können. Letzteres kann man auf einfache Weise verhindern, wenn man aus den Objekten Wertobjekte macht und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt.

Frage: Wie versucht C#, das Problem der mangelnden Kaspelung zu lösen?
Antwort: In C# kann man die "Klasse" der Teil-Objekte per struct definieren. (Aus Werttypen können, genau wie in PASCAL oder C, mittels des Typkonstruktors struct (dem C-äquivalent von PASCALs record) neue Werttypen erzeugt werden, die sogar Methoden und Konstruktoren haben können, die aber keine Klassen sind (und insbesondere keine Typerweiterung und somit auch keine Vererbung erlauben)) 

Frage: Welche Lösung bietet EIFFEL für das Problem der mangelnden Kapselung an?
Antwort: Zwar erlaubt EIFFEL, auf Wertobjekte Referenzen zu haben (und somit zumindest theoretisch, dass ein Repräsentationsobjekt einen Alias besitzt), aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, so dass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Es entsteht also faktisch kein Alias auf ein Wertobjekt, und als Wertobjekte angelegte Repräsentationsobjekte sind aliasfrei.

Frage: Wozu benötigt man Zwischenobjekte?
Antwort: Bei durch indizierte Instanzvariablen eines Objekts realisierten Zu-n-Beziehungen kann nicht zwischen verschiedenen solchen Beziehungen desselben Objekts unterschieden werden - die indizierten Instanzvariablen sind ja nicht benannt. Deswegen werden Zu-n-Beziehungen in der objektorientierten Programmierpraxis praktisch immer über Zwischenobjekte realisiert, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Dabei können diese Zwischenobjekte die Zu-n-Beziehung ggf. mit weiteren Attributen (z.B. Anzahl n, Verweise auf ein bestimmtes Element, Art der Sortierung o.ä.) versehen, die dann in den benannten Instanzvariablen der Zwischenobjekte untergebracht werden. Das Originalobjekt, das die Zu-n-Beziehung eigentlich haben sollte, steht dann statt dessen in einer von einer benannten Instanzvariable hergestellten Zu-1-Beziehung zu dem Zwischenobjekt, das die Zu-n-Beziehung herstellt.

Frage: Was sind die Vorteile von Zwischenobjekten?
Antwort: Der Umstand, dass Zu-n-Beziehungen über Zwischenobjekte realisiert werden, die vollwertige Objekte sind, erlaubt, die Beziehung beliebig auszugestalten. So kann beispielsweise eine (Sortier-)Reihenfolge vorgegeben oder ein ausgezeichnetes Element der Beziehung noch einmal gesondert referenziert werden (z.B. das oberste Element auf einem Stack). Auch besondere Zugriffsverfahren wie z.B. das Auffinden von Elementen (in Beziehung stehenden Objekten) anhand eines Schlüssels können auf diese Weise realisiert werden. Da in SMALLTALK Objekte auch eigene Kontrollstrukturen (wie z.B. spezielle Schleifen) anbieten können, sind der Ausgestaltung von Beziehungen über Zwischenobjekte praktisch keine Grenzen gesetzt.

Frage: Was ist ein Nachteil von Zwischenobjekten, wenn man an guten objektorientierten Stil denkt?
Antwort: Mit Zwischenobjekten wird das Gesetz Demeters verletzt.

Frage: Was sind zwei verschiedene Arten, auf die man neue Objekte erzeugen kann?
Antwort: Per Instanziierung, verbunden mit der klassenbasierten objektorientierten Programmierung. 
Per Klonen, verbunden mit der prototypbasierten objektorientierten Programmierung.

Frage: Was sind verschiedene Arten von Beziehungen?
Antwort: Beziehungen zwischen Klassen, das ist im Wesentlichen die Subklassen- oder Vererbungsbeziehung. Beziehungen zwischen Klassen und Instanzen, das ist im Wesentlichen die Instanziierungs- oder Klassikationsbeziehung Beziehungen zwischen Instanzen (oder Objekten), das sind im Wesentlichen beliebige Assoziationen (wie Mutter-Tochter) und bestimmte spezielle wie Komposition oder Aggregation.

Frage: In welchem Fall ist die Reservierung von an die Objektgröße angepasstem Speicherplatz für Variablen unnötig?
Antwort: Die Reservierung von an die Objektgröße angepasstem Speicherplatz für Variablen ist im Fall der in der objektorientierten Programmierung dominierenden Referenzsemantik unnötig - in Variablen werden nur Referenzen gespeichert, die immer gleich groß sind.

Frage: Wozu braucht man beschränkten parametrischen Polymorphismus?
Antwort: Um Bedingungen auszudrücken, die der tatsächliche Typparameter, also der für die Typvariable eingesetzte Typ, einhalten muss. Die Bedingung wird dabei durch die Angabe eines Typs genannt, der Supertyp des tatsächlichen Typparameters sein muss (eine obere Schranke). Dadurch wird garantiert, dass der tatsächliche Typparameter alle in der Schranke vereinten Eigenschaften besitzt.

Frage: Was sind die Nachteile des Subtyping Eiffels!
Antwort: Eiffel erlaubt Kovarianz bei Parametertypen und Feldern, was die Substituierbarkeit einschränkt und im Gegensatz zur Vererbung der Vorbedingungen steht, die zu einer Kontravarianz (schwächere Vorbedingungen der in Subtypen überschriebenen Methoden) führt.

Frage: Wie lautet das Gesetz Demeters?
Antwort: Sprich nicht mit Fremden - jedes Objekt soll nur auf Objekte zugreifen, die es selbst kennt, auf die also seine eigenen Instanzvariablen (oder die Parameter seiner Methoden) verweisen. Insbesondere sog. Kettenaufrufe sind nach dem Gesetz Demeters nicht erlaubt. Das Gesetz hat jedoch enge praktische Grenzen.
