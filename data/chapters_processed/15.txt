15 Ein- und Ausgabeströme

Ein- und Ausgabeströme spielen in der konventionellen (objektorientierten) Programmierung eine wichtige Rolle, da über sie Eingaben in und Ausgaben aus dem System erfolgen, und zwar sowohl von/zu der Benutzerin als auch vom/zum Dateisystem. Nun ist SMALLTALK aber als fensterbasiertes, grafisches System konzipiert, das der zeilenorientierten und textbasierten Ein- und Ausgabe der damals vorherrschenden Programme eine Alternative gegenüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden. Da ist es nur konsequent, dass die Ein- und Ausgabe über Streams wenig Gewicht hat.


Frage: Wie wird in SMALLTALK mit Ein- und Ausgabeströmen umgegangen?
Antwort: In SMALLTALK spielt die Ein- und Ausgabe über Streams eine untergeordnete Rolle, da SMALLTALK als fensterbasiertes, grafisches System konzipiert ist und mit dem Image alle Objekte dauerhaft gespeichert werden können.

Frage: Warum spielen Ein- und Ausgabeströme in Smalltalk eine untergeordnete Rolle?
Antwort: In Smalltalk spielen Ein- und Ausgabeströme eine untergeordnete Rolle, da Smalltalk als fensterbasiertes, grafisches System konzipiert ist, das der zeilenorientierten und textbasierten Ein- und Ausgabe der damals vorherrschenden Programme eine Alternative gegenüberstellen wollte. Zudem ist auch eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden.

Frage: Warum spielen Ein- und Ausgabeströme in SMALLTALK eine weniger wichtige Rolle als in konventioneller Programmierung?
Antwort: In SMALLTALK spielen Ein- und Ausgabeströme eine weniger wichtige Rolle als in konventioneller Programmierung, weil SMALLTALK als fensterbasiertes, grafisches System konzipiert ist, das der zeilenorientierten und textbasierten Ein- und Ausgabe eine Alternative gegenüberstellen wollte. Zudem ist eine Speicherung permanenter Daten in Dateien nicht nötig, da mit dem Image alle Objekte dauerhaft gespeichert werden.


In SMALLTALK haben Streams somit zunächst auch eine andere Aufgabe: Sie erlauben eine Form des Zugriffs auf Collections, die das Collection-Protokoll nicht bieten kann, nämlich: den sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen (bei den Iteratoren wird immer in einem Schritt, oder in einer Anweisung, über die ganze Collection iteriert) sowie den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Collection durch mehrere andere Objekte.


Frage: Was ist die Aufgabe von Streams in SMALLTALK?
Antwort: In SMALLTALK erlauben Streams einen sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen und den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Collection durch mehrere andere Objekte.


Um dies umzusetzen, braucht man Positionszeiger in eine Collection hinein, und genau die zu liefern ist die Funktion von Streams. Streams werden zunächst immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält. Das Basisprotokoll auf Instanzebene enthält die folgenden Methoden: atEnd: gibt an, ob der Stream bereits am Ende seiner Basis angekommen ist. next: gibt das nächste Element der Basis zurück und rückt den Stream auf dieses Element vor. upToEnd: gibt eine Collection zurück, die alle Elemente der Basis bis zum Ende enthält. upTo: gibt eine Collection zurück, die alle Elemente der Basis bis zu einem bestimmten Element enthält. copyFrom: kopiert einen Teil der Basis in den Stream. reset: setzt den Stream auf den Anfang der Basis zurück.


Frage: Was ist die Funktion von Streams in einer Collection?
Antwort: Die Funktion von Streams in einer Collection ist es, Positionszeiger in die Collection hineinzuliefern.

Frage: Wofür werden Streams in der Programmierung verwendet?
Antwort: Streams werden in der Programmierung verwendet, um auf eine Collection zuzugreifen und deren Elemente zu verarbeiten. Sie werden auf einer Collection erzeugt und bieten Methoden, um das nächste Element zu ermitteln, zu prüfen, ob das Ende der Collection erreicht ist, oder um eine Teilmenge der Collection zu kopieren.

Frage: Wie wird ein Stream erzeugt?
Antwort: Ein Stream wird immer auf einer Collection erzeugt, deren Inhalt Basis des Streams ist. Die Erzeugung erfolgt mittels der Klassenmethode on:, die als Parameter eine Collection erhält.

Frage: Wie wird ein Stream auf einer Collection erzeugt?
Antwort: Ein Stream wird auf einer Collection erzeugt, indem die Klassenmethode on: aufgerufen wird und die Collection als Parameter übergeben wird.


Für frei positionierbare Streams kommt noch das Protokoll zur Änderung des Zeigers hinzu:, next: gibt das nächste Element zurück und bewegt den Zeiger auf das folgende Element, previous: gibt das vorherige Element zurück und bewegt den Zeiger auf das vorherige Element, at: gibt das Element am aktuellen Zeigerposition zurück, ohne den Zeiger zu bewegen, before: setzt den Zeiger auf das vorherige Element, after: setzt den Zeiger auf das folgende Element, at:setzt den Zeiger auf das angegebene Element.Diese Protokolle sind in der Lage, den Zeiger an eine bestimmte Position zu verschieben.


Frage: Was ist das Protokoll zur Änderung des Zeigers für frei positionierbare Streams?
Antwort: Das Protokoll zur Änderung des Zeigers für frei positionierbare Streams umfasst die Methoden next, previous, at, before, after und at:. Diese Methoden ermöglichen das Navigieren und Abrufen von Elementen in einem Stream.


Für peek ist die freie Positionierbarkeit notwendig, weil man dazu erst das nächste Element anspringen und dann wieder einen Schritt zurückgehen muss. Da ein Stream (wie eine Collection) eine Menge von Objekten repräsentiert, möchte man darüber (genau wie über eine Collection) iterieren können. Die Iteratoren von Streams sind jedoch etwas spezieller als die von Collections. Sie sind sog. "Single-use"-Iteratoren, d.h. nachdem man einmal next() aufgerufen hat, ist das Iterator-Objekt ungültig. Außerdem wird natürlich zwischen (nur) lesbaren und schreibbaren Streams unterschieden.


Frage: Was ist ein Single-use Iterator?
Antwort: Ein Single-use Iterator ist ein Iterator, der, nachdem man einmal die next()-Methode aufgerufen hat, ungültig wird. Das bedeutet, dass man ihn nicht mehr verwenden kann, um weitere Elemente des Streams zu iterieren.


Frage: Was ist der Unterschied zwischen lesbaren und schreibbaren Streams?
Antwort: Lesbare Streams sind Ströme, die nur zum Lesen von Daten verwendet werden können, während schreibbare Streams zum Schreiben von Daten verwendet werden können.


Erst eine weitere Kategorie von Streams operiert nicht auf Collections, sondern auf externen Daten. Dazu gehören insbesondere die File streams. In SMALLTALK-80 wurde mit den Klassen FileDirectory, File und FilePage (die selbst keine Streams sind) ein eigenes Dateisystem geschaffen; die meisten heute gebräuchlichen Implementierungen nehmen jedoch eine Abbildung auf das Betriebssystem vor, für das sie geschrieben wurden. Man erkennt hier noch sehr schön, welche Funktion SMALLTALK ursprünglich zugedacht war: die der einzigen Software auf einem Computer.


Frage: Wofür werden File streams in Smalltalk verwendet?
Antwort: File streams in Smalltalk werden für die Verarbeitung externer Daten verwendet, insbesondere für die Arbeit mit Dateien. In Smalltalk-80 wurde dafür ein eigenes Dateisystem geschaffen, aber heutige Implementierungen bilden meist das Betriebssystem ab, für das sie geschrieben wurden.


Besonders in SQUEAK gibt es noch zahllose weitere Streams, so u. a. für Multimedia-Aufgaben; insgesamt unterscheiden sich die verschiedenen SMALLTALK-Dialekte bei der Handhabung von Streams zum Teil erheblich, weswegen wir hier auch nicht weiter darauf eingehen.
