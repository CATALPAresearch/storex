51.2 Klassen

C++ ist insofern objektorientiert, als es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und JAVA, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden (wie in JAVA; s. Abschnitt 36.1 in Kurseinheit 4) mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.
Dass man in C++ wie in JAVA das Schlüsselwort class verwendet, heißt nicht automatisch, dass man damit Klassen im Sinne JAVAs oder SMALLTALKs definiert. Insbesondere haben Variablen mit einer Klasse als Typ keine Referenz-, sondern Wertsemantik. Entsprechend müssen die Werte solcher Variablen, die "Objekte", nicht erst mit new angelegt werden — der für ein "Objekt" benötigte Speicherplatz wird, genau wie bei den Records PASCALs oder bei den Structs von C, bei der Deklaration reserviert. Dabei steht "Objekt" hier deswegen in Anführungsstrichen, weil diese "Objekte" eigentlich keine Objekte sind, sondern Werte; insbesondere haben sie keine Identität, und bei Zuweisungen an andere Variablen werden Kopien angefertigt. Aliase gibt es entsprechend zunächst auch keine.
Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren. Syntaktisch sieht das, wenn man einen parameterlosen Konstruktor für die Klasse A als gegeben voraussetzt.
Sieht man einmal von der expliziten Festlegung, dass es sich bei der Variable a um eine Pointervariable handelt, ab, dann gleicht diese Anweisung einer äquivalenten in JAVA oder C#.
Zur Dereferenzierung einer solchen Pointer-(Objekt-)Variable bei gleichzeitigem Zugriff auf ein Element (Feld oder Methode) der Instanz in C++
Dies ist äquivalent zu (*a).x bzw. (*a).f(x). Besondere Obacht ist bei Zuweisungen geboten, da man sich hier genau überlegen muss, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen will.
Besonders verwirrend ist die Situation bei den impliziten Zuweisungen, die im Rahmen von Methodenaufrufen stattfinden. C++ macht zunächst ein "Call by value", das heißt, es wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Im Falle von Pointer-Variablen wie dem obigen a bedeutet das aber, dass nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben wird. Es entspricht dies genau dem Verhalten von JAVA und SMALLTALK, wobei allerdings bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-variable handelt — es ist einfach immer so.
Wenn man nun davon abweichend ein "Call by reference" haben möchte, dann gibt es zum einen die Möglichkeit, an der Aufrufstelle den Zeigeroperator & zu verwenden, der anstelle einer Kopie des Inhalts der Variable einen Zeiger auf die Speicherstelle der Variable erzeugt und diesen übergibt.
Dafür müssen dann aber die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.
Alternativ gibt es in C++ aber die Möglichkeit, wie in PASCAL zu verfahren wobei dann die Aufrufstelle unverändert bleiben kann (also ohne & auskommt). Vgl. dazu aber die Bemerkungen in Abschnitt 50.2 zur Praxis in C#.

Frage: Welche Strukturen bietet C++ im Bereich der objektorientierten Programmierung?
Antwort: C++ bietet sowohl Strukturen (structs) als auch Klassen (classes) im Bereich der objektorientierten Programmierung.

Frage: Was enthält eine C++ Klasse neben Feldern (Instanzvariablen)?
Antwort: Eine C++ Klasse enthält neben Feldern (Instanzvariablen) auch Methoden.

Frage: Wie werden Klassenfelder und -methoden in C++ deklariert?
Antwort: Klassenfelder und -methoden werden in C++ mit dem Schlüsselwort "static" in einer Klasse eingeführt, ähnlich wie in Java.

Frage: Wie erfolgt die Erzeugung von Objekten in C++ im Vergleich zu Java?
Antwort: In C++ erfolgt die Erzeugung von Objekten oft ohne "new". Der benötigte Speicherplatz wird bei der Deklaration reserviert, und es entstehen Werte (Objekte) mit Wertsemantik, im Gegensatz zu Java, wo "new" verwendet wird.

Frage: Wie erzeugt man in C++ Objekte mit Identität?
Antwort: Um in C++ Objekte mit Identität zu erzeugen, muss man Zeigervariablen (Pointer) verwenden und eine Klasse mit dem "new"-Operator instanziieren.

Frage: Wie sieht die Dereferenzierung eines Zeigers auf ein Objekt in C++ aus?
Antwort: In C++ erfolgt die Dereferenzierung eines Zeigers auf ein Objekt mit "->", z.B., "a->x" oder "a->f(x)" für ein Feld oder eine Methode der Klasse.

Frage: Welche Besonderheiten gibt es bei Zuweisungen von Pointervariablen in C++?
Antwort: Bei Zuweisungen von Pointervariablen muss man sich in C++ genau überlegen, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen möchte. C++ verwendet standardmäßig "Call by value" für Methodenaufrufe, was bedeutet, dass Kopien von Parametern übergeben werden.

Frage: Wie kann in C++ "Call by reference" erreicht werden?
Antwort: In C++ kann "Call by reference" erreicht werden, indem man den Zeigeroperator "&" verwendet und die formalen Parameter so deklariert, dass sie Zeiger auf Zeiger aufnehmen können.

Frage: Gibt es in C++ die Möglichkeit, "Call by reference" ohne Verwendung des Zeigeroperators "&" zu erreichen?
Antwort: Ja, in C++ gibt es die Möglichkeit, "Call by reference" ohne Verwendung des Zeigeroperators "&" zu erreichen, ähnlich wie in Pascal. Hierbei bleiben die Aufrufstellen unverändert.

Frage: Was ist die Grundlage für die Übertragung von Parametern in C++-Methodenaufrufen?
Antwort: In C++-Methodenaufrufen erfolgt die Übertragung von Parametern standardmäßig durch "Call by value", was bedeutet, dass Kopien der Parameter übergeben werden.