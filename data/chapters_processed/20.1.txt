20.1 Induktiver Aufbau von Typen und Semantik

Um diese Frage zu beantworten, ist es zunächst interessant, festzustellen, dass es Typen gibt, die sich ausschließlich auf sich selbst beziehen, deren Bedeutung also zumindest nicht von der anderer Typen abhängt. Das klassische Beispiel hierfür ist Boolean: Alle seine Operationen fordern den Typ Boolean als Operanden und haben Boolean als Typ zum Ergebnis. Aber woher erhält Boolean seine Bedeutung? Typkonstruktoren Eine eher theoretisch relevante Möglichkeit, solchen nur auf sich selbst beruhenden Typen eine Bedeutung zu geben, ist, sie auf bekannte externe Formalismen abzubilden. Im Beispiel von Boolean ist dies natürlich die boolesche Algebra. Jeder, der die boolesche Algebra kennt und akzeptiert, wird auch den Typ Boolean sofort verstehen und akzeptieren (sofern er den Erwartungen entsprechend definiert ist). Entsprechend lässt sich ein Typ Fraction mit den Operationen +, –, *, und / definieren, der die rationalen Zahlen mit den entsprechenden Operationen repräsentiert. Nimmt man dann noch Boolean als mit Bedeutung (Semantik) versehen an, kann man noch Ver-gleichsoperationen wie =, >, <, etc. hinzufügen, ohne in Interpretationsprobleme zu geraten. Andere Typen, für die es eine solche direkte Abbildung nicht gibt, die aber in ihrer Definition rekursiv auf solche Typen zurückgeführt werden können, kann man "induktiv über deren Aufbau" eine Bedeutung beimessen. Man nennt eine solche Art des Versehens mit Bedeutung eine denotationale Semantik. Eine andere, für die praktische Programmierung relevantere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer (gedachten oder realen, Hauptsache gut spezifizierten) Maschine abzubilden. Die Abbildung für Basistypen wie Rational oder Boolean ist in der Programmiersprache bzw. deren Compiler gewissermaßen hart verdrahtet. Für von der Programmiererin definierte Typen kann dies hingegen nicht der Fall sein; deren Bedeutung kann aber vom Compiler, wiederum "induktiv über deren Aufbau", aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Man nennt dies dann auch eine operationale Semantik. Man beachte, dass es für beide Arten der Semantik notwendig ist, dass sich alle Typen auf solche zurückführen lassen, deren Bedeutung vorausgesetzt werden kann. Es gibt also kein vollständig in sich selbst definiertes, von Externem unabhängiges System. Selbst SMALLTALK bzw. STRONGTALK ist kein solches: Auch wenn die Implementierung von Boolean nicht "hart verdrahtet" ist, sondern auf dynamisches Binden abgewälzt wird, so sind dennoch mindestens die beiden Wahrheitswerte true und false dem System bekannt, und Integer und Float (nicht jedoch Fraction!) sind "fest verdrahtet", inklusive der Vergleichsrelationen (die ja die Wahrheitswerte zum Ergebnis haben). Wenn Sie Kurs 01661 ("Datenstrukturen") bereits belegt haben oder ähnliches Vorwissen besitzen, dann erinnert Sie obiges Schema von Typdefinitionen vielleicht an die Schreibweise abstrakter Datentypen. Auch dort wird ein Typ syntaktisch als eine Menge von Operationen (Funktionen) beschrieben, deren Operanden (Argumente) alle selbst typisiert sind. Es gibt jedoch mindestens zwei wichtige Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs: 1. Abstrakte Datentypen sind nicht objektorientiert in dem Sinne, dass die Objekte keinen Zustand haben und bei Operationen (Funktionen) die Objekte, auf denen die Operationen ausgeführt werden, nicht ihren Zustand wechseln. Stattdessen geben Operationen neue Objekte zurück. Die Objekte der abstrakten Datentypen sind also gewissermaßen alle unveränderlich. 2. Entsprechend haben die den Methoden eines Protokolls entsprechenden Funktionen in den Spezifikationen abstrakter Datentypen immer ein Argument mehr, und zwar vom Typ des Datentyps selbst. Dieses Argument entspricht in der objektorientierten Programmierung dem Nachrichtenempfänger, dem impliziten Parameter self. Der Bezug zu abstrakten Datentypen ist auch eine beliebte Möglichkeit, Typen einer Programmiersprache mit einer Semantik zu versehen.


Frage: Wie kann man Typen in einer Programmiersprache Bedeutung verleihen?
Antwort: Es gibt verschiedene Möglichkeiten, Typen in einer Programmiersprache Bedeutung zu verleihen. Eine Möglichkeit ist, Typen auf bekannte externe Formalismen abzubilden, wie zum Beispiel den booleschen Algebra für den Typ Boolean. Eine andere Möglichkeit ist, Typen und ihre Operationen auf Anweisungen einer (gedachten oder realen) Maschine abzubilden. Für von der Programmiererin definierte Typen kann die Bedeutung vom Compiler aus der Bedeutung von Typen, die eine vorgegebene Semantik haben, abgeleitet werden. Diese Art der Bedeutungsvergabe wird operationale Semantik genannt. Eine weitere Möglichkeit ist, Typen und ihre Operationen auf abstrakte Datentypen abzubilden, die in der Programmiersprache definiert sind.

Frage: Was ist eine denotationale Semantik?
Antwort: Eine denotationale Semantik ist eine Möglichkeit, einem Typ und seinen Operationen eine Bedeutung zu geben, indem sie auf externe Formalismen abgebildet werden. Ein klassisches Beispiel hierfür ist der Typ Boolean, der auf die boolesche Algebra abgebildet wird.

Frage: Wie können Typen in einer Programmiersprache mit Bedeutung versehen werden?
Antwort: Es gibt verschiedene Möglichkeiten, Typen in einer Programmiersprache mit Bedeutung zu versehen. Eine Möglichkeit ist, sie auf bekannte externe Formalismen abzubilden, wie beispielsweise die boolesche Algebra für den Typ Boolean. Eine andere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer Maschine abzubilden. Für von der Programmiererin definierte Typen kann die Bedeutung vom Compiler "induktiv über deren Aufbau" aus der Bedeutung von Typen abgeleitet werden, die eine vorgegebene Semantik haben. Diese Art der Semantik wird operationale Semantik genannt. Eine weitere Möglichkeit ist, Typen über abstrakte Datentypen zu definieren, die in der Programmiersprache syntaktisch als eine Menge von Operationen beschrieben werden, deren Operanden alle selbst typisiert sind.
