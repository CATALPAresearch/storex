47.3 Multi-Threading

Ähnlich wie in SMALLTALK erlaubt auch JAVA das Programmieren von parallelen Ausführungssträngen. Diese werden in JAVA jedoch als Threads und nicht als Prozesse bezeichnet. Threads sind im Gegensatz zu den Prozessen eines Betriebssystems leichtgewichtig, was bedeutet, dass Threads keine separate Allokation von Ressourcen wie Hauptspeicher erfordern und alle auf denselben Ressourcen arbeiten. Daher können mehrere Threads innerhalb eines Prozesses ausgeführt werden. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst implementiert werden müssen, während sie bei Prozessen über die Inter-Prozess-Kommunikation des Betriebssystems geregelt sind. (Bei den "Prozessen" in SMALLTALK handelt es sich also eher um Threads als um Prozesse im oben beschriebenen Sinn.)
In JAVA wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.
Die Frage ist nun, was dieser Thread tun soll. Die Klasse Thread enthält eine Methode namens run(), die von start() aufgerufen wird. Diese Methode ist jedoch standardmäßig leer, sodass der Thread sofort beendet wird. Um sicherzustellen, dass ein neuer Thread sinnvolle Aufgaben ausführt, gibt es zwei Möglichkeiten: Man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen oder zumindest anzustoßen. Man lässt eine Klasse das Interface Runnable implementieren, implementiert dann in der Klasse die vom Interface geforderte Methode run(), erzeugt eine Instanz dieser Klasse und startet deren Methode run() mit (new Thread(i)).start(), wobei i die Instanz darstellt.
Auch im zweiten Fall wird eine Instanz der Klasse Thread erzeugt, die den neuen Thread repräsentiert. Es ist jedoch wichtig zu beachten, dass diese Instanz nicht selbst der Thread ist. Der Thread ist, wie bereits erwähnt, ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Aktive Objekte, die ihren eigenen Ausführungsstrang haben und behalten (wie im Kapitel 16 beschrieben), müssen in JAVA genauso wie in SMALLTALK simuliert werden. Jeder Thread hat jedoch ein Thread-Objekt, das ihn repräsentiert und spezifische Daten wie den Namen des Threads und seine Priorität speichert. Dieses Objekt kann mit Thread.currentThread() abgefragt werden.
Die Threads in JAVA erfordern daher eine explizite Synchronisation. Ähnlich wie bei den Prozessen in SMALLTALK funktioniert dies mit Semaphoren, die in JAVA als Monitore bezeichnet werden. Jeder Monitor ist mit einem Objekt verknüpft (und jedes Objekt mit einem Monitor). Wenn ein Thread einen Monitor eines Objekts sperrt ("lockt"), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.
Es gibt zwei Möglichkeiten, die Synchronisation von Threads zu erzwingen. Die erste Möglichkeit erfolgt durch die Verwendung der synchronized-Anweisung, die Sie bereits kurz kennengelernt haben. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden. Häufig ist dies das Schlüsselwort this, das auf das Objekt im Kontext des Blocks verweist.
Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren. Wenn es sich um eine Instanzmethode handelt, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird. Wenn es sich um eine Klassenmethode (also eine static deklarierte Methode) handelt, wird die Sperre auf das Objekt angewendet, das die Klasse repräsentiert. Beachten Sie jedoch, dass Felder nicht als synchronized deklariert werden können.

Frage: Was sind Threads in JAVA und wie unterscheiden sie sich von Prozessen?
Antwort: Threads in JAVA sind parallele Ausführungsstränge, während Prozesse in der Regel eigenständige Programme mit separater Ressourcenallokation sind. Threads sind leichtgewichtiger und teilen sich Ressourcen innerhalb eines Prozesses. Bei Threads müssen die Synchronisationsmechanismen selbst implementiert werden, während Prozesse in Betriebssystemen über die Inter-Prozess-Kommunikation reguliert werden.

Frage: Wie startet man einen neuen Thread in JAVA?
Antwort: Einen neuen Thread in JAVA startet man, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.

Frage: Was passiert standardmäßig, wenn man einen neuen Thread in JAVA startet?
Antwort: Standardmäßig führt ein Thread in JAVA keine spezifischen Aufgaben aus und endet sofort. Dies geschieht, weil die Methode run() in der Klasse Thread standardmäßig leer ist.

Frage: Wie stellt man sicher, dass ein neuer Thread in JAVA sinnvolle Aufgaben ausführt?
Antwort: Es gibt zwei Möglichkeiten, sicherzustellen, dass ein neuer Thread in JAVA sinnvolle Aufgaben ausführt. Entweder man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen, oder man lässt eine Klasse das Interface Runnable implementieren und implementiert die Methode run() in dieser Klasse. Dann erzeugt man eine Instanz dieser Klasse und startet deren Methode run().

Frage: Was ist ein Monitor in Bezug auf Threads in JAVA?
Antwort: Ein Monitor in Bezug auf Threads in JAVA ist ein Mechanismus, der dazu dient, die Synchronisation von Threads zu ermöglichen. Jedes Objekt in JAVA ist mit einem Monitor verknüpft. Wenn ein Thread einen Monitor eines Objekts sperrt ("lockt"), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.

Frage: Wie kann die Synchronisation von Threads in JAVA erzwungen werden?
Antwort: Die Synchronisation von Threads in JAVA kann auf zwei Arten erzwungen werden. Die erste Möglichkeit ist die Verwendung der synchronized-Anweisung, um einen synchronisierten Block zu erstellen. Die Anweisungen innerhalb dieses Blocks können nur von einem Thread gleichzeitig ausgeführt werden. Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren, wodurch die Sperre auf das zugehörige Objekt angewendet wird. Es ist wichtig zu beachten, dass Felder nicht als synchronized deklariert werden können.