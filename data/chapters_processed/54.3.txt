54.3 Verhaltensbasiertes Subtyping

Die Regeln des Subtypings aus Kapitel 26 und die damit verbundene Regelung der ZuweisungskompatibilitÃ¤t bezogen sich lediglich auf die Elemente einer Typdeklaration und somit auf rein statische Informationen. Um nun auch das Verhalten der Objekte eines Typs zu berÃ¼cksichtigen, greift man auf eine Idee aus der formalen Programmverifikation zurÃ¼ck, nÃ¤mlich die ÃœberfÃ¼hrung von Vorbedingungen in Nachbedingungen, Ã¤hnlich wie in (54.1).


Frage: Was ist die Idee hinter der ÃœberfÃ¼hrung von Vorbedingungen in Nachbedingungen?
Antwort: Die Idee hinter der ÃœberfÃ¼hrung von Vorbedingungen in Nachbedingungen stammt aus der formalen Programmverifikation und wird genutzt, um auch das Verhalten der Objekte eines Typs zu berÃ¼cksichtigen. Dabei werden Vorbedingungen in Nachbedingungen Ã¼berfÃ¼hrt, um die ZuweisungskompatibilitÃ¤t zu regeln.


Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn fÃ¼r jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs hÃ¶chstens temporÃ¤r, wÃ¤hrend der MethodenausfÃ¼hrung, verletzt werden).


Frage: Was bedeutet es, wenn ein Typ als korrekt implementiert gilt?
Antwort: Ein Typ wird als korrekt implementiert betrachtet, wenn fÃ¼r jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt und dass die Invarianten des Typs hÃ¶chstens temporÃ¤r wÃ¤hrend der MethodenausfÃ¼hrung verletzt werden.

Frage: Was ist eine Vorbedingung und Nachbedingung in der Objektorientierung?
Antwort: In der Objektorientierung ist eine Vorbedingung eine Bedingung, die vor der AusfÃ¼hrung einer Methode erfÃ¼llt sein muss. Die Nachbedingung ist eine Bedingung, die nach der AusfÃ¼hrung einer Methode erfÃ¼llt sein muss. Ein Typ gilt als korrekt implementiert, wenn fÃ¼r jede Methode gezeigt werden kann, dass aus der Vorbedingung die Nachbedingung folgt.

Frage: Was beschreibt die Nachbedingung einer Methode?
Antwort: Die Nachbedingung einer Methode beschreibt den Zustand, in dem sich das Objekt nach der AusfÃ¼hrung der Methode befindet.

Frage: Was beschreibt die Vorbedingung einer Methode?
Antwort: Die Vorbedingung einer Methode beschreibt den Zustand, in dem sich ein Objekt befinden muss, damit die Methode aufgerufen werden kann.

Frage: Was sind Invarianten?
Antwort: Invarianten sind Bedingungen, die fÃ¼r alle ZustÃ¤nde eines Objekts gelten mÃ¼ssen.


Damit meinen wir, dass fÃ¼r eine Implementierung von m in der zugehÃ¶rigen Klasse von T, die auf einem EmpfÃ¤ngerobjekt vom Typ T (einer Instanz der entsprechenden Klasse) aufgerufen wird, die Nachbedingung aus der Vorbedingung folgt. Wir mÃ¼ssen diesen Beweis jedoch nicht fÃ¼hren, da unser Interesse hier nicht auf der Korrektheit der Implementierungen an sich liegt, sondern vielmehr daran, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhÃ¤ngig vom Verwendungskontext. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird und es durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Mehr dazu in Abschnitt 54.5.


Frage: Was ist der Zweck der PrÃ¼fung, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhÃ¤ngig vom Verwendungskontext?
Antwort: Der Zweck der PrÃ¼fung ist es, festzustellen, ob ein Objekt durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird.

Frage: Was ist der Zweck der Nachbedingung in der objektorientierten Programmierung?
Antwort: Der Zweck der Nachbedingung in der objektorientierten Programmierung ist es, die Korrektheit der Implementierung zu gewÃ¤hrleisten. Die Nachbedingung wird aus der Vorbedingung abgeleitet und gilt fÃ¼r die Implementierung einer Methode in der zugehÃ¶rigen Klasse. Der Beweis fÃ¼r die Nachbedingung muss nicht gefÃ¼hrt werden, da es hier um die Austauschbarkeit von Implementierungen abhÃ¤ngig vom Verwendungskontext geht.


Uns interessiert, ob eine umfassende Substituierung mÃ¶glich ist. Konkret: Wir mÃ¶chten eine verhaltensbasierte Subtypenrelation betrachten, das heiÃŸt, wir mÃ¶chten die Bedingungen verstehen, die potenzielle Subtypen erfÃ¼llen mÃ¼ssen, damit sie die Spezifikation des Supertyps erfÃ¼llen und als verhaltenskonform betrachtet werden kÃ¶nnen. Dabei handelt es sich um eine Subtypenbeziehung, wie sie in Kapitel 26 beschrieben wird. Dies ist dann der Fall, wenn die obige Implikation auch fÃ¼r Objekte des potenziellen Subtypen S gilt.


Frage: Was ist eine verhaltensbasierte Subtypenrelation?
Antwort: Eine verhaltensbasierte Subtypenrelation ist eine Beziehung zwischen potenziellen Subtypen und Supertypen, bei der die Bedingungen betrachtet werden, die erfÃ¼llt sein mÃ¼ssen, damit die potenziellen Subtypen die Spezifikation des Supertyps erfÃ¼llen und als verhaltenskonform betrachtet werden kÃ¶nnen. Diese Beziehung wird in Kapitel 26 beschrieben.


Man spricht dann von einem Behavior Subtyping, was am besten als verhaltensbasiertes Subtyping wiedergegeben wird.


Frage: Was ist verhaltensbasiertes Subtyping?
Antwort: Verhaltensbasiertes Subtyping, auch bekannt als Behavior Subtyping, ist ein Prinzip in der objektorientierten Programmierung, bei dem ein Untertyp die gleichen Methoden wie sein Obertyp haben muss, aber nicht unbedingt die gleichen Attribute. Das bedeutet, dass ein Objekt eines Untertyps die gleichen Methoden wie ein Objekt des Obertyps aufrufen kann, aber nicht umgekehrt.

Frage: Was ist Behavior Subtyping?
Antwort: Behavior Subtyping, auch verhaltensbasiertes Subtyping genannt, ist eine Art von Subtyping, bei der ein Untertyp die gleichen Methoden wie sein Obertyp haben muss, aber nicht unbedingt die gleichen Attribute.


Wir mÃ¼ssen also sicherstellen, dass (6.3) erfÃ¼llt ist. Bei der Spezifikation der Methoden des (potenziellen Sub-)Typs S werden wir zunÃ¤chst nicht auf die Vor- und Nachbedingungen von T zurÃ¼ckgreifen, sondern unsere eigenen definieren. Dies ist jedoch im Allgemeinen nicht der Fall. Die Frage lautet also: Wie mÃ¼ssen ğ‘ğ‘Ÿğ‘’ğ‘šS, ğ‘ğ‘Ÿğ‘’ğ‘šT, ğ‘ğ‘œğ‘ ğ‘¡ğ‘šS und ğ‘ğ‘œğ‘ ğ‘¡ğ‘šT miteinander in Beziehung stehen, damit Objekte vom Typ S die Anforderungen fÃ¼r Objekte vom Typ T erfÃ¼llen? Formal ausgedrÃ¼ckt: Was mÃ¼ssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), dem Verhalten von m in T angewandt auf Objekte aus S, folgt?
Leider reicht es nicht aus, diese Frage zu beantworten. Aufgrund des weit verbreiteten Aliasings in der objektorientierten Programmierung kann ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden. Dadurch kÃ¶nnen Methoden auf dem Objekt aufgerufen werden, die ZustandsÃ¤nderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und fÃ¼r Benutzer, die das Objekt als T betrachten, nicht akzeptabel. Eine methodenweise Betrachtung von Bedingungen fÃ¼r die Substituierbarkeit reicht also nicht aus. Man kann bereits erahnen, dass diese Angelegenheit komplex wird.


Frage: Was ist das Problem mit der methodenweisen Betrachtung von Bedingungen fÃ¼r die Substituierbarkeit?
Antwort: Die methodenweise Betrachtung von Bedingungen fÃ¼r die Substituierbarkeit reicht nicht aus, weil sie nicht berÃ¼cksichtigt, dass ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden kann. Dadurch kÃ¶nnen Methoden auf dem Objekt aufgerufen werden, die ZustandsÃ¤nderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und fÃ¼r Benutzer, die das Objekt als T betrachten, nicht akzeptabel.

Frage: Was ist das Problem mit der Substituierbarkeit von Objekten in der objektorientierten Programmierung?
Antwort: Das Problem ist, dass ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden kann. Dadurch kÃ¶nnen Methoden auf dem Objekt aufgerufen werden, die ZustandsÃ¤nderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und fÃ¼r Benutzer, die das Objekt als T betrachten, nicht akzeptabel.

Frage: Was ist Aliasing in der objektorientierten Programmierung?
Antwort: Aliasing in der objektorientierten Programmierung bedeutet, dass mehrere Variablen auf dasselbe Objekt verweisen. Das kann dazu fÃ¼hren, dass ZustandsÃ¤nderungen an dem Objekt von einem Klienten unerwartet fÃ¼r einen anderen Klienten sichtbar werden, da beide Klienten das Objekt Ã¼ber eine eigene Variable referenzieren.
