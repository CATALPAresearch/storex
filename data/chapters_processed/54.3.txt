54.3 Verhaltensbasiertes Subtyping

Die Regeln des Subtypings aus Kapitel 26 und die damit verbundene Regelung der Zuweisungskompatibilität bezogen sich lediglich auf die Elemente einer Typdeklaration und somit auf rein statische Informationen. Um nun auch das Verhalten der Objekte eines Typs zu berücksichtigen, greift man auf eine Idee aus der formalen Programmverifikation zurück, nämlich die Überführung von Vorbedingungen in Nachbedingungen, ähnlich wie in (54.1).


Frage: Was ist die Idee hinter der Überführung von Vorbedingungen in Nachbedingungen?
Antwort: Die Idee hinter der Überführung von Vorbedingungen in Nachbedingungen stammt aus der formalen Programmverifikation und wird genutzt, um auch das Verhalten der Objekte eines Typs zu berücksichtigen. Dabei werden Vorbedingungen in Nachbedingungen überführt, um die Zuweisungskompatibilität zu regeln.


Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs höchstens temporär, während der Methodenausführung, verletzt werden).


Frage: Was bedeutet es, wenn ein Typ als korrekt implementiert gilt?
Antwort: Ein Typ wird als korrekt implementiert betrachtet, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt und dass die Invarianten des Typs höchstens temporär während der Methodenausführung verletzt werden.

Frage: Was ist eine Vorbedingung und Nachbedingung in der Objektorientierung?
Antwort: In der Objektorientierung ist eine Vorbedingung eine Bedingung, die vor der Ausführung einer Methode erfüllt sein muss. Die Nachbedingung ist eine Bedingung, die nach der Ausführung einer Methode erfüllt sein muss. Ein Typ gilt als korrekt implementiert, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung die Nachbedingung folgt.

Frage: Was beschreibt die Nachbedingung einer Methode?
Antwort: Die Nachbedingung einer Methode beschreibt den Zustand, in dem sich das Objekt nach der Ausführung der Methode befindet.

Frage: Was beschreibt die Vorbedingung einer Methode?
Antwort: Die Vorbedingung einer Methode beschreibt den Zustand, in dem sich ein Objekt befinden muss, damit die Methode aufgerufen werden kann.

Frage: Was sind Invarianten?
Antwort: Invarianten sind Bedingungen, die für alle Zustände eines Objekts gelten müssen.


Damit meinen wir, dass für eine Implementierung von m in der zugehörigen Klasse von T, die auf einem Empfängerobjekt vom Typ T (einer Instanz der entsprechenden Klasse) aufgerufen wird, die Nachbedingung aus der Vorbedingung folgt. Wir müssen diesen Beweis jedoch nicht führen, da unser Interesse hier nicht auf der Korrektheit der Implementierungen an sich liegt, sondern vielmehr daran, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird und es durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Mehr dazu in Abschnitt 54.5.


Frage: Was ist der Zweck der Prüfung, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext?
Antwort: Der Zweck der Prüfung ist es, festzustellen, ob ein Objekt durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird.

Frage: Was ist der Zweck der Nachbedingung in der objektorientierten Programmierung?
Antwort: Der Zweck der Nachbedingung in der objektorientierten Programmierung ist es, die Korrektheit der Implementierung zu gewährleisten. Die Nachbedingung wird aus der Vorbedingung abgeleitet und gilt für die Implementierung einer Methode in der zugehörigen Klasse. Der Beweis für die Nachbedingung muss nicht geführt werden, da es hier um die Austauschbarkeit von Implementierungen abhängig vom Verwendungskontext geht.


Uns interessiert, ob eine umfassende Substituierung möglich ist. Konkret: Wir möchten eine verhaltensbasierte Subtypenrelation betrachten, das heißt, wir möchten die Bedingungen verstehen, die potenzielle Subtypen erfüllen müssen, damit sie die Spezifikation des Supertyps erfüllen und als verhaltenskonform betrachtet werden können. Dabei handelt es sich um eine Subtypenbeziehung, wie sie in Kapitel 26 beschrieben wird. Dies ist dann der Fall, wenn die obige Implikation auch für Objekte des potenziellen Subtypen S gilt.


Frage: Was ist eine verhaltensbasierte Subtypenrelation?
Antwort: Eine verhaltensbasierte Subtypenrelation ist eine Beziehung zwischen potenziellen Subtypen und Supertypen, bei der die Bedingungen betrachtet werden, die erfüllt sein müssen, damit die potenziellen Subtypen die Spezifikation des Supertyps erfüllen und als verhaltenskonform betrachtet werden können. Diese Beziehung wird in Kapitel 26 beschrieben.


Man spricht dann von einem Behavior Subtyping, was am besten als verhaltensbasiertes Subtyping wiedergegeben wird.


Frage: Was ist verhaltensbasiertes Subtyping?
Antwort: Verhaltensbasiertes Subtyping, auch bekannt als Behavior Subtyping, ist ein Prinzip in der objektorientierten Programmierung, bei dem ein Untertyp die gleichen Methoden wie sein Obertyp haben muss, aber nicht unbedingt die gleichen Attribute. Das bedeutet, dass ein Objekt eines Untertyps die gleichen Methoden wie ein Objekt des Obertyps aufrufen kann, aber nicht umgekehrt.

Frage: Was ist Behavior Subtyping?
Antwort: Behavior Subtyping, auch verhaltensbasiertes Subtyping genannt, ist eine Art von Subtyping, bei der ein Untertyp die gleichen Methoden wie sein Obertyp haben muss, aber nicht unbedingt die gleichen Attribute.


Wir müssen also sicherstellen, dass (6.3) erfüllt ist. Bei der Spezifikation der Methoden des (potenziellen Sub-)Typs S werden wir zunächst nicht auf die Vor- und Nachbedingungen von T zurückgreifen, sondern unsere eigenen definieren. Dies ist jedoch im Allgemeinen nicht der Fall. Die Frage lautet also: Wie müssen 𝑝𝑟𝑒𝑚S, 𝑝𝑟𝑒𝑚T, 𝑝𝑜𝑠𝑡𝑚S und 𝑝𝑜𝑠𝑡𝑚T miteinander in Beziehung stehen, damit Objekte vom Typ S die Anforderungen für Objekte vom Typ T erfüllen? Formal ausgedrückt: Was müssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), dem Verhalten von m in T angewandt auf Objekte aus S, folgt?
Leider reicht es nicht aus, diese Frage zu beantworten. Aufgrund des weit verbreiteten Aliasings in der objektorientierten Programmierung kann ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel. Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht also nicht aus. Man kann bereits erahnen, dass diese Angelegenheit komplex wird.


Frage: Was ist das Problem mit der methodenweisen Betrachtung von Bedingungen für die Substituierbarkeit?
Antwort: Die methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht nicht aus, weil sie nicht berücksichtigt, dass ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden kann. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel.

Frage: Was ist das Problem mit der Substituierbarkeit von Objekten in der objektorientierten Programmierung?
Antwort: Das Problem ist, dass ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden kann. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel.

Frage: Was ist Aliasing in der objektorientierten Programmierung?
Antwort: Aliasing in der objektorientierten Programmierung bedeutet, dass mehrere Variablen auf dasselbe Objekt verweisen. Das kann dazu führen, dass Zustandsänderungen an dem Objekt von einem Klienten unerwartet für einen anderen Klienten sichtbar werden, da beide Klienten das Objekt über eine eigene Variable referenzieren.
