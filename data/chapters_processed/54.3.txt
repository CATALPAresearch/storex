54.3 Verhaltensbasiertes Subtyping

Die Regeln des Subtypings aus Kapitel 26 und die damit verbundene Regelung der ZuweisungskompatibilitÃ¤t bezogen sich lediglich auf die Elemente einer Typdeklaration und somit auf rein statische Informationen. Um nun auch das Verhalten der Objekte eines Typs zu berÃ¼cksichtigen, greift man auf eine Idee aus der formalen Programmverifikation zurÃ¼ck, nÃ¤mlich die ÃœberfÃ¼hrung von Vorbedingungen in Nachbedingungen, Ã¤hnlich wie in (54.1).
Im Kontext der Objektorientierung bedeutet dies, dass ein Typ als korrekt implementiert betrachtet wird, wenn fÃ¼r jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt (und dass die Invarianten des Typs hÃ¶chstens temporÃ¤r, wÃ¤hrend der MethodenausfÃ¼hrung, verletzt werden).
Damit meinen wir, dass fÃ¼r eine Implementierung von m in der zugehÃ¶rigen Klasse von T, die auf einem EmpfÃ¤ngerobjekt vom Typ T (einer Instanz der entsprechenden Klasse) aufgerufen wird, die Nachbedingung aus der Vorbedingung folgt. Wir mÃ¼ssen diesen Beweis jedoch nicht fÃ¼hren, da unser Interesse hier nicht auf der Korrektheit der Implementierungen an sich liegt, sondern vielmehr daran, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhÃ¤ngig vom Verwendungskontext. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird und es durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Mehr dazu in Abschnitt 54.5.
Uns interessiert, ob eine umfassende Substituierung mÃ¶glich ist. Konkret: Wir mÃ¶chten eine verhaltensbasierte Subtypenrelation betrachten, das heiÃŸt, wir mÃ¶chten die Bedingungen verstehen, die potenzielle Subtypen erfÃ¼llen mÃ¼ssen, damit sie die Spezifikation des Supertyps erfÃ¼llen und als verhaltenskonform betrachtet werden kÃ¶nnen. Dabei handelt es sich um eine Subtypenbeziehung, wie sie in Kapitel 26 beschrieben wird. Dies ist dann der Fall, wenn die obige Implikation auch fÃ¼r Objekte des potenziellen Subtypen S gilt.
Man spricht dann von einem Behavior Subtyping, was am besten als verhaltensbasiertes Subtyping wiedergegeben wird.
Wir mÃ¼ssen also sicherstellen, dass (6.3) erfÃ¼llt ist. Bei der Spezifikation der Methoden des (potenziellen Sub-)Typs S werden wir zunÃ¤chst nicht auf die Vor- und Nachbedingungen von T zurÃ¼ckgreifen, sondern unsere eigenen definieren. Dies ist jedoch im Allgemeinen nicht der Fall. Die Frage lautet also: Wie mÃ¼ssen ğ‘ğ‘Ÿğ‘’ğ‘šS, ğ‘ğ‘Ÿğ‘’ğ‘šT, ğ‘ğ‘œğ‘ ğ‘¡ğ‘šS und ğ‘ğ‘œğ‘ ğ‘¡ğ‘šT miteinander in Beziehung stehen, damit Objekte vom Typ S die Anforderungen fÃ¼r Objekte vom Typ T erfÃ¼llen? Formal ausgedrÃ¼ckt: Was mÃ¼ssen wir voraussetzen, damit aus (54.4), dem Verhalten von m in S, (54.3), dem Verhalten von m in T angewandt auf Objekte aus S, folgt?
Leider reicht es nicht aus, diese Frage zu beantworten. Aufgrund des weit verbreiteten Aliasings in der objektorientierten Programmierung kann ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden. Dadurch kÃ¶nnen Methoden auf dem Objekt aufgerufen werden, die ZustandsÃ¤nderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und fÃ¼r Benutzer, die das Objekt als T betrachten, nicht akzeptabel. Eine methodenweise Betrachtung von Bedingungen fÃ¼r die Substituierbarkeit reicht also nicht aus. Man kann bereits erahnen, dass diese Angelegenheit komplex wird.

Frage: Welche Idee aus der formalen Programmverifikation wird verwendet, um das Verhalten von Objekten in der Subtypenbeziehung zu berÃ¼cksichtigen?
Antwort: Die Idee aus der formalen Programmverifikation besteht darin, Vorbedingungen in Nachbedingungen zu Ã¼berfÃ¼hren, um das Verhalten von Objekten eines Typs zu berÃ¼cksichtigen. Dies wird verwendet, um sicherzustellen, dass die Implementierung eines Typs korrekt ist und dass aus Vorbedingungen die entsprechenden Nachbedingungen folgen.

Frage: Was bedeutet "verhaltensbasiertes Subtyping" oder "Behavior Subtyping"?
Antwort: "Verhaltensbasiertes Subtyping" oder "Behavior Subtyping" bezieht sich auf eine Subtypenbeziehung, bei der die Bedingungen erfÃ¼llt sein mÃ¼ssen, damit die Spezifikation des Subtyps die des Supertyps erfÃ¼llt und als verhaltenskonform betrachtet werden kann. Dies bedeutet, dass das Verhalten der Objekte des Subtyps mit dem Verhalten des Supertyps Ã¼bereinstimmen muss.

Frage: Warum kann es zu Problemen kommen, wenn Objekte vom Typ S von einem Klienten als Typ T betrachtet werden?
Antwort: Es kÃ¶nnen Probleme auftreten, wenn Objekte vom Typ S von einem Klienten als Typ T betrachtet werden, da dies zu Aliasen fÃ¼hren kann, bei denen das Objekt von verschiedenen Klienten unterschiedliche Typen hat. Dies kann dazu fÃ¼hren, dass Methoden auf dem Objekt aufgerufen werden, die ZustandsÃ¤nderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und kann fÃ¼r Benutzer, die das Objekt als T betrachten, nicht akzeptabel sein.

Frage: Warum reicht eine methodenweise Betrachtung von Bedingungen fÃ¼r die Substituierbarkeit nicht aus?
Antwort: Eine methodenweise Betrachtung von Bedingungen fÃ¼r die Substituierbarkeit reicht nicht aus, da Aliasings in der objektorientierten Programmierung dazu fÃ¼hren kann, dass ein Objekt vom Typ S von verschiedenen Klienten unterschiedliche Typen hat und Methodenaufrufe auf dem Objekt ZustandsÃ¤nderungen verursachen kÃ¶nnen, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Daher muss eine umfassendere Betrachtung erfolgen, die die Auswirkungen des Verhaltens auf den Zustand und die Spezifikation des Typs berÃ¼cksichtigt.