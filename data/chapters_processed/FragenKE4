Weitere Fragen zu KE4

Frage: Welche beiden Interfaces in Java ermöglichen eine einheitliche Iteration über Collections mittels Iteratoren?
Antwort: In Java ermöglichen die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer) eine einheitliche Iteration über Collections mittels Iteratoren.

Frage: Was ist das Überschreiben von Methoden in Java, und welche Bedingungen gelten dafür?
Antwort: Das Überschreiben von Methoden in Java bedeutet, dass eine bereits vorhandene Methode in einer Subklasse mit derselben Signatur (Methodenname und formale Parametertypen) neu definiert wird. Die Bedingungen dafür sind, dass die Methode denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode hat und dass die deklarierten Parametertypen der Methode Subtypen der deklarierten Parametertypen der Methode in der Superklasse sind.

Frage: Was ist das Überladen von Methoden in Java, und wie unterscheidet es sich vom Überschreiben?
Antwort: Das Überladen von Methoden in Java bedeutet, dass Methoden denselben Namen haben, aber verschiedene Parametertypen in derselben Klasse oder einer Subklasse haben. Der Unterschied zum Überschreiben besteht darin, dass beim Überladen neue Methoden hinzugefügt werden, während beim Überschreiben bereits vorhandene Methoden neu definiert werden.

Frage: Was ist dynamisches Binden in Java, und wie funktioniert der Bindungsalgorithmus?
Antwort: Das dynamische Binden in Java bezieht sich auf die Auswahl der Methode zur Laufzeit, basierend auf dem tatsächlichen Typ des Empfängerobjekts. Der Bindungsalgorithmus in Java wählt die Methode aus, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode, ist in der Klasse des deklarierten Typs des Ausdrucks deklariert und deren deklarierte Parametertypen sind Subtypen der deklarierten Parametertypen der aufgerufenen Methode. Wenn mehrere Methoden die Bedingungen erfüllen, wird diejenige ausgewählt, deren Klasse am nächsten zur Klasse des Empfängerobjekts in der Superklassenkette ist.

Frage: Was sind die Einschränkungen von Java-Arrays im Vergleich zu Collections?
Antwort: Java-Arrays haben im Vergleich zu Collections Einschränkungen in ihrer Funktionalität. Sie bieten keine eigenen Methoden zur Unterstützung des Zugriffs, kein dynamisches Wachstum und es gibt einige Probleme mit dem Subtyping von Arrays.

Frage: Welche Vorteile bietet die Verwendung von Interfaces in Java?
Antwort: Die Verwendung von Interfaces in Java ermöglicht die Bereitstellung verschiedener Sichten auf Objekte, die von Klassen implementiert werden. Dies kann dazu beitragen, den Zugriff auf die Methoden eines Objekts zu beschränken oder die Austauschbarkeit von Klassen zu verbessern.

Frage: Was sind Tagging oder Marker-Interfaces in Java und wofür werden sie verwendet?
Antwort: Tagging oder Marker-Interfaces in Java sind Schnittstellen, die in der Regel keine eigenen Methoden deklarieren, sondern dazu verwendet werden, Klassen zu markieren oder zu "taggen". Sie dienen der Filterung von Variablenwerten und können beispielsweise dazu verwendet werden, bestimmte Eigenschaften oder Fähigkeiten von Klassen oder Objekten zu kennzeichnen. Ein Beispiel ist das Marker-Interface "Serializable", das angibt, dass Instanzen einer Klasse serialisierbar sind.

Frage: Welche Rolle spielen Interfaces bei der Einschränkung des Zugriffs auf Methoden in Java?
Antwort: Interfaces können dazu verwendet werden, den Zugriff auf Methoden zu beschränken, da nur die im Interface definierten Methoden aufgerufen werden können. Dies ermöglicht es, verschiedene Sichten auf ein Objekt zu gewähren und den Zugriff auf bestimmte Methoden zu kontrollieren.

Frage: Welche Rolle spielt die Java Virtual Machine (JVM) in Java-Programmen?
Antwort: Die Java Virtual Machine (JVM) interpretiert den Bytecode, der das Ergebnis der Übersetzung von Java-Programmen ist. Sie spielt eine entscheidende Rolle bei der Ausführung von Java-Programmen.

Frage: Was ist die typische Methode, um ein Java-Programm auszuführen, und wie lautet ihre Signatur?
Antwort: Die typische Methode, um ein Java-Programm auszuführen, ist die "main"-Methode mit der Signatur "public static void main(String[] args)". Dies ist die Startmethode für Java-Anwendungen.

Frage: Was ist ein wichtiges Merkmal des Programmiermodells von Java in Bezug auf die Namenskonvention von Klassen?
Antwort: Ein wichtiges Merkmal des Programmiermodells von Java ist, dass Klassennamen immer großgeschrieben werden sollen.

Frage: Welches Problem ergibt sich bei der Erweiterung von Interfaces, wenn man keine abstrakten Klassen verwendet?
Antwort: Bei der Erweiterung von Interfaces, insbesondere wenn diese von Anwendungsklassen implementiert werden, entsteht das Problem, dass die Klassen, die diese Interfaces implementieren, aktualisiert werden müssen. Dies kann zu Schwierigkeiten führen, insbesondere wenn die Entwicklung dieser Klassen in den Händen Dritter liegt.

Frage: Welchen Zusammenhang gibt es zwischen Klassen und Dateien in Java?
Antwort: In Java entspricht normalerweise jede Datei der Definition einer Klasse mit dem gleichen Namen wie der Dateiname (ohne Erweiterung). Es ist möglich, mehrere Klassen in einer Datei zu definieren, aber keine dieser Klassen darf als "public" deklariert werden. Dies liegt an Konventionen, die die meisten integrierten Entwicklungsumgebungen und Versionsverwaltungssysteme unterstützen. In der Regel sollte jede Datei eine öffentliche Klasse mit demselben Namen enthalten.

Frage: Welche Konvention wird in Java verwendet, um den Typ bei Deklarationen anzugeben, und wie unterscheidet sich dies von STRONGTALK?
Antwort: In Java wird der Typ bei Deklarationen ohne spitze Klammern vorangestellt. Dies unterscheidet sich von STRONGTALK, bei dem die spitzen Klammern in Deklarationen verwendet werden. In Java folgt die Typangabe der Tradition von C und C++.

Frage: Was ist das Reflection API in Java und wofür wird es verwendet?
Antwort: Das Reflection API in Java ermöglicht den Zugriff auf die Elemente eines Programms, obwohl nicht alles in Java ein Objekt ist. Es stellt Klassen zur Verfügung, die verschiedene Programmelemente repräsentieren, wie Methoden (Klasse Method) oder Felder (Klasse Field). Dies ermöglicht es, Programmierung auf einer höheren Ebene durchzuführen, indem man dynamisch auf Programmstrukturen zugreift. Eine ausführliche Untersuchung dieses APIs wird im Kurs 01853 ("Moderne Programmiertechniken und -methoden") behandelt.

Frage: Was sind Annotationen in Java und welche Rolle spielen sie in der Metaprogrammierung?
Antwort: Annotationen in Java sind eine Form der Metaprogrammierung, bei der Programmmetadaten den Programmelementen im Quelltext zugeordnet werden. Diese Metadaten können während der Übersetzung und/oder während der Ausführung des Programms abgefragt werden und den jeweiligen Prozess beeinflussen oder steuern. In Java 5 wurden Annotationen als eine spezielle Art von Interfaces eingeführt, die jedoch keine Methoden, sondern nur Felder deklarieren. Annotationen werden häufig verwendet, um zusätzliche Informationen oder Konfigurationen zu einem Programm hinzuzufügen.

Frage: Was ist ein Modul in der Programmierung und wie ist seine Schnittstelle definiert?
Antwort: Ein Modul ist eine Einheit von Programmelementen, deren Funktion von außen, z. B. von anderen Modulen, nur über die Schnittstelle des Moduls zugänglich ist. Die Schnittstelle definiert, welche Teile des Moduls öffentlich sichtbar sind.

Frage: Welche Trennung gibt es in Java zwischen Operationen und Methoden?
Antwort: In Java gibt es eine Trennung zwischen Operationen, die auf primitiven Typen fest vorgegeben sind, und Methoden, die in Klassen definiert werden müssen.

Frage: Welcher Operator steht speziell für Referenztypen in Java zur Verfügung?
Antwort: Ein Operator, der speziell für Referenztypen in Java zur Verfügung steht, ist der Typtest "instanceof". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist.

Frage: Welche Funktionen haben Klassen in Java?
Antwort: Klassen in Java dienen als Vorlagen für die Erzeugung von Objekten, liefern Typen für ein Programm und dienen der Modularisierung.

Frage: Was sind Zugriffsmodifikatoren in Java?
Antwort: Zugriffsmodifikatoren (access modifiers) sind in Java Schlüsselwörter wie private, protected, public und "Package local," die die Zugriffsbeschränkungen für Klassen, Typen und deren Elemente festlegen. Sie regeln, welche Teile einer Klasse von anderen Klassen aus zugänglich sind.

Frage: Welche Auswirkungen haben die Zugriffsbeschränkungen in Java?
Antwort: Die Zugriffsbeschränkungen in Java regeln, welche Teile einer Klasse oder eines Typs von anderen Klassen oder Typen aus zugänglich sind. Sie beeinflussen die Sichtbarkeit von Variablen, Methoden und anderen Elementen innerhalb einer Klasse und zwischen Klassen, insbesondere in verschiedenen Paketen.

Frage: Was sind die konkreten Auswirkungen der Zugriffsbeschränkungen in Java?
Antwort: Die Zugriffsbeschränkungen in Java wirken sich auf die Sichtbarkeit von Elementen innerhalb von Klassen und zwischen Klassen aus. Sie regeln, welche Teile eines Moduls von anderen Modulen aus sichtbar sind und können durch Hiding, Shadowing und Obscuring weiter eingeschränkt werden. Die Verknüpfung von Typ und Zugriffsbeschränkung ist in Java etabliert und ermöglicht die Deklaration von Typen und Schnittstellen in einem.

Frage: Welche Arten von Literale gibt es in Java?
Antwort: In Java gibt es Literale für Zahlen, Zeichen und Strings.

Frage: Welche drei besonderen Werte im Fließkommabereich haben keine Literale, sondern nur Konstanten in Java?
Antwort: Die drei besonderen Werte im Fließkommabereich, die keine Literale, sondern nur Konstanten in Java haben, sind "NaN" (Not a Number), "POSITIVE_INFINITY" und "NEGATIVE_INFINITY".

Frage: Welcher Typ hat ein Klassenliteral in Java?
Antwort: Der Typ eines Klassenliterals in Java ist "Class<T>", wobei T der Typ der Klasse ist. Zum Beispiel hat "Class<Object>" den Typ "Class<Object>".

Frage: Welche Art von Typprüfungen kann Java zur Übersetzungszeit durchführen?
Antwort: Java kann zur Übersetzungszeit statische Typprüfungen durchführen.

Frage: Welche gelegentlichen Typprüfungen erfordern dynamische Typprüfungen in Java?
Antwort: Gelegentliche Typprüfungen, die dynamische Typprüfungen in Java erfordern, sind insbesondere Typumwandlungen (Type casts).

Frage: Welches Schlüsselwort verwendet Java, um die Bestehen einer Subklassenbeziehung zwischen zwei Klassen zu deklarieren?
Antwort: Java verwendet das Schlüsselwort "extends," um die Bestehen einer Subklassenbeziehung zwischen zwei Klassen zu deklarieren.

Frage: Was ist ein Interface in Java und wie wird es deklariert?
Antwort: Ein Interface in Java ist eine eigenständige Schnittstellendeklaration, die von einer Klasse unabhängig ist, aber genauso wie eine Klasse einen Typ definiert. Interfaces werden mit dem Schlüsselwort "interface" deklariert.

Frage: Welche Unterschiede gibt es zwischen der Deklaration eines Interfaces und einer Klasse?
Antwort: Die Unterschiede zwischen der Deklaration eines Interfaces und einer Klasse sind: Verwendung des Schlüsselworts "interface" anstelle von "class". Fehlen von Felddeklarationen in Interfaces. In Interfaces folgt auf die Methodendeklaration lediglich ein abschließendes Semikolon, ohne Implementierung.

Frage: Welchen Vorteil bietet die Verwendung von Interfaces bei der Verwendung von Variablen?
Antwort: Die Verwendung von Interfaces ermöglicht es, Methoden und Felder einer Instanz vor anderen Instanzen zu verbergen. Durch die Deklaration von Variablen mit dem Interface als Typ kann der Zugriff auf bestimmte Methoden und Felder beschränkt werden.

Frage: Welche Beziehung müssen die Typen in Java haben, damit Ausdrücke von einem Typ Variablen eines anderen Typs zugewiesen werden können?
Antwort: Damit Ausdrücke von einem Typ Variablen eines anderen Typs zugewiesen werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen ihnen bestehen.

Frage: Was ist nominale Typkonformität, und welche Vor- und Nachteile hat sie?
Antwort: Nominale Typkonformität bedeutet, dass die Subtypbeziehung explizit deklariert werden muss. Dies hat den Vorteil der Filterfunktion, aber den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen, was bei verteilten Anwendungen problematisch sein kann.

Frage: Welche Anforderung stellt Java an geerbte Variablen (Felder und Parametertypen von Methoden)?
Antwort: Java verlangt, dass die Typen geerbter Variablen nicht verändert werden dürfen. Dies wird als Kovarianz bezeichnet.

Frage: Was sind Konstruktoren in Java, und wie verhalten sie sich im Vergleich zu SMALLTALK?
Antwort: Konstruktoren in Java sind spezielle Methoden, die zur Erzeugung von Objekten verwendet werden. Im Gegensatz zu SMALLTALK sind Konstruktoren in Java keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Sie verhalten sich wie Instanzmethoden und können auf alle Felder und Methoden der neu erzeugten Instanz zugreifen.

Frage: Was sind Factory-Methoden in Java, und wie werden sie verwendet?
Antwort: Factory-Methoden sind Klassenmethoden in Java, die zur Erzeugung von Objekten verwendet werden können. Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben. Factory-Methoden ermöglichen eine flexible Objekterzeugung und werden oft in Bibliotheken und Frameworks eingesetzt.

Frage: Was ist Exception Handling in Java?
Antwort: Exception Handling ist eine Möglichkeit in Java, mögliche Ausnahmesituationen und deren Behandlung bei der Spezifikation des Kontrollflusses eines Programms vorübergehend zu vernachlässigen und so zu tun, als würde immer alles gutgehen. Ausnahmesituationen werden in Java in Form von Exception-Klassen dargestellt.

Frage: Was sind Checked Exceptions in Java?
Antwort: Checked Exceptions sind Ausnahmesituationen, bei denen die Programmierer sich der möglichen Ausnahmesituationen bewusst sein müssen. Sie erfordern eine Deklaration im Methodenkopf oder müssen innerhalb der Methode behandelt werden. Diese Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind.

Frage: Was sind Unchecked Exceptions in Java?
Antwort: Unchecked Exceptions sind Ausnahmesituationen, die in der Praxis überall auftreten können. Sie erfordern keine explizite Deklaration im Methodenkopf und können überall auftreten. Unchecked Exceptions werden von Exception-Klassen abgeleitet, die von RuntimeException abgeleitet sind.

Frage: Welche Initiative wurde von der Java-Community aufgegriffen, um die Situation mit aufgeteilten Paketen zu verbessern?
Antwort: Die Java-Community griff die Open Services Gateway Initiative (OSGi) auf, um die Situation mit aufgeteilten Paketen zu verbessern. OSGi ermöglichte die Zusammenfassung von Java-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation.

Frage: Was ist der qualifizierte Export in der Moduldefinition von Java?
Antwort: Der qualifizierte Export in der Moduldefinition von Java ist ähnlich wie in EIFFEL. Er nennt die Module, an die exportiert wird, namentlich und erlaubt einen "privaten" Austausch zwischen bestimmten Modulen, die somit ihre eigenen, privaten Schnittstellen haben.

Frage: Was ist das Besondere an der Moduldefinition von Java in Bezug auf die Einhaltung der Schnittstellenspezifikationen?
Antwort: Die Moduldefinition von Java erzwingt die Einhaltung der Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit. Sie kontrolliert auch den reflektiven Zugriff auf Programmelemente, was zu einer erheblichen Verbesserung der Sicherheit von Java-Programmen führt.

Frage: Welche Möglichkeit zur Iteration von Collection-Klassen kennen Sie aus SMALLTALK?
Antwort: In SMALLTALK gibt es die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren, was als interne Iteration bezeichnet wird.

Frage: Welche neuen Funktionen wurden in Java 8 eingeführt, um interne Iterationen zu ermöglichen?
Antwort: In Java 8 wurden (anonyme) Funktionen, auch bekannt als Lambda-Ausdrücke, eingeführt, um interne Iterationen à la SMALLTALK zu ermöglichen.

Frage: Welches Framework wurde für die Implementierung der Methoden forEach, filter, map und reduce in Java 8 geschaffen?
Antwort: Für die Implementierung der Methoden forEach, filter, map und reduce in Java 8 wurde das Stream-Framework geschaffen.

Frage: Welche Vorteile bietet das Stream-Framework von Java im Vergleich zu naiven Implementierungen von Pipelines?
Antwort: Das Stream-Framework von Java ermöglicht für viele Pipelines eine besonders effiziente Ausführung. Es minimiert die Anzahl der Iterationen, reduziert die interne Speicherung von Zwischenergebnissen und erlaubt die Auswahl zwischen paralleler und sequenzieller Verarbeitung der Pipeline. Dennoch ist die Performanz von Java-Pipelines nicht leicht vorherzusagen und erfordert Erfahrung und Kenntnisse der Implementierung.

Frage: Was ist die Hauptanwendung generischer Typen in Java?
Antwort: Eine Hauptanwendung generischer Typen in Java ist die Arbeit mit Collections, um den Typ der Elemente in der Collection anzugeben und so die Typsicherheit zu erhöhen.

Frage: Welche Konvention wird häufig verwendet, um Typparameter von Klassen- und Variablennamen zu unterscheiden?
Antwort: Eine häufig verwendete Konvention ist es, einzelne Großbuchstaben für Typparameter zu wählen. Zum Beispiel steht "E" üblicherweise für den Elementtyp von Containern wie Collections.

Frage: Was ist rekursiv beschränkter parametrischer Polymorphismus in Java?
Antwort: Rekursiv beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Möglichkeit, Beschränkungen für Typparameter auf eine Weise zu definieren, die auf sich selbst oder andere Typparameter verweist.

Frage: Welcher Typkonstruktor wurde in Java 1.5 für Aufzählungstypen hinzugefügt?
Antwort: In Java 1.5 wurde der Typkonstruktor enum für Aufzählungstypen hinzugefügt.

Frage: Welche Art von Typen sind Aufzählungstypen in Java?
Antwort: Aufzählungstypen in Java sind Klassentypen. Sie können neben den Aufzählungselementen auch Felder und Methoden enthalten.

Frage: Was ist das Symbol für eine Typ-Wildcard in Java?
Antwort: Das Symbol für eine Typ-Wildcard in Java ist das Fragezeichen.

Frage: Was ist die Verwendung von "extends" und "super" in Verbindung mit Typ-Wildcards?
Antwort: "extends" wird verwendet, um eine obere Schranke für Typ-Wildcards anzugeben, während "super" verwendet wird, um eine untere Schranke anzugeben. Mit "extends" beschränkte Wildcard-Typen sind kovariant, und mit "super" beschränkte Wildcard-Typen sind kontravariant.

Frage: Welche Einschränkung gibt es bei der Verwendung von "super" beschränkten Typ-Wildcards?
Antwort: Bei "super" beschränkten Typ-Wildcards ist der Zugriff auf Elemente in der Regel auf schreibende Zugriffe beschränkt, und lesende Zugriffe haben immer den Typ "Object".

Frage: Welche Art von Subtyping wird bei "extends" beschränkten Wildcard-Typen verwendet?
Antwort: "extends" beschränkte Wildcard-Typen verwenden kovariantes Subtyping.

Frage: Welche Art von Subtyping wird bei "super" beschränkten Wildcard-Typen verwendet?
Antwort: "super" beschränkte Wildcard-Typen verwenden kontravariantes Subtyping.

Frage: Was sind generische Typen in Java?
Antwort: Generische Typen in Java sind Typdefinitionen, die Typvariablen verwenden, um die Referenzierung eines oder mehrerer Typen innerhalb der Definition zu abstrahieren.

Frage: Welche Merkmale von C++ und SMALLTALK wurden in Java übernommen?
Antwort: In Java wurden weite Teile der Syntax und der statischen Typüberprüfung von C++ übernommen. Außerdem wurde der eher klassisch prozedurale Charakter von C++ beibehalten, wobei Methodenaufrufe anstelle von Nachrichtenversand verwendet werden. Von SMALLTALK wurden die umfassende Objektorientierung (es gibt keinen Code außerhalb von Klassen), die Einfachvererbung sowie die Garbage Collection übernommen.

Frage: Was sind Instanzvariablen in Java?
Antwort: Instanzvariablen in Java sind Felder, die zur Speicherung von Daten in einer Klasse verwendet werden. Jede Instanz der Klasse hat ihre eigenen Kopien dieser Variablen.

Frage: Was sind Instanzmethoden in Java?
Antwort: Instanzmethoden in Java sind Methoden, die auf Instanzen (Objekten) einer Klasse angewendet werden können. Sie definieren das Verhalten der Klasse.

Frage: Was sind "Member" in Bezug auf Klassendefinitionen in Java?
Antwort: "Member" ist ein zusammenfassender Begriff für Felder und Methoden innerhalb einer Klassendefinition in Java.

Frage: Welche weiteren Arten von Klassendefinitionen sind in Java möglich?
Antwort: In Java können Sie auch geschachtelte Klassendefinitionen und innere Klassendefinitionen erstellen, die ebenfalls als Members der umschließenden Klasse gelten.

Frage: Welche Arten von Ausdrücken gibt es in Java?
Antwort: In Java gibt es verschiedene Arten von Ausdrücken, darunter Literale, Variablen, Methodenaufrufe, Operatoranwendungen, Feldzugriffe, Klasseninstanziierungen, Array-Instanziierungen, Konditionalausdrücke, Cast-Ausdrücke und Lambda-Ausdrücke.

Frage: Welche Typisierungsanforderungen gelten für Ausdrücke in Java?
Antwort: In Java müssen alle Ausdrücke korrekt typisiert sein. Das bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks übereinstimmen muss, an der Stelle, an der er eingesetzt wird.

Frage: Welche Rolle spielen Lambda-Ausdrücke in Java, und wie unterscheiden sie sich von anonymen inneren Klassen?
Antwort: Lambda-Ausdrücke in Java, die in Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Sie ermöglichen die Darstellung von Funktionen als Werte und werden häufig für die Implementierung von Schnittstellen mit nur einer Methode (Funktionale Interfaces) verwendet. Im Gegensatz dazu verwenden anonyme innere Klassen explizite Klassendefinitionen, um Schnittstellen zu implementieren.

Frage: Welche Arten von Typumwandlungen gibt es in Java?
Antwort: In Java gibt es drei Arten von Typumwandlungen: Up casts, Down casts und Cross casts.

Frage: Was ist ein Up cast?
Antwort: Ein Up cast tritt auf, wenn der Zieltyp ein Supertyp des Ausgangstyps ist.

Frage: Was ist ein Down cast?
Antwort: Ein Down cast tritt auf, wenn der Zieltyp ein Subtyp des Ausgangstyps ist.

Frage: Was ist ein Cross cast?
Antwort: Ein Cross cast tritt auf, wenn Zieltyp und Ausgangstyp keine Subtypenbeziehung zueinander haben und nebeneinander stehen.

Frage: Welche Art von Typumwandlung ist immer sicher?
Antwort: Ein Up cast ist immer sicher, da jedes Objekt neben seinem Typ auch den Typ all seiner Supertypen hat.

Frage: Welche Art von Typumwandlung kann zu Laufzeittypfehlern führen?
Antwort: Down und Cross casts können zu Laufzeittypfehlern führen, wenn das Objekt, zu dem der typumgewandelte Ausdruck ausgewertet wird, nicht den Zieltyp oder einen Subtyp davon hat. Dies kann zur Laufzeit zu ClassCastException-Fehlern führen.

Frage: Welche Bedeutung haben Interfaces und Module in Java?
Antwort: Interfaces und Module sind in Java eng miteinander verknüpft und dienen dazu, die Schnittstellen und die Modularisierung von Klassen und Programmen zu definieren.

Frage: Welche Rolle spielen Interfaces in der objektorientierten Programmierung?
Antwort: Interfaces spielen in der objektorientierten Programmierung eine wichtige Rolle, da sie dazu dienen, Schnittstellen zu definieren, über die Klassen miteinander kommunizieren können. Sie ermöglichen die Implementierung von Methoden in verschiedenen Klassen und erlauben die Implementierung von Polymorphismus.

Frage: Was ist die Besonderheit von Javas Interfaces?
Antwort: Javas Interfaces sind eigenständige Konstrukte, die über die ursprüngliche Bedeutung hinausgehen und weitreichende Möglichkeiten zur Definition von Schnittstellen und zur Entwicklung objektorientierter Programmiersprachen bieten.

Frage: Welche Formen von Abhängigkeiten gibt es in den Klassen als Modulen der Java-Programmierung?
Antwort: In den Klassen als Modulen der Java-Programmierung gibt es zwei Formen von Abhängigkeiten: Eine Klasse hängt von einer anderen ab, wenn auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich durch die Deklaration von Variablen des entsprechenden Typs und gegebenenfalls durch das Importieren der Klasse oder des Pakets, in dem sich die andere Klasse befindet. Eine Klasse bietet einige ihrer Member zur Benutzung durch andere Klassen an und diese werden dadurch von ihr abhängig. Dies erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht privat sind, sowie an der Implementierung von Interfaces.

Frage: Welche Arten von Abhängigkeiten können zwischen Klassen und Paketen in Java entstehen?
Antwort: In Java können Vererbungsabhängigkeiten zwischen Klassen auftreten, die nicht zirkulär sind. Bei der Ausdehnung der Abhängigkeiten auf Pakete können jedoch auch zirkuläre Abhängigkeiten zwischen Paketen entstehen.

Frage: Welches Schlüsselwort wird in Java für Typtests verwendet?
Antwort: Das Schlüsselwort für Typtests in Java lautet "instanceof".

Frage: Welche Vorteile bieten Typtests in Kombination mit bedingten Umwandlungen?
Antwort: Typtests in Kombination mit bedingten Umwandlungen bilden die typsichere Variante der Typumwandlung und helfen, Laufzeitfehler zu vermeiden.

Frage: Was ist die Sichtbarkeit von Typparametern in Methodendefinitionen?
Antwort: Die Sichtbarkeit von Typparametern in Methodendefinitionen ist auf die jeweilige Methode beschränkt.

Frage: Was ist Typinferenz in Bezug auf generische Methoden?
Antwort: Typinferenz in Bezug auf generische Methoden bezieht sich auf die Fähigkeit des Java-Compilers, den tatsächlichen Typparameter wegzulassen, wenn er sich aus dem Kontext des Methodenaufrufs ableiten kann.

Frage: Welche Vorteile bietet die Verwendung von Typinferenz bei generischen Methoden?
Antwort: Die Verwendung von Typinferenz bei generischen Methoden erleichtert die Verwendung, da der tatsächliche Typparameter nicht immer explizit angegeben werden muss, was den Code lesbarer macht.

Frage: Welche Arten von Anweisungen gibt es in Java?
Antwort: In Java gibt es verschiedene Arten von Anweisungen, darunter Variablendeklarationen, Wertzuweisungen, Methodenaufrufe, Klasseninstanziierungen und Kontrollstrukturen wie If-Anweisungen, Schleifen, Switch-Anweisungen, Try-Anweisungen und mehr.

Frage: Welche Arten von Schleifen werden in Java unterstützt?
Antwort: Java unterstützt While-Schleifen, Do-Schleifen, For-Schleifen und die erweiterte For-Schleife. Dabei wird While-Schleife verwendet, um Anweisungen solange auszuführen, wie eine Bedingung wahr ist. Do-Schleife ist ähnlich, aber die Bedingung wird erst nach der Ausführung überprüft. For-Schleifen ermöglichen die explizite Initialisierung, Bedingung und Veränderung der Schleifenvariable. Die erweiterte For-Schleife iteriert über die Elemente eines Arrays oder Objekts, das Iterable implementiert.

Frage: Was ist der Zweck der Assert-Anweisung in Java?
Antwort: Die Assert-Anweisung in Java dient dazu, bestimmte Bedingungen im Programm zu überprüfen. Wenn die Bedingung zu false ausgewertet wird, wird das Programm mit einer entsprechenden Fehlermeldung abgebrochen. Die Assert-Anweisung kann auch ein optionales Ergebnis liefern, das in der Fehlermeldung angezeigt wird. Sie eignet sich zur Überprüfung von Invarianten zur Laufzeit.

Frage: Welche Semantik haben Variablen in Java, und wie wird dies bestimmt?
Antwort: Variablen in Java haben entweder Referenzsemantik oder Wertsemantik, je nach ihrem Typ. Primitive Typen wie byte, short, int, usw., haben Wertsemantik. Andere Typen haben Referenzsemantik.

Frage: Was ist "Auto boxing" und "Auto unboxing" in Java?
Antwort: Seit Java 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man "Auto boxing" für das Verpacken in Wrapper-Typen und "Auto unboxing" für das Entpacken.

Frage: Welche Vorsichtsmaßnahmen müssen bei "Auto boxing" und "Auto unboxing" in Java getroffen werden?
Antwort: Bei "Auto boxing" und "Auto unboxing" in Java ist Vorsicht geboten, da unerwartete Ergebnisse auftreten können. Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte, um Programmierfehler zu vermeiden.

Frage: Was sind die sechs Arten von Typen, die in Java unterschieden werden?
Antwort: In Java werden die folgenden sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen.

Frage: Welche primitiven Typen sind in Java definiert?
Antwort: In Java sind die folgenden primitiven Typen definiert: byte, short, int, long, float, double, boolean und char.

Frage: Was sind Wrapper-Typen in Java und wofür werden sie verwendet?
Antwort: Wrapper-Typen in Java sind Referenztypen, die jeweils einen Wert eines entsprechenden primitiven Typs aufnehmen können. Sie werden verwendet, um primitiven Typen eine Objekthülle zu geben und sie in Situationen zu verwenden, die Referenztypen erfordern.

Frage: Welche vordefinierten Typen sind in der Java-Sprachdefinition bereits festgelegt?
Antwort: In der Java-Sprachdefinition sind folgende vordefinierte Typen festgelegt: Object, String, Throwable, Error, Exception, RuntimeException und Thread.

Frage: Was sind Literale in Java, und wie werden sie verwendet?
Antwort: Literale in Java sind Werte wie Zahlen, Zeichen und Wahrheitswerte, die direkt in den Code geschrieben werden können, ohne sie durch Instanziierung von Klassen zu erzeugen. Literale sind eine Möglichkeit, Objekte in Java zu erstellen.

Frage: Was ist beschränkter parametrischer Polymorphismus in Java?
Antwort: Beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Einschränkung der möglichen Typen, die für einen Typparameter einer generischen Klasse verwendet werden können. Dies geschieht durch das Festlegen von Beschränkungen oder Bedingungen für den Typparameter.

Frage: Welche Art von Typvariablen können in generischen Variablen verwendet werden?
Antwort: In generischen Variablen können anonyme Typvariablen, also Wildcards, verwendet werden.

Frage: Welche Einschränkungen gelten für generische Variablen mit Typ-Wildcards?
Antwort: Generische Variablen mit Typ-Wildcards unterliegen den im Abschnitt 43.2 genannten Einschränkungen, insbesondere in Bezug auf die Verwendung von Wildcards mit oberen und unteren Schranken.

Frage: Welche Methode wird in Java verwendet, um die Gleichheit von Objekten zu prüfen?
Antwort: In Java wird die Methode equals(.) verwendet, um die Gleichheit von Objekten zu prüfen.

Frage: Welche Klasse erbt die Methode equals(.) in Java?
Antwort: Die Methode equals(.) wird von der Klasse Object geerbt, die in Java die Superklasse aller Klassen ist.

Frage: Was sind Threads in Java und wie unterscheiden sie sich von Prozessen?
Antwort: Threads in Java sind parallele Ausführungsstränge, während Prozesse in der Regel eigenständige Programme mit separater Ressourcenallokation sind. Threads sind leichtgewichtiger und teilen sich Ressourcen innerhalb eines Prozesses. Bei Threads müssen die Synchronisationsmechanismen selbst implementiert werden, während Prozesse in Betriebssystemen über die Inter-Prozess-Kommunikation reguliert werden.

Frage: Was ist ein Monitor in Bezug auf Threads in Java?
Antwort: Ein Monitor in Bezug auf Threads in Java ist ein Mechanismus, der dazu dient, die Synchronisation von Threads zu ermöglichen. Jedes Objekt in Java ist mit einem Monitor verknüpft. Wenn ein Thread einen Monitor eines Objekts sperrt ("lockt"), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.

Frage: Welche Besonderheiten gibt es bei mehrdimensionalen Arrays in Java?
Antwort: In Java können mehrdimensionale Arrays geschachtelt werden, wobei die Größen der Dimensionen nicht für jedes Element der ersten Dimension gleich sein müssen.

Frage: Wie wurde der Fehler bezüglich unnötig langer Bezeichner in Iterationen mit Java 5 korrigiert?
Antwort: Der Fehler bezüglich unnötig langer Bezeichner in Iterationen wurde mit Java 5 korrigiert, indem die "for"-Schleife um eine vereinfachte Schreibweise für die externe Iteration über Collections ergänzt wurde.

Frage: Wie wird das dynamische Binden in Java durchgeführt, und warum ist es wichtig zu verstehen?
Antwort: Das dynamische Binden in Java erfolgt zur Laufzeit, wenn der tatsächliche Typ des Empfängerobjekts bestimmt wird, um die entsprechende Methode auszuwählen. Es ist wichtig zu verstehen, da es das Verhalten eines Programms beeinflusst und zur Vorhersage des Programmverhaltens beiträgt.

Frage: Wie können Interfaces in Java dazu beitragen, die Austauschbarkeit von Klassen zu verbessern?
Antwort: Interfaces ermöglichen es, verschiedene Implementierungen eines Interfaces zu verwenden, ohne den zugrunde liegenden Klassentyp zu spezifizieren. Dies verbessert die Austauschbarkeit von Klassen, da verschiedene Klassen, die dasselbe Interface implementieren, in derselben Weise verwendet werden können.

Frage: Wie erfolgt die Ausführung eines Java-Programms auf Betriebssystemebene?
Antwort: Die Ausführung eines Java-Programms auf Betriebssystemebene erfolgt, indem man der JVM den Namen der Klasse als Parameter übergibt. Zum Beispiel: "Java MeineKlasse".

Frage: Wie erfolgt in Java das Deployment von Anwendungen?
Antwort: In Java erfolgt das Deployment von Anwendungen oft durch die Verteilung von sogenannten Java Archiven (.jar-Dateien). Zur Ausführung ist jedoch eine Installation der JVM erforderlich.

Frage: Wie wurde das Problem der Erweiterung von Interfaces in Java 8 gelöst?
Antwort: In Java 8 wurde das Problem der Erweiterung von Interfaces gelöst, indem Interfaces die Implementierung von Methoden durch das Schlüsselwort "default" vorgeben konnten. Dadurch konnten zusätzliche Methoden in Interfaces hinzugefügt werden, ohne die implementierenden Klassen zu zwingen, sie zu implementieren.

Frage: Wie wird ein Typ in Java aus einer Klassendefinition abgeleitet?
Antwort: In Java spezifiziert jede Klasse ihren eigenen Typ. Der Typ trägt denselben Namen wie die Klasse und enthält Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften.

Frage: Wie wurden Module in Java bis zur Version 8 simuliert?
Antwort: In Java wurden Module bis zur Version 8 mehr oder weniger gut durch Klassen und Pakete simuliert.

Frage: Wie kann auf Klassen und Typen in unterschiedlichen Paketen in Java zugegriffen werden?
Antwort: Um auf Klassen und Typen in verschiedenen Paketen zuzugreifen, müssen in Java explizite Import-Deklarationen verwendet werden, die die jeweiligen Paketnamen nennen. Pakete ermöglichen keinen privilegierten Zugriff auf Klassen ihrer Subpakete.

Frage: Wie werden Zeichenliterale und String-Literale in Java dargestellt?
Antwort: Zeichenliterale werden in Java durch einfache Anführungsstriche eingeschlossen, während String-Literale durch doppelte Anführungsstriche eingeschlossen werden.

Frage: Wie gibt man in Java den Typ einer Klasse als Wert an?
Antwort: In Java gibt man den Typ einer Klasse als Wert mittels eines sogenannten Klassenliterals an. Dieses besteht aus dem Namen der Klasse, gefolgt von ".class", z. B. "Klasse.class".

Frage: Wie werden abstrakte Methoden in Java deklariert, und wie werden sie in Subklassen implementiert?
Antwort: Abstrakte Methoden in Java werden deklariert, indem man hinter der Methodensignatur ein abschließendes Semikolon setzt, anstatt eine Implementierung anzugeben. In Subklassen müssen abstrakte Methoden mit Implementierungen versehen werden, andernfalls gibt der Compiler eine Fehlermeldung aus.

Frage: Wie kann in Java verhindert werden, dass von einer Klasse abgeleitet wird?
Antwort: In Java kann verhindert werden, dass von einer Klasse abgeleitet wird, indem man das Schlüsselwort "final" vor der Klassendefinition verwendet.

Frage: Wie gibt eine Klasse an, dass sie ein Interface implementiert, und welche Verpflichtung ergibt sich daraus?
Antwort: Eine Klasse gibt an, dass sie ein Interface implementiert, indem sie das Schlüsselwort "implements" verwendet, gefolgt vom Namen des Interfaces. Die Klasse verpflichtet sich, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten.

Frage: Wie können Interfaces in Variablendeklarationen verwendet werden?
Antwort: Interfaces können in Variablendeklarationen als Typen verwendet werden. Der Type Checker garantiert dann, dass auf der Variable nur die Methoden aufgerufen werden können, die im Interface deklariert sind, selbst wenn das Objekt, das die Variable referenziert, mehr Methoden anbietet.

Frage: Wie werden Konstruktoren in Java aufgerufen?
Antwort: In Java werden Konstruktoren aufgerufen, indem der Klassenname gefolgt von den Konstruktorargumenten verwendet wird, z.B., "new MeineKlasse(argumente)".

Frage: Wie unterscheiden sich Streams von Collections in Java?
Antwort: Streams unterscheiden sich von Collections in Java dadurch, dass sie keine Datenspeicher sind, sondern interne Iteratoren. Jeder Stream hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen.

Frage: Wann liefert eine Stream-Pipeline in Java ein Ergebnis?
Antwort: Eine Stream-Pipeline in Java liefert ein Ergebnis immer erst durch einen sogenannten Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert, beispielsweise eine Collection im Falle von collect.

Frage: Wie werden parametrische (generische) Typen in Java definiert?
Antwort: Parametrische (generische) Typen in Java werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Die formalen Typparameter in der Klassendefinition können durch verschiedene Typen ersetzt werden.

Frage: Wie können Typ-Wildcards in Java zur Verbesserung der Typsicherheit verwendet werden?
Antwort: Typ-Wildcards können verwendet werden, um sicherzustellen, dass Zuweisungen und Zugriffe auf generische Typen zur Übersetzungszeit statisch typsicher sind, ohne dass es zu Laufzeitfehlern kommt. Dies erhöht die Typsicherheit von Java-Programmen.

Frage: Wie können Typ-Wildcards in Java dazu verwendet werden, eine Liste von Zahlen oder Untertypen von "Number" zu verarbeiten?
Antwort: Typ-Wildcards können verwendet werden, um eine Methode wie "sum(List<? extends Number> list)" zu erstellen, die eine Liste von Zahlen oder Untertypen von "Number" akzeptiert und die Summe der Zahlen berechnet, unabhängig von ihrem konkreten Typ.

Frage: Wie werden Typvariablen in Java generischen Typen dargestellt?
Antwort: In Java werden Typvariablen in generischen Typen in spitzen Klammern dargestellt.

Frage: Wie sieht eine einfache Klassendefinition in Java aus?
Antwort: Eine einfache Klassendefinition in Java besteht aus dem Klassennamen, der Angabe von Instanzvariablen (Felder) und Instanzmethoden.

Frage: Wann werden "final"-Variablen in Java verwendet?
Antwort: "final"-Variablen werden in Java verwendet, um Konstanten zu deklarieren. Sie dürfen nur einmal einen Wert zugewiesen bekommen und sind dann nicht mehr änderbar.

Frage: Wie werden Ausdrücke in Java aufgebaut, und welche rekursiven Elemente sind dabei beteiligt?
Antwort: Ausdrücke in Java können rekursiv aus anderen Ausdrücken aufgebaut werden. Zum Beispiel enthalten Methodenausdrücke Ausdrücke für den Empfänger und die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung von Indexen oder Größen.

Frage: Wann werden Type casts in Java verwendet?
Antwort: Type casts werden in Java verwendet, wenn man einem Programmelement, das einen bestimmten Typ hat, einen anderen Typ zuweisen möchte oder wenn man auf Methoden oder Felder zugreifen möchte, die nicht im deklarierten Typ verfügbar sind.

Frage: Wie vermeidet man Laufzeitfehler bei Typumwandlungen in Java?
Antwort: Man vermeidet Laufzeitfehler bei Typumwandlungen in Java mithilfe von Typtests, die vor der Typumwandlung durchgeführt werden.

Frage: Wie können Ausdrücke zu Anweisungen in Java gemacht werden?
Antwort: In Java können Ausdrücke zu Anweisungen gemacht werden, indem sie einfach durch ein Semikolon abgeschlossen werden. Dies gilt insbesondere für Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen.

Frage: Wie werden Werte Variablen in Java zugewiesen?
Antwort: In Java werden Werte Variablen sowohl explizit per Zuweisungsoperator "=" als auch implizit per Methodenaufruf zugewiesen.

Frage: Wie wird beschränkter parametrischer Polymorphismus in Java implementiert?
Antwort: In Java wird beschränkter parametrischer Polymorphismus durch das Hinzufügen von Beschränkungen für den Typparameter einer generischen Klasse oder Methode erreicht. Dies geschieht durch die Verwendung des "extends" oder "super" Schlüsselworts gefolgt von einem bestimmten Typ oder einer bestimmten Schnittstelle.

Frage: Wie wird in Java zwischen Gleichheit und Identität von Objekten unterschieden?
Antwort: In Java wird zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) geprüft, während die Identität mittels == (bzw. !=) überprüft wird.

Frage: Wie startet man einen neuen Thread in Java?
Antwort: Einen neuen Thread in Java startet man, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.

Frage: Wie stellt man sicher, dass ein neuer Thread in Java sinnvolle Aufgaben ausführt?
Antwort: Es gibt zwei Möglichkeiten, sicherzustellen, dass ein neuer Thread in Java sinnvolle Aufgaben ausführt. Entweder man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen, oder man lässt eine Klasse das Interface Runnable implementieren und implementiert die Methode run() in dieser Klasse. Dann erzeugt man eine Instanz dieser Klasse und startet deren Methode run().

Frage: Wie kann die Synchronisation von Threads in Java erzwungen werden?
Antwort: Die Synchronisation von Threads in Java kann auf zwei Arten erzwungen werden. Die erste Möglichkeit ist die Verwendung der synchronized-Anweisung, um einen synchronisierten Block zu erstellen. Die Anweisungen innerhalb dieses Blocks können nur von einem Thread gleichzeitig ausgeführt werden. Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren, wodurch die Sperre auf das zugehörige Objekt angewendet wird. Es ist wichtig zu beachten, dass Felder nicht als synchronized deklariert werden können.

Frage: Wie erfolgt die Deklaration von Arrays in Java?
Antwort: Die Deklaration von Arrays in Java erfolgt implizit in Variablendeklarationen, wobei die Größe des Arrays nicht in der Deklaration festgelegt wird.

Frage: Wie können Arrays in Java initialisiert werden?
Antwort: Arrays können in Java bei ihrer Deklaration initialisiert werden. Dabei wird die Größe des Arrays automatisch festgelegt.

Frage: Wie funktioniert die Zuweisung von Array-Variablen in Java?
Antwort: In Java haben Array-Variablen Referenzsemantik, und bei der Zuweisung wird lediglich ein Verweis auf das Array übergeben. Die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[] ist zulässig.

Frage: Warum ist die oben gezeigte Form der Iteration in Java nicht anwendbar, wenn Collections verwendet werden, die nicht indiziert sind?
Antwort: Die oben gezeigte Form der Iteration mittels Indizes ist nicht anwendbar, wenn Collections verwendet werden, die nicht indiziert sind, da diese Collections keine numerischen Indizes für den Zugriff auf ihre Elemente bereitstellen.

Frage: Was tut die Methode next() eines Iterator-Objekts?
Antwort: Die Methode next() eines Iterator-Objekts gibt das nächste Element der Collection zurück, über die iteriert wird.

Frage: Wofür wird die Methode hasNext() bei der Verwendung von Iteratoren in Java eingesetzt?
Antwort: Die Methode hasNext() wird bei der Verwendung von Iteratoren in Java eingesetzt, um abzufragen, ob die Collection noch weitere Elemente enthält, die iteriert werden können.

Frage: Was passiert, wenn der Bindungsalgorithmus in Java zu mehreren Methoden führt, die die Bedingungen erfüllen?
Antwort: Wenn der Bindungsalgorithmus zu mehreren Methoden führt, die die Bedingungen erfüllen, meldet der Compiler einen Methodenambiguitätsfehler, da die aufgerufene Methode nicht eindeutig bestimmt werden kann. Dieser Fehler wird durch Methodenaufrufe, nicht durch Methodendeklarationen, verursacht.

Frage: In der Java-Programmierung gibt es zwei Arten von Zwischenobjekten für die Umsetzung von Zu-n-Beziehungen. Welche sind das?
Antwort: In der Java-Programmierung gibt es zwei Arten von Zwischenobjekten für die Umsetzung von Zu-n-Beziehungen: Arrays und Collections.

Frage: Was bedeutet es, dass in Java jeder Typ ein Subtyp von Object ist?
Antwort: In Java ist jeder Typ, einschließlich Klassen und Interfaces, ein Subtyp von Object. Das bedeutet, dass alle Typen in Java die Methoden und Eigenschaften erben, die in der Object-Klasse definiert sind. Dies ermöglicht eine gewisse Einheitlichkeit und Polymorphie in der Java-Programmierung. Beachten Sie jedoch, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können, obwohl sie Object erweitern.

Frage: Warum werden Marker-Interfaces in Java manchmal durch Metadaten (Annotationen) ersetzt?
Antwort: Marker-Interfaces werden in Java manchmal durch Metadaten (Annotationen) ersetzt, da Metadaten eine flexiblere Möglichkeit bieten, Informationen über Klassen oder Methoden zu kennzeichnen, ohne zusätzliche Schnittstellen zu definieren. Annotations können zur Laufzeit oder zur Übersetzungszeit gelesen und interpretiert werden, während Marker-Interfaces nur zur Übersetzungszeit überprüft werden können. Dies bietet mehr Flexibilität und ermöglicht es, zusätzliche Informationen zu annotieren, ohne die Klassenhierarchie zu ändern.

Frage: Warum sind Java-Programme weitgehend plattformunabhängig?
Antwort: Java-Programme sind weitgehend plattformunabhängig, da sie in Form von Bytecode vorliegen und von der JVM interpretiert werden. Solange eine JVM für ein bestimmtes Betriebssystem verfügbar ist, können Java-Programme auf jedem Rechner und Betriebssystem ausgeführt werden, für das es eine JVM gibt.

Frage: Warum wird darauf hingewiesen, dass Java-Programmierung oft in integrierten Entwicklungsumgebungen (IDEs) stattfindet?
Antwort: Es wird darauf hingewiesen, dass Java-Programmierung oft in integrierten Entwicklungsumgebungen (IDEs) stattfindet, da diese Werkzeuge die Entwicklung erleichtern. Allerdings können IDEs aufgrund ihrer Komplexität Anfänger überwältigen.

Frage: Warum haben Interfaces in Java seit Version 8 einen Bedeutungswandel erfahren?
Antwort: Interfaces in Java haben einen Bedeutungswandel erfahren, weil sie im Laufe der Zeit um zusätzliche Methoden erweitert wurden, was dazu führte, dass Klassen, die diese Interfaces implementieren, aktualisiert werden mussten. Insbesondere bei Black-Box-Frameworks, bei denen die Entwicklung von Anwendungsklassen in den Händen Dritter liegt, führte dies zu erheblichen Problemen.

Frage: Was erlaubte Java 9 in Bezug auf Interfaces?
Antwort: In Java 9 wurde es erlaubt, in Interfaces auch private Methoden zu definieren. Diese privaten Methoden sind nur innerhalb des Interfaces selbst zugreifbar und dienen dazu, die Lesbarkeit von Default-Methoden zu verbessern, indem gemeinsame Teile in private Methoden ausgelagert werden können.

Frage: Was bedeutet es, dass Java eine klassenbasierte Programmiersprache ist, und wie unterscheidet sich dies von prototypenbasierten Sprachen?
Antwort: Java ist klassenbasiert, was bedeutet, dass Programmierung durch die Definition von Klassen erfolgt. Im Gegensatz dazu sind prototypenbasierte Sprachen wie SMALLTALK auf Prototypenobjekten aufgebaut, und es gibt keine strikten Klassendefinitionen.

Frage: Warum ist es wichtig, zwischen öffentlichen und nicht öffentlichen (privaten) Teilen eines Moduls zu unterscheiden?
Antwort: Es ist wichtig, zwischen öffentlichen und privaten Teilen eines Moduls zu unterscheiden, damit die Programmierer die Kontrolle über die Implementierung des Moduls behalten können. Indem sie sich auf eine Schnittstelle festlegen und private Teile hinter der Schnittstelle verbergen, können sie Änderungen an den verborgenen Teilen vornehmen, ohne andere Benutzer des Moduls zu beeinträchtigen.

Frage: Ab welcher Version von Java wurde ein Modulbegriff eingeführt, der diesen Namen verdient?
Antwort: Ein Modulbegriff, der den Namen verdient, wurde mit Java 9 eingeführt, nach langer Vorbereitungszeit.

Frage: Warum gibt es für mathematische Funktionen in Java die spezielle Klasse Math?
Antwort: Die primitiven Typen in Java sind keine Klassen, daher werden mathematische Funktionen wie sin(.) in der speziellen Klasse Math als Klassenmethoden definiert.

Frage: Können Klassendefinitionen in Java Operatoren definieren?
Antwort: Nein, in Java ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren wie es bei den binären Methoden in SMALLTALK der Fall ist.

Frage: Was unterscheidet Prozeduren und Funktionen in Java?
Antwort: In Java können Methoden in Prozeduren und Funktionen unterteilt werden. Der einzige Unterschied besteht darin, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp "void" deklarieren.

Frage: Wozu dienen Pakete in Java?
Antwort: Pakete in Java dienen der Sammlung von Klassen und dienen gleichzeitig als Namensräume für diese. Sie ermöglichen die Organisation von Klassen und bieten zugleich laxere Zugriffsbeschränkungen für Klassen innerhalb desselben Pakets.

Frage: Warum sind Klassenliterale in Java eher selten anzutreffen?
Antwort: Klassenliterale sind in Java eher selten anzutreffen, da Klassennamen auch direkt in Java-Programmen verwendet werden können, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie "instanceof".

Frage: Warum können nicht alle Typprüfungen in Java zur Übersetzungszeit durchgeführt werden?
Antwort: Nicht alle Typprüfungen können in Java zur Übersetzungszeit durchgeführt werden, da einige Typprüfungen erst zur Laufzeit notwendig sind und nicht im Voraus bekannt sind.

Frage: Was bedeutet es, wenn eine Klasse in Java als abstrakt deklariert wird?
Antwort: Wenn eine Klasse in Java als abstrakt deklariert wird, bedeutet dies, dass sie nicht instanziierbar ist. Es können keine Objekte dieser Klasse erstellt werden.

Frage: Warum ist es eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren?
Antwort: Es ist eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren, um das Prinzip der abstrakten Generalisierung zu fördern und Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien zu vermeiden.

Frage: Warum wird das Schlüsselwort "abstract" in Interfaces automatisch angenommen?
Antwort: Das Schlüsselwort "abstract" wird in Interfaces automatisch angenommen, da Interfaces zunächst weder Implementierungen noch Objekte liefern. Sie dienen der Definition von Schnittstellen und Typen.

Frage: Kann eine Klasse mehrere Interfaces gleichzeitig implementieren?
Antwort: Ja, eine Klasse kann mehrere Interfaces gleichzeitig implementieren, indem die entsprechenden Interface-Namen durch Kommata getrennt angegeben werden. In diesem Fall müssen die Methoden in der Klasse zumindest als abstrakt deklariert werden.

Frage: An welches Konzept in Java ist die Typkonformität und die Zuweisungskompatibilität unter Referenztypen gebunden?
Antwort: Die Typkonformität und die Zuweisungskompatibilität unter Referenztypen in Java sind an das Konzept des Subtypings gebunden.

Frage: Ist Java eine Sprache mit einem strengen Typsystem, und was bedeutet das?
Antwort: Ja, Java ist eine Sprache mit einem strengen Typsystem, was bedeutet, dass alle Typfehler entweder während der Übersetzung durch den Compiler oder während der Laufzeit erkannt werden, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung, bei der eine Typinvariante verletzt wird.

Frage: Was passiert, wenn kein Konstruktor in Java definiert wird?
Antwort: Wenn kein Konstruktor in Java definiert wird, verwendet Java standardmäßig den impliziten Standardkonstruktor, der parameterlos ist und eine neue Instanz der Klasse erzeugt.

Frage: Werden Konstruktoren in Java vererbt?
Antwort: Nein, Konstruktoren werden in Java nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse automatisch aufgerufen, wenn eine Instanz einer ihrer Subklassen erzeugt wird.

Frage: Was passiert, wenn der Typ der geworfenen Exception nicht in einer Catch-Klausel aufgeführt ist?
Antwort: Wenn der Typ der geworfenen Exception nicht in einer Catch-Klausel aufgeführt ist, wird die Exception als unbehandelt betrachtet. Die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung ("Exception in thread ...").

Frage: Was unterscheidet Checked Exceptions und Unchecked Exceptions in Java?
Antwort: Der Hauptunterschied besteht darin, dass Checked Exceptions eine explizite Deklaration im Methodenkopf oder eine Behandlung innerhalb der Methode erfordern, während Unchecked Exceptions dies nicht tun. Checked Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind, während Unchecked Exceptions von Exception-Klassen abgeleitet werden, die von RuntimeException abgeleitet sind. Checked Exceptions sollen den Programmierer auf mögliche Ausnahmesituationen hinweisen, während Unchecked Exceptions oft schwer vorhersehbar sind und überall auftreten können.

Frage: Warum funktioniert der ursprüngliche Ansatz von Java, bei dem alle Klassen eines Programms zu einem Paket zusammengefasst werden können, nicht mehr, wenn Programme in mehrere Pakete aufgeteilt werden?
Antwort: Der ursprüngliche Ansatz von Java, bei dem alle Klassen eines Programms zu einem Paket zusammengefasst werden können, funktioniert nicht mehr, wenn Programme in mehrere Pakete aufgeteilt werden, weil Abhängigkeiten zwischen den Paketen öffentliche Deklarationen erfordern, die dann jedoch alle Programmelemente für jeden sichtbar machen, was die Modularität einschränkt.

Frage: Was wurde mit Java 9 eingeführt, um das Problem der Modularität in Java zu lösen?
Antwort: Mit Java 9 wurde ein eigenes Modulkonzept eingeführt, das über Klassen und Paketen steht. Ein Modul in Java 9 ist eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Die Moduldeklaration umfasst den Namen des Moduls, die angebotene Schnittstelle und die benötigte Schnittstelle.

Frage: Warum führt die Zuweisung von List<Integer> zu List<Object> zu einem statischen Typfehler in Java?
Antwort: Die Zuweisung von List<Integer> zu List<Object> führt zu einem statischen Typfehler in Java, weil bei generischen Typen nicht automatisch eine Zuweisungskompatibilität zwischen unterschiedlichen generischen Typen besteht, selbst wenn die Typen, die sie parametrisieren, zueinander in Beziehung stehen. Dies erhöht die Typsicherheit zur Übersetzungszeit.

Frage: Warum könnte eine Parametrisierung von "Comparable" vorteilhaft sein?
Antwort: Eine Parametrisierung von "Comparable" könnte vorteilhaft sein, um die Flexibilität bei der Verwendung von Vergleichen zu erhöhen. Es ermöglicht, dass Objekte mit verschiedenen, aber kompatiblen Typen miteinander verglichen werden können.

Frage: Was würde die Deklaration "interface Comparable<T extends T>" bedeuten?
Antwort: Die Deklaration "interface Comparable<T extends T>" würde bedeuten, dass der Typparameter "T" vom gleichen Typ sein muss wie der Typparameter "T" selbst, was in der Praxis keine sinnvolle Einschränkung ist.

Frage: Warum ist die Bedingung, dass zu vergleichende Elemente vom gleichen Typ sein müssen, zu restriktiv?
Antwort: Die Bedingung, dass zu vergleichende Elemente vom gleichen Typ sein müssen, ist zu restriktiv, weil es Fälle gibt, in denen Objekte unterschiedlicher, aber verwandter Typen miteinander verglichen werden sollen. Eine flexiblere Einschränkung ist erforderlich.

Frage: Was bedeutet "Comparable<? super E>"?
Antwort: "Comparable<? super E>" bedeutet, dass der Parametertyp von "Comparable" mindestens "E" umfassen muss, kann jedoch auch allgemeiner sein, z. B. "Object". Das "?" in der Typ-Wildcard steht für einen beliebigen Typen, der die Bedingung erfüllt, in diesem Fall ein Supertyp von "E".

Frage: Warum ist "Comparable<? super E>" flexibler als "Comparable<T extends T>"?
Antwort: "Comparable<? super E>" ist flexibler, weil es eine größere Bandbreite von Typen zulässt, die miteinander verglichen werden können. Es erlaubt, dass Objekte vom Typ "E" mit Objekten anderer, aber verwandter Typen verglichen werden, was die Verwendung von "Comparable" vielseitiger macht.

Frage: Warum wurden Typ-Wildcards (Wildcard-Typen) in Java eingeführt?
Antwort: Typ-Wildcards wurden eingeführt, um eine flexiblere Form der Zuweisungskompatibilität für generische Typen zu ermöglichen, insbesondere bei der Verwendung von Collections mit unterschiedlichen Typparametern.

Frage: Was bedeutet es, wenn ein Typ mit einer Typ-Wildcard (z. B. List<?>) deklariert wird?
Antwort: Wenn ein Typ mit einer Typ-Wildcard deklariert wird, bedeutet dies, dass die Variable dieses Typs Objekte beliebigen, aber unbekannten Typparameters akzeptieren kann. Es ist eine abstrakte Deklaration.

Frage: Warum sind "ArrayList<Integer>" und "ArrayList<String>" trotz "Integer" und "String" als Subtypen von "Comparable" nicht zuweisungskompatibel mit "ArrayList<Comparable>"?
Antwort: "ArrayList<Integer>" und "ArrayList<String>" sind nicht zuweisungskompatibel mit "ArrayList<Comparable>", weil generische Typen in Java keine kovariante Zuweisung von Subtypen erlauben. Dies wurde durch die Einführung von Typ-Wildcards gelöst.

Frage: Warum sollten Klassenbibliotheken unabhängig von der Sprachdefinition sein und austauschbar sein?
Antwort: Klassenbibliotheken sollten unabhängig von der Sprachdefinition sein und austauschbar sein, um die Flexibilität und Portabilität von Software zu gewährleisten. Wenn Klassenbibliotheken eng an die Sprachdefinition gebunden sind, könnte dies dazu führen, dass eine Software nur auf einer bestimmten Plattform oder mit einer bestimmten Sprachversion funktioniert. Durch die Unabhängigkeit von der Sprachdefinition können Klassenbibliotheken in verschiedenen Umgebungen verwendet werden und die Softwareentwicklung erleichtern.

Frage: Warum sind einige Klassen in Java von der Sprache fest vorgegeben und können nicht beliebig ersetzt werden?
Antwort: In Java sind einige Klassen von der Sprache fest vorgegeben, um die grundlegende Funktionalität der Sprache sicherzustellen und um sicherzustellen, dass bestimmte wichtige Aufgaben immer erfüllt werden können. Zum Beispiel sind Klassen wie Object und String integraler Bestandteil der Java-Sprache und können nicht ersetzt werden, da sie grundlegende Funktionen wie die Objekterstellung und Zeichenkettenmanipulation ermöglichen. Diese Klassen stellen die Grundlage für die Entwicklung von Java-Programmen dar und sind daher unverzichtbar.

Frage: Was bedeutet es, wenn ein Member in Java als "static" deklariert wird?
Antwort: Wenn ein Member als "static" deklariert wird, bedeutet dies, dass er sich nicht auf Instanzen der Klasse bezieht, sondern auf die Klasse selbst. Es handelt sich um Klassenvariablen und -methoden.

Frage: Warum sind "static"-Felder in Java keine Konstanten?
Antwort: "static"-Felder in Java sind nicht automatisch Konstanten, da sie mehrfach geändert werden können. Konstanten werden in Java stattdessen durch das Schlüsselwort "final" gekennzeichnet.

Frage: Was unterscheidet Call by Value und Call by Reference, und wie wird dies in Java gehandhabt?
Antwort: In Java wird Call by Value verwendet, was bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Dies ist eine Einschränkung im Vergleich zu Call by Reference, bei dem eine Methode auf den ursprünglichen Wert einer Variablen zugreifen und ihn ändern kann.

Frage: Was versteht man unter einem Type cast (Typumwandlung)?
Antwort: Ein Type cast ist der Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde.

Frage: Warum werden Interfaces in Java als einer der wichtigsten Beiträge zur objektorientierten Programmierung angesehen?
Antwort: Interfaces in Java sind einer der wichtigsten Beiträge zur objektorientierten Programmierung, da sie die Möglichkeit bieten, Schnittstellen und Polymorphismus zu implementieren, was die Flexibilität und Erweiterbarkeit von Programmen erheblich verbessert.

Frage: Warum ist die Aufteilung eines Programms in Module wichtig?
Antwort: Die Aufteilung eines Programms in Module ist wichtig, um die unabhängige Entwicklung von Programmteilen zu ermöglichen. Dadurch sollen Abhängigkeiten zwischen den Modulen minimiert werden, insbesondere in Bezug auf Änderungen.

Frage: Was bedeutet Abhängigkeit zwischen Modulen in der Programmierung?
Antwort: In der Programmierung bedeutet Abhängigkeit zwischen Modulen in der Regel Änderungsabhängigkeit. Wenn sich in einem Modul etwas ändert, kann dies Auswirkungen auf andere davon abhängige Module haben. Abhängigkeiten ergeben sich oft aus Benutzungsbeziehungen und können in der objektorientierten Programmierung auch Vererbungsabhängigkeiten einschließen.

Frage: Sind zirkuläre Abhängigkeiten zwischen Klassen in Java erlaubt?
Antwort: Ja, zirkuläre Abhängigkeiten zwischen Klassen sind in Java zunächst erlaubt. Dies bedeutet, dass sich zwei Klassen wechselseitig importieren können. Jedoch wird dies in der Softwareentwicklung vermieden, da wechselseitige Abhängigkeiten eine enge Kopplung zwischen Modulen anzeigen, die vermieden werden sollte. Für Java-Module sind zirkuläre Abhängigkeiten jedoch verboten.

Frage: Warum sind zirkuläre Abhängigkeiten in Java-Modulen verpönt?
Antwort: Zirkuläre Abhängigkeiten in Java-Modulen sind verpönt, da sie eine enge Kopplung zwischen Modulen dokumentieren und dies vermieden werden sollte. Das Verbot zirkulärer Abhängigkeiten erfordert eine sorgfältige Planung der Modularisierung, was generell von großem Wert ist.

Frage: Wem obliegt es, zu definieren, was passieren soll, wenn der Typtest fehlschlägt?
Antwort: Es obliegt der Programmiererin, zu definieren, was passieren soll, wenn der Typtest fehlschlägt, d.h., wenn das Objekt nicht den geforderten Typ hat.

Frage: Wo können Typvariablen (formale Typparameter) in Java verwendet werden?
Antwort: Typvariablen können sowohl in Typdefinitionen als auch in Methodendefinitionen in Java verwendet werden.

Frage: Warum könnte es sinnvoll sein, den Typparameter einer generischen Methode mit "extends" zu beschränken?
Antwort: Das Beschränken des Typparameters einer generischen Methode mit "extends" kann sinnvoll sein, um die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte zu erhöhen, da deren Typ innerhalb der Methode bekannter ist.

Frage: Warum könnte es in einigen Fällen sinnvoll sein, ein Typ-Wildcard anstelle eines Typparameters in einer generischen Methode zu verwenden?
Antwort: In einigen Fällen, in denen der Typparameter innerhalb der Methode nicht verwendet wird, kann es sinnvoll sein, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard in der generischen Methode zu verwenden, um den Code einfacher und lesbarer zu gestalten.

Frage: Was bewirkt die Break-Anweisung in Java?
Antwort: Die Break-Anweisung in Java bewirkt, dass eine Schleife oder ein Switch-Statement sofort verlassen wird. Sie kann optional mit einem Label versehen werden, um eine äußere Schleife oder ein äußeres Switch-Statement zu verlassen.

Frage: Was bedeutet es, dass Java eine stark typisierte Sprache ist?
Antwort: Java ist eine stark typisierte Sprache, was bedeutet, dass alle Ausdrücke einen Typ haben und Variablen bei ihrer Deklaration einen Typ angeben müssen.

Frage: Was unterscheidet eine Wertzuweisung und eine Zuweisung von Referenzen in Java?
Antwort: Bei der Wertzuweisung wird der tatsächliche Wert einer Variable kopiert, während bei der Zuweisung von Referenzen nur die Referenz auf das Objekt kopiert wird.

Frage: Gibt es in Java "Call by reference"?
Antwort: Nein, in Java gibt es kein "Call by reference", sondern nur "Call by value". Auch wenn Variablen Referenztypen haben, wird bei Methodenaufrufen immer eine Kopie des Zeigers an die formalen Parameter übergeben.

Frage: Warum ist beschränkter parametrischer Polymorphismus wichtig?
Antwort: Beschränkter parametrischer Polymorphismus ist wichtig, um sicherzustellen, dass die Objekte, die von einem generischen Typ erzeugt werden, bestimmte Eigenschaften oder Methoden haben. Dadurch wird die Typsicherheit erhöht und es können bestimmte Annahmen über die Objekte gemacht werden.

Frage: Was bedeutet die Einschränkung "<E extends Comparable<E>>" in der Klasse "SortedList"?
Antwort: Die Einschränkung "<E extends Comparable<E>>" bedeutet, dass der Typparameter "E" auf Typen beschränkt ist, die das Interface "Comparable" implementieren oder davon erben. Dies stellt sicher, dass Objekte vom Typ "E" die Methode "compareTo(.)" implementieren können, die vom Interface "Comparable" vorgeschrieben wird.

Frage: Warum wird "SortedList<String>" als gültige Deklaration betrachtet, aber "SortedList<Integer>" nicht?
Antwort: "SortedList<String>" wird als gültige Deklaration betrachtet, weil "String" ein Subtyp von "Comparable" ist und daher die Bedingung "<E extends Comparable<E>>" erfüllt. "SortedList<Integer>" wird hingegen nicht als gültige Deklaration betrachtet, da "Integer" nicht "Comparable<Integer>" implementiert, was nicht der Einschränkung entspricht.

Frage: Ist "SortedList<String>" ein Subtyp von "SortedList<Comparable>"?
Antwort: Nein, "SortedList<String>" ist kein Subtyp von "SortedList<Comparable>". Die Einschränkung "<E extends Comparable<E>>" in "SortedList" sorgt dafür, dass der Typparameter "E" ein Subtyp von "Comparable<E>" sein muss, aber sie schafft keine Subtypenbeziehung zwischen den "SortedList"-Instanzen selbst.

Frage: Ist es in Java möglich, generische Variablen zu deklarieren?
Antwort: Ja, es ist in Java möglich, generische Variablen zu deklarieren.

Frage: Was passiert, wenn eine Variable mit einem Typ-Wildcard deklariert wird?
Antwort: Wenn eine Variable mit einem Typ-Wildcard deklariert wird, kann ihr eine Instanz eines beliebigen konkreten Typs zugewiesen werden, der den Anforderungen der Wildcard entspricht.

Frage: Führen generische Variablendeklarationen einen neuen Typ ein?
Antwort: Nein, generische Variablendeklarationen führen keinen neuen Typ ein. Der durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzte Typ ist ein konkreter Typ.

Frage: Warum ist die Verwechslung von equals(.) und == ein häufiger Programmierfehler in Java?
Antwort: Die Verwechslung von equals(.) und == ist auch in Java ein häufiger Programmierfehler, da sie unterschiedliche Bedeutungen haben. equals(.) prüft die Gleichheit von Objekten, während == die Identität überprüft.

Frage: Wofür steht das Gleichheitszeichen = in Java?
Antwort: Das Gleichheitszeichen = in Java steht für die Wertzuweisung, nicht für die Überprüfung der Gleichheit von Objekten.

Frage: Was passiert standardmäßig, wenn man einen neuen Thread in Java startet?
Antwort: Standardmäßig führt ein Thread in Java keine spezifischen Aufgaben aus und endet sofort. Dies geschieht, weil die Methode run() in der Klasse Thread standardmäßig leer ist.

Frage: Was ermöglicht Java in Bezug auf Arrays in Bezug auf Wert- und Referenztypen?
Antwort: In Java ist es möglich, sowohl Arrays von primitiven (Wert-)Typen als auch von Referenztypen zu erstellen.

Frage: Warum gestattet Java die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[]?
Antwort: Diese Zuweisungskompatibilität ermöglicht eine flexiblere Programmierung, insbesondere in Situationen, in denen der statische Typ der Array-Elemente nicht genau festgelegt ist, aber nach oben beschränkt werden soll, wie im Beispiel mit dem Interface Comparable und der Methode sort. Dieser Kompromiss zwischen statischer und dynamischer Typprüfung bietet Flexibilität beim Programmieren.
