51.5 Das Typsystem von C++

Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.
Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.
Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C-Sharp) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.
Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie JAVA oder C-Sharp; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.
Obwohl die Zuweisungskompatibilität in C++ wie in JAVA über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C-Sharp) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.
Bei virtuellen Methoden wird hingegen wie in JAVA zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und JAVA-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In JAVA hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C-Sharp hat man diese Entscheidung nicht nachvollzogen.
In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu JAVA (und genau wie z. B. in ADA) werden aus Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expandiert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer Template) ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.
Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts; s. Kapitel 27). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in JAVA oder C-Sharp wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen:
"Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right." Margaret A. Ellis und Bjarne Stroustrup
Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften JAVAs gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.

Frage: Was ist das Ziel des Typsystems von C++?
Antwort: Das Ziel des Typsystems von C++ ist, objektorientierte Programmierung mit starker Typsicherheit zu ermöglichen, während gleichzeitig die volle Freiheit der Programmiererin erhalten bleibt und der Laufzeit-Overhead minimiert wird.

Frage: Welche primitive Datentypen gibt es in C++?
Antwort: In C++ gibt es primitive Datentypen wie int, bool, etc. Diese Datentypen sind genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik.

Frage: Was ermöglicht Mehrfachvererbung in C++?
Antwort: Mehrfachvererbung in C++ ermöglicht es, eine Klasse von mehreren anderen abzuleiten. Dadurch kann eine Klasse mehrere direkte Supertypen haben, einen pro direkte Superklasse.

Frage: Wie erfolgt die Methodenbindung in C++ standardmäßig?
Antwort: Standardmäßig erfolgt die Methodenbindung (Methodenaufruf) in C++ statisch. Das bedeutet, dass die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable hat.

Frage: Wann werden Methoden in C++ zur Laufzeit dynamisch gebunden?
Antwort: In C++ werden Methoden zur Laufzeit dynamisch gebunden, wenn sie mit dem Schlüsselwort virtual deklariert sind. Bei virtuellen Methoden wird zur Laufzeit überprüft, welchen Typs das Objekt ist, und zur entsprechenden Methodenimplementierung verzweigt.

Frage: Wie wird Generizität in C++ implementiert?
Antwort: Generizität in C++ wird mit Hilfe von Templates erreicht. Ein Template ist ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Tatsächlich werden aus Templates neue Typen erzeugt, und für jede Instanz eines generischen Typs wird ein neuer Typ erzeugt und kompiliert.

Frage: Was ist ein Typumwandlung (Type cast) in C++?
Antwort: Eine Typumwandlung (Type cast) in C++ ist ein Ausdruck der Form <Typ> <Ausdruck>, der den Compiler davon überzeugt, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Diese Umwandlung wird vom Compiler überwacht, und die Zulässigkeit wird zur Laufzeit überprüft.

Frage: Wie wird die Zulässigkeit von Typumwandlungen in C++ überprüft?
Antwort: Die Zulässigkeit von Typumwandlungen in C++ wird zur Laufzeit überprüft, und sie kann nicht zur Kompilierzeit überprüft werden. Typumwandlungen sollten vermieden werden, da sie die Typsicherheit untergraben können.