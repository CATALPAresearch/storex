51.5 Das Typsystem von C++

Das Typsystem von C++ stellt den Versuch dar, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.


Frage: Was ist das Ziel des Typsystems von C++?
Antwort: Das Typsystem von C++ versucht, objektorientierte Programmierung mit starker Typsicherheit unter Beibehaltung der vollen Freiheit der Programmiererin mit möglichst wenig Laufzeit-Overhead zu erreichen.

Frage: Was ist die Zuweisung in der objektorientierten Programmierung?
Antwort: Die Zuweisung ist ein elementares Konstrukt der objektorientierten Programmierung, das durch den Zuweisungsoperator durchgeführt wird. Es gibt jedoch auch implizite Zuweisungen, die bei Methodenaufrufen vorkommen.


Wie bereits eingangs erwähnt, wurde bei der Definition von C++ als objektorientierter Erweiterung der Sprache C auf Rückwärtskompatibilität geachtet. Und so findet sich auch das Typsystem von C in C++ wieder. Es gibt also primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct (entsprechend dem record PASCALs) und union (entsprechend dem varianten Record). Alle diese Typen sind, genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik. Es lassen sich jedoch auch, genau wie in C, Zeigertypen darauf definieren.


Frage: Was ist die Rolle des Typsystems in C++?
Antwort: Das Typsystem von C++ ist ein wichtiger Bestandteil der Sprache und umfasst primitive Datentypen wie int, bool, etc., sowie die Typkonstruktoren struct und union. Diese Typen sind alle Typen mit Wertsemantik. Es ist auch möglich, Zeigertypen auf diese Typen zu definieren.

Frage: Welche Datentypen gibt es in C++?
Antwort: In C++ gibt es primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct und union. Alle diese Typen sind Typen mit Wertsemantik. Es lassen sich jedoch auch Zeigertypen darauf definieren.

Frage: Was ist der Unterschied zwischen Typen mit Wertsemantik und Typen mit Referenzsemantik in C++?
Antwort: In C++ haben Typen mit Wertsemantik eine eigene Kopie im Speicher, während Typen mit Referenzsemantik (Zeiger) nur einen Speicherort im Speicher referenzieren. Das bedeutet, dass bei der Zuweisung von Werten mit Wertsemantik eine Kopie erstellt wird, während bei der Zuweisung von Werten mit Referenzsemantik nur der Speicherort kopiert wird.


Wie in Abschnitt 51.4 diskutiert, erlaubt C++ anders als alle zuvor diskutierten Sprachen Mehrfachvererbung. Es kann also eine Klasse von mehreren anderen abgeleitet werden. Die Syntax von C++ sieht (analog zur mehrfachen Interface-Implementierung bei C-Sharp) vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.


Frage: Was ist Mehrfachvererbung in C++?
Antwort: Mehrfachvererbung in C++ bedeutet, dass eine Klasse von mehreren anderen Klassen abgeleitet werden kann. Die Syntax von C++ sieht vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.

Frage: Was erlaubt C++ und unterscheidet sich dadurch von vielen anderen objektorientierten Programmiersprachen?
Antwort: C++ erlaubt Mehrfachvererbung, das heißt, eine Klasse kann von mehreren anderen Klassen abgeleitet werden. Diese Funktionalität unterscheidet C++ von den zuvor diskutierten Sprachen, die nur die Einfachvererbung unterstützen.


Die Mehrfachvererbung wirkt sich natürlich auch auf das Typsystem aus: Ein von einer Klasse abgeleiteter Typ kann beliebig viele direkte Supertypen haben (nämlich einen pro direkte Superklasse). C++ kennt dafür keine Interfaces wie Java oder C-Sharp; sie müssen durch rein abstrakte Klassen emuliert werden. Ein Problem ergibt sich dann, wenn verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren – der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.


Frage: Was ist das Problem bei der Mehrfachvererbung in C++?
Antwort: Das Problem bei der Mehrfachvererbung in C++ ist, dass verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren können. Der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.

Frage: Wie wird Mehrfachvererbung in C++ emuliert?
Antwort: In C++ wird Mehrfachvererbung durch rein abstrakte Klassen emuliert, da C++ keine Interfaces wie Java oder C-Sharp kennt.

Frage: Was ist die Folge der Mehrfachvererbung für das Typsystem?
Antwort: Die Folge der Mehrfachvererbung für das Typsystem ist, dass ein von einer Klasse abgeleiteter Typ beliebig viele direkte Supertypen haben kann (nämlich einen pro direkte Superklasse).


Obwohl die Zuweisungskompatibilität in C++ wie in Java über die Typerweiterung gebunden ist und somit einer Variable eines Typs auch Objekte seiner Subtypen zugewiesen werden können, werden in C++ (wie auch in C-Sharp) Methoden zunächst einmal statisch gebunden. Das bedeutet im Klartext, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.


Frage: Was bedeutet statische Bindung in C++?
Antwort: In C++ werden Methoden standardmäßig statisch gebunden, das heißt, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ des Objekts wird also ignoriert.

Frage: Wie werden Methoden in C++ gebunden?
Antwort: In C++ werden Methoden standardmäßig statisch gebunden, das bedeutet, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.


Bei virtuellen Methoden wird hingegen wie in Java zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Zu diesem Zweck hält das Laufzeitsystem eine sog. Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer (sie bedeutet einen Performanzverlust, den man schon an SMALLTALK immer bemängelt hatte) und sollte daher nur verwendet werden, wenn unbedingt notwendig. Die Folge ist, dass virtual (vor allem von SMALLTALK- und Java-Programmierern) gelegentlich vergessen wird und Programme dann nicht wie erwartet funktionieren oder dass die nachträgliche Erweiterung einer Klasse, auf die ein Programmierer selbst keinen Einfluss hat, um Subklassen dazu führt, dass die Methoden der Subklasse auf Variablen der alten Klasse nicht aufgerufen werden können. In Java hat man deswegen bewusst davon Abstand genommen (und überlässt die Performanzsteigerung einem optimierenden Compiler); in C-Sharp hat man diese Entscheidung nicht nachvollzogen.


Frage: Was ist eine virtuelle Methode?
Antwort: Bei virtuellen Methoden wird zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Dies geschieht über eine Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt als teuer und sollte daher nur verwendet werden, wenn unbedingt notwendig.

Frage: Wie wird bei einer virtuellen Methode die richtige Implementierung ermittelt?
Antwort: Zur Ermittlung der richtigen Implementierung wird eine sog. Virtual function table verwendet, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer und sollte daher nur verwendet werden, wenn unbedingt notwendig.

Frage: Was ist eine Virtual function table und wozu wird sie verwendet?
Antwort: Eine Virtual function table ist eine Tabelle, die im Laufzeitsystem gehalten wird und in der die zum Objekt passende Implementierung einer virtuellen Methode nachgeschlagen werden kann. Sie wird verwendet, um zur Laufzeit zu prüfen, welchen Typs das Objekt ist und dann zur entsprechenden Methodenimplementierung zu verzweigen.


In C++ wird Generizität mit Hilfe sog. Templates erreicht. Wie der Name schon nahelegt, ist ein Template ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu Java (und genau wie z. B. in ADA) werden aus Templates tatsächlich neue Klassen erzeugt: Man sagt, dass in C++ Typparameter expandiert werden. Das bedeutet, dass für jede Instanz eines generischen Typs (einer Template) ein neuer Typ tatsächlich erzeugt und kompiliert wird. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen; ihn umzusetzen ist die Aufgabe des Präprozessors.


Frage: Wie wird Generizität in C++ erreicht?
Antwort: In C++ wird Generizität mithilfe von Templates erreicht. Templates sind Muster, anhand derer neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu Java werden aus Templates tatsächlich neue Klassen erzeugt, die kompiliert werden. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen, der vom Präprozessor umgesetzt wird.


Das Typsystem von C++ ist zwar rein statisch, aber nicht strikt: Es erlaubt nämlich Typumwandlungen (Type casts). Ausdrücke der Form (<Typ>) <Ausdruck> überzeugen den Compiler davon, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Dabei wird nur leider vollkommen ignoriert, welchen Typs das Objekt tatsächlich ist und ob dieser Typ zuweisungskompatibel mit <Typ> ist. Anders als in Java oder C-Sharp wird die Zulässigkeit dieser Typumwandlung auch nicht zur Laufzeit überprüft, ja sie kann zum Teil nicht einmal überprüft werden – wenn sie falsch war, dann hat man halt nicht richtig programmiert. So steht denn auch zu lesen: "Type casts are not checked at run time; they are checked at compile time. If the type of the expression does not match the required type, the program is ill-formed and will not compile. Type casts are not checked at run-time. If they are not done correctly, the program will not work. If you are not sure whether a type cast is necessary or whether it is done correctly, do not do it. If you are sure, then do it, but be prepared to debug the resulting problems. Explicit type conversion is best avoided. Using a cast suppresses the type checking provided by the compiler and will therefore lead to surprises unless the programmer was right." Margaret A. Ellis und Bjarne Stroustrup. Man spürt die Distanz der Autoren zu dem, was sie da beschreiben. Und so darf es als eine der großen Errungenschaften Javas gefeiert werden, dass es Type casts wenigstens zur Laufzeit auf Zulässigkeit prüft und damit ein Loch in der Typsicherheit schließt. Das führt uns zur dynamischen Seite des Typsystems von C++.


Frage: Was ist das Typsystem von C++?
Antwort: Das Typsystem von C++ ist rein statisch, aber nicht strikt. Es erlaubt Typumwandlungen (Type casts), die nur zur Kompilierungszeit überprüft werden. Während der Laufzeit wird die Zulässigkeit der Typumwandlung nicht überprüft.

Frage: Was ist der Unterschied zwischen statischen und strikten Typsystemen?
Antwort: Ein statisches Typsystem ist ein Typsystem, in dem die Typen der Ausdrücke bereits zur Übersetzungszeit bestimmt werden. Ein striktes Typsystem ist ein Typsystem, in dem die Typen der Ausdrücke nicht nur zur Übersetzungszeit, sondern auch zur Laufzeit überprüft werden und die Zulässigkeit von Typumwandlungen sichergestellt wird.

Frage: Was wird durch explizite Typumwandlung vermieden?
Antwort: Explicit type conversion ist am besten zu vermeiden. Durch die Verwendung eines Casts wird die vom Compiler bereitgestellte Typüberprüfung unterdrückt und wird daher zu Überraschungen führen, es sei denn, die Programmiererin hat recht.

Frage: Was ist explizite Typkonvertierung und warum sollte sie vermieden werden?
Antwort: Explicit type conversion, auch bekannt als "casting", ist eine Technik, bei der der Programmierer den Typ einer Variablen manuell ändert. Diese Technik sollte vermieden werden, da sie die Typüberprüfung des Compilers unterdrückt und daher zu unerwarteten Ergebnissen führen kann, es sei denn, der Programmierer hat recht.
