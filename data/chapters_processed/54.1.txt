54.1 Der Begriff der Substituierbarkeit

Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.


Frage: Was bedeutet Zuweisungskompatibilität?
Antwort: Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.


Nun ist die Frage, ob eine Zuweisung gutgeht, eine, die man gerne automatisch, am besten durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der Programmierung zu einem eigenständigen Begriff geworden, der zunächst unabhängig von der (an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der Begriff der Substituierbarkeit soll daher zunächst genauer untersucht werden.


Frage: Was ist Substituierbarkeit in der Programmierung?
Antwort: Substituierbarkeit in der Programmierung ist ein Begriff, der unabhängig von der Typkonformität betrachtet wird. Er bezieht sich darauf, ob eine Zuweisung automatisch und ohne Probleme durch den Compiler beantwortet werden kann.


In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack gerade leer ist, ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar: Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus Wartungsgründen substituiert werden müssten), gibt es wohl kaum einen Grund für eine Substituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend eng gefassten Substituierbarkeitsbegriff.


Frage: Was ist Substituierbarkeit in der objektorientierten Programmierung?
Antwort: Substituierbarkeit in der objektorientierten Programmierung bedeutet, dass ein Objekt ein anderes Objekt ersetzen kann, ohne dass sich der Programmablauf ändert. In der strengsten Auslegung müsste das ersetzende Objekt nicht nur gleich implementiert sein wie das ersetzte, sondern sich auch noch im selben Zustand befinden.

Frage: Was ist die strengste Auslegung des Begriffs der Substituierbarkeit?
Antwort: In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden.


Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.


Frage: Was ist der Substituierbarkeitsbegriff und wie hängt er mit der Übersetzungszeit zusammen?
Antwort: Der Substituierbarkeitsbegriff ist ein Begriff, der unabhängig vom konkreten Zustand der Objekte sein muss. Wenn man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungszeit verlagert, ist das Verhalten aller Objekte einer Klasse gleich spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.

Frage: Was ist der Substituierbarkeitsbegriff und wovon sollte er unabhängig sein?
Antwort: Der Substituierbarkeitsbegriff bezieht sich darauf, ob ein Objekt eines Typs durch ein Objekt eines anderen Typs ersetzt werden kann, ohne dass sich das Verhalten des Systems ändert. Er sollte unabhängig vom konkreten Zustand der Objekte sein.

Frage: Was ist der Vorteil, wenn man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann?
Antwort: Der Vorteil ist, dass auf dieser Ebene das Verhalten aller Objekte einer Klasse gleich ist und somit eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.


Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. So könnte man sich beispielsweise vorstellen, dass ein substituierendes Objekt funktional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen. Diese sogenannten nichtfunktionalen Anforderungen, die normalerweise von den funktionalen getrennt dargestellt werden, sind jedoch in Wirklichkeit gar nicht immer hundertprozentig voneinander zu trennen. Es ist durchaus vorstellbar, dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, nicht funktioniert (beispielsweise weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu Abbrüchen durch Timeouts o. ä. führt).


Frage: Was ist die Frage der Substituierbarkeit?
Antwort: Die Frage der Substituierbarkeit bezieht sich darauf, ob ein Objekt durch ein anderes Objekt ersetzt werden kann, ohne dass sich das Verhalten des Gesamtsystems ändert. Diese Frage wird interessant, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. Diese Abweichungen können sowohl funktional als auch nichtfunktional sein.

Frage: Was ist Substituierbarkeit und wann wird sie interessant?
Antwort: Substituierbarkeit bedeutet, dass ein Objekt durch ein anderes Objekt ersetzt werden kann, ohne dass sich das Verhalten des Systems ändert. Sie wird interessant, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt, wie beispielsweise in nichtfunktionalen Eigenschaften wie Geschwindigkeit oder Speicheranforderungen. Es ist jedoch zu beachten, dass funktionale und nichtfunktionale Anforderungen nicht immer hundertprozentig voneinander zu trennen sind und dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, möglicherweise nicht funktioniert.


Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.


Frage: Was ist funktionale Äquivalenz?
Antwort: Funktionale Äquivalenz bedeutet, dass zwei Objekte, die zu verschiedenen Typen gehören, aber innerhalb derselben Gruppe sind, die gleichen Funktionen erfüllen und die gleichen Methoden aufrufen können. Sie können sich jedoch im Aussehen und Verhalten unterscheiden.

Frage: Was ist ein Beispiel für funktional äquivalente, aber verschiedene Typen?
Antwort: Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So können beispielsweise die Objekte für die Elemente eines GUI, wie Fenster, Buttons etc. für jedes Betriebssystem eine eigene Implementierung haben. Diese Objekte sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.

Frage: Was ist funktionale Äquivalenz?
Antwort: Funktionale Äquivalenz bedeutet, dass Objekte verschiedener Typen, aber innerhalb derselben Gruppe, die gleichen Funktionen erfüllen und die gleichen Ergebnisse liefern, auch wenn sie sich im Aussehen und ggf. im Detailverhalten unterscheiden. Diese Unterschiede sind jedoch gewollt und die Substituierbarkeit bleibt davon unberührt.


Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion "rückgängig machen" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion "ausführen" auch noch eine "Rückgängigmachen"-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit "ausführen" und "rückgängig machen" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.


Frage: Was ist der Zweck von Objekten, die eine "Rückgängigmachen"-Funktion haben?
Antwort: Der Zweck von Objekten, die eine "Rückgängigmachen"-Funktion haben, ist es, Aktionen als Objekte zu repräsentieren, die neben einer Funktion "ausführen" auch noch eine "Rückgängigmachen"-Funktion haben, die für jeden Typ von Aktion unterschiedlich ist. Diese Objekte sind dann gegeneinander austauschbar, und die Aktionstypen sind alle Subtypen eines allgemeinen (abstrakten) Typs Aktion. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.

Frage: Was ist der Zweck von abstrakten Typen?
Antwort: Abstrakte Typen werden verwendet, um Objekte verschiedener konkreter Typen zu repräsentieren, die eine gemeinsame Schnittstelle haben, aber ein unterschiedliches Verhalten aufweisen. Die Objekte sind austauschbar, da sie die gleichen Methoden besitzen, aber das konkrete Verhalten dieser Methoden kann unterschiedlich sein. Abstrakte Typen werden verwendet, um eine allgemeine Klasse von Objekten zu definieren, ohne sich auf eine bestimmte Implementierung festzulegen.

Frage: Was ist die Idee hinter dem Begriff der Substituierbarkeit?
Antwort: Die Idee hinter dem Begriff der Substituierbarkeit ist, dass Objekte unterschiedlicher Typen austauschbar sind, wenn sie die gleichen Methoden besitzen und diese auf die gleiche Weise implementieren. Dies ermöglicht es, Objekte verschiedener Typen in einem Programm zu verwenden, ohne dass das Programmverhalten davon beeinflusst wird. Die Substituierbarkeit ist ein wichtiges Prinzip in der objektorientierten Programmierung, da es die Wiederverwendung von Code und die Entwicklung von abstrakten Klassen und Schnittstellen ermöglicht.


Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die "rückgängig machen" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion "rückgängig machen" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung "rückgängig Machen leider nicht möglich" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.


Frage: Was ist der Unterschied zwischen einer Aktion, die in dem auszutauschenden Typen definiert ist, und einer Aktion, die in dem austauschenden Typ schlicht fehlt?
Antwort: Wenn eine Aktion in dem auszutauschenden Typen definiert ist, aber in dem austauschenden Typ fehlt, dann ist diese Aktion nicht austauschbar. Ein Beispiel wäre eine Aktion, für die "rückgängig machen" nicht definiert ist, wie zum Beispiel das Speichern. Ob es ausreicht, die Funktion "rückgängig machen" in Speichern leer zu implementieren, ist diskutierbar. Die formale Spezifikation, nämlich die Aktion rückgängig zu machen, würde nicht erfüllt, und Objekte vom Typ Speichern sind damit nicht gegen andere Objekte vom Typ Aktion austauschbar.

Frage: Was ist der Unterschied zwischen Subtypen und austauschbaren Typen?
Antwort: Subtypen sind im Allgemeinen nicht gegeneinander austauschbar, während austauschbare Typen es sind. Ein Beispiel für einen Subtyp, der nicht gegen einen anderen Subtyp austauschbar ist, ist eine Aktion, für die "rückgängig machen" nicht definiert ist, während eine Aktion, für die "rückgängig machen" definiert ist, gegen eine Aktion austauschbar ist, für die "rückgängig machen" leer implementiert ist.

Frage: Was ist der Unterschied zwischen austauschbaren und nicht austauschbaren Typen?
Antwort: Austauschbare Typen sind solche, bei denen eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ vorhanden ist und die gleiche Funktionalität aufweist. Nicht austauschbare Typen hingegen sind solche, bei denen eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ fehlt oder eine andere Funktionalität aufweist. Ein Beispiel für nicht austauschbare Typen ist eine Aktion, für die "rückgängig machen" nicht definiert ist, wie beispielsweise Speichern. Es ist diskutierbar, ob es ausreicht, die Funktion "rückgängig machen" in Speichern leer zu implementieren, die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.
