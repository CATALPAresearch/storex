54.1 Der Begriff der Substituierbarkeit

Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.
Nun ist die Frage, ob eine Zuweisung gutgeht, eine, die man gerne automatisch, am besten durch den Compiler, beantwortet hätte. Der Begriff der Substituierbarkeit ist daher in der Programmierung zu einem eigenständigen Begriff geworden, der zunächst unabhängig von der (an Typkonformität gebundenen) Zuweisungskompatibilität betrachtet werden kann. Der Begriff der Substituierbarkeit soll daher zunächst genauer untersucht werden.
In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt aber nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden. Wenn nämlich beispielsweise eine Instanz der Klasse Stack gerade leer ist, ist sie nicht grundsätzlich gegen eine, die gerade nicht leer ist, austauschbar: Eine Operation pop, die das oberste Element des Stacks liefern soll, würde im einen Fall scheitern, im anderen Fall nicht. Da sich Objekte aber nicht abnutzen (so dass sie aus Wartungsgründen substituiert werden müssten), gibt es wohl kaum einen Grund für eine Substituierung sich identisch verhaltender Objekte und damit auch nicht für einen entsprechend eng gefassten Substituierbarkeitsbegriff.
Der Substituierbarkeitsbegriff muss also zumindest vom konkreten Zustand der Objekte unabhängig sein. Das hat den Vorteil, dass man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann. Auf dieser Ebene ist jedoch das Verhalten aller Objekte einer Klasse gleich (nämlich durch dieselbe Klassendefinition) spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.
Interessant wird die Frage der Substituierbarkeit erst, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. So könnte man sich beispielsweise vorstellen, dass ein substituierendes Objekt funktional äquivalent ist (also das Gleiche tut), aber auf eine andere Art. Es könnte z. B. seinen Dienst schneller verrichten als das substituierte oder mit weniger Speicheranforderungen. Diese sogenannten nichtfunktionalen Anforderungen, die normalerweise von den funktionalen getrennt dargestellt werden, sind jedoch in Wirklichkeit gar nicht immer hundertprozentig voneinander zu trennen. Es ist durchaus vorstellbar, dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, nicht funktioniert (beispielsweise weil bestimmte angenommene Echtzeitbedingungen nicht eingehalten werden und dies zu Abbrüchen durch Timeouts o. ä. führt).
Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So basiert beispielsweise die GUI-Programmierung von und mit ECLIPSE auf einer Reihe von Typen, deren Objekte für die Elemente eines GUI stehen, also Fenster, Buttons etc. Nun hat jedes Betriebssystem seine eigenen, den jeweiligen Eigenheiten angepassten Implementierungen dieser GUI-Elemente. Es ist also sinnvoll, für jeden Typ eine Reihe von Subtypen, einen pro Betriebssystem, anzubieten, die die Elemente auf die jeweiligen Implementierungen des Betriebssystems abbilden. Objekte dieser Typen sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.
Aber auch damit ist noch nicht Schluss mit der Auslegung des Begriffs von der Substituierbarkeit. Es ist z. B. denkbar, dass unterschiedliches Verhalten nicht nur toleriert, sondern sogar gewünscht wird. Denken Sie beispielsweise an einen Editor, der eine Funktion "rückgängig machen" hat, die es erlaubt, den Effekt der letzten Aktion, die Sie ausgeführt haben, zurückzunehmen, und zwar unabhängig davon, welche Aktion dies war. Die Aktionen, die möglich sind, sind in der Regel höchst unterschiedlich, so dass es keinen einheitlichen Mechanismus gibt, der erlauben würde, jeden Effekt auf die gleiche Weise rückgängig zu machen. Es ist also sinnvoll, Aktionen als Objekte zu repräsentieren, die neben einer Funktion "ausführen" auch noch eine "Rückgängigmachen"-Funktion haben, die, für jeden Typ von Aktion unterschiedlich, das jeweils Notwendige verrichtet. Objekte all dieser Aktionstypen wären dann, was den Tatbestand der Ausführ- und Rückgängigmachbarkeit angeht, gegeneinander austauschbar, und die Aktionstypen wären alle Subtypen eines allgemeinen (abstrakten) Typs Aktion, obwohl ihr konkretes Verhalten, also das, was jeweils mit "ausführen" und "rückgängig machen" verbunden ist, jeweils höchst unterschiedlich ausfällt. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.
Im Allgemeinen als nicht gegeneinander austauschbar angesehen wird jedoch Verhalten, bei dem eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ schlicht fehlt. So wäre beispielsweise eine Aktion, für die "rückgängig machen" nicht definiert ist (z. B. Speichern), kein Subtyp von Aktion, da Objekte dieses Typs nicht überall da auftauchen können, wo allgemein Aktionen erwartet werden. Es ist diskutierbar, ob es ausreicht, die Funktion "rückgängig machen" in Speichern leer zu implementieren, also beispielsweise nichts passieren zu lassen oder eine Meldung "rückgängig Machen leider nicht möglich" auszugeben; die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.

Frage: Was bedeutet Zuweisungskompatibilität zwischen verschiedenen Typen?
Antwort: Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs an Stellen verwendet werden können, an denen Objekte eines anderen Typs erwartet werden. Es bedeutet, dass die Objekte auf der linken Seite der Zuweisung durch die Objekte auf der rechten Seite substituiert werden können.

Frage: Wie wird der Begriff der Substituierbarkeit in der Programmierung betrachtet?
Antwort: Der Begriff der Substituierbarkeit bezieht sich darauf, ob eine Zuweisung zwischen verschiedenen Typen gutgeht, ohne Fehler zu verursachen. Dieser Begriff wird unabhängig von der Zuweisungskompatibilität betrachtet und kann als eigenständiger Begriff betrachtet werden.

Frage: Was bedeutet die strengste Auslegung des Begriffs der Substituierbarkeit?
Antwort: In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dies bedeutet, dass die Objekte nicht nur gleich implementiert sein müssen, sondern sich auch im selben Zustand befinden müssen.

Frage: Warum ist die Unabhängigkeit vom konkreten Zustand der Objekte wichtig im Zusammenhang mit der Substituierbarkeit?
Antwort: Die Unabhängigkeit vom konkreten Zustand der Objekte ermöglicht es, die Substituierbarkeit von der Laufzeit auf die Übersetzungs- oder Entwurfszeit zu verlagern. Auf dieser Ebene ist das Verhalten aller Objekte einer Klasse gleich, da sie durch dieselbe Klassendefinition spezifiziert sind.

Frage: Wann wird die Frage der Substituierbarkeit interessant?
Antwort: Die Frage der Substituierbarkeit wird interessant, wenn Objekte nicht derselben Klasse angehören und eine gewisse Abweichung im Verhalten der zu substituierenden Objekte erlaubt ist.

Frage: Warum könnten funktional äquivalente, aber verschiedene Typen ausgetauscht werden?
Antwort: Funktional äquivalente, aber verschiedene Typen können ausgetauscht werden, wenn Unterschiede im Verhalten toleriert oder sogar gewünscht werden. Ein Beispiel dafür ist die plattformunabhängige GUI-Programmierung, bei der GUI-Elemente funktional äquivalent sein können, sich jedoch im Aussehen und Detailverhalten unterscheiden.

Frage: Wann werden Objekte als nicht gegeneinander austauschbar angesehen?
Antwort: Objekte werden als nicht gegeneinander austauschbar angesehen, wenn eine Funktion, die in einem Typ definiert ist, in einem anderen Typ schlicht fehlt. Dies ist der Fall, wenn das Verhalten eines Typs nicht das erwartete Verhalten eines anderen Typs bietet, was zu Inkompatibilitäten führt.