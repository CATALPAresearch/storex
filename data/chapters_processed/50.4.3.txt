50.4.3 Generizität in C-Sharp

Genau wie in JAVA entspricht in C-Sharp zunächst jeder Klasse und jedem Interface ein Typ. Mit der Version 2.0 ist C-Sharp jedoch ebenfalls generisch geworden. Genauer gesagt erlaubt C-Sharp sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht so aus, wobei die Syntax für unbeschränkte sich nicht von der von JAVA unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C-Sharp erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).
Auch wenn sich die Generics von C-Sharp auf den ersten Blick nicht groß von denen von JAVA zu unterscheiden scheinen, verbirgt sich hinter der Oberfläche doch ein anderer Mechanismus. Während JAVA die Typparameter grundsätzlich immer wegkompiliert (um Abwärtskompatibilität zu erreichen; die sog. Type erasure), instanziiert C-Sharp im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Dies hat den Vorteil, dass diese Implementierungen ohne Boxing/Unboxing auskommen und vom JIT-Compiler durch Berücksichtigung der Typparameter optimiert werden können. Für Referenztypen wird der Code jedoch (wie in JAVA) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.
Genau wie in JAVA gibt es in C-Sharp beim Subtyping von Containern (wie z. B. Collections) ein Varianzproblem: Collection<A> und Collection<B> sind auch dann nicht zuweisungskompatibel, wenn A ein Subtyp von B ist (vgl. Abschnitt 43.2 in Kurseinheit 4). Um dennoch Zuweisungskompatibilität herzustellen, sieht C-Sharp keine spezielle Annotation der Benutzung eines Typs wie in JAVA vor, sondern eine Annotation der Definition des Typs: Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen. Übrigens: Für Arrays in C-Sharp gilt dasselbe wie in JAVA: Sie sind kovariant, das Schreiben in ein Array kann jedoch zu einem Laufzeittypfehler führen, der in C-Sharp "Array Type-Mismatch Exception" heißt.

Frage: Was ist Generizität in C-Sharp?
Antwort: Generizität in C-Sharp ermöglicht es, parametrischen Polymorphismus sowohl für Klassen als auch für Methoden zu nutzen. Sie erlaubt die Definition von generischen Klassen und Interfaces, die eine Menge von Typen spezifizieren, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen.

Frage: Welche Arten von Generizität werden in C-Sharp unterstützt?
Antwort: C-Sharp unterstützt sowohl beschränkte als auch unbeschränkte parametrische Polymorphismus für Klassen und Methoden. Dies bedeutet, dass Typparameter sowohl eingeschränkte (mit bestimmten Anforderungen) als auch unbeschränkte (ohne Anforderungen) Typen sein können.

Frage: Was unterscheidet Generics in C-Sharp und Generics in Java?
Antwort: Obwohl die Oberfläche von C-Sharp Generics der von Java ähnelt, unterscheidet sich der Mechanismus dahinter. C-Sharp instanziiert generische Klassen für Werttypen (wie int oder selbst definierte structs) für jeden verwendeten Typ, während Java Typparameter grundsätzlich immer entfernt (Type Erasure) und nur eine Implementierung erzeugt.

Frage: Wie wird das Varianzproblem bei der Subtypisierung von Containern in C-Sharp gelöst?
Antwort: In C-Sharp wird das Varianzproblem bei der Subtypisierung von Containern durch das Hinzufügen des Schlüsselworts "out" für kovariante Typparameter und "in" für kontravariante Typparameter bei der Definition des Typs gelöst. Dies stellt sicher, dass Zuweisungskompatibilität auch dann gegeben ist, wenn die generischen Typen verschiedene Typparameter haben.

Frage: Welche Vorteile bietet die Typexpansion in C-Sharp für Werttypen?
Antwort: Die Typexpansion in C-Sharp ermöglicht es, generische Klassen für Werttypen ohne Boxing/Unboxing zu optimieren. Dies führt zu besserer Leistung und geringerem Overhead, da der JIT-Compiler den Code für verschiedene Typen optimieren kann.

Frage: Bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten?
Antwort: Ja, in C-Sharp bleibt die generische Typinformation auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.

Frage: Gibt es in C-Sharp eine Möglichkeit zur Typparameter-Inferenz bei generischen Methodenaufrufen?
Antwort: Ja, C-Sharp unterstützt Typparameter-Inferenz, was bedeutet, dass der Compiler den tatsächlichen Typparameter bei generischen Methodenaufrufen automatisch aus den Argumenten ableiten kann. Dies führt zu weniger Code und erhöht die Lesbarkeit.