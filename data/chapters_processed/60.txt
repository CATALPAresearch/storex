60 Das Problem der mangelnden Eignung

Wie alle Ingenieurinnen verfallen objektorientierte Programmiererinnen gerne dem Hammerprinzip: Wenn man einen Hammer in der Hand hat, sieht alles wie ein Nagel aus. Nicht alle Aufgaben sind jedoch gleichermaßen zur Lösung per objektorientierter Programmierung geschaffen. Für viele logische und Suchprobleme sind beispielsweise funktionale oder logische Programmiersprachen weit besser geeignet; aber auch viele Batch- und Scripting-Probleme (in denen lediglich vorhandene Programme mit den richtigen Daten versorgt und angestoßen werden müssen) haben eher einen imperativ-prozeduralen Charakter.


Frage: Was ist das Hammerprinzip in der objektorientierten Programmierung?
Antwort: Das Hammerprinzip in der objektorientierten Programmierung bedeutet, dass Programmiererinnen dazu neigen, alle Probleme mit objektorientierter Programmierung zu lösen, auch wenn andere Programmierparadigmen besser geeignet wären.


Auch wenn pauschale Aussagen riskant sind, so erscheinen doch Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, weniger geeignet für die objektorientierte Programmierung. Wie schon in Kapitel 56 erwähnt, verlangt die "gute" objektorientierte Programmierung, den Code (die Funktionalität) auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Da größere Probleme in der Regel auf durch verschiedene Klassen definierte Daten zugreifen müssen, wird der Code durch seine Datenbindung regelrecht zerfleddert.


Frage: Warum sind Probleme mit hohem algorithmischen Anteil und einfachen Datenstrukturen weniger geeignet für die objektorientierte Programmierung?
Antwort: Probleme mit hohem algorithmischen Anteil und einfachen Datenstrukturen sind weniger geeignet für die objektorientierte Programmierung, da sie eine Zerfledderung des Codes durch die Datenbindung verursachen. Die Funktionalität wird in der objektorientierten Programmierung auf die Klassen aufgeteilt, die die Daten definieren, auf denen der Code arbeitet.

Frage: Was ist weniger geeignet für die objektorientierte Programmierung?
Antwort: Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, sind weniger geeignet für die objektorientierte Programmierung.

Frage: Was ist das Ziel der Objektorientierung?
Antwort: Das Ziel der Objektorientierung ist es, die Komplexität von Software zu reduzieren, indem sie die Software in kleinere, leichter zu verstehende Einheiten aufteilt, die Objekte genannt werden und Instanzen von Klassen sind.


Ein ähnlich gelagertes Problem hat man, wenn man Programme entwickelt, in denen es vor allem um Abläufe geht. Hier möchte man, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird (Lokalitätsprinzip!) und nicht auf zig Klassen aufgeteilt ist. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten — dass hier die objektorientierte Programmierung nicht ideal ist, liegt eigentlich auf der Hand.


Frage: Warum ist die objektorientierte Programmierung nicht ideal, wenn das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten liegt?
Antwort: In der objektorientierten Programmierung liegt der Fokus auf der Struktur der Daten, indem Objekte mit ihren Daten und Methoden im Vordergrund stehen. Wenn das Interesse jedoch hauptsächlich an der Struktur der Funktionen liegt, kann die objektorientierte Programmierung ineffizient sein, da die Funktionen auf zahlreiche Klassen aufgeteilt werden müssen. In solchen Fällen ist es besser, die Abläufe in einem Stück festzuhalten, um die Lesbarkeit und Wartbarkeit des Codes zu verbessern.


So hat man es bei der Wahl einer geeigneten Programmiersprache in der Praxis fast immer mit einem Abwägungsproblem zu tun. Wenn man sich für die objektorientierte Programmierung entscheidet, bleibt die Organisation der Funktionen auf der Strecke, wenn man sich für die prozedurale Programmierung entscheidet, werden die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt oder sind global, was auch kein Idealzustand ist. Sprachen, die eine Mischung mehrerer Paradigmen erlauben, scheinen die Lösung zu sein. Für die Didaktik eignen sie sich jedoch weniger, schon weil sie Anfängerinnen mit ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann, überfordern. C++ ist ein gutes Beispiel dafür.


Frage: Warum eignen sich Sprachen, die mehrere Programmierparadigmen erlauben, weniger für die Didaktik?
Antwort: Sprachen, die mehrere Programmierparadigmen erlauben, sind für Anfängerinnen oft überfordernd, da sie eine große Auswahl an Konstrukten und eine unüberschaubare Anzahl von Alternativen bieten, um ein einzelnes Problem zu lösen.

Frage: Was sind die Nachteile der objektorientierten Programmierung?
Antwort: Die Nachteile der objektorientierten Programmierung sind, dass die Organisation der Funktionen auf der Strecke bleibt und dass die Daten hin- und hergeschickt werden müssen.

Frage: Was sind die Nachteile der prozeduralen Programmierung?
Antwort: Die Nachteile der prozeduralen Programmierung sind, dass die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt werden oder global sind.

Frage: Was sind die Vorteile von Sprachen, die eine Mischung mehrerer Programmierparadigmen erlauben?
Antwort: Die Vorteile von Sprachen, die eine Mischung mehrerer Programmierparadigmen erlauben, sind, dass sie eine größere Auswahl an Konstrukten bieten und eine unüberschaubare Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann.


Ein anderes Problem ist der Einsatz objektorientierter Programmierung in Verbindung mit relationalen Datenbanken. Zwar spiegelt ein gut entworfenes Datenbankschema, genau wie ein gut entworfenes Klassenmodell, eine Strukturierung der Anwendungsdomäne wider, doch tun es beide mit ganz unterschiedlichen Mitteln: Während relationale Datenbanken wertbasiert sind (alle Daten werden als Tupel primitiver Datentypen wie Zahlen und Zeichenketten dargestellt), sind objektorientierte Programme zeigerbasiert. Beziehungen werden in relationalen Datenbanken über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen hergestellt, in objektorientierten Programmen über Referenzen und deren Dereferenzierung (Navigation). Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Sollen also relationale Daten durch objektorientierte Programme verarbeitet werden, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben, weswegen man hier auch häufig von einem Impedanzmismatch spricht (das entsprechende deutsche Wort "Fehlanpassung" ist in diesem Zusammenhang ungebräuchlich).


Frage: Was ist ein Impedanzmismatch zwischen relationalen Datenbanken und objektorientierten Programmen?
Antwort: Ein Impedanzmismatch zwischen relationalen Datenbanken und objektorientierten Programmen ist das Problem, dass sich beide Welten in ihrer Art und Weise unterscheiden, wie sie Daten und Beziehungen darstellen. Relationale Datenbanken sind wertbasiert und stellen Beziehungen über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen her, während objektorientierte Programme zeigerbasiert sind und Beziehungen über Referenzen und deren Dereferenzierung (Navigation) herstellen. Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Daher muss man sich, wenn relationale Daten durch objektorientierte Programme verarbeitet werden sollen, an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben.

Frage: Was ist ein Impedanzmismatch?
Antwort: Ein Impedanzmismatch ist ein Problem, das auftritt, wenn relationale Daten durch objektorientierte Programme verarbeitet werden sollen. Dies liegt daran, dass relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Um dieses Problem zu lösen, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben.


Etwas anders gelagert ist der Fall, dass man eine relationale Datenbank dazu einsetzt, eine Objektorientiertierung zu simulieren. In diesem Fall werden die Daten zunächst (wie in der gewöhnlichen objektorientierten Programmierung) angelegt und nur zu Persistenz- und Synchronisationszwecken (bei Mehrbenutzersystemen) in der Datenbank abgelegt. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird dabei heute meistens durch ein sogenanntes Persistenzlayer erreicht — das Programm selbst muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern. Dennoch muss man auch hier die Frage stellen, warum man einer relationalen Datenbank den Vorzug vor einer objektorientierten gegeben hat — am Ende, weil im betrieblichen Umfeld häufig bereits relationale Datenbanken mit gutem Ergebnis verwendet werden und die Umstellung auf Objektorientierung in der Datenhaltung mit unwägbaren Risiken verbunden scheint — schließlich sind die Daten häufig der eigentliche Wert eines Softwaresystems.


Frage: Warum kann es sinnvoll sein, eine relationale Datenbank für die Simulation einer Objektorientiertierung zu verwenden?
Antwort: Es kann sinnvoll sein, eine relationale Datenbank für die Simulation einer objektorientierten zu verwenden, wenn bereits relationale Datenbanken im betrieblichen Umfeld erfolgreich eingesetzt werden und die Umstellung auf Objektorientierung in der Datenhaltung mit Risiken verbunden scheint. Die Daten sind häufig der eigentliche Wert eines Softwaresystems. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird durch ein Persistenzlayer erreicht, das Programm muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern.


Zuletzt, und beinahe paradoxerweise, ist auch die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung. Zwar kann man für die verschiedenen Arten von GUI-Elementen noch ganz gut Klassen angeben, die die Gemeinsamkeiten im Aussehen der in einem konkreten GUI verwendeten Objekte herausfaktorisieren, aber spätestens beim gemeinsamen Verhalten ist Schluss: Zwei Buttons beispielsweise unterscheiden sich nicht nur bezüglich ihrer Position und des angezeigten Texts, sondern auch darin, welche Aktion ausgeführt wird, wenn sie gedrückt werden. Da sich die Instanzen einer Klasse aber alle Methoden teilen, ist es nicht möglich, für verschiedene Buttons derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Hier kann man lediglich versuchen, eine Indirektion einzubauen, in SMALLTALK über einen Block, der die auszuführende Methode beinhaltet, in Java über anonyme innere Klassen, die für eine bestimmte Methodensignatur eine Implementierung liefern, die nur den Instanzen dieser (unbenannten) Klasse gehört, und in C++ sowie C-Sharp über Funktionszeiger (Delegates in C-Sharp). Von Haus aus besser geeignet scheint hier aber die prototypenbasierte Variante der objektorientierten Programmierung, wie in der Einleitung zu Kurseinheit 2 bemerkt (und wie sie ja auch in Form von JavaSCRIPT seit Jahren einen heimlichen Siegeszug feiert).


Frage: Warum ist die objektorientierte Programmierung nicht gut für GUI-Programmierung geeignet?
Antwort: Objektorientierte Programmierung ist nicht gut für GUI-Programmierung geeignet, weil sich die Instanzen einer Klasse alle Methoden teilen, was es nicht möglich macht, für verschiedene Objekte derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Um dies zu erreichen, muss eine Indirektion eingebaut werden, wie zum Beispiel in Smalltalk über einen Block, in Java über anonyme innere Klassen, in C++ und C-Sharp über Funktionszeiger (Delegates in C-Sharp). Die prototypenbasierte Variante der objektorientierten Programmierung, wie sie in JavaScript verwendet wird, scheint hier besser geeignet zu sein.

Frage: Warum ist es nicht möglich, für verschiedene Instanzen einer Klasse verschiedene Implementierungen einer Methode anzugeben?
Antwort: Da sich die Instanzen einer Klasse alle Methoden teilen, ist es nicht möglich, für verschiedene Instanzen derselben Klasse verschiedene Implementierungen einer Methode anzugeben.

Frage: Warum können in objektorientierter Programmierung nicht für verschiedene Instanzen einer Klasse verschiedene Implementierungen einer Methode angegeben werden?
Antwort: In objektorientierter Programmierung können für verschiedene Instanzen einer Klasse nicht verschiedene Implementierungen einer Methode angegeben werden, weil alle Instanzen einer Klasse dieselben Methoden teilen. Um dieses Problem zu lösen, können Indirektionen eingebaut werden, wie zum Beispiel in Smalltalk über einen Block, in Java über anonyme innere Klassen, in C++ und C-Sharp über Funktionszeiger (Delegates in C-Sharp). Eine bessere Eignung scheint hier die prototypenbasierte Variante der objektorientierten Programmierung zu haben, wie sie in JavaScript seit Jahren erfolgreich eingesetzt wird.
