29.3 Parametrischer Polymorphismus und Inklusionspolymorphie

Nun war die Speicherung von Personen in Collections, wie sie oben benötigt wurde, auch schon ohne den parametrischen Polymorphismus möglich, nämlich per Inklusionspolymorphie (Subtyping).


Frage: Was ist Inklusionspolymorphie?
Antwort: Inklusionspolymorphie, auch bekannt als Subtyping, ist eine Form der Polymorphie, bei der ein Objekt eines Untertyps an einer Stelle verwendet werden kann, an der ein Objekt des Supertyps erwartet wird. Das bedeutet, dass eine Collection, die Objekte eines bestimmten Typs enthält, auch Objekte eines Untertyps dieses Typs enthalten kann.

Frage: Was ist Subtyping?
Antwort: Subtyping, auch bekannt als Inklusionspolymorphie, ist eine Form der Polymorphie, bei der ein Objekt eines Untertyps an einer Stelle verwendet werden kann, an der ein Objekt des Supertyps erwartet wird. Das bedeutet, dass eine Collection, die Objekte eines bestimmten Typs enthält, auch Objekte eines Untertyps dieses Typs enthalten kann.

Frage: Was ist der Unterschied zwischen parametrischen Polymorphismus und Inklusionspolymorphie?
Antwort: Parametrischer Polymorphismus ist eine Technik, die es ermöglicht, dass eine Funktion oder Methode mit Argumenten verschiedener Typen aufgerufen werden kann, während Inklusionspolymorphie (Subtyping) eine Beziehung zwischen Typen ist, bei der ein Typ B ein Untertyp eines anderen Typs A ist, wenn ein Wert vom Typ B auch als Wert vom Typ A behandelt werden kann. Im Falle von Collections bedeutet dies, dass eine Collection, die auf Objekte eines bestimmten Typs ausgelegt ist, auch Objekte eines Untertyps dieses Typs aufnehmen kann.


An die Stelle der Typvariable E tritt also der (konkrete) Typ Object. Da in STRONGTALK alle Typen Subtypen von Object sind, kann man jedes beliebige Objekt in einer solchen Collection speichern. In der Klasse Person, die Collection verwendet, würde dann kinder schlicht als vom Typ Collection (ohne Typparameter) deklariert. Das obige Programmfragment (Zeilen 936–940) könnte dann auch beinahe so bleiben, bis auf eine kleine Ausnahme: Zeile 940 enthält jetzt einen Typfehler, da das Ergebnis von p kinder at: 1 vom Typ Object ist und das Protokoll von Object keine Methode kinder unterstützt. Es wäre also erst noch eine Typumwandlung von Object nach Person, ein Downcast, vonnöten. Deren Zulässigkeit ist aber davon abhängig, was wirklich in der Collection drinsteckt, und das kann der Compiler nicht (oder nur sehr aufwendig) feststellen. Die Lösung, die Inklusionspolymorphie bietet, beinhaltet also eine Sicherheitslücke in der statischen Typprüfung, die der parametrische Polymorphismus behebt.


Frage: Was ist eine Collection in STRONGTALK und wie wird sie verwendet?
Antwort: In STRONGTALK ist eine Collection ein Objekt, das eine Sammlung von anderen Objekten enthält. Alle Typen sind Subtypen von Object, wodurch jedes beliebige Objekt in einer Collection gespeichert werden kann. In der Klasse Person, die Collection verwendet, würde kinder als vom Typ Collection (ohne Typparameter) deklariert. Allerdings kann es bei der Verwendung von Objekten in Collections zu Typfehlern kommen, die durch Downcasting behoben werden können. Diese Lösung bietet jedoch eine Sicherheitslücke in der statischen Typprüfung, die durch parametrische Polymorphie behoben wird.

Frage: Was ist eine Collection in Strongtalk und welchen Typ hat die Variable E?
Antwort: In Strongtalk ist eine Collection ein Objekt, das eine Sammlung von Objekten speichert. Die Variable E wird durch den Typ Object ersetzt, da alle Typen in Strongtalk Subtypen von Object sind. Das bedeutet, dass man jedes beliebige Objekt in einer Collection speichern kann.

Frage: Was ist die Sicherheitslücke in der statischen Typprüfung, die durch die Inklusionspolymorphie entsteht?
Antwort: Die Sicherheitslücke in der statischen Typprüfung, die durch die Inklusionspolymorphie entsteht, ist, dass der Compiler nicht oder nur sehr aufwendig feststellen kann, ob das Ergebnis von p kinder at: 1 vom Typ Object in eine Methode kinder von Typ Person umgewandelt werden kann.


Nun ist aber auch der parametrische Polymorphismus nicht ohne Makel. Zum einen wäre es ohne Inklusionspolymorphie nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern. Solche heterogenen Collections kommen aber in der Praxis immer wieder vor, so dass man selbst bei Verwendung einer parametrischen Definition von Collections nicht auf Inklusionspolymorphie verzichten wird.


Frage: Was ist parametrischer Polymorphismus?
Antwort: Parametrischer Polymorphismus ist eine Technik in der objektorientierten Programmierung, bei der eine Funktion oder Methode mit verschiedenen Datentypen verwendet werden kann. Es ist jedoch nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern, ohne Inklusionspolymorphie zu verwenden.

Frage: Was ist der Unterschied zwischen parametrischen Polymorphismus und Inklusionspolymorphismus?
Antwort: Parametrischer Polymorphismus ermöglicht es, eine Funktion oder Methode mit verschiedenen Datentypen aufzurufen, während Inklusionspolymorphismus es ermöglicht, Objekte verschiedener Subtypen in einer Collection zu speichern. Ohne Inklusionspolymorphismus wäre es nicht möglich, in einer Collection mit Elementtyp XYZ auch Objekte eines Subtyps von XYZ zu speichern.


Zum anderen wird die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen (wo man ja zumindest bei homogener, also ohne Ausnutzung der Inklusionspolymorphie, Belegung der mit einem Typparameter typisierten Variablen ohne Typumwandlungen auskommt) mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst erkauft. Dies verlangt nach Erklärung.


Frage: Was ist der Trade-off zwischen Typsicherheit und Typsicherheit innerhalb der Typdefinition bei der Verwendung von parametrisch definierten Typen?
Antwort: Der Trade-off besteht darin, dass die erhöhte Typsicherheit bei der Verwendung von parametrisch definierten Typen mit einer geringeren Typsicherheit innerhalb der Typdefinition (bzw. Klassendefinition) selbst einhergeht. Das bedeutet, dass man bei der Verwendung von parametrisch definierten Typen zwar eine höhere Typsicherheit hat, aber gleichzeitig innerhalb der Typdefinition selbst mit einer geringeren Typsicherheit rechnen muss.


Nun kann aber die Definition eines parametrischen Typs nicht wissen, wie sie hinterher verwendet wird, und wenn eine Operation durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird. Es wird also die erhöhte Typsicherheit außerhalb der Typdefinition, nämlich bei ihrer Verwendung, durch eine verminderte Typsicherheit innerhalb erkauft.


Frage: Was ist die erhöhte Typsicherheit außerhalb der Typdefinition und die verminderte Typsicherheit innerhalb der Typdefinition?
Antwort: Die erhöhte Typsicherheit außerhalb der Typdefinition bedeutet, dass die Verwendung des parametrischen Typs sicherer ist, da er nur mit Typen von addierbaren Objekten instanziiert wird. Die verminderte Typsicherheit innerhalb der Typdefinition bedeutet, dass die Definition des parametrischen Typs nicht wissen kann, wie er hinterher verwendet wird, und daher bei der Addition auf die Verwendung von addierbaren Objekten angewiesen ist.

Frage: Was ist die erhöhte Typsicherheit außerhalb der Typdefinition und die verminderte Typsicherheit innerhalb?
Antwort: Die erhöhte Typsicherheit außerhalb der Typdefinition bedeutet, dass die Verwendung des parametrischen Typs MyCollection sichergestellt ist, dass er nur mit Typen von addierbaren Objekten instanziiert wird. Die verminderte Typsicherheit innerhalb bedeutet, dass die Definition des parametrischen Typs MyCollection nicht wissen kann, wie sie hinterher verwendet wird, und wenn eine Addition durchgeführt werden soll, ist sie darauf angewiesen, dass sie nur mit Typen von addierbaren Objekten instanziiert wird.

Frage: Was ist der Nachteil der erhöhten Typsicherheit außerhalb der Typdefinition?
Antwort: Der Nachteil der erhöhten Typsicherheit außerhalb der Typdefinition ist die verminderte Typsicherheit innerhalb der Typdefinition.


Was man gerne hätte, um diesen Mangel zu beheben, wäre die Sicherheit, dass alle Typen, die für E eingesetzt werden können, bestimmte Eigenschaften haben, im gegebenen Beispiel, dass sie sortierbar und addierbar sind. Entsprechend sollte ein Typfehler nicht erst in Zeile 950 moniert werden, sondern bereits an der Stelle, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, nämlich bei der Verwendung (der Instanziierung) der parametrischen Typdefinition in der Deklaration von Zeile 951. Genau das erlaubt der beschränkte parametrische Polymorphismus, der im nächsten Abschnitt behandelt wird. Zunächst jedoch noch zu einem anderen wichtigen Aspekt von parametrischem Polymorphismus und Subtyping.


Frage: Was ist der beschränkte parametrische Polymorphismus?
Antwort: Der beschränkte parametrische Polymorphismus ist eine Technik, die es ermöglicht, Typen zu verwenden, die bestimmte Eigenschaften haben. Dadurch kann ein Typfehler bereits an der Stelle moniert werden, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, anstatt erst später im Programm.
