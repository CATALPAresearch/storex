46.2 Interne Iteration

Von SMALLTALK kennen Sie bereits die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren (die interne Iteration). Mit Version 8 wurden nun auch in Java (anonyme) Funktionen (die sog. Lambda-Ausdrücke) eingeführt, die interne Iterationen à la SMALLTALK erlauben. Allerdings wurde für die Implementierung der Methoden forEach, filter, map und reduce (entsprechend SMALLTALKs do, select, collect und inject) ein eigenes Framework geschaffen: die sog. Streams.


Frage: Was sind Streams in Java?
Antwort: Streams in Java sind ein Framework, das interne Iterationen à la SMALLTALK erlaubt. Mit Hilfe von Streams können Methoden wie forEach, filter, map und reduce definiert werden, die auf Collection-Klassen angewendet werden können.


Streams sind ein mit Java 8 neu eingeführtes Konstrukt, das eine Datenverarbeitung in Pipelines ganz ähnlich wie die Collections in SMALLTALK ermöglicht: Das Ergebnis einer Operation wie filter oder map, auf einem Stream ausgeführt, ist wieder ein Stream, auf dem weitere Operationen dieser Art ausgeführt werden können (das Pipelining). Das Besondere an Streams ist, dass sie keine Datenspeicher wie Collections sind, sondern interne Iteratoren: Jeder Stream für sich hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen. Dabei dienen Streams entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren (wie beispielsweise ein Zufallszahlengenerator oder eine Vorschrift zur Berechnung einer Fibonacci-Folge) als Quelle. Ein Ergebnis liefert eine Stream-Pipeline (die auch aus nur einem Element bestehen kann) immer erst durch einen sog. Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert (eine Collection im Falle von collect).


Frage: Was sind Streams in Java 8?
Antwort: Streams in Java 8 sind ein neues Konstrukt, das eine Datenverarbeitung in Pipelines ermöglicht. Sie sind interne Iteratoren, die eine potenziell unendliche Folge von Elementen halten. Streams können entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren als Quelle dienen. Ein Ergebnis liefert eine Stream-Pipeline immer durch einen Abschluss, also eine Methode, die ein anderes Ergebnis als einen Stream liefert.


Das Stream-Framework von Java ermöglicht für viele Pipelines eine besonders effiziente Ausführung. So muss jedes Element einer Datenquelle in der Regel nur einmal angefragt werden, und die interne Speicherung von Zwischenergebnissen wird automatisch gering gehalten. Insbesondere wird gegenüber einer naiven Implementierung von Pipelines, die eine Iteration je Element der Pipeline benötigt, in vielen Fällen nur eine Iteration benötigt (die sog. Stream-Fusion). Zudem kann durch die Wahl des Streams (und nicht der Operationen) bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt. Gleichwohl ist die Performanz von Java-Pipelines nicht leicht vorherzusagen, und eine gewinnbringende Verwendung setzt sicherlich einiges an Erfahrung und Kenntnissen der Implementierung voraus.


Frage: Was ermöglicht das Stream-Framework von Java?
Antwort: Das Stream-Framework von Java ermöglicht eine besonders effiziente Ausführung für viele Pipelines, indem jedes Element einer Datenquelle nur einmal angefragt wird und die interne Speicherung von Zwischenergebnissen automatisch gering gehalten wird. Es kann auch bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt.
