14.1 Kopieren von Objekten

In Abschnitt 7.3 hatten wir bereits die Instanziierung als den hauptsächlichen Weg kennengelernt, wie neue Instanzen von Klassen, für deren Objekte es keine literale Repräsentation gibt, erzeugt werden. Wir hatten allerdings dort schon auf die Möglichkeit des Klonens/Kopierens hingewiesen. Darauf wollen wir nun wieder zurückkommen. Klonen/Kopieren ist eine weitere Möglichkeit, neue Instanzen zu erzeugen. Dabei wird eine bestehende Instanz kopiert, d.h. es wird eine neue Instanz erzeugt, die eine identische Kopie der alten Instanz ist. Klonen/Kopieren ist eine Alternative zur Instanziierung, wenn die Klasse eine komplexe Struktur hat, die sich nicht einfach aus Literalen zusammensetzen lässt. Klonen/Kopieren ist auch dann sinnvoll, wenn die Klasse eine komplexe Struktur hat, die sich zwar einfach aus Literalen zusammensetzen lässt, aber die Initialisierung der Literale aufwändig ist. Klonen/Kopieren ist eine weitere Möglichkeit, neue Instanzen von Klassen zu erzeugen. Dabei wird ein bestehendes Objekt kopiert, d.h. es wird eine exakte Kopie des Objekts erstellt. Die Kopie ist dabei eine eigenständige Instanz, die nicht mit dem Original verbunden ist.
Die Kopie eines Objekts kann auf zwei Arten erfolgen: 1. Shallow Copy: Hierbei wird das Objekt inklusive seiner Instanzvariablen kopiert. Wird ein Objekt auf diese Weise kopiert, so wird eine exakte Kopie des Objekts erstellt, die Instanzvariablen verweisen jedoch auf die gleichen Objekte wie im Original. 2. Deep Copy: Hierbei wird das Objekt inklusive seiner Instanzvariablen und deren Instanzvariablen kopiert. Wird ein Objekt auf diese Weise kopiert, so wird eine exakte Kopie des Objekts erstellt, die Instanzvariablen verweisen auf exakte Kopien der Objekte, auf die im Original verwiesen wird.

Frage: Was ist Klonen/Kopieren?
Antwort: Klonen/Kopieren ist eine Methode, um neue Instanzen von Klassen zu erzeugen, bei der ein bestehendes Objekt kopiert wird, um eine exakte Kopie des Objekts zu erstellen, die eigenständig und nicht mit dem Original verbunden ist. Es gibt zwei Arten von Kopien: Shallow Copy und Deep Copy.

Frage: Wozu dient das Klonen/Kopieren?
Antwort: Das Klonen/Kopieren wird verwendet, um eine unabhängige Kopie eines Objekts zu erstellen, das unabhängig von der Originalinstanz geändert werden kann, ohne die Originalinstanz zu beeinflussen. Es wird auch verwendet, um Objekte zu erstellen, die mit den gleichen Daten initialisiert werden sollen, oder um Objekte zu speichern, die später wiederhergestellt werden sollen.

Frage: Was ist der Unterschied zwischen einer Shallow Copy und einer Deep Copy?
Antwort: Bei einer Shallow Copy wird nur die oberste Ebene der Objektstruktur kopiert, während bei einer Deep Copy auch alle Unterobjekte rekursiv kopiert werden. Das heißt, beim flachen Klonen wird nur eine Referenz auf das Unterobjekt kopiert, während beim tiefen Klonen eine neue Kopie des Unterobjekts erstellt wird.


Die einfachste Form des Kopierens eines Objekts erzeugt ein Objekt gleicher Klasse mit gleichen Variablenbelegungen. Dazu gibt es in SMALLTALK die Methode shallowCopy. Diese Methode liefert eine neue Instanz der Klasse des Empfängers, die in denselben Beziehungen zu denselben anderen Objekten steht wie das Original. Insbesondere werden die Objekte, die die Instanzvariablen des Originals benennen, nicht selbst kopiert. Deswegen nennt man die Kopie flach. Sie erfolgt einfach durch Zuweisung aller Instanzvariablen des Originals an die Instanzvariablen des neuen Objekts, das damit zur Kopie wird. Die Implementierung in SMALLTALK EXPRESS ist die folgende:


Frage: Was macht die Methode "copy" in SMALLTALK?
Antwort: Die Methode "copy" in SMALLTALK erzeugt eine flache Kopie des Empfängers, indem sie eine neue Instanz der Klasse des Empfängers erstellt und die Instanzvariablen des Originals an die Instanzvariablen des neuen Objekts zuweist.

isVariable unterscheidet dabei zwischen Klassen mit indizierten Instanzvariablen und solchen ohne; isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.

Frage: Was macht die Methode isVariable?
Antwort: Die Methode isVariable unterscheidet zwischen Klassen mit indizierten Instanzvariablen und solchen ohne.

Frage: Was untersucht die Methode isPointers?
Antwort: Die Methode isPointers unterscheidet zwischen Klassen mit zusammengesetzten Objekten und atomaren.

Frage: Was ist der Unterschied zwischen isVariable und isPointers?
Antwort: isVariable ist eine Methode, die zwischen Klassen mit indizierten Instanzvariablen und solchen ohne unterscheidet, während isPointers eine Methode ist, die zwischen Klassen mit zusammengesetzten Objekten und atomaren unterscheidet.


Nun ist eine flache Kopie aber häufig nicht genug. Es gibt daher noch eine zweite Methode deepCopy, die ein Objekt und alle seine Unterobjekte tief kopiert. Wie der Name nahelegt, unterscheidet sich die Methode deepCopy von shallowCopy darin, dass auch die in Beziehung stehenden (durch die Instanzvariablen benannten) Objekte kopiert werden. Statt einzelner Objekte wird also ein Objektgeflecht kopiert — die Kopie ist tief. Es muss dazu an die beiden tatsächlichen Parameter von put: (Zeilen 566 und 570) lediglich eine Nachricht zum Kopieren der Parameter angehängt werden. Dabei ist jedoch flaches Kopieren Vorsicht geboten: Wenn es sich dabei ebenfalls um ein tiefes Kopieren handelt, dann kann der Kopiervorgang leicht in eine Endlosrekursion geraten.

Frage: Was ist der Unterschied zwischen deepCopy und shallowCopy?
Antwort: deepCopy kopiert auch die in Beziehung stehenden Objekte, während shallowCopy nur einzelne Objekte kopiert. deepCopy erstellt also eine Kopie des Objektgeflechts, während shallowCopy nur eine flache Kopie erstellt.


Nun ist die Festlegung, ob die Kopien ihrer Instanzen tiefe oder flache sein sollen, gelegentlich ein Charakteristikum der Klasse selbst. Jede Klasse erbt deswegen von Object eine Methode copy, die standardmäßig (also in Object) einfach shallowCopy aufruft (warum es nicht deepCopy aufruft, sollte klar sein) und die die erbende Klasse entsprechend ihren eigenen Konditionen überschreiben kann. Es ist so möglich, die Kopiertiefe von Objektstrukturen selbst zu bestimmen, indem man copy für manche Klassen deepCopy aufrufen lässt und das tiefe Kopieren durch Instanzen terminiert, deren Klassen shallowCopy aufrufen lassen.


Frage: Wie kann die Kopiertiefe von Objektstrukturen bestimmt werden?
Antwort: Die Kopiertiefe von Objektstrukturen kann bestimmt werden, indem man für manche Klassen deepCopy aufruft und das tiefe Kopieren durch Instanzen terminiert, deren Klassen shallowCopy aufrufen lassen.


Manchmal darf bei Kopier- oder Konvertieroperationen kein Objekt des gleichen Typs zurückgegeben werden. In diesen Fällen sollte statt self class (Zeile 554) self species aufgerufen werden:


Frage: Was ist der Unterschied zwischen self class und self species in Smalltalk?
Antwort: In Smalltalk, self class gibt den Klassentyp des empfangenden Objekts zurück, während self species den Metaklassentyp des empfangenden Objekts zurückgibt.

Frage: Wann sollte self class und wann self species in Smalltalk verwendet werden?
Antwort: Wenn man eine Kopie oder Konvertierung durchführen möchte und kein Objekt des gleichen Typs zurückgegeben werden darf, sollte man self species anstelle von self class verwenden.


Die Methode species war uns schon einmal begegnet. Sie gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist z. B. bei der Methode collect:, ausgeführt auf einer Instanz von Interval, sinnvoll, da collect: hier kein Intervall zurückgeben kann. So kann beispielsweise die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. Entsprechend ist in der Klasse Interval die Methode species als implementiert.


Frage: Was macht die Methode species?
Antwort: Die Methode species gibt standardmäßig die Klasse des Empfängerobjekts zurück und kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Zum Beispiel bei der Methode collect:, die auf einer Instanz von Interval ausgeführt wird, ist es sinnvoll, die Methode species zu überschreiben, da collect: kein Intervall zurückgeben kann. So kann die von species zurückgegebene Collection von Strings nicht als Intervall dargestellt werden. In der Klasse Interval ist die Methode species als implementiert.
