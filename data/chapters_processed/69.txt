69 Klassenhierarchie

Der Begriff des Programmierstils kann weiter gefasst werden, als dies in den bisherigen Kapiteln dieser Kurseinheit der Fall war. Tatsächlich ist die Abgrenzung eines Stilbegriffs von allgemeinen Handlungsgrundsätzen und guter Praxis in der Programmierung nicht einfacher als in jeder anderen Disziplin, in der eine gewisse schöpferische Freiheit besteht. Sie ist fast immer willkürlich. Im Folgenden soll daher noch kurz ein Entwurfsprinzip vorgestellt werden, das ich persönlich eher nicht als Stilfrage einstufen würde, das aber dennoch häufiger in diesem Zusammenhang genannt wird.


Frage: Was ist ein Entwurfsprinzip in der Programmierung?
Antwort: Ein Entwurfsprinzip in der Programmierung ist ein Grundsatz, der bei der Gestaltung von Software berücksichtigt wird. Im Gegensatz zu einem Programmierstil ist ein Entwurfsprinzip eher allgemein und weniger willkürlich. Es kann die Gestaltung von Software in Hinsicht auf Funktionalität, Wartbarkeit, Lesbarkeit und Effizienz beeinflussen.

Frage: Was ist ein Entwurfsprinzip und wie unterscheidet es sich von einem Programmierstil?
Antwort: Ein Entwurfsprinzip ist ein allgemeiner Grundsatz oder Richtlinie, die bei der Gestaltung von Softwarearchitektur und Design befolgt wird. Im Gegensatz dazu ist ein Programmierstil eine bestimmte Art und Weise, wie Code geschrieben wird, die von der persönlichen Vorliebe des Programmierers abhängt. Ein Entwurfsprinzip ist also ein allgemeinerer Begriff als Programmierstil und bezieht sich auf die Architektur und das Design von Software, während Programmierstil sich auf die Art und Weise bezieht, wie Code geschrieben wird.


Wie bereits in Kurseinheit 6 und teilweise auch schon in Kurseinheit 2, Abschnitt 10.1 bemerkt, ist die Vererbung Aushängeschild und Problemkind der objektorientierten Programmierung zugleich. Es verwundert daher nicht, dass sich eine ganze Menge von Programmierrichtlinien mit genau diesem Thema beschäftigen. Die meines Erachtens gewichtigste aller Regeln zu diesem Thema ist jedoch: Mache alle Superklassen abstrakt.

Frage: Was ist die wichtigste Programmierrichtlinie zur Vererbung?
Antwort: Die wichtigste Programmierrichtlinie zur Vererbung ist: Mache alle Superklassen abstrakt.

Für Java lässt sich diese Regel auch als „deklariere jede Klasse entweder als abstrakt oder als final“ formulieren. Der Grund dafür, dass nur die Blätter der Klassenhierarchie instanziierbar sein sollen, ist einfach: Wenn man mit der Funktionalität einer Klasse bzw. genauer und in diesem Fall wichtig, der Funktionalität der Instanzen einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern. Als Programmiererin möchte man diese Änderung unabhängig von der Frage, ob davon auch andere Klassen betroffen sind, durchführen können. Deswegen wird man die Änderungen auch nur an der Klasse selbst und nicht etwa an einer ihrer Superklassen durchführen. Betrifft der Änderungswunsch eine geerbte Methode, so überschreibt man diese in der betreffenden Klasse nach seinen Vorstellungen. Nur wenn eine eingehende Analyse der Superklasse und all ihrer Subklassen ergibt, dass die gewünschte Änderung für alle sinnvoll ist und den Erwartungen der Klienten entspricht, kann man darüber nachdenken, die Änderung in der Superklasse durchzuführen.


Frage: Warum sollten nur die Blätter der Klassenhierarchie instanziierbar sein?
Antwort: Die Blätter der Klassenhierarchie sollten instanziierbar sein, weil man die Implementierung einer Klasse ändern will, ohne die Implementierung der Superklasse ändern zu müssen. Wenn man mit der Funktionalität einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern, ohne die Implementierung der Superklasse ändern zu müssen.


Wenn nun aber die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, dann ist man der Freiheit beraubt, nur für sich zu entscheiden. Von jeder Änderung, die man durchführt, muss man fürchten, dass sie sich auf andere Klassen ausbreitet und den Vertrag dieser Klassen mit ihren Klienten bricht (Siehe auch das Fragile-base-class-Problem in Kapitel 55). Etwas subtiler, aber genau dasselbe Problem, ereilt die Designerin von Klassenbibliotheken, wenn sie beschließt, das Verhalten einer Klasse zu ändern. Selbst wenn sie sich sicher ist, dass dies innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, so kann sie doch nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.


Frage: Was ist das Fragile-base-class-Problem?
Antwort: Das Fragile-base-class-Problem ist ein Problem, bei dem eine Änderung an der Basisklasse sich auf andere Klassen ausbreiten und den Vertrag dieser Klassen mit ihren Klienten brechen kann. Das Problem tritt auf, wenn die Klasse, deren Verhalten man ändern möchte, Subklassen hat oder wenn die Designerin von Klassenbibliotheken beschließt, das Verhalten einer Klasse zu ändern.

Frage: Warum kann eine Änderung am Verhalten einer Klasse Auswirkungen auf andere Klassen haben?
Antwort: Eine Änderung am Verhalten einer Klasse kann Auswirkungen auf andere Klassen haben, weil wenn die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, jede Änderung sich auf diese Subklassen ausbreiten und den Vertrag dieser Klassen mit ihren Klienten brechen kann. Auch wenn die Designerin sicher ist, dass die Änderung innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, kann sie nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.


Nun ist aber, wie gerade erst (Kapitel 66) erwähnt, einer der wichtigsten Gedanken der Objektorientierung, existierenden Code, vor allem Bibliotheksklassen, per Vererbung wiederzuverwenden. Wenn die Bibliotheksdesignerin aber alle relevanten Klassen (das sind üblicherweise gerade die konkreten, also die instanziierbaren) final deklariert hat, dann ist das nicht möglich. Eine einfache Konvention erlaubt jedoch, diese Beschränkung zu umgehen: In der Bibliothek wird einfach die Klasse, von der geerbt werden soll, als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die zunächst keine Änderungen (Differenzia) hinzufügt, dafür aber konkret (also instanziierbar) und auch final ist. Sollte die Bibliotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Bibliothek mit den Änderungen beglücken möchte, die Änderungen in der abstrakten Superklasse durchführen. Machen alle Superklassen abstrakt.


Frage: Wie kann man die Beschränkung umgehen, wenn die Bibliotheksdesignerin alle relevanten Klassen final deklariert hat?
Antwort: Eine Möglichkeit, diese Beschränkung zu umgehen, ist die Konvention, die Klasse, von der geerbt werden soll, als abstrakt zu deklarieren und eine Subklasse davon abzuleiten, die zunächst keine Änderungen hinzufügt, dafür aber konkret und final ist. Sollte die Bibliotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Bibliothek mit den Änderungen beglücken möchte, die Änderungen in der abstrakten Superklasse durchführen.
