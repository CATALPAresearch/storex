"""
Questions
"""
from enum import IntEnum


class KE(IntEnum):
    KE1 = 0
    KE2 = 1
    KE3 = 2
    KE4 = 3
    KE5 = 4
    KE6 = 5
    KE7 = 6


KE2_questions = []
KE3_questions = []
KE4_questions = []
KE5_questions = []
KE7_questions = []

# TODO: Keywords, linking between questions
KE1_topics = [{'question': "Was sind die Grundkonzepte der objektorientierten Programmierung?",
              'keywords': ["Objekt", "Beziehung", "Zustand", "Verhalten"]}]

KE2_topics = [{'question': "Was ist die Systematik der objektorientierten Programmierung?",
              'keywords': ["Klasse", "Metaklasse", "Generalisierung", "Spezialisierung", "Vererbung",
                           "abstrakte Klasse", "Superklasse", "Subklasse", "dynamisches Binden", "Collection",
                           "Verhalten", "Eingabestrom", "Ausgabestrom", "Parallelität"]}]

KE3_topics = [{'question': "Was sind Typen in der objektorientierten Programmierung?",
              'keywords': ["Deklaration", "Definition", "Verwendung", "Typdefinition", "Zuweisungskompatibilität",
                           "Typäquivalenz", "Typerweiterung", "Typkonformität", "Typeinschränkung", "Subtyping",
                           "Inklusionspolymorphie", "Typumwandlung", "Generischer Typ",
                           "parametrischer Polymorphismus", "Kovarianz", "Grenze", "Typisierung"]}]

KE4_topics = [{'question': "Was sind die Besonderheiten von JAVA?",
              'keywords': ["Programmiermodell", "Objekt", "Typ", "Klasse", "Ausdruck", "Anweisung", "Block",
                           "Kontrollstruktur", "Modul", "Interface", "Array", "Aufzählungstyp", "Generischer Typ",
                           "dynamische Typprüfung", "interne Iteration", "externe Iteration", "spezielle Klasse"]}]

# TODO:
KE5_topics = [{'question': "Was sind die Besonderheiten anderer objektorientierter Programmiersprachen?",
              'keywords': ["C#", "C++", "EIFFEL"]}]

KE6_topics = [{'question': "Was sind Probleme der objektorientierten Programmierung?",
              'keywords': ["Problem der Substituierbarkeit",
                           "Fragile-base-class-Problem",
                           "Problem der schlechten Tracebarkeit",
                           "Problem der eindimensionalen Strukturierung",
                           "Problem der mangelnden Kapselung",
                           "Problem der mangelnden Skalierbarkeit",
                           "Problem der mangelnden Eignung"]}]

KE7_topics = [{'question': "Was ist guter objektorientierter Stil?",
              'keywords': ["Namen", "Formatierung", "kurze Methoden", "deklarativ", "Bibliothek", "Verteilung",
                           "Gesetz Demeters", "Klassenhierarchie"]}]


KE6_solutions = [
    {'question': "Was ist das Liskov-Substitutionsprinzip?",
     'keywords': ['verhaltensbezogenes Subtyping', 'Subtypenrelation', 'Kontravarianz der Argumenttypen',
                  'Kovarianz des Ergebnistyps', 'Kovarianz der Ausnahmen', 'implizierte Vorbedingungen',
                  'implizierende Nachbedingungen', 'implizierende Invarianten', 'restriktiv']},
    {'question': "Welchen Lösungsansatz gibt es für das Fragile-Base-Class-Problem?",
     'keywords': ['explizites Vererbungsinterface', 'Zugriffsmodifikatoren']},
    {'question': "Welchen Lösungsansatz gibt es für das Problem der mangelnden Kapselung?",
     'keywords': ['Teil-Ganzes-Beziehung', 'kein Alias auf Wertobjekte']},
]
# TODO: What are good answers and keywords? Paraphrase answers/ multiple correct answers
KE6_questions = [
    # {'question': "Was ist das Problem der Substituierbarkeit?",
    #  'keywords': ['Zuweisungskompatibilität', 'nichtkonforme Verhaltensänderung',
    #  'keine Prüfung der Substituierbarkeit', "Liskov-Substitutionsprinzip",],
    #  'follow-up': [KE6_solutions[0]]},
    # {'question': "Welche Probleme gibt es bei Subtyping unter Wertsemantik?", 'keywords': []},
    {'question': "Was ist das Fragile-Base-Class-Problem?",
     'keywords': ['Vererbung', 'Abhängigkeit', 'anfällig', 'Subklasse', 'unerwartet', 'Verhalten'],
     'answer': 'Das Fragile-Base-Class-Problem bezieht sich auf eine Gruppe von Problemen in der Vererbung von Klassen. '
               'Wenn zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke '
               'Abhängigkeiten bestehen, können Änderungen an der Basisklasse, welche etwa durch eine unvollständige '
               'Dokumentation nicht auffallen, zu unerwarteten und unerwünschten Auswirkungen in der abgeleiteten '
               'Klasse führen.', 'follow-up': [KE6_solutions[1]]},
    {'question': "Was ist das Problem der schlechten Tracebarkeit?",
     'keywords': ['dynamischer Programmablauf', 'Goto-Anweisung', 'durchbrochenes Lokalitätsprinzip',
                  'Unterprogrammaufrufe', 'dynamisches Binden'],  # 'schweres Debuggen'
     'answer': 'Das Problem der schlechten Tracebarkeit entsteht durch den dynamischen Programmablauf. Die '
               'Goto-Anweisung erlaubt Sprünge von beliebigen Stellen eines Programms zu anderen Stellen und bricht '
               'dabei das Lokalitätsprinzip von Programmen, bei dem zusammengehörende Anweisungen im Programmtext nahe '
               'beieinander stehen. Dies führte zu einer Unübersichtlichkeit im Programmtext und erschwerte das '
               'Verstehen und Debuggen von Programmen.'},
    {'question': "Was ist das Problem der eindimensionalen Strukturierung?",
     'keywords': ['mehrere Strukturierungskriterien', 'unzureichende Trennung der Belange'],
     'answer': 'Bei größeren Programmen kann das Bedürfnis entstehen, ein Programm nach mehreren Kriterien '
               'gleichzeitig zu strukturieren, da verschiedene Vererbungshierarchien oder andere '
               'Strukturierungskriterien gleichzeitig relevant sein können. Die Trennung der Belange, auch als '
               'Separation of Concerns bekannt, wird in der objektorientierten Programmierung als unzureichend '
               'unterstützt angesehen, da es schwer ist, verschiedene Aspekte eines Systems sauber voneinander zu '
               'trennen.'},
    {'question': "Was ist das Problem der mangelnden Kapselung?",
     'keywords': ['Vererbung', 'Abhängigkeit', 'Aliasing-Problem', 'Geheimnisprinzip'], 'follow-up': [KE6_solutions[2]],
     'answer': 'Vererbung führte zu starken Abhängigkeiten zwischen Klassen und ihren Subklassen. Das Aliasing-Problem '
               'tritt auf, wenn ein Objekt, das von einem anderen Objekt gekapselt wird, auch einen Alias besitzt, der '
               'nicht selbst dem kapselnden Objekt gehört. Dies bedeutet, dass von außen auf das gekapselte Objekt '
               'zugegriffen werden kann, indem man ein Alias verwendet. Dies stellt eine Herausforderung für die '
               'Kapselung dar, das Geheimnisprinzip durchbrochen werden kann.'}
    # {'question': "Was ist das Aliasing-Problem?",
    #  'keywords': ['Zugriff auf gekapselte Objekte', 'Referenz auf Repräsentationsobjekte',
    #               'Umgehen des Geheimnisprinzips', 'verschiedene Typen']},
    # {'question': "Was ist das Problem der mangelnden Skalierbarkeit?", 'keywords': ['mangelnde Komponenten']},
    # {'question': "Was ist das Problem der mangelnden Eignung?", 'keywords': ['geeignete Programmiersprache',
    #                                                                          'Abwägungsproblem']}
]

KE1_questions = [{'question': 'Was sind Literale?', 'answer': 'Ein Literal ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten.'}, {'question': 'Was ist der Unterschied zwischen Literale und objekterzeugenden Anweisungen?', 'answer': 'Der Compiler erzeugt bei der Übersetzung eines Literals das entsprechende Objekt im Speicher, während objekterzeugende Anweisungen erst zur Laufzeit des Programms ausgeführt werden.'}, {'question': 'Warum sind Literale keine Objekte?', 'answer': 'Literale repräsentieren Objekte, sind jedoch selbst keine Objekte, da sie textuelle Spezifikationen von Objekten sind.'}, {'question': 'Was sind die einfachsten Literale in SMALLTALK?', 'answer': 'Die einfachsten Literale in SMALLTALK repräsentieren Zeichenobjekte und Zahl-Literale.'}, {'question': 'Was sind atomare Objekte?', 'answer': 'Atomare Objekte sind Zeichenobjekte und Zahlobjekte, die nicht aus anderen Objekten bestehen.'}, {'question': 'Was sind Pseudo-Variablen in SMALLTALK?', 'answer': 'In SMALLTALK sind die in anderen Programmiersprachen vorhandenen Literale, die ebenfalls atomare Objekte repräsentieren, Pseudo-Variablen.'}, {'question': 'Was sind Strings?', 'answer': 'Strings sind aus Zeichen zusammengesetzte Zeichenketten. String-Literale repräsentieren also zusammengesetzte Objekte.'}, {'question': 'Was sind Symbole in SMALLTALK?', 'answer': 'Symbole sind eine weitere Art von Objekten mit literaler Repräsentation in SMALLTALK. Sie dienen dazu, sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen.'}, {'question': 'Was ist der Unterschied zwischen Symbole und Strings in SMALLTALK?', 'answer': 'Symbole dürfen im Gegensatz zu Strings keine Leerzeichen enthalten. Zudem ist die Erzeugung eines Objekts anhand eines Symbolliterals technisch aufwendiger als die Erzeugung eines Objekts anhand eines String-Literals.'}, {'question': 'Was kann bei der Verwendung von identischen Symbolliteralen passieren?', 'answer': 'Bei der Verwendung identischer Symbolliterale kann es durch sogenanntes Aliasing zu unerwarteten Ergebnissen führen.'}, {'question': 'Was sind Array-Literale in SMALLTALK ?', 'answer': 'Array-Literale repräsentieren Objekte, die aus einer Folge beliebiger anderer Objekte bestehen.'}, {'question': 'Was ist die Gleichheit von Objekten?', 'answer': 'Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten und wird in SMALLTALK durch den Gleichheitsoperator getestet.'}, {'question': 'Was ist die Identität von Objekten?', 'answer': 'Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren.'}, {'question': 'Was ist der Unterschied zwischen Gleichheit und Identität von Objekten?', 'answer': 'Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten. Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren.'}, {'question': 'Warum können syntaktisch gleiche String-Literale in SMALLTALK unterschiedliche Identitäten haben?', 'answer': 'Syntaktisch gleiche String-Literale können in SMALLTALK unterschiedliche Identitäten haben, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen.'}, {'question': 'Warum sind gleiche Zahlen nur manchmal identisch in SMALLTALK?', 'answer': 'In SMALLTALK werden gleiche Zahlen manchmal als identisch behandelt und manchmal nicht, abhängig von ihrer Größe und technischen Gründen.'}, {'question': 'Was ist der Unterschied zwischen "das gleiche" und "dasselbe"?', 'answer': 'In der objektorientierten Programmierung sind "das gleiche" und "dasselbe" nicht dasselbe. Zwei Objekte können gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins.'}, {'question': 'Warum ist die Identität von Objekten wichtig?', 'answer': 'Die Identität von Objekten ist wichtig, um festzustellen, ob zwei Namen oder Variablen dasselbe Objekt repräsentieren oder nicht.'}, {'question': 'Warum haben veränderliche Objekte eine Identität?', 'answer': 'Veränderliche Objekte haben eine Identität um sie auch bei vorübergehender Gleichheit voneinander unterscheiden zu können, da sie sich hinterher wieder auseinanderentwickeln können.'}, {'question': 'Warum haben unveränderliche Objekte eine Identität?', 'answer': 'Unveränderliche Objekte haben aus technischen Gründen eine Identität. Wenn sich ein unveränderliches Objekt aus einer Operation ergibt, dann müsste für eine Zusammenlegung gleicher Objekte zu einem immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Ganze Zahlen bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind.'}, {'question': 'Was sind Attribute?', 'answer': 'Attribute sind Instanzvariablen, die die Eigenschaften eines Objekts festhalten.'}, {'question': 'Was sind Kategorien von Instanzvariablen?', 'answer': 'Instanzvariablen können logischerweise in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Eigenschaften sind Attribute wie Farbe oder Name, die ihre Bedeutung verlieren, wenn sie isoliert betrachtet werden. Beziehungen hingegen repräsentieren Verbindungen zwischen Objekten und behalten ihre Bedeutung auch isoliert betrachtet.'}, {'question': 'Welche Semantik haben Variablen, die Attribute repräsentieren?', 'answer': 'Variablen, die Attribute repräsentieren, haben in der Regel eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Dies ermöglicht es, dass Änderungen an einem Attributwert nicht automatisch andere Objekte mit dem gleichen Attributwert beeinflussen.'}, {'question': 'Welche Objekte sind in SMALLTALK veränderbar?', 'answer': 'Atomare Objekte und Objekte, die aus Symbolliteralen hervorgegangen sind, sind grundsätzlich nicht veränderbar. Zusammengesetzte Objekte in SMALLTALK sind jedoch veränderbar.'}, {'question': 'Warum sind atomare Objekte grundsätzlich nicht veränderbar?', 'answer': 'Atomare Objekte sind grundsätzlich nicht veränderbar, da es keinen Sinn ergibt, sie zu verändern. Zum Beispiel macht es keinen Sinn, aus einer "1" eine "2" zu machen.'}, {'question': 'Warum könnten zusammengesetzte Objekte veränderbar sein?', 'answer': 'Zusammengesetzte Objekte könnten veränderbar sein, da es sinnvoll sein kann, eine Komponente durch eine andere zu ersetzen.'}, {'question': 'Sind Array-Objekten in SMALLTALK veränderbar?', 'answer': 'Zusammengesetzte Array-Objekte sind in der Regel veränderbar. Ob Array-Objekte, die aus Literalen erzeugt wurden, veränderbar sein sollen, ist ansichtssache und wird von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt.'}, {'question': 'Warum sind zusammengesetzte Objekte in SMALLTALK grundsätzlich veränderbar?', 'answer': 'Zusammengesetzte Objekte sind in SMALLTALK grundsätzlich veränderbar, da dies eine Voraussetzung dafür ist, dass Objekte einen Zustand haben können.'}, {'question': 'Warum bieten immer mehr Sprachen unveränderliche Objekte an?', 'answer': 'Immer mehr Sprachen bieten unveränderliche Objekte an aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung.'}, {'question': 'Was ist eine Zuweisung?', 'answer': 'Eine Zuweisung ist der Vorgang, bei dem einer Variable ein Objekt zugewiesen wird, damit sie dieses Objekt bezeichnet.'}, {'question': 'Warum ist die Zuweisung kommutativ?', 'answer': 'Die Zuweisung ist nicht kommutativ, da "x := y" und "y := x" unterschiedliche Bedeutungen haben, es sei denn, "x" und "y" hatten bereits denselben Wert vor der jeweiligen Zuweisung.'}, {'question': 'Was ist der Unterschied zwischen Zuweisungen unter Wertsemantik und Verweissemantik?', 'answer': 'Bei Zuweisungen unter Wertsemantik muss eine Kopie des Objekts angefertigt werden, da die Variable das Objekt selbst speichert. Bei Zuweisungen unter Verweissemantik wird nur der Verweis auf das Objekt kopiert und in der Variable gespeichert. Dies hat Auswirkungen darauf, ob Änderungen an einem Objekt in einer Variable sich auf dasselbe Objekt in einer anderen Variable auswirken.'}, {'question': 'Was sind Instanzvariablen?', 'answer': 'Instanzvariablen sind lokale Variablen, die einem Objekt zugeordnet sind und dazu verwendet werden, Informationen zu speichern, die spezifisch für dieses Objekt sind. Sie bestimmen die Struktur zusammengesetzter Objekte.'}, {'question': 'Was ist die Sichtbarkeit von Instanzvariablen in SMALLTALK?', 'answer': 'Die Sichtbarkeit von Instanzvariablen in SMALLTALK ist auf das besitzende Objekt beschränkt. Instanzvariablen können von anderen Objekten nicht direkt zugegriffen werden.'}, {'question': 'Was sind zwei Arten von Instanzvariablen in SMALLTALK?', 'answer': 'In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte Instanzvariablen.'}, {'question': 'Was sind benannte Instanzvariablen in SMALLTALK?', 'answer': 'Benannte Instanzvariablen sind Instanzvariablen, die jeweils auf ein bestimmtes Objekt verweisen oder es benennen. Der Name der Variablen wird zum Namen des Objekts, auf das sie verweisen.'}, {'question': 'Was sind indizierte Instanzvariablen in SMALLTALK?', 'answer': 'Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zum Objekt angesprochen, dem sie gehören. Der Index fungiert gewissermaßen als Name für die Instanzvariable.'}, {'question': 'Was sind Indexer?', 'answer': 'Indexer sind ähnlich zu indizierten Instanzvariablen und werden beispielsweise von C# und VISUAL BASIC verwendet.'}, {'question': 'Wie ist die Anzahl indizierten Instanzvariablen eines Objekts?', 'answer': 'Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix, und die Größe eines Objekts mit indizierten Instanzvariablen ist ebenfalls fest und kann nicht verändert werden.'}, {'question': 'Welche Arten von Ausdrücken gibt es?', 'answer': 'Es gibt Literale, Variablen, Zuweisungsausdrücke und Nachrichtenausdrücke.'}, {'question': 'Was sind primitive Ausdrücke?', 'answer': 'Primitive Ausdrücke sind nicht aus anderen Ausdrücken zusammengesetzt, wie Literale und Variablen.'}, {'question': 'Welche zwei Ausdrücke sind wichtig?', 'answer': 'Zuweisungsausdrücke und Nachrichtenausdrücke sind wichtig. Sie ermöglichen es, Aktionen mit den repräsentierten Objekten auszuführen und damit ein Programm tatsächlich auszuführen.'}, {'question': 'Was sind Anweisungen?', 'answer': 'Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird.'}, {'question': 'Wie werden Anweisungen in SMALLTALK getrennt?', 'answer': 'In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt.'}, {'question': 'Welche Funktion hat die Return-Anweisung in SMALLTALK?', 'answer': 'Die Return-Anweisung gibt das Objekt zurück, zu dem der nachfolgende Ausdruck ausgewertet wird. Sie wird in Methoden und Blöcken verwendet, um das Ergebnis der Ausführung zurückzugeben.'}, {'question': 'Was ist der Lebenslauf von Objekten in SMALLTALK?', 'answer': 'In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung.'}, {'question': 'Was ist die "Garbage Collection" in SMALLTALK?', 'answer': 'Die "Garbage Collection" ist ein Mechanismus in SMALLTALK, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr über Variablen zugreifbar sind.'}, {'question': 'Wann kann ein Objekt in SMALLTALK aus dem Speicher entfernt werden?', 'answer': 'Ein Objekt in SMALLTALK kann aus dem Speicher entfernt werden, wenn keine Variable mehr auf dieses Objekt verweist und es somit nicht mehr erreichbar ist.'}, {'question': 'Welche Objekte sind von der automatischen Speicherbereinigung ausgenommen?', 'answer': 'Von der automatischen Speicherbereinigung ausgenommen sind Objekte mit eindeutiger literaler Repräsentation, wie kleine Zahlen, Zeichen und Symbole. Zahlen und Zeichen werden durch Werte in Variablen repräsentiert und Symbole sind in einer Symboltabelle abgelegt.'}, {'question': 'Warum wurde in SMALLTALK die explizite Speicherfreigabe aufgegeben?', 'answer': 'Die explizite Speicherfreigabe wurde in SMALLTALK aufgegeben, da es schwierig ist, genau zu verfolgen, welche Objekte noch referenziert werden, insbesondere in großen und komplexen Programmen. Die Verantwortung dafür den Anwendungsprogrammierern zu überlassen, würde zu vielen potenziellen Programmierfehlern führen.'}, {'question': 'Was sind die Vorteile der Garbage Collection in SMALLTALK?', 'answer': 'Die Garbage Collection verhindert vorzeitige Entfernung von Objekten, die noch in Verwendung sind, und stellt sicher, dass Variablen auf gültige Objekte verweisen. Dies trägt zur Stabilität und Sicherheit von Programmen bei.'}, {'question': 'Warum ist "Lebenszyklus" eines Objekts irreführend?', 'answer': 'Der Begriff "Lebenszyklus" würde implizieren, dass das Objekt nach seinem Ende wiederverwendet wird, was nicht der Fall ist. Objekte werden nicht recycelt, sondern nur der von ihnen belegte Speicherplatz wird möglicherweise wiederverwendet.'}, {'question': 'Was ist die Auswertung von Ausdrücken?', 'answer': 'Die Auswertung von Ausdrücken ist der Prozess, bei dem ein Programm tatsächlich Aktionen ausführt. Sie ist wichtig, weil sie den eigentlichen "Tätigkeitsprozess" eines Programms darstellt und sicherstellt, dass die gewünschten Operationen durchgeführt werden.'}, {'question': 'Was ist eine Zuweisung?', 'answer': 'Eine Zuweisung ist eine Aktion, bei der der Inhalt einer Variable geändert wird. Die Zuweisung selbst steht für (eine Referenz auf) das Objekt. Dies ist eine Art von Seiteneffekt der Auswertung des Ausdrucks.'}, {'question': 'Was sind primitive Ausdrücke in SMALLTALK?', 'answer': 'Die Zuweisung wird in SMALLTALK als primitiver Ausdruck betrachtet.'}, {'question': 'Wie werden Nachrichtenausdrücke in SMALLTALK ausgewertet?', 'answer': 'Nachrichtenausdrücke in SMALLTALK werden ausgewertet, indem die Nachricht (das Prädikat) an das Empfängerobjekt (das Subjekt) mit den Parametern (Prädikatsergänzungen) gesendet wird. Nach der Auswertung repräsentiert der Nachrichtenausdruck das Ergebnis der Nachricht, das von dem Empfängerobjekt zurückgegeben wird.'}, {'question': 'Ist es in SMALLTALK möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben?', 'answer': 'In SMALLTALK ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben, da jeder Nachrichtenversand ein Ergebnis zurückgibt. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API (fließende Programmierung).'}, {'question': 'Was ist ein Methodenaufruf?', 'answer': 'Ein Methodenaufruf ist die Auswertung eines Nachrichtenausdrucks, da diese zur Ausführung der Anweisungen im Rumpf einer Methode führt.'}, {'question': 'Was sind Objekte in der objektorientierten Programmierung?', 'answer': 'Objekte sind in der objektorientierten Programmierung Daten, die im Speicher abgelegt sind und in der Lage sind, Informationen zu speichern und Aktionen auszuführen. Sie repräsentieren Dinge aus der realen Welt und können miteinander in Beziehung stehen.'}, {'question': 'Was sind Inkonsistenzen im objektorientierten Weltbild?', 'answer': 'In der objektorientierten Programmierung werden verschiedene Arten von Sachverhalten, die in der realen Welt unterschiedliche Eigenschaften haben, durch Objekte repräsentiert. Dies kann zu Inkonsistenzen führen, da nicht alle Sachverhalte dieselben Eigenschaften wie Objekte haben. Dies ist auf die homogene Natur der Objektorientierung zurückzuführen.'}, {'question': 'Was ist der Unterschied zwischen einem Objekt und einem Wert?', 'answer': 'Objekte haben eine eindeutige Identität und sind an einer bestimmten Stelle im Speicher abgelegt, während Werte an verschiedenen Stellen im Speicher vorkommen können und keine Identität haben.'}, {'question': 'Was ist das Motto von SMALLTALK?', 'answer': 'Das Motto von SMALLTALK lautet "alles ist ein Objekt".'}, {'question': 'Warum haben Objekte im Speicher eine konstante Größe?', 'answer': 'Objekte im Speicher haben eine feste Größe, die aus technischen Gründen nicht verändert werden kann. Wenn ein Objekt mehr Platz benötigt oder verkleinert werden muss, muss ein neues Objekt erzeugt werden, das an die Stelle des alten tritt. Dieses neue Objekt hat jedoch eine andere Identität.'}, {'question': 'Was sind Pseudovariablen in SMALLTALK?', 'answer': 'Pseudovariablen in SMALLTALK sind Variablen wie "true", "false", "nil", "self", "super" und formale Parameter von Methoden sowie Klassennamen, denen der Programmierer keinen Wert zuweisen kann.'}, {'question': 'Warum werden Pseudovariablen als solche bezeichnet?', 'answer': 'Sie werden als Pseudovariablen bezeichnet, da sie ihren Wert entweder nicht ändern können oder ihren Wert vom System erhalten.'}, {'question': 'Warum ist die Zuweisung für Pseudovariablen in SMALLTALK nicht zulässig?', 'answer': 'Die Zuweisung für Pseudovariablen ist in SMALLTALK nicht zulässig, da sie auf Objekte von spezifischer Bedeutung verweisen und diese Bedeutung nicht verändert werden sollte.'}, {'question': 'Was ist der "Inhalt" einer Variable?', 'answer': 'Der "Inhalt" einer Variable bezieht sich auf das Objekt, das von der Variable bezeichnet wird.'}, {'question': 'Was ist Verweis- oder Referenzsemantik?', 'answer': 'Bei Verweis- oder Referenzsemantik haben Variablen nur Verweise die Speicherstellen, an denen die Objekte abgelegt sind.'}, {'question': 'Was ist Wertsemantik?', 'answer': 'Bei Wertsemantik macht das bezeichnete Objekt tatsächlich den Inhalt der Variable aus.'}, {'question': 'Was ist eine Variable aus technischer Sicht?', 'answer': 'Aus technischer Sicht entspricht eine Variable einer Stelle im Speicher.'}, {'question': 'Was sind Variablen mit Verweissemantik?', 'answer': 'Es handelt sich bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen.'}, {'question': 'Was ist der Unterschied zwischen Verweissemantik und Wertsemantik von Variablen?', 'answer': 'Unter Wertsemantik können zwei Variablen niemals dasselbe Objekt bezeichnen, während Verweissemantik erlaubt, dass mehrere Variablen auf dasselbe Objekt verweisen.'}, {'question': 'Warum wird in der objektorientierten Programmierung häufig Verweissemantik verwendet?', 'answer': 'Verweissemantik wird in der objektorientierten Programmierung häufig verwendet, da sie einen speicher- und recheneffizienten Umgang mit Objekten ermöglicht und unterschiedliche Objekte unterschiedlich viel Speicherplatz belegen.'}, {'question': 'Haben Variablen Wert- oder Verweissemantik?', 'answer': 'In manchen Sprachen haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik, z. B. JAVA. Andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll, z. B. C++ und EIFFEL.'}, {'question': 'Welche Variablen haben in SMALLTALK Wertsemantik?', 'answer': 'In den meisten SMALLTALK-Implementationen haben Variablen, die Zeichen, kleine Zahlen und boolesche Werte bezeichnen, Wertsemantik, um Speicherplatz zu sparen, obwohl der Begriff der Identität für diese Objekte verloren geht. Die mehrfache Existenz identischer Objekte im Speicher hat in der Regel keine große Bedeutung, da Gleichheit an die Stelle der Identität treten kann.'}, {'question': 'Was bezeichnet eine Variable?', 'answer': 'Eine Variable bezeichnet ein Objekt.'}, {'question': 'Wie wird der Zugriff auf Variablen einzuschränken?', 'answer': 'Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen.'}, {'question': 'Was ist die Sichtbarkeit einer Variable?', 'answer': 'Die Sichtbarkeit einer Variable bezieht sich immer auf einen Abschnitt des Programmcodes, in dem der Variablenname verwendet werden kann und damit Zugriff auf das von diesem Namen bezeichnete Objekt besteht.'}, {'question': 'Was ist der Unterschiede zwischen globalen und lokalen Variablen?', 'answer': 'Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht. Globale Variablen sind auch außerhalb davon von überall her sichtbar.'}, {'question': 'Was ist das Geheimnisprinzip?', 'answer': 'Das Geheimnisprinzip oder Information Hiding bezieht sich auf das Verbergen von Implementationsdetails eines Objekts, insbesondere der Struktur zusammengesetzter Objekte, vor den Objekten, die sie verwenden. Dadurch können Änderungen an der Struktur vorgenommen werden, ohne dass abhängige Objekte davon betroffen sind.'}, {'question': 'Was ist Kapselung?', 'answer': 'Bei der Kapselung geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann.'}, {'question': 'Was ist der Unterschied zwischen dem Geheimnisprinzip und der Kapselung?', 'answer': 'Der Unterschied besteht darin, dass das Geheimnisprinzip sich auf das Verbergen von Implementationsdetails und Struktur bezieht, während die Kapselung sich auf das Verbergen und die Kontrolle des Zustands eines Objekts bezieht.'}, {'question': 'Wie wird die Kapselung umgesetzt?', 'answer': 'Über lokale Instanzvariablen kann ein Objekt verbergen, welche Objekte es kennt. Aber aufgrund von Aliasing kann ein Objekt, dessen Name unsichtbar ist, über einen anderen Namen zugänglich sein kann.'}, {'question': 'Warum kann ein Objekt seinen inneren Aufbau nicht kapseln?', 'answer': 'Ein Objekt kann seinen inneren Aufbau nicht vollständig vor der Außenwelt abkapseln, da aufgrund der möglichen Existenz von Aliasen andere Objekte diese Objekte kennen und ohne sein Wissen manipulieren können. Die Abschottung erfordert spezielle Vorkehrungen, die derzeit nicht in gängige objektorientierte Programmiersprachen integriert sind und explizit programmiert werden müssen.'}, {'question': 'Was sind Kardinalitäten?', 'answer': 'Kardinalitäten sind in der Daten- und Softwaremodellierung häufig verwendete Beziehungsattribute, die angeben, wie viele andere Objekte ein Objekt in einer Beziehung haben kann.'}, {'question': 'Welche Beziehungen gibt es?', 'answer': 'Es gibt Zu-eins-Beziehungen, auch :1-Beziehung und Zu-n-Beziehungen, auch :n-Beziehungen, wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.'}, {'question': 'Wie werden :1-Beziehungen umgesetzt?', 'answer': ':1-Beziehungen können direkt durch benannte Instanzvariablen zwischen Objekten umgesetzt werden.'}, {'question': 'Wie werden :n-Beziehungen umgesetzt?', 'answer': ':n-Beziehungen werden meistens über Zwischenobjekte umgesetzt, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen.'}, {'question': 'Warum werden :n-Beziehungen über Zwischenobjekte umgesetzt?', 'answer': ':n-Beziehungen werden über Zwischenobjekte umgesetzt, da die indizierten Instanzvariablen eines Objekts nicht benannt sind und daher nicht zwischen verschiedenen :n-Beziehungen unterschieden werden kann'}, {'question': 'Was sind Zwischenobjekte?', 'answer': 'Die Aufgabe von Zwischenobjekten ist es, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Zwischenobjekte können zusätzliche Attribute enthalten, die in ihren benannten Instanzvariablen gespeichert werden.'}, {'question': 'Was ist die Teil-Ganzes-Beziehung?', 'answer': 'Die Teil-Ganzes-Beziehung bestimmt die Weltansicht, dass alles aus kleineren Teilen zusammengesetzt ist, die selbst wieder Zusammensetzungen (Aggregate, Komposita) sind, bis hinunter zu den elementaren, unteilbaren Bausteinen.'}, {'question': 'Warum ist die Teil-Ganzes-Beziehung komplixiert?', 'answer': 'Die Definition der Teil-Ganzes-Beziehung ist komplex, da es verschiedene Arten von Beziehungen zwischen einem Ganzen und seinen Teilen gibt, die je nach Art der Zusammensetzung unterschiedliche Wechselwirkungen aufweisen. Es existieren sowohl physische als auch logische Teil-Ganzes-Beziehungen, und diese Vielfalt macht es schwer, eine klare und einheitliche Definition zu finden.'}, {'question': 'Was bieten objektorientierten Programmiersprachen für die Teil-Ganzes-Beziehung?', 'answer': 'Die meisten objektorientierten Programmiersprachen bieten keine speziellen Sprachkonstrukte für die Teil-Ganzes-Beziehung. Stattdessen können Programmierer die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik nutzen, um eine bestimmte Form der Teil-Ganzes-Beziehung darzustellen. Bei Wertsemantik werden beim Entfernen eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt.'}, {'question': 'Warum ist die Teil-Ganzes-Beziehung in der objektorientierten Programmierung von Bedeutung?', 'answer': 'Die Teil-Ganzes-Beziehung ist in der objektorientierten Programmierung wichtig, da sie es ermöglicht, komplexe Software-Systeme aus Teilen aufzubauen, wobei jeder Teil seine eigene interne Struktur kapselt. Dies hilft dabei, sicherzustellen, dass keine Aliasnamen für Teile existieren und Änderungen an einem Teil nicht unabsichtlich andere Teile beeinflussen. Dieses Konzept ist entscheidend für die Entwicklung komplexer und intakter Software-Systeme.'}, {'question': 'Was ist der Unterschied zwischen veränderlichen und unveränderlichen Objekten?', 'answer': 'Veränderliche Objekte können ihren Zustand im Laufe der Zeit ändern, während unveränderliche Objekte keinen Zustand haben und ihre Werte konstant bleiben.'}, {'question': 'Was ist der Zustand eines Objekts?', 'answer': 'Der Zustand eines Objekts setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert.'}, {'question': 'Wie wird der Zustand eines Objekts verändern?', 'answer': 'Die einzige Möglichkeit, den Zustand eines Objekts zu ändern, besteht darin, die Werte seiner Instanzvariablen zuzuweisen, was gleichbedeutend mit der Änderung seiner Beziehungen ist.'}, {'question': 'Worauf lässt sich der Zustand eines Objekts eingrenzen?', 'answer': 'Der Zustand eines Objekts lässt sich in einer eingeschränkten Sicht auf seine Attributwerte eingrenzen.'}, {'question': 'Was ist der Unterschied zwischen Attributen und Beziehungen?', 'answer': 'Die Unterscheidung zwischen Attributen und Beziehungen kann in Ermangelung spezieller Schlüsselwörter allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese ist jedoch in einigen Programmiersprachen wie Java nicht immer eindeutig ist.'}, {'question': 'Warum ändert sich der Zustand eines Objekts nur über Instanzvariablen?', 'answer': 'Wenn Änderungen am Zustand eines Objekts, auf das ein anderes Objekt per Instanzvariable verweist, als Änderung des Zustands des ersten Objekts betrachtet würden, könnte jede Änderung an einem Objekt zu einer Kettenreaktion führen, da der Zustand aller Objekte, die darauf verweisen, sich ändern würde. Dies entspricht nicht unserem üblichen Verständnis von Zustand.'}, {'question': 'Warum ist der Zustandsbegriff nicht auf mehrere Objekte im Allgemeinen ausgedehnt?', 'answer': 'Der Zustandsbegriff kann nicht auf mehrere Objekte im Allgemeinen ausgedehnt werden, da dies zu komplexen Problemen führen würde und das objektorientierte Modell nicht ohne Herausforderungen ist. Programmierfehler könnten in vermeintlich simplen Situationen auftreten.'}, {'question': 'Wann ist es angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen?', 'answer': 'Es ist angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen, wenn es sich um Kompositionen handelt, also um aus Teilen zusammengesetzte Ganze.'}, {'question': 'Was sind Zuweisungsausdrücke?', 'answer': 'Zuweisungsausdrücke bestehen aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite. Sie bewirken den Zustandswechsel von Objekten und sind die einzigen Ausdrücke, die dies tun.'}, {'question': 'Welche Auswirkung haben Zuweisungsausdrücke auf Objekte?', 'answer': 'Zuweisungsausdrücke ändern den Zustand von Objekten, indem sie neue Werte in Variablen zuweisen.'}, {'question': 'Warum ist das Verhalten eines Objekts wichtig, wenn Objekte ihren Zustand kapseln?', 'answer': 'Das Verhalten eines Objekts ist wichtig, wenn Objekte ihren Zustand kapseln, weil das Verhalten dafür verantwortlich ist, den Zustand eines Objekts zu ändern und die Interaktion mit diesem Objekt zu steuern. Das Verhalten bestimmt, wie ein Objekt auf Nachrichten reagiert und welche Operationen es auf seinem internen Zustand durchführt.'}, {'question': 'Warum hängt das Verhalten eines Objekts in der Regel von seinem Zustand ab?', 'answer': 'Das Verhalten eines Objekts hängt in der Regel von seinem Zustand ab, weil der Zustand eines Objekts die Informationen enthält, die benötigt werden, um die richtigen Entscheidungen zu treffen und die entsprechenden Aktionen auszuführen. Das Verhalten eines Objekts basiert auf den Daten in seinem Zustand, und diese Daten beeinflussen, wie das Objekt auf Nachrichten reagiert.'}, {'question': 'Welche ist die zweite wichtige Ausdrucksform neben der Zuweisung?', 'answer': 'Die weite wichtige Ausdrucksform neben der Zuweisung in der objektorientierten Programmierung ist der Nachrichtenversand.'}, {'question': 'Was sind "unäre Nachrichten"?', 'answer': '"Unäre Nachrichten" sind parameterlose Nachrichten, die den Empfänger als implizites erstes Argument haben.'}, {'question': 'Was sind "binäre Nachrichten"?', 'answer': '"Binäre Nachrichten" sind Nachrichten mit einem Parameter, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.'}, {'question': 'Was sind Schlüsselwortnachrichten in SMALLTALK?', 'answer': 'Schlüsselwortnachrichten sind Nachrichten in SMALLTALK, die neben dem Empfänger mindestens ein Argument erfordern. Sie enthalten normalerweise kein herkömmliches Schlüsselwort im Sinne von Schlüsselwort-Argumenten, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.'}, {'question': 'Was ist ein Nachrichtenausdruck?', 'answer': 'Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.'}, {'question': 'Was ist die Kaskadierung in SMALLTALK?', 'answer': 'Die Kaskadierung ist eine syntaktische Abkürzung in SMALLTALK, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen. Dies erleichtert das Verketten von Nachrichten an dasselbe Objekt.'}, {'question': 'Ist die Reihenfolge der Nachrichtenteile in SMALLTALK von Bedeutung?', 'answer': 'Die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor bestimmt die Bedeutung der Nachricht. Der Nachrichtenselektor selbst ist ein Symbol, das aus der Konkatenation aller seiner Teile besteht.'}, {'question': 'Wie kann man sich ein laufendes objektorientiertes Programm vorstellen?', 'answer': 'Ein laufendes objektorientiertes Programm kann man sich als eine Menge interagierender Objekte vorstellen. Diese Objekte sind miteinander verbunden und bilden ein Geflecht von Beziehungen. Das Geflecht ändert sich dynamisch durch die Interaktion der Objekte, wobei bestimmte statische Strukturen durch das Programm vorgegeben sind.'}, {'question': 'Warum ist die Unterscheidung zwischen Statik und Dynamik in der Programmierung wichtig?', 'answer': 'Die Unterscheidung zwischen Statik und Dynamik ist wichtig, um das Verhalten von Programmen zu verstehen. Programme haben eine statische Struktur, die ihre Komponenten und ihre Beziehungen zueinander beschreibt. Diese Struktur kann als Grundlage für die Ausführung des Programms dienen. Auf der anderen Seite ist die Ausführung eines Programms immer dynamisch und kann sich im Laufe der Zeit ändern. Die Unterscheidung hilft dabei, die Beziehung zwischen der Programmstruktur und ihrem Verhalten zu verstehen.'}, {'question': 'Wie kann die Unterscheidung zwischen Struktur und Verhalten in der objektorientierten Programmierung angewendet werden?', 'answer': 'In der objektorientierten Programmierung kann die Unterscheidung zwischen Struktur und Verhalten angewendet werden, um die verschiedenen Aspekte eines Programms zu analysieren und zu gestalten. Die Struktur bezieht sich auf das Objektgeflecht und die Beziehungen zwischen den Objekten. Das Verhalten bezieht sich auf die Spezifikation der Änderungen, die im Verlauf der Programmausführung auftreten. Diese Unterscheidung kann bei der Analyse und Gestaltung von Programmen hilfreich sein, da sie ermöglicht, sich auf die Struktur und das Verhalten von Objekten und Klassen zu konzentrieren und diese getrennt zu behandeln.'}, {'question': 'Warum reichen Literale zum Programmieren nicht aus?', 'answer': 'Literale reichen zum Programmieren nicht aus, weil sie immer die gleichen Objekte repräsentieren.'}, {'question': 'Was sind Variablen?', 'answer': 'Variablen sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können.'}, {'question': 'Warum gibt es Variablen?', 'answer': 'Variablen sind notwendig, weil Literale immer die gleichen Objekte repräsentieren, weshalb sie zum Programmieren nicht ausreichen.'}, {'question': 'Was ist der Unterschied zwischen Variablen und Literale?', 'answer': 'Anders als bei Literalen wird aus einer Variable kein Objekt erzeugt, sie ist lediglich ein Name für ein bereits existierendes Objekt.'}, {'question': 'Wie ist die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK?', 'answer': 'Die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK wird durch Präzedenzen und Klammern festgelegt.'}, {'question': 'In welcher Reihenfolge werden Ausdrücke ausgewertet?', 'answer': 'In SMALLTALK werden Ausdrücke normalerweise von links nach rechts ausgewertet.'}, {'question': 'Welche Ausdrücke haben in SMALLTALK Vorrang?', 'answer': 'In SMALLTALK haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke haben Vorrang vor Schlüsselwortnachrichten.'}, {'question': 'Wie kann die Reihenfolge der Auswertung in SMALLTALK verändert werden?', 'answer': 'Um die Reihenfolge der Auswertung in SMALLTALK zu ändern, können Klammern verwendet werden, um sicherzustellen, dass bestimmte Teile eines Ausdrucks zuerst ausgewertet werden.'}, {'question': 'Warum stehen Objekte in Beziehung zueinander?', 'answer': 'Objekte stehen in Beziehung zueinander, um Bedeutung zu erlangen. Die meisten Objekte in einem System werden erst durch ihre Beziehungen zu anderen Objekten nützlich.'}, {'question': 'Wie werden Informationen dargestellt?', 'answer': 'In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt. Dieses Geflecht kann navigiert und manipuliert werden.'}, {'question': 'Wie wird das Geflecht von Objekten genutzt?', 'answer': 'Das Geflecht von Objekten kann navigiert werden, um von einem Datum zu einem anderen zu kommen, oder auch manipuliert werden, um die repräsentierte Information zu verändern.'}, {'question': 'Wie werden Beziehungen zwischen Objekten hergestellt?', 'answer': 'Beziehungen zwischen Objekten werden über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten "navigieren". Dabei ist zu beachten, dass diese Verknüpfung immer gerichtet ist und man nicht zwangsläufig wieder zurücknavigieren kann.'}, {'question': 'Wie werden Variablen für Beziehungen genutzt?', 'answer': 'Variablen enthalten Verweise. Wenn jemand Zugriff auf die Variable hat, kann er auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.'}, {'question': 'Was ist Aliasing?', 'answer': 'Aliasing bezieht sich auf die Situation, in der mehrere Variablen gleichzeitig auf dasselbe Objekt verweisen. Das bedeutet, dass ein Objekt mehrere Namen, Aliase, haben kann.'}, {'question': 'Wann entstehen Aliase?', 'answer': 'Aliase entstehen immer bei der Zuweisung, wenn die Variable auf der linken Seite Verweissemantik hat.'}, {'question': 'Warum kann das Aliasing erwünscht sein?', 'answer': 'Aliasing ist zunächst erwünscht, da es die Effizienz der Informationsverarbeitung erhöht. Es ermöglicht das Teilen von Objekten ohne Kopieren.'}, {'question': 'Warum kann Aliasing zu Programmierfehlern führen?', 'answer': 'Aliasing kann zu Programmierfehlern führen, weil Änderungen an einem Objekt, das durch eine Variable bezeichnet wird, sich auf alle Aliase dieses Objekts auswirken. Unerwartete Veränderungen an einem Alias können schwer zu erkennen und zu debuggen sein.'}, {'question': 'Wie werden in SMALLTALK Programmierfehler durch Aliasing verhindert?', 'answer': 'Um Programmierfehler durch Aliasing in SMALLTALK zu verhindern, werden auf Basis literaler Repräsentationen erzeugte Objekte als unveränderlich markiert. Wenn eine Zuweisung mit Wertsemantik benötigt wird, kann das Kopieren des Objekts verwendet werden.'}, {'question': 'Was macht "copy" in SMALLTALK?', 'answer': 'In SMALLTALK kann das Schlüsselwort "copy" verwendet werden, um von einem Objekt eine Kopie anzufertigen, anstatt eine Referenz auf dasselbe Objekt zu erstellen. Dies verhindert Aliasing.'}, {'question': 'Was ist wichtig in Bezug auf Aliase?', 'answer': 'Es ist wichtig, sich der aliasbildenden Wirkung der Zuweisung bewusst zu sein, da dies in Sprachen wie SMALLTALK der Regelfall ist.'}]
