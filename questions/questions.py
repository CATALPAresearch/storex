"""
Questions sorted into open questions and question-answer pairs per course unit.
"""

KE1_topics = {'question': "Was ist das Grundkonzept der objektorientierten Programmierung?",
              'keywords': ["Objekt", "Beziehung", "Zustand", "Verhalten"]}

KE2_topics = {'question': "Mittels welcher Konzepte lassen sich objektorientierte Programme strukturieren?",
              'keywords': ["Klasse", "Generalisierung", "Spezialisierung", "Vererbung", "dynamisch Binden"]}

KE3_topics = {'question': "Was sind Typen in der objektorientierten Programmierung?",
              'keywords': ["Typdefinition", "Zuweisungskompatibilität", "Subtyp", "Inklusionspolymorphie",
                           "parametrischer Polymorphismus", "Typisierung"]}

KE4_topics = {'question': "Was sind die Besonderheiten einier Programmiermodelle?",  # Java, C-Sharp, C++, EIFFEL
              'keywords': ["Interface", "Generischer Typ", "Mehrfachvererbung"]}

KE6_topics = {'question': "Was sind Probleme der objektorientierten Programmierung?",
              'keywords': ["Problem der Substituierbarkeit",
                           "Fragile-base-class-Problem",
                           "Problem der schlechten Tracebarkeit",
                           "Problem der eindimensionalen Strukturierung",
                           "Problem der mangelnden Kapselung",
                           "Problem der mangelnden Skalierbarkeit",
                           "Problem der mangelnden Eignung"]}

KE1_questions = [
    [{'question': 'Was ist ein Literal?', 'answer': 'Ein Literal ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten.'},
     {'question': 'Was sind die einfachsten Literale in SMALLTALK?', 'answer': 'Die einfachsten Literale in SMALLTALK repräsentieren Zeichenobjekte.'},
     {'question': 'Was sind atomare Objekte?', 'answer': 'Atomare Objekte sind Zeichenobjekte und Zahlobjekte, die nicht aus anderen Objekten bestehen.'},
     {'question': 'Was sind Pseudo-Variablen in SMALLTALK?', 'answer': 'In SMALLTALK sind die in anderen Programmiersprachen vorhandenen Literale, die ebenfalls atomare Objekte repräsentieren, Pseudo-Variablen.'},
     {'question': 'Was sind Strings?', 'answer': 'Strings sind aus Zeichen zusammengesetzte Zeichenketten. String-Literale repräsentieren also zusammengesetzte Objekte.'},
     {'question': 'Was sind Symbole in SMALLTALK?', 'answer': 'Symbole sind eine weitere Art von Objekten mit literaler Repräsentation in SMALLTALK. Sie dienen dazu, sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen.'},
     {'question': 'Was sind Array-Literale in SMALLTALK ?', 'answer': 'Array-Literale repräsentieren Objekte, die aus einer Folge beliebiger anderer Objekte bestehen.'},
     {'question': 'Was sind unveränderliche Objekte?', 'answer': 'Unveränderliche oder zustandslose Objekte in SMALLTALK sind Objekte, deren Zustand nicht geändert werden kann. Operationen oder Methoden, die auf solchen Objekten ausgeführt werden, ändern nicht den Zustand des Objekts selbst, sondern erzeugen in der Regel ein neues Objekt als Ergebnis.'},
     {'question': 'Was ist die Gleichheit von Objekten?', 'answer': 'Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten und wird in SMALLTALK durch den Gleichheitsoperator getestet.'},
     {'question': 'Was ist die Identität von Objekten?', 'answer': 'Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren.'},
     {'question': 'Was sind reservierte Namen in SMALLTALK?', 'answer': 'In SMALLTALK gibt es einige reservierte Namen, die als Pseudovariablen dienen. Diese reservierten Namen sind: true, false, nil, self and super. Alle anderen Schlüsselwörter, die in anderen Programmiersprachen üblich sind, werden in SMALLTALK als Methoden definiert.'},
     {'question': 'Was sind anonyme Funktionen?', 'answer': 'Blöcke in SMALLTALK können auch als anonyme Funktionen aufgefasst werden.'},
     {'question': 'Was sind parametrisierten Blöcke?', 'answer': 'Parametrisierte Blöcke können mit Parametern versehen werden, die bei ihrer Auswertung an Objekte aus dem Auswertungskontext gebunden werden können.'},
     {'question': 'Was ist der Home Context eines Blocks in SMALLTALK?', 'answer': 'Der Home Context eines Blocks in SMALLTALK ist der Kontext, in dem der Block definiert wurde oder genauer gesagt, in dem das ihn repräsentierende Objekt erzeugt wurde. Dieser Kontext enthält Informationen über die lokalen Variablen und formalen Parameter, die der Block "einfängt". Die Ausführung eines Blocks erfolgt immer in seinem Home Context, selbst wenn der Block in einem anderen Kontext ausgewertet wird.'},
     {'question': 'Was sind Closures?', 'answer': 'Closures sind in SMALLTALK Blöcke für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können.'},
     {'question': 'Was sind Blöcke?', 'answer': 'Blöcke in SMALLTALK werden in anderen Programmiersprachen oft als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, die anonyme Funktionen repräsentieren und als Objekte oder Werte behandelt werden können. Closures erlauben es, Funktionen aus ihrem Kontext herauszulösen und in andere Kontexte zu übertragen. Die Verwendung und das Verhalten von Closures können sich jedoch zwischen verschiedenen Programmiersprachen erheblich unterscheiden.'},
     {'question': 'Was sind Attribute?', 'answer': 'Attribute sind Instanzvariablen, die die Eigenschaften eines Objekts festhalten.'},
     {'question': 'Was sind die beiden Kategorien von Instanzvariablen?', 'answer': 'Instanzvariablen können logischerweise in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Eigenschaften sind Attribute wie Farbe oder Name, die ihre Bedeutung verlieren, wenn sie isoliert betrachtet werden. Beziehungen hingegen repräsentieren Verbindungen zwischen Objekten und behalten ihre Bedeutung auch isoliert betrachtet.'},
     {'question': 'Welche Semantik haben Variablen, die Attribute repräsentieren?', 'answer': 'Variablen, die Attribute repräsentieren, haben in der Regel eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Dies ermöglicht es, dass Änderungen an einem Attributwert nicht automatisch andere Objekte mit dem gleichen Attributwert beeinflussen.'},
     {'question': 'Welche Objekte sind in SMALLTALK veränderbar?', 'answer': 'Atomare Objekte und Objekte, die aus Symbolliteralen hervorgegangen sind, sind grundsätzlich nicht veränderbar. Zusammengesetzte Objekte in SMALLTALK sind jedoch veränderbar.'},
     {'question': 'Was sind Kontrollstrukturen?', 'answer': 'Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, die seine Ausführung bestimmen. In SMALLTALK gibt es ie Sequenz und den dynamisch gebundenen Methodenaufruf.'},
     {'question': 'Welche Kontrollstrukturen gibt es in SMALLTALK?', 'answer': 'In SMALLTALK gibt es nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf.'},
     {'question': 'Was ist eine Zuweisung?', 'answer': 'Eine Zuweisung ist der Vorgang, bei dem einer Variable ein Objekt zugewiesen wird, damit sie dieses Objekt bezeichnet.'},
     {'question': 'Was ist ein Block in SMALLTALK?', 'answer': 'Ein Block in SMALLTALK ist eine abgegrenzte Sequenz oder Folge von Anweisungen. Anders als eine Methode ist ein Block nicht benannt, kann aber einer Variable zugewiesen werden.'},
     {'question': 'Was sind Instanzvariablen?', 'answer': 'Instanzvariablen sind lokale Variablen, die einem Objekt zugeordnet sind und dazu verwendet werden, Informationen zu speichern, die spezifisch für dieses Objekt sind. Sie bestimmen die Struktur zusammengesetzter Objekte.'},
     {'question': 'Welche zwei Arten von Instanzvariablen werden in SMALLTALK unterschieden?', 'answer': 'In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte Instanzvariablen.'},
     {'question': 'Was sind benannte Instanzvariablen in SMALLTALK?', 'answer': 'Benannte Instanzvariablen sind Instanzvariablen, die jeweils auf ein bestimmtes Objekt verweisen oder es benennen. Der Name der Variablen wird zum Namen des Objekts, auf das sie verweisen.'},
     {'question': 'Was sind indizierte Instanzvariablen in SMALLTALK?', 'answer': 'Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zum Objekt angesprochen, dem sie gehören. Der Index fungiert gewissermaßen als Name für die Instanzvariable.'},
     {'question': 'Welche Arten von Ausdrücken gibt es?', 'answer': 'Es gibt Literale, Variablen, Zuweisungsausdrücke und Nachrichtenausdrücke.'},
     {'question': 'Was sind primitive Ausdrücke?', 'answer': 'Primitive Ausdrücke sind nicht aus anderen Ausdrücken zusammengesetzt, wie Literale und Variablen.'},
     {'question': 'Welche zwei Ausdrücke ermöglichen die Programmausführung?', 'answer': 'Zuweisungsausdrücke und Nachrichtenausdrücke sind wichtig. Sie ermöglichen es, Aktionen mit den repräsentierten Objekten auszuführen und damit ein Programm tatsächlich auszuführen.'},
     {'question': 'Was sind Anweisungen?', 'answer': 'Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird.'},
     {'question': 'Was sind primitive Methoden?', 'answer': 'Primitive Methoden sind primitive Operationen, die auf native Implementierungen zurückgreifen. Diese Methoden sind durch Nummern identifiziert und sollen nicht direkt von Programmierern verwendet werden.'},
     {'question': 'Was ist der Lebenslauf eines Objekts in SMALLTALK?', 'answer': 'In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung.'},
     {'question': 'Was ist die "Garbage Collection" in SMALLTALK?', 'answer': 'Die "Garbage Collection" ist ein Mechanismus in SMALLTALK, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr über Variablen zugreifbar sind.'},
     {'question': 'Welche Objekte sind von der automatischen Speicherbereinigung ausgenommen?', 'answer': 'Von der automatischen Speicherbereinigung ausgenommen sind Objekte mit eindeutiger literaler Repräsentation, wie kleine Zahlen, Zeichen und Symbole. Zahlen und Zeichen werden durch Werte in Variablen repräsentiert und Symbole sind in einer Symboltabelle abgelegt.'},
     {'question': 'Was ist ein Methodenaufruf?', 'answer': 'Ein Methodenaufruf ist die Auswertung eines Nachrichtenausdrucks, da diese zur Ausführung der Anweisungen im Rumpf einer Methode führt.'},
     {'question': 'Was sind Objekte in der objektorientierten Programmierung?', 'answer': 'Objekte sind in der objektorientierten Programmierung Daten, die im Speicher abgelegt sind und in der Lage sind, Informationen zu speichern und Aktionen auszuführen. Sie repräsentieren Dinge aus der realen Welt und können miteinander in Beziehung stehen.'},
     {'question': 'Was sind Pseudovariablen in SMALLTALK?', 'answer': 'Pseudovariablen in SMALLTALK sind Variablen wie "true", "false", "nil", "self", "super" und formale Parameter von Methoden sowie Klassennamen, denen der Programmierer keinen Wert zuweisen kann.'},
     {'question': 'Was ist der "Inhalt" einer Variable?', 'answer': 'Der "Inhalt" einer Variable bezieht sich auf das Objekt, das von der Variable bezeichnet wird.'},
     {'question': 'Was ist Verweis- oder Referenzsemantik?', 'answer': 'Bei Verweis- oder Referenzsemantik haben Variablen nur Verweise die Speicherstellen, an denen die Objekte abgelegt sind.'},
     {'question': 'Was ist Wertsemantik?', 'answer': 'Bei Wertsemantik macht das bezeichnete Objekt tatsächlich den Inhalt der Variable aus.'},
     {'question': 'Was ist eine Variable aus technischer Sicht?', 'answer': 'Aus technischer Sicht entspricht eine Variable einer Stelle im Speicher.'},
     {'question': 'Was sind Variablen mit Verweissemantik?', 'answer': 'Es handelt sich bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen.'},
     {'question': 'Welche Variablen haben in SMALLTALK Wertsemantik?', 'answer': 'In den meisten SMALLTALK-Implementationen haben Variablen, die Zeichen, kleine Zahlen und boolesche Werte bezeichnen, Wertsemantik, um Speicherplatz zu sparen, obwohl der Begriff der Identität für diese Objekte verloren geht. Die mehrfache Existenz identischer Objekte im Speicher hat in der Regel keine große Bedeutung, da Gleichheit an die Stelle der Identität treten kann.'},
     {'question': 'Was ist eine Continuation im Kontext von Blöcken?', 'answer': 'Im Kontext von Blöcken in SMALLTALK bezieht sich "Continuation" auf das Konzept, dass eine Return-Anweisung innerhalb eines Blocks immer zur unmittelbaren Rückkehr in den Home Context des Blocks führt.'},
     {'question': 'Was ist das Geheimnisprinzip?', 'answer': 'Das Geheimnisprinzip oder Information Hiding bezieht sich auf das Verbergen von Implementationsdetails eines Objekts, insbesondere der Struktur zusammengesetzter Objekte, vor den Objekten, die sie verwenden. Dadurch können Änderungen an der Struktur vorgenommen werden, ohne dass abhängige Objekte davon betroffen sind.'},
     {'question': 'Was ist Kapselung?', 'answer': 'Bei der Kapselung geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann.'},
     {'question': 'Was sind Zugriffsmethoden?', 'answer': 'Zugriffsmethoden sind Methoden, um die Belegung der Instanzvariablen und damit den Zustand eines Objekts auszulesen oder zu verändern. In Java gibt es dafür Getter und Setter.'},
     {'question': 'Was ist das Interface eines Objekts?', 'answer': 'Das Interface eines Objekts ist die Art und Weise, wie ein Objekt seinen Zustand codiert, als sein Implementationsgeheimnis und die Menge der Methodensignaturen, die den Zugriff auf das Objekt (seinen Zustand) erlauben.'},
     {'question': 'Was sind Schlüsselwörter?', 'answer': 'In Programmiersprachen wie PASCAL, C oder Java repräsentieren Schlüsselwörter Kontrollstrukturen.'},
     {'question': 'Welche Kontrollstrukturen kennen Sie?', 'answer': 'Die grundlegenden Kontrollstrukturen sind: Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf.'},
     {'question': 'Was sind Kardinalitäten?', 'answer': 'Kardinalitäten sind in der Daten- und Softwaremodellierung häufig verwendete Beziehungsattribute, die angeben, wie viele andere Objekte ein Objekt in einer Beziehung haben kann.'},
     {'question': 'Welche Beziehungen gibt es?', 'answer': 'Es gibt Zu-1-Beziehungen und Zu-n-Beziehungen wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.'},
     {'question': 'Was sind Zwischenobjekte?', 'answer': 'Die Aufgabe von Zwischenobjekten ist es, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Zwischenobjekte können zusätzliche Attribute enthalten, die in ihren benannten Instanzvariablen gespeichert werden.'},
     {'question': 'Was ist das Protokoll eines Objekts?', 'answer': 'Das Protokoll eines Objekts ist der Katalog von Methoden, über den ein Objekt verfügt und auf den es entsprechend reagieren kann.'},
     {'question': 'Was ist die Teil-Ganzes-Beziehung?', 'answer': 'Die Teil-Ganzes-Beziehung bestimmt die Weltansicht, dass alles aus kleineren Teilen zusammengesetzt ist, die selbst wieder Zusammensetzungen (Aggregate, Komposita) sind, bis hinunter zu den elementaren, unteilbaren Bausteinen.'},
     {'question': 'Was sind konstante Methoden?', 'answer': 'Konstante Methoden sind Methoden, die immer dasselbe Objekt zurückgeben. Sie werden häufig verwendet, um Literale auf eine Weise zu repräsentieren, die sicherstellt, dass sie konsistent sind und immer auf dasselbe Objekt verweisen.'},
     {'question': 'Was sind Zuweisungsausdrücke?', 'answer': 'Zuweisungsausdrücke bestehen aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite. Sie bewirken den Zustandswechsel von Objekten und sind die einzigen Ausdrücke, die dies tun.'},
     {'question': 'Welche Auswirkung haben Zuweisungsausdrücke auf Objekte?', 'answer': 'Zuweisungsausdrücke ändern den Zustand von Objekten, indem sie neue Werte in Variablen zuweisen.'},
     {'question': 'Welche wichtigen Ausdrucksform können Sie nennen?', 'answer': 'Die Zuweisung und der Nachrichtenversand sind wichtige Ausdrucksformen.'},
     {'question': 'Was sind unäre Nachrichten?', 'answer': 'Unäre Nachrichten sind parameterlose Nachrichten, die den Empfänger als implizites erstes Argument haben.'},
     {'question': 'Was sind binäre Nachrichten?', 'answer': 'Binäre Nachrichten sind Nachrichten mit einem Parameter, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.'},
     {'question': 'Was sind Schlüsselwortnachrichten in SMALLTALK?', 'answer': 'Schlüsselwortnachrichten sind Nachrichten in SMALLTALK, die neben dem Empfänger mindestens ein Argument erfordern. Sie enthalten normalerweise kein herkömmliches Schlüsselwort im Sinne von Schlüsselwort-Argumenten, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.'},
     {'question': 'Was ist ein Nachrichtenausdruck?', 'answer': 'Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.'},
     {'question': 'Was ist die Kaskadierung in SMALLTALK?', 'answer': 'Die Kaskadierung ist eine syntaktische Abkürzung in SMALLTALK, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen. Dies erleichtert das Verketten von Nachrichten an dasselbe Objekt.'},
     {'question': 'Was ist das Protokoll in SMALLTALK?', 'answer': 'In SMALLTALK ist das Protokoll eines Objekts die Menge der Nachrichten, die es versteht. Es wird in Form der Protokollbeschreibung spezifiziert und besteht aus den Methodensignaturen und den dazugehörigen Kommentaren der Methoden. Das Protokoll beschreibt das Interface eines Objekts.'},
     {'question': 'Was ist dynamisches Binden?', 'answer': 'Dynamisches Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung, bei der die Auswahl der Methodenimplementierung erst zur Laufzeit erfolgt, abhängig vom Empfängerobjekt des Methodenaufrufs. Dies wird auch als Polymorphismus oder Polymorphie bezeichnet.'},
     {'question': 'Was ist statisches Binden?', 'answer': 'Bei statischem Binden wird ein Methodenaufruf schon zur Übersetzungszeit an eine Implementierung gebunden.'},
     {'question': 'Was sind Variablen?', 'answer': 'Variablen sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können.'},
     {'question': 'Welche Ausdrücke haben in SMALLTALK Vorrang?', 'answer': 'In SMALLTALK haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke haben Vorrang vor Schlüsselwortnachrichten.'},
     {'question': 'Was ist eine Methode?', 'answer': 'Eine Methode beschreibt, was ein Objekt in Reaktion auf den Erhalt einer bestimmten Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf (Methodensignatur), einer optionalen Liste von lokalen Variablen und einem Methodenrumpf, der die Anweisungen für die Ausführung der Methode enthält.'},
     {'question': 'Was ist eine Methodensignatur?', 'answer': 'Eine Methodensignatur beschreibt, welche Parameter eine Methode erwartet und wie sie in SMALLTALK aufgerufen wird. Sie besteht aus dem Methodennamen und der Liste der formalen Parameter.'},
     {'question': 'Was ist ein Nachrichtenselektor?', 'answer': 'Ein Nachrichtenselektor ist Teil eines Nachrichtenausdrucks und gibt an, welche Methode auf dem Empfängerobjekt aufgerufen werden soll.'},
     {'question': 'Was sind Methodenrümpfe?', 'answer': 'Methodenrümpfe bestehen aus einer Folge von Anweisungen.'},
     {'question': 'Welche Funktion hat die Return-Anweisung?', 'answer': 'Die Return-Anweisung ermöglicht eine explizite Beendigung der Methode und die Rückgabe eines anderen Objekts als des Empfängers. Die Return-Anweisung kann an beliebigen Stellen innerhalb der Methode auftreten und beeinflusst den Kontrollfluss des Programms.'},
     {'question': 'Was sind temporäre Variablen?', 'answer': 'Eine Methode kann temporäre Variablen für ihre Berechnungen benötigen. Temporäre Variablen existieren nur für die Dauer der Ausführung der Methode und werden vom System nach Beendigung der Methode entfernt. Die Werte sind außerhalb der Methode nicht sichtbar. Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben.'},
     {'question': 'Was sind Methoden?', 'answer': 'Methoden sind die Einheiten des Programms, in denen die Anweisungen untergebracht sind.'},
     {'question': 'Was ist Aliasing?', 'answer': 'Aliasing bezieht sich auf die Situation, in der mehrere Variablen gleichzeitig auf dasselbe Objekt verweisen. Das bedeutet, dass ein Objekt mehrere Namen, Aliase, haben kann.'},
     {'question': 'Was ist wichtig im Umgang mit Aliasen?', 'answer': 'Es ist wichtig, sich der aliasbildenden Wirkung der Zuweisung bewusst zu sein, da dies in Sprachen wie SMALLTALK der Regelfall ist.'}
     ],
    [{'question': 'Wie werden Verzweigungen und Wiederholungen in SMALLTALK simuliert?', 'answer': 'Verzweigungen und Wiederholungen in SMALLTALK werden durch die Verwendung von Blöcken und dynamisch gebundenen Methodenaufrufen simuliert. Da SMALLTALK keine direkten Verzweigungs- und Schleifenkonstrukte wie in einigen anderen Programmiersprachen hat, werden Entscheidungen und Wiederholungen durch den Aufruf entsprechender Methoden und die Auswertung von Blöcken erreicht.'},
     {'question': 'Wie sendet man Nachrichten in Zu-1-Beziehungen?', 'answer': 'In Zu-1-Beziehungen in SMALLTALK sendet man oft Nachrichten direkt an das Objekt, auf das die betreffende Variable verweist.'},
     {'question': 'Wie sendet man Nachrichten in Zu-n-Beziehungen?', 'answer': 'Bei Zu-n-Beziehungen erreicht die Nachricht nicht mehr die logisch in Beziehung stehenden Objekte, sondern das Zwischenobjekt, das die Beziehung selbst repräsentiert (der Wert der Variable). Um die Nachricht stattdessen an alle von diesem Zwischenobjekt referenzierten Objekte zu senden, verwendet man die Nachricht do: aBlock, wobei aBlock ein Block ist, der mit einem Parameter parametrisiert ist und der für jedes Element des Arrays genau einmal (mit dem Element als tatsächlichem Parameter) aufgerufen wird.'},
     {'question': 'Wie kann eine Sequenz unterbrochen werden?', 'answer': 'In SMALLTALK kann die zeitliche Sequenz von aufeinanderfolgenden Anweisungen nur durch den Methodenaufruf unterbrochen werden.'},
     {'question': 'Wann kann ein Objekt aus dem Speicher entfernt werden?', 'answer': 'Ein Objekt kann aus dem Speicher entfernt werden, wenn keine Variable mehr auf dieses Objekt verweist und es somit nicht mehr erreichbar ist.'},
     {'question': 'Wie werden Nachrichtenausdrücke in SMALLTALK ausgewertet?', 'answer': 'Nachrichtenausdrücke in SMALLTALK werden ausgewertet, indem die Nachricht (das Prädikat) an das Empfängerobjekt (das Subjekt) mit den Parametern (Prädikatsergänzungen) gesendet wird. Nach der Auswertung repräsentiert der Nachrichtenausdruck das Ergebnis der Nachricht, das von dem Empfängerobjekt zurückgegeben wird.'},
     {'question': 'Wie lässt sich der Zugriff auf Variablen einschränken?', 'answer': 'Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen.'},
     {'question': 'Wie wird die Iteration in SMALLTALK realisiert?', 'answer': 'Die Iteration in SMALLTALK erfolgt durch eine Form der internen Iteration, bei der die Steuerstruktur für das Fortschreiten durch Elemente und die Überprüfung der Abbruchbedingung innerhalb der Sammlung erfolgt, über die iteriert wird.'},
     {'question': 'Wie wird die Kapselung in SMALLTALK umgesetzt?', 'answer': 'Über lokale Instanzvariablen kann ein Objekt verbergen, welche Objekte es kennt. Aber aufgrund von Aliasing kann ein Objekt, dessen Name unsichtbar ist, über einen anderen Namen zugänglich sein kann.'},
     {'question': 'Wie ist die Sichtbarkeit von Instanzvariablen in SMALLTALK?', 'answer': 'In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar, um den Zustand des Objekts zu kapseln und seine Struktur vor direktem Zugriff von außen zu schützen.'},
     {'question': 'Wie werden Zu-1-Beziehungen umgesetzt?', 'answer': 'Zu-1-Beziehungen können direkt durch benannte Instanzvariablen zwischen Objekten umgesetzt werden.'},
     {'question': 'Wie werden Zu-n-Beziehungen umgesetzt?', 'answer': 'Zu-n-Beziehungen werden meistens über Zwischenobjekte umgesetzt, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen.'},
     {'question': 'Wie wird der Zustand eines Objekts verändern?', 'answer': 'Die einzige Möglichkeit, den Zustand eines Objekts zu ändern, besteht darin, die Werte seiner Instanzvariablen zuzuweisen, was gleichbedeutend mit der Änderung seiner Beziehungen ist.'},
     {'question': 'Wann ist es angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen?', 'answer': 'Es ist angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen, wenn es sich um Kompositionen handelt, also um aus Teilen zusammengesetzte Ganze.'},
     {'question': 'Wie werden Protokolle in SMALLTALK spezifiziert?', 'answer': 'In SMALLTALK werden Protokolle nicht auf Objektebene, sondern auf Klassenebene spezifiziert. Dies bedeutet, dass eine Klasse ein bestimmtes Protokoll implementiert und die Objekte dieser Klasse dieses Protokoll erben. In STRONGTALK, einer Erweiterung von SMALLTALK, werden Protokolle zu Typen erhoben und ähneln Interfaces in Java.'},
     {'question': 'Wie wird ein Nachrichtenausdruck in SMALLTALK übersetzt?', 'answer': 'Ein Nachrichtenausdruck wird in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung vergleichbar ist.'},
     {'question': 'Wie erfolgt die Zuweisung der formalen Parameter in einer Methode?', 'answer': 'Die Zuweisung der formalen Parameter erfolgt in einer Methode durch eine implizite Zuweisung der tatsächlichen Parameter des Methodenaufrufs an die formalen Parameter der Methode.'},
     {'question': 'Wie ist die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK?', 'answer': 'Die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK wird durch Präzedenzen und Klammern festgelegt.'},
     {'question': 'Wie werden Informationen in der objektorientierten Programmierung dargestellt?', 'answer': 'In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt. Dieses Geflecht kann navigiert und manipuliert werden.'},
     {'question': 'Wie werden Beziehungen zwischen Objekten hergestellt?', 'answer': 'Beziehungen zwischen Objekten werden über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten "navigieren". Dabei ist zu beachten, dass diese Verknüpfung immer gerichtet ist und man nicht zwangsläufig wieder zurücknavigieren kann.'},
     {'question': 'Wie werden Variablen für Beziehungen genutzt?', 'answer': 'Variablen enthalten Verweise. Wenn jemand Zugriff auf die Variable hat, kann er auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.'},
     {'question': 'Wie wird die Ausführung einer Methode beendet?', 'answer': 'Die Ausführung einer Methode wird standardmäßig nach Abarbeitung der letzten Anweisung mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung da.'},
     {'question': 'Wie werden Methoden in SMALLTALK gespeichert?', 'answer': 'Methoden werden in SMALLTALK nicht in Dateien gespeichert, sondern in einer Datenstruktur von SMALLTALK, nämlich in Form von Objekten. Dies bedeutet, dass der Großteil eines jeden SMALLTALK-Programms aus Methodendefinitionen besteht, die im SMALLTALK-System als Objekte gespeichert sind.'},
     {'question': 'Wann entstehen Aliase?', 'answer': 'Aliase entstehen immer bei der Zuweisung, wenn die Variable auf der linken Seite Verweissemantik hat.'},
     {'question': 'Wie werden in SMALLTALK Programmierfehler durch Aliasing verhindert?', 'answer': 'Um Programmierfehler durch Aliasing in SMALLTALK zu verhindern, werden auf Basis literaler Repräsentationen erzeugte Objekte als unveränderlich markiert. Wenn eine Zuweisung mit Wertsemantik benötigt wird, kann das Kopieren des Objekts verwendet werden.'},
     {'question': 'Wie wird die Wiederholungen (Schleifen) in SMALLTALK realisiert?', 'answer': 'In SMALLTALK wird die Implementierung von Wiederholungen (Schleifen) durch Endrekursion simuliert. Dabei wird eine Methode wie whileTrue: am Ende selbst wieder aufgerufen. Der Schleifenrumpf wird durch einen Block dargestellt, und das Abbruchkriterium wird ebenfalls in einem Block ausgewertet. Der rekursive Aufruf am Ende der Methode kann vom Compiler in eine echte Schleife übersetzt werden.'},
     {'question': 'Wie ist die Sichtbarkeit von Instanzvariablen in SMALLTALK begrenzt?', 'answer': 'Die Sichtbarkeit von Instanzvariablen in SMALLTALK ist auf das besitzende Objekt beschränkt. Instanzvariablen können von anderen Objekten nicht direkt zugegriffen werden.'},
     {'question': 'Warum sind Literale keine Objekte?', 'answer': 'Literale repräsentieren Objekte, sind jedoch selbst keine Objekte, da sie textuelle Spezifikationen von Objekten sind.'},
     {'question': 'Warum können syntaktisch gleiche String-Literale in SMALLTALK unterschiedliche Identitäten haben?', 'answer': 'Syntaktisch gleiche String-Literale können in SMALLTALK unterschiedliche Identitäten haben, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen.'},
     {'question': 'Warum ist die Identität von Objekten wichtig?', 'answer': 'Die Identität von Objekten ist wichtig, um festzustellen, ob zwei Namen oder Variablen dasselbe Objekt repräsentieren oder nicht.'},
     {'question': 'Warum haben unveränderliche Objekte eine Identität?', 'answer': 'Unveränderliche Objekte haben aus technischen Gründen eine Identität. Wenn sich ein unveränderliches Objekt aus einer Operation ergibt, dann müsste für eine Zusammenlegung gleicher Objekte zu einem immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Ganze Zahlen bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind.'},
     {'question': 'Warum können zusammengesetzte Objekte veränderbar sein?', 'answer': 'Zusammengesetzte Objekte könnten veränderbar sein, da es sinnvoll sein kann, eine Komponente durch eine andere zu ersetzen.'},
     {'question': 'Warum wurde in SMALLTALK die explizite Speicherfreigabe aufgegeben?', 'answer': 'Die explizite Speicherfreigabe wurde in SMALLTALK aufgegeben, da es schwierig ist, genau zu verfolgen, welche Objekte noch referenziert werden, insbesondere in großen und komplexen Programmen. Die Verantwortung dafür den Anwendungsprogrammierern zu überlassen, würde zu vielen potenziellen Programmierfehlern führen.'},
     {'question': 'Warum haben Objekte im Speicher eine konstante Größe?', 'answer': 'Objekte im Speicher haben eine feste Größe, die aus technischen Gründen nicht verändert werden kann. Wenn ein Objekt mehr Platz benötigt oder verkleinert werden muss, muss ein neues Objekt erzeugt werden, das an die Stelle des alten tritt. Dieses neue Objekt hat jedoch eine andere Identität.'},
     {'question': 'Warum ist die Zuweisung für Pseudovariablen in SMALLTALK nicht zulässig?', 'answer': 'Die Zuweisung für Pseudovariablen ist in SMALLTALK nicht zulässig, da sie auf Objekte von spezifischer Bedeutung verweisen und diese Bedeutung nicht verändert werden sollte.'},
     {'question': 'Warum wird in der objektorientierten Programmierung häufig Verweissemantik verwendet?', 'answer': 'Verweissemantik wird in der objektorientierten Programmierung häufig verwendet, da sie einen speicher- und recheneffizienten Umgang mit Objekten ermöglicht und unterschiedliche Objekte unterschiedlich viel Speicherplatz belegen.'},
     {'question': 'Warum können Continuations zu Laufzeitfehlern führen?', 'answer': 'Continuations können zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde. Return-Anweisungen in Blöcken sind daher ein umstrittenes Konzept.'},
     {'question': 'Warum kann ein Objekt seinen inneren Aufbau nicht kapseln?', 'answer': 'Ein Objekt kann seinen inneren Aufbau nicht vollständig vor der Außenwelt abkapseln, da aufgrund der möglichen Existenz von Aliasen andere Objekte diese Objekte kennen und ohne sein Wissen manipulieren können. Die Abschottung erfordert spezielle Vorkehrungen, die derzeit nicht in gängige objektorientierte Programmiersprachen integriert sind und explizit programmiert werden müssen.'},
     {'question': 'Warum werden Zu-n-Beziehungen über Zwischenobjekte umgesetzt?', 'answer': 'Zu-n-Beziehungen werden über Zwischenobjekte umgesetzt, da die indizierten Instanzvariablen eines Objekts nicht benannt sind und daher nicht zwischen verschiedenen Zu-n-Beziehungen unterschieden werden kann'},
     {'question': 'Warum ist die Teil-Ganzes-Beziehung kompliziert?', 'answer': 'Die Definition der Teil-Ganzes-Beziehung ist komplex, da es verschiedene Arten von Beziehungen zwischen einem Ganzen und seinen Teilen gibt, die je nach Art der Zusammensetzung unterschiedliche Wechselwirkungen aufweisen. Es existieren sowohl physische als auch logische Teil-Ganzes-Beziehungen, und diese Vielfalt macht es schwer, eine klare und einheitliche Definition zu finden.'},
     {'question': 'Warum ist die Teil-Ganzes-Beziehung in der objektorientierten Programmierung von Bedeutung?', 'answer': 'Die Teil-Ganzes-Beziehung ist in der objektorientierten Programmierung wichtig, da sie es ermöglicht, komplexe Software-Systeme aus Teilen aufzubauen, wobei jeder Teil seine eigene interne Struktur kapselt. Dies hilft dabei, sicherzustellen, dass keine Aliasnamen für Teile existieren und Änderungen an einem Teil nicht unabsichtlich andere Teile beeinflussen. Dieses Konzept ist entscheidend für die Entwicklung komplexer und intakter Software-Systeme.'},
     {'question': 'Warum ändert sich der Zustand eines Objekts nur über seine Instanzvariablen?', 'answer': 'Wenn Änderungen am Zustand eines Objekts, auf das ein anderes Objekt per Instanzvariable verweist, als Änderung des Zustands des ersten Objekts betrachtet würden, könnte jede Änderung an einem Objekt zu einer Kettenreaktion führen, da der Zustand aller Objekte, die darauf verweisen, sich ändern würde. Dies entspricht nicht unserem üblichen Verständnis von Zustand.'},
     {'question': 'Warum werden konstante Methoden verwendet?', 'answer': 'Konstante Methoden werden verwendet, um sicherzustellen, dass bestimmte Literale in einem Programm konsistent sind und immer auf dasselbe Objekt verweisen. Dies ist wichtig, um Probleme im Zusammenhang mit Objektidentität und Vergleichen zu vermeiden.'},
     {'question': 'Warum reichen Literale zum Programmieren nicht aus?', 'answer': 'Literale reichen zum Programmieren nicht aus, weil sie immer die gleichen Objekte repräsentieren.'},
     {'question': 'Warum stehen Objekte in Beziehung zueinander?', 'answer': 'Objekte stehen in Beziehung zueinander, um Bedeutung zu erlangen. Die meisten Objekte in einem System werden erst durch ihre Beziehungen zu anderen Objekten nützlich.'},
     {'question': 'Warum kann Aliasing erwünscht sein?', 'answer': 'Aliasing ist zunächst erwünscht, da es die Effizienz der Informationsverarbeitung erhöht. Es ermöglicht das Teilen von Objekten ohne Kopieren.'},
     {'question': 'Warum kann Aliasing zu Programmierfehlern führen?', 'answer': 'Aliasing kann zu Programmierfehlern führen, weil Änderungen an einem Objekt, das durch eine Variable bezeichnet wird, sich auf alle Aliase dieses Objekts auswirken. Unerwartete Veränderungen an einem Alias können schwer zu erkennen und zu debuggen sein.'},
     {'question': 'Warum sind gleiche Zahlen nur manchmal identisch in SMALLTALK?', 'answer': 'In SMALLTALK werden gleiche Zahlen manchmal als identisch behandelt und manchmal nicht, abhängig von ihrer Größe und technischen Gründen.'},
     {'question': 'Warum haben veränderliche Objekte eine Identität?', 'answer': 'Veränderliche Objekte haben eine Identität um sie auch bei vorübergehender Gleichheit voneinander unterscheiden zu können, da sie sich hinterher wieder auseinanderentwickeln können.'},
     {'question': 'Warum ist der Begriff "Lebenszyklus" eines Objekts irreführend?', 'answer': 'Der Begriff "Lebenszyklus" würde implizieren, dass das Objekt nach seinem Ende wiederverwendet wird, was nicht der Fall ist. Objekte werden nicht recycelt, sondern nur der von ihnen belegte Speicherplatz wird möglicherweise wiederverwendet.'},
     {'question': 'Warum werden Pseudovariablen als solche bezeichnet?', 'answer': 'Sie werden als Pseudovariablen bezeichnet, da sie ihren Wert entweder nicht ändern können oder ihren Wert vom System erhalten.'},
     {'question': 'Warum ist die Zuordnung von Methoden zu Objekten wichtig?', 'answer': 'Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen und somit das Verhalten des Objekts zu spezifizieren und zu beeinflussen.'},
     {'question': 'Warum ist der Zustandsbegriff nicht auf mehrere Objekte im Allgemeinen ausgedehnt?', 'answer': 'Der Zustandsbegriff kann nicht auf mehrere Objekte im Allgemeinen ausgedehnt werden, da dies zu komplexen Problemen führen würde und das objektorientierte Modell nicht ohne Herausforderungen ist. Programmierfehler könnten in vermeintlich simplen Situationen auftreten.'},
     {'question': 'Warum gibt es Variablen?', 'answer': 'Variablen sind notwendig, weil Literale immer die gleichen Objekte repräsentieren, weshalb sie zum Programmieren nicht ausreichen.'}
     ],
    [{'question': 'Was unterscheidet Literale und objekterzeugende Anweisungen?', 'answer': 'Der Compiler erzeugt bei der Übersetzung eines Literals das entsprechende Objekt im Speicher, während objekterzeugende Anweisungen erst zur Laufzeit des Programms ausgeführt werden.'},
     {'question': 'Was ist der Unterschiede zwischen globalen und lokalen Variablen?', 'answer': 'Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht. Globale Variablen sind auch außerhalb davon von überall her sichtbar.'},
     {'question': 'Was ist der Unterschied zwischen Statik und Dynamik in der Programmierung?', 'answer': 'In der Programmierung wird traditionell zwischen Statik und Dynamik unterschieden. Statik bezieht sich auf die statischen Strukturen eines Programms, die auf Papier oder in einem Nur-Lese-Speicher festgehalten werden können. Dynamik hingegen bezieht sich auf die Ausführung des Programms, die immer etwas Veränderliches ist. Wenn Programme selbst als Daten aufgefasst werden und sich sogar selbst verändern können, wird die Unterscheidung zwischen Statik und Dynamik nur noch bedingt nützlich. Alternativ kann man auch zwischen Struktur und Verhalten unterscheiden, wobei Struktur das Objektgeflecht und Verhalten die Folge seiner Veränderungen meint.'},
     {'question': 'Was ist der Unterschied zwischen einer internen und einer externen Iteration?', 'answer': 'Bei der internen Iteration erfolgt die Steuerstruktur für das Fortschreiten durch Elemente und die Überprüfung der Abbruchbedingung innerhalb der Sammlung, über die iteriert wird. Im Gegensatz dazu muss bei der traditionellen externen Iteration manuell eine Schleifenvariable als Index verwaltet werden.'},
     {'question': 'Was für Probleme können durch konstante Methoden auftreten?', 'answer': 'Bei der erneuten Übersetzung einer Methode mit einer konstanten Methode wird möglicherweise ein neues Objekt erzeugt, das nicht identisch mit dem zuvor zurückgegebenen Objekt ist. Dies kann zu Problemen führen, wenn das zuvor zurückgegebene Objekt in Variablen gespeichert wurde und mit dem neuen Objekt auf Identität verglichen wird.'},
     {'question': 'Was ist der Vorteil der Kontrollstrukturen in SMALLTALK?', 'answer': 'In SMALLTALK wird es als bedeutender Vorteil angesehen, dass Programmierer neue Kontrollstrukturen einführen können, wenn sie es wünschen.'},
     {'question': 'Was unterscheidet Symbole und Strings in SMALLTALK?', 'answer': 'Symbole dürfen im Gegensatz zu Strings keine Leerzeichen enthalten. Zudem ist die Erzeugung eines Objekts anhand eines Symbolliterals technisch aufwendiger als die Erzeugung eines Objekts anhand eines String-Literals.'},
     {'question': 'Was kann bei der Verwendung von identischen Symbolliteralen passieren?', 'answer': 'Bei der Verwendung identischer Symbolliterale kann es durch sogenanntes Aliasing zu unerwarteten Ergebnissen führen.'},
     {'question': 'Was unterscheidet Gleichheit und Identität von Objekten?', 'answer': 'Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten. Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren.'},
     {'question': 'Was unterscheidet die Bezeichnungen "das gleiche" und "dasselbe"?', 'answer': 'In der objektorientierten Programmierung sind "das gleiche" und "dasselbe" nicht dasselbe. Zwei Objekte können gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins.'},
     {'question': 'Warum sind atomare Objekte grundsätzlich nicht veränderbar?', 'answer': 'Atomare Objekte sind grundsätzlich nicht veränderbar, da es keinen Sinn ergibt, sie zu verändern. Zum Beispiel macht es keinen Sinn, aus einer "1" eine "2" zu machen.'},
     {'question': 'Was unterscheidet Zuweisungen unter Wertsemantik und unter Verweissemantik?', 'answer': 'Bei Zuweisungen unter Wertsemantik muss eine Kopie des Objekts angefertigt werden, da die Variable das Objekt selbst speichert. Bei Zuweisungen unter Verweissemantik wird nur der Verweis auf das Objekt kopiert und in der Variable gespeichert. Dies hat Auswirkungen darauf, ob Änderungen an einem Objekt in einer Variable sich auf dasselbe Objekt in einer anderen Variable auswirken.'},
     {'question': 'Was passiert nach einer Methode in SMALLTALK?', 'answer': 'Bei der Rückkehr nach der Abarbeitung einer Methode in SMALLTALK wird das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Dies ermöglicht die Weiterverarbeitung des Ergebnisses im Kontext des aufrufenden Objekts.'},
     {'question': 'Ist es in SMALLTALK möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben?', 'answer': 'In SMALLTALK ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben, da jeder Nachrichtenversand ein Ergebnis zurückgibt. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API (fließende Programmierung).'},
     {'question': 'Was unterscheidet ein Objekt und ein Wert?', 'answer': 'Objekte haben eine eindeutige Identität und sind an einer bestimmten Stelle im Speicher abgelegt, während Werte an verschiedenen Stellen im Speicher vorkommen können und keine Identität haben.'},
     {'question': 'Was unterscheidet Verweissemantik und Wertsemantik bei Variablen?', 'answer': 'Unter Wertsemantik können zwei Variablen niemals dasselbe Objekt bezeichnen, während Verweissemantik erlaubt, dass mehrere Variablen auf dasselbe Objekt verweisen.'},
     {'question': 'Haben Variablen in der objektorientierten Programmierung Wert- oder Verweissemantik?', 'answer': 'In manchen Sprachen haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik, z. B. Java. Andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll, z. B. C++ und EIFFEL.'},
     {'question': 'Was unterscheidet das Geheimnisprinzip und die Kapselung?', 'answer': 'Der Unterschied besteht darin, dass das Geheimnisprinzip sich auf das Verbergen von Implementationsdetails und Struktur bezieht, während die Kapselung sich auf das Verbergen und die Kontrolle des Zustands eines Objekts bezieht.'},
     {'question': 'Was unterscheidet eine benannte Instanzvariable und eine indizierte Instanzvariable in SMALLTALK?', 'answer': 'In SMALLTALK können benannte Instanzvariablen direkt über ihren Namen zugegriffen werden, während indizierte Instanzvariablen nur über die vordefinierten Nachrichten "at:" und "at:put:" gelesen und geschrieben werden können. Der Zugriff auf indizierte Instanzvariablen erfolgt nicht über Zugriffsmethoden, sondern über diese Nachrichten.'},
     {'question': 'Was bieten objektorientierte Programmiersprachen für die Teil-Ganzes-Beziehung?', 'answer': 'Die meisten objektorientierten Programmiersprachen bieten keine speziellen Sprachkonstrukte für die Teil-Ganzes-Beziehung. Stattdessen können Programmierer die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik nutzen, um eine bestimmte Form der Teil-Ganzes-Beziehung darzustellen. Bei Wertsemantik werden beim Entfernen eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt.'},
     {'question': 'Was unterscheidet veränderliche und unveränderliche Objekte?', 'answer': 'Veränderliche Objekte können ihren Zustand im Laufe der Zeit ändern, während unveränderliche Objekte keinen Zustand haben und ihre Werte konstant bleiben.'},
     {'question': 'Was unterscheidet Attribute und Beziehungen?', 'answer': 'Die Unterscheidung zwischen Attributen und Beziehungen kann in Ermangelung spezieller Schlüsselwörter allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese ist jedoch in einigen Programmiersprachen nicht immer eindeutig ist und beispielsweise in Java gar nicht zutreffend.'},
     {'question': 'Warum hängt das Verhalten eines Objekts von seinem Zustand ab?', 'answer': 'Das Verhalten eines Objekts hängt in der Regel von seinem Zustand ab, weil der Zustand eines Objekts die Informationen enthält, die benötigt werden, um die richtigen Entscheidungen zu treffen und die entsprechenden Aktionen auszuführen. Das Verhalten eines Objekts basiert auf den Daten in seinem Zustand, und diese Daten beeinflussen, wie das Objekt auf Nachrichten reagiert.'},
     {'question': 'Was unterscheidet Protokoll und Implementierung in SMALLTALK?', 'answer': 'Das Protokoll beschreibt das Interface eines Objekts und umfasst die Methodensignaturen und dazugehörigen Kommentare. Die Implementierung hingegen besteht aus den tatsächlichen Methodenrümpfen und den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Das Protokoll dient dazu, das Verhalten eines Objekts zu beschreiben, während die Implementierung die Details der Umsetzung enthält.'},
     {'question': 'Von welchem Objekt hängt die Auswahl der aufzurufenden Methode ab?', 'answer': 'Die Auswahl der Methode, die aufgerufen wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Verschiedene Objekte mit gleichen Methodensignaturen können unterschiedliche Methodenimplementierungen haben.'},
     {'question': 'Was passiert, wenn ein Methodenaufruf in SMALLTALK ins Leere läuft?', 'answer': 'Wenn ein Methodenaufruf ins Leere läuft, wird er in einen Aufruf der Methode "doesNotUnderstand:" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung, die besagt, dass das Objekt die Nachricht nicht versteht. Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren.'},
     {'question': 'Was unterscheidet Variablen und Literale?', 'answer': 'Anders als bei Literalen wird aus einer Variable kein Objekt erzeugt, sie ist lediglich ein Name für ein bereits existierendes Objekt.'},
     {'question': 'In welcher Reihenfolge werden Ausdrücke in SMALLTALK ausgewertet?', 'answer': 'In SMALLTALK werden Ausdrücke normalerweise von links nach rechts ausgewertet.'},
     {'question': 'Was unterscheidet eine Methodensignatur und einen Nachrichtenselektor?', 'answer': 'Die Methodensignatur ist das Gegenstück zum Nachrichtenselektor.'},
     {'question': 'Was sind die Vorteile einer Garbage Collection?', 'answer': 'Die Garbage Collection verhindert vorzeitige Entfernung von Objekten, die noch in Verwendung sind, und stellt sicher, dass Variablen auf gültige Objekte verweisen. Dies trägt zur Stabilität und Sicherheit von Programmen bei.'},
     {'question': 'Was verbirgt sich hinter dem Nachrichtenversand in SMALLTALK?', 'answer': 'Hinter dem Nachrichtenversand in SMALLTALK verbirgt sich der Methodenaufruf. Wenn ein Objekt eine Nachricht an ein Empfängerobjekt sendet, wird der Kontrollfluss zur Methode des Empfängerobjekts verschoben, die zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung dieser Methode kehrt der Kontrollfluss an das sendende Objekt zurück und setzt seine Arbeit dort fort.'},
     {'question': 'Können Sie auch Inkonsistenzen im objektorientierten Weltbild nennen?', 'answer': 'In der objektorientierten Programmierung werden verschiedene Arten von Sachverhalten, die in der realen Welt unterschiedliche Eigenschaften haben, durch Objekte repräsentiert. Dies kann zu Inkonsistenzen führen, da nicht alle Sachverhalte dieselben Eigenschaften wie Objekte haben. Dies ist auf die homogene Natur der Objektorientierung zurückzuführen.'},
     {'question': 'Was umfasst der Home Context eines Blocks?', 'answer': 'Das Konzept des Home Contexts eines Blocks in SMALLTALK umfasst nicht nur die sichtbaren Variablen aus dem Kontext der Definition des Blocks, sondern auch den sogenannten Call Stack, der die Rücksprungadressen von Methodenaufrufen speichert.'},
     {'question': 'Worauf bezieht sich die Sichtbarkeit einer Variable?', 'answer': 'Die Sichtbarkeit einer Variable bezieht sich immer auf einen Abschnitt des Programmcodes, in dem der Variablenname verwendet werden kann und damit Zugriff auf das von diesem Namen bezeichnete Objekt besteht.'},
     {'question': 'Was bezeichnet die Variable "self" in Methoden?', 'answer': 'Die Variable "self" verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird benötigt, wenn eine Nachricht aus einer Methode heraus an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. "self" ist somit der implizite erste Parameter einer Methode.'},
     {'question': 'Woraus setzt sich der Zustand eines Objekts zusammen?', 'answer': 'Der Zustand eines Objekts setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert.'},
     {'question': 'Wofür ist das Verhalten eines Objekts zuständig?', 'answer': 'Wenn Objekte ihren Zustand kapseln, ist ausschließlich das Verhalten eines Objekts dafür verantwortlich, den Zustand eines Objekts zu ändern und die Interaktion mit diesem Objekt zu steuern. Das Verhalten bestimmt, wie ein Objekt auf Nachrichten reagiert und welche Operationen es auf seinem internen Zustand durchführt.'},
     {'question': 'Ist die Zuweisung kommutativ?', 'answer': 'Die Zuweisung ist nicht kommutativ, es sei denn, die Variablen auf der linnken und der rechten Seite hatten bereits denselben Wert vor der jeweiligen Zuweisung.'},
     {'question': 'Was bezeichnet eine Variable?', 'answer': 'Eine Variable bezeichnet ein Objekt.'}
     ]
]

KE2_questions = [
    [{'question': 'Was ist eine Metaklasse in der Programmierung?', 'answer': 'Eine Metaklasse ist eine Klasse, die für die Erstellung von Klassen verantwortlich ist. Sie ist eine Klasse der Klassen und ermöglicht es, die Verhaltensweisen von Klassen zu ändern oder zu erweitern.'},
     {'question': 'Was ist die Aufgabe von Metaklassen in der Programmierung?', 'answer': 'Metaklassen sind eine Ebene oberhalb von Klassen und werden verwendet, um die Verhaltensweisen von Klassen zu definieren. Sie können auch geändert werden, um die Erstellung von Klassen zu ändern, wie zum Beispiel das automatische Generieren von Zugriffsmethoden für alle benannten Instanzvariablen einer Klasse.'},
     {'question': 'Was ist eine Metaklasse in Smalltalk?', 'answer': 'In Smalltalk ist eine Metaklasse eine Klasse, die dazu dient, andere Klassen zu definieren und zu erstellen.'},
     {'question': 'Was ist Klonen oder Kopieren?', 'answer': 'Klonen oder Kopieren ist eine Methode, um neue Instanzen von Klassen zu erzeugen, bei der ein bestehendes Objekt kopiert wird, um eine exakte Kopie des Objekts zu erstellen, die eigenständig und nicht mit dem Original verbunden ist. Es gibt zwei Arten von Kopien: Shallow Copy und Deep Copy.'},
     {'question': 'Was ist die Rolle der Klasse "Class" in Smalltalk?', 'answer': 'Die Klasse "Class" ist in Smalltalk die Superklasse aller Metaklassen. Jede Instanz dieser Klasse ist eine Klasse. Die Klasse von Class ist Class class und erst Class class eine Metaklasse.'},
     {'question': 'Was ist der Klassenansatz in der objektorientierten Programmierung?', 'answer': 'Der Klassenansatz ist ein Ansatz in der objektorientierten Programmierung, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden. Diese Vorlagen werden als Klassen bezeichnet.'},
     {'question': 'Was ist der Prototypenansatz in der objektorientierten Programmierung?', 'answer': 'Der Prototypenansatz ist ein Ansatz in der objektorientierten Programmierung, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird. Ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden.'},
     {'question': 'Welche praktische Bedeutung haben Metaklassen für die Programmierung in SMALLTALK?', 'answer': 'Metaklassen haben in SMALLTALK die praktische Bedeutung, dass sie die Definition von Klassen steuern und die Struktur des Programms beeinflussen. Sie ermöglichen es, Klassen dynamisch zu erzeugen und zu verändern. Zum Beispiel können Sie an der Ebene der Metaklassen Methoden hinzufügen, um das Verhalten von Klassen zu ändern, ohne die Klassen selbst zu ändern.'},
     {'question': 'Was ist die einfachste Form des Kopierens eines Objekts in SMALLTALK?', 'answer': 'Die einfachste Form des Kopierens eines Objekts in SMALLTALK ist das Erzeugen eines Objekts derselben Klasse mit denselben Variablenbelegungen. Dies wird durch die Methode "shallowCopy" ermöglicht.'},
     {'question': 'Welche Programmiersprachen nutzen den Klassenansatz?', 'answer': 'Der Klassenansatz wird in Sprachen wie SMALLTALK, C++, EIFFEL, Java, C-Sharp, SCALA und vielen anderen mehr angewendet.'},
     {'question': 'Was sind Konstruktoren in SMALLTALK?', 'answer': 'In SMALLTALK sind Konstruktoren Methoden, die, wenn sie auf einer Klasse aufgerufen werden, eine neue Instanz dieser Klasse erstellen und zurückgeben. Sie sind Klassenmethoden, die dazu dienen, neue Objekte zu erzeugen.'},
     {'question': 'Welche Rolle spielen Ein- und Ausgabeströme in der objektorientierten Programmierung?', 'answer': 'Ein- und Ausgabeströme spielen in der objektorientierten Programmierung eine wichtige Rolle, da sie den Zugriff auf Eingabe- und Ausgabedaten im System ermöglichen. Sie dienen dazu, Daten sowohl von/zu Benutzern als auch von/zu Dateisystemen zu lesen und zu schreiben.'},
     {'question': 'Welche Informationen können in einer Metaklasse definiert werden?', 'answer': 'In einer Metaklasse können Informationen wie Instanzvariablen und Methoden für die zugehörige Klasse definiert werden. Dies ermöglicht es, das Verhalten und die Eigenschaften der Klasse individuell anzupassen.'},
     {'question': 'Welche Bedeutung hat die Generalisierung in der objektorientierten Programmierung?', 'answer': 'Die Generalisierung ermöglicht es, mehrere Klassen, deren Definitionen inhaltlich verwandt sind, zu abstrahieren und zusammenzufassen. Dies führt zur Bildung einer Generalisierungsklasse, die die gemeinsamen Eigenschaften (Instanzvariablen und Methoden) der generalisierten Klassen enthält. Die Generalisierung erlaubt es, Gemeinsamkeiten zwischen Klassen auf höherer Abstraktionsebene darzustellen und die Wiederverwendung von Code zu fördern.'},
     {'question': 'Was ist eine Klassendefinition?', 'answer': 'Eine Klassendefinition liefert die Intension oder Beschreibung einer Klasse. Sie besteht aus dem Namen der Klasse, der Liste der benannten Instanzvariablen, Angaben zu indizierten Instanzvariablen, Informationen zur Atomarität, und einer Liste von Instanzmethoden.'},
     {'question': 'Was sind Instanzen einer Klasse?', 'answer': 'Eine Instanz der Klasse ist das Objekt, das zur Extension der Klasse gehört. Jede Instanz belegt den Satz an Instanzvariablen individuell. Alle Instanzen einer Klasse verstehen dieselben Nachrichten und verwenden dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren.'},
     {'question': 'Was sind indizierte Instanzvariablen?', 'answer': 'Indizierten Instanzvariablen enthalten binäre Repräsentationen.'},
     {'question': 'Was sind globale Pseudovariablen in SMALLTALK?', 'answer': 'In SMALLTALK wird jede Klasse nach ihrer Erzeugung durch eine globale Pseudovariable repräsentiert, deren Name dem Namen der Klasse entspricht. Diese globale Pseudovariable ist notwendig, um auf die Klasse und ihre Methoden zugreifen zu können. Klassennamen sind global und von überall aus im Code zugreifbar.'},
     {'question': 'Welche beiden Rollen gibt es in einer Subklassenbeziehung?', 'answer': 'Die beiden Enden der Subklassenbeziehung haben die Rollen "Superklasse" und "Subklasse". Diese Rollen legen nahe, dass die Subklassenbeziehung eine Hierarchie von Klassen aufbaut, in der die Superklassen über den Subklassen stehen. Die Superklasse ist die allgemeinere Klasse, von der die Subklasse erbt, während die Subklasse die speziellere Klasse ist, die die Eigenschaften der Superklasse erbt und möglicherweise erweitert oder anpasst.'},
     {'question': 'Was ist das Konzept der offenen Rekursion in SMALLTALK?', 'answer': 'Das Konzept der offenen Rekursion in SMALLTALK bedeutet, dass die Methode, die durch eine Nachricht an self aufgerufen wird, nicht zwangsläufig die in derselben Klasse definierte Methode ist. Stattdessen kann die passende Methode in einer Subklasse gefunden werden, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde. Dies kann zu überraschenden Ergebnissen führen, wenn nicht erwartet wird, dass die Methode in einer Subklasse überschrieben wurde.'},
     {'question': 'Welche Ebenen gibt es in SMALLTALK im Zusammenhang mit Klassen und Instanzen?', 'answer': 'In SMALLTALK gibt es mehrere Ebenen im Zusammenhang mit Klassen und Instanzen: Ebene 0: Konkrete Objekte, die nicht instanziierbar sind und Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Ebene 1: Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Ebene 2: Metaklassen, die die Klassen auf Ebene 1 definieren. Jede Metaklasse hat genau eine Instanz. Ebene 3: Die Klasse "Metaclass", von der alle Metaklassen Instanzen sind.'},
     {'question': 'Welche Gemeinsamkeiten haben die Klassen "Set" und "Bag" in SMALLTALK?', 'answer': 'Die Gemeinsamkeit zwischen den Klassen "Set" und "Bag" besteht darin, dass beide ungeordnete Collections repräsentieren. In diesen Collections darf jedes Element höchstens einmal vorkommen. Sie unterscheiden sich jedoch darin, dass in einem Set die Elemente eindeutig sind und keine Duplikate enthalten, während in einer Bag Elemente mehrmals vorhanden sein können.'},
     {'question': 'Was ist Spezialisierung in der objektorientierten Programmierung?', 'answer': 'Spezialisierung ist das Gegenteil von Generalisierung in der objektorientierten Programmierung. Während bei der Generalisierung Eigenschaften weggelassen oder verallgemeinert werden, fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene Eigenschaften von Klassen. Es bedeutet, dass eine Klasse eine Spezialisierung ihrer Generalisierungen sein kann, wenn sie zusätzliche Merkmale oder Verhaltensweisen hinzufügt.'},
     {'question': 'Was ist Instanziierung?', 'answer': 'Instanziierung ist der Prozess, bei dem ein neues Objekt einer bestimmten Klasse erstellt wird. Das neue Objekt wird eine Instanz dieser Klasse genannt und hat die Eigenschaften (Instanzvariablen und Methoden), die durch die Definition (Intension) der Klasse festgelegt sind.'},
     {'question': 'Welche Alternative gibt es zur Instanziierung?', 'answer': 'Eine Alternative zur Instanziierung ist das Klonen.'},
     {'question': 'Was ist das Klonen?', 'answer': 'Das Klone ist ein Prozess, bei dem ein neues Objekt auf der Basis eines bereits existierenden Objekts erstellt wird. Der Klon ist eine Kopie des Originalobjekts. Beim Klonen muss festgelegt werden, wie tief die Kopie gehen soll, dh ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht, kopiert werden sollen. Während das Klonen in klassenbasierten objektorientierten Programmiersprachen in der Regel durch Instanziierung und Übertragung von Inhaltsdaten der Instanzvariablen erzeugt wird, erfolgt das Klonen in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse nicht kennen, durch einfaches Kopieren. In SMALLTALK wird die Instanziierung normalerweise bevorzugt, da es sich um eine klassenbasierte Sprache handelt.'},
     {'question': 'Welche Bedingungen müssen erfüllt sein, damit eine Subklassenbeziehung zwischen zwei Klassen in SMALLTALK zulässig ist?', 'answer': 'Damit eine Subklassenbeziehung zwischen zwei Klassen in SMALLTALK zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen: Benannte Instanz- und Klassenvariablen dürfen nicht dieselben Namen haben wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Wenn die Superklasse indizierte Instanzvariablen hat, müssen diese auch in der Subklasse vorhanden sein. Methodendefinitionen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden.'},
     {'question': 'Was sind Factory-Methoden?', 'answer': 'Factory-Methoden sind spezielle Klassenmethoden, die ähnlich wie Konstruktoren neue Instanzen erstellen. Allerdings können sie die Klasse der Instanz basierend auf anderen Faktoren als nur der Klasse, zu der die Methode gehört, festlegen.'},
     {'question': 'Welches Prinzip geht der Vererbung voraus?', 'answer': 'Die Prinzipien von Generalisierung und Spezialisierung gehen der Vererbung voraus. Generalisierung und Spezialisierung sind eng mit der Vererbung verbunden, da Vererbung oft verwendet wird, um diese Prinzipien umzusetzen. Generalisierung ist die Bildung von allgemeineren Klassen aus spezifischeren Klassen, während Spezialisierung die Bildung spezifischerer Klassen aus allgemeineren Klassen ist.'},
     {'question': 'Was ist eine Klassifikation?', 'answer': 'Eine Klassifikation ist eine Zuordnung von Individuen oder Objekten zu bestimmten Allgemeinbegriffen oder Klassen. Diese Klassifikation ermöglicht eine Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen und Eigenschaften nur noch für die Klassen im Allgemeinen getroffen werden müssen, anstatt für jedes einzelne Objekt. Statt also Eigenschaften und Methoden direkt Objekten zuzuweisen, verbindet man sie mit Klassen und legt fest, dass sie die einzelnen Objekte, die zu dieser Klasse gehören, beschreiben.'},
     {'question': 'Was ist die Extension?', 'answer': 'Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören.'},
     {'question': 'Was ist die Intension?', 'answer': 'Die Intension ist die Summe der Merkmale oder Eigenschaften, die den Begriff ausmachen und die Objekte charakterisieren, die zu dieser Klasse gehören. Die Intension ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die entscheidet, ob ein beliebiges Element unter den Begriff fällt.'},
     {'question': 'Was sind abstrakte Klassen?', 'answer': 'Abstrakte Klassen in der objektorientierten Programmierung sind Klassen, die selbst keine Instanzen haben und daher nicht instanziierbar sind. Sie werden oft verwendet, um gemeinsame Eigenschaften und Methoden für ihre Subklassen bereitzustellen, aber sie sind in der Regel unvollständig definiert und können zu Laufzeitfehlern führen, wenn sie direkt instanziiert werden.'},
     {'question': 'Welche Art von Methoden bietet die Klasse "Object" den Objekten an?', 'answer': 'Die Klasse "Object" bietet eine Vielzahl von Methoden an, die grundlegende Typtests und andere gemeinsame Operationen für Objekte ermöglichen. Dazu gehören Methoden wie isNil, notNil, isInteger, isFloat und viele andere. Diese Methoden erlauben es, Eigenschaften von Objekten abzufragen und deren Typ zu überprüfen.'},
     {'question': 'Welche Rolle spielen Zwischenobjekte in der Umsetzung von Zu-n-Beziehungen?', 'answer': 'Zwischenobjekte spielen eine Rolle in der Umsetzung von Zu-n-Beziehungen. Sie ermöglichen es, solche Beziehungen indirekt über ihre indizierten Instanzvariablen herzustellen.'},
     {'question': 'Was ist die Aufgabe von Streams in SMALLTALK?', 'answer': 'In SMALLTALK erlauben Streams einen sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen und den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Collection durch mehrere andere Objekte.'},
     {'question': 'Was ist die Funktion von Streams in einer Collection?', 'answer': 'Die Funktion von Streams in einer Collection ist es, Positionszeiger in die Collection hineinzuliefern.'},
     {'question': 'Was ist eine Instanz?', 'answer': 'Eine Instanz ist ein konkretes Exemplar einer Klasse.'},
     {'question': 'Was ist eine explizite Zuweisung?', 'answer': 'Eine explizite Zuweisung ist eine Zuweisung, die durch den Zuweisungsoperator vorgenommen wird.'},
     {'question': 'Was ist eine implizite Zuweisung?', 'answer': 'Eine implizite Zuweisung ist eine Zuweisung, die bei Methodenaufrufen vorgenommen wird.'},
     {'question': 'Was ist die Beziehung zwischen Klassen und Metaklassen in Smalltalk?', 'answer': 'In Smalltalk besteht eine 1-zu-1-Beziehung zwischen Klassen und Metaklassen, die nicht getrennt voneinander definiert werden, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt über Abschnitte für die Deklaration der Instanzvariablen, Definition der Methoden, Angabe der Klassenvariablen und -methoden.'},
     {'question': 'Was sind Klassenvariablen und Klassenmethoden?', 'answer': 'Klassenvariablen und Klassenmethoden sind Variablen und Methoden, die allen Instanzen einer Klasse gemeinsam sind. Klassenvariablen werden mit einem Doppelpunkt und dem Klassennamen deklariert, Klassenmethoden mit einem Pluszeichen und dem Klassennamen. Sie können von allen Instanzen der Klasse aus aufgerufen werden. Ein Beispiel für eine Klassenvariable ist "Dependents Fields" in der Klasse "Object", eins für eine Klassenmethode ist "pi" in der Klasse "Float".'},
     {'question': 'Was ist eine Klassenvariable?', 'answer': 'Eine Klassenvariable ist eine Variable, die einer Klasse gehört und allen Instanzen dieser Klasse gemeinsam ist. In diesem Fall gehört die Klassenvariable "Pi" der Klasse "Float" und ist allen Instanzen dieser Klasse zugeordnet.'},
     {'question': 'Was ist ein Rollback?', 'answer': 'Ein Rollback ist eine Möglichkeit, den ursprünglichen Zustand eines Objekts oder Objektgeflechts wiederherzustellen, indem eine Kopie des Objekts vor der Durchführung einer Menge von Änderungen angelegt und das ursprüngliche Objekt durch die Kopie ersetzt wird.'},
     {'question': 'Was ist die Funktion von Generalisierungen in der objektorientierten Programmierung?', 'answer': 'Die Funktion von Generalisierungen in der objektorientierten Programmierung ist es, Eigenschaften zu definieren, die automatisch auch für alle Klassen gelten, von denen die Generalisierung abstrahiert. Diese Klassen müssen dann nur noch die Unterschiede definieren, die sie von der Generalisierung und voneinander unterscheiden.'},
     {'question': 'Was ist die Aufgabe der Klassen, die von einer Generalisierung abstrahiert?', 'answer': 'Die Aufgabe der Klassen, die von einer Generalisierung abstrahiert, ist es, nur noch die Unterschiede zu definieren, die sie von der Generalisierung und voneinander unterscheiden. Sie müssen nicht die Eigenschaften wiederholen, die der Generalisierung zugeordnet sind, da diese per Definition automatisch auch für sie gelten.'},
     {'question': 'Was sind Genera in der objektorientierten Programmierung?', 'answer': 'Genera sind in der objektorientierten Praxis Generalisierungen, die keine eigenen, direkten Instanzen haben, sondern als abstrakte Objekte fungieren, die von konkreteren Klassen geerbt werden.'},
     {'question': 'Was ist Generalisierung bei Attributen?', 'answer': 'Bei der Generalisierung von Attributen wird ihr Wertebereich von einem spezielleren (kleineren) zu einem allgemeineren (größeren) erweitert. Zum Beispiel würde das Attribut "Aufenthaltsort" bei der Generalisierung von Mensch zu Zweibeiner von Punkten auf der Erdoberfläche zu Punkten einschließlich des Luftraums darüber generalisiert. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen.'},
     {'question': 'Was ist eine Generalisierungshierarchie?', 'answer': 'Eine Generalisierungshierarchie ist eine hierarchische Struktur, in der Klassen nach ihrer Allgemeinheit geordnet sind. Dabei gilt, dass eine allgemeinere Klasse eine speziellere Klasse als Unterklasse enthält. Die Generalisierungshierarchie ist eine wichtige Konzept in der objektorientierten Programmierung, da sie die Beziehung zwischen Klassen und Objekten definiert.'},
     {'question': 'Was ist das Model-View-Controller-Entwurfsmuster (MVC-Pattern)?', 'answer': 'Das MVC-Pattern ist ein Entwurfsmuster, das in SMALLTALK eingeführt wurde und sich heute noch großer Beliebtheit erfreut. Es gibt verschiedene Ansichten auf ein logisches Modell, und Änderungen im Modell können potenziell alle Sichten betreffen. Daher muss jede Änderung alle Sichten darüber unterrichten, was eine Eins-zu-viele-Kommunikation erfordert, die nicht durch den normalen Nachrichtenversand abgedeckt wird.'},
     {'question': 'Was ist Lazy Initialization?', 'answer': 'Lazy Initialization ist eine Technik, bei der die Initialisierung einer Variablen oder eines Objekts verzögert wird, bis sie tatsächlich benötigt wird. Diese Technik wird eingesetzt, um Ressourcen zu sparen und die Leistung zu verbessern.'},
     {'question': 'Was ist eine Subklassenbeziehung?', 'answer': 'Die Subklassenbeziehung ist eine Beziehung zwischen Klassen, bei der die Subklasse eine spezialisiertere Form der Superklasse ist. Die Subklassenbeziehung ist transitiv, d.h. wenn A eine Subklasse von B ist und B eine von C, dann ist A auch eine Subklasse von C. Eine Klasse kann nicht gleichzeitig Superklasse und Subklasse einer anderen Klasse sein.'},
     {'question': 'Was ist die Funktion der Pseudovariablen „super“ in SMALLTALK?', 'answer': 'Die Pseudovariable „super“ in SMALLTALK wird verwendet, um die überschriebene Methode aufzurufen, wenn eine überschreibende Methode lediglich modifizieren möchte, aber das grundlegende Verhalten beibehalten muss.'},
     {'question': 'Was ist die Bedeutung von self in Smalltalk?', 'answer': 'In Smalltalk bezieht sich self auf das Objekt, auf das die gerade ausgeführte Methode angewendet wird. Die Klasse des durch self bezeichneten Objekts muss nicht unbedingt dieselbe sein, in der die Methode definiert ist, sondern kann durchaus eine Superklasse sein. Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden.'},
     {'question': 'Was sind aktive Objekte?', 'answer': 'Aktive Objekte sind Objekte, die über einen eigenen Prozess verfügen, der nur die eigenen Methoden ausführt. Sie arbeiten Nachrichten ab, sobald sie die Zeit dazu haben, was zu einem asynchronen Kommunikationsablauf führt.'},
     {'question': 'Was sind Semaphoren?', 'answer': 'Semaphoren in SMALLTALK sind Objekte, die zur Synchronisation von parallelen Prozessen verwendet werden. Sie verfügen über zwei Methoden, "wait" und "signal", und eine Instanzvariable, die für jedes Empfangen von "signal" um 1 erhöht und für jedes Empfangen von "wait" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt. Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht "signal" und es gibt noch Prozesse, die schlafen, dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden und weitermachen.'},
     {'question': 'Was ist eine SharedQueue?', 'answer': 'SharedQueue ist eine Unterklasse von OrderedCollection, die Objekte aufnimmt und eine Synchronisation über "next" und "nextPut:" erlaubt.'},
     {'question': 'Was ist ein dynamisch gebundener Methodenaufruf?', 'answer': 'Ein dynamisch gebundener Methodenaufruf ist eine Methode, bei der die Auswahl der Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt abhängig ist.'},
     {'question': 'Was ist das Methodenwörterbuch in Smalltalk?', 'answer': 'Das Methodenwörterbuch in Smalltalk ist eine Tabelle, die alle Methoden enthält, die zu einer bestimmten Klasse gehören. Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist.'},
     {'question': 'Was ist die Rolle der Metaklasse "Metaclass" in SMALLTALK?', 'answer': 'Die Metaklasse "Metaclass" in SMALLTALK ist eine gemeinsame Metaklasse, von der alle Metaklassen Instanzen sind. Sie wird verwendet, um die Instanzvariablen und Methoden für Metaklassen bereitzustellen, da es nicht notwendig ist, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen.'},
     {'question': 'Was ist die Metaklasse von Metaclass?', 'answer': 'Die Metaklasse von Metaclass ist selbst nur eine einfache Metaklasse und wird als Instanz von Metaclass betrachtet.'},
     {'question': 'Was ist die Funktion von Arrays?', 'answer': 'Arrays werden in der Programmierung häufig verwendet, insbesondere wegen der Möglichkeit der einfachen literalen Definition. Sie ermöglichen es, einfach über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung zu iterieren. Zum Beispiel kann man den Laufparameter eines Blocks, "element", nacheinander die Elemente des literalen Arrays zuweisen.'},
     {'question': 'Was ist die Abstraktionshierarchie in Smalltalk?', 'answer': 'Eine Abstraktionshierarchie in Smalltalk ist eine Hierarchie, die auf dem Konzept der Klassifikation aufbaut und mit der Sprachdefinition festgelegt ist.'},
     {'question': 'Was sind Anwendungsklassen?', 'answer': 'Anwendungsklassen sind Klassen, die zur Laufzeit des Programms für die Erzeugung von Anwendungsobjekten genutzt werden.'},
     {'question': 'Was sind Anwendungsobjekte?', 'answer': 'Anwendungsobjekte sind Objekte, die zur Laufzeit des Programms aus Anwendungsklassen erzeugt werden.'},
     {'question': 'Was ist die Klasse "Collection" in SMALLTALK?', 'answer': 'Die Klasse "Collection" ist eine abstrakte Klasse in SMALLTALK, die eine Hierarchie von spezielleren, instanziierbaren (konkreten) Collection-Klassen umfasst, die für unterschiedlichste Zwecke eingesetzt werden können. Dazu gehören zum Beispiel "Set" für ungeordnete Collections, in denen jedes Element höchstens einmal vorkommen darf, und "Bag" für Collections, in denen die letzte Einschränkung aufgehoben ist. "Set" und "Bag" haben gemeinsam, dass die Elemente in beiden nicht über einen Index zugreifbar sind.'},
     {'question': 'Was ist die Vererbung?', 'answer': 'Die Vererbung ist ein Mechanismus, der es ermöglicht, die Definition einer Klasse (der Superklasse) auf eine andere Klasse (die Subklasse) zu übertragen. Dabei wird die gesamte Definition der Superklasse auf die Subklasse kopiert.'},
     {'question': 'Was ist eine Spezialisierung?', 'answer': 'Spezialisierung ist das Prinzip, bei dem Eigenschaften hinzugefügt oder bereits vorhandene spezialisiert werden, im Gegensatz zur Generalisierung, bei der Eigenschaften weggelassen oder generalisiert werden. Jede Klasse ist eine Spezialisierung ihrer Generalisierungen, sofern sie welche hat.'},
     {'question': 'Was ist Spezialisierung in der Programmierung?', 'answer': 'Spezialisierung in der Programmierung ist der Prozess der Erstellung einer neuen Klasse, die auf einer bestehenden Klasse basiert und diese erweitert oder verändert, um spezifischere Funktionalitäten bereitzustellen. Die neue Klasse wird als spezialisiertere Version der ursprünglichen Klasse angesehen, da sie die gleichen allgemeinen Merkmale und Verhalten besitzt, aber zusätzliche Merkmale und Verhalten hinzufügt, um ihre Funktionalität zu erweitern.'},
     {'question': 'Welche Bedingungen müssen für eine zulässige Subklassenbeziehung erfüllt sein?', 'answer': 'Für eine zulässige Subklassenbeziehung müssen die Definitionen der Klassen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden.'},
     {'question': 'Was ist die Klasse "Object" in SMALLTALK?', 'answer': 'Die Klasse "Object" ist die oberste Superklasse in SMALLTALK, von der alle anderen Klassen abgeleitet sind. Sie enthält Definitionen, die den Instanzen aller Klassen zugutekommen sollen, wie zum Beispiel die Methode "printString". Diese Methoden werden durch Vererbung auf alle anderen Klassen übertragen, wodurch sie deren Instanzen zur Verfügung stehen.'},
     {'question': 'Was ist die Problematik bei der Vererbung in SMALLTALK?', 'answer': 'Die Problematik bei der Vererbung in SMALLTALK ist, dass man davon ausgeht, dass Vererbung etwas mit der auf Generalisierung bzw. Spezialisierung beruhenden Abstraktionshierarchie zu tun hat. Dies ist jedoch nicht immer der Fall, wie das Beispiel der Ableitung der Klasse Rechteck von der Klasse Quadrat zeigt. Diese vererbungsorientierte Vorgehensweise kann zu unangenehmen Folgen führen.'},
     {'question': 'Was ist Überschreiben?', 'answer': 'Überschreiben bedeutet, dass eine abgeleitete Klasse dieselben Methoden wie die Basisklasse besitzt, aber die Methoden anders implementiert. Das ist häufig Voraussetzung dafür, Vererbung sinnvoll einzusetzen.'},
     {'question': 'Was ist das Problem mit der Vererbung?', 'answer': 'Das Problem mit der Vererbung ist, dass sie auf die oberflächliche Wiederverwendung von Elementen einer Klassendefinition ausgerichtet ist und dabei den Zusammenhang der Extensionen der beteiligten Klassen außer Acht lässt, was für Generalisierung/Spezialisierung wesentlich ist. Diese Ignoranz hat weitreichende Konsequenzen.'},
     {'question': 'Was ist Generalisierung und Spezialisierung in Bezug auf objektorientierte Programmierung?', 'answer': 'Generalisierung und Spezialisierung sind Prinzipien in der objektorientierten Programmierung. Dabei wird eine allgemeine Klasse (Generalisation) erstellt, die dann durch eine spezifischere Klasse (Spezialisation) erweitert wird. In diesem Fall wird die Klasse Rechteck als allgemeine Klasse angesehen und Quadrat als spezifischere Klasse, die von Rechteck erbt.'},
     {'question': 'Was ist die Klasse Dictionary in SMALLTALK?', 'answer': 'Die Klasse Dictionary in SMALLTALK realisiert sogenannte Assoziativspeicher, bei denen auf eine Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet, zum Beispiel für das Hinterlegen von Methoden in Dictionaries.'},
     {'question': 'Was ist Delegation in der objektorientierten Programmierung?', 'answer': 'Delegation ist eine Technik in der objektorientierten Programmierung, bei der eine Instanz eine andere Instanz als Sklavin hält, die für sie den Dienst verrichtet. Sie wird oft genutzt, um die Funktion der Vererbung zu übernehmen, da sie dynamisch eingerichtet werden kann und nicht an Fragen der Generalisierung/Spezialisierung gebunden ist.'},
     {'question': 'Was sind Allgemeinbegriffe?', 'answer': 'Allgemeinbegriffe sind die Vorbilder für Klassen in der objektorientierten Programmierung. In SMALLTALK werden Allgemeinbegriffe in Form von Klassen repräsentiert. Klassen sind die Vorbilder für Objekte in der objektorientierten Programmierung. Jede Klasse kann Instanzvariablen und Methoden haben, die das Verhalten und die Eigenschaften der Objekte beschreiben, die zu dieser Klasse gehören.'},
     {'question': 'Was ist offene Rekursion?', 'answer': 'Offene Rekursion ist ein Muster in der objektorientierten Programmierung, bei dem eine abstrakte, in der Klasse nicht implementierte Methode aus derselben Klasse heraus mit "self" als Empfänger aufgerufen wird. Dieses Muster wird verwendet, um die Implementierung der Methode in einer erbenden Klasse zu ermöglichen.'},
     {'question': 'Was ist Parametrische Polymorphie?', 'answer': 'Parametrische Polymorphie ist eine Art der Polymorphie, bei der die Auswahl einer Methode von den tatsächlichen Parametern abhängt. Wenn die Methode, die für eine bestimmte Nachricht vorgesehen ist, nicht für alle möglichen Parameter geeignet ist, muss eine alternative Methode ausgewählt werden, die besser zu den tatsächlichen Parametern passt.'},
     {'question': 'Was ist Double Dispatch und wofür wird es verwendet?', 'answer': 'Double Dispatch ist eine Technik, bei der eine Methode gleicher Bedeutung unter Vertauschung von Sender und Empfänger aufgerufen wird. Diese Technik wird verwendet, um die dynamische Bindung zweimal hintereinander durchzuführen. Double Dispatch wurde erstmals von Dan Ingalls am Beispiel von Smalltalk beschrieben und findet auch in anderen Sprachen mit Single Dispatch Anwendung. In Sprachen, bei denen bei der dynamischen Methodenauswahl die Parametertypen berücksichtigt werden, wird Double Dispatch nicht benötigt.'},
     {'question': 'Was ist ein Objekt in Bezug auf Klassen?', 'answer': 'Ein Objekt ist eine Instanz einer Klasse.'},
     {'question': 'Welches Problem kann bei der Vererbung auftreten, wenn sie nicht in Einklang mit den Prinzipien von Generalisierung und Spezialisierung angewendet wird?', 'answer': 'Ein Problem bei der Vererbung tritt auf, wenn sie oberflächlich zur Wiederverwendung von Elementen einer Klassendefinition verwendet wird, ohne die Prinzipien von Generalisierung und Spezialisierung zu berücksichtigen. Dies kann dazu führen, dass die Beziehung zwischen den Extensionen der beteiligten Klassen nicht angemessen berücksichtigt wird und zu unerwarteten Konsequenzen führt.'},
     {'question': 'Was bedeutet es, dass Objekte passiv sind?', 'answer': 'Objekte sind passiv, was bedeutet, dass sie nur aktiv sind, solange sie gerade eine Methode ausführen. Im Wesentlichen sind Objekte in der objektorientierten Programmierung nicht anders als Variablen in prozeduralen Programmiersprachen. Sie enthalten Daten und können auf diese Daten zugreifen, aber sie können nicht von sich aus Aktionen ausführen. Stattdessen müssen ihnen Nachrichten gesendet werden, um sie zu aktivieren und sie dazu zu bringen, eine Methode auszuführen.'},
     {'question': 'Was bedeutet es, wenn man von einer Klasse spezialisiert?', 'answer': 'Wenn man von einer Klasse spezialisiert, erweitert man diese Klasse um neue Eigenschaften und Verhaltensweisen. Die spezialisierte Klasse ist eine Unterklasse der ursprünglichen Klasse und erbt alle Eigenschaften und Verhaltensweisen von dieser.'},
     {'question': 'Was sind die Schwierigkeiten bei einer Vererbung unter Instanzen?', 'answer': 'Die Vererbung unter Instanzen kann das Nachvollziehen und Debuggen eines Programms schwieriger machen, da die Vererbungshierarchie nicht so einfach zu verfolgen ist wie bei der Vererbung unter Klassen. Die Vererbung unter Klassen ist üblicherweise hierarchisch und bietet eine klare Struktur, während die Vererbung unter Instanzen eher netzartig sein kann und daher schwieriger nachzuvollziehen ist.'}
     ],
    [{'question': 'Wann kann eine Lazy initialization sinnvoll sein?', 'answer': '"Lazy initialization" ist eine Technik, bei der die Initialisierung von Instanzvariablen zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt wird. Dies kann sinnvoll sein, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Die Initialisierung wird verschoben, um den Preis der Initialisierung im Programmablauf zu sparen, wenn sie nie notwendig wird.'},
     {'question': 'Wie sieht die Abstraktionshierarchie in SMALLTALK aus?', 'answer': 'In SMALLTALK gibt es eine Abstraktionshierarchie, bei der von konkreten Objekten der Ebene 0 über Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Konzepte auf Ebene 2 und schließlich zur Fassung von Definitionen auf Ebene 3 fortgeschritten wird.'},
     {'question': 'Wie lässt sich die Vererbung von Superklassen auf Subklassen umsetzen?', 'answer': 'Es gibt verschiedene Möglichkeiten, den Mechanismus der Vererbung von Superklassen auf Subklassen umzusetzen. Zwei dieser Möglichkeiten wurden im Text angedeutet: Kopieren und Einfügen: Eine Möglichkeit wäre, die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Dies würde die Semantik der Vererbung korrekt wiedergeben, aber bei Änderungen an der Superklasse müssten auch alle Subklassen aktualisiert werden, was technisch problematisch wäre. Automatische Instanzerzeugung: Eine andere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch Instanzen aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Dies würde jedoch das Konzept der Identität von Objekten beeinträchtigen, da Objekte einer Subklasse mehrere Identitäten hätten.'},
     {'question': 'Was ist ein Beispiel für eine abstrakte Klasse in SMALLTALK?', 'answer': 'Ein Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse "Collection". Ihre Abstraktheit zeigt sich darin, dass sie keine benannten Instanzvariablen hat und einige ihrer Methoden, wie "add:", nicht implementiert sind. Wenn jemand versuchen würde, die Methode "add:" auf einer Instanz von "Collection" oder einer ihrer Subklassen aufzurufen, würde dies zu einer Fehlermeldung führen.'},
     {'question': 'Wie wird Delegation in prototypenbasierten objektorientierten Programmiersprachen genutzt?', 'answer': 'Delegation ist eine Beziehung zwischen zwei Objekten, bei der ein Objekt (Delegierter) die Verantwortung für die Bearbeitung bestimmter Anfragen an ein anderes Objekt (Delegator) überträgt. In prototypenbasierten objektorientierten Programmiersprachen wird Delegation genutzt, um die Funktion der Vererbung zu übernehmen. Sie kann dynamisch eingerichtet werden und ist von Fragen der Generalisierung/Spezialisierung befreit, was sie zu einer beliebten Alternative zur Vererbung macht.'},
     {'question': 'Wie kann man in Smalltalk automatische Zugriffsmethoden für alle benannten Instanzvariablen generieren?', 'answer': 'Dies ist möglich, indem man eine neue Methode zur Klassendefinition in der Klasse "Class" oder "Behavior" hinzufügt, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert.'},
     {'question': 'Wie wird der Zustand eines Objekts in Smalltalk verändert?', 'answer': 'Der Zustand eines Objekts in Smalltalk wird verändert, indem die Werte seiner Instanzvariablen zugewiesen werden, was gleichbedeutend mit der Änderung seiner Beziehungen ist.'},
     {'question': 'Wann entstehen Aliase in Smalltalk?', 'answer': 'Aliase entstehen in Smalltalk immer bei der Zuweisung, wenn die Variable auf der linken Seite Verweissemantik hat.'},
     {'question': 'Wie werden Informationen in der objektorientierten Programmierung in Smalltalk dargestellt?', 'answer': 'In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt, das navigiert und manipuliert werden kann.'},
     {'question': 'Wann sollte self class und wann self species in Smalltalk verwendet werden?', 'answer': 'Wenn man eine Kopie oder Konvertierung durchführen möchte und kein Objekt des gleichen Typs zurückgegeben werden darf, sollte man self species anstelle von self class verwenden.'},
     {'question': 'Wie werden Klassenvariablen und -methoden in SMALLTALK vererbt?', 'answer': 'In SMALLTALK werden Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt. Dies geschieht automatisch parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind.'},
     {'question': 'Wie werden Klassen und Metaklassen in SMALLTALK unterschieden?', 'answer': 'In SMALLTALK gibt es zwei Arten von Objekten: solche, die instanziierbar sind (Klassen) und solche, die es nicht sind. Darüber hinaus gibt es eine Unterscheidung zwischen Klassen, die Metaklassen sind, und solchen, die es nicht sind. Diese Unterscheidungen müssen irgendwo getroffen werden. Die Klasse Object ist nicht die Wurzel der Vererbungshierarchie der Metaklassen, sondern erbt von einer für diesen Zweck vorgesehenen Klasse. Die Klasse Class ist die Superklasse aller Metaklassen, ist aber selbst keine Metaklasse. Die Klasse von Class ist Class class und erst Class class eine Metaklasse.'},
     {'question': 'Wie ist die Vererbungshierarchie der Metaklassen in SMALLTALK organisiert?', 'answer': 'In SMALLTALK können Metaklassen, die ebenfalls Klassen sind, voneinander erben. Die Vererbungshierarchie der Metaklassen wird parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind, erstellt. Dies bedeutet, dass in SMALLTALK sowohl Instanzvariablen und -methoden als auch Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt werden. Jede Metaklasse in SMALLTALK erbt automatisch von "Object class", der Metaklasse von "Object". Die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, einschließlich der Standardkonstruktoren "new" und "new:", werden in "Object class" (genauer gesagt als Instanzmethoden von "Object class") definiert. Um die Unterscheidung zwischen instanziierbaren Klassen (Klassen) und nicht instanziierbaren Klassen (Metaklassen) sowie zwischen Klassen und Metaklassen zu treffen, wird die Klasse "Class" verwendet. "Class" ist die Superklasse aller Metaklassen und stellt sicher, dass jede Instanz dieser Klasse eine Klasse ist. Obwohl "Class" die Superklasse aller Metaklassen ist, ist sie selbst keine Metaklasse. Die Klasse von "Class" ist "Class class", und erst "Class class" ist eine Metaklasse.'},
     {'question': 'Wie werden Metaklassen in SMALLTALK erstellt?', 'answer': 'In SMALLTALK werden Metaklassen automatisch erstellt, wenn eine neue Klasse definiert wird. Jede Klasse hat automatisch ihre eigene Metaklasse, die die Definitionen von Instanzvariablen und Methoden für diese Klasse enthält.'},
     {'question': 'Wie können Programmierer in SMALLTALK geerbte Methoden löschen?', 'answer': 'In SMALLTALK können Programmierer geerbte Methoden löschen, indem sie die Methode "shouldNotImplement" in der Subklasse implementieren und die geerbte Methode überschreiben. Wenn eine Klasse also eine geerbte Methode löschen möchte, überschreibt sie diese Methode einfach mit "shouldNotImplement". Diese Konvention ermöglicht es Programmierern, geerbte Methoden elegant auszulöschen, sollte dies erforderlich sein. Es ist jedoch wichtig zu beachten, dass der Wunsch, geerbte Methoden zu löschen, eine direkte Folge der Orientierung an Vererbung ist, die in dieser Textpassage kritisiert wird. Wenn die Superklasse auf Grundlage des Prinzips der Generalisierung ausgewählt wurde, besteht normalerweise keine Notwendigkeit, geerbte Methoden zu löschen, da alles, was für die Generalisierung sinnvoll ist, auch für ihre Spezialisierungen sinnvoll ist.'},
     {'question': 'Wie werden Instanzvariablen in SMALLTALK standardmäßig initialisiert, nachdem eine Instanz erzeugt wurde?', 'answer': 'Nach der Erzeugung einer Instanz in SMALLTALK haben alle Instanzvariablen standardmäßig den Wert "nil". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden, normalerweise durch Aufrufen der Methode "initialize".'},
     {'question': 'Wie werden Klassendefinitionen in SMALLTALK umgesetzt?', 'answer': 'In SMALLTALK erfolgt die Klassendefinition nicht in einer separaten Datei wie in vielen anderen objektorientierten Programmiersprachen. Stattdessen werden Klassendefinitionen durch Eintragungen in eine Datenstruktur oder das Erzeugen eines Objekts repräsentiert. Es gibt keine spezielle Syntax für Klassendefinitionen, nur ein Schema.'},
     {'question': 'Wie funktioniert die Verwendung von super in SMALLTALK?', 'answer': 'Wenn super als Nachrichtenempfänger in einer Methodendefinition verwendet wird, beginnt die Suche nach der zur Nachricht passenden Methodendefinition in der (direkten) Superklasse der Klasse, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet. Anders als bei self ist die Suche unabhängig von der Klasse des Objekts, für das super steht. Das bedeutet, dass super immer eine von der Klasse des konkreten Empfängerobjekts losgelöste Suche auslöst, die in der Superklasse der Klasse beginnt, in der super verwendet wird, und nicht in der Superklasse der Klasse, von der das (durch super bezeichnete) Empfängerobjekt eine direkte Instanz ist.'},
     {'question': 'Warum werden in SMALLTALK keine aktiven Objekte verwendet?', 'answer': 'In SMALLTALK wird Parallelverarbeitung nicht in Form von aktiven Objekten, sondern in Form von parallelen Prozessen implementiert. Dies liegt daran, dass aktive Objekte, die asynchron Nachrichten verarbeiten, in der Praxis sehr aufwendig wären.'},
     {'question': 'Wie erfolgt die Synchronisation von parallelen Prozessen in SMALLTALK?', 'answer': 'Die Synchronisation von parallelen Prozessen in SMALLTALK erfolgt zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen über Methoden wie "wait" und "signal", um die Ausführung von Prozessen zu steuern. Semaphore-Objekte zählen die Anzahl der Signale und können Prozesse in den Schlaf versetzen oder aufwecken, abhängig von ihrem aktuellen Zustand. Die Synchronisation kann auch über die Klasse SharedQueue erfolgen, die Objekte aufnimmt und Synchronisation über "next" und "nextPut:" ermöglicht.'},
     {'question': 'Wie funktioniert die Suche nach einer Methode in SMALLTALK?', 'answer': 'Bei der Suche nach einer Methode wird zunächst im Methodenwörterbuch der Klasse des Empfängers nachgeschlagen. Wenn die Methode dort nicht gefunden wird, wird in der direkten Superklasse der Klasse des Objekts gesucht, und dieser Prozess setzt sich fort, bis die Methode gefunden wird oder bis zur Klasse "Object". Sobald die Methode gefunden wird, wird sie ausgeführt. Falls die Methode auch in "Object" nicht gefunden wird, wird die Nachricht "doesNotUnderstand:" an den ursprünglichen Empfänger mit der ursprünglichen Nachricht als Argument gesendet.'},
     {'question': 'Wie können Zu-n-Beziehungen in SMALLTALK gepflegt werden?', 'answer': 'In SMALLTALK werden Zu-n-Beziehungen standardmäßig mit den Methoden add: und remove: gepflegt. Diese Methoden sind in der abstrakten Klasse Collection definiert, und alle Klassen, die : n-Beziehungen repräsentieren, sind indirekte Instanzen von Collection. Diese Methoden bleiben zunächst abstrakt und müssen in den entsprechenden Subklassen implementiert werden.'},
     {'question': 'Wie wird die Vererbung in SMALLTALK und vielen anderen objektorientierten Programmiersprachen umgesetzt?', 'answer': 'In SMALLTALK und vielen anderen objektorientierten Programmiersprachen wird die Vererbung als ein Teilen der Klassendefinitionen realisiert. Das bedeutet, dass Vereinbarungen, die in einer Klasse getroffen wurden, automatisch auch für alle Subklassen gelten, es sei denn, diese spezifizieren etwas anderes. Die Vereinbarungen werden nicht übertragen oder kopiert, sondern einfach gemeinsam genutzt. Dies ermöglicht eine effiziente Vererbung von Eigenschaften und Verhalten, ohne die Probleme mit der Identität von Objekten oder der Notwendigkeit der Aktualisierung von Subklassen bei Änderungen in der Superklasse.'},
     {'question': 'Wie kann man das Problem der Spezialisierung von Klassen lösen?', 'answer': 'Das Problem der Spezialisierung von Klassen kann elegant gelöst werden, indem parallel zur spezialisierten Klasse eine Klasse "NichtSpezialisierteKlasse" eingeführt wird. Alle Eigenschaften, die andere Instanzen von derselben Generalisierung unterscheiden, können in der "NichtSpezialisierteKlasse" platziert werden. Dadurch bleibt die Hierarchie sauber und ermöglicht eine klare Unterscheidung zwischen spezialisierten und nicht spezialisierten Klassen.'},
     {'question': 'Wie werden Klassen in SMALLTALK erzeugt?', 'answer': 'In SMALLTALK werden Klassen erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Dies ist notwendig, da Instanzen in SMALLTALK grundsätzlich über Konstruktoren erstellt werden, und jede Klasse ist eine Instanz ihrer Metaklasse.'},
     {'question': 'Wie kann in SMALLTALK verhindert werden, dass Instanzen einer abstrakten Klasse erzeugt werden?', 'answer': 'In SMALLTALK erfolgt die Erkennung, dass eine abstrakte Klasse instanziiert wurde, zur Laufzeit, wenn versucht wird, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere "new" und "new:", entsprechend überschreiben. Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von der abstrakten Klasse erben, was oft nicht akzeptabel ist.'},
     {'question': 'Wie wird die Unterscheidung nach den Parameterobjekten in SMALLTALK durchgeführt?', 'answer': 'In SMALLTALK kann die Unterscheidung nach den Parameterobjekten mithilfe einer Technik namens "Double Dispatch" durchgeführt werden. Bei dieser Technik wird im Rumpf einer Methode dieselbe Methode noch einmal aufgerufen, wobei Empfänger (self) und Parameter vertauscht werden. Die Klasse des Empfängers wird im Nachrichtenselektor der neu aufgerufenen Methode kodiert. Dadurch erfolgt die dynamische Bindung zweimal hintereinander, einmal für den Empfänger und einmal für den Parameter, um die richtige Methode basierend auf beiden Objekten auszuwählen.'},
     {'question': 'Wie ist die Definition einer Metaklasse aufgebaut?', 'answer': 'Die Definition einer Metaklasse ist ähnlich wie die einer normalen Klasse aufgebaut, bestehend aus benannten Instanzvariablen und Instanzmethodendefinitionen. Der Klassenname kann jedoch nicht frei angegeben werden. Indizierte Instanzvariablen sind nicht vorgesehen.'},
     {'question': 'Wie ist das Verhältnis von Klassen und Metaklassen in SMALLTALK?', 'answer': 'Aufgrund der bestehenden 1-zu-1-Beziehung zwischen Klassen und Metaklassen werden diese in SMALLTALK nicht getrennt voneinander definiert, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt demnach neben den Abschnitten zur Deklaration der Instanzvariablen und zur Definition der Methoden auch noch über zwei Abschnitte für die entsprechenden Angaben zur ihrer Metaklasse, die Angabe der sogenannten Klassenvariablen und -methoden.'},
     {'question': 'Wie kann man ein Objekt vergrößern?', 'answer': 'Eine Möglichkeit, ein Objekt zu vergrößern, ist das "Umziehen" der Repräsentation des Objekts in den Speicher. Dazu wird ein neues Objekt mit der doppelten Größe angelegt, die Daten werden in das neue Objekt kopiert und das alte Objekt wird durch das neue Objekt ersetzt. Die Methode grow erzeugt eine neue ArrayedCollection mit einer um 100 erhöhten Größe und kopiert den Inhalt der alten ArrayedCollection in die neue. Anschließend gibt sie die neue ArrayedCollection zurück.'},
     {'question': 'Wie wird die Initialisierung von Instanzvariablen in Smalltalk durchgeführt?', 'answer': 'In Smalltalk wird die Initialisierung von Instanzvariablen durchgeführt, indem die Methode "initialize" aufgerufen wird, die standardmäßig von den Methoden "new" und "new:" vorgesehen ist. Diese Methode kann alle Initialisierungen vornehmen, ohne dass etwas über den Aufbau der Instanzen nach außen verraten wird.'},
     {'question': 'Wie funktioniert die Vererbung in SMALLTALK?', 'answer': 'In SMALLTALK hat Vererbung eine Kopieren-und-Einfügen-Semantik, d.h. wenn man die Implementierung einer Methode aus der Superklasse in die Subklasse wiederholt, erhält man das gleiche Ergebnis.'},
     {'question': 'Wann sollte man offene Rekursion nicht verwenden?', 'answer': 'Man sollte offene Rekursion nicht verwenden, wenn sie zu Problemen führen kann, die als "Fragile-base-class-Problem" bekannt sind.'},
     {'question': 'Wie würden aktive Objekte kommunizieren?', 'answer': 'Aktive Objekte würden asynchron kommunizieren, indem sie Nachrichten (Methodenaufrufe) ohne Prozess empfangen und dann abarbeiten, wenn sie die Zeit dazu haben.'},
     {'question': 'Wie wird Parallelverarbeitung in Smalltalk und Java umgesetzt?', 'answer': 'In Smalltalk und Java wird Parallelverarbeitung durch parallele Prozesse umgesetzt, die zu einer Zeit eine Methode ausführen. Diese Prozesse besuchen mit dem Methodenaufruf die Empfängerobjekte, die jedoch selbst passiv bleiben und kein Eigenleben haben.'},
     {'question': 'Wie wird eine Methode in SMALLTALK aufgerufen?', 'answer': 'In SMALLTALK wird eine Methode auf einem Empfängerobjekt aufgerufen, indem zunächst geprüft wird, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Diese Prüfung kann man auch selbst durchführen, indem man die Instanzmethode includesSelector: der Klasse Behavior aufruft, die allen Klassen zur Verfügung steht.'},
     {'question': 'Wie ist die Beziehung zwischen Klassen und Objekten in SMALLTALK?', 'answer': 'In SMALLTALK gibt es eine 1:n-Beziehung zwischen Klassen und Objekten. Klassen stellen die Definitionen für Objekte bereit und repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit. Objekte werden durch Instanziierung von Klassen erstellt.'},
     {'question': 'Wie passiert in SMALLTALK die Instanziierung?', 'answer': 'In SMALLTALK wird normalerweise die Instanziierung eines Objekts durch Senden der Nachricht "new" (für Klassen ohne indizierte Instanzvariablen) oder "new:" (für Klassen mit indizierten Instanzvariablen) an die Klasse durchgeführt. Das neue Objekt wird im Speicher angelegt, und seine Instanzvariablen werden alle mit "nil" initialisiert.'},
     {'question': 'Wie werden in Smalltalk Klassen verwaltet?', 'answer': 'In Smalltalk werden alle Klassen, die in einem SMALLTALK-System zur Verfügung stehen, in einem gemeinsamen Namensraum verwaltet.'},
     {'question': 'Wie funktionieren Factory-Methoden?', 'answer': 'Factory-Methoden sind statische Methoden, die eine Instanz einer bestimmten Unterklasse erzeugen und zurückgeben, anstatt die Instanz direkt zu instanziieren. Sie entscheiden dynamisch, welche Unterklasse instanziiert werden soll, abhängig von den gegebenen Eingaben. Dadurch können sie die richtige Instanzklasse auswählen und eine Instanz dieser Klasse zurückgeben, ohne dass der Aufrufer sich um die Details der Instanziierung kümmern muss.'},
     {'question': 'Wie hängt die Intension und Extension zusammen?', 'answer': 'Je größer die Intension (die Menge der Eigenschaften) ist, desto kleiner ist die Extension (die Menge der Objekte, die diese Eigenschaften erfüllen).'},
     {'question': 'Wann wird das Empfängerobjekt und die Parameterobjekte bei der Auswahl einer Methode berücksichtigt?', 'answer': 'Das Empfängerobjekt und die Parameterobjekte werden bei der Auswahl einer Methode berücksichtigt, wenn die Auswahl der geeigneten Methode von den tatsächlichen Parametern abhängt.'},
     {'question': 'Wie wird die Parametrische Polymorphie in der objektorientierten Programmierung implementiert?', 'answer': 'In der objektorientierten Programmierung wird Parametrische Polymorphie in der Regel durch Überladen von Methoden implementiert. Dabei werden mehrere Methoden mit dem gleichen Namen, aber unterschiedlichen Parametern definiert. Wenn eine Nachricht gesendet wird, wird die Methode mit den passenden Parametern ausgewählt und ausgeführt.'},
     {'question': 'Wann spielen die tatsächlichen Parameter eine Rolle bei der Methodenauswahl?', 'answer': 'Die tatsächlichen Parameter spielen eine Rolle bei der Methodenauswahl, wenn eine Methode für verschiedene Datentypen unterschiedlich implementiert ist, wie zum Beispiel bei arithmetischen Operatoren.'},
     {'question': 'Was ist der Zweck von Konvertierungsmethoden in Collection?', 'answer': 'Der Zweck von Konvertierungsmethoden in Collection ist es, eine Menge von Objekten aus einer Collection in eine andere zu übertragen, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, wie z.B. das Entfernen doppelter Elemente bei der Konvertierung in eine Menge (asSet) oder das Sortieren der Elemente bei der Konvertierung in eine sortierte Collection (asSortedCollection).'},
     {'question': 'Was ist ein Beispiel für eine instanziierbare Collection-Klasse in SMALLTALK?', 'answer': 'Einige Beispiele für spezielle, instanziierbare (konkrete) Collection-Klassen in SMALLTALK sind: Set: Diese Klasse wird verwendet, um ungeordnete Collections darzustellen, in denen jedes Element höchstens einmal vorkommen darf, was einer Menge entspricht. Bag: Bag wird verwendet, um ungeordnete Collections darzustellen, in denen die Einschränkung aufgehoben ist, dass Elemente nur einmal vorkommen dürfen. In einer Bag können Elemente mehrmals vorhanden sein. SequenceableCollection oder IndexedCollection: Diese Klassen repräsentieren geordnete Collections, bei denen das i-te Element eindeutig bestimmt ist. Sie implementieren die Methoden "at:" und "at:put:", um auf Elemente zuzugreifen oder Elemente an einer bestimmten Position einzufügen oder zu ändern. Dictionary: Diese Klasse repräsentiert eine ungeordnete Collection, bei der jedes Element unter einem Schlüssel gespeichert wird. Die Methoden "at:" und "at:put:" werden verwendet, um auf die Elemente zuzugreifen oder sie zu ändern. Dabei können Schlüssel Objekte verschiedener Klassen sein, nicht nur Integer.'},
     {'question': 'Was ist der Zweck von Klassen in SMALLTALK?', 'answer': 'In SMALLTALK hat jede Klasse Instanz ihre eigenen Instanzvariablen und Methoden, die nur für sie angelegt werden können. Dies ermöglicht eine Programmierpraxis, bei der jede Klasse ihre eigenen Instanzvariablen und Methoden besitzt und die Programmiererin diese frei bestimmen kann, ohne dabei an andere Klassen denken zu müssen.'},
     {'question': 'Was ist der Zweck von Konstruktoren in der objektorientierten Programmierung?', 'answer': 'Konstruktoren sind spezielle Methoden in der objektorientierten Programmierung, die verwendet werden, um neue Objekte einer Klasse zu initialisieren. Sie werden aufgerufen, wenn ein neues Objekt erstellt wird und werden verwendet, um die Anfangswerte der Attribute des Objekts festzulegen. In dem gegebenen Beispiel, werden zwei alternative Konstruktoren für die Klasse "Time" definiert, die die neuen Objekte jeweils unterschiedlich initialisieren.'},
     {'question': 'Was ist der Zweck der Vererbung?', 'answer': 'Der Zweck der Vererbung ist es, die Definition einer Superklasse auf eine Subklasse zu übertragen, um die Wiederverwendung von Code zu erhöhen und die Wartbarkeit des Codes zu verbessern.'},
     {'question': 'Wie unterscheidet sich die SortedCollection in SMALLTALK von anderen Collection-Klassen?', 'answer': 'Eine SortedCollection ist eine Collection-Klasse in SMALLTALK, die eine Subklasse von OrderedCollection ist. Im Gegensatz zu anderen Collection-Klassen wird die Reihenfolge der Elemente in einer SortedCollection nicht von außen, durch Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt. Stattdessen wird die Reihenfolge von innen durch eine Qualität der eingefügten Objekte bestimmt. Dies ermöglicht es, die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge zu halten, unabhängig von der Reihenfolge, in der sie der Collection hinzugefügt wurden.'},
     {'question': 'Wie Unterschiden sich Factory-Methode von Konstruktoren?', 'answer': 'Eine Factory-Methode ist eine Methode, die eine neue Instanz liefert, ähnlich wie ein Konstruktor. Der Unterschied liegt darin, dass die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode gehört, abhängig gemacht wird. In SMALLTALK sind Factory-Methoden einfach zu implementieren und unterscheiden sich formal nicht von Konstruktoren, da es sich einfach um Klassenmethoden handelt.'},
     {'question': 'Warum hat sich die klassenbasierte Form der objektorientierten Programmierung gegenüber der prototypenbasierten Form durchgesetzt?', 'answer': 'Die klassenbasierte Form der objektorientierten Programmierung hat sich vermutlich aus verschiedenen Gründen durchgesetzt. Zum einen bieten Klassen ein etabliertes Ordnungskonzept, das in anderen Disziplinen wie Mathematik und Biologie verwendet wird, und das sich gut zur Strukturierung von objektorientierten Programmen eignet. Zum anderen eignen sich Klassen als Vorlagen für Typen, was die Integration von objektorientierter Programmierung in typisierte Sprachen ermöglicht. Die prototypenbasierte Form der Objektorientierung bietet hingegen Flexibilität bei der Anpassung von einzelnen Objekten an ihren Zweck und ist besonders nützlich in interaktiven Anwendungen.'},
     {'question': 'Warum benötigen Klassen in SMALLTALK ihre eigenen Metaklassen?', 'answer': 'Klassen in SMALLTALK benötigen ihre eigenen Metaklassen, damit sie ihre eigenen Instanzvariablen und Methoden definieren können, ohne die Definitionen anderer Klassen zu beeinflussen. Dies ermöglicht eine hohe Flexibilität und erlaubt es den Programmierern, das Verhalten von Klassen individuell anzupassen.'},
     {'question': 'Warum erhalten Programmierer in SMALLTALK erst zur Laufzeit des Programms eine Fehlermeldung, wenn sie eine Nachricht an eine Instanz einer abstrakten Klasse senden?', 'answer': 'In SMALLTALK und ähnlichen objektorientierten Programmiersprachen erhalten Programmierer zur Laufzeit des Programms eine Fehlermeldung, wenn sie eine Nachricht an eine Instanz einer abstrakten Klasse senden, da diese abstrakten Klassen unvollständig sind und daher nicht implementierte Methoden enthalten können. Die Fehlermeldung, die durch die Methode "doesNotUnderstand:" (in der Klasse "Object") ausgelöst wird, informiert die Programmierer darüber, dass die Methode in einer Subklasse implementiert werden sollte. Dieser Ansatz entspricht dem interaktiven Geist des SMALLTALK-Systems, bei dem das Programmieren als iteratives Zurechtbiegen und Erweitern eines bereits funktionierenden Systems betrachtet wird.'},
     {'question': 'Warum ist eine Eins-zu-viele-Kommunikation im MVC-Pattern erforderlich?', 'answer': 'Im MVC-Pattern gibt es verschiedene Ansichten auf ein logisches Modell. Wenn Änderungen im Modell potenziell alle Ansichten betreffen, müssen diese Änderungen alle Ansichten darüber informieren. Daher ist eine Eins-zu-viele-Kommunikation erforderlich, um sicherzustellen, dass alle betroffenen Ansichten aktualisiert werden.'},
     {'question': 'Warum sind Generalisierung und Spezialisierung in der objektorientierten Programmierung relevant?', 'answer': 'Obwohl Generalisierung und Spezialisierung eher theoretisch motivierte Konzepte sind, sind sie dennoch relevant, da sie dazu beitragen, die Struktur und Hierarchie von Klassen in objektorientierten Programmen zu definieren. Sie ermöglichen es, Klassen in Beziehung zueinander zu setzen und abstrakte Modelle für die Softwareentwicklung zu entwickeln. Diese Konzepte können in komplexen Softwareprojekten zur Verbesserung der Wartbarkeit und Erweiterbarkeit beitragen.'},
     {'question': 'Warum gibt es in SMALLTALK mindestens eine Klasse, die keine Subklasse ist?', 'answer': 'In SMALLTALK ist die Subklassenbeziehung nicht reflexiv, was bedeutet, dass jede Klasse mindestens eine Superklasse haben muss. Diese oberste Superklasse ist die Klasse "Object". In "Object" sind Definitionen enthalten, die den Instanzen aller Klassen zugutekommen sollen, und diese Methoden werden per Vererbung auf alle anderen Klassen übertragen.'},
     {'question': 'Warum könnte die Vererbung zwischen Instanzen in der objektorientierten Programmierung das Verfolgen und Debuggen von Programmen erschweren?', 'answer': 'Die Vererbung zwischen Instanzen kann das Verfolgen und Debuggen von Programmen erschweren, da sie die Beziehungen zwischen Objekten komplexer gestaltet. Wenn Objekte Eigenschaften und Verhalten von anderen Objekten erben können und diese Eigenschaften überschreiben oder löschen können, kann dies zu unvorhersehbarem Verhalten führen und die Fehlersuche erschweren.'},
     {'question': 'Warum sind abstrakte Klassen in der objektorientierten Programmierung nicht instanziierbar?', 'answer': 'Abstrakte Klassen sind in der Regel nicht instanziierbar, weil ihnen oft die notwendigen Informationen fehlen, um Instanzen vollständig zu initialisieren. Sie dienen als Vorlagen für Subklassen, die die fehlenden Details ergänzen.'},
     {'question': 'Warum sind Klassen keine Instanzen einer speziellen Klasse "Class"?', 'answer': 'Wenn Klassen Instanzen einer speziellen Klasse "Class" wären, hätten sie dieselbe Menge von Instanzvariablen und Methoden. Das würde aber bedeuten, dass alle Klassen gleich wären, was nicht der Fall ist. Jede Klasse hat ihre eigene, einzigartige Menge von Instanzvariablen und Methoden. Deshalb sind Klassen keine Instanzen einer speziellen Klasse "Class".'},
     {'question': 'Warum kann es sinnvoll sein, eine Methode wie "new" für bestimmte Klassen anders zu definieren?', 'answer': 'Es kann sinnvoll sein, eine Methode wie "new" für bestimmte Klassen anders zu definieren, um die Instanzvariablen der neu erzeugten Instanzen bestimmte Startwerte zuzuweisen oder um das Verhalten der Methode an die Anforderungen der Klasse anzupassen.'},
     {'question': 'Warum ist das Entfernen von Instanzvariablen oder Methoden unvereinbar mit der Spezialisierung?', 'answer': 'Das Entfernen von Instanzvariablen oder Methoden ist unvereinbar mit der Spezialisierung, weil die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Zudem würde die Richtung von Spezialisierung und Generalisierung beliebig werden, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte.'},
     {'question': 'Warum ist die Vererbung in der objektorientierten Programmierung problematisch?', 'answer': 'Die Vererbung in der objektorientierten Programmierung ist problematisch, weil sie oft fälschlicherweise als ein Zeichen für eine Generalisierung/Spezialisierung interpretiert wird. Es ist jedoch möglich, dass eine Klasse Eigenschaften einer anderen Klasse erbt, ohne dass sie eine Spezialisierung der vererbenden Klasse ist. Ein klassisches Beispiel hierfür ist die Ableitung der Klasse Rechteck von der Klasse Quadrat, was zu unangenehmen Folgen führen kann.'},
     {'question': 'Warum sollte das Attribut, das als Schlüssel in einem Dictionary verwendet wird, unveränderlich sein?', 'answer': 'Das Attribut, das als Schlüssel in einem Dictionary verwendet wird, sollte unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden wird. Wenn das Attribut veränderlich ist, kann es zu Problemen bei der Suche nach dem Objekt im Dictionary führen, da der alte Attributwert nicht mehr gültig ist.'}
     ],
    [{'question': 'Was ist der Unterschied zwischen dem Konstruktoransatz und dem Klassenansatz in der objektorientierten Programmierung?', 'answer': 'Beim Konstruktoransatz wird der Aufbau eines Objekts in einer Methode beschrieben, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden. Bei jedem Aufruf dieser Methode entsteht ein neues Objekt. Im Gegensatz dazu, erzeugt der Klassenansatz Objekte als Instanzen von bestimmten Vorlagen, die als Klassen bezeichnet werden. Alle Objekte, die von einer Klasse erzeugt werden, haben dieselben Instanzvariablen und Methoden.'},
     {'question': 'Was ist der Unterschied zwischen dem Prototypenansatz und dem Klassenansatz in der objektorientierten Programmierung?', 'answer': 'Beim Prototypenansatz wird ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont und bei Bedarf um weitere Instanzvariablen und Methoden ergänzt. Im Gegensatz dazu, erzeugt der Klassenansatz Objekte als Instanzen von bestimmten Vorlagen, die als Klassen bezeichnet'},
     {'question': 'Was ist der Unterschied zwischen aktiven und passiven Objekten?', 'answer': 'Aktive Objekte sind Objekte, die über einen eigenen Rechenprozess verfügen und Nachrichten asynchron empfangen und verarbeiten können. Passive Objekte hingegen sind Objekte, die nur aktiv sind, solange sie gerade eine Methode ausführen. In der Praxis werden jedoch passive Objekte verwendet, da aktive Objekte sehr aufwendig wären.'},
     {'question': 'Was ist der wesentliche Nachteil von Arrays in SMALLTALK?', 'answer': 'Der wesentliche Nachteil von Arrays in SMALLTALK ist, dass ihre Größe beschränkt ist. Das bedeutet, dass die Anzahl der Elemente in einem Array begrenzt ist, und es schwierig oder teuer sein kann, die Größe eines Arrays dynamisch zu ändern, um mehr Elemente aufzunehmen.'},
     {'question': 'Welcher Vorteil ergibt sich aus der Verwendung von Zwischenobjekten in Zu-n-Beziehungen?', 'answer': 'Ein entscheidender Vorteil der Verwendung von Zwischenobjekten in Bezug auf Zu-n-Beziehungen ist die Möglichkeit, verschiedene Arten von solchen Beziehungen zu definieren und diesen jeweils spezifisches Verhalten zuzuweisen, das auf die Art der Beziehung abgestimmt ist. Dies ermöglicht es, mengenwertige Beziehungen oder sortierte Beziehungen zu erstellen und Operationen wie das Hinzufügen oder Entfernen von Objekten individuell anzupassen.'},
     {'question': 'Was ist der Unterschied zwischen lesbaren und schreibbaren Streams?', 'answer': 'Lesbare Streams sind Ströme, die nur zum Lesen von Daten verwendet werden können, während schreibbare Streams zum Schreiben von Daten verwendet werden können.'},
     {'question': 'Was ist der Unterschied zwischen einer Metaklasse und einer normalen Klasse?', 'answer': 'Der Unterschied zwischen einer Metaklasse und einer normalen Klasse besteht darin, dass Metaklassen keine indizierten Instanzvariablen enthalten dürfen und der Klassenname nicht frei angegeben werden kann.'},
     {'question': 'Was ist der Unterschied zwischen Instanzvariablen und Klassenvariablen?', 'answer': 'Der Unterschied zwischen Instanzvariablen und Klassenvariablen liegt darin, dass Instanzvariablen jeweils zu einer Instanz gehören, während Klassenvariablen zu einer Klasse gehören. Das bedeutet, dass jede Instanz einer Klasse ihre eigenen Werte für die Instanzvariablen hat, während alle Instanzen einer Klasse die gleichen Werte für die Klassenvariablen teilen.'},
     {'question': 'Was ist der Unterschied zwischen Generalisierung und Klassifikation in der objektorientierten Programmierung?', 'answer': 'Klassifikation ist eine Form der Ist-ein-Abstraktion, bei der man von einem Individuum zu seinem Allgemeinbegriff übergeht, während Generalisierung zwei Allgemeinbegriffe miteinander in Beziehung setzt. Ein weiterer Unterschied besteht darin, dass die Klassifikation nicht transitiv ist, während die Generalisierung es ist.'},
     {'question': 'Was ist der Unterschied zwischen Konstruktoren und Initialisierung in Smalltalk?', 'answer': 'In Smalltalk sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert "nil". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet. Somit ist der Unterschied, dass Konstruktor ein Klassenmethode ist, die eine neue Instanz erzeugt, während Initialisierung ein Vorgang ist, bei dem Instanzvariablen sinnvolle Anfangswerte zugewiesen bekommen.'},
     {'question': 'Was ist der Unterschied zwischen Konstruktoren in SMALLTALK und Konstruktoren in Sprachen wie C++, Java oder C-Sharp?', 'answer': 'In SMALLTALK sind Konstruktoren Klassenmethoden, während sie in Sprachen wie C++, Java oder C-Sharp eine Art Zwitterstatus haben und sowohl auf der Klasse als auch auf der neuen Instanz aufgerufen werden können. SMALLTALK-Konstruktoren können nicht auf die Instanzvariablen der neu erzeugten Instanz zugreifen, während Konstruktoren in C++, Java oder C-Sharp dies können.'},
     {'question': 'Was ist der Unterschied zwischen self und super?', 'answer': 'Der Unterschied liegt darin, dass die Suche bei self von der Klasse des Objekts abhängt, für das self steht, während die Suche bei super unabhängig von der Klasse des Objekts ist, für das super steht. Super beginnt die Suche immer mit der Superklasse der Klasse, in der super verwendet wird, und nicht mit der Superklasse der Klasse, von der das Empfängerobjekt eine direkte Instanz ist.'},
     {'question': 'Was ist der Unterschied zwischen dem klassenbasierten Methoden-Lookup und dem objektbasierten Methoden-Lookup?', 'answer': 'Der Unterschied zwischen dem klassenbasierten Methoden-Lookup und dem objektbasierten Methoden-Lookup besteht darin, dass man beim objektbasierten Methoden-Lookup jedem Objekt sein eigenes Methodenwörterbuch zur Verfügung stellt, während beim klassenbasierten Methoden-Lookup die Methoden in der Klasse gespeichert sind.'},
     {'question': 'Was ist der Unterschied zwischen dynamischem und statischem Binden in der objektorientierten Programmierung?', 'answer': 'Beim dynamischen Binden wird eine Nachricht an ein Objekt geschickt und es wird zur Laufzeit entschieden, welche Methode aufgerufen wird. Beim statischen Binden wird dies bereits zur Übersetzungszeit entschieden. Ein Vorteil des dynamischen Bindens ist die größere Flexibilität, allerdings müssen dafür bestimmte Laufzeitprüfungen durchgeführt werden. Statische Typprüfung kann das Risiko von Typfehlern verringern, schränkt aber die Flexibilität beim Programmieren ein.'},
     {'question': 'Was ist der Unterschied zwischen den Klassen "Set" und "Bag" in Smalltalk?', 'answer': 'Die Klasse "Set" ist eine ungeordnete Collection, in der jedes Element höchstens einmal vorkommen darf, während die Klasse "Bag" eine ungeordnete Collection ist, in der die letzte Einschränkung aufgehoben ist, d.h. in der ein Element mehrfach vorkommen kann.'},
     {'question': 'Was ist der Unterschied zwischen Spezialisierung und Instanziierung?', 'answer': 'Spezialisierung und Instanziierung sind zwei verschiedene Vorgänge. Spezialisierung bedeutet, den Wertebereich einer Instanzvariable einzuschränken, während Instanziierung bedeutet, einer Instanzvariable eines Objekts ein Element aus dem Wertebereich zuzuweisen. Im Fall von "Zweibeiner" kann durch Spezialisierung der Wertebereich der Instanzvariable "anzahlBeine" auf {2} eingeschränkt werden, während durch Instanziierung einer Instanzvariable eines Objekts der Wert 2 zugewiesen wird.'},
     {'question': 'Was ist der Unterschied zwischen Spezialisierung und Vererbung?', 'answer': 'Spezialisierung und Vererbung scheinen Hand in Hand zu gehen, aber in der Praxis kann eine unbedachte Spezialisierung zu Komplikationen führen und eine Fixierung auf die Nutzung der Vererbung zu Problemen. Spezialisierung bezieht sich auf das Erstellen einer Unterklasse, die eine Oberklasse erweitert, während Vererbung ein Mechanismus ist, bei dem eine Unterklasse die Eigenschaften und Methoden einer Oberklasse erbt.'},
     {'question': 'Was ist der Unterschied zwischen Vererbung und Generalisierung?', 'answer': 'Vererbung und Generalisierung sind zwei verschiedene Konzepte. Wenn man denkt, man hätte mit der Vererbung auch eine Generalisierungsbeziehung geschaffen, ist man auf dem Holzweg. Ein Beispiel: Die Menge der Quadrate enthält nicht die Menge der Rechtecke, was eine charakteristische Begleiterscheinung der Generalisierung gewesen wäre. Der Unterschied liegt in der Intension und Extension: Die Intension von Rechteck ist umfangreicher als die von Quadrat, da sie eine Instanzvariable mehr enthält. Die Intension von Quadrat ist aber trotzdem restriktiver als die von Rechteck, da sie eine zusätzliche Bedingung enthält.'},
     {'question': 'Was ist der Unterschied zwischen Generalisierung/Spezialisierung und Vererbung in der objektorientierten Programmierung?', 'answer': 'Generalisierung/Spezialisierung und Vererbung sind zwei verschiedene Konzepte in der objektorientierten Programmierung. Generalisierung/Spezialisierung steht für die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze, während Vererbung für die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung steht. Vererbung stellt eine Art genetischen Zusammenhang zwischen Klassen dar, während Generalisierung/Spezialisierung eher eine abstrakte Ordnung ist. Vererbung bringt Komplexität in ein System, während Generalisierung/Spezialisierung versucht, sie durch Strukturierung zu reduzieren.'},
     {'question': 'Was sind die Vorteile des klassenbasierten Ansatzes gegenüber dem prototypenbasierten Ansatz?', 'answer': 'Der klassenbasierte Ansatz ist besser geeignet, um massenhaft gleiche Objekte abzudecken, was in vielen Anwendungsdomänen der Fall ist. Im Vergleich zur Vererbung unter Instanzen, die der prototypenbasierte Ansatz bietet, ist die Vererbung unter Klassen im klassenbasierten Ansatz einfacher nachzuvollziehen und zu debuggen.'},
     {'question': 'Was ist der Unterschied zwischen abstrakten und konkreten Klassen?', 'answer': 'Abstrakte Klassen sind nicht instanziierbar, da sie in der Regel Angaben fehlen, die das Verhalten ihrer Instanzen vollständig spezifizieren. Konkrete Klassen hingegen haben eigene Instanzen und können instanziiert werden.'},
     {'question': 'Was ist der Unterschied zwischen einer Shallow Copy und einer Deep Copy?', 'answer': 'Bei einer Shallow Copy wird nur die oberste Ebene der Objektstruktur kopiert, während bei einer Deep Copy auch alle Unterobjekte rekursiv kopiert werden. Das heißt, beim flachen Klonen wird nur eine Referenz auf das Unterobjekt kopiert, während beim tiefen Klonen eine neue Kopie des Unterobjekts erstellt wird.'},
     {'question': 'Wozu werden temporäre Variablen in Smalltalk verwendet?', 'answer': 'Temporäre Variablen werden in Smalltalk verwendet, um Zwischenergebnissen Namen zu geben und die Lesbarkeit zu verbessern.'},
     {'question': 'Was können Konvertierungsmethoden in Collections tun?', 'answer': 'Konvertierungsmethoden in Collections können eine Menge von Objekten aus einer Collection in eine andere übertragen, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z.B. asSet, das doppelte Elemente entfernt. Besonders interessant sind Konvertierungen in Collections, die strengere Bedingungen stellen, z.B. asSet und asSortedCollection.'},
     {'question': 'Was passiert, wenn man die Attributwerte eines Objekts nachträglich ändert, die für die Sortierung herangezogen wurden?', 'answer': 'Eine nachträgliche Änderung der Attributwerte, die zum Vergleich der Objekte für die Sortierung herangezogen wurden, bewirkt keine automatische Änderung der Reihenfolge.'},
     {'question': 'Wozu dient das Klonen oder Kopieren?', 'answer': 'Das Klonen/Kopieren wird verwendet, um eine unabhängige Kopie eines Objekts zu erstellen, das unabhängig von der Originalinstanz geändert werden kann, ohne die Originalinstanz zu beeinflussen. Es wird auch verwendet, um Objekte zu erstellen, die mit den gleichen Daten initialisiert werden sollen, oder um Objekte zu speichern, die später wiederhergestellt werden sollen.'},
     {'question': 'Kann Vererbung in SMALLTALK auch auf Metaklassen angewendet werden?', 'answer': 'Ja, Vererbung kann in SMALLTALK auch auf Metaklassen angewendet werden, da Metaklassen ebenfalls Klassen sind. Die Vererbungshierarchie der Metaklassen wird automatisch parallel zur Vererbungshierarchie der Klassen angelegt, die Instanzen der Metaklassen sind.'},
     {'question': 'Wo werden die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, in SMALLTALK definiert?', 'answer': 'Die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, werden in Object class definiert, der Metaklasse von Object.'},
     {'question': 'Gibt es Gründe, die prototypenbasierte Form der objektorientierten Programmierung zu nutzen?', 'answer': 'Ja, es gibt gute Gründe, die prototypenbasierte Form der objektorientierten Programmierung zu nutzen. Sie erlaubt eine hohe Flexibilität bei der Anpassung von Objekten an ihren jeweiligen Zweck, insbesondere in interaktiven Anwendungen. Ein Beispiel dafür ist die Programmierung von grafischen Benutzeroberflächen, bei der verschiedene Buttons verschiedene Ereignisse auslösen können. JavaScript ist eine erfolgreiche Programmiersprache für interaktive Webseiten und basiert auf dem Prototypenansatz.'},
     {'question': 'Warum gibt es eine 1-zu-1-Beziehung zwischen Klassen und ihren Metaklassen in SMALLTALK?', 'answer': 'Die 1-zu-1-Beziehung zwischen Klassen und ihren Metaklassen in SMALLTALK gewährleistet, dass jede Klasse ihre eigenen Instanzvariablen und Methoden definieren kann, ohne andere Klassen zu beeinflussen. Dadurch wird die Flexibilität und Unabhängigkeit der Klassen in SMALLTALK gewährleistet.'},
     {'question': 'Warum ist es möglich, in SMALLTALK mehrere alternative Konstruktoren für eine Klasse zu definieren?', 'answer': 'Es ist möglich, mehrere alternative Konstruktoren für eine Klasse in SMALLTALK zu definieren, da nicht immer alle Instanzen einer Klasse auf die gleiche Weise initialisiert werden müssen. Dies ermöglicht es, verschiedene Initialisierungsmethoden für verschiedene Anwendungsfälle anzubieten.'},
     {'question': 'Was bedeutet es, dass die Subklassenbeziehung transitiv ist?', 'answer': 'Die Transitivität der Subklassenbeziehung bedeutet, dass, wenn Klasse A eine Subklasse von Klasse B ist und Klasse B eine Subklasse von Klasse C ist, dann ist Klasse A auch eine Subklasse von Klasse C. Dies bedeutet, dass die Vererbung von Eigenschaften und Verhalten in der Klassenhierarchie entlang der Subklassenbeziehung in einer kaskadierenden Weise erfolgt.'},
     {'question': 'Was unterscheidet ein direkte Subklasse und ein indirekte Subklasse?', 'answer': 'Eine direkte Subklasse ist eine Klasse, die direkt von einer anderen Klasse erbt, ohne dass eine weitere Klasse dazwischen liegt. Eine indirekte Subklasse ist eine Klasse, die von einer Superklasse erbt, die selbst von einer anderen Klasse erbt. Mit anderen Worten, eine indirekte Subklasse ist eine Subklasse, die von einer Superklasse erbt, die ebenfalls eine Subklasse ist.'},
     {'question': 'Warum muss in SMALLTALK das Empfängerobjekt einer Nachricht immer explizit angegeben werden?', 'answer': 'In SMALLTALK muss das Empfängerobjekt einer Nachricht immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. Dies unterscheidet sich von einigen anderen Programmiersprachen wie Java, in denen das Empfängerobjekt manchmal implizit ist. Die Verwendung von self ist notwendig, um das Objekt zu identifizieren, auf dem die Methode ausgeführt wird, und auf dessen Instanzvariablen zugegriffen werden kann.'},
     {'question': 'Was unterscheidet dynamische und statische Typisierung in Bezug auf das dynamische Binden?', 'answer': 'In der dynamischen Bindung, wie sie in SMALLTALK verwendet wird, erfolgt die Auswahl der Methode zur Laufzeit und hängt von der Art des Empfängerobjekts ab. In der statischen Typisierung, wie sie in statisch typgeprüften Sprachen wie Java, C-Sharp und C++ verwendet wird, erfolgt die Typüberprüfung zur Übersetzungszeit und nicht zur Laufzeit. Statisch typisierte Sprachen erfordern in der Regel, dass der Programmierer den Datentyp der Objekte und deren Methoden im Voraus festlegt, während dynamisch typisierte Sprachen mehr Flexibilität bieten, da die Typüberprüfung erst zur Laufzeit erfolgt. Allerdings erhöht die dynamische Bindung das Risiko von Laufzeitfehlern, die in statisch typisierten Sprachen vermieden werden können, indem explizite Typüberprüfungen durchgeführt werden.'},
     {'question': 'Gibt es Einschränkungen bei der Spezialisierung von Klassen?', 'answer': 'Ja, es gibt Einschränkungen bei der Spezialisierung von Klassen. Das Entfernen von Instanzvariablen oder Methoden ist vollkommen unvereinbar mit der Spezialisierung, da dies die Umkehrung der Spezialisierung, die Generalisierung, verhindern würde. Es ist jedoch möglich, Eigenschaften durch Beschränkungen zu ändern oder hinzuzufügen, aber das Entfernen ist nicht erlaubt.'},
     {'question': 'Warum kann die Vererbung allein nicht als Indikator für Generalisierung und Spezialisierung dienen?', 'answer': 'Die Vererbung allein kann nicht als Indikator für Generalisierung und Spezialisierung dienen, da sie keinen kausalen Zusammenhang zwischen Klassen herstellt. Nur weil eine Klasse Eigenschaften von einer anderen geerbt hat, bedeutet das nicht zwangsläufig, dass die erbende Klasse eine Spezialisierung der vererbenden ist. Ein klassisches Beispiel dafür wurde bereits mit der Ableitung der Klasse "Rechteck" von der Klasse "Quadrat" gegeben. Es ist wichtig zu erkennen, dass die Vererbung nicht immer eindeutig auf eine Generalisierung/Spezialisierung hinweist und vorsichtige Analyse und Planung erfordert. In einigen Fällen kann eine zu starke Vererbung sogar zu unerwünschten Ergebnissen führen.'},
     {'question': 'Was unterscheidet Extension und Intension?', 'answer': 'Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören. Die Intension ist die Summe der Merkmale oder Eigenschaften, die den Begriff ausmachen und die Objekte charakterisieren, die zu dieser Klasse gehören. Mit steigender Intension wird die Extension kleiner, und umgekehrt.'},
     {'question': 'Was könnte man tun, wenn man weitere Eigenschaften für eine Klasse haben möchte, die diese nicht mit allen anderen teilt?', 'answer': 'In diesem Fall kann man eine Unterklasse erstellen, die die gewünschten Eigenschaften besitzt.'},
     {'question': 'Was ermöglicht es in Smalltalk, dass jede Klasse ihre eigenen Instanzvariablen und Methoden besitzt?', 'answer': 'In Smalltalk kann jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können, da jede Klasse Instanz einer eigenen Klasse ist.'},
     {'question': 'Was passiert, wenn eine Programmiererin eine abstrakte Klasse instanziiert und eine Nachricht an die entsprechende Instanz sendet?', 'answer': 'Wenn eine Programmiererin eine abstrakte Klasse instanziiert und eine Nachricht an die entsprechende Instanz sendet, führt dies zu einer Fehlermeldung, die ihr anzeigt, dass die Methode (erst) in einer Subklasse implementiert werden sollte. Diese Fehlermeldung bekommt die Programmiererin allerdings erst zur Laufzeit des Programms zu Gesicht, was bedeutet, dass sie das Problem erst bemerkt, wenn es bereits zu spät ist.'},
     {'question': 'Was bewirkt die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition?', 'answer': 'Die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der (direkten) Superklasse der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet.'},
     {'question': 'Was bewirkt die Verwendung von self als Nachrichtenempfänger in einer Methodendefinition?', 'answer': 'Die Verwendung von self als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet.'},
     {'question': 'Was bewirkt die Verwendung von this als Nachrichtenempfänger in einer Methodendefinition?', 'answer': 'Die Verwendung von this als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet.'},
     {'question': 'Was passiert, wenn an self eine Nachricht geschickt wird?', 'answer': 'Wenn an self eine Nachricht geschickt wird, wird die zu dieser Nachricht passende Methode gesucht. Die Suche beginnt in der Klasse, in der die gerade ausgeführte Methode definiert ist. Wenn die Methode nicht in dieser Klasse gefunden wird, wird die Suche in der Kette der Superklassen fortgesetzt, bis die Methode gefunden wird.'},
     {'question': 'Was passiert, wenn an self eine Nachricht geschickt wird, die in der Klasse des Objekts nicht definiert ist?', 'answer': 'Wenn an self eine Nachricht geschickt wird, die in der Klasse des Objekts nicht definiert ist, wird die Suche nach der passenden Methode in der Kette der Superklassen fortgesetzt, bis die Methode gefunden wird.'},
     {'question': 'Was versteht man unter Kopieren-und-Einfügen-Semantik bei Vererbung?', 'answer': 'Bei der Kopieren-und-Einfügen-Semantik bei Vererbung wird die Implementierung der übergeordneten Klasse in die Unterklasse kopiert und kann dann in der Unterklasse gegebenenfalls angepasst werden. Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.'},
     {'question': 'Sind Objekte in der objektorientierten Programmierung aktiv oder passiv?', 'answer': 'Objekte in der objektorientierten Programmierung sind passiv, was bedeutet, dass sie nur aktiv sind, solange sie gerade eine Methode ausführen.'},
     {'question': 'Warum werden in der objektorientierten Programmierung in der Praxis eher passive Objekte verwendet?', 'answer': 'Aktive Objekte sind sehr aufwendig, weshalb in der objektorientierten Programmierung in der Praxis eher passive Objekte verwendet werden.'},
     {'question': 'Kann es in der objektorientierten Programmierung Parallelverarbeitung geben?', 'answer': 'Ja, in der objektorientierten Programmierung ist Parallelverarbeitung möglich, jedoch nicht in Form von aktiven Objekten, sondern in Form von parallelen Prozessen, die jeweils eine Methode ausführen.'},
     {'question': 'Was passiert, wenn eine Methode nicht gefunden wird?', 'answer': 'Wenn eine Methode nicht gefunden wird, wird in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument.'},
     {'question': 'Was passiert, wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind?', 'answer': 'Wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind, kann sie dies tun, wenn sie in der gleichen Klasse definiert ist. Wenn die Methode jedoch in einer Superklasse definiert ist, kann sie nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind, und nicht auf Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind.'},
     {'question': 'Was passiert, wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind, aber in der Unterklasse hinzugekommen sind?', 'answer': 'Die Methode kann nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar.'},
     {'question': 'Was passiert, wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind, aber in einer Superklasse definiert wurden?', 'answer': 'Die Methode kann nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar.'},
     {'question': 'Was repräsentiert die "Ist-eine-Instanz-von"-Beziehungn?', 'answer': 'Die "Ist-eine-Instanz-von"-Beziehung stellt die Beziehung zwischen einer Klasse und einer Instanz dar, was bedeutet, dass die Instanz ein Objekt der Klasse ist.'},
     {'question': 'Was wäre eine Möglichkeit, die Vererbung umzusetzen?', 'answer': 'Eine Möglichkeit wäre, die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Diese Methode würde die Semantik der Vererbung korrekt wiedergeben, würde aber das Problem mit sich bringen, dass bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müssten.'},
     {'question': 'Was wäre problematisch, wenn jede Instanz einer Subklasse automatisch je eine Instanz aller ihrer Superklassen erzeugen würde?', 'answer': 'Das wäre problematisch, weil ein Objekt einer Subklasse auf einmal mehrere Identitäten hätte, und zwar eine für sich selbst und eine pro Superklasse, von der sie erbt. Das Konzept der Identität von Objekten würde verletzt werden.'},
     {'question': 'Kann eine Klasse neue Spezialisierungen hinzufügen, wenn sie bereits Generalisierungen besitzt?', 'answer': 'Ja, eine Klasse kann neue Spezialisierungen hinzufügen, auch wenn sie bereits Generalisierungen besitzt. Das ist eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind.'},
     {'question': 'Kann eine Klasse neue Spezialisierungen hinzufügen, wenn die Generalisierung bereits über Spezialisierungen verfügt?', 'answer': 'Ja, eine Klasse kann neue Spezialisierungen hinzufügen, wenn die Generalisierung bereits über Spezialisierungen verfügt. Das ist eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind.'},
     {'question': 'Was bedeutet es, wenn man von einer Klasse spezialisieren möchte, die selbst keine Generalisierung ist?', 'answer': 'In diesem Fall spricht man von einer Spezialisierung durch Verengung (engl. narrowing). Dabei wird eine bestehende Klasse so spezialisiert, dass sie weniger Fähigkeiten besitzt als die ursprüngliche Klasse. Diese Art der Spezialisierung ist in der objektorientierten Programmierung eher unüblich, kann aber in manchen Fällen sinnvoll sein.'},
     {'question': 'Was wird durch eine Subklassenbeziehung zwischen zwei Klassen ausgedrückt?', 'answer': 'Durch eine Subklassenbeziehung zwischen zwei Klassen wird ausgedrückt, dass die Subklasse alle Instanzvariablen und Methoden der Superklasse erbt. Es wird jedoch nicht ausgedrückt, dass die Subklasse eine Spezialisierung der Superklasse ist oder die Superklasse eine Generalisierung der Subklasse. Diese Sicherstellung obliegt der Verantwortung des Programmierers.'},
     {'question': 'Was muss bei der Definition einer Subklasse in SMALLTALK beachtet werden?', 'answer': 'In SMALLTALK müssen bei der Definition einer Subklasse neue, benannte Instanz- und Klassenvariablen andere Namen als Variablen in Superklassen haben und indizierte Instanzvariablen müssen vorhanden sein, wenn die Superklasse solche hat. Methodendefinitionen mit derselben Signatur überschreiben einfach die geerbten Methoden.'},
     {'question': 'Was repräsentieren die Instanzvariablennamen in SMALLTALK?', 'answer': 'Die Instanzvariablennamen in SMALLTALK sind eine Liste von Symbolen, die die Namen der Instanzvariablen der neuen Klasse repräsentieren.'},
     {'question': 'Kann man eine Instanzvariable löschen, die von einer übergeordneten Klasse geerbt wurde?', 'answer': 'Ja, man kann eine Instanzvariable löschen, die von einer übergeordneten Klasse geerbt wurde. Allerdings muss man dann auch die Methoden, die diese Instanzvariable verwenden, überschreiben.'},
     {'question': 'Was passiert, wenn man eine Instanzvariable löscht, die von einer übergeordneten Klasse geerbt wurde?', 'answer': 'Wenn man eine Instanzvariable löscht, die von einer übergeordneten Klasse geerbt wurde, muss man auch die Methoden, die diese Instanzvariable verwenden, überschreiben.'},
     {'question': 'Warum ist die Übertragung der Vererbung auf Klassen nicht vollkommen unnatürlich?', 'answer': 'Die Übertragung der Vererbung auf Klassen ist nicht vollkommen unnatürlich, weil Programmierer in objektorientierten Programmen Klassen entwerfen, die die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Zudem sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung und somit sind auch Klassendefinitionen im ständigen Wandel.'},
     {'question': 'Was passiert, wenn man versucht, eine nicht implementierte Methode in SMALLTALK aufzurufen?', 'answer': 'Wenn man versucht, eine nicht implementierte Methode in SMALLTALK aufzurufen, erfolgt ein Hinweis, dass man eine abstrakte Klasse instanziiert hat.'},
     {'question': 'Wozu dient die Intervall-Collection?', 'answer': 'Die Intervall-Collection dient der Umsetzung von Zu-n-Beziehungen und enthält eine Anzahl von Elementen, die durch eine untere und obere Grenze bestimmt sind. Die untere Grenze ist inklusiv, die obere Grenze exklusiv. Die Anzahl der Elemente ist also die Differenz zwischen der oberen und unteren Grenze. Die Elemente eines Intervalls sind die ganzen Zahlen, die zwischen der unteren und oberen Grenze liegen.'},
     {'question': 'Wofür werden indizierte Instanzvariablen verwendet?', 'answer': 'Indizierte Instanzvariablen werden verwendet, um Zu-n-Beziehungen zwischen Objekten herzustellen. Sie sind speziell für diesen Zweck eingeführt worden, um die Häufigkeit des Vorkommens von Zu-n-Beziehungen in der Programmierung zu unterstützen.'},
     {'question': 'Mit welchen drei Ansätzen lassen sich Objekte erzeugen?', 'answer': 'Die drei Varianten der Objektorientierung sind der Konstruktoransatz, der Prototypenansatz und der Klassenansatz. Die klassenbasierte Form der Objektorientierung hat sich gegenüber der prototypenbasierten Form weitgehend durchgesetzt, da Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen übernehmen kann. Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann.'},
     {'question': 'Was sind die Unterschiede zwischen lesbarbaren und schreibbaren Streams?', 'answer': 'Lesbare Streams ermöglichen das Lesen von Daten aus einer Quelle, während schreibbare Streams das Schreiben von Daten in eine Zielquelle ermöglichen. Lesbare Streams bieten Methoden zum Lesen von Daten, während schreibbare Streams Methoden zum Schreiben von Daten bereitstellen.'},
     {'question': 'Was ist der Unterschied zwischen direkten und indirekten Instanzen?', 'answer': 'Direkte Instanzen sind Elemente der Extension einer Klasse, während indirekte Instanzen Elemente der Extension einer Unterklasse sind, die nicht direkt der Oberklasse zugeordnet ist.'},
     {'question': 'Ist das Entfernen von Instanzvariablen oder Methoden vereinbar mit einer Spezialisierung?', 'answer': 'Nein, das Entfernen von Instanzvariablen oder Methoden ist unvereinbar mit der Spezialisierung. Die Richtung von Spezialisierung und Generalisierung würde beliebig werden, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte.'},
     {'question': 'Was ist der Unterschied zwischen Schlüssel und Wert in einem Dictionary?', 'answer': 'Der Schlüssel (key) ist ein eindeutiger Bezeichner für ein Element in einem Dictionary, während der Wert (value) das Element selbst ist, das unter diesem Schlüssel gespeichert ist.'}
     ]
]
KE3_questions = [
    [{'question': 'Was ist eine Typvariable in einer Typdefinition?', 'answer': 'In der Typdefinition ist eine Typvariable ein Platzhalter für einen tatsächlichen Typ, der bei der Instantiierung der Klasse eingesetzt wird. Traditionell werden einzelne Großbuchstaben für Typvariablen verwendet, um versehentliches Verdecken eines tatsächlichen Typs zu vermeiden.'},
     {'question': 'Was ist der Zweck der Typisierung in der Programmierung?', 'answer': 'Der Zweck der Typisierung in der Programmierung ist es, die möglichen Werte einer Variablen oder Funktion einzuschränken und so die Fehleranfälligkeit zu verringern. Durch die Angabe eines Typs wird sichergestellt, dass nur Werte dieses Typs an die Variable oder Funktion übergeben werden können, was die Korrektheit des Programms erhöht.'},
     {'question': 'Was ist die Bedeutung von Typparametern in einer parametrisierten Typdefinition?', 'answer': 'Typparameter in einer parametrisierten Typdefinition sind Platzhalter für konkrete Typen, die bei der Instanziierung des Typs eingesetzt werden können. Sie ermöglichen es, den gleichen Code für verschiedene Typen wiederzuverwenden und die Typsicherheit zu erhalten.'},
     {'question': 'Was ist parametrischer Polymorphismus?', 'answer': 'Parametrischer Polymorphismus ist eine Technik in der objektorientierten Programmierung, bei der eine Typvariable innerhalb einer Typdefinition verwendet wird. Diese Typvariable kann später durch einen konkreten Typ ersetzt werden, wenn die Typdefinition instanziiert wird.'},
     {'question': 'Was sind Metatypen?', 'answer': 'Metatypen sind eine Möglichkeit, um die Typvariable innerhalb der mit ihr parametrisierten Typdefinition wertbeschränkt zu machen. Dabei sind die Wertebereiche der Metatypen Typen mit von den Metatypen vorgegebenen Eigenschaften. Diese Möglichkeit wird jedoch in der Praxis nicht genutzt.'},
     {'question': 'Was ist Subtyping?', 'answer': 'Subtyping ist eine Art der Beschränkung des Wertebereichs von Typvariablen, bei der ein tatsächlicher Typparameter (der Wert der Typvariable) ein Subtyp eines bestimmten Typs sein muss, der die benötigten Eigenschaften umfasst. Aufgrund der Regeln des Subtyping hat jeder solche Typ die Eigenschaften des Supertyps.'},
     {'question': 'Was ist ein Subtyp?', 'answer': 'Ein Subtyp ist ein Typ, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp ist eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung, und die Gegenrolle heißt Supertyp.'},
     {'question': 'Was bedeutet Zuweisungskompatibilität?', 'answer': 'Zuweisungskompatibilität bedeutet, dass Objekte eines Subtyps überall auftauchen dürfen, wo Objekte seines Supertyps erwartet werden. Ein Subtyp ist also per Definition mit seinem Supertyp zuweisungskompatibel.'},
     {'question': 'Was ist Typeinschränkung?', 'answer': 'Typeinschränkung ist eine Möglichkeit, auf der Basis eines bereits bestehenden Typs einen neuen, verwandten Typen zu erzeugen, indem man ihn auf Basis des bestehenden Typs definiert, aber mit dem Entfernen von Eigenschaften (Methoden). Diese Form der Typeinschränkung stellt die Umkehrung der Typerweiterung dar, führt aber nicht zur Zuweisungskompatibilität.'},
     {'question': 'Was ist die unter dem Gesichtspunkt der Zuweisungskompatibilität interessante Form der Typeinschränkung?', 'answer': 'Die unter dem Gesichtspunkt der Zuweisungskompatibilität interessante Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere zu ersetzen. Diese Form der Typeinschränkung ergibt sich auf natürliche Weise, wenn man sich den Zusammenhang von Extensionen von definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht.'},
     {'question': 'Was ist das Ziel der Typerweiterung ?', 'answer': 'Das Ziel der Typerweiterung ist die Vereinigung von Typerweiterung und Typeinschränkung zu einer Beziehung zwischen Typen, nicht die Schaffung zweier Komplementäre.'},
     {'question': 'Was ist Zuweisungskompatibilität?', 'answer': 'Die Zuweisungskompatibilität ist eine Regel, die bestimmt, ob ein Wert einer Variablen zugewiesen werden kann. Wenn der Typ des Werts mit dem Typ der Variablen kompatibel ist, ist die Zuweisungskompatibilität gegeben.'},
     {'question': 'Was ist die Typkonformität?', 'answer': 'Die Typkonformität ist eine Regel, die bestimmt, ob ein Typ in eine Typerweiterung übergehen kann. Wenn der Typ des Werts mit dem Typ der Variablen kompatibel ist, ist die Typkonformität gegeben.'},
     {'question': 'Was ist die Funktion von Typen in der objektorientierten Programmierung?', 'answer': 'Typen dienen in der objektorientierten Programmierung nicht nur dazu, Objekte zu klassifizieren, sondern auch dazu, das Implementationsgeheimnis der Klassen zu wahren und die Einhaltung der Schnittstellen durch den Compiler zu gewährleisten. Diese Funktion von Typen wurde mit der Programmiersprache Java und ihrem Interface-als-Typ-Konzept weiterentwickelt, was zur interfacebasierten Programmierung führte.'},
     {'question': 'Was ist die Auswirkung der Typeinschränkung auf die Zuweisungskompatibilität?', 'answer': 'Die Typeinschränkung hebelt die Zuweisungskompatibilität aus, was bedeutet, dass die Zuweisung von Werten mit unverträglichen Typen nicht mehr möglich ist.'},
     {'question': 'Was ist eine Deklaration in der Programmierung?', 'answer': 'Eine Deklaration in Programmierung ist ein Vorgang, bei dem man Programmelemente, wie Variablen oder Funktionen, vor der ersten Verwendung bekannt gibt. Dabei wird der Bezeichner dem Compiler bekannt gegeben, damit er ihn in der Folge wiedererkennen und mit der Deklaration in Verbindung bringen kann.'},
     {'question': 'Was sind formale Parameter in SMALLTALK?', 'answer': 'Formale Parameter sind Variablen, die in der Deklaration einer Methode angegeben werden und Werte entgegennehmen, die bei einem Methodenaufruf übergeben werden.'},
     {'question': 'Was ist die Bedingung für eine zulässige Zuweisung bei unterschiedlichen Typen?', 'answer': 'Damit eine Zuweisung b an a, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein.'},
     {'question': 'Was ist eine Filterfunktion von Typen?', 'answer': 'Eine Filterfunktion von Typen ist eine Funktion, die neben der formalen Funktion, Fehler zu vermeiden, auch eine inhaltliche Funktion erfüllt. Sie setzt voraus, dass dem Typ eine Bedeutung beigemessen wird, die über seine bloße Struktur hinausgeht. Diese Bedeutung wird heute hauptsächlich durch die Benennung des Typs vermittelt. Die Namensäquivalenz als Bedingung der Zuweisungskompatibilität verlangt, dass einer Variablen nur Werte gleicher Bedeutung zugewiesen werden können. Die Filterfunktion drückt also eher eine Absicht der Programmiererin aus als eine technische Notwendigkeit.'},
     {'question': 'Was ist eine Schnittstelle in Bezug auf eine Klasse?', 'answer': 'Eine Schnittstelle in Bezug auf eine Klasse ist das Verbergen der Implementierung und das Nach-außen-Treten der Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind. Dieses Prinzip wird auch als Geheimnisprinzip bezeichnet.'},
     {'question': 'Was sind Zugriffsmodifikatoren?', 'answer': 'Zugriffsmodifikatoren sind spezielle Schlüsselwörter in Programmiersprachen wie Java und C++, die einem Element einer Klassendefinition vorangestellt werden, um dessen Zugreifbarkeit festzulegen. Sie legen gemeinsam mit der Klassendefinition, die die vollständige Implementierung beinhaltet, auch die Schnittstelle der Klasse fest.'},
     {'question': 'Was ist eine absolut spezifizierte Schnittstelle einer Klasse?', 'answer': 'Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nur aus Deklarationen von Methoden und enthält keine Instanzvariablen.'},
     {'question': 'Was ist strukturelle Typkonformität?', 'answer': 'Strukturelle Typkonformität bedeutet, dass der konforme Typ alle Elemente des Typs, zu dem er konform sein soll, enthält.'},
     {'question': 'Was ist namensgebundene Typkonformität?', 'answer': 'Namensgebundene Typkonformität bedeutet, dass der konforme Typ nicht nur die Elemente des Typs, zu dem er konform sein soll, enthält, sondern dass er auch ausdrücklich als konform zu diesem Typ erklärt wurde.'},
     {'question': 'Was ist statische Typisierung?', 'answer': 'Statische Typisierung ist eine Eigenschaft von Sprachen, die die'},
     {'question': 'Was ist Zuweisungskompatibilität unter Typerweiterung?', 'answer': 'Zuweisungskompatibilität unter Typerweiterung bezieht sich auf die Möglichkeit, Werte verschiedener Typen einander zuzuweisen, wenn der Zieltyp eine Erweiterung des Quelltyps ist. Funktionsaufrufe sind Anweisungen, die eine Funktion mit bestimmten Argumenten aufrufen. Wenn eine Funktion aufgerufen wird, werden implizite Zuweisungen durchgeführt, bei denen die Typen der Argumente mit den Parametern der Funktion kompatibel sein müssen. Diese Zuweisungskompatibilität spielt auch bei Funktionsaufrufen eine wichtige Rolle.'},
     {'question': 'Was sind implizite Zuweisungen?', 'answer': 'Implizite Zuweisungen treten bei Funktionsaufrufen auf, bei denen die Funktion eine Kopie des Objekts erhält, auf das die Funktionsargument-Variable verweist.'},
     {'question': 'Was sind Funktionsaufrufe?', 'answer': 'Funktionsaufrufe sind Anweisungen, die eine Funktion aufrufen und deren Ergebnis berechnen. Sie werden verwendet, um Werte zu berechnen, Objekte zu manipulieren oder die Kontrolle in einem Programm zu übertragen.'},
     {'question': 'Was ist Typerweiterung?', 'answer': 'Typerweiterung ist ein Konzept in der objektorientierten Programmierung, bei dem eine Unterklasse eine Oberklasse erweitert, indem sie neue Attribute und Methoden hinzufügt oder bestehende Methoden überschreibt.'},
     {'question': 'Was ist Typäquivalenz?', 'answer': 'Typäquivalenz bedeutet, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind.'},
     {'question': 'Was ist die Voraussetzung für die Zuweisungskompatibilität von zwei Typen?', 'answer': 'Die Voraussetzung für die Zuweisungskompatibilität von zwei Typen ist, dass sie identisch sind oder eine Typäquivalenz aufweisen, d.h. sich die Typdefinitionen bis auf ihre Namen gleichen.'},
     {'question': 'Was bedeutet die Transitivität der Typäquivalenz?', 'answer': 'Die Transitivität der Typäquivalenz bedeutet, dass wenn ein Typ A äquivalent zu einem Typ B ist und Typ B wiederum äquivalent zu einem Typ C ist, dann ist auch Typ A äquivalent zu Typ C. Diese Eigenschaft ist wichtig, um sicherzustellen, dass die Typäquivalenz konsistent ist und dass die Typisierung von Ausdrücken und Variablen in einem Programm konsistent bleibt.'},
     {'question': 'Was ist strukturelle Typäquivalenz?', 'answer': 'Strukturelle Typäquivalenz ist ein Verfahren, um festzustellen, ob zwei Typen gleich sind. Dabei werden die Definitionen der beteiligten Typen rekursiv expandiert, was bedeutet, dass in einer Typdefinition vorkommende Namen anderer Typen durch ihre Struktur ersetzt werden.'},
     {'question': 'Was ist Strukturäquivalenz?', 'answer': 'Strukturäquivalenz ist eine Bedingung der Zuweisungskompatibilität, die ausreicht, um Typfehler zu verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten durchgeführt werden können.'},
     {'question': 'Was ist Type branding?', 'answer': 'Type branding ist eine Technik, bei der jedem Typ eine für ihn charakteristische Methode exklusiv zugeordnet wird, sodass er mit keinem anderen mehr strukturäquivalent ist. Diese Technik wird gelegentlich in Sprachen mit Strukturäquivalenz angewendet, um semantische Fehler durch das Zuweisen von Objekten über Typgrenzen hinweg zu vermeiden.'},
     {'question': 'Was ist die Bedingung für Typkompatibilität bei Zuweisungen in SMALLTALK?', 'answer': 'Für Typkompatibilität bei Zuweisungen in SMALLTALK reicht es aus, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält. Der Typ auf der rechten Seite einer Zuweisung darf also eine Erweiterung dessen auf der linken Seite um zusätzliche Methoden sein.'},
     {'question': 'Was ist ein erweiternder Typ?', 'answer': 'Ein erweiternder Typ, auch Untertyp genannt, ist eine Typdefinition, die auf einer bestehenden Typdefinition aufbaut und diese erweitert. Die Methodendeklarationen des erweiterten Typs werden dabei vererbt und müssen nicht noch einmal wiederholt werden.'},
     {'question': 'Was sind Protokolle?', 'answer': 'Protokolle sind eine Art von Typdefinition, die die Methoden und Eigenschaften beschreiben, die ein Objekt haben muss, um eine bestimmte Rolle zu erfüllen. Variablen spielen in Protokollen eine Rolle, indem sie als formale Parameter in Methoden auftauchen und als Typen für die Ein- und Ausgabeobjekte spezifiziert werden.'},
     {'question': 'Was ist die Protokollbildung in STRONGTALK?', 'answer': 'In STRONGTALK ist die Protokollbildung der einzige Typkonstruktor, mit dem man neue Typen definieren kann.'},
     {'question': 'Was ist der einzige Typkonstruktor in STRONGTALK?', 'answer': 'In STRONGTALK ist die Protokollbildung der einzige Typkonstruktor.'},
     {'question': 'Was ist die Typisierung von Variablen ?', 'answer': 'Die Typisierung von Variablen ist ein Konzept, bei dem jede Variable nur die Werte haben kann, für die sie vorgesehen ist. Sie wird erreicht, indem jeder Variablen ein Typ zugeordnet wird, und indem auch jedes Objekt sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Dies geschieht durch Variablendeklarationen, die Zuordnung von Typen zu Literalen, die Instanziierung von Klassen und die Deklaration von Methoden, die angeben muss, welchen Typs die Objekte sind, die sie liefert.'},
     {'question': 'Was ist Zuweisungskompatibilität unter Subtyping?', 'answer': 'Zuweisungskompatibilität unter Subtyping erlaubt die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps.'},
     {'question': 'Was ist ein Upcast in der Typumwandlung?', 'answer': 'Ein Upcast ist eine Typumwandlung von einem Typ zu einem Supertyp. Upcasts sind immer typsicher.'},
     {'question': 'Was ist kovariante Redefinition?', 'answer': 'Kovariante Redefinition bezieht sich auf eine Situation, in der der Parametertyp einer Methode sich mit dem Empfängertyp ändert. Im Fall des rekursiv beschränkten parametrischen Polymorphismus wird der Parametertyp der Methode zu einem Subtyp des Empfängertyps, was keinen Widerspruch zur Kontravarianzregel des Subtyping darstellt.'},
     {'question': 'Was ist Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie?', 'answer': 'Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie ist eine Technik in der objektorientierten Programmierung, bei der ein Subtyp eine Methode seines Obertyps mit einem spezifischeren Rückgabetyp neu definieren kann, während er gleichzeitig die Liskov-Substitutionsprinzip einhält. Diese Technik kann jedoch nicht mit parametrischen Typen erreicht werden.'},
     {'question': 'Was ist Parametrisierung von Typen?', 'answer': 'Parametrisierung von Typen ist eine Möglichkeit, den Wertebereich eines Typs variabel zu halten, ohne die statische Typprüfung aufgeben zu müssen. Dabei wird der Typ mit einem oder mehreren anderen Typen parametrisiert.'},
     {'question': 'Was ist eine parametrische Typdefinition?', 'answer': 'Eine parametrische Typdefinition ist eine Art von Typdefinition, die Platzhalter für andere Typen verwendet, die durch Typparameter, auch Typvariablen genannt, vertreten werden. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt.'},
     {'question': 'Was sind formale Typparameter und tatsächliche Typparameter?', 'answer': 'Formale Typparameter sind die Typvariablen, die in parametrischen Typdefinitionen vorkommen. Tatsächliche Typparameter sind die konkreten Typen, die bei der Verwendung des Typs in Deklarationen in die formalen Parameter eingesetzt werden.'},
     {'question': 'Was ist Typsicherheit?', 'answer': 'Typsicherheit ist die Eigenschaft einer Programmiersprache, die das Fehlen bestimmter Ausführungsfehler in allen Programmläufen gewährleistet.'},
     {'question': 'Was sind rekursive Typen?', 'answer': 'Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Sie sind ein wichtiges Instrument der Programmierung, um dynamische Strukturen wie verschachtelte Listen oder Bäume zu ermöglichen. Allerdings bringen sie auch Probleme mit sich, wie zum Beispiel die Feststellung der strukturellen Äquivalenz zweier rekursiver Typen, die aufgrund der notwendigen Expansion unendlich große Definitionen ergeben kann.'},
     {'question': 'Was ist das Problem bei der Verwendung von variablen Typen in einer parametrischen Typdefinition?', 'answer': 'Das Problem ist, dass der Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel sein soll, aber der Typ bereits definiert ist. Dies tritt auf, wenn man beispielsweise den Test auf Gleichheit so definieren möchte, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.'},
     {'question': 'Was ist ein parametrischer Typ?', 'answer': 'Ein parametrischer Typ ist ein Typ, der einen oder mehrere Typvariablen enthält, die bei der Instanziierung durch konkrete Typen ersetzt werden. Dies ermöglicht die Erstellung von generischen Klassen und Methoden, die für verschiedene Typen verwendet werden können.'},
     {'question': 'Was ist eine stilistische Figur in Bezug auf den formalen Typparameter T von Equatable?', 'answer': 'Eine stilistische Figur in Bezug auf den formalen Typparameter T von Equatable ist die Beschränkung von T auf einen Subtyp von Equatable[T].'},
     {'question': 'Was ist Typerweiterung als Basis des Subtyping?', 'answer': 'Typerweiterung als Basis des Subtyping bedeutet, dass ein neuer Typ, der ein Supertyp ist, zusätzliche Eigenschaften und Methoden enthalten kann, aber die Eigenschaften und Methoden des Supertyps haben muss. Dadurch sind Typfehler ausgeschlossen, und es bleibt lediglich das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind.'},
     {'question': 'Was ist Typerweiterung und warum bereitet sie keine technischen Probleme?', 'answer': 'Typerweiterung ist eine Möglichkeit, eine neue Unterklasse von einer bestehenden Klasse abzuleiten, indem neue Attribute und Methoden hinzugefügt werden. Es bereitet keine technischen Probleme, weil es keine Typfehler verursacht, da die Unterklasse alle Merkmale der Oberklasse erbt und zusätzliche Merkmale hinzufügen kann. Das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind, kann nicht immer vermieden werden, aber es ist kein technisches Problem.'},
     {'question': 'Welche Bedingungen müssen an die Parametertypen bei der Redefinition einer Methode gestellt werden, um eine Verletzung einer Typinvariante zu vermeiden?', 'answer': 'Die Typinvariante muss für den neuen Parametertyp und den alten Parametertyp gelten, d.h. der neue Parametertyp muss eine Unterklasse des alten Parametertyps sein.'},
     {'question': 'Was ist Kontravarianz und Kovarianz?', 'answer': 'Kontravarianz und Kovarianz sind zwei Begriffe, die die Richtung der Variation von Parametern bei der Redefinition von Methoden beschreiben. Kontravarianz bezieht sich auf die Eingabeparameter, die gegenläufig zum Empfängertyp variieren, während Kovarianz sich auf den Ausgabeparameter bezieht, der gleichgerichtet zum Empfängertyp variiert.'},
     {'question': 'Was ist das Problem bei der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren?', 'answer': 'Das Problem ist, dass wenn das Eingabe-Objekt und das Ausgabe-Objekt identisch sind, nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden kann, da der Subtyp mehr Eigenschaften verlangt als der Supertyp garantiert.'},
     {'question': 'Was ist Novarianz?', 'answer': 'Novarianz ist die Unveränderlichkeit der Parametertypen in einem Programm.'},
     {'question': 'Was ist die Kontravarianzregel für Parametertypen?', 'answer': 'Die Kontravarianzregel für Parametertypen ist eine Regel in der objektorientierten Programmierung, die besagt, dass ein Untertyp eines Parametertyps als Argument für eine Methode verwendet werden kann, die den Obertyp des Parametertyps erwartet. Diese Regel wird infrage gestellt, weil sie in der Realität (der Interpretation oder Semantik) keine Bedeutung hat, aber in der Programmierpraxis nicht benötigt wird.'},
     {'question': 'Was ist Inklusionspolymorphie?', 'answer': 'Inklusionspolymorphie, auch bekannt als Subtyping oder Subtyp-Polymorphie, ist eine Form der Polymorphie, bei der ein Objekt eines Untertyps an einer Stelle verwendet werden kann, an der ein Objekt des Supertyps erwartet wird. Das bedeutet, dass eine Collection, die Objekte eines bestimmten Typs enthält, auch Objekte eines Untertyps dieses Typs enthalten kann.'},
     {'question': 'Was ist eine Sicherheitslücke in der statischen Typprüfung, die durch die Inklusionspolymorphie entsteht?', 'answer': 'Die Sicherheitslücke in der statischen Typprüfung, die durch die Inklusionspolymorphie entsteht, ist, dass der Compiler nicht oder nur sehr aufwendig feststellen kann, ob das Ergebnis von p kinder at: 1 vom Typ Object in eine Methode kinder von Typ Person umgewandelt werden kann.'},
     {'question': 'Was ist der beschränkte parametrische Polymorphismus?', 'answer': 'Der beschränkte parametrische Polymorphismus ist eine Technik, die es ermöglicht, Typen zu verwenden, die bestimmte Eigenschaften haben. Dadurch kann ein Typfehler bereits an der Stelle moniert werden, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, anstatt erst später im Programm.'},
     {'question': 'Welches Problem möchte man mit dem beschränkten parametrischen Polymorphismus lösen?', 'answer': 'Mit dem beschränkten parametrischen Polymorphismus möchte man sicherstellen, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist und nur bestimmte, benötigte Protokolle für die als Werte zulässigen Typen erlaubt.'},
     {'question': 'Welche Formen der Typeinschränkung gibt es?', 'answer': 'Eine Form der Typeinschränkung besteht darin, einen Typ auf Basis eines anderen Typs zu definieren, indem man Eigenschaften (Methoden) entfernt. Diese Form führt jedoch nicht zur Zuweisungskompatibilität und wird in vielen Sprachen nicht unterstützt. Eine interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere Typen zu ersetzen, ohne Eigenschaften zu löschen.'},
     {'question': 'Welche inhaltliche Funktionen können Typen neben ihrer formalen Rolle erfüllen?', 'answer': 'Typen können in der Programmierung neben ihrer formalen Rolle, Fehler zu vermeiden, auch eine inhaltliche Funktion erfüllen. Diese inhaltliche Funktion wird vor allem durch die Benennung des Typs hergestellt, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität. Sie verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können.'},
     {'question': 'Welche Rolle spielen Zugriffsmodifikatoren in Programmiersprachen wie Java und C++ bei der Festlegung der Schnittstelle einer Klasse?', 'answer': 'Zugriffsmodifikatoren legen fest, welche Elemente einer Klassendefinition für Benutzer sichtbar sind und somit die Schnittstelle der Klasse beeinflussen. Sie regeln die Zugriffsberechtigungen auf Methoden und Instanzvariablen.'},
     {'question': 'Was ist nominales Subtyping?', 'answer': 'Nominales Subtyping bedeutet, dass ein Subtyp explizit aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. In diesem Fall ist die Namensähnlichkeit entscheidend.'},
     {'question': 'Was ist strukturelles Subtyping?', 'answer': 'Strukturelles Subtyping liegt vor, wenn ein Typ die allgemeine Definition eines Subtyps erfüllt, unabhängig von seiner expliziten Nennung als Supertyp. Hier ist die Struktur und das Verhalten des Typs entscheidend, nicht seine explizite Nennung als Supertyp.'},
     {'question': 'Welches der beiden Subtyping-Modelle, nominales Subtyping und strukturelles Subtyping, impliziert das andere?', 'answer': 'Nominales Subtyping impliziert strukturelles Subtyping. Das bedeutet, wenn ein Subtyp nominal als Supertyp erwähnt wird, erfüllt er automatisch auch die strukturellen Kriterien eines Subtyps.'},
     {'question': 'Welche Bedeutung hat die Typkonformität in Bezug auf die Zuweisungskompatibilität?', 'answer': 'Typkonformität ist in vielen Sprachen eine notwendige Voraussetzung für die Zuweisungskompatibilität. Das bedeutet, dass ein Objekt eines typkonformen Typs einer Variable eines anderen, typgleichen Typs zugewiesen werden darf.'},
     {'question': 'Welche beiden Varianten der Typkonformität gibt es, und wie unterscheiden sie sich?', 'answer': 'Es gibt strukturelle Typkonformität und nominale Typkonformität. Bei struktureller Typkonformität müssen alle Elemente des konformen Typs im konformen Typ enthalten sein. Bei nominaler Typkonformität muss zusätzlich die Erweiterung eines anderen Typs explizit angegeben werden.'},
     {'question': 'Welche Arten von Typäquivalenz gibt es, und wie unterscheiden sie sich?', 'answer': 'Es gibt zwei Arten von Typäquivalenz: die nominale (Namensäquivalenz) und die strukturelle (Strukturäquivalenz) Typäquivalenz. Die nominale Typäquivalenz erfordert, dass zwei Deklarationen denselben Typnamen angeben, um Zuweisungskompatibilität zu haben. Die strukturelle Typäquivalenz hingegen erfordert nur, dass die Typen paarweise gleich definiert sind, unabhängig von ihren Namen.'},
     {'question': 'Welche Eigenschaften gelten für die Typäquivalenz?', 'answer': 'Die Typäquivalenz ist reflexiv, was bedeutet, dass jeder Typ zu sich selbst äquivalent ist. Sie ist auch transitiv, was bedeutet, dass wenn A äquivalent zu B ist und B äquivalent zu C ist, dann ist auch A äquivalent zu C.'},
     {'question': 'Was sind Bezeichner in der Programmierung, und wie werden sie verwendet?', 'answer': 'Bezeichner sind Namen, die in der Programmierung frei vergeben werden können. Sie werden verwendet, um Programmelemente zu identifizieren und auf sie zu verweisen, beispielsweise Variablen oder Methoden.'},
     {'question': 'Welche Probleme können in untypisierten Sprachen auftreten?', 'answer': 'In untypisierten Sprachen, in denen Variablen ohne Angabe eines Typs deklariert werden, kann es zu Problemen führen, da Variablen quasi implizit deklariert werden, wenn sie zum ersten Mal verwendet werden. Dies kann zu Schreibfehlern führen, bei denen versehentlich zwei Variablen mit dem gleichen Namen erstellt werden, die jedoch nichts miteinander zu tun haben. Dies erhöht das Risiko von Programmierfehlern.'},
     {'question': 'Welche Rolle spielt Typinformation zur Laufzeit eines Programms?', 'answer': 'Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante durch einen dynamischen Typtest abbricht.'},
     {'question': 'Was ist eine Typumwandlung?', 'answer': 'Eine Typumwandlung (type cast) ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen Typ konvertiert wird. Dies geschieht, um dem Compiler oder Type Checker mitzuteilen, dass der Ausdruck den angegebenen Typ hat, auch wenn dies nicht automatisch sichergestellt ist.'},
     {'question': 'Welche Richtungen von Typumwandlungen gibt es?', 'answer': 'Typumwandlungen können in verschiedene Richtungen erfolgen: zu Supertypen (Upcast), zu Subtypen (Downcast) oder zu Typen, die weder Supertyp noch Subtyp des Ausgangstyps sind (Crosscast).'},
     {'question': 'Was ist das Kovarianzproblem im Zusammenhang mit parametrischem Polymorphismus?', 'answer': 'Das Kovarianzproblem im Zusammenhang mit parametrischem Polymorphismus bezieht sich darauf, wie Eingabeparameter in Methoden kovariant, also flexibel, in Bezug auf ihren Typ angepasst werden können.'},
     {'question': 'Was ist die Idee des parametrischen Polymorphismus?', 'answer': 'Die Idee des parametrischen Polymorphismus besteht darin, aus einer Typdefinition durch Parametrisierung viele verschiedene Typen zu generieren, je nachdem, welche konkreten Typen als Typparameter verwendet werden.'},
     {'question': 'Was sind Typen, die sich ausschließlich auf sich selbst beziehen?', 'answer': 'Typen, die sich ausschließlich auf sich selbst beziehen, sind solche, deren Bedeutung nicht von anderen Typen abhängt. Ein Beispiel dafür ist der Typ "Boolean". Sie können Bedeutung erhalten, indem sie auf bekannte externe Formalismen abgebildet werden, wie die boolesche Algebra.'},
     {'question': 'Was ist eine denotationale Semantik in Bezug auf Typisierung?', 'answer': 'Eine denotationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf bekannte externe Formalismen abgebildet werden. Dies kann beispielsweise bedeuten, dass die Operationen eines Typs auf mathematische oder logische Konzepte abgebildet werden, die in der Programmierung verwendet werden.'},
     {'question': 'Was ist eine operationale Semantik in Bezug auf Typisierung?', 'answer': 'Eine operationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf Anweisungen einer (gedachten oder realen) Maschine abgebildet werden. Dies bedeutet, dass die Operationen eines Typs auf die Ausführung von Maschinenbefehlen oder anderen niedrigstufigen Operationen abgebildet werden.'},
     {'question': 'Welches Problem ergibt sich bei der strukturellen Äquivalenz von rekursiven Typen?', 'answer': 'Das Problem bei der strukturellen Äquivalenz von rekursiven Typen besteht darin, dass die Expansion rekursiver Typen unendlich große Definitionen ergeben kann, was die Feststellung der strukturellen Äquivalenz erschwert.'},
     {'question': 'Was ist Kovarianz und Kontravarianz bei Methodenaufrufen im Zusammenhang mit Subtyping?', 'answer': 'Bei Methodenaufrufen und Subtyping unterscheidet man zwischen Kovarianz und Kontravarianz. Kovarianz bezieht sich auf die Veränderung von Rückgabetypen, während Kontravarianz die Veränderung von Parametertypen beschreibt.'},
     {'question': 'Was ist Kovarianz?', 'answer': 'Kovarianz tritt auf, wenn der Rückgabetyp einer Methode in einem Subtyp ein Subtyp des Rückgabetyps in einem Supertyp ist. Dies bedeutet, dass der Subtyp mehr Werte zurückgeben kann als der Supertyp.'},
     {'question': 'Was ist Kontravarianz?', 'answer': 'Kontravarianz tritt auf, wenn die Parametertypen einer Methode in einem Subtyp Supertypen der Parametertypen in einem Supertyp sind. Dies bedeutet, dass der Subtyp Eingabeparameter akzeptiert, die allgemeiner sind als die des Supertyps.'},
     {'question': 'Welcher konkrete Typ tritt an die Stelle einer Typvariable bei der Verwendung von Inklusionspolymorphie?', 'answer': 'Bei der Verwendung von Inklusionspolymorphie tritt der konkrete Typ "Object" an die Stelle der Typvariable E.'},
     {'question': 'Welche Art von Typfehler kann auftreten, wenn Inklusionspolymorphie verwendet wird?', 'answer': 'Ein Typfehler kann auftreten, wenn Methoden auf Objekten eines konkreten Subtyps von "Object" aufgerufen werden, da die statische Typprüfung solche Methoden nicht unterstützt.'},
     {'question': 'Welchen Kompromiss geht man bei der Verwendung parametrischen Typen ein?', 'answer': 'Bei der Verwendung parametrischer Typen geht man einen Kompromiss ein, bei dem die erhöhte Typsicherheit außerhalb der Typdefinition durch eine geringere Typsicherheit innerhalb der Typdefinition erkauft wird.'},
     {'question': 'Welche Art von Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen?', 'answer': 'Der beschränkte parametrische Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen, um Typfehler frühzeitig zu erkennen.'},
     {'question': 'Was ist ein Typ in der Programmierung?', 'answer': 'Ein Typ in der Programmierung schränkt die möglichen Werte eines deklarierten Elements (z. B. einer Variable) ein. Ein Typ hat eine Intension (Definition) und eine Extension (Wertebereich), wobei er eine Menge von Elementen (Objekten) umfasst, die zu diesem Typ gehören. Typen sind die Grundlage von Typsystemen.'},
     {'question': 'Welche Gründe gibt es, Variablen und andere Programmelemente zu typisieren?', 'answer': 'Es gibt mindestens vier gute Gründe für die Typisierung von Variablen und anderen Programmelementen: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm.'},
     {'question': 'Was ist ein Typsystem?', 'answer': 'Ein Typsystem umfasst Typausdrücke, Objekt- oder Wertausdrücke, Regeln, die Wertausdrücken Typen zuordnen, und Regeln, die von Wertausdrücken einzuhalten sind(zusammen die Typregeln).'},
     {'question': 'Was sind Gründe für die Verwendung von Typsystemen?', 'answer': 'Ein Grund für die Verwendung von Typsystemen ist die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt.'},
     {'question': 'Was ist ein logischer Fehler in einem Programm?', 'answer': 'Ein logischer Fehler in einem Programm ist ein Fehler, bei dem das Programm zwar fehlerfrei läuft, aber das Ergebnis falsch ist. Im Gegensatz zu einem Programmabbruch, der auf einen Programmierfehler hinweist, bleibt ein logischer Fehler oft unbemerkt.'},
     {'question': 'Was sind die Folgen eines logischen Fehlers in einem Programm?', 'answer': 'Ein logischer Fehler in einem Programm kann dazu führen, dass das Programm weiterläuft, aber das Ergebnis falsch ist. Es ist schwieriger zu erkennen als ein Programmabbruch, da keine erkennbare Reaktion auf einen Programmierfehler stattfindet.'},
     {'question': 'Was sind Typinvarianten?', 'answer': 'Typinvarianten sind eine Möglichkeit, Variablenfehlbelegungen zu verhindern. Sie beschränken die Menge der zulässigen Werte einer Variablen. In typisierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Variablendeklaration. In nicht oder nur optional typisierten Sprachen kann sie auch hergeleitet (inferiert) werden.'},
     {'question': 'Was sind Typannotationen?', 'answer': 'Typannotationen sind eine Möglichkeit, Variablen mit expliziten Typinvarianten zu versehen, die die Menge ihrer zulässigen Werte beschränken. Sie werden in typisierten Programmiersprachen explizit und zwingend bei der Variablendeklaration angegeben, während sie in nicht oder nur optional typisierten Sprachen hergeleitet und implizit sein können.'},
     {'question': 'Was sind semantische Fehler in einem Programm?', 'answer': 'Semantische Fehler in einem Programm sind logische Fehler, die sich in unzulässigen Wertzuweisungen ausdrücken. Sie entstehen, wenn die tatsächliche Verwendung eines Programmelements nicht seiner intendierten Bedeutung entspricht, die im Typ des Programmelements spezifiziert ist.'},
     {'question': 'Was ist der einzige Weg, eine mit der Typisierung einer Variablen ausgedrückte Invariante zu verletzen?', 'answer': 'Der einzige Weg, eine mit der Typisierung einer Variablen ausgedrückte Invariante zu verletzen, ist per Wertzuweisung an die Variable.'},
     {'question': 'Was ist eine Invariante?', 'answer': 'Eine Invariante ist eine Bedingung, die während der Ausführung eines Programms immer erfüllt sein muss. Im gegebenen Beispiel ist die Invariante von i, dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen.'},
     {'question': 'Was ist dynamische Typprüfung?', 'answer': 'Dynamische Typprüfung ist eine Methode zur Gewährleistung von Typkorrektheit, bei der zur Laufzeit vor einer Variablenzuweisung geprüft wird, ob der zuzuweisende Wert den von der Variablen geforderten Typ hat. Der Nachteil ist, dass diese Prüfung zu spät kommt und häufig nur zu einem Programmabbruch führt.'},
     {'question': 'Was ist dynamische Typisierung?', 'answer': 'Dynamische Typisierung ist die Tatsache, dass der Typ eines Objekts zur Laufzeit bekannt ist. Im Gegensatz zur statischen Typisierung, bei der der Typ zur Übersetzungszeit bekannt ist.'},
     {'question': 'Was ist statische Typprüfung?', 'answer': 'Die statische Typprüfung ist ein Verfahren, bei dem die Typkorrektheit eines Programms bereits während der Übersetzungszeit geprüft wird. Im Gegensatz zur dynamischen Typprüfung, die zur Laufzeit erfolgt, wird bei der statischen Typprüfung der Beweis erbracht, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird.'},
     {'question': 'Was ist ein ausdruckskräftiges Typsystem?', 'answer': 'Ein ausdruckskräftiges Typsystem ist ein Typsystem, das in einer Typannotation mehr Informationen unterbringen und damit mehr Typfehler aufdecken kann. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass eine aufwändige Typprüfung notwendig ist. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können.'},
     {'question': 'Was bedeutet nominale Konformität?', 'answer': 'Nominale Konformität bedeutet, dass für die Konformität einer Erweiterung nicht nur die Struktur, sondern auch der Name des Typs, der erweitert wird, explizit angegeben werden muss.'},
     {'question': 'Was bedeutet es, wenn ein Typ reflexiv ist?', 'answer': 'Wenn ein Typ reflexiv ist, bedeutet das, dass er eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.'},
     {'question': 'Welche Arten von Typisierung bietet STRONGTALK?', 'answer': 'STRONGTALK bietet zwei Arten von Typisierung: Die erste Art erfordert vom Compiler eine Prüfung, ob eine Klasse tatsächlich über alle Eigenschaften der von ihr genannten Typen verfügt. Bei der zweiten Art ist diese Prüfung automatisch der Fall, da der Typ gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den meisten typisierten, objektorientierten Programmiersprachen bevorzugt, während die erste Art in Sprachen wie Java und C-Sharp vorkommt.'}
     ],
    [{'question': 'Wie wird der Typ einer parametrischen Typdefinition konkretisiert?', 'answer': 'Die Typdefinition wird durch Instanziierung der parametrischen Typdefinition mit einem konkreten Typen konkretisiert. Dieser Vorgang ergibt sich automatisch und muss nicht explizit hingeschrieben werden.'},
     {'question': 'Wie oft kann eine parametrische Typdefinition in einem Programm verwendet werden?', 'answer': 'Eine parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.'},
     {'question': 'Wie hängt das Löschen von Eigenschaften (Methoden) mit der Typeinschränkung zusammen?', 'answer': 'Das Löschen von Eigenschaften (Methoden) kann als ein Spezialfall der Typeinschränkung verstanden werden, bei der der Wertebereich auf die leere Menge eingeschränkt wird. In diesem Fall wäre die Methode nicht mehr aufrufbar, da es kein typkorrektes Parameterobjekt gäbe, was einer Löschung gleichkäme.'},
     {'question': 'Wie kann man den Typ der in Beziehung stehenden Objekte bei der Deklaration von n-wertigen Attributen angeben?', 'answer': 'Man kann den Typ der in Beziehung stehenden Objekte bei der Deklaration von n-wertigen Attributen angeben, indem man die Collection-Klassen als Typen für die Zwischenobjekte verwendet.'},
     {'question': 'Wie wird Typkonformität in der Regel gehandhabt?', 'answer': 'In der objektorientierten Programmierung wird die Typkonformität in der Regel namensgebunden gehandhabt.'},
     {'question': 'Wann sind zwei Typen zuweisungskompatibel?', 'answer': 'Zwei Typen sind zuweisungskompatibel, wenn sie identisch sind oder wenn sie eine Typäquivalenz aufweisen, d.h. wenn sie bis auf ihre Namen gleich sind.'},
     {'question': 'Wie funktioniert Typerweiterung?', 'answer': 'Typerweiterung wird zum Beispiel durch die Definition neuer Module erreicht, die den ursprünglichen Datentyp erweitern, indem sie neue Methoden hinzufügen. Diese neuen Module können dann verwendet werden, um auf die erweiterten Funktionen des Datentyps zuzugreifen, ohne den ursprünglichen Code zu ändern.'},
     {'question': 'Wie wird ein Typ in SMALLTALK definiert?', 'answer': 'In SMALLTALK wird ein Typ durch das Protokoll definiert, das heißt, durch die Menge der Methoden, die ein Objekt versteht.'},
     {'question': 'Wie werden Typen in STRONGTALK definiert?', 'answer': 'In STRONGTALK werden Typen in tabellarischer Form definiert und mit einem Namen versehen. Die Typdefinition enthält keine Typdefinitionen, sondern Namen.'},
     {'question': 'Wie werden Typen in SMALLTALK verwendet?', 'answer': 'In SMALLTALK werden keine Typen verwendet. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht.'},
     {'question': 'Wie werden Typen in Smalltalk definiert?', 'answer': 'In Smalltalk werden keine Typen verwendet, stattdessen findet man in Smalltalk-Programmen manchmal Namen wie "aString", "anInteger" etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht.'},
     {'question': 'Wie können Typen in einer Programmiersprache mit Bedeutung versehen werden?', 'answer': 'Es gibt verschiedene Möglichkeiten, Typen in einer Programmiersprache mit Bedeutung zu versehen. Eine Möglichkeit ist, sie auf bekannte externe Formalismen abzubilden, wie beispielsweise die boolesche Algebra für den Typ Boolean. Eine andere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer Maschine abzubilden. Für von der Programmiererin definierte Typen kann die Bedeutung vom Compiler "induktiv über deren Aufbau" aus der Bedeutung von Typen abgeleitet werden, die eine vorgegebene Semantik haben. Diese Art der Semantik wird operationale Semantik genannt. Eine weitere Möglichkeit ist, Typen über abstrakte Datentypen zu definieren, die in der Programmiersprache syntaktisch als eine Menge von Operationen beschrieben werden, deren Operanden alle selbst typisiert sind.'},
     {'question': 'Wie kann man Rekursion in der Programmierung herstellen?', 'answer': 'Eine Möglichkeit, Rekursion in der Programmierung herzustellen, ist die Verwendung eines nicht parametrischen Typs als Subtyp eines parametrisierten Typs, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.'},
     {'question': 'Wie verändern sich die Eingabe- und Ausgabeparameter bei einer Methodenredefinition?', 'answer': 'Bei einer Methodenredefinition dürfen sich die Eingabeparameter nur zu einem Supertypen hin und die Ausgabeparameter nur zu einem Subtyp hin verändern, um die Typkorrektheit des Programms zu gewährleisten.'},
     {'question': 'Wie kann die Einschränkung von Ein- oder Rückgabetypen von Methoden die Zuweisungskompatibilität beeinflussen?', 'answer': 'Die Einschränkung von Ein- oder Rückgabetypen von Methoden kann die Zuweisungskompatibilität beeinflussen, indem sie sicherstellt, dass die Extension des eingeschränkten Typs eine Teilmenge der Extension des einschränkenden Typs ist. Dies kann dazu beitragen, die Typkorrektheit von Zuweisungen zu gewährleisten.'},
     {'question': 'Wie gewährleistet die Verwendung von Typen die Wahrung des Geheimnisprinzips und die Einhaltung von Schnittstellen?', 'answer': 'Die Verwendung von Typen stellt sicher, dass über Variablen nur auf die Elemente einer Klasse zugegriffen wird, die Teil der Schnittstelle sind. Dadurch wird das Geheimnisprinzip gewahrt, und die Einhaltung von Schnittstellen wird durch den Compiler sichergestellt.'},
     {'question': 'Wie verhält sich die Typkonformität in Bezug auf Reflexivität, Transitivität und Symmetrie?', 'answer': 'Typkonformität ist reflexiv, da jeder Typ konform zu sich selbst ist. Sie ist transitiv, sodass wenn Typ A konform zu Typ B ist und Typ B konform zu Typ C ist, dann ist auch Typ A konform zu Typ C. Im Gegensatz zur Typäquivalenz ist Typkonformität nicht symmetrisch. Es gilt jedoch meistens die Antisymmetrie, was bedeutet, dass wenn Typ B zu Typ A und Typ A zu Typ B konform ist, dann müssen A und B identisch sein.'},
     {'question': 'Wie verhält sich die Typäquivalenz in Bezug auf Symmetrie?', 'answer': 'Typäquivalenz ist eine symmetrische Eigenschaft, was bedeutet, dass wenn Typ A äquivalent zu Typ B ist, dann ist auch Typ B äquivalent zu Typ A.'},
     {'question': 'Wie können Typen und Klassen in einem Sprachkonstrukt trotz unterschiedlicher Zwecke zusammengefasst werden?', 'answer': 'Obwohl Typen und Klassen unterschiedliche Zwecke haben, teilen sie sich strukturelle Ähnlichkeiten, die es ermöglichen, ihre Definition in einem Sprachkonstrukt zu kombinieren. Dies erleichtert die Verwendung beider Konzepte in einer Programmiersprache.'},
     {'question': 'Wie steht Inklusionspolymorphie in Beziehung zum Subtyping?', 'answer': 'Inklusionspolymorphie und Subtyping sind im Wesentlichen dasselbe Konzept. Beide Begriffe beschreiben, wie Objekte eines Subtyps anstelle ihres Supertyps verwendet werden können.'},
     {'question': 'Wie werden Typfehler in STRONGTALK vermieden?', 'answer': 'In STRONGTALK werden Typfehler vermieden, indem Variablen mit einem Protokoll als Typ typisiert werden. Wenn das Programm typkorrekt ist, bedeutet dies, dass jede Methode im Protokoll, die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist.'},
     {'question': 'Wie werden Typen in Variablendeklarationen verwendet?', 'answer': 'Typen werden in Variablendeklarationen explizit angegeben, um jedem Objekt und Ausdruck im Programm einen Typ zuzuordnen.'},
     {'question': 'Wie erfolgt die Zuweisung eines Typs an eine Typvariable?', 'answer': 'Die Zuweisung eines Typs zu einer Typvariable erfolgt bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, z. B. der Deklaration einer Variable oder des Rückgabewerts einer Methode. Diese Verwendung entspricht oberflächlich betrachtet dem Aufruf einer Methode oder eines Konstruktors, führt aber bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen.'},
     {'question': 'Wie wird eine Beschränkung des tatsächlichen Typparameters in der Typdefinition erreicht?', 'answer': 'Die Beschränkung des tatsächlichen Typparameters wird erreicht, indem der formale Typparameter auf einen Subtyp beschränkt wird.'},
     {'question': 'Wie können definierte Typen in STRONGTALK-Programmen verwendet werden?', 'answer': 'Definierte Typen können in STRONGTALK-Programmen bei der Deklaration von (anderen) Typen, von Variablen, von Blöcken und von Methoden verwendet werden. Dies führt zu einer Typisierung der deklarierten Programmelemente.'},
     {'question': 'Wie werden Variablen in STRONGTALK typisiert?', 'answer': 'Variablen (einschließlich Instanzvariablen und temporäre Variablen) werden in STRONGTALK typisiert, indem ein Typname in spitzen Klammern an die Variable angehängt wird.'},
     {'question': 'Wie bestimmt der Compiler den Speicherbedarf einer Variable?', 'answer': 'Der Compiler kann anhand des Typs einer Variablen bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss.'},
     {'question': 'Wozu kann die Typisierung in der Entwurfsphase verwendet werden?', 'answer': 'In der Entwurfsphase kann die Typisierung dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt.'},
     {'question': 'Wozu kann die Typisierung in der Testphase verwendet werden?', 'answer': 'In der Testphase kann die Typisierung dazu verwendet werden, die Art der Daten zu überprüfen, die an Methoden übergeben werden.'},
     {'question': 'Wozu dienen Typinformationen in der Dokumentation?', 'answer': 'Typinformationen in der Dokumentation helfen anderen Entwicklern, den Code zu verstehen und korrekt zu verwenden.'},
     {'question': 'Was ist der Zweck von Typvariablen in Typdefinitionen?', 'answer': 'Der Zweck von Typvariablen in der Typdefinition ist, dass sie anstelle des Parameters und des Rückgabetyps T nennen, wobei T eine Typvariable ist. Typvariablen werden verwendet, um keinen tatsächlichen Typen zu verdecken, wie es sonst versehentlich passieren könnte. Typvariablen können auch zu einer parametrischen Klassendefinition beliebig viele Typen haben.'},
     {'question': 'Was ist der Zweck von Typumwandlungen?', 'answer': 'Typumwandlungen sind in der Programmierung entweder überflüssig oder unsicher. Wenn sie unverzichtbar sind, sollten sie mit einem Typtest abgesichert werden, um sicherzustellen, dass das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat.'},
     {'question': 'Was ist der Zweck eines Typsystems?', 'answer': 'Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern.'},
     {'question': 'Was ist ein Beispiel für eine parametrische Definition einer Collection?', 'answer': 'Ein Beispiel für eine parametrische Definition einer Collection ist Dictionary, bei dem nicht nur der Elementtyp, sondern auch der Schlüsseltyp variabel gehalten werden sollte.'},
     {'question': 'Was ist der Zweck der Deklaration von Programmelementen?', 'answer': 'Die Deklaration von Programmelementen dient dazu, dem Compiler den Bezeichner bekanntzugeben, damit er ihn in der Folge wiedererkennen und mit der entsprechenden Definition in Verbindung bringen kann.'},
     {'question': 'Was ist der Zweck der Typisierung in Programmiersprachen?', 'answer': 'Der Zweck der Typisierung in Programmiersprachen ist es, den möglichen Wertebereich von Variablen und anderen Programmelementen einzuschränken. So lassen sich beispielsweise in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zeichenketten speichern.'},
     {'question': 'Was ist der Zweck von Typsystemen für die Fehlerentdeckung?', 'answer': 'Typsysteme in der Fehlerentdeckung zielen darauf ab, einen Teil logischer Programmierfehler frühzeitig zu erkennen, indem sie Variablen daran hindern, Werte anzunehmen, die sie eigentlich nicht haben dürften. Dies hilft, Fehler zu vermeiden, die erst zur Laufzeit auftreten und in der Regel einen Programmabbruch verursachen. Diese Art von Fehlern werden als Typfehler bezeichnet.'},
     {'question': 'Wie unterscheidet sich die Verwendung von Klassendefinitionen in STRONGTALK von anderen Sprachen wie Java oder C++?', 'answer': 'In STRONGTALK sind formale Parameter in Klassendefinitionen typisiert, während in Java oder C++ Instanzvariablen nicht Teil einer Typdefinition sein können.'},
     {'question': 'Warum werden Metatypen in der Praxis nicht genutzt?', 'answer': 'Metatypen werden in der Praxis nicht genutzt, da sie eine zusätzliche Komplexität in die Sprache einführen und die Sprache unnötig erschweren würden. Zudem gibt es andere Möglichkeiten, um Typbeschränkungen zu erreichen, wie zum Beispiel die Verwendung von generischen Typen oder die Verwendung von Interfaces.'},
     {'question': 'Warum sind Typsysteme, die kovariante Redefinition erlauben, kaum praxistauglich?', 'answer': 'Typsysteme, die kovariante Redefinition erlauben, sind kaum praxistauglich, weil sie zu Problemen führen können, wenn Objekte mit unterschiedlichen Typen miteinander interagieren. Wenn beispielsweise eine Methode, die ein Objekt erwartet, das von Typ A ist, ein Objekt erhält, das von Typ B ist, aber B von A abgeleitet ist, kann dies zu unerwarteten Ergebnissen führen, wenn die Methode versucht, auf die spezifischen Eigenschaften von A zuzugreifen, die in B nicht vorhanden sind. Dies kann zu Laufzeitfehlern führen und die Wartbarkeit und Zuverlässigkeit des Codes beeinträchtigen.'},
     {'question': 'Warum ist strukturelle Typkonformität in der objektorientierten Programmierung weniger gebräuchlich?', 'answer': 'Strukturelle Typkonformität ist in der objektorientierten Programmierung weniger gebräuchlich, weil sie die statische Typisierung untergraben würde.'},
     {'question': 'Warum ist Zuweisungskompatibilität unter Subtyping möglich?', 'answer': 'Zuweisungskompatibilität unter Subtyping ist möglich, weil Subtypen alle Eigenschaften ihrer Supertypen erben und somit keine Typfehler auftreten können.'},
     {'question': 'Warum sollte man auf Typumwandlungen verzichten?', 'answer': 'Typumwandlungen können überflüssig oder unsicher sein. Daher ist es besser, auf sie zu verzichten, um Fehler zu vermeiden. Wenn sie unverzichtbar sind, sollten sie mit einem Typtest abgesichert werden, um sicherzustellen, dass das Objekt, für das der typgewandelte Ausdruck steht, den gewünschten Typ hat.'},
     {'question': 'Warum ist die Typsicherheit eine nicht-triviale Eigenschaft?', 'answer': 'Die Typsicherheit ist eine nicht-triviale Eigenschaft, weil eine sorgfältige Analyse erforderlich ist, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden.'},
     {'question': 'Warum ist die einfache Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich?', 'answer': 'Die einfache Form des parametrischen Polymorphismus ist nur teilweise nützlich, da die Typvariablen selbst nicht typisiert sind, und somit innerhalb der Typdefinition keine Aussagen über den Typ getroffen werden können.'},
     {'question': 'Warum führt die Typeinschränkung zur Problematik der Zuweisungskompatibilität?', 'answer': 'Die Typeinschränkung kann die Zuweisungskompatibilität beeinträchtigen, da sie die Parameter-Typen in Methoden neu definiert und dadurch potenziell Konflikte bei der Zuweisung von Objekten unterschiedlicher Typen verursachen kann. Dies führt dazu, dass nicht alle Zuweisungen, die bei Typerweiterung basierend auf Typkonformität zulässig wären, bei Typeinschränkung ebenfalls zulässig sind.'},
     {'question': 'Warum wird in der Praxis der objektorientierten Programmierung oft die Referenzsemantik verwendet?', 'answer': 'In der Praxis der objektorientierten Programmierung wird oft die Referenzsemantik verwendet, da sie effizienter ist und es ermöglicht, auf dasselbe Objekt von verschiedenen Stellen im Code aus zuzugreifen. Dies erleichtert die Arbeit mit komplexen Datenstrukturen und verhindert unnötige Kopien von Objekten. Die Referenzsemantik ist daher die gebräuchlichere Semantik in vielen objektorientierten Programmiersprachen.'},
     {'question': 'Warum ist die Teilmengenbeziehung bei der Typeinschränkung nicht immer offensichtlich?', 'answer': 'Bei der Typeinschränkung, bei der Eigenschaften (Methoden) entfernt werden, kann die Extension des eingeschränkten Typs tatsächlich größer werden, da weniger spezifische Anforderungen gestellt werden. Dies kann zu einer scheinbaren Umkehrung der Teilmengenbeziehung führen.'},
     {'question': 'Warum ist die Namensäquivalenz als Bedingung der Zuweisungskompatibilität wichtig?', 'answer': 'Die Namensäquivalenz ist wichtig, da sie sicherstellt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Sie verhindert Zuweisungen zwischen Typen, die zwar strukturell gleich sind, aber unterschiedliche Bedeutungen haben. Dies ist entscheidend, um logische Programmierfehler zu vermeiden, die sonst schwer zu entdecken wären.'},
     {'question': 'Warum gehört eine Instanz einer Subklasse nicht zwangsläufig zum Wertebereich des zur Superklasse gehörenden Typs?', 'answer': 'Eine Instanz einer Subklasse gehört nicht zwangsläufig zum Wertebereich des zur Superklasse gehörenden Typs, da in der Subklasse Änderungen vorgenommen werden können, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben können. Zum Beispiel können Methoden gelöscht oder inkompatibel redefiniert werden.'},
     {'question': 'Warum setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität?', 'answer': 'Die meisten Programmiersprachen setzen auf nominale Typkonformität, da sie automatisch gegeben ist, wenn der Typ, von dem ein neuer per Erweiterung abgeleitet wird, genannt wird. Dies vermeidet aufwendige, fallweise Konformitätstests. Strukturelle Typsysteme, insbesondere solche ohne explizite Benennung von Typen, erschweren die Ausdrücklichkeit der Programmiererin bei der Definition ihrer Absicht (intendierte Semantik) und können Programme schwerer lesbar und debugbar machen. Fehlermeldungen aus strukturellen Typprüfungen sind oft schwer zu verstehen und beziehen sich nicht immer auf die eigentliche Fehlerquelle.'},
     {'question': 'Warum wird die Unterscheidung zwischen Klassen und Typen in Sprachen, in denen jede Klasse einen Typ definiert, nicht klar getroffen?', 'answer': 'In Sprachen, in denen Klassen auch Typen definieren, kann die Unterscheidung zwischen den beiden Konzepten verschwommen sein, da Programmierer möglicherweise nicht immer klar wahrnehmen, wie sie zur Laufzeit eines Programms wirken.'},
     {'question': 'Warum ist die Typisierung von Variablen und Ausdrücken in einem Programm wichtig?', 'answer': 'Die Typisierung von Variablen und Ausdrücken in einem Programm ist wichtig, um sicherzustellen, dass jede Variable nur Werte haben kann, für die sie vorgesehen ist. Dies gewährleistet die Einhaltung der Typinvariante und verhindert Typfehler im Programm.'},
     {'question': 'Warum ist Zuweisungskompatibilität auch bei impliziten Zuweisungen wichtig?', 'answer': 'Zuweisungskompatibilität ist auch bei impliziten Zuweisungen wichtig, da sie Typkorrektheit impliziert. Bei der Parameterübergabe von Methodenaufrufen oder impliziten Zuweisungen müssen die beteiligten Typen kompatibel sein, um Typfehler zu vermeiden.'},
     {'question': 'Warum sind Upcasts immer typsicher, während Downcasts und Crosscasts unsicher sein können?', 'answer': 'Upcasts sind immer typsicher, da sie von einem spezielleren Typ zu einem allgemeineren Typ erfolgen. Downcasts und Crosscasts können unsicher sein, da sie von einem allgemeineren Typ zu einem spezielleren oder nicht verwandten Typ erfolgen, was dazu führen kann, dass der Ausdruck zur Laufzeit nicht den erwarteten Typ hat.'},
     {'question': 'Warum nennt man parametrische Typen auch generische Typen oder Generics?', 'answer': 'Parametrische Typen werden auch als generische Typen oder Generics bezeichnet, weil sie die Idee verfolgen, aus einer Typdefinition generisch (theoretisch für beliebig viele Typen) viele Typen zu erzeugen, je nach Bedarf. Sie ermöglichen eine gewisse Generizität in der Typsicherung.'},
     {'question': 'Warum ist die Kovarianz für Parametertypen in der Praxis nicht notwendig und kann sogar zu typinkorrekten Programmen führen?', 'answer': 'Obwohl Kovarianz für Parametertypen auf den ersten Blick sinnvoll erscheint, kann sie in der Praxis zu typinkorrekten Programmen führen. Dies liegt daran, dass die Anzahl der möglichen Eingabewerte in einem Subtyp reduziert wird, wenn die Menge der Empfängerobjekte eingeschränkt wird. Dies führt dazu, dass die Parametertypen tatsächlich kontravariant sind. Kovarianz für Parametertypen würde typinkorrekte Programme ermöglichen.'},
     {'question': 'Warum ist es vorteilhaft, wenn man den Typ einer Variablen kennt?', 'answer': 'Wenn man den Typ einer Variablen kennt, kann der Compiler bestimmte Optimierungen durchführen, wie z.B. die Ganzzahladdition oder die Inkrement-Anweisung des Prozessors verwenden. Wenn der Compiler den Typ nicht kennt, muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist, was zu Laufzeitverzögerungen führen kann.'},
     {'question': 'Warum ist es sinnvoll, Variablen und Methoden mit Typen zu assoziieren?', 'answer': 'Es ist sinnvoll, Variablen und Methoden mit Typen zu assoziieren, um die Bedeutung der Variablen und Methoden für den Nutzer zu verdeutlichen. Zum Beispiel kann eine Deklaration der Methode next, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, nahelegen, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren.'},
     {'question': 'Erklären Sie Kovarianz und Kontravarianz in Bezug auf Redefinition von Methodenaufrufen im Subtyping?', 'answer': 'Bei der Redefinition von Methodenaufrufen im Subtyping müssen die Parametertypen kontravariant und die Rückgabetypen kovariant sein. Dies bedeutet, dass die Eingabeparameter des Subtyps genereller sein dürfen als die des Supertyps, während der Subtyp mehr Werte zurückgeben kann als der Supertyp.'}
     ],
    [{'question': 'Was versteht man unter parametrisierter Typdefinition?', 'answer': 'Eine parametrisierte Typdefinition ist eine Möglichkeit, einen Typ in der Programmierung zu definieren, der einen oder mehrere Typparameter enthält. Diese Typparameter können bei der Instanziierung des Typs durch konkrete Typen ersetzt werden, um einen konkreten Typ zu erzeugen. Durch die Verwendung parametrisierter Typdefinitionen kann Code wiederverwendet werden, und die Typsicherheit wird erhalten.'},
     {'question': 'Was ist der Nachteil der einfachen Form des parametrischen Polymorphismus?', 'answer': 'Der Nachteil der einfachen Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung ist, dass die Typvariablen selbst nicht typisiert sind, und man daher innerhalb der Typdefinition keine Aussagen über den Typ treffen kann.'},
     {'question': 'Was bedeutet die Beschränkung von Typvariablen?', 'answer': 'Die Beschränkung von Typvariablen drückt aus, dass die Typen, die als Werte für die Typvariable eingesetzt werden dürfen, Subtypen des angegebenen Typs sein müssen.'},
     {'question': 'Was passiert, wenn eine unzulässige Deklaration von Typvariablen durchgeführt wird?', 'answer': 'Wenn eine unzulässige Deklaration von Typvariablen durchgeführt wird, führt dies zu einem Typfehler während der statischen Typprüfung.'},
     {'question': 'Was impliziert die Definition von Subtypen in Bezug auf Zuweisungskompatibilität?', 'answer': 'Die Definition von Subtypen impliziert Zuweisungskompatibilität, das heißt, Objekte eines Subtyps dürfen überall auftauchen, wo Objekte seines Supertyps erwartet werden, und sie dürfen auch Werte von jemandem zugreifen, der bei einer Zeichnung auf ihre Zeilen zugreifen will.'},
     {'question': 'Was ist der Unterschied zwischen Typerweiterung und Typeinschränkung?', 'answer': 'Typerweiterung erfolgt durch Hinzufügen von Eigenschaften (Methoden) zu einem bestehenden Typen, während Typeinschränkung durch Entfernen von Eigenschaften (Methoden) von einem bestehenden Typen erfolgt. Typerweiterung führt zur Zuweisungskompatibilität, während Typeinschränkung nicht dazu führt.'},
     {'question': 'Was ist der Unterschied zwischen Wertsemantik und Referenzsemantik in Bezug auf Zuweisungskompatibilität in der objektorientierten Programmierung?', 'answer': 'In der objektorientierten Programmierung ist bei der Zuweisungskompatibilität nur die Referenzsemantik relevant. Bei der Referenzsemantik wird nur der Verweis auf das Objekt kopiert und in der Variablen gespeichert, während bei der Wertsemantik eine Kopie des Objekts angefertigt wird. Dies führt dazu, dass bei der Referenzsemantik Änderungen am Objekt in einer Variablen auch das Objekt in einer anderen Variablen betrifft, wenn sie auf dasselbe Objekt verweisen. Bei der Wertsemantik hingegen betrifft eine Änderung am Objekt in einer Variablen nicht das Objekt in einer anderen Variablen, da es sich um eine Kopie handelt.'},
     {'question': 'Was ist der Unterschied zwischen Deklaration und Definition einer Variablen?', 'answer': 'Bei der Deklaration wird dem Bezeichner das zugeordnet, wofür er steht, während bei der Definition der Speicherplatz für die Variable zugewiesen wird. In manchen Kontexten wird der Begriff Definition aber auch für die Zuweisung eines Anfangswerts an eine Variable verwendet.'},
     {'question': 'Was ist der Unterschied zwischen Deklaration und Definition einer Methode?', 'answer': 'Bei der Deklaration wird die Signatur einer Methode bekannt gegeben, bei der Definition wird der Signatur der Methodenrumpf zugeordnet.'},
     {'question': 'Was sind die Nachteile von Sprachen, die Variablen nicht deklarieren?', 'answer': 'Wenn Variablen nicht deklariert werden, können Schreibfehler dazu führen, dass plötzlich zwei Variablen anstatt einer existieren, was zu Programmierfehlern führen kann. Diese Art von Fehlern ist schwer zu erkennen und zu beheben.'},
     {'question': 'Was ist der Nachteil von Namensäquivalenz?', 'answer': 'Der Nachteil von Namensäquivalenz ist, dass sie voraussetzt, dass getrennt voneinander entwickelte Programme dieselben Typen verwenden. Für die Interoperabilität von getrennt voneinander entwickelten Programmen kann dies ein echtes Hindernis sein.'},
     {'question': 'Was ist der Unterschied zwischen nominaler und struktureller Typäquivalenz?', 'answer': 'Nominale Typäquivalenz erlaubt Äquivalenz von Typen, bei deren Definition man vom jeweils anderen nichts wusste. Strukturelle Typäquivalenz bietet mehr Flexibilität, hat jedoch den Nachteil, dass zufällige strukturelle Übereinstimmungen zu einer Äquivalenz führen können, die nicht der intendierten Semantik entspricht. Type branding führt in solchen Fällen optional eine Namensäquivalenz durch die Hintertür ein, mit dem Vorteil, dass diese optional ist.'},
     {'question': 'Was ist der Unterschied zwischen einer Schnittstelle und einem Typ?', 'answer': 'Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nämlich nur aus Deklarationen von Methoden. Im Gegensatz dazu, werden bei einem Typ die Instanzvariablen der Objekte in die Schnittstelle der Klassen aufgenommen, was dem Gedanken des Geheimnisprinzips widerspricht.'},
     {'question': 'Was passiert mit der Typkonformität zwischen Super- und Subklasse, wenn Methoden gelöscht oder inkompatibel redefiniert werden?', 'answer': 'Wenn in der Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, also z. B. Methoden gelöscht oder inkompatibel redefiniert werden, dann ist eine Instanz einer Subklasse nicht mehr dem Wertebereich des zur Superklasse gehörenden Typs zugehörig.'},
     {'question': 'Was passiert, wenn in einer Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben?', 'answer': 'Wenn in einer Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, dann ist eine Instanz der Subklasse nicht mehr mit dem Typ der Superklasse kompatibel. Das ist in den meisten objektorientierten Programmiersprachen nicht erlaubt.'},
     {'question': 'Was bedeutet die Antisymmetrie der Typkonformität?', 'answer': 'Die Antisymmetrie der Typkonformität bedeutet, dass wenn ein Typ B typkonform zu einem Typ A ist und A zu B typkonform ist, dann müssen A und B identisch sein. Das heißt, dass es keine zwei verschiedenen Typen geben kann, die beide typkonform zu einander sind.'},
     {'question': 'Was ist der Unterschied zwischen struktureller Typkonformität und namensgebundener Typkonformität?', 'answer': 'Strukturelle Typkonformität besteht, wenn der konforme Typ alle Elemente des Typs, zu dem er konform sein soll, enthält. Nominale Typkonformität hingegen bezieht sich auf die Übereinstimmung von Typnamen, unabhängig davon, ob die Typen strukturell identisch sind oder nicht.'},
     {'question': 'Warum folgt die Konformität aus der Erweiterung?', 'answer': 'Die Konformität folgt aus der Erweiterung, weil bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben.'},
     {'question': 'Was bedeutet es, wenn ein Typ eine Erweiterung eines anderen ist, ohne tatsächlich etwas hinzuzufügen?', 'answer': 'In diesem Fall spricht man von Typerweiterung, bei der ein Typ eine Untermenge eines anderen Typs ist und somit alle Eigenschaften und Methoden des übergeordneten Typs besitzt, aber keine zusätzlichen Eigenschaften oder Methoden hinzufügt. Dies ist eine reflexive Beziehung, was bedeutet, dass ein Typ auch sich selbst als Untertyp haben kann.'},
     {'question': 'Ist Typäquivalenz gleichbedeutend mit Typkonformität?', 'answer': 'Nein, Typäquivalenz impliziert Typkonformität, aber nicht umgekehrt. Zwei äquivalente Typen sind auch immer konform, aber ein konformer Typ ist nicht unbedingt äquivalent zu einem anderen Typ.'},
     {'question': 'Was ist der Unterschied zwischen Strukturäquivalenz und Namensäquivalenz?', 'answer': 'Strukturäquivalenz bedeutet, dass zwei Typen die gleiche Struktur haben, aber die Namen können unterschiedlich sein. Bei Namensäquivalenz hingegen haben die Namen eine von der Struktur unabhängige Bedeutung, d.h. sie sind identisch. Namensäquivalenz impliziert Strukturäquivalenz, aber nicht umgekehrt.'},
     {'question': 'Was sind die Vorteile von Typerweiterung?', 'answer': 'Die Vorteile von Typerweiterung sind, dass sie es ermöglicht, bestehenden Code wiederzuverwenden und neue Funktionalität hinzuzufügen, ohne den ursprünglichen Code zu ändern. Dies führt zu einer besseren Codequalität, da weniger Änderungen am Code vorgenommen werden müssen und die Wahrscheinlichkeit von Fehlern reduziert wird.'},
     {'question': 'Was sind die Nachteile von Typerweiterung?', 'answer': 'Die Nachteile von Typerweiterung sind, dass sie die Komplexität des Codes erhöhen kann, da es mehrere Versionen des gleichen Datentyps gibt. Dies kann zu Verwirrung führen und die Wartbarkeit des Codes beeinträchtigen. Außerdem kann Typerweiterung zu einer unkontrollierten Ausdehnung des Codes führen, wenn nicht sorgfältig geplant und implementiert wird.'},
     {'question': 'Was wird verhindert, wenn man eine Variable mit einem Protokoll als Typ typisiert und das Programm typkorrekt ist?', 'answer': 'Wenn man eine Variable mit einem Protokoll als Typ typisiert und das Programm typkorrekt ist, wird verhindert, dass Typfehler auftreten, also Fehler der Sorte „does not understand“, die auftreten, wenn eine Methode aufgerufen wird, die für den Inhalt der Variable, das referenzierte Objekt, nicht definiert ist.'},
     {'question': 'Was ist der Unterschied zwischen STRONGTALK und anderen Programmiersprachen hinsichtlich primitiver Typen?', 'answer': 'Im Gegensatz zu STRONGTALK haben andere Programmiersprachen oft primitiver Typen, deren Definitionen nicht auf andere Typen zurückgeführt werden müssen. In STRONGTALK gibt es keine primitiven Typen, alle Typen sind selbstbezüglich.'},
     {'question': 'Was ist der Unterschied zwischen Upcast, Downcast und Crosscast?', 'answer': 'Upcasts sind Typumwandlungen zu Supertypen, Downcasts sind Typumwandlungen zu Subtypen und Crosscasts sind Typumwandlungen zu Typen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Upcasts sind immer typsicher, Downcasts und Crosscasts hingegen nicht. Downcasts werden häufig verwendet, wenn kein parametrischer Polymorphismus zur Verfügung steht oder wenn ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten und stehen für einen Rollenwechsel eines Objekts.'},
     {'question': 'Was ist der Unterschied zwischen Klassen und Typen?', 'answer': 'Klassen definieren die Implementierung ihrer Objekte, während Typen frei von Implementierungsaspekten sind. Typen sind abstrakte Spezifikationen, die auf eine Typprüfung ohne Ansehen der Implementierung abzielen. Klassen können zumindest eine partielle Implementierung vorgeben, die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können.'},
     {'question': 'Was ist der Unterschied zwischen Typen und Klassen?', 'answer': 'Typen sind abstrakte Spezifikationen, die den Wertebereich von Variablen einschränken und das Protokoll von Objekten angeben. Klassen hingegen sind Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Objekte können den Wertebereich von Typen ausmachen, aber Typen und Klassen sind nicht dasselbe.'},
     {'question': 'Können Instanzvariablen ein Bestandteil einer Typdefinition in STRONGTALK sein?', 'answer': 'Nein, anders als z. B. in Java oder C++, können Instanzvariablen kein Bestandteil einer Typdefinition in STRONGTALK sein.'},
     {'question': 'Was ist der Unterschied zwischen Klassendefinitionen in Smalltalk und Strongtalk?', 'answer': 'In Smalltalk werden in Klassendefinitionen keine Typen verwendet, während in Strongtalk die formalen Parameter der Methoden in den Klassendefinitionen typisiert sind. Zudem können in Strongtalk Instanzvariablen kein Bestandteil einer Typdefinition sein, im Gegensatz zu Java oder C++.'},
     {'question': 'Was ist der Unterschied zwischen kovarianter Redefinition und kontravarianter Redefinition?', 'answer': 'Kovariante Redefinition tritt auf, wenn der Parametertyp der Methode sich mit dem Empfängertyp ändert, während kontravariante Redefinition auftritt, wenn der Parametertyp der Methode sich in die entgegengesetzte Richtung zum Empfängertyp ändert. In diesem Fall ist es kein Widerspruch zur Kontravarianzregel des Subtyping, da Integer unmittelbar zu einem Subtyp von Equatable[Integer] wird und nicht von Equatable[Object]. Equatable[Integer] und Equatable[Object] sind zwei vollkommen verschiedene Typen mit disjunkten Wertebereichen, und Equatable[T] ist kein Typ, sodass keinerlei Zuweisungskompatibilität und damit auch kein Problem mit Typkorrektheit besteht.'},
     {'question': 'Kann das Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mit parametrischen Polymorphismus gelöst werden?', 'answer': 'Nur zum Teil, da parametrischer Polymorphismus zwar die Verwendung von verschiedenen Typen von Eingabeparametern ermöglicht, aber nicht die kovariante Redefinition von Eingabeparametern in Unterklassenmethoden.'},
     {'question': 'Was ist der Unterschied zwischen einer parametrischen Typdefinition und einer normalen Typdefinition?', 'answer': 'Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit auf Typen beschränkt ist. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt.'},
     {'question': 'Was ist der Unterschied zwischen typisierten und nicht typisierten Programmiersprachen?', 'answer': 'Im Gegensatz zu typisierten Programmiersprachen, in denen Programmelementen bei ihrer Deklaration Typen zugeordnet werden, sind nicht typisierte Sprachen so konzipiert, dass Typen bei der Deklaration entbehrlich sind. Typen beschränken die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache, aber in nicht typisierten Sprachen können Typen von der restlichen Sprachdefinition getrennt werden, um sie auszutauschen oder zu verbessern.'},
     {'question': 'Wozu werden rekursive Typen verwendet?', 'answer': 'Rekursive Typen werden verwendet, um dynamische Strukturen wie verschachtelte Listen oder Bäume zu definieren. Sie sind ein wichtiges Instrument der Programmierung, bringen aber auch Probleme mit sich, wie zum Beispiel die Schwierigkeit, die strukturelle Äquivalenz zweier rekursiver Typen festzustellen.'},
     {'question': 'Was ist der Unterschied zwischen Invarianz, Kovarianz und Kontravarianz?', 'answer': 'Invarianz, Kovarianz und Kontravarianz sind Konzepte in der objektorientierten Programmierung, die sich auf die Beziehung zwischen dem Typ eines Objekts und dem Typ eines seiner Untertypen beziehen. Invarianz bedeutet, dass der Typ eines Objekts unverändert bleibt, wenn es in ein Untertyp-Objekt konvertiert wird. Kovarianz bedeutet, dass der Typ eines Objekts sich auf die gleiche Weise ändert wie der Typ des Untertyps, wenn es in ein Untertyp-Objekt konvertiert wird. Kontravarianz bedeutet, dass der Typ eines Objekts sich entgegengesetzt zum Typ des Untertyps ändert, wenn es in ein Untertyp-Objekt konvertiert wird.'},
     {'question': 'Wozu dient ein allgemeiner parametrischer Typ?', 'answer': 'Ein allgemeiner parametrischer Typ dient dem Zweck, den Parametertyp des Tests variabel zu halten und nur für den Gleichheitstest verwendet zu werden.'},
     {'question': 'Wozu dient ein parametrischer Typ im Gleichheitstest?', 'answer': 'Ein parametrischer Typ wird im Gleichheitstest verwendet, um den Typ des Parameters variabel zu halten und einen allgemeinen Gleichheitstest zu definieren, der für verschiedene Typen verwendet werden kann.'},
     {'question': 'Was passiert bei der Redefinition einer Methode mit den Eingabe- und Ausgabeparametern?', 'answer': 'Bei der Redefinition einer Methode dürfen sich die Eingabeparameter nur zu einem Supertypen ändern, während die Ausgabeparameter nur zu einem Subtyp geändert werden dürfen, um die Typkorrektheit des Programms zu gewährleisten.'},
     {'question': 'Was ist der Unterschied zwischen parametrischen Polymorphismus und Inklusionspolymorphie?', 'answer': 'Parametrischer Polymorphismus ist eine Technik, die es ermöglicht, dass eine Funktion oder Methode mit Argumenten verschiedener Typen aufgerufen werden kann, während Inklusionspolymorphie (Subtyping) eine Beziehung zwischen Typen ist, bei der ein Typ B ein Untertyp eines anderen Typs A ist, wenn ein Wert vom Typ B auch als Wert vom Typ A behandelt werden kann. Im Falle von Collections bedeutet dies, dass eine Collection, die auf Objekte eines bestimmten Typs ausgelegt ist, auch Objekte eines Untertyps dieses Typs aufnehmen kann.'},
     {'question': 'Was ist der Nachteil einer erhöhten Typsicherheit außerhalb der Typdefinition?', 'answer': 'Der Nachteil der erhöhten Typsicherheit außerhalb der Typdefinition ist die verminderte Typsicherheit innerhalb der Typdefinition.'},
     {'question': 'Welchen Nachteil hat die Namensäquivalenz in Bezug auf die Interoperabilität von getrennt voneinander entwickelten Programmen?', 'answer': 'Die Namensäquivalenz setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen dieselben Typen verwenden. Dies kann ein Hindernis für die Interoperabilität von solchen Programmen, wie zum Beispiel Web Services, darstellen.'},
     {'question': 'Was sind die Unterschiede zwischen struktureller Typäquivalenz und Namensäquivalenz in Bezug auf Flexibilität und Semantik?', 'answer': 'Strukturelle Typäquivalenz bietet mehr Flexibilität als Namensäquivalenz, da sie die Äquivalenz von Typen erlaubt, deren Definition voneinander unabhängig ist. Allerdings können zufällige strukturelle Übereinstimmungen zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Um diesen Nachteil zu vermeiden, kann optional eine Namensäquivalenz durch Type branding eingeführt werden.'},
     {'question': 'Welche Vorteile bietet nominale Typkonformität gegenüber struktureller Typkonformität?', 'answer': 'Nominale Typkonformität bietet die Vorteile der Zuweisungskompatibilität und Abwesenheit von Typfehlern. Sie dient auch als Filterfunktion, da nur Objekte von solchen Typen Variablen zugewiesen werden können, für die die Programmiererin dies aus semantischen Überlegungen heraus ausdrücklich vorgesehen hat.'},
     {'question': 'Was sind mögliche Nachteile der Strukturäquivalenz?', 'answer': 'Bei Verwendung der Strukturäquivalenz können Typen, die inhaltlich nichts miteinander zu tun haben, fälschlicherweise als äquivalent betrachtet werden. Dies kann dazu führen, dass Objekte, die eigentlich unterschiedlichen Typen angehören, fälschlicherweise zugewiesen werden können, was zu semantischen Fehlern führen kann. Dieses Problem kann durch die Technik des "Type Branding" gelöst werden, bei der jedem Typ eine charakteristische Methode exklusiv zugeordnet wird, um die Strukturäquivalenz einzuschränken.'},
     {'question': 'Was sind die Unterschiede zwischen abstrakten Datentypen und STRONGTALK-Typen?', 'answer': 'Es gibt mindestens zwei wichtige Unterschiede: Abstrakte Datentypen sind nicht objektorientiert, während STRONGTALK-Typen objektorientiert sind und Objekte Zustand haben können. Abstrakte Datentypen haben Funktionen mit einem Argument mehr, das dem Typ des Datentyps selbst entspricht. In objektorientierten Sprachen entspricht dies dem Nachrichtenempfänger, dem impliziten Parameter "self".'},
     {'question': 'Welchen Vorteil bietet der parametrische Polymorphismus gegenüber der Inklusionspolymorphie?', 'answer': 'Der parametrische Polymorphismus bietet den Vorteil einer erhöhten Typsicherheit, da Typfehler bereits zur Instanziierung des parametrischen Typs erkannt werden können.'},
     {'question': 'Was passiert bei der Instanziierung eines parametrischen Typs mit einem konkreten Typen?', 'answer': 'Der konkrete Typ wird in die formale Typvariable eingesetzt, und der resultierende Typ wird zur Verwendung im Programm definiert.'},
     {'question': 'Warum könnte die Annotation von Variablen mit einem Supertypen ein Problem darstellen?', 'answer': 'Die Annotation von Variablen mit dem Supertypen könnte ein Problem darstellen, da dies die Verwendung von Subtypen einschränken würde. Wenn Variablen mit dem Supertypen annotiert sind und nur Werte des Supertyps akzeptieren, könnten keine Objekte des Subtyps in diesen Variablen gespeichert werden, selbst wenn sie die gleiche Struktur oder das gleiche Verhalten aufweisen. Dies würde die Flexibilität des Typsystems einschränken und die Verwendung von Subtypen weniger nützlich machen.'},
     {'question': 'Warum ist die Unterscheidung zwischen Wertsemantik und Referenzsemantik relevant, wenn es um Typeinschränkung geht?', 'answer': 'Die Unterscheidung zwischen Wertsemantik und Referenzsemantik ist relevant, da sie Auswirkungen auf die Zuweisungskompatibilität hat. Unter Wertsemantik wird bei der Zuweisung eine Kopie des Objekts erstellt, während unter Referenzsemantik mehrere Variablen auf dasselbe Objekt verweisen können. In diesem Zusammenhang ist die Referenzsemantik interessanter, da Typeinschränkungen bei der Zuweisung von Aliasen (Variablen, die auf dasselbe Objekt verweisen) Probleme verursachen können, die bei Wertsemantik nicht auftreten.'},
     {'question': 'Was bedeutet es, wenn die Extension eines Typs in der Extension eines anderen Typs enthalten ist?', 'answer': 'Wenn die Extension eines Typs in der Extension eines anderen Typs enthalten ist, bedeutet dies, dass Objekte des ersten Typs an Stellen verwendet werden können, an denen Objekte des zweiten Typs erwartet werden, ohne die Typkorrektheit zu verletzen.'},
     {'question': 'Warum kann es trotz der Harmonie von Typerweiterung und -einschränkung zu einem Verlust der Zuweisungskompatibilität kommen?', 'answer': 'Der Verlust der Zuweisungskompatibilität kann aus der impliziten Allquantifiziertheit von Typinvarianten resultieren. Typsysteme mit solchen Invarianten sind nicht in der Lage, Aussagen über Wertebereiche zu treffen, die nicht implizit allquantifiziert sind.'},
     {'question': 'Warum ist es wichtig, Implementierungen von Klassen hinter Schnittstellen zu verbergen?', 'answer': 'Das Verbergen von Implementierungen hinter Schnittstellen ist wichtig, um das Geheimnisprinzip zu wahren und sicherzustellen, dass nur die für Benutzer einer Klasse vorgesehenen Elemente sichtbar sind.'},
     {'question': 'Was unterscheidet eine absolute und eine relativ spezifizierte Schnittstelle einer Klasse?', 'answer': 'Eine absolute Schnittstelle verrät keinerlei Implementierungsdetails und besteht nur aus Methodendeklarationen. Eine relative Schnittstelle kann sich je nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse unterscheiden und gibt mehr Einblicke in die Implementierung.'},
     {'question': 'Was unterscheidet nominales und strukturelles Subtyping?', 'answer': 'Beim Subtyping gibt es zwei Unterscheidungen: nominales und strukturelles Subtyping.'},
     {'question': 'Warum reicht Strukturäquivalenz als Bedingung für Zuweisungskompatibilität aus?', 'answer': 'Strukturäquivalenz reicht als Bedingung für Zuweisungskompatibilität aus, um Typfehler zu verhindern, die auf der Annahme einer nicht vorhandenen Methode bei einem Wert einer Variable basieren. Sie gewährleistet, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.'},
     {'question': 'Warum gibt es in STRONGTALK keine primitiven Typen?', 'answer': 'In STRONGTALK gibt es keine primitiven Typen, da alle Typen in STRONGTALK auf andere Typen zurückgeführt werden können. Selbst wenn eine Typannotation weggelassen wird, hat die entsprechende Variable bzw. der Rückgabewert der Methode immer einen impliziten Typ. Dies ermöglicht es, Typen mit zwangsläufiger Selbstbezüglichkeit eine Bedeutung zuzuweisen.'},
     {'question': 'Ist Zuweisungskompatibilität eine transitive Eigenschaft?', 'answer': 'Ja, in der Regel ist Zuweisungskompatibilität eine transitive Eigenschaft. Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c ist, dann ist auch a zuweisungskompatibel mit c.'},
     {'question': 'Warum kann es für die Programmiererin problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden?', 'answer': 'Es kann problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden, da der Supertyp möglicherweise nicht alle Methoden und Eigenschaften des tatsächlichen Typs enthält, die die Programmiererin verwenden möchte.'},
     {'question': 'Warum ergibt sich beim rekursiv beschränkten parametrischen Polymorphismus kein Widerspruch zur Kontravarianzregel des Subtyping?', 'answer': 'Es ergibt sich kein Widerspruch zur Kontravarianzregel des Subtyping, da der Empfängertyp (z. B. Integer) lediglich zu einem Subtyp von Equatable[Integer] wird und nicht von Equatable[Object].'},
     {'question': 'Kann das Kovarianzproblem durch parametrische Typen gelöst werden?', 'answer': 'Das Kovarianzproblem kann in bestimmten Fällen durch parametrische Typen gelöst werden, aber es gibt keine allgemeine Lösung, die in allen Fällen die kovariante Redefinition von Eingabeparametern in Methoden ermöglicht. Die Flexibilität ist begrenzt, und es kann zu Einschränkungen bei der Verwendung von parametrischen Typen führen.'},
     {'question': 'Gibt es vollständig in sich selbst definierte Typsysteme, die von externen Einflüssen unabhängig sind?', 'answer': 'Nein, es gibt keine vollständig in sich selbst definierten Typsysteme, die vollständig unabhängig von externen Einflüssen sind. Selbst in Typsystemen wie SMALLTALK oder STRONGTALK sind mindestens einige grundlegende Typen oder Konzepte, wie Wahrheitswerte oder Ganzzahlen, von externen Formalismen oder vorgegebenen Semantiken abhängig.'},
     {'question': 'Warum wird in der Praxis trotz parametrischer Definitionen von Collectios oft auch auf Inklusionspolymorphie zurückgegriffen?', 'answer': 'In der Praxis wird trotz Verwendung parametrischer Definitionen von Collections oft auf Inklusionspolymorphie zurückgegriffen, da heterogene Collections, die Objekte unterschiedlicher Subtypen enthalten, häufig vorkommen und Inklusionspolymorphie dies ermöglicht.'},
     {'question': 'Was ist der Unterschied zwischen Intension und Extension eines Typs?', 'answer': 'Die Intension eines Typs entspricht seiner Definition, während die Extension dem Wertebereich des Typs entspricht, also der Menge der Elemente (Objekte), die zu dem Typ gehören.'},
     {'question': 'Wofür ist der Typ einer Variablen in der objektorientierten Programmierung relevant?', 'answer': 'In der objektorientierten Programmierung ist der Typ einer Variablen nur für Variablen mit Wertsemantik relevant, was jedoch in Sprachen wie SMALLTALK, in denen Referenzsemantik vorherrscht, von untergeordneter Bedeutung ist.'},
     {'question': 'Was ist der Vorteil einer expliziten Typisierung von Variablen?', 'answer': 'Wenn man weiß, dass die Werte einer Variable immer vom selben Typ sind, also alle demselben Wertebereich entstammen, dann lassen sich bestimmte Optimierungen durchführen. Zum Beispiel kann der Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkrement-Anweisung des Prozessors verwenden.'},
     {'question': 'Warum ist es sinnvoll, temporären Variablen einen Hinweis auf den Typ der Werte zu geben?', 'answer': 'Es ist sinnvoll, temporären Variablen einen Hinweis auf den Typ der Werte zu geben, um die Lesbarkeit des Codes zu verbessern und die Funktion der Variablen für die Nutzerin der Funktion, die die Implementation nicht kennt, transparenter zu gestalten.'},
     {'question': 'Wozu dient die Verknüpfung von deklarierten Elementen mit Typen?', 'answer': 'Die Verknüpfung von deklarierten Elementen mit Typen erlaubt die Angabe redundanter Information im Programm, was das Aufdecken von logischen Fehlern erleichtert. Denn nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen logischen Programmierfehler hinweisen.'},
     {'question': 'Was ist ein Vorteil von Typsystemen?', 'answer': 'Ein Vorteil von Typsystemen ist die dadurch entstehende Modularisierung von Programmen, wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt.'},
     {'question': 'Was ist der Nachteil der dynamischen Typprüfung?', 'answer': 'Der Nachteil der dynamischen Typprüfung ist, dass sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes machen kann als einen Fehler zu signalisieren.'},
     {'question': 'Gibt es in SMALLTALK eine Typisierung?', 'answer': 'Nein, in SMALLTALK gibt es keine Typisierung, weder statisch noch dynamisch.'},
     {'question': 'Was ist der Unterschied zwischen dynamischer und statischer Typprüfung?', 'answer': 'Dynamische Typprüfung findet zur Laufzeit eines Programms statt und wird vom Laufzeitsystem oder der Programmiererin durchgeführt, während statische Typprüfung zur Übersetzungszeit stattfindet und vom Compiler durchgeführt wird. Statische Typprüfung stellt sicher, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird, während dynamische Typprüfung dies zur Laufzeit überprüft. Statische Typprüfung ist nützlicher als dynamische Typprüfung, lehnt aber auch Programme ab, die nützlich, sinnvoll und typkorrekt sind.'},
     {'question': 'Was passiert, wenn das Typsystem eines Programms zu kompliziert wird?', 'answer': 'Wenn das Typsystem eines Programms zu kompliziert wird, wird es schwieriger zu benutzen und kann sogar so kompliziert sein wie das Programm, dessen Fehler es entdecken soll. In diesem Fall muss man bei auftretenden Typfehlern prüfen, ob die Ursache in einem fehlerhaften Programm oder in fehlerhaften Typannotationen liegt.'},
     {'question': 'Was passiert, wenn man versucht, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen?', 'answer': 'Wenn man versucht, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen, wird das dazu notwendige Typsystem immer aufwendiger und schwieriger zu benutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken soll. In diesem Fall muss man bei auftretenden Typfehlern prüfen, ob die Ursache tatsächlich in einem fehlerhaften Programm oder in fehlerhaften Typannotationen liegt.'},
     {'question': 'Was ist ein Nachteil von ausdruckskräftigen Typsystemen?', 'answer': 'Ein Nachteil von ausdruckskräftigen Typsystemen ist, dass sie die Gestaltung von Schnittstellen erschweren können und die beteiligten Programme nicht ohne weiteres zusammenarbeiten können.'},
     {'question': 'Was sieht die Typsicherheit bei der Verwendung von parametrischem Polymorphismus aus?', 'answer': 'Die erhöhte Typsicherheit außerhalb der Typdefinition bedeutet, dass die Verwendung des parametrischen Typs sicherer ist, da er nur mit Typen von addierbaren Objekten instanziiert wird. Die verminderte Typsicherheit innerhalb der Typdefinition bedeutet, dass die Definition des parametrischen Typs nicht wissen kann, wie er hinterher verwendet wird, und daher bei der Addition auf die Verwendung von addierbaren Objekten angewiesen ist.'},
     {'question': 'Welchen Vorteil bietet der parametrische Polymorphismus gegenüber der Inklusionspolymorphie?', 'answer': 'Der parametrische Polymorphismus bietet den Vorteil einer erhöhten Typsicherheit, da Typfehler bereits zur Instanziierung des parametrischen Typs erkannt werden können.'},
     {'question': 'Was geschieht bei der Festlegung von Strukturäquivalenz?', 'answer': 'Bei der Feststellung von Strukturäquivalenz werden die Definitionen der beteiligten Typen rekursiv expandiert, wobei Namen anderer Typen durch ihre Struktur ersetzt werden. Diese Strukturäquivalenz ermöglicht es, Typen zu vergleichen, indem ihre Strukturen miteinander verglichen werden.'},
     {'question': 'Was ermöglicht der parametrische Polymorphismus?', 'answer': 'Der parametrische Polymorphismus ermöglicht die Definition eines nicht parametrischen Typs als Subtyp eines parametrisierten Typs, wodurch die gewünschte Rekursion indirekt hergestellt werden kann.'},
     {'question': 'Wozu dient die Typisierung in den verschiedenen Phasen des Programmentwicklungsprozesses?', 'answer': 'In der Entwurfsphase hilft die Typisierung, die Struktur des Programms zu definieren, indem sie abstrakte Datentypen und Schnittstellen spezifiziert. In der Implementierungsphase wird sie verwendet, um die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. In der Testphase kann die Typisierung dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen.'},
     {'question': 'Wozu kann die Typisierung in der Implementierungsphase verwendet werden?', 'answer': 'In der Implementierungsphase kann die Typisierung dazu verwendet werden, die richtigen Methoden für die richtigen Objekte aufzurufen.'},
     {'question': 'Wozu kann die Typisierung in der Wartungsphase verwendet werden?', 'answer': 'In der Wartungsphase kann die Typisierung dazu verwendet werden, die Auswirkungen von Änderungen zu verstehen und zu kontrollieren.'}
     ]
]
KE4_questions = [
    [{'question': 'Was sind Iteratoren in Java?', 'answer': 'Iteratoren in Java sind Objekte, die eine einheitliche Iteration über verschiedene Collection-Klassen ermöglichen. Jede Collection-Klasse, die Iterator implementiert, bietet eine Methode iterator() an, die ein Iteratorobjekt zurückliefert.'},
     {'question': 'Was ist ein Methodenambiguitätsfehler?', 'answer': 'Ein Methodenambiguitätsfehler tritt auf, wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind. Dies bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist.'},
     {'question': 'Was ist das grundlegende Problem von C++?', 'answer': 'Das grundlegende Problem von C++ ist, dass es eine Erweiterung von C ist.'},
     {'question': 'Was sind die Eigenschaften der Klasse Object in Java?', 'answer': 'Die Klasse Object definiert die Eigenschaften, die allen Objekten, einschließlich Array-Objekten, gemeinsam sind. Hierbei handelt es sich um elf Methoden, darunter clone() zum Erzeugen von Kopien, equals(Object) zum Test auf Gleichheit anstelle von Identität, toString() zur Rückgabe einer String-Repräsentation des Objekts, getClass() zur Ermittlung des Klassentyps, hashCode() zur Speicherung von Objekten in Hash-Tabellen, und finalize() zur Freigabe von externen Ressourcen, die mit dem Objekt verbunden sind.'},
     {'question': 'Was sind die Auswirkungen davon, dass Interfaces in Java auch Subtypen von Object sind?', 'answer': 'Interfaces können nicht wie Klassen instanziiert werden, aber sie können als Typen für Variablen, Parameter und Rückgabewerte verwendet werden. Da Interfaces auch Subtypen von Object sind, können sie daher überall dort verwendet werden, wo ein Object erwartet wird.'},
     {'question': 'Was ist der Subtyp von jedem Typ in Java?', 'answer': 'In Java ist jeder Typ ein Subtyp von Object, was auch für Interfaces gilt.'},
     {'question': 'Welche Rolle spielen Interfaces in Java?', 'answer': 'Interfaces in Java spielen eine wichtige Rolle bei der Abstraktion und der Schaffung von Schnittstellen, die von mehreren Klassen implementiert werden können. Sie ermöglichen es, die Abhängigkeiten zwischen Klassen zu verringern und die Code-Wiederverwendung zu erhöhen. Interfaces können auch als Verträge zwischen Klassen betrachtet werden, die sicherstellen, dass eine Klasse eine bestimmte Funktionalität bereitstellt.'},
     {'question': 'Was ist ein Klient einer Instanz?', 'answer': 'Ein Klient von Instanz einer Klasse kann auf die Methoden und Variablen der Klasse zugreifen.'},
     {'question': 'Was sind Tagging oder Marker Interfaces in Java?', 'answer': 'Tagging oder Marker Interfaces in Java haben keine eigenen Methodendeklarationen, sondern dienen lediglich der Filterung von Variablenwerten. Sie können erzwingen, dass einer Variablen nur Instanzen solcher Klassen zugewiesen werden, die das Interface zu implementieren deklarieren. Die Implementierung des Interfaces für die Klasse ist zunächst ohne Konsequenzen, kann aber zur Übersetzungszeit vom Compiler und zur Laufzeit durch einen Typtest überprüft werden.'},
     {'question': 'Was ist das Interface-als-Typ-Konzept in Java?', 'answer': 'Javas Interface-als-Typ-Konzept ist ein Mechanismus, bei dem Interfaces als Typen verwendet werden können. Dies ermöglicht es, eine Schnittstelle einer Klasse unabhängig von ihrer Implementierung zu definieren und verschiedene Klassen können diese Schnittstelle implementieren. Das Interface-als-Typ-Konzept ist ein wichtiger Beitrag von Java zur objektorientierten Programmierung, wird aber in der Praxis nur langsam angenommen.'},
     {'question': 'Was ist der Java Community Process?', 'answer': 'Der Java Community Process ist ein Prozess, bei dem aktiven Entwicklern die Möglichkeit eingeräumt wird, Vorschläge zur Spracherweiterung von Java zu machen. Dabei ist jedoch auf Rückwärtskompatibilität zu achten, um die riesige Menge an Software, die in Java geschrieben ist, nicht zu beeinträchtigen.'},
     {'question': 'Was sind die grundlegenden Werkzeuge der Java-Programmierung?', 'answer': 'Die grundlegenden Werkzeuge der Java-Programmierung sind der Editor, der Java-Compiler Javac, die JVM, die Java-Klassenbibliothek (das sogenannte Application Programming Interface, API) und die Dokumentation (API-Dokumentation und Sprachdefinition).'},
     {'question': 'Was ist die Java Virtual Machine (JVM)?', 'answer': 'Die JVM ist eine virtuelle Maschine, die Bytecode-Anweisungen ausführt, die von einem Java-Compiler erzeugt wurden. Sie ermöglicht es, Java-Programme auf verschiedenen Geräten und Betriebssystemen auszuführen.'},
     {'question': 'Was ist die Funktion von Default-Methoden in Java?', 'answer': 'In Java 8 können Interfaces die Implementierung einer Methode vorgeben, die dann an implementierende Klassen (oder per "extends" abgeleitete Interfaces) vererbt wird. Dafür wurde das Schlüsselwort "default" eingeführt. Default-Methoden können allenfalls auf abstrakte Getter und Setter zugreifen, da Interfaces keine Instanzvariablen haben.'},
     {'question': 'Was ist ein Event (Ereignis) in C-Sharp?', 'answer': 'Ein Event (Ereignis) in C-Sharp ist ein Konstrukt, über das sog. Event handler aktiviert werden können. Die Handhabung von Ereignissen erfolgt über sog. Delegates. Leider ist die Syntax von C-Sharp, die mit Deklaration und Registrierung von Eventhandlern sowie der Verbreitung von Ereignissen verbunden ist, nach Ansicht des Autors dieses Textes komplett unleserlich geraten, so dass hier auf eine weitergehende Befassung mit dem Thema verzichtet wird.'},
     {'question': 'Welche Besonderheiten gibt es bei Zuweisungen von Pointervariablen in C++?', 'answer': 'Bei Zuweisungen von Pointervariablen muss man sich in C++ genau überlegen, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen möchte. C++ verwendet standardmäßig "Call by value" für Methodenaufrufe, was bedeutet, dass Kopien von Parametern übergeben werden.'},
     {'question': 'Was ist Generizität in C-Sharp?', 'answer': 'Generizität in C-Sharp ermöglicht es, parametrischen Polymorphismus sowohl für Klassen als auch für Methoden zu nutzen. Sie erlaubt die Definition von generischen Klassen und Interfaces, die eine Menge von Typen spezifizieren, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen.'},
     {'question': 'Welche Arten von Generizität werden in C-Sharp unterstützt?', 'answer': 'C-Sharp unterstützt sowohl beschränkte als auch unbeschränkte parametrische Polymorphismus für Klassen und Methoden. Dies bedeutet, dass Typparameter sowohl eingeschränkte (mit bestimmten Anforderungen) als auch unbeschränkte (ohne Anforderungen) Typen sein können.'},
     {'question': 'Welche Freiheit bietet der Präprozessor in C++?', 'answer': 'Der Präprozessor in C++ bietet die Freiheit, die Syntax der Sprache durch Hinzufügen einer neuen Syntax zu verändern. Dies ermöglicht es, Code in einer für Entwickler verständlicheren Weise zu schreiben, wenn gewünscht.'},
     {'question': 'Was sind explizite Interfaceimplementierungen in C-Sharp?', 'answer': 'Explizite Interfaceimplementierungen in C-Sharp ermöglichen es einer Klasse, die gleiche Methodendeklaration von verschiedenen Interfaces getrennt voneinander zu implementieren. Dies wird durch die Angabe des Interfacequalifikators vor der Methode erreicht.'},
     {'question': 'Welchen Nutzen haben explizite Interfaceimplementierungen in C-Sharp?', 'answer': 'Der Nutzen von expliziten Interfaceimplementierungen liegt darin, dass die Methode je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Dies ermöglicht es, verschiedene Verhaltensweisen für denselben Methodennamen in verschiedenen Kontexten zu definieren.'},
     {'question': 'Welche Arten von Vererbung erlaubt EIFFEL?', 'answer': 'EIFFEL erlaubt Mehrfachvererbung, was bedeutet, dass eine Klasse von mehreren anderen Klassen erben kann.'},
     {'question': 'Was ist die Just-in-time-(JIT-)Kompilierung in C-Sharp?', 'answer': 'In C-Sharp ist die Just-in-time-(JIT-)Kompilierung die Standardmethode zur Übersetzung des CIL-Codes in Maschinencode. Dieser Vorgang erfolgt unmittelbar vor der Ausführung und nur dann, wenn der Code tatsächlich ausgeführt wird. Im Gegensatz dazu verwendet Java normalerweise den Ahead-of-time-(AOT-)Kompilierungsansatz, bei dem der Bytecode vor der Ausführung in nativen Maschinencode übersetzt wird. Die JIT-Kompilierung in C-Sharp ermöglicht eine feinere Granularität, da sie bis auf die Ebene einzelner Methoden herabgeht.'},
     {'question': 'Wie werden in EIFFEL Vor- und Nachbedingungen für Methoden zu definiert?', 'answer': 'In EIFFEL werden die Schlüsselwörter "require" (vor der Implementierung der Methode) und "ensure" (nach der Implementierung der Methode) verwendet, um Vor- und Nachbedingungen für Methoden zu definieren.'},
     {'question': 'Was sind Klasseninvarianten in EIFFEL?', 'answer': 'Klasseninvarianten in EIFFEL sind Bedingungen, die zwischen zwei Methodenaufrufen in einer Klasse immer gelten müssen. Sie werden mit dem Schlüsselwort "invariant" deklariert und sind sozusagen eine Zusammenfassung von Vor- und Nachbedingungen, die für die Klasse als Ganzes gelten.'},
     {'question': 'Welche Rolle nimmt EIFFEL unter den Programmiersprachen ein?', 'answer': 'EIFFEL nimmt eine besondere Position unter den behandelten Sprachen ein, da es mehrere Funktionen erfüllt: Es dient als Sprache für objektorientierte Analyse und Design, für kommerzielle Programmierung und als akademische Lehrsprache.'},
     {'question': 'Welche Abweichungen gibt es in EIFFEL im Vergleich zu anderen Sprachen?', 'answer': 'Obwohl EIFFEL syntaktisch Ähnlichkeiten zu anderen Sprachen wie PASCAL aufweist, gibt es einige Abweichungen. Diese Abweichungen sind jedoch gut begründet und bieten eine alternative Perspektive auf vertraute Konzepte. Sie tragen dazu bei, klarere und orthogonalere Konzepte zu schaffen.'},
     {'question': 'Was ist das Common Type System (CTS) in C-Sharp?', 'answer': 'Das Common Type System (CTS) ist ein Teil des .NET-Frameworks und sorgt dafür, dass Typen, die in verschiedenen .NET-Sprachen definiert wurden, gemeinsam genutzt werden können. Es stellt sicher, dass Typen in einer einheitlichen Hierarchie organisiert sind und in verschiedenen .NET-Sprachen verwendet werden können, als wären sie in der jeweiligen Sprache selbst definiert worden. Dies erleichtert die Interoperabilität zwischen verschiedenen .NET-Sprachen und ermöglicht es, Bibliotheken und Komponenten in verschiedenen Sprachen zu verwenden.'},
     {'question': 'Welche Arten von Werttypen gibt es in C-Sharp?', 'answer': 'In C-Sharp gibt es verschiedene Arten von Werttypen, darunter die primitiven Typen (z. B. int, bool, double), Aufzählungstypen (enum) und vom Entwickler definierte Werttypen. Werttypen werden in C-Sharp mit dem Typkonstruktor "struct" erstellt und können Methoden und Konstruktoren haben, jedoch erlauben sie keine Typerweiterung oder Vererbung.'},
     {'question': 'Welche Arten von Referenztypen gibt es in C-Sharp?', 'answer': 'In C-Sharp gibt es verschiedene Arten von Referenztypen, darunter Klassen, Interfaces, Arrays, Delegates und Attribut-Typen. Diese Referenztypen ermöglichen eine größere Vielfalt an Programmierkonzepten und -strukturen in C-Sharp.'},
     {'question': 'Was sind Delegates in C-Sharp und wozu dienen sie?', 'answer': 'Delegates in C-Sharp sind Zeiger auf an ein Objekt gebundene einzelne Methoden. Sie ermöglichen es, Funktionen und Methoden als Parameter an andere Funktionen oder Methoden zu übergeben, was besonders nützlich für Problemstellungen wie Listener-Mechanismen ist. Delegates ersetzen die aus anderen Sprachen bekannten Funktionszeiger oder Funktionspointer.'},
     {'question': 'Was ist Runtime Type Information (RTTI) in C++?', 'answer': 'Runtime Type Information (RTTI) ist eine Funktion in C++, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. RTTI ermöglicht die Ermittlung des Typs eines Objekts zur Laufzeit.'},
     {'question': 'Welche Aufgaben können Zugriffsmethoden in EIFFEL erfüllen?', 'answer': 'Neben dem Lesen und Setzen von Instanzvariablen können Zugriffsmethoden in EIFFEL auch andere Aufgaben erfüllen, wie das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen.'},
     {'question': 'Was sind Features in EIFFEL?', 'answer': 'In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als "Features" bezeichnet. Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL.'},
     {'question': 'Was ist das Besondere an der Definition einer Schnittstelle in EIFFEL?', 'answer': 'Die Definition einer Schnittstelle in EIFFEL ist recht unspezifisch. Alle Klienten einer Klasse haben standardmäßig das gleiche Bild von ihr. Statt den Zugriff an Pakete oder Freunde zu binden, bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (exportieren).'},
     {'question': 'Welche Methode verwendet EIFFEL zur Speicherfreigabe?', 'answer': 'EIFFEL verwendet Garbage Collection zur Speicherfreigabe.'},
     {'question': 'Welche Gemeinsamkeiten gibt es zwischen C-Sharp und Java?', 'answer': 'C-Sharp und Java weisen in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen viele Gemeinsamkeiten auf. Die grundlegende Syntax und Struktur der beiden Sprachen sind ähnlich. In beiden Sprachen werden Klassen verwendet, um Objekte zu erstellen, Variablen und Ausdrücke zu definieren, Anweisungen auszuführen und Kontrollstrukturen zu steuern.'},
     {'question': 'Welche Besonderheit gibt es in C-Sharp in Bezug auf die Überladung von Operatoren?', 'answer': 'In C-Sharp ist es möglich, Operatoren wie +, -, == usw. zu überladen. Dies wird durch das Schlüsselwort "operator" ermöglicht, das in einer Operatordefinition vorangestellt wird. Die Überladung von Operatoren erfolgt ähnlich wie die Definition von Methoden, aber anstelle von Methodennamen werden die Operatorzeichen verwendet.'},
     {'question': 'Was sind "Call by reference" und "Call by value" in C-Sharp umgesetzt?', 'answer': 'In C-Sharp ermöglicht "Call by reference" (auch als "ref" und "out" bekannt) das Übergeben von Argumenten an Methoden, bei denen die Änderungen an den Parametern innerhalb der Methode auf die ursprünglichen Argumente außerhalb der Methode angewendet werden. Im Gegensatz dazu verwendet "Call by value" Kopien der Argumente, und Änderungen innerhalb der Methode haben keine Auswirkungen auf die ursprünglichen Argumente.'},
     {'question': 'Welche Bedeutung haben "verankerte Typen" im Kontext von kovarianten Redefinitionen in EIFFEL?', 'answer': '"Verankerte Typen" (engl. "anchored types") spielen im Kontext von kovarianten Redefinitionen in EIFFEL eine wichtige Rolle. Sie ermöglichen es, die Kovarianz bei der Redefinition von Methoden zu unterstützen und sind eine besondere Eigenschaft von EIFFEL.'},
     {'question': 'Was sind einige der Eigenschaften des Typsystems von EIFFEL?', 'answer': 'Einige der prominenten Eigenschaften des Typsystems von EIFFEL sind Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen sowie die Unterstützung kovarianter Redefinitionen durch "verankerte Typen".'},
     {'question': 'Welche Arten von Anweisungen gibt es in EIFFEL?', 'answer': 'In EIFFEL gibt es Anweisungen, die aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung bestehen.'},
     {'question': 'Welche Prinzipien der Programmierung werden von EIFFEL strikt eingehalten?', 'answer': 'EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat.'},
     {'question': 'Welche Besonderheit bietet das Exception Handling in EIFFEL?', 'answer': 'EIFFEL bietet ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet, insbesondere erlaubt es ein "Retry", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss.'},
     {'question': 'Welche Rolle spielt der Zuweisungsversuch bei kovarianten Redefinitionen in EIFFEL?', 'answer': 'Der Zuweisungsversuch spielt eine Rolle bei kovarianten Redefinitionen in EIFFEL, da er verwendet wird, um dynamische Bindungen programmatisch zu emulieren. Da EIFFEL polymorphe CAT-Calls verbietet, werden Zuweisungsversuche genutzt, um das dynamische Binden zu ermöglichen.'},
     {'question': 'Welche Probleme ergeben sich aus der Verwendung von kovarianten Redefinitionen in EIFFEL?', 'answer': 'Die Verwendung von kovarianten Redefinitionen in EIFFEL kann zu Problemen führen, insbesondere wenn dynamische Bindungen auftreten. Dies kann dazu führen, dass Typen inkonsistent werden und unerwartetes Verhalten auftritt.'},
     {'question': 'Welche Rolle spielen verankerte Typdeklarationen in EIFFEL?', 'answer': 'Verankerte Typdeklarationen in EIFFEL ermöglichen es, den Typ von Variablen automatisch an den Typ eines bereits typisierten Programms zu binden. Dies erleichtert die Verwendung von kovarianten Redefinitionen.'},
     {'question': 'Was ist das Ziel des Typsystems von C++?', 'answer': 'Das Ziel des Typsystems von C++ ist, objektorientierte Programmierung mit starker Typsicherheit zu ermöglichen, während gleichzeitig die volle Freiheit der Programmiererin erhalten bleibt und der Laufzeit-Overhead minimiert wird.'},
     {'question': 'Welche primitive Datentypen gibt es in C++?', 'answer': 'In C++ gibt es primitive Datentypen wie int, bool, etc. Diese Datentypen sind genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik.'},
     {'question': 'Welche Eigenschaften sollte eine typsichere Sprache haben?', 'answer': 'Eine typsichere Sprache wie C-Sharp soll strikte Typprüfungen durchführen, um sicherzustellen, dass Variablen nur Werte akzeptieren, die ihrem deklarierten Typ entsprechen.'},
     {'question': 'Was ist die Position von Bertrand Meyer zum Überladen von Methoden?', 'answer': 'Bertrand Meyer ist ein entschiedener Gegner des Überladens.'},
     {'question': 'Was ist die Reflection API in Java?', 'answer': 'Die Reflection API in Java ist eine Programmierschnittstelle, die es ermöglicht, auf die Elemente eines Programms zuzugreifen und diese zu untersuchen. Es enthält Klassen, die Instanzen entsprechender Programmelemente repräsentieren, wie zum Beispiel Methoden und Felder.'},
     {'question': 'Was sind Annotationen in Java?', 'answer': 'Annotationen in Java 5 sind eine spezielle Art von Interfaces, die nur Felder deklarieren und zur Zuordnung von Programmmetadaten zu Programmelementen im Quelltext dienen. Diese können während der Übersetzung und/oder Ausführung des Programms abgefragt und den jeweiligen Prozess beeinflussen oder sogar steuern.'},
     {'question': 'Was ist ein Modul in der Programmierung?', 'answer': 'Ein Modul ist eine Einheit von Programmelementen, die nur über die Schnittstelle des Moduls von außen zugänglich sind. Damit behält ein Modul einen Teil seiner Implementierung für sich und hütet ein Implementationsgeheimnis. Der Teil, den es nach außen trägt, gilt als öffentlich.'},
     {'question': 'Was sind die Funktionen von Klassen in Java?', 'answer': 'Klassen in Java haben drei Funktionen: Sie dienen als Vorlage für die Erzeugung von Objekten, sie liefern Typen für ein Programm und sie dienen der Modularisierung.'},
     {'question': 'Was sind Pakete in der Programmierung?', 'answer': 'Pakete sind in der Programmierung Sammlungen von Klassen und dienen gleichzeitig als Namensräume für sie. Sie haben eine hierarchische Organisation, aber diese hat keine Bedeutung. Pakete erlauben keinen privilegierten Zugriff auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen können, bedarf es expliziter Import-Deklarationen unter Nennung der jeweiligen Paketnamen.'},
     {'question': 'Was ist Sichtbarkeit in Java?', 'answer': 'In Java bezieht sich Sichtbarkeit auf lexikalische Scopes und wird durch Hiding, Shadowing und Obscuring eingeschränkt. Sie kann bisweilen über Qualifizierer wiederhergestellt werden.'},
     {'question': 'Was sind Array-Initialisierer in Java?', 'answer': 'Array-Initialisierer in Java sind eine Möglichkeit, Arrays mit Werten zu initialisieren. Sie werden verwendet, um die Elemente eines Arrays bei der Erstellung des Arrays zu initialisieren. Die Elemente werden in geschweiften Klammern ({}) aufgelistet, getrennt durch Kommas. Zum Beispiel: int[] arr = {1, 2, 3}; erstellt ein Array von ganzen Zahlen mit den Werten 1, 2 und 3.'},
     {'question': 'Was ist ein Klassenliteral in Java?', 'answer': 'Ein Klassenliteral in Java ist eine Notation, die aus dem Namen der Klasse, gefolgt von ".class" besteht, und mit der man Klassen als Werte angeben kann.'},
     {'question': 'Was ist das Typsystem von Java?', 'answer': 'Das Typsystem von Java hat eine starke statische Komponente, bei der jedoch nicht alle Typprüfungen zur Übersetzungszeit durchgeführt werden können. Für manche Typumwandlungen sind dynamische Typprüfungen notwendig.'},
     {'question': 'Was sind Wildcards in Java?', 'answer': 'Wildcards in Java sind eine Möglichkeit, dynamische Typprüfungen bei Arrays zu vermeiden. Sie ermöglichen es, Arrays mit unterschiedlichen Typen zu verwenden, ohne dass statische Typprüfungen zur Übersetzungszeit erforderlich sind.'},
     {'question': 'Was ist eine öffentliche Schnittstelle in Java?', 'answer': 'In Java ist eine öffentliche Schnittstelle eine eigenständige Deklaration, die von der Klasse unabhängig ist und einen Typ definiert. Sie wird mit Hilfe des Schlüsselwortes "interface" deklariert und enthält eine Menge von Instanzvariablen und -methoden, die public deklariert sind.'},
     {'question': 'Was sind Interfaces in Java?', 'answer': 'Interfaces in Java definieren Typen und können daher in Variablendeklarationen verwendet werden. Der Type checker garantiert, dass auf der Variablen mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ.'},
     {'question': 'Was ist Interfacevererbung in Java?', 'answer': 'Interfacevererbung in Java bedeutet, dass eine Klasse mehrere Interfaces gleichzeitig implementieren kann. Dabei wird nichts vererbt, sondern es handelt sich um eine Art Mehrfach-Subtyping.'},
     {'question': 'Was ist Typkonformität in Java?', 'answer': 'In Java ist die Typkonformität und damit die Zuweisungskompatibilität unter Referenztypen an Subtyping gebunden. Damit Ausdrücke von einem Typ Variablen eines anderen zugeordnet werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen den beiden bestehen. Java setzt auf nominale Typkonformität, das heißt, dass Subtypen ihre Supertypen namentlich kennen müssen.'},
     {'question': 'Was ist nominale Typkonformität in Java?', 'answer': 'In Java ist nominale Typkonformität eine Art von Typkonformität, bei der die Typen entweder identisch sein müssen oder eine Subtypbeziehung zwischen den beiden bestehen muss, die explizit deklariert werden muss. Das bedeutet, dass Subtypen ihre Supertypen namentlich kennen müssen.'},
     {'question': 'Was ist Kovarianz in Java?', 'answer': 'In Java ist Kovarianz eine Regel im Subtyping, die vorschreibt, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen. Dadurch wird eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt.'},
     {'question': 'Was bedeutet es, dass Java ein strenges Typsystem hat?', 'answer': 'Ein strenges Typsystem in Java bedeutet, dass alle Typfehler während der Übersetzung durch den Compiler oder während der Laufzeit erkannt werden, insbesondere bei einer Wertzuweisung, bei der eine Typinvariante verletzt wird.'},
     {'question': 'Was sind Konstruktoren in Java?', 'answer': 'Konstruktoren sind spezielle Methoden in Java, die verwendet werden, um Objekte zu erzeugen, die keine literale Repräsentation haben. Sie sind keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können.'},
     {'question': 'Was sind Factory-Methoden in Java?', 'answer': 'Factory-Methoden sind Klassenmethoden in Java, die zur Objekterzeugung verwendet werden können. Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben.'},
     {'question': 'Was ist Exception Handling in Java?', 'answer': 'Exception Handling in Java ist eine Möglichkeit, bei der Spezifikation des Kontrollflusses eines Programms zunächst mögliche Ausnahmesituationen und deren Behandlung unberücksichtigt zu lassen und so zu tun, als würde immer alles gutgehen. Es erlaubt sowohl der Autorin als auch dem Leser eines Programms, sich auf die Hauptfunktion zu konzentrieren, mit dem Motto "Zu den Ausnahmen kommen wir später!".'},
     {'question': 'Was ist eine Exception in Java?', 'answer': 'In Java sind Exceptions Instanzen von Klassen, die jeweils eine konkrete Ausnahmesituation während des Programmablaufs repräsentieren. Wenn eine Exception geworfen wird, wird der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist.'},
     {'question': 'Was ist der Zweck der Throws-Klausel in Java?', 'answer': 'Die Throws-Klausel in Java wird verwendet, um eine Methode zu deklarieren, dass sie eine bestimmte Exception wirft, ohne sie selbst abzufangen. Dies muss geschehen, wenn die Methode eine Exception wirft und kein passender Catch-Block vorhanden ist.'},
     {'question': 'Was ist der Zugriffsschutz in Java?', 'answer': 'In Java wird der Zugriffsschutz durch die Zugriffskontrollmodifikatoren private, protected und public realisiert. Diese Modifikatoren bestimmen, welche Klassen auf die Elemente einer anderen Klasse zugreifen können. Standardmäßig ist alles, was nicht explizit als privat, geschützt oder öffentlich deklariert ist, in Java package-private, d.h. nur innerhalb des Pakets sichtbar.'},
     {'question': 'Was ist der privilegierte Zugriff in Java?', 'answer': 'In Java wird der privilegierte Zugriff durch die Zugriffskontrollmodifikatoren private, protected und public realisiert. Diese Modifikatoren bestimmen, welche Klassen auf die Elemente einer anderen Klasse zugreifen können. Klassen, die sich im selben Paket befinden, können auf package-private Elemente zugreifen, und Klassen, die eine Klasse erweitern, können auf protected Elemente zugreifen. Somit gewähren sich die Klassen eines Programms untereinander privilegierten Zugriff.'},
     {'question': 'Was ist die private Schnittstelle eines Moduls?', 'answer': 'Die private Schnittstelle eines Moduls besteht aus allen Deklarationen, die nicht Teil der öffentlichen Schnittstelle sind.'},
     {'question': 'Was ist die öffentliche Schnittstelle eines Moduls?', 'answer': 'Die öffentliche Schnittstelle eines Moduls besteht aus allen Deklarationen, die mit einem Schlüsselwort als öffentlich gekennzeichnet sind.'},
     {'question': 'Was ist die Open Services Gateway Initiative (OSGi)?', 'answer': 'Die Open Services Gateway Initiative (OSGi) ist ein Standard, der die Zusammenfassung von Java-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation erlaubt. Dieser Standard ist unter anderem die Grundlage von Eclipse, das nicht nur eine Java-IDE, sondern im Kern ein Framework für die Entwicklung beliebig komplexer Java-Programme (sog. Rich Clients) ist.'},
     {'question': 'Was ist ein Modul in Java?', 'answer': 'Ein Modul in Java 9 ist eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Eine Moduldeklaration besteht aus einem (eindeutigen) Namen des Moduls, einer Deklaration der angebotenen Schnittstelle und einer Deklaration der benötigten Schnittstelle. Neben den allgemeinen Export tritt der sog. qualifizierte Export, der den Austausch zwischen bestimmten Modulen erlaubt.'},
     {'question': 'Was sind Streams in Java?', 'answer': 'Streams in Java 8 sind ein neues Konstrukt, das eine Datenverarbeitung in Pipelines ermöglicht. Sie sind interne Iteratoren, die eine potenziell unendliche Folge von Elementen halten. Streams können entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren als Quelle dienen. Ein Ergebnis liefert eine Stream-Pipeline immer durch einen Abschluss, also eine Methode, die ein anderes Ergebnis als einen Stream liefert.'},
     {'question': 'Was ist das Überschreiben von Methoden in Java?', 'answer': 'Das Überschreiben von Methoden in Java bedeutet, dass eine bereits vorhandene Methode in einer Subklasse mit derselben Signatur (Methodenname und formale Parametertypen) neu definiert wird. Die Bedingungen dafür sind, dass die Methode denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode hat und dass die deklarierten Parametertypen der Methode Subtypen der deklarierten Parametertypen der Methode in der Superklasse sind.'},
     {'question': 'Was ist das Überladen von Methoden in Java?', 'answer': 'Das Überladen von Methoden in Java bedeutet, dass Methoden denselben Namen haben, aber verschiedene Parametertypen in derselben Klasse oder einer Subklasse haben. Der Unterschied zum Überschreiben besteht darin, dass beim Überladen neue Methoden hinzugefügt werden, während beim Überschreiben bereits vorhandene Methoden neu definiert werden.'},
     {'question': 'Was ist dynamisches Binden in Java, und wie funktioniert der Bindungsalgorithmus?', 'answer': 'Das dynamische Binden in Java bezieht sich auf die Auswahl der Methode zur Laufzeit, basierend auf dem tatsächlichen Typ des Empfängerobjekts. Der Bindungsalgorithmus in Java wählt die Methode aus, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode, ist in der Klasse des deklarierten Typs des Ausdrucks deklariert und deren deklarierte Parametertypen sind Subtypen der deklarierten Parametertypen der aufgerufenen Methode. Wenn mehrere Methoden die Bedingungen erfüllen, wird diejenige ausgewählt, deren Klasse am nächsten zur Klasse des Empfängerobjekts in der Superklassenkette ist.'},
     {'question': 'Welche Rolle spielen Interfaces bei der Einschränkung des Zugriffs auf Methoden in Java?', 'answer': 'Interfaces können dazu verwendet werden, den Zugriff auf Methoden zu beschränken, da nur die im Interface definierten Methoden aufgerufen werden können. Dies ermöglicht es, verschiedene Sichten auf ein Objekt zu gewähren und den Zugriff auf bestimmte Methoden zu kontrollieren.'},
     {'question': 'Welche Rolle spielt die Java Virtual Machine (JVM) in Java-Programmen?', 'answer': 'Die Java Virtual Machine (JVM) interpretiert den Bytecode, der das Ergebnis der Übersetzung von Java-Programmen ist. Sie spielt eine entscheidende Rolle bei der Ausführung von Java-Programmen.'},
     {'question': 'Was sind Annotationen in Java und welche Rolle spielen sie in der Metaprogrammierung?', 'answer': 'Annotationen in Java sind eine Form der Metaprogrammierung, bei der Programmmetadaten den Programmelementen im Quelltext zugeordnet werden. Diese Metadaten können während der Übersetzung und/oder während der Ausführung des Programms abgefragt werden und den jeweiligen Prozess beeinflussen oder steuern. In Java 5 wurden Annotationen als eine spezielle Art von Interfaces eingeführt, die jedoch keine Methoden, sondern nur Felder deklarieren. Annotationen werden häufig verwendet, um zusätzliche Informationen oder Konfigurationen zu einem Programm hinzuzufügen.'},
     {'question': 'Welche Trennung gibt es in Java zwischen Operationen und Methoden?', 'answer': 'In Java gibt es eine Trennung zwischen Operationen, die auf primitiven Typen fest vorgegeben sind, und Methoden, die in Klassen definiert werden müssen.'},
     {'question': 'Welcher Operator steht speziell für Referenztypen in Java zur Verfügung?', 'answer': 'Ein Operator, der speziell für Referenztypen in Java zur Verfügung steht, ist der Typtest "instanceof". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist.'},
     {'question': 'Welche Funktionen haben Klassen in Java?', 'answer': 'Klassen in Java dienen als Vorlagen für die Erzeugung von Objekten, liefern Typen für ein Programm und dienen der Modularisierung.'},
     {'question': 'Was sind Zugriffsmodifikatoren in Java?', 'answer': 'Zugriffsmodifikatoren (access modifiers) sind in Java Schlüsselwörter wie private, protected, public und "Package local," die die Zugriffsbeschränkungen für Klassen, Typen und deren Elemente festlegen. Sie regeln, welche Teile einer Klasse von anderen Klassen aus zugänglich sind.'},
     {'question': 'Welche Auswirkungen haben die Zugriffsbeschränkungen in Java?', 'answer': 'Die Zugriffsbeschränkungen in Java regeln, welche Teile einer Klasse oder eines Typs von anderen Klassen oder Typen aus zugänglich sind. Sie beeinflussen die Sichtbarkeit von Variablen, Methoden und anderen Elementen innerhalb einer Klasse und zwischen Klassen, insbesondere in verschiedenen Paketen.'},
     {'question': 'Was sind die konkreten Auswirkungen der Zugriffsbeschränkungen in Java?', 'answer': 'Die Zugriffsbeschränkungen in Java wirken sich auf die Sichtbarkeit von Elementen innerhalb von Klassen und zwischen Klassen aus. Sie regeln, welche Teile eines Moduls von anderen Modulen aus sichtbar sind und können durch Hiding, Shadowing und Obscuring weiter eingeschränkt werden. Die Verknüpfung von Typ und Zugriffsbeschränkung ist in Java etabliert und ermöglicht die Deklaration von Typen und Schnittstellen in einem.'},
     {'question': 'Welche Arten von Literale gibt es in Java?', 'answer': 'In Java gibt es Literale für Zahlen, Zeichen und Strings.'},
     {'question': 'Welche Art von Typprüfungen kann Java zur Übersetzungszeit durchführen?', 'answer': 'Java kann zur Übersetzungszeit statische Typprüfungen durchführen.'},
     {'question': 'Welche Typprüfungen müssen in Java dynamisch durchgeführt werden?', 'answer': 'Gelegentliche Typprüfungen, die dynamische Typprüfungen in Java erfordern, sind insbesondere Typumwandlungen (Type casts).'},
     {'question': 'Welche Anforderung stellt Java an geerbte Variablen?', 'answer': 'Java verlangt, dass die Typen geerbter Variablen nicht verändert werden dürfen. Dies wird als Kovarianz bezeichnet.'},
     {'question': 'Was sind Checked Exceptions in Java?', 'answer': 'Checked Exceptions sind Ausnahmesituationen, bei denen die Programmierer sich der möglichen Ausnahmesituationen bewusst sein müssen. Sie erfordern eine Deklaration im Methodenkopf oder müssen innerhalb der Methode behandelt werden. Diese Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind.'},
     {'question': 'Was sind Unchecked Exceptions in Java?', 'answer': 'Unchecked Exceptions sind Ausnahmesituationen, die in der Praxis überall auftreten können. Sie erfordern keine explizite Deklaration im Methodenkopf und können überall auftreten. Unchecked Exceptions werden von Exception-Klassen abgeleitet, die von RuntimeException abgeleitet sind.'},
     {'question': 'Was ist der qualifizierte Export in der Moduldefinition von Java?', 'answer': 'Der qualifizierte Export in der Moduldefinition von Java ist ähnlich wie in EIFFEL. Er nennt die Module, an die exportiert wird, namentlich und erlaubt einen "privaten" Austausch zwischen bestimmten Modulen, die somit ihre eigenen, privaten Schnittstellen haben.'},
     {'question': 'Was ist das Besondere an der Moduldefinition von Java?', 'answer': 'Die Moduldefinition von Java erzwingt die Einhaltung der Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit. Sie kontrolliert auch den reflektiven Zugriff auf Programmelemente, was zu einer erheblichen Verbesserung der Sicherheit von Java-Programmen führt.'},
     {'question': 'Was ist die Hauptanwendung generischer Typen in Java?', 'answer': 'Eine Hauptanwendung generischer Typen in Java ist die Arbeit mit Collections, um den Typ der Elemente in der Collection anzugeben und so die Typsicherheit zu erhöhen.'},
     {'question': 'Was ist rekursiv beschränkter parametrischer Polymorphismus in Java?', 'answer': 'Rekursiv beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Möglichkeit, Beschränkungen für Typparameter auf eine Weise zu definieren, die auf sich selbst oder andere Typparameter verweist.'},
     {'question': 'Welche Art von Subtyping wird bei "extends" beschränkten Wildcard-Typen verwendet?', 'answer': '"extends" beschränkte Wildcard-Typen verwenden kovariantes Subtyping.'},
     {'question': 'Welche Art von Subtyping wird bei "super" beschränkten Wildcard-Typen verwendet?', 'answer': '"super" beschränkte Wildcard-Typen verwenden kontravariantes Subtyping.'},
     {'question': 'Was sind Instanzvariablen in Java?', 'answer': 'Instanzvariablen in Java sind Felder, die zur Speicherung von Daten in einer Klasse verwendet werden. Jede Instanz der Klasse hat ihre eigenen Kopien dieser Variablen.'},
     {'question': 'Was sind Instanzmethoden in Java?', 'answer': 'Instanzmethoden in Java sind Methoden, die auf Instanzen (Objekten) einer Klasse angewendet werden können. Sie definieren das Verhalten der Klasse.'},
     {'question': 'Was sind "Member" in Bezug auf Klassendefinitionen in Java?', 'answer': '"Member" ist ein zusammenfassender Begriff für Felder und Methoden innerhalb einer Klassendefinition in Java.'},
     {'question': 'Welche weiteren Arten von Klassendefinitionen sind in Java möglich?', 'answer': 'In Java können Sie auch geschachtelte Klassendefinitionen und innere Klassendefinitionen erstellen, die ebenfalls als Members der umschließenden Klasse gelten.'},
     {'question': 'Welche Arten von Ausdrücken gibt es in Java?', 'answer': 'In Java gibt es verschiedene Arten von Ausdrücken, darunter Literale, Variablen, Methodenaufrufe, Operatoranwendungen, Feldzugriffe, Klasseninstanziierungen, Array-Instanziierungen, Konditionalausdrücke, Cast-Ausdrücke und Lambda-Ausdrücke.'},
     {'question': 'Welche Typisierungsanforderungen gelten für Ausdrücke in Java?', 'answer': 'In Java müssen alle Ausdrücke korrekt typisiert sein. Das bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks übereinstimmen muss, an der Stelle, an der er eingesetzt wird.'},
     {'question': 'Welche Arten von Typumwandlungen gibt es in Java?', 'answer': 'In Java gibt es drei Arten von Typumwandlungen: Up casts, Down casts und Cross casts.'},
     {'question': 'Was ist die Besonderheit von Javas Interfaces?', 'answer': 'Javas Interfaces sind eigenständige Konstrukte, die über die ursprüngliche Bedeutung hinausgehen und weitreichende Möglichkeiten zur Definition von Schnittstellen und zur Entwicklung objektorientierter Programmiersprachen bieten.'},
     {'question': 'Welche Arten von Abhängigkeiten können zwischen Klassen und Paketen in Java entstehen?', 'answer': 'In Java können Vererbungsabhängigkeiten zwischen Klassen auftreten, die nicht zirkulär sind. Bei der Ausdehnung der Abhängigkeiten auf Pakete können jedoch auch zirkuläre Abhängigkeiten zwischen Paketen entstehen.'},
     {'question': 'Welche Arten von Anweisungen gibt es in Java?', 'answer': 'In Java gibt es verschiedene Arten von Anweisungen, darunter Variablendeklarationen, Wertzuweisungen, Methodenaufrufe, Klasseninstanziierungen und Kontrollstrukturen wie If-Anweisungen, Schleifen, Switch-Anweisungen, Try-Anweisungen und mehr.'},
     {'question': 'Welche Semantik haben Variablen in Java?', 'answer': 'Variablen in Java haben entweder Referenzsemantik oder Wertsemantik, je nach ihrem Typ. Primitive Typen wie byte, short, int, usw., haben Wertsemantik. Andere Typen haben Referenzsemantik.'},
     {'question': 'Welche Vorsichtsmaßnahmen müssen bei "Auto boxing" und "Auto unboxing" in Java getroffen werden?', 'answer': 'Bei "Auto boxing" und "Auto unboxing" in Java ist Vorsicht geboten, da unerwartete Ergebnisse auftreten können. Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte, um Programmierfehler zu vermeiden.'},
     {'question': 'Was ist beschränkter parametrischer Polymorphismus in Java?', 'answer': 'Beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Einschränkung der möglichen Typen, die für einen Typparameter einer generischen Klasse verwendet werden können. Dies geschieht durch das Festlegen von Beschränkungen oder Bedingungen für den Typparameter.'},
     {'question': 'Welche Einschränkungen gelten für generische Variablen mit Typ-Wildcards?', 'answer': 'Generische Variablen mit Typ-Wildcards unterliegen Einschränkungen, insbesondere in Bezug auf die Verwendung von Wildcards mit oberen und unteren Schranken.'},
     {'question': 'Was sind Threads in Java und wie unterscheiden sie sich von Prozessen?', 'answer': 'Threads in Java sind parallele Ausführungsstränge, während Prozesse in der Regel eigenständige Programme mit separater Ressourcenallokation sind. Threads sind leichtgewichtiger und teilen sich Ressourcen innerhalb eines Prozesses. Bei Threads müssen die Synchronisationsmechanismen selbst implementiert werden, während Prozesse in Betriebssystemen über die Inter-Prozess-Kommunikation reguliert werden.'},
     {'question': 'Was ist ein Monitor in Bezug auf Threads in Java?', 'answer': 'Ein Monitor in Bezug auf Threads in Java ist ein Mechanismus, der dazu dient, die Synchronisation von Threads zu ermöglichen. Jedes Objekt in Java ist mit einem Monitor verknüpft. Wenn ein Thread einen Monitor eines Objekts sperrt ("lockt"), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.'},
     {'question': 'Welche Besonderheiten gibt es bei mehrdimensionalen Arrays in Java?', 'answer': 'In Java können mehrdimensionale Arrays geschachtelt werden, wobei die Größen der Dimensionen nicht für jedes Element der ersten Dimension gleich sein müssen.'},
     {'question': 'Was ist der Supertyp aller Referenztypen in Java?', 'answer': 'Object ist der Supertyp aller Referenztypen in Java.'},
     {'question': 'Was ist ein klassischer Anwendungsfall von generischen Typen?', 'answer': 'Die klassische Anwendung generischer Typen findet man bei Collections. Genauso, wie man in Java Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt Java über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die Java-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition Javas, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen.'},
     {'question': 'Was ist eine Besonderheit von EIFFEL in Bezug auf Zusicherungen?', 'answer': 'In EIFFEL sind Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen integriert. Das bedeutet, dass es für Zusicherungen vorgesehene Orte gibt und sie nicht ganz im Ermessen der Programmiererin liegen.'},
     {'question': 'Was ist die Funktion von "require" und "ensure" in EIFFEL?', 'answer': '"Require" und "ensure" sind Schlüsselwörter in EIFFEL, die Boolesche Ausdrücke folgen. "Require"-Klauseln sollten erfüllt sein, damit die Methode korrekt funktioniert, während "Ensure"-Klauseln garantieren, dass die Methode bestimmte Bedingungen erfüllt. Beide Klauseln dürfen nebenwirkungsfreie Abfragen der Klasse verwenden.'},
     {'question': 'Was ist der Zusammenhang zwischen Zusicherungen und Methoden in EIFFEL?', 'answer': 'In EIFFEL werden Zusicherungen wie Vor- und Nachbedingungen von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen auch die Zusicherungen angepasst werden, allerdings gilt hierbei, dass die Vorbedingung nur abgeschwächt und die Nachbedingung nur verschärft werden darf. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.'},
     {'question': 'Was ist die Sprache EIFFEL?', 'answer': 'EIFFEL ist eine Sprache, die für objektorientierte Analyse und Design, kommerzielle Programmierung und akademische Lehre verwendet wird.'},
     {'question': 'Was ist die Sonderstellung von EIFFEL unter den hier behandelten Sprachen?', 'answer': 'EIFFEL ist eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache.'},
     {'question': 'Was ist die Besonderheit von EIFFEL?', 'answer': 'Die Besonderheit von EIFFEL ist die Integration von Zusicherungen, die als Verträge zwischen dienstanbietenden und dienstnehmenden Klassen interpretiert werden können. Diese erlauben, das "Was" einer Software zumindest teilweise unabhängig vom "Wie" zu spezifizieren. EIFFEL erlaubt darüber hinaus, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können.'},
     {'question': 'Was ist eine Typhierarchie in C-Sharp?', 'answer': 'In C-Sharp ist eine Typhierarchie eine Vererbungshierarchie, die die Beziehungen zwischen den verschiedenen Datentypen definiert. Alle Typen, einschließlich primitiver Typen, gelten als von Object (genauer: System.Object) abgeleitet. Diese Hierarchie ermöglicht es, Objekte verschiedener Typen zu behandeln, als ob sie vom gleichen Typ wären, was Polymorphie ermöglicht.'},
     {'question': 'Was sind Attribute in C-Sharp?', 'answer': 'Attribute in C-Sharp sind eine Möglichkeit, zusätzliche Informationen zu einem Programmelement hinzuzufügen. Sie sind ähnlich wie Annotationen in Java und haben nichts unmittelbar mit objektorientierter Programmierung zu tun.'},
     {'question': 'Was ist eine Klassenhierarchie in C-Sharp?', 'answer': 'Eine Klassenhierarchie in C-Sharp ist eine Vererbungshierarchie, die die verschiedenen Arten von Typen in C-Sharp einteilt. Sie ist wesentlich komplexer und vereinheitlicht das Typsystem von C-Sharp, indem alle Typen von System.Object abgeleitet sind.'},
     {'question': 'Was ist eine Einteilung der verschiedenen Arten von Typen in C-Sharp?', 'answer': 'Die Einteilung der verschiedenen Arten von Typen in C-Sharp ist eine Einteilung, die die verschiedenen Arten von Typen in C-Sharp in ValueType, Delegate und class einteilt.'},
     {'question': 'Was ist ein Wertetyp in C-Sharp?', 'answer': 'Ein Wertetyp ist ein Typ, der von System.ValueType abgeleitet'},
     {'question': 'Was ist Auto-Boxing und Unboxing in C-Sharp?', 'answer': 'Auto-Boxing ist eine automatische Konvertierung eines Werttyps in einen Referenztyp, während Unboxing die umgekehrte Konvertierung ist. Diese Funktionen ermöglichen es, Werttypen als Subtypen eines Referenztyps (nämlich Object) zu deklarieren.'},
     {'question': 'Was sind Aufzählungstypen in Java?', 'answer': 'Aufzählungstypen in Java sind mit Java 1.5 hinzugekommen und stellen eine Unterart der Klassentypen dar. Sie werden mit dem Schlüsselwort enum definiert und können Elemente, Felder und Methoden enthalten. Die Elemente einer Aufzählung werden zu Konstanten, also zu lebenslang gültigen Namen für Objekte einer Klasse, die den Aufzählungstyp repräsentiert.'},
     {'question': 'Was sind Typ-Wildcards in Java?', 'answer': 'Typ-Wildcards, auch als Typ-Joker oder Platzhalter bezeichnet, sind ein Konzept in Java, das eingeführt wurde, um das Problem der Instanziierung eines generischen Typs mit einem beliebigen Typ zu lösen. Sie können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: "List<?>" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ "List<?>" ein Supertyp aller Instanziierungen von "List<T>" - beispielsweise sind "List<Integer>" und "List<String>" mit "List<?>" zuweisungskompatibel.'},
     {'question': 'Was sind Wildcard-Typen in Java?', 'answer': 'Wildcard-Typen wie "List<?>" und "ArrayList<?>" sind abstrakt und haben keine direkten Instanzen. Das Fragezeichen selbst ist kein Typ oder eine Typvariable.'},
     {'question': 'Was sind per extends beschränkte Typ-Wildcards?', 'answer': 'Per extends beschränkte Typ-Wildcards erlauben eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird.'},
     {'question': 'Was ist umgekehrtes Subtyping?', 'answer': 'Umgekehrtes Subtyping ist eine Art des Subtypings, bei der nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.'},
     {'question': 'Was sind Zugriffsmethoden in Eiffel?', 'answer': 'Zugriffsmethoden in Eiffel sind Methoden, die vom System automatisch bereitgestellt werden, um auf Instanzvariablen zuzugreifen. Sie nehmen syntaktisch die Form von Variablen an, ermöglichen aber dennoch die Datenkapselung.'},
     {'question': 'Was ist eine Setter-Funktion?', 'answer': 'Eine Setter-Funktion ist eine Funktion, die mit einem Parameter aufgerufen wird und üblicherweise einen Wert setzt.'},
     {'question': 'Was ist eine Getter-Funktion?', 'answer': 'Eine Getter-Funktion ist eine Funktion, die einen Wert zurückgibt und üblicherweise mit einer Zuweisung an eine Variable verwendet wird.'},
     {'question': 'Was sind Setter und Getter?', 'answer': 'Setter und Getter sind Funktionen, die den Zustand eines Objekts ändern oder abfragen. Ein Setter wird mit einem Parameter aufgerufen, um den Zustand des Objekts zu ändern, während ein Getter aufgerufen wird, um einen Wert zurückzugeben, der mit dem Zustand des Objekts kompatibel ist.'},
     {'question': 'Was sind die einzigen Elemente einer Klassendefinition in EIFFEL?', 'answer': 'In EIFFEL sind Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet und die einzigen Elemente einer Klassendefinition.'},
     {'question': 'Was ist Mehrfachvererbung?', 'answer': 'Mehrfachvererbung ist eine Konstruktion in der objektorientierten Programmierung, bei der eine Klasse von mehreren anderen Klassen erben kann. Sie wird häufig von Programmiererinnen gewünscht, bringt aber praktische Probleme mit sich, wie zum Beispiel die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements erbt.'},
     {'question': 'Welche Probleme bringt Mehrfachvererbung mit sich?', 'answer': 'Mehrfachvererbung bringt einige praktische Probleme mit sich, wie zum Beispiel die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements (Feld oder Methode) erbt. Darüber hinaus führt die Mehrfachvererbung noch zu zahlreichen weiteren Problemen, wie zum Beispiel das unerwartete Verhalten im Zusammenhang mit dynamischem Binden und offener Rekursion.'},
     {'question': 'Was ist Operatorüberladung in C-Sharp?', 'answer': 'In C-Sharp ist es möglich, Operatoren wie +, -, ==, new, ( ), ||, &&, = etc. zu überladen. Dies wird durch das Schlüsselwort "operator" in einer Operatordefinition erreicht, die der Definition einer Methode ähnelt.'},
     {'question': 'Was sind generische Typen in Java?', 'answer': 'Generische Typen in Java sind eine Abstraktion von Typen, bei der die Referenzierung eines oder mehrerer Typen innerhalb einer Typdefinition durch Typvariablen ersetzt wird. Diese Typvariablen stehen in Java jedoch nicht in eckigen, sondern in spitzen Klammern.'},
     {'question': 'Was ist ein Indexer in C-Sharp?', 'answer': 'Ein Indexer in C-Sharp ist eine spezielle Art von Methode, die es ermöglicht, auf Instanzvariablen eines Objekts über einen Index zuzugreifen. Der Indexer kann überladen werden, um mehrere indizierte Instanzvariablen zu simulieren, wobei der Elementtyp (der Rückgabetyp beim Überladen) gleich bleiben muss. Der Zugriff auf den Indexer erfolgt aufgrund des fehlenden Namens einzig über den Typ des Indexes. Der Inhalt des Indexers muss nicht zwangsläufig auf eine interne Instanzvariable zugreifen, sondern kann auch berechnet werden.'},
     {'question': 'Was sind Instanzvariablen und Instanzmethoden in Java?', 'answer': 'Instanzvariablen und Instanzmethoden sind Bestandteile einer Klassendefinition in Java. Sie werden zusammenfassend auch als "Member" bezeichnet. Instanzvariablen, auch Felder genannt, sind Variablen, die zu einer Instanz einer Klasse gehören. Instanzmethoden sind Methoden, die auf eine Instanz einer Klasse angewendet werden können.'},
     {'question': 'Was ist der Begriff "Member" in Java?', 'answer': 'Der Begriff "Member" in Java bezieht sich auf die Klassendefinition und umfasst Instanzvariablen und Instanzmethoden.'},
     {'question': 'Was sind innere Klassen in Java?', 'answer': 'Innere Klassen in Java sind Klassendefinitionen, die innerhalb einer anderen Klasse definiert werden. Sie sind vor allem sinnvoll, wenn die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Instanzen innerer Klassen liegen "innerhalb" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt "Outer this" auf diese zugreifen.'},
     {'question': 'Was sind die verschiedenen Arten von Ausdrücken in Java?', 'answer': 'In Java gibt es Literale, Variablen, Operatoranwendungen, Feldzugriffe, Methodenaufrufe, Array-Zugriffe, Klasseninstanziierungen, Array-Instanziierungen, Konditionalausdrücke, Cast-Ausdrücke, Lambda-Ausdrücke.'},
     {'question': 'Was ist ein Methodenausdruck in Java?', 'answer': 'Ein Methodenausdruck in Java beinhaltet einen Ausdruck für den Empfänger sowie möglicherweise weitere Ausdrücke für die Parameter des Methodenaufrufs.'},
     {'question': 'Was sind Lambda-Ausdrücke in Java?', 'answer': 'Lambda-Ausdrücke in Java sind eine Möglichkeit, Funktionen zu definieren, die mit Version 8 eingeführt wurden. Sie ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Die Funktionen, die Lambda-Ausdrücke darstellen, erhalten über das Interface einen Namen.'},
     {'question': 'Was ist das Typsystem in EIFFEL?', 'answer': 'Das Typsystem in EIFFEL ist ein einheitliches Typsystem, das keine separaten Referenz- und Werttypen kennt. Es unterscheidet auch nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden.'},
     {'question': 'Welche Unterscheidung gibt es im Typsystem von EIFFEL nicht?', 'answer': 'EIFFEL besitzt ein einheitliches Typsystem und unterscheidet nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden. Auch gibt es keine an bestimmte Typkonstruktoren gebundene Unterscheidung von Wert- und Referenztypen.'},
     {'question': 'Was sind die prominentesten Eigenschaften des Typsystems von EIFFEL?', 'answer': 'Die prominentesten Eigenschaften des Typsystems von EIFFEL sind Mehrfachvererbung, Generizität, das Unterdrücken von Instanzvariablen und Methoden in Subklassen, und kovariante Redefinition, unterstützt durch sog. "verankerte Typen".'},
     {'question': 'Was ist Mehrfachvererbung in EIFFEL?', 'answer': 'Mehrfachvererbung in EIFFEL ist eine Eigenschaft des Typsystems, die es ermöglicht, dass eine Klasse von mehreren übergeordneten Klassen erben kann. Das bedeutet, dass eine Klasse Merkmale und Eigenschaften von mehreren Elternklassen erben kann, was die Wiederverwendung von Code und die Flexibilität bei der Gestaltung von Klassenhierarchien erhöht.'},
     {'question': 'Was ist kovariante Redefinition in EIFFEL?', 'answer': 'In EIFFEL, kovariante Redefinition ist eine Eigenschaft, bei der die Menge der möglichen Parameterobjekte in einer Unterklasse eingeschränkt wird, so dass es keinen gültigen Aufruf gibt. Diese Eigenschaft ist ähnlich wie das Unterdrücken von Methoden eines Typs in seinen Subtypen.'},
     {'question': 'Was ist eine ClassCastException in Java?', 'answer': 'Eine ClassCastException in Java ist eine Laufzeittypfehlermeldung, die geworfen wird, wenn ein Down oder Cross cast zu einem Objekt durchgeführt wird, das nicht den Zieltyp oder einen Subtyp davon hat.'},
     {'question': 'Was sind die Anweisungen in EIFFEL?', 'answer': 'In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. Jede Kontrollstruktur hat genau einen Eingang und einen Ausgang. EIFFEL bietet ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet.'},
     {'question': 'Was sind die Bestandteile einer Anweisung in EIFFEL?', 'answer': 'In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. Jede Kontrollstruktur hat genau einen Eingang und einen Ausgang. EIFFEL bietet ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet.'},
     {'question': 'Was sind Properties in C-Sharp?', 'answer': 'Properties in C-Sharp sind eine Möglichkeit, gewissermaßen die Umkehrung von Zugriffsmethoden zu erreichen. Statt auf ein Feld eines Objekts über Methoden zuzugreifen, ruft man Methoden über das auf, was syntaktisch wie ein Feldzugriff aussieht. Dies erlaubt es, Feldzugriffe mit Nebeneffekten zu versehen, wie zum Beispiel einer dynamischen Typprüfung bei schreibendem Zugriff. Properties können auch dazu verwendet werden, Felder mit Nur-Lese- oder Nur-Schreib-Zugriff zu simulieren.'},
     {'question': 'Was ist ein Zuweisungsversuch in EIFFEL?', 'answer': 'In EIFFEL wird ein Zuweisungsversuch verwendet, um einen Typtest durchzuführen. Wenn die Zuweisungskompatibilität nicht gegeben ist, wird einfach "void" zugewiesen.'},
     {'question': 'Was ist nominale Typkonformität in EIFFEL?', 'answer': 'In EIFFEL ist nominale Typkonformität die Zuweisungskompatibilität, die mit der Typerweiterung (Vererbung) einhergeht. Das bedeutet, dass eine Unterklasse mit einer Oberklasse kompatibel ist und eine Variable der Oberklasse mit einem Objekt der Unterklasse zugewiesen werden kann.'},
     {'question': 'Was ist das Problem der Kovarianz in EIFFEL?', 'answer': 'Das Problem der Kovarianz in EIFFEL tritt auf, wenn eine Konstruktion vom Type checker zur Übersetzungszeit zurückgewiesen wird, weil der Typ des Objekts nicht mit den Typkonformitätsregeln übereinstimmt.'},
     {'question': 'Was sind CAT-Calls in Eiffel?', 'answer': 'CAT-Calls (Change Availability or Type Calls) sind dynamisch gebundene Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen ändern können. Ein Beispiel für einen CAT-Call ist der Aufruf von share auf s1 wie oben, der verboten ist, weil share in BOY und GIRL kovariant redefiniert wird.'},
     {'question': 'Was sind zirkuläre Abhängigkeiten zwischen Paketen?', 'answer': 'Zirkuläre Abhängigkeiten zwischen Paketen sind Abhängigkeiten, bei denen zwei oder mehr Pakete aufeinander referenzieren, so dass ein Kreislauf entsteht. Diese Abhängigkeiten können die Modularisierung und Wartbarkeit des Codes erschweren.'},
     {'question': 'Was sind Typtests in Java?', 'answer': 'Typtests in Java sind eine Methode, um Laufzeitfehler zu vermeiden. Sie werden durchgeführt, bevor eine Typumwandlung durchgeführt wird. Das Schlüsselwort hierfür ist instanceof.'},
     {'question': 'Was ist Typinferenz in Java?', 'answer': 'Typinferenz in Java ist eine Funktion des Compilers, die es ermöglicht, den tatsächlichen Typparameter bei einem Aufruf einer parametrischen Methode wegzulassen, wenn er sich aus dem Aufruf erschließen lässt.'},
     {'question': 'Was sind Tupel in EIFFEL?', 'answer': 'Tupel in EIFFEL sind eine Möglichkeit, mehrere Objekte ohne großen Aufwand zu gruppieren, insbesondere ohne die Notwendigkeit, eine Klasse zu definieren. Tupel sind besonders interessant, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugeordnet wird. Dies ist besonders prominent bei Methoden, die mehrere Werte anstelle eines einzigen Wertes zurückgeben sollen.'},
     {'question': 'Was sind Blöcke in Java?', 'answer': 'In Java sind Blöcke lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt Java erst seit Version 8, mit der Einführung der Lambda-Ausdrücke.'},
     {'question': 'Was sind die Kontrollstrukturen in der Programmierung?', 'answer': 'Die Kontrollstrukturen in der Programmierung sind if-Anweisungen, while-Anweisungen, repeat-Anweisungen, for-Anweisungen und case-Anweisungen. Sie dienen dazu, den Kontrollfluss eines Programms von der normalen, sequentiellen Ausführung abzuweichen.'},
     {'question': 'Was sind die Anweisungen die den Kontrollfluss eines Programms beeinflussen?', 'answer': 'Die Anweisungen die den Kontrollfluss eines Programms beeinflussen sind: if-Anweisungen, while-Anweisungen, repeat-Anweisungen, case-Anweisungen, for-Anweisungen, loop-Anweisungen, exit-Anweisungen und return-Anweisungen.'},
     {'question': 'Was ist die Switch-Anweisung in Java?', 'answer': 'Die Switch-Anweisung in Java ist eine Steuerungsanweisung, die einen Ausdruck mit einem oder mehreren Literalen vergleicht und eine entsprechende Anweisungsliste ausführt. Der Ausdruck und die Literale müssen vom Typ char, byte, short, int, String oder einem Aufzählungstyp sein. Die Anweisungslisten können mit einem break abgeschlossen werden, müssen aber nicht. Wenn keines der Literale mit dem Ausdruck übereinstimmt, wird die default-Anweisungsliste ausgeführt.'},
     {'question': 'Was sind die möglichen Seiteneffekte der Assert-Anweisung?', 'answer': 'Die Assert-Anweisung kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen.'},
     {'question': 'Was sind Assert-Anweisungen in Java?', 'answer': 'Assert-Anweisungen in Java sind ein Verfahren, um Invarianten in einem Programm zu überprüfen. Dabei werden die Bedingungen, die die Invarianten formulieren, zur Laufzeit überprüft, indem die entsprechenden Statements ausgeführt werden. Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden jedoch als Quellcodeannotationen formuliert und stellen sicher, dass alle Zugriffe auf Programmelemente den Zustand des Programms nicht verändern.'},
     {'question': 'Was ist Auto boxing und Auto unboxing in Java?', 'answer': 'Seit Java 5 können Werte primitiver Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man "Auto boxing" bzw. "Auto unboxing". Dabei ist es wichtig, in Java sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte, um unerwartete Phänomene zu vermeiden.'},
     {'question': 'Was ist das Friends-Konzept in C++?', 'answer': 'Das Friends-Konzept in C++ ist ein Mechanismus, der eine enge Kooperation zwischen Klassen ermöglicht. Dabei kann eine Klasse auf Elemente einer anderen Klasse zugreifen, die anderen Klassen verborgen bleiben sollen. Die Schnittstelle solcher kooperierender Klassen kann somit relativ zu anderen Klassen definiert werden.'},
     {'question': 'Was sind Wrapper-Typen in Java?', 'answer': 'In Java werden für jeden primitiven Typ Referenztypen definiert, die Werte eines entsprechenden primitiven Typs aufnehmen können. Diese Typen, nämlich Byte, Short, Integer, Long, Float, Double, Boolean und Character, werden Wrapper-Typen genannt.'},
     {'question': 'Was sind Literale in Java?', 'answer': 'Literale sind in Java fest definierte Werte, die direkt in den Quellcode eingebettet werden können. Sie werden vom Compiler in Maschinencode übersetzt. In Java gibt es Literale für die folgenden Datentypen: Ganze Zahlen (Integer-Literale), Gleitkommazahlen (Floating-Point-Literale), Zeichen (Character-Literale), Zeichenketten (String-Literale), Boolean-Literale und Null-Literale. Ganze Zahlen'},
     {'question': 'Welche Typkonstruktoren bietet C-Sharp für Wert- und Referenztypen an?', 'answer': 'C-Sharp bietet für Wert-Typen die Typkonstruktoren struct und enum, für Referenz-Typen die Typkonstruktoren class und interface an.'},
     {'question': 'Welche Verbesserungen bietet C-Sharp in Verbindung mit dem Typsystem?', 'answer': 'C-Sharp bietet eine ganze Reihe von Verbesserungen in Verbindung mit dem Typsystem, auf die hier aber nicht näher eingegangen wird.'},
     {'question': 'Was ist der Zweck von generischen Variablen in Java?', 'answer': 'Der Zweck von generischen Variablen in Java ist es, Variablen zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Dies ist möglich, da eine Variable keinen neuen Sichtbarkeitsbereich definiert, jedoch nur mit anonymen Typvariablen, also Wildcards. Der per "Wildcard" deklarierten Variable können also Listen beliebigen Elementtyps zugewiesen werden, weil "List<?>" Supertyp aller Instanziierungen von "List<T>" ist.'},
     {'question': 'Was ist die Rolle des Typsystems in C++?', 'answer': 'Das Typsystem von C++ ist ein wichtiger Bestandteil der Sprache und umfasst primitive Datentypen wie int, bool, etc., sowie die Typkonstruktoren struct und union. Diese Typen sind alle Typen mit Wertsemantik. Es ist auch möglich, Zeigertypen auf diese Typen zu definieren.'},
     {'question': 'Welche Datentypen gibt es in C++?', 'answer': 'In C++ gibt es primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct und union. Alle diese Typen sind Typen mit Wertsemantik. Es lassen sich jedoch auch Zeigertypen darauf definieren.'},
     {'question': 'Was ist Mehrfachvererbung in C++?', 'answer': 'Mehrfachvererbung in C++ bedeutet, dass eine Klasse von mehreren anderen Klassen abgeleitet werden kann. Die Syntax von C++ sieht vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.'},
     {'question': 'Was ist die Folge der Mehrfachvererbung für das Typsystem?', 'answer': 'Die Folge der Mehrfachvererbung für das Typsystem ist, dass ein von einer Klasse abgeleiteter Typ beliebig viele direkte Supertypen haben kann (nämlich einen pro direkte Superklasse).'},
     {'question': 'Was ist eine virtuelle Methode?', 'answer': 'Bei virtuellen Methoden wird zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Dies geschieht über eine Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt als teuer und sollte daher nur verwendet werden, wenn unbedingt notwendig.'},
     {'question': 'Was ist ein Virtual function table?', 'answer': 'Ein Virtual function table ist eine Tabelle, die im Laufzeitsystem gehalten wird und in der die zum Objekt passende Implementierung einer virtuellen Methode nachgeschlagen werden kann. Sie wird verwendet, um zur Laufzeit zu prüfen, welchen Typs das Objekt ist und dann zur entsprechenden Methodenimplementierung zu verzweigen.'},
     {'question': 'Was ist das Typsystem von C++?', 'answer': 'Das Typsystem von C++ ist rein statisch, aber nicht strikt. Es erlaubt Typumwandlungen (Type casts), die nur zur Kompilierungszeit überprüft werden. Während der Laufzeit wird die Zulässigkeit der Typumwandlung nicht überprüft.'},
     {'question': 'Was ist der Zweck der synchronized-Anweisung in Java?', 'answer': 'Die synchronized-Anweisung in Java wird verwendet, um die Synchronisation von Threads zu erzwingen. Sie stellt sicher, dass die Anweisungen innerhalb des synchronisierten Blocks nur dann ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden.'},
     {'question': 'Was ist die Aufgabe der Laufzeitkomponente des Typsystems in C-Sharp?', 'answer': 'Die Laufzeitkomponente des Typsystems in C-Sharp führt eine strikte Typprüfung durch, um sicherzustellen, dass die Variablen und Ausdrücke nur mit Werten verwendet werden, die zum jeweiligen Typ passen.'},
     {'question': 'Was sind Ragged oder Jagged arrays in Java?', 'answer': 'Ragged oder Jagged arrays in Java sind mehrdimensionalen Arrays, bei denen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten müssen.'},
     {'question': 'Was ist die Lösung für das Problem der fehlenden Zuweisungskompatibilität zwischen "ArrayList<Integer>" und "ArrayList<Comparable>"?', 'answer': 'Die Lösung für das Problem der fehlenden Zuweisungskompatibilität zwischen "ArrayList<Integer>" und "ArrayList<Comparable>" ist die Verwendung von Generics. Generics ermöglichen es, den Typ der Elemente in einer ArrayList bei der Erstellung der ArrayList anzugeben. Dadurch wird sichergestellt, dass nur Elemente des angegebenen Typs in die ArrayList aufgenommen werden können. Wenn man also eine ArrayList<Integer> erstellt, kann man nicht versehentlich eine ArrayList<String> zuweisen, und umgekehrt.'},
     {'question': 'Welche Ansätze gibt es, um die Kovarianzprobleme in EIFFEL zu verhindern?', 'answer': 'Es gibt verschiedene Ansätze, um die Kovarianzprobleme in EIFFEL zu verhindern, darunter die Beschränkung der Zuweisungskompatibilität, die Durchführung einer Typinferenz für das gesamte Programm und das Verbot dynamisch gebundener Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen ändern. Jede dieser Methoden hat jedoch ihre eigenen Einschränkungen und Herausforderungen.'},
     {'question': 'Welche Verpflichtung ergibt sich in Java daraus, wenn eine Klasse ein Interface implementiert?', 'answer': 'Eine Klasse gibt an, dass sie ein Interface implementiert, indem sie das Schlüsselwort "implements" verwendet, gefolgt vom Namen des Interfaces. Die Klasse verpflichtet sich, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten.'},
     {'question': 'Was bedeutet "Call by value" in C++?', 'answer': 'Bei "Call by value" in C++ wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen.'},
     {'question': 'Was bedeutet es, eine Methode in Java zu redefinieren?', 'answer': 'In Java kann eine Subklasse eine Methode mit derselben Signatur (bestehend aus Methodennamen und formalen Parametertypen) wie eine Methode der Superklasse neu definieren, jedoch mit einer geänderten Implementierung. Die Methode kann auch den Rückgabetyp kovariant ändern, d.h., in Richtung Subtyp. Die Einhaltung der Typinvarianten, die mit ihren (geerbten) Parametern verbunden sind, über die hinaus die überschreibende Methode nichts tut, was mit der überschriebenen Methode inkompatibel ist, kann durch die Sprachdefinition von Java nicht erzwungen werden. In diesem Punkt liegt die Verantwortung beim Programmierer.'},
     {'question': 'Was bedeutet ein Methodenambiguitätsfehler?', 'answer': 'Ein Methodenambiguitätsfehler bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist.'},
     {'question': 'Was bedeutet es, dass jeder Typ in Java ein Subtyp von Object ist?', 'answer': 'Das bedeutet, dass jeder Typ in Java eine Unterklasse von Object ist und somit die Methoden von Object erbt.'},
     {'question': 'Was bedeutet "Redefinition" in EIFFEL?', 'answer': 'In EIFFEL wird das Überschreiben von Methoden als "Redefinition" bezeichnet.'},
     {'question': 'Was bedeutet es, wenn eine Java-Klasse von einer anderen Klasse ableitet?', 'answer': 'Wenn eine Java-Klasse von einer anderen Klasse ableitet, wird eine Subklassenbeziehung zwischen den beiden Klassen deklariert. Die abgeleitete Klasse erbt alle Eigenschaften und Methoden der Basisklasse und kann diese erweitern oder überschreiben. Diese Beziehung ermöglicht auch Zuweisungskompatibilität, was bedeutet, dass eine Instanz der abgeleiteten Klasse auch als Instanz der Basisklasse behandelt werden kann.'},
     {'question': 'Was bedeutet es, dass Java eine stark typisierte Sprache ist?', 'answer': 'Java ist eine stark typisierte Sprache, was bedeutet, dass alle Ausdrücke einen Typ haben und Variablen bei ihrer Deklaration einen Typ angeben müssen.'},
     {'question': 'Was bedeutet es, wenn der Indexer in C-Sharp überladen wird?', 'answer': 'Wenn der Indexer in C-Sharp überladen wird, kann ein Objekt mehrere indizierte Instanzvariablen haben. Der Zugriff erfolgt aufgrund des fehlenden Namens einzig über den Typ des Indexes. Durch das Überladen ist es wiederum möglich, nicht eine, sondern mehrere indizierte Instanzvariablen zu simulieren, wobei jedoch die Einschränkung besteht, dass der Elementtyp (der Rückgabetyp beim Überladen) gleich bleiben muss.'},
     {'question': 'Was bedeutet statische Bindung in C++?', 'answer': 'In C++ werden Methoden standardmäßig statisch gebunden, das heißt, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ des Objekts wird also ignoriert.'}
     ],
    [{'question': 'Wie werden Parameter bei Methodenaufrufen in Java und SMALLTALK übergeben?', 'answer': 'In Java und SMALLTALK wird bei Methodenaufrufen immer der Zeiger auf das Objekt übergeben, und es wird nirgends explizit angegeben, dass es sich um eine Pointer-variable handelt.'},
     {'question': 'Wie werden Generics in C-Sharp und Java behandelt?', 'answer': 'In Java werden die Typparameter grundsätzlich immer wegkompiliert, um Abwärtskompatibilität zu erreichen. Im Gegensatz dazu instanziiert C-Sharp im Fall von Werttyp-Parametern jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen. Für Referenztypen wird der Code jedoch nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.'},
     {'question': 'Wie werden Typen in C-Sharp und Java behandelt?', 'answer': 'In Java werden die Typparameter grundsätzlich immer wegkompiliert, um Abwärtskompatibilität zu erreichen (Type erasure). Im Gegensatz dazu instanziiert C-Sharp im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Für Referenztypen wird der Code jedoch (wie in Java) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.'},
     {'question': 'Wie wird in C-Sharp Zuweisungskompatibilität bei Containern hergestellt?', 'answer': 'In C-Sharp wird Zuweisungskompatibilität bei Containern hergestellt, indem dem kovarianten bzw. kontravarianten Typparameter das Schlüsselwort out bzw. in vorangestellt wird. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen.'},
     {'question': 'Wie wird in C-Sharp das Varianzproblem bei der Zuweisung von Containern gelöst?', 'answer': 'In C-Sharp wird das Varianzproblem bei der Zuweisung von Containern durch eine Annotation der Definition des Typs gelöst. Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen.'},
     {'question': 'Wie funktioniert das dynamische Binden in Java?', 'answer': 'Das dynamische Binden in Java funktioniert durch einen Bindealgorithmus, der im Klassenbereich der Klasse des Objekts beginnt und sich durch die Klassenhierarchie nach oben arbeitet, bis eine passende Methode gefunden wird oder die Suche bei Object endet.'},
     {'question': 'Wie werden Zu-n-Beziehungen in Java umgesetzt?', 'answer': 'In Java werden Zu-n-Beziehungen mithilfe von Zwischenobjekten umgesetzt, wobei zwischen zwei Arten von Zwischenobjekten unterschieden wird: Arrays und Collections. Arrays sind in Java beschränkt, da sie keine eigenen Methoden zur Unterstützung des Zugriffs haben, kein dynamisches Wachstum ermöglichen und eine etwas verkorkste Situation beim Subtyping aufweisen.'},
     {'question': 'Wie können Klienten auf die Methoden zugreifen, ohne die tatsächliche Implementierung zu kennen?', 'answer': 'Klienten können auf die Methoden zugreifen, ohne die tatsächliche Implementierung zu kennen, indem sie die Interfaces verwenden, die die Schnittstelle zwischen Klienten und Diensten definieren. Die Interfaces definieren den Vertrag, welche Methoden eine Klasse implementieren muss, um ein bestimmtes Verhalten zu bieten, und die Klienten können auf die Methoden zugreifen, indem sie die Interfaces als Typen verwenden.'},
     {'question': 'Wie startet man ein Java-Programm?', 'answer': 'Um ein Java-Programm auszuführen, muss man eine Klasse angeben, die eine main-Methode besitzt. Die Signatur der main-Methode hat die Form public static void main(String[] args). Die main-Methode ist eine normale Instanzmethode, die zu einem beliebigen Objekt gehören kann, das die main-Methode implementiert.'},
     {'question': 'Wie ist der Zusammenhang zwischen Klassen und Dateien in Java?', 'answer': 'In Java besteht ein enger Zusammenhang zwischen Klassen und Dateien. Jede Datei enthält die Definition einer Klasse, die den Dateinamen (ohne Erweiterung) als Namen trägt. Eine Datei kann auch mehrere Klassen enthalten, die dann verschiedene Namen haben müssen. Es darf jedoch nur eine dieser Klassen als "public" deklariert werden.'},
     {'question': 'Wie hängen Klassen und Typen in Java zusammen?', 'answer': 'In Java definiert jede Klasse ihren eigenen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält.'},
     {'question': 'Wie wird in Java ein Typ definiert?', 'answer': 'In Java wird ein Typ durch eine Klassendefinition definiert, die Felddefinitionen und Methodendeklarationen enthält. Jede Klasse definiert somit ihren eigenen Typ, der denselben Namen wie die Klasse trägt.'},
     {'question': 'Wie werden Variablen in Java deklariert?', 'answer': 'In Java wird der Typ einer Variablen bei der Deklaration vorangestellt, z.B. int x; oder String s;'},
     {'question': 'Wie erzeugt man in C++ Objekte mit Identität?', 'answer': 'Um in C++ Objekte mit Identität zu erzeugen, muss man Zeigervariablen (Pointer) verwenden und eine Klasse mit dem "new"-Operator instanziieren.'},
     {'question': 'Wie kann in C++ "Call by reference" erreicht werden?', 'answer': 'In C++ kann "Call by reference" erreicht werden, indem man den Zeigeroperator "&" verwendet und die formalen Parameter so deklariert, dass sie Zeiger auf Zeiger aufnehmen können.'},
     {'question': 'Wie wird das Varianzproblem bei der Subtypisierung von Containern in C-Sharp gelöst?', 'answer': 'In C-Sharp wird das Varianzproblem bei der Subtypisierung von Containern durch das Hinzufügen des Schlüsselworts "out" für kovariante Typparameter und "in" für kontravariante Typparameter bei der Definition des Typs gelöst. Dies stellt sicher, dass Zuweisungskompatibilität auch dann gegeben ist, wenn die generischen Typen verschiedene Typparameter haben.'},
     {'question': 'Wie unterscheidet sich das Programmiermodell von C-Sharp von dem von Java?', 'answer': 'Das Programmiermodell von C-Sharp weist zunächst einige Ähnlichkeiten mit dem von Java auf, da es ebenfalls auf Klassen basiert und der Code in einzelnen Klassen organisiert ist. Die Klassen in C-Sharp können jedoch in lockererem Verhältnis zu Dateien stehen, und Klassen können anders benannt werden als ihre Dateien. Ein wesentlicher Unterschied besteht darin, dass der Bytecode von C-Sharp und die zugehörige virtuelle Maschine, Common Intermediate Language (CIL) genannt, für alle .NET-Sprachen entwickelt wurden und nicht exklusiv für C-Sharp. Die CIL gilt als menschenlesbar.'},
     {'question': 'Wie werden Vor- und Nachbedingungen in EIFFEL formuliert?', 'answer': 'Vor- und Nachbedingungen in EIFFEL werden als Boolesche Ausdrücke formuliert, die immer als "wahr" ausgewertet werden müssen. Die "require"-Klausel stellt Bedingungen dar, die vor dem Aufruf der Methode erfüllt sein müssen, während die "ensure"-Klausel Bedingungen darstellt, die nach dem Aufruf der Methode garantiert erfüllt sind.'},
     {'question': 'Wie werden Zusicherungen in EIFFEL vererbt?', 'answer': 'Zusicherungen, einschließlich Vor- und Nachbedingungen, werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen die Zusicherungen angepasst werden, jedoch mit bestimmten Einschränkungen. Die Vorbedingung darf nur abgeschwächt und die Nachbedingung nur verschärft werden, und die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingungen eingehalten werden.'},
     {'question': 'Wie wird der Zugriff auf Features in EIFFEL kontrolliert?', 'answer': 'In EIFFEL wird der Zugriff auf Features durch die gezielte Veröffentlichung (Export) von Features gesteuert. Klassen, die auf diese Features zugreifen sollen, werden explizit genannt.'},
     {'question': 'Wie wird in EIFFEL ein Typtest durchgeführt?', 'answer': 'In EIFFEL wird ein Typtest mithilfe eines "Zuweisungsversuchs" (engl. "assignment attempt") durchgeführt. Wenn es keine Zuweisungskompatibilität zwischen den Typen gibt, wird "void" (entsprechend "nil" in SMALLTALK oder "null" in Java) zugewiesen. Die Programmiererin muss dann den Typ von "a" nach der Zuweisung überprüfen.'},
     {'question': 'Wie wird in EIFFEL zwischen Wert- und Referenztypen unterschieden?', 'answer': 'In EIFFEL kann bei der Deklaration angegeben werden, ob Variablen eines Typs Wertsemantik oder Referenzsemantik haben sollen. Dies kann für alle Variablen eines Typs oder nur für bestimmte Variablen festgelegt werden.'},
     {'question': 'Wie werden Tupeltypen in EIFFEL deklariert?', 'answer': 'Tupeltypen in EIFFEL werden deklariert, indem für jede Position im Tupel ein Typ angegeben wird. Konkrete Werte eines Tupels werden in eckigen Klammern notiert, wobei die Positionen optional auch Namen erhalten können.'},
     {'question': 'Wie wird in C++ festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen?', 'answer': 'In C++ wird festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen, indem man die betreffenden Klassen mit dem Schlüsselwort "friend" in der Zielsklasse deklariert. Zum Beispiel: friend class B; und friend class C;'},
     {'question': 'Wie wird das Friends-Konzept in Java angenähert?', 'answer': 'Das Friends-Konzept wird in Java durch die Verwendung von Modulen und den dedizierten (qualifizierten) Export auf Ebene der Pakete angenähert. Dies ermöglicht eine kontrollierte Freigabe von Elementen an bestimmte Pakete.'},
     {'question': 'Wie ermöglicht C++ die getrennte Übersetzung von Programmteilen?', 'answer': 'C++ ermöglicht die getrennte Übersetzung von Programmteilen mithilfe von Header-Dateien, die die Schnittstellen der Teile enthalten.'},
     {'question': 'Wie erfolgt die Methodenbindung in C++ standardmäßig?', 'answer': 'Standardmäßig erfolgt die Methodenbindung (Methodenaufruf) in C++ statisch. Das bedeutet, dass die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable hat.'},
     {'question': 'Wann werden Methoden in C++ zur Laufzeit dynamisch gebunden?', 'answer': 'In C++ werden Methoden zur Laufzeit dynamisch gebunden, wenn sie mit dem Schlüsselwort virtual deklariert sind. Bei virtuellen Methoden wird zur Laufzeit überprüft, welchen Typs das Objekt ist, und zur entsprechenden Methodenimplementierung verzweigt.'},
     {'question': 'Wie wird die Zulässigkeit von Typumwandlungen in C++ überprüft?', 'answer': 'Die Zulässigkeit von Typumwandlungen in C++ wird zur Laufzeit überprüft, und sie kann nicht zur Kompilierzeit überprüft werden. Typumwandlungen sollten vermieden werden, da sie die Typsicherheit untergraben können.'},
     {'question': 'Wie kann in C-Sharp eine Typumwandlung (Casting) durchgeführt werden?', 'answer': 'In C-Sharp kann eine Typumwandlung mithilfe von Casts durchgeführt werden. Die Syntax dafür ist (T)a;, wobei T der Zieltyp ist und a der Ausdruck, der umgewandelt werden soll.'},
     {'question': 'Wie wird in C-Sharp sichergestellt, dass ein Cast sicher ist?', 'answer': 'In C-Sharp wird ein Cast sicher gemacht, indem der is-Operator verwendet wird, um zu prüfen, ob die Zuweisung kompatibel ist. Zusätzlich kann der as-Operator verwendet werden, der bei fehlschlagender Zuweisung null zurückgibt.'},
     {'question': 'Wie wirkt sich das Umbenennen von geerbten Features auf das dynamische Binden in Eiffel aus?', 'answer': 'Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.'},
     {'question': 'Wie ist das Verhältnis von Klasse zu Datei in C-Sharp?', 'answer': 'Das Verhältnis von Klasse zu Datei in C-Sharp ist lockerer als in Java. Klassen können anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden.'},
     {'question': 'Wie wird der Zugriff auf Klassen, Typen und deren Elemente in Java eingeschränkt?', 'answer': 'In Java wird der Zugriff auf Klassen, Typen und deren Elemente durch sogenannte Zugriffsmodifikatoren eingeschränkt. Es gibt vier Zugriffsmodifikatoren: private, protected, public und "Package local". Die Zugriffsbeschränkung ist konzeptionell eine Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.'},
     {'question': 'Wie kann man in Java Klassen als Werte angeben?', 'answer': 'In Java können Klassen als Werte angegeben werden, indem man ein sogenanntes Klassenliteral verwendet, das aus dem Namen der Klasse, gefolgt von ".class" besteht, also beispielsweise "Klasse.class".'},
     {'question': 'Wie ist der Zugriff auf Klassen in Java geregelt?', 'answer': 'In Java gewähren Klassen sich untereinander privilegierten Zugriff, während nach außen nur öffentlich deklarierte Programmelemente sichtbar sind.'},
     {'question': 'Wie ist der Zugriff auf Programmelemente in Java geregelt?', 'answer': 'In Java ist der Zugriff auf Programmelemente so geregelt, dass Klassen eines Programms untereinander privilegierten Zugriff haben, während nach außen nur öffentlich deklarierte Programmelemente sichtbar sind.'},
     {'question': 'Wie wird der Zugriffsschutz in Java realisiert?', 'answer': 'Der Zugriffsschutz in Java wird durch die Zugriffskontrollmodifikatoren private, protected und public realisiert. Diese Modifikatoren bestimmen, welche Klassen auf die Elemente einer anderen Klasse zugreifen können. Standardmäßig ist alles, was nicht explizit als privat, geschützt oder öffentlich deklariert ist, in Java package-private, d.h. nur innerhalb des Pakets sichtbar.'},
     {'question': 'Wie wird der Zugriff auf die Elemente einer anderen Klasse in Java geregelt?', 'answer': 'Der Zugriff auf die Elemente einer anderen Klasse in Java wird durch die Zugriffskontrollmodifikatoren private, protected und public geregelt. Diese Modifikatoren bestimmen, welche Klassen auf die'},
     {'question': 'Wie wird das dynamische Binden in Java durchgeführt?', 'answer': 'Das dynamische Binden in Java erfolgt zur Laufzeit, wenn der tatsächliche Typ des Empfängerobjekts bestimmt wird, um die entsprechende Methode auszuwählen. Es ist wichtig zu verstehen, da es das Verhalten eines Programms beeinflusst und zur Vorhersage des Programmverhaltens beiträgt.'},
     {'question': 'Wie können Interfaces in Java dazu beitragen, die Austauschbarkeit von Klassen zu verbessern?', 'answer': 'Interfaces ermöglichen es, verschiedene Implementierungen eines Interfaces zu verwenden, ohne den zugrunde liegenden Klassentyp zu spezifizieren. Dies verbessert die Austauschbarkeit von Klassen, da verschiedene Klassen, die dasselbe Interface implementieren, in derselben Weise verwendet werden können.'},
     {'question': 'Wie kann auf Klassen und Typen in unterschiedlichen Paketen in Java zugegriffen werden?', 'answer': 'Um auf Klassen und Typen in verschiedenen Paketen zuzugreifen, müssen in Java explizite Import-Deklarationen verwendet werden, die die jeweiligen Paketnamen nennen. Pakete ermöglichen keinen privilegierten Zugriff auf Klassen ihrer Subpakete.'},
     {'question': 'Wie kann in Java verhindert werden, dass von einer Klasse abgeleitet wird?', 'answer': 'In Java kann verhindert werden, dass von einer Klasse abgeleitet wird, indem man das Schlüsselwort "final" vor der Klassendefinition verwendet.'},
     {'question': 'Wie werden parametrische (generische) Typen in Java definiert?', 'answer': 'Parametrische (generische) Typen in Java werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Die formalen Typparameter in der Klassendefinition können durch verschiedene Typen ersetzt werden.'},
     {'question': 'Wie können Typ-Wildcards in Java zur Verbesserung der Typsicherheit verwendet werden?', 'answer': 'Typ-Wildcards können verwendet werden, um sicherzustellen, dass Zuweisungen und Zugriffe auf generische Typen zur Übersetzungszeit statisch typsicher sind, ohne dass es zu Laufzeitfehlern kommt. Dies erhöht die Typsicherheit von Java-Programmen.'},
     {'question': 'Wie sieht eine einfache Klassendefinition in Java aus?', 'answer': 'Eine einfache Klassendefinition in Java besteht aus dem Klassennamen, der Angabe von Instanzvariablen (Felder) und Instanzmethoden.'},
     {'question': 'Wann werden "final"-Variablen in Java verwendet?', 'answer': '"final"-Variablen werden in Java verwendet, um Konstanten zu deklarieren. Sie dürfen nur einmal einen Wert zugewiesen bekommen und sind dann nicht mehr änderbar.'},
     {'question': 'Wann werden Type casts in Java verwendet?', 'answer': 'Type casts werden in Java verwendet, wenn man einem Programmelement, das einen bestimmten Typ hat, einen anderen Typ zuweisen möchte oder wenn man auf Methoden oder Felder zugreifen möchte, die nicht im deklarierten Typ verfügbar sind.'},
     {'question': 'Wie vermeidet man Laufzeitfehler bei Typumwandlungen in Java?', 'answer': 'Man vermeidet Laufzeitfehler bei Typumwandlungen in Java mithilfe von Typtests, die vor der Typumwandlung durchgeführt werden.'},
     {'question': 'Wie können Arrays in Java initialisiert werden?', 'answer': 'Arrays können in Java bei ihrer Deklaration initialisiert werden. Dabei wird die Größe des Arrays automatisch festgelegt.'},
     {'question': 'Wie funktioniert die Zuweisung von Array-Variablen in Java?', 'answer': 'In Java haben Array-Variablen Referenzsemantik, und bei der Zuweisung wird lediglich ein Verweis auf das Array übergeben. Die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[] ist zulässig.'},
     {'question': 'Wie ist die Typenhierarchie in C-Sharp aufgebaut?', 'answer': 'In C-Sharp sind alle Variablen typisiert. Anders als in Java wird zunächst nicht zwischen Wert- (primitiven) und Referenztypen unterschieden: Alle Typen, auch die primitiven, gelten als von Object (genauer: System.Object) abgeleitet.'},
     {'question': 'Wie kann man die Zuweisungskompatibilität zwischen "ArrayList<Integer>" und "ArrayList<Comparable<Integer>>" herstellen?', 'answer': 'Die Zuweisungskompatibilität zwischen "ArrayList<Integer>" und "ArrayList<Comparable<Integer>>" kann durch die Verwendung des Upper-Bounded Wildcards hergestellt werden. Dazu wird der generische Typ mit einem Fragezeichen und dem Upper-Bound (in diesem Fall "Comparable<Integer>") angegeben, was bedeutet, dass der generische Typ jede Klasse sein kann, die ein Subtyp von "Comparable<Integer>" ist. Somit ist "Integer" ein Subtyp von "Comparable<Integer>" und die Zuweisungskompatibilität wird hergestellt.'},
     {'question': 'Wie hängen die Subtyp-Beziehungen von generischen Typen mit Typ-Wildcards zusammen?', 'answer': 'Für mit "extends" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also "Integer" ein Subtyp von "Number" ist, dann ist auch "List<? extends Integer>" ein Subtyp von "List<? extends Number>". Umgekehrt gilt für mit "super" nach unten beschränkte Typen, dass "List<? super Integer>" ein Supertyp von "List<? super Number>" ist. Man sagt auch, das Subtyping mit "extends" beschränkter Wildcard-Typen sei kovariant und das mit "super" beschränkter Wildcard-Typen kontravariant.'},
     {'question': 'Wie werden auf Attribute in EIFFEL zugegriffen?', 'answer': 'In EIFFEL werden auf Attribute über Zugriffsmethoden zugegriffen, die syntaktisch wie Variablen aussehen. Um das Attribut a eines Objekts x zu ändern, wird ein Zuweisungsausdruck verwendet: x.a := b.'},
     {'question': 'Wie können in Eiffel auf Instanzvariablen zugegriffen werden?', 'answer': 'In Eiffel können auf Instanzvariablen, die als Attribute bezeichnet werden, nur über Zugriffsmethoden zugegriffen werden. Diese Zugriffsmethoden nehmen syntaktisch die Form von Variablen an, werden jedoch vom System automatisch bereitgestellt.'},
     {'question': 'Wie ist die Zugriffsmodellierung in EIFFEL?', 'answer': 'In EIFFEL gibt es keine Zugriffsmodifikatoren wie in Java/C-Sharp/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt. Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.'},
     {'question': 'Wie ist die Zugriffsebene von Features in EIFFEL festgelegt?', 'answer': 'In EIFFEL gibt es keine Zugriffsmodifikatoren wie in Java/C-Sharp/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt. Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.'},
     {'question': 'Wie wird der Zustand eines Objekts in EIFFEL gekapselt?', 'answer': 'In EIFFEL wird der Zustand eines Objekts automatisch gekapselt, indem Attribute nur über Zugriffsmethoden zugänglich sind. Diese Zugriffsmethoden müssen nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.'},
     {'question': 'Wie wird die Sichtbarkeit von Features in EIFFEL geregelt?', 'answer': 'In EIFFEL wird die Sichtbarkeit von Features durch den dedizierten Export geregelt, bei dem die Klassen genannt werden, die auf die Features zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was privat in anderen Sprachen entspricht.'},
     {'question': 'Wie werden Features in EIFFEL exportiert?', 'answer': 'In EIFFEL können Features gezielt exportiert werden, indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren.'},
     {'question': 'Wie wird eine Methode in C-Sharp überschrieben?', 'answer': 'In C-Sharp muss eine Methode, die überschrieben werden soll, mit dem Schlüsselwort "virtual" deklariert werden. Die überschreibende Methode muss mit dem Schlüsselwort "override" deklariert werden.'},
     {'question': 'Wie unterscheidet sich C-Sharp von Java in Bezug auf Schlüsselwörter und Kontrollflussanweisungen?', 'answer': 'In C-Sharp werden einige Sprachkonstrukte mit anderen Schlüsselwörtern als in Java verwendet, wie zum Beispiel "lock" anstatt "synchronized" und "foreach" anstatt "for" für die zweite Form von "For"-Schleifen. Zudem sind in C-Sharp auch "Strings" als Basis einer "Switch"-Anweisung zugelassen und jeder Zweig muss mit einer expliziten Kontrollflussanweisung abgeschlossen werden. Im Gegensatz zu Java verfügt C-Sharp über eine "Goto"-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. Diese Unterschiede haben jedoch nichts mit Objektorientierung zu tun.'},
     {'question': 'Wie werden Typvariablen in Java bezeichnet?', 'answer': 'In Java werden Typvariablen in generischen Typen in spitzen Klammern bezeichnet.'},
     {'question': 'Wie würden Sie die Programmiersprache Java beschreiben?', 'answer': 'Java ist eine Programmiersprache, die eine Mischung aus SMALLTALK und C++ ist. Es übernahm weite Teile der Syntax und der statischen Typüberprüfung von C++ sowie den eher klassisch prozeduralen Charakter. Andererseits übernahm es die umfassende Objektorientierung, die Einfachvererbung und die Garbage Collection von SMALLTALK.'},
     {'question': 'Wie können anonyme Funktionen oder Blöcke in Java erstellt werden?', 'answer': 'In Java können anonyme Funktionen oder Blöcke über vordefinierte Interfaces erstellt werden.'},
     {'question': 'Wie unterscheiden sich Java-Ausdrücke und SMALLTALK-Ausdrücke?', 'answer': 'Es gibt einige Unterschiede zwischen Java-Ausdrücken und SMALLTALK-Ausdrücken, darunter die Verwendung von direkten Feldzugriffen in Java (a.x) und das Fehlen von indizierten Instanzvariablen in SMALLTALK. Außerdem unterscheidet Java zwischen Operatoranwendungen (+, -, etc.), Methodenaufrufen, Konstruktoraufrufen und Arrayzugriffen, während in SMALLTALK nur Methodenaufrufe existieren.'},
     {'question': 'Wie werden Properties in C-Sharp verwendet?', 'answer': 'Properties werden verwendet, um (lesend und schreibend) Feldzugriffe zu ermöglichen, die wie Feldzugriffe aussehen, aber mit zusätzlichen Funktionalitäten. Sie können auch verwendet werden, um Felder mit Nur-Lese- oder Nur-Schreib-Zugriff zu simulieren.'},
     {'question': 'Wie äußert sich die Abhängigkeit zwischen Klassen in Java?', 'answer': 'Die Abhängigkeit zwischen Klassen in Java manifestiert sich in zwei verschiedenen Formen: Zum einen, wenn eine Klasse auf Objekte einer anderen Klasse zugreift, was sich durch die Deklaration von Variablen des entsprechenden Typs und gegebenenfalls durch das Importieren der Klasse oder des Pakets zeigt. Zum anderen, wenn eine Klasse einige ihrer Member anderen zur Benutzung anbietet, was sich durch die Verwendung von Zugriffsmodifikatoren, die nicht private sind, sowie an der Implementierung von Interfaces zeigt.'},
     {'question': 'Wie werden Ausdrücke in Java zu Anweisungen?', 'answer': 'In Java können bestimmte Ausdrücke zu Anweisungen gemacht werden, indem sie durch ein Semikolon abgeschlossen werden. Dazu gehören Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen.'},
     {'question': 'Wie werden Parameter in Java übergeben?', 'answer': 'In Java werden Parameter immer durch Wertübertragung übergeben, auch wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben.'},
     {'question': 'Wie viele Arten von Typen werden in Java unterschieden?', 'answer': 'In Java werden sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen.'},
     {'question': 'Wann wird in C-Sharp die Unterscheidung von Wert- und Referenztypen getroffen?', 'answer': 'In C-Sharp wird die Unterscheidung von Wert- und Referenztypen dynamisch zur Laufzeit getroffen.'},
     {'question': 'Wie werden Interfaces in C-Sharp verwendet?', 'answer': 'In C-Sharp können Interfaces als Typen verwendet werden, das heißt, dass eine Variable einen Interface-Typ haben kann.'},
     {'question': 'Wie werden Methoden in C++ gebunden?', 'answer': 'In C++ werden Methoden standardmäßig statisch gebunden, das bedeutet, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.'},
     {'question': 'Wie wird Generizität in C++ erreicht?', 'answer': 'In C++ wird Generizität mithilfe von Templates erreicht. Templates sind Muster, anhand derer neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu Java werden aus Templates tatsächlich neue Klassen erzeugt, die kompiliert werden. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen, der vom Präprozessor umgesetzt wird.'},
     {'question': 'Wie werden parallele Ausführungsstränge in Java bezeichnet?', 'answer': 'In Java werden parallele Ausführungsstränge als Threads bezeichnet.'},
     {'question': 'Wie wird die Synchronisation von Threads in Java erreicht?', 'answer': 'Die Synchronisation von Threads in Java erfolgt mit Monitoren, die mit Objekten verknüpft sind. Wenn ein Thread einen Monitor eines Objekts sperrt, kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.'},
     {'question': 'Wie kann die Synchronisation von Threads erzwungen werden?', 'answer': 'Die Synchronisation von Threads kann durch die Verwendung der synchronized-Anweisung erzwungen werden. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden.'},
     {'question': 'Wie wird die Größe eines Arrays in Java festgelegt?', 'answer': 'Die Größe eines Arrays in Java wird nicht in der Deklaration festgelegt, sondern erst bei der Initialisierung.'},
     {'question': 'Wie ist die Nummerierung der Indizes in Java-Arrays?', 'answer': 'Java-Arrays sind 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.)'},
     {'question': 'Wie werden mehrdimensionale Arrays in Java deklariert?', 'answer': 'Mehrdimensionale Arrays in Java werden als Arrays von Arrays deklariert.'},
     {'question': 'Wie verhält sich die Zuweisungskompatibilität von Array-Variablen in Java?', 'answer': 'In Java haben Array-Variablen immer Referenzsemantik. Eine Zuweisung von f an eine Variable vom Typ Object ist zulässig, während eine Zuweisung von f an eine Variable vom Typ Object[] nicht zulässig ist. Dies liegt daran, dass float[] kein Subtyp von Object[] ist.'},
     {'question': 'Was ist der Zweck von Interfaces in der Programmierung?', 'answer': 'Interfaces definieren eine Schnittstelle für Klassen, die eine bestimmte Funktionalität bereitstellen. Sie legen fest, welche Methoden eine Klasse implementieren muss, um ein bestimmtes Interface zu unterstützen. Durch Interfaces können Klienten auf die Funktionalität einer Klasse zugreifen, ohne von der konkreten Implementierung abhängig zu sein. In dem oben genannten Kontext können verschiedene Klienten entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.'},
     {'question': 'Was ist der Zweck der main-Methode in Java?', 'answer': 'Die main-Methode ist der Einstiegspunkt für die Ausführung eines Java-Programms. Das Betriebssystem übergibt der JVM den Namen der Klasse, die die main-Methode enthält, als Parameter, um das Programm auszuführen.'},
     {'question': 'Was ist der Zweck von privaten Methoden in Interfaces in Java?', 'answer': 'Der Zweck von privaten Methoden in Interfaces in Java 9 ist die Verbesserung der Lesbarkeit von Default-Methoden, indem man zusammenhängende Teile aus ihnen herauslöst und in private Methoden verlegt. Diese privaten Methoden sind ausschließlich aus dem Interface selbst heraus zugreifbar.'},
     {'question': 'Wie erfolgt die Übertragung von Parametern in C++-Methodenaufrufen?', 'answer': 'In C++-Methodenaufrufen erfolgt die Übertragung von Parametern standardmäßig durch "Call by value", was bedeutet, dass Kopien der Parameter übergeben werden.'},
     {'question': 'Wie geht EIFFEL mit Zusicherungen (Assertions) um?', 'answer': 'Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Anders als in Java, wo Zusicherungen flexibel platziert werden können, gibt es in EIFFEL spezielle vorgesehene Stellen für diese Zusicherungen.'},
     {'question': 'Wie würden Sie das Programmiermodell von EIFFEL beschreiben?', 'answer': 'Das Programmiermodell von EIFFEL ist rein objektorientiert, bei dem der gesamte Code in Klassen organisiert ist. Diese Klassen können separat übersetzt werden, und die Ausführung erfolgt direkt auf der Zielmaschine.'},
     {'question': 'Wie würden Sie das Programmiermodell von C++ beschreiben?', 'answer': 'Das Programmiermodell von C++ ist ein klassisches Modell, bei dem Programme als eine Menge von Quellcode-Dateien geschrieben werden, die auf einer Zielmaschine direkt in ausführbaren Maschinencode übersetzt werden.'},
     {'question': 'Was ist der Zweck von Wildcards in Java?', 'answer': 'Der Zweck von Wildcards in Java ist es, die dynamischen Typprüfungen bei Arrays zu vermeiden.'},
     {'question': 'Was ist der Zweck eines Konstruktors in Java?', 'answer': 'Der Zweck eines Konstruktors in Java ist es, eine neue Instanz der Klasse zu erzeugen und gegebenenfalls die Variablen der Klasse zu initialisieren. Wird kein Konstruktor definiert, wird standardmäßig ein impliziter parameterloser Konstruktor verwendet. Konstruktoren werden nicht vererbt, aber beim Erzeugen einer Instanz einer Subklasse wird automatisch der Standardkonstruktor der Superklasse aufgerufen.'},
     {'question': 'Was ist der Zweck von Try-Catch-Blöcken in Java?', 'answer': 'Try-Catch-Blöcke in Java werden verwendet, um Ausnahmesituationen während des Programmablaufs abzufangen und zu behandeln. Der Codeabschnitt, in dem die Exception auftreten kann, wird in den Try-Block eingefasst, während der Catch-Block den Code enthält, der die Exception behandelt.'},
     {'question': 'Was ist der Zweck der Assert-Anweisung in Java?', 'answer': 'Die Assert-Anweisung in Java dient dazu, bestimmte Bedingungen im Programm zu überprüfen. Wenn die Bedingung zu false ausgewertet wird, wird das Programm mit einer entsprechenden Fehlermeldung abgebrochen. Die Assert-Anweisung kann auch ein optionales Ergebnis liefern, das in der Fehlermeldung angezeigt wird. Sie eignet sich zur Überprüfung von Invarianten zur Laufzeit.'},
     {'question': 'Was ist der Zweck der Verwendung von Generics in Java?', 'answer': 'Der Zweck der Verwendung von Generics in Java ist es, die Typsicherheit statisch, also zur Übersetzungszeit, zu erhöhen und die Notwendigkeit von Typumwandlungen (Downcast) zu verringern, die zu Laufzeitfehlern führen können.'},
     {'question': 'Wie verwendet C-Sharp Call by reference?', 'answer': 'Call by reference in C-Sharp ist eine Möglichkeit, Funktionen oder Methoden zu schreiben, bei der die Funktions- oder Methodenparameter als Referenzen übergeben werden, anstatt als Werte. Das bedeutet, dass die Funktion oder Methode direkt auf die Originalvariablen zugreifen und diese ändern kann, anstatt Kopien der Variablen zu verwenden. Diese Funktionalität ist ähnlich wie in Pascal, aber in C-Sharp wird es ohne explizite Pointer implementiert. Diese Funktionalität ist besonders nützlich für Methoden wie "swap", die die Werte von zwei Variablen vertauschen.'},
     {'question': 'Was ist der Zweck von Konstruktoren in Java?', 'answer': 'Konstruktoren werden verwendet, um die Initialisierung von Objekten zu definieren, wenn sie erstellt werden. Sie werden nicht als Members einer Klasse betrachtet.'},
     {'question': 'Wann sollte man eine Typ-Wildcard verwenden?', 'answer': 'Ein Typparameter ist ein Parameter, der innerhalb einer Methode nicht mehr verwendet wird. Wenn eine Variable nur einmal vorkommt, kann man sie weglassen oder zumindest unbenannt lassen. In diesen Fällen ist es gute Praxis, anstelle des Typparameters eine Typ-Wildcard zu verwenden.'},
     {'question': 'Was ist der Zweck von Monitoren in Java?', 'answer': 'Monitoren in Java werden verwendet, um den Zugriff auf ein Objekt durch mehrere Threads zu synchronisieren. Wenn ein Thread einen Monitor sperrt, kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.'},
     {'question': 'Was ist der Zweck von Casts in C++?', 'answer': 'Der Zweck von Casts in C++ ist es, die statische Typisierung zu umgehen und den Compiler zu zwingen, den Ausdruck auf der linken Seite des Casts als Typ zu interpretieren, der auf der rechten Seite angegeben ist.'},
     {'question': 'Wie unterscheiden sich Properties in C-Sharp von Zugriffsmethoden (Settern und Gettern)?', 'answer': 'Properties in C-Sharp sind eine Möglichkeit, auf die Felder eines Objekts zuzugreifen, indem Methoden aufgerufen werden, die wie Feldzugriffe aussehen. Sie sind die Umkehrung von Zugriffsmethoden (Settern und Gettern) und ermöglichen es, Feldzugriffe mit Nebeneffekten zu versehen. In C-Sharp werden die Schlüsselwörter "get" und "set" verwendet, wobei "get" für den Lesezugriff und "set" für den Schreibzugriff verwendet wird. Die Variable "value" wird verwendet, um den Eingabewert eines Setters zu halten.'},
     {'question': 'Warum können Interfaces in Java nicht von Klassen abgeleitet werden?', 'answer': 'Interfaces in Java können nicht von Klassen abgeleitet werden, weil sie nur eine Schnittstelle definieren und keine Implementierung enthalten. Sie spezifizieren lediglich eine Menge von Methodensignaturen, die eine Klasse implementieren muss, wenn sie das Interface implementiert. Daher können Interfaces nicht von Klassen abgeleitet werden, sondern nur von anderen Interfaces.'},
     {'question': 'Warum wird C++ als eine sehr komplexe Sprache beschrieben?', 'answer': 'C++ wird als eine sehr komplexe Sprache beschrieben, weil ihre Beherrschung Jahre dauern kann, selbst bei täglichem Umgang mit ihr. Die eigentliche Komplexität ergibt sich aus der kombinierten Verwendung ihrer zahlreichen Konstrukte, und die Möglichkeiten sind vielfältig.'},
     {'question': 'Warum kann Mehrfachvererbung in C++ sinnvoll sein?', 'answer': 'Mehrfachvererbung kann aus verschiedenen Gründen sinnvoll sein: Eine Klasse kann von mehreren vollständig abstrakten Klassen erben und damit mehrere Interfaces implementieren. In Aufgabenstellungen, in denen eine Klasse Eigenschaften von mehreren anderen Klassen benötigt, erlaubt Mehrfachvererbung, alle benötigten Eigenschaften zu erben, anstatt sich für eine einzige Superklasse entscheiden zu müssen.'},
     {'question': 'Warum ist das Friends-Konzept in C++ nützlich?', 'answer': 'Das Friends-Konzept ist nützlich, wenn ein Teilproblem in der Programmierung nicht von einer einzelnen Klasse gelöst werden kann, sondern die Zusammenarbeit mehrerer Klassen erfordert. Es ermöglicht, dass diese Klassen eng zusammenarbeiten können, ohne dass alle Klassen dieselbe Schnittstelle haben müssen.'},
     {'question': 'Warum gibt es in Java eine klare Trennung zwischen primitiven und Referenztypen?', 'answer': 'Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von Java als Programmiersprache geprägt hat. Sie ist sinnvoll, weil Werte, im Gegensatz zu Objekten, weder Identität noch Zustand besitzen und somit unterschieden werden müssen.'},
     {'question': 'Warum ist die Angabe des Rückgabetyps in Konstruktordefinitionen in Java nicht erforderlich?', 'answer': 'In Konstruktordefinitionen in Java ist die Angabe des Rückgabetyps nicht erforderlich, weil der Typ der erzeugten Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist. Somit ist der Typ der Instanz bereits festgelegt und muss nicht explizit angegeben werden.'},
     {'question': 'Warum sind Java-Programme weitgehend plattformunabhängig?', 'answer': 'Java-Programme sind weitgehend plattformunabhängig, da sie in Form von Bytecode vorliegen und von der JVM interpretiert werden. Solange eine JVM für ein bestimmtes Betriebssystem verfügbar ist, können Java-Programme auf jedem Rechner und Betriebssystem ausgeführt werden, für das es eine JVM gibt.'},
     {'question': 'Warum können nicht alle Typprüfungen in Java zur Übersetzungszeit durchgeführt werden?', 'answer': 'Nicht alle Typprüfungen können in Java zur Übersetzungszeit durchgeführt werden, da einige Typprüfungen erst zur Laufzeit notwendig sind und nicht im Voraus bekannt sind.'},
     {'question': 'Warum führt die Zuweisung von List<Integer> zu List<Object> zu einem statischen Typfehler in Java?', 'answer': 'Die Zuweisung von List<Integer> zu List<Object> führt zu einem statischen Typfehler in Java, weil bei generischen Typen nicht automatisch eine Zuweisungskompatibilität zwischen unterschiedlichen generischen Typen besteht, selbst wenn die Typen, die sie parametrisieren, zueinander in Beziehung stehen. Dies erhöht die Typsicherheit zur Übersetzungszeit.'},
     {'question': 'Warum sind "ArrayList<Integer>" und "ArrayList<String>" trotz "Integer" und "String" als Subtypen von "Comparable" nicht zuweisungskompatibel mit "ArrayList<Comparable>"?', 'answer': '"ArrayList<Integer>" und "ArrayList<String>" sind nicht zuweisungskompatibel mit "ArrayList<Comparable>", weil generische Typen in Java keine kovariante Zuweisung von Subtypen erlauben. Dies wurde durch die Einführung von Typ-Wildcards gelöst.'},
     {'question': 'Warum sind einige Klassen in Java von der Sprache fest vorgegeben und können nicht beliebig ersetzt werden?', 'answer': 'In Java sind einige Klassen von der Sprache fest vorgegeben, um die grundlegende Funktionalität der Sprache sicherzustellen und um sicherzustellen, dass bestimmte wichtige Aufgaben immer erfüllt werden können. Zum Beispiel sind Klassen wie Object und String integraler Bestandteil der Java-Sprache und können nicht ersetzt werden, da sie grundlegende Funktionen wie die Objekterstellung und Zeichenkettenmanipulation ermöglichen. Diese Klassen stellen die Grundlage für die Entwicklung von Java-Programmen dar und sind daher unverzichtbar.'},
     {'question': 'Warum sind zirkuläre Abhängigkeiten in Java-Modulen verpönt?', 'answer': 'Zirkuläre Abhängigkeiten in Java-Modulen sind verpönt, da sie eine enge Kopplung zwischen Modulen dokumentieren und dies vermieden werden sollte. Das Verbot zirkulärer Abhängigkeiten erfordert eine sorgfältige Planung der Modularisierung, was generell von großem Wert ist.'},
     {'question': 'Warum gestattet Java die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[]?', 'answer': 'Diese Zuweisungskompatibilität ermöglicht eine flexiblere Programmierung, insbesondere in Situationen, in denen der statische Typ der Array-Elemente nicht genau festgelegt ist, aber nach oben beschränkt werden soll, wie im Beispiel mit dem Interface Comparable und der Methode sort. Dieser Kompromiss zwischen statischer und dynamischer Typprüfung bietet Flexibilität beim Programmieren.'},
     {'question': 'Warum ist es sinnvoll, für generische Typen eine liberalere Form der Zuweisungskompatibilität zuzulassen?', 'answer': 'Es ist sinnvoll, weil es so möglich ist, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel kann so eine Methode "sort" mit Objekten verschiedener Instanzen von "ArrayList<E>" aufgerufen werden, also beispielsweise mit Objekten vom Typ "ArrayList<Integer>" und "ArrayList<String>".'},
     {'question': 'Warum haben Array-Variablen in Java immer Referenzsemantik?', 'answer': 'Array-Variablen haben in Java immer Referenzsemantik, weil Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Dies hat den Hintergrund, dass bei der Zuweisung an die Variable f lediglich ein Pointer darauf übergeben wird, anstatt ein ganzes Array als Kopie.'}
     ],
    [{'question': 'Gibt es in C++ Metaklassen?', 'answer': 'Nein, in C++ gibt es keine Metaklassen.'},
     {'question': 'Unterstützt C++ Objektorientierung?', 'answer': 'Ja, C++ unterstützt Objektorientierung, indem es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und Java, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden mit dem Schlüsselwort static in einer Klasse eingeführt.'},
     {'question': 'Was ist der Unterschied zwischen Objekten in SMALLTALK und Objekten in C++?', 'answer': 'In SMALLTALK haben Objekte Identität, während in C++ Objekte Werte sind, die keine Identität haben. Bei Zuweisungen an andere Variablen werden in SMALLTALK Referenzen angefertigt, während in C++ Kopien erstellt werden.'},
     {'question': 'Was ist der Unterschied zwischen "Call by value" und der Übertragung von Pointer-Variablen in C++?', 'answer': 'Im "Call by value" in C++ wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Bei Pointer-Variablen wie dem obigen a wird jedoch nur der Zeiger auf das Objekt übergeben, was dem Verhalten von Java und SMALLTALK entspricht. In Java und SMALLTALK wird jedoch nirgends explizit angegeben, dass es sich um eine Pointer-variable handelt.'},
     {'question': 'Was passiert bei Methodenaufrufen mit Pointer-Variablen in C++?', 'answer': 'Bei Methodenaufrufen mit Pointer-Variablen in C++ wird nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben. Dies entspricht dem Verhalten von Java und SMALLTALK, wobei bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-Variable handelt.'},
     {'question': 'Was passiert bei "Call by value" in C++, wenn Pointer-Variablen übergeben werden?', 'answer': 'Wenn Pointer-Variablen wie dem obigen a übergeben werden, wird nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben.'},
     {'question': 'Was ist der Unterschied zwischen "Call by reference" und der Übergabe von Zeigern in C++?', 'answer': '"Call by reference" ist eine Technik, bei der anstelle einer Kopie des Inhalts der Variablen ein Zeiger auf die Speicherstelle der Variablen übergeben wird. In C++ kann dies durch die Verwendung des Zeigeroperators & an der Aufrufstelle erreicht werden, wobei die formalen Parameter so deklariert werden müssen, dass sie Zeiger auf Zeiger aufnehmen können. Alternativ kann in C++ wie in PASCAL verfahren werden, wobei die Aufrufstelle unverändert bleibt (also ohne & auskommt). Der Unterschied besteht darin, dass bei "Call by reference" die Aufrufstelle geändert werden muss, während bei der Übergabe von Zeigern in C++ die Aufrufstelle unverändert bleibt.'},
     {'question': 'Was ist der Unterschied zwischen Generics in C-Sharp und Java?', 'answer': 'Der Hauptunterschied besteht darin, dass Java die Typparameter grundsätzlich immer wegkompiliert, während C-Sharp im Fall von Werttyp-Parametern jede generische Klasse für jeden verwendeten Typ einmal instanziiert und alternative Implementierungen erzeugt, was zu optimierten Implementierungen führt. Für Referenztypen verhält sich C-Sharp jedoch wie Java. Zudem bleibt die generische Typinformation in C-Sharp zur Laufzeit erhalten und kann per Reflection abgefragt werden.'},
     {'question': 'Wozu dienen Iteratoren in Java?', 'answer': 'Iteratoren in Java dienen dazu, eine einheitliche Iteration über verschiedene Arten von Collections zu ermöglichen, unabhängig davon, ob sie indiziert sind oder nicht. Sie bieten eine standardisierte Möglichkeit, durch die Elemente einer Collection zu iterieren, ohne sich um die interne Implementierung der Collection kümmern zu müssen.'},
     {'question': 'Was bedeutet es, wenn eine Methode in Java kovariant geändert wird?', 'answer': 'Wenn eine Methode in Java kovariant geändert wird, bedeutet das, dass sie den Rückgabetyp in Richtung Subtyp ändern kann. Das heißt, der Rückgabetyp der überschriebenen Methode kann eine Unterklasse des Rückgabetyp der ursprünglichen Methode sein.'},
     {'question': 'Was ist der Unterschied zwischen Überladen und Überschreiben in Java?', 'answer': 'Beim Überladen wird eine neue Methode mit demselben Namen, aber verschiedenen Parametertypen eingeführt, während beim Überschreiben eine bereits existierende Methode neu definiert wird. Diese Unterscheidung ist wichtig für das dynamische Binden.'},
     {'question': 'Was verursacht einen Methodenambiguitätsfehler?', 'answer': 'Ein Methodenambiguitätsfehler wird verursacht, wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind und der Compiler dadurch nicht eindeutig bestimmen kann, welche Methode aufgerufen werden soll.'},
     {'question': 'Wer meldet einen Methodenambiguitätsfehler?', 'answer': 'Der Compiler meldet einen Methodenambiguitätsfehler.'},
     {'question': 'Warum wird C++ als "sofortige Legacy"-Sprache bezeichnet?', 'answer': 'C++ wird als "sofortige Legacy"-Sprache bezeichnet, weil es zahlreiche große Projekte gibt, die bereits in veralteten Dialekten geschrieben wurden und weil die chaotische Syntax von C++ dazu führt, dass sogar Compiler raten müssen, was der Programmierer beabsichtigt hat. Diese Faktoren machen es unwahrscheinlich, dass C++-Code rückentwickelt wird, und somit ist die Wiederverwendbarkeit von C++-Code wichtiger als seine Rückentwicklung.'},
     {'question': 'Was ist der Unterschied zwischen Arrays und Collections in Java?', 'answer': 'In Java werden Arrays und Collections als Zwischenobjekte verwendet, um Zu-n-Beziehungen umzusetzen. Der Hauptunterschied besteht darin, dass Arrays beschränkt sind und keine eigenen Methoden zur Unterstützung des Zugriffs haben, kein dynamisches Wachstum ermöglichen und eine etwas verkorkste Situation beim Subtyping aufweisen. Collections hingegen sind dynamisch und verfügen über eine Vielzahl von Methoden, die das Manipulieren von Objekten erleichtern.'},
     {'question': 'Was ist in Java der Unterschied zwischen Klassen und Interfaces?', 'answer': 'In Java sind Klassen die Blaupausen für Objekte, die definieren, welche Attribute und Methoden ein Objekt besitzt. Interfaces hingegen definieren nur eine Schnittstelle, die von Klassen implementiert werden kann. Sie spezifizieren eine Menge von Methodensignaturen, die eine Klasse implementieren muss, wenn sie das Interface implementiert. Im Gegensatz zu Klassen können Interfaces keine Attribute haben und die Methoden in Interfaces sind immer abstrakt.'},
     {'question': 'Was sind die Vorteile von Interfaces?', 'answer': 'Interfaces ermöglichen es, unterschiedliche Sichten auf ein Objekt zu gewähren, indem sie unterschiedliche Methodenmengen zur Verfügung stellen. Dadurch können beispielsweise auf eine Variable, die mit einem Interfacetyp deklariert wurde, nur die Methoden aufgerufen werden, die der Interfacetyp veröffentlicht. Dies führt zu einer besseren Kapselung und erhöht die Sicherheit, da Laufzeitfehler vermieden werden können.'},
     {'question': 'Was ist der Vorteil von Interfaces in Java?', 'answer': 'Der Vorteil von Interfaces in Java ist, dass sie die Abhängigkeit von der Implementierung verringern, da Klienten auf die Methoden zugreifen können, ohne die tatsächliche Implementierung zu kennen. Dies ermöglicht es, die Klassen zu ändern, ohne die Klienten zu beeinflussen, und erleichtert die Wartung und Erweiterung des Codes.'},
     {'question': 'Was ist der Unterschied zwischen der Verwendung von Interfaces und der Verwendung von Klassen als Typ in Java?', 'answer': 'In Java können Variablendeklarationen entweder mit der Klasse oder mit dem Interface als Typ erfolgen. Wenn man die Klasse als Typ verwendet, hat man syntaktische Unterstützung bei der Benutzung der Variable, aber keine Zugriffsbeschränkung. Wenn man das Interface als Typ verwendet, hat man eine Zugriffsbeschränkung, aber keine syntaktische Unterstützung. Seit Java 8 können in Interfaces auch statische Methoden definiert werden, die neue Instanzen von Klassen, die das Interface implementieren, zurückliefern. Dadurch können die Konstruktoren der Klassen ersetzt und die Klassen hinter dem Interface als Schnittstelle verborgen werden.'},
     {'question': 'Was ermöglichen Interfaces in Java und C-Sharp?', 'answer': 'Interfaces in Java ermöglichen es, die Variablen mit dem Typ der Klasse zu deklarieren, die die Instanz des Objekts bereitstellt, und somit die syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variablen zu behalten. C-Sharp geht noch weiter und ermöglicht es, Klassendefinitionen ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen und somit die Konstruktoren der Klassen zu ersetzen. Seit Java 8 können in Interfaces auch statische Methoden definiert werden, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen.'},
     {'question': 'Was ist der Unterschied zwischen STRONGTALK und Java in Bezug auf Deklarationen?', 'answer': 'In STRONGTALK werden die Typen bei Deklarationen ohne spitze Klammern nachgestellt, während in Java der Typ bei Deklarationen ohne spitze Klammern vorangestellt wird, in Anlehnung an die Tradition von C und C++. Die spitzen Klammern in Zeile 985 kennzeichnen in diesem Zusammenhang lediglich metasyntaktische Variablen.'},
     {'question': 'Welche Vorteile bietet die Typexpansion in C-Sharp für Werttypen?', 'answer': 'Die Typexpansion in C-Sharp ermöglicht es, generische Klassen für Werttypen ohne Boxing/Unboxing zu optimieren. Dies führt zu besserer Leistung und geringerem Overhead, da der JIT-Compiler den Code für verschiedene Typen optimieren kann.'},
     {'question': 'Welche Unterschiede gibt es in Bezug auf die Garbage Collection zwischen C-Sharp und Java?', 'answer': 'In C-Sharp haben Entwickler die Möglichkeit, den Speicherplatz für Objekte, die mit "new" erstellt wurden, manuell freizugeben. Dies kann jedoch zu Speicherlecks führen, wenn Entwickler vergessen, den Speicher freizugeben, oder zu Problemen, wenn auf freigegebene Objekte weiterhin Referenzen vorhanden sind. Im Gegensatz dazu verwendet Java normalerweise eine automatische Garbage Collection, bei der nicht mehr benötigte Objekte automatisch erkannt und freigegeben werden.'},
     {'question': 'Was ist ein Nachteil der Mehrfachvererbung in C++?', 'answer': 'Ein Nachteil der Mehrfachvererbung in C++ ist, dass das Erben nicht selektiv erfolgt, und das Löschen von geerbten Membern nicht möglich ist. Dies führt oft dazu, dass Klassen in viele kleine Teile aufgespalten werden, um unnötigen Ballast zu vermeiden.'},
     {'question': 'Welche Unterschiede gibt es zwischen der Überschreibung von Methoden in C-Sharp und in Java?', 'answer': 'In C-Sharp müssen dynamisch zu bindende Methoden als "virtual" deklariert werden, und überschreibende Methoden müssen mit "override" gekennzeichnet sein. Wenn eine Methode in einer Subklasse neu eingeführt werden soll, wird "new" verwendet. Dies unterscheidet sich von Java, wo Methoden standardmäßig überschrieben werden können, es sei denn, sie sind als "final" deklariert. Diese Unterschiede sollen das sogenannte "Fragile-base-class-Problem" verhindern und die Programmiererin darüber informieren, welche Methoden dynamisch gebunden werden und welche nicht.'},
     {'question': 'Welche Unterschiede gibt es im Typsystem von EIFFEL im Vergleich zu anderen Sprachen?', 'answer': 'Im Gegensatz zu Java besitzt EIFFEL ein einheitliches Typsystem, bei dem keine separaten Referenz- und Werttypen unterschieden werden. EIFFEL unterscheidet auch nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden. Alle Operationen, einschließlich derer auf eingebauten Typen wie Integern, werden als Methoden behandelt.'},
     {'question': 'Welche Vorteile bieten Properties in C-Sharp im Vergleich zu direktem Feldzugriff?', 'answer': 'Properties in C-Sharp bieten den Vorteil, dass sie Feldzugriffe mit zusätzlicher Logik und Validierung versehen können. Sie machen den Code auf der Aufruferinnenseite knapper und besser lesbar, da sie wie Feldzugriffe aussehen und die Details der Implementierung verbergen. Außerdem ermöglichen sie die Simulation von Feldern mit Nur-Lese- oder Nur-Schreib-Zugriff, indem entweder der Getter oder der Setter weggelassen wird.'},
     {'question': 'Welche Unterschiede gibt es zwischen Zuweisungsversuchen in EIFFEL und Downcasts in Java?', 'answer': 'Ein Unterschied besteht darin, dass Zuweisungsversuche in EIFFEL keinen Laufzeitfehler verursachen können, im Gegensatz zu Downcasts in Java. Allerdings kann "void" in einer Variable in EIFFEL zur Laufzeit eine Nullzeiger-Ausnahme auslösen.'},
     {'question': 'Welchen Nachteil hat die Verwendung von Paketen in Java?', 'answer': 'In Java hatte man bis zur Version 8 die Möglichkeit, Klassen in ein Paket zu verfrachten, um die Zusammenarbeit von Klassen zu ermöglichen. Der Nachteil dabei ist, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben, was die Aufteilung der Klassen auf Pakete einschränken kann.'},
     {'question': 'Was unterscheidet Generics in C-Sharp und Generics in Java?', 'answer': 'Obwohl die Oberfläche von C-Sharp Generics der von Java ähnelt, unterscheidet sich der Mechanismus dahinter. C-Sharp instanziiert generische Klassen für Werttypen (wie int oder selbst definierte structs) für jeden verwendeten Typ, während Java Typparameter grundsätzlich immer entfernt (Type Erasure) und nur eine Implementierung erzeugt.'},
     {'question': 'Bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten?', 'answer': 'Ja, in C-Sharp bleibt die generische Typinformation auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.'},
     {'question': 'Was passiert, wenn man versucht, eine explizite Interfaceimplementierung mit einem anderen Zugriffsmodifikator als "public" zu deklarieren?', 'answer': 'In C-Sharp ist es möglich, Methoden von expliziten Interfaceimplementierungen mit Zugriffsmodifikatoren, die nicht "public" sind, von außen aufzurufen. Dies ist jedoch an die explizite Implementierung gebunden und erfordert die Verwendung des richtigen Interfacequalifikators.'},
     {'question': 'Können explizite Interfaceimplementierungen in C-Sharp überschrieben werden?', 'answer': 'Nein, explizite Interfaceimplementierungen können nicht überschrieben werden. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut.'},
     {'question': 'Gibt es in C-Sharp einen Unterschied zwischen Wert- und Referenztypen wie in Java?', 'answer': 'In C-Sharp wird zunächst nicht zwischen Wert- (primitiven) und Referenztypen wie in Java unterschieden. Alle Typen, einschließlich der primitiven Typen, gelten als von Object (genauer: System.Object) abgeleitet.'},
     {'question': 'Bietet C++ eine dynamische Typprüfung wie andere Sprachen?', 'answer': 'Nein, C++ bietet keine eingebaute dynamische Typprüfung.'},
     {'question': 'Gibt es in EIFFEL Zugriffsmodifikatoren wie in Java oder C++?', 'answer': 'Nein, es gibt in EIFFEL keine Zugriffsmodifikatoren wie in Java oder C++. Alle Features sind standardmäßig öffentlich zugänglich.'},
     {'question': 'Warum wird in EIFFEL eine kovariante Redefinition benötigt?', 'answer': 'In EIFFEL wird eine kovariante Redefinition benötigt, um die Unterkunft der jungen Skifahrerinnen nach Geschlechtern getrennt zu organisieren. Dies ermöglicht es, Mädchen und Jungen unterschiedliche Typen für "roommate" zuzuweisen.'},
     {'question': 'Gibt es in EIFFEL explizite Typumwandlungen wie in anderen Sprachen?', 'answer': 'In EIFFEL gibt es keine expliziten Typumwandlungen wie in einigen anderen Sprachen. Die Typumwandlung erfolgt immer in Verbindung mit einer Zuweisung.'},
     {'question': 'Was unterscheidet Werttypen und Referenztypen in EIFFEL?', 'answer': 'Anders als in C-Sharp unterscheidet EIFFEL nicht zwischen Wert- und Referenztypen auf der Ebene von Typkonstruktoren. Stattdessen kann es für jeden Typ sowohl Wertsemantik als auch Referenzsemantik geben.'},
     {'question': 'Wie unterscheidet sich das Typsystem von C-Sharp von dem von Java?', 'answer': 'Das Typsystem von C-Sharp unterscheidet sich von Java in mehreren wesentlichen Punkten, darunter die Art der Unterscheidung von Wert- und Referenztypen, die angebotenen Typkonstruktoren für Wert- und Referenztypen und den Umgang mit Interfaces als Typen.'},
     {'question': 'Was ermöglicht Mehrfachvererbung in C++?', 'answer': 'Mehrfachvererbung in C++ ermöglicht es, eine Klasse von mehreren anderen abzuleiten. Dadurch kann eine Klasse mehrere direkte Supertypen haben, einen pro direkte Superklasse.'},
     {'question': 'Unterstützt EIFFEL Mehrfachvererbung?', 'answer': 'Ja, EIFFEL erlaubt Mehrfachvererbung.'},
     {'question': 'Was ist der Unterschied zwischen der Verwendung von Klassen in C-Sharp und Java?', 'answer': 'Der Unterschied liegt darin, dass in C-Sharp das Verhältnis von Klasse zu Datei lockerer ist als in Java. In C-Sharp können Klassen anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden. Im Gegensatz dazu ist in Java das Verhältnis von Klasse zu Datei strenger, da die Klasse denselben Namen wie ihre Datei haben muss.'},
     {'question': 'Was ist der Unterschied zwischen primitiven und Referenztypen in Java?', 'answer': 'In Java gibt es eine Trennung zwischen primitiven und Referenztypen. Primitiven Typen sind vordefinierte Datentypen, wie zum Beispiel int, float oder boolean. Referenztypen hingegen sind Objekte, die in der Sprache definiert werden. Die Operationen auf primitiven Typen sind fest vorgegeben, während alle anderen Operationen als Methoden in Klassen definiert werden müssen. Primitiven Typen besitzen weder Identität noch Zustand, im Gegensatz zu Referenztypen.'},
     {'question': 'Was ist der Unterschied zwischen Prozeduren und Funktionen in Java?', 'answer': 'Der Unterschied zwischen Prozeduren und Funktionen in Java besteht darin, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp "void" deklarieren, während Funktionen einen Rückgabewert haben.'},
     {'question': 'Was regeln die Zugriffsmodifikatoren in Java?', 'answer': 'Die Zugriffsmodifikatoren in Java regeln die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) in Abhängigkeit von der Position, an der sie verwendet werden. Es gibt vier Zugriffsmodifikatoren: private, protected, public und "Package local". Die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, ist konzeptionell jedoch nicht mit dem Typ selbst verbunden, sondern vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.'},
     {'question': 'Was ist der Vorteil der Verknüpfung von Typ und Zugriffsbeschränkung in Java?', 'answer': 'Der Vorteil der Verknüpfung von Typ und Zugriffsbeschränkung in Java ist die sprachliche Knappheit, da Typ- und Schnittstellendeklaration in einem angegeben werden können.'},
     {'question': 'Was ist der Unterschied zwischen Klassennamen und Klassenliteralen in Java?', 'answer': 'In Java sind Klassennamen und Klassenliteralen zwei verschiedene Dinge. Klassennamen werden direkt verwendet, zum Beispiel als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie "instanceof". Klassenliteralen hingegen sind Objekte, die die Metaklasse einer Klasse repräsentieren. Sie werden mit dem Schlüsselwort "Class" und dem Klassennamen in spitzen Klammern erzeugt. Die Unterscheidung von Klassennamen und Klassenliteralen in Java ist nicht sehr intuitiv und wird eher selten verwendet.'},
     {'question': 'Was bedeutet es, wenn eine Klasse in Java als abstrakt deklariert wird?', 'answer': 'Wenn eine Klasse in Java als abstrakt deklariert wird, bedeutet das, dass sie nicht instanziiert werden kann, d.h. es können keine Objekte dieser Klasse erzeugt werden. Diese Klasse dient lediglich als Basisklasse für andere Klassen und enthält in der Regel eine oder mehrere abstrakte Methoden, die von den Unterklassen implementiert werden müssen.'},
     {'question': 'Was passiert, wenn man in Java eine abstrakte Klasse ableitet und die abstrakten Methoden nicht implementiert?', 'answer': 'Wenn man in Java eine abstrakte Klasse ableitet und die abstrakten Methoden nicht implementiert, erhält man vom Compiler eine entsprechende Aufforderung.'},
     {'question': 'Was besagt die goldene Regel der objektorientierten Programmierung bezüglich der Deklaration von Klassen als abstrakt oder final?', 'answer': 'Die goldene Regel der objektorientierten Programmierung besagt, dass man alle Klassen entweder als abstrakt oder als final deklarieren sollte. Dies fördert das Prinzip der abstrakten Generalisierung und vermeidet die Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien.'},
     {'question': 'Was ist der Unterschied zwischen einer Klasse und einem Interface in Java?', 'answer': 'Ein Interface in Java ist ein eigenständiges Konstrukt, das eine öffentliche Schnittstelle definiert, während eine Klasse sowohl eine öffentliche Schnittstelle als auch eine Implementierung der Methoden bereitstellt. Ein Interface kann nur Methoden deklarieren, aber keine Implementierungen bereitstellen. Eine Klasse hingegen kann eine Implementierung für die Methoden bereitstellen, die in einem Interface deklariert sind. Ein Interface kann von mehreren Klassen implementiert werden, während eine Klasse nur von einer Superklasse erben kann.'},
     {'question': 'Was ist der Unterschied zwischen Mehrfachvererbung und Mehrfach-Subtyping in Java?', 'answer': 'Mehrfachvererbung bezieht sich auf die Fähigkeit einer Klasse, Eigenschaften und Methoden von mehr als einer Superklasse zu erben, während Mehrfach-Subtyping darauf beruht, dass eine Klasse mehr als einem Interface gleichzeitig implementieren kann. Im Gegensatz zur Mehrfachvererbung wird bei der Implementierung eines Interface nichts vererbt, sondern es wird eine Art Mehrfach-Subtyping erreicht, das auch nützlich sein kann.'},
     {'question': 'Was unterscheidet Konstruktoren in Java im Vergleich zu SMALLTALK?', 'answer': 'Im Gegensatz zu SMALLTALK sind Konstruktoren in Java keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Sie verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne können Konstruktoren als Instanzmethoden betrachtet werden, die auf der neu erzeugten Instanz aufgerufen werden.'},
     {'question': 'Was ist der Unterschied zwischen Konstruktoren und Klassenmethoden in Java?', 'answer': 'Der Unterschied zwischen Konstruktoren und Klassenmethoden in Java ist, dass Konstruktoren auf der Klasse aufgerufen werden und dazu dienen, ein neues Objekt zu initialisieren, während Klassenmethoden ebenfalls auf der Klasse aufgerufen werden, aber kein neues Objekt erstellen.'},
     {'question': 'Was passiert, wenn kein Konstruktor in Java definiert wird?', 'answer': 'Wenn kein Konstruktor in Java definiert wird, verwendet Java standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse.'},
     {'question': 'Was passiert, wenn eine Exception in Java geworfen wird?', 'answer': 'Wenn eine Exception geworfen wird, wird der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist. Der Codeabschnitt, in dem die Exception auftreten kann, muss in einen Try-Catch-Block eingefasst sein.'},
     {'question': 'Was ermöglicht die Throw-Anweisung in Java?', 'answer': 'Die Throw-Anweisung in Java ermöglicht es, Ausnahmesituationen vom Programm selbst zu erkennen und eine entsprechende Exception-Klasse zu instanziieren, um die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.'},
     {'question': 'Was ist der Unterschied zwischen Exceptions und Errors in Java?', 'answer': 'Exceptions und Errors sind beides Unterklassen von Throwable, aber Errors sollten nicht abgefangen werden und führen zu einem sofortigen Programmabbruch. Exceptions sind checked und müssen abgefangen werden, während Errors unchecked sind und nicht abgefangen werden sollten. Auslassungszeichen in Java werden zur Formulierung einer Invariante verwendet und wurden früher zur Emulation der mittlerweile vorhandenen Assert-Anweisung verwendet. Auch heute sollte man Errors eigentlich nur während der Testphase eines Programms einsetzen.'},
     {'question': 'Was ist der Unterschied zwischen Paketen und Modulen in Java?', 'answer': 'Der Unterschied zwischen Paketen und Modulen besteht darin, dass Module neben einer öffentlichen Schnittstelle auch eine private Schnittstelle haben, die für andere Module nicht sichtbar ist, wodurch die Kapselung von Details gewährleistet wird.'},
     {'question': 'Was wird durch die Moduldefinition in Java erzwungen?', 'answer': 'Die Einhaltung der Schnittstellenspezifikationen wird sowohl zur Übersetzungszeit als auch zur Laufzeit erzwungen. Zudem wird der reflektive Zugriff auf Programmelemente kontrolliert, was die Sicherheit von Java-Programmen erhöht.'},
     {'question': 'Was ermöglicht das Stream-Framework von Java?', 'answer': 'Das Stream-Framework von Java ermöglicht eine besonders effiziente Ausführung für viele Pipelines, indem jedes Element einer Datenquelle nur einmal angefragt wird und die interne Speicherung von Zwischenergebnissen automatisch gering gehalten wird. Es kann auch bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt.'},
     {'question': 'Welche Vorteile bietet die Verwendung von Interfaces in Java?', 'answer': 'Die Verwendung von Interfaces in Java ermöglicht die Bereitstellung verschiedener Sichten auf Objekte, die von Klassen implementiert werden. Dies kann dazu beitragen, den Zugriff auf die Methoden eines Objekts zu beschränken oder die Austauschbarkeit von Klassen zu verbessern.'},
     {'question': 'Was passiert, wenn der Bindungsalgorithmus in Java zu mehreren Methoden führt, die die Bedingungen erfüllen?', 'answer': 'Wenn der Bindungsalgorithmus zu mehreren Methoden führt, die die Bedingungen erfüllen, meldet der Compiler einen Methodenambiguitätsfehler, da die aufgerufene Methode nicht eindeutig bestimmt werden kann. Dieser Fehler wird durch Methodenaufrufe, nicht durch Methodendeklarationen, verursacht.'},
     {'question': 'In der Java-Programmierung gibt es zwei Arten von Zwischenobjekten für die Umsetzung von Zu-n-Beziehungen. Welche sind das?', 'answer': 'Arrays und Collections.'},
     {'question': 'Was unterscheidet Prozeduren und Funktionen in Java?', 'answer': 'In Java können Methoden in Prozeduren und Funktionen unterteilt werden. Der einzige Unterschied besteht darin, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp "void" deklarieren.'},
     {'question': 'Wozu dienen Pakete in Java?', 'answer': 'Pakete in Java dienen der Sammlung von Klassen und dienen gleichzeitig als Namensräume für diese. Sie ermöglichen die Organisation von Klassen und bieten zugleich laxere Zugriffsbeschränkungen für Klassen innerhalb desselben Pakets.'},
     {'question': 'Warum ist es eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren?', 'answer': 'Es ist eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren, um das Prinzip der abstrakten Generalisierung zu fördern und Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien zu vermeiden.'},
     {'question': 'Kann eine Klasse mehrere Interfaces gleichzeitig implementieren?', 'answer': 'Ja, eine Klasse kann mehrere Interfaces gleichzeitig implementieren, indem die entsprechenden Interface-Namen durch Kommata getrennt angegeben werden. In diesem Fall müssen die Methoden in der Klasse zumindest als abstrakt deklariert werden.'},
     {'question': 'Ist Java eine Sprache mit einem strengen Typsystem?', 'answer': 'Ja, Java ist eine Sprache mit einem strengen Typsystem, was bedeutet, dass alle Typfehler entweder während der Übersetzung durch den Compiler oder während der Laufzeit erkannt werden, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung, bei der eine Typinvariante verletzt wird.'},
     {'question': 'Werden Konstruktoren in Java vererbt?', 'answer': 'Nein, Konstruktoren werden in Java nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse automatisch aufgerufen, wenn eine Instanz einer ihrer Subklassen erzeugt wird.'},
     {'question': 'Was unterscheidet Checked Exceptions und Unchecked Exceptions in Java?', 'answer': 'Der Hauptunterschied besteht darin, dass Checked Exceptions eine explizite Deklaration im Methodenkopf oder eine Behandlung innerhalb der Methode erfordern, während Unchecked Exceptions dies nicht tun. Checked Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind, während Unchecked Exceptions von Exception-Klassen abgeleitet werden, die von RuntimeException abgeleitet sind. Checked Exceptions sollen den Programmierer auf mögliche Ausnahmesituationen hinweisen, während Unchecked Exceptions oft schwer vorhersehbar sind und überall auftreten können.'},
     {'question': 'Warum wurden Typ-Wildcards (Wildcard-Typen) in Java eingeführt?', 'answer': 'Typ-Wildcards wurden eingeführt, um eine flexiblere Form der Zuweisungskompatibilität für generische Typen zu ermöglichen, insbesondere bei der Verwendung von Collections mit unterschiedlichen Typparametern.'},
     {'question': 'Warum sollten Klassenbibliotheken unabhängig von der Sprachdefinition sein?', 'answer': 'Klassenbibliotheken sollten unabhängig von der Sprachdefinition sein und austauschbar sein, um die Flexibilität und Portabilität von Software zu gewährleisten. Wenn Klassenbibliotheken eng an die Sprachdefinition gebunden sind, könnte dies dazu führen, dass eine Software nur auf einer bestimmten Plattform oder mit einer bestimmten Sprachversion funktioniert. Durch die Unabhängigkeit von der Sprachdefinition können Klassenbibliotheken in verschiedenen Umgebungen verwendet werden und die Softwareentwicklung erleichtern.'},
     {'question': 'Warum sind "static"-Felder in Java keine Konstanten?', 'answer': '"static"-Felder in Java sind nicht automatisch Konstanten, da sie mehrfach geändert werden können. Konstanten werden in Java stattdessen durch das Schlüsselwort "final" gekennzeichnet.'},
     {'question': 'Sind zirkuläre Abhängigkeiten zwischen Klassen in Java erlaubt?', 'answer': 'Ja, zirkuläre Abhängigkeiten zwischen Klassen sind in Java zunächst erlaubt. Dies bedeutet, dass sich zwei Klassen wechselseitig importieren können. Jedoch wird dies in der Softwareentwicklung vermieden, da wechselseitige Abhängigkeiten eine enge Kopplung zwischen Modulen anzeigen, die vermieden werden sollte. Für Java-Module sind zirkuläre Abhängigkeiten jedoch verboten.'},
     {'question': 'Wo können Typvariablen (formale Typparameter) in Java verwendet werden?', 'answer': 'Typvariablen können sowohl in Typdefinitionen als auch in Methodendefinitionen in Java verwendet werden.'},
     {'question': 'Was bewirkt die Break-Anweisung in Java?', 'answer': 'Die Break-Anweisung in Java bewirkt, dass eine Schleife oder ein Switch-Statement sofort verlassen wird. Sie kann optional mit einem Label versehen werden, um eine äußere Schleife oder ein äußeres Switch-Statement zu verlassen.'},
     {'question': 'Was unterscheidet eine Wertzuweisung und eine Zuweisung von Referenzen in Java?', 'answer': 'Bei der Wertzuweisung wird der tatsächliche Wert einer Variable kopiert, während bei der Zuweisung von Referenzen nur die Referenz auf das Objekt kopiert wird.'},
     {'question': 'Gibt es in Java "Call by reference"?', 'answer': 'Nein, in Java gibt es kein "Call by reference", sondern nur "Call by value". Auch wenn Variablen Referenztypen haben, wird bei Methodenaufrufen immer eine Kopie des Zeigers an die formalen Parameter übergeben.'},
     {'question': 'Ist es in Java möglich, generische Variablen zu deklarieren?', 'answer': 'Ja, es ist in Java möglich, generische Variablen zu deklarieren.'},
     {'question': 'Was passiert, wenn eine Variable mit einem Typ-Wildcard deklariert wird?', 'answer': 'Wenn eine Variable mit einem Typ-Wildcard deklariert wird, kann ihr eine Instanz eines beliebigen konkreten Typs zugewiesen werden, der den Anforderungen der Wildcard entspricht.'},
     {'question': 'Führen generische Variablendeklarationen einen neuen Typ ein?', 'answer': 'Nein, generische Variablendeklarationen führen keinen neuen Typ ein. Der durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzte Typ ist ein konkreter Typ.'},
     {'question': 'Was ist der Unterschied zwischen der Verwendung von Zusicherungen in EIFFEL und Java?', 'answer': 'In EIFFEL sind Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen integriert, während in Java die Assert-Anweisung verwendet wird, die es erlaubt, Zusicherungen zur Laufzeit auszuwerten, aber keine von der Sprachdefinition vorgesehenen Orte für ihre Platzierung gibt.'},
     {'question': 'Was passiert mit Zusicherungen bei der Redefinition einer Methode in EIFFEL?', 'answer': 'Bei der Redefinition einer Methode in EIFFEL dürfen die Vorbedingungen nur abgeschwächt und die Nachbedingungen nur verschärft werden. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.'},
     {'question': 'Was ist der Unterschied zwischen Vor- und Nachbedingungen in EIFFEL?', 'answer': 'In EIFFEL sind Vorbedingungen (preconditions) Bedingungen, die vor der Ausführung einer Methode erfüllt sein müssen, während Nachbedingungen (postconditions) Bedingungen sind, die nach der Ausführung einer Methode erfüllt sein müssen. Vorbedingungen werden verwendet, um sicherzustellen, dass die Methode nur dann aufgerufen wird, wenn die Voraussetzungen erfüllt sind, während Nachbedingungen sicherstellen, dass die Methode das gewünschte Ergebnis liefert.'},
     {'question': 'Was ermöglicht EIFFEL im Vergleich zu anderen Typsystemen?', 'answer': 'EIFFEL ermöglicht es, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können. Im Gegensatz zu anderen Typsystemen, die sich jeweils auf die möglichen Werte einer Variablen beziehen und dabei voneinander und von der Zeit unabhängig bleiben.'},
     {'question': 'Was ist der Unterschied zwischen Wert- und Referenztypen in C-Sharp?', 'answer': 'In C-Sharp werden primitiven Typen als Werttypen implementiert, die auf dem Stack abgelegt und bei der Übergabe an eine Methode kopiert werden. Referenztypen werden dagegen auf dem Heap abgelegt und bei der Übergabe an eine Methode nur der Verweis kopiert.'},
     {'question': 'Was ist der Unterschied zwischen Use-site-Variance und Declaration-site-Variance?', 'answer': 'Use-site-Variance bedeutet, dass Wildcards bei der Verwendung an der Stelle definiert werden, an der sie benötigt werden, während Declaration-site-Variance bedeutet, dass Wildcards an der Stelle definiert werden, an der sie erklärt werden, wie beispielsweise in C-Sharp.'},
     {'question': 'Was erlauben per extends beschränkte Typ-Wildcards?', 'answer': 'Per extends beschränkte Typ-Wildcards erlauben eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt).'},
     {'question': 'Was ist der Unterschied zwischen Abfragen und Befehlen in EIFFEL?', 'answer': 'In EIFFEL werden Methoden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.'},
     {'question': 'Ist EIFFEL eine objektorientierte Programmiersprache?', 'answer': 'Ja, EIFFEL ist eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist.'},
     {'question': 'Was ist der Unterschied zwischen Mehrfachvererbung und Einfachvererbung?', 'answer': 'Im Gegensatz zur Einfachvererbung, bei der eine Klasse nur eine Superklasse haben kann, erlaubt Mehrfachvererbung, dass eine Klasse von mehreren Superklassen erbt.'},
     {'question': 'Was ist der Unterschied zwischen dem Überschreiben von Methoden in Java und C-Sharp?', 'answer': 'In Java können alle Methoden überschrieben werden, während in C-Sharp dynamisch zu bindende Methoden unbedingt als solche zu deklarieren sind und eine überschreibende Methode mit dem Schlüsselwort "override" deklariert werden muss. Wenn eine Methode gleicher Signatur in einer Subklasse neu eingeführt werden soll, muss dies durch Verwendung des Schlüsselworts "new" bekanntgegeben werden. Diese Deklaration vermindert die Zahl der dynamischen Bindungen in einem Programm und markiert alle Stellen im Programm, an denen das sog. "Fragile-base-class-Problem" auftreten kann.'},
     {'question': 'Was ist der Unterschied zwischen Members und Konstruktoren in Java?', 'answer': 'Members einer Klasse sind Instanzvariablen und Instanzmethoden, während Konstruktoren keine Members sind.'},
     {'question': 'Was ist der Unterschied zwischen "static" und "final" in Java?', 'answer': '"static" deklarierte Felder sind nicht konstant, während "final" dazu verwendet wird, Variablen als Konstanten zu deklarieren. "final" bedeutet, dass einer Variablen genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in Smalltalk konstante Methoden für Konstanten. "final" in Java verhindert auch, dass eine Methode in Subklassen überschrieben wird.'},
     {'question': 'Was unterscheidet EIFFEL von SMALLTALK und C-Sharp in Bezug auf das Typsystem?', 'answer': 'EIFFEL hat ein einheitliches Typsystem, das keine separate Unterscheidung zwischen Referenz- und Werttypen macht, im Gegensatz zu C-Sharp. Im Gegensatz zu SMALLTALK, das sich auf Referenztypen festgelegt hat, unterstützt EIFFEL auch Werttypen.'},
     {'question': 'Wozu können Typprüfungen in EIFFEL notwendig sein?', 'answer': 'Typprüfungen können in EIFFEL notwendig sein, wenn man in einen Container Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt.'},
     {'question': 'Was ist der Unterschied zwischen dem Zuweisungsversuch in EIFFEL und dem Downcast in Java?', 'answer': 'Im Gegensatz zum Zuweisungsversuch in EIFFEL kann der Downcast in Java einen Laufzeitfehler verursachen.'},
     {'question': 'Was ist der Unterschied zwischen expliziten Typumwandlungen in EIFFEL und Java?', 'answer': 'In EIFFEL gibt es keine expliziten Typumwandlungen, während es in Java welche gibt. In EIFFEL kann der Zuweisungsversuch die Funktion einer Typumwandlung erfüllen, während er in Java einen Laufzeitfehler verursachen kann. Allerdings kann der Zuweisungsversuch in EIFFEL auch einen Typumwandlungsfehler verursachen, der jedoch als Nullzeiger-Ausnahme behandelt wird.'},
     {'question': 'Wofür wird die Typumwandlung in EIFFEL verwendet?', 'answer': 'In EIFFEL wird die Typumwandlung für das Binden von Aufrufen kovariant redefinierter Methoden verwendet. Da EIFFEL polymorphe CAT-Calls verbieten muss, diese aber gleichwohl notwendig sein können, hat man nur die Möglichkeit, die dynamische Bindung programmatisch zu emulieren. Und dafür braucht man Zuweisungsversuche.'},
     {'question': 'Was ist der Unterschied zwischen direkter und indirekter Erweiterung in EIFFEL?', 'answer': 'Eine direkte Erweiterung bedeutet, dass U direkt von T erbt, während eine indirekte Erweiterung bedeutet, dass es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist.'},
     {'question': 'Was ist der Unterschied zwischen expanded Variablen und normalen Variablen in EIFFEL?', 'answer': 'In EIFFEL können Instanzen einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) haben. Expanded Variablen sind Komponentenobjekte, während normale Variablen freie Objekte sind. Dieses Feature ist in C-Sharp (zumindest nicht im Safe mode) nicht verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen.'},
     {'question': 'Was ist der Unterschied zwischen Komponentenobjekten und freien Objekten in EIFFEL?', 'answer': 'In EIFFEL können Instanzen einer Klasse fallweise Komponentenobjekte und freie Objekte haben. Komponentenobjekte werden über expanded Variablen definiert und sind in anderen Objekten enthalten, während freie Objekte über normale Variablen definiert werden und nirgends enthalten sind.'},
     {'question': 'Wofür werden Tupel in EIFFEL verwendet?', 'answer': 'Tupel werden in EIFFEL als eine Möglichkeit verwendet, mehrere Objekte ohne großen Aufwand zu gruppieren, insbesondere ohne die Notwendigkeit, eine Klasse zu definieren. Sie sind besonders interessant, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugeordnet wird. Dies ist beispielsweise bei Methoden der Fall, die mehrere Werte anstelle eines einzigen Wertes zurückgeben sollen.'},
     {'question': 'Was bewirkt die Synchronized-Anweisung in Java?', 'answer': 'Die Synchronized-Anweisung in Java sorgt dafür, dass der durch den Block bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem der Ausdruck ausgewertet wird, verbundene Lock dies zulässt.'},
     {'question': 'Wozu werden Assert-Anweisungen in Java verwendet?', 'answer': 'Assert-Anweisungen in Java werden verwendet, um sicherzustellen, dass bestimmte Bedingungen während der Laufzeit erfüllt sind. Dabei werden die Bedingungen in Form von Statements formuliert, die zur Laufzeit ausgeführt werden. Assert-Anweisungen beziehen sich häufig auf Methoden des Programms, für die die Invarianten angegeben werden sollen. Allerdings können diese Methoden den Zustand des Programms ändern, weshalb man einer Zusicherung mit assert nicht ansehen kann, ob sie seiteneffektfrei ist.'},
     {'question': 'Was ist der Unterschied zwischen der equals-Methode und dem Test auf Identität in Java?', 'answer': 'Die equals-Methode testet, ob zwei Objekte den gleichen Wert repräsentieren, während der Test auf Identität (==) prüft, ob zwei Objekte identisch sind.'},
     {'question': 'Wofür wird das Friends-Konzept in C++ verwendet?', 'answer': 'Das Friends-Konzept wird verwendet, um die Schnittstelle von kooperierenden Klassen relativ zu anderen Klassen definieren zu können, indem es den Zugriff auf private und protected Elemente erlaubt, die anderen Klassen verborgen bleiben sollen.'},
     {'question': 'Was ist der Unterschied zwischen lokalen Variablen und Instanzvariablen in Java?', 'answer': 'Lokale Variablen sind Variablen, die innerhalb einer Methode deklariert werden und nur innerhalb dieser Methode sichtbar sind. Instanzvariablen sind Variablen, die in einer Klasse deklariert werden und für alle Instanzen dieser Klasse gültig sind. Instanzvariablen werden initialisiert, wenn ein Objekt erzeugt wird und behalten ihren Wert zwischen verschiedenen Methodenaufrufen bei.'},
     {'question': 'Was ist der Unterschied zwischen einem Objekt und einem Literal in Java?', 'answer': 'Der Unterschied zwischen einem Objekt und einem Literal in Java ist, dass ein Objekt eine Instanz einer Klasse ist, die zur Laufzeit erzeugt wird, während ein Literal ein Wert ist, der direkt in den Quellcode eingebettet ist und zur Laufzeit als konkreter Wert zur Verfügung gestellt wird. Objekte haben einen Klassentyp, während Literale einen primitiven Typ haben.'},
     {'question': 'Was ist der Unterschied zwischen Typen mit Wertsemantik und Typen mit Referenzsemantik in C++?', 'answer': 'In C++ haben Typen mit Wertsemantik eine eigene Kopie im Speicher, während Typen mit Referenzsemantik (Zeiger) nur einen Speicherort im Speicher referenzieren. Das bedeutet, dass bei der Zuweisung von Werten mit Wertsemantik eine Kopie erstellt wird, während bei der Zuweisung von Werten mit Referenzsemantik nur der Speicherort kopiert wird.'},
     {'question': 'Was erlaubt C++ und unterscheidet sich dadurch von vielen anderen objektorientierten Programmiersprachen?', 'answer': 'C++ erlaubt Mehrfachvererbung, das heißt, eine Klasse kann von mehreren anderen Klassen abgeleitet werden. Diese Funktionalität unterscheidet C++ von den zuvor diskutierten Sprachen, die nur die Einfachvererbung unterstützen.'},
     {'question': 'Ist C-Sharp eine typsichere Sprache?', 'answer': 'Ja, C-Sharp ist eine typsichere Sprache, die eine strikte Typprüfung durchführt. Allerdings hat das Typsystem von C-Sharp auch eine Laufzeitkomponente, da nicht alles zur Übersetzungszeit geschehen kann.'},
     {'question': 'Was ist der Unterschied zwischen C-Sharp und C++ in Bezug auf Typsicherheit?', 'answer': 'Im Gegensatz zu C++ ist C-Sharp eine typsichere Sprache, die eine strikte Typprüfung durchführt. Diese Typprüfung erfolgt sowohl zur Übersetzungszeit als auch zur Laufzeit. In C++ hingegen wird keine Laufzeitprüfung durchgeführt, was zu potenziellen Sicherheitsrisiken führen kann.'},
     {'question': 'Was passiert bei der Verwendung von Casts in C++?', 'answer': 'Bei der Verwendung von Casts in C++ wird der Compiler gezwungen, den Ausdruck auf der linken Seite des Casts als Typ zu interpretieren, der auf der rechten Seite angegeben ist, wodurch die statische Typisierung umgangen wird.'},
     {'question': 'Welche Gründe gibt es, auf die statische Typprüfung zugunsten einer dynamischen Typprüfung zu verzichten?', 'answer': 'Der Verzicht auf die statische Typprüfung zugunsten einer dynamischen Typprüfung wird vorgenommen, um die Möglichkeit der statischen Typprüfung zu verhindern, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung melden würde. Dies geschieht, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies vom Compiler garantiert werden könnte.'},
     {'question': 'Ist das Überladen in EIFFEL erlaubt?', 'answer': 'In EIFFEL ist es nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt.'},
     {'question': 'Was unterstützt das Typsystem von EIFFEL?', 'answer': 'Ein herausragendes Merkmal des Typsystems von EIFFEL ist die Unterstützung von Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden), sowie kovariante Redefinitionen, die durch "verankerte Typen" ermöglicht werden.'},
     {'question': 'Ist es in Eiffel erlaubt, das zwei Methoden den gleichen Namen haben?', 'answer': 'In Eiffel ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben, solange diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen oder die Methoden gleiche oder kovariant redefinierte Parameter haben.'},
     {'question': 'Kennen Sie vordefinierte Type der Java-Sprachdefinition?', 'answer': 'In der Java-Sprachdefinition sind folgende vordefinierte Typen festgelegt: Object, String, Throwable, Error, Exception, RuntimeException und Thread.'},
     {'question': 'Wofür wird C++ eingesetzt?', 'answer': 'C++ ist ein objektorientierter Nachfolger von C, der einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung ermöglicht. Es wird hauptsächlich für maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen eingesetzt, bei denen extreme Speicher- und Recheneffizienz oft oberste Kriterien sind.'}
     ]
]
KE6_questions = [
    [{'question': 'Was ist das Ziel von "guter Programmierung"?', 'answer': 'Das Ziel von "guter Programmierung" ist es, die Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf zu minimieren. Eine gute Programmiererin schreibt ihre Programme so, dass die statische Struktur des Programms möglichst viele Rückschlüsse auf seinen dynamischen Ablauf zulässt.'},
     {'question': 'Was ist das Lokalitätsprinzip in Programmen?', 'answer': 'Das Lokalitätsprinzip in Programmen besagt, dass Dinge, die zusammengehören, auch im Programmtext beieinander stehen sollten. Dadurch wird die Lesbarkeit und Nachvollziehbarkeit des Programms verbessert.'},
     {'question': 'Was ist die Auswirkung von Goto-Anweisungen auf den Programmfluss?', 'answer': 'Goto-Anweisungen können den Programmfluss beeinflussen, indem sie den Kontext verlassen und zu einer anderen Stelle im Programm springen. Das Ziel des Sprungs ist nicht immer eindeutig aus dem Kontext erkennbar, und es kann unklar sein, welche Anweisungen vorher ausgeführt wurden.'},
     {'question': 'Was ist strukturierte Programmierung?', 'answer': 'Die strukturierte Programmierung ist eine Programmiermethode, die neben der Sequenz von Anweisungen, die Verzweigung, die Wiederholung und den Unterprogrammaufruf vorsieht. Sie behält das Lokalitätsprinzip bei, solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife ausdehnt.'},
     {'question': 'Was sind die Kriterien für die Aufteilung in Unterprogramme bei der objektorientierten Programmierung?', 'answer': 'Bei der objektorientierten Programmierung sind die Kriterien für die Aufteilung in Unterprogramme das Vermeiden von doppeltem Code, die stufenweise Verfeinerung, das Zuordnen jeder Teilfunktion der Klasse, deren Daten sie manipuliert, und die Disziplin, die Implementierung größerer Funktionen zu verteilen.'},
     {'question': 'Was ist ein Entwurfsprinzip in der Programmierung?', 'answer': 'Ein Entwurfsprinzip in der Programmierung ist ein Grundsatz, der bei der Gestaltung von Software berücksichtigt wird. Im Gegensatz zu einem Programmierstil ist ein Entwurfsprinzip eher allgemein und weniger willkürlich. Es kann die Gestaltung von Software in Hinsicht auf Funktionalität, Wartbarkeit, Lesbarkeit und Effizienz beeinflussen.'},
     {'question': 'Was ist die wichtigste Programmierrichtlinie zur Vererbung?', 'answer': 'Die wichtigste Programmierrichtlinie zur Vererbung ist: Mache alle Superklassen abstrakt.'},
     {'question': 'Was sind Formatierungskonventionen?', 'answer': 'Formatierungskonventionen sind Vereinbarungen über die Formatierung von Quellcode, die neben Namenskonventionen dazu dienen, den Code lesbarer zu gestalten. Sie regeln Dinge wie Einrückungen und an welchen Stellen Zeilenumbrüche, Leerzeilen und Leerzeichen einzufügen sind.'},
     {'question': 'Was sind Coding Conventions?', 'answer': 'Coding Conventions sind Vereinbarungen über die Formatierung von Quellcode, die neben Namenskonventionen und anderen Richtlinien dazu dienen, den Code lesbarer zu gestalten. Sie regeln Dinge wie Einrückungen, Zeilenumbrüche, Leerzeilen und Leerzeichen.'},
     {'question': 'Was ist Substituierbarkeit?', 'answer': 'Substituierbarkeit in der Programmierung ist ein Begriff, der unabhängig von der Typkonformität betrachtet wird. Er bezieht sich darauf, ob eine Zuweisung automatisch und ohne Probleme durch den Compiler beantwortet werden kann.'},
     {'question': 'Was ist die strengste Auslegung des Begriffs der Substituierbarkeit?', 'answer': 'In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden.'},
     {'question': 'Was ist die Frage der Substituierbarkeit?', 'answer': 'Die Frage der Substituierbarkeit bezieht sich darauf, ob ein Objekt durch ein anderes Objekt ersetzt werden kann, ohne dass sich das Verhalten des Gesamtsystems ändert. Diese Frage wird interessant, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. Diese Abweichungen können sowohl funktional als auch nichtfunktional sein.'},
     {'question': 'Was ist funktionale Äquivalenz?', 'answer': 'Funktionale Äquivalenz bedeutet, dass zwei Objekte, die zu verschiedenen Typen gehören, aber innerhalb derselben Gruppe sind, die gleichen Funktionen erfüllen und die gleichen Methoden aufrufen können. Sie können sich jedoch im Aussehen und Verhalten unterscheiden.'},
     {'question': 'Was ist das Problem der schlechten Tracebarkeit?', 'answer': 'Das Problem der schlechten Tracebarkeit entsteht durch den dynamischen Programmablauf. Die Goto-Anweisung erlaubt Sprünge von beliebigen Stellen eines Programms zu anderen Stellen und bricht dabei das Lokalitätsprinzip von Programmen, bei dem zusammengehörende Anweisungen im Programmtext nahe beieinander stehen. Dies führte zu einer Unübersichtlichkeit im Programmtext und erschwerte das Verstehen und Debuggen von Programmen.'},
     {'question': 'Welche Probleme ergeben sich bei der Verwendung dynamisch gebundener Unterprogrammaufrufe in der objektorientierten Programmierung?', 'answer': 'Bei der Verwendung dynamisch gebundener Unterprogrammaufrufe in der objektorientierten Programmierung ergibt sich das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht. Dies führt zu einer Unsicherheit darüber, welcher Code tatsächlich ausgeführt wird, insbesondere beim Tracen oder Debuggen von Programmen.'},
     {'question': 'Welches Konzept bieten Programmiersprachen wie Java und C-Sharp, um die doppelte Sichtweise auf Typen zu unterstützen?', 'answer': 'Programmiersprachen wie Java und C-Sharp bieten das Konzept von "Interfaces als Typen" an, mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. Dies ermöglicht es den Nutzerinnen, ihre eigenen Anforderungen als Typen zu definieren. Allerdings wird diese Möglichkeit in der Praxis oft nicht genutzt, um Anwenderinnen ihre eigenen Typen definieren zu lassen. Es wird jedoch darauf hingewiesen, dass dies in Zukunft anders gehandhabt werden könnte.'},
     {'question': 'Was ist das Fragile-Base-Class-Problem?', 'answer': 'Das Fragile-Base-Class-Problem bezieht sich auf eine Gruppe von Problemen in der Vererbung von Klassen. Wenn zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, können Änderungen an der Basisklasse zu unerwarteten und unerwünschten Auswirkungen in der abgeleiteten Klasse führen.'},
     {'question': 'Welche Herausforderungen ergeben sich aus dem Fragile-Base-Class-Problem in verteilten Objektsystemen?', 'answer': 'In verteilten Objektsystemen wird das Problem komplexer, da Änderungen an einer Komponente unerwartete Auswirkungen auf verwandte Komponenten haben können. Die Schnittstellen und Beziehungen zwischen Komponenten müssen klar und stabil sein, um unerwartetes Verhalten zu verhindern. Das Problem wird noch schwerwiegender, wenn verschiedene Anbieter Komponenten entwickeln, da Änderungen an einer Komponente die Funktionalität anderer Komponenten beeinträchtigen könnten.'},
     {'question': 'Welche Ansätze werden zur Bewältigung des Fragile-Base-Class-Problems vorgeschlagen?', 'answer': 'Ein Ansatz besteht darin, explizite Vererbungsinterfaces einzuführen, um die Beziehungen zwischen Klassen in einer Vererbungshierarchie klarer zu definieren. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie "protected," "virtual" und "override," um die Überschreibbarkeit von Methoden zu steuern und das Verhalten in Subklassen zu dokumentieren. Jedoch gibt es keine universelle Lösung für das Problem.'},
     {'question': 'Welche Herausforderung besteht hinsichtlich der Strukturierung von Klassen in der objektorientierten Programmierung?', 'answer': 'Eine Herausforderung besteht darin, dass die hierarchische Struktur objektorientierter Systeme auf Klassenebene nicht immer vorschreibbar ist. Objekte einer Klasse sind nicht immer Teile von Objekten anderer Klassen, sondern können auch einzelne Exemplare (Instanzen) sein und selbst Teile haben können. Es fehlen Konstrukte zur Definition von Komponenten als separate strukturbildende Einheiten neben Klassen und Objekten.'},
     {'question': 'Was ist das Problem der eindimensionalen Strukturierung?', 'answer': 'Bei größeren Programmen kann das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren, da verschiedene Vererbungshierarchien oder andere Strukturierungskriterien gleichzeitig relevant sein können. Die Trennung der Belange, auch als Separation of Concerns bekannt, wird in der objektorientierten Programmierung als unzureichend unterstützt angesehen, da es schwer ist, verschiedene Aspekte eines Systems sauber voneinander zu trennen.'},
     {'question': 'Was ist das Problem der mangelnden Kapselung?', 'answer': 'Die Vererbung in der objektorientierten Programmierung beeinträchtigt die Kapselung von Klassen auf unangenehme Weise. Vererbung führte zu starken Abhängigkeiten zwischen Klassen und ihren Subklassen, einschließlich der Implementierungsdetails. Diese Abhängigkeiten führten dazu, dass Teile der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufgegeben werden mussten. Das Aliasing-Problem tritt auf, wenn ein Objekt, das von einem anderen Objekt gekapselt wird, auch einen Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dies bedeutet, dass von außen auf das gekapselte Objekt zugegriffen werden kann, indem man den Alias verwendet. Dies stellt eine Herausforderung für die Kapselung dar, da es die Geheimhaltung der Implementierung durchbrechen kann.'},
     {'question': 'Welche Möglichkeiten zur Kontrolle von Aliasing gibt es?', 'answer': 'Es gibt verschiedene Ansätze zur Kontrolle von Aliasing in objektorientierten Programmiersprachen. Ein Ansatz besteht darin, die Teil-Ganzes-Beziehung zwischen Repräsentationsobjekten und dem Objekt zu definieren, sodass die Teile dem Ganzen gehören und nicht gleichzeitig Teile anderer Objekte sein können. Ein anderer Ansatz ist die Verwendung von Wertobjekten, die keine Referenzen auf andere Objekte zulassen. Ein dritter Ansatz besteht darin, Mechanismen zur Aliaskontrolle in die Programmiersprache zu integrieren, wobei viele dieser Mechanismen noch in der Entwicklung sind.'},
     {'question': 'Was ist die Idee hinter der Überführung von Vorbedingungen in Nachbedingungen?', 'answer': 'Die Idee hinter der Überführung von Vorbedingungen in Nachbedingungen stammt aus der formalen Programmverifikation und wird genutzt, um auch das Verhalten der Objekte eines Typs zu berücksichtigen. Dabei werden Vorbedingungen in Nachbedingungen überführt, um die Zuweisungskompatibilität zu regeln.'},
     {'question': 'Was sind Vor- und Nachbedingungen in der Objektorientierung?', 'answer': 'In der Objektorientierung ist eine Vorbedingung eine Bedingung, die vor der Ausführung einer Methode erfüllt sein muss. Die Nachbedingung ist eine Bedingung, die nach der Ausführung einer Methode erfüllt sein muss. Ein Typ gilt als korrekt implementiert, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung die Nachbedingung folgt.'},
     {'question': 'Was sind Invarianten?', 'answer': 'Invarianten sind Bedingungen, die für alle Zustände eines Objekts gelten müssen.'},
     {'question': 'Was ist eine verhaltensbasierte Subtypenrelation?', 'answer': 'Eine verhaltensbasierte Subtypenrelation ist eine Beziehung zwischen potenziellen Subtypen und Supertypen, bei der die Bedingungen betrachtet werden, die erfüllt sein müssen, damit die potenziellen Subtypen die Spezifikation des Supertyps erfüllen und als verhaltenskonform betrachtet werden können.'},
     {'question': 'Was ist verhaltensbasiertes Subtyping?', 'answer': 'Verhaltensbasiertes Subtyping, auch bekannt als Behavior Subtyping, ist ein Prinzip in der objektorientierten Programmierung, bei dem ein Untertyp die gleichen Methoden wie sein Obertyp haben muss, aber nicht unbedingt die gleichen Attribute. Das bedeutet, dass ein Objekt eines Untertyps die gleichen Methoden wie ein Objekt des Obertyps aufrufen kann, aber nicht umgekehrt.'},
     {'question': 'Was ist Behavior Subtyping?', 'answer': 'Behavior Subtyping, auch verhaltensbasiertes Subtyping genannt, ist eine Art von Subtyping, bei der ein Untertyp die gleichen Methoden wie sein Obertyp haben muss, aber nicht unbedingt die gleichen Attribute.'},
     {'question': 'Was ist das Problem mit der Substituierbarkeit von Objekten?', 'answer': 'Das Problem ist, dass ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden kann. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel.'},
     {'question': 'Was ist ein Indikator dafür, dass eine Klasse in mehrere Subklassen aufgeteilt werden sollte?', 'answer': 'Ein guter Indikator dafür ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen.'},
     {'question': 'Was ist ein Indikator dafür, dass eine Klasse in mehrere Spezialisierungen aufgeteilt werden sollte?', 'answer': 'Ein guter Indikator dafür ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen.'},
     {'question': 'Was ist die ungarische Notation?', 'answer': 'Die ungarische Notation ist eine Namenskonvention, bei der Bezeichner, die für ein Objekt oder einen Wert stehen, den Typ dieses Objekts oder Werts widerspiegeln. Es gibt verschiedene Auslegungen der ungarischen Notation, eine davon verlangt, dass alle Variablen, die Strings bezeichnen, mit "str" beginnen. Eine sinnvollere Auslegung ist, Variablen um die Verwendung ihres so bezeichneten Inhalts zu ergänzen, was in der objektorientierten Programmierung auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt werden kann.'},
     {'question': 'Was ist die Voraussetzung dafür, dass Objekte ihre Rolle spielen können?', 'answer': 'Die einzige Voraussetzung dafür ist, dass sie typkonform sind.'},
     {'question': 'Was ist die Voraussetzung dafür, dass Objekte typkonform sind?', 'answer': 'Die Voraussetzung dafür, dass Objekte typkonform sind, ist, dass sie die Eigenschaften und Verhaltensweisen besitzen, die von einem Objekt seines Typs erwartet werden.'},
     {'question': 'Was sind Interfaces als Typen?', 'answer': 'Interfaces als Typen sind ein Konzept in Programmiersprachen wie Java und C-Sharp, mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. Diese Möglichkeit wird jedoch selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen.'},
     {'question': 'Was ist ein Refactoring?', 'answer': 'Refactoring ist eine semantikerhaltende Umstrukturierung von Code, bei der der Verhaltensumfang der Methode nicht verändert wird, sondern nur die innere Struktur der Methode.'},
     {'question': 'Was ist die Vererbung von Implementierung?', 'answer': 'Die Vererbung von Implementierung ist eine Technologie zum Erstellen von Anwendungen, bei der eine Komponente von einer anderen Komponente abgeleitet wird oder Teile ihrer Funktionalität erbt.'},
     {'question': 'Welche Probleme kann die Vererbung von Implementierung verursachen?', 'answer': 'Die Vererbung von Implementierung kann viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen, da sie die Kopplung zwischen Komponenten erhöht und die Änderungen in der Basiskomponente Auswirkungen auf die abgeleiteten Komponenten haben können.'},
     {'question': 'Was ist ein explizites Vererbungsinterface?', 'answer': 'Ein explizites Vererbungsinterface ist eine Schnittstelle zwischen einer Klasse und ihren Subklassen, die die Eigenschaften definiert, auf die man über die Variablen self oder super zugreifen kann. Im Gegensatz zu anderen Schnittstellen handelt es sich hierbei nicht um eine Abhängigkeit zu anderen Objekten, sondern um eine Schnittstelle, die das Verhalten zwischen einer Klasse und ihren Subklassen regelt.'},
     {'question': 'Was ist ein deklarativer Programmierstil?', 'answer': 'Ein deklarativer Programmierstil in der objektorientierten Programmierung bemüht sich mehr um das "Was" als um das "Wie". Er ist typisch für die objektorientierte Programmierung und geht einher mit kurzen Methoden und aussagekräftigen Bezeichnern. Der Effizienzgedanke ist dabei sekundär – mögliche Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben, wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung zu ineffizient ist.'},
     {'question': 'Was ist die Bedeutung von Zusicherungen (Assertions) in der Programmierung?', 'answer': 'Zusicherungen (Assertions) sind in der Programmierung eine Möglichkeit, die Richtigkeit von Bedingungen zu einem bestimmten Zeitpunkt während der Ausführung eines Programms zu überprüfen. Wenn die Sprache dies zulässt, können sie auch dazu verwendet werden, dem Aufrufer der Methode zu zeigen, wie er selbst prüfen kann, ob die Vorbedingung eingehalten ist.'},
     {'question': 'Was sind Komponenten in objektorientierter Programmierung?', 'answer': 'In objektorientierter Programmierung werden Komponenten als wiederverwendbare, selbstbeschreibende und austauschbare Einheiten angesehen, die eine bestimmte Funktionalität bereitstellen. Sie werden in der Regel zur Laufzeit, per Aggregation von Objekten, zusammengebaut. Leider ist es mit der Einführung von Komponenten in objektorientierten Programmiersprachen noch nicht besonders weit, da keine weit verbreitete objektorientierte Programmiersprache das Schlüsselwort "component" verwendet oder reserviert. Stattdessen werden Programmierer dazu veranlasst, alles in Form von Klassen zu definieren. Konzepte wie Pakete (Java) oder Assemblies (C-Sharp) können einen Komponentenbegriff nicht ersetzen, da sie lediglich Klassen gruppieren und dabei ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann. Es wird vermutet, dass in den nächsten Jahren in diesem Bereich noch der größte Fortschritt erzielt werden kann.'},
     {'question': 'Was ist die Faustregel für eine gute Namenswahl?', 'answer': 'Als Faustregel wird genannt, dass ein Name dann gut gewählt ist, wenn man alle Ausdrücke, in denen er vorkommt, schnell und klar verstehen kann. Ein gut gewählter Name sollte keine falschen Assoziationen oder Vermutungen hervorrufen und sollte somit leicht verständlich sein. Es ist ratsam, sich Zeit für die Auswahl eines passenden Namens zu nehmen, da dies eine sorgfältige Überlegung erfordert und die Lesbarkeit des Codes erheblich verbessern kann.'},
     {'question': 'Welche Rolle spielen Bibliotheken in der objektorientierten Programmierung?', 'answer': 'Bibliotheken spielen eine entscheidende Rolle in der objektorientierten Programmierung. Sie sind ein wesentlicher Bestandteil des objektorientierten Programmierstils und tragen maßgeblich zum Erfolg dieses Ansatzes bei.'},
     {'question': 'Welche Art von Zugriffsregel führt Demeters Gesetz ein?', 'answer': 'Demeters Gesetz führt faktisch eine neue, kontextabhängige Zugriffsregel ein: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt, auf die es aber nicht zugreifen darf. Dies führt zu einer klaren Trennung zwischen direkten und indirekten Beziehungen zwischen Objekten.'},
     {'question': 'Was ist Substituierbarkeit in Bezug auf Typerweiterung und Typeinschränkung?', 'answer': 'Substituierbarkeit bedeutet, dass ein Objekt eines Typs durch ein Objekt eines anderen Typs ersetzt werden kann, ohne dass die Korrektheit des Programms beeinträchtigt wird. Wenn eine Typerweiterung vorliegt, ist die Substituierbarkeit in der Regel unproblematisch. Wenn jedoch eine Typeinschränkung vorliegt, kann die Substituierbarkeit fraglich sein, da das ersetzende Objekt möglicherweise nicht die gleichen Eigenschaften und Methoden aufweist wie das ursprüngliche Objekt.'},
     {'question': 'Was ist ein mögliches Problem, wenn man Bag als Subtyp von Set annimmt?', 'answer': 'Wenn man Bag als Subtyp von Set annimmt, kann dies dazu führen, dass die für Set charakteristische Eigenschaft verletzt wird, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden.'},
     {'question': 'Was ist das Ziel des Gesetzes Demeters?', 'answer': 'Das Ziel des Gesetzes Demeters ist es, die Kopplung und damit die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wenn das Gesetz Demeters verletzt wird, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen.'},
     {'question': 'Welche Probleme ergeben sich aus Subtyping?', 'answer': 'Das Problem, das sich aus Subtyping ergibt, ist, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat. In einer statischen, lokalen Betrachtung befinden wir uns in einem Zustand völliger Unsicherheit.'},
     {'question': 'Was ist das Problem der formalen Programmverifikation?', 'answer': 'Das Problem der formalen Programmverifikation ist die Beziehung P {e m} Q, bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse über die Implementierung der Methode.'},
     {'question': 'Was ist weniger geeignet für die objektorientierte Programmierung?', 'answer': 'Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, sind weniger geeignet für die objektorientierte Programmierung.'},
     {'question': 'Was ist das Ziel der Objektorientierung?', 'answer': 'Das Ziel der Objektorientierung ist es, die Komplexität von Software zu reduzieren, indem sie die Software in kleinere, leichter zu verstehende Einheiten aufteilt, die Objekte genannt werden und Instanzen von Klassen sind.'},
     {'question': 'Was ist das Liskov-Substitutionsprinzip?', 'answer': 'Das Liskov-Substitutionsprinzip ist eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen. Es besagt, dass ein Typ B, der als Subtyp eines Typs A deklariert ist, in einem Programm an allen Stellen, an denen ein Objekt vom Typ A erwartet wird, durch ein Objekt vom Typ B ersetzt werden kann, ohne dass das Programm dadurch in seiner Funktionalität beeinträchtigt wird.'},
     {'question': 'Was ist die Subtypenbeziehung?', 'answer': 'Die Subtypenbeziehung ist eine Beziehung zwischen zwei Typen, bei der der Untertyp alle Eigenschaften des Obertyps erfüllt. Das bedeutet, dass ein Objekt des Untertyps auch als Objekt des Obertyps behandelt werden kann. Diese Beziehung wird oft durch eine Hierarchie von Klassen dargestellt, bei der eine Unterklasse eine spezifischere Version einer Oberklasse ist.'},
     {'question': 'Was sind Vor- und Nachbedingungen in typlosen Sprachen?', 'answer': 'In typlosen Sprachen wie Smalltalk werden die Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert. Vorbedingungen beschreiben die Bedingungen, die vor der Ausführung einer Methode erfüllt sein müssen, während Nachbedingungen die Bedingungen beschreiben, die nach der Ausführung der Methode erfüllt sein müssen. Die Menge der ausgelösten Ausnahmen ist Teil der Nachbedingungen.'},
     {'question': 'Was sind Zustandswechselinvarianten?', 'answer': 'Zustandswechselinvarianten sind Verlaufseigenschaften, die die möglichen Zustandsänderungen von Objekten betreffen. Sie werden benötigt, um eine weniger restriktive Lösung für die Spezifikation von Methoden zu ermöglichen, die neben Vor- und Nachbedingungen auch die Zustandsänderungen von Objekten berücksichtigt. Dazu ist eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Um den Zustandsraum kombinatorisch zu vermeiden, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss.'},
     {'question': 'Was ist die Trennung der Belange (Separation of Concerns) in der objektorientierten Programmierung?', 'answer': 'Die Trennung der Belange, auch Separation of Concerns genannt, ist ein Prinzip in der objektorientierten Programmierung, das die Aufgaben und Verantwortlichkeiten von Objekten und Komponenten klar trennen soll. Es ist jedoch unzureichend unterstützt und kann die Komplexität nur in das Zusammenführen der Sichten verschieben.'},
     {'question': 'Was ist das Aliasing-Problem?', 'answer': 'Das Aliasing-Problem ist ein Problem in der Objektorientierung, bei dem ein Objekt, das durch ein anderes Objekt gekapselt wird, einen weiteren Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dadurch kann man auf das gekapselte Objekt zugegriffen werden, auch wenn die Instanzvariable von außen unzugreifbar ist.'},
     {'question': 'Was sind Repräsentationsobjekte?', 'answer': 'Repräsentationsobjekte sind Objekte, die die Implementierung eines anderen Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen. Sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen.'},
     {'question': 'Was ist Aliasing?', 'answer': 'Aliasing bedeutet, dass mehrere Variablen auf das gleiche Objekt verweisen. Dies kann zu Problemen führen, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, da Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger zugreifen können. Dies ist bei sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Am Programmverhalten ist dies jedoch nicht zu erkennen.'},
     {'question': 'Was bedeutet "gute Programmierung"?', 'answer': 'Laut dem Kurstext bedeutet "gute Programmierung", dass der Programmtext und der Programmablauf einander möglichst ähnlich sind, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zulässt.'},
     {'question': 'Was bedeutet es, wenn ein Objekt typkonform ist?', 'answer': 'Wenn ein Objekt typkonform ist, bedeutet das, dass es die Eigenschaften und Verhaltensweisen besitzt, die von einem Objekt seines Typs erwartet werden. Es erfüllt also die Anforderungen, die an Objekte dieses Typs gestellt werden.'},
     {'question': 'Was bedeutet funktional äquivalent?', 'answer': 'Funktional äquivalent bedeutet, dass zwei Ausdrücke das gleiche Ergebnis liefern, wenn sie mit den gleichen Eingabewerten ausgeführt werden.'}
     ],
    [{'question': 'Wie wird das Lokalitätsprinzip durch dynamisches Binden aufgeweicht?', 'answer': 'Das Lokalitätsprinzip besagt, dass die Bedeutung eines Namens durch die unmittelbare Umgebung bestimmt wird, in der er deklariert ist. Durch dynamisches Binden wird das Lokalitätsprinzip aufgeweicht, da die Bedeutung eines Namens, der auf eine Methode verweist, nicht nur durch die unmittelbare Umgebung bestimmt wird, sondern auch durch die Klasse des Empfängerobjekts, auf dem die Methode aufgerufen wurde. Diese Information ist in der Regel nicht lokal bestimmbar und erfordert eine vollständige Programmanalyse.'},
     {'question': 'Wie lässt sich das Problem der schlechten Tracebarkeit lösen?', 'answer': 'Man versuchte, das Problem der schlechten Tracebarkeit durch das Vermeiden von Goto-Anweisungen zu lösen. Stattdessen setzte man auf strukturierte Programmierung, die Verzweigung, Wiederholung und Unterprogrammaufrufe verwendete, um den Programmfluss zu steuern.'},
     {'question': 'Wie kann man das Fragile-Base-Class-Problem verhindern?', 'answer': 'Eine Möglichkeit zur Vermeidung des Problems besteht darin, explizite Schnittstellen oder Vererbungsinterfaces einzuführen, die genau definieren, welche Eigenschaften und Methoden von Subklassen erwartet werden. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie "virtual" und "override," um die Überschreibbarkeit und das Verhalten von Methoden in der Vererbungshierarchie zu steuern.'},
     {'question': 'Wie wird die Prüfung der Substituierbarkeit in der Praxis durchgeführt?', 'answer': 'In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren, insbesondere die Prüfung der Typkonformität, angenähert. Dabei wird jedoch betont, dass nicht einmal eine Substituierbarkeit ausgeschlossen werden kann, wenn mangelnde Typkonformität vorliegt. Substituierbarkeit erfordert auch eine Betrachtung des Verhaltens der Objekte.'},
     {'question': 'Wie können Programmierer ihre Erwartungen an Objekte ausdrücken?', 'answer': 'Programmierer können ihre Erwartungen an Objekte ausdrücken, indem sie selbst einen Typen definieren, der nur die Eigenschaften umfasst, die sie benötigen. Ein solcher Typ spezifiziert gewissermaßen die Rolle, die die Objekte im Kontext der Verwendung spielen sollen.'},
     {'question': 'Wie beeinflusst die Ausdrucksweise einer Programmiersprache die Qualität eines Programms?', 'answer': 'Die Ausdrucksweise einer Programmiersprache beeinflusst die Qualität eines Programms, indem sie die Effizienz der Problemlösung und die Verständlichkeit der Formulierung beeinflusst. Dies hängt von Faktoren wie Schreibstil, Mode und Ästhetik ab.'},
     {'question': 'Wie kann die Analysephase eines Projekts zur Identifizierung der Klassen eines Systems beitragen?', 'answer': 'In der Analysephase eines Projekts können alle Substantive aus der Spezifikation extrahiert werden, um auf der Basis dieser Liste die Menge der Klassen eines Systems zu identifizieren. Dies ist eine vielzitierte objektorientierte Technik.'},
     {'question': 'Wie wird das Gesetz Demeters oft zusammengefasst?', 'answer': 'Das Gesetz Demeters wird oft in folgender Phrase zusammengefasst: "Sprich nicht mit Fremden." In Bezug auf SMALLTALK bedeutet dies, dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen.'},
     {'question': 'Wann wird das Gesetz Demeters typischerweise verletzt?', 'answer': 'Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks vorliegen, wie zum Beispiel bei Kettenaufrufen oder über eine zwischenzeitliche Zuweisung zu einer temporären Variablen.'},
     {'question': 'Wie kann das Problem der Aliasbildung gelöst werden?', 'answer': 'Das Problem der Aliasbildung kann durch zwei Lösungen gelöst werden: Die Aliasbildung wird vermieden, indem die Objekte, die als Argumente übergeben werden, kopiert werden. Dadurch wird sichergestellt, dass die Methode nur auf eine Kopie des Objekts zugreift und nicht auf das Original. Oder die Aliasbildung wird zugelassen, aber die Methodenaufrufe werden begrenzt, was bedeutet, dass die Methode nur auf die Objekte zugreifen kann, die ihr als Argumente übergeben werden, und nicht auf die Objekte, auf die diese Objekte verweisen.'},
     {'question': 'Wie können Klassen strukturiert werden?', 'answer': 'Die Menge der Module und damit das Programm werden durch die Vererbungshierarchie weiter strukturiert. Parallel dazu gibt es noch eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen geprägt ist. Diese ist jedoch nicht hierarchisch und insgesamt eher unorganisiert. Die Klassenhierarchie stellt also insbesondere keine Form der hierarchischen Modularisierung dar.'},
     {'question': 'Wie wirkt sich Vererbung auf die Kapselung von Klassen aus?', 'answer': 'Vererbung kann die Kapselung von Klassen auf unangenehme Weise aufbrechen, indem sie starke Abhängigkeiten zwischen Klassen und ihren Subklassen erzeugt. Diese Abhängigkeiten explizit zu machen, kann zwar vor Programmierfehlern schützen, aber die Abhängigkeiten nicht beseitigen. Die Abhängigkeiten zu beschränken, bedeutet, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben.'},
     {'question': 'Wie kann man sicherstellen, dass eine Methode in einer Klasse keine Aliase anlegt und verwendet?', 'answer': 'Um sicherzustellen, dass eine Methode in einer Klasse keine Aliase anlegt und verwendet, kann man die Implementierung der Klasse überprüfen und sicherstellen, dass sie keine Aliase erstellt oder verwendet. Zusätzlich kann man die Sprache und die Laufzeitumgebung überprüfen, um sicherzustellen, dass sie keine Aliase automatisch erzeugen.'},
     {'question': 'Wie kann das Geheimnisprinzip umgangen werden?', 'answer': 'Das Geheimnisprinzip kann umgangen werden, indem Repräsentationsobjekte, deren Namen verborgen werden sollen, noch andere Namen besitzen, zum Beispiel wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt oder wenn das Objekt selbst eine Referenz auf ein Repräsentationsobjekt herausgibt, beispielsweise durch einen Getter.'},
     {'question': 'Wie kann man verhindern, dass Objekte von anderen Objekten referenziert werden können?', 'answer': 'Eine Möglichkeit, dies zu verhindern, ist, aus den Objekten Wertobjekte zu machen und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Dies ist jedoch nur in einigen Programmiersprachen möglich, wie zum Beispiel in C-Sharp im Safe mode, wenn die „Klasse“ der Teil-Objekte per "struct" definiert wurde. Diese Vorgehensweise ist jedoch nur selten ohne unerwünschte Nebenwirkungen, da alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was die Anwendungsdomäne in der Regel nicht korrekt abbildet.'},
     {'question': 'Wie geht EIFFEL mit Referenz- und Wertvariablen um?', 'answer': 'EIFFEL erlaubt, auf Wertobjekte Referenzen zu haben, aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Somit sind Wertobjekte in EIFFEL aliasfrei.'},
     {'question': 'Wie hängt der Substituierbarkeitsbegriff mit der Übersetzungszeit zusammen?', 'answer': 'Der Substituierbarkeitsbegriff ist ein Begriff, der unabhängig vom konkreten Zustand der Objekte sein muss. Wenn man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungszeit verlagert, ist das Verhalten aller Objekte einer Klasse gleich spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.'},
     {'question': 'Was ist der Zweck von abstrakten Typen?', 'answer': 'Abstrakte Typen werden verwendet, um Objekte verschiedener konkreter Typen zu repräsentieren, die eine gemeinsame Schnittstelle haben, aber ein unterschiedliches Verhalten aufweisen. Die Objekte sind austauschbar, da sie die gleichen Methoden besitzen, aber das konkrete Verhalten dieser Methoden kann unterschiedlich sein. Abstrakte Typen werden verwendet, um eine allgemeine Klasse von Objekten zu definieren, ohne sich auf eine bestimmte Implementierung festzulegen.'},
     {'question': 'Wie kann das Verhalten von Objekten in der Subtypenbeziehung berücksichtigt werden?', 'answer': 'Die Idee aus der formalen Programmverifikation besteht darin, Vorbedingungen in Nachbedingungen zu überführen, um das Verhalten von Objekten eines Typs zu berücksichtigen. Dies wird verwendet, um sicherzustellen, dass die Implementierung eines Typs korrekt ist und dass aus Vorbedingungen die entsprechenden Nachbedingungen folgen.'},
     {'question': 'Was ist der Zweck der Nachbedingung in der objektorientierten Programmierung?', 'answer': 'Der Zweck der Nachbedingung in der objektorientierten Programmierung ist es, die Korrektheit der Implementierung zu gewährleisten. Die Nachbedingung wird aus der Vorbedingung abgeleitet und gilt für die Implementierung einer Methode in der zugehörigen Klasse. Der Beweis für die Nachbedingung muss nicht geführt werden, da es hier um die Austauschbarkeit von Implementierungen abhängig vom Verwendungskontext geht.'},
     {'question': 'Was ist der Zweck des Gesetzes Demeters?', 'answer': 'Der Sinn und Zweck des Gesetzes Demeters ist es, die Kopplung und die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wenn das Gesetz Demeters verletzt wird, kann eine Änderung des Protokolls einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zur Klasse stehen, was vermieden werden sollte.'},
     {'question': 'Was ist der Zweck der Substituierbarkeit?', 'answer': 'Der Zweck der Substituierbarkeit in der objektorientierten Programmierung ist es, die Gewissheit zu haben, dass eine lokale, "modulare" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte.'},
     {'question': 'Warum wird dynamisches Binden in der objektorientierten Programmierung kritisiert?', 'answer': 'Kritikerinnen der objektorientierten Programmierung haben das dynamische Binden als eine Art Goto der 90er Jahre betrachtet. Dieser Vergleich ist jedoch nicht ganz fair, weil die Aufruferin nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen. Es reicht zu wissen, welchen Vertrag die aufgerufene Methode erfüllt.'},
     {'question': 'Warum sollten nur die Blätter der Klassenhierarchie instanziierbar sein?', 'answer': 'Die Blätter der Klassenhierarchie sollten instanziierbar sein, weil man die Implementierung einer Klasse ändern will, ohne die Implementierung der Superklasse ändern zu müssen. Wenn man mit der Funktionalität einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern, ohne die Implementierung der Superklasse ändern zu müssen.'},
     {'question': 'Warum sollte man sich zur Angewohnheit machen, automatische Codeformatierer einzusetzen?', 'answer': 'Man sollte sich zur Angewohnheit machen, automatische Codeformatierer einzusetzen, um Energieverschwendung zu vermeiden, Codierungs-konventionen umzusetzen, sich nicht zu weit von dem, was allgemein üblich ist, zu entfernen und sich auf die Entwicklung des persönlichen Programmierstils zu konzentrieren.'},
     {'question': 'Warum sind gemeinsame Konventionen in der Softwareentwicklung wichtig?', 'answer': 'Gemeinsame Konventionen in der Softwareentwicklung sind wichtig, weil ein großer Teil des Aufwands bei der Softwareentwicklung darin besteht, bestehende Software zu lesen und sicherzustellen, dass andere das Geschriebene leicht verstehen können. Individuelle Eigenheiten sind nicht hilfreich, während gemeinsame Konventionen allen Entwicklern helfen.'},
     {'question': 'Warum ist die Unabhängigkeit vom konkreten Zustand der Objekte wichtig im Zusammenhang mit der Substituierbarkeit?', 'answer': 'Die Unabhängigkeit vom konkreten Zustand der Objekte ermöglicht es, die Substituierbarkeit von der Laufzeit auf die Übersetzungs- oder Entwurfszeit zu verlagern. Auf dieser Ebene ist das Verhalten aller Objekte einer Klasse gleich, da sie durch dieselbe Klassendefinition spezifiziert sind.'},
     {'question': 'Warum reicht eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit nicht aus?', 'answer': 'Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht nicht aus, da Aliasings in der objektorientierten Programmierung dazu führen kann, dass ein Objekt vom Typ S von verschiedenen Klienten unterschiedliche Typen hat und Methodenaufrufe auf dem Objekt Zustandsänderungen verursachen können, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Daher muss eine umfassendere Betrachtung erfolgen, die die Auswirkungen des Verhaltens auf den Zustand und die Spezifikation des Typs berücksichtigt.'},
     {'question': 'Warum ist der Name Fragile-Base-Class-Problem etwas irreführend?', 'answer': 'Der Name ist etwas irreführend, da nicht unbedingt die Basisklassen, sondern eher die abgeleiteten Klassen als "anfällig" oder "zerbrechlich" gelten.'},
     {'question': 'Warum ist es wichtig, aussagekräftige Bezeichner in Programmen zu verwenden?', 'answer': 'Die Verwendung von aussagekräftigen Bezeichnern in Programmen trägt zur Verständlichkeit des Codes bei. Gut gewählte Bezeichner drücken im Kontext ihre Bedeutung aus, sodass Kommentare zur Erklärung der Programmelemente oft unnötig werden. Dies erleichtert anderen Entwicklerinnen das Verständnis des Codes und erhöht die Lesbarkeit und Wartbarkeit des Programms.'},
     {'question': 'Warum können Konzepte wie Pakete (Java) oder Assemblies (C-Sharp) den Begriff der Komponente nicht ersetzen?', 'answer': 'Pakete (Java) oder Assemblies (C-Sharp) gruppieren lediglich Klassen und berücksichtigen nicht, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann. Sie können den Begriff der Komponente daher nicht vollständig ersetzen.'},
     {'question': 'Warum kann die Unterdrückung von Eigenschaften bei abgeleiteten Typen in Java problematisch sein?', 'answer': 'In Java ist die Unterdrückung von Eigenschaften bei abgeleiteten Typen problematisch, da sie dazu führen kann, dass an Stellen im Programm, an denen ein Objekt des Supertyps erwartet wird, ein Objekt des Subtyps auftaucht. Dies kann zu schwerwiegenden Programmierfehlern führen, da die erwarteten Funktionen des Supertyps möglicherweise nicht verfügbar sind.'},
     {'question': 'Warum sind nicht alle Aufgaben gleichermaßen zur Lösung per objektorientierter Programmierung geeignet?', 'answer': 'Nicht alle Aufgaben sind gleichermaßen zur Lösung per objektorientierter Programmierung geeignet, da einige Aufgaben besser mit anderen Programmierparadigmen wie funktionale oder logische Programmiersprachen gelöst werden können. Auch Batch- und Scripting-Probleme, die einen imperativ-prozeduralen Charakter haben, eignen sich möglicherweise nicht optimal für die objektorientierte Programmierung.'},
     {'question': 'Warum stellt die Klassenhierarchie keine Form der hierarchischen Modularisierung dar?', 'answer': 'Die Klassenhierarchie stellt keine Form der hierarchischen Modularisierung dar, da das Herauslösen eines Teilbaums der Vererbungshierarchie praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen trennt. Somit werden Beziehungen zwischen Klassenmitgliedern gestört.'},
     {'question': 'Warum wird die Trennung der Belange in der objektorientierten Programmierung als unzureichend unterstützt angesehen?', 'answer': 'Die Trennung der Belange, auch als Separation of Concerns bekannt, wird in der objektorientierten Programmierung als unzureichend unterstützt angesehen, da es schwer ist, verschiedene Aspekte eines Systems sauber voneinander zu trennen. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar diskutiert, haben jedoch keine breite Akzeptanz gefunden. Die Gründe dafür können vielfältig sein, aber letztendlich ist es schwierig, die essentielle Komplexität eines Problems durch programmiersprachliche Mittel vollständig zu beseitigen.'},
     {'question': 'Warum kann das Verbot von Aliasing in einigen Programmiersprachen nicht immer eine geeignete Lösung sein?', 'answer': 'Das Verbot von Aliasing in einigen Programmiersprachen kann nicht immer eine geeignete Lösung sein, da es zahlreiche Anwendungsfälle gibt, in denen die Verwendung von Aliasing notwendig oder sinnvoll ist. Zum Beispiel können bestimmte Datenstrukturen oder Container von Natur aus Aliase erfordern, um effizient zu arbeiten.'},
     {'question': 'Warum ist es vorteilhaft, existierende Bibliotheken in der objektorientierten Programmierung zu verwenden?', 'answer': 'Es ist vorteilhaft, existierende Bibliotheken in der objektorientierten Programmierung zu verwenden, da die Implementierungen in der Regel korrekt sind, die Wartung und Anpassung übernommen wird, die Funktionalität bekannt ist und die eigene Arbeit klein und überschaubar bleibt.'},
     {'question': 'Warum ist die Implementierungsvererbung nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert?', 'answer': 'Die Implementierungsvererbung ist nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert, weil sie implizit und mehrdeutig ist. Wenn die Eltern- oder Kindkomponente unerwartet ihr Verhalten ändert, kann dies zu undefiniertem Verhalten verwandter Komponenten führen. Diese Unsicherheit ist nicht akzeptabel in einem System, das von vielen verschiedenen Programmierern entwickelt wird, die nicht alle gleichzeitig Updates an allen Komponenten vornehmen können.'},
     {'question': 'Warum ist es wichtig, dass die Schnittstelle einer Komponente für beide Parteien kristallklar ist?', 'answer': 'Damit der Komponentenanbieter sicherstellen kann, dass er die Schnittstelle beibehält und somit die bestehenden Clients nicht stört.'},
     {'question': 'Warum sollte man bei Optimierungen vorsichtig sein?', 'answer': 'Man sollte bei Optimierungen vorsichtig sein, weil nicht sichergestellt ist, dass die optimierte Version funktional äquivalent ist und dasselbe Ergebnis liefert. Zum Beispiel könnte "auswerten" für "Literale" einen Seiteneffekt haben, was die optimierten Versionen ungleich machen würde.'},
     {'question': 'Warum sollte man den langen Namen einer Variablen bevorzugen, wenn sie nicht nur in ihrer unmittelbaren Umgebung sichtbar ist?', 'answer': 'Der lange Name einer Variablen sollte bevorzugt werden, wenn sie nicht nur in ihrer unmittelbaren Umgebung sichtbar ist, um die Lesbarkeit und Verständlichkeit des Codes zu erhöhen. Ein aussagekräftiger und beschreibender Name hilft anderen Programmierern und auch dem zukünftigen Selbst, den Zweck und die Funktion der Variablen besser zu verstehen.'},
     {'question': 'Warum ist die Verwendung aussagekräftiger Variablennamen wichtig?', 'answer': 'Die Verwendung aussagekräftiger Variablennamen ist wichtig, um das Verständnis des Programms zu erleichtern. Wenn Variablennamen wie "i" verwendet werden, ist es schwieriger zu verstehen, wofür die Variablen stehen. Durch die Verwendung aussagekräftiger Variablennamen wie "r", "m" oder "w" in diesem Beispiel wird das Programm jedoch leichter verständlich.'},
     {'question': 'Warum sollten Klassen nicht zu groß sein?', 'answer': 'Klassen sollten nicht zu groß sein, da dies als schlechter Stil gilt und die Anwendungsdomäne nicht angemessen widerspiegelt. Stattdessen sollten große Dinge in einfachere zusammengesetzt werden, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind. Diese Art der Strukturierung findet man auch in anderen Ingenieursdisziplinen wie dem Bauwesen.'},
     {'question': 'Warum sind innere Klassen in Java nicht besonders nützlich?', 'answer': 'Obwohl in Java innere Klassen genutzt werden können, um Klassen zu strukturieren, wird davon relativ wenig Gebrauch gemacht. Dies liegt daran, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind und vielmehr einzelne Exemplare (Instanzen) sein und vielleicht sogar selbst Teile haben können. Einzelne Instanzen können nicht durch innere Klassen beschrieben werden, weshalb sie als ein nicht besonders nützlicher Mechanismus angesehen werden.'},
     {'question': 'Warum ist die Vererbung ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung?', 'answer': 'Die Vererbung ist ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung, weil sie einerseits ein mächtiges Konzept zur Wiederverwendung von Code und zur Erstellung von Klassenhierarchien darstellt, andererseits aber auch dazu führen kann, dass Änderungen an einer Klasse sich auf alle davon abgeleiteten Klassen auswirken. Dies kann die Wartbarkeit und Erweiterbarkeit des Codes beeinträchtigen und zu unerwartetem Verhalten führen.'},
     {'question': 'Warum sind Formatierungskonventionen in der Programmierung wichtig?', 'answer': 'Formatierungskonventionen in der Programmierung sind wichtig, da sie die Lesbarkeit des Codes verbessern. Sie regeln Dinge wie Einrückungen, Zeilenumbrüche, Leerzeichen und Leerzeilen, um den Code übersichtlicher zu gestalten.'},
     {'question': 'Warum sind die Methoden in objektorientierten Programmen im Durchschnitt ziemlich kurz?', 'answer': 'Die Methoden in objektorientierten Programmen sind im Durchschnitt ziemlich kurz, weil in der objektorientierten Programmierung die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Wenn eine Funktion verschiedene Arten von Daten manipuliert, wird die Funktionalität wahrscheinlich nicht vollständig in einer Methode implementiert.'},
     {'question': 'Warum ist die automatische Überprüfung des Gesetzes Demeters in SMALLTALK nicht möglich?', 'answer': 'In SMALLTALK ist die automatische Überprüfung des Gesetzes Demeters nicht möglich, da Ausdrücke in SMALLTALK nicht typisiert sind. Daher können Checker nicht feststellen, ob die Art und Weise, wie auf Objekte zugegriffen wird, dem Gesetz Demeters entspricht.'},
     {'question': 'Warum ist das Gesetz Demeters umstritten und nicht allgemein anerkannt?', 'answer': 'Das Gesetz Demeters ist umstritten und nicht allgemein anerkannt, weil es in einigen Fällen schwer umsetzbar sein kann und zu unpraktischem Code führen kann. Es erfordert, dass Verkettungen von Nachrichten vermieden werden, was in einigen Fällen zu einer unnötigen Fragmentierung des Codes führen kann. Einige Entwickler sehen das Gesetz Demeters als zu restriktiv an und argumentieren, dass es in bestimmten Situationen vernünftiger ist, Verkettungen von Nachrichten zu verwenden, um den Code lesbarer und effizienter zu gestalten. Dennoch ist es wichtig, das Gesetz Demeters zu verstehen und in Betracht zu ziehen, da es in vielen Fällen dazu beitragen kann, die Kopplung zwischen Klassen zu verringern und den Code wartbarer zu machen.'},
     {'question': 'Warum ist die objektorientierte Programmierung nicht gut für GUI-Programmierung geeignet?', 'answer': 'Objektorientierte Programmierung ist nicht gut für GUI-Programmierung geeignet, weil sich die Instanzen einer Klasse alle Methoden teilen, was es nicht möglich macht, für verschiedene Objekte derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Um dies zu erreichen, muss eine Indirektion eingebaut werden, wie zum Beispiel in Smalltalk über einen Block, in Java über anonyme innere Klassen, in C++ und C-Sharp über Funktionszeiger (Delegates in C-Sharp). Die prototypenbasierte Variante der objektorientierten Programmierung, wie sie in JavaScript verwendet wird, scheint hier besser geeignet zu sein.'},
     {'question': 'Warum erweist sich das Liskov-Substitutionsprinzip in der Praxis als zu restriktiv?', 'answer': 'Das Liskov-Substitutionsprinzip erweist sich in der Praxis als zu restriktiv, weil es eine Typüberprüfung darstellt, die gültige Programme ablehnt. Zum Beispiel, wenn eine Methode in einem Subtyp kontravariant im Eingabeparameter und nicht kovariant im Ausgabeparameter ist, erfüllt sie nicht die Bedingungen des LSP, aber sie kann trotzdem an jeder Stelle, an der die Methode im Basistyp erwartet wird, ohne Probleme verwendet werden. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.'},
     {'question': 'Warum wird die Trennung der Belange in der objektorientierten Programmierung nur unzureichend unterstützt?', 'answer': 'Die Trennung der Belange wird in der objektorientierten Programmierung nur unzureichend unterstützt, weil die Ansätze wie das Subject- oder Aspect-oriented Programming zwar hoch gehandelt wurden, aber noch nicht im Mainstream angekommen sind. Die Gründe dafür sind vielfältig, aber letztlich ist es illusorisch, die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen zu wollen. Die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen.'},
     {'question': 'Warum können Aliase ein Problem sein?', 'answer': 'Aliase sind Variablen, die auf das gleiche Objekt verweisen. Sie können schlecht sein, weil sie zu unerwarteten Nebenwirkungen führen können, wenn man nicht vorsichtig ist. Wenn man beispielsweise den Zustand eines Objekts über eine Variable ändert, kann dies auch den Zustand über eine andere Variable beeinflussen, die auf dasselbe Objekt verweist. Dies kann zu Verwirrung und Fehlern führen. Einige Programmiersprachen bieten die Möglichkeit, Klassen als Werttypen zu definieren, um das Entstehen von Aliase zu vermeiden.'},
     {'question': 'Warum können Aliase ein Problem bei sicherheitskritischen Anwendungen darstellen?', 'answer': 'Aliase können ein Problem bei sicherheitskritischen Anwendungen darstellen, da sie mit der Spezifikation nicht vereinbar wären. Wenn es Aliase von außen auf geheime Daten- oder Funktionsträger gibt, ist die Spezifikation nicht erfüllt.'}
     ],
    [{'question': 'Warum wird die Verwendung von Goto-Anweisungen im Programmieren nicht empfohlen?', 'answer': 'Die Verwendung von Goto-Anweisungen verursacht ein hohes Maß an Nichtwissen bei der Interpretation von Quelltext, insbesondere beim Debugging von Programmen ist der Blick in den Quelltext des Programms nur bedingt von Nutzen.'},
     {'question': 'Welche Vorteile bietet ein Unterprogrammaufruf gegenüber der Duplizierung von Code?', 'answer': 'Durch den Unterprogrammaufruf wird die Duplizierung von Code vermieden, was die Notwendigkeit beseitigt, die Anweisungen des Unterprogramms im Aufrufkontext zu halten, wenn es mehrere solche Aufrufkontexte gibt. Dies erleichtert die Unterteilung von Programmen in Abschnitte, die getrennt untersucht und verstanden werden können.'},
     {'question': 'Was ist der Vorteil von lokalen Variablen in Unterprogrammen?', 'answer': 'Der Vorteil von lokalen Variablen in Unterprogrammen ist, dass die Programmiererin das Unterprogramm korrekt benutzen kann, ohne in das Unterprogramm hineinschauen zu müssen. Sie muss also nicht die Anweisungen des Unterprogramms inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt.'},
     {'question': 'Was ist der Vorteil von Unterprogrammen?', 'answer': 'Der Vorteil von Unterprogrammen ist, dass die Programmiererin nicht in das Unterprogramm hineinschauen muss, um es korrekt benutzen zu können. Sie muss also nicht die Anweisungen des Unterprogramms inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird.'},
     {'question': 'Was passiert, wenn man die Klasse des Empfängerobjekts nicht kennt?', 'answer': 'Wenn man die Klasse des Empfängerobjekts nicht kennt, ist es nicht möglich, an der Stelle der betrachteten Anweisung zu bestimmen, von woher der in der Anweisung zuvor angestoßene Unterprogrammaufruf zurückkehrt. Das Lokalitätsprinzip wird also durch das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein.'},
     {'question': 'Warum werden objektorientierte Programme als schwerer zu tracen und zu debuggen angesehen als prozedurale?', 'answer': 'Objektorientierte Programme werden als schwerer zu tracen und zu debuggen angesehen als prozedurale, weil sie dynamisch gebundene Unterprogrammaufrufe verwenden, was die Nachverfolgung von Programmabläufen erschweren kann.'},
     {'question': 'Warum kann eine Änderung am Verhalten einer Klasse Auswirkungen auf andere Klassen haben?', 'answer': 'Eine Änderung am Verhalten einer Klasse kann Auswirkungen auf andere Klassen haben, weil wenn die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, jede Änderung sich auf diese Subklassen ausbreiten und den Vertrag dieser Klassen mit ihren Klienten brechen kann. Auch wenn die Designerin sicher ist, dass die Änderung innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, kann sie nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.'},
     {'question': 'Was ist der Unterschied zwischen Subtypen und austauschbaren Typen?', 'answer': 'Subtypen sind im Allgemeinen nicht gegeneinander austauschbar, während austauschbare Typen es sind. Ein Beispiel für einen Subtyp, der nicht gegen einen anderen Subtyp austauschbar ist, ist eine Aktion, für die "rückgängig machen" nicht definiert ist, während eine Aktion, für die "rückgängig machen" definiert ist, gegen eine Aktion austauschbar ist, für die "rückgängig machen" leer implementiert ist.'},
     {'question': 'Was ist der Unterschied zwischen austauschbaren und nicht austauschbaren Typen?', 'answer': 'Austauschbare Typen sind solche, bei denen eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ vorhanden ist und die gleiche Funktionalität aufweist. Nicht austauschbare Typen hingegen sind solche, bei denen eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ fehlt oder eine andere Funktionalität aufweist. Ein Beispiel für nicht austauschbare Typen ist eine Aktion, für die "rückgängig machen" nicht definiert ist, wie beispielsweise Speichern. Es ist diskutierbar, ob es ausreicht, die Funktion "rückgängig machen" in Speichern leer zu implementieren, die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.'},
     {'question': 'Wozu dienen Namenskonventionen?', 'answer': 'Namenskonventionen erleichtern die Bezeichnerwahl, indem sie die schöpferische Freiheit der Programmiererin einschränken und das Lesen von Code, indem sie die Bedeutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter entschlüsseln.'},
     {'question': 'Warum wurde die Goto-Anweisung als Hauptverursacher für schlechte Programmierung identifiziert?', 'answer': 'Die Goto-Anweisung erlaubt Sprünge von beliebigen Stellen eines Programms zu anderen Stellen und bricht dabei das Lokalitätsprinzip von Programmen, bei dem zusammengehörende Anweisungen im Programmtext nahe beieinander stehen. Dies führte zu einer Unübersichtlichkeit im Programmtext und erschwerte das Verstehen und Debuggen von Programmen.'},
     {'question': 'Warum könnten funktional äquivalente, aber verschiedene Typen ausgetauscht werden?', 'answer': 'Funktional äquivalente, aber verschiedene Typen können ausgetauscht werden, wenn Unterschiede im Verhalten toleriert oder sogar gewünscht werden. Ein Beispiel dafür ist die plattformunabhängige GUI-Programmierung, bei der GUI-Elemente funktional äquivalent sein können, sich jedoch im Aussehen und Detailverhalten unterscheiden.'},
     {'question': 'Warum hängt die Substituierbarkeit von Typen von ihrer jeweiligen Verwendung ab?', 'answer': 'Die Substituierbarkeit von Typen hängt von ihrer jeweiligen Verwendung ab, da verschiedene Anwendungsfälle unterschiedliche Anforderungen an Typen und deren Objekte haben können. Ein Typ kann in einem bestimmten Kontext problemlos durch einen anderen Typen ersetzt werden, während dies in einem anderen Kontext nicht der Fall sein kann. Die Substituierbarkeit ist daher relativ zur Verwendung der Typen.'},
     {'question': 'Warum ist es schwierig, das Fragile-Base-Class-Problem zu erkennen?', 'answer': 'Es ist schwer zu erkennen, da die Basisklasse auf den ersten Blick korrekt erscheint. Das Problem besteht darin, dass die Subklasse von bestimmtem Verhalten der Basisklasse abhängt, ohne dass dies in der Basisklasse explizit dokumentiert ist.'},
     {'question': 'Warum werden große Klassen in der objektorientierten Programmierung in der Regel vermieden?', 'answer': 'Große Klassen gelten in der Regel als schlechter Stil, da sie die Anwendungsdomäne nicht angemessen widerspiegeln. In der Anwendungsdomäne sind komplexe Dinge normalerweise aus einfacheren Teilen zusammengesetzt, die selbst wieder aus kleineren Teilen bestehen.'},
     {'question': 'Warum ist die Substituierbarkeit fraglich, wenn keine Typerweiterung vorliegt?', 'answer': 'Die Substituierbarkeit ist fraglich, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies führt zu Problemen, wenn Objekte eines Subtyps an Stellen verwendet werden, an denen Objekte des Supertyps erwartet werden.'},
     {'question': 'Warum reicht die Typkonformität allein nicht aus, um Substituierbarkeit sicherzustellen?', 'answer': 'Die Typkonformität allein reicht nicht aus, um Substituierbarkeit sicherzustellen, da auch das Verhalten der Objekte betrachtet werden muss. Typkonformität bedeutet nicht automatisch Substituierbarkeit. Substituierbarkeit erfordert eine Betrachtung des Verhaltens der Objekte.'},
     {'question': 'Warum wird bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung oft von einem Impedanzmismatch gesprochen?', 'answer': 'Bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung besteht häufig ein Impedanzmismatch, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Die beiden Ansätze verwenden unterschiedliche Mittel zur Darstellung von Beziehungen und Datenstrukturen.'},
     {'question': 'Warum kann bei größeren Programmen das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren?', 'answer': 'Bei größeren Programmen kann das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren, da verschiedene Vererbungshierarchien oder andere Strukturierungskriterien gleichzeitig relevant sein können, ähnlich wie in der Biologie, wo Arten nach verschiedenen Gesichtspunkten klassifiziert werden. Dies erfordert jedoch, dass die verschiedenen Darstellungen getrennt gepflegt werden und keine Inkonsistenzen oder ungewollten Interferenzen entstehen.'},
     {'question': 'Warum können private Instanzvariablen allein das Aliasing-Problem nicht lösen?', 'answer': 'Private Instanzvariablen können allein das Aliasing-Problem nicht lösen, da sie lediglich Namen verbergen und nicht verhindern können, dass Repräsentationsobjekte (Implementierungsdetails) Aliasen ausgesetzt sind.'},
     {'question': 'Was bedeutet es, wenn ein Typ als korrekt implementiert gilt?', 'answer': 'Ein Typ wird als korrekt implementiert betrachtet, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt und dass die Invarianten des Typs höchstens temporär während der Methodenausführung verletzt werden.'},
     {'question': 'Warum ist die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte, wichtig?', 'answer': 'Die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte, ist wichtig, weil sie genau weiß, welche Erwartungen sie an einen Typen hat und welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind.'},
     {'question': 'Warum ist es wichtig, dass Objekte typkonform sind?', 'answer': 'Es ist wichtig, dass Objekte typkonform sind, weil sie nur dann die ihnen zugewiesene Rolle spielen können. Wenn Objekte nicht typkonform sind, können sie nicht die gewünschten Funktionen erfüllen und können zu Fehlern im Programm führen.'},
     {'question': 'Was passiert, wenn ein Objekt nicht typkonform ist?', 'answer': 'Wenn ein Objekt nicht typkonform ist, kann es nicht die gewünschten Funktionen erfüllen und kann zu Fehlern im Programm führen.'},
     {'question': 'Was ist der Unterschied zwischen der Sicht der Nutzerin und der Sicht der Anbieterin auf Typen?', 'answer': 'Die Sicht der Nutzerin auf Typen ist, wie sie in einem Programm verwendet werden, während die Sicht der Anbieterin sich auf die Implementierung des Typs bezieht. Die Programmiersprachen Java und C-Sharp bieten das Konzept von "Interfaces als Typen" an, mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. In der Praxis wird diese Möglichkeit jedoch selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen.'},
     {'question': 'Warum ist es wichtig, dass die Schnittstelle einer Komponente für den Anbieter und den Client klar definiert ist?', 'answer': 'Damit der Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet.'},
     {'question': 'Warum wurde die Vererbung von Implementierung in Microsofts Component Object Model (COM) verbannt?', 'answer': 'Die Vererbung von Implementierung wurde in COM verbannt, weil der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen.'},
     {'question': 'Was ist der Vorteil von Interfaces gegenüber der Vererbung von Implementierung?', 'answer': 'Der Vorteil von Interfaces gegenüber der Vererbung von Implementierung ist, dass sie den Vertrag zwischen Klassen klar definiert und das dynamische Binden ermöglicht, ohne sich um die Implementierungsdetails kümmern zu müssen.'},
     {'question': 'Was ist der Nachteil von Interfaces gegenüber der Vererbung von Implementierung?', 'answer': 'Der Nachteil von Interfaces gegenüber der Vererbung von Implementierung ist, dass sie keine gemeinsam genutzten Implementierungen ermöglicht und die Code-Duplizierung erhöhen kann.'},
     {'question': 'Was ist der Unterschied zwischen der Schnittstelle, die einem Client einer Klasse angeboten wird und der Schnittstelle zwischen einer Klasse und ihren Subklassen?', 'answer': 'Die Schnittstelle, die einem Client einer Klasse angeboten wird, ist die Schnittstelle, die der Client nutzt, indem er Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann. Die Schnittstelle zwischen einer Klasse und ihren Subklassen hingegen ist eine etwas anders geartete Schnittstelle, die lediglich zwei Variablen, self (oder this) und super, umfasst und nicht explizit typisiert ist. Die Schnittstelle zwischen einer Klasse und ihren Subklassen muss man selbst zusammensuchen und ist nicht mit Information Hiding und dem Verbergen von Implementationsdetails zu tun.'},
     {'question': 'Was ist der Unterschied zwischen statischer und dynamischer Bindung?', 'answer': 'Statische Bindung findet zur Übersetzungszeit statt und ist damit schneller, während dynamische Bindung zur Laufzeit erfolgt und damit etwas langsamer ist. Statische Bindung wird verwendet, wenn der Compiler die Methodenaufrufe bereits zur Übersetzungszeit auflösen kann, während dynamische Bindung verwendet wird, wenn der Compiler die Methodenaufrufe nicht auflösen kann und sie daher zur Laufzeit auflösen muss.'},
     {'question': 'Was ist der Unterschied zwischen einem deklarativen und einem imperativen Programmierstil?', 'answer': 'Ein deklarativer Programmierstil beschäftigt sich mehr mit dem "Was" als mit dem "Wie" und beschreibt, was das Programm tun soll, während ein imperativer Programmierstil sich mehr auf die Anweisungen und die Reihenfolge der Befehle konzentriert, die das Programm ausführen soll, um ein bestimmtes Ergebnis zu erzielen.'},
     {'question': 'Was ist der Unterschied zwischen imperativer und deklarativer Programmierung?', 'answer': 'Imperative Programmierung ist eine Programmierparadigme, bei der der Programmierer explizit die Schritte angibt, die der Computer ausführen soll, um ein Problem zu lösen. Deklarative Programmierung hingegen ist eine Programmierparadigme, bei der der Programmierer lediglich die gewünschte Lösung angibt, ohne die Schritte zur Lösung des Problems zu spezifizieren. In der objektorientierten Programmierung ist es durchaus üblich, einzelne Schleifen aus einem Methodenrumpf in eine eigene Methode zu verschieben und durch einen entsprechenden Methodenaufruf zu ersetzen, um das Programm deklarativer zu gestalten, aber es ist immer noch imperativ.'},
     {'question': 'Was sollte man bei vermeintlichen Abkürzungen beachten?', 'answer': 'Man sollte sicherstellen, dass die Abkürzung funktional äquivalent ist, d.h. dasselbe Ergebnis liefert, bevor man solche Optimierungen vornimmt. Wenn beispielsweise "auswerten" für "Literale" einen Seiteneffekt hat, wären die optimierten Versionen nicht mehr äquivalent.'},
     {'question': 'Wozu können Zusicherungen in der objektorientierten Programmierung eingesetzt werden?', 'answer': 'Zusicherungen können in der objektorientierten Programmierung eingesetzt werden, um die Laufzeitverifikation zu ermöglichen und dem Aufrufer der Methode zu zeigen, wie er prüfen kann, ob die Vorbedingung eingehalten ist.'},
     {'question': 'Sind Abkürzungen in der Programmierung zu vermeiden?', 'answer': 'Abkürzungen sind nicht grundsätzlich zu vermeiden. Wenn sie etabliert sind und man davon ausgehen darf, dass eine Leserin des Programms sie kennt, ist ihre Verwendung sogar angezeigt. Man sollte jedoch auf hausgemachte Abkürzungen verzichten, deren Bedeutung nur von einem selbst bekannt ist.'},
     {'question': 'Warum spielt die Ausdrucksweise in Programmiersprachen eine Rolle?', 'answer': 'Die Ausdrucksweise in Programmiersprachen bestimmt nicht den Inhalt des Programms, sondern seine Qualität. Sie beeinflusst, wie effizient ein gegebenes Problem gelöst wird oder wie verständlich die Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat viel mit Schreibstil zu tun, aber auch andere Faktoren wie Mode und Ästhetik (Eleganz) spielen eine Rolle.'},
     {'question': 'Was ist der Unterschied zwischen einem mathematisch prägnanten Stil und einem prosaisch-verbosen Stil in der Programmierung?', 'answer': 'Ein mathematisch prägnanter Stil in der Programmierung zeichnet sich durch eine kompakte und präzise Schreibweise aus, während ein prosaisch-verboser Stil durch eine ausführliche und detaillierte Schreibweise gekennzeichnet ist.'},
     {'question': 'Was versteht man unter einem mathematisch prägnanten Stil in der Programmierung?', 'answer': 'Ein mathematisch prägnanter Stil in der Programmierung zeichnet sich durch eine kompakte, präzise und logische Schreibweise aus, die an die mathematische Notation erinnert. Er vermeidet unnötige Wiederholungen und nutzt stattdessen abstrakte Konzepte und Funktionen, um die Absicht des Programmcodes klar und eindeutig auszudrücken. Diese Art der Programmierung wird oft als "sauber" und "elegant" angesehen, da sie die Komplexität reduziert und die Wartbarkeit des Codes verbessert.'},
     {'question': 'Warum sind Kommentare in einem Programm nicht immer notwendig?', 'answer': 'Heutzutage ist es üblich, Bezeichner in einem Programm so zu wählen, dass Kommentare zur Bedeutung der jeweiligen Programmelemente unnötig sind, da die Bezeichner ihre Bedeutung bereits im Kontext ausdrücken. Ein gut geschriebenes objektorientiertes Programm benötigt daher eigentlich keine Kommentare.'},
     {'question': 'Was passiert, wenn die Verkettung von Nachrichtenausdrücken länger wird?', 'answer': 'Wenn die Verkettung von Nachrichtenausdrücken länger wird, wird das Protokoll der Klasse von "a" komplexer und muss mit entsprechenden Implementierungen versehen werden.'},
     {'question': 'Wozu dienen feingranulare Klassen in der objektorientierten Programmierung?', 'answer': 'Feingranulare Klassen in der objektorientierten Programmierung sind nützlich, um die Anwendungsdomäne angemessen abzubilden und die Komplexität der Klassen zu reduzieren. Sie ermöglichen eine bessere Strukturierung der Klassen und erleichtern die Wartung und Weiterentwicklung des Codes.'},
     {'question': 'Was ist der Unterschied zwischen Objekten und Klassen in Bezug auf die Teil-Ganzes-Beziehung?', 'answer': 'Objekte können mithilfe der Teil-Ganzes-Beziehung rekursiv aufgebaut werden, während Klassen nicht hierarchisch strukturiert werden können. Objekte sind einzelne Exemplare (Instanzen) und können Teile haben, während Klassen Typen von Objekten sind und nicht immer Teile von anderen Klassen sind.'},
     {'question': 'Was ist der Unterschied zwischen Komponenten und Klassen in objektorientierten Programmiersprachen?', 'answer': 'Im Gegensatz zu Klassen, die in objektorientierten Programmiersprachen verwendet werden, um Objekte zu definieren, werden Komponenten verwendet, um Objekte zur Laufzeit zusammenzubauen. Leider ist der Begriff "Komponente" in objektorientierten Programmiersprachen noch nicht weit verbreitet und wird oft durch andere Konzepte wie Pakete oder Assemblies ersetzt, die lediglich Klassen gruppieren.'},
     {'question': 'Welche Vorteile haben Namenskonventionen in der Programmierung?', 'answer': 'Namenskonventionen in der Programmierung haben mehrere Vorteile. Sie erleichtern die Bezeichnerwahl, begrenzen die schöpferische Freiheit der Programmiererin, was als Entlastung empfunden werden kann, und machen das Lesen von Code einfacher, da Entwicklerinnen, die die Konventionen kennen, die Bedeutung der Bezeichner schneller entschlüsseln können und sich somit schneller zurechtfinden.'},
     {'question': 'Welche Vorteile ergeben sich aus kurzen Methoden in der objektorientierten Programmierung?', 'answer': 'Kurze Methoden in der objektorientierten Programmierung fördern die Lesbarkeit und den objektorientierten Stil. Sie erlauben es, Teile einer Methode in separate, klar benannte Methoden auszulagern, was die Lesbarkeit und Wartbarkeit des Codes verbessert. Dieser Stil fördert auch die Verwendung von aussagekräftigen Bezeichnern und trägt zur besseren Dokumentation des Codes bei.'},
     {'question': 'Was wird durch die Deklaration von Klassen als abstrakt oder final erreicht?', 'answer': 'Das Deklarieren von Klassen als abstrakt oder final ermöglicht es, Änderungen an der Funktionalität der Klasse auf sichere Weise durchzuführen. Wenn eine Klasse als abstrakt deklariert ist, können Änderungen in den abgeleiteten Subklassen vorgenommen werden, ohne die anderen Klassen in der Hierarchie zu beeinflussen. Wenn eine Klasse als final deklariert ist, kann sie nicht abgeleitet werden, was bedeutet, dass ihre Funktionalität nicht geändert werden kann. Dies ermöglicht es, den Vertrag zwischen der Klasse und ihren Klienten zu schützen und unerwartete Verhaltensänderungen zu verhindern.'},
     {'question': 'Warum werden Interfaces oft mit Substantiven oder Adjektiven bezeichnet?', 'answer': 'Interfaces sind wie Klassen Typen, aber sie bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte spielen können. Diese Rollen werden häufig durch Substantive oder Adjektive bezeichnet. Zum Beispiel enden viele Interfacenamen im Englischen auf „able“ oder „ible“, wie "Serializable."'},
     {'question': 'Was kennzeichnet den deklarativen Programmierstil in der objektorientierten Programmierung?', 'answer': 'Der deklarative Programmierstil in der objektorientierten Programmierung legt mehr Wert auf das "Was" als auf das "Wie". Er betont die Ausdrucksform und verschiebt mögliche Optimierungen auf den Compiler oder später in der Entwicklung. Das bedeutet, dass die Programmiererin sich auf das Beschreiben dessen konzentriert, was erreicht werden soll, anstatt detaillierte Anweisungen zur Durchführung zu geben.'},
     {'question': 'Ist es möglich, die Einhaltung des Gesetzes Demeters automatisch zu überprüfen?', 'answer': 'Die automatische Überprüfung des Gesetzes Demeters gestaltet sich schwierig, da das Gesetz in Bezug auf Objekte formuliert ist und die Auswertung von konkreten Zuweisungen und dynamischen Programmfluss erfordern würde, was mechanisch extrem aufwendig oder sogar unmöglich ist. Stattdessen überprüfen automatische Checker des Gesetzes Demeters in der Regel die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters haben.'},
     {'question': 'Warum muss man bei der Verwendung von Collections als Zwischenobjekte immer eine Ausnahme von Demeters Gesetz machen?', 'answer': 'Bei der Verwendung von Collections als Zwischenobjekte muss man eine Ausnahme von Demeters Gesetz machen, weil die Verwendung von Iteratoren und Methoden wie "detect:" eine Verkettung von Nachrichten erzeugt, die in direktem Widerspruch zum Gesetz Demeters steht. Dies liegt daran, dass die Klausel "detect:" auf einer Kollektion nicht dem Prinzip des Gesetzes Demeters entspricht, bei dem Nachrichten nur an Objekte gesendet werden dürfen, die der Sender selbst kennt oder erzeugt.'},
     {'question': 'Warum können in Java abgeleitete Typen keine Eigenschaften unterdrücken?', 'answer': 'In Java können abgeleitete Typen keine Eigenschaften unterdrücken, weil es in Java nicht möglich ist, die öffentlich zugängliche Schnittstelle eines abgeleiteten Typs von der des Basistyps zu unterscheiden. Wenn ein Objekt vom Typ Stack in einem Programmabschnitt erwartet wird, in dem ein Objekt vom Typ Vector auftauchen kann, kann das Programm nicht fortgesetzt werden, wenn es auf ein Element zugreifen will, wenn stattdessen ein Stack vorliegt. Eine solche Prüfung muss zur Laufzeit erfolgen, und wenn sie vergessen wird, kann dies zu einem schwerwiegenden Programmierfehler führen. Solche Fehler lassen sich einfach vermeiden, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.'},
     {'question': 'Was ist der Unterschied zwischen Typkonformität und Substituierbarkeit?', 'answer': 'Typkonformität bedeutet, dass ein Objekt dem erwarteten Typ entspricht, während Substituierbarkeit bedeutet, dass ein Objekt anstelle eines anderen Objekts verwendet werden kann, ohne dass sich das Verhalten des Programms ändert. Typkonformität ist eine notwendige, aber nicht hinreichende Bedingung für Substituierbarkeit.'},
     {'question': 'Was sind die Nachteile der objektorientierten Programmierung?', 'answer': 'Die Nachteile der objektorientierten Programmierung sind, dass die Organisation der Funktionen auf der Strecke bleibt und dass die Daten hin- und hergeschickt werden müssen.'},
     {'question': 'Was sind die Vorteile von Sprachen, die eine Mischung mehrerer Programmierparadigmen erlauben?', 'answer': 'Die Vorteile von Sprachen, die eine Mischung mehrerer Programmierparadigmen erlauben, sind, dass sie eine größere Auswahl an Konstrukten bieten und eine unüberschaubare Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann.'},
     {'question': 'Warum ist es nicht möglich, für verschiedene Instanzen einer Klasse verschiedene Implementierungen einer Methode anzugeben?', 'answer': 'Da sich die Instanzen einer Klasse alle Methoden teilen, ist es nicht möglich, für verschiedene Instanzen derselben Klasse verschiedene Implementierungen einer Methode anzugeben.'},
     {'question': 'Was ist der Unterschied zwischen Verhalten des Programms und seiner Spezifikation?', 'answer': 'Die Spezifikation eines Programms beschreibt, was das Programm tun soll, während das Verhalten des Programms beschreibt, was das Programm tatsächlich tut. Die Spezifikation ist eine Art Blaupause oder Anleitung für das Programm, während das Verhalten das Ergebnis der Ausführung des Programms ist.'},
     {'question': 'Was ist der Nachteil des Liskov-Substitutionsprinzips?', 'answer': 'Der Nachteil des Liskov-Substitutionsprinzips ist, dass es sich in der Praxis als zu restriktiv erweist und eine Typüberprüfung darstellt, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.'},
     {'question': 'Warum ist es wichtig, verschiedene Vererbungshierarchien in einem Programm getrennt voneinander zu pflegen?', 'answer': 'Es ist wichtig, verschiedene Vererbungshierarchien in einem Programm getrennt voneinander zu pflegen, um Inkonsistenzen im Code und ungewollte Interferenzen zu vermeiden.'},
     {'question': 'Was sind die Nachteile der Vererbung in objektorientierter Programmierung?', 'answer': 'Die Vererbung in objektorientierter Programmierung kann die Kapselung von Klassen auf unangenehme Weise aufbrechen und starke Abhängigkeiten zwischen Klassen und ihren Subklassen erzeugen. Diese Abhängigkeiten explizit zu machen, kann zwar vor Programmierfehlern schützen, aber sie nicht beseitigen. Die Abhängigkeiten zu beschränken, bedeutet, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben.'},
     {'question': 'Was ist der Unterschied zwischen einem Alias und einem Wert?', 'answer': 'Ein Alias ist eine Referenz auf ein Objekt, während ein Wert eine eigene Kopie des Objekts ist. Wenn man einen Alias ändert, dann ändert man das Originalobjekt, während man bei einem Wert nur die Kopie ändert. Im Beispiel von "jetzt" und "Time now" sind beide Alias auf das gleiche Zeitobjekt, und wenn man das Zeitobjekt ändert, dann ändert sich auch die Erzeugungszeit von "a".'},
     {'question': 'Was sind die Nachteile, wenn Aliase in Programmiersprachen verboten werden?', 'answer': 'Wenn Aliase in Programmiersprachen verboten werden, schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein. Ein Beispiel dafür ist die Verwendung von Klassen als Werttypen in Programmiersprachen wie C-Sharp, C++ und EIFFEL, bei der bei Zuweisungen nicht automatisch Aliase entstehen.'},
     {'question': 'Was ist der Unterschied zwischen einer Kopie und einem Zeiger auf Objekte?', 'answer': 'In Bezug auf Objekte ist eine Kopie eine unabhängige Instanz des Objekts, während ein Zeiger auf das originale Objekt verweist. In Sprachen ohne Referenzsemantik ist es nicht möglich, Zeiger zu verwenden, während Sprachen mit Referenzsemantik dies ermöglichen.'},
     {'question': 'Was ist der Unterschied zwischen Namensschutz und Geheimnisprinzip?', 'answer': 'Namensschutz (name protection) verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, indem es ihre Namen verbirgt. Das Geheimnisprinzip (information hiding) hingegen verhindert, dass andere Klassen von der Implementierung eines Objekts abhängen, indem es die Möglichkeit schafft, die Implementierung ohne Auswirkungen auf andere Klassen zu ändern.'},
     {'question': 'Was wird durch den Namensschutz verhindert?', 'answer': 'Der Namensschutz verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, sodass diese problemlos geändert werden können.'},
     {'question': 'Beschreiben Sie das Problem, das im Zusammenhang mit Subtyping und dynamischem Methodenaufruf auftritt?', 'answer': 'Das Problem besteht darin, dass aufgrund des dynamischen Bindens von Methodenaufrufen nicht vorhergesagt werden kann, welchen Effekt ein Aufruf der Methode in einem bestimmten Programmfragment haben wird, selbst wenn der Typ des Empfängerobjekts bekannt ist. Es ist schwer zu bestimmen, welcher Subtyp des Typs des Empfängerobjekts tatsächlich betroffen ist.'},
     {'question': 'Kann man die Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung beschreiben?', 'answer': 'Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können.'}
     ]
]
