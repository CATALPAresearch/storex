"""
Questions
"""
# TODO: Remove once added"
KE2_questions = []
KE3_questions = []
KE4_questions = []
KE5_questions = []
KE7_questions = []

# TODO: Keywords, linking between questions?

KE1_topics = {'question': "Was sind die Grundkonzepte der objektorientierten Programmierung?",
              'keywords': {'terms': ["Objekt", "Beziehung", "Zustand", "Verhalten"]}}

KE2_topics = {'question': "Was ist die Systematik der objektorientierten Programmierung?",
              'keywords': {'terms': ["Klasse", "Metaklasse", "Generalisierung", "Spezialisierung", "Vererbung",
                                     "abstrakte Klasse", "Superklasse", "Subklasse", "dynamisches Binden", "Collection",
                                     "Verhalten", "Eingabestrom", "Ausgabestrom", "Parallelität"]}}

KE3_topics = {'question': "Was sind Typen in der objektorientierten Programmierung?",
              'keywords': {'terms': ["Deklaration", "Definition", "Verwendung", "Typdefinition",
                                     "Zuweisungskompatibilität", "Typäquivalenz", "Typerweiterung", "Typkonformität",
                                     "Typeinschränkung", "Subtyping", "Inklusionspolymorphie", "Typumwandlung",
                                     "Generischer Typ", "parametrischer Polymorphismus", "Kovarianz", "Typisierung"]}}

KE4_topics = {'question': "Was sind die Besonderheiten von JAVA?",
              'keywords': {'terms': ["Programmiermodell", "Objekt", "Typ", "Klasse", "Ausdruck", "Anweisung", "Block",
                                     "Kontrollstruktur", "Modul", "Interface", "Array", "Aufzählungstyp",
                                     "Generischer Typ", "dynamische Typprüfung", "interne Iteration",
                                     "externe Iteration", "spezielle Klasse"]}}

# TODO:
KE5_topics = {'question': "Was sind die Besonderheiten anderer objektorientierter Programmiersprachen?",
              'keywords': {'terms': ["C#", "C++", "EIFFEL"]}}

KE6_topics = {'question': "Was sind Probleme der objektorientierten Programmierung?",
              'keywords': {'terms': ["Problem der Substituierbarkeit",
                                     "Fragile-base-class-Problem",
                                     "Problem der schlechten Tracebarkeit",
                                     "Problem der eindimensionalen Strukturierung",
                                     "Problem der mangelnden Kapselung",
                                     "Problem der mangelnden Skalierbarkeit",
                                     "Problem der mangelnden Eignung"]}}

KE7_topics = {'question': "Was ist guter objektorientierter Stil?",
              'keywords': {'terms': ["Namen", "Formatierung", "kurze Methoden", "deklarativ", "Bibliothek",
                                     "Verteilung", "Gesetz Demeters", "Klassenhierarchie"]}}

KE6_solutions = [
    {'question': "Was ist das Liskov-Substitutionsprinzip?",
     'keywords': ['verhaltensbezogenes Subtyping', 'Subtypenrelation', 'Kontravarianz der Argumenttypen',
                  'Kovarianz des Ergebnistyps', 'Kovarianz der Ausnahmen', 'implizierte Vorbedingungen',
                  'implizierende Nachbedingungen', 'implizierende Invarianten', 'restriktiv']},
    {'question': "Welchen Lösungsansatz gibt es für das Fragile-Base-Class-Problem?",
     'keywords': ['explizites Vererbungsinterface', 'Zugriffsmodifikatoren']},
    {'question': "Welchen Lösungsansatz gibt es für das Problem der mangelnden Kapselung?",
     'keywords': ['Teil-Ganzes-Beziehung', 'kein Alias auf Wertobjekte']},
]
# TODO: What are good answers and keywords? Paraphrase answers/ multiple correct answers
KE6_questions = [
    # {'question': "Was ist das Problem der Substituierbarkeit?",
    #  'keywords': ['Zuweisungskompatibilität', 'nichtkonforme Verhaltensänderung',
    #  'keine Prüfung der Substituierbarkeit', "Liskov-Substitutionsprinzip",],
    #  'follow-up': [KE6_solutions[0]]},
    # {'question': "Welche Probleme gibt es bei Subtyping unter Wertsemantik?", 'keywords': []},
    {'question': "Was ist das Fragile-Base-Class-Problem?",
     'keywords': ['Vererbung', 'Abhängigkeit', 'anfällig', 'Subklasse', 'unerwartet', 'Verhalten'],
     'answer': 'Das Fragile-Base-Class-Problem bezieht sich auf eine Gruppe von Problemen in der Vererbung von Klassen. '
               'Wenn zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke '
               'Abhängigkeiten bestehen, können Änderungen an der Basisklasse, welche etwa durch eine unvollständige '
               'Dokumentation nicht auffallen, zu unerwarteten und unerwünschten Auswirkungen in der abgeleiteten '
               'Klasse führen.', 'follow-up': [KE6_solutions[1]]},
    {'question': "Was ist das Problem der schlechten Tracebarkeit?",
     'keywords': ['dynamischer Programmablauf', 'Goto-Anweisung', 'durchbrochenes Lokalitätsprinzip',
                  'Unterprogrammaufrufe', 'dynamisches Binden'],  # 'schweres Debuggen'
     'answer': 'Das Problem der schlechten Tracebarkeit entsteht durch den dynamischen Programmablauf. Die '
               'Goto-Anweisung erlaubt Sprünge von beliebigen Stellen eines Programms zu anderen Stellen und bricht '
               'dabei das Lokalitätsprinzip von Programmen, bei dem zusammengehörende Anweisungen im Programmtext nahe '
               'beieinander stehen. Dies führte zu einer Unübersichtlichkeit im Programmtext und erschwerte das '
               'Verstehen und Debuggen von Programmen.'},
    {'question': "Was ist das Problem der eindimensionalen Strukturierung?",
     'keywords': ['mehrere Strukturierungskriterien', 'unzureichende Trennung der Belange'],
     'answer': 'Bei größeren Programmen kann das Bedürfnis entstehen, ein Programm nach mehreren Kriterien '
               'gleichzeitig zu strukturieren, da verschiedene Vererbungshierarchien oder andere '
               'Strukturierungskriterien gleichzeitig relevant sein können. Die Trennung der Belange, auch als '
               'Separation of Concerns bekannt, wird in der objektorientierten Programmierung als unzureichend '
               'unterstützt angesehen, da es schwer ist, verschiedene Aspekte eines Systems sauber voneinander zu '
               'trennen.'},
    {'question': "Was ist das Problem der mangelnden Kapselung?",
     'keywords': ['Vererbung', 'Abhängigkeit', 'Aliasing-Problem', 'Geheimnisprinzip'], 'follow-up': [KE6_solutions[2]],
     'answer': 'Vererbung führte zu starken Abhängigkeiten zwischen Klassen und ihren Subklassen. Das Aliasing-Problem '
               'tritt auf, wenn ein Objekt, das von einem anderen Objekt gekapselt wird, auch einen Alias besitzt, der '
               'nicht selbst dem kapselnden Objekt gehört. Dies bedeutet, dass von außen auf das gekapselte Objekt '
               'zugegriffen werden kann, indem man ein Alias verwendet. Dies stellt eine Herausforderung für die '
               'Kapselung dar, das Geheimnisprinzip durchbrochen werden kann.'}
    # {'question': "Was ist das Aliasing-Problem?",
    #  'keywords': ['Zugriff auf gekapselte Objekte', 'Referenz auf Repräsentationsobjekte',
    #               'Umgehen des Geheimnisprinzips', 'verschiedene Typen']},
    # {'question': "Was ist das Problem der mangelnden Skalierbarkeit?", 'keywords': ['mangelnde Komponenten']},
    # {'question': "Was ist das Problem der mangelnden Eignung?", 'keywords': ['geeignete Programmiersprache',
    #                                                                          'Abwägungsproblem']}
]

KE1_questions = [
    {'question': 'Was ist ein Literal?', 'answer': 'Ein Literal ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten.'},
    {'question': 'Was ist der Unterschied zwischen Literale und objekterzeugenden Anweisungen?', 'answer': 'Der Compiler erzeugt bei der Übersetzung eines Literals das entsprechende Objekt im Speicher, während objekterzeugende Anweisungen erst zur Laufzeit des Programms ausgeführt werden.'},
    {'question': 'Warum sind Literale keine Objekte?', 'answer': 'Literale repräsentieren Objekte, sind jedoch selbst keine Objekte, da sie textuelle Spezifikationen von Objekten sind.'},
    {'question': 'Was sind die einfachsten Literale in SMALLTALK?', 'answer': 'Die einfachsten Literale in SMALLTALK repräsentieren Zeichenobjekte.'},
    {'question': 'Was sind atomare Objekte?', 'answer': 'Atomare Objekte sind Zeichenobjekte und Zahlobjekte, die nicht aus anderen Objekten bestehen.'},
    {'question': 'Was sind Pseudo-Variablen in SMALLTALK?', 'answer': 'In SMALLTALK sind die in anderen Programmiersprachen vorhandenen Literale, die ebenfalls atomare Objekte repräsentieren, Pseudo-Variablen.'},
    {'question': 'Was sind Strings?', 'answer': 'Strings sind aus Zeichen zusammengesetzte Zeichenketten. String-Literale repräsentieren also zusammengesetzte Objekte.'},
    {'question': 'Was sind Symbole in SMALLTALK?', 'answer': 'Symbole sind eine weitere Art von Objekten mit literaler Repräsentation in SMALLTALK. Sie dienen dazu, sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen.'},
    {'question': 'Was ist der Unterschied zwischen Symbole und Strings in SMALLTALK?', 'answer': 'Symbole dürfen im Gegensatz zu Strings keine Leerzeichen enthalten. Zudem ist die Erzeugung eines Objekts anhand eines Symbolliterals technisch aufwendiger als die Erzeugung eines Objekts anhand eines String-Literals.'},
    {'question': 'Was kann bei der Verwendung von identischen Symbolliteralen passieren?', 'answer': 'Bei der Verwendung identischer Symbolliterale kann es durch sogenanntes Aliasing zu unerwarteten Ergebnissen führen.'},
    {'question': 'Was sind Array-Literale in SMALLTALK ?', 'answer': 'Array-Literale repräsentieren Objekte, die aus einer Folge beliebiger anderer Objekte bestehen.'},
    {'question': 'Was sind unveränderliche Objekte?', 'answer': 'Unveränderliche oder zustandslose Objekte in SMALLTALK sind Objekte, deren Zustand nicht geändert werden kann. Operationen oder Methoden, die auf solchen Objekten ausgeführt werden, ändern nicht den Zustand des Objekts selbst, sondern erzeugen in der Regel ein neues Objekt als Ergebnis.'},
    {'question': 'Was ist die Gleichheit von Objekten?', 'answer': 'Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten und wird in SMALLTALK durch den Gleichheitsoperator getestet.'},
    {'question': 'Was ist die Identität von Objekten?', 'answer': 'Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren.'},
    {'question': 'Was ist der Unterschied zwischen Gleichheit und Identität von Objekten?', 'answer': 'Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten. Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren.'},
    {'question': 'Warum können syntaktisch gleiche String-Literale in SMALLTALK unterschiedliche Identitäten haben?', 'answer': 'Syntaktisch gleiche String-Literale können in SMALLTALK unterschiedliche Identitäten haben, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen.'},
    {'question': 'Warum sind gleiche Zahlen nur manchmal identisch in SMALLTALK?', 'answer': 'In SMALLTALK werden gleiche Zahlen manchmal als identisch behandelt und manchmal nicht, abhängig von ihrer Größe und technischen Gründen.'},
    {'question': 'Was ist der Unterschied zwischen "das gleiche" und "dasselbe"?', 'answer': 'In der objektorientierten Programmierung sind "das gleiche" und "dasselbe" nicht dasselbe. Zwei Objekte können gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins.'},
    {'question': 'Warum ist die Identität von Objekten wichtig?', 'answer': 'Die Identität von Objekten ist wichtig, um festzustellen, ob zwei Namen oder Variablen dasselbe Objekt repräsentieren oder nicht.'},
    {'question': 'Warum haben veränderliche Objekte eine Identität?', 'answer': 'Veränderliche Objekte haben eine Identität um sie auch bei vorübergehender Gleichheit voneinander unterscheiden zu können, da sie sich hinterher wieder auseinanderentwickeln können.'},
    {'question': 'Warum haben unveränderliche Objekte eine Identität?', 'answer': 'Unveränderliche Objekte haben aus technischen Gründen eine Identität. Wenn sich ein unveränderliches Objekt aus einer Operation ergibt, dann müsste für eine Zusammenlegung gleicher Objekte zu einem immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Ganze Zahlen bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind.'},
    {'question': 'Wie sendet man Nachrichten in Zu-1-Beziehungen?', 'answer': 'In Zu-1-Beziehungen in SMALLTALK sendet man oft Nachrichten direkt an das Objekt, auf das die betreffende Variable verweist.'},
    {'question': 'Wie sendet man Nachrichten in Zu-n-Beziehungen?', 'answer': 'Bei Zu-n-Beziehungen erreicht die Nachricht nicht mehr die logisch in Beziehung stehenden Objekte, sondern das Zwischenobjekt, das die Beziehung selbst repräsentiert (der Wert der Variable). Um die Nachricht stattdessen an alle von diesem Zwischenobjekt referenzierten Objekte zu senden, verwendet man die Nachricht do: aBlock, wobei aBlock ein Block ist, der mit einem Parameter parametrisiert ist und der für jedes Element des Arrays genau einmal (mit dem Element als tatsächlichem Parameter) aufgerufen wird.'},
    {'question': 'Warum gibt es in SMALLTALK keine Schlüsselwörter?', 'answer': 'In SMALLTALK gibt es keine Schlüsselwörter, sondern nur Symbole mit spezieller Bedeutung. Stattdessen sind alle aus anderen Sprachen bekannten Schlüsselwörter in SMALLTALK als Methoden implementiert.'},
    {'question': 'Was sind reservierte Namen in SMALLTALK?', 'answer': 'In SMALLTALK gibt es einige reservierte Namen, die als Pseudovariablen dienen. Diese reservierten Namen sind: true, false, nil, self and super. Alle anderen Schlüsselwörter, die in anderen Programmiersprachen üblich sind, werden in SMALLTALK als Methoden definiert.'},
    {'question': 'Was sind anonyme Funktionen?', 'answer': 'Blöcke in SMALLTALK können auch als anonyme Funktionen aufgefasst werden.'},
    {'question': 'Was sind parametrisierten Blöcke?', 'answer': 'Parametrisierte Blöcke können mit Parametern versehen werden, die bei ihrer Auswertung an Objekte aus dem Auswertungskontext gebunden werden können.'},
    {'question': 'Was ist der Home Context eines Blocks in SMALLTALK?', 'answer': 'Der Home Context eines Blocks in SMALLTALK ist der Kontext, in dem der Block definiert wurde oder genauer gesagt, in dem das ihn repräsentierende Objekt erzeugt wurde. Dieser Kontext enthält Informationen über die lokalen Variablen und formalen Parameter, die der Block "einfängt". Die Ausführung eines Blocks erfolgt immer in seinem Home Context, selbst wenn der Block in einem anderen Kontext ausgewertet wird.'},
    {'question': 'Was sind Closures?', 'answer': 'Closures sind in SMALLTALK Blöcke für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können.'},
    {'question': 'Was sind Blöcke?', 'answer': 'Blöcke in SMALLTALK werden in anderen Programmiersprachen oft als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, die anonyme Funktionen repräsentieren und als Objekte oder Werte behandelt werden können. Closures erlauben es, Funktionen aus ihrem Kontext herauszulösen und in andere Kontexte zu übertragen. Die Verwendung und das Verhalten von Closures können sich jedoch zwischen verschiedenen Programmiersprachen erheblich unterscheiden.'},
    {'question': 'Was sind Attribute?', 'answer': 'Attribute sind Instanzvariablen, die die Eigenschaften eines Objekts festhalten.'},
    {'question': 'Was sind Kategorien von Instanzvariablen?', 'answer': 'Instanzvariablen können logischerweise in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Eigenschaften sind Attribute wie Farbe oder Name, die ihre Bedeutung verlieren, wenn sie isoliert betrachtet werden. Beziehungen hingegen repräsentieren Verbindungen zwischen Objekten und behalten ihre Bedeutung auch isoliert betrachtet.'},
    {'question': 'Welche Semantik haben Variablen, die Attribute repräsentieren?', 'answer': 'Variablen, die Attribute repräsentieren, haben in der Regel eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Dies ermöglicht es, dass Änderungen an einem Attributwert nicht automatisch andere Objekte mit dem gleichen Attributwert beeinflussen.'},
    {'question': 'Welche Objekte sind in SMALLTALK veränderbar?', 'answer': 'Atomare Objekte und Objekte, die aus Symbolliteralen hervorgegangen sind, sind grundsätzlich nicht veränderbar. Zusammengesetzte Objekte in SMALLTALK sind jedoch veränderbar.'},
    {'question': 'Warum sind atomare Objekte grundsätzlich nicht veränderbar?', 'answer': 'Atomare Objekte sind grundsätzlich nicht veränderbar, da es keinen Sinn ergibt, sie zu verändern. Zum Beispiel macht es keinen Sinn, aus einer "1" eine "2" zu machen.'},
    {'question': 'Warum könnten zusammengesetzte Objekte veränderbar sein?', 'answer': 'Zusammengesetzte Objekte könnten veränderbar sein, da es sinnvoll sein kann, eine Komponente durch eine andere zu ersetzen.'},
    {'question': 'Sind Array-Objekten in SMALLTALK veränderbar?', 'answer': 'Zusammengesetzte Array-Objekte sind in der Regel veränderbar. Ob Array-Objekte, die aus Literalen erzeugt wurden, veränderbar sein sollen, ist ansichtssache und wird von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt.'},
    {'question': 'Warum sind zusammengesetzte Objekte in SMALLTALK grundsätzlich veränderbar?', 'answer': 'Zusammengesetzte Objekte sind in SMALLTALK grundsätzlich veränderbar, da dies eine Voraussetzung dafür ist, dass Objekte einen Zustand haben können.'},
    {'question': 'Warum bieten immer mehr Sprachen unveränderliche Objekte an?', 'answer': 'Immer mehr Sprachen bieten unveränderliche Objekte an aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung.'},
    {'question': 'Was ist die Sequenz als Kontrollstruktur in SMALLTALK?', 'answer': 'Die Sequenz als Kontrollstruktur besagt lediglich, dass textuell aufeinanderfolgende Anweisungen eines Programms (einer Methode) auch zeitlich nacheinander ausgeführt werden. Die zeitliche Sequenz aufeinanderfolgender Anweisungen kann lediglich durch andere Kontrollstrukturen unterbrochen werden.'},
    {'question': 'Wie kann eine Sequenz unterbrochen werden?', 'answer': 'In SMALLTALK kann die zeitliche Sequenz von aufeinanderfolgenden Anweisungen nur durch den Methodenaufruf unterbrochen werden.'},
    {'question': 'Was sind Kontrollstrukturen?', 'answer': 'Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, die seine Ausführung bestimmen. In SMALLTALK gibt es ie Sequenz und den dynamisch gebundenen Methodenaufruf.'},
    {'question': 'Welche Kontrollstrukturen gibt es in SMALLTALK?', 'answer': 'In SMALLTALK gibt es nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf.'},
    {'question': 'Was sind Verzweigungen und Wiederholungen in SMALLTALK?', 'answer': 'Verzweigungen und Wiederholungen in SMALLTALK werden durch die Verwendung von Blöcken und dynamisch gebundenen Methodenaufrufen simuliert. Da SMALLTALK keine direkten Verzweigungs- und Schleifenkonstrukte wie in einigen anderen Programmiersprachen hat, werden Entscheidungen und Wiederholungen durch den Aufruf entsprechender Methoden und die Auswertung von Blöcken erreicht.'},
    {'question': 'Was ist eine Zuweisung?', 'answer': 'Eine Zuweisung ist der Vorgang, bei dem einer Variable ein Objekt zugewiesen wird, damit sie dieses Objekt bezeichnet.'},
    {'question': 'Warum ist die Zuweisung kommutativ?', 'answer': 'Die Zuweisung ist nicht kommutativ, da "x := y" und "y := x" unterschiedliche Bedeutungen haben, es sei denn, "x" und "y" hatten bereits denselben Wert vor der jeweiligen Zuweisung.'},
    {'question': 'Was ist der Unterschied zwischen Zuweisungen unter Wertsemantik und Verweissemantik?', 'answer': 'Bei Zuweisungen unter Wertsemantik muss eine Kopie des Objekts angefertigt werden, da die Variable das Objekt selbst speichert. Bei Zuweisungen unter Verweissemantik wird nur der Verweis auf das Objekt kopiert und in der Variable gespeichert. Dies hat Auswirkungen darauf, ob Änderungen an einem Objekt in einer Variable sich auf dasselbe Objekt in einer anderen Variable auswirken.'},
    {'question': 'Was ist ein Block in SMALLTALK?', 'answer': 'Ein Block in SMALLTALK ist eine abgegrenzte Sequenz oder Folge von Anweisungen. Anders als eine Methode ist ein Block nicht benannt, kann aber einer Variable zugewiesen werden.'},
    {'question': 'Wie werden Blöcke in SMALLTALK ausgeführt?', 'answer': 'Bei der Ausführung des Blockausdrucks wird ein neues Blockobjekt erzeugt.'},
    {'question': 'Was sind Instanzvariablen?', 'answer': 'Instanzvariablen sind lokale Variablen, die einem Objekt zugeordnet sind und dazu verwendet werden, Informationen zu speichern, die spezifisch für dieses Objekt sind. Sie bestimmen die Struktur zusammengesetzter Objekte.'},
    {'question': 'Was ist die Sichtbarkeit von Instanzvariablen in SMALLTALK?', 'answer': 'Die Sichtbarkeit von Instanzvariablen in SMALLTALK ist auf das besitzende Objekt beschränkt. Instanzvariablen können von anderen Objekten nicht direkt zugegriffen werden.'},
    {'question': 'Was sind zwei Arten von Instanzvariablen in SMALLTALK?', 'answer': 'In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte Instanzvariablen.'},
    {'question': 'Was sind benannte Instanzvariablen in SMALLTALK?', 'answer': 'Benannte Instanzvariablen sind Instanzvariablen, die jeweils auf ein bestimmtes Objekt verweisen oder es benennen. Der Name der Variablen wird zum Namen des Objekts, auf das sie verweisen.'},
    {'question': 'Was sind indizierte Instanzvariablen in SMALLTALK?', 'answer': 'Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zum Objekt angesprochen, dem sie gehören. Der Index fungiert gewissermaßen als Name für die Instanzvariable.'},
    {'question': 'Was sind Indexer?', 'answer': 'Indexer sind ähnlich zu indizierten Instanzvariablen und werden beispielsweise von C# und VISUAL BASIC verwendet.'},
    {'question': 'Wie ist die Anzahl indizierten Instanzvariablen eines Objekts?', 'answer': 'Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix, und die Größe eines Objekts mit indizierten Instanzvariablen ist ebenfalls fest und kann nicht verändert werden.'},
    {'question': 'Welche Arten von Ausdrücken gibt es?', 'answer': 'Es gibt Literale, Variablen, Zuweisungsausdrücke und Nachrichtenausdrücke.'},
    {'question': 'Was sind primitive Ausdrücke?', 'answer': 'Primitive Ausdrücke sind nicht aus anderen Ausdrücken zusammengesetzt, wie Literale und Variablen.'},
    {'question': 'Welche zwei Ausdrücke sind wichtig?', 'answer': 'Zuweisungsausdrücke und Nachrichtenausdrücke sind wichtig. Sie ermöglichen es, Aktionen mit den repräsentierten Objekten auszuführen und damit ein Programm tatsächlich auszuführen.'},
    {'question': 'Was sind Anweisungen?', 'answer': 'Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird.'},
    {'question': 'Wie werden Anweisungen in SMALLTALK getrennt?', 'answer': 'In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt.'},
    {'question': 'Welche Funktion hat die Return-Anweisung in SMALLTALK?', 'answer': 'Die Return-Anweisung gibt das Objekt zurück, zu dem der nachfolgende Ausdruck ausgewertet wird. Sie wird in Methoden und Blöcken verwendet, um das Ergebnis der Ausführung zurückzugeben.'},
    {'question': 'Was sind primitive Methoden?', 'answer': 'Primitive Methoden sind primitive Operationen, die auf native Implementierungen zurückgreifen. Diese Methoden sind durch Nummern identifiziert und sollen nicht direkt von Programmierern verwendet werden.'},
    {'question': 'Was ist der Lebenslauf von Objekten in SMALLTALK?', 'answer': 'In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung.'},
    {'question': 'Was ist die "Garbage Collection" in SMALLTALK?', 'answer': 'Die "Garbage Collection" ist ein Mechanismus in SMALLTALK, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr über Variablen zugreifbar sind.'},
    {'question': 'Wann kann ein Objekt in SMALLTALK aus dem Speicher entfernt werden?', 'answer': 'Ein Objekt in SMALLTALK kann aus dem Speicher entfernt werden, wenn keine Variable mehr auf dieses Objekt verweist und es somit nicht mehr erreichbar ist.'},
    {'question': 'Welche Objekte sind von der automatischen Speicherbereinigung ausgenommen?', 'answer': 'Von der automatischen Speicherbereinigung ausgenommen sind Objekte mit eindeutiger literaler Repräsentation, wie kleine Zahlen, Zeichen und Symbole. Zahlen und Zeichen werden durch Werte in Variablen repräsentiert und Symbole sind in einer Symboltabelle abgelegt.'},
    {'question': 'Warum wurde in SMALLTALK die explizite Speicherfreigabe aufgegeben?', 'answer': 'Die explizite Speicherfreigabe wurde in SMALLTALK aufgegeben, da es schwierig ist, genau zu verfolgen, welche Objekte noch referenziert werden, insbesondere in großen und komplexen Programmen. Die Verantwortung dafür den Anwendungsprogrammierern zu überlassen, würde zu vielen potenziellen Programmierfehlern führen.'},
    {'question': 'Was sind die Vorteile der Garbage Collection in SMALLTALK?', 'answer': 'Die Garbage Collection verhindert vorzeitige Entfernung von Objekten, die noch in Verwendung sind, und stellt sicher, dass Variablen auf gültige Objekte verweisen. Dies trägt zur Stabilität und Sicherheit von Programmen bei.'},
    {'question': 'Warum ist "Lebenszyklus" eines Objekts irreführend?', 'answer': 'Der Begriff "Lebenszyklus" würde implizieren, dass das Objekt nach seinem Ende wiederverwendet wird, was nicht der Fall ist. Objekte werden nicht recycelt, sondern nur der von ihnen belegte Speicherplatz wird möglicherweise wiederverwendet.'},
    {'question': 'Was ist der Nachrichtenversand in SMALLTALK?', 'answer': 'Hinter dem Nachrichtenversand in SMALLTALK verbirgt sich der Methodenaufruf. Wenn ein Objekt eine Nachricht an ein Empfängerobjekt sendet, wird der Kontrollfluss zur Methode des Empfängerobjekts verschoben, die zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung dieser Methode kehrt der Kontrollfluss an das sendende Objekt zurück und setzt seine Arbeit dort fort.'},
    {'question': 'Was passiert nach einer Methode in SMALLTALK?', 'answer': 'Bei der Rückkehr nach der Abarbeitung einer Methode in SMALLTALK wird das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Dies ermöglicht die Weiterverarbeitung des Ergebnisses im Kontext des aufrufenden Objekts.'},
    {'question': 'Was ist die Auswertung von Ausdrücken?', 'answer': 'Die Auswertung von Ausdrücken ist der Prozess, bei dem ein Programm tatsächlich Aktionen ausführt. Sie ist wichtig, weil sie den eigentlichen "Tätigkeitsprozess" eines Programms darstellt und sicherstellt, dass die gewünschten Operationen durchgeführt werden.'},
    {'question': 'Was ist eine Zuweisung?', 'answer': 'Eine Zuweisung ist eine Aktion, bei der der Inhalt einer Variable geändert wird. Die Zuweisung selbst steht für (eine Referenz auf) das Objekt. Dies ist eine Art von Seiteneffekt der Auswertung des Ausdrucks.'},
    {'question': 'Was sind primitive Ausdrücke in SMALLTALK?', 'answer': 'Die Zuweisung wird in SMALLTALK als primitiver Ausdruck betrachtet.'},
    {'question': 'Wie werden Nachrichtenausdrücke in SMALLTALK ausgewertet?', 'answer': 'Nachrichtenausdrücke in SMALLTALK werden ausgewertet, indem die Nachricht (das Prädikat) an das Empfängerobjekt (das Subjekt) mit den Parametern (Prädikatsergänzungen) gesendet wird. Nach der Auswertung repräsentiert der Nachrichtenausdruck das Ergebnis der Nachricht, das von dem Empfängerobjekt zurückgegeben wird.'},
    {'question': 'Ist es in SMALLTALK möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben?', 'answer': 'In SMALLTALK ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben, da jeder Nachrichtenversand ein Ergebnis zurückgibt. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API (fließende Programmierung).'},
    {'question': 'Was ist ein Methodenaufruf?', 'answer': 'Ein Methodenaufruf ist die Auswertung eines Nachrichtenausdrucks, da diese zur Ausführung der Anweisungen im Rumpf einer Methode führt.'},
    {'question': 'Was sind Objekte in der objektorientierten Programmierung?', 'answer': 'Objekte sind in der objektorientierten Programmierung Daten, die im Speicher abgelegt sind und in der Lage sind, Informationen zu speichern und Aktionen auszuführen. Sie repräsentieren Dinge aus der realen Welt und können miteinander in Beziehung stehen.'},
    {'question': 'Was sind Inkonsistenzen im objektorientierten Weltbild?', 'answer': 'In der objektorientierten Programmierung werden verschiedene Arten von Sachverhalten, die in der realen Welt unterschiedliche Eigenschaften haben, durch Objekte repräsentiert. Dies kann zu Inkonsistenzen führen, da nicht alle Sachverhalte dieselben Eigenschaften wie Objekte haben. Dies ist auf die homogene Natur der Objektorientierung zurückzuführen.'},
    {'question': 'Was ist der Unterschied zwischen einem Objekt und einem Wert?', 'answer': 'Objekte haben eine eindeutige Identität und sind an einer bestimmten Stelle im Speicher abgelegt, während Werte an verschiedenen Stellen im Speicher vorkommen können und keine Identität haben.'},
    {'question': 'Was ist das Motto von SMALLTALK?', 'answer': 'Das Motto von SMALLTALK lautet "alles ist ein Objekt".'},
    {'question': 'Warum haben Objekte im Speicher eine konstante Größe?', 'answer': 'Objekte im Speicher haben eine feste Größe, die aus technischen Gründen nicht verändert werden kann. Wenn ein Objekt mehr Platz benötigt oder verkleinert werden muss, muss ein neues Objekt erzeugt werden, das an die Stelle des alten tritt. Dieses neue Objekt hat jedoch eine andere Identität.'},
    {'question': 'Was sind Pseudovariablen in SMALLTALK?', 'answer': 'Pseudovariablen in SMALLTALK sind Variablen wie "true", "false", "nil", "self", "super" und formale Parameter von Methoden sowie Klassennamen, denen der Programmierer keinen Wert zuweisen kann.'},
    {'question': 'Warum werden Pseudovariablen als solche bezeichnet?', 'answer': 'Sie werden als Pseudovariablen bezeichnet, da sie ihren Wert entweder nicht ändern können oder ihren Wert vom System erhalten.'},
    {'question': 'Warum ist die Zuweisung für Pseudovariablen in SMALLTALK nicht zulässig?', 'answer': 'Die Zuweisung für Pseudovariablen ist in SMALLTALK nicht zulässig, da sie auf Objekte von spezifischer Bedeutung verweisen und diese Bedeutung nicht verändert werden sollte.'},
    {'question': 'Was ist der "Inhalt" einer Variable?', 'answer': 'Der "Inhalt" einer Variable bezieht sich auf das Objekt, das von der Variable bezeichnet wird.'},
    {'question': 'Was ist Verweis- oder Referenzsemantik?', 'answer': 'Bei Verweis- oder Referenzsemantik haben Variablen nur Verweise die Speicherstellen, an denen die Objekte abgelegt sind.'},
    {'question': 'Was ist Wertsemantik?', 'answer': 'Bei Wertsemantik macht das bezeichnete Objekt tatsächlich den Inhalt der Variable aus.'},
    {'question': 'Was ist eine Variable aus technischer Sicht?', 'answer': 'Aus technischer Sicht entspricht eine Variable einer Stelle im Speicher.'},
    {'question': 'Was sind Variablen mit Verweissemantik?', 'answer': 'Es handelt sich bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen.'},
    {'question': 'Was ist der Unterschied zwischen Verweissemantik und Wertsemantik von Variablen?', 'answer': 'Unter Wertsemantik können zwei Variablen niemals dasselbe Objekt bezeichnen, während Verweissemantik erlaubt, dass mehrere Variablen auf dasselbe Objekt verweisen.'},
    {'question': 'Warum wird in der objektorientierten Programmierung häufig Verweissemantik verwendet?', 'answer': 'Verweissemantik wird in der objektorientierten Programmierung häufig verwendet, da sie einen speicher- und recheneffizienten Umgang mit Objekten ermöglicht und unterschiedliche Objekte unterschiedlich viel Speicherplatz belegen.'},
    {'question': 'Haben Variablen Wert- oder Verweissemantik?', 'answer': 'In manchen Sprachen haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik, z. B. JAVA. Andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll, z. B. C++ und EIFFEL.'},
    {'question': 'Welche Variablen haben in SMALLTALK Wertsemantik?', 'answer': 'In den meisten SMALLTALK-Implementationen haben Variablen, die Zeichen, kleine Zahlen und boolesche Werte bezeichnen, Wertsemantik, um Speicherplatz zu sparen, obwohl der Begriff der Identität für diese Objekte verloren geht. Die mehrfache Existenz identischer Objekte im Speicher hat in der Regel keine große Bedeutung, da Gleichheit an die Stelle der Identität treten kann.'},
    {'question': 'Was ist der Home Contexts eines Blocks?', 'answer': 'Das Konzept des Home Contexts eines Blocks in SMALLTALK umfasst nicht nur die sichtbaren Variablen aus dem Kontext der Definition des Blocks, sondern auch den sogenannten Call Stack, der die Rücksprungadressen von Methodenaufrufen speichert.'},
    {'question': 'Was ist eine Continuation?', 'answer': 'Im Kontext von Blöcken in SMALLTALK bezieht sich "Continuation" auf das Konzept, dass eine Return-Anweisung innerhalb eines Blocks immer zur unmittelbaren Rückkehr in den Home Context des Blocks führt. Dieses Konzept stammt aus der Welt der funktionalen Programmierung und spielt bei der Implementierung von Kontrollstrukturen in SMALLTALK eine wichtige Rolle.'},
    {'question': 'Warum können Continuations zu Laufzeitfehlern führen?', 'answer': 'Continuations können zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde. Return-Anweisungen in Blöcken sind daher ein umstrittenes Konzept.'},
    {'question': 'Was bezeichnet eine Variable?', 'answer': 'Eine Variable bezeichnet ein Objekt.'},
    {'question': 'Wie wird der Zugriff auf Variablen einzuschränken?', 'answer': 'Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen.'},
    {'question': 'Was ist die Sichtbarkeit einer Variable?', 'answer': 'Die Sichtbarkeit einer Variable bezieht sich immer auf einen Abschnitt des Programmcodes, in dem der Variablenname verwendet werden kann und damit Zugriff auf das von diesem Namen bezeichnete Objekt besteht.'},
    {'question': 'Was ist der Unterschiede zwischen globalen und lokalen Variablen?', 'answer': 'Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht. Globale Variablen sind auch außerhalb davon von überall her sichtbar.'},
    {'question': 'Wie wird die Iteration in SMALLTALK realisiert?', 'answer': 'Die Iteration in SMALLTALK erfolgt durch eine Form der internen Iteration, bei der die Steuerstruktur für das Fortschreiten durch Elemente und die Überprüfung der Abbruchbedingung innerhalb der Sammlung erfolgt, über die iteriert wird.'},
    {'question': 'Was ist interne Iteration?', 'answer': 'Bei der internen Iteration erfolgt die Steuerstruktur für das Fortschreiten durch Elemente und die Überprüfung der Abbruchbedingung innerhalb der Sammlung erfolgt, über die iteriert wird.'},
    {'question': 'Was ist externe Iteration?', 'answer': 'Bei der traditionellen externen Iteration muss manuell eine Schleifenvariable als Index verwaltet werden.'},
    {'question': 'Was ist das Geheimnisprinzip?', 'answer': 'Das Geheimnisprinzip oder Information Hiding bezieht sich auf das Verbergen von Implementationsdetails eines Objekts, insbesondere der Struktur zusammengesetzter Objekte, vor den Objekten, die sie verwenden. Dadurch können Änderungen an der Struktur vorgenommen werden, ohne dass abhängige Objekte davon betroffen sind.'},
    {'question': 'Was ist Kapselung?', 'answer': 'Bei der Kapselung geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann.'},
    {'question': 'Was ist der Unterschied zwischen dem Geheimnisprinzip und der Kapselung?', 'answer': 'Der Unterschied besteht darin, dass das Geheimnisprinzip sich auf das Verbergen von Implementationsdetails und Struktur bezieht, während die Kapselung sich auf das Verbergen und die Kontrolle des Zustands eines Objekts bezieht.'},
    {'question': 'Wie wird die Kapselung umgesetzt?', 'answer': 'Über lokale Instanzvariablen kann ein Objekt verbergen, welche Objekte es kennt. Aber aufgrund von Aliasing kann ein Objekt, dessen Name unsichtbar ist, über einen anderen Namen zugänglich sein kann.'},
    {'question': 'Warum kann ein Objekt seinen inneren Aufbau nicht kapseln?', 'answer': 'Ein Objekt kann seinen inneren Aufbau nicht vollständig vor der Außenwelt abkapseln, da aufgrund der möglichen Existenz von Aliasen andere Objekte diese Objekte kennen und ohne sein Wissen manipulieren können. Die Abschottung erfordert spezielle Vorkehrungen, die derzeit nicht in gängige objektorientierte Programmiersprachen integriert sind und explizit programmiert werden müssen.'},
    {'question': 'Wie sind Instanzvariablen in SMALLTALK sichtbar?', 'answer': 'In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar, um den Zustand des Objekts zu kapseln und seine Struktur vor direktem Zugriff von außen zu schützen.'},
    {'question': 'Was sind Zugriffsmethoden?', 'answer': 'Zugriffsmethoden sind Methoden, um die Belegung der Instanzvariablen und damit den Zustand eines Objekts auszulesen oder zu verändern. In JAVA gibt es dafür Getter und Setter.'},
    {'question': 'Was ist der Unterschied zwischen einer benannten Instanzvariable und einer indizierten Instanzvariable in SMALLTALK?', 'answer': 'In SMALLTALK können benannte Instanzvariablen direkt über ihren Namen zugegriffen werden, während indizierte Instanzvariablen nur über die vordefinierten Nachrichten "at:" und "at:put:" gelesen und geschrieben werden können. Der Zugriff auf indizierte Instanzvariablen erfolgt nicht über Zugriffsmethoden, sondern über diese Nachrichten.'},
    {'question': 'Was ist das Interface eines Objekts?', 'answer': 'Das Interface eines Objekts ist die Art und Weise, wie ein Objekt seinen Zustand codiert, als sein Implementationsgeheimnis und die Menge der Methodensignaturen, die den Zugriff auf das Objekt (seinen Zustand) erlauben.'},
    {'question': 'Was sind Schlüsselwörter?', 'answer': 'In Programmiersprachen wie PASCAL, C oder JAVA repräsentieren Schlüsselwörter Kontrollstrukturen.'},
    {'question': 'Was sind Kontrollstrukturen?', 'answer': 'Die grundlegenden Kontrollstrukturen sind: Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf.'},
    {'question': 'Wie ist das Goto angesehen?', 'answer': 'Das Goto wird in der strukturierten Programmierung als unerwünscht angesehen.'},
    {'question': 'Was sind Kontrollstrukturen in SMALLTALK?', 'answer': 'In SMALLTALK sind Kontrollstrukturen auf Sequenz und Aufruf begrenzt. Alle anderen Kontrollstrukturen, einschließlich Verzweigung und Wiederholung, müssen mithilfe der Sprache simuliert werden.'},
    {'question': 'Was ist der Vorteil der Kontrollstrukturen in SMALLTALK?', 'answer': 'In SMALLTALK wird es als bedeutender Vorteil angesehen, dass Programmierer neue Kontrollstrukturen einführen können, wenn sie es wünschen.'},
    {'question': 'Was sind Kardinalitäten?', 'answer': 'Kardinalitäten sind in der Daten- und Softwaremodellierung häufig verwendete Beziehungsattribute, die angeben, wie viele andere Objekte ein Objekt in einer Beziehung haben kann.'},
    {'question': 'Welche Beziehungen gibt es?', 'answer': 'Es gibt Zu-1-Beziehungen und Zu-n-Beziehungen wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.'},
    {'question': 'Wie werden Zu-1-Beziehungen umgesetzt?', 'answer': 'Zu-1-Beziehungen können direkt durch benannte Instanzvariablen zwischen Objekten umgesetzt werden.'},
    {'question': 'Wie werden Zu-n-Beziehungen umgesetzt?', 'answer': 'Zu-n-Beziehungen werden meistens über Zwischenobjekte umgesetzt, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen.'},
    {'question': 'Warum werden Zu-n-Beziehungen über Zwischenobjekte umgesetzt?', 'answer': 'Zu-n-Beziehungen werden über Zwischenobjekte umgesetzt, da die indizierten Instanzvariablen eines Objekts nicht benannt sind und daher nicht zwischen verschiedenen Zu-n-Beziehungen unterschieden werden kann'},
    {'question': 'Was sind Zwischenobjekte?', 'answer': 'Die Aufgabe von Zwischenobjekten ist es, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Zwischenobjekte können zusätzliche Attribute enthalten, die in ihren benannten Instanzvariablen gespeichert werden.'},
    {'question': 'Wie sind Methoden Objekten zugeordnet?', 'answer': 'Methoden sind immer Objekten, den sogenannten Empfängerobjekten, zugeordnet.'},
    {'question': 'Was ist das Protokoll eines Objekts?', 'answer': 'Das Protokoll eines Objekts ist der Katalog von Methoden, über den ein Objekt verfügt und auf den es entsprechend reagieren kann.'},
    {'question': 'Warum ist die Zuordnung von Methoden zu Objekten wichtig?', 'answer': 'Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen und somit das Verhalten des Objekts zu spezifizieren und zu beeinflussen.'},
    {'question': 'Was ist die Variable "self" in Methoden?', 'answer': 'Die Variable "self" verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird benötigt, wenn eine Nachricht aus einer Methode heraus an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. "self" ist somit der implizite erste Parameter einer Methode.'},
    {'question': 'Was ist die Teil-Ganzes-Beziehung?', 'answer': 'Die Teil-Ganzes-Beziehung bestimmt die Weltansicht, dass alles aus kleineren Teilen zusammengesetzt ist, die selbst wieder Zusammensetzungen (Aggregate, Komposita) sind, bis hinunter zu den elementaren, unteilbaren Bausteinen.'},
    {'question': 'Warum ist die Teil-Ganzes-Beziehung komplixiert?', 'answer': 'Die Definition der Teil-Ganzes-Beziehung ist komplex, da es verschiedene Arten von Beziehungen zwischen einem Ganzen und seinen Teilen gibt, die je nach Art der Zusammensetzung unterschiedliche Wechselwirkungen aufweisen. Es existieren sowohl physische als auch logische Teil-Ganzes-Beziehungen, und diese Vielfalt macht es schwer, eine klare und einheitliche Definition zu finden.'},
    {'question': 'Was bieten objektorientierten Programmiersprachen für die Teil-Ganzes-Beziehung?', 'answer': 'Die meisten objektorientierten Programmiersprachen bieten keine speziellen Sprachkonstrukte für die Teil-Ganzes-Beziehung. Stattdessen können Programmierer die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik nutzen, um eine bestimmte Form der Teil-Ganzes-Beziehung darzustellen. Bei Wertsemantik werden beim Entfernen eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt.'},
    {'question': 'Warum ist die Teil-Ganzes-Beziehung in der objektorientierten Programmierung von Bedeutung?', 'answer': 'Die Teil-Ganzes-Beziehung ist in der objektorientierten Programmierung wichtig, da sie es ermöglicht, komplexe Software-Systeme aus Teilen aufzubauen, wobei jeder Teil seine eigene interne Struktur kapselt. Dies hilft dabei, sicherzustellen, dass keine Aliasnamen für Teile existieren und Änderungen an einem Teil nicht unabsichtlich andere Teile beeinflussen. Dieses Konzept ist entscheidend für die Entwicklung komplexer und intakter Software-Systeme.'},
    {'question': 'Wie wird die einfache Verzweigung in SMALLTALK realisiert?', 'answer': 'In SMALLTALK wird die einfache Verzweigung durch das Versenden einer Nachricht an einen Wahrheitswert realisiert. Diese Nachricht enthält die bedingt auszuführenden Anweisungen in Form eines Blocks als Parameter.'},
    {'question': 'Was ist der Unterschied zwischen veränderlichen und unveränderlichen Objekten?', 'answer': 'Veränderliche Objekte können ihren Zustand im Laufe der Zeit ändern, während unveränderliche Objekte keinen Zustand haben und ihre Werte konstant bleiben.'},
    {'question': 'Was ist der Zustand eines Objekts?', 'answer': 'Der Zustand eines Objekts setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert.'},
    {'question': 'Wie wird der Zustand eines Objekts verändern?', 'answer': 'Die einzige Möglichkeit, den Zustand eines Objekts zu ändern, besteht darin, die Werte seiner Instanzvariablen zuzuweisen, was gleichbedeutend mit der Änderung seiner Beziehungen ist.'},
    {'question': 'Worauf lässt sich der Zustand eines Objekts eingrenzen?', 'answer': 'Der Zustand eines Objekts lässt sich in einer eingeschränkten Sicht auf seine Attributwerte eingrenzen.'},
    {'question': 'Was ist der Unterschied zwischen Attributen und Beziehungen?', 'answer': 'Die Unterscheidung zwischen Attributen und Beziehungen kann in Ermangelung spezieller Schlüsselwörter allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese ist jedoch in einigen Programmiersprachen wie Java nicht immer eindeutig ist.'},
    {'question': 'Warum ändert sich der Zustand eines Objekts nur über Instanzvariablen?', 'answer': 'Wenn Änderungen am Zustand eines Objekts, auf das ein anderes Objekt per Instanzvariable verweist, als Änderung des Zustands des ersten Objekts betrachtet würden, könnte jede Änderung an einem Objekt zu einer Kettenreaktion führen, da der Zustand aller Objekte, die darauf verweisen, sich ändern würde. Dies entspricht nicht unserem üblichen Verständnis von Zustand.'},
    {'question': 'Warum ist der Zustandsbegriff nicht auf mehrere Objekte im Allgemeinen ausgedehnt?', 'answer': 'Der Zustandsbegriff kann nicht auf mehrere Objekte im Allgemeinen ausgedehnt werden, da dies zu komplexen Problemen führen würde und das objektorientierte Modell nicht ohne Herausforderungen ist. Programmierfehler könnten in vermeintlich simplen Situationen auftreten.'},
    {'question': 'Wann ist es angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen?', 'answer': 'Es ist angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen, wenn es sich um Kompositionen handelt, also um aus Teilen zusammengesetzte Ganze.'},
    {'question': 'Was sind konstante Methoden?', 'answer': 'Konstante Methoden sind Methoden, die immer dasselbe Objekt zurückgeben. Sie werden häufig verwendet, um Literale auf eine Weise zu repräsentieren, die sicherstellt, dass sie konsistent sind und immer auf dasselbe Objekt verweisen.'},
    {'question': 'Warum werden konstante Methoden verwendet?', 'answer': 'Konstante Methoden werden verwendet, um sicherzustellen, dass bestimmte Literale in einem Programm konsistent sind und immer auf dasselbe Objekt verweisen. Dies ist wichtig, um Probleme im Zusammenhang mit Objektidentität und Vergleichen zu vermeiden.'},
    {'question': 'Was ist ein Problem bei konstanten Methoden?', 'answer': 'Bei der erneuten Übersetzung einer Methode mit einer konstanten Methode wird möglicherweise ein neues Objekt erzeugt, das nicht identisch mit dem zuvor zurückgegebenen Objekt ist. Dies kann zu Problemen führen, wenn das zuvor zurückgegebene Objekt in Variablen gespeichert wurde und mit dem neuen Objekt auf Identität verglichen wird.'},
    {'question': 'Was sind Zuweisungsausdrücke?', 'answer': 'Zuweisungsausdrücke bestehen aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite. Sie bewirken den Zustandswechsel von Objekten und sind die einzigen Ausdrücke, die dies tun.'},
    {'question': 'Welche Auswirkung haben Zuweisungsausdrücke auf Objekte?', 'answer': 'Zuweisungsausdrücke ändern den Zustand von Objekten, indem sie neue Werte in Variablen zuweisen.'},
    {'question': 'Was ist das Verhalten eines Objekts?', 'answer': 'Wenn Objekte ihren Zustand kapseln, ist ausschließlich sas Verhalten eines Objekts dafür verantwortlich, den Zustand eines Objekts zu ändern und die Interaktion mit diesem Objekt zu steuern. Das Verhalten bestimmt, wie ein Objekt auf Nachrichten reagiert und welche Operationen es auf seinem internen Zustand durchführt.'},
    {'question': 'Warum hängt das Verhalten eines Objekts von seinem Zustand ab?', 'answer': 'Das Verhalten eines Objekts hängt in der Regel von seinem Zustand ab, weil der Zustand eines Objekts die Informationen enthält, die benötigt werden, um die richtigen Entscheidungen zu treffen und die entsprechenden Aktionen auszuführen. Das Verhalten eines Objekts basiert auf den Daten in seinem Zustand, und diese Daten beeinflussen, wie das Objekt auf Nachrichten reagiert.'},
    {'question': 'Welche ist die zweite wichtige Ausdrucksform neben der Zuweisung?', 'answer': 'Die weite wichtige Ausdrucksform neben der Zuweisung in der objektorientierten Programmierung ist der Nachrichtenversand.'},
    {'question': 'Was sind "unäre Nachrichten"?', 'answer': '"Unäre Nachrichten" sind parameterlose Nachrichten, die den Empfänger als implizites erstes Argument haben.'},
    {'question': 'Was sind "binäre Nachrichten"?', 'answer': '"Binäre Nachrichten" sind Nachrichten mit einem Parameter, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.'},
    {'question': 'Was sind Schlüsselwortnachrichten in SMALLTALK?', 'answer': 'Schlüsselwortnachrichten sind Nachrichten in SMALLTALK, die neben dem Empfänger mindestens ein Argument erfordern. Sie enthalten normalerweise kein herkömmliches Schlüsselwort im Sinne von Schlüsselwort-Argumenten, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.'},
    {'question': 'Was ist ein Nachrichtenausdruck?', 'answer': 'Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.'},
    {'question': 'Was ist die Kaskadierung in SMALLTALK?', 'answer': 'Die Kaskadierung ist eine syntaktische Abkürzung in SMALLTALK, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen. Dies erleichtert das Verketten von Nachrichten an dasselbe Objekt.'},
    {'question': 'Ist die Reihenfolge der Nachrichtenteile in SMALLTALK von Bedeutung?', 'answer': 'Die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor bestimmt die Bedeutung der Nachricht. Der Nachrichtenselektor selbst ist ein Symbol, das aus der Konkatenation aller seiner Teile besteht.'},
    {'question': 'Wie kann man Nachrichten in SMALLTALK als Objekte verwenden?', 'answer': 'In SMALLTALK kann man Nachrichten (oder Nachrichtenselektoren) selbst als Objekte verwenden, indem man die Methode "perform:" verwendet. Diese Methode ermöglicht es, einem Empfängerobjekt eine Nachricht als Objekt zu senden, und das Empfängerobjekt führt die zur Nachricht passende Methode aus, als hätte es einen entsprechenden Methodenaufruf erhalten.'},
    {'question': 'Was ist der Nachrichtenselektor?', 'answer': 'Der Nachrichtenselektor ist der Name der Nachricht, die an ein Objekt gesendet wird. Der Nachrichtenselektor ist wichtig, da er angibt, welche Methode auf dem Empfängerobjekt aufgerufen werden soll.'},
    {'question': 'Was ist das Protokoll in SMALLTALK?', 'answer': 'In SMALLTALK ist das Protokoll eines Objekts die Menge der Nachrichten, die es versteht. Es wird in Form der Protokollbeschreibung spezifiziert und besteht aus den Methodensignaturen und den dazugehörigen Kommentaren der Methoden. Das Protokoll beschreibt das Interface eines Objekts.'},
    {'question': 'Wie wird das Protokoll in SMALLTALK unterteilt?', 'answer': 'Das Protokoll von Objekten in SMALLTALK wird oft in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien haben Namen, die die enthaltenen Methodennamen zusammenfassen. Nachrichtenkategorien dienen der besseren Lesbarkeit und partitionieren das Interface eines Objekts. Einige Kategorien können das Wort "private" enthalten, um anzuzeigen, dass die darin enthaltenen Methoden vorzugsweise nur vom Objekt selbst aufgerufen werden sollten.'},
    {'question': 'Was ist der Unterschied zwischen Protokoll und Implementierung in SMALLTALK?', 'answer': 'Das Protokoll beschreibt das Interface eines Objekts und umfasst die Methodensignaturen und dazugehörigen Kommentare. Die Implementierung hingegen besteht aus den tatsächlichen Methodenrümpfen und den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Das Protokoll dient dazu, das Verhalten eines Objekts zu beschreiben, während die Implementierung die Details der Umsetzung enthält.'},
    {'question': 'Wie werden Protokolle in SMALLTALK spezifiziert?', 'answer': 'In SMALLTALK werden Protokolle nicht auf Objektebene, sondern auf Klassenebene spezifiziert. Dies bedeutet, dass eine Klasse ein bestimmtes Protokoll implementiert und die Objekte dieser Klasse dieses Protokoll erben. In STRONGTALK, einer Erweiterung von SMALLTALK, werden Protokolle zu Typen erhoben und ähneln Interfaces in JAVA.'},
    {'question': 'Wie wird ein Nachrichtenausdruck in SMALLTALK übersetzt?', 'answer': 'Ein Nachrichtenausdruck wird in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung vergleichbar ist.'},
    {'question': 'Von welchem Objekt hängt die Auswahl der Methode ab?', 'answer': 'Die Auswahl der Methode, die aufgerufen wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Verschiedene Objekte mit gleichen Methodensignaturen können unterschiedliche Methodenimplementierungen haben.'},
    {'question': 'Was ist dynamisches Binden?', 'answer': 'Dynamisches Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung, bei der die Auswahl der Methodenimplementierung erst zur Laufzeit erfolgt, abhängig vom Empfängerobjekt des Methodenaufrufs. Dies wird auch als Polymorphismus oder Polymorphie bezeichnet.'},
    {'question': 'Was ist statisches Binden?', 'answer': 'Bei statischem Binden wird ein Methodenaufruf schon zur Übersetzungszeit an eine Implementierung gebunden.'},
    {'question': 'Wie erfolgt die Zuweisung der formalen Parameter in einer Methode?', 'answer': 'Die Zuweisung der formalen Parameter erfolgt in einer Methode durch eine implizite Zuweisung der tatsächlichen Parameter des Methodenaufrufs an die formalen Parameter der Methode.'},
    {'question': 'Was passiert, wenn ein Methodenaufruf in SMALLTALK ins Leere läuft?', 'answer': 'Wenn ein Methodenaufruf ins Leere läuft, wird er in einen Aufruf der Methode "doesNotUnderstand:" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung, die besagt, dass das Objekt die Nachricht nicht versteht. Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren.'},
    {'question': 'Wie kann man sich ein laufendes objektorientiertes Programm vorstellen?', 'answer': 'Ein laufendes objektorientiertes Programm kann man sich als eine Menge interagierender Objekte vorstellen. Diese Objekte sind miteinander verbunden und bilden ein Geflecht von Beziehungen. Das Geflecht ändert sich dynamisch durch die Interaktion der Objekte, wobei bestimmte statische Strukturen durch das Programm vorgegeben sind.'},
    {'question': 'Warum ist die Unterscheidung zwischen Statik und Dynamik in der Programmierung wichtig?', 'answer': 'Die Unterscheidung zwischen Statik und Dynamik ist wichtig, um das Verhalten von Programmen zu verstehen. Programme haben eine statische Struktur, die ihre Komponenten und ihre Beziehungen zueinander beschreibt. Diese Struktur kann als Grundlage für die Ausführung des Programms dienen. Auf der anderen Seite ist die Ausführung eines Programms immer dynamisch und kann sich im Laufe der Zeit ändern. Die Unterscheidung hilft dabei, die Beziehung zwischen der Programmstruktur und ihrem Verhalten zu verstehen.'},
    {'question': 'Wie kann die Unterscheidung zwischen Struktur und Verhalten in der objektorientierten Programmierung angewendet werden?', 'answer': 'In der objektorientierten Programmierung kann die Unterscheidung zwischen Struktur und Verhalten angewendet werden, um die verschiedenen Aspekte eines Programms zu analysieren und zu gestalten. Die Struktur bezieht sich auf das Objektgeflecht und die Beziehungen zwischen den Objekten. Das Verhalten bezieht sich auf die Spezifikation der Änderungen, die im Verlauf der Programmausführung auftreten. Diese Unterscheidung kann bei der Analyse und Gestaltung von Programmen hilfreich sein, da sie ermöglicht, sich auf die Struktur und das Verhalten von Objekten und Klassen zu konzentrieren und diese getrennt zu behandeln.'},
    {'question': 'Warum reichen Literale zum Programmieren nicht aus?', 'answer': 'Literale reichen zum Programmieren nicht aus, weil sie immer die gleichen Objekte repräsentieren.'},
    {'question': 'Was sind Variablen?', 'answer': 'Variablen sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können.'},
    {'question': 'Warum gibt es Variablen?', 'answer': 'Variablen sind notwendig, weil Literale immer die gleichen Objekte repräsentieren, weshalb sie zum Programmieren nicht ausreichen.'},
    {'question': 'Was ist der Unterschied zwischen Variablen und Literale?', 'answer': 'Anders als bei Literalen wird aus einer Variable kein Objekt erzeugt, sie ist lediglich ein Name für ein bereits existierendes Objekt.'},
    {'question': 'Wie ist die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK?', 'answer': 'Die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK wird durch Präzedenzen und Klammern festgelegt.'},
    {'question': 'In welcher Reihenfolge werden Ausdrücke ausgewertet?', 'answer': 'In SMALLTALK werden Ausdrücke normalerweise von links nach rechts ausgewertet.'},
    {'question': 'Welche Ausdrücke haben in SMALLTALK Vorrang?', 'answer': 'In SMALLTALK haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke haben Vorrang vor Schlüsselwortnachrichten.'},
    {'question': 'Wie kann die Reihenfolge der Auswertung in SMALLTALK verändert werden?', 'answer': 'Um die Reihenfolge der Auswertung in SMALLTALK zu ändern, können Klammern verwendet werden, um sicherzustellen, dass bestimmte Teile eines Ausdrucks zuerst ausgewertet werden.'},
    {'question': 'Warum stehen Objekte in Beziehung zueinander?', 'answer': 'Objekte stehen in Beziehung zueinander, um Bedeutung zu erlangen. Die meisten Objekte in einem System werden erst durch ihre Beziehungen zu anderen Objekten nützlich.'},
    {'question': 'Wie werden Informationen dargestellt?', 'answer': 'In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt. Dieses Geflecht kann navigiert und manipuliert werden.'},
    {'question': 'Wie wird das Geflecht von Objekten genutzt?', 'answer': 'Das Geflecht von Objekten kann navigiert werden, um von einem Datum zu einem anderen zu kommen, oder auch manipuliert werden, um die repräsentierte Information zu verändern.'},
    {'question': 'Wie werden Beziehungen zwischen Objekten hergestellt?', 'answer': 'Beziehungen zwischen Objekten werden über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten "navigieren". Dabei ist zu beachten, dass diese Verknüpfung immer gerichtet ist und man nicht zwangsläufig wieder zurücknavigieren kann.'},
    {'question': 'Wie werden Variablen für Beziehungen genutzt?', 'answer': 'Variablen enthalten Verweise. Wenn jemand Zugriff auf die Variable hat, kann er auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.'},
    {'question': 'Was ist eine Methode?', 'answer': 'Eine Methode beschreibt, was ein Objekt in Reaktion auf den Erhalt einer bestimmten Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf (Methodensignatur), einer optionalen Liste von lokalen Variablen und einem Methodenrumpf, der die Anweisungen für die Ausführung der Methode enthält.'},
    {'question': 'Was ist eine Methodensignatur?', 'answer': 'Eine Methodensignatur beschreibt, welche Parameter eine Methode erwartet und wie sie in SMALLTALK aufgerufen wird. Sie besteht aus dem Methodennamen und der Liste der formalen Parameter.'},
    {'question': 'Was ist ein Nachrichtenselektor?', 'answer': 'Ein Nachrichtenselektor ist Teil eines Nachrichtenausdrucks und gibt an, welche Nachricht an ein Objekt gesendet wird.'},
    {'question': 'Was ist der Unterschied zwischen einer Methodensignatur und einem Nachrichtenselektor?', 'answer': 'Die Methodensignatur ist das Gegenstück zum Nachrichtenselektor.'},
    {'question': 'Was sind Methodenrümpfe?', 'answer': 'Methodenrümpfe bestehen aus einer Folge von Anweisungen.'},
    {'question': 'Wie wird die Ausführung einer Methode beendet?', 'answer': 'Die Ausführung einer Methode wird standardmäßig nach Abarbeitung der letzten Anweisung mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung da.'},
    {'question': 'Was ist die Return-Anweisung?', 'answer': 'Die Return-Anweisung ermöglicht eine explizite Beendigung der Methode und die Rückgabe eines anderen Objekts als des Empfängers. Die Return-Anweisung kann an beliebigen Stellen innerhalb der Methode auftreten und beeinflusst den Kontrollfluss des Programms.'},
    {'question': 'Was sind temporäre Variablen?', 'answer': 'Eine Methode kann temporäre Variablen für ihre Berechnungen benötigen. Temporäre Variablen existieren nur für die Dauer der Ausführung der Methode und werden vom System nach Beendigung der Methode entfernt. Die Werte sind außerhalb der Methode nicht sichtbar. Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben.'},
    {'question': 'Was sind Methoden?', 'answer': 'Methoden sind die Einheiten des Programms, in denen die Anweisungen untergebracht sind.'},
    {'question': 'Wie werden Methoden kompiliert?', 'answer': 'Methoden werden werden nach der Eingabe und bei jeder Änderung mit dem "Speichern" kompiliert.'},
    {'question': 'Wie werden Methoden in SMALLTALK gespeichert?', 'answer': 'Methoden werden in SMALLTALK nicht in Dateien gespeichert, sondern in einer Datenstruktur von SMALLTALK, nämlich in Form von Objekten. Dies bedeutet, dass der Großteil eines jeden SMALLTALK-Programms aus Methodendefinitionen besteht, die im SMALLTALK-System als Objekte gespeichert sind.'},
    {'question': 'Was ist Aliasing?', 'answer': 'Aliasing bezieht sich auf die Situation, in der mehrere Variablen gleichzeitig auf dasselbe Objekt verweisen. Das bedeutet, dass ein Objekt mehrere Namen, Aliase, haben kann.'},
    {'question': 'Wann entstehen Aliase?', 'answer': 'Aliase entstehen immer bei der Zuweisung, wenn die Variable auf der linken Seite Verweissemantik hat.'},
    {'question': 'Warum kann das Aliasing erwünscht sein?', 'answer': 'Aliasing ist zunächst erwünscht, da es die Effizienz der Informationsverarbeitung erhöht. Es ermöglicht das Teilen von Objekten ohne Kopieren.'},
    {'question': 'Warum kann Aliasing zu Programmierfehlern führen?', 'answer': 'Aliasing kann zu Programmierfehlern führen, weil Änderungen an einem Objekt, das durch eine Variable bezeichnet wird, sich auf alle Aliase dieses Objekts auswirken. Unerwartete Veränderungen an einem Alias können schwer zu erkennen und zu debuggen sein.'},
    {'question': 'Wie werden in SMALLTALK Programmierfehler durch Aliasing verhindert?', 'answer': 'Um Programmierfehler durch Aliasing in SMALLTALK zu verhindern, werden auf Basis literaler Repräsentationen erzeugte Objekte als unveränderlich markiert. Wenn eine Zuweisung mit Wertsemantik benötigt wird, kann das Kopieren des Objekts verwendet werden.'},
    {'question': 'Was macht "copy" in SMALLTALK?', 'answer': 'In SMALLTALK kann das Schlüsselwort "copy" verwendet werden, um von einem Objekt eine Kopie anzufertigen, anstatt eine Referenz auf dasselbe Objekt zu erstellen. Dies verhindert Aliasing.'},
    {'question': 'Was ist wichtig in Bezug auf Aliase?', 'answer': 'Es ist wichtig, sich der aliasbildenden Wirkung der Zuweisung bewusst zu sein, da dies in Sprachen wie SMALLTALK der Regelfall ist.'},
    {'question': 'Wie wird die Wiederholungen (Schleifen) in SMALLTALK realisiert?', 'answer': 'In SMALLTALK wird die Implementierung von Wiederholungen (Schleifen) durch Endrekursion simuliert. Dabei wird eine Methode wie whileTrue: am Ende selbst wieder aufgerufen. Der Schleifenrumpf wird durch einen Block dargestellt, und das Abbruchkriterium wird ebenfalls in einem Block ausgewertet. Der rekursive Aufruf am Ende der Methode kann vom Compiler in eine echte Schleife übersetzt werden.'},
]
