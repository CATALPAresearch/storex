"""
Questions sorted into open questions and question-answer pairs per course unit.
"""

KE1_topics = {'question': "Was ist das Grundkonzept der objektorientierten Programmierung?",
              'keywords': ["Objekt", "Beziehung", "Zustand", "Verhalten"]}

KE2_topics = {'question': "Mittels welcher Konzepte lassen sich objektorientierte Programme strukturieren?",
              'keywords': ["Klasse", "Metaklasse", "Generalisierung", "Spezialisierung", "Vererbung",
                           "abstrakte Klasse", "Superklasse", "Subklasse", "dynamisch Binden", "Collection",
                           "Parallelität"]}

KE3_topics = {'question': "Was sind Typen in der objektorientierten Programmierung?",
              'keywords': ["Deklaration", "Definition", "Typdefinition", "Zuweisungskompatibilität", "Typäquivalenz",
                           "Typerweiterung", "Typkonformität", "Typeinschränkung", "Subtyp", "Inklusionspolymorphie",
                           "Typumwandlung", "Generischer Typ", "parametrischer Polymorphismus", "Kovarianz",
                           "Typisierung"]}

KE4_topics = {'question': "Was sind die Besonderheiten von JAVA?",
              'keywords': ["Programmiermodell", "Objekt", "Typ", "Klasse", "Ausdruck", "Anweisung", "Block",
                           "Kontrollstruktur", "Modul", "Interface", "Array", "Aufzählungstyp", "Generischer Typ",
                           "dynamische Typprüfung", "interne Iteration", "externe Iteration", "spezielle Klasse"]}

# TODO: Combine topics 4 and 5?
KE5_topics = {'question': "Was sind Besonderheiten anderer objektorientierter Programmiersprachen?",
              'keywords': ["C-Sharp", "C++", "EIFFEL"]}

KE6_topics = {'question': "Was sind Probleme der objektorientierten Programmierung?",
              'keywords': ["Problem der Substituierbarkeit",
                           "Fragile-base-class-Problem",
                           "Problem der schlechten Tracebarkeit",
                           "Problem der eindimensionalen Strukturierung",
                           "Problem der mangelnden Kapselung",
                           "Problem der mangelnden Skalierbarkeit",
                           "Problem der mangelnden Eignung"]}

KE7_topics = {'question': "Was ist guter objektorientierter Stil?",
              'keywords': ["Namen", "Formatierung", "kurze Methoden", "deklarativ", "Bibliothek", "Verteilung",
                           "Gesetz Demeters", "Klassenhierarchie"]}

KE1_questions = [
    [{'question': 'Was ist ein Literal?', 'answer': 'Ein Literal ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten.'},
     {'question': 'Was sind die einfachsten Literale in SMALLTALK?', 'answer': 'Die einfachsten Literale in SMALLTALK repräsentieren Zeichenobjekte.'},
     {'question': 'Was sind atomare Objekte?', 'answer': 'Atomare Objekte sind Zeichenobjekte und Zahlobjekte, die nicht aus anderen Objekten bestehen.'},
     {'question': 'Was sind Pseudo-Variablen in SMALLTALK?', 'answer': 'In SMALLTALK sind die in anderen Programmiersprachen vorhandenen Literale, die ebenfalls atomare Objekte repräsentieren, Pseudo-Variablen.'},
     {'question': 'Was sind Strings?', 'answer': 'Strings sind aus Zeichen zusammengesetzte Zeichenketten. String-Literale repräsentieren also zusammengesetzte Objekte.'},
     {'question': 'Was sind Symbole in SMALLTALK?', 'answer': 'Symbole sind eine weitere Art von Objekten mit literaler Repräsentation in SMALLTALK. Sie dienen dazu, sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen.'},
     {'question': 'Was sind Array-Literale in SMALLTALK ?', 'answer': 'Array-Literale repräsentieren Objekte, die aus einer Folge beliebiger anderer Objekte bestehen.'},
     {'question': 'Was sind unveränderliche Objekte?', 'answer': 'Unveränderliche oder zustandslose Objekte in SMALLTALK sind Objekte, deren Zustand nicht geändert werden kann. Operationen oder Methoden, die auf solchen Objekten ausgeführt werden, ändern nicht den Zustand des Objekts selbst, sondern erzeugen in der Regel ein neues Objekt als Ergebnis.'},
     {'question': 'Was ist die Gleichheit von Objekten?', 'answer': 'Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten und wird in SMALLTALK durch den Gleichheitsoperator getestet.'},
     {'question': 'Was ist die Identität von Objekten?', 'answer': 'Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren.'},
     {'question': 'Was sind reservierte Namen in SMALLTALK?', 'answer': 'In SMALLTALK gibt es einige reservierte Namen, die als Pseudovariablen dienen. Diese reservierten Namen sind: true, false, nil, self and super. Alle anderen Schlüsselwörter, die in anderen Programmiersprachen üblich sind, werden in SMALLTALK als Methoden definiert.'},
     {'question': 'Was sind anonyme Funktionen?', 'answer': 'Blöcke in SMALLTALK können auch als anonyme Funktionen aufgefasst werden.'},
     {'question': 'Was sind parametrisierten Blöcke?', 'answer': 'Parametrisierte Blöcke können mit Parametern versehen werden, die bei ihrer Auswertung an Objekte aus dem Auswertungskontext gebunden werden können.'},
     {'question': 'Was ist der Home Context eines Blocks in SMALLTALK?', 'answer': 'Der Home Context eines Blocks in SMALLTALK ist der Kontext, in dem der Block definiert wurde oder genauer gesagt, in dem das ihn repräsentierende Objekt erzeugt wurde. Dieser Kontext enthält Informationen über die lokalen Variablen und formalen Parameter, die der Block "einfängt". Die Ausführung eines Blocks erfolgt immer in seinem Home Context, selbst wenn der Block in einem anderen Kontext ausgewertet wird.'},
     {'question': 'Was sind Closures?', 'answer': 'Closures sind in SMALLTALK Blöcke für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können.'},
     {'question': 'Was sind Blöcke?', 'answer': 'Blöcke in SMALLTALK werden in anderen Programmiersprachen oft als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, die anonyme Funktionen repräsentieren und als Objekte oder Werte behandelt werden können. Closures erlauben es, Funktionen aus ihrem Kontext herauszulösen und in andere Kontexte zu übertragen. Die Verwendung und das Verhalten von Closures können sich jedoch zwischen verschiedenen Programmiersprachen erheblich unterscheiden.'},
     {'question': 'Was sind Attribute?', 'answer': 'Attribute sind Instanzvariablen, die die Eigenschaften eines Objekts festhalten.'},
     {'question': 'Was sind Kategorien von Instanzvariablen?', 'answer': 'Instanzvariablen können logischerweise in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Eigenschaften sind Attribute wie Farbe oder Name, die ihre Bedeutung verlieren, wenn sie isoliert betrachtet werden. Beziehungen hingegen repräsentieren Verbindungen zwischen Objekten und behalten ihre Bedeutung auch isoliert betrachtet.'},
     {'question': 'Welche Semantik haben Variablen, die Attribute repräsentieren?', 'answer': 'Variablen, die Attribute repräsentieren, haben in der Regel eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Dies ermöglicht es, dass Änderungen an einem Attributwert nicht automatisch andere Objekte mit dem gleichen Attributwert beeinflussen.'},
     {'question': 'Welche Objekte sind in SMALLTALK veränderbar?', 'answer': 'Atomare Objekte und Objekte, die aus Symbolliteralen hervorgegangen sind, sind grundsätzlich nicht veränderbar. Zusammengesetzte Objekte in SMALLTALK sind jedoch veränderbar.'},
     {'question': 'Was ist die Sequenz als Kontrollstruktur in SMALLTALK?', 'answer': 'Die Sequenz als Kontrollstruktur besagt lediglich, dass textuell aufeinanderfolgende Anweisungen eines Programms (einer Methode) auch zeitlich nacheinander ausgeführt werden. Die zeitliche Sequenz aufeinanderfolgender Anweisungen kann lediglich durch andere Kontrollstrukturen unterbrochen werden.'},
     {'question': 'Was sind Kontrollstrukturen?', 'answer': 'Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, die seine Ausführung bestimmen. In SMALLTALK gibt es ie Sequenz und den dynamisch gebundenen Methodenaufruf.'},
     {'question': 'Welche Kontrollstrukturen gibt es in SMALLTALK?', 'answer': 'In SMALLTALK gibt es nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf.'},
     {'question': 'Was sind Verzweigungen und Wiederholungen in SMALLTALK?', 'answer': 'Verzweigungen und Wiederholungen in SMALLTALK werden durch die Verwendung von Blöcken und dynamisch gebundenen Methodenaufrufen simuliert. Da SMALLTALK keine direkten Verzweigungs- und Schleifenkonstrukte wie in einigen anderen Programmiersprachen hat, werden Entscheidungen und Wiederholungen durch den Aufruf entsprechender Methoden und die Auswertung von Blöcken erreicht.'},
     {'question': 'Was ist eine Zuweisung?', 'answer': 'Eine Zuweisung ist der Vorgang, bei dem einer Variable ein Objekt zugewiesen wird, damit sie dieses Objekt bezeichnet.'},
     {'question': 'Was ist ein Block in SMALLTALK?', 'answer': 'Ein Block in SMALLTALK ist eine abgegrenzte Sequenz oder Folge von Anweisungen. Anders als eine Methode ist ein Block nicht benannt, kann aber einer Variable zugewiesen werden.'},
     {'question': 'Was sind Instanzvariablen?', 'answer': 'Instanzvariablen sind lokale Variablen, die einem Objekt zugeordnet sind und dazu verwendet werden, Informationen zu speichern, die spezifisch für dieses Objekt sind. Sie bestimmen die Struktur zusammengesetzter Objekte.'},
     {'question': 'Was ist die Sichtbarkeit von Instanzvariablen in SMALLTALK?', 'answer': 'Die Sichtbarkeit von Instanzvariablen in SMALLTALK ist auf das besitzende Objekt beschränkt. Instanzvariablen können von anderen Objekten nicht direkt zugegriffen werden.'},
     {'question': 'Was sind zwei Arten von Instanzvariablen in SMALLTALK?', 'answer': 'In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte Instanzvariablen.'},
     {'question': 'Was sind benannte Instanzvariablen in SMALLTALK?', 'answer': 'Benannte Instanzvariablen sind Instanzvariablen, die jeweils auf ein bestimmtes Objekt verweisen oder es benennen. Der Name der Variablen wird zum Namen des Objekts, auf das sie verweisen.'},
     {'question': 'Was sind indizierte Instanzvariablen in SMALLTALK?', 'answer': 'Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zum Objekt angesprochen, dem sie gehören. Der Index fungiert gewissermaßen als Name für die Instanzvariable.'},
     {'question': 'Was sind Indexer?', 'answer': 'Indexer sind ähnlich zu indizierten Instanzvariablen und werden beispielsweise von C-Sharp und VISUAL BASIC verwendet.'},
     {'question': 'Welche Arten von Ausdrücken gibt es?', 'answer': 'Es gibt Literale, Variablen, Zuweisungsausdrücke und Nachrichtenausdrücke.'},
     {'question': 'Was sind primitive Ausdrücke?', 'answer': 'Primitive Ausdrücke sind nicht aus anderen Ausdrücken zusammengesetzt, wie Literale und Variablen.'},
     {'question': 'Welche zwei Ausdrücke sind wichtig?', 'answer': 'Zuweisungsausdrücke und Nachrichtenausdrücke sind wichtig. Sie ermöglichen es, Aktionen mit den repräsentierten Objekten auszuführen und damit ein Programm tatsächlich auszuführen.'},
     {'question': 'Was sind Anweisungen?', 'answer': 'Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird.'},
     {'question': 'Welche Funktion hat die Return-Anweisung in SMALLTALK?', 'answer': 'Die Return-Anweisung gibt das Objekt zurück, zu dem der nachfolgende Ausdruck ausgewertet wird. Sie wird in Methoden und Blöcken verwendet, um das Ergebnis der Ausführung zurückzugeben.'},
     {'question': 'Was sind primitive Methoden?', 'answer': 'Primitive Methoden sind primitive Operationen, die auf native Implementierungen zurückgreifen. Diese Methoden sind durch Nummern identifiziert und sollen nicht direkt von Programmierern verwendet werden.'},
     {'question': 'Was ist der Lebenslauf von Objekten in SMALLTALK?', 'answer': 'In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung.'},
     {'question': 'Was ist die "Garbage Collection" in SMALLTALK?', 'answer': 'Die "Garbage Collection" ist ein Mechanismus in SMALLTALK, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr über Variablen zugreifbar sind.'},
     {'question': 'Welche Objekte sind von der automatischen Speicherbereinigung ausgenommen?', 'answer': 'Von der automatischen Speicherbereinigung ausgenommen sind Objekte mit eindeutiger literaler Repräsentation, wie kleine Zahlen, Zeichen und Symbole. Zahlen und Zeichen werden durch Werte in Variablen repräsentiert und Symbole sind in einer Symboltabelle abgelegt.'},
     {'question': 'Was sind die Vorteile der Garbage Collection in SMALLTALK?', 'answer': 'Die Garbage Collection verhindert vorzeitige Entfernung von Objekten, die noch in Verwendung sind, und stellt sicher, dass Variablen auf gültige Objekte verweisen. Dies trägt zur Stabilität und Sicherheit von Programmen bei.'},
     {'question': 'Was ist der Nachrichtenversand in SMALLTALK?', 'answer': 'Hinter dem Nachrichtenversand in SMALLTALK verbirgt sich der Methodenaufruf. Wenn ein Objekt eine Nachricht an ein Empfängerobjekt sendet, wird der Kontrollfluss zur Methode des Empfängerobjekts verschoben, die zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung dieser Methode kehrt der Kontrollfluss an das sendende Objekt zurück und setzt seine Arbeit dort fort.'},
     {'question': 'Was ist die Auswertung von Ausdrücken?', 'answer': 'Die Auswertung von Ausdrücken ist der Prozess, bei dem ein Programm tatsächlich Aktionen ausführt. Sie ist wichtig, weil sie den eigentlichen "Tätigkeitsprozess" eines Programms darstellt und sicherstellt, dass die gewünschten Operationen durchgeführt werden.'},
     {'question': 'Was ist eine Zuweisung?', 'answer': 'Eine Zuweisung ist eine Aktion, bei der der Inhalt einer Variable geändert wird. Die Zuweisung selbst steht für (eine Referenz auf) das Objekt. Dies ist eine Art von Seiteneffekt der Auswertung des Ausdrucks.'},
     {'question': 'Was sind primitive Ausdrücke in SMALLTALK?', 'answer': 'Die Zuweisung wird in SMALLTALK als primitiver Ausdruck betrachtet.'},
     {'question': 'Was ist ein Methodenaufruf?', 'answer': 'Ein Methodenaufruf ist die Auswertung eines Nachrichtenausdrucks, da diese zur Ausführung der Anweisungen im Rumpf einer Methode führt.'},
     {'question': 'Was sind Objekte in der objektorientierten Programmierung?', 'answer': 'Objekte sind in der objektorientierten Programmierung Daten, die im Speicher abgelegt sind und in der Lage sind, Informationen zu speichern und Aktionen auszuführen. Sie repräsentieren Dinge aus der realen Welt und können miteinander in Beziehung stehen.'},
     {'question': 'Was sind Inkonsistenzen im objektorientierten Weltbild?', 'answer': 'In der objektorientierten Programmierung werden verschiedene Arten von Sachverhalten, die in der realen Welt unterschiedliche Eigenschaften haben, durch Objekte repräsentiert. Dies kann zu Inkonsistenzen führen, da nicht alle Sachverhalte dieselben Eigenschaften wie Objekte haben. Dies ist auf die homogene Natur der Objektorientierung zurückzuführen.'},
     {'question': 'Was ist das Motto von SMALLTALK?', 'answer': 'Das Motto von SMALLTALK lautet "alles ist ein Objekt".'},
     {'question': 'Was sind Pseudovariablen in SMALLTALK?', 'answer': 'Pseudovariablen in SMALLTALK sind Variablen wie "true", "false", "nil", "self", "super" und formale Parameter von Methoden sowie Klassennamen, denen der Programmierer keinen Wert zuweisen kann.'},
     {'question': 'Was ist der "Inhalt" einer Variable?', 'answer': 'Der "Inhalt" einer Variable bezieht sich auf das Objekt, das von der Variable bezeichnet wird.'},
     {'question': 'Was ist Verweis- oder Referenzsemantik?', 'answer': 'Bei Verweis- oder Referenzsemantik haben Variablen nur Verweise die Speicherstellen, an denen die Objekte abgelegt sind.'},
     {'question': 'Was ist Wertsemantik?', 'answer': 'Bei Wertsemantik macht das bezeichnete Objekt tatsächlich den Inhalt der Variable aus.'},
     {'question': 'Was ist eine Variable aus technischer Sicht?', 'answer': 'Aus technischer Sicht entspricht eine Variable einer Stelle im Speicher.'},
     {'question': 'Was sind Variablen mit Verweissemantik?', 'answer': 'Es handelt sich bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen.'},
     {'question': 'Welche Variablen haben in SMALLTALK Wertsemantik?', 'answer': 'In den meisten SMALLTALK-Implementationen haben Variablen, die Zeichen, kleine Zahlen und boolesche Werte bezeichnen, Wertsemantik, um Speicherplatz zu sparen, obwohl der Begriff der Identität für diese Objekte verloren geht. Die mehrfache Existenz identischer Objekte im Speicher hat in der Regel keine große Bedeutung, da Gleichheit an die Stelle der Identität treten kann.'},
     {'question': 'Was ist der Home Contexts eines Blocks?', 'answer': 'Das Konzept des Home Contexts eines Blocks in SMALLTALK umfasst nicht nur die sichtbaren Variablen aus dem Kontext der Definition des Blocks, sondern auch den sogenannten Call Stack, der die Rücksprungadressen von Methodenaufrufen speichert.'},
     {'question': 'Was ist eine Continuation?', 'answer': 'Im Kontext von Blöcken in SMALLTALK bezieht sich "Continuation" auf das Konzept, dass eine Return-Anweisung innerhalb eines Blocks immer zur unmittelbaren Rückkehr in den Home Context des Blocks führt. Dieses Konzept stammt aus der Welt der funktionalen Programmierung und spielt bei der Implementierung von Kontrollstrukturen in SMALLTALK eine wichtige Rolle.'},
     {'question': 'Was ist die Sichtbarkeit einer Variable?', 'answer': 'Die Sichtbarkeit einer Variable bezieht sich immer auf einen Abschnitt des Programmcodes, in dem der Variablenname verwendet werden kann und damit Zugriff auf das von diesem Namen bezeichnete Objekt besteht.'},
     {'question': 'Was ist der Unterschiede zwischen globalen und lokalen Variablen?', 'answer': 'Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht. Globale Variablen sind auch außerhalb davon von überall her sichtbar.'},
     {'question': 'Was ist interne Iteration?', 'answer': 'Bei der internen Iteration erfolgt die Steuerstruktur für das Fortschreiten durch Elemente und die Überprüfung der Abbruchbedingung innerhalb der Sammlung erfolgt, über die iteriert wird.'},
     {'question': 'Was ist externe Iteration?', 'answer': 'Bei der traditionellen externen Iteration muss manuell eine Schleifenvariable als Index verwaltet werden.'},
     {'question': 'Was ist das Geheimnisprinzip?', 'answer': 'Das Geheimnisprinzip oder Information Hiding bezieht sich auf das Verbergen von Implementationsdetails eines Objekts, insbesondere der Struktur zusammengesetzter Objekte, vor den Objekten, die sie verwenden. Dadurch können Änderungen an der Struktur vorgenommen werden, ohne dass abhängige Objekte davon betroffen sind.'},
     {'question': 'Was ist Kapselung?', 'answer': 'Bei der Kapselung geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann.'},
     {'question': 'Was sind Zugriffsmethoden?', 'answer': 'Zugriffsmethoden sind Methoden, um die Belegung der Instanzvariablen und damit den Zustand eines Objekts auszulesen oder zu verändern. In JAVA gibt es dafür Getter und Setter.'},
     {'question': 'Was ist das Interface eines Objekts?', 'answer': 'Das Interface eines Objekts ist die Art und Weise, wie ein Objekt seinen Zustand codiert, als sein Implementationsgeheimnis und die Menge der Methodensignaturen, die den Zugriff auf das Objekt (seinen Zustand) erlauben.'},
     {'question': 'Was sind Schlüsselwörter?', 'answer': 'In Programmiersprachen wie PASCAL, C oder JAVA repräsentieren Schlüsselwörter Kontrollstrukturen.'},
     {'question': 'Was sind Kontrollstrukturen?', 'answer': 'Die grundlegenden Kontrollstrukturen sind: Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf.'},
     {'question': 'Was sind Kontrollstrukturen in SMALLTALK?', 'answer': 'In SMALLTALK sind Kontrollstrukturen auf Sequenz und Aufruf begrenzt. Alle anderen Kontrollstrukturen, einschließlich Verzweigung und Wiederholung, müssen mithilfe der Sprache simuliert werden.'},
     {'question': 'Was ist der Vorteil der Kontrollstrukturen in SMALLTALK?', 'answer': 'In SMALLTALK wird es als bedeutender Vorteil angesehen, dass Programmierer neue Kontrollstrukturen einführen können, wenn sie es wünschen.'},
     {'question': 'Was sind Kardinalitäten?', 'answer': 'Kardinalitäten sind in der Daten- und Softwaremodellierung häufig verwendete Beziehungsattribute, die angeben, wie viele andere Objekte ein Objekt in einer Beziehung haben kann.'},
     {'question': 'Welche Beziehungen gibt es?', 'answer': 'Es gibt Zu-1-Beziehungen und Zu-n-Beziehungen wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.'},
     {'question': 'Was sind Zwischenobjekte?', 'answer': 'Die Aufgabe von Zwischenobjekten ist es, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Zwischenobjekte können zusätzliche Attribute enthalten, die in ihren benannten Instanzvariablen gespeichert werden.'},
     {'question': 'Was ist das Protokoll eines Objekts?', 'answer': 'Das Protokoll eines Objekts ist der Katalog von Methoden, über den ein Objekt verfügt und auf den es entsprechend reagieren kann.'},
     {'question': 'Was ist die Variable "self" in Methoden?', 'answer': 'Die Variable "self" verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird benötigt, wenn eine Nachricht aus einer Methode heraus an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. "self" ist somit der implizite erste Parameter einer Methode.'},
     {'question': 'Was ist die Teil-Ganzes-Beziehung?', 'answer': 'Die Teil-Ganzes-Beziehung bestimmt die Weltansicht, dass alles aus kleineren Teilen zusammengesetzt ist, die selbst wieder Zusammensetzungen (Aggregate, Komposita) sind, bis hinunter zu den elementaren, unteilbaren Bausteinen.'},
     {'question': 'Was ist der Zustand eines Objekts?', 'answer': 'Der Zustand eines Objekts setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert.'},
     {'question': 'Was sind konstante Methoden?', 'answer': 'Konstante Methoden sind Methoden, die immer dasselbe Objekt zurückgeben. Sie werden häufig verwendet, um Literale auf eine Weise zu repräsentieren, die sicherstellt, dass sie konsistent sind und immer auf dasselbe Objekt verweisen.'},
     {'question': 'Was ist ein Problem bei konstanten Methoden?', 'answer': 'Bei der erneuten Übersetzung einer Methode mit einer konstanten Methode wird möglicherweise ein neues Objekt erzeugt, das nicht identisch mit dem zuvor zurückgegebenen Objekt ist. Dies kann zu Problemen führen, wenn das zuvor zurückgegebene Objekt in Variablen gespeichert wurde und mit dem neuen Objekt auf Identität verglichen wird.'},
     {'question': 'Was sind Zuweisungsausdrücke?', 'answer': 'Zuweisungsausdrücke bestehen aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite. Sie bewirken den Zustandswechsel von Objekten und sind die einzigen Ausdrücke, die dies tun.'},
     {'question': 'Welche Auswirkung haben Zuweisungsausdrücke auf Objekte?', 'answer': 'Zuweisungsausdrücke ändern den Zustand von Objekten, indem sie neue Werte in Variablen zuweisen.'},
     {'question': 'Was ist das Verhalten eines Objekts?', 'answer': 'Wenn Objekte ihren Zustand kapseln, ist ausschließlich sas Verhalten eines Objekts dafür verantwortlich, den Zustand eines Objekts zu ändern und die Interaktion mit diesem Objekt zu steuern. Das Verhalten bestimmt, wie ein Objekt auf Nachrichten reagiert und welche Operationen es auf seinem internen Zustand durchführt.'},
     {'question': 'Welche Ausdrucksform ist neben der Zuweisung wichtig?', 'answer': 'Neben der Zuweisung ist der Nachrichtenversand eine wichtige Ausdrucksform.'},
     {'question': 'Was sind unäre Nachrichten?', 'answer': 'Unäre Nachrichten sind parameterlose Nachrichten, die den Empfänger als implizites erstes Argument haben.'},
     {'question': 'Was sind binäre Nachrichten?', 'answer': 'Binäre Nachrichten sind Nachrichten mit einem Parameter, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.'},
     {'question': 'Was sind Schlüsselwortnachrichten in SMALLTALK?', 'answer': 'Schlüsselwortnachrichten sind Nachrichten in SMALLTALK, die neben dem Empfänger mindestens ein Argument erfordern. Sie enthalten normalerweise kein herkömmliches Schlüsselwort im Sinne von Schlüsselwort-Argumenten, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.'},
     {'question': 'Was ist ein Nachrichtenausdruck?', 'answer': 'Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.'},
     {'question': 'Was ist die Kaskadierung in SMALLTALK?', 'answer': 'Die Kaskadierung ist eine syntaktische Abkürzung in SMALLTALK, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen. Dies erleichtert das Verketten von Nachrichten an dasselbe Objekt.'},
     {'question': 'Was ist der Nachrichtenselektor?', 'answer': 'Der Nachrichtenselektor ist der Name der Nachricht, die an ein Objekt gesendet wird. Der Nachrichtenselektor ist wichtig, da er angibt, welche Methode auf dem Empfängerobjekt aufgerufen werden soll.'},
     {'question': 'Was ist das Protokoll in SMALLTALK?', 'answer': 'In SMALLTALK ist das Protokoll eines Objekts die Menge der Nachrichten, die es versteht. Es wird in Form der Protokollbeschreibung spezifiziert und besteht aus den Methodensignaturen und den dazugehörigen Kommentaren der Methoden. Das Protokoll beschreibt das Interface eines Objekts.'},
     {'question': 'Was ist dynamisches Binden?', 'answer': 'Dynamisches Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung, bei der die Auswahl der Methodenimplementierung erst zur Laufzeit erfolgt, abhängig vom Empfängerobjekt des Methodenaufrufs. Dies wird auch als Polymorphismus oder Polymorphie bezeichnet.'},
     {'question': 'Was ist statisches Binden?', 'answer': 'Bei statischem Binden wird ein Methodenaufruf schon zur Übersetzungszeit an eine Implementierung gebunden.'},
     {'question': 'Was sind Variablen?', 'answer': 'Variablen sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können.'},
     {'question': 'Welche Ausdrücke haben in SMALLTALK Vorrang?', 'answer': 'In SMALLTALK haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke haben Vorrang vor Schlüsselwortnachrichten.'},
     {'question': 'Was ist eine Methode?', 'answer': 'Eine Methode beschreibt, was ein Objekt in Reaktion auf den Erhalt einer bestimmten Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf (Methodensignatur), einer optionalen Liste von lokalen Variablen und einem Methodenrumpf, der die Anweisungen für die Ausführung der Methode enthält.'},
     {'question': 'Was ist eine Methodensignatur?', 'answer': 'Eine Methodensignatur beschreibt, welche Parameter eine Methode erwartet und wie sie in SMALLTALK aufgerufen wird. Sie besteht aus dem Methodennamen und der Liste der formalen Parameter.'},
     {'question': 'Was ist ein Nachrichtenselektor?', 'answer': 'Ein Nachrichtenselektor ist Teil eines Nachrichtenausdrucks und gibt an, welche Nachricht an ein Objekt gesendet wird.'},
     {'question': 'Was sind Methodenrümpfe?', 'answer': 'Methodenrümpfe bestehen aus einer Folge von Anweisungen.'},
     {'question': 'Was ist die Return-Anweisung?', 'answer': 'Die Return-Anweisung ermöglicht eine explizite Beendigung der Methode und die Rückgabe eines anderen Objekts als des Empfängers. Die Return-Anweisung kann an beliebigen Stellen innerhalb der Methode auftreten und beeinflusst den Kontrollfluss des Programms.'},
     {'question': 'Was sind temporäre Variablen?', 'answer': 'Eine Methode kann temporäre Variablen für ihre Berechnungen benötigen. Temporäre Variablen existieren nur für die Dauer der Ausführung der Methode und werden vom System nach Beendigung der Methode entfernt. Die Werte sind außerhalb der Methode nicht sichtbar. Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben.'},
     {'question': 'Was sind Methoden?', 'answer': 'Methoden sind die Einheiten des Programms, in denen die Anweisungen untergebracht sind.'},
     {'question': 'Was ist Aliasing?', 'answer': 'Aliasing bezieht sich auf die Situation, in der mehrere Variablen gleichzeitig auf dasselbe Objekt verweisen. Das bedeutet, dass ein Objekt mehrere Namen, Aliase, haben kann.'},
     {'question': 'Was ist das Schlüsselword "copy" in SMALLTALK?', 'answer': 'In SMALLTALK kann das Schlüsselwort "copy" verwendet werden, um von einem Objekt eine Kopie anzufertigen, anstatt eine Referenz auf dasselbe Objekt zu erstellen. Dies verhindert Aliasing.'},
     {'question': 'Was ist wichtig in Bezug auf Aliase?', 'answer': 'Es ist wichtig, sich der aliasbildenden Wirkung der Zuweisung bewusst zu sein, da dies in Sprachen wie SMALLTALK der Regelfall ist.'}],
    [{'question': 'Wie sendet man Nachrichten in Zu-1-Beziehungen?', 'answer': 'In Zu-1-Beziehungen in SMALLTALK sendet man oft Nachrichten direkt an das Objekt, auf das die betreffende Variable verweist.'},
     {'question': 'Wie sendet man Nachrichten in Zu-n-Beziehungen?', 'answer': 'Bei Zu-n-Beziehungen erreicht die Nachricht nicht mehr die logisch in Beziehung stehenden Objekte, sondern das Zwischenobjekt, das die Beziehung selbst repräsentiert (der Wert der Variable). Um die Nachricht stattdessen an alle von diesem Zwischenobjekt referenzierten Objekte zu senden, verwendet man die Nachricht do: aBlock, wobei aBlock ein Block ist, der mit einem Parameter parametrisiert ist und der für jedes Element des Arrays genau einmal (mit dem Element als tatsächlichem Parameter) aufgerufen wird.'},
     {'question': 'Wie kann eine Sequenz unterbrochen werden?', 'answer': 'In SMALLTALK kann die zeitliche Sequenz von aufeinanderfolgenden Anweisungen nur durch den Methodenaufruf unterbrochen werden.'},
     {'question': 'Wie werden Blöcke in SMALLTALK ausgeführt?', 'answer': 'Bei der Ausführung des Blockausdrucks wird ein neues Blockobjekt erzeugt.'},
     {'question': 'Wie ist die Anzahl indizierten Instanzvariablen eines Objekts?', 'answer': 'Die Anzahl der indizierten Instanzvariablen eines Objekts ist fix, und die Größe eines Objekts mit indizierten Instanzvariablen ist ebenfalls fest und kann nicht verändert werden.'},
     {'question': 'Wie werden Anweisungen in SMALLTALK getrennt?', 'answer': 'In SMALLTALK werden Anweisungsfolgen durch einen Punkt getrennt.'},
     {'question': 'Wann kann ein Objekt in SMALLTALK aus dem Speicher entfernt werden?', 'answer': 'Ein Objekt in SMALLTALK kann aus dem Speicher entfernt werden, wenn keine Variable mehr auf dieses Objekt verweist und es somit nicht mehr erreichbar ist.'},
     {'question': 'Wie werden Nachrichtenausdrücke in SMALLTALK ausgewertet?', 'answer': 'Nachrichtenausdrücke in SMALLTALK werden ausgewertet, indem die Nachricht (das Prädikat) an das Empfängerobjekt (das Subjekt) mit den Parametern (Prädikatsergänzungen) gesendet wird. Nach der Auswertung repräsentiert der Nachrichtenausdruck das Ergebnis der Nachricht, das von dem Empfängerobjekt zurückgegeben wird.'},
     {'question': 'Wie wird der Zugriff auf Variablen einzuschränken?', 'answer': 'Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen.'},
     {'question': 'Wie wird die Iteration in SMALLTALK realisiert?', 'answer': 'Die Iteration in SMALLTALK erfolgt durch eine Form der internen Iteration, bei der die Steuerstruktur für das Fortschreiten durch Elemente und die Überprüfung der Abbruchbedingung innerhalb der Sammlung erfolgt, über die iteriert wird.'},
     {'question': 'Wie wird die Kapselung umgesetzt?', 'answer': 'Über lokale Instanzvariablen kann ein Objekt verbergen, welche Objekte es kennt. Aber aufgrund von Aliasing kann ein Objekt, dessen Name unsichtbar ist, über einen anderen Namen zugänglich sein kann.'},
     {'question': 'Wie sind Instanzvariablen in SMALLTALK sichtbar?', 'answer': 'In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar, um den Zustand des Objekts zu kapseln und seine Struktur vor direktem Zugriff von außen zu schützen.'},
     {'question': 'Wie ist das Goto angesehen?', 'answer': 'Das Goto wird in der strukturierten Programmierung als unerwünscht angesehen.'},
     {'question': 'Wie werden Zu-1-Beziehungen umgesetzt?', 'answer': 'Zu-1-Beziehungen können direkt durch benannte Instanzvariablen zwischen Objekten umgesetzt werden.'},
     {'question': 'Wie werden Zu-n-Beziehungen umgesetzt?', 'answer': 'Zu-n-Beziehungen werden meistens über Zwischenobjekte umgesetzt, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen.'},
     {'question': 'Wie sind Methoden Objekten zugeordnet?', 'answer': 'Methoden sind immer Objekten, den sogenannten Empfängerobjekten, zugeordnet.'},
     {'question': 'Wie wird die einfache Verzweigung in SMALLTALK realisiert?', 'answer': 'In SMALLTALK wird die einfache Verzweigung durch das Versenden einer Nachricht an einen Wahrheitswert realisiert. Diese Nachricht enthält die bedingt auszuführenden Anweisungen in Form eines Blocks als Parameter.'},
     {'question': 'Wie wird der Zustand eines Objekts verändern?', 'answer': 'Die einzige Möglichkeit, den Zustand eines Objekts zu ändern, besteht darin, die Werte seiner Instanzvariablen zuzuweisen, was gleichbedeutend mit der Änderung seiner Beziehungen ist.'},
     {'question': 'Wie lässt sich der Zustand eines Objekts eingrenzen?', 'answer': 'Der Zustand eines Objekts ließe sich auf seine Attributwerte eingrenzen. Da es jedoch keine klare Unterscheidung zwischen Attributen und Beziehungen gibt, kann dies allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen.'},
     {'question': 'Wann ist es angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen?', 'answer': 'Es ist angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen, wenn es sich um Kompositionen handelt, also um aus Teilen zusammengesetzte Ganze.'},
     {'question': 'Wie kann man Nachrichten in SMALLTALK als Objekte verwenden?', 'answer': 'In SMALLTALK kann man Nachrichten (oder Nachrichtenselektoren) selbst als Objekte verwenden, indem man die Methode "perform:" verwendet. Diese Methode ermöglicht es, einem Empfängerobjekt eine Nachricht als Objekt zu senden, und das Empfängerobjekt führt die zur Nachricht passende Methode aus, als hätte es einen entsprechenden Methodenaufruf erhalten.'},
     {'question': 'Wie wird das Protokoll in SMALLTALK unterteilt?', 'answer': 'Das Protokoll von Objekten in SMALLTALK wird oft in sogenannte Nachrichtenkategorien unterteilt. Diese Kategorien haben Namen, die die enthaltenen Methodennamen zusammenfassen. Nachrichtenkategorien dienen der besseren Lesbarkeit und partitionieren das Interface eines Objekts. Einige Kategorien können das Wort "private" enthalten, um anzuzeigen, dass die darin enthaltenen Methoden vorzugsweise nur vom Objekt selbst aufgerufen werden sollten.'},
     {'question': 'Wie werden Protokolle in SMALLTALK spezifiziert?', 'answer': 'In SMALLTALK werden Protokolle nicht auf Objektebene, sondern auf Klassenebene spezifiziert. Dies bedeutet, dass eine Klasse ein bestimmtes Protokoll implementiert und die Objekte dieser Klasse dieses Protokoll erben. In STRONGTALK, einer Erweiterung von SMALLTALK, werden Protokolle zu Typen erhoben und ähneln Interfaces in JAVA.'},
     {'question': 'Wie wird ein Nachrichtenausdruck in SMALLTALK übersetzt?', 'answer': 'Ein Nachrichtenausdruck wird in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung vergleichbar ist.'},
     {'question': 'Wie erfolgt die Zuweisung der formalen Parameter in einer Methode?', 'answer': 'Die Zuweisung der formalen Parameter erfolgt in einer Methode durch eine implizite Zuweisung der tatsächlichen Parameter des Methodenaufrufs an die formalen Parameter der Methode.'},
     {'question': 'Wie kann man sich ein laufendes objektorientiertes Programm vorstellen?', 'answer': 'Ein laufendes objektorientiertes Programm kann man sich als eine Menge interagierender Objekte vorstellen. Diese Objekte sind miteinander verbunden und bilden ein Geflecht von Beziehungen. Das Geflecht ändert sich dynamisch durch die Interaktion der Objekte, wobei bestimmte statische Strukturen durch das Programm vorgegeben sind.'},
     {'question': 'Wie kann die Unterscheidung zwischen Struktur und Verhalten in der objektorientierten Programmierung angewendet werden?', 'answer': 'In der objektorientierten Programmierung kann die Unterscheidung zwischen Struktur und Verhalten angewendet werden, um die verschiedenen Aspekte eines Programms zu analysieren und zu gestalten. Die Struktur bezieht sich auf das Objektgeflecht und die Beziehungen zwischen den Objekten. Das Verhalten bezieht sich auf die Spezifikation der Änderungen, die im Verlauf der Programmausführung auftreten. Diese Unterscheidung kann bei der Analyse und Gestaltung von Programmen hilfreich sein, da sie ermöglicht, sich auf die Struktur und das Verhalten von Objekten und Klassen zu konzentrieren und diese getrennt zu behandeln.'},
     {'question': 'Wie ist die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK?', 'answer': 'Die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK wird durch Präzedenzen und Klammern festgelegt.'},
     {'question': 'Wie kann die Reihenfolge der Auswertung in SMALLTALK verändert werden?', 'answer': 'Um die Reihenfolge der Auswertung in SMALLTALK zu ändern, können Klammern verwendet werden, um sicherzustellen, dass bestimmte Teile eines Ausdrucks zuerst ausgewertet werden.'},
     {'question': 'Wie werden Informationen dargestellt?', 'answer': 'In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt. Dieses Geflecht kann navigiert und manipuliert werden.'},
     {'question': 'Wie wird das Geflecht von Objekten genutzt?', 'answer': 'Das Geflecht von Objekten kann navigiert werden, um von einem Datum zu einem anderen zu kommen, oder auch manipuliert werden, um die repräsentierte Information zu verändern.'},
     {'question': 'Wie werden Beziehungen zwischen Objekten hergestellt?', 'answer': 'Beziehungen zwischen Objekten werden über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten "navigieren". Dabei ist zu beachten, dass diese Verknüpfung immer gerichtet ist und man nicht zwangsläufig wieder zurücknavigieren kann.'},
     {'question': 'Wie werden Variablen für Beziehungen genutzt?', 'answer': 'Variablen enthalten Verweise. Wenn jemand Zugriff auf die Variable hat, kann er auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.'},
     {'question': 'Wie wird die Ausführung einer Methode beendet?', 'answer': 'Die Ausführung einer Methode wird standardmäßig nach Abarbeitung der letzten Anweisung mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung da.'},
     {'question': 'Wie werden Methoden kompiliert?', 'answer': 'Methoden werden werden nach der Eingabe und bei jeder Änderung mit dem "Speichern" kompiliert.'},
     {'question': 'Wie werden Methoden in SMALLTALK gespeichert?', 'answer': 'Methoden werden in SMALLTALK nicht in Dateien gespeichert, sondern in einer Datenstruktur von SMALLTALK, nämlich in Form von Objekten. Dies bedeutet, dass der Großteil eines jeden SMALLTALK-Programms aus Methodendefinitionen besteht, die im SMALLTALK-System als Objekte gespeichert sind.'},
     {'question': 'Wann entstehen Aliase?', 'answer': 'Aliase entstehen immer bei der Zuweisung, wenn die Variable auf der linken Seite Verweissemantik hat.'},
     {'question': 'Wie werden in SMALLTALK Programmierfehler durch Aliasing verhindert?', 'answer': 'Um Programmierfehler durch Aliasing in SMALLTALK zu verhindern, werden auf Basis literaler Repräsentationen erzeugte Objekte als unveränderlich markiert. Wenn eine Zuweisung mit Wertsemantik benötigt wird, kann das Kopieren des Objekts verwendet werden.'},
     {'question': 'Wie wird die Wiederholungen (Schleifen) in SMALLTALK realisiert?', 'answer': 'In SMALLTALK wird die Implementierung von Wiederholungen (Schleifen) durch Endrekursion simuliert. Dabei wird eine Methode wie whileTrue: am Ende selbst wieder aufgerufen. Der Schleifenrumpf wird durch einen Block dargestellt, und das Abbruchkriterium wird ebenfalls in einem Block ausgewertet. Der rekursive Aufruf am Ende der Methode kann vom Compiler in eine echte Schleife übersetzt werden.'}],
    [{'question': 'Was unterscheidet Literale und objekterzeugende Anweisungen?', 'answer': 'Der Compiler erzeugt bei der Übersetzung eines Literals das entsprechende Objekt im Speicher, während objekterzeugende Anweisungen erst zur Laufzeit des Programms ausgeführt werden.'},
     {'question': 'Warum sind Literale keine Objekte?', 'answer': 'Literale repräsentieren Objekte, sind jedoch selbst keine Objekte, da sie textuelle Spezifikationen von Objekten sind.'},
     {'question': 'Was unterscheidet Symbole und Strings in SMALLTALK?', 'answer': 'Symbole dürfen im Gegensatz zu Strings keine Leerzeichen enthalten. Zudem ist die Erzeugung eines Objekts anhand eines Symbolliterals technisch aufwendiger als die Erzeugung eines Objekts anhand eines String-Literals.'},
     {'question': 'Was kann bei der Verwendung von identischen Symbolliteralen passieren?', 'answer': 'Bei der Verwendung identischer Symbolliterale kann es durch sogenanntes Aliasing zu unerwarteten Ergebnissen führen.'},
     {'question': 'Was unterscheidet Gleichheit und Identität von Objekten?', 'answer': 'Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten. Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren.'},
     {'question': 'Warum können syntaktisch gleiche String-Literale in SMALLTALK unterschiedliche Identitäten haben?', 'answer': 'Syntaktisch gleiche String-Literale können in SMALLTALK unterschiedliche Identitäten haben, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen.'},
     {'question': 'Warum sind gleiche Zahlen nur manchmal identisch in SMALLTALK?', 'answer': 'In SMALLTALK werden gleiche Zahlen manchmal als identisch behandelt und manchmal nicht, abhängig von ihrer Größe und technischen Gründen.'},
     {'question': 'Was unterscheidet die Bezeichnungen "das gleiche" und "dasselbe"?', 'answer': 'In der objektorientierten Programmierung sind "das gleiche" und "dasselbe" nicht dasselbe. Zwei Objekte können gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins.'},
     {'question': 'Warum ist die Identität von Objekten wichtig?', 'answer': 'Die Identität von Objekten ist wichtig, um festzustellen, ob zwei Namen oder Variablen dasselbe Objekt repräsentieren oder nicht.'},
     {'question': 'Warum haben veränderliche Objekte eine Identität?', 'answer': 'Veränderliche Objekte haben eine Identität um sie auch bei vorübergehender Gleichheit voneinander unterscheiden zu können, da sie sich hinterher wieder auseinanderentwickeln können.'},
     {'question': 'Warum haben unveränderliche Objekte eine Identität?', 'answer': 'Unveränderliche Objekte haben aus technischen Gründen eine Identität. Wenn sich ein unveränderliches Objekt aus einer Operation ergibt, dann müsste für eine Zusammenlegung gleicher Objekte zu einem immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Ganze Zahlen bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind.'},
     {'question': 'Warum gibt es in SMALLTALK keine Schlüsselwörter?', 'answer': 'In SMALLTALK gibt es keine Schlüsselwörter, sondern nur Symbole mit spezieller Bedeutung. Stattdessen sind alle aus anderen Sprachen bekannten Schlüsselwörter in SMALLTALK als Methoden implementiert.'},
     {'question': 'Warum sind atomare Objekte grundsätzlich nicht veränderbar?', 'answer': 'Atomare Objekte sind grundsätzlich nicht veränderbar, da es keinen Sinn ergibt, sie zu verändern. Zum Beispiel macht es keinen Sinn, aus einer "1" eine "2" zu machen.'},
     {'question': 'Warum könnten zusammengesetzte Objekte veränderbar sein?', 'answer': 'Zusammengesetzte Objekte könnten veränderbar sein, da es sinnvoll sein kann, eine Komponente durch eine andere zu ersetzen.'},
     {'question': 'Sind Array-Objekten in SMALLTALK veränderbar?', 'answer': 'Zusammengesetzte Array-Objekte sind in der Regel veränderbar. Ob Array-Objekte, die aus Literalen erzeugt wurden, veränderbar sein sollen, ist ansichtssache und wird von verschiedenen SMALLTALK-Dialekten unterschiedlich gehandhabt.'},
     {'question': 'Warum sind zusammengesetzte Objekte in SMALLTALK grundsätzlich veränderbar?', 'answer': 'Zusammengesetzte Objekte sind in SMALLTALK grundsätzlich veränderbar, da dies eine Voraussetzung dafür ist, dass Objekte einen Zustand haben können.'},
     {'question': 'Warum bieten immer mehr Sprachen unveränderliche Objekte an?', 'answer': 'Immer mehr Sprachen bieten unveränderliche Objekte an aufgrund zunehmender funktionaler Einflüsse auf die objektorientierte Programmierung.'},
     {'question': 'Warum ist die Zuweisung kommutativ?', 'answer': 'Die Zuweisung ist nicht kommutativ, da "x := y" und "y := x" unterschiedliche Bedeutungen haben, es sei denn, "x" und "y" hatten bereits denselben Wert vor der jeweiligen Zuweisung.'},
     {'question': 'Was unterscheidet Zuweisungen unter Wertsemantik und unter Verweissemantik?', 'answer': 'Bei Zuweisungen unter Wertsemantik muss eine Kopie des Objekts angefertigt werden, da die Variable das Objekt selbst speichert. Bei Zuweisungen unter Verweissemantik wird nur der Verweis auf das Objekt kopiert und in der Variable gespeichert. Dies hat Auswirkungen darauf, ob Änderungen an einem Objekt in einer Variable sich auf dasselbe Objekt in einer anderen Variable auswirken.'},
     {'question': 'Warum wurde in SMALLTALK die explizite Speicherfreigabe aufgegeben?', 'answer': 'Die explizite Speicherfreigabe wurde in SMALLTALK aufgegeben, da es schwierig ist, genau zu verfolgen, welche Objekte noch referenziert werden, insbesondere in großen und komplexen Programmen. Die Verantwortung dafür den Anwendungsprogrammierern zu überlassen, würde zu vielen potenziellen Programmierfehlern führen.'},
     {'question': 'Warum ist "Lebenszyklus" eines Objekts irreführend?', 'answer': 'Der Begriff "Lebenszyklus" würde implizieren, dass das Objekt nach seinem Ende wiederverwendet wird, was nicht der Fall ist. Objekte werden nicht recycelt, sondern nur der von ihnen belegte Speicherplatz wird möglicherweise wiederverwendet.'},
     {'question': 'Was passiert nach einer Methode in SMALLTALK?', 'answer': 'Bei der Rückkehr nach der Abarbeitung einer Methode in SMALLTALK wird das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Dies ermöglicht die Weiterverarbeitung des Ergebnisses im Kontext des aufrufenden Objekts.'},
     {'question': 'Ist es in SMALLTALK möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben?', 'answer': 'In SMALLTALK ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben, da jeder Nachrichtenversand ein Ergebnis zurückgibt. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API (fließende Programmierung).'},
     {'question': 'Was unterscheidet ein Objekt und ein Wert?', 'answer': 'Objekte haben eine eindeutige Identität und sind an einer bestimmten Stelle im Speicher abgelegt, während Werte an verschiedenen Stellen im Speicher vorkommen können und keine Identität haben.'},
     {'question': 'Warum haben Objekte im Speicher eine konstante Größe?', 'answer': 'Objekte im Speicher haben eine feste Größe, die aus technischen Gründen nicht verändert werden kann. Wenn ein Objekt mehr Platz benötigt oder verkleinert werden muss, muss ein neues Objekt erzeugt werden, das an die Stelle des alten tritt. Dieses neue Objekt hat jedoch eine andere Identität.'},
     {'question': 'Warum werden Pseudovariablen als solche bezeichnet?', 'answer': 'Sie werden als Pseudovariablen bezeichnet, da sie ihren Wert entweder nicht ändern können oder ihren Wert vom System erhalten.'},
     {'question': 'Warum ist die Zuweisung für Pseudovariablen in SMALLTALK nicht zulässig?', 'answer': 'Die Zuweisung für Pseudovariablen ist in SMALLTALK nicht zulässig, da sie auf Objekte von spezifischer Bedeutung verweisen und diese Bedeutung nicht verändert werden sollte.'},
     {'question': 'Was unterscheidet Verweissemantik und Wertsemantik bei Variablen?', 'answer': 'Unter Wertsemantik können zwei Variablen niemals dasselbe Objekt bezeichnen, während Verweissemantik erlaubt, dass mehrere Variablen auf dasselbe Objekt verweisen.'},
     {'question': 'Warum wird in der objektorientierten Programmierung häufig Verweissemantik verwendet?', 'answer': 'Verweissemantik wird in der objektorientierten Programmierung häufig verwendet, da sie einen speicher- und recheneffizienten Umgang mit Objekten ermöglicht und unterschiedliche Objekte unterschiedlich viel Speicherplatz belegen.'},
     {'question': 'Haben Variablen Wert- oder Verweissemantik?', 'answer': 'In manchen Sprachen haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik, z. B. JAVA. Andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll, z. B. C++ und EIFFEL.'},
     {'question': 'Warum können Continuations zu Laufzeitfehlern führen?', 'answer': 'Continuations können zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde. Return-Anweisungen in Blöcken sind daher ein umstrittenes Konzept.'},
     {'question': 'Was bezeichnet eine Variable?', 'answer': 'Eine Variable bezeichnet ein Objekt.'},
     {'question': 'Was unterscheidet das Geheimnisprinzip und die Kapselung?', 'answer': 'Der Unterschied besteht darin, dass das Geheimnisprinzip sich auf das Verbergen von Implementationsdetails und Struktur bezieht, während die Kapselung sich auf das Verbergen und die Kontrolle des Zustands eines Objekts bezieht.'},
     {'question': 'Warum kann ein Objekt seinen inneren Aufbau nicht kapseln?', 'answer': 'Ein Objekt kann seinen inneren Aufbau nicht vollständig vor der Außenwelt abkapseln, da aufgrund der möglichen Existenz von Aliasen andere Objekte diese Objekte kennen und ohne sein Wissen manipulieren können. Die Abschottung erfordert spezielle Vorkehrungen, die derzeit nicht in gängige objektorientierte Programmiersprachen integriert sind und explizit programmiert werden müssen.'},
     {'question': 'Was unterscheidet eine benannte Instanzvariable und eine indizierte Instanzvariable in SMALLTALK?', 'answer': 'In SMALLTALK können benannte Instanzvariablen direkt über ihren Namen zugegriffen werden, während indizierte Instanzvariablen nur über die vordefinierten Nachrichten "at:" und "at:put:" gelesen und geschrieben werden können. Der Zugriff auf indizierte Instanzvariablen erfolgt nicht über Zugriffsmethoden, sondern über diese Nachrichten.'},
     {'question': 'Warum werden Zu-n-Beziehungen über Zwischenobjekte umgesetzt?', 'answer': 'Zu-n-Beziehungen werden über Zwischenobjekte umgesetzt, da die indizierten Instanzvariablen eines Objekts nicht benannt sind und daher nicht zwischen verschiedenen Zu-n-Beziehungen unterschieden werden kann'},
     {'question': 'Warum ist die Zuordnung von Methoden zu Objekten wichtig?', 'answer': 'Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen und somit das Verhalten des Objekts zu spezifizieren und zu beeinflussen.'},
     {'question': 'Warum ist die Teil-Ganzes-Beziehung komplixiert?', 'answer': 'Die Definition der Teil-Ganzes-Beziehung ist komplex, da es verschiedene Arten von Beziehungen zwischen einem Ganzen und seinen Teilen gibt, die je nach Art der Zusammensetzung unterschiedliche Wechselwirkungen aufweisen. Es existieren sowohl physische als auch logische Teil-Ganzes-Beziehungen, und diese Vielfalt macht es schwer, eine klare und einheitliche Definition zu finden.'},
     {'question': 'Was bieten objektorientierten Programmiersprachen für die Teil-Ganzes-Beziehung?', 'answer': 'Die meisten objektorientierten Programmiersprachen bieten keine speziellen Sprachkonstrukte für die Teil-Ganzes-Beziehung. Stattdessen können Programmierer die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik nutzen, um eine bestimmte Form der Teil-Ganzes-Beziehung darzustellen. Bei Wertsemantik werden beim Entfernen eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt.'},
     {'question': 'Warum ist die Teil-Ganzes-Beziehung in der objektorientierten Programmierung von Bedeutung?', 'answer': 'Die Teil-Ganzes-Beziehung ist in der objektorientierten Programmierung wichtig, da sie es ermöglicht, komplexe Software-Systeme aus Teilen aufzubauen, wobei jeder Teil seine eigene interne Struktur kapselt. Dies hilft dabei, sicherzustellen, dass keine Aliasnamen für Teile existieren und Änderungen an einem Teil nicht unabsichtlich andere Teile beeinflussen. Dieses Konzept ist entscheidend für die Entwicklung komplexer und intakter Software-Systeme.'},
     {'question': 'Was unterscheidet veränderliche und unveränderliche Objekte?', 'answer': 'Veränderliche Objekte können ihren Zustand im Laufe der Zeit ändern, während unveränderliche Objekte keinen Zustand haben und ihre Werte konstant bleiben.'},
     {'question': 'Was unterscheidet Attribute und Beziehungen?', 'answer': 'Die Unterscheidung zwischen Attributen und Beziehungen kann in Ermangelung spezieller Schlüsselwörter allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese ist jedoch in einigen Programmiersprachen nicht immer eindeutig ist und beispielsweise in Java gar nicht zutreffend.'},
     {'question': 'Warum ändert sich der Zustand eines Objekts nur über Instanzvariablen?', 'answer': 'Wenn Änderungen am Zustand eines Objekts, auf das ein anderes Objekt per Instanzvariable verweist, als Änderung des Zustands des ersten Objekts betrachtet würden, könnte jede Änderung an einem Objekt zu einer Kettenreaktion führen, da der Zustand aller Objekte, die darauf verweisen, sich ändern würde. Dies entspricht nicht unserem üblichen Verständnis von Zustand.'},
     {'question': 'Warum ist der Zustandsbegriff nicht auf mehrere Objekte im Allgemeinen ausgedehnt?', 'answer': 'Der Zustandsbegriff kann nicht auf mehrere Objekte im Allgemeinen ausgedehnt werden, da dies zu komplexen Problemen führen würde und das objektorientierte Modell nicht ohne Herausforderungen ist. Programmierfehler könnten in vermeintlich simplen Situationen auftreten.'},
     {'question': 'Warum werden konstante Methoden verwendet?', 'answer': 'Konstante Methoden werden verwendet, um sicherzustellen, dass bestimmte Literale in einem Programm konsistent sind und immer auf dasselbe Objekt verweisen. Dies ist wichtig, um Probleme im Zusammenhang mit Objektidentität und Vergleichen zu vermeiden.'},
     {'question': 'Warum hängt das Verhalten eines Objekts von seinem Zustand ab?', 'answer': 'Das Verhalten eines Objekts hängt in der Regel von seinem Zustand ab, weil der Zustand eines Objekts die Informationen enthält, die benötigt werden, um die richtigen Entscheidungen zu treffen und die entsprechenden Aktionen auszuführen. Das Verhalten eines Objekts basiert auf den Daten in seinem Zustand, und diese Daten beeinflussen, wie das Objekt auf Nachrichten reagiert.'},
     {'question': 'Ist die Reihenfolge der Nachrichtenteile in SMALLTALK von Bedeutung?', 'answer': 'Die Reihenfolge der Nachrichtenteile in einem Nachrichtenselektor bestimmt die Bedeutung der Nachricht. Der Nachrichtenselektor selbst ist ein Symbol, das aus der Konkatenation aller seiner Teile besteht.'},
     {'question': 'Was unterscheidet Protokoll und Implementierung in SMALLTALK?', 'answer': 'Das Protokoll beschreibt das Interface eines Objekts und umfasst die Methodensignaturen und dazugehörigen Kommentare. Die Implementierung hingegen besteht aus den tatsächlichen Methodenrümpfen und den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Das Protokoll dient dazu, das Verhalten eines Objekts zu beschreiben, während die Implementierung die Details der Umsetzung enthält.'},
     {'question': 'Von welchem Objekt hängt die Auswahl der Methode ab?', 'answer': 'Die Auswahl der Methode, die aufgerufen wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Verschiedene Objekte mit gleichen Methodensignaturen können unterschiedliche Methodenimplementierungen haben.'},
     {'question': 'Was passiert, wenn ein Methodenaufruf in SMALLTALK ins Leere läuft?', 'answer': 'Wenn ein Methodenaufruf ins Leere läuft, wird er in einen Aufruf der Methode "doesNotUnderstand:" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung, die besagt, dass das Objekt die Nachricht nicht versteht. Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren.'},
     {'question': 'Warum ist die Unterscheidung zwischen Statik und Dynamik in der Programmierung wichtig?', 'answer': 'Die Unterscheidung zwischen Statik und Dynamik ist wichtig, um das Verhalten von Programmen zu verstehen. Programme haben eine statische Struktur, die ihre Komponenten und ihre Beziehungen zueinander beschreibt. Diese Struktur kann als Grundlage für die Ausführung des Programms dienen. Auf der anderen Seite ist die Ausführung eines Programms immer dynamisch und kann sich im Laufe der Zeit ändern. Die Unterscheidung hilft dabei, die Beziehung zwischen der Programmstruktur und ihrem Verhalten zu verstehen.'},
     {'question': 'Warum reichen Literale zum Programmieren nicht aus?', 'answer': 'Literale reichen zum Programmieren nicht aus, weil sie immer die gleichen Objekte repräsentieren.'},
     {'question': 'Warum gibt es Variablen?', 'answer': 'Variablen sind notwendig, weil Literale immer die gleichen Objekte repräsentieren, weshalb sie zum Programmieren nicht ausreichen.'},
     {'question': 'Was unterscheidet Variablen und Literale?', 'answer': 'Anders als bei Literalen wird aus einer Variable kein Objekt erzeugt, sie ist lediglich ein Name für ein bereits existierendes Objekt.'},
     {'question': 'In welcher Reihenfolge werden Ausdrücke ausgewertet?', 'answer': 'In SMALLTALK werden Ausdrücke normalerweise von links nach rechts ausgewertet.'},
     {'question': 'Warum stehen Objekte in Beziehung zueinander?', 'answer': 'Objekte stehen in Beziehung zueinander, um Bedeutung zu erlangen. Die meisten Objekte in einem System werden erst durch ihre Beziehungen zu anderen Objekten nützlich.'},
     {'question': 'Was unterscheidet eine Methodensignatur und einen Nachrichtenselektor?', 'answer': 'Die Methodensignatur ist das Gegenstück zum Nachrichtenselektor.'},
     {'question': 'Warum kann das Aliasing erwünscht sein?', 'answer': 'Aliasing ist zunächst erwünscht, da es die Effizienz der Informationsverarbeitung erhöht. Es ermöglicht das Teilen von Objekten ohne Kopieren.'},
     {'question': 'Warum kann Aliasing zu Programmierfehlern führen?', 'answer': 'Aliasing kann zu Programmierfehlern führen, weil Änderungen an einem Objekt, das durch eine Variable bezeichnet wird, sich auf alle Aliase dieses Objekts auswirken. Unerwartete Veränderungen an einem Alias können schwer zu erkennen und zu debuggen sein.'}],
]
KE2_questions = [
    [{'question': 'Welche praktische Bedeutung haben Metaklassen für die Programmierung in SMALLTALK?', 'answer': 'Metaklassen haben in SMALLTALK die praktische Bedeutung, dass sie die Definition von Klassen steuern und die Struktur des Programms beeinflussen. Sie ermöglichen es, Klassen dynamisch zu erzeugen und zu verändern. Zum Beispiel können Sie an der Ebene der Metaklassen Methoden hinzufügen, um das Verhalten von Klassen zu ändern, ohne die Klassen selbst zu ändern.'},
     {'question': 'Was ist die Hauptaufgabe von Programmierern im täglichen Programmieralltag im Zusammenhang mit Metaklassen?', 'answer': 'Im täglichen Programmieralltag beschränken sich die Aufgaben der Programmierer im Zusammenhang mit Metaklassen darauf, einfache Klassen anzulegen und zu ändern, insbesondere Klassen, deren Instanzen selbst keine Klassen sind. Die erforderlichen Metaklassen erstellt SMALLTALK automatisch selbst, und im Klassenbrowser werden sie nur durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden sichtbar.'},
     {'question': 'Was ist eine SortedCollection in SMALLTALK, und wie unterscheidet sie sich von anderen Collection-Klassen?', 'answer': 'Eine SortedCollection ist eine Collection-Klasse in SMALLTALK, die eine Subklasse von OrderedCollection ist. Im Gegensatz zu anderen Collection-Klassen wird die Reihenfolge der Elemente in einer SortedCollection nicht von außen, durch Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt. Stattdessen wird die Reihenfolge von innen durch eine Qualität der eingefügten Objekte bestimmt. Dies ermöglicht es, die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge zu halten, unabhängig von der Reihenfolge, in der sie der Collection hinzugefügt wurden.'},
     {'question': 'Welche Voraussetzungen müssen erfüllt sein, damit die Elemente einer SortedCollection sortiert werden können?', 'answer': 'Damit die Elemente einer SortedCollection sortiert werden können, müssen sie vergleichbar sein, dh die Methode <= (für kleiner gleich) muss für die Elemente definiert sein. Dies ermöglicht es, die Elemente aufsteigend zu sortieren.'},
     {'question': 'Was ist ein Sortierblock in einer SortedCollection, und wie wird er verwendet?', 'answer': 'Ein Sortierblock ist eine Funktion, die zwei formale Parameter hat und zurückliefert, ob der erste Parameter kleiner oder gleich dem zweiten ist. In einer SortedCollection kann ein Sortierblock angegeben werden, wenn die Elemente keine Größen sind oder keinen natürlichen Vergleich unterstützen. Der Sortierblock wird verwendet, um die Elemente zu vergleichen und die Reihenfolge in der SortedCollection festzulegen. Wenn kein Sortierblock angegeben wird, wird ein Standardsortierblock verwendet.'},
     {'question': 'Was ist die einfachste Form des Kopierens eines Objekts in SMALLTALK?', 'answer': 'Die einfachste Form des Kopierens eines Objekts in SMALLTALK ist das Erzeugen eines Objekts derselben Klasse mit denselben Variablenbelegungen. Dies wird durch die Methode "shallowCopy" ermöglicht.'},
     {'question': 'Welche Herausforderung kann bei flachem Kopieren auftreten, wenn es sich um ein tiefes Kopieren handelt?', 'answer': 'Bei flachem Kopieren, das selbst ein tiefes Kopieren enthält, kann der Kopiervorgang leicht in eine Endlosrekursion geraten.'},
     {'question': 'Welche Ansätze gibt es, um Objekte in der objektorientierten Programmierung zu erzeugen und ihnen Instanzvariablen und Methoden zuzuordnen?', 'answer': 'Es gibt drei verschiedene Ansätze, um Objekte in der objektorientierten Programmierung zu erzeugen und ihnen Instanzvariablen und Methoden zuzuordnen: Konstruktoransatz: Bei diesem Ansatz wird der Aufbau eines Objekts in einer Methode beschrieben, die dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zuweist. Verschiedene Konstruktoren können verschiedene Varianten von Objekten erzeugen. Prototypenansatz: Hier wird ein bereits existierendes Objekt samt seiner Instanzvariablen und Methoden geklont. Ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt oder abgeändert werden. Klassenansatz: Alle Objekte werden als Instanzen von bestimmten Vorlagen (Klassen) erzeugt. Diese Klassen definieren die Struktur und das Verhalten der Objekte.'},
     {'question': 'Welche Programmiersprachen nutzen den Konstruktoransatz?', 'answer': 'Der Konstruktoransatz findet sich in Sprachen wie EMERALD.'},
     {'question': 'Welche Programmiersprachen nutzen den Prototypenansatz?', 'answer': 'Der Prototypenansatz wird in Sprachen wie SELF oder JAVASCRIPT angewendet.'},
     {'question': 'Welche Programmiersprachen nutzen den Klassenansatz?', 'answer': 'Der Klassenansatz wird in Sprachen wie SMALLTALK, C++, EIFFEL, JAVA, C-Sharp, SCALA und vielen anderen mehr angewendet.'},
     {'question': 'Was sind Konstruktoren in SMALLTALK?', 'answer': 'In SMALLTALK sind Konstruktoren Methoden, die, wenn sie auf einer Klasse aufgerufen werden, eine neue Instanz dieser Klasse erstellen und zurückgeben. Sie sind Klassenmethoden, die dazu dienen, neue Objekte zu erzeugen.'},
     {'question': 'Welche Rolle spielen Ein- und Ausgabeströme in der objektorientierten Programmierung?', 'answer': 'Ein- und Ausgabeströme spielen in der objektorientierten Programmierung eine wichtige Rolle, da sie den Zugriff auf Eingabe- und Ausgabedaten im System ermöglichen. Sie dienen dazu, Daten sowohl von/zu Benutzern als auch von/zu Dateisystemen zu lesen und zu schreiben.'},
     {'question': 'Welche Funktion haben Streams in Bezug auf Collections?', 'answer': 'Streams ermöglichen einen sequentiellen Zugriff auf einzelne Elemente in Collections zu beliebigen Zeitpunkten. Dies unterscheidet sich von Iteratoren, die die gesamte Collection in einem Schritt durchlaufen. Streams ermöglichen auch den gleichzeitigen oder zeitlich abwechselnden Zugriff auf die Elemente einer Collection durch mehrere andere Objekte. Streams stellen Positionszeiger in eine Collection bereit, um diese Funktionen umzusetzen.'},
     {'question': 'Was sind die Unterschiede zwischen lesbarbaren und schreibbaren Streams?', 'answer': 'Lesbare Streams ermöglichen das Lesen von Daten aus einer Quelle, während schreibbare Streams das Schreiben von Daten in eine Zielquelle ermöglichen. Lesbare Streams bieten Methoden zum Lesen von Daten, während schreibbare Streams Methoden zum Schreiben von Daten bereitstellen.'},
     {'question': 'Welche Informationen können in einer Metaklasse definiert werden?', 'answer': 'In einer Metaklasse können Informationen wie Instanzvariablen und Methoden für die zugehörige Klasse definiert werden. Dies ermöglicht es, das Verhalten und die Eigenschaften der Klasse individuell anzupassen.'},
     {'question': 'Was sind Klassen sprachphilosophisch?', 'answer': 'Sprachphilosophisch betrachtet ist eine Klasse ein Allgemeinbegriff. Diese Allgemeinbegriffe repräsentieren in der Regel eine Menge von Objekten,. Dennoch ist die Klasse selbst immer im Singular, da sie selbst ein Objekt ist, das unter den Allgemeinbegriff "Klasse" fällt.'},
     {'question': 'Was sind die Eigenschaften einer Klasse?', 'answer': 'Die Eigenschaften einer Klasse ordnen wir den Objekten zu, die dieser Klasse angehören. Zum Beispiel sind mit dem Allgemeinbegriff "Person" Eigenschaften wie Name, Geburtstag und möglicherweise weitere Attribute verknüpft, aber auch bestimmtes Verhalten, das für Personen charakteristisch ist. Diese Eigenschaften gehören den individuellen Objekten an, die Teil der Klasse "Person" sind.'},
     {'question': 'Was ist die Methode become: in SMALLTALK?', 'answer': 'Die Methode become: in SMALLTALK bewirkt, dass das Empfängerobjekt die Identität des Parameterobjekts annimmt oder mit ihm tauscht.'},
     {'question': 'Welche Auswirkungen hat die Methode become: auf Variablen?', 'answer': 'Die Methode become: bewirkt, dass Variablen, die vor der Ausführung der Methode auf das Empfängerobjekt verwiesen haben, danach auf das Parameterobjekt verweisen.'},
     {'question': 'Was ist eine weitere Anwendung von become:?', 'answer': 'Eine weitere Anwendung von become: ist die Durchführung eines Rollbacks, um den ursprünglichen Zustand eines Objekts oder Objektgeflechts nach einer Menge von Änderungen wiederherzustellen. Dies geschieht durch Erzeugen einer Kopie des ursprünglichen Objekts und anschließendem Ersetzen des geänderten Objekts durch die Kopie mittels become:.'},
     {'question': 'Welche Bedeutung hat die Generalisierung in der objektorientierten Programmierung?', 'answer': 'Die Generalisierung ermöglicht es, mehrere Klassen, deren Definitionen inhaltlich verwandt sind, zu abstrahieren und zusammenzufassen. Dies führt zur Bildung einer Generalisierungsklasse, die die gemeinsamen Eigenschaften (Instanzvariablen und Methoden) der generalisierten Klassen enthält. Die Generalisierung erlaubt es, Gemeinsamkeiten zwischen Klassen auf höherer Abstraktionsebene darzustellen und die Wiederverwendung von Code zu fördern.'},
     {'question': 'Was ist die mengentheoretische Interpretation der Generalisierung?', 'answer': 'In der mengentheoretischen Interpretation der Generalisierung ist die Menge der Instanzen einer Generalisierung eine Obermenge der Vereinigung der Mengen der Instanzen von generalisierten Klassen. Dies bedeutet, dass Instanzen von generalisierten Klassen auch Instanzen der Generalisierung sind.'},
     {'question': 'Was sind Konstruktoren in SMALLTALK und was ist ihre Aufgabe?', 'answer': 'In SMALLTALK sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse erstellen und zurückliefern. Ihre Aufgabe ist es, neue Objekte zu erzeugen.'},
     {'question': 'Was ist "Lazy initialization" und wann kann es sinnvoll sein?', 'answer': '"Lazy initialization" ist eine Technik, bei der die Initialisierung von Instanzvariablen zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt wird. Dies kann sinnvoll sein, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Die Initialisierung wird verschoben, um den Preis der Initialisierung im Programmablauf zu sparen, wenn sie nie notwendig wird.'},
     {'question': 'Welches Entwurfsmuster wird SMALLTALK zugeschrieben und warum ist es wichtig?', 'answer': 'SMALLTALK wird das Model-View-Controller-Entwurfsmuster (MVC-Pattern) zugeschrieben. Es ist wichtig, da es sich auch heute noch großer Beliebtheit erfreut und in vielen Anwendungen, einschließlich Web-Anwendungen, verwendet wird. Das MVC-Pattern ermöglicht verschiedene Ansichten auf ein logisches Modell, und Änderungen im Modell müssen alle Ansichten darüber informieren. Daher erfordert es eine Eins-zu-viele-Kommunikation, die nicht durch den normalen Nachrichtenversand abgedeckt wird.'},
     {'question': 'Was ist eine Klassendefinition?', 'answer': 'Eine Klassendefinition liefert die Intension oder Beschreibung einer Klasse. Sie besteht aus dem Namen der Klasse, der Liste der benannten Instanzvariablen, Angaben zu indizierten Instanzvariablen, Informationen zur Atomarität, und einer Liste von Instanzmethoden.'},
     {'question': 'Was sind Instanzen einer Klasse?', 'answer': 'Eine Instanz der Klasse ist das Objekt, das zur Extension der Klasse gehört. Jede Instanz belegt den Satz an Instanzvariablen individuell. Alle Instanzen einer Klasse verstehen dieselben Nachrichten und verwenden dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren.'},
     {'question': 'Was sind indizierte Instanzvariablen?', 'answer': 'Indizierten Instanzvariablen enthalten binäre Repräsentationen.'},
     {'question': 'Was sind globale Pseudovariablen?', 'answer': 'In SMALLTALK wird jede Klasse nach ihrer Erzeugung durch eine globale Pseudovariable repräsentiert, deren Name dem Namen der Klasse entspricht. Diese globale Pseudovariable ist notwendig, um auf die Klasse und ihre Methoden zugreifen zu können. Klassennamen sind global und von überall aus im Code zugreifbar.'},
     {'question': 'Was sind die Rollen der beiden Enden der Subklassenbeziehung?', 'answer': 'Die beiden Enden der Subklassenbeziehung haben die Rollen "Superklasse" und "Subklasse". Diese Rollen legen nahe, dass die Subklassenbeziehung eine Hierarchie von Klassen aufbaut, in der die Superklassen über den Subklassen stehen. Die Superklasse ist die allgemeinere Klasse, von der die Subklasse erbt, während die Subklasse die speziellere Klasse ist, die die Eigenschaften der Superklasse erbt und möglicherweise erweitert oder anpasst.'},
     {'question': 'Welche Konzepte haben die Entwicklung objektorientierter Programmiersprachen im Gegensatz zu Generalisierung und Spezialisierung geprägt?', 'answer': 'Die Entwicklung objektorientierter Programmiersprachen wurde eher von abstrakten Klassen und Vererbung als von den theoretischen Konzepten der Generalisierung und Spezialisierung geprägt.'},
     {'question': 'Was ist das Konzept der offenen Rekursion in SMALLTALK?', 'answer': 'Das Konzept der offenen Rekursion in SMALLTALK bedeutet, dass die Methode, die durch eine Nachricht an self aufgerufen wird, nicht zwangsläufig die in derselben Klasse definierte Methode ist. Stattdessen kann die passende Methode in einer Subklasse gefunden werden, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde. Dies kann zu überraschenden Ergebnissen führen, wenn nicht erwartet wird, dass die Methode in einer Subklasse überschrieben wurde.'},
     {'question': 'Was ist der grundlegende Unterschied zwischen aktiven und passiven Objekten in der objektorientierten Programmierung?', 'answer': 'Aktive Objekte sind Objekte, die über einen eigenen Rechenprozess verfügen und Nachrichten asynchron empfangen und verarbeiten können. Passive Objekte hingegen sind Objekte, die nur aktiv sind, solange sie gerade eine Methode ausführen. In der Praxis werden jedoch passive Objekte verwendet, da aktive Objekte sehr aufwendig wären.'},
     {'question': 'Welche Methode wird verwendet, um einen parametrisierten Block als Prozess zu starten?', 'answer': 'Um einen parametrisierten Block als Prozess zu starten, verwendet man die Methode "newProcessWith:" mit einem Array als Parameter, das die tatsächlichen Parameter des Blocks enthält.'},
     {'question': 'Was ist die Beziehung zwischen der Klasse "Metaclass" und ihrer eigenen Meta-Metaklasse?', 'answer': 'Die Klasse "Metaclass" von "Metaclass" wird selbst als einfache Metaklasse betrachtet, obwohl sie eigentlich eine Meta-Meta-Metaklasse ist. Genau wie alle anderen Metaklassen ist sie eine Instanz von "Metaclass". Daher gilt für "Metaclass": Metaclass ist eine Instanz von Metaclass.'},
     {'question': 'Welche Ebenen gibt es in SMALLTALK im Zusammenhang mit Klassen und Instanzen?', 'answer': 'In SMALLTALK gibt es mehrere Ebenen im Zusammenhang mit Klassen und Instanzen: Ebene 0: Konkrete Objekte, die nicht instanziierbar sind und Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Ebene 1: Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Ebene 2: Metaklassen, die die Klassen auf Ebene 1 definieren. Jede Metaklasse hat genau eine Instanz. Ebene 3: Die Klasse "Metaclass", von der alle Metaklassen Instanzen sind.'},
     {'question': 'Was ist der wesentliche Nachteil von Arrays in SMALLTALK?', 'answer': 'Der wesentliche Nachteil von Arrays in SMALLTALK ist, dass ihre Größe beschränkt ist. Das bedeutet, dass die Anzahl der Elemente in einem Array begrenzt ist, und es schwierig oder teuer sein kann, die Größe eines Arrays dynamisch zu ändern, um mehr Elemente aufzunehmen.'},
     {'question': 'Welche SMALLTALK-Klasse eignet sich besser für geordnete Collections, die beliebig wachsen können, und warum?', 'answer': 'Für geordnete Collections, die beliebig wachsen können und bei denen am Anfang, am Ende oder an einer beliebigen Position dazwischen Elemente hinzugefügt werden können, eignet sich die Klasse "OrderedCollection" besser als Arrays. OrderedCollections bieten einen geeigneten Methodensatz und ein Protokoll für die Implementierung von Stapeln (Stacks) und Puffern (Queues). Sie sind flexibler und können dynamisch wachsen, was Arrays nicht können.'},
     {'question': 'Welche Besonderheiten gibt es beim Entfernen eines Objekts aus einer Collection in SMALLTALK?', 'answer': 'Beim Entfernen eines Objekts aus einer Collection gibt es zwei Sonderfälle zu berücksichtigen: Das Objekt ist nicht vorhanden oder das Objekt ist mehrfach vorhanden. Im ersten Fall wird ein Fehler gemeldet, während im zweiten Fall nur ein Vorkommen des Objekts aus der Collection entfernt wird. SMALLTALK bietet eine Variante von remove: namens remove: anObject ifAbsent: anExceptionBlock, die es ermöglicht, das Verhalten beim Fehlen des zu entfernenden Objekts zu steuern. Wenn das Objekt fehlt, wird anExceptionBlock ausgeführt, und dessen Ergebnis wird zurückgeliefert.'},
     {'question': 'Was ist die Hierarchie in SMALLTALK, die auf dem Konzept der Klassifikation basiert?', 'answer': 'In SMALLTALK gibt es eine Hierarchie, die auf dem Konzept der Klassifikation basiert. Diese Hierarchie stellt eine Abstraktionshierarchie dar, bei der von konkreten Objekten der Ebene 0 über Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Konzepte auf Ebene 2 und schließlich zur Fassung von Definitionen auf Ebene 3 fortgeschritten wird.'},
     {'question': 'Welche Ebene der Hierarchie nutzen Programmierer in der Praxis am meisten?', 'answer': 'In der Praxis bewegen sich Programmierer hauptsächlich auf Ebene 1. Sie definieren Anwendungsklassen, von denen zur Laufzeit des Programms die Anwendungsobjekte erzeugt werden. Direkt nutzen sie also hauptsächlich eine Abstraktionsstufe für die Programmierung.'},
     {'question': 'Was sind einige Beispiele für spezielle, instanziierbare (konkrete) Collection-Klassen in SMALLTALK und wofür werden sie verwendet?', 'answer': 'Einige Beispiele für spezielle, instanziierbare (konkrete) Collection-Klassen in SMALLTALK sind: Set: Diese Klasse wird verwendet, um ungeordnete Collections darzustellen, in denen jedes Element höchstens einmal vorkommen darf, was einer Menge entspricht. Bag: Bag wird verwendet, um ungeordnete Collections darzustellen, in denen die Einschränkung aufgehoben ist, dass Elemente nur einmal vorkommen dürfen. In einer Bag können Elemente mehrmals vorhanden sein. SequenceableCollection oder IndexedCollection: Diese Klassen repräsentieren geordnete Collections, bei denen das i-te Element eindeutig bestimmt ist. Sie implementieren die Methoden "at:" und "at:put:", um auf Elemente zuzugreifen oder Elemente an einer bestimmten Position einzufügen oder zu ändern. Dictionary: Diese Klasse repräsentiert eine ungeordnete Collection, bei der jedes Element unter einem Schlüssel gespeichert wird. Die Methoden "at:" und "at:put:" werden verwendet, um auf die Elemente zuzugreifen oder sie zu ändern. Dabei können Schlüssel Objekte verschiedener Klassen sein, nicht nur Integer.'},
     {'question': 'Welche Gemeinsamkeiten haben die Klassen "Set" und "Bag" in SMALLTALK?', 'answer': 'Die Gemeinsamkeit zwischen den Klassen "Set" und "Bag" besteht darin, dass beide ungeordnete Collections repräsentieren. In diesen Collections darf jedes Element höchstens einmal vorkommen. Sie unterscheiden sich jedoch darin, dass in einem Set die Elemente eindeutig sind und keine Duplikate enthalten, während in einer Bag Elemente mehrmals vorhanden sein können.'},
     {'question': 'Welche Möglichkeiten gibt es, den Mechanismus der Vererbung von Superklassen auf Subklassen umzusetzen?', 'answer': 'Es gibt verschiedene Möglichkeiten, den Mechanismus der Vererbung von Superklassen auf Subklassen umzusetzen. Zwei dieser Möglichkeiten wurden im Text angedeutet: Kopieren und Einfügen: Eine Möglichkeit wäre, die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Dies würde die Semantik der Vererbung korrekt wiedergeben, aber bei Änderungen an der Superklasse müssten auch alle Subklassen aktualisiert werden, was technisch problematisch wäre. Automatische Instanzerzeugung: Eine andere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch Instanzen aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Dies würde jedoch das Konzept der Identität von Objekten beeinträchtigen, da Objekte einer Subklasse mehrere Identitäten hätten.'},
     {'question': 'Was ist Spezialisierung in Bezug auf die objektorientierte Programmierung?', 'answer': 'Spezialisierung ist das Gegenteil von Generalisierung in der objektorientierten Programmierung. Während bei der Generalisierung Eigenschaften weggelassen oder verallgemeinert werden, fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene Eigenschaften von Klassen. Es bedeutet, dass eine Klasse eine Spezialisierung ihrer Generalisierungen sein kann, wenn sie zusätzliche Merkmale oder Verhaltensweisen hinzufügt.'},
     {'question': 'Was ist die Funktion der Methode printString in SMALLTALK?', 'answer': 'Die Methode printString gibt eine String-Repräsentation eines Objekts zurück. Diese Repräsentation kann für Ausgaben auf dem Transcript, zur Inspektion von Objekten und für das Debugging verwendet werden.'},
     {'question': 'Was ist die Funktion der Methode storeOn: in SMALLTALK?', 'answer': 'Die Methode storeOn: ermöglicht das Schreiben eines Objekts auf einen Ausgabestrom in einer textuellen Repräsentation, die später zur Rekonstruktion des Objekts verwendet werden kann. Es wird keine binäre Repräsentation verwendet. Dies ist nützlich, um Objekte in einer menschenlesbaren Form zu speichern und später wiederherzustellen.'},
     {'question': 'Was ist Instanziierung?', 'answer': 'Instanziierung ist der Prozess, bei dem ein neues Objekt einer bestimmten Klasse erstellt wird. Das neue Objekt wird eine Instanz dieser Klasse genannt und hat die Eigenschaften (Instanzvariablen und Methoden), die durch die Definition (Intension) der Klasse festgelegt sind.'},
     {'question': 'Was ist eine Instanz?', 'answer': 'In SMALLTALK ist jedes Objekt Instanz genau einer Klasse. Genaugenommen ist es direkte Instanz genau einer Klasse. Dabei weiß jedes Objekt, von welcher Klasse es eine Instanz ist.'},
     {'question': 'Welche Alternative gibt es zur Instanziierung?', 'answer': 'Eine Alternative zur Instanziierung ist das Klonen.'},
     {'question': 'Was ist das Klonen?', 'answer': 'Das Klone ist ein Prozess, bei dem ein neues Objekt auf der Basis eines bereits existierenden Objekts erstellt wird. Der Klon ist eine Kopie des Originalobjekts. Beim Klonen muss festgelegt werden, wie tief die Kopie gehen soll, dh ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht, kopiert werden sollen. Während das Klonen in klassenbasierten objektorientierten Programmiersprachen in der Regel durch Instanziierung und Übertragung von Inhaltsdaten der Instanzvariablen erzeugt wird, erfolgt das Klonen in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse nicht kennen, durch einfaches Kopieren. In SMALLTALK wird die Instanziierung normalerweise bevorzugt, da es sich um eine klassenbasierte Sprache handelt.'},
     {'question': 'Welche Bezeichnungen werden alternativ zur Subklassenbeziehung und den Begriffen Subklasse und Superklasse in der objektorientierten Programmierung verwendet?', 'answer': 'In der objektorientierten Programmierung werden neben der Subklassenbeziehung und den Begriffen Subklasse und Superklasse auch Begriffe wie "abgeleitete Klassen" und "Basisklassen" verwendet. Im Englischen sind auch die Begriffe "Derived class" und "Base class" gebräuchlich. Es kann je nach Programmiersprache und Konvention unterschiedliche Bezeichnungen geben.'},
     {'question': 'Welche Bedingungen müssen erfüllt sein, damit eine Subklassenbeziehung zwischen zwei Klassen in SMALLTALK zulässig ist?', 'answer': 'Damit eine Subklassenbeziehung zwischen zwei Klassen in SMALLTALK zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen: Benannte Instanz- und Klassenvariablen dürfen nicht dieselben Namen haben wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Wenn die Superklasse indizierte Instanzvariablen hat, müssen diese auch in der Subklasse vorhanden sein. Methodendefinitionen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden.'},
     {'question': 'Welche Ansicht über die objektorientierte Programmierung herrschte in den Anfängen von SMALLTALK?', 'answer': 'In den Anfängen von SMALLTALK herrschte die Ansicht vor, dass einer der Hauptvorteile der objektorientierten Programmierung die Wiederverwendung von Code durch Vererbung sei. Man glaubte, dass die Vererbung dazu diene, Code und Eigenschaften von einer allgemeineren Klasse (Superklasse) auf speziellere Klassen (Subklassen) zu übertragen, was die Wiederverwendung von Code fördert.'},
     {'question': 'Was sind Factory-Methoden in SMALLTALK?', 'answer': 'Factory-Methoden in SMALLTALK sind spezielle Klassenmethoden, die ähnlich wie Konstruktoren neue Instanzen erstellen. Allerdings können sie die Klasse der Instanz basierend auf anderen Faktoren als nur der Klasse, zu der die Methode gehört, festlegen.'},
     {'question': 'Welches Prinzip geht der Vererbung voraus und wie stehen sie in Beziehung zueinander?', 'answer': 'Die Prinzipien von Generalisierung und Spezialisierung gehen der Vererbung voraus. Generalisierung und Spezialisierung sind eng mit der Vererbung verbunden, da Vererbung oft verwendet wird, um diese Prinzipien umzusetzen. Generalisierung ist die Bildung von allgemeineren Klassen aus spezifischeren Klassen, während Spezialisierung die Bildung spezifischerer Klassen aus allgemeineren Klassen ist.'},
     {'question': 'Welches Problem kann bei der Vererbung auftreten, wenn sie nicht in Einklang mit den Prinzipien von Generalisierung und Spezialisierung angewendet wird?', 'answer': 'Ein Problem bei der Vererbung tritt auf, wenn sie oberflächlich zur Wiederverwendung von Elementen einer Klassendefinition verwendet wird, ohne die Prinzipien von Generalisierung und Spezialisierung zu berücksichtigen. Dies kann dazu führen, dass die Beziehung zwischen den Extensionen der beteiligten Klassen nicht angemessen berücksichtigt wird und zu unerwarteten Konsequenzen führt.'},
     {'question': 'Was sind Dictionaries in SMALLTALK, und wofür werden sie verwendet?', 'answer': 'In SMALLTALK repräsentieren Dictionaries qualifizierte Beziehungen, bei denen jedes Element der Beziehung durch einen Schlüssel (auch als Qualifizierer oder Key bezeichnet) eindeutig bestimmt wird. Ein Element einer qualifizierten Beziehung besteht aus einer Assoziation eines Schlüssels mit einem Wert (Value). Dictionaries ermöglichen es, Werte unter ihren Schlüsseln extrem schnell, idealerweise ohne Suche, zu finden. Dies wird in der Regel durch Hashing erreicht.'},
     {'question': 'Welche besondere Bedeutung hat die Klasse Dictionary in SMALLTALK?', 'answer': 'Die Klasse Dictionary in SMALLTALK realisiert Assoziativspeicher, bei denen auf Speicherzellen nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet, beispielsweise um Methoden in Dictionaries zu hinterlegen, wobei der Nachrichtenselektor die Rolle des Schlüssels spielt und als Wertobjekt die kompilierte Methode gespeichert ist. Dictionaries können auch verwendet werden, um andere Arten von Collections, wie z.B. die Klasse Bag, zu implementieren.'},
     {'question': 'Welche Einschränkung gibt es bei der Verwendung eines Attributs als Schlüssel in einem Dictionary?', 'answer': 'Wenn ein Attribut eines in einem Dictionary gespeicherten Objekts als Schlüssel verwendet wird, sollte dieses Attribut unveränderlich sein. Dies liegt daran, dass das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel im Dictionary gespeichert ist und nur unter diesem Wert wiedergefunden wird.'},
     {'question': 'Was ist die Klassifikation?', 'answer': 'Eine Klassifikation ist eine Zuordnung von Individuen oder Objekten zu bestimmten Allgemeinbegriffen oder Klassen. Diese Klassifikation ermöglicht eine Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen und Eigenschaften nur noch für die Klassen im Allgemeinen getroffen werden müssen, anstatt für jedes einzelne Objekt. Statt also Eigenschaften und Methoden direkt Objekten zuzuweisen, verbindet man sie mit Klassen und legt fest, dass sie die einzelnen Objekte, die zu dieser Klasse gehören, beschreiben.'},
     {'question': 'Was ist die Extension?', 'answer': 'Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören.'},
     {'question': 'Was ist die Intension?', 'answer': 'Die Intension ist die Summe der Merkmale oder Eigenschaften, die den Begriff ausmachen und die Objekte charakterisieren, die zu dieser Klasse gehören. Die Intension ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die entscheidet, ob ein beliebiges Element unter den Begriff fällt.'},
     {'question': 'Was sind Allgemeinbegriffe ?', 'answer': 'Allgemeinbegriffe sind die Vorbilder für Klassen in der objektorientierten Programmierung. In SMALLTALK werden Allgemeinbegriffe in Form von Klassen repräsentiert. Klassen sind die Vorbilder für Objekte in der objektorientierten Programmierung. Jede Klasse kann Instanzvariablen und Methoden haben, die das Verhalten und die Eigenschaften der Objekte beschreiben, die zu dieser Klasse gehören.'},
     {'question': 'Was sind abstrakte Klassen in der objektorientierten Programmierung?', 'answer': 'Abstrakte Klassen in der objektorientierten Programmierung sind Klassen, die selbst keine Instanzen haben und daher nicht instanziierbar sind. Sie werden oft verwendet, um gemeinsame Eigenschaften und Methoden für ihre Subklassen bereitzustellen, aber sie sind in der Regel unvollständig definiert und können zu Laufzeitfehlern führen, wenn sie direkt instanziiert werden.'},
     {'question': 'Was ist ein Beispiel für eine abstrakte Klasse in SMALLTALK und wie zeigt sich ihre Abstraktheit?', 'answer': 'Ein Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse "Collection". Ihre Abstraktheit zeigt sich darin, dass sie keine benannten Instanzvariablen hat und einige ihrer Methoden, wie "add:", nicht implementiert sind. Wenn jemand versuchen würde, die Methode "add:" auf einer Instanz von "Collection" oder einer ihrer Subklassen aufzurufen, würde dies zu einer Fehlermeldung führen.'},
     {'question': 'Was ist die Klasse "Interval" und wofür werden ihre Instanzen verwendet?', 'answer': 'Die Klasse "Interval" repräsentiert endliche arithmetische Folgen von Zahlen, bei denen alle Zahlen denselben Abstand voneinander haben. Instanzen dieser Klasse werden verwendet, um solche Intervalle zu definieren, wobei die Spezifikation eines Intervalls den Anfangs- und Endwert sowie die Schrittweite umfasst, die sogar negativ sein kann.'},
     {'question': 'Was ist das Besondere an der Methode "to:by:do:"?', 'answer': 'Die Methode "to:by:do:" erlaubt die kompakte Darstellung einer "For"-Schleife und erspart die Verwendung von Klammern. Sie ermöglicht es, den Schleifenkörper in einem übersichtlichen Format anzugeben.'},
     {'question': 'Welche Art von Methoden bietet die Klasse "Object" den Objekten an?', 'answer': 'Die Klasse "Object" bietet eine Vielzahl von Methoden an, die grundlegende Typtests und andere gemeinsame Operationen für Objekte ermöglichen. Dazu gehören Methoden wie isNil, notNil, isInteger, isFloat und viele andere. Diese Methoden erlauben es, Eigenschaften von Objekten abzufragen und deren Typ zu überprüfen.'},
     {'question': 'Was sind Zu-n-Beziehungen und wie stehen sie zu Zu-1-Beziehungen?', 'answer': 'Zu-n-Beziehungen sind Beziehungen, bei denen ein Objekt mit mehreren anderen Objekten in Beziehung stehen kann. Sie stehen logisch gleichberechtigt neben Zu-1-Beziehungen, bei denen ein Objekt nur mit einem anderen Objekt in Beziehung steht. Die Umsetzung von Zu-n-Beziehungen erfordert jedoch besondere Mechanismen.'},
     {'question': 'Welche Rolle spielen Zwischenobjekte in der Umsetzung von Zu-n-Beziehungen?', 'answer': 'Zwischenobjekte spielen eine Rolle in der Umsetzung von Zu-n-Beziehungen. Sie ermöglichen es, solche Beziehungen indirekt über ihre indizierten Instanzvariablen herzustellen.'},
     {'question': 'Welcher Vorteil ergibt sich aus der Verwendung von Zwischenobjekten in Bezug auf Zu-n-Beziehungen?', 'answer': 'Ein entscheidender Vorteil der Verwendung von Zwischenobjekten in Bezug auf Zu-n-Beziehungen ist die Möglichkeit, verschiedene Arten von solchen Beziehungen zu definieren und diesen jeweils spezifisches Verhalten zuzuweisen, das auf die Art der Beziehung abgestimmt ist. Dies ermöglicht es, mengenwertige Beziehungen oder sortierte Beziehungen zu erstellen und Operationen wie das Hinzufügen oder Entfernen von Objekten individuell anzupassen.'},
     {'question': 'Was sind einige Beispiele für spezielle Arten von Zu-n-Beziehungen?', 'answer': 'Ein Beispiel für eine spezielle Art von "n-Beziehung" ist eine mengenwertige Beziehung, bei der die Elemente jeweils nur einmal darin vorkommen dürfen. Eine weitere Art ist eine sortierte Beziehung, bei der die Elemente nach einem bestimmten Kriterium sortiert sind.'},
     {'question': 'Welche Rolle spielen Standarditeratoren in Bezug auf Zu-n-Beziehungen?', 'answer': 'Standarditeratoren spielen eine Rolle in Bezug auf Zu-n-Beziehungen, und je nach Art der Beziehung haben sie unterschiedliche Eigenschaften. Diese Standarditeratoren wurden bereits in Abschnitt 4.6.4 vorgestellt.'}],
    [{'question': 'Wie wird in SMALLTALK die Mächtigkeit eines Programms hervorgehoben, insbesondere im Vergleich zu imperativen und objektorientierten Programmiersprachen?', 'answer': 'In SMALLTALK wird die Mächtigkeit eines Programms hervorgehoben, indem betont wird, dass Klassen Instanzen von Metaklassen sind, die selbst Instanzen einer weiteren Klasse sind. Dieses Zusammenspiel von Klassen und Metaklassen ermöglicht eine hohe Programmiermächtigkeit. Im Vergleich zu imperativen und objektorientierten Programmiersprachen sucht diese Mächtigkeit bis heute ihresgleichen.'},
     {'question': 'Wie können Objekte von einer Collection in eine andere übertragen werden, und warum kann dies nützlich sein?', 'answer': 'Eine Menge von Objekten aus einer Collection kann in eine andere übertragen werden, indem Konvertierungsmethoden wie asSet oder asSortedCollection verwendet werden. Dies ist nützlich, um die Eigenschaften der Ziel-Collection zu berücksichtigen, z. B. doppelte Elemente zu entfernen oder die Elemente zu sortieren. Es ermöglicht auch die Umwandlung von Collections in Collections mit strengeren Bedingungen, was je nach Anwendungsfall nützlich sein kann.'},
     {'question': 'Wie können Sie technisch eine rekursive tiefe Kopie in den Griff bekommen?', 'answer': 'Um eine rekursive tiefe Kopie in den Griff zu bekommen, können Sie eine Methode implementieren, die überprüft, ob ein Objekt bereits kopiert wurde, und es nur dann kopiert, wenn es noch nicht kopiert wurde. Dadurch wird die Endlosrekursion vermieden.'},
     {'question': 'Wie ist die Vererbungshierarchie der Metaklassen in SMALLTALK organisiert?', 'answer': 'In SMALLTALK können Metaklassen, die ebenfalls Klassen sind, voneinander erben. Die Vererbungshierarchie der Metaklassen wird parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind, erstellt. Dies bedeutet, dass in SMALLTALK sowohl Instanzvariablen und -methoden als auch Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt werden. Jede Metaklasse in SMALLTALK erbt automatisch von "Object class", der Metaklasse von "Object". Die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, einschließlich der Standardkonstruktoren "new" und "new:", werden in "Object class" (genauer gesagt als Instanzmethoden von "Object class") definiert. Um die Unterscheidung zwischen instanziierbaren Klassen (Klassen) und nicht instanziierbaren Klassen (Metaklassen) sowie zwischen Klassen und Metaklassen zu treffen, wird die Klasse "Class" verwendet. "Class" ist die Superklasse aller Metaklassen und stellt sicher, dass jede Instanz dieser Klasse eine Klasse ist. Obwohl "Class" die Superklasse aller Metaklassen ist, ist sie selbst keine Metaklasse. Die Klasse von "Class" ist "Class class", und erst "Class class" ist eine Metaklasse.'},
     {'question': 'Wie werden Streams in SMALLTALK normalerweise erzeugt?', 'answer': 'Streams werden normalerweise durch die Klassenmethode on: auf einer Collection erzeugt. Diese Methode erhält eine Collection als Parameter und erstellt einen Stream, der auf dem Inhalt der Collection basiert.'},
     {'question': 'Wie werden Metaklassen in SMALLTALK erstellt?', 'answer': 'In SMALLTALK werden Metaklassen automatisch erstellt, wenn eine neue Klasse definiert wird. Jede Klasse hat automatisch ihre eigene Metaklasse, die die Definitionen von Instanzvariablen und Methoden für diese Klasse enthält.'},
     {'question': 'Wie können Programmierer in SMALLTALK geerbte Methoden löschen?', 'answer': 'In SMALLTALK können Programmierer geerbte Methoden löschen, indem sie die Methode "shouldNotImplement" in der Subklasse implementieren und die geerbte Methode überschreiben. Wenn eine Klasse also eine geerbte Methode löschen möchte, überschreibt sie diese Methode einfach mit "shouldNotImplement". Diese Konvention ermöglicht es Programmierern, geerbte Methoden elegant auszulöschen, sollte dies erforderlich sein. Es ist jedoch wichtig zu beachten, dass der Wunsch, geerbte Methoden zu löschen, eine direkte Folge der Orientierung an Vererbung ist, die in dieser Textpassage kritisiert wird. Wenn die Superklasse auf Grundlage des Prinzips der Generalisierung ausgewählt wurde, besteht normalerweise keine Notwendigkeit, geerbte Methoden zu löschen, da alles, was für die Generalisierung sinnvoll ist, auch für ihre Spezialisierungen sinnvoll ist. Dieses Prinzip wird in späteren Kurseinheiten weiter erläutert.'},
     {'question': 'Wie kann die Methode grow in der Klasse ArrayedCollection verwendet werden?', 'answer': 'Die Methode grow in der Klasse ArrayedCollection kann verwendet werden, um ein Objekt zu vergrößern, indem man eine neue Stelle als entsprechend groß dimensioniertes Objekt anlegt und dann das alte Objekt durch die neue Stelle mittels become: ersetzt.'},
     {'question': 'Wie werden Instanzvariablen in SMALLTALK standardmäßig initialisiert, nachdem eine Instanz erzeugt wurde?', 'answer': 'Nach der Erzeugung einer Instanz in SMALLTALK haben alle Instanzvariablen standardmäßig den Wert "nil". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden, normalerweise durch Aufrufen der Methode "initialize".'},
     {'question': 'Wie wird die Eins-zu-viele-Kommunikation in SMALLTALK umgesetzt?', 'answer': 'Die Eins-zu-viele-Kommunikation in SMALLTALK wird durch das in SMALLTALK implementierte Protokoll umgesetzt. Dieses Protokoll ermöglicht die Kommunikation zwischen verschiedenen Teilen einer Anwendung, insbesondere im Kontext des MVC-Patterns.'},
     {'question': 'Wie werden Klassendefinitionen in SMALLTALK umgesetzt?', 'answer': 'In SMALLTALK erfolgt die Klassendefinition nicht in einer separaten Datei wie in vielen anderen objektorientierten Programmiersprachen. Stattdessen werden Klassendefinitionen durch Eintragungen in eine Datenstruktur oder das Erzeugen eines Objekts repräsentiert. Es gibt keine spezielle Syntax für Klassendefinitionen, nur ein Schema.'},
     {'question': 'Wie funktioniert die Verwendung von super in SMALLTALK?', 'answer': 'Wenn super als Nachrichtenempfänger in einer Methodendefinition verwendet wird, beginnt die Suche nach der zur Nachricht passenden Methodendefinition in der (direkten) Superklasse der Klasse, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet. Anders als bei self ist die Suche unabhängig von der Klasse des Objekts, für das super steht. Das bedeutet, dass super immer eine von der Klasse des konkreten Empfängerobjekts losgelöste Suche auslöst, die in der Superklasse der Klasse beginnt, in der super verwendet wird, und nicht in der Superklasse der Klasse, von der das (durch super bezeichnete) Empfängerobjekt eine direkte Instanz ist.'},
     {'question': 'Wie wird Parallelverarbeitung in SMALLTALK implementiert, und warum werden keine aktiven Objekte verwendet?', 'answer': 'In SMALLTALK wird Parallelverarbeitung nicht in Form von aktiven Objekten, sondern in Form von parallelen Prozessen implementiert. Jeder dieser Prozesse führt zu einem Zeitpunkt eine Methode aus, wobei die Empfängerobjekte selbst passiv bleiben. Dies liegt daran, dass aktive Objekte, die asynchron Nachrichten verarbeiten, in der Praxis sehr aufwendig wären.'},
     {'question': 'Wie startet man in SMALLTALK einen neuen Prozess?', 'answer': 'In SMALLTALK kann man einen neuen Prozess starten, indem man einem Block die Nachricht "fork" sendet. Dies führt dazu, dass der Block in einem eigenen, unabhängigen Prozess ausgeführt wird.'},
     {'question': 'Wie erfolgt die Synchronisation von parallelen Prozessen in SMALLTALK?', 'answer': 'Die Synchronisation von parallelen Prozessen in SMALLTALK erfolgt zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen über Methoden wie "wait" und "signal", um die Ausführung von Prozessen zu steuern. Semaphore-Objekte zählen die Anzahl der Signale und können Prozesse in den Schlaf versetzen oder aufwecken, abhängig von ihrem aktuellen Zustand. Die Synchronisation kann auch über die Klasse SharedQueue erfolgen, die Objekte aufnimmt und Synchronisation über "next" und "nextPut:" ermöglicht.'},
     {'question': 'Wie funktioniert die Suche nach einer Methode in SMALLTALK?', 'answer': 'Bei der Suche nach einer Methode wird zunächst im Methodenwörterbuch der Klasse des Empfängers nachgeschlagen. Wenn die Methode dort nicht gefunden wird, wird in der direkten Superklasse der Klasse des Objekts gesucht, und dieser Prozess setzt sich fort, bis die Methode gefunden wird oder bis zur Klasse "Object". Sobald die Methode gefunden wird, wird sie ausgeführt. Falls die Methode auch in "Object" nicht gefunden wird, wird die Nachricht "doesNotUnderstand:" an den ursprünglichen Empfänger mit der ursprünglichen Nachricht als Argument gesendet.'},
     {'question': 'Wie wird die Klasse "Metaclass" in SMALLTALK bezeichnet und warum?', 'answer': 'Die Klasse "Metaclass" wird in SMALLTALK als "Metaclass" bezeichnet, weil alle ihre Instanzen Metaklassen sind. Dies folgt der Benennungspraxis in SMALLTALK, bei der jede Klasse so benannt ist, dass ihre Instanzen den Satz "<eine Instanz> ist ein <Klassenname>" korrekt ergänzen.'},
     {'question': 'Wie können Zu-n-Beziehungen in SMALLTALK gepflegt werden, und welche Methoden werden standardmäßig verwendet?', 'answer': 'In SMALLTALK werden Zu-n-Beziehungen standardmäßig mit den Methoden add: und remove: gepflegt. Diese Methoden sind in der abstrakten Klasse Collection definiert, und alle Klassen, die : n-Beziehungen repräsentieren, sind indirekte Instanzen von Collection. Diese Methoden bleiben zunächst abstrakt und müssen in den entsprechenden Subklassen implementiert werden.'},
     {'question': 'Wie können mehrere Objekte auf einmal einer Beziehung in SMALLTALK hinzugefügt oder daraus entfernt werden?', 'answer': 'Um mehrere Objekte auf einmal einer Beziehung hinzuzufügen oder daraus zu entfernen, stehen die Methoden addAll: aCollection und removeAll: aCollection zur Verfügung. Beide Methoden akzeptieren eine Collection als Parameter und führen die entsprechenden Aktionen für jedes Objekt in der übergebenen Collection aus.'},
     {'question': 'Wie wird die Vererbung in SMALLTALK und vielen anderen objektorientierten Programmiersprachen tatsächlich umgesetzt?', 'answer': 'In SMALLTALK und vielen anderen objektorientierten Programmiersprachen wird die Vererbung als ein Teilen der Klassendefinitionen realisiert. Das bedeutet, dass Vereinbarungen, die in einer Klasse getroffen wurden, automatisch auch für alle Subklassen gelten, es sei denn, diese spezifizieren etwas anderes. Die Vereinbarungen werden nicht übertragen oder kopiert, sondern einfach gemeinsam genutzt. Dies ermöglicht eine effiziente Vererbung von Eigenschaften und Verhalten, ohne die Probleme mit der Identität von Objekten oder der Notwendigkeit der Aktualisierung von Subklassen bei Änderungen in der Superklasse.'},
     {'question': 'Wie kann man das Problem der Spezialisierung von Klassen elegant lösen?', 'answer': 'Das Problem der Spezialisierung von Klassen kann elegant gelöst werden, indem parallel zur spezialisierten Klasse eine Klasse "NichtSpezialisierteKlasse" eingeführt wird. Alle Eigenschaften, die andere Instanzen von derselben Generalisierung unterscheiden, können in der "NichtSpezialisierteKlasse" platziert werden. Dadurch bleibt die Hierarchie sauber und ermöglicht eine klare Unterscheidung zwischen spezialisierten und nicht spezialisierten Klassen.'},
     {'question': 'Wie kann die Methode inspect in SMALLTALK genutzt werden und wofür ist sie nützlich?', 'answer': 'Die Methode inspect startet einen Inspektor auf dem Empfängerobjekt und gibt das Empfängerobjekt zurück. Sie ist nützlich, wenn Sie ein Zwischenergebnis eines Ausdrucks inspizieren möchten, ohne den Ausdruck in zwei Teile aufteilen zu müssen. Sie fügen einfach inspect an der Stelle des Ausdrucks ein, an der das zu inspizierende Objekt gewonnen wurde.'},
     {'question': 'Wie passiert in SMALLTALK die Instanziierung?', 'answer': 'In SMALLTALK wird normalerweise die Instanziierung eines Objekts durch Senden der Nachricht "new" (für Klassen ohne indizierte Instanzvariablen) oder "new:" (für Klassen mit indizierten Instanzvariablen) an die Klasse durchgeführt. Das neue Objekt wird im Speicher angelegt, und seine Instanzvariablen werden alle mit "nil" initialisiert.'},
     {'question': 'Wie wird in SMALLTALK eine neue Klasse erstellt und eine Superklasse angegeben?', 'answer': 'In SMALLTALK wird eine neue Klasse erstellt, indem man einer Superklasse eine entsprechende Nachricht sendet. Es gibt kein spezielles Schlüsselwort wie "extends" in anderen Programmiersprachen. Stattdessen erfolgt die Klassenerstellung in einem speziellen Browser durch Senden einer Nachricht an die Superklasse.'},
     {'question': 'Wie unterscheiden sich Factory-Methoden formal von Konstruktoren in SMALLTALK?', 'answer': 'Formal unterscheiden sich Factory-Methoden in SMALLTALK nicht von Konstruktoren; sie sind ebenfalls Klassenmethoden. Der Unterschied besteht darin, dass Factory-Methoden die Klasse der Instanz basierend auf anderen Faktoren festlegen können, während Konstruktoren normalerweise Instanzen derselben Klasse erstellen.'},
     {'question': 'Wie werden Klassen in SMALLTALK erzeugt?', 'answer': 'In SMALLTALK werden Klassen erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Dies ist notwendig, da Instanzen in SMALLTALK grundsätzlich über Konstruktoren erstellt werden, und jede Klasse ist eine Instanz ihrer Metaklasse.'},
     {'question': 'Wie wird das Dilemma, welche Klasse zuerst erstellt werden muss, in SMALLTALK gelöst?', 'answer': 'In SMALLTALK wird das Dilemma gelöst, indem eine Klasse in SMALLTALK erzeugt wird, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Diese Nachricht führt zur Erzeugung einer neuen Klasse und gleichzeitig ihrer Metaklasse.'},
     {'question': 'Wie unterscheiden sich die Weltansichten von Generalisierung/Spezialisierung und Vererbung?', 'answer': 'Generalisierung/Spezialisierung repräsentieren die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze (Client-Schnittstelle). Vererbung hingegen repräsentiert die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung (Vererbungsschnittstelle). Generalisierung/Spezialisierung versuchen, Komplexität durch Strukturierung zu reduzieren, während Vererbung eine Art genetischen Zusammenhang zwischen Klassen darstellt, der deren Entstehung aus Vorhandenem widerspiegelt. Beide Sichten führen nicht automatisch zum selben Ergebnis, und die Kunst des objektorientierten Entwurfs besteht darin, sie in Einklang zu bringen.'},
     {'question': 'Wie kann die Klasse Bag in SMALLTALK mit Hilfe von Dictionaries implementiert werden?', 'answer': 'Die Klasse Bag kann in SMALLTALK mithilfe von Dictionaries implementiert werden, indem die Anzahl der Vorkommen eines Elements der Bag in einem Dictionary unter dem Element als Schlüssel gespeichert wird. Dabei nutzt die Klasse Bag die Klasse Dictionary, ohne von ihr zu erben, sondern hält sich eine Instanz von Dictionary als Sklavin, die für sie den Dienst verrichtet. Dies wird als Delegation bezeichnet und ist in prototypenbasierten objektorientierten Programmiersprachen beliebt.'},
     {'question': 'Wie unterscheidet sich Vererbung in prototypenbasierten objektorientierten Programmiersprachen von der Vererbung in klassenbasierten Systemen?', 'answer': 'In klassenbasierten objektorientierten Programmiersprachen ist die Vererbung an Klassen gebunden, während in prototypenbasierten Sprachen die Vererbung vollständig zwischen Objekten definiert ist. In prototypenbasierten Systemen gibt jedes Objekt eines oder mehrere andere an, von denen es Eigenschaften und Verhalten erbt. Es hat die Möglichkeit, geerbte Teile der Definition zu überschreiben und zu löschen.'},
     {'question': 'Wie kann in SMALLTALK verhindert werden, dass Instanzen einer abstrakten Klasse erzeugt werden?', 'answer': 'In SMALLTALK erfolgt die Erkennung, dass eine abstrakte Klasse instanziiert wurde, zur Laufzeit, wenn versucht wird, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere "new" und "new:", entsprechend überschreiben. Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von der abstrakten Klasse erben, was oft nicht akzeptabel ist.'},
     {'question': 'Wie kann man ein Intervall in Smalltalk definieren, und welche Methode wird verwendet?', 'answer': 'Ein Intervall in Smalltalk kann mithilfe der Methode to:by: definiert werden. Zum Beispiel erzeugt 5 to: 1 by: -2 ein Intervall, das die Zahlen 5, 3 und 1 enthält.'},
     {'question': 'Wie funktioniert die Verwendung eines Intervalls in einer "For"-Schleife?', 'answer': 'In einer "For"-Schleife verwendet man ein Intervall, um durch die darin enthaltenen Werte zu iterieren. Zum Beispiel bewirkt der Ausdruck 5 to: 1 by: -2 do: [:i | "Code hier"], dass dem Laufparameter "i" nacheinander die Werte 5, 3 und 1 zugewiesen werden.'},
     {'question': 'Wie wird die Unterscheidung nach den Parameterobjekten in SMALLTALK durchgeführt?', 'answer': 'In SMALLTALK kann die Unterscheidung nach den Parameterobjekten mithilfe einer Technik namens "Double Dispatch" durchgeführt werden. Bei dieser Technik wird im Rumpf einer Methode dieselbe Methode noch einmal aufgerufen, wobei Empfänger (self) und Parameter vertauscht werden. Die Klasse des Empfängers wird im Nachrichtenselektor der neu aufgerufenen Methode kodiert. Dadurch erfolgt die dynamische Bindung zweimal hintereinander, einmal für den Empfänger und einmal für den Parameter, um die richtige Methode basierend auf beiden Objekten auszuwählen.'}],
    [{'question': 'Was können Programmierer tun, um automatisch Zugriffsmethoden für Instanzvariablen in SMALLTALK zu generieren?', 'answer': 'Programmierer können in SMALLTALK an der entsprechenden Stelle (z. B. in der Klasse "Class" oder "Behavior", die auf der Ebene der Metaklassen steht und für das Erstellen neuer Klassen verantwortlich ist) eine neue Methode zur Klassendefinition hinzufügen, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden (Accessoren) für ausgewählte Instanzvariablen erweitert. Dies ermöglicht es, Zugriffsmethoden für Instanzvariablen automatisch zu generieren.'},
     {'question': 'Was sollten Sie beachten, wenn Sie die Attributwerte von Objekten in einer SortedCollection ändern?', 'answer': 'Wenn Sie die Attributwerte von Objekten in einer SortedCollection nachträglich ändern, führt dies nicht automatisch zu einer Änderung der Reihenfolge der Elemente in der SortedCollection. Dies gilt selbst dann, wenn eine Änderung der Reihenfolge erforderlich wäre. Sie müssen sicherstellen, dass die Sortierung erneut durchgeführt wird, um die korrekte Reihenfolge beizubehalten.'},
     {'question': 'Was unterscheidet "shallowCopy" und "deepCopy"?', 'answer': '"shallowCopy" erstellt eine flache Kopie eines Objekts, bei der die in Beziehung stehenden Objekte nicht kopiert werden, während "deepCopy" eine tiefe Kopie erstellt, bei der auch die in Beziehung stehenden Objekte kopiert werden.'},
     {'question': 'Warum ist die Festlegung, ob Kopien tiefe oder flache Kopien sein sollen, gelegentlich ein Charakteristikum der Klasse selbst?', 'answer': 'Die Festlegung, ob Kopien tiefe oder flache Kopien sein sollen, ist gelegentlich ein Charakteristikum der Klasse selbst, da jede Klasse die Methode "copy" von "Object" erbt und diese Methode standardmäßig "shallowCopy" aufruft. Die erbende Klasse kann "copy" entsprechend ihren eigenen Konditionen überschreiben und somit die Kopiertiefe von Objektstrukturen selbst bestimmen.'},
     {'question': 'Was gibt die Methode "species" standardmäßig zurück, und wie kann sie überschrieben werden?', 'answer': 'Die Methode "species" gibt standardmäßig die Klasse des Empfängerobjekts zurück. Sie kann überschrieben werden, wenn eine andere Klasse angegeben werden soll. Dies ist nützlich, wenn bei Kopier- oder Konvertieroperationen ein Objekt eines anderen Typs als das ursprüngliche zurückgegeben werden soll.'},
     {'question': 'Warum heißt die Klasse "Class" und die Klasse "Metaclass" in SMALLTALK so?', 'answer': 'Die Klasse "Class" heißt so, weil jede Instanz dieser Klasse eine Klasse ist. Die Klasse "Metaclass" heißt so, weil sie die Metaklassen repräsentiert, die Klassen sind, die die Klassen selbst definieren. Diese Namensgebung spiegelt die Art der Objekte wider, die von diesen Klassen repräsentiert werden.'},
     {'question': 'Warum hat sich die klassenbasierte Form der objektorientierten Programmierung gegenüber der prototypenbasierten Form durchgesetzt?', 'answer': 'Die klassenbasierte Form der objektorientierten Programmierung hat sich vermutlich aus verschiedenen Gründen durchgesetzt. Zum einen bieten Klassen ein etabliertes Ordnungskonzept, das in anderen Disziplinen wie Mathematik und Biologie verwendet wird, und das sich gut zur Strukturierung von objektorientierten Programmen eignet. Zum anderen eignen sich Klassen als Vorlagen für Typen, was die Integration von objektorientierter Programmierung in typisierte Sprachen ermöglicht. Die prototypenbasierte Form der Objektorientierung bietet hingegen Flexibilität bei der Anpassung von einzelnen Objekten an ihren Zweck und ist besonders nützlich in interaktiven Anwendungen.'},
     {'question': 'Gibt es gute Gründe, die prototypenbasierte Form der objektorientierten Programmierung zu nutzen?', 'answer': 'Ja, es gibt gute Gründe, die prototypenbasierte Form der objektorientierten Programmierung zu nutzen. Sie erlaubt eine hohe Flexibilität bei der Anpassung von Objekten an ihren jeweiligen Zweck, insbesondere in interaktiven Anwendungen. Ein Beispiel dafür ist die Programmierung von grafischen Benutzeroberflächen, bei der verschiedene Buttons verschiedene Ereignisse auslösen können. JavaScript ist eine erfolgreiche Programmiersprache für interaktive Webseiten und basiert auf dem Prototypenansatz.'},
     {'question': 'Was bewirken die Methoden "basicNew" und "basicNew:" in den Konstruktoren?', 'answer': 'Die Methoden "basicNew" und "basicNew:" sind Instanzmethoden der Klasse, die eine neue Instanz (ein neues Objekt) der Klasse erstellen und zurückgeben. Sie weisen allen Instanzvariablen der erzeugten Objekte den Wert "nil" zu. Bevor die Objekte zurückgegeben werden, wird die Methode "initialize" auf ihnen aufgerufen, um die Instanzvariablen je nach Klasse anders zu belegen.'},
     {'question': 'Warum hat die Ein- und Ausgabe über Streams in SMALLTALK eine besondere Bedeutung?', 'answer': 'In SMALLTALK wurde die Ein- und Ausgabe über Streams anders konzipiert als in konventionellen textbasierten Programmen. SMALLTALK ist ein fensterbasiertes, grafisches System, das eine Alternative zur zeilenorientierten Ein- und Ausgabe bieten wollte. Zudem sind in SMALLTALK permanente Datenspeicherung in Dateien nicht notwendig, da alle Objekte im Image dauerhaft gespeichert werden. Daher haben Streams in SMALLTALK eine andere Aufgabe, nämlich den sequentiellen Zugriff auf einzelne Elemente in Collections und den gleichzeitigen Zugriff durch mehrere Objekte auf Collections zu ermöglichen.'},
     {'question': 'Warum benötigen Klassen in SMALLTALK ihre eigenen Metaklassen?', 'answer': 'Klassen in SMALLTALK benötigen ihre eigenen Metaklassen, damit sie ihre eigenen Instanzvariablen und Methoden definieren können, ohne die Definitionen anderer Klassen zu beeinflussen. Dies ermöglicht eine hohe Flexibilität und erlaubt es den Programmierern, das Verhalten von Klassen individuell anzupassen.'},
     {'question': 'Warum gibt es eine 1-zu-1-Beziehung zwischen Klassen und ihren Metaklassen in SMALLTALK?', 'answer': 'Die 1-zu-1-Beziehung zwischen Klassen und ihren Metaklassen in SMALLTALK gewährleistet, dass jede Klasse ihre eigenen Instanzvariablen und Methoden definieren kann, ohne andere Klassen zu beeinflussen. Dadurch wird die Flexibilität und Unabhängigkeit der Klassen in SMALLTALK gewährleistet.'},
     {'question': 'Warum erhalten Programmierer in SMALLTALK erst zur Laufzeit des Programms eine Fehlermeldung, wenn sie eine Nachricht an eine Instanz einer abstrakten Klasse senden?', 'answer': 'In SMALLTALK und ähnlichen objektorientierten Programmiersprachen erhalten Programmierer zur Laufzeit des Programms eine Fehlermeldung, wenn sie eine Nachricht an eine Instanz einer abstrakten Klasse senden, da diese abstrakten Klassen unvollständig sind und daher nicht implementierte Methoden enthalten können. Die Fehlermeldung, die durch die Methode "doesNotUnderstand:" (in der Klasse "Object") ausgelöst wird, informiert die Programmierer darüber, dass die Methode in einer Subklasse implementiert werden sollte. Dieser Ansatz entspricht dem interaktiven Geist des SMALLTALK-Systems, bei dem das Programmieren als iteratives Zurechtbiegen und Erweitern eines bereits funktionierenden Systems betrachtet wird.'},
     {'question': 'Was ermöglicht die Sprachregelung in der objektorientierten Programmierung bezüglich der Klassennamen?', 'answer': 'Die Sprachregelung in der objektorientierten Programmierung besagt, dass alle Klassennamen im Singular sind. Dies bedeutet, dass jeder Klassenname einen Singularausdruck verwendet, um die Klasse zu benennen, selbst wenn die Klasse eine Menge von Objekten repräsentiert.'},
     {'question': 'Was unterscheidet Klassifikation und Generalisierung?', 'answer': 'In der objektorientierten Programmierung entspricht die Klassifikation der "Ist-ein-Abstraktionsbeziehung" zwischen Individuen und ihren Klassen, während die Generalisierung eine Form der Abstraktion ist, bei der Allgemeinbegriffe miteinander in Beziehung gesetzt werden. Klassifikation bezieht sich auf die Zuordnung eines Individuums zu einer Klasse, während Generalisierung die Beziehung zwischen verschiedenen Klassen beschreibt, bei der eine Klasse eine Verallgemeinerung (Generalisierung) einer anderen ist.'},
     {'question': 'Ist die Generalisierung in der objektorientierten Programmierung transitiv?', 'answer': 'Ja, die Generalisierung ist in der objektorientierten Programmierung transitiv. Wenn eine Klasse A eine Generalisierung einer Klasse B ist und Klasse B wiederum eine Generalisierung einer Klasse C ist, ergibt sich logischerweise, dass Klasse A eine Generalisierung von Klasse C ist.'},
     {'question': 'Warum ist es möglich, in SMALLTALK mehrere alternative Konstruktoren (Klassenmethoden) für eine Klasse zu definieren?', 'answer': 'Es ist möglich, mehrere alternative Konstruktoren für eine Klasse in SMALLTALK zu definieren, da nicht immer alle Instanzen einer Klasse auf die gleiche Weise initialisiert werden müssen. Dies ermöglicht es, verschiedene Initialisierungsmethoden für verschiedene Anwendungsfälle anzubieten.'},
     {'question': 'Warum wird in SMALLTALK die Methode "initialize" standardmäßig von den Konstruktoren "new" und "new:" aufgerufen?', 'answer': 'In SMALLTALK wird die Methode "initialize" standardmäßig von den Konstruktoren "new" und "new:" aufgerufen, um die Initialisierung der Instanzvariablen vorzunehmen. Dies erlaubt es, alle Initialisierungen in einer zentralen Methode durchzuführen, ohne dass etwas über den Aufbau der Instanzen nach außen verraten wird.'},
     {'question': 'Warum ist eine Eins-zu-viele-Kommunikation im MVC-Pattern erforderlich?', 'answer': 'Im MVC-Pattern gibt es verschiedene Ansichten auf ein logisches Modell. Wenn Änderungen im Modell potenziell alle Ansichten betreffen, müssen diese Änderungen alle Ansichten darüber informieren. Daher ist eine Eins-zu-viele-Kommunikation erforderlich, um sicherzustellen, dass alle betroffenen Ansichten aktualisiert werden.'},
     {'question': 'Warum wurden die Begriffe "Superklasse" und "Subklasse" in früheren Abschnitten nicht erwähnt?', 'answer': 'Die Begriffe "Superklasse" und "Subklasse" wurden in früheren Abschnitten nicht erwähnt, da sie in verschiedenen Programmiersprachen unterschiedliche Bedeutungen haben können, während die Begriffe "Generalisierung", "Spezialisierung", "Vererbung" und "abstrakte Klassen" eher einheitlich interpretiert werden. Diese Begriffe können je nach Programmiersprache und Kontext unterschiedliche Konzepte darstellen, daher wurden sie in diesem Kurs erst später spezifiziert.'},
     {'question': 'Was bedeutet es, dass die Subklassenbeziehung transitiv ist?', 'answer': 'Die Transitivität der Subklassenbeziehung bedeutet, dass, wenn Klasse A eine Subklasse von Klasse B ist und Klasse B eine Subklasse von Klasse C ist, dann ist Klasse A auch eine Subklasse von Klasse C. Dies bedeutet, dass die Vererbung von Eigenschaften und Verhalten in der Klassenhierarchie entlang der Subklassenbeziehung in einer kaskadierenden Weise erfolgt.'},
     {'question': 'Was unterscheidet ein direkte Subklasse und ein indirekte Subklasse?', 'answer': 'Eine direkte Subklasse ist eine Klasse, die direkt von einer anderen Klasse erbt, ohne dass eine weitere Klasse dazwischen liegt. Eine indirekte Subklasse ist eine Klasse, die von einer Superklasse erbt, die selbst von einer anderen Klasse erbt. Mit anderen Worten, eine indirekte Subklasse ist eine Subklasse, die von einer Superklasse erbt, die ebenfalls eine Subklasse ist.'},
     {'question': 'Warum haben abstrakte Klassen und Vererbung die Entwicklung objektorientierter Programmiersprachen geprägt?', 'answer': 'Abstrakte Klassen und Vererbung haben die Entwicklung objektorientierter Programmiersprachen geprägt, weil sie pragmatische Werkzeuge sind, die die Wiederverwendung von Code und die Strukturierung von Software erleichtern. Sie ermöglichen es, gemeinsame Eigenschaften und Methoden in einer Oberklasse zu definieren und von dieser Oberklasse abgeleitete Unterklassen zu erstellen, die diese Eigenschaften und Methoden erben und bei Bedarf überschreiben können.'},
     {'question': 'Warum sind Generalisierung und Spezialisierung in der objektorientierten Programmierung dennoch relevant?', 'answer': 'Obwohl Generalisierung und Spezialisierung eher theoretisch motivierte Konzepte sind, sind sie dennoch relevant, da sie dazu beitragen, die Struktur und Hierarchie von Klassen in objektorientierten Programmen zu definieren. Sie ermöglichen es, Klassen in Beziehung zueinander zu setzen und abstrakte Modelle für die Softwareentwicklung zu entwickeln. Diese Konzepte können in komplexen Softwareprojekten zur Verbesserung der Wartbarkeit und Erweiterbarkeit beitragen.'},
     {'question': 'In welcher Situation ist es sinnvoll, die Methode super in SMALLTALK zu verwenden?', 'answer': 'Die Methode super in SMALLTALK wird verwendet, wenn eine überschreibende Methode die überschriebene Methode nicht vollständig ersetzen, sondern nur modifizieren möchte. Dies kann beispielsweise bei Konstruktoren, wie den Klassenmethoden new und new:, der Fall sein, bei denen das grundlegende Verhalten beibehalten werden muss. super ermöglicht es, die überschriebene Methode aufzurufen und sie um zusätzliche Ausdrücke zu ergänzen.'},
     {'question': 'Warum muss in SMALLTALK das Empfängerobjekt einer Nachricht immer explizit angegeben werden?', 'answer': 'In SMALLTALK muss das Empfängerobjekt einer Nachricht immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. Dies unterscheidet sich von einigen anderen Programmiersprachen wie JAVA, in denen das Empfängerobjekt manchmal implizit ist. Die Verwendung von self ist notwendig, um das Objekt zu identifizieren, auf dem die Methode ausgeführt wird, und auf dessen Instanzvariablen zugegriffen werden kann.'},
     {'question': 'Was bezeichnet die Pseudovariable self in SMALLTALK?', 'answer': 'Die Pseudovariable self bezeichnet immer den Empfänger der Nachricht, also dasjenige Objekt, auf dem die Methode, in deren Definition die Variable self vorkommt, gerade ausgeführt wird. Sie ermöglicht den Zugriff auf die Instanzvariablen dieses Objekts.'},
     {'question': 'Was versteht man unter dynamischem Binden von Methodenaufrufen in SMALLTALK?', 'answer': 'Beim dynamischen Binden von Methodenaufrufen in SMALLTALK hängt die Auswahl der auszuführenden Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt ab. Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zuerst überprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Wenn die Methode gefunden wird, wird sie ausgeführt. Andernfalls wird in der direkten Superklasse der Klasse des Objekts gesucht, und so weiter, bis die Methode gefunden wird oder ein Laufzeitfehler auftritt.'},
     {'question': 'Warum bleibt das Empfängerobjekt bei der Ausführung einer Methode aus einer Superklasse dasselbe?', 'answer': 'Obwohl bei der Ausführung einer Methode aus einer Superklasse die Methode in einer Superklasse kompiliert wurde, bleibt das Objekt, auf dem sie ausgeführt wird, dasselbe Empfängerobjekt. Dies bedeutet, dass das Objekt immer noch Instanz seiner ursprünglichen Klasse ist. Die Methode betrachtet es jedoch wie ein Objekt der Klasse, in der sie selbst definiert ist. Dies ermöglicht den Zugriff auf die Instanzvariablen, die für die Objekte dieser Klasse zugreifbar sind.'},
     {'question': 'Was unterscheidet dynamische und statische Typisierung in Bezug auf das dynamische Binden?', 'answer': 'In der dynamischen Bindung, wie sie in SMALLTALK verwendet wird, erfolgt die Auswahl der Methode zur Laufzeit und hängt von der Art des Empfängerobjekts ab. In der statischen Typisierung, wie sie in statisch typgeprüften Sprachen wie JAVA, C-Sharp und C++ verwendet wird, erfolgt die Typüberprüfung zur Übersetzungszeit und nicht zur Laufzeit. Statisch typisierte Sprachen erfordern in der Regel, dass der Programmierer den Datentyp der Objekte und deren Methoden im Voraus festlegt, während dynamisch typisierte Sprachen mehr Flexibilität bieten, da die Typüberprüfung erst zur Laufzeit erfolgt. Allerdings erhöht die dynamische Bindung das Risiko von Laufzeitfehlern, die in statisch typisierten Sprachen vermieden werden können, indem explizite Typüberprüfungen durchgeführt werden.'},
     {'question': 'Warum ist es nicht notwendig, dass jede Metaklasse in SMALLTALK ihre eigene Meta-Metaklasse hat?', 'answer': 'Es ist nicht notwendig, dass jede Metaklasse in SMALLTALK ihre eigene Meta-Metaklasse hat, da es in der Praxis ausreicht, eine gemeinsame Meta-Metaklasse vorzusehen, von der alle Metaklassen Instanzen sind.'},
     {'question': 'Was repräsentieren die Klassen der Ebene 1 und was repräsentieren die Metaklassen der Ebene 2?', 'answer': 'Die Klassen der Ebene 1 repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit und stellen die Konzepte und Allgemeinbegriffe des Anwendungsbereichs dar. Die Metaklassen der Ebene 2 definieren die Klassen auf Ebene 1, wobei jede Metaklasse genau eine Instanz auf Ebene 1 hat.'},
     {'question': 'Warum werden Arrays in SMALLTALK häufig verwendet?', 'answer': 'Arrays werden in SMALLTALK häufig verwendet, insbesondere aufgrund ihrer einfachen literalen Definitionsmöglichkeiten. Sie ermöglichen es, über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung zu iterieren, ohne viel Aufwand betreiben zu müssen.'},
     {'question': 'Warum ist die Hierarchie in SMALLTALK beschränkt?', 'answer': 'Die Hierarchie in SMALLTALK ist aus praktischen Überlegungen beschränkt und ist in der Sprachdefinition festgelegt. Dies bedeutet, dass die Hierarchie nicht unbegrenzt erweitert oder verändert werden kann, sondern einen festen Rahmen hat.'},
     {'question': 'Warum ist die Spezialisierung in der objektorientierten Programmierung wichtig?', 'answer': 'Spezialisierung ermöglicht es, bestehende Klassen um spezifische Eigenschaften oder Verhaltensweisen zu erweitern, ohne andere Teile des Programms zu beeinflussen. Dies fördert die Modularität und die Möglichkeit zur Erweiterung von Klassen, was eine der Stärken der objektorientierten Programmierung ist.'},
     {'question': 'Gibt es Einschränkungen bei der Spezialisierung von Klassen?', 'answer': 'Ja, es gibt Einschränkungen bei der Spezialisierung von Klassen. Das Entfernen von Instanzvariablen oder Methoden ist vollkommen unvereinbar mit der Spezialisierung, da dies die Umkehrung der Spezialisierung, die Generalisierung, verhindern würde. Es ist jedoch möglich, Eigenschaften durch Beschränkungen zu ändern oder hinzuzufügen, aber das Entfernen ist nicht erlaubt.'},
     {'question': 'Was bedeutet die Subklassenbeziehung in SMALLTALK?', 'answer': 'In SMALLTALK wird die Subklassenbeziehung mit der Vererbungsbeziehung gleichgesetzt. Das bedeutet, dass eine Subklasse alle Instanzvariablen und Methoden ihrer Superklasse erbt. Es ist jedoch wichtig zu beachten, dass die Subklassenbeziehung allein nicht ausdrückt, dass die Subklasse eine Spezialisierung der Superklasse ist oder umgekehrt. Diese Beziehung muss vom Programmierer explizit definiert und dokumentiert werden.'},
     {'question': 'Warum gibt es in SMALLTALK mindestens eine Klasse, die keine Subklasse ist?', 'answer': 'In SMALLTALK ist die Subklassenbeziehung nicht reflexiv, was bedeutet, dass jede Klasse mindestens eine Superklasse haben muss. Diese oberste Superklasse ist die Klasse "Object". In "Object" sind Definitionen enthalten, die den Instanzen aller Klassen zugutekommen sollen, und diese Methoden werden per Vererbung auf alle anderen Klassen übertragen.'},
     {'question': 'Warum kann die Vererbung allein nicht als Indikator für Generalisierung und Spezialisierung dienen?', 'answer': 'Die Vererbung allein kann nicht als Indikator für Generalisierung und Spezialisierung dienen, da sie keinen kausalen Zusammenhang zwischen Klassen herstellt. Nur weil eine Klasse Eigenschaften von einer anderen geerbt hat, bedeutet das nicht zwangsläufig, dass die erbende Klasse eine Spezialisierung der vererbenden ist. Ein klassisches Beispiel dafür wurde bereits mit der Ableitung der Klasse "Rechteck" von der Klasse "Quadrat" gegeben. Es ist wichtig zu erkennen, dass die Vererbung nicht immer eindeutig auf eine Generalisierung/Spezialisierung hinweist und vorsichtige Analyse und Planung erfordert. In einigen Fällen kann eine zu starke Vererbung sogar zu unerwünschten Ergebnissen führen.'},
     {'question': 'Warum kann man nicht einfach "new" an die Metaklasse einer Klasse senden, um eine neue Klasse zu erstellen?', 'answer': 'Man kann nicht einfach "new" oder ähnliches an die Metaklasse einer Klasse senden, da die Metaklasse zu diesem Zeitpunkt noch nicht existiert. Dies führt zu einem Dilemma, da die Frage aufkommt, ob die Klasse zuerst oder die Metaklasse zuerst erstellt werden muss.'},
     {'question': 'Was versteht man in der objektorientierten Programmierung unter Vererbung, und welchen Zweck erfüllt sie?', 'answer': 'In der objektorientierten Programmierung bezieht sich Vererbung auf die Übertragung der Definition von Eigenschaften und Verhalten von einer Klasse auf eine andere. Der Zweck der Vererbung besteht vor allem darin, Code wiederzuverwenden und die Ökonomie in der Softwareentwicklung zu verbessern.'},
     {'question': 'Warum sind Dictionaries in SMALLTALK nützlich, und wann sollte man sie verwenden?', 'answer': 'Dictionaries sind in SMALLTALK nützlich, da sie das schnelle Auffinden von Werten unter Schlüsseln ermöglichen. Sie sollten verwendet werden, wenn Sie auf die Elemente einer Menge von Objekten über Schlüssel zugreifen möchten. Dictionaries erlauben es, Assoziationsketten direkt in einem Programm nachzubilden und sind besonders geeignet, wenn die Zuordnung von Schlüsseln zu Werten benötigt wird.'},
     {'question': 'Warum könnte die prototypenbasierte Vererbung auf den ersten Blick als natürlicher angesehen werden?', 'answer': 'Auf den ersten Blick könnte die prototypenbasierte Vererbung als natürlicher angesehen werden, da sie dem Prinzip der biologischen Vererbung ähnelt, bei dem Merkmale von Individuum zu Individuum weitergegeben werden. In der Natur gibt es keine festen biologischen Klassen wie in klassenbasierten Systemen, und Arten können sich ständig verändern und anpassen.'},
     {'question': 'Warum wird die Vererbung oft auf Klassen in der objektorientierten Programmierung übertragen, obwohl sie in prototypenbasierten Sprachen zwischen Objekten definiert ist?', 'answer': 'Programmierer entwerfen normalerweise Klassen, nicht einzelne Objekte. Klassen sind die grundlegende Entität in der klassenbasierten objektorientierten Programmierung, und Klassendefinitionen ändern sich im Laufe der Zeit. Klassen bieten auch eine bessere Abdeckung für Anwendungsdomänen, die aus vielen gleichen Objekten bestehen. Daher wird die Vererbung oft auf Klassen übertragen, da sie besser zur strukturierten Programmierung passt und das Verfolgen und Debuggen von Programmen erleichtert.'},
     {'question': 'Warum könnte die Vererbung zwischen Instanzen in der objektorientierten Programmierung das Verfolgen und Debuggen von Programmen erschweren?', 'answer': 'Die Vererbung zwischen Instanzen kann das Verfolgen und Debuggen von Programmen erschweren, da sie die Beziehungen zwischen Objekten komplexer gestaltet. Wenn Objekte Eigenschaften und Verhalten von anderen Objekten erben können und diese Eigenschaften überschreiben oder löschen können, kann dies zu unvorhersehbarem Verhalten führen und die Fehlersuche erschweren.'},
     {'question': 'Was unterscheidet Extension und Intension?', 'answer': 'Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören. Die Intension ist die Summe der Merkmale oder Eigenschaften, die den Begriff ausmachen und die Objekte charakterisieren, die zu dieser Klasse gehören. Mit steigender Intension wird die Extension kleiner, und umgekehrt.'},
     {'question': 'Was machen Allgemeinbegriffe und Klassen in der objektorientierten Programmierung?', 'answer': 'Allgemeinbegriffe oder Klassen vereinfachen die Strukturierung von Objekten und die Beschreibung von Eigenschaften und Verhalten in der objektorientierten Programmierung.'},
     {'question': 'Warum sind abstrakte Klassen in der objektorientierten Programmierung nicht instanziierbar?', 'answer': 'Abstrakte Klassen sind in der Regel nicht instanziierbar, weil ihnen oft die notwendigen Informationen fehlen, um Instanzen vollständig zu initialisieren. Sie dienen als Vorlagen für Subklassen, die die fehlenden Details ergänzen.'},
     {'question': 'Warum könnte das Weglassen einer Methode wie "add:" in einer abstrakten Klasse in SMALLTALK weniger aufschlussreich für Programmierer sein?', 'answer': 'Das Weglassen einer Methode wie "add:" in einer abstrakten Klasse in SMALLTALK könnte weniger aufschlussreich sein, da die Fehlermeldung, die bei einem Aufruf dieser Methode auftritt, nicht zwischen einem falschen Methodennamen und dem Vergessen der Implementierung in einer Subklasse unterscheiden könnte. Das Bereitstellen einer Methode wie "add:" in der abstrakten Klasse, die auf ein Versäumnis hinweist, ist sinnvoll, um Programmierer auf das Problem aufmerksam zu machen.'},
     {'question': 'Wozu dienen Intervalle hauptsächlich in Smalltalk?', 'answer': 'Intervalle in Smalltalk dienen hauptsächlich dem Zweck, sogenannte "For"-Schleifen zu emulieren, wie sie im Abschnitt 4.6.3 in Kurseinheit 1 beschrieben sind.'},
     {'question': 'Gibt es eine Methode in der Klasse "Number," die die Verwendung von Intervallen noch komfortabler macht?', 'answer': 'Ja, in der Klasse "Number" gibt es die Methode "to:by:", die ein entsprechendes Intervall zurückliefert. Dadurch kann man eine "For"-Schleife in einer kompakteren Form schreiben, z. B. 5 to: 1 by: -2.'},
     {'question': 'Wo ist der Iterator für Intervalle definiert?', 'answer': 'Der Iterator für Intervalle ist in der Klasse "Number" definiert und nicht in einer Collection-Klasse wie "Interval."'},
     {'question': 'In welcher Klasse ist das Protokoll definiert, das allen Objekten gemeinsam ist, und warum ist es wichtig?', 'answer': 'Das Protokoll, das allen Objekten gemeinsam ist, ist in der Klasse "Object" definiert. Es ist wichtig, weil es Methodendefinitionen enthält, die von allen Klassen entweder geerbt oder in den meisten Fällen direkt übernommen werden können. Diese Methoden sind grundlegende Funktionen, die für alle Objekte verfügbar sind und von den meisten Objekten nicht überschrieben werden müssen.'},
     {'question': 'Warum ist es manchmal notwendig, auch die tatsächlichen Parameter bei der Methodenauswahl zu berücksichtigen?', 'answer': 'In bestimmten Situationen hängt die Auswahl einer geeigneten Methode nicht nur vom Empfängerobjekt ab, sondern auch von den tatsächlichen Parametern, die an die Methode übergeben werden. Dies ist beispielsweise bei arithmetischen Operationen wie Addition, Subtraktion, Multiplikation und Division der Fall, bei denen die Implementierung der Operation von der Art der Operanden abhängt (z. B. Ganzzahlen oder Gleitkommazahlen). Es ist notwendig, die Unterscheidung nach den Parameterobjekten vorzunehmen, um die richtige Methode auszuwählen.'},
     {'question': 'Wer hat die Technik des "Double Dispatch" erstmals beschrieben und in welchen Programmiersprachen wird sie verwendet?', 'answer': 'Die Technik des "Double Dispatch" wurde von Dan Ingalls am Beispiel von SMALLTALK erstmals beschrieben. Diese Technik wird auch in anderen Programmiersprachen mit "Single Dispatch" (wie JAVA und C-Sharp) verbreitet angewendet. Es ist jedoch zu beachten, dass in Sprachen, in denen die Parametertypen von Haus aus bei der (dynamischen) Methodenauswahl berücksichtigt werden (sog. "Multi Dispatch"-Sprachen), Double Dispatch nicht benötigt wird.'},
     {'question': 'Warum könnte die Einführung von indizierten Instanzvariablen den Anschein erwecken, dass sie speziell für Zu-n-Beziehungen eingeführt wurden?', 'answer': 'Indizierten Instanzvariablen könnten den Anschein erwecken, speziell für Zu-n-Beziehungen eingeführt worden zu sein, da sie es ermöglichen, Elemente in Beziehung zu setzen, selbst wenn sie nur indirekt über Zwischenobjekte erreicht werden. Dies erleichtert die Arbeit mit Zu-n-Beziehungen.'},
     {'question': 'Warum ist es besonders attraktiv, eigene Kontrollstrukturen für Zu-n-Beziehungen in SMALLTALK zu spezifizieren?', 'answer': 'Es ist besonders attraktiv, eigene Kontrollstrukturen für Zu-n-Beziehungen in SMALLTALK zu spezifizieren, weil es die Möglichkeit bietet, maßgeschneiderte und auf die spezifische Art der Beziehung zugeschnittene Kontrollstrukturen zu erstellen. Dies ermöglicht eine flexible und effiziente Programmierung für unterschiedliche Arten von Beziehungen.'},
     {'question': 'Was ermöglicht die Verwendung eigener Arten von Beziehungen in SMALLTALK?', 'answer': 'Die Verwendung eigener Arten von Beziehungen in SMALLTALK ermöglicht es, spezielle, nur für diese Beziehungen benötigte Kontrollstrukturen zu spezifizieren, um die Programmierung für diese Beziehungen effizienter zu gestalten.'}],
]
KE3_questions = [
    [{'question': 'Welches Problem möchte man mit dem beschränkten parametrischen Polymorphismus lösen?', 'answer': 'Mit dem beschränkten parametrischen Polymorphismus möchte man sicherstellen, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist und nur bestimmte, benötigte Protokolle für die als Werte zulässigen Typen erlaubt.'},
     {'question': 'Welche Möglichkeit zur Beschränkung des Wertebereichs von Typvariablen wird in der Praxis nicht genutzt?', 'answer': 'Die Einführung von Metatypen, deren Wertebereiche Typen mit von den Metatypen vorgegebenen Eigenschaften sind, wird in der Praxis nicht genutzt.'},
     {'question': 'Welche Implikation hat die Definition von Subtypen in Bezug auf die Zuweisungskompatibilität?', 'answer': 'Die Definition von Subtypen impliziert Zuweisungskompatibilität. Wenn die Objekte eines Subtyps überall dort verwendet werden können, wo Objekte seines Supertyps erwartet werden, dann können sie auch Werte für Variablen des Supertyps sein. Dies bedeutet, dass ein Subtyp per Definition zuweisungskompatibel mit seinem Supertyp ist.'},
     {'question': 'Was ist Typeinschränkung, und wie unterscheidet sie sich von Typerweiterung?', 'answer': 'Typeinschränkung ist eine Möglichkeit, auf der Basis eines bereits bestehenden Typs einen neuen, verwandten Typen zu erzeugen. Sie besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere Typen zu ersetzen. Im Gegensatz dazu erweitert Typerweiterung den vorhandenen Typ um zusätzliche Eigenschaften oder Methoden. Typeinschränkung ist also die Umkehrung der Typerweiterung in Bezug auf die Typdefinition.'},
     {'question': 'Welche Formen der Typeinschränkung gibt es?', 'answer': 'Eine Form der Typeinschränkung besteht darin, einen Typ auf Basis eines anderen Typs zu definieren, indem man Eigenschaften (Methoden) entfernt. Diese Form führt jedoch nicht zur Zuweisungskompatibilität und wird in vielen Sprachen nicht unterstützt. Eine interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere Typen zu ersetzen, ohne Eigenschaften zu löschen.'},
     {'question': 'Welchen Zweck dienen Collections in der Programmierung?', 'answer': 'Collections dienen u. a. dem Zweck, n-Beziehungen zwischen einem Objekt und mehreren anderen zu ermöglichen, indem sie dafür Zwischenobjekte zur Verfügung stellen.'},
     {'question': 'Welchen Typ repräsentieren die mit Collection-Klassen assoziierten Typen?', 'answer': 'Die mit Collection-Klassen assoziierten Typen repräsentieren die Typen für die Zwischenobjekte in den Collections.'},
     {'question': 'Was ist ein Beispiel für eine parametrische Definition einer Collection?', 'answer': 'Ein Beispiel für eine parametrische Definition einer Collection ist Dictionary, bei dem nicht nur der Elementtyp, sondern auch der Schlüsseltyp variabel gehalten werden sollte.'},
     {'question': 'Was ist die inhaltliche Funktion, die Typen neben ihrer formalen Rolle erfüllen können, und wie wird sie in der Programmierung hergestellt?', 'answer': 'Typen können in der Programmierung neben ihrer formalen Rolle, Fehler zu vermeiden, auch eine inhaltliche Funktion erfüllen. Diese inhaltliche Funktion wird vor allem durch die Benennung des Typs hergestellt, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität. Sie verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können.'},
     {'question': 'Welche Bedeutung hat die Filterfunktion, die durch die Namensäquivalenz verlangt wird?', 'answer': 'Die Filterfunktion, die durch die Namensäquivalenz verlangt wird, drückt die Absicht der Programmiererin aus, Werte nur gleicher Bedeutung zuzuweisen. Sie ermöglicht es, Fehler in einem Programm auf einfache Weise zu erkennen und zu vermeiden.'},
     {'question': 'Welches Prinzip in der Physik ähnelt der Typprüfung per Namensäquivalenz, und wie wird es angewendet?', 'answer': 'Ein ähnliches Prinzip wie die Typprüfung per Namensäquivalenz wird in der Physik angewendet. Bei physikalischen Berechnungen prüfen Physikerinnen nicht nur die Beträge der physikalischen Größen, sondern auch deren Einheiten. Wenn die Einheiten nicht korrekt behandelt werden und das Ergebnis etwas anderes als erwartet ergibt, liegt ein Fehler im Rechenvorgang vor.'},
     {'question': 'Welchen Nachteil hat die Namensäquivalenz in Bezug auf die Interoperabilität von getrennt voneinander entwickelten Programmen?', 'answer': 'Die Namensäquivalenz setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen dieselben Typen verwenden. Dies kann ein Hindernis für die Interoperabilität von solchen Programmen, wie zum Beispiel Web Services, darstellen.'},
     {'question': 'Was sind die Unterschiede zwischen struktureller Typäquivalenz und Namensäquivalenz in Bezug auf Flexibilität und Semantik?', 'answer': 'Strukturelle Typäquivalenz bietet mehr Flexibilität als Namensäquivalenz, da sie die Äquivalenz von Typen erlaubt, deren Definition voneinander unabhängig ist. Allerdings können zufällige strukturelle Übereinstimmungen zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Um diesen Nachteil zu vermeiden, kann optional eine Namensäquivalenz durch Type branding eingeführt werden.'},
     {'question': 'Welche Rolle spielen Zugriffsmodifikatoren in Programmiersprachen wie JAVA und C++ bei der Festlegung der Schnittstelle einer Klasse?', 'answer': 'Zugriffsmodifikatoren legen fest, welche Elemente einer Klassendefinition für Benutzer sichtbar sind und somit die Schnittstelle der Klasse beeinflussen. Sie regeln die Zugriffsberechtigungen auf Methoden und Instanzvariablen.'},
     {'question': 'Welche Konsequenz ergibt sich daraus für die Beziehung von Subklassen und Subtypen?', 'answer': 'Die Konsequenz daraus ist, dass die Beziehung von Subklassen und Subtypen in den meisten objektorientierten Programmiersprachen auf eine parallele Subtypenbeziehung übertragen werden kann. Das bedeutet, dass eine Instanz einer Subklasse auch als Instanz des zur Superklasse gehörenden Typs betrachtet werden kann, sofern die Subklassenbeziehung die Typkonformität nicht aufhebt.'},
     {'question': 'Welches Problem wird in diesem Abschnitt "Grenzen der Typisierung" angesprochen?', 'answer': 'In diesem Abschnitt wird das Problem der praktischen Grenzen der Typisierung diskutiert, insbesondere im Kontext von Typfehlern und der Einschränkung bei der Überprüfung von Zuweisungen.'},
     {'question': 'Was ist nominales Subtyping?', 'answer': 'Nominales Subtyping bedeutet, dass ein Subtyp explizit aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. In diesem Fall ist die Namensähnlichkeit entscheidend.'},
     {'question': 'Was ist strukturelles Subtyping?', 'answer': 'Strukturelles Subtyping liegt vor, wenn ein Typ die allgemeine Definition eines Subtyps erfüllt, unabhängig von seiner expliziten Nennung als Supertyp. Hier ist die Struktur und das Verhalten des Typs entscheidend, nicht seine explizite Nennung als Supertyp.'},
     {'question': 'Welches der beiden Subtyping-Modelle impliziert das andere?', 'answer': 'Nominales Subtyping impliziert strukturelles Subtyping. Das bedeutet, wenn ein Subtyp nominal als Supertyp erwähnt wird, erfüllt er automatisch auch die strukturellen Kriterien eines Subtyps.'},
     {'question': 'Was sind die Auswirkungen von nominalem und strukturellem Subtyping auf die Subtypenbeziehung?', 'answer': 'Nominales Subtyping macht die Subtypenbeziehung antisymmetrisch, während strukturelles Subtyping dies nicht tut. Das bedeutet, dass im Fall des nominalen Subtypings ein Subtyp nicht gleichzeitig Subtyp seines Supertyps sein kann, während dies im strukturellen Subtyping möglich ist.'},
     {'question': 'Welche Bedeutung hat die Typkonformität in Bezug auf die Zuweisungskompatibilität?', 'answer': 'Typkonformität ist in vielen Sprachen eine notwendige Voraussetzung für die Zuweisungskompatibilität. Das bedeutet, dass ein Objekt eines typkonformen Typs einer Variable eines anderen, typgleichen Typs zugewiesen werden darf.'},
     {'question': 'Welche beiden Varianten der Typkonformität gibt es, und wie unterscheiden sie sich?', 'answer': 'Es gibt strukturelle Typkonformität und nominale Typkonformität. Bei struktureller Typkonformität müssen alle Elemente des konformen Typs im konformen Typ enthalten sein. Bei nominaler Typkonformität muss zusätzlich die Erweiterung eines anderen Typs explizit angegeben werden.'},
     {'question': 'Welche Vorteile bietet nominale Typkonformität gegenüber struktureller Typkonformität?', 'answer': 'Nominale Typkonformität bietet die Vorteile der Zuweisungskompatibilität und Abwesenheit von Typfehlern. Sie dient auch als Filterfunktion, da nur Objekte von solchen Typen Variablen zugewiesen werden können, für die die Programmiererin dies aus semantischen Überlegungen heraus ausdrücklich vorgesehen hat.'},
     {'question': 'Was ist Typäquivalenz, und wie wird sie in Bezug auf die Zuweisungskompatibilität von Typen verwendet?', 'answer': 'Typäquivalenz ist eine Eigenschaft, die die Zuweisungskompatibilität von Typen beschreibt. Sie bezieht sich darauf, ob Typen in bestimmten Aspekten gleich oder äquivalent sind, ohne unbedingt identisch zu sein.'},
     {'question': 'Welche Arten von Typäquivalenz gibt es, und wie unterscheiden sie sich?', 'answer': 'Es gibt zwei Arten von Typäquivalenz: die nominale (Namensäquivalenz) und die strukturelle (Strukturäquivalenz) Typäquivalenz. Die nominale Typäquivalenz erfordert, dass zwei Deklarationen denselben Typnamen angeben, um Zuweisungskompatibilität zu haben. Die strukturelle Typäquivalenz hingegen erfordert nur, dass die Typen paarweise gleich definiert sind, unabhängig von ihren Namen.'},
     {'question': 'Welche weiteren Eigenschaften gelten für die Typäquivalenz?', 'answer': 'Die Typäquivalenz ist reflexiv, was bedeutet, dass jeder Typ zu sich selbst äquivalent ist. Sie ist auch transitiv, was bedeutet, dass wenn A äquivalent zu B ist und B äquivalent zu C ist, dann ist auch A äquivalent zu C.'},
     {'question': 'Was sind mögliche Nachteile der Strukturäquivalenz?', 'answer': 'Bei Verwendung der Strukturäquivalenz können Typen, die inhaltlich nichts miteinander zu tun haben, fälschlicherweise als äquivalent betrachtet werden. Dies kann dazu führen, dass Objekte, die eigentlich unterschiedlichen Typen angehören, fälschlicherweise zugewiesen werden können, was zu semantischen Fehlern führen kann. Dieses Problem kann durch die Technik des "Type Branding" gelöst werden, bei der jedem Typ eine charakteristische Methode exklusiv zugeordnet wird, um die Strukturäquivalenz einzuschränken.'},
     {'question': 'Welche Anforderungen müssen erfüllt sein, um Typfehler bei Zuweisungen zu vermeiden?', 'answer': 'Um Typfehler bei Zuweisungen zu vermeiden, ist es ausreichend, dass der Typ auf der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs auf der linken Seite enthält.'},
     {'question': 'Was ist Typerweiterung, und in welchen Programmiersprachen wird sie verwendet?', 'answer': 'Typerweiterung (englisch: type extension) erlaubt, dass der Typ auf der rechten Seite einer Zuweisung eine Erweiterung des Typs auf der linken Seite um zusätzliche Methoden ist. Sie wird in Programmiersprachen wie MODULA-3 und OBERON verwendet.'},
     {'question': 'Was sind Bezeichner in der Programmierung, und wie werden sie verwendet?', 'answer': 'Bezeichner sind Namen, die in der Programmierung frei vergeben werden können. Sie werden verwendet, um Programmelemente zu identifizieren und auf sie zu verweisen, beispielsweise Variablen oder Methoden.'},
     {'question': 'Was ist der Zweck der Deklaration von Programmelementen?', 'answer': 'Die Deklaration von Programmelementen dient dazu, dem Compiler den Bezeichner bekanntzugeben, damit er ihn in der Folge wiedererkennen und mit der entsprechenden Definition in Verbindung bringen kann.'},
     {'question': 'Welche Probleme können in untypisierten Sprachen auftreten, wenn Variablen ohne Angabe eines Typs deklariert werden?', 'answer': 'In untypisierten Sprachen, in denen Variablen ohne Angabe eines Typs deklariert werden, kann es zu Problemen führen, da Variablen quasi implizit deklariert werden, wenn sie zum ersten Mal verwendet werden. Dies kann zu Schreibfehlern führen, bei denen versehentlich zwei Variablen mit dem gleichen Namen erstellt werden, die jedoch nichts miteinander zu tun haben. Dies erhöht das Risiko von Programmierfehlern.'},
     {'question': 'Welche Rolle spielen Klassen in der Programmierung, und wie unterscheiden sie sich von Typen?', 'answer': 'Klassen dienen der Angabe von Implementierungen und fungieren als Container für ausführbaren Code. Sie sind strukturell ähnlich wie Typen, haben jedoch unterschiedliche Verwendungszwecke.'},
     {'question': 'Welche Funktion erfüllen Typen in der Programmierung, und wie unterscheiden sie sich von Klassen?', 'answer': 'Typen dienen der Formulierung von Invarianten, die für Variablenzuweisungen gelten müssen und bei deren Verletzung auf Programmfehler hinweisen. Sie sind strukturell ähnlich wie Klassen, haben jedoch eine andere Rolle zur Laufzeit des Programms.'},
     {'question': 'Welche Rolle spielt Typinformation zur Laufzeit eines Programms, und wie unterscheidet sie sich von Klasseninformation?', 'answer': 'Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante durch einen dynamischen Typtest abbricht. Klasseninformation hingegen bildet die Grundlage des dynamischen Bindens und kann in einem Programm als Eigenschaft von Objekten abgefragt werden.'},
     {'question': 'Was ist Inklusionspolymorphie?', 'answer': 'Inklusionspolymorphie, auch als Subtyp-Polymorphie bezeichnet, bedeutet, dass Objekte eines bestimmten Typs an Stellen erwartet werden können, an denen Objekte anderer Typen verwendet werden können, wenn der erste Typ die anderen Typen einschließt oder subsumiert.'},
     {'question': 'Welche Probleme gibt es in Bezug auf die Definition von Subtyping und Inklusionspolymorphie in der objektorientierten Programmierung?', 'answer': 'Die Definition von Subtyping und Inklusionspolymorphie in der objektorientierten Programmierung ist unklar, insbesondere in Bezug darauf, was erforderlich ist, damit ein Objekt eines Typs tatsächlich an Stellen verwendet werden kann, an denen ein Objekt eines anderen Typs erwartet wird. Die Regeln von Ko- und Kontravarianz geben zwar klare Bedingungen vor, sind aber in der Praxis umstritten und reichen nicht immer aus, um Ersetzbarkeit sicherzustellen. Dies führt zu Unsicherheiten in der Definition des Subtypenbegriffs.'},
     {'question': 'Was ist die Zuweisungskompatibilität, und warum ist sie wichtig?', 'answer': 'Die Zuweisungskompatibilität ist wichtig, um festzustellen, ob Zuweisungen zwischen Variablen oder Ausdrücken zulässig sind, ohne die Typinvariante zu verletzen. Sie stellt sicher, dass die Typen der beteiligten Objekte oder Ausdrücke kompatibel sind, um Typfehler zu vermeiden.'},
     {'question': 'Was ist eine Typumwandlung?', 'answer': 'Eine Typumwandlung (type cast) ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen Typ konvertiert wird. Dies geschieht, um dem Compiler oder Type Checker mitzuteilen, dass der Ausdruck den angegebenen Typ hat, auch wenn dies nicht automatisch sichergestellt ist.'},
     {'question': 'Welche Richtungen von Typumwandlungen gibt es?', 'answer': 'Typumwandlungen können in verschiedene Richtungen erfolgen: zu Supertypen (Upcast), zu Subtypen (Downcast) oder zu Typen, die weder Supertyp noch Subtyp des Ausgangstyps sind (Crosscast).'},
     {'question': 'Was ist der Zweck abstrakter Klassen, und warum enthalten sie normalerweise zumindest eine partielle Implementierung?', 'answer': 'Abstrakte Klassen können ausschließlich aus Methodendeklarationen bestehen und dienen dazu, eine gemeinsame partielle Implementierung für andere Klassen, einschließlich ihrer Subklassen, vorzugeben.'},
     {'question': 'Was ist das Kovarianzproblem im Zusammenhang mit parametrischem Polymorphismus?', 'answer': 'Das Kovarianzproblem im Zusammenhang mit parametrischem Polymorphismus bezieht sich darauf, wie Eingabeparameter in Methoden kovariant, also flexibel, in Bezug auf ihren Typ angepasst werden können.'},
     {'question': 'Was sind Typvariablen in parametrischen Typdefinitionen?', 'answer': 'Typvariablen sind Platzhalter in parametrischen Typdefinitionen, die implizit auf Typen beschränkt sind und erst bei der Verwendung eines parametrisierten Typs mit einem konkreten Typ belegt werden.'},
     {'question': 'Was ist die Idee des parametrischen Polymorphismus?', 'answer': 'Die Idee des parametrischen Polymorphismus besteht darin, aus einer Typdefinition durch Parametrisierung viele verschiedene Typen zu generieren, je nachdem, welche konkreten Typen als Typparameter verwendet werden.'},
     {'question': 'Was sind Typen, die sich ausschließlich auf sich selbst beziehen, und wie erhalten sie Bedeutung?', 'answer': 'Typen, die sich ausschließlich auf sich selbst beziehen, sind solche, deren Bedeutung nicht von anderen Typen abhängt. Ein Beispiel dafür ist der Typ "Boolean". Sie können Bedeutung erhalten, indem sie auf bekannte externe Formalismen abgebildet werden, wie die boolesche Algebra.'},
     {'question': 'Was ist eine denotationale Semantik in Bezug auf die Bedeutung von Typen?', 'answer': 'Eine denotationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf bekannte externe Formalismen abgebildet werden. Dies kann beispielsweise bedeuten, dass die Operationen eines Typs auf mathematische oder logische Konzepte abgebildet werden, die in der Programmierung verwendet werden.'},
     {'question': 'Was ist eine operationale Semantik in Bezug auf die Bedeutung von Typen?', 'answer': 'Eine operationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf Anweisungen einer (gedachten oder realen) Maschine abgebildet werden. Dies bedeutet, dass die Operationen eines Typs auf die Ausführung von Maschinenbefehlen oder anderen niedrigstufigen Operationen abgebildet werden.'},
     {'question': 'Was sind die Unterschiede zwischen den Signaturen eines abstrakten Datentyps und dem Protokoll eines STRONGTALK-Typs?', 'answer': 'Es gibt mindestens zwei wichtige Unterschiede: Abstrakte Datentypen sind nicht objektorientiert, während STRONGTALK-Typen objektorientiert sind und Objekte Zustand haben können. Abstrakte Datentypen haben Funktionen mit einem Argument mehr, das dem Typ des Datentyps selbst entspricht. In objektorientierten Sprachen entspricht dies dem Nachrichtenempfänger, dem impliziten Parameter "self".'},
     {'question': 'Was ist der Zweck eines Typsystems in der objektorientierten Programmierung?', 'answer': 'Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern. Es sorgt dafür, dass Programmelemente bei ihrer Deklaration Typen zugewiesen bekommen, die die Menge der zulässigen Objekte und die erlaubten Operationen auf diesen Objekten einschränken.'},
     {'question': 'Welche Unterschiede gibt es zwischen SMALLTALK und den meisten anderen objektorientierten Programmiersprachen in Bezug auf die Typisierung?', 'answer': 'Im Gegensatz zu SMALLTALK sind die meisten anderen objektorientierten Programmiersprachen typisiert, was bedeutet, dass Programmelementen bei ihrer Deklaration Typen zugeordnet werden. In SMALLTALK wird die Typisierung in der Regel erst zur Laufzeit überprüft, während in anderen Sprachen dies bereits zur Übersetzungszeit geschieht.'},
     {'question': 'Was sind rekursive Typen, und warum sind sie wichtig?', 'answer': 'Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren, und sie sind wichtig, um dynamische Strukturen wie verschachtelte Listen oder Bäume in der Programmierung zu ermöglichen.'},
     {'question': 'Welches Problem ergibt sich bei der strukturellen Äquivalenz von rekursiven Typen?', 'answer': 'Das Problem bei der strukturellen Äquivalenz von rekursiven Typen besteht darin, dass die Expansion rekursiver Typen unendlich große Definitionen ergeben kann, was die Feststellung der strukturellen Äquivalenz erschwert.'},
     {'question': 'Was ist Kovarianz und Kontravarianz bei Methodenaufrufen im Zusammenhang mit Subtyping?', 'answer': 'Bei Methodenaufrufen und Subtyping unterscheidet man zwischen Kovarianz und Kontravarianz. Kovarianz bezieht sich auf die Veränderung von Rückgabetypen, während Kontravarianz die Veränderung von Parametertypen beschreibt.'},
     {'question': 'Was ist Kovarianz?', 'answer': 'Kovarianz tritt auf, wenn der Rückgabetyp einer Methode in einem Subtyp ein Subtyp des Rückgabetyps in einem Supertyp ist. Dies bedeutet, dass der Subtyp mehr Werte zurückgeben kann als der Supertyp.'},
     {'question': 'Was ist Kontravarianz?', 'answer': 'Kontravarianz tritt auf, wenn die Parametertypen einer Methode in einem Subtyp Supertypen der Parametertypen in einem Supertyp sind. Dies bedeutet, dass der Subtyp Eingabeparameter akzeptiert, die allgemeiner sind als die des Supertyps.'},
     {'question': 'Welcher konkrete Typ tritt an die Stelle der Typvariable E bei der Verwendung von Inklusionspolymorphie?', 'answer': 'Bei der Verwendung von Inklusionspolymorphie tritt der konkrete Typ "Object" an die Stelle der Typvariable E.'},
     {'question': 'Welche Art von Typfehler kann auftreten, wenn Inklusionspolymorphie verwendet wird?', 'answer': 'Ein Typfehler kann auftreten, wenn Methoden auf Objekten eines konkreten Subtyps von "Object" aufgerufen werden, da die statische Typprüfung solche Methoden nicht unterstützt.'},
     {'question': 'Welchen Vorteil bietet der parametrische Polymorphismus gegenüber der Inklusionspolymorphie?', 'answer': 'Der parametrische Polymorphismus bietet den Vorteil einer erhöhten Typsicherheit, da Typfehler bereits zur Instanziierung des parametrischen Typs erkannt werden können.'},
     {'question': 'Welchen Kompromiss geht man bei der Verwendung parametrischer Typen ein?', 'answer': 'Bei der Verwendung parametrischer Typen geht man einen Kompromiss ein, bei dem die erhöhte Typsicherheit außerhalb der Typdefinition durch eine geringere Typsicherheit innerhalb der Typdefinition erkauft wird.'},
     {'question': 'Welche Eigenschaften müssen die Typen haben, die für die Typvariable E eingesetzt werden können, um die Sicherheit zu gewährleisten?', 'answer': 'Die Typen, die für die Typvariable E eingesetzt werden können, müssen bestimmte Eigenschaften haben, wie z.B. Sortierbarkeit und Addierbarkeit, um die Sicherheit zu gewährleisten.'},
     {'question': 'Welche Art von Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen?', 'answer': 'Der beschränkte parametrische Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen, um Typfehler frühzeitig zu erkennen.'},
     {'question': 'Was ist ein Typ in der Programmierung, und wie ist er definiert?', 'answer': 'Ein Typ in der Programmierung schränkt die möglichen Werte eines deklarierten Elements (z. B. einer Variable) ein. Ein Typ hat eine Intension (Definition) und eine Extension (Wertebereich), wobei er eine Menge von Elementen (Objekten) umfasst, die zu diesem Typ gehören. Typen sind die Grundlage von Typsystemen.'},
     {'question': 'Welche Gründe gibt es, Variablen und andere Programmelemente zu typisieren?', 'answer': 'Es gibt mindestens vier gute Gründe für die Typisierung von Variablen und anderen Programmelementen: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm.'},
     {'question': 'Welche Phase des Entwicklungszyklus verwendet die Typisierung in der Softwareentwicklung?', 'answer': 'Die Typisierung wird in verschiedenen Phasen des Entwicklungszyklus verwendet: In der Entwurfsphase hilft sie bei der Strukturspezifikation. In der Implementierungsphase stellt sie sicher, dass Variablen und Funktionen korrekt verwendet werden. In der Testphase ermöglicht sie gezielte Tests, um die Einhaltung von Datentypen und Schnittstellen zu prüfen. In der Wartungsphase trägt sie zur sicheren Durchführung von Änderungen bei. Bei der Dokumentation hilft sie anderen Entwicklern, den Code zu verstehen und zu verwenden.'}],
    [{'question': 'Wie instanziiert man den Typ A mit einem konkreten Typparameter?', 'answer': 'Um den Typ A zu instanziiert, verwendet man eckige Klammern, um den tatsächlichen Typparameter anzugeben. Zum Beispiel: a := A[Integer] new.'},
     {'question': 'Wie ist die Beziehung zwischen Typäquivalenz und Typkonformität auf der einen Seite und den Wertebereichen (Extensionen) von Typen auf der anderen Seite?', 'answer': 'Damit Typkorrektheit erhalten bleibt, müssen die Wertebereiche von Typen in Bezug auf Zuweisungen miteinander in Beziehung stehen. Wenn ein Objekt eines Typs einem Objekt eines anderen Typs zugewiesen werden soll, muss die Extension des zweiten Typs eine Teilmenge der Extension des ersten Typs sein.'},
     {'question': 'Wie kann die Einschränkung von Ein- oder Rückgabetypen von Methoden die Zuweisungskompatibilität beeinflussen?', 'answer': 'Die Einschränkung von Ein- oder Rückgabetypen von Methoden kann die Zuweisungskompatibilität beeinflussen, indem sie sicherstellt, dass die Extension des eingeschränkten Typs eine Teilmenge der Extension des einschränkenden Typs ist. Dies kann dazu beitragen, die Typkorrektheit von Zuweisungen zu gewährleisten.'},
     {'question': 'Wie gewährleistet die Verwendung von Typen die Wahrung des Geheimnisprinzips und die Einhaltung von Schnittstellen in der objektorientierten Programmierung?', 'answer': 'Die Verwendung von Typen stellt sicher, dass über Variablen nur auf die Elemente einer Klasse zugegriffen wird, die Teil der Schnittstelle sind. Dadurch wird das Geheimnisprinzip gewahrt, und die Einhaltung von Schnittstellen wird durch den Compiler sichergestellt.'},
     {'question': 'Wie verhält sich die Typkonformität in Bezug auf Reflexivität, Transitivität und Symmetrie?', 'answer': 'Typkonformität ist reflexiv, da jeder Typ konform zu sich selbst ist. Sie ist transitiv, sodass wenn Typ A konform zu Typ B ist und Typ B konform zu Typ C ist, dann ist auch Typ A konform zu Typ C. Im Gegensatz zur Typäquivalenz ist Typkonformität nicht symmetrisch. Es gilt jedoch meistens die Antisymmetrie, was bedeutet, dass wenn Typ B zu Typ A und Typ A zu Typ B konform ist, dann müssen A und B identisch sein.'},
     {'question': 'Wann sind zwei Typen zuweisungskompatibel?', 'answer': 'Zwei Typen sind zuweisungskompatibel, wenn sie identisch sind oder eine bestimmte Form der Typäquivalenz aufweisen.'},
     {'question': 'Wie verhält sich die Typäquivalenz in Bezug auf Symmetrie?', 'answer': 'Typäquivalenz ist eine symmetrische Eigenschaft, was bedeutet, dass wenn Typ A äquivalent zu Typ B ist, dann ist auch Typ B äquivalent zu Typ A.'},
     {'question': 'Wie wird die Strukturäquivalenz bei der Feststellung von Typäquivalenz verwendet?', 'answer': 'Bei der Feststellung von Strukturäquivalenz werden die Definitionen der beteiligten Typen rekursiv expandiert, wobei Namen anderer Typen durch ihre Struktur ersetzt werden. Diese Strukturäquivalenz ermöglicht es, Typen zu vergleichen, indem ihre Strukturen miteinander verglichen werden.'},
     {'question': 'Wie wird Typerweiterung in Bezug auf bereits existierende Typen definiert?', 'answer': 'Typerweiterung definiert einen neuen Typ relativ zu einem bereits bestehenden, dem erweiterten Typ. Die Methodendeklarationen des erweiterten Typs werden an den erweiternden Typ vererbt, sodass sie nicht erneut deklariert werden müssen.'},
     {'question': 'Wie äußert sich die Verwendung eines Programmelements in einem Programmtext?', 'answer': 'Die Verwendung eines Programmelements zeigt sich darin, dass sein Name (Bezeichner) im Programmtext angeführt oder referenziert wird. An dieser Stelle kann eine Variable für ihren aktuellen Wert oder eine Methode für ihren Aufruf stehen.'},
     {'question': 'Wie können Typen und Klassen in einem Sprachkonstrukt zusammengefasst werden, obwohl sie unterschiedliche Zwecke haben?', 'answer': 'Obwohl Typen und Klassen unterschiedliche Zwecke haben, teilen sie sich strukturelle Ähnlichkeiten, die es ermöglichen, ihre Definition in einem Sprachkonstrukt zu kombinieren. Dies erleichtert die Verwendung beider Konzepte in einer Programmiersprache.'},
     {'question': 'Wie steht Inklusionspolymorphie in Beziehung zum Subtyping?', 'answer': 'Inklusionspolymorphie und Subtyping sind im Wesentlichen dasselbe Konzept. Beide Begriffe beschreiben, wie Objekte eines Subtyps anstelle ihres Supertyps verwendet werden können.'},
     {'question': 'Wie werden Typfehler in STRONGTALK vermieden?', 'answer': 'In STRONGTALK werden Typfehler vermieden, indem Variablen mit einem Protokoll als Typ typisiert werden. Wenn das Programm typkorrekt ist, bedeutet dies, dass jede Methode im Protokoll, die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist.'},
     {'question': 'Wie werden formale Parameter in STRONGTALK typisiert?', 'answer': 'Formale Parameter in STRONGTALK werden durch Typannotationen in spitzen Klammern hinter den Parametern typisiert.'},
     {'question': 'Wie kennzeichnet man in STRONGTALK den Rückgabetyp einer Methode?', 'answer': 'In STRONGTALK wird der Rückgabetyp einer Methode durch ein vorangestelltes Dach (^) gekennzeichnet und folgt auf den letzten Parameter der Methode.'},
     {'question': 'Wie werden Typen in Variablendeklarationen zugeordnet?', 'answer': 'Typen werden in Variablendeklarationen explizit angegeben, um jedem Objekt und Ausdruck im Programm einen Typ zuzuordnen.'},
     {'question': 'Wie wird die Richtung der erlaubten Zuweisung bei der Zuweisungskompatibilität interpretiert?', 'answer': 'Bei der Zuweisungskompatibilität wird die Richtung der erlaubten Zuweisung so interpretiert, dass beim Satz "a ist zuweisungskompatibel mit b" die Zuweisung "b := a" zulässig ist. Die umgekehrte Richtung, "a := b," wird durch den Satz nicht ausgesagt.'},
     {'question': 'Wie ist der Zusammenhang zwischen Typen und Klassen in Bezug auf schematische Klassendefinitionen in SMALLTALK?', 'answer': 'In SMALLTALK enthalten Klassendefinitionen bestimmte Elemente, die auch in Typdefinitionen auftauchen, wie Namen, von denen Definitionen abgeleitet werden, und Methodennamen mit formalen Parametern.'},
     {'question': 'Wie unterscheidet sich die Verwendung von Klassendefinitionen in STRONGTALK von anderen Sprachen wie JAVA oder C++?', 'answer': 'In STRONGTALK sind formale Parameter in Klassendefinitionen typisiert, während in JAVA oder C++ Instanzvariablen nicht Teil einer Typdefinition sein können.'},
     {'question': 'Wie erfolgt die Zuweisung eines Typs zu einer Typvariable bei der Verwendung eines parametrisch definierten Typs?', 'answer': 'Die Zuweisung eines Typs zu einer Typvariable erfolgt bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, z. B. der Deklaration einer Variable oder des Rückgabewerts einer Methode. Diese Verwendung entspricht oberflächlich betrachtet dem Aufruf einer Methode oder eines Konstruktors, führt aber bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen.'},
     {'question': 'Wie kann der parametrische Polymorphismus zur Lösung des Problems der rekursiven Typen beitragen?', 'answer': 'Der parametrische Polymorphismus ermöglicht die Definition eines nicht parametrischen Typs als Subtyp eines parametrisierten Typs, wodurch die gewünschte Rekursion indirekt hergestellt werden kann.'},
     {'question': 'Wie wird die Beschränkung des tatsächlichen Typparameters in der Typdefinition erreicht?', 'answer': 'Die Beschränkung des tatsächlichen Typparameters wird erreicht, indem der formale Typparameter auf einen Subtyp beschränkt wird.'},
     {'question': 'Wie wird Kovarianz und Kontravarianz bei der Redefinition von Methodenaufrufen im Subtyping angewendet?', 'answer': 'Bei der Redefinition von Methodenaufrufen im Subtyping müssen die Parametertypen kontravariant und die Rückgabetypen kovariant sein. Dies bedeutet, dass die Eingabeparameter des Subtyps genereller sein dürfen als die des Supertyps, während der Subtyp mehr Werte zurückgeben kann als der Supertyp.'},
     {'question': 'Wie können definierte Typen in STRONGTALK-Programmen verwendet werden?', 'answer': 'Definierte Typen können in STRONGTALK-Programmen bei der Deklaration von (anderen) Typen, von Variablen, von Blöcken und von Methoden verwendet werden. Dies führt zu einer Typisierung der deklarierten Programmelemente.'},
     {'question': 'Wie erfolgt die Verwendung definierter Typen in Typdefinitionen und Methoden in STRONGTALK?', 'answer': 'Die Verwendung von definierten Typen in Typdefinitionen und Methoden erfolgt analog. In Methoden werden Variablen (einschließlich formaler Parameter) durch die Anfügung eines Typnamens in spitzen Klammern typisiert. Der Rückgabetyp eines Blocks wird im selben Segment wie die formalen Parameter angegeben, also vor dem Trennzeichen.'},
     {'question': 'Wie werden Variablen in STRONGTALK typisiert?', 'answer': 'Variablen (einschließlich Instanzvariablen und temporäre Variablen) werden in STRONGTALK typisiert, indem ein Typname in spitzen Klammern an die Variable angehängt wird.'}],
    [{'question': 'Wo wird die Typvariable T deklariert, und wo wird sie verwendet?', 'answer': 'T wird im Abschnitt "Typvariablen" deklariert und im Abschnitt "Protokoll" verwendet.'},
     {'question': 'Warum verwendet man traditionell einzelne Großbuchstaben für Typvariablen?', 'answer': 'Typvariablen werden traditionell mit einzelnen Großbuchstaben bezeichnet, um zu vermeiden, dass sie tatsächliche Typen verdecken. Dies ermöglicht die Verwendung beliebig vieler Typen in einer parametrischen Klassendefinition.'},
     {'question': 'Was passiert bei der Instanziierung eines parametrischen Typs mit einem konkreten Typen?', 'answer': 'Der konkrete Typ wird in die formale Typvariable eingesetzt, und der resultierende Typ wird zur Verwendung im Programm definiert.'},
     {'question': 'Warum ist die einfache Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich?', 'answer': 'Die einfache Form des parametrischen Polymorphismus ist nur teilweise nützlich, da die Typvariablen selbst nicht typisiert sind, und somit innerhalb der Typdefinition keine Aussagen über den Typ getroffen werden können.'},
     {'question': 'Was versteht man unter einem Subtyp und wie steht er in Beziehung zu einem Supertyp?', 'answer': 'Ein Subtyp ist ein Typ, dessen Werte oder Objekte überall dort verwendet werden können, wo die Werte des Supertyps, von dem er ein Subtyp ist, erwartet werden. Der Begriff "Subtyp" bezieht sich auf die Rolle eines Typs in der Beziehung zu einem anderen Typ, nämlich der Subtypenbeziehung. Die Gegenrolle in dieser Beziehung wird als Supertyp bezeichnet.'},
     {'question': 'Gibt es eine gewisse Zirkularität in der Definition von Subtypen?', 'answer': 'Ja, es gibt eine gewisse Zirkularität in der Definition von Subtypen. Die Definition selbst basiert auf der Zuweisungskompatibilität zwischen Subtypen und Supertypen. Dies kann den Eindruck erwecken, dass die Beziehung zwischen Subtypen und Supertypen einfacher ist, als sie in der Realität ist. Die eigentliche Frage, welche Bedingungen erfüllt sein müssen, damit ein Objekt eines Subtyps tatsächlich an Stellen verwendet werden darf, an denen ein Objekt eines Supertyps erwartet wird, wird jedoch in dieser Definition nicht näher erläutert.'},
     {'question': 'Warum könnte die Annotation von Variablen mit dem Supertypen ein Problem darstellen?', 'answer': 'Die Annotation von Variablen mit dem Supertypen könnte ein Problem darstellen, da dies die Verwendung von Subtypen einschränken würde. Wenn Variablen mit dem Supertypen annotiert sind und nur Werte des Supertyps akzeptieren, könnten keine Objekte des Subtyps in diesen Variablen gespeichert werden, selbst wenn sie die gleiche Struktur oder das gleiche Verhalten aufweisen. Dies würde die Flexibilität des Typsystems einschränken und die Verwendung von Subtypen weniger nützlich machen.'},
     {'question': 'Warum führt die Typeinschränkung zur Problematik der Zuweisungskompatibilität?', 'answer': 'Die Typeinschränkung kann die Zuweisungskompatibilität beeinträchtigen, da sie die Parameter-Typen in Methoden neu definiert und dadurch potenziell Konflikte bei der Zuweisung von Objekten unterschiedlicher Typen verursachen kann. Dies führt dazu, dass nicht alle Zuweisungen, die bei Typerweiterung basierend auf Typkonformität zulässig wären, bei Typeinschränkung ebenfalls zulässig sind.'},
     {'question': 'Warum ist die Unterscheidung zwischen Wertsemantik und Referenzsemantik relevant, wenn es um Typeinschränkung geht?', 'answer': 'Die Unterscheidung zwischen Wertsemantik und Referenzsemantik ist relevant, da sie Auswirkungen auf die Zuweisungskompatibilität hat. Unter Wertsemantik wird bei der Zuweisung eine Kopie des Objekts erstellt, während unter Referenzsemantik mehrere Variablen auf dasselbe Objekt verweisen können. In diesem Zusammenhang ist die Referenzsemantik interessanter, da Typeinschränkungen bei der Zuweisung von Aliasen (Variablen, die auf dasselbe Objekt verweisen) Probleme verursachen können, die bei Wertsemantik nicht auftreten.'},
     {'question': 'Warum wird in der Praxis der objektorientierten Programmierung oft die Referenzsemantik verwendet?', 'answer': 'In der Praxis der objektorientierten Programmierung wird oft die Referenzsemantik verwendet, da sie effizienter ist und es ermöglicht, auf dasselbe Objekt von verschiedenen Stellen im Code aus zuzugreifen. Dies erleichtert die Arbeit mit komplexen Datenstrukturen und verhindert unnötige Kopien von Objekten. Die Referenzsemantik ist daher die gebräuchlichere Semantik in vielen objektorientierten Programmiersprachen.'},
     {'question': 'Was möchte man bei der Deklaration von n-wertigen Attributen angeben?', 'answer': 'Bei der Deklaration von n-wertigen Attributen möchte man den Typ der in Beziehung stehenden Objekte angeben.'},
     {'question': 'Was bedeutet es, wenn die Extension eines Typs in der Extension eines anderen Typs enthalten ist?', 'answer': 'Wenn die Extension eines Typs in der Extension eines anderen Typs enthalten ist, bedeutet dies, dass Objekte des ersten Typs an Stellen verwendet werden können, an denen Objekte des zweiten Typs erwartet werden, ohne die Typkorrektheit zu verletzen.'},
     {'question': 'Warum ist die Teilmengenbeziehung bei der Typeinschränkung nicht immer offensichtlich?', 'answer': 'Bei der Typeinschränkung, bei der Eigenschaften (Methoden) entfernt werden, kann die Extension des eingeschränkten Typs tatsächlich größer werden, da weniger spezifische Anforderungen gestellt werden. Dies kann zu einer scheinbaren Umkehrung der Teilmengenbeziehung führen.'},
     {'question': 'Warum kann es trotz der Harmonie von Typerweiterung und -einschränkung zu einem Verlust der Zuweisungskompatibilität kommen?', 'answer': 'Der Verlust der Zuweisungskompatibilität kann aus der impliziten Allquantifiziertheit von Typinvarianten resultieren. Typsysteme mit solchen Invarianten sind nicht in der Lage, Aussagen über Wertebereiche zu treffen, die nicht implizit allquantifiziert sind.'},
     {'question': 'Was bietet der Begriff des Subtyps als Lösung für diese Probleme?', 'answer': 'Der Begriff des Subtyps bietet eine Möglichkeit, Typerweiterung und Typeinschränkung mit Zuweisungskompatibilität und Typkorrektheit zu vereinen. Ein Subtyp ist ein Typ, dessen Extension eine Teilmenge der Extension seines Supertyps ist, was sicherstellt, dass Objekte des Subtyps an Stellen verwendet werden können, an denen Objekte des Supertyps erwartet werden.'},
     {'question': 'Warum ist die Namensäquivalenz als Bedingung der Zuweisungskompatibilität wichtig?', 'answer': 'Die Namensäquivalenz ist wichtig, da sie sicherstellt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Sie verhindert Zuweisungen zwischen Typen, die zwar strukturell gleich sind, aber unterschiedliche Bedeutungen haben. Dies ist entscheidend, um logische Programmierfehler zu vermeiden, die sonst schwer zu entdecken wären.'},
     {'question': 'Warum ist es nach den Prinzipien der objektorientierten Programmierung wichtig, Implementierungen von Klassen hinter Schnittstellen zu verbergen?', 'answer': 'Das Verbergen von Implementierungen hinter Schnittstellen ist wichtig, um das Geheimnisprinzip zu wahren und sicherzustellen, dass nur die für Benutzer einer Klasse vorgesehenen Elemente sichtbar sind.'},
     {'question': 'Was unterscheidet eine absolute und eine relativ spezifizierte Schnittstelle einer Klasse?', 'answer': 'Eine absolute Schnittstelle verrät keinerlei Implementierungsdetails und besteht nur aus Methodendeklarationen. Eine relative Schnittstelle kann sich je nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse unterscheiden und gibt mehr Einblicke in die Implementierung.'},
     {'question': 'Warum beschränken einige Sprachen, wie JAVA und C++, die Instanzvariablen ihrer Klassen in der Schnittstelle?', 'answer': 'Das Beschränken von Instanzvariablen in der Schnittstelle dient dazu, die Repräsentation der Objekte nach außen nicht sichtbar zu machen, um das Geheimnisprinzip zu wahren und Implementierungsdetails zu verbergen.'},
     {'question': 'Was ermöglicht das Interface-als-Typ-Konzept in JAVA, und warum wird es als bedeutend für die objektorientierte Programmierung angesehen?', 'answer': 'Das Interface-als-Typ-Konzept in JAVA ermöglicht es, dass eine Klasse verschiedene Schnittstellen anbieten kann, die alle als Typen der Klasse dienen. Dies erleichtert die interfacebasierte Programmierung und wird als einer der wichtigsten Beiträge von JAVA zur objektorientierten Programmierung angesehen.'},
     {'question': 'Warum gehört eine Instanz einer Subklasse nicht zwangsläufig zum Wertebereich des zur Superklasse gehörenden Typs?', 'answer': 'Eine Instanz einer Subklasse gehört nicht zwangsläufig zum Wertebereich des zur Superklasse gehörenden Typs, da in der Subklasse Änderungen vorgenommen werden können, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben können. Zum Beispiel können Methoden gelöscht oder inkompatibel redefiniert werden.'},
     {'question': 'Warum werden bestimmte Typsysteme als kaum praxistauglich bezeichnet?', 'answer': 'Bestimmte Typsysteme, die in der Lage sind, solche Einschränkungen zu überprüfen, werden als kaum praxistauglich bezeichnet, da sie die Flexibilität und die praktische Anwendbarkeit in realen Programmiersituationen stark einschränken. Sie können zu komplexen und schwer wartbaren Code führen.'},
     {'question': 'Was unterscheidet nominales und strukturelles Subtyping?', 'answer': 'Beim Subtyping gibt es zwei Unterscheidungen: nominales und strukturelles Subtyping.'},
     {'question': 'Was bedeutet es, wenn ein Typ als "typkonform" bezeichnet wird?', 'answer': 'Ein Typ wird als "typkonform" bezeichnet, wenn seine Definition alle deklarierten Elemente der Definition eines anderen Typen enthält.'},
     {'question': 'Warum setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität?', 'answer': 'Die meisten Programmiersprachen setzen auf nominale Typkonformität, da sie automatisch gegeben ist, wenn der Typ, von dem ein neuer per Erweiterung abgeleitet wird, genannt wird. Dies vermeidet aufwendige, fallweise Konformitätstests. Strukturelle Typsysteme, insbesondere solche ohne explizite Benennung von Typen, erschweren die Ausdrücklichkeit der Programmiererin bei der Definition ihrer Absicht (intendierte Semantik) und können Programme schwerer lesbar und debugbar machen. Fehlermeldungen aus strukturellen Typprüfungen sind oft schwer zu verstehen und beziehen sich nicht immer auf die eigentliche Fehlerquelle.'},
     {'question': 'Was unterscheidet Namensäquivalenz und Strukturäquivalenz?', 'answer': 'Bei der Namensäquivalenz spielen die Namen der Typen eine eigenständige Rolle und haben unabhängig von ihrer Struktur Bedeutung. Bei der Strukturäquivalenz dienen Namen lediglich als abkürzende Schreibweise für die Typstrukturen. Namensäquivalenz impliziert Strukturäquivalenz, aber nicht umgekehrt.'},
     {'question': 'Warum reicht Strukturäquivalenz als Bedingung für Zuweisungskompatibilität aus?', 'answer': 'Strukturäquivalenz reicht als Bedingung für Zuweisungskompatibilität aus, um Typfehler zu verhindern, die auf der Annahme einer nicht vorhandenen Methode bei einem Wert einer Variable basieren. Sie gewährleistet, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.'},
     {'question': 'Was bedeutet Typkonformität in Bezug auf Typerweiterung?', 'answer': 'Typkonformität regelt die Zuweisungskompatibilität unter Typerweiterung. Es bedeutet, dass Variablen, deren deklarierter Typ ein erweiterter Typ ist, auch Objekte des ursprünglichen Typs enthalten können, ohne zu Typfehlern zu führen. Die umgekehrte Zuweisung, bei der ein Objekt des ursprünglichen Typs einer Variable mit dem erweiterten Typ zugewiesen wird, kann jedoch Probleme verursachen, wenn auf Methoden des erweiterten Typs zugegriffen wird, die für das Objekt nicht definiert sind.'},
     {'question': 'Was unterscheidet eine Deklaration und eine Definition?', 'answer': 'Deklaration gibt dem Bezeichner bekannt, während Definition ihm sagt, wofür er steht. Bei Variablen kann die Definition implizit sein und aus der Deklaration abgeleitet werden, während bei Methoden die Unterscheidung zwischen Deklaration (Signatur) und Definition (Methodenrumpf) essentiell ist.'},
     {'question': 'Warum wurden Typen und Klassen in diesem Text als separate Konzepte dargestellt, obwohl sie in vielen Sprachen gleich sind?', 'answer': 'Die Trennung von Typen und Klassen wird gezeigt, weil sie nicht in allen Programmiersprachen identisch sind, und selbst in den Sprachen, in denen sie ähnlich sind, gibt es Unterschiede und spezifische Verwendungszwecke.'},
     {'question': 'Warum wird die Unterscheidung zwischen Klassen und Typen in Sprachen, in denen jede Klasse einen Typ definiert, manchmal nicht klar getroffen?', 'answer': 'In Sprachen, in denen Klassen auch Typen definieren, kann die Unterscheidung zwischen den beiden Konzepten verschwommen sein, da Programmierer möglicherweise nicht immer klar wahrnehmen, wie sie zur Laufzeit eines Programms wirken.'},
     {'question': 'Warum ist Inklusionspolymorphie interessant?', 'answer': 'Inklusionspolymorphie ermöglicht die Erweiterung des Wertebereichs von Typen, indem neue Typen hinzugefügt werden können, die anstelle bereits existierender Typen verwendet werden können, ohne dass am Programm sonst etwas geändert werden muss. Dies ist besonders nützlich für die Weiterentwicklung und Wiederverwendung von Programmen.'},
     {'question': 'Warum ist es wichtig, die Eigenschaften eines Typs und seiner Elemente in einem Typsystem zu kennen?', 'answer': 'Es ist wichtig, die Eigenschaften eines Typs und seiner Elemente in einem Typsystem zu kennen, um Fehler im Programm zu vermeiden, die auf der Annahme von Eigenschaften beruhen, die Objekte möglicherweise nicht haben. Ein Typsystem definiert, welche Methoden auf einem Objekt aufgerufen werden können, und stellt sicher, dass diese Methoden auch für das Objekt definiert sind.'},
     {'question': 'Warum müssen Protokolle in STRONGTALK selbst Typen verwenden?', 'answer': 'Protokolle in STRONGTALK verwenden selbst Typen, da sie die Typen der Eingabe- und Ausgabeobjekte in den Methoden spezifizieren. Dies gewährleistet, dass die Typen der Objekte, die mit den Methoden interagieren, kompatibel sind.'},
     {'question': 'Warum gibt es in STRONGTALK keine primitiven Typen?', 'answer': 'In STRONGTALK gibt es keine primitiven Typen, da alle Typen in STRONGTALK auf andere Typen zurückgeführt werden können. Selbst wenn eine Typannotation weggelassen wird, hat die entsprechende Variable bzw. der Rückgabewert der Methode immer einen impliziten Typ. Dies ermöglicht es, Typen mit zwangsläufiger Selbstbezüglichkeit eine Bedeutung zuzuweisen.'},
     {'question': 'Warum ist die Typisierung von Variablen und Ausdrücken in einem Programm wichtig?', 'answer': 'Die Typisierung von Variablen und Ausdrücken in einem Programm ist wichtig, um sicherzustellen, dass jede Variable nur Werte haben kann, für die sie vorgesehen ist. Dies gewährleistet die Einhaltung der Typinvariante und verhindert Typfehler im Programm.'},
     {'question': 'Ist Zuweisungskompatibilität eine transitive Eigenschaft?', 'answer': 'Ja, in der Regel ist Zuweisungskompatibilität eine transitive Eigenschaft. Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c ist, dann ist auch a zuweisungskompatibel mit c.'},
     {'question': 'Warum ist Zuweisungskompatibilität auch bei impliziten Zuweisungen wichtig?', 'answer': 'Zuweisungskompatibilität ist auch bei impliziten Zuweisungen wichtig, da sie Typkorrektheit impliziert. Bei der Parameterübergabe von Methodenaufrufen oder impliziten Zuweisungen müssen die beteiligten Typen kompatibel sein, um Typfehler zu vermeiden.'},
     {'question': 'Was erlaubt die Zuweisungskompatibilität unter Subtyping?', 'answer': 'Die Zuweisungskompatibilität unter Subtyping erlaubt die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps.'},
     {'question': 'Warum kann es für die Programmiererin problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden?', 'answer': 'Es kann problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden, da der Supertyp möglicherweise nicht alle Methoden und Eigenschaften des tatsächlichen Typs enthält, die die Programmiererin verwenden möchte.'},
     {'question': 'Warum sind Upcasts immer typsicher, während Downcasts und Crosscasts unsicher sein können?', 'answer': 'Upcasts sind immer typsicher, da sie von einem spezielleren Typ zu einem allgemeineren Typ erfolgen. Downcasts und Crosscasts können unsicher sein, da sie von einem allgemeineren Typ zu einem spezielleren oder nicht verwandten Typ erfolgen, was dazu führen kann, dass der Ausdruck zur Laufzeit nicht den erwarteten Typ hat.'},
     {'question': 'Warum sollte man versuchen, Typumwandlungen zu vermeiden?', 'answer': 'Typumwandlungen sollten vermieden werden, da sie potenziell unsicher sind und die Programmlogik komplexer machen können. Wenn Typumwandlungen unvermeidbar sind, sollten sie mit einem Typtest abgesichert werden, um sicherzustellen, dass das Objekt zur Laufzeit den gewünschten Typ hat.'},
     {'question': 'Warum wurde in dieser Kurseinheit bisher nur über Typen gesprochen und Klassen ignoriert?', 'answer': 'Typen und Klassen werden getrennt behandelt, da Klassen die Implementierung von Objekten festlegen, während Typdefinitionen frei von Implementierungsaspekten sind.'},
     {'question': 'Was unterscheidet Typen und Klassen, wenn es um die Einschränkung des Wertebereichs von Variablen und die Angabe des Protokolls von Objekten geht?', 'answer': 'Typen sind abstrakte Spezifikationen, die den Wertebereich von Variablen und das Protokoll von Objekten festlegen. Klassen hingegen sind Konstrukte, die Objekte bilden und mit Implementierung versehen.'},
     {'question': 'Warum werden in SMALLTALKs Klassendefinitionen keine Typen verwendet, und wie werden formale Parameter in Bezug auf Typen behandelt?', 'answer': 'In SMALLTALK werden keine Typen in Klassendefinitionen verwendet, und formale Parameter verwenden stattdessen Namen wie "aString" oder "anInteger", die darauf hinweisen, welcher Klasse der Wert sein sollte. Dies wird jedoch nicht überprüft.'},
     {'question': 'Warum ergibt sich beim rekursiv beschränkten parametrischen Polymorphismus kein Widerspruch zur Kontravarianzregel des Subtyping?', 'answer': 'Beim rekursiv beschränkten parametrischen Polymorphismus ändert sich der Parametertyp der Methode = mit dem Empfängertyp, was kovariant wirkt. Es ergibt sich jedoch kein Widerspruch zur Kontravarianzregel des Subtyping, da der Empfängertyp (z. B. Integer) lediglich zu einem Subtyp von Equatable[Integer] wird und nicht von Equatable[Object].'},
     {'question': 'Gibt es eine Lösung für das Problem der kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischem Polymorphismus?', 'answer': 'Es gibt keine zufriedenstellende Lösung für das Problem der kovarianten Redefinition von Eingabeparametern in Methoden mittels parametrischem Polymorphismus. Die Kovarianz kann zwar in bestimmten Fällen erreicht werden, aber sie ist nicht in allen Typdefinitionen festgehalten und bietet keine vollständige Kontrolle über die Typkorrektheit.'},
     {'question': 'Warum ist die Assoziation von Zeichnung mit Plotter in keiner Typdefinition festgehalten?', 'answer': 'Die Assoziation von Zeichnung mit Plotter, die Kovarianz, ist in keiner Typdefinition festgehalten, da es keine Möglichkeit gibt, einen bestimmten Wert für einen Typparameter vorzuschreiben. Die Kovarianz ist nicht in allen Fällen durch parametrische Typen abbildbar.'},
     {'question': 'Kann das Kovarianzproblem durch parametrische Typen gelöst werden?', 'answer': 'Das Kovarianzproblem kann in bestimmten Fällen durch parametrische Typen gelöst werden, aber es gibt keine allgemeine Lösung, die in allen Fällen die kovariante Redefinition von Eingabeparametern in Methoden ermöglicht. Die Flexibilität ist begrenzt, und es kann zu Einschränkungen bei der Verwendung von parametrischen Typen führen.'},
     {'question': 'Was unterscheidet eine parametrische Typdefinition und eine normale Typdefinition?', 'answer': 'Der Unterschied besteht darin, dass in einer parametrischen Typdefinition andere Typen durch Platzhalter, sogenannte Typparameter, vertreten werden können, die erst bei der Verwendung des parametrisierten Typs belegt werden. Bei einer normalen Typdefinition werden die anderen Typen direkt genannt.'},
     {'question': 'Warum nennt man parametrische Typen auch generische Typen oder Generics?', 'answer': 'Parametrische Typen werden auch als generische Typen oder Generics bezeichnet, weil sie die Idee verfolgen, aus einer Typdefinition generisch (theoretisch für beliebig viele Typen) viele Typen zu erzeugen, je nach Bedarf. Sie ermöglichen eine gewisse Generizität in der Typsicherung.'},
     {'question': 'Müssen die zugewiesenen Typen Objekte sein, um Typvariablen in parametrischen Typen zu belegen?', 'answer': 'Nein, die zugewiesenen Typen müssen keine Objekte sein, um Typvariablen in parametrischen Typen zu belegen. Es können auch andere Typen sein, solange sie die erforderlichen Bedingungen erfüllen.'},
     {'question': 'Gibt es vollständig in sich selbst definierte Typsysteme, die von externen Einflüssen unabhängig sind?', 'answer': 'Nein, es gibt keine vollständig in sich selbst definierten Typsysteme, die vollständig unabhängig von externen Einflüssen sind. Selbst in Typsystemen wie SMALLTALK oder STRONGTALK sind mindestens einige grundlegende Typen oder Konzepte, wie Wahrheitswerte oder Ganzzahlen, von externen Formalismen oder vorgegebenen Semantiken abhängig.'},
     {'question': 'Was bedeutet Typisierung in objektorientierten Programmiersprachen?', 'answer': 'Typisierung in objektorientierten Programmiersprachen bedeutet, dass bei der Deklaration von Programmelementen, wie Variablen oder Funktionen, Typen zugeordnet werden. Diese Typen bestimmen, welche Arten von Objekten in diesen Programmelementen gespeichert oder verarbeitet werden können und welche Operationen auf diese Objekte angewendet werden können.'},
     {'question': 'Warum könnte es sinnvoll sein, das Typsystem einer Programmiersprache von ihrem Rest zu isolieren?', 'answer': 'Das Isolieren des Typsystems einer Programmiersprache ermöglicht es, das Typsystem auszutauschen oder zu verbessern, ohne die gesamte Sprachdefinition ändern zu müssen. Dies kann besonders nützlich sein, wenn man eine Sprache an spezifische Anforderungen anpassen möchte.'},
     {'question': 'Warum wird in dieser Kurseinheit das Typsystem am Beispiel von STRONGTALK behandelt?', 'answer': 'Diese Kurseinheit behandelt das Typsystem am Beispiel von STRONGTALK, einer SMALLTALK-Erweiterung um ein optionales Typsystem. Dies geschieht, um die Konzepte schrittweise und verständlich einzuführen. Das Ziel ist, dass die Leserinnen und Leser Typsysteme als Möglichkeiten zur Spezifikation redundanter Informationen verstehen, die die Qualität von Programmen erhöhen sollen.'},
     {'question': 'Warum ist die direkte Deklaration des Gleichheitstests in Object problematisch?', 'answer': 'Die direkte Deklaration des Gleichheitstests in Object wäre problematisch, da sie zu einer kovarianten Redefinition führen würde, was zu bekannten Problemen führt.'},
     {'question': 'Warum sind solche Konstrukte wichtig in der objektorientierten Programmierung?', 'answer': 'Solche Konstrukte sind wichtig in der objektorientierten Programmierung, da sie die Typsicherheit erhöhen und es ermöglichen, flexible Frameworks und komplexe Datenstrukturen zu erstellen. Sie sind in vielen modernen Programmiersprachen und Frameworks weit verbreitet.'},
     {'question': 'Warum ist die Kovarianz für Parametertypen in der Praxis nicht notwendig und kann sogar zu typinkorrekten Programmen führen?', 'answer': 'Obwohl Kovarianz für Parametertypen auf den ersten Blick sinnvoll erscheint, kann sie in der Praxis zu typinkorrekten Programmen führen. Dies liegt daran, dass die Anzahl der möglichen Eingabewerte in einem Subtyp reduziert wird, wenn die Menge der Empfängerobjekte eingeschränkt wird. Dies führt dazu, dass die Parametertypen tatsächlich kontravariant sind. Kovarianz für Parametertypen würde typinkorrekte Programme ermöglichen.'},
     {'question': 'Warum wird in der Praxis trotz Verwendung parametrischer Definitionen von Collections oft auch auf Inklusionspolymorphie zurückgegriffen?', 'answer': 'In der Praxis wird trotz Verwendung parametrischer Definitionen von Collections oft auf Inklusionspolymorphie zurückgegriffen, da heterogene Collections, die Objekte unterschiedlicher Subtypen enthalten, häufig vorkommen und Inklusionspolymorphie dies ermöglicht.'},
     {'question': 'Warum ist es wichtig, dass ein Typfehler bereits bei der Verwendung der parametrischen Typdefinition erkannt wird?', 'answer': 'Es ist wichtig, dass ein Typfehler bereits bei der Verwendung der parametrischen Typdefinition erkannt wird, um sicherzustellen, dass alle eingesetzten Typen die erforderlichen Eigenschaften haben, bevor sie verwendet werden.'},
     {'question': 'Wo wird der Rückgabetyp für Blöcke in STRONGTALK angegeben?', 'answer': 'Der Rückgabetyp für Blöcke in STRONGTALK wird im selben Segment wie die formalen Parameter angegeben, und zwar vor dem Trennzeichen.'},
     {'question': 'Gibt es eine Verbindung zwischen Typen und Klassen in der objektorientierten Programmierung?', 'answer': 'Ja, es gibt eine Verbindung zwischen Typen und Klassen in der objektorientierten Programmierung. Der Zusammenhang wird jedoch vorerst zurückgestellt und wird in Kapitel 28 erklärt.'},
     {'question': 'Was unterscheidet statische und dynamische Typprüfung?', 'answer': 'Statische Typprüfung erfolgt zur Übersetzungszeit und gewährleistet, dass die Typkorrektheit eines Programms vor der Ausführung sichergestellt wird. Dynamische Typprüfung erfolgt zur Laufzeit und prüft, ob der zuzuweisende Wert den geforderten Typ hat. Statische Typprüfung erfordert Typenannotationen bei der Variablendeklaration, während dynamische Typprüfung dies zur Laufzeit überprüft.'}],
]
KE4_questions = [
    [{'question': 'Welche beiden Interfaces in JAVA ermöglichen eine einheitliche Iteration über Collections mittels Iteratoren?', 'answer': 'In JAVA ermöglichen die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer) eine einheitliche Iteration über Collections mittels Iteratoren.'},
     {'question': 'Welches Interface muss eine Klasse implementieren, um die "syntaktische Zucker"-Version der "for"-Schleife in JAVA verwenden zu können?', 'answer': 'Eine Klasse muss das Interface "Iterable" implementieren, um die "syntaktische Zucker"-Version der "for"-Schleife in JAVA verwenden zu können. Diese Version ermöglicht die externe Iteration über Collections.'},
     {'question': 'Was ist das Überschreiben von Methoden in JAVA, und welche Bedingungen gelten dafür?', 'answer': 'Das Überschreiben von Methoden in JAVA bedeutet, dass eine bereits vorhandene Methode in einer Subklasse mit derselben Signatur (Methodenname und formale Parametertypen) neu definiert wird. Die Bedingungen dafür sind, dass die Methode denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode hat und dass die deklarierten Parametertypen der Methode Subtypen der deklarierten Parametertypen der Methode in der Superklasse sind.'},
     {'question': 'Was ist das Überladen von Methoden in JAVA, und wie unterscheidet es sich vom Überschreiben?', 'answer': 'Das Überladen von Methoden in JAVA bedeutet, dass Methoden denselben Namen haben, aber verschiedene Parametertypen in derselben Klasse oder einer Subklasse haben. Der Unterschied zum Überschreiben besteht darin, dass beim Überladen neue Methoden hinzugefügt werden, während beim Überschreiben bereits vorhandene Methoden neu definiert werden.'},
     {'question': 'Was ist dynamisches Binden in JAVA, und wie funktioniert der Bindungsalgorithmus?', 'answer': 'Das dynamische Binden in JAVA bezieht sich auf die Auswahl der Methode zur Laufzeit, basierend auf dem tatsächlichen Typ des Empfängerobjekts. Der Bindungsalgorithmus in JAVA wählt die Methode aus, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode, ist in der Klasse des deklarierten Typs des Ausdrucks deklariert und deren deklarierte Parametertypen sind Subtypen der deklarierten Parametertypen der aufgerufenen Methode. Wenn mehrere Methoden die Bedingungen erfüllen, wird diejenige ausgewählt, deren Klasse am nächsten zur Klasse des Empfängerobjekts in der Superklassenkette ist.'},
     {'question': 'Was sind die Einschränkungen von JAVA-Arrays im Vergleich zu Collections?', 'answer': 'JAVA-Arrays haben im Vergleich zu Collections Einschränkungen in ihrer Funktionalität. Sie bieten keine eigenen Methoden zur Unterstützung des Zugriffs, kein dynamisches Wachstum und es gibt einige Probleme mit dem Subtyping von Arrays.'},
     {'question': 'Welche Vorteile bietet die Verwendung von Interfaces in Java?', 'answer': 'Die Verwendung von Interfaces in Java ermöglicht die Bereitstellung verschiedener Sichten auf Objekte, die von Klassen implementiert werden. Dies kann dazu beitragen, den Zugriff auf die Methoden eines Objekts zu beschränken oder die Austauschbarkeit von Klassen zu verbessern.'},
     {'question': 'Was sind Tagging oder Marker-Interfaces in Java und wofür werden sie verwendet?', 'answer': 'Tagging oder Marker-Interfaces in Java sind Schnittstellen, die in der Regel keine eigenen Methoden deklarieren, sondern dazu verwendet werden, Klassen zu markieren oder zu "taggen". Sie dienen der Filterung von Variablenwerten und können beispielsweise dazu verwendet werden, bestimmte Eigenschaften oder Fähigkeiten von Klassen oder Objekten zu kennzeichnen. Ein Beispiel ist das Marker-Interface "Serializable", das angibt, dass Instanzen einer Klasse serialisierbar sind.'},
     {'question': 'Welche Rolle spielen Interfaces bei der Einschränkung des Zugriffs auf Methoden in Java?', 'answer': 'Interfaces können dazu verwendet werden, den Zugriff auf Methoden zu beschränken, da nur die im Interface definierten Methoden aufgerufen werden können. Dies ermöglicht es, verschiedene Sichten auf ein Objekt zu gewähren und den Zugriff auf bestimmte Methoden zu kontrollieren.'},
     {'question': 'Welche Rolle spielt die Java Virtual Machine (JVM) in JAVA-Programmen?', 'answer': 'Die Java Virtual Machine (JVM) interpretiert den Bytecode, der das Ergebnis der Übersetzung von JAVA-Programmen ist. Sie spielt eine entscheidende Rolle bei der Ausführung von JAVA-Programmen.'},
     {'question': 'Was ist die typische Methode, um ein JAVA-Programm auszuführen, und wie lautet ihre Signatur?', 'answer': 'Die typische Methode, um ein JAVA-Programm auszuführen, ist die "main"-Methode mit der Signatur "public static void main(String[] args)". Dies ist die Startmethode für JAVA-Anwendungen.'},
     {'question': 'Was ist ein wichtiges Merkmal des Programmiermodells von JAVA in Bezug auf die Namenskonvention von Klassen?', 'answer': 'Ein wichtiges Merkmal des Programmiermodells von JAVA ist, dass Klassennamen immer großgeschrieben werden sollen.'},
     {'question': 'Welches Problem ergibt sich bei der Erweiterung von Interfaces, wenn man keine abstrakten Klassen verwendet?', 'answer': 'Bei der Erweiterung von Interfaces, insbesondere wenn diese von Anwendungsklassen implementiert werden, entsteht das Problem, dass die Klassen, die diese Interfaces implementieren, aktualisiert werden müssen. Dies kann zu Schwierigkeiten führen, insbesondere wenn die Entwicklung dieser Klassen in den Händen Dritter liegt.'},
     {'question': 'Welchen Zusammenhang gibt es zwischen Klassen und Dateien in JAVA, und warum dürfen mehrere Klassen nicht als "public" deklariert werden?', 'answer': 'In JAVA entspricht normalerweise jede Datei der Definition einer Klasse mit dem gleichen Namen wie der Dateiname (ohne Erweiterung). Es ist möglich, mehrere Klassen in einer Datei zu definieren, aber keine dieser Klassen darf als "public" deklariert werden. Dies liegt an Konventionen, die die meisten integrierten Entwicklungsumgebungen und Versionsverwaltungssysteme unterstützen. In der Regel sollte jede Datei eine öffentliche Klasse mit demselben Namen enthalten.'},
     {'question': 'Welche Konvention wird in JAVA verwendet, um den Typ bei Deklarationen anzugeben, und wie unterscheidet sich dies von STRONGTALK?', 'answer': 'In JAVA wird der Typ bei Deklarationen ohne spitze Klammern vorangestellt. Dies unterscheidet sich von STRONGTALK, bei dem die spitzen Klammern in Deklarationen verwendet werden. In JAVA folgt die Typangabe der Tradition von C und C++.'},
     {'question': 'Was ist das Reflection API in JAVA und wofür wird es verwendet?', 'answer': 'Das Reflection API in JAVA ermöglicht den Zugriff auf die Elemente eines Programms, obwohl nicht alles in JAVA ein Objekt ist. Es stellt Klassen zur Verfügung, die verschiedene Programmelemente repräsentieren, wie Methoden (Klasse Method) oder Felder (Klasse Field). Dies ermöglicht es, Programmierung auf einer höheren Ebene durchzuführen, indem man dynamisch auf Programmstrukturen zugreift. Eine ausführliche Untersuchung dieses APIs wird im Kurs 01853 ("Moderne Programmiertechniken und -methoden") behandelt.'},
     {'question': 'Was sind Annotationen in JAVA und welche Rolle spielen sie in der Metaprogrammierung?', 'answer': 'Annotationen in JAVA sind eine Form der Metaprogrammierung, bei der Programmmetadaten den Programmelementen im Quelltext zugeordnet werden. Diese Metadaten können während der Übersetzung und/oder während der Ausführung des Programms abgefragt werden und den jeweiligen Prozess beeinflussen oder steuern. In JAVA 5 wurden Annotationen als eine spezielle Art von Interfaces eingeführt, die jedoch keine Methoden, sondern nur Felder deklarieren. Annotationen werden häufig verwendet, um zusätzliche Informationen oder Konfigurationen zu einem Programm hinzuzufügen.'},
     {'question': 'Was ist ein Modul in der Programmierung und wie ist seine Schnittstelle definiert?', 'answer': 'Ein Modul ist eine Einheit von Programmelementen, deren Funktion von außen, z. B. von anderen Modulen, nur über die Schnittstelle des Moduls zugänglich ist. Die Schnittstelle definiert, welche Teile des Moduls öffentlich sichtbar sind.'},
     {'question': 'Welche Trennung gibt es in JAVA zwischen Operationen und Methoden?', 'answer': 'In JAVA gibt es eine Trennung zwischen Operationen, die auf primitiven Typen fest vorgegeben sind, und Methoden, die in Klassen definiert werden müssen.'},
     {'question': 'Welcher Operator steht speziell für Referenztypen in JAVA zur Verfügung?', 'answer': 'Ein Operator, der speziell für Referenztypen in JAVA zur Verfügung steht, ist der Typtest "instanceof". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist.'},
     {'question': 'Welche Funktionen haben Klassen in JAVA?', 'answer': 'Klassen in JAVA dienen als Vorlagen für die Erzeugung von Objekten, liefern Typen für ein Programm und dienen der Modularisierung.'},
     {'question': 'Was sind Zugriffsmodifikatoren in JAVA?', 'answer': 'Zugriffsmodifikatoren (access modifiers) sind in JAVA Schlüsselwörter wie private, protected, public und "Package local," die die Zugriffsbeschränkungen für Klassen, Typen und deren Elemente festlegen. Sie regeln, welche Teile einer Klasse von anderen Klassen aus zugänglich sind.'},
     {'question': 'Welche Auswirkungen haben die Zugriffsbeschränkungen in JAVA?', 'answer': 'Die Zugriffsbeschränkungen in JAVA regeln, welche Teile einer Klasse oder eines Typs von anderen Klassen oder Typen aus zugänglich sind. Sie beeinflussen die Sichtbarkeit von Variablen, Methoden und anderen Elementen innerhalb einer Klasse und zwischen Klassen, insbesondere in verschiedenen Paketen.'},
     {'question': 'Was sind die konkreten Auswirkungen der Zugriffsbeschränkungen in JAVA?', 'answer': 'Die Zugriffsbeschränkungen in JAVA wirken sich auf die Sichtbarkeit von Elementen innerhalb von Klassen und zwischen Klassen aus. Sie regeln, welche Teile eines Moduls von anderen Modulen aus sichtbar sind und können durch Hiding, Shadowing und Obscuring weiter eingeschränkt werden. Die Verknüpfung von Typ und Zugriffsbeschränkung ist in JAVA etabliert und ermöglicht die Deklaration von Typen und Schnittstellen in einem.'},
     {'question': 'Welche Arten von Literale gibt es in JAVA?', 'answer': 'In JAVA gibt es Literale für Zahlen, Zeichen und Strings.'},
     {'question': 'Welche drei besonderen Werte im Fließkommabereich haben keine Literale, sondern nur Konstanten in JAVA?', 'answer': 'Die drei besonderen Werte im Fließkommabereich, die keine Literale, sondern nur Konstanten in JAVA haben, sind "NaN" (Not a Number), "POSITIVE_INFINITY" und "NEGATIVE_INFINITY".'},
     {'question': 'Welcher Typ hat ein Klassenliteral in JAVA?', 'answer': 'Der Typ eines Klassenliterals in JAVA ist "Class<T>", wobei T der Typ der Klasse ist. Zum Beispiel hat "Class<Object>" den Typ "Class<Object>".'},
     {'question': 'Welche Art von Typprüfungen kann Java zur Übersetzungszeit durchführen?', 'answer': 'Java kann zur Übersetzungszeit statische Typprüfungen durchführen.'},
     {'question': 'Welche gelegentlichen Typprüfungen erfordern dynamische Typprüfungen in Java?', 'answer': 'Gelegentliche Typprüfungen, die dynamische Typprüfungen in Java erfordern, sind insbesondere Typumwandlungen (Type casts).'},
     {'question': 'Welches Schlüsselwort verwendet JAVA, um die Bestehen einer Subklassenbeziehung zwischen zwei Klassen zu deklarieren?', 'answer': 'JAVA verwendet das Schlüsselwort "extends," um die Bestehen einer Subklassenbeziehung zwischen zwei Klassen zu deklarieren.'},
     {'question': 'Was ist ein Interface in JAVA und wie wird es deklariert?', 'answer': 'Ein Interface in JAVA ist eine eigenständige Schnittstellendeklaration, die von einer Klasse unabhängig ist, aber genauso wie eine Klasse einen Typ definiert. Interfaces werden mit dem Schlüsselwort "interface" deklariert.'},
     {'question': 'Welche Unterschiede gibt es zwischen der Deklaration eines Interfaces und einer Klasse?', 'answer': 'Die Unterschiede zwischen der Deklaration eines Interfaces und einer Klasse sind: Verwendung des Schlüsselworts "interface" anstelle von "class". Fehlen von Felddeklarationen in Interfaces. In Interfaces folgt auf die Methodendeklaration lediglich ein abschließendes Semikolon, ohne Implementierung.'},
     {'question': 'Welchen Vorteil bietet die Verwendung von Interfaces bei der Verwendung von Variablen?', 'answer': 'Die Verwendung von Interfaces ermöglicht es, Methoden und Felder einer Instanz vor anderen Instanzen zu verbergen. Durch die Deklaration von Variablen mit dem Interface als Typ kann der Zugriff auf bestimmte Methoden und Felder beschränkt werden.'},
     {'question': 'Welche Beziehung müssen die Typen in JAVA haben, damit Ausdrücke von einem Typ Variablen eines anderen Typs zugewiesen werden können?', 'answer': 'Damit Ausdrücke von einem Typ Variablen eines anderen Typs zugewiesen werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen ihnen bestehen.'},
     {'question': 'Was ist nominale Typkonformität, und welche Vor- und Nachteile hat sie?', 'answer': 'Nominale Typkonformität bedeutet, dass die Subtypbeziehung explizit deklariert werden muss. Dies hat den Vorteil der Filterfunktion, aber den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen, was bei verteilten Anwendungen problematisch sein kann.'},
     {'question': 'Welche Anforderung stellt JAVA an geerbte Variablen (Felder und Parametertypen von Methoden)?', 'answer': 'JAVA verlangt, dass die Typen geerbter Variablen nicht verändert werden dürfen. Dies wird als Kovarianz bezeichnet.'},
     {'question': 'Was sind Konstruktoren in JAVA, und wie verhalten sie sich im Vergleich zu SMALLTALK?', 'answer': 'Konstruktoren in JAVA sind spezielle Methoden, die zur Erzeugung von Objekten verwendet werden. Im Gegensatz zu SMALLTALK sind Konstruktoren in JAVA keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Sie verhalten sich wie Instanzmethoden und können auf alle Felder und Methoden der neu erzeugten Instanz zugreifen.'},
     {'question': 'Was sind Factory-Methoden in JAVA, und wie werden sie verwendet?', 'answer': 'Factory-Methoden sind Klassenmethoden in JAVA, die zur Erzeugung von Objekten verwendet werden können. Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben. Factory-Methoden ermöglichen eine flexible Objekterzeugung und werden oft in Bibliotheken und Frameworks eingesetzt.'},
     {'question': 'Was ist Exception Handling in JAVA?', 'answer': 'Exception Handling ist eine Möglichkeit in JAVA, mögliche Ausnahmesituationen und deren Behandlung bei der Spezifikation des Kontrollflusses eines Programms vorübergehend zu vernachlässigen und so zu tun, als würde immer alles gutgehen. Ausnahmesituationen werden in JAVA in Form von Exception-Klassen dargestellt.'},
     {'question': 'Was sind Checked Exceptions in JAVA?', 'answer': 'Checked Exceptions sind Ausnahmesituationen, bei denen die Programmierer sich der möglichen Ausnahmesituationen bewusst sein müssen. Sie erfordern eine Deklaration im Methodenkopf oder müssen innerhalb der Methode behandelt werden. Diese Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind.'},
     {'question': 'Was sind Unchecked Exceptions in JAVA?', 'answer': 'Unchecked Exceptions sind Ausnahmesituationen, die in der Praxis überall auftreten können. Sie erfordern keine explizite Deklaration im Methodenkopf und können überall auftreten. Unchecked Exceptions werden von Exception-Klassen abgeleitet, die von RuntimeException abgeleitet sind.'},
     {'question': 'Welche Initiative wurde von der JAVA-Community aufgegriffen, um die Situation mit aufgeteilten Paketen zu verbessern?', 'answer': 'Die JAVA-Community griff die Open Services Gateway Initiative (OSGi) auf, um die Situation mit aufgeteilten Paketen zu verbessern. OSGi ermöglichte die Zusammenfassung von JAVA-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation.'},
     {'question': 'Was ist der qualifizierte Export in der Moduldefinition von JAVA?', 'answer': 'Der qualifizierte Export in der Moduldefinition von JAVA ist ähnlich wie in EIFFEL. Er nennt die Module, an die exportiert wird, namentlich und erlaubt einen "privaten" Austausch zwischen bestimmten Modulen, die somit ihre eigenen, privaten Schnittstellen haben.'},
     {'question': 'Was ist das Besondere an der Moduldefinition von JAVA in Bezug auf die Einhaltung der Schnittstellenspezifikationen?', 'answer': 'Die Moduldefinition von JAVA erzwingt die Einhaltung der Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit. Sie kontrolliert auch den reflektiven Zugriff auf Programmelemente, was zu einer erheblichen Verbesserung der Sicherheit von JAVA-Programmen führt.'},
     {'question': 'Welche Möglichkeit zur Iteration von Collection-Klassen kennen Sie aus SMALLTALK?', 'answer': 'In SMALLTALK gibt es die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren, was als interne Iteration bezeichnet wird.'},
     {'question': 'Welche neuen Funktionen wurden in JAVA 8 eingeführt, um interne Iterationen zu ermöglichen?', 'answer': 'In JAVA 8 wurden (anonyme) Funktionen, auch bekannt als Lambda-Ausdrücke, eingeführt, um interne Iterationen à la SMALLTALK zu ermöglichen.'},
     {'question': 'Welches Framework wurde für die Implementierung der Methoden forEach, filter, map und reduce in JAVA 8 geschaffen?', 'answer': 'Für die Implementierung der Methoden forEach, filter, map und reduce in JAVA 8 wurde das Stream-Framework geschaffen.'},
     {'question': 'Welche Vorteile bietet das Stream-Framework von JAVA im Vergleich zu naiven Implementierungen von Pipelines?', 'answer': 'Das Stream-Framework von JAVA ermöglicht für viele Pipelines eine besonders effiziente Ausführung. Es minimiert die Anzahl der Iterationen, reduziert die interne Speicherung von Zwischenergebnissen und erlaubt die Auswahl zwischen paralleler und sequenzieller Verarbeitung der Pipeline. Dennoch ist die Performanz von JAVA-Pipelines nicht leicht vorherzusagen und erfordert Erfahrung und Kenntnisse der Implementierung.'},
     {'question': 'Was ist die Hauptanwendung generischer Typen in Java?', 'answer': 'Eine Hauptanwendung generischer Typen in Java ist die Arbeit mit Collections, um den Typ der Elemente in der Collection anzugeben und so die Typsicherheit zu erhöhen.'},
     {'question': 'Welche Konvention wird häufig verwendet, um Typparameter von Klassen- und Variablennamen zu unterscheiden?', 'answer': 'Eine häufig verwendete Konvention ist es, einzelne Großbuchstaben für Typparameter zu wählen. Zum Beispiel steht "E" üblicherweise für den Elementtyp von Containern wie Collections.'},
     {'question': 'Was ist rekursiv beschränkter parametrischer Polymorphismus in Java?', 'answer': 'Rekursiv beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Möglichkeit, Beschränkungen für Typparameter auf eine Weise zu definieren, die auf sich selbst oder andere Typparameter verweist.'},
     {'question': 'Welche Typkonstruktoren gab es in JAVA bis zur Version 1.4?', 'answer': 'Bis JAVA 1.4 gab es die Typkonstruktoren class, interface und [] (Array).'},
     {'question': 'Welcher Typkonstruktor wurde in JAVA 1.5 für Aufzählungstypen hinzugefügt?', 'answer': 'In JAVA 1.5 wurde der Typkonstruktor enum für Aufzählungstypen hinzugefügt.'},
     {'question': 'Welche Art von Typen sind Aufzählungstypen in JAVA?', 'answer': 'Aufzählungstypen in JAVA sind Klassentypen. Sie können neben den Aufzählungselementen auch Felder und Methoden enthalten.'},
     {'question': 'Was ist das Symbol für eine Typ-Wildcard in Java?', 'answer': 'Das Symbol für eine Typ-Wildcard in Java ist das Fragezeichen (?).'},
     {'question': 'Was ist die Verwendung von "extends" und "super" in Verbindung mit Typ-Wildcards?', 'answer': '"extends" wird verwendet, um eine obere Schranke für Typ-Wildcards anzugeben, während "super" verwendet wird, um eine untere Schranke anzugeben. Mit "extends" beschränkte Wildcard-Typen sind kovariant, und mit "super" beschränkte Wildcard-Typen sind kontravariant.'},
     {'question': 'Welche Einschränkung gibt es bei der Verwendung von "super" beschränkten Typ-Wildcards?', 'answer': 'Bei "super" beschränkten Typ-Wildcards ist der Zugriff auf Elemente in der Regel auf schreibende Zugriffe beschränkt, und lesende Zugriffe haben immer den Typ "Object".'},
     {'question': 'Welche Art von Subtyping wird bei "extends" beschränkten Wildcard-Typen verwendet?', 'answer': '"extends" beschränkte Wildcard-Typen verwenden kovariantes Subtyping.'},
     {'question': 'Welche Art von Subtyping wird bei "super" beschränkten Wildcard-Typen verwendet?', 'answer': '"super" beschränkte Wildcard-Typen verwenden kontravariantes Subtyping.'},
     {'question': 'Was sind generische Typen in Java?', 'answer': 'Generische Typen in Java sind Typdefinitionen, die Typvariablen verwenden, um die Referenzierung eines oder mehrerer Typen innerhalb der Definition zu abstrahieren.'},
     {'question': 'Welche Merkmale von C++ und SMALLTALK wurden in JAVA übernommen?', 'answer': 'In JAVA wurden weite Teile der Syntax und der statischen Typüberprüfung von C++ übernommen. Außerdem wurde der eher klassisch prozedurale Charakter von C++ beibehalten, wobei Methodenaufrufe anstelle von Nachrichtenversand verwendet werden. Von SMALLTALK wurden die umfassende Objektorientierung (es gibt keinen Code außerhalb von Klassen), die Einfachvererbung sowie die Garbage Collection übernommen.'},
     {'question': 'Was sind Instanzvariablen in Java?', 'answer': 'Instanzvariablen in Java sind Felder, die zur Speicherung von Daten in einer Klasse verwendet werden. Jede Instanz der Klasse hat ihre eigenen Kopien dieser Variablen.'},
     {'question': 'Was sind Instanzmethoden in Java?', 'answer': 'Instanzmethoden in Java sind Methoden, die auf Instanzen (Objekten) einer Klasse angewendet werden können. Sie definieren das Verhalten der Klasse.'},
     {'question': 'Was sind "Member" in Bezug auf Klassendefinitionen in Java?', 'answer': '"Member" ist ein zusammenfassender Begriff für Felder und Methoden innerhalb einer Klassendefinition in Java.'},
     {'question': 'Welche weiteren Arten von Klassendefinitionen sind in Java möglich?', 'answer': 'In Java können Sie auch geschachtelte Klassendefinitionen und innere Klassendefinitionen erstellen, die ebenfalls als Members der umschließenden Klasse gelten.'},
     {'question': 'Welche Arten von Ausdrücken gibt es in JAVA?', 'answer': 'In JAVA gibt es verschiedene Arten von Ausdrücken, darunter Literale, Variablen, Methodenaufrufe, Operatoranwendungen, Feldzugriffe, Klasseninstanziierungen, Array-Instanziierungen, Konditionalausdrücke, Cast-Ausdrücke und Lambda-Ausdrücke.'},
     {'question': 'Welche Typisierungsanforderungen gelten für Ausdrücke in JAVA?', 'answer': 'In JAVA müssen alle Ausdrücke korrekt typisiert sein. Das bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks übereinstimmen muss, an der Stelle, an der er eingesetzt wird.'},
     {'question': 'Welche Rolle spielen Lambda-Ausdrücke in JAVA, und wie unterscheiden sie sich von anonymen inneren Klassen?', 'answer': 'Lambda-Ausdrücke in JAVA, die in Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Sie ermöglichen die Darstellung von Funktionen als Werte und werden häufig für die Implementierung von Schnittstellen mit nur einer Methode (Funktionale Interfaces) verwendet. Im Gegensatz dazu verwenden anonyme innere Klassen explizite Klassendefinitionen, um Schnittstellen zu implementieren.'},
     {'question': 'Welche Arten von Typumwandlungen gibt es in Java?', 'answer': 'In Java gibt es drei Arten von Typumwandlungen: Up casts, Down casts und Cross casts.'},
     {'question': 'Was ist ein Up cast?', 'answer': 'Ein Up cast tritt auf, wenn der Zieltyp ein Supertyp des Ausgangstyps ist.'},
     {'question': 'Was ist ein Down cast?', 'answer': 'Ein Down cast tritt auf, wenn der Zieltyp ein Subtyp des Ausgangstyps ist.'},
     {'question': 'Was ist ein Cross cast?', 'answer': 'Ein Cross cast tritt auf, wenn Zieltyp und Ausgangstyp keine Subtypenbeziehung zueinander haben und nebeneinander stehen.'},
     {'question': 'Welche Art von Typumwandlung ist immer sicher?', 'answer': 'Ein Up cast ist immer sicher, da jedes Objekt neben seinem Typ auch den Typ all seiner Supertypen hat.'},
     {'question': 'Welche Art von Typumwandlung kann zu Laufzeittypfehlern führen?', 'answer': 'Down und Cross casts können zu Laufzeittypfehlern führen, wenn das Objekt, zu dem der typumgewandelte Ausdruck ausgewertet wird, nicht den Zieltyp oder einen Subtyp davon hat. Dies kann zur Laufzeit zu ClassCastException-Fehlern führen.'},
     {'question': 'Welche Bedeutung haben Interfaces und Module in JAVA?', 'answer': 'Interfaces und Module sind in JAVA eng miteinander verknüpft und dienen dazu, die Schnittstellen und die Modularisierung von Klassen und Programmen zu definieren.'},
     {'question': 'Welche Rolle spielen Interfaces in der objektorientierten Programmierung?', 'answer': 'Interfaces spielen in der objektorientierten Programmierung eine wichtige Rolle, da sie dazu dienen, Schnittstellen zu definieren, über die Klassen miteinander kommunizieren können. Sie ermöglichen die Implementierung von Methoden in verschiedenen Klassen und erlauben die Implementierung von Polymorphismus.'},
     {'question': 'Was ist die Besonderheit von JAVAs Interfaces?', 'answer': 'JAVAs Interfaces sind eigenständige Konstrukte, die über die ursprüngliche Bedeutung hinausgehen und weitreichende Möglichkeiten zur Definition von Schnittstellen und zur Entwicklung objektorientierter Programmiersprachen bieten.'},
     {'question': 'Welche Formen von Abhängigkeiten gibt es in den Klassen als Modulen der JAVA-Programmierung?', 'answer': 'In den Klassen als Modulen der JAVA-Programmierung gibt es zwei Formen von Abhängigkeiten: Eine Klasse hängt von einer anderen ab, wenn auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich durch die Deklaration von Variablen des entsprechenden Typs und gegebenenfalls durch das Importieren der Klasse oder des Pakets, in dem sich die andere Klasse befindet. Eine Klasse bietet einige ihrer Member zur Benutzung durch andere Klassen an und diese werden dadurch von ihr abhängig. Dies erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht privat sind, sowie an der Implementierung von Interfaces.'},
     {'question': 'Welche Arten von Abhängigkeiten können zwischen Klassen und Paketen in JAVA entstehen?', 'answer': 'In JAVA können Vererbungsabhängigkeiten zwischen Klassen auftreten, die nicht zirkulär sind. Bei der Ausdehnung der Abhängigkeiten auf Pakete können jedoch auch zirkuläre Abhängigkeiten zwischen Paketen entstehen.'},
     {'question': 'Welches Schlüsselwort wird in Java für Typtests verwendet?', 'answer': 'Das Schlüsselwort für Typtests in Java lautet "instanceof".'},
     {'question': 'Welche Vorteile bieten Typtests in Kombination mit bedingten Umwandlungen?', 'answer': 'Typtests in Kombination mit bedingten Umwandlungen bilden die typsichere Variante der Typumwandlung und helfen, Laufzeitfehler zu vermeiden.'},
     {'question': 'Was ist die Sichtbarkeit von Typparametern in Methodendefinitionen?', 'answer': 'Die Sichtbarkeit von Typparametern in Methodendefinitionen ist auf die jeweilige Methode beschränkt.'},
     {'question': 'Was ist Typinferenz in Bezug auf generische Methoden?', 'answer': 'Typinferenz in Bezug auf generische Methoden bezieht sich auf die Fähigkeit des Java-Compilers, den tatsächlichen Typparameter wegzulassen, wenn er sich aus dem Kontext des Methodenaufrufs ableiten kann.'},
     {'question': 'Welche Vorteile bietet die Verwendung von Typinferenz bei generischen Methoden?', 'answer': 'Die Verwendung von Typinferenz bei generischen Methoden erleichtert die Verwendung, da der tatsächliche Typparameter nicht immer explizit angegeben werden muss, was den Code lesbarer macht.'},
     {'question': 'Welche Arten von Anweisungen gibt es in JAVA?', 'answer': 'In JAVA gibt es verschiedene Arten von Anweisungen, darunter Variablendeklarationen, Wertzuweisungen, Methodenaufrufe, Klasseninstanziierungen und Kontrollstrukturen wie If-Anweisungen, Schleifen, Switch-Anweisungen, Try-Anweisungen und mehr.'},
     {'question': 'Welche Arten von Schleifen werden in JAVA unterstützt?', 'answer': 'JAVA unterstützt While-Schleifen, Do-Schleifen, For-Schleifen und die erweiterte For-Schleife. Dabei wird While-Schleife verwendet, um Anweisungen solange auszuführen, wie eine Bedingung wahr ist. Do-Schleife ist ähnlich, aber die Bedingung wird erst nach der Ausführung überprüft. For-Schleifen ermöglichen die explizite Initialisierung, Bedingung und Veränderung der Schleifenvariable. Die erweiterte For-Schleife iteriert über die Elemente eines Arrays oder Objekts, das Iterable implementiert.'},
     {'question': 'Was ist der Zweck der Assert-Anweisung in JAVA?', 'answer': 'Die Assert-Anweisung in JAVA dient dazu, bestimmte Bedingungen im Programm zu überprüfen. Wenn die Bedingung zu false ausgewertet wird, wird das Programm mit einer entsprechenden Fehlermeldung abgebrochen. Die Assert-Anweisung kann auch ein optionales Ergebnis liefern, das in der Fehlermeldung angezeigt wird. Sie eignet sich zur Überprüfung von Invarianten zur Laufzeit.'},
     {'question': 'Welche Semantik haben Variablen in JAVA, und wie wird dies bestimmt?', 'answer': 'Variablen in JAVA haben entweder Referenzsemantik oder Wertsemantik, je nach ihrem Typ. Primitive Typen wie byte, short, int, usw., haben Wertsemantik. Andere Typen haben Referenzsemantik.'},
     {'question': 'Was ist "Auto boxing" und "Auto unboxing" in JAVA?', 'answer': 'Seit JAVA 5 können Werte primitiven Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man "Auto boxing" für das Verpacken in Wrapper-Typen und "Auto unboxing" für das Entpacken.'},
     {'question': 'Welche Vorsichtsmaßnahmen müssen bei "Auto boxing" und "Auto unboxing" in JAVA getroffen werden?', 'answer': 'Bei "Auto boxing" und "Auto unboxing" in JAVA ist Vorsicht geboten, da unerwartete Ergebnisse auftreten können. Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte, um Programmierfehler zu vermeiden.'},
     {'question': 'Was sind die sechs Arten von Typen, die in JAVA unterschieden werden?', 'answer': 'In JAVA werden die folgenden sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen.'},
     {'question': 'Welche primitiven Typen sind in JAVA definiert?', 'answer': 'In JAVA sind die folgenden primitiven Typen definiert: byte, short, int, long, float, double, boolean und char.'},
     {'question': 'Was sind Wrapper-Typen in JAVA und wofür werden sie verwendet?', 'answer': 'Wrapper-Typen in JAVA sind Referenztypen, die jeweils einen Wert eines entsprechenden primitiven Typs aufnehmen können. Sie werden verwendet, um primitiven Typen eine Objekthülle zu geben und sie in Situationen zu verwenden, die Referenztypen erfordern.'},
     {'question': 'Welche vordefinierten Typen sind in der JAVA-Sprachdefinition bereits festgelegt?', 'answer': 'In der JAVA-Sprachdefinition sind folgende vordefinierte Typen festgelegt: Object, String, Throwable, Error, Exception, RuntimeException und Thread.'},
     {'question': 'Was sind Literale in JAVA, und wie werden sie verwendet?', 'answer': 'Literale in JAVA sind Werte wie Zahlen, Zeichen und Wahrheitswerte, die direkt in den Code geschrieben werden können, ohne sie durch Instanziierung von Klassen zu erzeugen. Literale sind eine Möglichkeit, Objekte in JAVA zu erstellen.'},
     {'question': 'Was ist beschränkter parametrischer Polymorphismus in Java?', 'answer': 'Beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Einschränkung der möglichen Typen, die für einen Typparameter einer generischen Klasse verwendet werden können. Dies geschieht durch das Festlegen von Beschränkungen oder Bedingungen für den Typparameter.'},
     {'question': 'Welche Art von Typvariablen können in generischen Variablen verwendet werden?', 'answer': 'In generischen Variablen können anonyme Typvariablen, also Wildcards, verwendet werden.'},
     {'question': 'Welche Einschränkungen gelten für generische Variablen mit Typ-Wildcards?', 'answer': 'Generische Variablen mit Typ-Wildcards unterliegen den im Abschnitt 43.2 genannten Einschränkungen, insbesondere in Bezug auf die Verwendung von Wildcards mit oberen und unteren Schranken.'},
     {'question': 'Welche Methode wird in JAVA verwendet, um die Gleichheit von Objekten zu prüfen?', 'answer': 'In JAVA wird die Methode equals(.) verwendet, um die Gleichheit von Objekten zu prüfen.'},
     {'question': 'Welche Klasse erbt die Methode equals(.) in JAVA?', 'answer': 'Die Methode equals(.) wird von der Klasse Object geerbt, die in JAVA die Superklasse aller Klassen ist.'},
     {'question': 'Was sind Threads in JAVA und wie unterscheiden sie sich von Prozessen?', 'answer': 'Threads in JAVA sind parallele Ausführungsstränge, während Prozesse in der Regel eigenständige Programme mit separater Ressourcenallokation sind. Threads sind leichtgewichtiger und teilen sich Ressourcen innerhalb eines Prozesses. Bei Threads müssen die Synchronisationsmechanismen selbst implementiert werden, während Prozesse in Betriebssystemen über die Inter-Prozess-Kommunikation reguliert werden.'},
     {'question': 'Was ist ein Monitor in Bezug auf Threads in JAVA?', 'answer': 'Ein Monitor in Bezug auf Threads in JAVA ist ein Mechanismus, der dazu dient, die Synchronisation von Threads zu ermöglichen. Jedes Objekt in JAVA ist mit einem Monitor verknüpft. Wenn ein Thread einen Monitor eines Objekts sperrt ("lockt"), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.'},
     {'question': 'Welche Besonderheiten gibt es bei mehrdimensionalen Arrays in JAVA?', 'answer': 'In JAVA können mehrdimensionale Arrays geschachtelt werden, wobei die Größen der Dimensionen nicht für jedes Element der ersten Dimension gleich sein müssen.'}],
    [{'question': 'Wie wurde der Fehler bezüglich unnötig langer Bezeichner in Iterationen mit JAVA 5 korrigiert?', 'answer': 'Der Fehler bezüglich unnötig langer Bezeichner in Iterationen wurde mit JAVA 5 korrigiert, indem die "for"-Schleife um eine vereinfachte Schreibweise für die externe Iteration über Collections ergänzt wurde.'},
     {'question': 'Wie wird das dynamische Binden in JAVA durchgeführt, und warum ist es wichtig zu verstehen?', 'answer': 'Das dynamische Binden in JAVA erfolgt zur Laufzeit, wenn der tatsächliche Typ des Empfängerobjekts bestimmt wird, um die entsprechende Methode auszuwählen. Es ist wichtig zu verstehen, da es das Verhalten eines Programms beeinflusst und zur Vorhersage des Programmverhaltens beiträgt.'},
     {'question': 'Wie können Interfaces in Java dazu beitragen, die Austauschbarkeit von Klassen zu verbessern?', 'answer': 'Interfaces ermöglichen es, verschiedene Implementierungen eines Interfaces zu verwenden, ohne den zugrunde liegenden Klassentyp zu spezifizieren. Dies verbessert die Austauschbarkeit von Klassen, da verschiedene Klassen, die dasselbe Interface implementieren, in derselben Weise verwendet werden können.'},
     {'question': 'Wie erfolgt die Ausführung eines JAVA-Programms auf Betriebssystemebene?', 'answer': 'Die Ausführung eines JAVA-Programms auf Betriebssystemebene erfolgt, indem man der JVM den Namen der Klasse als Parameter übergibt. Zum Beispiel: "java MeineKlasse".'},
     {'question': 'Wie erfolgt in JAVA das Deployment von Anwendungen?', 'answer': 'In JAVA erfolgt das Deployment von Anwendungen oft durch die Verteilung von sogenannten JAVA Archiven (.jar-Dateien). Zur Ausführung ist jedoch eine Installation der JVM erforderlich.'},
     {'question': 'Wie wurde das Problem der Erweiterung von Interfaces in JAVA 8 gelöst?', 'answer': 'In JAVA 8 wurde das Problem der Erweiterung von Interfaces gelöst, indem Interfaces die Implementierung von Methoden durch das Schlüsselwort "default" vorgeben konnten. Dadurch konnten zusätzliche Methoden in Interfaces hinzugefügt werden, ohne die implementierenden Klassen zu zwingen, sie zu implementieren.'},
     {'question': 'Wie wird ein Typ in JAVA aus einer Klassendefinition abgeleitet?', 'answer': 'In JAVA spezifiziert jede Klasse ihren eigenen Typ. Der Typ trägt denselben Namen wie die Klasse und enthält Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften.'},
     {'question': 'Wie wurden Module in JAVA bis zur Version 8 simuliert?', 'answer': 'In JAVA wurden Module bis zur Version 8 mehr oder weniger gut durch Klassen und Pakete simuliert.'},
     {'question': 'Wie kann auf Klassen und Typen in unterschiedlichen Paketen in JAVA zugegriffen werden?', 'answer': 'Um auf Klassen und Typen in verschiedenen Paketen zuzugreifen, müssen in JAVA explizite Import-Deklarationen verwendet werden, die die jeweiligen Paketnamen nennen. Pakete ermöglichen keinen privilegierten Zugriff auf Klassen ihrer Subpakete.'},
     {'question': 'Wie werden Zeichenliterale und String-Literale in JAVA dargestellt?', 'answer': 'Zeichenliterale werden in JAVA durch einfache Anführungsstriche (\' \') eingeschlossen, während String-Literale durch doppelte Anführungsstriche (" ") eingeschlossen werden.'},
     {'question': 'Wie gibt man in JAVA den Typ einer Klasse als Wert an?', 'answer': 'In JAVA gibt man den Typ einer Klasse als Wert mittels eines sogenannten Klassenliterals an. Dieses besteht aus dem Namen der Klasse, gefolgt von ".class", z. B. "Klasse.class".'},
     {'question': 'Wie werden abstrakte Methoden in JAVA deklariert, und wie werden sie in Subklassen implementiert?', 'answer': 'Abstrakte Methoden in JAVA werden deklariert, indem man hinter der Methodensignatur ein abschließendes Semikolon setzt, anstatt eine Implementierung anzugeben. In Subklassen müssen abstrakte Methoden mit Implementierungen versehen werden, andernfalls gibt der Compiler eine Fehlermeldung aus.'},
     {'question': 'Wie kann in JAVA verhindert werden, dass von einer Klasse abgeleitet wird?', 'answer': 'In JAVA kann verhindert werden, dass von einer Klasse abgeleitet wird, indem man das Schlüsselwort "final" vor der Klassendefinition verwendet.'},
     {'question': 'Wie gibt eine Klasse an, dass sie ein Interface implementiert, und welche Verpflichtung ergibt sich daraus?', 'answer': 'Eine Klasse gibt an, dass sie ein Interface implementiert, indem sie das Schlüsselwort "implements" verwendet, gefolgt vom Namen des Interfaces. Die Klasse verpflichtet sich, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten.'},
     {'question': 'Wie können Interfaces in Variablendeklarationen verwendet werden?', 'answer': 'Interfaces können in Variablendeklarationen als Typen verwendet werden. Der Type Checker garantiert dann, dass auf der Variable nur die Methoden aufgerufen werden können, die im Interface deklariert sind, selbst wenn das Objekt, das die Variable referenziert, mehr Methoden anbietet.'},
     {'question': 'Wie werden Konstruktoren in JAVA aufgerufen?', 'answer': 'In JAVA werden Konstruktoren aufgerufen, indem der Klassenname gefolgt von den Konstruktorargumenten verwendet wird, z.B., "new MeineKlasse(argumente)".'},
     {'question': 'Wie unterscheiden sich Streams von Collections in JAVA?', 'answer': 'Streams unterscheiden sich von Collections in JAVA dadurch, dass sie keine Datenspeicher sind, sondern interne Iteratoren. Jeder Stream hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen.'},
     {'question': 'Wann liefert eine Stream-Pipeline in JAVA ein Ergebnis?', 'answer': 'Eine Stream-Pipeline in JAVA liefert ein Ergebnis immer erst durch einen sogenannten Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert, beispielsweise eine Collection im Falle von collect.'},
     {'question': 'Wie werden parametrische (generische) Typen in Java definiert?', 'answer': 'Parametrische (generische) Typen in Java werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Die formalen Typparameter in der Klassendefinition können durch verschiedene Typen ersetzt werden.'},
     {'question': 'Wie können Typ-Wildcards in Java zur Verbesserung der Typsicherheit verwendet werden?', 'answer': 'Typ-Wildcards können verwendet werden, um sicherzustellen, dass Zuweisungen und Zugriffe auf generische Typen zur Übersetzungszeit statisch typsicher sind, ohne dass es zu Laufzeitfehlern kommt. Dies erhöht die Typsicherheit von Java-Programmen.'},
     {'question': 'Wie können Typ-Wildcards in Java dazu verwendet werden, eine Liste von Zahlen oder Untertypen von "Number" zu verarbeiten?', 'answer': 'Typ-Wildcards können verwendet werden, um eine Methode wie "sum(List<? extends Number> list)" zu erstellen, die eine Liste von Zahlen oder Untertypen von "Number" akzeptiert und die Summe der Zahlen berechnet, unabhängig von ihrem konkreten Typ.'},
     {'question': 'Wie werden Typvariablen in Java generischen Typen dargestellt?', 'answer': 'In Java werden Typvariablen in generischen Typen in spitzen Klammern dargestellt.'},
     {'question': 'Wie sieht eine einfache Klassendefinition in Java aus?', 'answer': 'Eine einfache Klassendefinition in Java besteht aus dem Klassennamen, der Angabe von Instanzvariablen (Felder) und Instanzmethoden.'},
     {'question': 'Wann werden "final"-Variablen in Java verwendet?', 'answer': '"final"-Variablen werden in Java verwendet, um Konstanten zu deklarieren. Sie dürfen nur einmal einen Wert zugewiesen bekommen und sind dann nicht mehr änderbar.'},
     {'question': 'Wie werden Ausdrücke in JAVA aufgebaut, und welche rekursiven Elemente sind dabei beteiligt?', 'answer': 'Ausdrücke in JAVA können rekursiv aus anderen Ausdrücken aufgebaut werden. Zum Beispiel enthalten Methodenausdrücke Ausdrücke für den Empfänger und die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung von Indexen oder Größen.'},
     {'question': 'Wann werden Type casts in Java verwendet?', 'answer': 'Type casts werden in Java verwendet, wenn man einem Programmelement, das einen bestimmten Typ hat, einen anderen Typ zuweisen möchte oder wenn man auf Methoden oder Felder zugreifen möchte, die nicht im deklarierten Typ verfügbar sind.'},
     {'question': 'Wie vermeidet man Laufzeitfehler bei Typumwandlungen in Java?', 'answer': 'Man vermeidet Laufzeitfehler bei Typumwandlungen in Java mithilfe von Typtests, die vor der Typumwandlung durchgeführt werden.'},
     {'question': 'Wie können Ausdrücke zu Anweisungen in JAVA gemacht werden?', 'answer': 'In JAVA können Ausdrücke zu Anweisungen gemacht werden, indem sie einfach durch ein Semikolon abgeschlossen werden. Dies gilt insbesondere für Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen.'},
     {'question': 'Wie werden Werte Variablen in JAVA zugewiesen?', 'answer': 'In JAVA werden Werte Variablen sowohl explizit per Zuweisungsoperator "=" als auch implizit per Methodenaufruf zugewiesen.'},
     {'question': 'Wie wird beschränkter parametrischer Polymorphismus in Java implementiert?', 'answer': 'In Java wird beschränkter parametrischer Polymorphismus durch das Hinzufügen von Beschränkungen für den Typparameter einer generischen Klasse oder Methode erreicht. Dies geschieht durch die Verwendung des "extends" oder "super" Schlüsselworts gefolgt von einem bestimmten Typ oder einer bestimmten Schnittstelle.'},
     {'question': 'Wie wird in JAVA zwischen Gleichheit und Identität von Objekten unterschieden?', 'answer': 'In JAVA wird zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) geprüft, während die Identität mittels == (bzw. !=) überprüft wird.'},
     {'question': 'Wie startet man einen neuen Thread in JAVA?', 'answer': 'Einen neuen Thread in JAVA startet man, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.'},
     {'question': 'Wie stellt man sicher, dass ein neuer Thread in JAVA sinnvolle Aufgaben ausführt?', 'answer': 'Es gibt zwei Möglichkeiten, sicherzustellen, dass ein neuer Thread in JAVA sinnvolle Aufgaben ausführt. Entweder man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen, oder man lässt eine Klasse das Interface Runnable implementieren und implementiert die Methode run() in dieser Klasse. Dann erzeugt man eine Instanz dieser Klasse und startet deren Methode run().'},
     {'question': 'Wie kann die Synchronisation von Threads in JAVA erzwungen werden?', 'answer': 'Die Synchronisation von Threads in JAVA kann auf zwei Arten erzwungen werden. Die erste Möglichkeit ist die Verwendung der synchronized-Anweisung, um einen synchronisierten Block zu erstellen. Die Anweisungen innerhalb dieses Blocks können nur von einem Thread gleichzeitig ausgeführt werden. Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren, wodurch die Sperre auf das zugehörige Objekt angewendet wird. Es ist wichtig zu beachten, dass Felder nicht als synchronized deklariert werden können.'},
     {'question': 'Wie erfolgt die Deklaration von Arrays in JAVA?', 'answer': 'Die Deklaration von Arrays in JAVA erfolgt implizit in Variablendeklarationen, wobei die Größe des Arrays nicht in der Deklaration festgelegt wird.'},
     {'question': 'Wie können Arrays in JAVA initialisiert werden?', 'answer': 'Arrays können in JAVA bei ihrer Deklaration initialisiert werden. Dabei wird die Größe des Arrays automatisch festgelegt.'},
     {'question': 'Wie funktioniert die Zuweisung von Array-Variablen in JAVA?', 'answer': 'In JAVA haben Array-Variablen Referenzsemantik, und bei der Zuweisung wird lediglich ein Verweis auf das Array übergeben. Die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[] ist zulässig.'}],
    [{'question': 'Warum ist die oben gezeigte Form der Iteration in JAVA nicht anwendbar, wenn Collections verwendet werden, die nicht indiziert sind?', 'answer': 'Die oben gezeigte Form der Iteration mittels Indizes ist nicht anwendbar, wenn Collections verwendet werden, die nicht indiziert sind, da diese Collections keine numerischen Indizes für den Zugriff auf ihre Elemente bereitstellen.'},
     {'question': 'Was tut die Methode next() eines Iterator-Objekts?', 'answer': 'Die Methode next() eines Iterator-Objekts gibt das nächste Element der Collection zurück, über die iteriert wird.'},
     {'question': 'Wofür wird die Methode hasNext() bei der Verwendung von Iteratoren in JAVA eingesetzt?', 'answer': 'Die Methode hasNext() wird bei der Verwendung von Iteratoren in JAVA eingesetzt, um abzufragen, ob die Collection noch weitere Elemente enthält, die iteriert werden können.'},
     {'question': 'Was passiert, wenn der Bindungsalgorithmus in JAVA zu mehreren Methoden führt, die die Bedingungen erfüllen?', 'answer': 'Wenn der Bindungsalgorithmus zu mehreren Methoden führt, die die Bedingungen erfüllen, meldet der Compiler einen Methodenambiguitätsfehler, da die aufgerufene Methode nicht eindeutig bestimmt werden kann. Dieser Fehler wird durch Methodenaufrufe, nicht durch Methodendeklarationen, verursacht.'},
     {'question': 'In der JAVA-Programmierung gibt es zwei Arten von Zwischenobjekten für die Umsetzung von Zu-n-Beziehungen. Welche sind das?', 'answer': 'In der JAVA-Programmierung gibt es zwei Arten von Zwischenobjekten für die Umsetzung von Zu-n-Beziehungen: Arrays und Collections.'},
     {'question': 'Was bedeutet es, dass in JAVA jeder Typ ein Subtyp von Object ist?', 'answer': 'In JAVA ist jeder Typ, einschließlich Klassen und Interfaces, ein Subtyp von Object. Das bedeutet, dass alle Typen in JAVA die Methoden und Eigenschaften erben, die in der Object-Klasse definiert sind. Dies ermöglicht eine gewisse Einheitlichkeit und Polymorphie in der JAVA-Programmierung. Beachten Sie jedoch, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können, obwohl sie Object erweitern.'},
     {'question': 'Warum werden Marker-Interfaces in Java manchmal durch Metadaten (Annotationen) ersetzt?', 'answer': 'Marker-Interfaces werden in Java manchmal durch Metadaten (Annotationen) ersetzt, da Metadaten eine flexiblere Möglichkeit bieten, Informationen über Klassen oder Methoden zu kennzeichnen, ohne zusätzliche Schnittstellen zu definieren. Annotations können zur Laufzeit oder zur Übersetzungszeit gelesen und interpretiert werden, während Marker-Interfaces nur zur Übersetzungszeit überprüft werden können. Dies bietet mehr Flexibilität und ermöglicht es, zusätzliche Informationen zu annotieren, ohne die Klassenhierarchie zu ändern.'},
     {'question': 'Warum sind JAVA-Programme weitgehend plattformunabhängig?', 'answer': 'JAVA-Programme sind weitgehend plattformunabhängig, da sie in Form von Bytecode vorliegen und von der JVM interpretiert werden. Solange eine JVM für ein bestimmtes Betriebssystem verfügbar ist, können JAVA-Programme auf jedem Rechner und Betriebssystem ausgeführt werden, für das es eine JVM gibt.'},
     {'question': 'Warum wird darauf hingewiesen, dass JAVA-Programmierung oft in integrierten Entwicklungsumgebungen (IDEs) stattfindet?', 'answer': 'Es wird darauf hingewiesen, dass JAVA-Programmierung oft in integrierten Entwicklungsumgebungen (IDEs) stattfindet, da diese Werkzeuge die Entwicklung erleichtern. Allerdings können IDEs aufgrund ihrer Komplexität Anfänger überwältigen.'},
     {'question': 'Warum haben Interfaces in JAVA seit Version 8 einen Bedeutungswandel erfahren?', 'answer': 'Interfaces in JAVA haben einen Bedeutungswandel erfahren, weil sie im Laufe der Zeit um zusätzliche Methoden erweitert wurden, was dazu führte, dass Klassen, die diese Interfaces implementieren, aktualisiert werden mussten. Insbesondere bei Black-Box-Frameworks, bei denen die Entwicklung von Anwendungsklassen in den Händen Dritter liegt, führte dies zu erheblichen Problemen.'},
     {'question': 'Was erlaubte JAVA 9 in Bezug auf Interfaces?', 'answer': 'In JAVA 9 wurde es erlaubt, in Interfaces auch private Methoden zu definieren. Diese privaten Methoden sind nur innerhalb des Interfaces selbst zugreifbar und dienen dazu, die Lesbarkeit von Default-Methoden zu verbessern, indem gemeinsame Teile in private Methoden ausgelagert werden können.'},
     {'question': 'Was bedeutet es, dass JAVA eine klassenbasierte Programmiersprache ist, und wie unterscheidet sich dies von prototypenbasierten Sprachen?', 'answer': 'JAVA ist klassenbasiert, was bedeutet, dass Programmierung durch die Definition von Klassen erfolgt. Im Gegensatz dazu sind prototypenbasierte Sprachen wie SMALLTALK auf Prototypenobjekten aufgebaut, und es gibt keine strikten Klassendefinitionen.'},
     {'question': 'Warum ist es wichtig, zwischen öffentlichen und nicht öffentlichen (privaten) Teilen eines Moduls zu unterscheiden?', 'answer': 'Es ist wichtig, zwischen öffentlichen und privaten Teilen eines Moduls zu unterscheiden, damit die Programmierer die Kontrolle über die Implementierung des Moduls behalten können. Indem sie sich auf eine Schnittstelle festlegen und private Teile hinter der Schnittstelle verbergen, können sie Änderungen an den verborgenen Teilen vornehmen, ohne andere Benutzer des Moduls zu beeinträchtigen.'},
     {'question': 'Ab welcher Version von JAVA wurde ein Modulbegriff eingeführt, der diesen Namen verdient?', 'answer': 'Ein Modulbegriff, der den Namen verdient, wurde mit JAVA 9 eingeführt, nach langer Vorbereitungszeit.'},
     {'question': 'Warum gibt es für mathematische Funktionen in JAVA die spezielle Klasse Math?', 'answer': 'Die primitiven Typen in JAVA sind keine Klassen, daher werden mathematische Funktionen wie sin(.) in der speziellen Klasse Math als Klassenmethoden definiert.'},
     {'question': 'Können Klassendefinitionen in JAVA Operatoren definieren?', 'answer': 'Nein, in JAVA ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren wie es bei den binären Methoden in SMALLTALK der Fall ist.'},
     {'question': 'Was unterscheidet Prozeduren und Funktionen in JAVA?', 'answer': 'In JAVA können Methoden in Prozeduren und Funktionen unterteilt werden. Der einzige Unterschied besteht darin, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp "void" deklarieren.'},
     {'question': 'Wozu dienen Pakete in JAVA?', 'answer': 'Pakete in JAVA dienen der Sammlung von Klassen und dienen gleichzeitig als Namensräume für diese. Sie ermöglichen die Organisation von Klassen und bieten zugleich laxere Zugriffsbeschränkungen für Klassen innerhalb desselben Pakets.'},
     {'question': 'Warum sind Klassenliterale in JAVA eher selten anzutreffen?', 'answer': 'Klassenliterale sind in JAVA eher selten anzutreffen, da Klassennamen auch direkt in JAVA-Programmen verwendet werden können, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie "instanceof".'},
     {'question': 'Warum können nicht alle Typprüfungen in Java zur Übersetzungszeit durchgeführt werden?', 'answer': 'Nicht alle Typprüfungen können in Java zur Übersetzungszeit durchgeführt werden, da einige Typprüfungen erst zur Laufzeit notwendig sind und nicht im Voraus bekannt sind.'},
     {'question': 'Was bedeutet es, wenn eine Klasse in JAVA als abstrakt deklariert wird?', 'answer': 'Wenn eine Klasse in JAVA als abstrakt deklariert wird, bedeutet dies, dass sie nicht instanziierbar ist. Es können keine Objekte dieser Klasse erstellt werden.'},
     {'question': 'Warum ist es eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren?', 'answer': 'Es ist eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren, um das Prinzip der abstrakten Generalisierung zu fördern und Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien zu vermeiden.'},
     {'question': 'Warum wird das Schlüsselwort "abstract" in Interfaces automatisch angenommen?', 'answer': 'Das Schlüsselwort "abstract" wird in Interfaces automatisch angenommen, da Interfaces zunächst weder Implementierungen noch Objekte liefern. Sie dienen der Definition von Schnittstellen und Typen.'},
     {'question': 'Kann eine Klasse mehrere Interfaces gleichzeitig implementieren?', 'answer': 'Ja, eine Klasse kann mehrere Interfaces gleichzeitig implementieren, indem die entsprechenden Interface-Namen durch Kommata getrennt angegeben werden. In diesem Fall müssen die Methoden in der Klasse zumindest als abstrakt deklariert werden.'},
     {'question': 'An welches Konzept in JAVA ist die Typkonformität und die Zuweisungskompatibilität unter Referenztypen gebunden?', 'answer': 'Die Typkonformität und die Zuweisungskompatibilität unter Referenztypen in JAVA sind an das Konzept des Subtypings gebunden.'},
     {'question': 'Ist JAVA eine Sprache mit einem strengen Typsystem, und was bedeutet das?', 'answer': 'Ja, JAVA ist eine Sprache mit einem strengen Typsystem, was bedeutet, dass alle Typfehler entweder während der Übersetzung durch den Compiler oder während der Laufzeit erkannt werden, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung, bei der eine Typinvariante verletzt wird.'},
     {'question': 'Was passiert, wenn kein Konstruktor in JAVA definiert wird?', 'answer': 'Wenn kein Konstruktor in JAVA definiert wird, verwendet JAVA standardmäßig den impliziten Standardkonstruktor, der parameterlos ist und eine neue Instanz der Klasse erzeugt.'},
     {'question': 'Werden Konstruktoren in JAVA vererbt?', 'answer': 'Nein, Konstruktoren werden in JAVA nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse automatisch aufgerufen, wenn eine Instanz einer ihrer Subklassen erzeugt wird.'},
     {'question': 'Was passiert, wenn der Typ der geworfenen Exception nicht in einer Catch-Klausel aufgeführt ist?', 'answer': 'Wenn der Typ der geworfenen Exception nicht in einer Catch-Klausel aufgeführt ist, wird die Exception als unbehandelt betrachtet. Die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung ("Exception in thread ...").'},
     {'question': 'Was unterscheidet Checked Exceptions und Unchecked Exceptions in JAVA?', 'answer': 'Der Hauptunterschied besteht darin, dass Checked Exceptions eine explizite Deklaration im Methodenkopf oder eine Behandlung innerhalb der Methode erfordern, während Unchecked Exceptions dies nicht tun. Checked Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind, während Unchecked Exceptions von Exception-Klassen abgeleitet werden, die von RuntimeException abgeleitet sind. Checked Exceptions sollen den Programmierer auf mögliche Ausnahmesituationen hinweisen, während Unchecked Exceptions oft schwer vorhersehbar sind und überall auftreten können.'},
     {'question': 'Warum funktioniert der ursprüngliche Ansatz von JAVA, bei dem alle Klassen eines Programms zu einem Paket zusammengefasst werden können, nicht mehr, wenn Programme in mehrere Pakete aufgeteilt werden?', 'answer': 'Der ursprüngliche Ansatz von JAVA, bei dem alle Klassen eines Programms zu einem Paket zusammengefasst werden können, funktioniert nicht mehr, wenn Programme in mehrere Pakete aufgeteilt werden, weil Abhängigkeiten zwischen den Paketen öffentliche Deklarationen erfordern, die dann jedoch alle Programmelemente für jeden sichtbar machen, was die Modularität einschränkt.'},
     {'question': 'Was wurde mit JAVA 9 eingeführt, um das Problem der Modularität in JAVA zu lösen?', 'answer': 'Mit JAVA 9 wurde ein eigenes Modulkonzept eingeführt, das über Klassen und Paketen steht. Ein Modul in JAVA 9 ist eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Die Moduldeklaration umfasst den Namen des Moduls, die angebotene Schnittstelle und die benötigte Schnittstelle.'},
     {'question': 'Warum führt die Zuweisung von List<Integer> zu List<Object> zu einem statischen Typfehler in Java?', 'answer': 'Die Zuweisung von List<Integer> zu List<Object> führt zu einem statischen Typfehler in Java, weil bei generischen Typen nicht automatisch eine Zuweisungskompatibilität zwischen unterschiedlichen generischen Typen besteht, selbst wenn die Typen, die sie parametrisieren, zueinander in Beziehung stehen. Dies erhöht die Typsicherheit zur Übersetzungszeit.'},
     {'question': 'Warum könnte eine Parametrisierung von "Comparable" vorteilhaft sein?', 'answer': 'Eine Parametrisierung von "Comparable" könnte vorteilhaft sein, um die Flexibilität bei der Verwendung von Vergleichen zu erhöhen. Es ermöglicht, dass Objekte mit verschiedenen, aber kompatiblen Typen miteinander verglichen werden können.'},
     {'question': 'Was würde die Deklaration "interface Comparable<T extends T>" bedeuten?', 'answer': 'Die Deklaration "interface Comparable<T extends T>" würde bedeuten, dass der Typparameter "T" vom gleichen Typ sein muss wie der Typparameter "T" selbst, was in der Praxis keine sinnvolle Einschränkung ist.'},
     {'question': 'Warum ist die Bedingung, dass zu vergleichende Elemente vom gleichen Typ sein müssen, zu restriktiv?', 'answer': 'Die Bedingung, dass zu vergleichende Elemente vom gleichen Typ sein müssen, ist zu restriktiv, weil es Fälle gibt, in denen Objekte unterschiedlicher, aber verwandter Typen miteinander verglichen werden sollen. Eine flexiblere Einschränkung ist erforderlich.'},
     {'question': 'Was bedeutet "Comparable<? super E>"?', 'answer': '"Comparable<? super E>" bedeutet, dass der Parametertyp von "Comparable" mindestens "E" umfassen muss, kann jedoch auch allgemeiner sein, z. B. "Object". Das "?" in der Typ-Wildcard steht für einen beliebigen Typen, der die Bedingung erfüllt, in diesem Fall ein Supertyp von "E".'},
     {'question': 'Warum ist "Comparable<? super E>" flexibler als "Comparable<T extends T>"?', 'answer': '"Comparable<? super E>" ist flexibler, weil es eine größere Bandbreite von Typen zulässt, die miteinander verglichen werden können. Es erlaubt, dass Objekte vom Typ "E" mit Objekten anderer, aber verwandter Typen verglichen werden, was die Verwendung von "Comparable" vielseitiger macht.'},
     {'question': 'Warum wurden Typ-Wildcards (Wildcard-Typen) in Java eingeführt?', 'answer': 'Typ-Wildcards wurden eingeführt, um eine flexiblere Form der Zuweisungskompatibilität für generische Typen zu ermöglichen, insbesondere bei der Verwendung von Collections mit unterschiedlichen Typparametern.'},
     {'question': 'Was bedeutet es, wenn ein Typ mit einer Typ-Wildcard (z. B. List<?>) deklariert wird?', 'answer': 'Wenn ein Typ mit einer Typ-Wildcard deklariert wird, bedeutet dies, dass die Variable dieses Typs Objekte beliebigen, aber unbekannten Typparameters akzeptieren kann. Es ist eine abstrakte Deklaration.'},
     {'question': 'Warum sind "ArrayList<Integer>" und "ArrayList<String>" trotz "Integer" und "String" als Subtypen von "Comparable" nicht zuweisungskompatibel mit "ArrayList<Comparable>"?', 'answer': '"ArrayList<Integer>" und "ArrayList<String>" sind nicht zuweisungskompatibel mit "ArrayList<Comparable>", weil generische Typen in Java keine kovariante Zuweisung von Subtypen erlauben. Dies wurde durch die Einführung von Typ-Wildcards gelöst.'},
     {'question': 'Warum sollten Klassenbibliotheken unabhängig von der Sprachdefinition sein und austauschbar sein?', 'answer': 'Klassenbibliotheken sollten unabhängig von der Sprachdefinition sein und austauschbar sein, um die Flexibilität und Portabilität von Software zu gewährleisten. Wenn Klassenbibliotheken eng an die Sprachdefinition gebunden sind, könnte dies dazu führen, dass eine Software nur auf einer bestimmten Plattform oder mit einer bestimmten Sprachversion funktioniert. Durch die Unabhängigkeit von der Sprachdefinition können Klassenbibliotheken in verschiedenen Umgebungen verwendet werden und die Softwareentwicklung erleichtern.'},
     {'question': 'Warum sind einige Klassen in JAVA von der Sprache fest vorgegeben und können nicht beliebig ersetzt werden?', 'answer': 'In JAVA sind einige Klassen von der Sprache fest vorgegeben, um die grundlegende Funktionalität der Sprache sicherzustellen und um sicherzustellen, dass bestimmte wichtige Aufgaben immer erfüllt werden können. Zum Beispiel sind Klassen wie Object und String integraler Bestandteil der JAVA-Sprache und können nicht ersetzt werden, da sie grundlegende Funktionen wie die Objekterstellung und Zeichenkettenmanipulation ermöglichen. Diese Klassen stellen die Grundlage für die Entwicklung von JAVA-Programmen dar und sind daher unverzichtbar.'},
     {'question': 'Warum werden in diesem Kapitel keine metasyntaktischen Variablen verwendet?', 'answer': 'Metasyntaktische Variablen könnten aufgrund der Verwendung von spitzen Klammern für Typvariablen in Java zu Verwechselungen führen. Daher werden in diesem Kapitel keine metasyntaktischen Variablen verwendet.'},
     {'question': 'Warum wird in den kommenden Kurseinheiten JAVA behandelt?', 'answer': 'In den kommenden Kurseinheiten wird JAVA behandelt, da es immer noch die am weitesten verbreitete objektorientierte Programmiersprache ist und viele Parallelen zu SMALLTALK aufweist, was den Übergang zu anderen Programmiersprachen erleichtert. Es ist jedoch wichtig zu beachten, dass JAVA aus theoretischer Sicht keine besondere Position einnimmt, und sein Erfolg war wahrscheinlich eher auf das Internet zurückzuführen.'},
     {'question': 'Was bedeutet es, wenn ein Member in Java als "static" deklariert wird?', 'answer': 'Wenn ein Member als "static" deklariert wird, bedeutet dies, dass er sich nicht auf Instanzen der Klasse bezieht, sondern auf die Klasse selbst. Es handelt sich um Klassenvariablen und -methoden.'},
     {'question': 'Warum sind "static"-Felder in Java keine Konstanten?', 'answer': '"static"-Felder in Java sind nicht automatisch Konstanten, da sie mehrfach geändert werden können. Konstanten werden in Java stattdessen durch das Schlüsselwort "final" gekennzeichnet.'},
     {'question': 'Was unterscheidet Call by Value und Call by Reference, und wie wird dies in JAVA gehandhabt?', 'answer': 'In JAVA wird Call by Value verwendet, was bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Dies ist eine Einschränkung im Vergleich zu Call by Reference, bei dem eine Methode auf den ursprünglichen Wert einer Variablen zugreifen und ihn ändern kann.'},
     {'question': 'Was versteht man unter einem Type cast (Typumwandlung)?', 'answer': 'Ein Type cast ist der Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde.'},
     {'question': 'Warum werden Interfaces in JAVA als einer der wichtigsten Beiträge zur objektorientierten Programmierung angesehen?', 'answer': 'Interfaces in JAVA sind einer der wichtigsten Beiträge zur objektorientierten Programmierung, da sie die Möglichkeit bieten, Schnittstellen und Polymorphismus zu implementieren, was die Flexibilität und Erweiterbarkeit von Programmen erheblich verbessert.'},
     {'question': 'Warum ist die Aufteilung eines Programms in Module wichtig?', 'answer': 'Die Aufteilung eines Programms in Module ist wichtig, um die unabhängige Entwicklung von Programmteilen zu ermöglichen. Dadurch sollen Abhängigkeiten zwischen den Modulen minimiert werden, insbesondere in Bezug auf Änderungen.'},
     {'question': 'Was bedeutet Abhängigkeit zwischen Modulen in der Programmierung?', 'answer': 'In der Programmierung bedeutet Abhängigkeit zwischen Modulen in der Regel Änderungsabhängigkeit. Wenn sich in einem Modul etwas ändert, kann dies Auswirkungen auf andere davon abhängige Module haben. Abhängigkeiten ergeben sich oft aus Benutzungsbeziehungen und können in der objektorientierten Programmierung auch Vererbungsabhängigkeiten einschließen.'},
     {'question': 'Sind zirkuläre Abhängigkeiten zwischen Klassen in JAVA erlaubt?', 'answer': 'Ja, zirkuläre Abhängigkeiten zwischen Klassen sind in JAVA zunächst erlaubt. Dies bedeutet, dass sich zwei Klassen wechselseitig importieren können. Jedoch wird dies in der Softwareentwicklung vermieden, da wechselseitige Abhängigkeiten eine enge Kopplung zwischen Modulen anzeigen, die vermieden werden sollte. Für JAVA-Module sind zirkuläre Abhängigkeiten jedoch verboten.'},
     {'question': 'Warum sind zirkuläre Abhängigkeiten in JAVA-Modulen verpönt?', 'answer': 'Zirkuläre Abhängigkeiten in JAVA-Modulen sind verpönt, da sie eine enge Kopplung zwischen Modulen dokumentieren und dies vermieden werden sollte. Das Verbot zirkulärer Abhängigkeiten erfordert eine sorgfältige Planung der Modularisierung, was generell von großem Wert ist.'},
     {'question': 'Wem obliegt es, zu definieren, was passieren soll, wenn der Typtest fehlschlägt?', 'answer': 'Es obliegt der Programmiererin, zu definieren, was passieren soll, wenn der Typtest fehlschlägt, d.h., wenn das Objekt nicht den geforderten Typ hat.'},
     {'question': 'Wo können Typvariablen (formale Typparameter) in Java verwendet werden?', 'answer': 'Typvariablen können sowohl in Typdefinitionen als auch in Methodendefinitionen in Java verwendet werden.'},
     {'question': 'Warum könnte es sinnvoll sein, den Typparameter einer generischen Methode mit "extends" zu beschränken?', 'answer': 'Das Beschränken des Typparameters einer generischen Methode mit "extends" kann sinnvoll sein, um die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte zu erhöhen, da deren Typ innerhalb der Methode bekannter ist.'},
     {'question': 'Warum könnte es in einigen Fällen sinnvoll sein, ein Typ-Wildcard anstelle eines Typparameters in einer generischen Methode zu verwenden?', 'answer': 'In einigen Fällen, in denen der Typparameter innerhalb der Methode nicht verwendet wird, kann es sinnvoll sein, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard in der generischen Methode zu verwenden, um den Code einfacher und lesbarer zu gestalten.'},
     {'question': 'Was bewirkt die Break-Anweisung in JAVA?', 'answer': 'Die Break-Anweisung in JAVA bewirkt, dass eine Schleife oder ein Switch-Statement sofort verlassen wird. Sie kann optional mit einem Label versehen werden, um eine äußere Schleife oder ein äußeres Switch-Statement zu verlassen.'},
     {'question': 'Was bedeutet es, dass JAVA eine stark typisierte Sprache ist?', 'answer': 'JAVA ist eine stark typisierte Sprache, was bedeutet, dass alle Ausdrücke einen Typ haben und Variablen bei ihrer Deklaration einen Typ angeben müssen.'},
     {'question': 'Was unterscheidet eine Wertzuweisung und eine Zuweisung von Referenzen in JAVA?', 'answer': 'Bei der Wertzuweisung wird der tatsächliche Wert einer Variable kopiert, während bei der Zuweisung von Referenzen nur die Referenz auf das Objekt kopiert wird.'},
     {'question': 'Gibt es in JAVA "Call by reference"?', 'answer': 'Nein, in JAVA gibt es kein "Call by reference", sondern nur "Call by value". Auch wenn Variablen Referenztypen haben, wird bei Methodenaufrufen immer eine Kopie des Zeigers an die formalen Parameter übergeben.'},
     {'question': 'Warum ist beschränkter parametrischer Polymorphismus wichtig?', 'answer': 'Beschränkter parametrischer Polymorphismus ist wichtig, um sicherzustellen, dass die Objekte, die von einem generischen Typ erzeugt werden, bestimmte Eigenschaften oder Methoden haben. Dadurch wird die Typsicherheit erhöht und es können bestimmte Annahmen über die Objekte gemacht werden.'},
     {'question': 'Was bedeutet die Einschränkung "<E extends Comparable<E>>" in der Klasse "SortedList"?', 'answer': 'Die Einschränkung "<E extends Comparable<E>>" bedeutet, dass der Typparameter "E" auf Typen beschränkt ist, die das Interface "Comparable" implementieren oder davon erben. Dies stellt sicher, dass Objekte vom Typ "E" die Methode "compareTo(.)" implementieren können, die vom Interface "Comparable" vorgeschrieben wird.'},
     {'question': 'Warum wird "SortedList<String>" als gültige Deklaration betrachtet, aber "SortedList<Integer>" nicht?', 'answer': '"SortedList<String>" wird als gültige Deklaration betrachtet, weil "String" ein Subtyp von "Comparable" ist und daher die Bedingung "<E extends Comparable<E>>" erfüllt. "SortedList<Integer>" wird hingegen nicht als gültige Deklaration betrachtet, da "Integer" nicht "Comparable<Integer>" implementiert, was nicht der Einschränkung entspricht.'},
     {'question': 'Ist "SortedList<String>" ein Subtyp von "SortedList<Comparable>"?', 'answer': 'Nein, "SortedList<String>" ist kein Subtyp von "SortedList<Comparable>". Die Einschränkung "<E extends Comparable<E>>" in "SortedList" sorgt dafür, dass der Typparameter "E" ein Subtyp von "Comparable<E>" sein muss, aber sie schafft keine Subtypenbeziehung zwischen den "SortedList"-Instanzen selbst.'},
     {'question': 'Ist es in Java möglich, generische Variablen zu deklarieren?', 'answer': 'Ja, es ist in Java möglich, generische Variablen zu deklarieren.'},
     {'question': 'Was passiert, wenn eine Variable mit einem Typ-Wildcard deklariert wird?', 'answer': 'Wenn eine Variable mit einem Typ-Wildcard deklariert wird, kann ihr eine Instanz eines beliebigen konkreten Typs zugewiesen werden, der den Anforderungen der Wildcard entspricht.'},
     {'question': 'Führen generische Variablendeklarationen einen neuen Typ ein?', 'answer': 'Nein, generische Variablendeklarationen führen keinen neuen Typ ein. Der durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzte Typ ist ein konkreter Typ.'},
     {'question': 'Warum ist die Verwechslung von equals(.) und == ein häufiger Programmierfehler in JAVA?', 'answer': 'Die Verwechslung von equals(.) und == ist auch in JAVA ein häufiger Programmierfehler, da sie unterschiedliche Bedeutungen haben. equals(.) prüft die Gleichheit von Objekten, während == die Identität überprüft.'},
     {'question': 'Wofür steht das Gleichheitszeichen = in JAVA?', 'answer': 'Das Gleichheitszeichen = in JAVA steht für die Wertzuweisung, nicht für die Überprüfung der Gleichheit von Objekten.'},
     {'question': 'Was passiert standardmäßig, wenn man einen neuen Thread in JAVA startet?', 'answer': 'Standardmäßig führt ein Thread in JAVA keine spezifischen Aufgaben aus und endet sofort. Dies geschieht, weil die Methode run() in der Klasse Thread standardmäßig leer ist.'},
     {'question': 'Was ermöglicht JAVA in Bezug auf Arrays in Bezug auf Wert- und Referenztypen?', 'answer': 'In JAVA ist es möglich, sowohl Arrays von primitiven (Wert-)Typen als auch von Referenztypen zu erstellen.'},
     {'question': 'Warum gestattet JAVA die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[]?', 'answer': 'Diese Zuweisungskompatibilität ermöglicht eine flexiblere Programmierung, insbesondere in Situationen, in denen der statische Typ der Array-Elemente nicht genau festgelegt ist, aber nach oben beschränkt werden soll, wie im Beispiel mit dem Interface Comparable und der Methode sort. Dieser Kompromiss zwischen statischer und dynamischer Typprüfung bietet Flexibilität beim Programmieren.'}],
]
KE5_questions = [
    [{'question': 'Welche Strukturen bietet C++ im Bereich der objektorientierten Programmierung?', 'answer': 'C++ bietet sowohl Strukturen (structs) als auch Klassen (classes) im Bereich der objektorientierten Programmierung.'},
     {'question': 'Welche Besonderheiten gibt es bei Zuweisungen von Pointervariablen in C++?', 'answer': 'Bei Zuweisungen von Pointervariablen muss man sich in C++ genau überlegen, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen möchte. C++ verwendet standardmäßig "Call by value" für Methodenaufrufe, was bedeutet, dass Kopien von Parametern übergeben werden.'},
     {'question': 'Was ist die Grundlage für die Übertragung von Parametern in C++-Methodenaufrufen?', 'answer': 'In C++-Methodenaufrufen erfolgt die Übertragung von Parametern standardmäßig durch "Call by value", was bedeutet, dass Kopien der Parameter übergeben werden.'},
     {'question': 'Was ist Generizität in C-Sharp?', 'answer': 'Generizität in C-Sharp ermöglicht es, parametrischen Polymorphismus sowohl für Klassen als auch für Methoden zu nutzen. Sie erlaubt die Definition von generischen Klassen und Interfaces, die eine Menge von Typen spezifizieren, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen.'},
     {'question': 'Welche Arten von Generizität werden in C-Sharp unterstützt?', 'answer': 'C-Sharp unterstützt sowohl beschränkte als auch unbeschränkte parametrische Polymorphismus für Klassen und Methoden. Dies bedeutet, dass Typparameter sowohl eingeschränkte (mit bestimmten Anforderungen) als auch unbeschränkte (ohne Anforderungen) Typen sein können.'},
     {'question': 'Welche Vorteile bietet die Typexpansion in C-Sharp für Werttypen?', 'answer': 'Die Typexpansion in C-Sharp ermöglicht es, generische Klassen für Werttypen ohne Boxing/Unboxing zu optimieren. Dies führt zu besserer Leistung und geringerem Overhead, da der JIT-Compiler den Code für verschiedene Typen optimieren kann.'},
     {'question': 'Welche Freiheit bietet der Präprozessor in C++?', 'answer': 'Der Präprozessor in C++ bietet die Freiheit, die Syntax der Sprache durch Hinzufügen einer neuen Syntax zu verändern. Dies ermöglicht es, Code in einer für Entwickler verständlicheren Weise zu schreiben, wenn gewünscht.'},
     {'question': 'Was sind explizite Interfaceimplementierungen in C-Sharp?', 'answer': 'Explizite Interfaceimplementierungen in C-Sharp ermöglichen es einer Klasse, die gleiche Methodendeklaration von verschiedenen Interfaces getrennt voneinander zu implementieren. Dies wird durch die Angabe des Interfacequalifikators vor der Methode erreicht.'},
     {'question': 'Welchen Nutzen haben explizite Interfaceimplementierungen in C-Sharp?', 'answer': 'Der Nutzen von expliziten Interfaceimplementierungen liegt darin, dass die Methode je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Dies ermöglicht es, verschiedene Verhaltensweisen für denselben Methodennamen in verschiedenen Kontexten zu definieren.'},
     {'question': 'Welche Arten von Vererbung erlaubt EIFFEL?', 'answer': 'EIFFEL erlaubt Mehrfachvererbung, was bedeutet, dass eine Klasse von mehreren anderen Klassen erben kann.'},
     {'question': 'Welches Schlüsselwort wird in EIFFEL für abstrakte Klassen verwendet?', 'answer': 'In EIFFEL wird das Schlüsselwort "deferred" anstelle von "abstract" für abstrakte Klassen verwendet.'},
     {'question': 'Was ist in EIFFEL nicht erlaubt, was das Überladen von Methoden betrifft?', 'answer': 'In EIFFEL ist es nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt.'},
     {'question': 'Was ist die Just-in-time-(JIT-)Kompilierung in C-Sharp und wie unterscheidet sie sich von JAVA?', 'answer': 'In C-Sharp ist die Just-in-time-(JIT-)Kompilierung die Standardmethode zur Übersetzung des CIL-Codes in Maschinencode. Dieser Vorgang erfolgt unmittelbar vor der Ausführung und nur dann, wenn der Code tatsächlich ausgeführt wird. Im Gegensatz dazu verwendet JAVA normalerweise den Ahead-of-time-(AOT-)Kompilierungsansatz, bei dem der Bytecode vor der Ausführung in nativen Maschinencode übersetzt wird. Die JIT-Kompilierung in C-Sharp ermöglicht eine feinere Granularität, da sie bis auf die Ebene einzelner Methoden herabgeht.'},
     {'question': 'Welche Unterschiede gibt es in Bezug auf die Garbage Collection zwischen C-Sharp und JAVA?', 'answer': 'In C-Sharp haben Entwickler die Möglichkeit, den Speicherplatz für Objekte, die mit "new" erstellt wurden, manuell freizugeben. Dies kann jedoch zu Speicherlecks führen, wenn Entwickler vergessen, den Speicher freizugeben, oder zu Problemen, wenn auf freigegebene Objekte weiterhin Referenzen vorhanden sind. Im Gegensatz dazu verwendet JAVA normalerweise eine automatische Garbage Collection, bei der nicht mehr benötigte Objekte automatisch erkannt und freigegeben werden.'},
     {'question': 'Welche Spracherweiterungen, die später in Java eingeführt wurden, gab es bereits in C-Sharp?', 'answer': 'In C-Sharp gab es von Anfang an sogenannte "Attributes" (Attribute), die in Java in der Version 5 als "Annotationen" Einzug hielten. C-Sharp führte auch bereits ab Version 3.0 Lambda-Ausdrücke ein, während Java erst mit Version 8 nachzog.'},
     {'question': 'Was ist ein herausragendes Merkmal von EIFFEL in Bezug auf Zusicherungen (Assertions)?', 'answer': 'Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Anders als in Java, wo Zusicherungen flexibel platziert werden können, gibt es in EIFFEL spezielle vorgesehene Stellen für diese Zusicherungen.'},
     {'question': 'Welche Schlüsselwörter werden in EIFFEL verwendet, um Vor- und Nachbedingungen für Methoden zu definieren?', 'answer': 'In EIFFEL werden die Schlüsselwörter "require" (vor der Implementierung der Methode) und "ensure" (nach der Implementierung der Methode) verwendet, um Vor- und Nachbedingungen für Methoden zu definieren.'},
     {'question': 'Was sind Klasseninvarianten in EIFFEL?', 'answer': 'Klasseninvarianten in EIFFEL sind Bedingungen, die zwischen zwei Methodenaufrufen in einer Klasse immer gelten müssen. Sie werden mit dem Schlüsselwort "invariant" deklariert und sind sozusagen eine Zusammenfassung von Vor- und Nachbedingungen, die für die Klasse als Ganzes gelten.'},
     {'question': 'Welche Rolle nimmt EIFFEL unter den behandelten Sprachen ein?', 'answer': 'EIFFEL nimmt eine besondere Position unter den behandelten Sprachen ein, da es mehrere Funktionen erfüllt: Es dient als Sprache für objektorientierte Analyse und Design, für kommerzielle Programmierung und als akademische Lehrsprache.'},
     {'question': 'Was ist das herausragende Merkmal von EIFFEL und wie trägt es zu seiner Multifunktion bei?', 'answer': 'Das herausragende Merkmal von EIFFEL ist die Integration von Zusicherungen (Vorbedingungen, Nachbedingungen und Klasseninvarianten), die als Verträge zwischen Klassen dienen können. Dies ermöglicht eine Spezifikation des "Was" einer Software unabhängig vom "Wie". Es erlaubt, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sich auf andere Werte und den zeitlichen Verlauf beziehen können. Diese Funktion trägt zu seiner Multifunktion bei, da sie verschiedene Anwendungsbereiche unterstützt.'},
     {'question': 'Welche Abweichungen gibt es in EIFFEL im Vergleich zu anderen Sprachen, und warum sind sie vorhanden?', 'answer': 'Obwohl EIFFEL syntaktisch Ähnlichkeiten zu anderen Sprachen wie PASCAL aufweist, gibt es einige Abweichungen. Diese Abweichungen sind jedoch gut begründet und bieten eine alternative Perspektive auf vertraute Konzepte. Sie tragen dazu bei, klarere und orthogonalere Konzepte zu schaffen.'},
     {'question': 'Was ist das Common Type System (CTS) in C-Sharp und warum ist es wichtig?', 'answer': 'Das Common Type System (CTS) ist ein Teil des .NET-Frameworks und sorgt dafür, dass Typen, die in verschiedenen .NET-Sprachen definiert wurden, gemeinsam genutzt werden können. Es stellt sicher, dass Typen in einer einheitlichen Hierarchie organisiert sind und in verschiedenen .NET-Sprachen verwendet werden können, als wären sie in der jeweiligen Sprache selbst definiert worden. Dies erleichtert die Interoperabilität zwischen verschiedenen .NET-Sprachen und ermöglicht es, Bibliotheken und Komponenten in verschiedenen Sprachen zu verwenden.'},
     {'question': 'Welche Arten von Werttypen gibt es in C-Sharp?', 'answer': 'In C-Sharp gibt es verschiedene Arten von Werttypen, darunter die primitiven Typen (z. B. int, bool, double), Aufzählungstypen (enum) und vom Entwickler definierte Werttypen. Werttypen werden in C-Sharp mit dem Typkonstruktor "struct" erstellt und können Methoden und Konstruktoren haben, jedoch erlauben sie keine Typerweiterung oder Vererbung.'},
     {'question': 'Welche Arten von Referenztypen gibt es in C-Sharp?', 'answer': 'In C-Sharp gibt es verschiedene Arten von Referenztypen, darunter Klassen, Interfaces, Arrays, Delegates und Attribut-Typen. Diese Referenztypen ermöglichen eine größere Vielfalt an Programmierkonzepten und -strukturen in C-Sharp.'},
     {'question': 'Was sind Delegates in C-Sharp und wozu dienen sie?', 'answer': 'Delegates in C-Sharp sind Zeiger auf an ein Objekt gebundene einzelne Methoden. Sie ermöglichen es, Funktionen und Methoden als Parameter an andere Funktionen oder Methoden zu übergeben, was besonders nützlich für Problemstellungen wie Listener-Mechanismen ist. Delegates ersetzen die aus anderen Sprachen bekannten Funktionszeiger oder Funktionspointer.'},
     {'question': 'Was ist Runtime Type Information (RTTI) in C++?', 'answer': 'Runtime Type Information (RTTI) ist eine Funktion in C++, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. RTTI ermöglicht die Ermittlung des Typs eines Objekts zur Laufzeit.'},
     {'question': 'Was ist die Funktion dynamic_cast in C++?', 'answer': 'Die Funktion dynamic_cast<T>(x) in C++ nimmt zwei Parameter, einen Typ (T) und ein Objekt (x), und gibt das Objekt mit dem angegebenen Typ zurück, wenn die RTTI dies als korrekt erkennt. Andernfalls gibt sie 0 zurück.'},
     {'question': 'Was sind Zugriffsmethoden in EIFFEL und wofür werden sie verwendet?', 'answer': 'Zugriffsmethoden in EIFFEL sind Methoden, die verwendet werden, um auf private Instanzvariablen (Attribute) zuzugreifen. Sie dienen dazu, den Zugriff auf diese Variablen zu kontrollieren und bieten die Möglichkeit, Vor- und Nachbedingungen festzulegen.'},
     {'question': 'Welche Aufgaben können Zugriffsmethoden in EIFFEL erfüllen?', 'answer': 'Neben dem Lesen und Setzen von Instanzvariablen können Zugriffsmethoden in EIFFEL auch andere Aufgaben erfüllen, wie das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen.'},
     {'question': 'Was sind Features in EIFFEL und wie werden sie zusammengefasst?', 'answer': 'In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als "Features" bezeichnet. Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL.'},
     {'question': 'Was ist das Besondere an der Definition einer Schnittstelle in EIFFEL?', 'answer': 'Die Definition einer Schnittstelle in EIFFEL ist recht unspezifisch. Alle Klienten einer Klasse haben standardmäßig das gleiche Bild von ihr. Statt den Zugriff an Pakete oder Freunde zu binden, bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (exportieren).'},
     {'question': 'Was ist das Programmiermodell von EIFFEL?', 'answer': 'Das Programmiermodell von EIFFEL ist rein objektorientiert, bei dem der gesamte Code in Klassen organisiert ist. Diese Klassen können separat übersetzt werden, und die Ausführung erfolgt direkt auf der Zielmaschine.'},
     {'question': 'Welche Methode verwendet EIFFEL zur Speicherfreigabe?', 'answer': 'EIFFEL verwendet Garbage Collection zur Speicherfreigabe.'},
     {'question': 'Welche Art der Vererbung bietet C++ in Bezug auf Mehrfachvererbung?', 'answer': 'C++ bietet uneingeschränkte Mehrfachvererbung, was bedeutet, dass eine Klasse von mehreren anderen Klassen erben kann.'},
     {'question': 'Was ist ein Nachteil der Mehrfachvererbung in C++?', 'answer': 'Ein Nachteil der Mehrfachvererbung in C++ ist, dass das Erben nicht selektiv erfolgt, und das Löschen von geerbten Membern nicht möglich ist. Dies führt oft dazu, dass Klassen in viele kleine Teile aufgespalten werden, um unnötigen Ballast zu vermeiden.'},
     {'question': 'Welches Problem kann auftreten, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements erbt?', 'answer': 'Wenn eine Klasse in C++ von mehreren anderen Klassen verschiedene Definitionen desselben Elements (z. B. eines Feldes oder einer Methode) erbt, muss die Klasse sich für eine der beiden Definitionen entscheiden, und die andere geht verloren. Dies kann zu unerwartetem Verhalten führen, insbesondere im Zusammenhang mit dynamischem Binden und offener Rekursion.'},
     {'question': 'Welche praktischen Probleme können sich aus der Mehrfachvererbung in C++ ergeben?', 'answer': 'Die Mehrfachvererbung in C++ kann zu zahlreichen praktischen Problemen führen, darunter die Auswahl von geerbten Definitionen, Konflikte bei gleichen Elementen in verschiedenen Elternklassen und unerwartetes Verhalten im Zusammenhang mit dynamischem Binden. Weitere Probleme können auftreten, sind jedoch in diesem Abschnitt nicht näher erläutert.'},
     {'question': 'Welche Gemeinsamkeiten gibt es zwischen C-Sharp und JAVA in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen?', 'answer': 'C-Sharp und JAVA weisen in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen viele Gemeinsamkeiten auf. Die grundlegende Syntax und Struktur der beiden Sprachen sind ähnlich. In beiden Sprachen werden Klassen verwendet, um Objekte zu erstellen, Variablen und Ausdrücke zu definieren, Anweisungen auszuführen und Kontrollstrukturen zu steuern.'},
     {'question': 'Welche Besonderheit gibt es in C-Sharp in Bezug auf die Überladung von Operatoren, und wie wird sie umgesetzt?', 'answer': 'In C-Sharp ist es möglich, Operatoren wie +, -, == usw. zu überladen. Dies wird durch das Schlüsselwort "operator" ermöglicht, das in einer Operatordefinition vorangestellt wird. Die Überladung von Operatoren erfolgt ähnlich wie die Definition von Methoden, aber anstelle von Methodennamen werden die Operatorzeichen verwendet.'},
     {'question': 'Was ist "Call by reference" in C-Sharp, und wie unterscheidet es sich von "Call by value"?', 'answer': 'In C-Sharp ermöglicht "Call by reference" (auch als "ref" und "out" bekannt) das Übergeben von Argumenten an Methoden, bei denen die Änderungen an den Parametern innerhalb der Methode auf die ursprünglichen Argumente außerhalb der Methode angewendet werden. Im Gegensatz dazu verwendet "Call by value" Kopien der Argumente, und Änderungen innerhalb der Methode haben keine Auswirkungen auf die ursprünglichen Argumente.'},
     {'question': 'Was sind die Unterschiede zwischen "ref" und "out" in Bezug auf Methodenparameter in C-Sharp?', 'answer': 'In C-Sharp werden "ref" und "out" verwendet, um formale Parameter zu kennzeichnen, die durch den Methodenaufruf modifiziert werden können. Der Hauptunterschied besteht darin, dass bei "ref" die übergebene Variable vor dem Aufruf initialisiert sein muss, während bei "out" dies nicht erforderlich ist. Bei "out" muss jedoch die formale Parameter in der Methode selbst einen Wert zugewiesen bekommen. Beide ermöglichen mehrere Rückgabewerte für Methoden.'},
     {'question': 'Welche Unterschiede gibt es zwischen der Überschreibung von Methoden in C-Sharp im Vergleich zu JAVA?', 'answer': 'In C-Sharp müssen dynamisch zu bindende Methoden als "virtual" deklariert werden, und überschreibende Methoden müssen mit "override" gekennzeichnet sein. Wenn eine Methode in einer Subklasse neu eingeführt werden soll, wird "new" verwendet. Dies unterscheidet sich von JAVA, wo Methoden standardmäßig überschrieben werden können, es sei denn, sie sind als "final" deklariert. Diese Unterschiede sollen das sogenannte "Fragile-base-class-Problem" verhindern und die Programmiererin darüber informieren, welche Methoden dynamisch gebunden werden und welche nicht.'},
     {'question': 'Welche anderen Unterschiede und Konventionen gibt es zwischen C-Sharp und JAVA in Bezug auf Sprachkonstrukte?', 'answer': 'Einige Unterschiede und Konventionen zwischen C-Sharp und JAVA umfassen die Verwendung von "lock" anstelle von "synchronized" für die Synchronisation, die Verwendung von "foreach" anstelle von "for" für bestimmte Schleifen, die Möglichkeit, "Strings" als Basis einer "Switch"-Anweisung zu verwenden, und die Anforderung, dass jeder Zweig (case) einer "Switch"-Anweisung mit einer expliziten Kontrollflussanweisung ("break", "goto", "return" oder "throw") abgeschlossen sein muss. C-Sharp verfügt auch über eine "Goto"-Anweisung, die jedoch nicht in Blöcke springen kann.'},
     {'question': 'Was sind Indexer in C-Sharp und wie ähneln sie Properties?', 'answer': 'Indexer in C-Sharp sind eine Möglichkeit, auf indizierte Instanzvariablen zuzugreifen, ähnlich dem Konzept der indizierten Instanzvariablen in SMALLTALK. Jede Instanz einer Klasse mit einem Indexer hat eine Menge von indizierten Instanzvariablen, auf die über einen Index zugegriffen werden kann. Indexer verwenden Get- und Set-Methoden, um den Zugriff auf diese indizierten Variablen zu ermöglichen. Sie ähneln Properties insofern, als der Zugriff über einen Index mithilfe von Get- und Set-Abbildungen auf eine benannte Instanzvariable übertragen wird.'},
     {'question': 'Welche Schwierigkeit ergibt sich aus der kovarianten Redefinition?', 'answer': 'Durch die kovariante Redefinition wird bei einem Funktionsaufruf von "share" dynamische Bindung verwendet, was dazu führt, dass ein Objekt vom Typ "GIRL" einem "BOY" zugewiesen wird. Dies führt zu einem Programmfehler, da das Programm nicht mehr typkorrekt ist.'},
     {'question': 'Welche Unterschiede gibt es im Typsystem von EIFFEL im Vergleich zu anderen Sprachen wie JAVA?', 'answer': 'Im Gegensatz zu JAVA besitzt EIFFEL ein einheitliches Typsystem, bei dem keine separaten Referenz- und Werttypen unterschieden werden. EIFFEL unterscheidet auch nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden. Alle Operationen, einschließlich derer auf eingebauten Typen wie Integern, werden als Methoden behandelt.'},
     {'question': 'Was ist ein herausragendes Merkmal des Typsystems von EIFFEL?', 'answer': 'Ein herausragendes Merkmal des Typsystems von EIFFEL ist die Unterstützung von Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden), sowie kovariante Redefinitionen, die durch "verankerte Typen" ermöglicht werden.'},
     {'question': 'Welche Bedeutung haben "verankerte Typen" im Kontext von kovarianten Redefinitionen in EIFFEL?', 'answer': '"Verankerte Typen" (engl. "anchored types") spielen im Kontext von kovarianten Redefinitionen in EIFFEL eine wichtige Rolle. Sie ermöglichen es, die Kovarianz bei der Redefinition von Methoden zu unterstützen und sind eine besondere Eigenschaft von EIFFEL.'},
     {'question': 'Was sind einige der Eigenschaften des Typsystems von EIFFEL?', 'answer': 'Einige der prominenten Eigenschaften des Typsystems von EIFFEL sind Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen sowie die Unterstützung kovarianter Redefinitionen durch "verankerte Typen".'},
     {'question': 'Welche Arten von Anweisungen gibt es in EIFFEL?', 'answer': 'In EIFFEL gibt es Anweisungen, die aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung bestehen.'},
     {'question': 'Welche Prinzipien der Programmierung werden von EIFFEL strikt eingehalten?', 'answer': 'EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat.'},
     {'question': 'Welche Besonderheit bietet das Exception Handling in EIFFEL?', 'answer': 'EIFFEL bietet ein Exception Handling, das sich angenehm von dem in JAVA/C-Sharp/C++ unterscheidet, insbesondere erlaubt es ein "Retry", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss.'},
     {'question': 'Was ist die Besonderheit bezüglich der Verwendung des Semikolons in EIFFEL?', 'answer': 'In EIFFEL dient das Semikolon als Trennzeichen und ist kein Bestandteil einer Anweisung. Darüber hinaus kann es am Ende einer Zeile auch weggelassen werden, was dazu führt, dass kleine EIFFEL-Programme optisch aufgeräumt wirken.'},
     {'question': 'Was sind Properties in C-Sharp und wie unterscheiden sie sich von Zugriffsmethoden (Settern und Gettern)?', 'answer': 'Properties in C-Sharp sind eine Möglichkeit, auf die Felder eines Objekts zuzugreifen, indem Methoden aufgerufen werden, die wie Feldzugriffe aussehen. Sie sind die Umkehrung von Zugriffsmethoden (Settern und Gettern) und ermöglichen es, Feldzugriffe mit Nebeneffekten zu versehen. In C-Sharp werden die Schlüsselwörter "get" und "set" verwendet, wobei "get" für den Lesezugriff und "set" für den Schreibzugriff verwendet wird. Die Variable "value" wird verwendet, um den Eingabewert eines Setters zu halten.'},
     {'question': 'Welche Vorteile bieten Properties in C-Sharp im Vergleich zu direktem Feldzugriff?', 'answer': 'Properties in C-Sharp bieten den Vorteil, dass sie Feldzugriffe mit zusätzlicher Logik und Validierung versehen können. Sie machen den Code auf der Aufruferinnenseite knapper und besser lesbar, da sie wie Feldzugriffe aussehen und die Details der Implementierung verbergen. Außerdem ermöglichen sie die Simulation von Feldern mit Nur-Lese- oder Nur-Schreib-Zugriff, indem entweder der Getter oder der Setter weggelassen wird.'},
     {'question': 'Was ist die spezielle Variable "value" in einem Property-Setter?', 'answer': 'Die spezielle Variable "value" in einem Property-Setter enthält den Eingabewert, der beim Setzen des Property-Werts übergeben wurde. Sie ermöglicht es, den neuen Wert zu verarbeiten und in das entsprechende Feld oder die entsprechende Variable zu schreiben. Dies ist besonders nützlich, um Validierungen oder Transformationen beim Schreibzugriff durchzuführen.'},
     {'question': 'Welche Rolle spielt der Zuweisungsversuch bei kovarianten Redefinitionen in EIFFEL?', 'answer': 'Der Zuweisungsversuch spielt eine Rolle bei kovarianten Redefinitionen in EIFFEL, da er verwendet wird, um dynamische Bindungen programmatisch zu emulieren. Da EIFFEL polymorphe CAT-Calls verbietet, werden Zuweisungsversuche genutzt, um das dynamische Binden zu ermöglichen.'},
     {'question': 'Welche Unterschiede gibt es zwischen Zuweisungsversuchen in EIFFEL und Downcasts in JAVA?', 'answer': 'Ein Unterschied besteht darin, dass Zuweisungsversuche in EIFFEL keinen Laufzeitfehler verursachen können, im Gegensatz zu Downcasts in JAVA. Allerdings kann "void" in einer Variable in EIFFEL zur Laufzeit eine Nullzeiger-Ausnahme auslösen.'},
     {'question': 'Welche Rolle spielt die kovariante Redefinition in EIFFEL?', 'answer': 'In EIFFEL kann die kovariante Redefinition verwendet werden, um den Typ von Variablen automatisch mit dem Typ eines anderen, bereits typisierten Programms zu verknüpfen. Dies ermöglicht die automatische Anpassung von Typen bei Vererbung.'},
     {'question': 'Welche Probleme ergeben sich aus der Verwendung von kovarianten Redefinitionen in EIFFEL?', 'answer': 'Die Verwendung von kovarianten Redefinitionen in EIFFEL kann zu Problemen führen, insbesondere wenn dynamische Bindungen auftreten. Dies kann dazu führen, dass Typen inkonsistent werden und unerwartetes Verhalten auftritt.'},
     {'question': 'Welche Rolle spielen verankerte Typdeklarationen in EIFFEL?', 'answer': 'Verankerte Typdeklarationen in EIFFEL ermöglichen es, den Typ von Variablen automatisch an den Typ eines bereits typisierten Programms zu binden. Dies erleichtert die Verwendung von kovarianten Redefinitionen.'},
     {'question': 'Was sind Tupel in EIFFEL und wofür werden sie verwendet?', 'answer': 'Tupel sind in EIFFEL eine relativ neue Funktion, die es ermöglicht, mehrere Objekte ohne die Notwendigkeit der Definition einer eigenen Klasse zu gruppieren. Sie sind besonders nützlich, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugewiesen wird. Tupel werden oft verwendet, wenn Methoden mehrere Werte zurückgeben sollen.'},
     {'question': 'Welche Rolle spielen die Positionen und Positionsnamen in Tupeln?', 'answer': 'In Tupeln spielen die Positionen und gegebenenfalls die Positionsnamen eine wichtige Rolle. Sie dienen dazu, die Struktur des Tupels festzulegen und die Werte den richtigen Positionen zuzuordnen. Die Zuordnung eines Tupels zu einem Tupeltyp erfolgt durch den Abgleich der vorhandenen Positionen mit den deklarierten Positionstypen sowie gegebenenfalls den Positionsnamen.'},
     {'question': 'Was ist das Friends-Konzept in C++?', 'answer': 'Das Friends-Konzept in C++ ermöglicht es, dass bestimmte Klassen auf private Elemente einer anderen Klasse zugreifen können, ohne direkte Mitglieder dieser Klasse zu sein.'},
     {'question': 'Welchen Nachteil hat die Verwendung von Paketen in Java für die Zusammenarbeit von Klassen?', 'answer': 'In Java hatte man bis zur Version 8 die Möglichkeit, Klassen in ein Paket zu verfrachten, um die Zusammenarbeit von Klassen zu ermöglichen. Der Nachteil dabei ist, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben, was die Aufteilung der Klassen auf Pakete einschränken kann.'},
     {'question': 'Welche Antwort auf Java stellt C-Sharp dar?', 'answer': 'C-Sharp ist Microsofts Antwort auf Java.'},
     {'question': 'Was sind einige der zusätzlichen Merkmale von C-Sharp, die es im Vergleich zu Java enthält?', 'answer': 'C-Sharp enthält einige zusätzliche Merkmale von C++ sowie von Microsofts hauseigener Sprache, Visual Basic.'},
     {'question': 'Was sind einige der Unterschiede im Typsystem von C-Sharp, die im Text erwähnt werden?', 'answer': 'Im Text werden die folgenden Unterschiede im Typsystem von C-Sharp im Vergleich zu Java erwähnt: Die Unterscheidung von Wert- und Referenztypen. Die verschiedenen Typkonstruktoren für Wert- und Referenztypen. Der Umgang mit Interfaces als Typen.'},
     {'question': 'Welche weiteren Verbesserungen im Zusammenhang mit dem Typsystem von C-Sharp werden im Text erwähnt?', 'answer': 'Im Text wird erwähnt, dass C-Sharp noch eine ganze Reihe weiterer Verbesserungen im Zusammenhang mit dem Typsystem aufweist, jedoch wird auf diese Verbesserungen hier nur am Rande eingegangen, ohne sie im Detail zu erläutern.'},
     {'question': 'Welches Programmiermodell wird in C++ verwendet?', 'answer': 'Das Programmiermodell von C++ ist ein klassisches Modell, bei dem Programme als eine Menge von Quellcode-Dateien geschrieben werden, die auf einer Zielmaschine direkt in ausführbaren Maschinencode übersetzt werden.'},
     {'question': 'Was ist das Ziel von C++ in Bezug auf die Art von Anwendungen, die es unterstützt?', 'answer': 'C++ zielt auf die gleiche Klasse von Anwendungen wie C ab, insbesondere maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen, wobei extreme Speicher- und Recheneffizienz oft oberste Kriterien sind.'},
     {'question': 'Was ist das Ziel des Typsystems von C++?', 'answer': 'Das Ziel des Typsystems von C++ ist, objektorientierte Programmierung mit starker Typsicherheit zu ermöglichen, während gleichzeitig die volle Freiheit der Programmiererin erhalten bleibt und der Laufzeit-Overhead minimiert wird.'},
     {'question': 'Welche primitive Datentypen gibt es in C++?', 'answer': 'In C++ gibt es primitive Datentypen wie int, bool, etc. Diese Datentypen sind genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik.'},
     {'question': 'Was ist ein Typumwandlung (Type cast) in C++?', 'answer': 'Eine Typumwandlung (Type cast) in C++ ist ein Ausdruck der Form <Typ> <Ausdruck>, der den Compiler davon überzeugt, dass das Objekt, für das <Ausdruck> steht, vom Typ <Typ> ist und entsprechend verwendet werden kann. Diese Umwandlung wird vom Compiler überwacht, und die Zulässigkeit wird zur Laufzeit überprüft.'},
     {'question': 'Welche Eigenschaften sollte eine typsichere Sprache haben?', 'answer': 'Eine typsichere Sprache wie C-Sharp soll strikte Typprüfungen durchführen, um sicherzustellen, dass Variablen nur Werte akzeptieren, die ihrem deklarierten Typ entsprechen.'},
     {'question': 'Welcher Operator in C-Sharp entspricht dem instanceof-Operator in Java?', 'answer': 'In C-Sharp entspricht der Operator is dem instanceof-Operator in Java. Er prüft, ob das Ergebnis der Auswertung eines Ausdrucks mit einem gegebenen Typ T zuweisungskompatibel ist.'}],
    [{'question': 'Wie werden Klassenfelder und -methoden in C++ deklariert?', 'answer': 'Klassenfelder und -methoden werden in C++ mit dem Schlüsselwort "static" in einer Klasse eingeführt, ähnlich wie in Java.'},
     {'question': 'Wie erfolgt die Erzeugung von Objekten in C++ im Vergleich zu Java?', 'answer': 'In C++ erfolgt die Erzeugung von Objekten oft ohne "new". Der benötigte Speicherplatz wird bei der Deklaration reserviert, und es entstehen Werte (Objekte) mit Wertsemantik, im Gegensatz zu Java, wo "new" verwendet wird.'},
     {'question': 'Wie erzeugt man in C++ Objekte mit Identität?', 'answer': 'Um in C++ Objekte mit Identität zu erzeugen, muss man Zeigervariablen (Pointer) verwenden und eine Klasse mit dem "new"-Operator instanziieren.'},
     {'question': 'Wie sieht die Dereferenzierung eines Zeigers auf ein Objekt in C++ aus?', 'answer': 'In C++ erfolgt die Dereferenzierung eines Zeigers auf ein Objekt mit "->", z.B., "a->x" oder "a->f(x)" für ein Feld oder eine Methode der Klasse.'},
     {'question': 'Wie kann in C++ "Call by reference" erreicht werden?', 'answer': 'In C++ kann "Call by reference" erreicht werden, indem man den Zeigeroperator "&" verwendet und die formalen Parameter so deklariert, dass sie Zeiger auf Zeiger aufnehmen können.'},
     {'question': 'Wie wird das Varianzproblem bei der Subtypisierung von Containern in C-Sharp gelöst?', 'answer': 'In C-Sharp wird das Varianzproblem bei der Subtypisierung von Containern durch das Hinzufügen des Schlüsselworts "out" für kovariante Typparameter und "in" für kontravariante Typparameter bei der Definition des Typs gelöst. Dies stellt sicher, dass Zuweisungskompatibilität auch dann gegeben ist, wenn die generischen Typen verschiedene Typparameter haben.'},
     {'question': 'Wie hat Microsoft versucht, das Problem der Kommunikation mit unbekannten Objekten auf der Ebene der Programmiersprache zu lösen?', 'answer': 'Microsoft hat versucht, das Problem der Kommunikation mit unbekannten Objekten teilweise von der Ebene der Programmierung auf die Ebene der Programmiersprache zu heben, indem sie das Konstrukt des Events (Ereignisses) eingeführt haben. Über Ereignisse können sogenannte Eventhandler aktiviert werden, die auf unerwartete Ereignisse reagieren können. Dies wurde mithilfe von Delegates realisiert, wie im Abschnitt 50.4.1 skizziert.'},
     {'question': 'Wie wird in C-Sharp sichergestellt, dass explizite Interfaceimplementierungen von außen aufgerufen werden?', 'answer': 'In C-Sharp muss der tatsächliche deklarierende Typ des Objekts als Qualifikator für den Methodenaufruf angegeben werden, um sicherzustellen, dass die richtige explizite Interfaceimplementierung aufgerufen wird.'},
     {'question': 'Wie werden in EIFFEL überschriebene Methoden bezeichnet?', 'answer': 'In EIFFEL werden überschriebene Methoden als "Redefinition" bezeichnet.'},
     {'question': 'Wie können in EIFFEL Methoden mit demselben Namen in verschiedenen Klassen behandelt werden?', 'answer': 'In EIFFEL ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben, solange diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen. Wenn die Methoden gleiche oder kovariant redefinierte Parameter haben, handelt es sich nicht um Überladung, sondern um Überschreibung.'},
     {'question': 'Wie kann in EIFFEL sichergestellt werden, dass geerbte Features mit demselben Namen unterschiedlich benannt werden?', 'answer': 'EIFFEL ermöglicht es, geerbte Features umzubenennen, indem eine "Rename"-Klausel verwendet wird. Diese Klausel erlaubt es, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen, ohne das dynamische Binden zu beeinflussen.'},
     {'question': 'Wie unterscheidet sich das Programmiermodell von C-Sharp von dem von JAVA?', 'answer': 'Das Programmiermodell von C-Sharp weist zunächst einige Ähnlichkeiten mit dem von JAVA auf, da es ebenfalls auf Klassen basiert und der Code in einzelnen Klassen organisiert ist. Die Klassen in C-Sharp können jedoch in lockererem Verhältnis zu Dateien stehen, und Klassen können anders benannt werden als ihre Dateien. Ein wesentlicher Unterschied besteht darin, dass der Bytecode von C-Sharp und die zugehörige virtuelle Maschine, Common Intermediate Language (CIL) genannt, für alle .NET-Sprachen entwickelt wurden und nicht exklusiv für C-Sharp. Die CIL gilt als menschenlesbar.'},
     {'question': 'Wie werden Vor- und Nachbedingungen in EIFFEL formuliert?', 'answer': 'Vor- und Nachbedingungen in EIFFEL werden als Boolesche Ausdrücke formuliert, die immer als "wahr" ausgewertet werden müssen. Die "require"-Klausel stellt Bedingungen dar, die vor dem Aufruf der Methode erfüllt sein müssen, während die "ensure"-Klausel Bedingungen darstellt, die nach dem Aufruf der Methode garantiert erfüllt sind.'},
     {'question': 'Wie werden Zusicherungen in EIFFEL vererbt, insbesondere wenn eine Methode redefiniert wird?', 'answer': 'Zusicherungen, einschließlich Vor- und Nachbedingungen, werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen die Zusicherungen angepasst werden, jedoch mit bestimmten Einschränkungen. Die Vorbedingung darf nur abgeschwächt und die Nachbedingung nur verschärft werden, und die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingungen eingehalten werden.'},
     {'question': 'Wie kann RTTI in C++ verwendet werden, um den Typ eines Objekts zu ermitteln?', 'answer': 'RTTI kann verwendet werden, indem die Funktion typeid auf eine Referenz aufgerufen wird. Diese Funktion ist auf Klassennamen überladen und gibt eine Struktur zurück, auf der == als Gleichheitstest definiert ist. Der Typ eines Objekts kann überprüft werden, indem typeid(x) == typeid(T) verwendet wird.'},
     {'question': 'Wie kann in C++ ohne Verwendung von typeid herausgefunden werden, welcher Klasse Instanzen aller Klassen angehören?', 'answer': 'Eine Möglichkeit, den Typ einer Klasse in C++ ohne Verwendung von typeid herauszufinden, ist die Verwendung von dynamic_cast. Man kann versuchen, das Objekt auf verschiedene Klassen zu überprüfen, und wenn das Casting erfolgreich ist, gehört das Objekt zu dieser Klasse.'},
     {'question': 'Wie werden Zugriffsmethoden in EIFFEL syntaktisch dargestellt?', 'answer': 'Zugriffsmethoden in EIFFEL sehen syntaktisch aus wie Variablen, können jedoch Funktionen (Setter) oder Funktionen (Getter) sein. Sie können verwendet werden, um Werte zu setzen oder zu lesen.'},
     {'question': 'Wie werden in EIFFEL Abfragen und Befehle logisch unterteilt?', 'answer': 'In EIFFEL werden Methoden einer Klasse als "Abfragen" (queries) und "Befehle" (commands) logisch unterteilt. Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern.'},
     {'question': 'Wie wird der Zugriff auf Features in EIFFEL kontrolliert?', 'answer': 'In EIFFEL wird der Zugriff auf Features durch die gezielte Veröffentlichung (Export) von Features gesteuert. Klassen, die auf diese Features zugreifen sollen, werden explizit genannt.'},
     {'question': 'Wie unterscheidet sich EIFFEL von C++ in Bezug auf die Ausführungsumgebung?', 'answer': 'Im Gegensatz zu C++ führt EIFFEL den Code nicht auf einer virtuellen Maschine aus, sondern direkt auf der Zielmaschine. Es gibt jedoch auch eine Version von EIFFEL für .NET, die in CIL übersetzt und dann in Maschinencode ausgeführt wird.'},
     {'question': 'Wie wird EIFFEL als Sprache häufig charakterisiert?', 'answer': 'EIFFEL wird als eine akademische Sprache charakterisiert, was bedeutet, dass sie in erster Linie in der akademischen Welt verwendet wird und möglicherweise weniger in kommerziellen Anwendungen anzutreffen ist.'},
     {'question': 'Wie wird in EIFFEL ein Typtest durchgeführt?', 'answer': 'In EIFFEL wird ein Typtest mithilfe eines "Zuweisungsversuchs" (engl. "assignment attempt") durchgeführt. Wenn es keine Zuweisungskompatibilität zwischen den Typen gibt, wird "void" (entsprechend "nil" in SMALLTALK oder "null" in JAVA) zugewiesen. Die Programmiererin muss dann den Typ von "a" nach der Zuweisung überprüfen.'},
     {'question': 'Wie definiert EIFFEL unparametrisierte und parametrisierte Klassen?', 'answer': 'In EIFFEL definiert jede unparametrisierte Klasse einen Typ, während jede parametrisierte Klasse eine (generische) Menge von Typen definiert.'},
     {'question': 'Wie wird in EIFFEL zwischen Wert- und Referenztypen unterschieden?', 'answer': 'In EIFFEL kann bei der Deklaration angegeben werden, ob Variablen eines Typs Wertsemantik oder Referenzsemantik haben sollen. Dies kann für alle Variablen eines Typs oder nur für bestimmte Variablen festgelegt werden.'},
     {'question': 'Wie könnte man die Kovarianzprobleme in EIFFEL verhindern?', 'answer': 'Es gibt verschiedene Ansätze, um die Kovarianzprobleme in EIFFEL zu verhindern, darunter die Beschränkung der Zuweisungskompatibilität, die Durchführung einer Typinferenz für das gesamte Programm und das Verbot dynamisch gebundener Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen ändern. Jede dieser Methoden hat jedoch ihre eigenen Einschränkungen und Herausforderungen.'},
     {'question': 'Wie werden Tupeltypen in EIFFEL deklariert?', 'answer': 'Tupeltypen in EIFFEL werden deklariert, indem für jede Position im Tupel ein Typ angegeben wird. Konkrete Werte eines Tupels werden in eckigen Klammern notiert, wobei die Positionen optional auch Namen erhalten können.'},
     {'question': 'Wie wird in C++ festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen?', 'answer': 'In C++ wird festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen, indem man die betreffenden Klassen mit dem Schlüsselwort "friend" in der Zielsklasse deklariert. Zum Beispiel: friend class B; und friend class C;'},
     {'question': 'Wie wird das Friends-Konzept in Java angenähert?', 'answer': 'Das Friends-Konzept wird in Java durch die Verwendung von Modulen und den dedizierten (qualifizierten) Export auf Ebene der Pakete angenähert. Dies ermöglicht eine kontrollierte Freigabe von Elementen an bestimmte Pakete.'},
     {'question': 'Wie ermöglicht C++ die getrennte Übersetzung von Programmteilen?', 'answer': 'C++ ermöglicht die getrennte Übersetzung von Programmteilen mithilfe von Header-Dateien, die die Schnittstellen der Teile enthalten.'},
     {'question': 'Wie erfolgt die Methodenbindung in C++ standardmäßig?', 'answer': 'Standardmäßig erfolgt die Methodenbindung (Methodenaufruf) in C++ statisch. Das bedeutet, dass die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable hat.'},
     {'question': 'Wann werden Methoden in C++ zur Laufzeit dynamisch gebunden?', 'answer': 'In C++ werden Methoden zur Laufzeit dynamisch gebunden, wenn sie mit dem Schlüsselwort virtual deklariert sind. Bei virtuellen Methoden wird zur Laufzeit überprüft, welchen Typs das Objekt ist, und zur entsprechenden Methodenimplementierung verzweigt.'},
     {'question': 'Wie wird Generizität in C++ implementiert?', 'answer': 'Generizität in C++ wird mit Hilfe von Templates erreicht. Ein Template ist ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Tatsächlich werden aus Templates neue Typen erzeugt, und für jede Instanz eines generischen Typs wird ein neuer Typ erzeugt und kompiliert.'},
     {'question': 'Wie wird die Zulässigkeit von Typumwandlungen in C++ überprüft?', 'answer': 'Die Zulässigkeit von Typumwandlungen in C++ wird zur Laufzeit überprüft, und sie kann nicht zur Kompilierzeit überprüft werden. Typumwandlungen sollten vermieden werden, da sie die Typsicherheit untergraben können.'},
     {'question': 'Wie kann in C-Sharp eine Typumwandlung (Casting) durchgeführt werden?', 'answer': 'In C-Sharp kann eine Typumwandlung mithilfe von Casts durchgeführt werden. Die Syntax dafür ist (T)a;, wobei T der Zieltyp ist und a der Ausdruck, der umgewandelt werden soll.'},
     {'question': 'Wie wird in C-Sharp sichergestellt, dass ein Cast sicher ist?', 'answer': 'In C-Sharp wird ein Cast sicher gemacht, indem der is-Operator verwendet wird, um zu prüfen, ob die Zuweisung kompatibel ist. Zusätzlich kann der as-Operator verwendet werden, der bei fehlschlagender Zuweisung null zurückgibt.'}],
    [{'question': 'Was enthält eine C++ Klasse neben Feldern (Instanzvariablen)?', 'answer': 'Eine C++ Klasse enthält neben Feldern (Instanzvariablen) auch Methoden.'},
     {'question': 'Gibt es in C++ die Möglichkeit, "Call by reference" ohne Verwendung des Zeigeroperators "&" zu erreichen?', 'answer': 'Ja, in C++ gibt es die Möglichkeit, "Call by reference" ohne Verwendung des Zeigeroperators "&" zu erreichen, ähnlich wie in Pascal. Hierbei bleiben die Aufrufstellen unverändert.'},
     {'question': 'Was unterscheidet Generics in C-Sharp und Generics in Java?', 'answer': 'Obwohl die Oberfläche von C-Sharp Generics der von Java ähnelt, unterscheidet sich der Mechanismus dahinter. C-Sharp instanziiert generische Klassen für Werttypen (wie int oder selbst definierte structs) für jeden verwendeten Typ, während Java Typparameter grundsätzlich immer entfernt (Type Erasure) und nur eine Implementierung erzeugt.'},
     {'question': 'Bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten?', 'answer': 'Ja, in C-Sharp bleibt die generische Typinformation auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.'},
     {'question': 'Gibt es in C-Sharp eine Möglichkeit zur Typparameter-Inferenz bei generischen Methodenaufrufen?', 'answer': 'Ja, C-Sharp unterstützt Typparameter-Inferenz, was bedeutet, dass der Compiler den tatsächlichen Typparameter bei generischen Methodenaufrufen automatisch aus den Argumenten ableiten kann. Dies führt zu weniger Code und erhöht die Lesbarkeit.'},
     {'question': 'Warum wird C++ als "sofortige Legacy"-Sprache bezeichnet?', 'answer': 'C++ wird als "sofortige Legacy"-Sprache bezeichnet, weil sie eine Erweiterung von C ist und eine chaotische Syntax hat, die es schwer macht, den Code zu verstehen oder zurückzuentwickeln. Außerdem gibt es viele große Projekte, die bereits in veralteten C++-Dialekten geschrieben wurden.'},
     {'question': 'Warum wird darauf hingewiesen, dass C++ eine Erweiterung von C ist?', 'answer': 'Es wird darauf hingewiesen, dass C++ eine Erweiterung von C ist, um zu betonen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist. Dies bedeutet, dass C++-Code mit C-Code kombiniert werden kann und C++-Programmierer auf bestehende C-Bibliotheken zugreifen können.'},
     {'question': 'Warum wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann?', 'answer': 'Es wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann, um zu betonen, dass die Lesbarkeit des Codes in C++ stark von der Programmierpraxis abhängt. C++ bietet die Flexibilität, Code auf unterschiedliche Weisen zu schreiben, von sehr lesbar bis hin zu sehr unlesbar, je nach den Entscheidungen der Entwickler.'},
     {'question': 'Warum benötigen viele Applikationen, insbesondere solche mit GUI, eine Kommunikation mit unbekannten Objekten?', 'answer': 'Viele Applikationen benötigen eine Kommunikation mit unbekannten Objekten, da sie neben der direkten Kommunikation zwischen Objekten, die sich kennen, auch mit anderen Objekten kommunizieren müssen, die nicht im Voraus bekannt sind. Dies tritt insbesondere in Anwendungen mit grafischer Benutzeroberfläche (GUI) auf, wo verschiedene Elemente miteinander interagieren müssen, ohne im Voraus genau zu wissen, welche Objekte diese Interaktion benötigen.'},
     {'question': 'Warum bezeichnet der Autor die Syntax von C-Sharp im Zusammenhang mit Events als "komplett unleserlich"?', 'answer': 'Der Autor bezeichnet die Syntax von C-Sharp im Zusammenhang mit Events als "komplett unleserlich", weil er sie als schwer verständlich oder verwirrend empfindet. Dies kann auf die Art und Weise zurückzuführen sein, wie Events deklariert, Eventhandler registriert und Ereignisse behandelt werden, was möglicherweise die Lesbarkeit des Codes beeinträchtigt.'},
     {'question': 'Was passiert, wenn man versucht, eine explizite Interfaceimplementierung mit einem anderen Zugriffsmodifikator als "public" zu deklarieren?', 'answer': 'In C-Sharp ist es möglich, Methoden von expliziten Interfaceimplementierungen mit Zugriffsmodifikatoren, die nicht "public" sind, von außen aufzurufen. Dies ist jedoch an die explizite Implementierung gebunden und erfordert die Verwendung des richtigen Interfacequalifikators.'},
     {'question': 'Können explizite Interfaceimplementierungen in C-Sharp überschrieben werden?', 'answer': 'Nein, explizite Interfaceimplementierungen können nicht überschrieben werden. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut.'},
     {'question': 'Gibt es eine Namenskonvention für Interfaces in C-Sharp?', 'answer': 'Ja, im Common Type System von .NET sollten alle Interfacenamen mit einem "I" beginnen. Dies dient zur Unterscheidung von Interface- und Klassennamen und folgt der Tradition der ungarischen Notation bei Microsoft.'},
     {'question': 'Warum wurde in C-Sharp das Hantieren mit Pointern wieder eingeführt, und wie werden unsichere Bereiche behandelt?', 'answer': 'In C-Sharp wurde das Hantieren mit Pointern in unsichere Bereiche verbannt, weil es in systemnahen Programmierungen und beim Zugriff auf das Betriebssystem notwendig ist. Der Modifikator "unsafe" kennzeichnet solche unsicheren Bereiche und wird verwendet, um den Einsatz von Pointern zu ermöglichen. In unsicheren Bereichen können Zeiger auf Typen deklariert werden, und die Dereferenzierung eines Zeigers erfolgt mit einem Stern (*). Dies ermöglicht das Hantieren mit Pointern in einem begrenzten und kontrollierten Umfeld.'},
     {'question': 'Warum wird C++ als eine sehr komplexe Sprache beschrieben?', 'answer': 'C++ wird als eine sehr komplexe Sprache beschrieben, weil ihre Beherrschung Jahre dauern kann, selbst bei täglichem Umgang mit ihr. Die eigentliche Komplexität ergibt sich aus der kombinierten Verwendung ihrer zahlreichen Konstrukte, und die Möglichkeiten sind vielfältig.'},
     {'question': 'Warum ist es schwer, C++ zu lehren?', 'answer': 'Es ist schwer, C++ zu lehren, weil die Sprache sehr komplex ist und die Kombinatorik ihrer Konstrukte zu einer hohen Zahl von Möglichkeiten führt. Die Vielzahl von Idiomen (Wendungen) in C++ trägt ebenfalls zur Komplexität bei.'},
     {'question': 'Warum ist es schwierig, die Komplexität von C++ von der Objektorientierung zu trennen?', 'answer': 'Es ist schwierig, die Komplexität von C++ von der Objektorientierung zu trennen, weil viele Beiträge zur Komplexität von C++ in Zusammenhang mit der Objektorientierung stehen. Die Kombination von objektorientierten Konzepten und anderen Sprachmerkmalen macht C++ zu einer komplexen Sprache.'},
     {'question': 'Was wird als mögliche Gefahr hinsichtlich der Entwicklung von C-Sharp und Java erwähnt?', 'answer': 'Als mögliche Gefahr wird erwähnt, dass die beiden Sprachen sich gegenseitig übertrumpfen könnten. Es besteht die Möglichkeit, dass jemand auf die Idee kommt, die besten Eigenschaften beider Sprachen zu kombinieren und eine neue Sprache zu entwickeln. Dies könnte auch eine Gelegenheit sein, sich von den Syntax-Erben aus der C-Welt zu verabschieden.'},
     {'question': 'Warum könnte EIFFEL trotz seiner Funktionen kein größerer Erfolg geworden sein?', 'answer': 'Es gibt mehrere mögliche Gründe für den begrenzten Erfolg von EIFFEL. Dies könnte auf unzureichende Implementierungen der Werkzeuge, die Kompromisslosigkeit des Schöpfers BERTRAND MEYER und den Spagat zwischen kommerzieller Anwendbarkeit und akademischer Eignung zurückzuführen sein. Auch das Typsystem von EIFFEL und akademische Vorbehalte gegenüber bestimmten Programmierweisen könnten eine Rolle spielen. Trotzdem hat EIFFEL Einfluss auf die Art und Weise, wie über das Programmieren nachgedacht wird.'},
     {'question': 'Gibt es in C-Sharp einen Unterschied zwischen Wert- (primitiven) und Referenztypen wie in JAVA?', 'answer': 'In C-Sharp wird zunächst nicht zwischen Wert- (primitiven) und Referenztypen wie in JAVA unterschieden. Alle Typen, einschließlich der primitiven Typen, gelten als von Object (genauer: System.Object) abgeleitet.'},
     {'question': 'Bietet C++ eine dynamische Typprüfung wie andere Sprachen?', 'answer': 'Nein, C++ bietet keine eingebaute dynamische Typprüfung.'},
     {'question': 'Warum wissen einige Objekte in C++, von welcher Klasse sie eine Instanz sind?', 'answer': 'Einige Objekte in C++ wissen zumindest im Prinzip, von welcher Klasse sie eine Instanz sind, weil sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Diese virtuelle Funktionstabelle dient als eine Art Repräsentation der Klasse.'},
     {'question': 'Gibt es in EIFFEL Zugriffsmodifikatoren wie in JAVA oder C++?', 'answer': 'Nein, es gibt in EIFFEL keine Zugriffsmodifikatoren wie in JAVA oder C++. Alle Features sind standardmäßig öffentlich zugänglich.'},
     {'question': 'Bietet EIFFEL spezielle Konstrukte zur Leistungsoptimierung?', 'answer': 'Nein, EIFFEL sieht keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Die Performance-Verbesserungen werden vollständig einem optimierenden Compiler überlassen.'},
     {'question': 'Warum kann Mehrfachvererbung in C++ sinnvoll sein?', 'answer': 'Mehrfachvererbung kann aus verschiedenen Gründen sinnvoll sein: Eine Klasse kann von mehreren vollständig abstrakten Klassen erben und damit mehrere Interfaces implementieren. In Aufgabenstellungen, in denen eine Klasse Eigenschaften von mehreren anderen Klassen benötigt, erlaubt Mehrfachvererbung, alle benötigten Eigenschaften zu erben, anstatt sich für eine einzige Superklasse entscheiden zu müssen.'},
     {'question': 'Warum gibt es in C-Sharp keine "Throws"-Klauseln in Methodendeklarationen, wie sie in JAVA existieren?', 'answer': 'C-Sharp verzichtet auf "Throws"-Klauseln in Methodendeklarationen, die in JAVA zur Unterscheidung von Checked Exceptions und Unchecked Exceptions verwendet werden. Stattdessen gibt es in C-Sharp nur Unchecked Exceptions. Diese Entscheidung wurde getroffen, um die Programmierer nicht dazu zu zwingen, im Voraus zu wissen, was in jeder Methode schief gehen kann. Es gibt jedoch Möglichkeiten, Exception-Handling in C-Sharp durch "Exception chaining" und "Exception tunneling" zu implementieren.'},
     {'question': 'Können Indexer in C-Sharp überladen werden und mehrere indizierte Instanzvariablen simulieren?', 'answer': 'Ja, Indexer in C-Sharp können überladen werden, um mehrere indizierte Instanzvariablen zu simulieren. Dies ermöglicht einem Objekt, mehrere indizierte Variablen mit unterschiedlichen Indexen zu haben. Die Einschränkung dabei ist, dass der Rückgabetyp (Elementtyp) beim Überladen gleich bleiben muss. Indexer können auch berechnete Werte zurückgeben, ohne auf interne Instanzvariablen zuzugreifen, ähnlich wie Properties.'},
     {'question': 'Warum wird in EIFFEL eine kovariante Redefinition benötigt?', 'answer': 'In EIFFEL wird eine kovariante Redefinition benötigt, um die Unterkunft der jungen Skifahrerinnen nach Geschlechtern getrennt zu organisieren. Dies ermöglicht es, Mädchen und Jungen unterschiedliche Typen für "roommate" zuzuweisen.'},
     {'question': 'Warum führt die implizite Allquantifizierung einer Deklaration zu einem Fehler?', 'answer': 'Die implizite Allquantifizierung einer Deklaration wie "SKIER.share(SKIER)" bedeutet nicht, dass alle Skifahrerinnen (beider Geschlechter) ihr Zimmer mit allen Skifahrerinnen teilen können. Dies ist aufgrund von Faktoren wie Krankheit nicht immer möglich. Die statische Typisierung kann solche situativen Unterschiede nicht abbilden.'},
     {'question': 'Warum sind Typtests in EIFFEL manchmal notwendig?', 'answer': 'Typtests in EIFFEL sind manchmal notwendig, um festzustellen, welchen genauen Typ ein Element hat, das in einen Container (eine Variable oder eine Collection) ungleichen Typs gelegt wurde. Dadurch kann das Element entsprechend seines Typs verwendet werden.'},
     {'question': 'Gibt es in EIFFEL explizite Typumwandlungen wie in anderen Sprachen?', 'answer': 'In EIFFEL gibt es keine expliziten Typumwandlungen wie in einigen anderen Sprachen. Die Typumwandlung erfolgt immer in Verbindung mit einer Zuweisung.'},
     {'question': 'Was unterscheidet Werttypen und Referenztypen in EIFFEL?', 'answer': 'Anders als in C-Sharp unterscheidet EIFFEL nicht zwischen Wert- und Referenztypen auf der Ebene von Typkonstruktoren. Stattdessen kann es für jeden Typ sowohl Wertsemantik als auch Referenzsemantik geben.'},
     {'question': 'Warum ist das Friends-Konzept in C++ nützlich?', 'answer': 'Das Friends-Konzept ist nützlich, wenn ein Teilproblem in der Programmierung nicht von einer einzelnen Klasse gelöst werden kann, sondern die Zusammenarbeit mehrerer Klassen erfordert. Es ermöglicht, dass diese Klassen eng zusammenarbeiten können, ohne dass alle Klassen dieselbe Schnittstelle haben müssen.'},
     {'question': 'Gibt es in C++ die Möglichkeit, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren?', 'answer': 'Nein, in C++ ist es nicht möglich, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren. Stattdessen erlaubt das Friends-Konzept, dass bestimmte Klassen auf alle privaten Elemente einer anderen Klasse zugreifen können.'},
     {'question': 'Warum wurde C-Sharp entwickelt?', 'answer': 'Die Entwicklung von C-Sharp wurde weniger als Versuch betrachtet, mit Microsofts Marktmacht einen proprietären Standard durchzusetzen, sondern war vielmehr dem Umstand geschuldet, dass Java keine volle Kontrolle über Hardware und Betriebssystem bietet und somit nicht für jede kommerzielle Softwareentwicklung geeignet ist.'},
     {'question': 'In welchen wesentlichen Punkten unterscheidet sich das Typsystem von C-Sharp von dem von Java?', 'answer': 'Das Typsystem von C-Sharp unterscheidet sich von Java in mehreren wesentlichen Punkten, darunter die Art der Unterscheidung von Wert- und Referenztypen, die angebotenen Typkonstruktoren für Wert- und Referenztypen und den Umgang mit Interfaces als Typen.'},
     {'question': 'Warum ist es wichtig, andere objektorientierte Programmiersprachen zu kennen?', 'answer': 'Es ist wichtig, andere objektorientierte Programmiersprachen zu kennen, da Praktikerinnen und solche, die es werden wollen, die Programmiersprachen kennen müssen, die auf dem Markt gefragt sind. Dies ermöglicht es ihnen, in verschiedenen beruflichen Situationen flexibel zu sein und die am besten geeignete Sprache für bestimmte Aufgaben auszuwählen.'},
     {'question': 'Was ermöglicht Mehrfachvererbung in C++?', 'answer': 'Mehrfachvererbung in C++ ermöglicht es, eine Klasse von mehreren anderen abzuleiten. Dadurch kann eine Klasse mehrere direkte Supertypen haben, einen pro direkte Superklasse.'},
     {'question': 'Was passiert, wenn eine Typumwandlung in C-Sharp nicht möglich ist?', 'answer': 'Wenn eine Typumwandlung in C-Sharp nicht möglich ist, weil der tatsächliche Typ des Ausdrucks a kein Subtyp von T ist oder keine entsprechende Typumwandlung definiert ist, führt dies zu einem Laufzeitfehler.'}],
]
KE6_questions = [
    [{'question': 'Was ist das Problem der schlechten Tracebarkeit?', 'answer': 'Das Problem der schlechten Tracebarkeit entsteht durch den dynamischen Programmablauf. Die Goto-Anweisung erlaubt Sprünge von beliebigen Stellen eines Programms zu anderen Stellen und bricht dabei das Lokalitätsprinzip von Programmen, bei dem zusammengehörende Anweisungen im Programmtext nahe beieinander stehen. Dies führte zu einer Unübersichtlichkeit im Programmtext und erschwerte das Verstehen und Debuggen von Programmen.'},
     {'question': 'Welche Probleme ergeben sich bei der Verwendung dynamisch gebundener Unterprogrammaufrufe in der objektorientierten Programmierung?', 'answer': 'Bei der Verwendung dynamisch gebundener Unterprogrammaufrufe in der objektorientierten Programmierung ergibt sich das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht. Dies führt zu einer Unsicherheit darüber, welcher Code tatsächlich ausgeführt wird, insbesondere beim Tracen oder Debuggen von Programmen.'},
     {'question': 'Welche Idee aus der formalen Programmverifikation wird verwendet, um das Verhalten von Objekten in der Subtypenbeziehung zu berücksichtigen?', 'answer': 'Die Idee aus der formalen Programmverifikation besteht darin, Vorbedingungen in Nachbedingungen zu überführen, um das Verhalten von Objekten eines Typs zu berücksichtigen. Dies wird verwendet, um sicherzustellen, dass die Implementierung eines Typs korrekt ist und dass aus Vorbedingungen die entsprechenden Nachbedingungen folgen.'},
     {'question': 'Welches Konzept bieten Programmiersprachen wie Java und C-Sharp, um die doppelte Sichtweise auf Typen zu unterstützen?', 'answer': 'Programmiersprachen wie Java und C-Sharp bieten das Konzept von "Interfaces als Typen" an, mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. Dies ermöglicht es den Nutzerinnen, ihre eigenen Anforderungen als Typen zu definieren. Allerdings wird diese Möglichkeit in der Praxis oft nicht genutzt, um Anwenderinnen ihre eigenen Typen definieren zu lassen. Es wird jedoch darauf hingewiesen, dass dies in Zukunft anders gehandhabt werden könnte.'},
     {'question': 'Was ist das Fragile-Base-Class-Problem?', 'answer': 'Das Fragile-Base-Class-Problem bezieht sich auf eine Gruppe von Problemen in der Vererbung von Klassen. Wenn zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, können Änderungen an der Basisklasse zu unerwarteten und unerwünschten Auswirkungen in der abgeleiteten Klasse führen.'},
     {'question': 'Welche Herausforderungen ergeben sich aus dem Fragile-Base-Class-Problem in verteilten Objektsystemen?', 'answer': 'In verteilten Objektsystemen wird das Problem komplexer, da Änderungen an einer Komponente unerwartete Auswirkungen auf verwandte Komponenten haben können. Die Schnittstellen und Beziehungen zwischen Komponenten müssen klar und stabil sein, um unerwartetes Verhalten zu verhindern. Das Problem wird noch schwerwiegender, wenn verschiedene Anbieter Komponenten entwickeln, da Änderungen an einer Komponente die Funktionalität anderer Komponenten beeinträchtigen könnten.'},
     {'question': 'Welche Ansätze werden zur Bewältigung des Fragile-Base-Class-Problems vorgeschlagen?', 'answer': 'Ein Ansatz besteht darin, explizite Vererbungsinterfaces einzuführen, um die Beziehungen zwischen Klassen in einer Vererbungshierarchie klarer zu definieren. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie "protected," "virtual" und "override," um die Überschreibbarkeit von Methoden zu steuern und das Verhalten in Subklassen zu dokumentieren. Jedoch gibt es keine universelle Lösung für das Problem.'},
     {'question': 'Welche Faktoren beeinflussen den Programmierstil in der Softwareentwicklung?', 'answer': 'Programmiersprachen ermöglichen es einer Autorin, sich auf eine persönliche Art und Weise auszudrücken. Die Qualität eines Programms wird nicht durch die Ausdrucksweise bestimmt, sondern durch Faktoren wie Effizienz und Verständlichkeit. Der Programmierstil, der sich ausdrückt, spielt eine entscheidende Rolle für die Verständlichkeit und Qualität eines Programms. Weitere Faktoren wie Mode und Ästhetik (Eleganz) können ebenfalls den Programmierstil beeinflussen.'},
     {'question': 'Welche strukturbildende Einheit wird in der objektorientierten Programmierung auf Programmebene hauptsächlich verwendet?', 'answer': 'Auf Programmebene besteht die strukturbildende Einheit in der objektorientierten Programmierung hauptsächlich aus Klassen.'},
     {'question': 'Welche Herausforderung besteht hinsichtlich der Strukturierung von Klassen in der objektorientierten Programmierung?', 'answer': 'Eine Herausforderung besteht darin, dass die hierarchische Struktur objektorientierter Systeme auf Klassenebene nicht immer vorschreibbar ist. Objekte einer Klasse sind nicht immer Teile von Objekten anderer Klassen, sondern können auch einzelne Exemplare (Instanzen) sein und selbst Teile haben können. Es fehlen Konstrukte zur Definition von Komponenten als separate strukturbildende Einheiten neben Klassen und Objekten.'},
     {'question': 'Welches Beispiel wird gegeben, um das Problem der Substituierbarkeit zwischen den Typen Set (Menge) und Bag (Multimenge) zu erklären?', 'answer': 'Das Beispiel betrifft die Substituierbarkeit zwischen den Typen Set (Menge) und Bag (Multimenge). Wenn Set als Subtyp von Bag angesehen wird, gibt es Probleme, da Sets einige charakteristische Eigenschaften von Multimengen verletzen, wie die Größenänderung nach dem Hinzufügen eines Elements. Wenn Bag als Subtyp von Set angesehen wird, wird die charakteristische Eigenschaft verletzt, dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist.'},
     {'question': 'Was ist das Problem, das im Zusammenhang mit Subtyping und dynamischem Methodenaufruf auftritt?', 'answer': 'Das Problem besteht darin, dass aufgrund des dynamischen Bindens von Methodenaufrufen nicht vorhergesagt werden kann, welchen Effekt ein Aufruf der Methode in einem bestimmten Programmfragment haben wird, selbst wenn der Typ des Empfängerobjekts bekannt ist. Es ist schwer zu bestimmen, welcher Subtyp des Typs des Empfängerobjekts tatsächlich betroffen ist.'},
     {'question': 'Welche Variante der objektorientierten Programmierung scheint besser für die GUI-Programmierung geeignet zu sein?', 'answer': 'Die prototypenbasierte Variante der objektorientierten Programmierung, wie sie in JAVASCRIPT verwendet wird, scheint besser für die GUI-Programmierung geeignet zu sein.'},
     {'question': 'Was ist das Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) und warum ist es wichtig?', 'answer': 'Das Liskov-Substitutionsprinzip (LSP) ist ein Prinzip im Zusammenhang mit Subtyping, das von Barbara Liskov und Jeannette Wing entwickelt wurde. Es besagt, dass ein Subtyp (z. B. eine abgeleitete Klasse) eines Typs (z. B. eine Basisklasse) sich so verhalten sollte, dass er anstelle des Supertyps (der Basisklasse) in jedem Programm oder Kontext verwendet werden kann, ohne die Korrektheit des Programms zu gefährden. Das LSP ist wichtig, um sicherzustellen, dass Subtypen die Spezifikationen und das Verhalten des Supertyps beibehalten und korrekt verwenden.'},
     {'question': 'Welche beiden Lösungen werden vorgeschlagen, um das Problem der Aliasbildung und zusätzlicher Methodenaufrufe zu lösen?', 'answer': 'Es werden zwei Lösungen vorgeschlagen, um das Problem der Aliasbildung und zusätzlicher Methodenaufrufe zu lösen: Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existieren muss, die denselben Effekt wie die zusätzliche Methode hat. Die zweite Lösung erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet und erfordern eine Art Spezifikation endlicher Automaten, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt.'},
     {'question': 'Was ist das Problem der eindimensionalen Strukturierung?', 'answer': 'Bei größeren Programmen kann das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren, da verschiedene Vererbungshierarchien oder andere Strukturierungskriterien gleichzeitig relevant sein können. Die Trennung der Belange, auch als Separation of Concerns bekannt, wird in der objektorientierten Programmierung als unzureichend unterstützt angesehen, da es schwer ist, verschiedene Aspekte eines Systems sauber voneinander zu trennen.'},
     {'question': 'Welche Rolle spielen Klassen in der objektorientierten Programmierung, und wie werden Programme weiter strukturiert?', 'answer': 'Klassen sind die Module der objektorientierten Programmierung. Programme werden durch die Vererbungshierarchie weiter strukturiert, was bedeutet, dass Klassen in einer hierarchischen Beziehung zueinander stehen.'},
     {'question': 'Welche Art von Struktur gibt es parallel zur Vererbungshierarchie, die jedoch nicht hierarchisch ist und sich nicht zur systematischen Programmorganisation eignet?', 'answer': 'Parallel zur Vererbungshierarchie gibt es eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen bzw. Objekten geprägt ist. Diese Struktur ist nicht hierarchisch und eher unorganisiert, weshalb sie sich nicht zur systematischen Programmorganisation eignet.'},
     {'question': 'Was ist das Problem der mangelnden Kapselung?', 'answer': 'Die Vererbung in der objektorientierten Programmierung beeinträchtigt die Kapselung von Klassen auf unangenehme Weise. Vererbung führte zu starken Abhängigkeiten zwischen Klassen und ihren Subklassen, einschließlich der Implementierungsdetails. Diese Abhängigkeiten führten dazu, dass Teile der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufgegeben werden mussten. Das Aliasing-Problem tritt auf, wenn ein Objekt, das von einem anderen Objekt gekapselt wird, auch einen Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dies bedeutet, dass von außen auf das gekapselte Objekt zugegriffen werden kann, indem man den Alias verwendet. Dies stellt eine Herausforderung für die Kapselung dar, da es die Geheimhaltung der Implementierung durchbrechen kann.'},
     {'question': 'Welche Enttäuschung trat auf, die die Kapselung von Klassen beeinflusste?', 'answer': 'Die Enttäuschung trat auf, als man feststellte, dass die Vererbung in der objektorientierten Programmierung die Kapselung von Klassen auf unangenehme Weise beeinträchtigte. Vererbung führte zu starken Abhängigkeiten zwischen Klassen und ihren Subklassen, einschließlich der Implementierungsdetails. Diese Abhängigkeiten konnten dokumentiert, aber nicht beseitigt werden, und sie führten dazu, dass Teile der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufgegeben werden mussten.'},
     {'question': 'Was ist das Aliasing-Problem, und warum stellt es eine Herausforderung für die Kapselung dar?', 'answer': 'Das Aliasing-Problem tritt auf, wenn ein Objekt, das von einem anderen Objekt gekapselt wird, auch einen Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dies bedeutet, dass von außen auf das gekapselte Objekt zugegriffen werden kann, indem man den Alias verwendet. Dies stellt eine Herausforderung für die Kapselung dar, da es die Geheimhaltung der Implementierung durchbrechen kann.'},
     {'question': 'Welche Möglichkeiten zur Kontrolle von Aliasing werden in objektorientierten Programmiersprachen diskutiert?', 'answer': 'Es gibt verschiedene Ansätze zur Kontrolle von Aliasing in objektorientierten Programmiersprachen. Ein Ansatz besteht darin, die Teil-Ganzes-Beziehung zwischen Repräsentationsobjekten und dem Objekt zu definieren, sodass die Teile dem Ganzen gehören und nicht gleichzeitig Teile anderer Objekte sein können. Ein anderer Ansatz ist die Verwendung von Wertobjekten, die keine Referenzen auf andere Objekte zulassen. Ein dritter Ansatz besteht darin, Mechanismen zur Aliaskontrolle in die Programmiersprache zu integrieren, wobei viele dieser Mechanismen noch in der Entwicklung sind.'}],
    [{'question': 'Wie versuchte man das Problem der schlechten Tracebarkeit durch Goto-Anweisungen zu lösen?', 'answer': 'Man versuchte, das Problem der schlechten Tracebarkeit durch das Vermeiden von Goto-Anweisungen zu lösen. Stattdessen setzte man auf strukturierte Programmierung, die Verzweigung, Wiederholung und Unterprogrammaufrufe verwendete, um den Programmfluss zu steuern.'},
     {'question': 'Wie wird der Begriff der Substituierbarkeit in der Programmierung betrachtet?', 'answer': 'Der Begriff der Substituierbarkeit bezieht sich darauf, ob eine Zuweisung zwischen verschiedenen Typen gutgeht, ohne Fehler zu verursachen. Dieser Begriff wird unabhängig von der Zuweisungskompatibilität betrachtet und kann als eigenständiger Begriff betrachtet werden.'},
     {'question': 'Wann wird die Frage der Substituierbarkeit interessant?', 'answer': 'Die Frage der Substituierbarkeit wird interessant, wenn Objekte nicht derselben Klasse angehören und eine gewisse Abweichung im Verhalten der zu substituierenden Objekte erlaubt ist.'},
     {'question': 'Wann werden Objekte als nicht gegeneinander austauschbar angesehen?', 'answer': 'Objekte werden als nicht gegeneinander austauschbar angesehen, wenn eine Funktion, die in einem Typ definiert ist, in einem anderen Typ schlicht fehlt. Dies ist der Fall, wenn das Verhalten eines Typs nicht das erwartete Verhalten eines anderen Typs bietet, was zu Inkompatibilitäten führt.'},
     {'question': 'Wie kann man dem Umstand der relativen Substituierbarkeit begegnen?', 'answer': 'Man kann dem Umstand der relativen Substituierbarkeit begegnen, indem man nicht nur die Sichtweise der Person berücksichtigt, die die Typen erstellt (die Anbieterin), sondern auch die Sichtweise der Person, die die Typen für einen bestimmten Zweck verwendet (die Nutzerin). Die Nutzerin kann ihre Erwartungen an einen Typen definieren, indem sie einen eigenen Typen erstellt, der nur die benötigten Eigenschaften umfasst. Dieser Typ spezifiziert die Rolle, die die Objekte im Kontext der Verwendung spielen sollen. Die Auswahl der Typen, deren Objekte für spezielle Zwecke in Frage kommen, erweitert sich dadurch, ohne die Substituierbarkeit zu beeinträchtigen.'},
     {'question': 'Wie kann die Programmiererin ihre Erwartungen an Typen ausdrücken?', 'answer': 'Die Programmiererin kann ihre Erwartungen an Typen ausdrücken, indem sie einen eigenen Typen definiert, der nur die benötigten Eigenschaften umfasst. Dieser Typ stellt gewissermaßen die Rolle dar, die die Objekte im Kontext der Verwendung spielen sollen. Durch die Definition solcher Typen kann die Programmiererin ihre Anforderungen klar ausdrücken und sicherstellen, dass die Typen ihren speziellen Zwecken entsprechen.'},
     {'question': 'Wie kann man das Fragile-Base-Class-Problem verhindern?', 'answer': 'Eine Möglichkeit zur Vermeidung des Problems besteht darin, explizite Schnittstellen oder Vererbungsinterfaces einzuführen, die genau definieren, welche Eigenschaften und Methoden von Subklassen erwartet werden. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie "virtual" und "override," um die Überschreibbarkeit und das Verhalten von Methoden in der Vererbungshierarchie zu steuern.'},
     {'question': 'Wie hat sich der Programmierstil im Laufe der Zeit entwickelt?', 'answer': 'In den letzten Jahrzehnten gab es einen Wandel im Programmierstil weg von einem mathematisch prägnanten Stil hin zu einem prosaisch-verbosen Stil. Früher wurden oft kurze und kryptische Bezeichner für Variablen verwendet, während heute der Trend zu aussagekräftigen und selbstdokumentierenden Bezeichnern geht. Ein Beispiel zeigt den Unterschied zwischen den beiden Stilen: Früher wurden Variablen oft als "i" bezeichnet, während heute aussagekräftigere Namen verwendet werden, die im Kontext ihre Bedeutung klar machen.'},
     {'question': 'Wie wird die Prüfung der Substituierbarkeit in der Praxis durchgeführt?', 'answer': 'In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren, insbesondere die Prüfung der Typkonformität, angenähert. Dabei wird jedoch betont, dass nicht einmal eine Substituierbarkeit ausgeschlossen werden kann, wenn mangelnde Typkonformität vorliegt. Substituierbarkeit erfordert auch eine Betrachtung des Verhaltens der Objekte.'},
     {'question': 'Wie kann das Problem des dynamischen Bindens und der Unsicherheit bei Methodenaufrufen in Bezug auf Subtyping ausgedrückt werden?', 'answer': 'Das Problem kann als ein Problem der formalen Programmverifikation ausgedrückt werden. Es geht darum, wie bewiesen werden kann, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts korrekt gebunden werden können. Dies erfordert genaue Kenntnisse darüber, welchen Effekt der Methodenaufruf hat, was die Kenntnis der Implementierung der Methode erfordert.'},
     {'question': 'Wie kann das Problem der Substituierbarkeit dazu beitragen, das Problem des dynamischen Bindens und der Unsicherheit bei Methodenaufrufen zu lösen?', 'answer': 'Das Konzept der Substituierbarkeit zielt darauf ab, sicherzustellen, dass eine lokale, "modulare" Betrachtung ausreicht, um zu verstehen, welchen Effekt ein Methodenaufruf haben wird, ohne eine umfassende Analyse des gesamten Programms durchführen zu müssen. Substituierbarkeit soll sicherstellen, dass die Bedingungen, unter denen die Methodenaufrufe korrekt sind, bekannt sind, und dass die Implementierungen von Methoden für Subtypen eines bestimmten Typs korrekt verwendet werden können.'}],
    [{'question': 'Warum wurde die Frage nach "guter Programmierung" besonders mit der Einführung von Hochsprachen und großen Programmen relevant?', 'answer': 'Die Frage nach "guter Programmierung" wurde relevant, weil mit der Verfügbarkeit von Hochsprachen und immer größer werdenden Programmen die Diskrepanz zwischen dem statischen, linearen Programmtext und dem dynamischen, stark verzweigten Programmablauf immer offensichtlicher wurde.'},
     {'question': 'Warum wurde die Goto-Anweisung als Hauptverursacher für schlechte Programmierung identifiziert?', 'answer': 'Die Goto-Anweisung erlaubt Sprünge von beliebigen Stellen eines Programms zu anderen Stellen und bricht dabei das Lokalitätsprinzip von Programmen, bei dem zusammengehörende Anweisungen im Programmtext nahe beieinander stehen. Dies führte zu einer Unübersichtlichkeit im Programmtext und erschwerte das Verstehen und Debuggen von Programmen.'},
     {'question': 'Warum wird das dynamische Binden von Skeptikern und Gegnern der objektorientierten Programmierung manchmal als eine Art Goto der 90er Jahre betrachtet?', 'answer': 'Das dynamische Binden wird manchmal als eine Art Goto der 90er Jahre betrachtet, weil es ähnliche Probleme in Bezug auf Tracebarkeit und Verständlichkeit von Programmen verursachen kann. Es erfordert, den Programmablauf im Kontext des dynamisch aufgerufenen Codes zu verstehen, was die Nachverfolgung und das Debuggen erschwert.'},
     {'question': 'Was bedeutet Zuweisungskompatibilität zwischen verschiedenen Typen?', 'answer': 'Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs an Stellen verwendet werden können, an denen Objekte eines anderen Typs erwartet werden. Es bedeutet, dass die Objekte auf der linken Seite der Zuweisung durch die Objekte auf der rechten Seite substituiert werden können.'},
     {'question': 'Was bedeutet die strengste Auslegung des Begriffs der Substituierbarkeit?', 'answer': 'In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dies bedeutet, dass die Objekte nicht nur gleich implementiert sein müssen, sondern sich auch im selben Zustand befinden müssen.'},
     {'question': 'Warum ist die Unabhängigkeit vom konkreten Zustand der Objekte wichtig im Zusammenhang mit der Substituierbarkeit?', 'answer': 'Die Unabhängigkeit vom konkreten Zustand der Objekte ermöglicht es, die Substituierbarkeit von der Laufzeit auf die Übersetzungs- oder Entwurfszeit zu verlagern. Auf dieser Ebene ist das Verhalten aller Objekte einer Klasse gleich, da sie durch dieselbe Klassendefinition spezifiziert sind.'},
     {'question': 'Warum könnten funktional äquivalente, aber verschiedene Typen ausgetauscht werden?', 'answer': 'Funktional äquivalente, aber verschiedene Typen können ausgetauscht werden, wenn Unterschiede im Verhalten toleriert oder sogar gewünscht werden. Ein Beispiel dafür ist die plattformunabhängige GUI-Programmierung, bei der GUI-Elemente funktional äquivalent sein können, sich jedoch im Aussehen und Detailverhalten unterscheiden.'},
     {'question': 'Was bedeutet "verhaltensbasiertes Subtyping" oder "Behavior Subtyping"?', 'answer': '"Verhaltensbasiertes Subtyping" oder "Behavior Subtyping" bezieht sich auf eine Subtypenbeziehung, bei der die Bedingungen erfüllt sein müssen, damit die Spezifikation des Subtyps die des Supertyps erfüllt und als verhaltenskonform betrachtet werden kann. Dies bedeutet, dass das Verhalten der Objekte des Subtyps mit dem Verhalten des Supertyps übereinstimmen muss.'},
     {'question': 'Warum kann es zu Problemen kommen, wenn Objekte vom Typ S von einem Klienten als Typ T betrachtet werden?', 'answer': 'Es können Probleme auftreten, wenn Objekte vom Typ S von einem Klienten als Typ T betrachtet werden, da dies zu Aliasen führen kann, bei denen das Objekt von verschiedenen Klienten unterschiedliche Typen hat. Dies kann dazu führen, dass Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und kann für Benutzer, die das Objekt als T betrachten, nicht akzeptabel sein.'},
     {'question': 'Warum reicht eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit nicht aus?', 'answer': 'Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht nicht aus, da Aliasings in der objektorientierten Programmierung dazu führen kann, dass ein Objekt vom Typ S von verschiedenen Klienten unterschiedliche Typen hat und Methodenaufrufe auf dem Objekt Zustandsänderungen verursachen können, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Daher muss eine umfassendere Betrachtung erfolgen, die die Auswirkungen des Verhaltens auf den Zustand und die Spezifikation des Typs berücksichtigt.'},
     {'question': 'Warum hängt die Substituierbarkeit von Typen von ihrer jeweiligen Verwendung ab?', 'answer': 'Die Substituierbarkeit von Typen hängt von ihrer jeweiligen Verwendung ab, da verschiedene Anwendungsfälle unterschiedliche Anforderungen an Typen und deren Objekte haben können. Ein Typ kann in einem bestimmten Kontext problemlos durch einen anderen Typen ersetzt werden, während dies in einem anderen Kontext nicht der Fall sein kann. Die Substituierbarkeit ist daher relativ zur Verwendung der Typen.'},
     {'question': 'Warum ist der Name Fragile-Base-Class-Problem etwas irreführend?', 'answer': 'Der Name ist etwas irreführend, da nicht unbedingt die Basisklassen, sondern eher die abgeleiteten Klassen als "anfällig" oder "zerbrechlich" gelten.'},
     {'question': 'Können Sie ein einfaches Beispiel für das Fragile-Base-Class-Problem geben?', 'answer': 'Ja, nehmen wir an, es gibt eine Klasse namens "TapeArchive", die Videobänder archiviert. Später wird eine Subklasse namens "NotifyingTapeArchive" erstellt, die Nachrichten sendet, wenn Bänder archiviert werden. Das Problem besteht darin, dass Änderungen in der Basisklasse "TapeArchive" sich unerwartet auf die Subklasse "NotifyingTapeArchive" auswirken können.'},
     {'question': 'Warum ist es schwierig, das Fragile-Base-Class-Problem zu erkennen?', 'answer': 'Es ist schwer zu erkennen, da die Basisklasse auf den ersten Blick korrekt erscheint. Das Problem besteht darin, dass die Subklasse von bestimmtem Verhalten der Basisklasse abhängt, ohne dass dies in der Basisklasse explizit dokumentiert ist.'},
     {'question': 'Warum ist es wichtig, aussagekräftige Bezeichner in Programmen zu verwenden?', 'answer': 'Die Verwendung von aussagekräftigen Bezeichnern in Programmen trägt zur Verständlichkeit des Codes bei. Gut gewählte Bezeichner drücken im Kontext ihre Bedeutung aus, sodass Kommentare zur Erklärung der Programmelemente oft unnötig werden. Dies erleichtert anderen Entwicklerinnen das Verständnis des Codes und erhöht die Lesbarkeit und Wartbarkeit des Programms.'},
     {'question': 'Warum könnte es in einigen Fällen sinnvoll sein, eine geistreichere Lösung mit einem erklärenden Kommentar zu versehen?', 'answer': 'In einigen Fällen könnte eine Lösung, auch wenn sie in ihrer verständlichsten Form vorliegt, weniger elegant sein als eine raffinierte Variante, die nicht jedem sofort ersichtlich ist. In solchen Situationen kann die Versuchung groß sein, die geistreichere Lösung zu wählen und sie mit einem erklärenden Kommentar zu versehen, um sicherzustellen, dass auch weniger erfahrene Entwicklerinnen den Code nachvollziehen können. Dies ermöglicht es, komplexe Algorithmen oder unkonventionelle Ansätze zu dokumentieren und zu erläutern.'},
     {'question': 'Warum werden große Klassen (mit vielen Attributen und Methoden) in der objektorientierten Programmierung in der Regel vermieden?', 'answer': 'Große Klassen gelten in der Regel als schlechter Stil, da sie die Anwendungsdomäne nicht angemessen widerspiegeln. In der Anwendungsdomäne sind komplexe Dinge normalerweise aus einfacheren Teilen zusammengesetzt, die selbst wieder aus kleineren Teilen bestehen.'},
     {'question': 'Warum sind innere Klassen (in JAVA) allein keine ausreichende Lösung für die Strukturierung von Klassen?', 'answer': 'Innere Klassen in JAVA können Klassen strukturieren, aber sie werden relativ wenig verwendet, da sie sich nicht als besonders nützlich erweisen. Objekte einer Klasse sind nicht immer Teile von Objekten anderer Klassen, daher ist die hierarchische Struktur auf Klassenebene nicht immer passend.'},
     {'question': 'Warum können Konzepte wie Pakete (JAVA) oder Assemblies (C-Sharp) den Begriff der Komponente nicht ersetzen?', 'answer': 'Pakete (JAVA) oder Assemblies (C-Sharp) gruppieren lediglich Klassen und berücksichtigen nicht, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann. Sie können den Begriff der Komponente daher nicht vollständig ersetzen.'},
     {'question': 'Warum ist die Substituierbarkeit fraglich, wenn keine Typerweiterung vorliegt?', 'answer': 'Die Substituierbarkeit ist fraglich, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies führt zu Problemen, wenn Objekte eines Subtyps an Stellen verwendet werden, an denen Objekte des Supertyps erwartet werden.'},
     {'question': 'Warum kann die Unterdrückung von Eigenschaften bei abgeleiteten Typen in Java problematisch sein?', 'answer': 'In Java ist die Unterdrückung von Eigenschaften bei abgeleiteten Typen problematisch, da sie dazu führen kann, dass an Stellen im Programm, an denen ein Objekt des Supertyps erwartet wird, ein Objekt des Subtyps auftaucht. Dies kann zu schwerwiegenden Programmierfehlern führen, da die erwarteten Funktionen des Supertyps möglicherweise nicht verfügbar sind.'},
     {'question': 'Warum können keine korrekten Aussagen wie "Für alle Objekte vom Typ X gilt..." gebildet werden, wenn X (Bag oder Set) als Subtyp von Y (dem jeweils anderen Typ) betrachtet wird?', 'answer': 'Es können keine korrekten Aussagen wie "Für alle Objekte vom Typ X gilt..." gebildet werden, wenn X (Bag oder Set) als Subtyp von Y (dem jeweils anderen Typ) betrachtet wird, da die charakteristischen Eigenschaften der beiden Typen im Widerspruch zueinander stehen. Dies entspricht nicht der Definition des Subtypings, da die Bedingungen der Ko- und Kontravarianz nicht erfüllt sind.'},
     {'question': 'Warum reicht die Typkonformität allein nicht aus, um Substituierbarkeit sicherzustellen?', 'answer': 'Die Typkonformität allein reicht nicht aus, um Substituierbarkeit sicherzustellen, da auch das Verhalten der Objekte betrachtet werden muss. Typkonformität bedeutet nicht automatisch Substituierbarkeit. Substituierbarkeit erfordert eine Betrachtung des Verhaltens der Objekte.'},
     {'question': 'Warum ist es wichtig zu wissen, wie Methoden einer neu eingeführten Klasse in ein bestehendes Programm integriert werden können?', 'answer': 'Es ist wichtig zu wissen, wie Methoden einer neu eingeführten Klasse in ein bestehendes Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert und keine unerwarteten Verhaltensänderungen auftreten. Dies ist notwendig, um sicherzustellen, dass die neuen Implementierungen sich nahtlos in das bestehende Programm einfügen und die Programmfunktionalität nicht gefährden.'},
     {'question': 'Warum sind nicht alle Aufgaben gleichermaßen zur Lösung per objektorientierter Programmierung geeignet?', 'answer': 'Nicht alle Aufgaben sind gleichermaßen zur Lösung per objektorientierter Programmierung geeignet, da einige Aufgaben besser mit anderen Programmierparadigmen wie funktionale oder logische Programmiersprachen gelöst werden können. Auch Batch- und Scripting-Probleme, die einen imperativ-prozeduralen Charakter haben, eignen sich möglicherweise nicht optimal für die objektorientierte Programmierung.'},
     {'question': 'Warum ist die gute objektorientierte Programmierung bei Problemen mit einem hohen algorithmischen Anteil und einfachen Datenstrukturen möglicherweise weniger geeignet?', 'answer': 'Die gute objektorientierte Programmierung erfordert, den Code auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Bei Problemen mit einfachen Datenstrukturen und einem hohen algorithmischen Anteil müssen größere Probleme jedoch in der Regel auf durch verschiedene Klassen definierte Daten zugreifen. Dies kann dazu führen, dass der Code durch seine Datenbindung regelrecht zerfleddert wird.'},
     {'question': 'Warum ist die objektorientierte Programmierung möglicherweise nicht ideal für Programme, in denen es hauptsächlich um Abläufe geht?', 'answer': 'In Programmen, in denen es hauptsächlich um Abläufe geht, möchte man oft, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten, was die objektorientierte Programmierung weniger ideal macht.'},
     {'question': 'Warum ist die Wahl einer geeigneten Programmiersprache in der Praxis oft ein Abwägungsproblem?', 'answer': 'Die Wahl einer geeigneten Programmiersprache ist oft ein Abwägungsproblem, da verschiedene Programmiersprachen unterschiedliche Vor- und Nachteile haben. Bei der objektorientierten Programmierung kann die Organisation der Funktionen auf der Strecke bleiben, während bei der prozeduralen Programmierung die Daten häufig in unüberschaubarer Weise hin- und hergeschickt werden oder global sind.'},
     {'question': 'Warum eignen sich Programmiersprachen, die eine Mischung mehrerer Paradigmen erlauben, weniger für Anfängerinnen?', 'answer': 'Programmiersprachen, die eine Mischung mehrerer Paradigmen erlauben, können Anfängerinnen aufgrund ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen überfordern, wie man ein einzelnes Problem lösen kann.'},
     {'question': 'Warum wird bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung oft von einem Impedanzmismatch gesprochen?', 'answer': 'Bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung besteht häufig ein Impedanzmismatch, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Die beiden Ansätze verwenden unterschiedliche Mittel zur Darstellung von Beziehungen und Datenstrukturen.'},
     {'question': 'Warum muss man bei der Verarbeitung von relationalen Daten durch objektorientierte Programme oft Prinzipien der relationalen Welt anpassen?', 'answer': 'Bei der Verarbeitung von relationalen Daten durch objektorientierte Programme muss man sich an die Prinzipien der relationalen Welt anpassen, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Dies erfordert häufig, einen Teil dessen, was Objektorientierung ausmacht, aufzugeben.'},
     {'question': 'Warum ist die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung?', 'answer': 'Die GUI-Programmierung ist nicht unbedingt ein Heimspiel für die objektorientierte Programmierung, da die Instanzen einer Klasse alle Methoden teilen und es nicht möglich ist, für verschiedene GUI-Elemente derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Dies kann zu Problemen führen, insbesondere wenn es um das gemeinsame Verhalten von GUI-Elementen geht.'},
     {'question': 'Warum wird darauf hingewiesen, dass das Liskov-Substitutionsprinzip nicht ausschließlich auf die Arbeiten von Barbara Liskov und Jeannette Wing beschränkt ist?', 'answer': 'Es wird darauf hingewiesen, dass das Liskov-Substitutionsprinzip nicht ausschließlich auf die Arbeiten von Barbara Liskov und Jeannette Wing beschränkt ist, um anzuerkennen, dass es frühere Arbeiten gab, die ebenfalls zur Entwicklung dieses Prinzips beigetragen haben. Das Prinzip selbst ist eine wichtige Konzeption in Bezug auf Subtyping und geht über die Beiträge einzelner Personen hinaus.'},
     {'question': 'Warum ist das Liskov-Substitutionsprinzip möglicherweise zu streng formuliert?', 'answer': 'Das Liskov-Substitutionsprinzip (LSP) könnte zu streng formuliert sein, da es einige problematische Aspekte aufweist. Zum Beispiel geht es davon aus, dass Objekte genau die Typen T oder S haben, was nicht auf abstrakte Typen und Interfaces anwendbar ist. Außerdem verlangt es, dass alle Eigenschaften von T auch für S gelten, was im Widerspruch zur eigentlichen Absicht des Subtypings steht, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Daher könnte eine weniger strenge Formulierung des Prinzips notwendig sein.'},
     {'question': 'Warum könnte das Liskov-Substitutionsprinzip in der Praxis als zu restriktiv angesehen werden?', 'answer': 'Das Liskov-Substitutionsprinzip (LSP) könnte in der Praxis als zu restriktiv angesehen werden, da es strengere Anforderungen an die Subtypen stellt und einige gültige Programme ablehnt. Zum Beispiel kann es vorkommen, dass ein Subtyp spezifische Methodenaufrufe erlaubt, die nicht im Supertyp vorhanden sind, aber dennoch in bestimmten Kontexten korrekt und sicher sind. Das LSP kann diese Fälle nicht berücksichtigen, was zu einer unnötigen Ablehnung von gültigen Programmen führen kann.'},
     {'question': 'Warum stellt die Klassenhierarchie keine Form der hierarchischen Modularisierung dar?', 'answer': 'Die Klassenhierarchie stellt keine Form der hierarchischen Modularisierung dar, da das Herauslösen eines Teilbaums der Vererbungshierarchie praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen trennt. Somit werden Beziehungen zwischen Klassenmitgliedern gestört.'},
     {'question': 'Warum kann bei größeren Programmen das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren?', 'answer': 'Bei größeren Programmen kann das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren, da verschiedene Vererbungshierarchien oder andere Strukturierungskriterien gleichzeitig relevant sein können, ähnlich wie in der Biologie, wo Arten nach verschiedenen Gesichtspunkten klassifiziert werden. Dies erfordert jedoch, dass die verschiedenen Darstellungen getrennt gepflegt werden und keine Inkonsistenzen oder ungewollten Interferenzen entstehen.'},
     {'question': 'Warum wird die Trennung der Belange in der objektorientierten Programmierung als unzureichend unterstützt angesehen?', 'answer': 'Die Trennung der Belange, auch als Separation of Concerns bekannt, wird in der objektorientierten Programmierung als unzureichend unterstützt angesehen, da es schwer ist, verschiedene Aspekte eines Systems sauber voneinander zu trennen. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar diskutiert, haben jedoch keine breite Akzeptanz gefunden. Die Gründe dafür können vielfältig sein, aber letztendlich ist es schwierig, die essentielle Komplexität eines Problems durch programmiersprachliche Mittel vollständig zu beseitigen.'},
     {'question': 'Warum werden Softwaresysteme als die kompliziertesten technischen Artefakte bezeichnet, die die Menschheit jemals hervorgebracht hat?', 'answer': 'Softwaresysteme werden als die kompliziertesten technischen Artefakte bezeichnet, die die Menschheit jemals hervorgebracht hat, weil sie eine immense Komplexität aufweisen. Die Trennung der Belange und die Bewältigung dieser Komplexität sind nach wie vor große Herausforderungen in der Softwareentwicklung. Daher wird darauf hingewiesen, dass Einfachheit in diesem Kontext schwer zu erreichen ist.'},
     {'question': 'Was war die anfängliche Erwartung in Bezug auf Kapselung in der objektorientierten Programmierung, und warum?', 'answer': 'Anfangs glaubte man, dass die objektorientierte Programmierung durch das Konzept der Klassen eine natürliche Form der Kapselung gefunden hatte. Dies wurde auch mit der Theorie der abstrakten Datentypen in Einklang gebracht. Klassen sollten natürliche Repräsentanten von Allgemeinbegriffen sein, und Daten sowie Implementierungsdetails sollten hinter der Klassenschnittstelle verborgen werden.'},
     {'question': 'Warum können private Instanzvariablen allein das Aliasing-Problem nicht lösen?', 'answer': 'Private Instanzvariablen können allein das Aliasing-Problem nicht lösen, da sie lediglich Namen verbergen und nicht verhindern können, dass Repräsentationsobjekte (Implementierungsdetails) Aliasen ausgesetzt sind.'},
     {'question': 'Warum kann das Verbot von Aliasing in einigen Programmiersprachen nicht immer eine geeignete Lösung sein?', 'answer': 'Das Verbot von Aliasing in einigen Programmiersprachen kann nicht immer eine geeignete Lösung sein, da es zahlreiche Anwendungsfälle gibt, in denen die Verwendung von Aliasing notwendig oder sinnvoll ist. Zum Beispiel können bestimmte Datenstrukturen oder Container von Natur aus Aliase erfordern, um effizient zu arbeiten.'}],
]
KE7_questions = [
    [{'question': 'Welches Mittel wird empfohlen, um unnötigen Aufwand und Konflikte in Bezug auf Formatierung zu vermeiden?', 'answer': 'Es wird empfohlen, automatische Codeformatierer zu verwenden, die auf Knopfdruck bestimmte Formatierungskonventionen anwenden. Selbst wenn man alleine arbeitet, sollte man solche Tools nutzen, um sich an allgemein übliche Formatierungsstandards zu halten und die Entwicklung eines persönlichen Programmierstils nicht zu weit von der Norm entfernen zu lassen. Individualität in der Programmierung ist nicht geeignet, um effizienten und wartbaren Code zu produzieren.'},
     {'question': 'Welche Vorteile haben Namenskonventionen in der Programmierung?', 'answer': 'Namenskonventionen in der Programmierung haben mehrere Vorteile. Sie erleichtern die Bezeichnerwahl, begrenzen die schöpferische Freiheit der Programmiererin, was als Entlastung empfunden werden kann, und machen das Lesen von Code einfacher, da Entwicklerinnen, die die Konventionen kennen, die Bedeutung der Bezeichner schneller entschlüsseln können und sich somit schneller zurechtfinden.'},
     {'question': 'Welche Wortarten einer natürlichen Sprache sollten für verschiedene Arten von Programmelementen verwendet werden?', 'answer': 'Es ist angemessen, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. Zum Beispiel werden in der objektorientierten Programmierung Substantive oft für Klassennamen verwendet.'},
     {'question': 'Welche Art von Methoden wird oft mit Verben benannt, und welche Formen von Verben können verwendet werden?', 'answer': 'Methoden, die eine Aktion implementieren (Befehle), werden oft mit Verben benannt. Bei der Wahl der Verben ist es eine Stilfrage, ob man die Infinitiv- oder die Imperativform bevorzugt. Beispielsweise kann man "hinzufügen" (Infinitivform) oder "entfernen" (Imperativform) verwenden.'},
     {'question': 'Welche Namenskonvention wird für Methoden, die Abfragen darstellen (Queries), vorgeschlagen?', 'answer': 'Für Methoden, die Abfragen darstellen (Queries), werden oft Adjektive oder Kopula plus Prädikatsnomen verwendet. Beispiele hierfür sind "istLeer" oder "hatInhalt."'},
     {'question': 'Welche Wortarten werden für Instanzvariablen verwendet, abhängig davon, ob sie Attribute oder Beziehungen repräsentieren?', 'answer': 'Für Instanzvariablen, die Attribute repräsentieren, wie Größe oder Farbe, verwendet man oft den Namen der Qualität als Substantiv. Wenn es sich um zweiwertige (Boolesche) Attribute handelt, nimmt man das entsprechende Adjektiv oder ein Gerundivum. Für Instanzvariablen, die Beziehungen repräsentieren, verwendet man oft den Namen der Gegenrolle, wie "mutter" in einer Kind-Mutter-Beziehung.'},
     {'question': 'Was ist eine interessante Option für Programmiererinnen, deren Muttersprache nicht Englisch ist, in Bezug auf die Wahl der Bezeichner?', 'answer': 'Programmiererinnen, deren Muttersprache nicht Englisch ist, haben die Möglichkeit, zwischen zwei Sprachen bei der Wahl der Bezeichner zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Man kann deutsche Bezeichner für Begrifflichkeiten aus der Anwendungsdomäne und englische Bezeichner für technische Umsetzungselemente verwenden, oder alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von denen aus Bibliotheken und Frameworks zu unterscheiden.'},
     {'question': 'Welche Faustregel wird genannt, um einen guten Namen für ein Programmelement auszuwählen?', 'answer': 'Als Faustregel wird genannt, dass ein Name dann gut gewählt ist, wenn man alle Ausdrücke, in denen er vorkommt, schnell und klar verstehen kann. Ein gut gewählter Name sollte keine falschen Assoziationen oder Vermutungen hervorrufen und sollte somit leicht verständlich sein. Es ist ratsam, sich Zeit für die Auswahl eines passenden Namens zu nehmen, da dies eine sorgfältige Überlegung erfordert und die Lesbarkeit des Codes erheblich verbessern kann.'},
     {'question': 'Welche Vorteile ergeben sich aus kurzen Methoden in der objektorientierten Programmierung?', 'answer': 'Kurze Methoden in der objektorientierten Programmierung fördern die Lesbarkeit und den objektorientierten Stil. Sie erlauben es, Teile einer Methode in separate, klar benannte Methoden auszulagern, was die Lesbarkeit und Wartbarkeit des Codes verbessert. Dieser Stil fördert auch die Verwendung von aussagekräftigen Bezeichnern und trägt zur besseren Dokumentation des Codes bei.'},
     {'question': 'Welches Refactoring-Verfahren wird häufig angewendet, um Teile einer Methode in separate Methoden auszulagern?', 'answer': 'Das "Extract-method"-Refactoring-Verfahren wird häufig angewendet, um Teile einer Methode in separate Methoden auszulagern. Dieses Verfahren ermöglicht es, Teile des Codes in neue Methoden auszulagern, selbst wenn diese Teile vorerst nur von ihrer ursprünglichen Position aus aufgerufen werden, um die Lesbarkeit zu verbessern. Es handelt sich um eine gängige Praxis in der objektorientierten Programmierung.'},
     {'question': 'Was ist ein wichtiges Merkmal der objektorientierten Programmierung in Bezug auf die Größe von Klassen?', 'answer': 'Ein wichtiges Merkmal der objektorientierten Programmierung ist, dass Klassen nicht ins Uferlose wachsen sollten. Wenn der Methodenumfang einer Klasse zu groß wird, deutet dies darauf hin, dass die Klasse möglicherweise mehrere Abstraktionen repräsentiert oder auf einem höheren Abstraktionsniveau steht als die aktuelle Implementierung.'},
     {'question': 'Welche Gründe können dazu führen, dass eine Klasse in der objektorientierten Programmierung zu groß wird?', 'answer': 'Es gibt zwei mögliche Gründe, warum eine Klasse in der objektorientierten Programmierung zu groß werden kann: Die Klasse repräsentiert nicht nur eine Abstraktion der Anwendungsdomäne, sondern mehrere. In diesem Fall sollte die Klasse in mehrere Teilklassen aufgeteilt werden, wobei jede Teilklassen eine Abstraktion darstellt, und die Daten und Methoden entsprechend zugeordnet werden. Die Klasse repräsentiert eine Abstraktion der Anwendungsdomäne auf einem höheren Abstraktionsniveau als die aktuelle Implementierung. Dies kann entweder bedeuten, dass die Klasse eine Generalisierung darstellt und alle Spezialisierungen in einer Klasse zusammengefasst sind oder dass die Klasse eine Aggregation oder Komposition darstellt und Teile als logische Einheiten identifiziert werden müssen.'},
     {'question': 'Welche Schritte sollten unternommen werden, wenn eine Klasse zu groß wird?', 'answer': 'Wenn eine Klasse zu groß wird, sollten die folgenden Schritte unternommen werden, abhängig von der Ursache der Größe: Wenn die Klasse mehrere Abstraktionen repräsentiert, sollte die Klasse in mehrere Teilklassen aufgeteilt werden, wobei jede Teilklassen eine Abstraktion darstellt, und die Daten und Methoden entsprechend zugeordnet werden. Wenn die Klasse eine Generalisierung darstellt, sollten die unterschiedlichen Spezialisierungen identifiziert und die jeweils darauf bezogenen Daten und Funktionen in neu zu schaffende Subklassen verlagert werden. Das gemeinsame Protokoll sollte idealerweise in der neuen Superklasse verbleiben. Wenn die Klasse eine Aggregation oder Komposition darstellt, sollten die Teile als logische Einheiten identifiziert und neue Klassen formuliert werden. Falls diese neuen Klassen außerhalb der Abstraktion keine Bedeutung haben, kann in Erwägung gezogen werden, sie als innere Klassen zu deklarieren, um den Namensraum nicht unnötig zu überfrachten und die Anzahl der wahrgenommenen Klassen nicht unnötig zu erhöhen.'},
     {'question': 'Was ist eine gängige Namenskonvention in Bezug auf Interfacetypen?', 'answer': 'Eine gängige Namenskonvention ist, Namen von Interfacetypen mit einem großen "I" beginnen zu lassen. Zum Beispiel könnte ein Interface "Auto" als "IAuto" benannt werden.'},
     {'question': 'Was ist die ungarische Notation in Bezug auf Namenskonventionen?', 'answer': 'Die ungarische Notation ist eine Namenskonvention, bei der Bezeichner, die für ein Objekt oder einen Wert stehen (wie Variablen und Funktionsnamen), den Typ dieses Objekts oder Werts widerspiegeln. Es gibt verschiedene Auslegungen der ungarischen Notation.'},
     {'question': 'Was ist eine mögliche Auslegung der ungarischen Notation?', 'answer': 'Eine mögliche Auslegung der ungarischen Notation verlangt, dass Variablen, die Strings bezeichnen, mit "str" beginnen. Diese Auslegung kann jedoch als weniger sinnvoll angesehen werden, da Compiler und IDE bereits Informationen über den Typ der Variablen bereitstellen und diese Information den Namen der Variablen nicht zusätzlich belasten sollte.'},
     {'question': 'Welche sinnvollere Auslegung der ungarischen Notation wird vorgeschlagen?', 'answer': 'Eine sinnvollere Auslegung der ungarischen Notation schlägt vor, Variablen um die Verwendung ihres Inhalts zu ergänzen. Das bedeutet, die Funktion des durch die Variable bezeichneten Objekts oder Werts innerhalb des Kontextes anzugeben, in dem die Variable gültig ist. Dies ermöglicht es, die Funktion kontextbezogen auszudrücken, ohne den Namen der Variable mit redundanten Informationen zu belasten. In der objektorientierten Programmierung kann diese kontextbezogene Funktion oft auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt werden, was vom Compiler überprüft werden kann.'},
     {'question': 'Welche Rolle spielen Bibliotheken in der objektorientierten Programmierung?', 'answer': 'Bibliotheken spielen eine entscheidende Rolle in der objektorientierten Programmierung. Sie sind ein wesentlicher Bestandteil des objektorientierten Programmierstils und tragen maßgeblich zum Erfolg dieses Ansatzes bei.'},
     {'question': 'Welche Techniken und Praktiken kennzeichnen den deklarativen Programmierstil in der objektorientierten Programmierung?', 'answer': 'Der deklarative Programmierstil in der objektorientierten Programmierung zeichnet sich durch folgende Techniken und Praktiken aus: Verwendung von aussagekräftigen Bezeichnern, die beschreiben, was eine Methode tut. Aufteilung von komplexen Funktionen in separate Methoden mit klaren Namen. Betonung des "Was" anstelle des "Wie" bei der Formulierung des Codes. Verwendung von Zusicherungen (Vor- und Nachbedingungen, Invarianten) anstelle von Kommentaren, um die Absichten und Bedingungen des Codes deutlicher zu machen. Zurückhaltung bei der Verwendung von Optimierungen, die die funktionale Äquivalenz gefährden könnten, bis ihre Auswirkungen vollständig verstanden sind.'},
     {'question': 'Was ist der Sinn und Zweck des Gesetzes Demeters in der objektorientierten Programmierung?', 'answer': 'Der Sinn und Zweck des Gesetzes Demeters ist es, die Kopplung und die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wenn das Gesetz Demeters verletzt wird, kann eine Änderung des Protokolls einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zur Klasse stehen, was vermieden werden sollte.'},
     {'question': 'Welche Art von Zugriffsregel führt Demeters Gesetz faktisch ein?', 'answer': 'Demeters Gesetz führt faktisch eine neue, kontextabhängige Zugriffsregel ein: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt, auf die es aber nicht zugreifen darf. Dies führt zu einer klaren Trennung zwischen direkten und indirekten Beziehungen zwischen Objekten.'}],
    [{'question': 'Wie kann die Einhaltung von Namenskonventionen die Kreativität der Entwicklerinnen fördern?', 'answer': 'Die Einhaltung von Namenskonventionen kann die Kreativität der Entwicklerinnen fördern, indem sie die schöpferische Energie auf die relevanten Aspekte lenkt. Durch die Festlegung bestimmter Regeln wird die Entwicklerin in ihrer kreativen Gestaltung eingeschränkt, was jedoch dazu führen kann, dass die Kreativität gezielter eingesetzt wird und besser zur Geltung kommt.'},
     {'question': 'Wie kann die Analysephase eines Projekts zur Identifizierung der Klassen eines Systems beitragen?', 'answer': 'In der Analysephase eines Projekts können alle Substantive aus der Spezifikation extrahiert werden, um auf der Basis dieser Liste die Menge der Klassen eines Systems zu identifizieren. Dies ist eine vielzitierte objektorientierte Technik.'},
     {'question': 'Wann sollte der lange Name einer Variable bevorzugt werden?', 'answer': 'Der lange Name einer Variable sollte bevorzugt werden, sobald dies nicht mehr der Fall ist, wenn die Sichtbarkeit der Variable über die unmittelbare Umgebung der Deklaration hinausgeht, wie es typischerweise bei der Deklaration von Instanzvariablen der Fall ist. Dies gilt auch, wenn der Typ der Variable aus dem Kontext abgeleitet werden kann (Typinferenz).'},
     {'question': 'Wie kann man die Einhaltung des Gesetzes Demeters sicherstellen und dennoch die Funktionalität von Ausdrücken beibehalten?', 'answer': 'Um sowohl die Funktionalität von Ausdrücken beizubehalten als auch das Gesetz Demeters einzuhalten, kann man das Protokoll der Klasse des ersten Nachrichtenempfängers erweitern. Dies bedeutet, dass die Klasse des von "a" benannten Objekts um die Methode "doY" erweitert wird, wenn "a" das Ergebnis von "doX" ist. Dadurch wird sicherer gestellt, dass "a" auch die Methode "doY" aufruft und das Ergebnis zurückgibt.'},
     {'question': 'Wann wird das Gesetz Demeters typischerweise verletzt, und wie äußert sich diese Verletzung?', 'answer': 'Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks vorliegen. Dies tritt oft bei Kettenaufrufen auf oder kann durch eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen. Eine Verletzung des Gesetzes Demeters äußert sich darin, dass Nachrichten an Objekte gesendet werden, die nicht vom Sender direkt gekannt oder erzeugt wurden.'},
     {'question': 'Wie wird das Gesetz Demeters oft in einer kurzen Phrase zusammengefasst?', 'answer': 'Das Gesetz Demeters wird oft in folgender Phrase zusammengefasst: "Sprich nicht mit Fremden." In Bezug auf SMALLTALK bedeutet dies, dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen.'}],
    [{'question': 'Warum ist die Vererbung ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung?', 'answer': 'Die Vererbung ist ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung, weil sie einerseits ein mächtiges Konzept zur Wiederverwendung von Code und zur Erstellung von Klassenhierarchien darstellt, andererseits aber auch dazu führen kann, dass Änderungen an einer Klasse sich auf alle davon abgeleiteten Klassen auswirken. Dies kann die Wartbarkeit und Erweiterbarkeit des Codes beeinträchtigen und zu unerwartetem Verhalten führen.'},
     {'question': 'Was besagt die gewichtigste Regel im Zusammenhang mit Vererbung?', 'answer': 'Die gewichtigste Regel im Zusammenhang mit Vererbung besagt: "Deklariere jede Klasse entweder als abstrakt oder als final." Das bedeutet, dass Klassen entweder als abstrakt (nicht instanziierbar) oder als final (nicht ableitbar) deklariert werden sollten.'},
     {'question': 'Warum sollten nur die Blätter der Klassenhierarchie instanziierbar sein?', 'answer': 'Die Blätter der Klassenhierarchie sollten instanziierbar sein, weil dies sicherstellt, dass Änderungen an einer Klasse nur Auswirkungen auf diese Klasse selbst haben und nicht auf alle davon abgeleiteten Klassen. Wenn eine Klasse in der Hierarchie geändert werden muss, können diese Änderungen in der Klasse selbst oder in ihren Subklassen vorgenommen werden, ohne die anderen Klassen in der Hierarchie zu beeinflussen.'},
     {'question': 'Warum ist es wichtig, Klassen als abstrakt oder final zu deklarieren, um Änderungen an der Funktionalität der Klasse zu ermöglichen?', 'answer': 'Das Deklarieren von Klassen als abstrakt oder final ermöglicht es, Änderungen an der Funktionalität der Klasse auf sichere Weise durchzuführen. Wenn eine Klasse als abstrakt deklariert ist, können Änderungen in den abgeleiteten Subklassen vorgenommen werden, ohne die anderen Klassen in der Hierarchie zu beeinflussen. Wenn eine Klasse als final deklariert ist, kann sie nicht abgeleitet werden, was bedeutet, dass ihre Funktionalität nicht geändert werden kann. Dies ermöglicht es, den Vertrag zwischen der Klasse und ihren Klienten zu schützen und unerwartete Verhaltensänderungen zu verhindern.'},
     {'question': 'Warum ist die Verwendung von abstrakten Klassen in Bibliotheken eine Möglichkeit, die Beschränkungen von finalen Klassen zu umgehen?', 'answer': 'Die Verwendung von abstrakten Klassen in Bibliotheken ermöglicht es, die Beschränkungen von finalen Klassen zu umgehen, indem sie eine Schicht der Abstraktion hinzufügen. Anstatt eine Klasse als final zu deklarieren, wird sie als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die konkret (instanziierbar) und final ist. Auf diese Weise können Klienten der Bibliothek von der abgeleiteten, finalen Klasse erben und diese verwenden, ohne die ursprüngliche Klasse ändern zu müssen. Wenn Änderungen erforderlich sind, können sie in der finalen Klasse vorgenommen werden, und nur wenn sie für alle Klienten geeignet sind, werden sie in der abstrakten Superklasse durchgeführt. Dies ermöglicht eine gewisse Flexibilität bei der Aktualisierung von Bibliotheken, ohne den Vertrag mit den Klienten zu brechen.'},
     {'question': 'Warum sind Formatierungskonventionen in der Programmierung wichtig?', 'answer': 'Formatierungskonventionen in der Programmierung sind wichtig, da sie die Lesbarkeit des Codes verbessern. Sie regeln Dinge wie Einrückungen, Zeilenumbrüche, Leerzeichen und Leerzeilen, um den Code übersichtlicher zu gestalten.'},
     {'question': 'Warum sind Formatierungskonventionen besonders in Teamprojekten wichtig?', 'answer': 'In Teamprojekten sind Formatierungskonventionen besonders wichtig, um zu verhindern, dass jede Entwicklerin im Team ihre eigenen Formatierungsvorlieben pflegt. Ohne einheitliche Konventionen kann es passieren, dass Entwicklerinnen den Code anderer Teammitglieder nach ihren eigenen Vorlieben formatieren, was zu Konflikten und ineffizienter Arbeit führen kann.'},
     {'question': 'Warum ist es wichtig, dass Namenskonventionen genau festgeschrieben sind und von allen akzeptiert werden?', 'answer': 'Es ist wichtig, dass Namenskonventionen genau festgeschrieben sind und von allen akzeptiert werden, da andernfalls individuelle Auslegungen der Regeln Verwirrung stiften können. Wenn jede Person ihre eigene Auslegung hat, verliert die Namenskonvention ihren Nutzen und kann sogar zu mehr Verwirrung führen.'},
     {'question': 'Warum werden Interfaces oft mit Substantiven oder Adjektiven bezeichnet?', 'answer': 'Interfaces sind wie Klassen Typen, aber sie bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte spielen können. Diese Rollen werden häufig durch Substantive oder Adjektive bezeichnet. Zum Beispiel enden viele Interfacenamen im Englischen auf „able“ oder „ible“, wie "Serializable."'},
     {'question': 'Warum könnte die Verwendung langer, sprechender Bezeichner in der Programmierung problematisch sein?', 'answer': 'Die Verwendung langer, sprechender Bezeichner kann in der Programmierung problematisch sein, da der Programmtext dadurch übermäßig lang wird. Anweisungen, die normalerweise in eine Zeile passen würden, müssen möglicherweise mehrfach umgebrochen werden, was die Lesbarkeit beeinträchtigen kann. Außerdem hört man gelegentlich das Argument, dass lange Namen zusätzliche Schreibarbeit für die Entwicklerin bedeuten. Dieses Argument wird jedoch in der Regel nicht akzeptiert, da die meisten Entwicklungsumgebungen über automatische Vervollständigungsfunktionen verfügen, die das Tippen erleichtern.'},
     {'question': 'Warum sind die Methoden in objektorientierten Programmen im Durchschnitt ziemlich kurz?', 'answer': 'Die Methoden in objektorientierten Programmen sind im Durchschnitt ziemlich kurz, weil in der objektorientierten Programmierung die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Wenn eine Funktion verschiedene Arten von Daten manipuliert, wird die Funktionalität wahrscheinlich nicht vollständig in einer Methode implementiert.'},
     {'question': 'Warum ist die Verwendung von Bibliotheken in der objektorientierten Programmierung wichtig?', 'answer': 'Die Verwendung von Bibliotheken in der objektorientierten Programmierung bietet mehrere Vorteile: Sie ermöglicht es, Lösungen für Probleme aus vorhandenen, bewährten und weit verbreiteten Bibliotheken zusammenzustellen, was Zeit und Aufwand spart. Bibliotheken enthalten in der Regel korrekte Implementierungen von Funktionen und berücksichtigen Probleme sowie Sonderfälle, die ein einzelner Entwickler möglicherweise übersehen würde. Die Wartung und Anpassung von Bibliotheken wird oft von anderen Entwicklern übernommen, was die Entwickler entlastet. Die Verwendung weit verbreiteter Bibliotheken erleichtert die Kommunikation und Zusammenarbeit mit anderen Entwicklern, da diese bereits mit den Bibliotheken vertraut sind.'},
     {'question': 'Warum sollten Entwickler in der objektorientierten Programmierung Bibliotheken nutzen?', 'answer': 'Entwickler sollten Bibliotheken in der objektorientierten Programmierung nutzen, um Zeit zu sparen, Fehler zu vermeiden, auf bewährte Lösungen zuzugreifen und den Entwicklungsprozess effizienter zu gestalten. Die Verwendung von Bibliotheken ermöglicht es Entwicklern, sich auf die spezifischen Anforderungen ihres Projekts zu konzentrieren, anstatt grundlegende Funktionen und Implementierungen selbst zu schreiben. Dies trägt zur Produktivität und Qualität der Software bei.'},
     {'question': 'Was kennzeichnet den deklarativen Programmierstil in der objektorientierten Programmierung?', 'answer': 'Der deklarative Programmierstil in der objektorientierten Programmierung legt mehr Wert auf das "Was" als auf das "Wie". Er betont die Ausdrucksform und verschiebt mögliche Optimierungen auf den Compiler oder später in der Entwicklung. Das bedeutet, dass die Programmiererin sich auf das Beschreiben dessen konzentriert, was erreicht werden soll, anstatt detaillierte Anweisungen zur Durchführung zu geben.'},
     {'question': 'Warum ist der deklarative Programmierstil in der objektorientierten Programmierung trotz ihres eher imperativen Charakters relevant?', 'answer': 'Der deklarative Programmierstil ist in der objektorientierten Programmierung relevant, da er die Lesbarkeit und Wartbarkeit des Codes verbessert. Obwohl die objektorientierte Programmierung tendenziell eher imperativ ist, kann der deklarative Stil durch den Einsatz von aussagekräftigen Bezeichnern und die Aufteilung von Funktionalität in separate Methoden erreicht werden. Dies führt dazu, dass der Code leichter zu verstehen ist und die Absicht der Programmiererin klarer hervortritt.'},
     {'question': 'Warum sind Abkürzungen in der Programmierung nicht grundsätzlich zu vermeiden?', 'answer': 'Abkürzungen in der Programmierung sind nicht grundsätzlich zu vermeiden, besonders wenn sie etabliert sind und die Leserin des Programms wahrscheinlich weiß, was sie bedeuten. Dies kann dazu beitragen, zu lange Namen zu vermeiden und den Code lesbarer zu machen.'},
     {'question': 'Warum sollte man auf selbst erstellte Abkürzungen verzichten?', 'answer': 'Auf selbst erstellte Abkürzungen sollte man verzichten, da ihre Bedeutung oft nur von der Person bekannt ist, die sie erstellt hat. Dies kann die Lesbarkeit des Codes für andere Programmiererinnen beeinträchtigen und zu Missverständnissen führen.'},
     {'question': 'In welchen Fällen ist die Verwendung von Abkürzungen in JAVA und ähnlichen objektorientierten Programmiersprachen legitim?', 'answer': 'In JAVA und ähnlichen objektorientierten Programmiersprachen ist die Verwendung von Abkürzungen legitim, wenn Typen und Variablen denselben Namen haben und sich nur in der Groß- bzw. Kleinschreibung ihres Anfangsbuchstabens unterscheiden. Dies kann in Fällen auftreten, in denen es keinen besseren Namen für die Variable gibt und die Sichtbarkeit der Variable auf die unmittelbare Umgebung der Deklaration beschränkt ist.'},
     {'question': 'Ist es möglich, die Einhaltung des Gesetzes Demeters automatisch zu überprüfen? Warum oder warum nicht?', 'answer': 'Die automatische Überprüfung des Gesetzes Demeters gestaltet sich schwierig, da das Gesetz in Bezug auf Objekte formuliert ist und die Auswertung von konkreten Zuweisungen und dynamischen Programmfluss erfordern würde, was mechanisch extrem aufwendig oder sogar unmöglich ist. Stattdessen überprüfen automatische Checker des Gesetzes Demeters in der Regel die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters haben.'},
     {'question': 'Warum ist die automatische Überprüfung des Gesetzes Demeters in SMALLTALK nicht möglich?', 'answer': 'In SMALLTALK ist die automatische Überprüfung des Gesetzes Demeters nicht möglich, da Ausdrücke in SMALLTALK nicht typisiert sind. Daher können Checker nicht feststellen, ob die Art und Weise, wie auf Objekte zugegriffen wird, dem Gesetz Demeters entspricht.'},
     {'question': 'Was wird komplizierter, wenn die Verkettung von Methodenaufrufen länger ist?', 'answer': 'Die Sache wird komplizierter, wenn die Verkettung von Methodenaufrufen länger ist, da dann alle Methoden in der Verkettung zur Klasse des ersten Nachrichtenempfängers hinzugefügt und mit entsprechenden Implementierungen versehen werden müssen. Dies führt zu einem Wachstum des Protokolls der Klasse des ersten Nachrichtenempfängers.'},
     {'question': 'Was besagt das Gesetz Demeters in Bezug auf die Nachrichtenübermittlung in der objektorientierten Programmierung?', 'answer': 'Das Gesetz Demeters besagt, dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, indem es auf eine Variable direkt zugreift, die das andere Objekt benennt. Die Dauer des Kennens kann variieren, wobei Instanzvariablen eine dauerhafte Bindung darstellen, während formale Parameter einer Methode temporär bekannt sind.'},
     {'question': 'Warum muss man bei der Verwendung von Collections als Zwischenobjekte immer eine Ausnahme von Demeters Gesetz machen?', 'answer': 'Bei der Verwendung von Collections als Zwischenobjekte muss man eine Ausnahme von Demeters Gesetz machen, weil die Verwendung von Iteratoren und Methoden wie "detect:" eine Verkettung von Nachrichten erzeugt, die in direktem Widerspruch zum Gesetz Demeters steht. Dies liegt daran, dass die Klausel "detect:" auf einer Kollektion nicht dem Prinzip des Gesetzes Demeters entspricht, bei dem Nachrichten nur an Objekte gesendet werden dürfen, die der Sender selbst kennt oder erzeugt.'},
     {'question': 'Warum ist das Gesetz Demeters umstritten und nicht allgemein anerkannt?', 'answer': 'Das Gesetz Demeters ist umstritten und nicht allgemein anerkannt, weil es in einigen Fällen schwer umsetzbar sein kann und zu unpraktischem Code führen kann. Es erfordert, dass Verkettungen von Nachrichten vermieden werden, was in einigen Fällen zu einer unnötigen Fragmentierung des Codes führen kann. Einige Entwickler sehen das Gesetz Demeters als zu restriktiv an und argumentieren, dass es in bestimmten Situationen vernünftiger ist, Verkettungen von Nachrichten zu verwenden, um den Code lesbarer und effizienter zu gestalten. Dennoch ist es wichtig, das Gesetz Demeters zu verstehen und in Betracht zu ziehen, da es in vielen Fällen dazu beitragen kann, die Kopplung zwischen Klassen zu verringern und den Code wartbarer zu machen.'}],
]
