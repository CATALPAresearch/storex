"""
Questions sorted into open questions and question-answer pairs per course unit.
"""

KE1_topics = {'question': "Was ist das Grundkonzept der objektorientierten Programmierung?",
              'keywords': ["Objekt", "Beziehung", "Zustand", "Verhalten"]}

KE2_topics = {'question': "Mittels welcher Konzepte lassen sich objektorientierte Programme strukturieren?",
              'keywords': ["Klasse", "Metaklasse", "Generalisierung", "Spezialisierung", "Vererbung",
                           "abstrakte Klasse", "Superklasse", "Subklasse", "dynamisch Binden", "Collection",
                           "Parallelität"]}

KE3_topics = {'question': "Was sind Typen in der objektorientierten Programmierung?",
              'keywords': ["Deklaration", "Definition", "Typdefinition", "Zuweisungskompatibilität", "Typäquivalenz",
                           "Typerweiterung", "Typkonformität", "Typeinschränkung", "Subtyp", "Inklusionspolymorphie",
                           "Typumwandlung", "Generischer Typ", "parametrischer Polymorphismus", "Kovarianz",
                           "Typisierung"]}

# KE4_topics = {'question': "Was sind die Besonderheiten von Java?",
#               'keywords': ["Programmiermodell", "Objekt", "Typ", "Klasse", "Ausdruck", "Anweisung", "Block",
#                            "Kontrollstruktur", "Modul", "Interface", "Array", "Aufzählungstyp", "Generischer Typ",
#                            "dynamische Typprüfung", "interne Iteration", "externe Iteration", "spezielle Klasse"]}

KE4_topics = {'question': "Was sind die Besonderheiten anderer Programmiermodelle?",
              'keywords': ["Interface", "Generischer Typ", "dynamische Typprüfung", "Mehrfachvererbung"]}  # "Java", "C-Sharp", "C++", "EIFFEL"

KE6_topics = {'question': "Was sind Probleme der objektorientierten Programmierung?",
              'keywords': ["Problem der Substituierbarkeit",
                           "Fragile-base-class-Problem",
                           "Problem der schlechten Tracebarkeit",
                           "Problem der eindimensionalen Strukturierung",
                           "Problem der mangelnden Kapselung",
                           "Problem der mangelnden Skalierbarkeit",
                           "Problem der mangelnden Eignung"]}

# KE7_topics = {'question': "Was ist guter objektorientierter Stil?",
#               'keywords': ["Namen", "Formatierung", "kurze Methoden", "deklarativ", "Bibliothek", "Verteilung",
#                            "Gesetz Demeters", "Klassenhierarchie"]}

KE1_questions = [
    [{'question': 'Was ist ein Literal?', 'answer': 'Ein Literal ist eine Repräsentation eines Objekts, die in der Syntax der Programmiersprache ausgedrückt wird. Literale sind somit textuelle Spezifikationen von Objekten.'},
     {'question': 'Was sind die einfachsten Literale in SMALLTALK?', 'answer': 'Die einfachsten Literale in SMALLTALK repräsentieren Zeichenobjekte.'},
     {'question': 'Was sind atomare Objekte?', 'answer': 'Atomare Objekte sind Zeichenobjekte und Zahlobjekte, die nicht aus anderen Objekten bestehen.'},
     {'question': 'Was sind Pseudo-Variablen in SMALLTALK?', 'answer': 'In SMALLTALK sind die in anderen Programmiersprachen vorhandenen Literale, die ebenfalls atomare Objekte repräsentieren, Pseudo-Variablen.'},
     {'question': 'Was sind Strings?', 'answer': 'Strings sind aus Zeichen zusammengesetzte Zeichenketten. String-Literale repräsentieren also zusammengesetzte Objekte.'},
     {'question': 'Was sind Symbole in SMALLTALK?', 'answer': 'Symbole sind eine weitere Art von Objekten mit literaler Repräsentation in SMALLTALK. Sie dienen dazu, sicherzustellen, dass syntaktisch identische Zeichenketten stets dasselbe Objekt bezeichnen.'},
     {'question': 'Was sind Array-Literale in SMALLTALK ?', 'answer': 'Array-Literale repräsentieren Objekte, die aus einer Folge beliebiger anderer Objekte bestehen.'},
     {'question': 'Was sind unveränderliche Objekte?', 'answer': 'Unveränderliche oder zustandslose Objekte in SMALLTALK sind Objekte, deren Zustand nicht geändert werden kann. Operationen oder Methoden, die auf solchen Objekten ausgeführt werden, ändern nicht den Zustand des Objekts selbst, sondern erzeugen in der Regel ein neues Objekt als Ergebnis.'},
     {'question': 'Was ist die Gleichheit von Objekten?', 'answer': 'Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten und wird in SMALLTALK durch den Gleichheitsoperator getestet.'},
     {'question': 'Was ist die Identität von Objekten?', 'answer': 'Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren.'},
     {'question': 'Was sind reservierte Namen in SMALLTALK?', 'answer': 'In SMALLTALK gibt es einige reservierte Namen, die als Pseudovariablen dienen. Diese reservierten Namen sind: true, false, nil, self and super. Alle anderen Schlüsselwörter, die in anderen Programmiersprachen üblich sind, werden in SMALLTALK als Methoden definiert.'},
     {'question': 'Was sind anonyme Funktionen?', 'answer': 'Blöcke in SMALLTALK können auch als anonyme Funktionen aufgefasst werden.'},
     {'question': 'Was sind parametrisierten Blöcke?', 'answer': 'Parametrisierte Blöcke können mit Parametern versehen werden, die bei ihrer Auswertung an Objekte aus dem Auswertungskontext gebunden werden können.'},
     {'question': 'Was ist der Home Context eines Blocks in SMALLTALK?', 'answer': 'Der Home Context eines Blocks in SMALLTALK ist der Kontext, in dem der Block definiert wurde oder genauer gesagt, in dem das ihn repräsentierende Objekt erzeugt wurde. Dieser Kontext enthält Informationen über die lokalen Variablen und formalen Parameter, die der Block "einfängt". Die Ausführung eines Blocks erfolgt immer in seinem Home Context, selbst wenn der Block in einem anderen Kontext ausgewertet wird.'},
     {'question': 'Was sind Closures?', 'answer': 'Closures sind in SMALLTALK Blöcke für sogenannte Lambda-Ausdrücke verwendet, also für anonyme Funktionen, die selbst Objekte oder Werte sind und deshalb aus ihrem Kontext herausgelöst und in andere verschoben werden können.'},
     {'question': 'Was sind Blöcke?', 'answer': 'Blöcke in SMALLTALK werden in anderen Programmiersprachen oft als (lexikalische) Closures bezeichnet. Sie werden für sogenannte Lambda-Ausdrücke verwendet, die anonyme Funktionen repräsentieren und als Objekte oder Werte behandelt werden können. Closures erlauben es, Funktionen aus ihrem Kontext herauszulösen und in andere Kontexte zu übertragen. Die Verwendung und das Verhalten von Closures können sich jedoch zwischen verschiedenen Programmiersprachen erheblich unterscheiden.'},
     {'question': 'Was sind Attribute?', 'answer': 'Attribute sind Instanzvariablen, die die Eigenschaften eines Objekts festhalten.'},
     {'question': 'Was sind die beiden Kategorien von Instanzvariablen?', 'answer': 'Instanzvariablen können logischerweise in zwei Kategorien unterteilt werden: solche, die die Eigenschaften eines Objekts festhalten, und solche, die tatsächliche Beziehungen zwischen Objekten repräsentieren. Eigenschaften sind Attribute wie Farbe oder Name, die ihre Bedeutung verlieren, wenn sie isoliert betrachtet werden. Beziehungen hingegen repräsentieren Verbindungen zwischen Objekten und behalten ihre Bedeutung auch isoliert betrachtet.'},
     {'question': 'Welche Semantik haben Variablen, die Attribute repräsentieren?', 'answer': 'Variablen, die Attribute repräsentieren, haben in der Regel eine Wertsemantik. Das bedeutet, sie halten eigene Kopien eines Objekts (oder verweisen darauf, je nach Implementierung der Sprache). Dies ermöglicht es, dass Änderungen an einem Attributwert nicht automatisch andere Objekte mit dem gleichen Attributwert beeinflussen.'},
     {'question': 'Welche Objekte sind in SMALLTALK veränderbar?', 'answer': 'Atomare Objekte und Objekte, die aus Symbolliteralen hervorgegangen sind, sind grundsätzlich nicht veränderbar. Zusammengesetzte Objekte in SMALLTALK sind jedoch veränderbar.'},
     {'question': 'Was sind Kontrollstrukturen?', 'answer': 'Kontrollstrukturen regeln den Ablauf des Programms, also die Reihenfolge der Schritte, die seine Ausführung bestimmen. In SMALLTALK gibt es ie Sequenz und den dynamisch gebundenen Methodenaufruf.'},
     {'question': 'Welche Kontrollstrukturen gibt es in SMALLTALK?', 'answer': 'In SMALLTALK gibt es nur zwei Kontrollstrukturen, nämlich die Sequenz und den dynamisch gebundenen Methodenaufruf.'},
     {'question': 'Was ist eine Zuweisung?', 'answer': 'Eine Zuweisung ist der Vorgang, bei dem einer Variable ein Objekt zugewiesen wird, damit sie dieses Objekt bezeichnet.'},
     {'question': 'Was ist ein Block in SMALLTALK?', 'answer': 'Ein Block in SMALLTALK ist eine abgegrenzte Sequenz oder Folge von Anweisungen. Anders als eine Methode ist ein Block nicht benannt, kann aber einer Variable zugewiesen werden.'},
     {'question': 'Was sind Instanzvariablen?', 'answer': 'Instanzvariablen sind lokale Variablen, die einem Objekt zugeordnet sind und dazu verwendet werden, Informationen zu speichern, die spezifisch für dieses Objekt sind. Sie bestimmen die Struktur zusammengesetzter Objekte.'},
     {'question': 'Wie ist die Sichtbarkeit von Instanzvariablen in SMALLTALK begrenzt?', 'answer': 'Die Sichtbarkeit von Instanzvariablen in SMALLTALK ist auf das besitzende Objekt beschränkt. Instanzvariablen können von anderen Objekten nicht direkt zugegriffen werden.'},
     {'question': 'Welche zwei Arten von Instanzvariablen werden in SMALLTALK unterschieden?', 'answer': 'In SMALLTALK werden zwei Arten von Instanzvariablen unterschieden: benannte und indizierte Instanzvariablen.'},
     {'question': 'Was sind benannte Instanzvariablen in SMALLTALK?', 'answer': 'Benannte Instanzvariablen sind Instanzvariablen, die jeweils auf ein bestimmtes Objekt verweisen oder es benennen. Der Name der Variablen wird zum Namen des Objekts, auf das sie verweisen.'},
     {'question': 'Was sind indizierte Instanzvariablen in SMALLTALK?', 'answer': 'Indizierte Instanzvariablen haben keine Namen, sondern werden über einen Index relativ zum Objekt angesprochen, dem sie gehören. Der Index fungiert gewissermaßen als Name für die Instanzvariable.'},
     {'question': 'Welche Arten von Ausdrücken gibt es?', 'answer': 'Es gibt Literale, Variablen, Zuweisungsausdrücke und Nachrichtenausdrücke.'},
     {'question': 'Was sind primitive Ausdrücke?', 'answer': 'Primitive Ausdrücke sind nicht aus anderen Ausdrücken zusammengesetzt, wie Literale und Variablen.'},
     {'question': 'Welche zwei Ausdrücke ermöglichen die Programmausführung?', 'answer': 'Zuweisungsausdrücke und Nachrichtenausdrücke sind wichtig. Sie ermöglichen es, Aktionen mit den repräsentierten Objekten auszuführen und damit ein Programm tatsächlich auszuführen.'},
     {'question': 'Was sind Anweisungen?', 'answer': 'Anweisungen legen fest, wie ein Programm schrittweise ausgeführt wird.'},
     {'question': 'Was sind primitive Methoden?', 'answer': 'Primitive Methoden sind primitive Operationen, die auf native Implementierungen zurückgreifen. Diese Methoden sind durch Nummern identifiziert und sollen nicht direkt von Programmierern verwendet werden.'},
     {'question': 'Was ist der Lebenslauf eines Objekts in SMALLTALK?', 'answer': 'In SMALLTALK beginnt der Lebenslauf eines Objekts mit seiner Erzeugung und endet mit seiner Entsorgung durch eine Speicherbereinigung.'},
     {'question': 'Was ist die "Garbage Collection" in SMALLTALK?', 'answer': 'Die "Garbage Collection" ist ein Mechanismus in SMALLTALK, der Objekte aus dem Speicher entfernt, wenn sie nicht mehr über Variablen zugreifbar sind.'},
     {'question': 'Welche Objekte sind von der automatischen Speicherbereinigung ausgenommen?', 'answer': 'Von der automatischen Speicherbereinigung ausgenommen sind Objekte mit eindeutiger literaler Repräsentation, wie kleine Zahlen, Zeichen und Symbole. Zahlen und Zeichen werden durch Werte in Variablen repräsentiert und Symbole sind in einer Symboltabelle abgelegt.'},
     {'question': 'Was verbirgt sich hinter dem Nachrichtenversand in SMALLTALK?', 'answer': 'Hinter dem Nachrichtenversand in SMALLTALK verbirgt sich der Methodenaufruf. Wenn ein Objekt eine Nachricht an ein Empfängerobjekt sendet, wird der Kontrollfluss zur Methode des Empfängerobjekts verschoben, die zur Reaktion auf die Nachricht vorgesehen ist. Nach der Abarbeitung dieser Methode kehrt der Kontrollfluss an das sendende Objekt zurück und setzt seine Arbeit dort fort.'},
     {'question': 'Was ist eine Zuweisung?', 'answer': 'Eine Zuweisung ist eine Aktion, bei der der Inhalt einer Variable geändert wird. Die Zuweisung selbst steht für (eine Referenz auf) das Objekt. Dies ist eine Art von Seiteneffekt der Auswertung des Ausdrucks.'},
     {'question': 'Was ist ein Methodenaufruf?', 'answer': 'Ein Methodenaufruf ist die Auswertung eines Nachrichtenausdrucks, da diese zur Ausführung der Anweisungen im Rumpf einer Methode führt.'},
     {'question': 'Was sind Objekte in der objektorientierten Programmierung?', 'answer': 'Objekte sind in der objektorientierten Programmierung Daten, die im Speicher abgelegt sind und in der Lage sind, Informationen zu speichern und Aktionen auszuführen. Sie repräsentieren Dinge aus der realen Welt und können miteinander in Beziehung stehen.'},
     {'question': 'Können Sie auch Inkonsistenzen im objektorientierten Weltbild nennen?', 'answer': 'In der objektorientierten Programmierung werden verschiedene Arten von Sachverhalten, die in der realen Welt unterschiedliche Eigenschaften haben, durch Objekte repräsentiert. Dies kann zu Inkonsistenzen führen, da nicht alle Sachverhalte dieselben Eigenschaften wie Objekte haben. Dies ist auf die homogene Natur der Objektorientierung zurückzuführen.'},
     {'question': 'Was sind Pseudovariablen in SMALLTALK?', 'answer': 'Pseudovariablen in SMALLTALK sind Variablen wie "true", "false", "nil", "self", "super" und formale Parameter von Methoden sowie Klassennamen, denen der Programmierer keinen Wert zuweisen kann.'},
     {'question': 'Was ist der "Inhalt" einer Variable?', 'answer': 'Der "Inhalt" einer Variable bezieht sich auf das Objekt, das von der Variable bezeichnet wird.'},
     {'question': 'Was ist Verweis- oder Referenzsemantik?', 'answer': 'Bei Verweis- oder Referenzsemantik haben Variablen nur Verweise die Speicherstellen, an denen die Objekte abgelegt sind.'},
     {'question': 'Was ist Wertsemantik?', 'answer': 'Bei Wertsemantik macht das bezeichnete Objekt tatsächlich den Inhalt der Variable aus.'},
     {'question': 'Was ist eine Variable aus technischer Sicht?', 'answer': 'Aus technischer Sicht entspricht eine Variable einer Stelle im Speicher.'},
     {'question': 'Was sind Variablen mit Verweissemantik?', 'answer': 'Es handelt sich bei Variablen mit Verweissemantik aus technischer Sicht um Pointervariablen.'},
     {'question': 'Welche Variablen haben in SMALLTALK Wertsemantik?', 'answer': 'In den meisten SMALLTALK-Implementationen haben Variablen, die Zeichen, kleine Zahlen und boolesche Werte bezeichnen, Wertsemantik, um Speicherplatz zu sparen, obwohl der Begriff der Identität für diese Objekte verloren geht. Die mehrfache Existenz identischer Objekte im Speicher hat in der Regel keine große Bedeutung, da Gleichheit an die Stelle der Identität treten kann.'},
     {'question': 'Was umfasst der Home Context eines Blocks?', 'answer': 'Das Konzept des Home Contexts eines Blocks in SMALLTALK umfasst nicht nur die sichtbaren Variablen aus dem Kontext der Definition des Blocks, sondern auch den sogenannten Call Stack, der die Rücksprungadressen von Methodenaufrufen speichert.'},
     {'question': 'Was ist eine Continuation im Kontext von Blöcken?', 'answer': 'Im Kontext von Blöcken in SMALLTALK bezieht sich "Continuation" auf das Konzept, dass eine Return-Anweisung innerhalb eines Blocks immer zur unmittelbaren Rückkehr in den Home Context des Blocks führt.'},
     {'question': 'Worauf bezieht sich die Sichtbarkeit einer Variable?', 'answer': 'Die Sichtbarkeit einer Variable bezieht sich immer auf einen Abschnitt des Programmcodes, in dem der Variablenname verwendet werden kann und damit Zugriff auf das von diesem Namen bezeichnete Objekt besteht.'},
     {'question': 'Was ist das Geheimnisprinzip?', 'answer': 'Das Geheimnisprinzip oder Information Hiding bezieht sich auf das Verbergen von Implementationsdetails eines Objekts, insbesondere der Struktur zusammengesetzter Objekte, vor den Objekten, die sie verwenden. Dadurch können Änderungen an der Struktur vorgenommen werden, ohne dass abhängige Objekte davon betroffen sind.'},
     {'question': 'Was ist Kapselung?', 'answer': 'Bei der Kapselung geht es darum, dass ein Objekt seinen Zustand so kapselt, dass dieser nur von ihm selbst geändert werden kann.'},
     {'question': 'Was sind Zugriffsmethoden?', 'answer': 'Zugriffsmethoden sind Methoden, um die Belegung der Instanzvariablen und damit den Zustand eines Objekts auszulesen oder zu verändern. In Java gibt es dafür Getter und Setter.'},
     {'question': 'Was ist das Interface eines Objekts?', 'answer': 'Das Interface eines Objekts ist die Art und Weise, wie ein Objekt seinen Zustand codiert, als sein Implementationsgeheimnis und die Menge der Methodensignaturen, die den Zugriff auf das Objekt (seinen Zustand) erlauben.'},
     {'question': 'Was sind Schlüsselwörter?', 'answer': 'In Programmiersprachen wie PASCAL, C oder Java repräsentieren Schlüsselwörter Kontrollstrukturen.'},
     {'question': 'Welche Kontrollstrukturen kennen Sie?', 'answer': 'Die grundlegenden Kontrollstrukturen sind: Sequenz, Verzweigung, Wiederholung (Iteration) und Aufruf.'},
     {'question': 'Was sind Kardinalitäten?', 'answer': 'Kardinalitäten sind in der Daten- und Softwaremodellierung häufig verwendete Beziehungsattribute, die angeben, wie viele andere Objekte ein Objekt in einer Beziehung haben kann.'},
     {'question': 'Welche Beziehungen gibt es?', 'answer': 'Es gibt Zu-1-Beziehungen und Zu-n-Beziehungen wobei n hier andeutet, dass es sich um eine nicht näher spezifizierte Zahl größer als 1 handelt.'},
     {'question': 'Was sind Zwischenobjekte?', 'answer': 'Die Aufgabe von Zwischenobjekten ist es, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen. Zwischenobjekte können zusätzliche Attribute enthalten, die in ihren benannten Instanzvariablen gespeichert werden.'},
     {'question': 'Was ist das Protokoll eines Objekts?', 'answer': 'Das Protokoll eines Objekts ist der Katalog von Methoden, über den ein Objekt verfügt und auf den es entsprechend reagieren kann.'},
     {'question': 'Was bezeichnet die Variable "self" in Methoden?', 'answer': 'Die Variable "self" verweist immer auf das Empfängerobjekt der Nachricht, also auf das Objekt, dessen Instanzvariablen gerade zugreifbar sind. Sie wird benötigt, wenn eine Nachricht aus einer Methode heraus an das Objekt geschickt werden soll, dem die Methode zugeordnet ist, also an sich selbst. "self" ist somit der implizite erste Parameter einer Methode.'},
     {'question': 'Was ist die Teil-Ganzes-Beziehung?', 'answer': 'Die Teil-Ganzes-Beziehung bestimmt die Weltansicht, dass alles aus kleineren Teilen zusammengesetzt ist, die selbst wieder Zusammensetzungen (Aggregate, Komposita) sind, bis hinunter zu den elementaren, unteilbaren Bausteinen.'},
     {'question': 'Woraus setzt sich der Zustand eines Objekts zusammen?', 'answer': 'Der Zustand eines Objekts setzt sich aus den Werten seiner Instanzvariablen zusammen. Da Instanzvariablen Beziehungen ausdrücken, wird der Zustand eines Objekts ausschließlich durch seine Verknüpfung mit anderen Objekten definiert.'},
     {'question': 'Was sind konstante Methoden?', 'answer': 'Konstante Methoden sind Methoden, die immer dasselbe Objekt zurückgeben. Sie werden häufig verwendet, um Literale auf eine Weise zu repräsentieren, die sicherstellt, dass sie konsistent sind und immer auf dasselbe Objekt verweisen.'},
     {'question': 'Was sind Zuweisungsausdrücke?', 'answer': 'Zuweisungsausdrücke bestehen aus einer Variablen auf der linken Seite und einem Ausdruck auf der rechten Seite. Sie bewirken den Zustandswechsel von Objekten und sind die einzigen Ausdrücke, die dies tun.'},
     {'question': 'Welche Auswirkung haben Zuweisungsausdrücke auf Objekte?', 'answer': 'Zuweisungsausdrücke ändern den Zustand von Objekten, indem sie neue Werte in Variablen zuweisen.'},
     {'question': 'Wofür ist das Verhalten eines Objekts zuständig?', 'answer': 'Wenn Objekte ihren Zustand kapseln, ist ausschließlich das Verhalten eines Objekts dafür verantwortlich, den Zustand eines Objekts zu ändern und die Interaktion mit diesem Objekt zu steuern. Das Verhalten bestimmt, wie ein Objekt auf Nachrichten reagiert und welche Operationen es auf seinem internen Zustand durchführt.'},
     {'question': 'Welche wichtigen Ausdrucksform können Sie nennen?', 'answer': 'Die Zuweisung und der Nachrichtenversand sind wichtige Ausdrucksformen.'},
     {'question': 'Was sind unäre Nachrichten?', 'answer': 'Unäre Nachrichten sind parameterlose Nachrichten, die den Empfänger als implizites erstes Argument haben.'},
     {'question': 'Was sind binäre Nachrichten?', 'answer': 'Binäre Nachrichten sind Nachrichten mit einem Parameter, der aus zwei Argumenten besteht: dem Empfänger und einem weiteren Argument.'},
     {'question': 'Was sind Schlüsselwortnachrichten in SMALLTALK?', 'answer': 'Schlüsselwortnachrichten sind Nachrichten in SMALLTALK, die neben dem Empfänger mindestens ein Argument erfordern. Sie enthalten normalerweise kein herkömmliches Schlüsselwort im Sinne von Schlüsselwort-Argumenten, da SMALLTALK keine herkömmlichen Schlüsselwörter verwendet.'},
     {'question': 'Was ist ein Nachrichtenausdruck?', 'answer': 'Ein Nachrichtenausdruck besteht aus einem Empfängerobjekt, einem Nachrichtenselektor und einer Anzahl von Argumentausdrücken. Der Ausdruck als Ganzes repräsentiert das Ergebnis der Nachrichtenauswertung durch den Empfänger.'},
     {'question': 'Was ist die Kaskadierung in SMALLTALK?', 'answer': 'Die Kaskadierung ist eine syntaktische Abkürzung in SMALLTALK, die es ermöglicht, eine Sequenz von Nachrichten an dasselbe Empfängerobjekt zu senden, ohne das Objekt jedes Mal wiederholen zu müssen. Dies erleichtert das Verketten von Nachrichten an dasselbe Objekt.'},
     {'question': 'Was ist das Protokoll in SMALLTALK?', 'answer': 'In SMALLTALK ist das Protokoll eines Objekts die Menge der Nachrichten, die es versteht. Es wird in Form der Protokollbeschreibung spezifiziert und besteht aus den Methodensignaturen und den dazugehörigen Kommentaren der Methoden. Das Protokoll beschreibt das Interface eines Objekts.'},
     {'question': 'Was ist dynamisches Binden?', 'answer': 'Dynamisches Binden ist eine charakteristische Eigenschaft der objektorientierten Programmierung, bei der die Auswahl der Methodenimplementierung erst zur Laufzeit erfolgt, abhängig vom Empfängerobjekt des Methodenaufrufs. Dies wird auch als Polymorphismus oder Polymorphie bezeichnet.'},
     {'question': 'Was ist statisches Binden?', 'answer': 'Bei statischem Binden wird ein Methodenaufruf schon zur Übersetzungszeit an eine Implementierung gebunden.'},
     {'question': 'Was sind Variablen?', 'answer': 'Variablen sind Namen, die zu verschiedenen Zeitpunkten verschiedene Objekte bezeichnen können.'},
     {'question': 'Welche Ausdrücke haben in SMALLTALK Vorrang?', 'answer': 'In SMALLTALK haben unäre Ausdrücke Vorrang vor binären Ausdrücken, und binäre Ausdrücke haben Vorrang vor Schlüsselwortnachrichten.'},
     {'question': 'Was ist eine Methode?', 'answer': 'Eine Methode beschreibt, was ein Objekt in Reaktion auf den Erhalt einer bestimmten Nachricht tun soll. Eine Methode besteht aus einem Methodenkopf (Methodensignatur), einer optionalen Liste von lokalen Variablen und einem Methodenrumpf, der die Anweisungen für die Ausführung der Methode enthält.'},
     {'question': 'Was ist eine Methodensignatur?', 'answer': 'Eine Methodensignatur beschreibt, welche Parameter eine Methode erwartet und wie sie in SMALLTALK aufgerufen wird. Sie besteht aus dem Methodennamen und der Liste der formalen Parameter.'},
     {'question': 'Was ist ein Nachrichtenselektor?', 'answer': 'Ein Nachrichtenselektor ist Teil eines Nachrichtenausdrucks und gibt an, welche Methode auf dem Empfängerobjekt aufgerufen werden soll.'},
     {'question': 'Was sind Methodenrümpfe?', 'answer': 'Methodenrümpfe bestehen aus einer Folge von Anweisungen.'},
     {'question': 'Welche Funktion hat die Return-Anweisung?', 'answer': 'Die Return-Anweisung ermöglicht eine explizite Beendigung der Methode und die Rückgabe eines anderen Objekts als des Empfängers. Die Return-Anweisung kann an beliebigen Stellen innerhalb der Methode auftreten und beeinflusst den Kontrollfluss des Programms.'},
     {'question': 'Was sind temporäre Variablen?', 'answer': 'Eine Methode kann temporäre Variablen für ihre Berechnungen benötigen. Temporäre Variablen existieren nur für die Dauer der Ausführung der Methode und werden vom System nach Beendigung der Methode entfernt. Die Werte sind außerhalb der Methode nicht sichtbar. Temporäre Variablen können auch der besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben.'},
     {'question': 'Was sind Methoden?', 'answer': 'Methoden sind die Einheiten des Programms, in denen die Anweisungen untergebracht sind.'},
     {'question': 'Was ist Aliasing?', 'answer': 'Aliasing bezieht sich auf die Situation, in der mehrere Variablen gleichzeitig auf dasselbe Objekt verweisen. Das bedeutet, dass ein Objekt mehrere Namen, Aliase, haben kann.'},
     {'question': 'Ist die Zuweisung kommutativ?', 'answer': 'Die Zuweisung ist nicht kommutativ, es sei denn, die Variablen auf der linnken und der rechten Seite hatten bereits denselben Wert vor der jeweiligen Zuweisung.'},
     {'question': 'Was bezeichnet eine Variable?', 'answer': 'Eine Variable bezeichnet ein Objekt.'},
     {'question': 'Was ist wichtig im Umgang mit Aliasen?', 'answer': 'Es ist wichtig, sich der aliasbildenden Wirkung der Zuweisung bewusst zu sein, da dies in Sprachen wie SMALLTALK der Regelfall ist.'}
     ],
    [{'question': 'Wie werden Verzweigungen und Wiederholungen in SMALLTALK simuliert?', 'answer': 'Verzweigungen und Wiederholungen in SMALLTALK werden durch die Verwendung von Blöcken und dynamisch gebundenen Methodenaufrufen simuliert. Da SMALLTALK keine direkten Verzweigungs- und Schleifenkonstrukte wie in einigen anderen Programmiersprachen hat, werden Entscheidungen und Wiederholungen durch den Aufruf entsprechender Methoden und die Auswertung von Blöcken erreicht.'},
     {'question': 'Wie sendet man Nachrichten in Zu-1-Beziehungen?', 'answer': 'In Zu-1-Beziehungen in SMALLTALK sendet man oft Nachrichten direkt an das Objekt, auf das die betreffende Variable verweist.'},
     {'question': 'Wie sendet man Nachrichten in Zu-n-Beziehungen?', 'answer': 'Bei Zu-n-Beziehungen erreicht die Nachricht nicht mehr die logisch in Beziehung stehenden Objekte, sondern das Zwischenobjekt, das die Beziehung selbst repräsentiert (der Wert der Variable). Um die Nachricht stattdessen an alle von diesem Zwischenobjekt referenzierten Objekte zu senden, verwendet man die Nachricht do: aBlock, wobei aBlock ein Block ist, der mit einem Parameter parametrisiert ist und der für jedes Element des Arrays genau einmal (mit dem Element als tatsächlichem Parameter) aufgerufen wird.'},
     {'question': 'Wie kann eine Sequenz unterbrochen werden?', 'answer': 'In SMALLTALK kann die zeitliche Sequenz von aufeinanderfolgenden Anweisungen nur durch den Methodenaufruf unterbrochen werden.'},
     {'question': 'Wann kann ein Objekt aus dem Speicher entfernt werden?', 'answer': 'Ein Objekt kann aus dem Speicher entfernt werden, wenn keine Variable mehr auf dieses Objekt verweist und es somit nicht mehr erreichbar ist.'},
     {'question': 'Wie werden Nachrichtenausdrücke in SMALLTALK ausgewertet?', 'answer': 'Nachrichtenausdrücke in SMALLTALK werden ausgewertet, indem die Nachricht (das Prädikat) an das Empfängerobjekt (das Subjekt) mit den Parametern (Prädikatsergänzungen) gesendet wird. Nach der Auswertung repräsentiert der Nachrichtenausdruck das Ergebnis der Nachricht, das von dem Empfängerobjekt zurückgegeben wird.'},
     {'question': 'Wie lässt sich der Zugriff auf Variablen einschränken?', 'answer': 'Um den Zugriff auf Variablen einzuschränken, gibt es den Begriff der Sichtbarkeit und Regeln für die Sichtbarkeit von Variablen.'},
     {'question': 'Wie wird die Iteration in SMALLTALK realisiert?', 'answer': 'Die Iteration in SMALLTALK erfolgt durch eine Form der internen Iteration, bei der die Steuerstruktur für das Fortschreiten durch Elemente und die Überprüfung der Abbruchbedingung innerhalb der Sammlung erfolgt, über die iteriert wird.'},
     {'question': 'Wie wird die Kapselung in SMALLTALK umgesetzt?', 'answer': 'Über lokale Instanzvariablen kann ein Objekt verbergen, welche Objekte es kennt. Aber aufgrund von Aliasing kann ein Objekt, dessen Name unsichtbar ist, über einen anderen Namen zugänglich sein kann.'},
     {'question': 'Wie ist die Sichtbarkeit von Instanzvariablen in SMALLTALK?', 'answer': 'In SMALLTALK sind die Instanzvariablen eines Objekts nur für das Objekt selbst sichtbar, um den Zustand des Objekts zu kapseln und seine Struktur vor direktem Zugriff von außen zu schützen.'},
     {'question': 'Wie werden Zu-1-Beziehungen umgesetzt?', 'answer': 'Zu-1-Beziehungen können direkt durch benannte Instanzvariablen zwischen Objekten umgesetzt werden.'},
     {'question': 'Wie werden Zu-n-Beziehungen umgesetzt?', 'answer': 'Zu-n-Beziehungen werden meistens über Zwischenobjekte umgesetzt, deren Aufgabe es ist, mittels ihrer indizierten Instanzvariablen jeweils eine Beziehung zu mehreren anderen Objekten herzustellen.'},
     {'question': 'Wie wird der Zustand eines Objekts verändern?', 'answer': 'Die einzige Möglichkeit, den Zustand eines Objekts zu ändern, besteht darin, die Werte seiner Instanzvariablen zuzuweisen, was gleichbedeutend mit der Änderung seiner Beziehungen ist.'},
     {'question': 'Wann ist es angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen?', 'answer': 'Es ist angemessen, den Zustandsbegriff auf mehrere Objekte auszudehnen, wenn es sich um Kompositionen handelt, also um aus Teilen zusammengesetzte Ganze.'},
     {'question': 'Wie werden Protokolle in SMALLTALK spezifiziert?', 'answer': 'In SMALLTALK werden Protokolle nicht auf Objektebene, sondern auf Klassenebene spezifiziert. Dies bedeutet, dass eine Klasse ein bestimmtes Protokoll implementiert und die Objekte dieser Klasse dieses Protokoll erben. In STRONGTALK, einer Erweiterung von SMALLTALK, werden Protokolle zu Typen erhoben und ähneln Interfaces in Java.'},
     {'question': 'Wie wird ein Nachrichtenausdruck in SMALLTALK übersetzt?', 'answer': 'Ein Nachrichtenausdruck wird in SMALLTALK aus Effizienzgründen vom Compiler in einen einfachen Methodenaufruf übersetzt, der mit dem Funktionsaufruf aus der prozeduralen Programmierung vergleichbar ist.'},
     {'question': 'Wie erfolgt die Zuweisung der formalen Parameter in einer Methode?', 'answer': 'Die Zuweisung der formalen Parameter erfolgt in einer Methode durch eine implizite Zuweisung der tatsächlichen Parameter des Methodenaufrufs an die formalen Parameter der Methode.'},
     {'question': 'Wie ist die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK?', 'answer': 'Die Reihenfolge der Auswertung von geschachtelten Ausdrücken in SMALLTALK wird durch Präzedenzen und Klammern festgelegt.'},
     {'question': 'Wie werden Informationen in der objektorientierten Programmierung dargestellt?', 'answer': 'In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt. Dieses Geflecht kann navigiert und manipuliert werden.'},
     {'question': 'Wie werden Beziehungen zwischen Objekten hergestellt?', 'answer': 'Beziehungen zwischen Objekten werden über Verweise hergestellt. Durch das Verfolgen dieser Verweise kann man von einem Objekt zum nächsten "navigieren". Dabei ist zu beachten, dass diese Verknüpfung immer gerichtet ist und man nicht zwangsläufig wieder zurücknavigieren kann.'},
     {'question': 'Wie werden Variablen für Beziehungen genutzt?', 'answer': 'Variablen enthalten Verweise. Wenn jemand Zugriff auf die Variable hat, kann er auch auf das referenzierte Objekt zugreifen und ist somit mit dem Objekt verknüpft. Es fehlt nur noch, Variablen den Objekten zuzuordnen, damit nur noch die Objekte darauf zugreifen können, und schon können Beziehungen auf einfache Weise ausgedrückt werden.'},
     {'question': 'Wie wird die Ausführung einer Methode beendet?', 'answer': 'Die Ausführung einer Methode wird standardmäßig nach Abarbeitung der letzten Anweisung mit der Rückgabe des Empfängerobjekts an den Sender der Nachricht beendet. Für explizite Beendigungen und die Rückgabe eines anderen Objekts als des Empfängers ist die Return-Anweisung da.'},
     {'question': 'Wie werden Methoden in SMALLTALK gespeichert?', 'answer': 'Methoden werden in SMALLTALK nicht in Dateien gespeichert, sondern in einer Datenstruktur von SMALLTALK, nämlich in Form von Objekten. Dies bedeutet, dass der Großteil eines jeden SMALLTALK-Programms aus Methodendefinitionen besteht, die im SMALLTALK-System als Objekte gespeichert sind.'},
     {'question': 'Wann entstehen Aliase?', 'answer': 'Aliase entstehen immer bei der Zuweisung, wenn die Variable auf der linken Seite Verweissemantik hat.'},
     {'question': 'Wie werden in SMALLTALK Programmierfehler durch Aliasing verhindert?', 'answer': 'Um Programmierfehler durch Aliasing in SMALLTALK zu verhindern, werden auf Basis literaler Repräsentationen erzeugte Objekte als unveränderlich markiert. Wenn eine Zuweisung mit Wertsemantik benötigt wird, kann das Kopieren des Objekts verwendet werden.'},
     {'question': 'Wie wird die Wiederholungen (Schleifen) in SMALLTALK realisiert?', 'answer': 'In SMALLTALK wird die Implementierung von Wiederholungen (Schleifen) durch Endrekursion simuliert. Dabei wird eine Methode wie whileTrue: am Ende selbst wieder aufgerufen. Der Schleifenrumpf wird durch einen Block dargestellt, und das Abbruchkriterium wird ebenfalls in einem Block ausgewertet. Der rekursive Aufruf am Ende der Methode kann vom Compiler in eine echte Schleife übersetzt werden.'}
     ],
    [{'question': 'Was unterscheidet Literale und objekterzeugende Anweisungen?', 'answer': 'Der Compiler erzeugt bei der Übersetzung eines Literals das entsprechende Objekt im Speicher, während objekterzeugende Anweisungen erst zur Laufzeit des Programms ausgeführt werden.'},
     {'question': 'Was ist der Unterschiede zwischen globalen und lokalen Variablen?', 'answer': 'Lokale Variablen sind in ihrer Sichtbarkeit auf den Programmabschnitt beschränkt, um den es gerade geht. Globale Variablen sind auch außerhalb davon von überall her sichtbar.'},
     {'question': 'Was ist der Unterschied zwischen Statik und Dynamik in der Programmierung?', 'answer': 'In der Programmierung wird traditionell zwischen Statik und Dynamik unterschieden. Statik bezieht sich auf die statischen Strukturen eines Programms, die auf Papier oder in einem Nur-Lese-Speicher festgehalten werden können. Dynamik hingegen bezieht sich auf die Ausführung des Programms, die immer etwas Veränderliches ist. Wenn Programme selbst als Daten aufgefasst werden und sich sogar selbst verändern können, wird die Unterscheidung zwischen Statik und Dynamik nur noch bedingt nützlich. Alternativ kann man auch zwischen Struktur und Verhalten unterscheiden, wobei Struktur das Objektgeflecht und Verhalten die Folge seiner Veränderungen meint.'},
     {'question': 'Was ist der Unterschied zwischen einer internen und einer externen Iteration?', 'answer': 'Bei der internen Iteration erfolgt die Steuerstruktur für das Fortschreiten durch Elemente und die Überprüfung der Abbruchbedingung innerhalb der Sammlung, über die iteriert wird. Im Gegensatz dazu muss bei der traditionellen externen Iteration manuell eine Schleifenvariable als Index verwaltet werden.'},
     {'question': 'Was für Probleme können durch konstante Methoden auftreten?', 'answer': 'Bei der erneuten Übersetzung einer Methode mit einer konstanten Methode wird möglicherweise ein neues Objekt erzeugt, das nicht identisch mit dem zuvor zurückgegebenen Objekt ist. Dies kann zu Problemen führen, wenn das zuvor zurückgegebene Objekt in Variablen gespeichert wurde und mit dem neuen Objekt auf Identität verglichen wird.'},
     {'question': 'Warum sind Literale keine Objekte?', 'answer': 'Literale repräsentieren Objekte, sind jedoch selbst keine Objekte, da sie textuelle Spezifikationen von Objekten sind.'},
     {'question': 'Was ist der Vorteil der Kontrollstrukturen in SMALLTALK?', 'answer': 'In SMALLTALK wird es als bedeutender Vorteil angesehen, dass Programmierer neue Kontrollstrukturen einführen können, wenn sie es wünschen.'},
     {'question': 'Was unterscheidet Symbole und Strings in SMALLTALK?', 'answer': 'Symbole dürfen im Gegensatz zu Strings keine Leerzeichen enthalten. Zudem ist die Erzeugung eines Objekts anhand eines Symbolliterals technisch aufwendiger als die Erzeugung eines Objekts anhand eines String-Literals.'},
     {'question': 'Was kann bei der Verwendung von identischen Symbolliteralen passieren?', 'answer': 'Bei der Verwendung identischer Symbolliterale kann es durch sogenanntes Aliasing zu unerwarteten Ergebnissen führen.'},
     {'question': 'Was unterscheidet Gleichheit und Identität von Objekten?', 'answer': 'Gleichheit bezieht sich in der Regel auf das Erscheinungsbild oder die Bedeutung von Objekten. Identität bezieht sich darauf, ob zwei Objekte dasselbe Objekt im Speicher repräsentieren.'},
     {'question': 'Warum können syntaktisch gleiche String-Literale in SMALLTALK unterschiedliche Identitäten haben?', 'answer': 'Syntaktisch gleiche String-Literale können in SMALLTALK unterschiedliche Identitäten haben, wenn die durch die String-Literale erzeugten Objekte unabhängig voneinander veränderbar sein sollen und deswegen tatsächlich zwei Objekte sein müssen.'},
     {'question': 'Warum sind gleiche Zahlen nur manchmal identisch in SMALLTALK?', 'answer': 'In SMALLTALK werden gleiche Zahlen manchmal als identisch behandelt und manchmal nicht, abhängig von ihrer Größe und technischen Gründen.'},
     {'question': 'Was unterscheidet die Bezeichnungen "das gleiche" und "dasselbe"?', 'answer': 'In der objektorientierten Programmierung sind "das gleiche" und "dasselbe" nicht dasselbe. Zwei Objekte können gleich, aber nie dasselbe sein, oder sie sind nicht zwei Objekte, sondern eins.'},
     {'question': 'Warum ist die Identität von Objekten wichtig?', 'answer': 'Die Identität von Objekten ist wichtig, um festzustellen, ob zwei Namen oder Variablen dasselbe Objekt repräsentieren oder nicht.'},
     {'question': 'Warum haben veränderliche Objekte eine Identität?', 'answer': 'Veränderliche Objekte haben eine Identität um sie auch bei vorübergehender Gleichheit voneinander unterscheiden zu können, da sie sich hinterher wieder auseinanderentwickeln können.'},
     {'question': 'Warum haben unveränderliche Objekte eine Identität?', 'answer': 'Unveränderliche Objekte haben aus technischen Gründen eine Identität. Wenn sich ein unveränderliches Objekt aus einer Operation ergibt, dann müsste für eine Zusammenlegung gleicher Objekte zu einem immer erst überprüft werden, ob ein gleiches Objekt bereits angelegt wurde. Ganze Zahlen bis zu einer bestimmten Größe und Zeichen sind aus technischen Gründen immer auch identisch, wenn sie gleich sind.'},
     {'question': 'Warum sind atomare Objekte grundsätzlich nicht veränderbar?', 'answer': 'Atomare Objekte sind grundsätzlich nicht veränderbar, da es keinen Sinn ergibt, sie zu verändern. Zum Beispiel macht es keinen Sinn, aus einer "1" eine "2" zu machen.'},
     {'question': 'Warum können zusammengesetzte Objekte veränderbar sein?', 'answer': 'Zusammengesetzte Objekte könnten veränderbar sein, da es sinnvoll sein kann, eine Komponente durch eine andere zu ersetzen.'},
     {'question': 'Was unterscheidet Zuweisungen unter Wertsemantik und unter Verweissemantik?', 'answer': 'Bei Zuweisungen unter Wertsemantik muss eine Kopie des Objekts angefertigt werden, da die Variable das Objekt selbst speichert. Bei Zuweisungen unter Verweissemantik wird nur der Verweis auf das Objekt kopiert und in der Variable gespeichert. Dies hat Auswirkungen darauf, ob Änderungen an einem Objekt in einer Variable sich auf dasselbe Objekt in einer anderen Variable auswirken.'},
     {'question': 'Warum wurde in SMALLTALK die explizite Speicherfreigabe aufgegeben?', 'answer': 'Die explizite Speicherfreigabe wurde in SMALLTALK aufgegeben, da es schwierig ist, genau zu verfolgen, welche Objekte noch referenziert werden, insbesondere in großen und komplexen Programmen. Die Verantwortung dafür den Anwendungsprogrammierern zu überlassen, würde zu vielen potenziellen Programmierfehlern führen.'},
     {'question': 'Warum ist der Begriff "Lebenszyklus" eines Objekts irreführend?', 'answer': 'Der Begriff "Lebenszyklus" würde implizieren, dass das Objekt nach seinem Ende wiederverwendet wird, was nicht der Fall ist. Objekte werden nicht recycelt, sondern nur der von ihnen belegte Speicherplatz wird möglicherweise wiederverwendet.'},
     {'question': 'Was passiert nach einer Methode in SMALLTALK?', 'answer': 'Bei der Rückkehr nach der Abarbeitung einer Methode in SMALLTALK wird das Ergebnis der Methode (eine Referenz auf) ein Objekt geliefert, das dann an der Stelle des Nachrichtenausdrucks, der den Methodenaufruf bewirkt hat, eingesetzt wird. Dies ermöglicht die Weiterverarbeitung des Ergebnisses im Kontext des aufrufenden Objekts.'},
     {'question': 'Ist es in SMALLTALK möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben?', 'answer': 'In SMALLTALK ist es nicht möglich, auf einen Nachrichtenversand keine Antwort zurückzugeben, da jeder Nachrichtenversand ein Ergebnis zurückgibt. Dies ermöglicht es, Nachrichtenausdrücke einfach zu verketten und unterstützt ein sogenanntes Fluent API (fließende Programmierung).'},
     {'question': 'Was unterscheidet ein Objekt und ein Wert?', 'answer': 'Objekte haben eine eindeutige Identität und sind an einer bestimmten Stelle im Speicher abgelegt, während Werte an verschiedenen Stellen im Speicher vorkommen können und keine Identität haben.'},
     {'question': 'Warum haben Objekte im Speicher eine konstante Größe?', 'answer': 'Objekte im Speicher haben eine feste Größe, die aus technischen Gründen nicht verändert werden kann. Wenn ein Objekt mehr Platz benötigt oder verkleinert werden muss, muss ein neues Objekt erzeugt werden, das an die Stelle des alten tritt. Dieses neue Objekt hat jedoch eine andere Identität.'},
     {'question': 'Warum werden Pseudovariablen als solche bezeichnet?', 'answer': 'Sie werden als Pseudovariablen bezeichnet, da sie ihren Wert entweder nicht ändern können oder ihren Wert vom System erhalten.'},
     {'question': 'Warum ist die Zuweisung für Pseudovariablen in SMALLTALK nicht zulässig?', 'answer': 'Die Zuweisung für Pseudovariablen ist in SMALLTALK nicht zulässig, da sie auf Objekte von spezifischer Bedeutung verweisen und diese Bedeutung nicht verändert werden sollte.'},
     {'question': 'Was unterscheidet Verweissemantik und Wertsemantik bei Variablen?', 'answer': 'Unter Wertsemantik können zwei Variablen niemals dasselbe Objekt bezeichnen, während Verweissemantik erlaubt, dass mehrere Variablen auf dasselbe Objekt verweisen.'},
     {'question': 'Warum wird in der objektorientierten Programmierung häufig Verweissemantik verwendet?', 'answer': 'Verweissemantik wird in der objektorientierten Programmierung häufig verwendet, da sie einen speicher- und recheneffizienten Umgang mit Objekten ermöglicht und unterschiedliche Objekte unterschiedlich viel Speicherplatz belegen.'},
     {'question': 'Haben Variablen in der objektorientierten Programmierung Wert- oder Verweissemantik?', 'answer': 'In manchen Sprachen haben Variablen, die Objekte aufnehmen, stets Verweissemantik, und Variablen, die Werte aufnehmen, stets Wertsemantik, z. B. Java. Andere objektorientierte Sprachen erlauben der Programmiererin, für jede Variable getrennt festzulegen, ob sie Wert- oder Verweissemantik haben soll, z. B. C++ und EIFFEL.'},
     {'question': 'Warum können Continuations zu Laufzeitfehlern führen?', 'answer': 'Continuations können zu Laufzeitfehlern führen, insbesondere wenn versucht wird, von einer Methode zurückzukehren, die bereits beendet wurde. Return-Anweisungen in Blöcken sind daher ein umstrittenes Konzept.'},
     {'question': 'Was unterscheidet das Geheimnisprinzip und die Kapselung?', 'answer': 'Der Unterschied besteht darin, dass das Geheimnisprinzip sich auf das Verbergen von Implementationsdetails und Struktur bezieht, während die Kapselung sich auf das Verbergen und die Kontrolle des Zustands eines Objekts bezieht.'},
     {'question': 'Warum kann ein Objekt seinen inneren Aufbau nicht kapseln?', 'answer': 'Ein Objekt kann seinen inneren Aufbau nicht vollständig vor der Außenwelt abkapseln, da aufgrund der möglichen Existenz von Aliasen andere Objekte diese Objekte kennen und ohne sein Wissen manipulieren können. Die Abschottung erfordert spezielle Vorkehrungen, die derzeit nicht in gängige objektorientierte Programmiersprachen integriert sind und explizit programmiert werden müssen.'},
     {'question': 'Was unterscheidet eine benannte Instanzvariable und eine indizierte Instanzvariable in SMALLTALK?', 'answer': 'In SMALLTALK können benannte Instanzvariablen direkt über ihren Namen zugegriffen werden, während indizierte Instanzvariablen nur über die vordefinierten Nachrichten "at:" und "at:put:" gelesen und geschrieben werden können. Der Zugriff auf indizierte Instanzvariablen erfolgt nicht über Zugriffsmethoden, sondern über diese Nachrichten.'},
     {'question': 'Warum werden Zu-n-Beziehungen über Zwischenobjekte umgesetzt?', 'answer': 'Zu-n-Beziehungen werden über Zwischenobjekte umgesetzt, da die indizierten Instanzvariablen eines Objekts nicht benannt sind und daher nicht zwischen verschiedenen Zu-n-Beziehungen unterschieden werden kann'},
     {'question': 'Warum ist die Zuordnung von Methoden zu Objekten wichtig?', 'answer': 'Die Zuordnung von Methoden zu Objekten ermöglicht es den Methoden, auf die Instanzvariablen des jeweiligen Objekts zuzugreifen und somit das Verhalten des Objekts zu spezifizieren und zu beeinflussen.'},
     {'question': 'Warum ist die Teil-Ganzes-Beziehung kompliziert?', 'answer': 'Die Definition der Teil-Ganzes-Beziehung ist komplex, da es verschiedene Arten von Beziehungen zwischen einem Ganzen und seinen Teilen gibt, die je nach Art der Zusammensetzung unterschiedliche Wechselwirkungen aufweisen. Es existieren sowohl physische als auch logische Teil-Ganzes-Beziehungen, und diese Vielfalt macht es schwer, eine klare und einheitliche Definition zu finden.'},
     {'question': 'Was bieten objektorientierte Programmiersprachen für die Teil-Ganzes-Beziehung?', 'answer': 'Die meisten objektorientierten Programmiersprachen bieten keine speziellen Sprachkonstrukte für die Teil-Ganzes-Beziehung. Stattdessen können Programmierer die Unterscheidung zwischen Instanzvariablen mit Referenz- und Wertsemantik nutzen, um eine bestimmte Form der Teil-Ganzes-Beziehung darzustellen. Bei Wertsemantik werden beim Entfernen eines Objekts aus dem Speicher auch alle Objekte, die als Werte seiner Instanzvariablen dienen, aus dem Speicher entfernt.'},
     {'question': 'Warum ist die Teil-Ganzes-Beziehung in der objektorientierten Programmierung von Bedeutung?', 'answer': 'Die Teil-Ganzes-Beziehung ist in der objektorientierten Programmierung wichtig, da sie es ermöglicht, komplexe Software-Systeme aus Teilen aufzubauen, wobei jeder Teil seine eigene interne Struktur kapselt. Dies hilft dabei, sicherzustellen, dass keine Aliasnamen für Teile existieren und Änderungen an einem Teil nicht unabsichtlich andere Teile beeinflussen. Dieses Konzept ist entscheidend für die Entwicklung komplexer und intakter Software-Systeme.'},
     {'question': 'Was unterscheidet veränderliche und unveränderliche Objekte?', 'answer': 'Veränderliche Objekte können ihren Zustand im Laufe der Zeit ändern, während unveränderliche Objekte keinen Zustand haben und ihre Werte konstant bleiben.'},
     {'question': 'Was unterscheidet Attribute und Beziehungen?', 'answer': 'Die Unterscheidung zwischen Attributen und Beziehungen kann in Ermangelung spezieller Schlüsselwörter allenfalls über die Unterscheidung zwischen Variablen mit Wert- und Variablen mit Referenzsemantik erfolgen. Diese ist jedoch in einigen Programmiersprachen nicht immer eindeutig ist und beispielsweise in Java gar nicht zutreffend.'},
     {'question': 'Warum ändert sich der Zustand eines Objekts nur über seine Instanzvariablen?', 'answer': 'Wenn Änderungen am Zustand eines Objekts, auf das ein anderes Objekt per Instanzvariable verweist, als Änderung des Zustands des ersten Objekts betrachtet würden, könnte jede Änderung an einem Objekt zu einer Kettenreaktion führen, da der Zustand aller Objekte, die darauf verweisen, sich ändern würde. Dies entspricht nicht unserem üblichen Verständnis von Zustand.'},
     {'question': 'Warum ist der Zustandsbegriff nicht auf mehrere Objekte im Allgemeinen ausgedehnt?', 'answer': 'Der Zustandsbegriff kann nicht auf mehrere Objekte im Allgemeinen ausgedehnt werden, da dies zu komplexen Problemen führen würde und das objektorientierte Modell nicht ohne Herausforderungen ist. Programmierfehler könnten in vermeintlich simplen Situationen auftreten.'},
     {'question': 'Warum werden konstante Methoden verwendet?', 'answer': 'Konstante Methoden werden verwendet, um sicherzustellen, dass bestimmte Literale in einem Programm konsistent sind und immer auf dasselbe Objekt verweisen. Dies ist wichtig, um Probleme im Zusammenhang mit Objektidentität und Vergleichen zu vermeiden.'},
     {'question': 'Warum hängt das Verhalten eines Objekts von seinem Zustand ab?', 'answer': 'Das Verhalten eines Objekts hängt in der Regel von seinem Zustand ab, weil der Zustand eines Objekts die Informationen enthält, die benötigt werden, um die richtigen Entscheidungen zu treffen und die entsprechenden Aktionen auszuführen. Das Verhalten eines Objekts basiert auf den Daten in seinem Zustand, und diese Daten beeinflussen, wie das Objekt auf Nachrichten reagiert.'},
     {'question': 'Was unterscheidet Protokoll und Implementierung in SMALLTALK?', 'answer': 'Das Protokoll beschreibt das Interface eines Objekts und umfasst die Methodensignaturen und dazugehörigen Kommentare. Die Implementierung hingegen besteht aus den tatsächlichen Methodenrümpfen und den Instanzvariablen, die das Implementationsgeheimnis eines Objekts bilden. Das Protokoll dient dazu, das Verhalten eines Objekts zu beschreiben, während die Implementierung die Details der Umsetzung enthält.'},
     {'question': 'Von welchem Objekt hängt die Auswahl der aufzurufenden Methode ab?', 'answer': 'Die Auswahl der Methode, die aufgerufen wird, hängt nicht nur vom Nachrichtenselektor allein ab, sondern auch vom Objekt, an das die Nachricht geschickt wird. Verschiedene Objekte mit gleichen Methodensignaturen können unterschiedliche Methodenimplementierungen haben.'},
     {'question': 'Was passiert, wenn ein Methodenaufruf in SMALLTALK ins Leere läuft?', 'answer': 'Wenn ein Methodenaufruf ins Leere läuft, wird er in einen Aufruf der Methode "doesNotUnderstand:" des ursprünglichen Empfängers umgewandelt. Diese Methode reagiert standardmäßig mit einer Fehlermeldung, die besagt, dass das Objekt die Nachricht nicht versteht. Diese Standardreaktion kann jedoch geändert werden, um auf Fehlermeldungen anders zu reagieren.'},
     {'question': 'Warum reichen Literale zum Programmieren nicht aus?', 'answer': 'Literale reichen zum Programmieren nicht aus, weil sie immer die gleichen Objekte repräsentieren.'},
     {'question': 'Warum gibt es Variablen?', 'answer': 'Variablen sind notwendig, weil Literale immer die gleichen Objekte repräsentieren, weshalb sie zum Programmieren nicht ausreichen.'},
     {'question': 'Was unterscheidet Variablen und Literale?', 'answer': 'Anders als bei Literalen wird aus einer Variable kein Objekt erzeugt, sie ist lediglich ein Name für ein bereits existierendes Objekt.'},
     {'question': 'In welcher Reihenfolge werden Ausdrücke in SMALLTALK ausgewertet?', 'answer': 'In SMALLTALK werden Ausdrücke normalerweise von links nach rechts ausgewertet.'},
     {'question': 'Warum stehen Objekte in Beziehung zueinander?', 'answer': 'Objekte stehen in Beziehung zueinander, um Bedeutung zu erlangen. Die meisten Objekte in einem System werden erst durch ihre Beziehungen zu anderen Objekten nützlich.'},
     {'question': 'Was unterscheidet eine Methodensignatur und einen Nachrichtenselektor?', 'answer': 'Die Methodensignatur ist das Gegenstück zum Nachrichtenselektor.'},
     {'question': 'Warum kann Aliasing erwünscht sein?', 'answer': 'Aliasing ist zunächst erwünscht, da es die Effizienz der Informationsverarbeitung erhöht. Es ermöglicht das Teilen von Objekten ohne Kopieren.'},
     {'question': 'Was sind die Vorteile einer Garbage Collection?', 'answer': 'Die Garbage Collection verhindert vorzeitige Entfernung von Objekten, die noch in Verwendung sind, und stellt sicher, dass Variablen auf gültige Objekte verweisen. Dies trägt zur Stabilität und Sicherheit von Programmen bei.'},
     {'question': 'Warum kann Aliasing zu Programmierfehlern führen?', 'answer': 'Aliasing kann zu Programmierfehlern führen, weil Änderungen an einem Objekt, das durch eine Variable bezeichnet wird, sich auf alle Aliase dieses Objekts auswirken. Unerwartete Veränderungen an einem Alias können schwer zu erkennen und zu debuggen sein.'}
     ],
]
KE2_questions = [
    [{'question': 'Was ist eine Metaklasse in der Programmierung?', 'answer': 'Eine Metaklasse ist eine Klasse, die für die Erstellung von Klassen verantwortlich ist. Sie ist eine Klasse der Klassen und ermöglicht es, die Verhaltensweisen von Klassen zu ändern oder zu erweitern.'},
     {'question': 'Was ist die Aufgabe von Metaklassen in der Programmierung?', 'answer': 'Metaklassen sind eine Ebene oberhalb von Klassen und werden verwendet, um die Verhaltensweisen von Klassen zu definieren. Sie können auch geändert werden, um die Erstellung von Klassen zu ändern, wie zum Beispiel das automatische Generieren von Zugriffsmethoden für alle benannten Instanzvariablen einer Klasse.'},
     {'question': 'Was ist eine Metaklasse in Smalltalk?', 'answer': 'In Smalltalk ist eine Metaklasse eine Klasse, die dazu dient, andere Klassen zu definieren und zu erstellen.'},
     {'question': 'Was sind Metaklassen in SMALLTALK?', 'answer': 'Metaklassen sind Klassen, die Klassen erstellen. In SMALLTALK erstellt die Programmiersprache automatisch Metaklassen, die für den Programmierer nicht sichtbar sind, außer durch die Unterscheidung zwischen Instanz- und Klassenvariablen bzw. -methoden im Klassenbrowser.'},
     {'question': 'Was ist die Klasse SortedCollection in Smalltalk?', 'answer': 'SortedCollection ist eine Subklasse von OrderedCollection, die die Elemente in einer bestimmten Reihenfolge hält, die durch eine Qualität der eingefügten Objekte bestimmt wird. Die Elemente müssen vergleichbar sein, d.h. die (binäre) Methode <= muss darauf definiert sein.'},
     {'question': 'Was ist der Zweck von Konvertierungsmethoden in Collection?', 'answer': 'Der Zweck von Konvertierungsmethoden in Collection ist es, eine Menge von Objekten aus einer Collection in eine andere zu übertragen, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, wie z.B. das Entfernen doppelter Elemente bei der Konvertierung in eine Menge (asSet) oder das Sortieren der Elemente bei der Konvertierung in eine sortierte Collection (asSortedCollection).'},
     {'question': 'Was ist Klonen oder Kopieren?', 'answer': 'Klonen oder Kopieren ist eine Methode, um neue Instanzen von Klassen zu erzeugen, bei der ein bestehendes Objekt kopiert wird, um eine exakte Kopie des Objekts zu erstellen, die eigenständig und nicht mit dem Original verbunden ist. Es gibt zwei Arten von Kopien: Shallow Copy und Deep Copy.'},
     {'question': 'Was ist die Rolle der Klasse "Class" in Smalltalk?', 'answer': 'Die Klasse "Class" ist in Smalltalk die Superklasse aller Metaklassen. Jede Instanz dieser Klasse ist eine Klasse. Die Klasse von Class ist Class class und erst Class class eine Metaklasse.'},
     {'question': 'Was ist der Klassenansatz in der objektorientierten Programmierung?', 'answer': 'Der Klassenansatz ist ein Ansatz in der objektorientierten Programmierung, bei dem alle Objekte als Instanzen von bestimmten Vorlagen, die entweder selbst keine Objekte oder Objekte auf einer anderen Ebene sind, erzeugt werden. Diese Vorlagen werden als Klassen bezeichnet.'},
     {'question': 'Was ist der Prototypenansatz in der objektorientierten Programmierung?', 'answer': 'Der Prototypenansatz ist ein Ansatz in der objektorientierten Programmierung, bei dem ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont wird. Ein Klon kann bei Bedarf um weitere Instanzvariablen und Methoden ergänzt werden oder geklonte können abgeändert oder entfernt werden.'},
     {'question': 'Mit welchen drei Ansätzen lassen sich Objekte erzeugen?', 'answer': 'Die drei Varianten der Objektorientierung sind der Konstruktoransatz, der Prototypenansatz und der Klassenansatz. Die klassenbasierte Form der Objektorientierung hat sich gegenüber der prototypenbasierten Form weitgehend durchgesetzt, da Klassen sich als (Vorlagen für) Typen eignen und somit die objektorientierte Programmierung Eigenschaften anderer, nicht objektorientierter, dafür aber typisierter Sprachen übernehmen kann. Die prototypenbasierte Form der Objektorientierung hat hingegen den Charme, dass sie mit weniger Konzepten auskommt und dass sie sehr viel flexibler einzelne Objekte an ihren jeweiligen Zweck anpassen kann.'},
     {'question': 'Welche praktische Bedeutung haben Metaklassen für die Programmierung in SMALLTALK?', 'answer': 'Metaklassen haben in SMALLTALK die praktische Bedeutung, dass sie die Definition von Klassen steuern und die Struktur des Programms beeinflussen. Sie ermöglichen es, Klassen dynamisch zu erzeugen und zu verändern. Zum Beispiel können Sie an der Ebene der Metaklassen Methoden hinzufügen, um das Verhalten von Klassen zu ändern, ohne die Klassen selbst zu ändern.'},
     {'question': 'Was ist die einfachste Form des Kopierens eines Objekts in SMALLTALK?', 'answer': 'Die einfachste Form des Kopierens eines Objekts in SMALLTALK ist das Erzeugen eines Objekts derselben Klasse mit denselben Variablenbelegungen. Dies wird durch die Methode "shallowCopy" ermöglicht.'},
     {'question': 'Welche Programmiersprachen nutzen den Klassenansatz?', 'answer': 'Der Klassenansatz wird in Sprachen wie SMALLTALK, C++, EIFFEL, Java, C-Sharp, SCALA und vielen anderen mehr angewendet.'},
     {'question': 'Was sind Konstruktoren in SMALLTALK?', 'answer': 'In SMALLTALK sind Konstruktoren Methoden, die, wenn sie auf einer Klasse aufgerufen werden, eine neue Instanz dieser Klasse erstellen und zurückgeben. Sie sind Klassenmethoden, die dazu dienen, neue Objekte zu erzeugen.'},
     {'question': 'Welche Rolle spielen Ein- und Ausgabeströme in der objektorientierten Programmierung?', 'answer': 'Ein- und Ausgabeströme spielen in der objektorientierten Programmierung eine wichtige Rolle, da sie den Zugriff auf Eingabe- und Ausgabedaten im System ermöglichen. Sie dienen dazu, Daten sowohl von/zu Benutzern als auch von/zu Dateisystemen zu lesen und zu schreiben.'},
     {'question': 'Was sind die Unterschiede zwischen lesbarbaren und schreibbaren Streams?', 'answer': 'Lesbare Streams ermöglichen das Lesen von Daten aus einer Quelle, während schreibbare Streams das Schreiben von Daten in eine Zielquelle ermöglichen. Lesbare Streams bieten Methoden zum Lesen von Daten, während schreibbare Streams Methoden zum Schreiben von Daten bereitstellen.'},
     {'question': 'Welche Informationen können in einer Metaklasse definiert werden?', 'answer': 'In einer Metaklasse können Informationen wie Instanzvariablen und Methoden für die zugehörige Klasse definiert werden. Dies ermöglicht es, das Verhalten und die Eigenschaften der Klasse individuell anzupassen.'},
     {'question': 'Welche Bedeutung hat die Generalisierung in der objektorientierten Programmierung?', 'answer': 'Die Generalisierung ermöglicht es, mehrere Klassen, deren Definitionen inhaltlich verwandt sind, zu abstrahieren und zusammenzufassen. Dies führt zur Bildung einer Generalisierungsklasse, die die gemeinsamen Eigenschaften (Instanzvariablen und Methoden) der generalisierten Klassen enthält. Die Generalisierung erlaubt es, Gemeinsamkeiten zwischen Klassen auf höherer Abstraktionsebene darzustellen und die Wiederverwendung von Code zu fördern.'},
     {'question': 'Was ist eine Klassendefinition?', 'answer': 'Eine Klassendefinition liefert die Intension oder Beschreibung einer Klasse. Sie besteht aus dem Namen der Klasse, der Liste der benannten Instanzvariablen, Angaben zu indizierten Instanzvariablen, Informationen zur Atomarität, und einer Liste von Instanzmethoden.'},
     {'question': 'Was sind Instanzen einer Klasse?', 'answer': 'Eine Instanz der Klasse ist das Objekt, das zur Extension der Klasse gehört. Jede Instanz belegt den Satz an Instanzvariablen individuell. Alle Instanzen einer Klasse verstehen dieselben Nachrichten und verwenden dieselben Methodendefinitionen, um auf die Nachrichten zu reagieren.'},
     {'question': 'Was sind indizierte Instanzvariablen?', 'answer': 'Indizierten Instanzvariablen enthalten binäre Repräsentationen.'},
     {'question': 'Was sind globale Pseudovariablen in SMALLTALK?', 'answer': 'In SMALLTALK wird jede Klasse nach ihrer Erzeugung durch eine globale Pseudovariable repräsentiert, deren Name dem Namen der Klasse entspricht. Diese globale Pseudovariable ist notwendig, um auf die Klasse und ihre Methoden zugreifen zu können. Klassennamen sind global und von überall aus im Code zugreifbar.'},
     {'question': 'Welche beiden Rollen gibt es in einer Subklassenbeziehung?', 'answer': 'Die beiden Enden der Subklassenbeziehung haben die Rollen "Superklasse" und "Subklasse". Diese Rollen legen nahe, dass die Subklassenbeziehung eine Hierarchie von Klassen aufbaut, in der die Superklassen über den Subklassen stehen. Die Superklasse ist die allgemeinere Klasse, von der die Subklasse erbt, während die Subklasse die speziellere Klasse ist, die die Eigenschaften der Superklasse erbt und möglicherweise erweitert oder anpasst.'},
     {'question': 'Was ist das Konzept der offenen Rekursion in SMALLTALK?', 'answer': 'Das Konzept der offenen Rekursion in SMALLTALK bedeutet, dass die Methode, die durch eine Nachricht an self aufgerufen wird, nicht zwangsläufig die in derselben Klasse definierte Methode ist. Stattdessen kann die passende Methode in einer Subklasse gefunden werden, wenn die aufrufende Methode selbst erst im Rahmen der Suche in der Kette der Superklassen gefunden wurde. Dies kann zu überraschenden Ergebnissen führen, wenn nicht erwartet wird, dass die Methode in einer Subklasse überschrieben wurde.'},
     {'question': 'Welche Ebenen gibt es in SMALLTALK im Zusammenhang mit Klassen und Instanzen?', 'answer': 'In SMALLTALK gibt es mehrere Ebenen im Zusammenhang mit Klassen und Instanzen: Ebene 0: Konkrete Objekte, die nicht instanziierbar sind und Dinge aus dem Anwendungsbereich eines Programms repräsentieren. Ebene 1: Klassen, die die Definition (Instanzvariablen und -methoden) dieser Objekte liefern und anhand derer die Objekte auf Ebene 0 durch Instanziierung erstellt werden. Ebene 2: Metaklassen, die die Klassen auf Ebene 1 definieren. Jede Metaklasse hat genau eine Instanz. Ebene 3: Die Klasse "Metaclass", von der alle Metaklassen Instanzen sind.'},
     {'question': 'Was ist ein Beispiel für eine instanziierbare Collection-Klasse in SMALLTALK?', 'answer': 'Einige Beispiele für spezielle, instanziierbare (konkrete) Collection-Klassen in SMALLTALK sind: Set: Diese Klasse wird verwendet, um ungeordnete Collections darzustellen, in denen jedes Element höchstens einmal vorkommen darf, was einer Menge entspricht. Bag: Bag wird verwendet, um ungeordnete Collections darzustellen, in denen die Einschränkung aufgehoben ist, dass Elemente nur einmal vorkommen dürfen. In einer Bag können Elemente mehrmals vorhanden sein. SequenceableCollection oder IndexedCollection: Diese Klassen repräsentieren geordnete Collections, bei denen das i-te Element eindeutig bestimmt ist. Sie implementieren die Methoden "at:" und "at:put:", um auf Elemente zuzugreifen oder Elemente an einer bestimmten Position einzufügen oder zu ändern. Dictionary: Diese Klasse repräsentiert eine ungeordnete Collection, bei der jedes Element unter einem Schlüssel gespeichert wird. Die Methoden "at:" und "at:put:" werden verwendet, um auf die Elemente zuzugreifen oder sie zu ändern. Dabei können Schlüssel Objekte verschiedener Klassen sein, nicht nur Integer.'},
     {'question': 'Welche Gemeinsamkeiten haben die Klassen "Set" und "Bag" in SMALLTALK?', 'answer': 'Die Gemeinsamkeit zwischen den Klassen "Set" und "Bag" besteht darin, dass beide ungeordnete Collections repräsentieren. In diesen Collections darf jedes Element höchstens einmal vorkommen. Sie unterscheiden sich jedoch darin, dass in einem Set die Elemente eindeutig sind und keine Duplikate enthalten, während in einer Bag Elemente mehrmals vorhanden sein können.'},
     {'question': 'Was ist Spezialisierung in der objektorientierten Programmierung?', 'answer': 'Spezialisierung ist das Gegenteil von Generalisierung in der objektorientierten Programmierung. Während bei der Generalisierung Eigenschaften weggelassen oder verallgemeinert werden, fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene Eigenschaften von Klassen. Es bedeutet, dass eine Klasse eine Spezialisierung ihrer Generalisierungen sein kann, wenn sie zusätzliche Merkmale oder Verhaltensweisen hinzufügt.'},
     {'question': 'Was ist Instanziierung?', 'answer': 'Instanziierung ist der Prozess, bei dem ein neues Objekt einer bestimmten Klasse erstellt wird. Das neue Objekt wird eine Instanz dieser Klasse genannt und hat die Eigenschaften (Instanzvariablen und Methoden), die durch die Definition (Intension) der Klasse festgelegt sind.'},
     {'question': 'Welche Alternative gibt es zur Instanziierung?', 'answer': 'Eine Alternative zur Instanziierung ist das Klonen.'},
     {'question': 'Was ist das Klonen?', 'answer': 'Das Klone ist ein Prozess, bei dem ein neues Objekt auf der Basis eines bereits existierenden Objekts erstellt wird. Der Klon ist eine Kopie des Originalobjekts. Beim Klonen muss festgelegt werden, wie tief die Kopie gehen soll, dh ob nur das Objekt oder auch seine Attributobjekte und die, zu denen es in Beziehung steht, kopiert werden sollen. Während das Klonen in klassenbasierten objektorientierten Programmiersprachen in der Regel durch Instanziierung und Übertragung von Inhaltsdaten der Instanzvariablen erzeugt wird, erfolgt das Klonen in prototypenbasierten objektorientierten Programmiersprachen, die das Konzept der Klasse nicht kennen, durch einfaches Kopieren. In SMALLTALK wird die Instanziierung normalerweise bevorzugt, da es sich um eine klassenbasierte Sprache handelt.'},
     {'question': 'Welche Bedingungen müssen erfüllt sein, damit eine Subklassenbeziehung zwischen zwei Klassen in SMALLTALK zulässig ist?', 'answer': 'Damit eine Subklassenbeziehung zwischen zwei Klassen in SMALLTALK zulässig ist, müssen deren Definitionen bestimmte Bedingungen erfüllen: Benannte Instanz- und Klassenvariablen dürfen nicht dieselben Namen haben wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Wenn die Superklasse indizierte Instanzvariablen hat, müssen diese auch in der Subklasse vorhanden sein. Methodendefinitionen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden.'},
     {'question': 'Was sind Factory-Methoden?', 'answer': 'Factory-Methoden sind spezielle Klassenmethoden, die ähnlich wie Konstruktoren neue Instanzen erstellen. Allerdings können sie die Klasse der Instanz basierend auf anderen Faktoren als nur der Klasse, zu der die Methode gehört, festlegen.'},
     {'question': 'Welches Prinzip geht der Vererbung voraus?', 'answer': 'Die Prinzipien von Generalisierung und Spezialisierung gehen der Vererbung voraus. Generalisierung und Spezialisierung sind eng mit der Vererbung verbunden, da Vererbung oft verwendet wird, um diese Prinzipien umzusetzen. Generalisierung ist die Bildung von allgemeineren Klassen aus spezifischeren Klassen, während Spezialisierung die Bildung spezifischerer Klassen aus allgemeineren Klassen ist.'},
     {'question': 'Was ist eine Klassifikation?', 'answer': 'Eine Klassifikation ist eine Zuordnung von Individuen oder Objekten zu bestimmten Allgemeinbegriffen oder Klassen. Diese Klassifikation ermöglicht eine Strukturierung der Anwendungsdomäne, indem bestimmte Aussagen und Eigenschaften nur noch für die Klassen im Allgemeinen getroffen werden müssen, anstatt für jedes einzelne Objekt. Statt also Eigenschaften und Methoden direkt Objekten zuzuweisen, verbindet man sie mit Klassen und legt fest, dass sie die einzelnen Objekte, die zu dieser Klasse gehören, beschreiben.'},
     {'question': 'Was ist die Extension?', 'answer': 'Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören.'},
     {'question': 'Was ist die Intension?', 'answer': 'Die Intension ist die Summe der Merkmale oder Eigenschaften, die den Begriff ausmachen und die Objekte charakterisieren, die zu dieser Klasse gehören. Die Intension ist gewissermaßen das Auswahlprädikat oder die charakteristische Funktion, die entscheidet, ob ein beliebiges Element unter den Begriff fällt.'},
     {'question': 'Was sind abstrakte Klassen?', 'answer': 'Abstrakte Klassen in der objektorientierten Programmierung sind Klassen, die selbst keine Instanzen haben und daher nicht instanziierbar sind. Sie werden oft verwendet, um gemeinsame Eigenschaften und Methoden für ihre Subklassen bereitzustellen, aber sie sind in der Regel unvollständig definiert und können zu Laufzeitfehlern führen, wenn sie direkt instanziiert werden.'},
     {'question': 'Welche Art von Methoden bietet die Klasse "Object" den Objekten an?', 'answer': 'Die Klasse "Object" bietet eine Vielzahl von Methoden an, die grundlegende Typtests und andere gemeinsame Operationen für Objekte ermöglichen. Dazu gehören Methoden wie isNil, notNil, isInteger, isFloat und viele andere. Diese Methoden erlauben es, Eigenschaften von Objekten abzufragen und deren Typ zu überprüfen.'},
     {'question': 'Welche Rolle spielen Zwischenobjekte in der Umsetzung von Zu-n-Beziehungen?', 'answer': 'Zwischenobjekte spielen eine Rolle in der Umsetzung von Zu-n-Beziehungen. Sie ermöglichen es, solche Beziehungen indirekt über ihre indizierten Instanzvariablen herzustellen.'},
     {'question': 'Was ist die Aufgabe von Streams in SMALLTALK?', 'answer': 'In SMALLTALK erlauben Streams einen sequentiellen Zugriff auf einzelne Elemente in beliebigen zeitlichen Abständen und den gleichzeitigen bzw. zeitlich abwechselnden Zugriff auf (die Elemente einer) Collection durch mehrere andere Objekte.'},
     {'question': 'Was ist die Funktion von Streams in einer Collection?', 'answer': 'Die Funktion von Streams in einer Collection ist es, Positionszeiger in die Collection hineinzuliefern.'},
     {'question': 'Was ist der Zweck von Klassen in SMALLTALK?', 'answer': 'In SMALLTALK hat jede Klasse Instanz ihre eigenen Instanzvariablen und Methoden, die nur für sie angelegt werden können. Dies ermöglicht eine Programmierpraxis, bei der jede Klasse ihre eigenen Instanzvariablen und Methoden besitzt und die Programmiererin diese frei bestimmen kann, ohne dabei an andere Klassen denken zu müssen.'},
     {'question': 'Was ist eine Instanz?', 'answer': 'Eine Instanz ist ein konkretes Exemplar einer Klasse.'},
     {'question': 'Was ist eine explizite Zuweisung?', 'answer': 'Eine explizite Zuweisung ist eine Zuweisung, die durch den Zuweisungsoperator vorgenommen wird.'},
     {'question': 'Was ist eine implizite Zuweisung?', 'answer': 'Eine implizite Zuweisung ist eine Zuweisung, die bei Methodenaufrufen vorgenommen wird.'},
     {'question': 'Was ist die Beziehung zwischen Klassen und Metaklassen in Smalltalk?', 'answer': 'In Smalltalk besteht eine 1-zu-1-Beziehung zwischen Klassen und Metaklassen, die nicht getrennt voneinander definiert werden, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt über Abschnitte für die Deklaration der Instanzvariablen, Definition der Methoden, Angabe der Klassenvariablen und -methoden.'},
     {'question': 'Was sind Klassenvariablen und Klassenmethoden?', 'answer': 'Klassenvariablen und Klassenmethoden sind Variablen und Methoden, die allen Instanzen einer Klasse gemeinsam sind. Klassenvariablen werden mit einem Doppelpunkt und dem Klassennamen deklariert, Klassenmethoden mit einem Pluszeichen und dem Klassennamen. Sie können von allen Instanzen der Klasse aus aufgerufen werden. Ein Beispiel für eine Klassenvariable ist "Dependents Fields" in der Klasse "Object", eins für eine Klassenmethode ist "pi" in der Klasse "Float".'},
     {'question': 'Was ist eine Klassenvariable?', 'answer': 'Eine Klassenvariable ist eine Variable, die einer Klasse gehört und allen Instanzen dieser Klasse gemeinsam ist. In diesem Fall gehört die Klassenvariable "Pi" der Klasse "Float" und ist allen Instanzen dieser Klasse zugeordnet.'},
     {'question': 'Was ist ein Rollback?', 'answer': 'Ein Rollback ist eine Möglichkeit, den ursprünglichen Zustand eines Objekts oder Objektgeflechts wiederherzustellen, indem eine Kopie des Objekts vor der Durchführung einer Menge von Änderungen angelegt und das ursprüngliche Objekt durch die Kopie ersetzt wird.'},
     {'question': 'Was ist die Funktion von Generalisierungen in der objektorientierten Programmierung?', 'answer': 'Die Funktion von Generalisierungen in der objektorientierten Programmierung ist es, Eigenschaften zu definieren, die automatisch auch für alle Klassen gelten, von denen die Generalisierung abstrahiert. Diese Klassen müssen dann nur noch die Unterschiede definieren, die sie von der Generalisierung und voneinander unterscheiden.'},
     {'question': 'Was ist die Aufgabe der Klassen, die von einer Generalisierung abstrahiert?', 'answer': 'Die Aufgabe der Klassen, die von einer Generalisierung abstrahiert, ist es, nur noch die Unterschiede zu definieren, die sie von der Generalisierung und voneinander unterscheiden. Sie müssen nicht die Eigenschaften wiederholen, die der Generalisierung zugeordnet sind, da diese per Definition automatisch auch für sie gelten.'},
     {'question': 'Was sind Genera in der objektorientierten Programmierung?', 'answer': 'Genera sind in der objektorientierten Praxis Generalisierungen, die keine eigenen, direkten Instanzen haben, sondern als abstrakte Objekte fungieren, die von konkreteren Klassen geerbt werden.'},
     {'question': 'Was ist der Unterschied zwischen direkten und indirekten Instanzen?', 'answer': 'Direkte Instanzen sind Elemente der Extension einer Klasse, während indirekte Instanzen Elemente der Extension einer Unterklasse sind, die nicht direkt der Oberklasse zugeordnet ist.'},
     {'question': 'Was ist Generalisierung bei Attributen?', 'answer': 'Bei der Generalisierung von Attributen wird ihr Wertebereich von einem spezielleren (kleineren) zu einem allgemeineren (größeren) erweitert. Zum Beispiel würde das Attribut "Aufenthaltsort" bei der Generalisierung von Mensch zu Zweibeiner von Punkten auf der Erdoberfläche zu Punkten einschließlich des Luftraums darüber generalisiert. In SMALLTALK gibt es jedoch keine Möglichkeit, Attributen durch Deklaration Wertebereiche zuzuweisen.'},
     {'question': 'Was ist eine Generalisierungshierarchie?', 'answer': 'Eine Generalisierungshierarchie ist eine hierarchische Struktur, in der Klassen nach ihrer Allgemeinheit geordnet sind. Dabei gilt, dass eine allgemeinere Klasse eine speziellere Klasse als Unterklasse enthält. Die Generalisierungshierarchie ist eine wichtige Konzept in der objektorientierten Programmierung, da sie die Beziehung zwischen Klassen und Objekten definiert.'},
     {'question': 'Was ist der Zweck von Konstruktoren in der objektorientierten Programmierung?', 'answer': 'Konstruktoren sind spezielle Methoden in der objektorientierten Programmierung, die verwendet werden, um neue Objekte einer Klasse zu initialisieren. Sie werden aufgerufen, wenn ein neues Objekt erstellt wird und werden verwendet, um die Anfangswerte der Attribute des Objekts festzulegen. In dem gegebenen Beispiel, werden zwei alternative Konstruktoren für die Klasse "Time" definiert, die die neuen Objekte jeweils unterschiedlich initialisieren.'},
     {'question': 'Was ist das Model-View-Controller-Entwurfsmuster (MVC-Pattern)?', 'answer': 'Das MVC-Pattern ist ein Entwurfsmuster, das in SMALLTALK eingeführt wurde und sich heute noch großer Beliebtheit erfreut. Es gibt verschiedene Ansichten auf ein logisches Modell, und Änderungen im Modell können potenziell alle Sichten betreffen. Daher muss jede Änderung alle Sichten darüber unterrichten, was eine Eins-zu-viele-Kommunikation erfordert, die nicht durch den normalen Nachrichtenversand abgedeckt wird.'},
     {'question': 'Was ist Lazy Initialization?', 'answer': 'Lazy Initialization ist eine Technik, bei der die Initialisierung einer Variablen oder eines Objekts verzögert wird, bis sie tatsächlich benötigt wird. Diese Technik wird eingesetzt, um Ressourcen zu sparen und die Leistung zu verbessern.'},
     {'question': 'Was ist eine Subklassenbeziehung?', 'answer': 'Die Subklassenbeziehung ist eine Beziehung zwischen Klassen, bei der die Subklasse eine spezialisiertere Form der Superklasse ist. Die Subklassenbeziehung ist transitiv, d.h. wenn A eine Subklasse von B ist und B eine von C, dann ist A auch eine Subklasse von C. Eine Klasse kann nicht gleichzeitig Superklasse und Subklasse einer anderen Klasse sein.'},
     {'question': 'Was ist die Funktion der Pseudovariablen „super“ in SMALLTALK?', 'answer': 'Die Pseudovariable „super“ in SMALLTALK wird verwendet, um die überschriebene Methode aufzurufen, wenn eine überschreibende Methode lediglich modifizieren möchte, aber das grundlegende Verhalten beibehalten muss.'},
     {'question': 'Was ist die Bedeutung von self in Smalltalk?', 'answer': 'In Smalltalk bezieht sich self auf das Objekt, auf das die gerade ausgeführte Methode angewendet wird. Die Klasse des durch self bezeichneten Objekts muss nicht unbedingt dieselbe sein, in der die Methode definiert ist, sondern kann durchaus eine Superklasse sein. Die zu einer an self geschickten Nachricht passende Methode ist nicht automatisch die, die in derselben Klasse definiert ist, sondern kann durchaus in einer ihrer Subklassen gefunden werden.'},
     {'question': 'Was sind aktive Objekte?', 'answer': 'Aktive Objekte sind Objekte, die über einen eigenen Prozess verfügen, der nur die eigenen Methoden ausführt. Sie arbeiten Nachrichten ab, sobald sie die Zeit dazu haben, was zu einem asynchronen Kommunikationsablauf führt.'},
     {'question': 'Was sind Semaphoren?', 'answer': 'Semaphoren in SMALLTALK sind Objekte, die zur Synchronisation von parallelen Prozessen verwendet werden. Sie verfügen über zwei Methoden, "wait" und "signal", und eine Instanzvariable, die für jedes Empfangen von "signal" um 1 erhöht und für jedes Empfangen von "wait" um 1 verringert wird. Wenn der Semaphor den Wert 0 hat, wird der ausführende Prozess in den Schlaf versetzt. Andernfalls läuft er weiter. Erhält der Semaphor die Nachricht "signal" und es gibt noch Prozesse, die schlafen, dann kann ein Prozess, der an dem Semaphor wartet, aufgeweckt werden und weitermachen.'},
     {'question': 'Was ist eine SharedQueue?', 'answer': 'SharedQueue ist eine Unterklasse von OrderedCollection, die Objekte aufnimmt und eine Synchronisation über "next" und "nextPut:" erlaubt.'},
     {'question': 'Was ist ein dynamisch gebundener Methodenaufruf?', 'answer': 'Ein dynamisch gebundener Methodenaufruf ist eine Methode, bei der die Auswahl der Methode nicht nur vom Nachrichtenselektor, sondern auch vom Empfängerobjekt abhängig ist.'},
     {'question': 'Was ist das Methodenwörterbuch in Smalltalk?', 'answer': 'Das Methodenwörterbuch in Smalltalk ist eine Tabelle, die alle Methoden enthält, die zu einer bestimmten Klasse gehören. Wenn eine Methode auf einem Empfängerobjekt aufgerufen wird, wird zunächst geprüft, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist.'},
     {'question': 'Was ist die Rolle der Metaklasse "Metaclass" in SMALLTALK?', 'answer': 'Die Metaklasse "Metaclass" in SMALLTALK ist eine gemeinsame Metaklasse, von der alle Metaklassen Instanzen sind. Sie wird verwendet, um die Instanzvariablen und Methoden für Metaklassen bereitzustellen, da es nicht notwendig ist, jeder Metaklasse eigene Instanzvariablen und Methoden zuzuweisen.'},
     {'question': 'Was ist die Metaklasse von Metaclass?', 'answer': 'Die Metaklasse von Metaclass ist selbst nur eine einfache Metaklasse und wird als Instanz von Metaclass betrachtet.'},
     {'question': 'Was ist die Funktion von Arrays?', 'answer': 'Arrays werden in der Programmierung häufig verwendet, insbesondere wegen der Möglichkeit der einfachen literalen Definition. Sie ermöglichen es, einfach über die Elemente einer beliebigen, ad hoc spezifizierten Aufzählung zu iterieren. Zum Beispiel kann man den Laufparameter eines Blocks, "element", nacheinander die Elemente des literalen Arrays zuweisen.'},
     {'question': 'Was ist die Abstraktionshierarchie in Smalltalk?', 'answer': 'Eine Abstraktionshierarchie in Smalltalk ist eine Hierarchie, die auf dem Konzept der Klassifikation aufbaut und mit der Sprachdefinition festgelegt ist.'},
     {'question': 'Was sind Anwendungsklassen?', 'answer': 'Anwendungsklassen sind Klassen, die zur Laufzeit des Programms für die Erzeugung von Anwendungsobjekten genutzt werden.'},
     {'question': 'Was sind Anwendungsobjekte?', 'answer': 'Anwendungsobjekte sind Objekte, die zur Laufzeit des Programms aus Anwendungsklassen erzeugt werden.'},
     {'question': 'Was ist die Klasse "Collection" in SMALLTALK?', 'answer': 'Die Klasse "Collection" ist eine abstrakte Klasse in SMALLTALK, die eine Hierarchie von spezielleren, instanziierbaren (konkreten) Collection-Klassen umfasst, die für unterschiedlichste Zwecke eingesetzt werden können. Dazu gehören zum Beispiel "Set" für ungeordnete Collections, in denen jedes Element höchstens einmal vorkommen darf, und "Bag" für Collections, in denen die letzte Einschränkung aufgehoben ist. "Set" und "Bag" haben gemeinsam, dass die Elemente in beiden nicht über einen Index zugreifbar sind.'},
     {'question': 'Was ist die Vererbung?', 'answer': 'Die Vererbung ist ein Mechanismus, der es ermöglicht, die Definition einer Klasse (der Superklasse) auf eine andere Klasse (die Subklasse) zu übertragen. Dabei wird die gesamte Definition der Superklasse auf die Subklasse kopiert.'},
     {'question': 'Was ist der Zweck der Vererbung?', 'answer': 'Der Zweck der Vererbung ist es, die Definition einer Superklasse auf eine Subklasse zu übertragen, um die Code-Reusability zu erhöhen und die Wartbarkeit des Codes zu verbessern.'},
     {'question': 'Was ist eine Spezialisierung?', 'answer': 'Spezialisierung ist das Prinzip, bei dem Eigenschaften hinzugefügt oder bereits vorhandene spezialisiert werden, im Gegensatz zur Generalisierung, bei der Eigenschaften weggelassen oder generalisiert werden. Jede Klasse ist eine Spezialisierung ihrer Generalisierungen, sofern sie welche hat.'},
     {'question': 'Was ist Spezialisierung in der Programmierung?', 'answer': 'Spezialisierung in der Programmierung ist der Prozess der Erstellung einer neuen Klasse, die auf einer bestehenden Klasse basiert und diese erweitert oder verändert, um spezifischere Funktionalitäten bereitzustellen. Die neue Klasse wird als spezialisiertere Version der ursprünglichen Klasse angesehen, da sie die gleichen allgemeinen Merkmale und Verhalten besitzt, aber zusätzliche Merkmale und Verhalten hinzufügt, um ihre Funktionalität zu erweitern.'},
     {'question': 'Was ist Spezialisierung in der objektorientierten Programmierung?', 'answer': 'Spezialisierung ist ein Prinzip in der objektorientierten Programmierung, bei dem Eigenschaften hinzugefügt oder bereits vorhandene spezialisiert werden, um eine Unterklasse zu erstellen, die eine spezifischere Version der Oberklasse darstellt. Jede Klasse ist eine Spezialisierung ihrer Generalisierungen (sofern sie welche hat).'},
     {'question': 'Ist das Entfernen von Instanzvariablen oder Methoden vereinbar mit einer Spezialisierung?', 'answer': 'Entfernen von Instanzvariablen oder Methoden ist unvereinbar mit der Spezialisierung. Die Richtung von Spezialisierung und Generalisierung würde beliebig werden, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte.'},
     {'question': 'Welche Bedingungen müssen für eine zulässige Subklassenbeziehung erfüllt sein?', 'answer': 'Für eine zulässige Subklassenbeziehung müssen die Definitionen der Klassen bestimmte Bedingungen erfüllen. In SMALLTALK gilt dabei für neue, benannte Instanz- und Klassenvariablen, dass sie nicht dieselben Namen haben dürfen wie Variablen, die bereits in (direkten oder indirekten) Superklassen deklariert wurden. Für indizierte Instanzvariablen gilt, dass wenn die Superklasse solche hat, sie auch in der Subklasse vorhanden sein müssen. Methodendefinitionen hingegen, die dieselbe Methodensignatur verwenden, überschreiben einfach die geerbten Methoden.'},
     {'question': 'Was ist die Klasse "Object" in SMALLTALK?', 'answer': 'Die Klasse "Object" ist die oberste Superklasse in SMALLTALK, von der alle anderen Klassen abgeleitet sind. Sie enthält Definitionen, die den Instanzen aller Klassen zugutekommen sollen, wie zum Beispiel die Methode "printString". Diese Methoden werden durch Vererbung auf alle anderen Klassen übertragen, wodurch sie deren Instanzen zur Verfügung stehen.'},
     {'question': 'Was ist die Problematik bei der Vererbung in SMALLTALK?', 'answer': 'Die Problematik bei der Vererbung in SMALLTALK ist, dass man davon ausgeht, dass Vererbung etwas mit der auf Generalisierung bzw. Spezialisierung beruhenden Abstraktionshierarchie zu tun hat. Dies ist jedoch nicht immer der Fall, wie das Beispiel der Ableitung der Klasse Rechteck von der Klasse Quadrat zeigt. Diese vererbungsorientierte Vorgehensweise kann zu unangenehmen Folgen führen.'},
     {'question': 'Was sind Konstruktoren in SMALLTALK?', 'answer': 'In SMALLTALK sind Konstruktoren ganz normale Klassenmethoden und daher an keine besonderen Konventionen gebunden. Sie können ein neues Objekt genau der Klasse zurückgeben, zu der sie gehören, aber auch nicht zwingend. Das ermöglicht die Verwendung sogenannter Factory-Methoden.'},
     {'question': 'Was ist Überschreiben?', 'answer': 'Überschreiben bedeutet, dass eine abgeleitete Klasse dieselben Methoden wie die Basisklasse besitzt, aber die Methoden anders implementiert. Das ist häufig Voraussetzung dafür, Vererbung sinnvoll einzusetzen.'},
     {'question': 'Was ist das Problem mit der Vererbung?', 'answer': 'Das Problem mit der Vererbung ist, dass sie auf die oberflächliche Wiederverwendung von Elementen einer Klassendefinition ausgerichtet ist und dabei den Zusammenhang der Extensionen der beteiligten Klassen außer Acht lässt, was für Generalisierung/Spezialisierung wesentlich ist. Diese Ignoranz hat weitreichende Konsequenzen.'},
     {'question': 'Was ist Generalisierung und Spezialisierung in Bezug auf objektorientierte Programmierung?', 'answer': 'Generalisierung und Spezialisierung sind Prinzipien in der objektorientierten Programmierung. Dabei wird eine allgemeine Klasse (Generalisation) erstellt, die dann durch eine spezifischere Klasse (Spezialisation) erweitert wird. In diesem Fall wird die Klasse Rechteck als allgemeine Klasse angesehen und Quadrat als spezifischere Klasse, die von Rechteck erbt.'},
     {'question': 'Was ist der Unterschied zwischen Schlüssel und Wert in einem Dictionary?', 'answer': 'Der Schlüssel (key) ist ein eindeutiger Bezeichner für ein Element in einem Dictionary, während der Wert (value) das Element selbst ist, das unter diesem Schlüssel gespeichert ist.'},
     {'question': 'Was ist die Klasse Dictionary in SMALLTALK?', 'answer': 'Die Klasse Dictionary in SMALLTALK realisiert sogenannte Assoziativspeicher, bei denen auf eine Speicherzelle nicht durch Angabe einer Speicheradresse, sondern durch Assoziation mit dem Inhalt zugegriffen wird. Sie wird im SMALLTALK-System selbst häufig verwendet, zum Beispiel für das Hinterlegen von Methoden in Dictionaries.'},
     {'question': 'Was ist Delegation in der objektorientierten Programmierung?', 'answer': 'Delegation ist eine Technik in der objektorientierten Programmierung, bei der eine Instanz eine andere Instanz als Sklavin hält, die für sie den Dienst verrichtet. Sie wird oft genutzt, um die Funktion der Vererbung zu übernehmen, da sie dynamisch eingerichtet werden kann und nicht an Fragen der Generalisierung/Spezialisierung gebunden ist.'},
     {'question': 'Was sind Allgemeinbegriffe?', 'answer': 'Allgemeinbegriffe sind die Vorbilder für Klassen in der objektorientierten Programmierung. In SMALLTALK werden Allgemeinbegriffe in Form von Klassen repräsentiert. Klassen sind die Vorbilder für Objekte in der objektorientierten Programmierung. Jede Klasse kann Instanzvariablen und Methoden haben, die das Verhalten und die Eigenschaften der Objekte beschreiben, die zu dieser Klasse gehören.'},
     {'question': 'Was ist offene Rekursion?', 'answer': 'Offene Rekursion ist ein Muster in der objektorientierten Programmierung, bei dem eine abstrakte, in der Klasse nicht implementierte Methode aus derselben Klasse heraus mit "self" als Empfänger aufgerufen wird. Dieses Muster wird verwendet, um die Implementierung der Methode in einer erbenden Klasse zu ermöglichen.'},
     {'question': 'Was ist Parametrische Polymorphie?', 'answer': 'Parametrische Polymorphie ist eine Art der Polymorphie, bei der die Auswahl einer Methode von den tatsächlichen Parametern abhängt. Wenn die Methode, die für eine bestimmte Nachricht vorgesehen ist, nicht für alle möglichen Parameter geeignet ist, muss eine alternative Methode ausgewählt werden, die besser zu den tatsächlichen Parametern passt.'},
     {'question': 'Was ist Double Dispatch und wofür wird es verwendet?', 'answer': 'Double Dispatch ist eine Technik, bei der eine Methode gleicher Bedeutung unter Vertauschung von Sender und Empfänger aufgerufen wird. Diese Technik wird verwendet, um die dynamische Bindung zweimal hintereinander durchzuführen. Double Dispatch wurde erstmals von Dan Ingalls am Beispiel von Smalltalk beschrieben und findet auch in anderen Sprachen mit Single Dispatch Anwendung. In Sprachen, bei denen bei der dynamischen Methodenauswahl die Parametertypen berücksichtigt werden, wird Double Dispatch nicht benötigt.'},
     {'question': 'Was ist ein Objekt in Bezug auf Klassen?', 'answer': 'Ein Objekt ist eine Instanz einer Klasse.'},
     ],
    [{'question': 'Wann kann eine Lazy initialization sinnvoll sein?', 'answer': '"Lazy initialization" ist eine Technik, bei der die Initialisierung von Instanzvariablen zu einem späteren Zeitpunkt nach der Instanziierung durchgeführt wird. Dies kann sinnvoll sein, wenn die Initialisierung aufwendig ist und die Abfrage des Anfangswerts selten erfolgt. Die Initialisierung wird verschoben, um den Preis der Initialisierung im Programmablauf zu sparen, wenn sie nie notwendig wird.'},
     {'question': 'Wie sieht die Abstraktionshierarchie in SMALLTALK aus?', 'answer': 'In SMALLTALK gibt es eine Abstraktionshierarchie, bei der von konkreten Objekten der Ebene 0 über Allgemeinbegriffe oder Konzepte der Ebene 1 zu den Definitionen dieser Konzepte auf Ebene 2 und schließlich zur Fassung von Definitionen auf Ebene 3 fortgeschritten wird.'},
     {'question': 'Wie lässt sich die Vererbung von Superklassen auf Subklassen umsetzen?', 'answer': 'Es gibt verschiedene Möglichkeiten, den Mechanismus der Vererbung von Superklassen auf Subklassen umzusetzen. Zwei dieser Möglichkeiten wurden im Text angedeutet: Kopieren und Einfügen: Eine Möglichkeit wäre, die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Dies würde die Semantik der Vererbung korrekt wiedergeben, aber bei Änderungen an der Superklasse müssten auch alle Subklassen aktualisiert werden, was technisch problematisch wäre. Automatische Instanzerzeugung: Eine andere Möglichkeit wäre, für jede Instanz einer Subklasse automatisch Instanzen aller ihrer Superklassen zu erzeugen und diese Instanzen zu einer zu vereinen. Dies würde jedoch das Konzept der Identität von Objekten beeinträchtigen, da Objekte einer Subklasse mehrere Identitäten hätten.'},
     {'question': 'Was ist ein Beispiel für eine abstrakte Klasse in SMALLTALK?', 'answer': 'Ein Beispiel für eine abstrakte Klasse in SMALLTALK ist die Klasse "Collection". Ihre Abstraktheit zeigt sich darin, dass sie keine benannten Instanzvariablen hat und einige ihrer Methoden, wie "add:", nicht implementiert sind. Wenn jemand versuchen würde, die Methode "add:" auf einer Instanz von "Collection" oder einer ihrer Subklassen aufzurufen, würde dies zu einer Fehlermeldung führen.'},
     {'question': 'Wie wird Delegation in prototypenbasierten objektorientierten Programmiersprachen genutzt?', 'answer': 'Delegation ist eine Beziehung zwischen zwei Objekten, bei der ein Objekt (Delegierter) die Verantwortung für die Bearbeitung bestimmter Anfragen an ein anderes Objekt (Delegator) überträgt. In prototypenbasierten objektorientierten Programmiersprachen wird Delegation genutzt, um die Funktion der Vererbung zu übernehmen. Sie kann dynamisch eingerichtet werden und ist von Fragen der Generalisierung/Spezialisierung befreit, was sie zu einer beliebten Alternative zur Vererbung macht.'},
     {'question': 'Wie kann man in Smalltalk automatische Zugriffsmethoden für alle benannten Instanzvariablen generieren?', 'answer': 'Dies ist möglich, indem man eine neue Methode zur Klassendefinition in der Klasse "Class" oder "Behavior" hinzufügt, die die vorhandenen Methoden um die automatische Generierung der Zugriffsmethoden erweitert.'},
     {'question': 'Wie wird der Zustand eines Objekts in Smalltalk verändert?', 'answer': 'Der Zustand eines Objekts in Smalltalk wird verändert, indem die Werte seiner Instanzvariablen zugewiesen werden, was gleichbedeutend mit der Änderung seiner Beziehungen ist.'},
     {'question': 'Wann entstehen Aliase in Smalltalk?', 'answer': 'Aliase entstehen in Smalltalk immer bei der Zuweisung, wenn die Variable auf der linken Seite Verweissemantik hat.'},
     {'question': 'Wie werden Informationen in der objektorientierten Programmierung in Smalltalk dargestellt?', 'answer': 'In der objektorientierten Programmierung werden sämtliche Informationen als ein Geflecht von Objekten dargestellt, das navigiert und manipuliert werden kann.'},
     {'question': 'Wann sollte self class und wann self species in Smalltalk verwendet werden?', 'answer': 'Wenn man eine Kopie oder Konvertierung durchführen möchte und kein Objekt des gleichen Typs zurückgegeben werden darf, sollte man self species anstelle von self class verwenden.'},
     {'question': 'Wie werden Klassenvariablen und -methoden in SMALLTALK vererbt?', 'answer': 'In SMALLTALK werden Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt. Dies geschieht automatisch parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind.'},
     {'question': 'Wie werden Klassen und Metaklassen in SMALLTALK unterschieden?', 'answer': 'In SMALLTALK gibt es zwei Arten von Objekten: solche, die instanziierbar sind (Klassen) und solche, die es nicht sind. Darüber hinaus gibt es eine Unterscheidung zwischen Klassen, die Metaklassen sind, und solchen, die es nicht sind. Diese Unterscheidungen müssen irgendwo getroffen werden. Die Klasse Object ist nicht die Wurzel der Vererbungshierarchie der Metaklassen, sondern erbt von einer für diesen Zweck vorgesehenen Klasse. Die Klasse Class ist die Superklasse aller Metaklassen, ist aber selbst keine Metaklasse. Die Klasse von Class ist Class class und erst Class class eine Metaklasse.'},
     {'question': 'Wie ist die Vererbungshierarchie der Metaklassen in SMALLTALK organisiert?', 'answer': 'In SMALLTALK können Metaklassen, die ebenfalls Klassen sind, voneinander erben. Die Vererbungshierarchie der Metaklassen wird parallel zur Vererbungshierarchie der Klassen, die Instanzen der Metaklassen sind, erstellt. Dies bedeutet, dass in SMALLTALK sowohl Instanzvariablen und -methoden als auch Klassenvariablen und -methoden von einer Klasse auf ihre Subklassen vererbt werden. Jede Metaklasse in SMALLTALK erbt automatisch von "Object class", der Metaklasse von "Object". Die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, einschließlich der Standardkonstruktoren "new" und "new:", werden in "Object class" (genauer gesagt als Instanzmethoden von "Object class") definiert. Um die Unterscheidung zwischen instanziierbaren Klassen (Klassen) und nicht instanziierbaren Klassen (Metaklassen) sowie zwischen Klassen und Metaklassen zu treffen, wird die Klasse "Class" verwendet. "Class" ist die Superklasse aller Metaklassen und stellt sicher, dass jede Instanz dieser Klasse eine Klasse ist. Obwohl "Class" die Superklasse aller Metaklassen ist, ist sie selbst keine Metaklasse. Die Klasse von "Class" ist "Class class", und erst "Class class" ist eine Metaklasse.'},
     {'question': 'Wie werden Metaklassen in SMALLTALK erstellt?', 'answer': 'In SMALLTALK werden Metaklassen automatisch erstellt, wenn eine neue Klasse definiert wird. Jede Klasse hat automatisch ihre eigene Metaklasse, die die Definitionen von Instanzvariablen und Methoden für diese Klasse enthält.'},
     {'question': 'Wie können Programmierer in SMALLTALK geerbte Methoden löschen?', 'answer': 'In SMALLTALK können Programmierer geerbte Methoden löschen, indem sie die Methode "shouldNotImplement" in der Subklasse implementieren und die geerbte Methode überschreiben. Wenn eine Klasse also eine geerbte Methode löschen möchte, überschreibt sie diese Methode einfach mit "shouldNotImplement". Diese Konvention ermöglicht es Programmierern, geerbte Methoden elegant auszulöschen, sollte dies erforderlich sein. Es ist jedoch wichtig zu beachten, dass der Wunsch, geerbte Methoden zu löschen, eine direkte Folge der Orientierung an Vererbung ist, die in dieser Textpassage kritisiert wird. Wenn die Superklasse auf Grundlage des Prinzips der Generalisierung ausgewählt wurde, besteht normalerweise keine Notwendigkeit, geerbte Methoden zu löschen, da alles, was für die Generalisierung sinnvoll ist, auch für ihre Spezialisierungen sinnvoll ist. Dieses Prinzip wird in späteren Kurseinheiten weiter erläutert.'},
     {'question': 'Wie werden Instanzvariablen in SMALLTALK standardmäßig initialisiert, nachdem eine Instanz erzeugt wurde?', 'answer': 'Nach der Erzeugung einer Instanz in SMALLTALK haben alle Instanzvariablen standardmäßig den Wert "nil". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden, normalerweise durch Aufrufen der Methode "initialize".'},
     {'question': 'Wie werden Klassendefinitionen in SMALLTALK umgesetzt?', 'answer': 'In SMALLTALK erfolgt die Klassendefinition nicht in einer separaten Datei wie in vielen anderen objektorientierten Programmiersprachen. Stattdessen werden Klassendefinitionen durch Eintragungen in eine Datenstruktur oder das Erzeugen eines Objekts repräsentiert. Es gibt keine spezielle Syntax für Klassendefinitionen, nur ein Schema.'},
     {'question': 'Wie funktioniert die Verwendung von super in SMALLTALK?', 'answer': 'Wenn super als Nachrichtenempfänger in einer Methodendefinition verwendet wird, beginnt die Suche nach der zur Nachricht passenden Methodendefinition in der (direkten) Superklasse der Klasse, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet. Anders als bei self ist die Suche unabhängig von der Klasse des Objekts, für das super steht. Das bedeutet, dass super immer eine von der Klasse des konkreten Empfängerobjekts losgelöste Suche auslöst, die in der Superklasse der Klasse beginnt, in der super verwendet wird, und nicht in der Superklasse der Klasse, von der das (durch super bezeichnete) Empfängerobjekt eine direkte Instanz ist.'},
     {'question': 'Warum werden in SMALLTALK keine aktiven Objekte verwendet?', 'answer': 'In SMALLTALK wird Parallelverarbeitung nicht in Form von aktiven Objekten, sondern in Form von parallelen Prozessen implementiert. Dies liegt daran, dass aktive Objekte, die asynchron Nachrichten verarbeiten, in der Praxis sehr aufwendig wären.'},
     {'question': 'Wie erfolgt die Synchronisation von parallelen Prozessen in SMALLTALK?', 'answer': 'Die Synchronisation von parallelen Prozessen in SMALLTALK erfolgt zunächst mittels Semaphoren. Objekte der Klasse Semaphore verfügen über Methoden wie "wait" und "signal", um die Ausführung von Prozessen zu steuern. Semaphore-Objekte zählen die Anzahl der Signale und können Prozesse in den Schlaf versetzen oder aufwecken, abhängig von ihrem aktuellen Zustand. Die Synchronisation kann auch über die Klasse SharedQueue erfolgen, die Objekte aufnimmt und Synchronisation über "next" und "nextPut:" ermöglicht.'},
     {'question': 'Wie funktioniert die Suche nach einer Methode in SMALLTALK?', 'answer': 'Bei der Suche nach einer Methode wird zunächst im Methodenwörterbuch der Klasse des Empfängers nachgeschlagen. Wenn die Methode dort nicht gefunden wird, wird in der direkten Superklasse der Klasse des Objekts gesucht, und dieser Prozess setzt sich fort, bis die Methode gefunden wird oder bis zur Klasse "Object". Sobald die Methode gefunden wird, wird sie ausgeführt. Falls die Methode auch in "Object" nicht gefunden wird, wird die Nachricht "doesNotUnderstand:" an den ursprünglichen Empfänger mit der ursprünglichen Nachricht als Argument gesendet.'},
     {'question': 'Wie können Zu-n-Beziehungen in SMALLTALK gepflegt werden?', 'answer': 'In SMALLTALK werden Zu-n-Beziehungen standardmäßig mit den Methoden add: und remove: gepflegt. Diese Methoden sind in der abstrakten Klasse Collection definiert, und alle Klassen, die : n-Beziehungen repräsentieren, sind indirekte Instanzen von Collection. Diese Methoden bleiben zunächst abstrakt und müssen in den entsprechenden Subklassen implementiert werden.'},
     {'question': 'Wie wird die Vererbung in SMALLTALK und vielen anderen objektorientierten Programmiersprachen umgesetzt?', 'answer': 'In SMALLTALK und vielen anderen objektorientierten Programmiersprachen wird die Vererbung als ein Teilen der Klassendefinitionen realisiert. Das bedeutet, dass Vereinbarungen, die in einer Klasse getroffen wurden, automatisch auch für alle Subklassen gelten, es sei denn, diese spezifizieren etwas anderes. Die Vereinbarungen werden nicht übertragen oder kopiert, sondern einfach gemeinsam genutzt. Dies ermöglicht eine effiziente Vererbung von Eigenschaften und Verhalten, ohne die Probleme mit der Identität von Objekten oder der Notwendigkeit der Aktualisierung von Subklassen bei Änderungen in der Superklasse.'},
     {'question': 'Wie kann man das Problem der Spezialisierung von Klassen lösen?', 'answer': 'Das Problem der Spezialisierung von Klassen kann elegant gelöst werden, indem parallel zur spezialisierten Klasse eine Klasse "NichtSpezialisierteKlasse" eingeführt wird. Alle Eigenschaften, die andere Instanzen von derselben Generalisierung unterscheiden, können in der "NichtSpezialisierteKlasse" platziert werden. Dadurch bleibt die Hierarchie sauber und ermöglicht eine klare Unterscheidung zwischen spezialisierten und nicht spezialisierten Klassen.'},
     {'question': 'Wie werden Klassen in SMALLTALK erzeugt?', 'answer': 'In SMALLTALK werden Klassen erzeugt, indem man einer anderen Klasse eine entsprechende Nachricht sendet. Dies ist notwendig, da Instanzen in SMALLTALK grundsätzlich über Konstruktoren erstellt werden, und jede Klasse ist eine Instanz ihrer Metaklasse.'},
     {'question': 'Wie kann in SMALLTALK verhindert werden, dass Instanzen einer abstrakten Klasse erzeugt werden?', 'answer': 'In SMALLTALK erfolgt die Erkennung, dass eine abstrakte Klasse instanziiert wurde, zur Laufzeit, wenn versucht wird, eine nicht implementierte Methode aufzurufen. Um zu verhindern, dass Instanzen einer abstrakten Klasse überhaupt erzeugt werden, könnte man die Konstruktoren, insbesondere "new" und "new:", entsprechend überschreiben. Dies würde jedoch auch die Instanziierung der Klassen verhindern, die von der abstrakten Klasse erben, was oft nicht akzeptabel ist.'},
     {'question': 'Wie wird die Unterscheidung nach den Parameterobjekten in SMALLTALK durchgeführt?', 'answer': 'In SMALLTALK kann die Unterscheidung nach den Parameterobjekten mithilfe einer Technik namens "Double Dispatch" durchgeführt werden. Bei dieser Technik wird im Rumpf einer Methode dieselbe Methode noch einmal aufgerufen, wobei Empfänger (self) und Parameter vertauscht werden. Die Klasse des Empfängers wird im Nachrichtenselektor der neu aufgerufenen Methode kodiert. Dadurch erfolgt die dynamische Bindung zweimal hintereinander, einmal für den Empfänger und einmal für den Parameter, um die richtige Methode basierend auf beiden Objekten auszuwählen.'},
     {'question': 'Wie ist die Definition einer Metaklasse aufgebaut?', 'answer': 'Die Definition einer Metaklasse ist ähnlich wie die einer normalen Klasse aufgebaut, bestehend aus benannten Instanzvariablen und Instanzmethodendefinitionen. Der Klassenname kann jedoch nicht frei angegeben werden. Indizierte Instanzvariablen sind nicht vorgesehen.'},
     {'question': 'Wie ist das Verhältnis von Klassen und Metaklassen in SMALLTALK?', 'answer': 'Aufgrund der bestehenden 1-zu-1-Beziehung zwischen Klassen und Metaklassen werden diese in SMALLTALK nicht getrennt voneinander definiert, sondern in einem gemeinsamen Schema. Jede Klassendefinition verfügt demnach neben den Abschnitten zur Deklaration der Instanzvariablen und zur Definition der Methoden auch noch über zwei Abschnitte für die entsprechenden Angaben zur ihrer Metaklasse, die Angabe der sogenannten Klassenvariablen und -methoden.'},
     {'question': 'Wie kann man ein Objekt vergrößern?', 'answer': 'Eine Möglichkeit, ein Objekt zu vergrößern, ist das "Umziehen" der Repräsentation des Objekts in den Speicher. Dazu wird ein neues Objekt mit der doppelten Größe angelegt, die Daten werden in das neue Objekt kopiert und das alte Objekt wird durch das neue Objekt ersetzt. Die Methode grow erzeugt eine neue ArrayedCollection mit einer um 100 erhöhten Größe und kopiert den Inhalt der alten ArrayedCollection in die neue. Anschließend gibt sie die neue ArrayedCollection zurück.'},
     {'question': 'Wie wird die Initialisierung von Instanzvariablen in Smalltalk durchgeführt?', 'answer': 'In Smalltalk wird die Initialisierung von Instanzvariablen durchgeführt, indem die Methode "initialize" aufgerufen wird, die standardmäßig von den Methoden "new" und "new:" vorgesehen ist. Diese Methode kann alle Initialisierungen vornehmen, ohne dass etwas über den Aufbau der Instanzen nach außen verraten wird.'},
     {'question': 'Wie funktioniert die Vererbung in SMALLTALK?', 'answer': 'In SMALLTALK hat Vererbung eine Kopieren-und-Einfügen-Semantik, d.h. wenn man die Implementierung einer Methode aus der Superklasse in die Subklasse wiederholt, erhält man das gleiche Ergebnis.'},
     {'question': 'Wann sollte man offene Rekursion nicht verwenden?', 'answer': 'Man sollte offene Rekursion nicht verwenden, wenn sie zu Problemen führen kann, die als "Fragile-base-class-Problem" bekannt sind.'},
     {'question': 'Wie würden aktive Objekte kommunizieren?', 'answer': 'Aktive Objekte würden asynchron kommunizieren, indem sie Nachrichten (Methodenaufrufe) ohne Prozess empfangen und dann abarbeiten, wenn sie die Zeit dazu haben.'},
     {'question': 'Wie wird Parallelverarbeitung in Smalltalk und Java umgesetzt?', 'answer': 'In Smalltalk und Java wird Parallelverarbeitung durch parallele Prozesse umgesetzt, die zu einer Zeit eine Methode ausführen. Diese Prozesse besuchen mit dem Methodenaufruf die Empfängerobjekte, die jedoch selbst passiv bleiben und kein Eigenleben haben.'},
     {'question': 'Wie wird eine Methode in SMALLTALK aufgerufen?', 'answer': 'In SMALLTALK wird eine Methode auf einem Empfängerobjekt aufgerufen, indem zunächst geprüft wird, ob die Methode im zur Klasse des Empfängers gehörenden Methodenwörterbuch enthalten ist. Diese Prüfung kann man auch selbst durchführen, indem man die Instanzmethode includesSelector: der Klasse Behavior aufruft, die allen Klassen zur Verfügung steht.'},
     {'question': 'Wie ist die Beziehung zwischen Klassen und Objekten in SMALLTALK?', 'answer': 'In SMALLTALK gibt es eine 1:n-Beziehung zwischen Klassen und Objekten. Klassen stellen die Definitionen für Objekte bereit und repräsentieren die Objekte der Ebene 0 in ihrer Gesamtheit. Objekte werden durch Instanziierung von Klassen erstellt.'},
     {'question': 'Wie passiert in SMALLTALK die Instanziierung?', 'answer': 'In SMALLTALK wird normalerweise die Instanziierung eines Objekts durch Senden der Nachricht "new" (für Klassen ohne indizierte Instanzvariablen) oder "new:" (für Klassen mit indizierten Instanzvariablen) an die Klasse durchgeführt. Das neue Objekt wird im Speicher angelegt, und seine Instanzvariablen werden alle mit "nil" initialisiert.'},
     {'question': 'Wie werden in Smalltalk Klassen verwaltet?', 'answer': 'In Smalltalk werden alle Klassen, die in einem SMALLTALK-System zur Verfügung stehen, in einem gemeinsamen Namensraum verwaltet.'},
     {'question': 'Wie funktionieren Factory-Methoden?', 'answer': 'Factory-Methoden sind statische Methoden, die eine Instanz einer bestimmten Unterklasse erzeugen und zurückgeben, anstatt die Instanz direkt zu instanziieren. Sie entscheiden dynamisch, welche Unterklasse instanziiert werden soll, abhängig von den gegebenen Eingaben. Dadurch können sie die richtige Instanzklasse auswählen und eine Instanz dieser Klasse zurückgeben, ohne dass der Aufrufer sich um die Details der Instanziierung kümmern muss.'},
     {'question': 'Wie werden Klassen in SMALLTALK erzeugt?', 'answer': 'In SMALLTALK werden Klassen erzeugt, indem einer anderen Klasse eine entsprechende Nachricht gesendet wird. Dies ist notwendig, da Instanzen, für die es keine literale Repräsentation gibt, in SMALLTALK grundsätzlich über Konstruktoren erstellt werden, und jede Klasse ist eine Instanz ihrer Metaklasse.'},
     {'question': 'Wie hängt die Intension und Extension zusammen?', 'answer': 'Je größer die Intension (die Menge der Eigenschaften) ist, desto kleiner ist die Extension (die Menge der Objekte, die diese Eigenschaften erfüllen).'},
     {'question': 'Wann wird das Empfängerobjekt und die Parameterobjekte bei der Auswahl einer Methode berücksichtigt?', 'answer': 'Das Empfängerobjekt und die Parameterobjekte werden bei der Auswahl einer Methode berücksichtigt, wenn die Auswahl der geeigneten Methode von den tatsächlichen Parametern abhängt.'},
     {'question': 'Wie wird die Parametrische Polymorphie in der objektorientierten Programmierung implementiert?', 'answer': 'In der objektorientierten Programmierung wird Parametrische Polymorphie in der Regel durch Überladen von Methoden implementiert. Dabei werden mehrere Methoden mit dem gleichen Namen, aber unterschiedlichen Parametern definiert. Wenn eine Nachricht gesendet wird, wird die Methode mit den passenden Parametern ausgewählt und ausgeführt.'},
     {'question': 'Wann spielen die tatsächlichen Parameter eine Rolle bei der Methodenauswahl?', 'answer': 'Die tatsächlichen Parameter spielen eine Rolle bei der Methodenauswahl, wenn eine Methode für verschiedene Datentypen unterschiedlich implementiert ist, wie zum Beispiel bei arithmetischen Operatoren.'},
     ],
    [{'question': 'Was ist der Unterschied zwischen dem Konstruktoransatz und dem Klassenansatz in der objektorientierten Programmierung?', 'answer': 'Beim Konstruktoransatz wird der Aufbau eines Objekts in einer Methode beschrieben, in der dem Objekt bei seiner Erzeugung Instanzvariablen und Methoden zugeordnet werden. Bei jedem Aufruf dieser Methode entsteht ein neues Objekt. Im Gegensatz dazu, erzeugt der Klassenansatz Objekte als Instanzen von bestimmten Vorlagen, die als Klassen bezeichnet werden. Alle Objekte, die von einer Klasse erzeugt werden, haben dieselben Instanzvariablen und Methoden.'},
     {'question': 'Was ist der Unterschied zwischen dem Prototypenansatz und dem Klassenansatz in der objektorientierten Programmierung?', 'answer': 'Beim Prototypenansatz wird ein schon existierendes Objekt samt seiner Instanzvariablen und Methoden geklont und bei Bedarf um weitere Instanzvariablen und Methoden ergänzt. Im Gegensatz dazu, erzeugt der Klassenansatz Objekte als Instanzen von bestimmten Vorlagen, die als Klassen bezeichnet'},
     {'question': 'Was ist der Unterschied zwischen aktiven und passiven Objekten?', 'answer': 'Aktive Objekte sind Objekte, die über einen eigenen Rechenprozess verfügen und Nachrichten asynchron empfangen und verarbeiten können. Passive Objekte hingegen sind Objekte, die nur aktiv sind, solange sie gerade eine Methode ausführen. In der Praxis werden jedoch passive Objekte verwendet, da aktive Objekte sehr aufwendig wären.'},
     {'question': 'Was ist der wesentliche Nachteil von Arrays in SMALLTALK?', 'answer': 'Der wesentliche Nachteil von Arrays in SMALLTALK ist, dass ihre Größe beschränkt ist. Das bedeutet, dass die Anzahl der Elemente in einem Array begrenzt ist, und es schwierig oder teuer sein kann, die Größe eines Arrays dynamisch zu ändern, um mehr Elemente aufzunehmen.'},
     {'question': 'Welches Problem kann bei der Vererbung auftreten, wenn sie nicht in Einklang mit den Prinzipien von Generalisierung und Spezialisierung angewendet wird?', 'answer': 'Ein Problem bei der Vererbung tritt auf, wenn sie oberflächlich zur Wiederverwendung von Elementen einer Klassendefinition verwendet wird, ohne die Prinzipien von Generalisierung und Spezialisierung zu berücksichtigen. Dies kann dazu führen, dass die Beziehung zwischen den Extensionen der beteiligten Klassen nicht angemessen berücksichtigt wird und zu unerwarteten Konsequenzen führt.'},
     {'question': 'Welcher Vorteil ergibt sich aus der Verwendung von Zwischenobjekten in Zu-n-Beziehungen?', 'answer': 'Ein entscheidender Vorteil der Verwendung von Zwischenobjekten in Bezug auf Zu-n-Beziehungen ist die Möglichkeit, verschiedene Arten von solchen Beziehungen zu definieren und diesen jeweils spezifisches Verhalten zuzuweisen, das auf die Art der Beziehung abgestimmt ist. Dies ermöglicht es, mengenwertige Beziehungen oder sortierte Beziehungen zu erstellen und Operationen wie das Hinzufügen oder Entfernen von Objekten individuell anzupassen.'},
     {'question': 'Was ist der Unterschied zwischen lesbaren und schreibbaren Streams?', 'answer': 'Lesbare Streams sind Ströme, die nur zum Lesen von Daten verwendet werden können, während schreibbare Streams zum Schreiben von Daten verwendet werden können.'},
     {'question': 'Wie unterscheidet sich die SortedCollection in SMALLTALK von anderen Collection-Klassen?', 'answer': 'Eine SortedCollection ist eine Collection-Klasse in SMALLTALK, die eine Subklasse von OrderedCollection ist. Im Gegensatz zu anderen Collection-Klassen wird die Reihenfolge der Elemente in einer SortedCollection nicht von außen, durch Angabe eines Indexes oder die Reihenfolge der Einfügung, festgelegt. Stattdessen wird die Reihenfolge von innen durch eine Qualität der eingefügten Objekte bestimmt. Dies ermöglicht es, die in Beziehung stehenden Objekte in einer bestimmten Reihenfolge zu halten, unabhängig von der Reihenfolge, in der sie der Collection hinzugefügt wurden.'},
     {'question': 'Was ist der Unterschied zwischen einer Metaklasse und einer normalen Klasse?', 'answer': 'Der Unterschied zwischen einer Metaklasse und einer normalen Klasse besteht darin, dass Metaklassen keine indizierten Instanzvariablen enthalten dürfen und der Klassenname nicht frei angegeben werden kann.'},
     {'question': 'Was ist der Unterschied zwischen Instanzvariablen und Klassenvariablen?', 'answer': 'Der Unterschied zwischen Instanzvariablen und Klassenvariablen liegt darin, dass Instanzvariablen jeweils zu einer Instanz gehören, während Klassenvariablen zu einer Klasse gehören. Das bedeutet, dass jede Instanz einer Klasse ihre eigenen Werte für die Instanzvariablen hat, während alle Instanzen einer Klasse die gleichen Werte für die Klassenvariablen teilen.'},
     {'question': 'Was ist der Unterschied zwischen Generalisierung und Klassifikation in der objektorientierten Programmierung?', 'answer': 'Klassifikation ist eine Form der Ist-ein-Abstraktion, bei der man von einem Individuum zu seinem Allgemeinbegriff übergeht, während Generalisierung zwei Allgemeinbegriffe miteinander in Beziehung setzt. Ein weiterer Unterschied besteht darin, dass die Klassifikation nicht transitiv ist, während die Generalisierung es ist.'},
     {'question': 'Was ist der Unterschied zwischen Konstruktoren und Initialisierung in Smalltalk?', 'answer': 'In Smalltalk sind Konstruktoren Klassenmethoden, die neue Instanzen der jeweiligen Klasse zurückliefern. Nach der Erzeugung einer Instanz haben alle Instanzvariablen standardmäßig den Wert "nil". Wenn diese Instanzvariablen sinnvolle Anfangswerte haben sollen, müssen sie explizit zugewiesen werden. Dieser Vorgang wird als Initialisierung der Instanz bezeichnet. Somit ist der Unterschied, dass Konstruktor ein Klassenmethode ist, die eine neue Instanz erzeugt, während Initialisierung ein Vorgang ist, bei dem Instanzvariablen sinnvolle Anfangswerte zugewiesen bekommen.'},
     {'question': 'Was ist der Unterschied zwischen Konstruktoren in SMALLTALK und Konstruktoren in Sprachen wie C++, Java oder C-Sharp?', 'answer': 'In SMALLTALK sind Konstruktoren Klassenmethoden, während sie in Sprachen wie C++, Java oder C-Sharp eine Art Zwitterstatus haben und sowohl auf der Klasse als auch auf der neuen Instanz aufgerufen werden können. SMALLTALK-Konstruktoren können nicht auf die Instanzvariablen der neu erzeugten Instanz zugreifen, während Konstruktoren in C++, Java oder C-Sharp dies können.'},
     {'question': 'Was ist der Unterschied zwischen Superklasse und Subklasse?', 'answer': 'Die Begriffe Superklasse und Subklasse können in verschiedenen Programmiersprachen unterschiedliche Bedeutungen haben. In einigen Sprachen bezeichnet Superklasse die Oberklasse und Subklasse die Unterklasse, während in anderen Sprachen die Bedeutungen vertauscht sind. Daher werden in diesem Kurs die Begriffe Generalisierung und Spezialisierung verwendet, um die Beziehung zwischen Ober- und Unterklassen zu beschreiben.'},
     {'question': 'Was ist der Unterschied zwischen self und super?', 'answer': 'Der Unterschied liegt darin, dass die Suche bei self von der Klasse des Objekts abhängt, für das self steht, während die Suche bei super unabhängig von der Klasse des Objekts ist, für das super steht. Super beginnt die Suche immer mit der Superklasse der Klasse, in der super verwendet wird, und nicht mit der Superklasse der Klasse, von der das Empfängerobjekt eine direkte Instanz ist.'},
     {'question': 'Was ist der Unterschied zwischen dem klassenbasierten Methoden-Lookup und dem objektbasierten Methoden-Lookup?', 'answer': 'Der Unterschied zwischen dem klassenbasierten Methoden-Lookup und dem objektbasierten Methoden-Lookup besteht darin, dass man beim objektbasierten Methoden-Lookup jedem Objekt sein eigenes Methodenwörterbuch zur Verfügung stellt, während beim klassenbasierten Methoden-Lookup die Methoden in der Klasse gespeichert sind.'},
     {'question': 'Was ist der Unterschied zwischen dynamischem und statischem Binden in der objektorientierten Programmierung?', 'answer': 'Beim dynamischen Binden wird eine Nachricht an ein Objekt geschickt und es wird zur Laufzeit entschieden, welche Methode aufgerufen wird. Beim statischen Binden wird dies bereits zur Übersetzungszeit entschieden. Ein Vorteil des dynamischen Bindens ist die größere Flexibilität, allerdings müssen dafür bestimmte Laufzeitprüfungen durchgeführt werden. Statische Typprüfung kann das Risiko von Typfehlern verringern, schränkt aber die Flexibilität beim Programmieren ein.'},
     {'question': 'Was ist der Unterschied zwischen den Klassen "Set" und "Bag" in Smalltalk?', 'answer': 'Die Klasse "Set" ist eine ungeordnete Collection, in der jedes Element höchstens einmal vorkommen darf, während die Klasse "Bag" eine ungeordnete Collection ist, in der die letzte Einschränkung aufgehoben ist, d.h. in der ein Element mehrfach vorkommen kann.'},
     {'question': 'Was ist der Unterschied zwischen Spezialisierung und Instanziierung?', 'answer': 'Spezialisierung und Instanziierung sind zwei verschiedene Vorgänge. Spezialisierung bedeutet, den Wertebereich einer Instanzvariable einzuschränken, während Instanziierung bedeutet, einer Instanzvariable eines Objekts ein Element aus dem Wertebereich zuzuweisen. Im Fall von "Zweibeiner" kann durch Spezialisierung der Wertebereich der Instanzvariable "anzahlBeine" auf {2} eingeschränkt werden, während durch Instanziierung einer Instanzvariable eines Objekts der Wert 2 zugewiesen wird.'},
     {'question': 'Wie Unterschiden sich Factory-Methode von Konstruktoren?', 'answer': 'Eine Factory-Methode ist eine Methode, die eine neue Instanz liefert, ähnlich wie ein Konstruktor. Der Unterschied liegt darin, dass die Klasse der Instanz von anderen Faktoren als nur der Klasse, zu der die Methode gehört, abhängig gemacht wird. In SMALLTALK sind Factory-Methoden einfach zu implementieren und unterscheiden sich formal nicht von Konstruktoren, da es sich einfach um Klassenmethoden handelt.'},
     {'question': 'Was ist der Unterschied zwischen Spezialisierung und Vererbung?', 'answer': 'Spezialisierung und Vererbung scheinen Hand in Hand zu gehen, aber in der Praxis kann eine unbedachte Spezialisierung zu Komplikationen führen und eine Fixierung auf die Nutzung der Vererbung zu Problemen. Spezialisierung bezieht sich auf das Erstellen einer Unterklasse, die eine Oberklasse erweitert, während Vererbung ein Mechanismus ist, bei dem eine Unterklasse die Eigenschaften und Methoden einer Oberklasse erbt.'},
     {'question': 'Was ist der Unterschied zwischen Vererbung und Generalisierung?', 'answer': 'Vererbung und Generalisierung sind zwei verschiedene Konzepte. Wenn man denkt, man hätte mit der Vererbung auch eine Generalisierungsbeziehung geschaffen, ist man auf dem Holzweg. Ein Beispiel: Die Menge der Quadrate enthält nicht die Menge der Rechtecke, was eine charakteristische Begleiterscheinung der Generalisierung gewesen wäre. Der Unterschied liegt in der Intension und Extension: Die Intension von Rechteck ist umfangreicher als die von Quadrat, da sie eine Instanzvariable mehr enthält. Die Intension von Quadrat ist aber trotzdem restriktiver als die von Rechteck, da sie eine zusätzliche Bedingung enthält.'},
     {'question': 'Was ist der Unterschied zwischen Generalisierung/Spezialisierung und Vererbung in der objektorientierten Programmierung?', 'answer': 'Generalisierung/Spezialisierung und Vererbung sind zwei verschiedene Konzepte in der objektorientierten Programmierung. Generalisierung/Spezialisierung steht für die Ordnung eines Systems von Klassen mit Blick von außen und für das Ganze, während Vererbung für die Pragmatik des Programmierens mit Blick von innen und einem Fokus auf Wiederverwendung steht. Vererbung stellt eine Art genetischen Zusammenhang zwischen Klassen dar, während Generalisierung/Spezialisierung eher eine abstrakte Ordnung ist. Vererbung bringt Komplexität in ein System, während Generalisierung/Spezialisierung versucht, sie durch Strukturierung zu reduzieren.'},
     {'question': 'Was sind die Vorteile des klassenbasierten Ansatzes gegenüber dem prototypenbasierten Ansatz?', 'answer': 'Der klassenbasierte Ansatz ist besser geeignet, um massenhaft gleiche Objekte abzudecken, was in vielen Anwendungsdomänen der Fall ist. Im Vergleich zur Vererbung unter Instanzen, die der prototypenbasierte Ansatz bietet, ist die Vererbung unter Klassen im klassenbasierten Ansatz einfacher nachzuvollziehen und zu debuggen.'},
     {'question': 'Was ist der Unterschied zwischen abstrakten und konkreten Klassen?', 'answer': 'Abstrakte Klassen sind nicht instanziierbar, da sie in der Regel Angaben fehlen, die das Verhalten ihrer Instanzen vollständig spezifizieren. Konkrete Klassen hingegen haben eigene Instanzen und können instanziiert werden.'},
     {'question': 'Was ist der Unterschied zwischen einer Shallow Copy und einer Deep Copy?', 'answer': 'Bei einer Shallow Copy wird nur die oberste Ebene der Objektstruktur kopiert, während bei einer Deep Copy auch alle Unterobjekte rekursiv kopiert werden. Das heißt, beim flachen Klonen wird nur eine Referenz auf das Unterobjekt kopiert, während beim tiefen Klonen eine neue Kopie des Unterobjekts erstellt wird.'},
     {'question': 'Wozu werden temporäre Variablen in Smalltalk verwendet?', 'answer': 'Temporäre Variablen werden in Smalltalk verwendet, um Zwischenergebnissen Namen zu geben und die Lesbarkeit zu verbessern.'},
     {'question': 'Was können Konvertierungsmethoden in Collections tun?', 'answer': 'Konvertierungsmethoden in Collections können eine Menge von Objekten aus einer Collection in eine andere übertragen, wobei die Eigenschaften der Ziel-Collection berücksichtigt werden, z.B. asSet, das doppelte Elemente entfernt. Besonders interessant sind Konvertierungen in Collections, die strengere Bedingungen stellen, z.B. asSet und asSortedCollection.'},
     {'question': 'Was passiert, wenn man die Attributwerte eines Objekts nachträglich ändert, die für die Sortierung herangezogen wurden?', 'answer': 'Eine nachträgliche Änderung der Attributwerte, die zum Vergleich der Objekte für die Sortierung herangezogen wurden, bewirkt keine automatische Änderung der Reihenfolge.'},
     {'question': 'Wozu dient das Klonen oder Kopieren?', 'answer': 'Das Klonen/Kopieren wird verwendet, um eine unabhängige Kopie eines Objekts zu erstellen, das unabhängig von der Originalinstanz geändert werden kann, ohne die Originalinstanz zu beeinflussen. Es wird auch verwendet, um Objekte zu erstellen, die mit den gleichen Daten initialisiert werden sollen, oder um Objekte zu speichern, die später wiederhergestellt werden sollen.'},
     {'question': 'Kann Vererbung in SMALLTALK auch auf Metaklassen angewendet werden?', 'answer': 'Ja, Vererbung kann in SMALLTALK auch auf Metaklassen angewendet werden, da Metaklassen ebenfalls Klassen sind. Die Vererbungshierarchie der Metaklassen wird automatisch parallel zur Vererbungshierarchie der Klassen angelegt, die Instanzen der Metaklassen sind.'},
     {'question': 'Wo werden die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, in SMALLTALK definiert?', 'answer': 'Die Klassenmethoden, die allen Klassen zur Verfügung stehen sollen, werden in Object class definiert, der Metaklasse von Object.'},
     {'question': 'Warum hat sich die klassenbasierte Form der objektorientierten Programmierung gegenüber der prototypenbasierten Form durchgesetzt?', 'answer': 'Die klassenbasierte Form der objektorientierten Programmierung hat sich vermutlich aus verschiedenen Gründen durchgesetzt. Zum einen bieten Klassen ein etabliertes Ordnungskonzept, das in anderen Disziplinen wie Mathematik und Biologie verwendet wird, und das sich gut zur Strukturierung von objektorientierten Programmen eignet. Zum anderen eignen sich Klassen als Vorlagen für Typen, was die Integration von objektorientierter Programmierung in typisierte Sprachen ermöglicht. Die prototypenbasierte Form der Objektorientierung bietet hingegen Flexibilität bei der Anpassung von einzelnen Objekten an ihren Zweck und ist besonders nützlich in interaktiven Anwendungen.'},
     {'question': 'Gibt es Gründe, die prototypenbasierte Form der objektorientierten Programmierung zu nutzen?', 'answer': 'Ja, es gibt gute Gründe, die prototypenbasierte Form der objektorientierten Programmierung zu nutzen. Sie erlaubt eine hohe Flexibilität bei der Anpassung von Objekten an ihren jeweiligen Zweck, insbesondere in interaktiven Anwendungen. Ein Beispiel dafür ist die Programmierung von grafischen Benutzeroberflächen, bei der verschiedene Buttons verschiedene Ereignisse auslösen können. JavaScript ist eine erfolgreiche Programmiersprache für interaktive Webseiten und basiert auf dem Prototypenansatz.'},
     {'question': 'Warum benötigen Klassen in SMALLTALK ihre eigenen Metaklassen?', 'answer': 'Klassen in SMALLTALK benötigen ihre eigenen Metaklassen, damit sie ihre eigenen Instanzvariablen und Methoden definieren können, ohne die Definitionen anderer Klassen zu beeinflussen. Dies ermöglicht eine hohe Flexibilität und erlaubt es den Programmierern, das Verhalten von Klassen individuell anzupassen.'},
     {'question': 'Warum gibt es eine 1-zu-1-Beziehung zwischen Klassen und ihren Metaklassen in SMALLTALK?', 'answer': 'Die 1-zu-1-Beziehung zwischen Klassen und ihren Metaklassen in SMALLTALK gewährleistet, dass jede Klasse ihre eigenen Instanzvariablen und Methoden definieren kann, ohne andere Klassen zu beeinflussen. Dadurch wird die Flexibilität und Unabhängigkeit der Klassen in SMALLTALK gewährleistet.'},
     {'question': 'Warum erhalten Programmierer in SMALLTALK erst zur Laufzeit des Programms eine Fehlermeldung, wenn sie eine Nachricht an eine Instanz einer abstrakten Klasse senden?', 'answer': 'In SMALLTALK und ähnlichen objektorientierten Programmiersprachen erhalten Programmierer zur Laufzeit des Programms eine Fehlermeldung, wenn sie eine Nachricht an eine Instanz einer abstrakten Klasse senden, da diese abstrakten Klassen unvollständig sind und daher nicht implementierte Methoden enthalten können. Die Fehlermeldung, die durch die Methode "doesNotUnderstand:" (in der Klasse "Object") ausgelöst wird, informiert die Programmierer darüber, dass die Methode in einer Subklasse implementiert werden sollte. Dieser Ansatz entspricht dem interaktiven Geist des SMALLTALK-Systems, bei dem das Programmieren als iteratives Zurechtbiegen und Erweitern eines bereits funktionierenden Systems betrachtet wird.'},
     {'question': 'Warum ist es möglich, in SMALLTALK mehrere alternative Konstruktoren für eine Klasse zu definieren?', 'answer': 'Es ist möglich, mehrere alternative Konstruktoren für eine Klasse in SMALLTALK zu definieren, da nicht immer alle Instanzen einer Klasse auf die gleiche Weise initialisiert werden müssen. Dies ermöglicht es, verschiedene Initialisierungsmethoden für verschiedene Anwendungsfälle anzubieten.'},
     {'question': 'Warum ist eine Eins-zu-viele-Kommunikation im MVC-Pattern erforderlich?', 'answer': 'Im MVC-Pattern gibt es verschiedene Ansichten auf ein logisches Modell. Wenn Änderungen im Modell potenziell alle Ansichten betreffen, müssen diese Änderungen alle Ansichten darüber informieren. Daher ist eine Eins-zu-viele-Kommunikation erforderlich, um sicherzustellen, dass alle betroffenen Ansichten aktualisiert werden.'},
     {'question': 'Was bedeutet es, dass die Subklassenbeziehung transitiv ist?', 'answer': 'Die Transitivität der Subklassenbeziehung bedeutet, dass, wenn Klasse A eine Subklasse von Klasse B ist und Klasse B eine Subklasse von Klasse C ist, dann ist Klasse A auch eine Subklasse von Klasse C. Dies bedeutet, dass die Vererbung von Eigenschaften und Verhalten in der Klassenhierarchie entlang der Subklassenbeziehung in einer kaskadierenden Weise erfolgt.'},
     {'question': 'Was unterscheidet ein direkte Subklasse und ein indirekte Subklasse?', 'answer': 'Eine direkte Subklasse ist eine Klasse, die direkt von einer anderen Klasse erbt, ohne dass eine weitere Klasse dazwischen liegt. Eine indirekte Subklasse ist eine Klasse, die von einer Superklasse erbt, die selbst von einer anderen Klasse erbt. Mit anderen Worten, eine indirekte Subklasse ist eine Subklasse, die von einer Superklasse erbt, die ebenfalls eine Subklasse ist.'},
     {'question': 'Warum sind Generalisierung und Spezialisierung in der objektorientierten Programmierung relevant?', 'answer': 'Obwohl Generalisierung und Spezialisierung eher theoretisch motivierte Konzepte sind, sind sie dennoch relevant, da sie dazu beitragen, die Struktur und Hierarchie von Klassen in objektorientierten Programmen zu definieren. Sie ermöglichen es, Klassen in Beziehung zueinander zu setzen und abstrakte Modelle für die Softwareentwicklung zu entwickeln. Diese Konzepte können in komplexen Softwareprojekten zur Verbesserung der Wartbarkeit und Erweiterbarkeit beitragen.'},
     {'question': 'Warum muss in SMALLTALK das Empfängerobjekt einer Nachricht immer explizit angegeben werden?', 'answer': 'In SMALLTALK muss das Empfängerobjekt einer Nachricht immer explizit angegeben werden, selbst wenn sich die dazu passende Methode in derselben Klasse befindet. Dies unterscheidet sich von einigen anderen Programmiersprachen wie Java, in denen das Empfängerobjekt manchmal implizit ist. Die Verwendung von self ist notwendig, um das Objekt zu identifizieren, auf dem die Methode ausgeführt wird, und auf dessen Instanzvariablen zugegriffen werden kann.'},
     {'question': 'Was unterscheidet dynamische und statische Typisierung in Bezug auf das dynamische Binden?', 'answer': 'In der dynamischen Bindung, wie sie in SMALLTALK verwendet wird, erfolgt die Auswahl der Methode zur Laufzeit und hängt von der Art des Empfängerobjekts ab. In der statischen Typisierung, wie sie in statisch typgeprüften Sprachen wie Java, C-Sharp und C++ verwendet wird, erfolgt die Typüberprüfung zur Übersetzungszeit und nicht zur Laufzeit. Statisch typisierte Sprachen erfordern in der Regel, dass der Programmierer den Datentyp der Objekte und deren Methoden im Voraus festlegt, während dynamisch typisierte Sprachen mehr Flexibilität bieten, da die Typüberprüfung erst zur Laufzeit erfolgt. Allerdings erhöht die dynamische Bindung das Risiko von Laufzeitfehlern, die in statisch typisierten Sprachen vermieden werden können, indem explizite Typüberprüfungen durchgeführt werden.'},
     {'question': 'Gibt es Einschränkungen bei der Spezialisierung von Klassen?', 'answer': 'Ja, es gibt Einschränkungen bei der Spezialisierung von Klassen. Das Entfernen von Instanzvariablen oder Methoden ist vollkommen unvereinbar mit der Spezialisierung, da dies die Umkehrung der Spezialisierung, die Generalisierung, verhindern würde. Es ist jedoch möglich, Eigenschaften durch Beschränkungen zu ändern oder hinzuzufügen, aber das Entfernen ist nicht erlaubt.'},
     {'question': 'Warum gibt es in SMALLTALK mindestens eine Klasse, die keine Subklasse ist?', 'answer': 'In SMALLTALK ist die Subklassenbeziehung nicht reflexiv, was bedeutet, dass jede Klasse mindestens eine Superklasse haben muss. Diese oberste Superklasse ist die Klasse "Object". In "Object" sind Definitionen enthalten, die den Instanzen aller Klassen zugutekommen sollen, und diese Methoden werden per Vererbung auf alle anderen Klassen übertragen.'},
     {'question': 'Warum kann die Vererbung allein nicht als Indikator für Generalisierung und Spezialisierung dienen?', 'answer': 'Die Vererbung allein kann nicht als Indikator für Generalisierung und Spezialisierung dienen, da sie keinen kausalen Zusammenhang zwischen Klassen herstellt. Nur weil eine Klasse Eigenschaften von einer anderen geerbt hat, bedeutet das nicht zwangsläufig, dass die erbende Klasse eine Spezialisierung der vererbenden ist. Ein klassisches Beispiel dafür wurde bereits mit der Ableitung der Klasse "Rechteck" von der Klasse "Quadrat" gegeben. Es ist wichtig zu erkennen, dass die Vererbung nicht immer eindeutig auf eine Generalisierung/Spezialisierung hinweist und vorsichtige Analyse und Planung erfordert. In einigen Fällen kann eine zu starke Vererbung sogar zu unerwünschten Ergebnissen führen.'},
     {'question': 'Warum könnte die Vererbung zwischen Instanzen in der objektorientierten Programmierung das Verfolgen und Debuggen von Programmen erschweren?', 'answer': 'Die Vererbung zwischen Instanzen kann das Verfolgen und Debuggen von Programmen erschweren, da sie die Beziehungen zwischen Objekten komplexer gestaltet. Wenn Objekte Eigenschaften und Verhalten von anderen Objekten erben können und diese Eigenschaften überschreiben oder löschen können, kann dies zu unvorhersehbarem Verhalten führen und die Fehlersuche erschweren.'},
     {'question': 'Was unterscheidet Extension und Intension?', 'answer': 'Die Extension (Ausdehnung) ist die Menge der Objekte, die zu dieser Klasse gehören. Die Intension ist die Summe der Merkmale oder Eigenschaften, die den Begriff ausmachen und die Objekte charakterisieren, die zu dieser Klasse gehören. Mit steigender Intension wird die Extension kleiner, und umgekehrt.'},
     {'question': 'Warum sind abstrakte Klassen in der objektorientierten Programmierung nicht instanziierbar?', 'answer': 'Abstrakte Klassen sind in der Regel nicht instanziierbar, weil ihnen oft die notwendigen Informationen fehlen, um Instanzen vollständig zu initialisieren. Sie dienen als Vorlagen für Subklassen, die die fehlenden Details ergänzen.'},
     {'question': 'Wozu dienen Intervalle hauptsächlich in Smalltalk?', 'answer': 'Intervalle in Smalltalk dienen hauptsächlich dem Zweck, sogenannte "For"-Schleifen zu emulieren, wie sie im Abschnitt 4.6.3 in Kurseinheit 1 beschrieben sind.'},
     {'question': 'Warum sind Klassen keine Instanzen einer speziellen Klasse "Class"?', 'answer': 'Wenn Klassen Instanzen einer speziellen Klasse "Class" wären, hätten sie dieselbe Menge von Instanzvariablen und Methoden. Das würde aber bedeuten, dass alle Klassen gleich wären, was nicht der Fall ist. Jede Klasse hat ihre eigene, einzigartige Menge von Instanzvariablen und Methoden. Deshalb sind Klassen keine Instanzen einer speziellen Klasse "Class".'},
     {'question': 'Was könnte man tun, wenn man weitere Eigenschaften für eine Klasse haben möchte, die diese nicht mit allen anderen teilt?', 'answer': 'In diesem Fall kann man eine Unterklasse erstellen, die die gewünschten Eigenschaften besitzt.'},
     {'question': 'Warum kann es sinnvoll sein, eine Methode wie "new" für bestimmte Klassen anders zu definieren?', 'answer': 'Es kann sinnvoll sein, eine Methode wie "new" für bestimmte Klassen anders zu definieren, um die Instanzvariablen der neu erzeugten Instanzen bestimmte Startwerte zuzuweisen oder um das Verhalten der Methode an die Anforderungen der Klasse anzupassen.'},
     {'question': 'Was ermöglicht es in Smalltalk, dass jede Klasse ihre eigenen Instanzvariablen und Methoden besitzt?', 'answer': 'In Smalltalk kann jede Klasse Instanz einer eigenen Klasse sein, in der diese Variablen und Methoden nur für sie angelegt werden können, da jede Klasse Instanz einer eigenen Klasse ist.'},
     {'question': 'Was passiert, wenn eine Programmiererin eine abstrakte Klasse instanziiert und eine Nachricht an die entsprechende Instanz sendet?', 'answer': 'Wenn eine Programmiererin eine abstrakte Klasse instanziiert und eine Nachricht an die entsprechende Instanz sendet, führt dies zu einer Fehlermeldung, die ihr anzeigt, dass die Methode (erst) in einer Subklasse implementiert werden sollte. Diese Fehlermeldung bekommt die Programmiererin allerdings erst zur Laufzeit des Programms zu Gesicht, was bedeutet, dass sie das Problem erst bemerkt, wenn es bereits zu spät ist.'},
     {'question': 'Was bewirkt die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition?', 'answer': 'Die Verwendung von super als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der (direkten) Superklasse der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet.'},
     {'question': 'Was bewirkt die Verwendung von self als Nachrichtenempfänger in einer Methodendefinition?', 'answer': 'Die Verwendung von self als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet.'},
     {'question': 'Was bewirkt die Verwendung von this als Nachrichtenempfänger in einer Methodendefinition?', 'answer': 'Die Verwendung von this als Nachrichtenempfänger in einer Methodendefinition bewirkt, dass die Suche nach der zur Nachricht passenden, „aufgerufenen“ Methodendefinition in der Klasse beginnt, in der sich der aufrufende Ausdruck (die aufrufende Methode) befindet.'},
     {'question': 'Was passiert, wenn an self eine Nachricht geschickt wird?', 'answer': 'Wenn an self eine Nachricht geschickt wird, wird die zu dieser Nachricht passende Methode gesucht. Die Suche beginnt in der Klasse, in der die gerade ausgeführte Methode definiert ist. Wenn die Methode nicht in dieser Klasse gefunden wird, wird die Suche in der Kette der Superklassen fortgesetzt, bis die Methode gefunden wird.'},
     {'question': 'Was passiert, wenn an self eine Nachricht geschickt wird, die in der Klasse des Objekts nicht definiert ist?', 'answer': 'Wenn an self eine Nachricht geschickt wird, die in der Klasse des Objekts nicht definiert ist, wird die Suche nach der passenden Methode in der Kette der Superklassen fortgesetzt, bis die Methode gefunden wird.'},
     {'question': 'Was versteht man unter Kopieren-und-Einfügen-Semantik bei Vererbung?', 'answer': 'Bei der Kopieren-und-Einfügen-Semantik bei Vererbung wird die Implementierung der übergeordneten Klasse in die Unterklasse kopiert und kann dann in der Unterklasse gegebenenfalls angepasst werden. Wenn man die Implementierung von sagMirWasDuBist aus Super in Sub wiederholt hätte, hätte man das gleiche Ergebnis erzielt.'},
     {'question': 'Sind Objekte in der objektorientierten Programmierung aktiv oder passiv?', 'answer': 'Objekte in der objektorientierten Programmierung sind passiv, was bedeutet, dass sie nur aktiv sind, solange sie gerade eine Methode ausführen.'},
     {'question': 'Was bedeutet es, dass Objekte passiv sind?', 'answer': 'Objekte sind passiv, was bedeutet, dass sie nur aktiv sind, solange sie gerade eine Methode ausführen. Im Wesentlichen sind Objekte in der objektorientierten Programmierung nicht anders als Variablen in prozeduralen Programmiersprachen. Sie enthalten Daten und können auf diese Daten zugreifen, aber sie können nicht von sich aus Aktionen ausführen. Stattdessen müssen ihnen Nachrichten gesendet werden, um sie zu aktivieren und sie dazu zu bringen, eine Methode auszuführen.'},
     {'question': 'Warum werden in der objektorientierten Programmierung in der Praxis eher passive Objekte verwendet?', 'answer': 'Aktive Objekte sind sehr aufwendig, weshalb in der objektorientierten Programmierung in der Praxis eher passive Objekte verwendet werden.'},
     {'question': 'Kann es in der objektorientierten Programmierung Parallelverarbeitung geben?', 'answer': 'Ja, in der objektorientierten Programmierung ist Parallelverarbeitung möglich, jedoch nicht in Form von aktiven Objekten, sondern in Form von parallelen Prozessen, die jeweils eine Methode ausführen.'},
     {'question': 'Was passiert, wenn eine Methode nicht gefunden wird?', 'answer': 'Wenn eine Methode nicht gefunden wird, wird in der direkten Superklasse der Klasse des Objekts weitergesucht und dann in deren direkter Superklasse usw. bis zur Klasse Object. Sobald die Methode gefunden wird, wird sie ausgeführt. Wird die Methode auch in Object nicht gefunden, kommt es zum Versenden der Nachricht doesNotUnderstand: an den ursprünglichen Empfänger mit der ursprünglichen, problematischen Nachricht als Argument.'},
     {'question': 'Was passiert, wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind?', 'answer': 'Wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind, kann sie dies tun, wenn sie in der gleichen Klasse definiert ist. Wenn die Methode jedoch in einer Superklasse definiert ist, kann sie nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind, und nicht auf Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind.'},
     {'question': 'Was passiert, wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind, aber in der Unterklasse hinzugekommen sind?', 'answer': 'Die Methode kann nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar.'},
     {'question': 'Was passiert, wenn eine Methode auf Instanzvariablen zugreifen will, die für die Objekte der entsprechenden Klasse zugreifbar sind, aber in einer Superklasse definiert wurden?', 'answer': 'Die Methode kann nur auf die Instanzvariablen zugreifen, die für die Objekte der entsprechenden Klasse zugreifbar sind. Instanzvariablen, die erst in der Klasse des Objekts hinzugekommen sind, sind für die Methode also nicht (direkt) sichtbar.'},
     {'question': 'Was repräsentiert die "Ist-eine-Instanz-von"-Beziehungn?', 'answer': 'Die "Ist-eine-Instanz-von"-Beziehung stellt die Beziehung zwischen einer Klasse und einer Instanz dar, was bedeutet, dass die Instanz ein Objekt der Klasse ist.'},
     {'question': 'Was verhindert die Interpretation von Klassen als Mengen von Objekten?', 'answer': 'Die Interpretation von Klassen als Mengen von Objekten wird durch den Kunstgriff verhindert, die Hierarchie zu beenden, was im Widerspruch zu Abschnitt 7.3 stünde.'},
     {'question': 'Was wäre eine Möglichkeit, die Vererbung umzusetzen?', 'answer': 'Eine Möglichkeit wäre, die Definition einer Superklasse per Kopieren und Einfügen auf ihre Subklassen zu übertragen. Diese Methode würde die Semantik der Vererbung korrekt wiedergeben, würde aber das Problem mit sich bringen, dass bei einer Änderung einer Superklasse auch alle ihre Subklassen mit geändert werden müssten.'},
     {'question': 'Was wäre problematisch, wenn jede Instanz einer Subklasse automatisch je eine Instanz aller ihrer Superklassen erzeugen würde?', 'answer': 'Das wäre problematisch, weil ein Objekt einer Subklasse auf einmal mehrere Identitäten hätte, und zwar eine für sich selbst und eine pro Superklasse, von der sie erbt. Das Konzept der Identität von Objekten würde verletzt werden.'},
     {'question': 'Kann eine Klasse neue Spezialisierungen hinzufügen, wenn sie bereits Generalisierungen besitzt?', 'answer': 'Ja, eine Klasse kann neue Spezialisierungen hinzufügen, auch wenn sie bereits Generalisierungen besitzt. Das ist eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind.'},
     {'question': 'Kann eine Klasse neue Spezialisierungen hinzufügen, wenn die Generalisierung bereits über Spezialisierungen verfügt?', 'answer': 'Ja, eine Klasse kann neue Spezialisierungen hinzufügen, wenn die Generalisierung bereits über Spezialisierungen verfügt. Das ist eine der größten Errungenschaften der objektorientierten Programmierung, dass solche Programmiererweiterungen modular, also ohne andere Teile des Programms zu beeinflussen, immer möglich sind.'},
     {'question': 'Was bedeutet es, wenn man von einer Klasse spezialisiert?', 'answer': 'Wenn man von einer Klasse spezialisiert, erweitert man diese Klasse um neue Eigenschaften und Verhaltensweisen. Die spezialisierte Klasse ist eine Unterklasse der ursprünglichen Klasse und erbt alle Eigenschaften und Verhaltensweisen von dieser.'},
     {'question': 'Was bedeutet es, wenn man von einer Klasse spezialisieren möchte, die selbst keine Generalisierung ist?', 'answer': 'In diesem Fall spricht man von einer Spezialisierung durch Verengung (engl. narrowing). Dabei wird eine bestehende Klasse so spezialisiert, dass sie weniger Fähigkeiten besitzt als die ursprüngliche Klasse. Diese Art der Spezialisierung ist in der objektorientierten Programmierung eher unüblich, kann aber in manchen Fällen sinnvoll sein.'},
     {'question': 'Kann man Instanzvariablen oder Methoden entfernen, wenn man sie nicht mehr benötigt?', 'answer': 'Nein, das ist nicht möglich. Das Entfernen von Instanzvariablen oder Methoden ist unvereinbar mit der Spezialisierung. Die Richtung von Spezialisierung und Generalisierung würde beliebig werden, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte.'},
     {'question': 'Warum ist das Entfernen von Instanzvariablen oder Methoden unvereinbar mit der Spezialisierung?', 'answer': 'Das Entfernen von Instanzvariablen oder Methoden ist unvereinbar mit der Spezialisierung, weil die Umkehrung der Spezialisierung, die Generalisierung, dann nicht aus dem bloßen Weglassen entstehen könnte. Zudem würde die Richtung von Spezialisierung und Generalisierung beliebig werden, wenn in beide Richtungen nach Belieben hinzugefügt und entfernt werden dürfte.'},
     {'question': 'Was wird durch eine Subklassenbeziehung zwischen zwei Klassen ausgedrückt?', 'answer': 'Durch eine Subklassenbeziehung zwischen zwei Klassen wird ausgedrückt, dass die Subklasse alle Instanzvariablen und Methoden der Superklasse erbt. Es wird jedoch nicht ausgedrückt, dass die Subklasse eine Spezialisierung der Superklasse ist oder die Superklasse eine Generalisierung der Subklasse. Diese Sicherstellung obliegt der Verantwortung des Programmierers.'},
     {'question': 'Was muss bei der Definition einer Subklasse in SMALLTALK beachtet werden?', 'answer': 'In SMALLTALK müssen bei der Definition einer Subklasse neue, benannte Instanz- und Klassenvariablen andere Namen als Variablen in Superklassen haben und indizierte Instanzvariablen müssen vorhanden sein, wenn die Superklasse solche hat. Methodendefinitionen mit derselben Signatur überschreiben einfach die geerbten Methoden.'},
     {'question': 'Warum ist die Vererbung in der objektorientierten Programmierung problematisch?', 'answer': 'Die Vererbung in der objektorientierten Programmierung ist problematisch, weil sie oft fälschlicherweise als ein Zeichen für eine Generalisierung/Spezialisierung interpretiert wird. Es ist jedoch möglich, dass eine Klasse Eigenschaften einer anderen Klasse erbt, ohne dass sie eine Spezialisierung der vererbenden Klasse ist. Ein klassisches Beispiel hierfür ist die Ableitung der Klasse Rechteck von der Klasse Quadrat, was zu unangenehmen Folgen führen kann.'},
     {'question': 'Was repräsentieren die Instanzvariablennamen in SMALLTALK?', 'answer': 'Die Instanzvariablennamen in SMALLTALK sind eine Liste von Symbolen, die die Namen der Instanzvariablen der neuen Klasse repräsentieren.'},
     {'question': 'Kann man eine Instanzvariable löschen, die von einer übergeordneten Klasse geerbt wurde?', 'answer': 'Ja, man kann eine Instanzvariable löschen, die von einer übergeordneten Klasse geerbt wurde. Allerdings muss man dann auch die Methoden, die diese Instanzvariable verwenden, überschreiben.'},
     {'question': 'Was passiert, wenn man eine Instanzvariable löscht, die von einer übergeordneten Klasse geerbt wurde?', 'answer': 'Wenn man eine Instanzvariable löscht, die von einer übergeordneten Klasse geerbt wurde, muss man auch die Methoden, die diese Instanzvariable verwenden, überschreiben.'},
     {'question': 'Warum sollte das Attribut, das als Schlüssel in einem Dictionary verwendet wird, unveränderlich sein?', 'answer': 'Das Attribut, das als Schlüssel in einem Dictionary verwendet wird, sollte unveränderlich sein, da das Objekt nach einer Änderung des Attributs immer noch unter dem alten Attributwert als Schlüssel gespeichert ist und nur unter diesem wiedergefunden wird. Wenn das Attribut veränderlich ist, kann es zu Problemen bei der Suche nach dem Objekt im Dictionary führen, da der alte Attributwert nicht mehr gültig ist.'},
     {'question': 'Warum ist die Übertragung der Vererbung auf Klassen nicht vollkommen unnatürlich?', 'answer': 'Die Übertragung der Vererbung auf Klassen ist nicht vollkommen unnatürlich, weil Programmierer in objektorientierten Programmen Klassen entwerfen, die die eigentliche „Schöpfung“ der objektorientierten Weltsicht abgeben. Zudem sind objektorientierte Programme nicht für die Ewigkeit gemacht, sondern unterliegen der ständigen Anpassung und somit sind auch Klassendefinitionen im ständigen Wandel.'},
     {'question': 'Was sind die Schwierigkeiten bei einer Vererbung unter Instanzen?', 'answer': 'Die Vererbung unter Instanzen kann das Nachvollziehen und Debuggen eines Programms schwieriger machen, da die Vererbungshierarchie nicht so einfach zu verfolgen ist wie bei der Vererbung unter Klassen. Die Vererbung unter Klassen ist üblicherweise hierarchisch und bietet eine klare Struktur, während die Vererbung unter Instanzen eher netzartig sein kann und daher schwieriger nachzuvollziehen ist.'},
     {'question': 'Was passiert, wenn man versucht, eine nicht implementierte Methode in SMALLTALK aufzurufen?', 'answer': 'Wenn man versucht, eine nicht implementierte Methode in SMALLTALK aufzurufen, erfolgt ein Hinweis, dass man eine abstrakte Klasse instanziiert hat.'},
     {'question': 'Wozu dient die Intervall-Collection?', 'answer': 'Die Intervall-Collection dient der Umsetzung von Zu-n-Beziehungen und enthält eine Anzahl von Elementen, die durch eine untere und obere Grenze bestimmt sind. Die untere Grenze ist inklusiv, die obere Grenze exklusiv. Die Anzahl der Elemente ist also die Differenz zwischen der oberen und unteren Grenze. Die Elemente eines Intervalls sind die ganzen Zahlen, die zwischen der unteren und oberen Grenze liegen.'},
     {'question': 'Wofür werden indizierte Instanzvariablen verwendet?', 'answer': 'Indizierte Instanzvariablen werden verwendet, um Zu-n-Beziehungen zwischen Objekten herzustellen. Sie sind speziell für diesen Zweck eingeführt worden, um die Häufigkeit des Vorkommens von Zu-n-Beziehungen in der Programmierung zu unterstützen.'}
     ],
]
KE3_questions = [
    [{'question': 'Was ist eine Typvariable in einer Typdefinition?', 'answer': 'In der Typdefinition ist eine Typvariable ein Platzhalter für einen tatsächlichen Typ, der bei der Instantiierung der Klasse eingesetzt wird. Traditionell werden einzelne Großbuchstaben für Typvariablen verwendet, um versehentliches Verdecken eines tatsächlichen Typs zu vermeiden.'},
     {'question': 'Was ist der Zweck von Typvariablen in Typdefinitionen?', 'answer': 'Der Zweck von Typvariablen in der Typdefinition ist, dass sie anstelle des Parameters und des Rückgabetyps T nennen, wobei T eine Typvariable ist. Typvariablen werden verwendet, um keinen tatsächlichen Typen zu verdecken, wie es sonst versehentlich passieren könnte. Typvariablen können auch zu einer parametrischen Klassendefinition beliebig viele Typen haben.'},
     {'question': 'Was ist der Zweck der Typisierung in der Programmierung?', 'answer': 'Der Zweck der Typisierung in der Programmierung ist es, die möglichen Werte einer Variablen oder Funktion einzuschränken und so die Fehleranfälligkeit zu verringern. Durch die Angabe eines Typs wird sichergestellt, dass nur Werte dieses Typs an die Variable oder Funktion übergeben werden können, was die Korrektheit des Programms erhöht.'},
     {'question': 'Was ist die Bedeutung von Typparametern in einer parametrisierten Typdefinition?', 'answer': 'Typparameter in einer parametrisierten Typdefinition sind Platzhalter für konkrete Typen, die bei der Instanziierung des Typs eingesetzt werden können. Sie ermöglichen es, den gleichen Code für verschiedene Typen wiederzuverwenden und die Typsicherheit zu erhalten.'},
     {'question': 'Was ist parametrischer Polymorphismus?', 'answer': 'Parametrischer Polymorphismus ist eine Technik in der objektorientierten Programmierung, bei der eine Typvariable innerhalb einer Typdefinition verwendet wird. Diese Typvariable kann später durch einen konkreten Typ ersetzt werden, wenn die Typdefinition instanziiert wird. Dadurch wird die Typsicherheit gewährleistet.'},
     {'question': 'Was sind Metatypen?', 'answer': 'Metatypen sind eine Möglichkeit, um die Typvariable innerhalb der mit ihr parametrisierten Typdefinition wertbeschränkt zu machen. Dabei sind die Wertebereiche der Metatypen Typen mit von den Metatypen vorgegebenen Eigenschaften. Diese Möglichkeit wird jedoch in der Praxis nicht genutzt.'},
     {'question': 'Was ist Subtyping?', 'answer': 'Subtyping ist eine Art der Beschränkung des Wertebereichs von Typvariablen, bei der ein tatsächlicher Typparameter (der Wert der Typvariable) ein Subtyp eines bestimmten Typs sein muss, der die benötigten Eigenschaften umfasst. Aufgrund der Regeln des Subtyping hat jeder solche Typ die Eigenschaften des Supertyps.'},
     {'question': 'Was ist ein Subtyp?', 'answer': 'Ein Subtyp ist ein Typ, dessen Werte oder Objekte überall auftauchen dürfen, wo ein Wert des Typs, von dem er ein Subtyp ist, verlangt wird. Subtyp ist eine Rolle in einer Beziehung zwischen zwei Typen, nämlich der Subtypenbeziehung, und die Gegenrolle heißt Supertyp.'},
     {'question': 'Was bedeutet Zuweisungskompatibilität?', 'answer': 'Zuweisungskompatibilität bedeutet, dass Objekte eines Subtyps überall auftauchen dürfen, wo Objekte seines Supertyps erwartet werden. Ein Subtyp ist also per Definition mit seinem Supertyp zuweisungskompatibel.'},
     {'question': 'Was ist Typeinschränkung?', 'answer': 'Typeinschränkung ist eine Möglichkeit, auf der Basis eines bereits bestehenden Typs einen neuen, verwandten Typen zu erzeugen, indem man ihn auf Basis des bestehenden Typs definiert, aber mit dem Entfernen von Eigenschaften (Methoden). Diese Form der Typeinschränkung stellt die Umkehrung der Typerweiterung dar, führt aber nicht zur Zuweisungskompatibilität.'},
     {'question': 'Was ist die unter dem Gesichtspunkt der Zuweisungskompatibilität interessante Form der Typeinschränkung?', 'answer': 'Die unter dem Gesichtspunkt der Zuweisungskompatibilität interessante Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere zu ersetzen. Diese Form der Typeinschränkung ergibt sich auf natürliche Weise, wenn man sich den Zusammenhang von Extensionen von definierten Typen und solchen, die in Typdefinitionen vorkommen, ansieht.'},
     {'question': 'Was ist das Ziel der Typerweiterung ?', 'answer': 'Das Ziel der Typerweiterung ist die Vereinigung von Typerweiterung und Typeinschränkung zu einer Beziehung zwischen Typen, nicht die Schaffung zweier Komplementäre.'},
     {'question': 'Was ist Zuweisungskompatibilität?', 'answer': 'Die Zuweisungskompatibilität ist eine Regel, die bestimmt, ob ein Wert einer Variablen zugewiesen werden kann. Wenn der Typ des Werts mit dem Typ der Variablen kompatibel ist, ist die Zuweisungskompatibilität gegeben.'},
     {'question': 'Was ist die Typkonformität?', 'answer': 'Die Typkonformität ist eine Regel, die bestimmt, ob ein Typ in eine Typerweiterung übergehen kann. Wenn der Typ des Werts mit dem Typ der Variablen kompatibel ist, ist die Typkonformität gegeben.'},
     {'question': 'Was ist die Funktion von Typen in der objektorientierten Programmierung?', 'answer': 'Typen dienen in der objektorientierten Programmierung nicht nur dazu, Objekte zu klassifizieren, sondern auch dazu, das Implementationsgeheimnis der Klassen zu wahren und die Einhaltung der Schnittstellen durch den Compiler zu gewährleisten. Diese Funktion von Typen wurde mit der Programmiersprache Java und ihrem Interface-als-Typ-Konzept weiterentwickelt, was zur interfacebasierten Programmierung führte.'},
     {'question': 'Was ist die Auswirkung der Typeinschränkung auf die Zuweisungskompatibilität?', 'answer': 'Die Typeinschränkung hebelt die Zuweisungskompatibilität aus, was bedeutet, dass die Zuweisung von Werten mit unverträglichen Typen nicht mehr möglich ist.'},
     {'question': 'Was ist eine Deklaration in der Programmierung?', 'answer': 'Eine Deklaration in Programmierung ist ein Vorgang, bei dem man Programmelemente, wie Variablen oder Funktionen, vor der ersten Verwendung bekannt gibt. Dabei wird der Bezeichner dem Compiler bekannt gegeben, damit er ihn in der Folge wiedererkennen und mit der Deklaration in Verbindung bringen kann.'},
     {'question': 'Was sind formale Parameter in SMALLTALK?', 'answer': 'Formale Parameter sind Variablen, die in der Deklaration einer Methode angegeben werden und Werte entgegennehmen, die bei einem Methodenaufruf übergeben werden.'},
     {'question': 'Was ist die Bedingung für eine zulässige Zuweisung bei unterschiedlichen Typen?', 'answer': 'Damit eine Zuweisung b an a, bei der sich die Typen von a und b unterscheiden, zulässig ist, muss die Extension des Typs von b eine Teilmenge der Extension des Typs von a sein.'},
     {'question': 'Was ist eine Filterfunktion von Typen?', 'answer': 'Eine Filterfunktion von Typen ist eine Funktion, die neben der formalen Funktion, Fehler zu vermeiden, auch eine inhaltliche Funktion erfüllt. Sie setzt voraus, dass dem Typ eine Bedeutung beigemessen wird, die über seine bloße Struktur hinausgeht. Diese Bedeutung wird heute hauptsächlich durch die Benennung des Typs vermittelt. Die Namensäquivalenz als Bedingung der Zuweisungskompatibilität verlangt, dass einer Variablen nur Werte gleicher Bedeutung zugewiesen werden können. Die Filterfunktion drückt also eher eine Absicht der Programmiererin aus als eine technische Notwendigkeit.'},
     {'question': 'Was ist eine Schnittstelle in Bezug auf eine Klasse?', 'answer': 'Eine Schnittstelle in Bezug auf eine Klasse ist das Verbergen der Implementierung und das Nach-außen-Treten der Elemente einer Klassendefinition, die für Benutzer einer Klasse zur Verwendung gedacht sind. Dieses Prinzip wird auch als Geheimnisprinzip bezeichnet.'},
     {'question': 'Was sind Zugriffsmodifikatoren?', 'answer': 'Zugriffsmodifikatoren sind spezielle Schlüsselwörter in Programmiersprachen wie Java und C++, die einem Element einer Klassendefinition vorangestellt werden, um dessen Zugreifbarkeit festzulegen. Sie legen gemeinsam mit der Klassendefinition, die die vollständige Implementierung beinhaltet, auch die Schnittstelle der Klasse fest.'},
     {'question': 'Was ist eine absolut spezifizierte Schnittstelle einer Klasse?', 'answer': 'Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nur aus Deklarationen von Methoden und enthält keine Instanzvariablen.'},
     {'question': 'Was ist strukturelle Typkonformität?', 'answer': 'Strukturelle Typkonformität bedeutet, dass der konforme Typ alle Elemente des Typs, zu dem er konform sein soll, enthält.'},
     {'question': 'Was ist namensgebundene Typkonformität?', 'answer': 'Namensgebundene Typkonformität bedeutet, dass der konforme Typ nicht nur die Elemente des Typs, zu dem er konform sein soll, enthält, sondern dass er auch ausdrücklich als konform zu diesem Typ erklärt wurde.'},
     {'question': 'Was ist statische Typisierung?', 'answer': 'Statische Typisierung ist eine Eigenschaft von Sprachen, die die'},
     {'question': 'Was ist Zuweisungskompatibilität unter Typerweiterung?', 'answer': 'Zuweisungskompatibilität unter Typerweiterung bezieht sich auf die Möglichkeit, Werte verschiedener Typen einander zuzuweisen, wenn der Zieltyp eine Erweiterung des Quelltyps ist. Funktionsaufrufe sind Anweisungen, die eine Funktion mit bestimmten Argumenten aufrufen. Wenn eine Funktion aufgerufen wird, werden implizite Zuweisungen durchgeführt, bei denen die Typen der Argumente mit den Parametern der Funktion kompatibel sein müssen. Diese Zuweisungskompatibilität spielt auch bei Funktionsaufrufen eine wichtige Rolle.'},
     {'question': 'Was sind implizite Zuweisungen?', 'answer': 'Implizite Zuweisungen treten bei Funktionsaufrufen auf, bei denen die Funktion eine Kopie des Objekts erhält, auf das die Funktionsargument-Variable verweist.'},
     {'question': 'Was sind Funktionsaufrufe?', 'answer': 'Funktionsaufrufe sind Anweisungen, die eine Funktion aufrufen und deren Ergebnis berechnen. Sie werden verwendet, um Werte zu berechnen, Objekte zu manipulieren oder die Kontrolle in einem Programm zu übertragen.'},
     {'question': 'Was ist Typerweiterung?', 'answer': 'Typerweiterung ist ein Konzept in der objektorientierten Programmierung, bei dem eine Unterklasse eine Oberklasse erweitert, indem sie neue Attribute und Methoden hinzufügt oder bestehende Methoden überschreibt.'},
     {'question': 'Was ist Typäquivalenz?', 'answer': 'Typäquivalenz bedeutet, dass sich zwei verschiedene Typdefinitionen bis auf ihre Namen gleichen, dass also z. B. in STRONGTALK die Mengen der Methodensignaturen, die die Typdefinitionen ausmachen, gleich sind.'},
     {'question': 'Was ist die Voraussetzung für die Zuweisungskompatibilität von zwei Typen?', 'answer': 'Die Voraussetzung für die Zuweisungskompatibilität von zwei Typen ist, dass sie identisch sind oder eine Typäquivalenz aufweisen, d.h. sich die Typdefinitionen bis auf ihre Namen gleichen.'},
     {'question': 'Was bedeutet die Transitivität der Typäquivalenz?', 'answer': 'Die Transitivität der Typäquivalenz bedeutet, dass wenn ein Typ A äquivalent zu einem Typ B ist und Typ B wiederum äquivalent zu einem Typ C ist, dann ist auch Typ A äquivalent zu Typ C. Diese Eigenschaft ist wichtig, um sicherzustellen, dass die Typäquivalenz konsistent ist und dass die Typisierung von Ausdrücken und Variablen in einem Programm konsistent bleibt.'},
     {'question': 'Was ist strukturelle Typäquivalenz?', 'answer': 'Strukturelle Typäquivalenz ist ein Verfahren, um festzustellen, ob zwei Typen gleich sind. Dabei werden die Definitionen der beteiligten Typen rekursiv expandiert, was bedeutet, dass in einer Typdefinition vorkommende Namen anderer Typen durch ihre Struktur ersetzt werden.'},
     {'question': 'Was ist Strukturäquivalenz?', 'answer': 'Strukturäquivalenz ist eine Bedingung der Zuweisungskompatibilität, die ausreicht, um Typfehler zu verhindern. Sie garantiert, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten durchgeführt werden können.'},
     {'question': 'Was ist Type branding?', 'answer': 'Type branding ist eine Technik, bei der jedem Typ eine für ihn charakteristische Methode exklusiv zugeordnet wird, sodass er mit keinem anderen mehr strukturäquivalent ist. Diese Technik wird gelegentlich in Sprachen mit Strukturäquivalenz angewendet, um semantische Fehler durch das Zuweisen von Objekten über Typgrenzen hinweg zu vermeiden.'},
     {'question': 'Was ist die Bedingung für Typkompatibilität bei Zuweisungen in SMALLTALK?', 'answer': 'Für Typkompatibilität bei Zuweisungen in SMALLTALK reicht es aus, dass der Typ der rechten Seite einer Zuweisung das Protokoll (die Menge der Methoden) des Typs der linken Seite enthält. Der Typ auf der rechten Seite einer Zuweisung darf also eine Erweiterung dessen auf der linken Seite um zusätzliche Methoden sein.'},
     {'question': 'Was ist ein erweiternder Typ?', 'answer': 'Ein erweiternder Typ, auch Untertyp genannt, ist eine Typdefinition, die auf einer bestehenden Typdefinition aufbaut und diese erweitert. Die Methodendeklarationen des erweiterten Typs werden dabei vererbt und müssen nicht noch einmal wiederholt werden.'},
     {'question': 'Was sind Protokolle?', 'answer': 'Protokolle sind eine Art von Typdefinition, die die Methoden und Eigenschaften beschreiben, die ein Objekt haben muss, um eine bestimmte Rolle zu erfüllen. Variablen spielen in Protokollen eine Rolle, indem sie als formale Parameter in Methoden auftauchen und als Typen für die Ein- und Ausgabeobjekte spezifiziert werden.'},
     {'question': 'Was ist die Protokollbildung in STRONGTALK?', 'answer': 'In STRONGTALK ist die Protokollbildung der einzige Typkonstruktor, mit dem man neue Typen definieren kann.'},
     {'question': 'Was ist der einzige Typkonstruktor in STRONGTALK?', 'answer': 'In STRONGTALK ist die Protokollbildung der einzige Typkonstruktor.'},
     {'question': 'Was ist die Typisierung von Variablen ?', 'answer': 'Die Typisierung von Variablen ist ein Konzept, bei dem jede Variable nur die Werte haben kann, für die sie vorgesehen ist. Sie wird erreicht, indem jeder Variablen ein Typ zugeordnet wird, und indem auch jedes Objekt sowie jeder Ausdruck, der für einen Wert oder ein Objekt steht, einen Typ hat. Dies geschieht durch Variablendeklarationen, die Zuordnung von Typen zu Literalen, die Instanziierung von Klassen und die Deklaration von Methoden, die angeben muss, welchen Typs die Objekte sind, die sie liefert.'},
     {'question': 'Was ist Zuweisungskompatibilität unter Subtyping?', 'answer': 'Zuweisungskompatibilität unter Subtyping erlaubt die Zuweisung von Objekten eines Subtyps an Variablen eines Supertyps.'},
     {'question': 'Was ist ein Upcast in der Typumwandlung?', 'answer': 'Ein Upcast ist eine Typumwandlung von einem Typ zu einem Supertyp. Upcasts sind immer typsicher.'},
     {'question': 'Was ist der Zweck von Typumwandlungen?', 'answer': 'Typumwandlungen sind in der Programmierung entweder überflüssig oder unsicher. Wenn sie unverzichtbar sind, sollten sie mit einem Typtest abgesichert werden, um sicherzustellen, dass das Objekt, für das der typgewandelte Ausdruck steht, auch den gewünschten Typ hat.'},
     {'question': 'Was ist kovariante Redefinition?', 'answer': 'Kovariante Redefinition bezieht sich auf eine Situation, in der der Parametertyp einer Methode sich mit dem Empfängertyp ändert. Im Fall des rekursiv beschränkten parametrischen Polymorphismus wird der Parametertyp der Methode zu einem Subtyp des Empfängertyps, was keinen Widerspruch zur Kontravarianzregel des Subtyping darstellt.'},
     {'question': 'Was ist Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie?', 'answer': 'Kovariante Redefinition bei gleichzeitiger Inklusionspolymorphie ist eine Technik in der objektorientierten Programmierung, bei der ein Subtyp eine Methode seines Obertyps mit einem spezifischeren Rückgabetyp neu definieren kann, während er gleichzeitig die Liskov-Substitutionsprinzip einhält. Diese Technik kann jedoch nicht mit parametrischen Typen erreicht werden.'},
     {'question': 'Was ist Parametrisierung von Typen?', 'answer': 'Parametrisierung von Typen ist eine Möglichkeit, den Wertebereich eines Typs variabel zu halten, ohne die statische Typprüfung aufgeben zu müssen. Dabei wird der Typ mit einem oder mehreren anderen Typen parametrisiert.'},
     {'question': 'Was ist eine parametrische Typdefinition?', 'answer': 'Eine parametrische Typdefinition ist eine Art von Typdefinition, die Platzhalter für andere Typen verwendet, die durch Typparameter, auch Typvariablen genannt, vertreten werden. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt.'},
     {'question': 'Was sind formale Typparameter und tatsächliche Typparameter?', 'answer': 'Formale Typparameter sind die Typvariablen, die in parametrischen Typdefinitionen vorkommen. Tatsächliche Typparameter sind die konkreten Typen, die bei der Verwendung des Typs in Deklarationen in die formalen Parameter eingesetzt werden.'},
     {'question': 'Was ist der Zweck eines Typsystems?', 'answer': 'Der Zweck eines Typsystems besteht darin, das Auftreten von Ausführungsfehlern während der Programmausführung zu verhindern.'},
     {'question': 'Was ist Typsicherheit?', 'answer': 'Typsicherheit ist die Eigenschaft einer Programmiersprache, die das Fehlen bestimmter Ausführungsfehler in allen Programmläufen gewährleistet.'},
     {'question': 'Was sind rekursive Typen?', 'answer': 'Rekursive Typen sind Typen, die sich in ihrer Definition selbst referenzieren. Sie sind ein wichtiges Instrument der Programmierung, um dynamische Strukturen wie verschachtelte Listen oder Bäume zu ermöglichen. Allerdings bringen sie auch Probleme mit sich, wie zum Beispiel die Feststellung der strukturellen Äquivalenz zweier rekursiver Typen, die aufgrund der notwendigen Expansion unendlich große Definitionen ergeben kann.'},
     {'question': 'Was ist das Problem bei der Verwendung von variablen Typen in einer parametrischen Typdefinition?', 'answer': 'Das Problem ist, dass der Typ eines Methodenarguments (eines formalen Parameters einer Methode) variabel sein soll, aber der Typ bereits definiert ist. Dies tritt auf, wenn man beispielsweise den Test auf Gleichheit so definieren möchte, dass das Objekt, das gleich sein soll, vom selben Typ sein muss wie das Objekt, mit dem man Gleichheit feststellen möchte.'},
     {'question': 'Was ist ein parametrischer Typ?', 'answer': 'Ein parametrischer Typ ist ein Typ, der einen oder mehrere Typvariablen enthält, die bei der Instanziierung durch konkrete Typen ersetzt werden. Dies ermöglicht die Erstellung von generischen Klassen und Methoden, die für verschiedene Typen verwendet werden können.'},
     {'question': 'Was ist eine stilistische Figur in Bezug auf den formalen Typparameter T von Equatable?', 'answer': 'Eine stilistische Figur in Bezug auf den formalen Typparameter T von Equatable ist die Beschränkung von T auf einen Subtyp von Equatable[T].'},
     {'question': 'Was ist Typerweiterung als Basis des Subtyping?', 'answer': 'Typerweiterung als Basis des Subtyping bedeutet, dass ein neuer Typ, der ein Supertyp ist, zusätzliche Eigenschaften und Methoden enthalten kann, aber die Eigenschaften und Methoden des Supertyps haben muss. Dadurch sind Typfehler ausgeschlossen, und es bleibt lediglich das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind.'},
     {'question': 'Was ist Typerweiterung und warum bereitet sie keine technischen Probleme?', 'answer': 'Typerweiterung ist eine Möglichkeit, eine neue Unterklasse von einer bestehenden Klasse abzuleiten, indem neue Attribute und Methoden hinzugefügt werden. Es bereitet keine technischen Probleme, weil es keine Typfehler verursacht, da die Unterklasse alle Merkmale der Oberklasse erbt und zusätzliche Merkmale hinzufügen kann. Das semantische Problem, dass Werte eines Subtyps inhaltlich keine Werte des Supertyps sind, kann nicht immer vermieden werden, aber es ist kein technisches Problem.'},
     {'question': 'Welche Bedingungen müssen an die Parametertypen bei der Redefinition einer Methode gestellt werden, um eine Verletzung einer Typinvariante zu vermeiden?', 'answer': 'Die Typinvariante muss für den neuen Parametertyp und den alten Parametertyp gelten, d.h. der neue Parametertyp muss eine Unterklasse des alten Parametertyps sein.'},
     {'question': 'Was ist Kontravarianz und Kovarianz?', 'answer': 'Kontravarianz und Kovarianz sind zwei Begriffe, die die Richtung der Variation von Parametern bei der Redefinition von Methoden beschreiben. Kontravarianz bezieht sich auf die Eingabeparameter, die gegenläufig zum Empfängertyp variieren, während Kovarianz sich auf den Ausgabeparameter bezieht, der gleichgerichtet zum Empfängertyp variiert.'},
     {'question': 'Was ist das Problem bei der Gegenläufigkeit der Veränderung von Parameter- und Ergebnistypen beim Redefinieren?', 'answer': 'Das Problem ist, dass wenn das Eingabe-Objekt und das Ausgabe-Objekt identisch sind, nicht einmal (bei der Eingabe) ein Supertyp und einmal (bei der Ausgabe) ein Subtyp zugedacht werden kann, da der Subtyp mehr Eigenschaften verlangt als der Supertyp garantiert.'},
     {'question': 'Was ist Novarianz?', 'answer': 'Novarianz ist die Unveränderlichkeit der Parametertypen in einem Programm.'},
     {'question': 'Was ist die Kontravarianzregel für Parametertypen?', 'answer': 'Die Kontravarianzregel für Parametertypen ist eine Regel in der objektorientierten Programmierung, die besagt, dass ein Untertyp eines Parametertyps als Argument für eine Methode verwendet werden kann, die den Obertyp des Parametertyps erwartet. Diese Regel wird infrage gestellt, weil sie in der Realität (der Interpretation oder Semantik) keine Bedeutung hat, aber in der Programmierpraxis nicht benötigt wird.'},
     {'question': 'Was ist Inklusionspolymorphie?', 'answer': 'Inklusionspolymorphie, auch bekannt als Subtyping oder Subtyp-Polymorphie, ist eine Form der Polymorphie, bei der ein Objekt eines Untertyps an einer Stelle verwendet werden kann, an der ein Objekt des Supertyps erwartet wird. Das bedeutet, dass eine Collection, die Objekte eines bestimmten Typs enthält, auch Objekte eines Untertyps dieses Typs enthalten kann.'},
     {'question': 'Was ist eine Sicherheitslücke in der statischen Typprüfung, die durch die Inklusionspolymorphie entsteht?', 'answer': 'Die Sicherheitslücke in der statischen Typprüfung, die durch die Inklusionspolymorphie entsteht, ist, dass der Compiler nicht oder nur sehr aufwendig feststellen kann, ob das Ergebnis von p kinder at: 1 vom Typ Object in eine Methode kinder von Typ Person umgewandelt werden kann.'},
     {'question': 'Was sieht die Typsicherheit bei der Verwendung von parametrischem Polymorphismus aus?', 'answer': 'Die erhöhte Typsicherheit außerhalb der Typdefinition bedeutet, dass die Verwendung des parametrischen Typs sicherer ist, da er nur mit Typen von addierbaren Objekten instanziiert wird. Die verminderte Typsicherheit innerhalb der Typdefinition bedeutet, dass die Definition des parametrischen Typs nicht wissen kann, wie er hinterher verwendet wird, und daher bei der Addition auf die Verwendung von addierbaren Objekten angewiesen ist.'},
     {'question': 'Was ist der beschränkte parametrische Polymorphismus?', 'answer': 'Der beschränkte parametrische Polymorphismus ist eine Technik, die es ermöglicht, Typen zu verwenden, die bestimmte Eigenschaften haben. Dadurch kann ein Typfehler bereits an der Stelle moniert werden, an der die unzulässige Wertzuweisung an die Typvariable stattfindet, anstatt erst später im Programm.'},
     {'question': 'Welches Problem möchte man mit dem beschränkten parametrischen Polymorphismus lösen?', 'answer': 'Mit dem beschränkten parametrischen Polymorphismus möchte man sicherstellen, dass die Typvariable innerhalb der mit ihr parametrisierten Typdefinition selbst wertbeschränkt ist und nur bestimmte, benötigte Protokolle für die als Werte zulässigen Typen erlaubt.'},
     {'question': 'Welche Formen der Typeinschränkung gibt es?', 'answer': 'Eine Form der Typeinschränkung besteht darin, einen Typ auf Basis eines anderen Typs zu definieren, indem man Eigenschaften (Methoden) entfernt. Diese Form führt jedoch nicht zur Zuweisungskompatibilität und wird in vielen Sprachen nicht unterstützt. Eine interessantere Form der Typeinschränkung besteht darin, die verwendeten Typen einer Typdefinition durch andere, speziellere Typen zu ersetzen, ohne Eigenschaften zu löschen.'},
     {'question': 'Was ist ein Beispiel für eine parametrische Definition einer Collection?', 'answer': 'Ein Beispiel für eine parametrische Definition einer Collection ist Dictionary, bei dem nicht nur der Elementtyp, sondern auch der Schlüsseltyp variabel gehalten werden sollte.'},
     {'question': 'Welche inhaltliche Funktionen können Typen neben ihrer formalen Rolle erfüllen?', 'answer': 'Typen können in der Programmierung neben ihrer formalen Rolle, Fehler zu vermeiden, auch eine inhaltliche Funktion erfüllen. Diese inhaltliche Funktion wird vor allem durch die Benennung des Typs hergestellt, gepaart mit der Namensäquivalenz als Bedingung der Zuweisungskompatibilität. Sie verlangt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können.'},
     {'question': 'Welche Rolle spielen Zugriffsmodifikatoren in Programmiersprachen wie Java und C++ bei der Festlegung der Schnittstelle einer Klasse?', 'answer': 'Zugriffsmodifikatoren legen fest, welche Elemente einer Klassendefinition für Benutzer sichtbar sind und somit die Schnittstelle der Klasse beeinflussen. Sie regeln die Zugriffsberechtigungen auf Methoden und Instanzvariablen.'},
     {'question': 'Was ist nominales Subtyping?', 'answer': 'Nominales Subtyping bedeutet, dass ein Subtyp explizit aus einem namentlich erwähnten Supertyp abgeleitet sein muss, um als sein Subtyp zu gelten. In diesem Fall ist die Namensähnlichkeit entscheidend.'},
     {'question': 'Was ist strukturelles Subtyping?', 'answer': 'Strukturelles Subtyping liegt vor, wenn ein Typ die allgemeine Definition eines Subtyps erfüllt, unabhängig von seiner expliziten Nennung als Supertyp. Hier ist die Struktur und das Verhalten des Typs entscheidend, nicht seine explizite Nennung als Supertyp.'},
     {'question': 'Welches der beiden Subtyping-Modelle, nominales Subtyping und strukturelles Subtyping, impliziert das andere?', 'answer': 'Nominales Subtyping impliziert strukturelles Subtyping. Das bedeutet, wenn ein Subtyp nominal als Supertyp erwähnt wird, erfüllt er automatisch auch die strukturellen Kriterien eines Subtyps.'},
     {'question': 'Welche Bedeutung hat die Typkonformität in Bezug auf die Zuweisungskompatibilität?', 'answer': 'Typkonformität ist in vielen Sprachen eine notwendige Voraussetzung für die Zuweisungskompatibilität. Das bedeutet, dass ein Objekt eines typkonformen Typs einer Variable eines anderen, typgleichen Typs zugewiesen werden darf.'},
     {'question': 'Welche beiden Varianten der Typkonformität gibt es, und wie unterscheiden sie sich?', 'answer': 'Es gibt strukturelle Typkonformität und nominale Typkonformität. Bei struktureller Typkonformität müssen alle Elemente des konformen Typs im konformen Typ enthalten sein. Bei nominaler Typkonformität muss zusätzlich die Erweiterung eines anderen Typs explizit angegeben werden.'},
     {'question': 'Welche Vorteile bietet nominale Typkonformität gegenüber struktureller Typkonformität?', 'answer': 'Nominale Typkonformität bietet die Vorteile der Zuweisungskompatibilität und Abwesenheit von Typfehlern. Sie dient auch als Filterfunktion, da nur Objekte von solchen Typen Variablen zugewiesen werden können, für die die Programmiererin dies aus semantischen Überlegungen heraus ausdrücklich vorgesehen hat.'},
     {'question': 'Welche Arten von Typäquivalenz gibt es, und wie unterscheiden sie sich?', 'answer': 'Es gibt zwei Arten von Typäquivalenz: die nominale (Namensäquivalenz) und die strukturelle (Strukturäquivalenz) Typäquivalenz. Die nominale Typäquivalenz erfordert, dass zwei Deklarationen denselben Typnamen angeben, um Zuweisungskompatibilität zu haben. Die strukturelle Typäquivalenz hingegen erfordert nur, dass die Typen paarweise gleich definiert sind, unabhängig von ihren Namen.'},
     {'question': 'Welche Eigenschaften gelten für die Typäquivalenz?', 'answer': 'Die Typäquivalenz ist reflexiv, was bedeutet, dass jeder Typ zu sich selbst äquivalent ist. Sie ist auch transitiv, was bedeutet, dass wenn A äquivalent zu B ist und B äquivalent zu C ist, dann ist auch A äquivalent zu C.'},
     {'question': 'Was sind Bezeichner in der Programmierung, und wie werden sie verwendet?', 'answer': 'Bezeichner sind Namen, die in der Programmierung frei vergeben werden können. Sie werden verwendet, um Programmelemente zu identifizieren und auf sie zu verweisen, beispielsweise Variablen oder Methoden.'},
     {'question': 'Was ist der Zweck der Deklaration von Programmelementen?', 'answer': 'Die Deklaration von Programmelementen dient dazu, dem Compiler den Bezeichner bekanntzugeben, damit er ihn in der Folge wiedererkennen und mit der entsprechenden Definition in Verbindung bringen kann.'},
     {'question': 'Welche Probleme können in untypisierten Sprachen auftreten?', 'answer': 'In untypisierten Sprachen, in denen Variablen ohne Angabe eines Typs deklariert werden, kann es zu Problemen führen, da Variablen quasi implizit deklariert werden, wenn sie zum ersten Mal verwendet werden. Dies kann zu Schreibfehlern führen, bei denen versehentlich zwei Variablen mit dem gleichen Namen erstellt werden, die jedoch nichts miteinander zu tun haben. Dies erhöht das Risiko von Programmierfehlern.'},
     {'question': 'Welche Rolle spielt Typinformation zur Laufzeit eines Programms?', 'answer': 'Typinformation beeinflusst die Ausführung eines laufenden Programms, indem sie das Programm bei Verletzung einer Invariante durch einen dynamischen Typtest abbricht.'},
     {'question': 'Was ist eine Typumwandlung?', 'answer': 'Eine Typumwandlung (type cast) ist ein Verfahren, bei dem der vorgefundene Typ eines Ausdrucks (einer Variable oder eines Methodenaufrufs) in einen vorgegebenen Typ konvertiert wird. Dies geschieht, um dem Compiler oder Type Checker mitzuteilen, dass der Ausdruck den angegebenen Typ hat, auch wenn dies nicht automatisch sichergestellt ist.'},
     {'question': 'Welche Richtungen von Typumwandlungen gibt es?', 'answer': 'Typumwandlungen können in verschiedene Richtungen erfolgen: zu Supertypen (Upcast), zu Subtypen (Downcast) oder zu Typen, die weder Supertyp noch Subtyp des Ausgangstyps sind (Crosscast).'},
     {'question': 'Was ist das Kovarianzproblem im Zusammenhang mit parametrischem Polymorphismus?', 'answer': 'Das Kovarianzproblem im Zusammenhang mit parametrischem Polymorphismus bezieht sich darauf, wie Eingabeparameter in Methoden kovariant, also flexibel, in Bezug auf ihren Typ angepasst werden können.'},
     {'question': 'Was ist die Idee des parametrischen Polymorphismus?', 'answer': 'Die Idee des parametrischen Polymorphismus besteht darin, aus einer Typdefinition durch Parametrisierung viele verschiedene Typen zu generieren, je nachdem, welche konkreten Typen als Typparameter verwendet werden.'},
     {'question': 'Was sind Typen, die sich ausschließlich auf sich selbst beziehen?', 'answer': 'Typen, die sich ausschließlich auf sich selbst beziehen, sind solche, deren Bedeutung nicht von anderen Typen abhängt. Ein Beispiel dafür ist der Typ "Boolean". Sie können Bedeutung erhalten, indem sie auf bekannte externe Formalismen abgebildet werden, wie die boolesche Algebra.'},
     {'question': 'Was ist eine denotationale Semantik in Bezug auf Typisierung?', 'answer': 'Eine denotationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf bekannte externe Formalismen abgebildet werden. Dies kann beispielsweise bedeuten, dass die Operationen eines Typs auf mathematische oder logische Konzepte abgebildet werden, die in der Programmierung verwendet werden.'},
     {'question': 'Was ist eine operationale Semantik in Bezug auf Typisierung?', 'answer': 'Eine operationale Semantik ist eine Möglichkeit, Typen eine Bedeutung zuzuweisen, indem sie auf Anweisungen einer (gedachten oder realen) Maschine abgebildet werden. Dies bedeutet, dass die Operationen eines Typs auf die Ausführung von Maschinenbefehlen oder anderen niedrigstufigen Operationen abgebildet werden.'},
     {'question': 'Welches Problem ergibt sich bei der strukturellen Äquivalenz von rekursiven Typen?', 'answer': 'Das Problem bei der strukturellen Äquivalenz von rekursiven Typen besteht darin, dass die Expansion rekursiver Typen unendlich große Definitionen ergeben kann, was die Feststellung der strukturellen Äquivalenz erschwert.'},
     {'question': 'Was ist Kovarianz und Kontravarianz bei Methodenaufrufen im Zusammenhang mit Subtyping?', 'answer': 'Bei Methodenaufrufen und Subtyping unterscheidet man zwischen Kovarianz und Kontravarianz. Kovarianz bezieht sich auf die Veränderung von Rückgabetypen, während Kontravarianz die Veränderung von Parametertypen beschreibt.'},
     {'question': 'Was ist Kovarianz?', 'answer': 'Kovarianz tritt auf, wenn der Rückgabetyp einer Methode in einem Subtyp ein Subtyp des Rückgabetyps in einem Supertyp ist. Dies bedeutet, dass der Subtyp mehr Werte zurückgeben kann als der Supertyp.'},
     {'question': 'Was ist Kontravarianz?', 'answer': 'Kontravarianz tritt auf, wenn die Parametertypen einer Methode in einem Subtyp Supertypen der Parametertypen in einem Supertyp sind. Dies bedeutet, dass der Subtyp Eingabeparameter akzeptiert, die allgemeiner sind als die des Supertyps.'},
     {'question': 'Welcher konkrete Typ tritt an die Stelle einer Typvariable bei der Verwendung von Inklusionspolymorphie?', 'answer': 'Bei der Verwendung von Inklusionspolymorphie tritt der konkrete Typ "Object" an die Stelle der Typvariable E.'},
     {'question': 'Welche Art von Typfehler kann auftreten, wenn Inklusionspolymorphie verwendet wird?', 'answer': 'Ein Typfehler kann auftreten, wenn Methoden auf Objekten eines konkreten Subtyps von "Object" aufgerufen werden, da die statische Typprüfung solche Methoden nicht unterstützt.'},
     {'question': 'Welchen Vorteil bietet der parametrische Polymorphismus gegenüber der Inklusionspolymorphie?', 'answer': 'Der parametrische Polymorphismus bietet den Vorteil einer erhöhten Typsicherheit, da Typfehler bereits zur Instanziierung des parametrischen Typs erkannt werden können.'},
     {'question': 'Welchen Kompromiss geht man bei der Verwendung parametrischen Typen ein?', 'answer': 'Bei der Verwendung parametrischer Typen geht man einen Kompromiss ein, bei dem die erhöhte Typsicherheit außerhalb der Typdefinition durch eine geringere Typsicherheit innerhalb der Typdefinition erkauft wird.'},
     {'question': 'Welche Art von Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen?', 'answer': 'Der beschränkte parametrische Polymorphismus erlaubt die Sicherstellung von bestimmten Eigenschaften für eingesetzte Typen, um Typfehler frühzeitig zu erkennen.'},
     {'question': 'Was ist ein Typ in der Programmierung?', 'answer': 'Ein Typ in der Programmierung schränkt die möglichen Werte eines deklarierten Elements (z. B. einer Variable) ein. Ein Typ hat eine Intension (Definition) und eine Extension (Wertebereich), wobei er eine Menge von Elementen (Objekten) umfasst, die zu diesem Typ gehören. Typen sind die Grundlage von Typsystemen.'},
     {'question': 'Welche Gründe gibt es, Variablen und andere Programmelemente zu typisieren?', 'answer': 'Es gibt mindestens vier gute Gründe für die Typisierung von Variablen und anderen Programmelementen: Typisierung regelt das Speicher-Layout. Typisierung erlaubt die effizientere Ausführung eines Programms. Typisierung erhöht die Lesbarkeit eines Programms. Typisierung ermöglicht das automatische Finden von logischen Fehlern in einem Programm.'},
     {'question': 'Was ist der Zweck der Typisierung in Programmiersprachen?', 'answer': 'Der Zweck der Typisierung in Programmiersprachen ist es, den möglichen Wertebereich von Variablen und anderen Programmelementen einzuschränken. So lassen sich beispielsweise in einer Variable vom Typ Boolean nur Wahrheitswerte, in einer vom Typ String nur Zeichenketten speichern.'},
     {'question': 'Was ist ein Typsystem?', 'answer': 'Ein Typsystem umfasst Typausdrücke, Objekt- oder Wertausdrücke, Regeln, die Wertausdrücken Typen zuordnen, und Regeln, die von Wertausdrücken einzuhalten sind(zusammen die Typregeln).'},
     {'question': 'Was sind Gründe für die Verwendung von Typsystemen?', 'answer': 'Ein Grund für die Verwendung von Typsystemen ist die dadurch entstehende Modularisierung von Programmen, nämlich wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt.'},
     {'question': 'Was ist der Zweck von Typsystemen für die Fehlerentdeckung?', 'answer': 'Typsysteme in der Fehlerentdeckung zielen darauf ab, einen Teil logischer Programmierfehler frühzeitig zu erkennen, indem sie Variablen daran hindern, Werte anzunehmen, die sie eigentlich nicht haben dürften. Dies hilft, Fehler zu vermeiden, die erst zur Laufzeit auftreten und in der Regel einen Programmabbruch verursachen. Diese Art von Fehlern werden als Typfehler bezeichnet.'},
     {'question': 'Was ist ein logischer Fehler in einem Programm?', 'answer': 'Ein logischer Fehler in einem Programm ist ein Fehler, bei dem das Programm zwar fehlerfrei läuft, aber das Ergebnis falsch ist. Im Gegensatz zu einem Programmabbruch, der auf einen Programmierfehler hinweist, bleibt ein logischer Fehler oft unbemerkt.'},
     {'question': 'Was sind die Folgen eines logischen Fehlers in einem Programm?', 'answer': 'Ein logischer Fehler in einem Programm kann dazu führen, dass das Programm weiterläuft, aber das Ergebnis falsch ist. Es ist schwieriger zu erkennen als ein Programmabbruch, da keine erkennbare Reaktion auf einen Programmierfehler stattfindet.'},
     {'question': 'Was sind Typinvarianten?', 'answer': 'Typinvarianten sind eine Möglichkeit, Variablenfehlbelegungen zu verhindern. Sie beschränken die Menge der zulässigen Werte einer Variablen. In typisierten Programmiersprachen erfolgt die Typannotation explizit und zwingend bei der Variablendeklaration. In nicht oder nur optional typisierten Sprachen kann sie auch hergeleitet (inferiert) werden.'},
     {'question': 'Was sind Typannotationen?', 'answer': 'Typannotationen sind eine Möglichkeit, Variablen mit expliziten Typinvarianten zu versehen, die die Menge ihrer zulässigen Werte beschränken. Sie werden in typisierten Programmiersprachen explizit und zwingend bei der Variablendeklaration angegeben, während sie in nicht oder nur optional typisierten Sprachen hergeleitet und implizit sein können.'},
     {'question': 'Was sind semantische Fehler in einem Programm?', 'answer': 'Semantische Fehler in einem Programm sind logische Fehler, die sich in unzulässigen Wertzuweisungen ausdrücken. Sie entstehen, wenn die tatsächliche Verwendung eines Programmelements nicht seiner intendierten Bedeutung entspricht, die im Typ des Programmelements spezifiziert ist.'},
     {'question': 'Was ist der einzige Weg, eine mit der Typisierung einer Variablen ausgedrückte Invariante zu verletzen?', 'answer': 'Der einzige Weg, eine mit der Typisierung einer Variablen ausgedrückte Invariante zu verletzen, ist per Wertzuweisung an die Variable.'},
     {'question': 'Was ist eine Invariante?', 'answer': 'Eine Invariante ist eine Bedingung, die während der Ausführung eines Programms immer erfüllt sein muss. Im gegebenen Beispiel ist die Invariante von i, dass die Werte immer vom Typ Integer sein müssen und somit nicht vom Typ String sein dürfen.'},
     {'question': 'Was ist dynamische Typprüfung?', 'answer': 'Dynamische Typprüfung ist eine Methode zur Gewährleistung von Typkorrektheit, bei der zur Laufzeit vor einer Variablenzuweisung geprüft wird, ob der zuzuweisende Wert den von der Variablen geforderten Typ hat. Der Nachteil ist, dass diese Prüfung zu spät kommt und häufig nur zu einem Programmabbruch führt.'},
     {'question': 'Was ist dynamische Typisierung?', 'answer': 'Dynamische Typisierung ist die Tatsache, dass der Typ eines Objekts zur Laufzeit bekannt ist. Im Gegensatz zur statischen Typisierung, bei der der Typ zur Übersetzungszeit bekannt ist.'},
     {'question': 'Was ist statische Typprüfung?', 'answer': 'Die statische Typprüfung ist ein Verfahren, bei dem die Typkorrektheit eines Programms bereits während der Übersetzungszeit geprüft wird. Im Gegensatz zur dynamischen Typprüfung, die zur Laufzeit erfolgt, wird bei der statischen Typprüfung der Beweis erbracht, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird.'},
     {'question': 'Was ist ein ausdruckskräftiges Typsystem?', 'answer': 'Ein ausdruckskräftiges Typsystem ist ein Typsystem, das in einer Typannotation mehr Informationen unterbringen und damit mehr Typfehler aufdecken kann. Allerdings steigt mit der Ausdruckskraft auch die Komplexität des Typsystems und damit die Wahrscheinlichkeit, dass eine aufwändige Typprüfung notwendig ist. Besonders anspruchsvolle Typsysteme können außerdem die Gestaltung von Schnittstellen erschweren, so dass die beteiligten Programme nicht ohne weiteres zusammenarbeiten können.'},
     ],
    [{'question': 'Wie wird der Typ einer parametrischen Typdefinition konkretisiert?', 'answer': 'Die Typdefinition wird durch Instanziierung der parametrischen Typdefinition mit einem konkreten Typen konkretisiert. Dieser Vorgang ergibt sich automatisch und muss nicht explizit hingeschrieben werden.'},
     {'question': 'Wie oft kann eine parametrische Typdefinition in einem Programm verwendet werden?', 'answer': 'Eine parametrische Typdefinition kann in einem Programm beliebig oft verwendet werden.'},
     {'question': 'Wie hängt das Löschen von Eigenschaften (Methoden) mit der Typeinschränkung zusammen?', 'answer': 'Das Löschen von Eigenschaften (Methoden) kann als ein Spezialfall der Typeinschränkung verstanden werden, bei der der Wertebereich auf die leere Menge eingeschränkt wird. In diesem Fall wäre die Methode nicht mehr aufrufbar, da es kein typkorrektes Parameterobjekt gäbe, was einer Löschung gleichkäme.'},
     {'question': 'Wie kann man den Typ der in Beziehung stehenden Objekte bei der Deklaration von n-wertigen Attributen angeben?', 'answer': 'Man kann den Typ der in Beziehung stehenden Objekte bei der Deklaration von n-wertigen Attributen angeben, indem man die Collection-Klassen als Typen für die Zwischenobjekte verwendet.'},
     {'question': 'Wie wird Typkonformität in der Regel gehandhabt?', 'answer': 'In der objektorientierten Programmierung wird die Typkonformität in der Regel namensgebunden gehandhabt.'},
     {'question': 'Wann sind zwei Typen zuweisungskompatibel?', 'answer': 'Zwei Typen sind zuweisungskompatibel, wenn sie identisch sind oder wenn sie eine Typäquivalenz aufweisen, d.h. wenn sie bis auf ihre Namen gleich sind.'},
     {'question': 'Wie funktioniert Typerweiterung?', 'answer': 'Typerweiterung wird zum Beispiel durch die Definition neuer Module erreicht, die den ursprünglichen Datentyp erweitern, indem sie neue Methoden hinzufügen. Diese neuen Module können dann verwendet werden, um auf die erweiterten Funktionen des Datentyps zuzugreifen, ohne den ursprünglichen Code zu ändern.'},
     {'question': 'Wie wird ein Typ in SMALLTALK definiert?', 'answer': 'In SMALLTALK wird ein Typ durch das Protokoll definiert, das heißt, durch die Menge der Methoden, die ein Objekt versteht.'},
     {'question': 'Wie werden Typen in STRONGTALK definiert?', 'answer': 'In STRONGTALK werden Typen in tabellarischer Form definiert und mit einem Namen versehen. Die Typdefinition enthält keine Typdefinitionen, sondern Namen.'},
     {'question': 'Wann sind zwei Typen zuweisungskompatibel?', 'answer': 'Zwei Typen zuweisungskompatibel, wenn eine entsprechende Zuweisung zulässig ist, also zu keiner Verletzung einer Typinvariante führt.'},
     {'question': 'Wie werden Typen in SMALLTALK verwendet?', 'answer': 'In SMALLTALK werden keine Typen verwendet. Stattdessen findet man in SMALLTALK-Programmen manchmal Namen wie „aString“, „anInteger“ etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht.'},
     {'question': 'Wie werden Typen in Smalltalk definiert?', 'answer': 'In Smalltalk werden keine Typen verwendet, stattdessen findet man in Smalltalk-Programmen manchmal Namen wie "aString", "anInteger" etc. für formale Parameter, die nahelegen, dass der Wert einer Variable Instanz einer bestimmten Klasse sein soll. Überprüft wird das jedoch nicht.'},
     {'question': 'Wie können Typen in einer Programmiersprache mit Bedeutung versehen werden?', 'answer': 'Es gibt verschiedene Möglichkeiten, Typen in einer Programmiersprache mit Bedeutung zu versehen. Eine Möglichkeit ist, sie auf bekannte externe Formalismen abzubilden, wie beispielsweise die boolesche Algebra für den Typ Boolean. Eine andere Möglichkeit ist, einen Typ und seine Operationen auf Anweisungen einer Maschine abzubilden. Für von der Programmiererin definierte Typen kann die Bedeutung vom Compiler "induktiv über deren Aufbau" aus der Bedeutung von Typen abgeleitet werden, die eine vorgegebene Semantik haben. Diese Art der Semantik wird operationale Semantik genannt. Eine weitere Möglichkeit ist, Typen über abstrakte Datentypen zu definieren, die in der Programmiersprache syntaktisch als eine Menge von Operationen beschrieben werden, deren Operanden alle selbst typisiert sind.'},
     {'question': 'Wie kann man Rekursion in der Programmierung herstellen?', 'answer': 'Eine Möglichkeit, Rekursion in der Programmierung herzustellen, ist die Verwendung eines nicht parametrischen Typs als Subtyp eines parametrisierten Typs, wobei man den zu definierenden Typ gleichzeitig als tatsächlichen Typparameter einsetzt.'},
     {'question': 'Wie verändern sich die Eingabe- und Ausgabeparameter bei einer Methodenredefinition?', 'answer': 'Bei einer Methodenredefinition dürfen sich die Eingabeparameter nur zu einem Supertypen hin und die Ausgabeparameter nur zu einem Subtyp hin verändern, um die Typkorrektheit des Programms zu gewährleisten.'},
     {'question': 'Wie kann die Einschränkung von Ein- oder Rückgabetypen von Methoden die Zuweisungskompatibilität beeinflussen?', 'answer': 'Die Einschränkung von Ein- oder Rückgabetypen von Methoden kann die Zuweisungskompatibilität beeinflussen, indem sie sicherstellt, dass die Extension des eingeschränkten Typs eine Teilmenge der Extension des einschränkenden Typs ist. Dies kann dazu beitragen, die Typkorrektheit von Zuweisungen zu gewährleisten.'},
     {'question': 'Wie gewährleistet die Verwendung von Typen die Wahrung des Geheimnisprinzips und die Einhaltung von Schnittstellen?', 'answer': 'Die Verwendung von Typen stellt sicher, dass über Variablen nur auf die Elemente einer Klasse zugegriffen wird, die Teil der Schnittstelle sind. Dadurch wird das Geheimnisprinzip gewahrt, und die Einhaltung von Schnittstellen wird durch den Compiler sichergestellt.'},
     {'question': 'Wie verhält sich die Typkonformität in Bezug auf Reflexivität, Transitivität und Symmetrie?', 'answer': 'Typkonformität ist reflexiv, da jeder Typ konform zu sich selbst ist. Sie ist transitiv, sodass wenn Typ A konform zu Typ B ist und Typ B konform zu Typ C ist, dann ist auch Typ A konform zu Typ C. Im Gegensatz zur Typäquivalenz ist Typkonformität nicht symmetrisch. Es gilt jedoch meistens die Antisymmetrie, was bedeutet, dass wenn Typ B zu Typ A und Typ A zu Typ B konform ist, dann müssen A und B identisch sein.'},
     {'question': 'Wann sind zwei Typen zuweisungskompatibel?', 'answer': 'Zwei Typen sind zuweisungskompatibel, wenn sie identisch sind oder eine bestimmte Form der Typäquivalenz aufweisen.'},
     {'question': 'Wie verhält sich die Typäquivalenz in Bezug auf Symmetrie?', 'answer': 'Typäquivalenz ist eine symmetrische Eigenschaft, was bedeutet, dass wenn Typ A äquivalent zu Typ B ist, dann ist auch Typ B äquivalent zu Typ A.'},
     {'question': 'Was geschieht bei der Festlegung von Strukturäquivalenz?', 'answer': 'Bei der Feststellung von Strukturäquivalenz werden die Definitionen der beteiligten Typen rekursiv expandiert, wobei Namen anderer Typen durch ihre Struktur ersetzt werden. Diese Strukturäquivalenz ermöglicht es, Typen zu vergleichen, indem ihre Strukturen miteinander verglichen werden.'},
     {'question': 'Wie können Typen und Klassen in einem Sprachkonstrukt trotz unterschiedlicher Zwecke zusammengefasst werden?', 'answer': 'Obwohl Typen und Klassen unterschiedliche Zwecke haben, teilen sie sich strukturelle Ähnlichkeiten, die es ermöglichen, ihre Definition in einem Sprachkonstrukt zu kombinieren. Dies erleichtert die Verwendung beider Konzepte in einer Programmiersprache.'},
     {'question': 'Wie steht Inklusionspolymorphie in Beziehung zum Subtyping?', 'answer': 'Inklusionspolymorphie und Subtyping sind im Wesentlichen dasselbe Konzept. Beide Begriffe beschreiben, wie Objekte eines Subtyps anstelle ihres Supertyps verwendet werden können.'},
     {'question': 'Wie werden Typfehler in STRONGTALK vermieden?', 'answer': 'In STRONGTALK werden Typfehler vermieden, indem Variablen mit einem Protokoll als Typ typisiert werden. Wenn das Programm typkorrekt ist, bedeutet dies, dass jede Methode im Protokoll, die auf der Variable aufgerufen wird, auch für den Inhalt der Variable, das referenzierte Objekt, definiert ist.'},
     {'question': 'Wie werden Typen in Variablendeklarationen verwendet?', 'answer': 'Typen werden in Variablendeklarationen explizit angegeben, um jedem Objekt und Ausdruck im Programm einen Typ zuzuordnen.'},
     {'question': 'Wie erfolgt die Zuweisung eines Typs an eine Typvariable?', 'answer': 'Die Zuweisung eines Typs zu einer Typvariable erfolgt bei der Verwendung eines parametrisch definierten Typs in einer Deklaration, z. B. der Deklaration einer Variable oder des Rückgabewerts einer Methode. Diese Verwendung entspricht oberflächlich betrachtet dem Aufruf einer Methode oder eines Konstruktors, führt aber bereits zur Übersetzungszeit zu einer Zuweisung an die Typvariablen.'},
     {'question': 'Was ermöglicht der parametrische Polymorphismus?', 'answer': 'Der parametrische Polymorphismus ermöglicht die Definition eines nicht parametrischen Typs als Subtyp eines parametrisierten Typs, wodurch die gewünschte Rekursion indirekt hergestellt werden kann.'},
     {'question': 'Wie wird eine Beschränkung des tatsächlichen Typparameters in der Typdefinition erreicht?', 'answer': 'Die Beschränkung des tatsächlichen Typparameters wird erreicht, indem der formale Typparameter auf einen Subtyp beschränkt wird.'},
     {'question': 'Erklären Sie Kovarianz und Kontravarianz in Bezug auf Redefinition von Methodenaufrufen im Subtyping?', 'answer': 'Bei der Redefinition von Methodenaufrufen im Subtyping müssen die Parametertypen kontravariant und die Rückgabetypen kovariant sein. Dies bedeutet, dass die Eingabeparameter des Subtyps genereller sein dürfen als die des Supertyps, während der Subtyp mehr Werte zurückgeben kann als der Supertyp.'},
     {'question': 'Wie können definierte Typen in STRONGTALK-Programmen verwendet werden?', 'answer': 'Definierte Typen können in STRONGTALK-Programmen bei der Deklaration von (anderen) Typen, von Variablen, von Blöcken und von Methoden verwendet werden. Dies führt zu einer Typisierung der deklarierten Programmelemente.'},
     {'question': 'Wie werden Variablen in STRONGTALK typisiert?', 'answer': 'Variablen (einschließlich Instanzvariablen und temporäre Variablen) werden in STRONGTALK typisiert, indem ein Typname in spitzen Klammern an die Variable angehängt wird.'},
     {'question': 'Wie bestimmt der Compiler den Speicherbedarf einer Variable?', 'answer': 'Der Compiler kann anhand des Typs einer Variablen bestimmen, wie viel Speicherplatz er für die Aufnahme eines Wertes reservieren muss.'},
     {'question': 'Wozu dient die Typisierung in den verschiedenen Phasen des Programmentwicklungsprozesses?', 'answer': 'In der Entwurfsphase hilft die Typisierung, die Struktur des Programms zu definieren, indem sie abstrakte Datentypen und Schnittstellen spezifiziert. In der Implementierungsphase wird sie verwendet, um die Eingabeparameter und Rückgabewerte der Methoden zu spezifizieren und die Korrektheit der Implementierung zu überprüfen. In der Testphase kann die Typisierung dazu verwendet werden, die Testfälle zu definieren und die Ergebnisse zu überprüfen.'},
     {'question': 'Wozu kann die Typisierung in der Entwurfsphase verwendet werden?', 'answer': 'In der Entwurfsphase kann die Typisierung dazu verwendet werden, abstrakte Datentypen und Schnittstellen zu spezifizieren, bevor die Implementierung beginnt.'},
     {'question': 'Wozu kann die Typisierung in der Implementierungsphase verwendet werden?', 'answer': 'In der Implementierungsphase kann die Typisierung dazu verwendet werden, die richtigen Methoden für die richtigen Objekte aufzurufen.'},
     {'question': 'Wozu kann die Typisierung in der Testphase verwendet werden?', 'answer': 'In der Testphase kann die Typisierung dazu verwendet werden, die Art der Daten zu überprüfen, die an Methoden übergeben werden.'},
     {'question': 'Wozu kann die Typisierung in der Wartungsphase verwendet werden?', 'answer': 'In der Wartungsphase kann die Typisierung dazu verwendet werden, die Auswirkungen von Änderungen zu verstehen und zu kontrollieren.'},
     {'question': 'Wozu dienen Typinformationen in der Dokumentation?', 'answer': 'Typinformationen in der Dokumentation helfen anderen Entwicklern, den Code zu verstehen und korrekt zu verwenden.'},
     ],
    [{'question': 'Wie unterscheidet sich die Verwendung von Klassendefinitionen in STRONGTALK von anderen Sprachen wie Java oder C++?', 'answer': 'In STRONGTALK sind formale Parameter in Klassendefinitionen typisiert, während in Java oder C++ Instanzvariablen nicht Teil einer Typdefinition sein können.'},
     {'question': 'Was versteht man unter parametrisierter Typdefinition?', 'answer': 'Eine parametrisierte Typdefinition ist eine Möglichkeit, einen Typ in der Programmierung zu definieren, der einen oder mehrere Typparameter enthält. Diese Typparameter können bei der Instanziierung des Typs durch konkrete Typen ersetzt werden, um einen konkreten Typ zu erzeugen. Durch die Verwendung parametrisierter Typdefinitionen kann Code wiederverwendet werden, und die Typsicherheit wird erhalten.'},
     {'question': 'Was ist der Nachteil der einfachen Form des parametrischen Polymorphismus?', 'answer': 'Der Nachteil der einfachen Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung ist, dass die Typvariablen selbst nicht typisiert sind, und man daher innerhalb der Typdefinition keine Aussagen über den Typ treffen kann.'},
     {'question': 'Warum werden Metatypen in der Praxis nicht genutzt?', 'answer': 'Metatypen werden in der Praxis nicht genutzt, da sie eine zusätzliche Komplexität in die Sprache einführen und die Sprache unnötig erschweren würden. Zudem gibt es andere Möglichkeiten, um Typbeschränkungen zu erreichen, wie zum Beispiel die Verwendung von generischen Typen oder die Verwendung von Interfaces.'},
     {'question': 'Was bedeutet die Beschränkung von Typvariablen?', 'answer': 'Die Beschränkung von Typvariablen drückt aus, dass die Typen, die als Werte für die Typvariable eingesetzt werden dürfen, Subtypen des angegebenen Typs sein müssen.'},
     {'question': 'Was passiert, wenn eine unzulässige Deklaration von Typvariablen durchgeführt wird?', 'answer': 'Wenn eine unzulässige Deklaration von Typvariablen durchgeführt wird, führt dies zu einem Typfehler während der statischen Typprüfung.'},
     {'question': 'Was impliziert die Definition von Subtypen in Bezug auf Zuweisungskompatibilität?', 'answer': 'Die Definition von Subtypen impliziert Zuweisungskompatibilität, das heißt, Objekte eines Subtyps dürfen überall auftauchen, wo Objekte seines Supertyps erwartet werden, und sie dürfen auch Werte von jemandem zugreifen, der bei einer Zeichnung auf ihre Zeilen zugreifen will.'},
     {'question': 'Was ist der Unterschied zwischen Typerweiterung und Typeinschränkung?', 'answer': 'Typerweiterung erfolgt durch Hinzufügen von Eigenschaften (Methoden) zu einem bestehenden Typen, während Typeinschränkung durch Entfernen von Eigenschaften (Methoden) von einem bestehenden Typen erfolgt. Typerweiterung führt zur Zuweisungskompatibilität, während Typeinschränkung nicht dazu führt.'},
     {'question': 'Was ist der Unterschied zwischen Wertsemantik und Referenzsemantik in Bezug auf Zuweisungskompatibilität in der objektorientierten Programmierung?', 'answer': 'In der objektorientierten Programmierung ist bei der Zuweisungskompatibilität nur die Referenzsemantik relevant. Bei der Referenzsemantik wird nur der Verweis auf das Objekt kopiert und in der Variablen gespeichert, während bei der Wertsemantik eine Kopie des Objekts angefertigt wird. Dies führt dazu, dass bei der Referenzsemantik Änderungen am Objekt in einer Variablen auch das Objekt in einer anderen Variablen betrifft, wenn sie auf dasselbe Objekt verweisen. Bei der Wertsemantik hingegen betrifft eine Änderung am Objekt in einer Variablen nicht das Objekt in einer anderen Variablen, da es sich um eine Kopie handelt.'},
     {'question': 'Was ist der Unterschied zwischen Deklaration und Definition einer Variablen?', 'answer': 'Bei der Deklaration wird dem Bezeichner das zugeordnet, wofür er steht, während bei der Definition der Speicherplatz für die Variable zugewiesen wird. In manchen Kontexten wird der Begriff Definition aber auch für die Zuweisung eines Anfangswerts an eine Variable verwendet.'},
     {'question': 'Was ist der Unterschied zwischen Deklaration und Definition einer Methode?', 'answer': 'Bei der Deklaration wird die Signatur einer Methode bekannt gegeben, bei der Definition wird der Signatur der Methodenrumpf zugeordnet.'},
     {'question': 'Was sind die Nachteile von Sprachen, die Variablen nicht deklarieren?', 'answer': 'Wenn Variablen nicht deklariert werden, können Schreibfehler dazu führen, dass plötzlich zwei Variablen anstatt einer existieren, was zu Programmierfehlern führen kann. Diese Art von Fehlern ist schwer zu erkennen und zu beheben.'},
     {'question': 'Was ist der Nachteil von Namensäquivalenz?', 'answer': 'Der Nachteil von Namensäquivalenz ist, dass sie voraussetzt, dass getrennt voneinander entwickelte Programme dieselben Typen verwenden. Für die Interoperabilität von getrennt voneinander entwickelten Programmen kann dies ein echtes Hindernis sein.'},
     {'question': 'Was ist der Unterschied zwischen nominaler und struktureller Typäquivalenz?', 'answer': 'Nominale Typäquivalenz erlaubt Äquivalenz von Typen, bei deren Definition man vom jeweils anderen nichts wusste. Strukturelle Typäquivalenz bietet mehr Flexibilität, hat jedoch den Nachteil, dass zufällige strukturelle Übereinstimmungen zu einer Äquivalenz führen können, die nicht der intendierten Semantik entspricht. Type branding führt in solchen Fällen optional eine Namensäquivalenz durch die Hintertür ein, mit dem Vorteil, dass diese optional ist.'},
     {'question': 'Was ist der Unterschied zwischen einer Schnittstelle und einem Typ?', 'answer': 'Eine absolut spezifizierte Schnittstelle einer Klasse kommt, wenn sie wirklich keinerlei Implementierungsgeheimnisse verrät, einem Typ gleich. Sie besteht nämlich nur aus Deklarationen von Methoden. Im Gegensatz dazu, werden bei einem Typ die Instanzvariablen der Objekte in die Schnittstelle der Klassen aufgenommen, was dem Gedanken des Geheimnisprinzips widerspricht.'},
     {'question': 'Was passiert mit der Typkonformität zwischen Super- und Subklasse, wenn Methoden gelöscht oder inkompatibel redefiniert werden?', 'answer': 'Wenn in der Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, also z. B. Methoden gelöscht oder inkompatibel redefiniert werden, dann ist eine Instanz einer Subklasse nicht mehr dem Wertebereich des zur Superklasse gehörenden Typs zugehörig.'},
     {'question': 'Was passiert, wenn in einer Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben?', 'answer': 'Wenn in einer Subklasse Änderungen vorgenommen werden, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben, dann ist eine Instanz der Subklasse nicht mehr mit dem Typ der Superklasse kompatibel. Das ist in den meisten objektorientierten Programmiersprachen nicht erlaubt.'},
     {'question': 'Warum sind Typsysteme, die kovariante Redefinition erlauben, kaum praxistauglich?', 'answer': 'Typsysteme, die kovariante Redefinition erlauben, sind kaum praxistauglich, weil sie zu Problemen führen können, wenn Objekte mit unterschiedlichen Typen miteinander interagieren. Wenn beispielsweise eine Methode, die ein Objekt erwartet, das von Typ A ist, ein Objekt erhält, das von Typ B ist, aber B von A abgeleitet ist, kann dies zu unerwarteten Ergebnissen führen, wenn die Methode versucht, auf die spezifischen Eigenschaften von A zuzugreifen, die in B nicht vorhanden sind. Dies kann zu Laufzeitfehlern führen und die Wartbarkeit und Zuverlässigkeit des Codes beeinträchtigen.'},
     {'question': 'Was bedeutet die Antisymmetrie der Typkonformität?', 'answer': 'Die Antisymmetrie der Typkonformität bedeutet, dass wenn ein Typ B typkonform zu einem Typ A ist und A zu B typkonform ist, dann müssen A und B identisch sein. Das heißt, dass es keine zwei verschiedenen Typen geben kann, die beide typkonform zu einander sind.'},
     {'question': 'Warum ist strukturelle Typkonformität in der objektorientierten Programmierung weniger gebräuchlich?', 'answer': 'Strukturelle Typkonformität ist in der objektorientierten Programmierung weniger gebräuchlich, weil sie die statische Typisierung untergraben würde.'},
     {'question': 'Was ist der Unterschied zwischen struktureller Typkonformität und namensgebundener Typkonformität?', 'answer': 'Strukturelle Typkonformität besteht, wenn der konforme Typ alle Elemente des Typs, zu dem er konform sein soll, enthält. Nominale Typkonformität hingegen bezieht sich auf die Übereinstimmung von Typnamen, unabhängig davon, ob die Typen strukturell identisch sind oder nicht.'},
     {'question': 'Was bedeutet nominale Konformität?', 'answer': 'Nominale Konformität bedeutet, dass für die Konformität einer Erweiterung nicht nur die Struktur, sondern auch der Name des Typs, der erweitert wird, explizit angegeben werden muss.'},
     {'question': 'Warum folgt die Konformität aus der Erweiterung?', 'answer': 'Die Konformität folgt aus der Erweiterung, weil bei der Erweiterung alle Elemente des Typs, der erweitert wird, beim erweiternden erhalten bleiben.'},
     {'question': 'Was bedeutet es, wenn ein Typ reflexiv ist?', 'answer': 'Wenn ein Typ reflexiv ist, bedeutet das, dass er eine Erweiterung eines anderen sein kann, ohne tatsächlich etwas hinzuzufügen.'},
     {'question': 'Was bedeutet es, wenn ein Typ eine Erweiterung eines anderen ist, ohne tatsächlich etwas hinzuzufügen?', 'answer': 'In diesem Fall spricht man von Typerweiterung, bei der ein Typ eine Untermenge eines anderen Typs ist und somit alle Eigenschaften und Methoden des übergeordneten Typs besitzt, aber keine zusätzlichen Eigenschaften oder Methoden hinzufügt. Dies ist eine reflexive Beziehung, was bedeutet, dass ein Typ auch sich selbst als Untertyp haben kann.'},
     {'question': 'Ist Typäquivalenz gleichbedeutend mit Typkonformität?', 'answer': 'Nein, Typäquivalenz impliziert Typkonformität, aber nicht umgekehrt. Zwei äquivalente Typen sind auch immer konform, aber ein konformer Typ ist nicht unbedingt äquivalent zu einem anderen Typ.'},
     {'question': 'Was ist der Unterschied zwischen nominaler und struktureller Typkonformität?', 'answer': 'Nominale Typkonformität ist eine Bedingung für die Zuweisungskompatibilität, bei der die Typkonformität gegeben ist, wenn der Typ namentlich angegeben wird. Strukturelle Typkonformität ist dagegen gegeben, wenn die Struktur des Typs übereinstimmt, unabhängig davon, wie er benannt ist. STRONGTALK hat ursprünglich ein strukturelles Typsystem verwendet, das später durch ein nominales Typsystem ersetzt wurde, da die strukturelle Typprüfung es schwieriger macht, die Absicht der Programmiererin auszudrücken und Fehlermeldungen sind oft schwer zu verstehen.'},
     {'question': 'Was ist der Unterschied zwischen Strukturäquivalenz und Namensäquivalenz?', 'answer': 'Strukturäquivalenz bedeutet, dass zwei Typen die gleiche Struktur haben, aber die Namen können unterschiedlich sein. Bei Namensäquivalenz hingegen haben die Namen eine von der Struktur unabhängige Bedeutung, d.h. sie sind identisch. Namensäquivalenz impliziert Strukturäquivalenz, aber nicht umgekehrt.'},
     {'question': 'Was sind die Vorteile von Typerweiterung?', 'answer': 'Die Vorteile von Typerweiterung sind, dass sie es ermöglicht, bestehenden Code wiederzuverwenden und neue Funktionalität hinzuzufügen, ohne den ursprünglichen Code zu ändern. Dies führt zu einer besseren Codequalität, da weniger Änderungen am Code vorgenommen werden müssen und die Wahrscheinlichkeit von Fehlern reduziert wird.'},
     {'question': 'Was sind die Nachteile von Typerweiterung?', 'answer': 'Die Nachteile von Typerweiterung sind, dass sie die Komplexität des Codes erhöhen kann, da es mehrere Versionen des gleichen Datentyps gibt. Dies kann zu Verwirrung führen und die Wartbarkeit des Codes beeinträchtigen. Außerdem kann Typerweiterung zu einer unkontrollierten Ausdehnung des Codes führen, wenn nicht sorgfältig geplant und implementiert wird.'},
     {'question': 'Was wird verhindert, wenn man eine Variable mit einem Protokoll als Typ typisiert und das Programm typkorrekt ist?', 'answer': 'Wenn man eine Variable mit einem Protokoll als Typ typisiert und das Programm typkorrekt ist, wird verhindert, dass Typfehler auftreten, also Fehler der Sorte „does not understand“, die auftreten, wenn eine Methode aufgerufen wird, die für den Inhalt der Variable, das referenzierte Objekt, nicht definiert ist.'},
     {'question': 'Was ist der Unterschied zwischen STRONGTALK und anderen Programmiersprachen hinsichtlich primitiver Typen?', 'answer': 'Im Gegensatz zu STRONGTALK haben andere Programmiersprachen oft primitiver Typen, deren Definitionen nicht auf andere Typen zurückgeführt werden müssen. In STRONGTALK gibt es keine primitiven Typen, alle Typen sind selbstbezüglich.'},
     {'question': 'Warum ist Zuweisungskompatibilität unter Subtyping möglich?', 'answer': 'Zuweisungskompatibilität unter Subtyping ist möglich, weil Subtypen alle Eigenschaften ihrer Supertypen erben und somit keine Typfehler auftreten können.'},
     {'question': 'Was ist der Unterschied zwischen Upcast, Downcast und Crosscast?', 'answer': 'Upcasts sind Typumwandlungen zu Supertypen, Downcasts sind Typumwandlungen zu Subtypen und Crosscasts sind Typumwandlungen zu Typen, die weder Supertyp noch Subtyp des Ausgangstyps sind. Upcasts sind immer typsicher, Downcasts und Crosscasts hingegen nicht. Downcasts werden häufig verwendet, wenn kein parametrischer Polymorphismus zur Verfügung steht oder wenn ein Objekt seinem tatsächlichen Typ entsprechend behandelt werden soll. Crosscasts sind eher selten und stehen für einen Rollenwechsel eines Objekts.'},
     {'question': 'Warum sollte man auf Typumwandlungen verzichten?', 'answer': 'Typumwandlungen können überflüssig oder unsicher sein. Daher ist es besser, auf sie zu verzichten, um Fehler zu vermeiden. Wenn sie unverzichtbar sind, sollten sie mit einem Typtest abgesichert werden, um sicherzustellen, dass das Objekt, für das der typgewandelte Ausdruck steht, den gewünschten Typ hat.'},
     {'question': 'Was ist der Unterschied zwischen Klassen und Typen?', 'answer': 'Klassen definieren die Implementierung ihrer Objekte, während Typen frei von Implementierungsaspekten sind. Typen sind abstrakte Spezifikationen, die auf eine Typprüfung ohne Ansehen der Implementierung abzielen. Klassen können zumindest eine partielle Implementierung vorgeben, die anderen Klassen, ihren Subklassen, gemeinsam ist, so dass sie diese erben können.'},
     {'question': 'Was ist der Unterschied zwischen Typen und Klassen?', 'answer': 'Typen sind abstrakte Spezifikationen, die den Wertebereich von Variablen einschränken und das Protokoll von Objekten angeben. Klassen hingegen sind Konstrukte, die Objekte als Instanzen bilden erlauben und mit Implementierung versehen. Objekte können den Wertebereich von Typen ausmachen, aber Typen und Klassen sind nicht dasselbe.'},
     {'question': 'Können Instanzvariablen ein Bestandteil einer Typdefinition in STRONGTALK sein?', 'answer': 'Nein, anders als z. B. in Java oder C++, können Instanzvariablen kein Bestandteil einer Typdefinition in STRONGTALK sein.'},
     {'question': 'Was ist der Unterschied zwischen Klassendefinitionen in Smalltalk und Strongtalk?', 'answer': 'In Smalltalk werden in Klassendefinitionen keine Typen verwendet, während in Strongtalk die formalen Parameter der Methoden in den Klassendefinitionen typisiert sind. Zudem können in Strongtalk Instanzvariablen kein Bestandteil einer Typdefinition sein, im Gegensatz zu Java oder C++.'},
     {'question': 'Welche Arten von Typisierung bietet STRONGTALK?', 'answer': 'STRONGTALK bietet zwei Arten von Typisierung: Die erste Art erfordert vom Compiler eine Prüfung, ob eine Klasse tatsächlich über alle Eigenschaften der von ihr genannten Typen verfügt. Bei der zweiten Art ist diese Prüfung automatisch der Fall, da der Typ gewissermaßen aus der Klasse erzeugt wird. Diese zweite Art wird von den meisten typisierten, objektorientierten Programmiersprachen bevorzugt, während die erste Art in Sprachen wie Java und C-Sharp vorkommt.'},
     {'question': 'Was ist der Unterschied zwischen kovarianter Redefinition und kontravarianter Redefinition?', 'answer': 'Kovariante Redefinition tritt auf, wenn der Parametertyp der Methode sich mit dem Empfängertyp ändert, während kontravariante Redefinition auftritt, wenn der Parametertyp der Methode sich in die entgegengesetzte Richtung zum Empfängertyp ändert. In diesem Fall ist es kein Widerspruch zur Kontravarianzregel des Subtyping, da Integer unmittelbar zu einem Subtyp von Equatable[Integer] wird und nicht von Equatable[Object]. Equatable[Integer] und Equatable[Object] sind zwei vollkommen verschiedene Typen mit disjunkten Wertebereichen, und Equatable[T] ist kein Typ, sodass keinerlei Zuweisungskompatibilität und damit auch kein Problem mit Typkorrektheit besteht.'},
     {'question': 'Kann das Problem der wünschenswerten kovarianten Redefinition von Eingabeparametern in Methoden mit parametrischen Polymorphismus gelöst werden?', 'answer': 'Nur zum Teil, da parametrischer Polymorphismus zwar die Verwendung von verschiedenen Typen von Eingabeparametern ermöglicht, aber nicht die kovariante Redefinition von Eingabeparametern in Unterklassenmethoden.'},
     {'question': 'Was ist der Unterschied zwischen einer parametrischen Typdefinition und einer normalen Typdefinition?', 'answer': 'Eine parametrische Typdefinition unterscheidet sich von einer normalen dadurch, dass in der Typdefinition verwendete, andere Typen durch Platzhalter, die Typparameter, vertreten werden können. Diese Platzhalter sind Variablen, deren Wert implizit auf Typen beschränkt ist. Diese Typvariablen werden erst bei der Verwendung eines parametrisierten Typs in der Deklaration eines anderen Programmelements mit einem Wert, also einem Typ, belegt.'},
     {'question': 'Warum ist die Typsicherheit eine nicht-triviale Eigenschaft?', 'answer': 'Die Typsicherheit ist eine nicht-triviale Eigenschaft, weil eine sorgfältige Analyse erforderlich ist, um falsche und peinliche Behauptungen zur Typsicherheit zu vermeiden.'},
     {'question': 'Was ist der Unterschied zwischen typisierten und nicht typisierten Programmiersprachen?', 'answer': 'Im Gegensatz zu typisierten Programmiersprachen, in denen Programmelementen bei ihrer Deklaration Typen zugeordnet werden, sind nicht typisierte Sprachen so konzipiert, dass Typen bei der Deklaration entbehrlich sind. Typen beschränken die Menge der Objekte, für die ein Programmelement stehen kann, und die Arten von Operationen, die darauf angewendet werden können. Typregeln sind in der Regel ein fester Bestandteil der Sprache, aber in nicht typisierten Sprachen können Typen von der restlichen Sprachdefinition getrennt werden, um sie auszutauschen oder zu verbessern.'},
     {'question': 'Wozu werden rekursive Typen verwendet?', 'answer': 'Rekursive Typen werden verwendet, um dynamische Strukturen wie verschachtelte Listen oder Bäume zu definieren. Sie sind ein wichtiges Instrument der Programmierung, bringen aber auch Probleme mit sich, wie zum Beispiel die Schwierigkeit, die strukturelle Äquivalenz zweier rekursiver Typen festzustellen.'},
     {'question': 'Was ist der Unterschied zwischen Invarianz, Kovarianz und Kontravarianz?', 'answer': 'Invarianz, Kovarianz und Kontravarianz sind Konzepte in der objektorientierten Programmierung, die sich auf die Beziehung zwischen dem Typ eines Objekts und dem Typ eines seiner Untertypen beziehen. Invarianz bedeutet, dass der Typ eines Objekts unverändert bleibt, wenn es in ein Untertyp-Objekt konvertiert wird. Kovarianz bedeutet, dass der Typ eines Objekts sich auf die gleiche Weise ändert wie der Typ des Untertyps, wenn es in ein Untertyp-Objekt konvertiert wird. Kontravarianz bedeutet, dass der Typ eines Objekts sich entgegengesetzt zum Typ des Untertyps ändert, wenn es in ein Untertyp-Objekt konvertiert wird.'},
     {'question': 'Wozu dient ein allgemeiner parametrischer Typ?', 'answer': 'Ein allgemeiner parametrischer Typ dient dem Zweck, den Parametertyp des Tests variabel zu halten und nur für den Gleichheitstest verwendet zu werden.'},
     {'question': 'Wozu dient ein parametrischer Typ im Gleichheitstest?', 'answer': 'Ein parametrischer Typ wird im Gleichheitstest verwendet, um den Typ des Parameters variabel zu halten und einen allgemeinen Gleichheitstest zu definieren, der für verschiedene Typen verwendet werden kann.'},
     {'question': 'Was passiert bei der Redefinition einer Methode mit den Eingabe- und Ausgabeparametern?', 'answer': 'Bei der Redefinition einer Methode dürfen sich die Eingabeparameter nur zu einem Supertypen ändern, während die Ausgabeparameter nur zu einem Subtyp geändert werden dürfen, um die Typkorrektheit des Programms zu gewährleisten.'},
     {'question': 'Was ist der Unterschied zwischen parametrischen Polymorphismus und Inklusionspolymorphie?', 'answer': 'Parametrischer Polymorphismus ist eine Technik, die es ermöglicht, dass eine Funktion oder Methode mit Argumenten verschiedener Typen aufgerufen werden kann, während Inklusionspolymorphie (Subtyping) eine Beziehung zwischen Typen ist, bei der ein Typ B ein Untertyp eines anderen Typs A ist, wenn ein Wert vom Typ B auch als Wert vom Typ A behandelt werden kann. Im Falle von Collections bedeutet dies, dass eine Collection, die auf Objekte eines bestimmten Typs ausgelegt ist, auch Objekte eines Untertyps dieses Typs aufnehmen kann.'},
     {'question': 'Was ist der Nachteil einer erhöhten Typsicherheit außerhalb der Typdefinition?', 'answer': 'Der Nachteil der erhöhten Typsicherheit außerhalb der Typdefinition ist die verminderte Typsicherheit innerhalb der Typdefinition.'},
     {'question': 'Welchen Nachteil hat die Namensäquivalenz in Bezug auf die Interoperabilität von getrennt voneinander entwickelten Programmen?', 'answer': 'Die Namensäquivalenz setzt voraus, dass getrennt voneinander entwickelte Programme zumindest an ihren Schnittstellen dieselben Typen verwenden. Dies kann ein Hindernis für die Interoperabilität von solchen Programmen, wie zum Beispiel Web Services, darstellen.'},
     {'question': 'Was sind die Unterschiede zwischen struktureller Typäquivalenz und Namensäquivalenz in Bezug auf Flexibilität und Semantik?', 'answer': 'Strukturelle Typäquivalenz bietet mehr Flexibilität als Namensäquivalenz, da sie die Äquivalenz von Typen erlaubt, deren Definition voneinander unabhängig ist. Allerdings können zufällige strukturelle Übereinstimmungen zu einer Äquivalenz führen, die nicht der intendierten Semantik entspricht. Um diesen Nachteil zu vermeiden, kann optional eine Namensäquivalenz durch Type branding eingeführt werden.'},
     {'question': 'Welche Vorteile bietet nominale Typkonformität gegenüber struktureller Typkonformität?', 'answer': 'Nominale Typkonformität bietet die Vorteile der Zuweisungskompatibilität und Abwesenheit von Typfehlern. Sie dient auch als Filterfunktion, da nur Objekte von solchen Typen Variablen zugewiesen werden können, für die die Programmiererin dies aus semantischen Überlegungen heraus ausdrücklich vorgesehen hat.'},
     {'question': 'Was sind mögliche Nachteile der Strukturäquivalenz?', 'answer': 'Bei Verwendung der Strukturäquivalenz können Typen, die inhaltlich nichts miteinander zu tun haben, fälschlicherweise als äquivalent betrachtet werden. Dies kann dazu führen, dass Objekte, die eigentlich unterschiedlichen Typen angehören, fälschlicherweise zugewiesen werden können, was zu semantischen Fehlern führen kann. Dieses Problem kann durch die Technik des "Type Branding" gelöst werden, bei der jedem Typ eine charakteristische Methode exklusiv zugeordnet wird, um die Strukturäquivalenz einzuschränken.'},
     {'question': 'Was sind die Unterschiede zwischen abstrakten Datentypen und STRONGTALK-Typen?', 'answer': 'Es gibt mindestens zwei wichtige Unterschiede: Abstrakte Datentypen sind nicht objektorientiert, während STRONGTALK-Typen objektorientiert sind und Objekte Zustand haben können. Abstrakte Datentypen haben Funktionen mit einem Argument mehr, das dem Typ des Datentyps selbst entspricht. In objektorientierten Sprachen entspricht dies dem Nachrichtenempfänger, dem impliziten Parameter "self".'},
     {'question': 'Welchen Vorteil bietet der parametrische Polymorphismus gegenüber der Inklusionspolymorphie?', 'answer': 'Der parametrische Polymorphismus bietet den Vorteil einer erhöhten Typsicherheit, da Typfehler bereits zur Instanziierung des parametrischen Typs erkannt werden können.'},
     {'question': 'Was passiert bei der Instanziierung eines parametrischen Typs mit einem konkreten Typen?', 'answer': 'Der konkrete Typ wird in die formale Typvariable eingesetzt, und der resultierende Typ wird zur Verwendung im Programm definiert.'},
     {'question': 'Warum ist die einfache Form des parametrischen Polymorphismus für die Typsicherheit in der objektorientierten Programmierung nur teilweise nützlich?', 'answer': 'Die einfache Form des parametrischen Polymorphismus ist nur teilweise nützlich, da die Typvariablen selbst nicht typisiert sind, und somit innerhalb der Typdefinition keine Aussagen über den Typ getroffen werden können.'},
     {'question': 'Warum könnte die Annotation von Variablen mit einem Supertypen ein Problem darstellen?', 'answer': 'Die Annotation von Variablen mit dem Supertypen könnte ein Problem darstellen, da dies die Verwendung von Subtypen einschränken würde. Wenn Variablen mit dem Supertypen annotiert sind und nur Werte des Supertyps akzeptieren, könnten keine Objekte des Subtyps in diesen Variablen gespeichert werden, selbst wenn sie die gleiche Struktur oder das gleiche Verhalten aufweisen. Dies würde die Flexibilität des Typsystems einschränken und die Verwendung von Subtypen weniger nützlich machen.'},
     {'question': 'Warum führt die Typeinschränkung zur Problematik der Zuweisungskompatibilität?', 'answer': 'Die Typeinschränkung kann die Zuweisungskompatibilität beeinträchtigen, da sie die Parameter-Typen in Methoden neu definiert und dadurch potenziell Konflikte bei der Zuweisung von Objekten unterschiedlicher Typen verursachen kann. Dies führt dazu, dass nicht alle Zuweisungen, die bei Typerweiterung basierend auf Typkonformität zulässig wären, bei Typeinschränkung ebenfalls zulässig sind.'},
     {'question': 'Warum ist die Unterscheidung zwischen Wertsemantik und Referenzsemantik relevant, wenn es um Typeinschränkung geht?', 'answer': 'Die Unterscheidung zwischen Wertsemantik und Referenzsemantik ist relevant, da sie Auswirkungen auf die Zuweisungskompatibilität hat. Unter Wertsemantik wird bei der Zuweisung eine Kopie des Objekts erstellt, während unter Referenzsemantik mehrere Variablen auf dasselbe Objekt verweisen können. In diesem Zusammenhang ist die Referenzsemantik interessanter, da Typeinschränkungen bei der Zuweisung von Aliasen (Variablen, die auf dasselbe Objekt verweisen) Probleme verursachen können, die bei Wertsemantik nicht auftreten.'},
     {'question': 'Warum wird in der Praxis der objektorientierten Programmierung oft die Referenzsemantik verwendet?', 'answer': 'In der Praxis der objektorientierten Programmierung wird oft die Referenzsemantik verwendet, da sie effizienter ist und es ermöglicht, auf dasselbe Objekt von verschiedenen Stellen im Code aus zuzugreifen. Dies erleichtert die Arbeit mit komplexen Datenstrukturen und verhindert unnötige Kopien von Objekten. Die Referenzsemantik ist daher die gebräuchlichere Semantik in vielen objektorientierten Programmiersprachen.'},
     {'question': 'Was bedeutet es, wenn die Extension eines Typs in der Extension eines anderen Typs enthalten ist?', 'answer': 'Wenn die Extension eines Typs in der Extension eines anderen Typs enthalten ist, bedeutet dies, dass Objekte des ersten Typs an Stellen verwendet werden können, an denen Objekte des zweiten Typs erwartet werden, ohne die Typkorrektheit zu verletzen.'},
     {'question': 'Warum ist die Teilmengenbeziehung bei der Typeinschränkung nicht immer offensichtlich?', 'answer': 'Bei der Typeinschränkung, bei der Eigenschaften (Methoden) entfernt werden, kann die Extension des eingeschränkten Typs tatsächlich größer werden, da weniger spezifische Anforderungen gestellt werden. Dies kann zu einer scheinbaren Umkehrung der Teilmengenbeziehung führen.'},
     {'question': 'Warum kann es trotz der Harmonie von Typerweiterung und -einschränkung zu einem Verlust der Zuweisungskompatibilität kommen?', 'answer': 'Der Verlust der Zuweisungskompatibilität kann aus der impliziten Allquantifiziertheit von Typinvarianten resultieren. Typsysteme mit solchen Invarianten sind nicht in der Lage, Aussagen über Wertebereiche zu treffen, die nicht implizit allquantifiziert sind.'},
     {'question': 'Warum ist die Namensäquivalenz als Bedingung der Zuweisungskompatibilität wichtig?', 'answer': 'Die Namensäquivalenz ist wichtig, da sie sicherstellt, dass einer Variable nur Werte gleicher Bedeutung zugewiesen werden können. Sie verhindert Zuweisungen zwischen Typen, die zwar strukturell gleich sind, aber unterschiedliche Bedeutungen haben. Dies ist entscheidend, um logische Programmierfehler zu vermeiden, die sonst schwer zu entdecken wären.'},
     {'question': 'Warum ist es wichtig, Implementierungen von Klassen hinter Schnittstellen zu verbergen?', 'answer': 'Das Verbergen von Implementierungen hinter Schnittstellen ist wichtig, um das Geheimnisprinzip zu wahren und sicherzustellen, dass nur die für Benutzer einer Klasse vorgesehenen Elemente sichtbar sind.'},
     {'question': 'Was unterscheidet eine absolute und eine relativ spezifizierte Schnittstelle einer Klasse?', 'answer': 'Eine absolute Schnittstelle verrät keinerlei Implementierungsdetails und besteht nur aus Methodendeklarationen. Eine relative Schnittstelle kann sich je nach Lokalität oder anderen Eigenschaften von benutzender und benutzter Klasse unterscheiden und gibt mehr Einblicke in die Implementierung.'},
     {'question': 'Warum gehört eine Instanz einer Subklasse nicht zwangsläufig zum Wertebereich des zur Superklasse gehörenden Typs?', 'answer': 'Eine Instanz einer Subklasse gehört nicht zwangsläufig zum Wertebereich des zur Superklasse gehörenden Typs, da in der Subklasse Änderungen vorgenommen werden können, die eine Typkonformität vom zur Subklasse gehörenden zum zur Superklasse gehörenden Typ aufheben können. Zum Beispiel können Methoden gelöscht oder inkompatibel redefiniert werden.'},
     {'question': 'Was unterscheidet nominales und strukturelles Subtyping?', 'answer': 'Beim Subtyping gibt es zwei Unterscheidungen: nominales und strukturelles Subtyping.'},
     {'question': 'Warum setzen die meisten gebräuchlichen, typisierten Programmiersprachen auf nominale Typkonformität als Bedingung für die Zuweisungskompatibilität?', 'answer': 'Die meisten Programmiersprachen setzen auf nominale Typkonformität, da sie automatisch gegeben ist, wenn der Typ, von dem ein neuer per Erweiterung abgeleitet wird, genannt wird. Dies vermeidet aufwendige, fallweise Konformitätstests. Strukturelle Typsysteme, insbesondere solche ohne explizite Benennung von Typen, erschweren die Ausdrücklichkeit der Programmiererin bei der Definition ihrer Absicht (intendierte Semantik) und können Programme schwerer lesbar und debugbar machen. Fehlermeldungen aus strukturellen Typprüfungen sind oft schwer zu verstehen und beziehen sich nicht immer auf die eigentliche Fehlerquelle.'},
     {'question': 'Warum reicht Strukturäquivalenz als Bedingung für Zuweisungskompatibilität aus?', 'answer': 'Strukturäquivalenz reicht als Bedingung für Zuweisungskompatibilität aus, um Typfehler zu verhindern, die auf der Annahme einer nicht vorhandenen Methode bei einem Wert einer Variable basieren. Sie gewährleistet, dass die Methoden eines Programms auf den jeweiligen Empfängerobjekten mit den geforderten Parameterobjekten auch durchgeführt werden können.'},
     {'question': 'Warum wird die Unterscheidung zwischen Klassen und Typen in Sprachen, in denen jede Klasse einen Typ definiert, nicht klar getroffen?', 'answer': 'In Sprachen, in denen Klassen auch Typen definieren, kann die Unterscheidung zwischen den beiden Konzepten verschwommen sein, da Programmierer möglicherweise nicht immer klar wahrnehmen, wie sie zur Laufzeit eines Programms wirken.'},
     {'question': 'Warum gibt es in STRONGTALK keine primitiven Typen?', 'answer': 'In STRONGTALK gibt es keine primitiven Typen, da alle Typen in STRONGTALK auf andere Typen zurückgeführt werden können. Selbst wenn eine Typannotation weggelassen wird, hat die entsprechende Variable bzw. der Rückgabewert der Methode immer einen impliziten Typ. Dies ermöglicht es, Typen mit zwangsläufiger Selbstbezüglichkeit eine Bedeutung zuzuweisen.'},
     {'question': 'Warum ist die Typisierung von Variablen und Ausdrücken in einem Programm wichtig?', 'answer': 'Die Typisierung von Variablen und Ausdrücken in einem Programm ist wichtig, um sicherzustellen, dass jede Variable nur Werte haben kann, für die sie vorgesehen ist. Dies gewährleistet die Einhaltung der Typinvariante und verhindert Typfehler im Programm.'},
     {'question': 'Ist Zuweisungskompatibilität eine transitive Eigenschaft?', 'answer': 'Ja, in der Regel ist Zuweisungskompatibilität eine transitive Eigenschaft. Wenn a zuweisungskompatibel mit b ist und b zuweisungskompatibel mit c ist, dann ist auch a zuweisungskompatibel mit c.'},
     {'question': 'Warum ist Zuweisungskompatibilität auch bei impliziten Zuweisungen wichtig?', 'answer': 'Zuweisungskompatibilität ist auch bei impliziten Zuweisungen wichtig, da sie Typkorrektheit impliziert. Bei der Parameterübergabe von Methodenaufrufen oder impliziten Zuweisungen müssen die beteiligten Typen kompatibel sein, um Typfehler zu vermeiden.'},
     {'question': 'Warum kann es für die Programmiererin problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden?', 'answer': 'Es kann problematisch sein, ein Objekt eines Supertyps wie ein Objekt seines tatsächlichen Typs zu verwenden, da der Supertyp möglicherweise nicht alle Methoden und Eigenschaften des tatsächlichen Typs enthält, die die Programmiererin verwenden möchte.'},
     {'question': 'Warum sind Upcasts immer typsicher, während Downcasts und Crosscasts unsicher sein können?', 'answer': 'Upcasts sind immer typsicher, da sie von einem spezielleren Typ zu einem allgemeineren Typ erfolgen. Downcasts und Crosscasts können unsicher sein, da sie von einem allgemeineren Typ zu einem spezielleren oder nicht verwandten Typ erfolgen, was dazu führen kann, dass der Ausdruck zur Laufzeit nicht den erwarteten Typ hat.'},
     {'question': 'Warum ergibt sich beim rekursiv beschränkten parametrischen Polymorphismus kein Widerspruch zur Kontravarianzregel des Subtyping?', 'answer': 'Es ergibt sich kein Widerspruch zur Kontravarianzregel des Subtyping, da der Empfängertyp (z. B. Integer) lediglich zu einem Subtyp von Equatable[Integer] wird und nicht von Equatable[Object].'},
     {'question': 'Kann das Kovarianzproblem durch parametrische Typen gelöst werden?', 'answer': 'Das Kovarianzproblem kann in bestimmten Fällen durch parametrische Typen gelöst werden, aber es gibt keine allgemeine Lösung, die in allen Fällen die kovariante Redefinition von Eingabeparametern in Methoden ermöglicht. Die Flexibilität ist begrenzt, und es kann zu Einschränkungen bei der Verwendung von parametrischen Typen führen.'},
     {'question': 'Warum nennt man parametrische Typen auch generische Typen oder Generics?', 'answer': 'Parametrische Typen werden auch als generische Typen oder Generics bezeichnet, weil sie die Idee verfolgen, aus einer Typdefinition generisch (theoretisch für beliebig viele Typen) viele Typen zu erzeugen, je nach Bedarf. Sie ermöglichen eine gewisse Generizität in der Typsicherung.'},
     {'question': 'Gibt es vollständig in sich selbst definierte Typsysteme, die von externen Einflüssen unabhängig sind?', 'answer': 'Nein, es gibt keine vollständig in sich selbst definierten Typsysteme, die vollständig unabhängig von externen Einflüssen sind. Selbst in Typsystemen wie SMALLTALK oder STRONGTALK sind mindestens einige grundlegende Typen oder Konzepte, wie Wahrheitswerte oder Ganzzahlen, von externen Formalismen oder vorgegebenen Semantiken abhängig.'},
     {'question': 'Warum ist die Kovarianz für Parametertypen in der Praxis nicht notwendig und kann sogar zu typinkorrekten Programmen führen?', 'answer': 'Obwohl Kovarianz für Parametertypen auf den ersten Blick sinnvoll erscheint, kann sie in der Praxis zu typinkorrekten Programmen führen. Dies liegt daran, dass die Anzahl der möglichen Eingabewerte in einem Subtyp reduziert wird, wenn die Menge der Empfängerobjekte eingeschränkt wird. Dies führt dazu, dass die Parametertypen tatsächlich kontravariant sind. Kovarianz für Parametertypen würde typinkorrekte Programme ermöglichen.'},
     {'question': 'Warum wird in der Praxis trotz parametrischer Definitionen von Collectios oft auch auf Inklusionspolymorphie zurückgegriffen?', 'answer': 'In der Praxis wird trotz Verwendung parametrischer Definitionen von Collections oft auf Inklusionspolymorphie zurückgegriffen, da heterogene Collections, die Objekte unterschiedlicher Subtypen enthalten, häufig vorkommen und Inklusionspolymorphie dies ermöglicht.'},
     {'question': 'Was ist der Unterschied zwischen Intension und Extension eines Typs?', 'answer': 'Die Intension eines Typs entspricht seiner Definition, während die Extension dem Wertebereich des Typs entspricht, also der Menge der Elemente (Objekte), die zu dem Typ gehören.'},
     {'question': 'Wofür ist der Typ einer Variablen in der objektorientierten Programmierung relevant?', 'answer': 'In der objektorientierten Programmierung ist der Typ einer Variablen nur für Variablen mit Wertsemantik relevant, was jedoch in Sprachen wie SMALLTALK, in denen Referenzsemantik vorherrscht, von untergeordneter Bedeutung ist.'},
     {'question': 'Was ist der Vorteil einer expliziten Typisierung von Variablen?', 'answer': 'Wenn man weiß, dass die Werte einer Variable immer vom selben Typ sind, also alle demselben Wertebereich entstammen, dann lassen sich bestimmte Optimierungen durchführen. Zum Beispiel kann der Compiler für die Übersetzung von x := x + 1 die Ganzzahladdition, ja sogar die Inkrement-Anweisung des Prozessors verwenden.'},
     {'question': 'Warum ist es vorteilhaft, wenn man den Typ einer Variablen kennt?', 'answer': 'Wenn man den Typ einer Variablen kennt, kann der Compiler bestimmte Optimierungen durchführen, wie z.B. die Ganzzahladdition oder die Inkrement-Anweisung des Prozessors verwenden. Wenn der Compiler den Typ nicht kennt, muss das Programm vor der Ausführung der Addition erst prüfen, von welchem Typ der Wert von x ist, was zu Laufzeitverzögerungen führen kann.'},
     {'question': 'Warum ist es sinnvoll, temporären Variablen einen Hinweis auf den Typ der Werte zu geben?', 'answer': 'Es ist sinnvoll, temporären Variablen einen Hinweis auf den Typ der Werte zu geben, um die Lesbarkeit des Codes zu verbessern und die Funktion der Variablen für die Nutzerin der Funktion, die die Implementation nicht kennt, transparenter zu gestalten.'},
     {'question': 'Warum ist es sinnvoll, Variablen und Methoden mit Typen zu assoziieren?', 'answer': 'Es ist sinnvoll, Variablen und Methoden mit Typen zu assoziieren, um die Bedeutung der Variablen und Methoden für den Nutzer zu verdeutlichen. Zum Beispiel kann eine Deklaration der Methode next, die ListElement als Typ des Ein- und Ausgabeparameters deklariert, nahelegen, dass sie das in einer Liste auf den Eingabeparameter folgende Element zurückliefert. Ohne die Angabe der Parametertypen müsste man als Nutzerin der Funktion, die ihre Implementation nicht kennt, schon über ihren Zweck spekulieren.'},
     {'question': 'Wozu dient die Verknüpfung von deklarierten Elementen mit Typen?', 'answer': 'Die Verknüpfung von deklarierten Elementen mit Typen erlaubt die Angabe redundanter Information im Programm, was das Aufdecken von logischen Fehlern erleichtert. Denn nur wenn eine solche Redundanz vorliegt, können Widersprüche entstehen, die auf einen logischen Programmierfehler hinweisen.'},
     {'question': 'Was ist ein Vorteil von Typsystemen?', 'answer': 'Ein Vorteil von Typsystemen ist die dadurch entstehende Modularisierung von Programmen, wenn ein Typ zugleich eine Schnittstelle oder ein Interface ausdrückt.'},
     {'question': 'Was ist der Nachteil der dynamischen Typprüfung?', 'answer': 'Der Nachteil der dynamischen Typprüfung ist, dass sie zu spät kommt, nämlich zu einem Zeitpunkt, in dem man bereits nicht mehr viel anderes machen kann als einen Fehler zu signalisieren.'},
     {'question': 'Gibt es in SMALLTALK eine Typisierung?', 'answer': 'Nein, in SMALLTALK gibt es keine Typisierung, weder statisch noch dynamisch.'},
     {'question': 'Was ist der Unterschied zwischen dynamischer und statischer Typprüfung?', 'answer': 'Dynamische Typprüfung findet zur Laufzeit eines Programms statt und wird vom Laufzeitsystem oder der Programmiererin durchgeführt, während statische Typprüfung zur Übersetzungszeit stattfindet und vom Compiler durchgeführt wird. Statische Typprüfung stellt sicher, dass bei keiner Ausführung eines Programms eine Typinvariante verletzt wird, während dynamische Typprüfung dies zur Laufzeit überprüft. Statische Typprüfung ist nützlicher als dynamische Typprüfung, lehnt aber auch Programme ab, die nützlich, sinnvoll und typkorrekt sind.'},
     {'question': 'Was passiert, wenn das Typsystem eines Programms zu kompliziert wird?', 'answer': 'Wenn das Typsystem eines Programms zu kompliziert wird, wird es schwieriger zu benutzen und kann sogar so kompliziert sein wie das Programm, dessen Fehler es entdecken soll. In diesem Fall muss man bei auftretenden Typfehlern prüfen, ob die Ursache in einem fehlerhaften Programm oder in fehlerhaften Typannotationen liegt.'},
     {'question': 'Was passiert, wenn man versucht, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen?', 'answer': 'Wenn man versucht, möglichst wenige typkorrekte Programme durch die statische Typprüfung zurückzuweisen, wird das dazu notwendige Typsystem immer aufwendiger und schwieriger zu benutzen, bis es irgendwann so kompliziert ist wie das Programm, dessen Fehler es entdecken soll. In diesem Fall muss man bei auftretenden Typfehlern prüfen, ob die Ursache tatsächlich in einem fehlerhaften Programm oder in fehlerhaften Typannotationen liegt.'},
     {'question': 'Was ist ein Nachteil von ausdruckskräftigen Typsystemen?', 'answer': 'Ein Nachteil von ausdruckskräftigen Typsystemen ist, dass sie die Gestaltung von Schnittstellen erschweren können und die beteiligten Programme nicht ohne weiteres zusammenarbeiten können.'},
     ],
]
KE4_questions = [
    [{'question': 'Was sind die Hauptunterschiede zwischen C++ und Smalltalk in Bezug auf Objektorientierung?', 'answer': 'Die Hauptunterschiede zwischen C++ und Smalltalk in Bezug auf Objektorientierung sind, dass Smalltalk keine Strukturen (structs) kennt, alle Instanzvariablen in Smalltalk Referenzen sein können, Smalltalk Metaklassen anbietet und der Name einer Klasse in Smalltalk als Wert verwendet werden kann.'},
     {'question': 'Was sind Iteratoren in Java?', 'answer': 'Iteratoren in Java sind Objekte, die eine einheitliche Iteration über verschiedene Collection-Klassen ermöglichen. Jede Collection-Klasse, die Iterator implementiert, bietet eine Methode iterator() an, die ein Iteratorobjekt zurückliefert.'},
     {'question': 'Was ist ein Methodenambiguitätsfehler?', 'answer': 'Ein Methodenambiguitätsfehler tritt auf, wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind. Dies bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist.'},
     {'question': 'Was ist das grundlegende Problem von C++?', 'answer': 'Das grundlegende Problem von C++ ist, dass es eine Erweiterung von C ist.'},
     {'question': 'Was sind die Eigenschaften der Klasse Object in Java?', 'answer': 'Die Klasse Object definiert die Eigenschaften, die allen Objekten, einschließlich Array-Objekten, gemeinsam sind. Hierbei handelt es sich um elf Methoden, darunter clone() zum Erzeugen von Kopien, equals(Object) zum Test auf Gleichheit anstelle von Identität, toString() zur Rückgabe einer String-Repräsentation des Objekts, getClass() zur Ermittlung des Klassentyps, hashCode() zur Speicherung von Objekten in Hash-Tabellen, und finalize() zur Freigabe von externen Ressourcen, die mit dem Objekt verbunden sind.'},
     {'question': 'Was sind die Auswirkungen davon, dass Interfaces in Java auch Subtypen von Object sind?', 'answer': 'Interfaces können nicht wie Klassen instanziiert werden, aber sie können als Typen für Variablen, Parameter und Rückgabewerte verwendet werden. Da Interfaces auch Subtypen von Object sind, können sie daher überall dort verwendet werden, wo ein Object erwartet wird.'},
     {'question': 'Was ist der Subtyp von jedem Typ in Java?', 'answer': 'In Java ist jeder Typ ein Subtyp von Object, was auch für Interfaces gilt.'},
     {'question': 'Welche Rolle spielen Interfaces in Java?', 'answer': 'Interfaces in Java spielen eine wichtige Rolle bei der Abstraktion und der Schaffung von Schnittstellen, die von mehreren Klassen implementiert werden können. Sie ermöglichen es, die Abhängigkeiten zwischen Klassen zu verringern und die Code-Wiederverwendung zu erhöhen. Interfaces können auch als Verträge zwischen Klassen betrachtet werden, die sicherstellen, dass eine Klasse eine bestimmte Funktionalität bereitstellt.'},
     {'question': 'Was ist ein Klient einer Instanz?', 'answer': 'Ein Klient von Instanz einer Klasse kann auf die Methoden und Variablen der Klasse zugreifen.'},
     {'question': 'Was ist der Zweck von Interfaces in der Programmierung?', 'answer': 'Interfaces definieren eine Schnittstelle für Klassen, die eine bestimmte Funktionalität bereitstellen. Sie legen fest, welche Methoden eine Klasse implementieren muss, um ein bestimmtes Interface zu unterstützen. Durch Interfaces können Klienten auf die Funktionalität einer Klasse zugreifen, ohne von der konkreten Implementierung abhängig zu sein. In dem oben genannten Kontext können verschiedene Klienten entweder nur lesend oder nur schreibend auf einen Ein-/Ausgabestrom zugreifen, abhängig davon, welches Interface die Variable, die auf den Strom verweist, zum Typ hat.'},
     {'question': 'Was sind Tagging oder Marker Interfaces in Java?', 'answer': 'Tagging oder Marker Interfaces in Java haben keine eigenen Methodendeklarationen, sondern dienen lediglich der Filterung von Variablenwerten. Sie können erzwingen, dass einer Variablen nur Instanzen solcher Klassen zugewiesen werden, die das Interface zu implementieren deklarieren. Die Implementierung des Interfaces für die Klasse ist zunächst ohne Konsequenzen, kann aber zur Übersetzungszeit vom Compiler und zur Laufzeit durch einen Typtest überprüft werden.'},
     {'question': 'Was ist das Interface-als-Typ-Konzept in Java?', 'answer': 'Javas Interface-als-Typ-Konzept ist ein Mechanismus, bei dem Interfaces als Typen verwendet werden können. Dies ermöglicht es, eine Schnittstelle einer Klasse unabhängig von ihrer Implementierung zu definieren und verschiedene Klassen können diese Schnittstelle implementieren. Das Interface-als-Typ-Konzept ist ein wichtiger Beitrag von Java zur objektorientierten Programmierung, wird aber in der Praxis nur langsam angenommen.'},
     {'question': 'Wie würden Sie die Programmiersprache Java beschreiben?', 'answer': 'Java ist eine konventionelle Programmiersprache, die in vielerlei Hinsicht SMALLTALK ähnelt, aber auch Unterschiede aufweist. Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss.'},
     {'question': 'Was ist der Java Community Process?', 'answer': 'Der Java Community Process ist ein Prozess, bei dem aktiven Entwicklern die Möglichkeit eingeräumt wird, Vorschläge zur Spracherweiterung von Java zu machen. Dabei ist jedoch auf Rückwärtskompatibilität zu achten, um die riesige Menge an Software, die in Java geschrieben ist, nicht zu beeinträchtigen.'},
     {'question': 'Was sind die grundlegenden Werkzeuge der Java-Programmierung?', 'answer': 'Die grundlegenden Werkzeuge der Java-Programmierung sind der Editor, der Java-Compiler Javac, die JVM, die Java-Klassenbibliothek (das sogenannte Application Programming Interface, API) und die Dokumentation (API-Dokumentation und Sprachdefinition).'},
     {'question': 'Was ist der Zweck der main-Methode in Java?', 'answer': 'Die main-Methode ist der Einstiegspunkt für die Ausführung eines Java-Programms. Das Betriebssystem übergibt der JVM den Namen der Klasse, die die main-Methode enthält, als Parameter, um das Programm auszuführen.'},
     {'question': 'Was ist die Java Virtual Machine (JVM)?', 'answer': 'Die JVM ist eine virtuelle Maschine, die Bytecode-Anweisungen ausführt, die von einem Java-Compiler erzeugt wurden. Sie ermöglicht es, Java-Programme auf verschiedenen Geräten und Betriebssystemen auszuführen.'},
     {'question': 'Was ist die Funktion von Default-Methoden in Java?', 'answer': 'In Java 8 können Interfaces die Implementierung einer Methode vorgeben, die dann an implementierende Klassen (oder per "extends" abgeleitete Interfaces) vererbt wird. Dafür wurde das Schlüsselwort "default" eingeführt. Default-Methoden können allenfalls auf abstrakte Getter und Setter zugreifen, da Interfaces keine Instanzvariablen haben.'},
     {'question': 'Was ist der Zweck von privaten Methoden in Interfaces in Java?', 'answer': 'Der Zweck von privaten Methoden in Interfaces in Java 9 ist die Verbesserung der Lesbarkeit von Default-Methoden, indem man zusammenhängende Teile aus ihnen herauslöst und in private Methoden verlegt. Diese privaten Methoden sind ausschließlich aus dem Interface selbst heraus zugreifbar.'},
     {'question': 'Was ist ein Event (Ereignis) in C-Sharp?', 'answer': 'Ein Event (Ereignis) in C-Sharp ist ein Konstrukt, über das sog. Event handler aktiviert werden können. Die Handhabung von Ereignissen erfolgt über die in Abschnitt 50.4.1 skizzierten sog. Delegates. Leider ist die Syntax von C-Sharp, die mit Deklaration und Registrierung von Eventhandlern sowie der Verbreitung von Ereignissen verbunden ist, nach Ansicht des Autors dieses Textes komplett unleserlich geraten, so dass hier auf eine weitergehende Befassung mit dem Thema verzichtet wird.'},
     {'question': 'Welche Besonderheiten gibt es bei Zuweisungen von Pointervariablen in C++?', 'answer': 'Bei Zuweisungen von Pointervariablen muss man sich in C++ genau überlegen, ob man Pointer oder die Werte, auf die die Pointer zeigen, zuweisen möchte. C++ verwendet standardmäßig "Call by value" für Methodenaufrufe, was bedeutet, dass Kopien von Parametern übergeben werden.'},
     {'question': 'Wie erfolgt die Übertragung von Parametern in C++-Methodenaufrufen?', 'answer': 'In C++-Methodenaufrufen erfolgt die Übertragung von Parametern standardmäßig durch "Call by value", was bedeutet, dass Kopien der Parameter übergeben werden.'},
     {'question': 'Was ist Generizität in C-Sharp?', 'answer': 'Generizität in C-Sharp ermöglicht es, parametrischen Polymorphismus sowohl für Klassen als auch für Methoden zu nutzen. Sie erlaubt die Definition von generischen Klassen und Interfaces, die eine Menge von Typen spezifizieren, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen.'},
     {'question': 'Welche Arten von Generizität werden in C-Sharp unterstützt?', 'answer': 'C-Sharp unterstützt sowohl beschränkte als auch unbeschränkte parametrische Polymorphismus für Klassen und Methoden. Dies bedeutet, dass Typparameter sowohl eingeschränkte (mit bestimmten Anforderungen) als auch unbeschränkte (ohne Anforderungen) Typen sein können.'},
     {'question': 'Welche Freiheit bietet der Präprozessor in C++?', 'answer': 'Der Präprozessor in C++ bietet die Freiheit, die Syntax der Sprache durch Hinzufügen einer neuen Syntax zu verändern. Dies ermöglicht es, Code in einer für Entwickler verständlicheren Weise zu schreiben, wenn gewünscht.'},
     {'question': 'Was sind explizite Interfaceimplementierungen in C-Sharp?', 'answer': 'Explizite Interfaceimplementierungen in C-Sharp ermöglichen es einer Klasse, die gleiche Methodendeklaration von verschiedenen Interfaces getrennt voneinander zu implementieren. Dies wird durch die Angabe des Interfacequalifikators vor der Methode erreicht.'},
     {'question': 'Welchen Nutzen haben explizite Interfaceimplementierungen in C-Sharp?', 'answer': 'Der Nutzen von expliziten Interfaceimplementierungen liegt darin, dass die Methode je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Dies ermöglicht es, verschiedene Verhaltensweisen für denselben Methodennamen in verschiedenen Kontexten zu definieren.'},
     {'question': 'Welche Arten von Vererbung erlaubt EIFFEL?', 'answer': 'EIFFEL erlaubt Mehrfachvererbung, was bedeutet, dass eine Klasse von mehreren anderen Klassen erben kann.'},
     {'question': 'Ist das Überladen in EIFFEL erlaubt?', 'answer': 'In EIFFEL ist es nicht erlaubt, dass eine Klasse zwei Methoden mit demselben Namen besitzt.'},
     {'question': 'Was ist die Just-in-time-(JIT-)Kompilierung in C-Sharp?', 'answer': 'In C-Sharp ist die Just-in-time-(JIT-)Kompilierung die Standardmethode zur Übersetzung des CIL-Codes in Maschinencode. Dieser Vorgang erfolgt unmittelbar vor der Ausführung und nur dann, wenn der Code tatsächlich ausgeführt wird. Im Gegensatz dazu verwendet Java normalerweise den Ahead-of-time-(AOT-)Kompilierungsansatz, bei dem der Bytecode vor der Ausführung in nativen Maschinencode übersetzt wird. Die JIT-Kompilierung in C-Sharp ermöglicht eine feinere Granularität, da sie bis auf die Ebene einzelner Methoden herabgeht.'},
     {'question': 'Wie geht EIFFEL mit Zusicherungen (Assertions) um?', 'answer': 'Ein herausragendes Merkmal von EIFFEL ist die Integration von Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen. Anders als in Java, wo Zusicherungen flexibel platziert werden können, gibt es in EIFFEL spezielle vorgesehene Stellen für diese Zusicherungen.'},
     {'question': 'Wie werden in EIFFEL Vor- und Nachbedingungen für Methoden zu definiert?', 'answer': 'In EIFFEL werden die Schlüsselwörter "require" (vor der Implementierung der Methode) und "ensure" (nach der Implementierung der Methode) verwendet, um Vor- und Nachbedingungen für Methoden zu definieren.'},
     {'question': 'Was sind Klasseninvarianten in EIFFEL?', 'answer': 'Klasseninvarianten in EIFFEL sind Bedingungen, die zwischen zwei Methodenaufrufen in einer Klasse immer gelten müssen. Sie werden mit dem Schlüsselwort "invariant" deklariert und sind sozusagen eine Zusammenfassung von Vor- und Nachbedingungen, die für die Klasse als Ganzes gelten.'},
     {'question': 'Welche Rolle nimmt EIFFEL unter den Programmeirsprachen ein?', 'answer': 'EIFFEL nimmt eine besondere Position unter den behandelten Sprachen ein, da es mehrere Funktionen erfüllt: Es dient als Sprache für objektorientierte Analyse und Design, für kommerzielle Programmierung und als akademische Lehrsprache.'},
     {'question': 'Welche Abweichungen gibt es in EIFFEL im Vergleich zu anderen Sprachen?', 'answer': 'Obwohl EIFFEL syntaktisch Ähnlichkeiten zu anderen Sprachen wie PASCAL aufweist, gibt es einige Abweichungen. Diese Abweichungen sind jedoch gut begründet und bieten eine alternative Perspektive auf vertraute Konzepte. Sie tragen dazu bei, klarere und orthogonalere Konzepte zu schaffen.'},
     {'question': 'Was ist das Common Type System (CTS) in C-Sharp?', 'answer': 'Das Common Type System (CTS) ist ein Teil des .NET-Frameworks und sorgt dafür, dass Typen, die in verschiedenen .NET-Sprachen definiert wurden, gemeinsam genutzt werden können. Es stellt sicher, dass Typen in einer einheitlichen Hierarchie organisiert sind und in verschiedenen .NET-Sprachen verwendet werden können, als wären sie in der jeweiligen Sprache selbst definiert worden. Dies erleichtert die Interoperabilität zwischen verschiedenen .NET-Sprachen und ermöglicht es, Bibliotheken und Komponenten in verschiedenen Sprachen zu verwenden.'},
     {'question': 'Welche Arten von Werttypen gibt es in C-Sharp?', 'answer': 'In C-Sharp gibt es verschiedene Arten von Werttypen, darunter die primitiven Typen (z. B. int, bool, double), Aufzählungstypen (enum) und vom Entwickler definierte Werttypen. Werttypen werden in C-Sharp mit dem Typkonstruktor "struct" erstellt und können Methoden und Konstruktoren haben, jedoch erlauben sie keine Typerweiterung oder Vererbung.'},
     {'question': 'Welche Arten von Referenztypen gibt es in C-Sharp?', 'answer': 'In C-Sharp gibt es verschiedene Arten von Referenztypen, darunter Klassen, Interfaces, Arrays, Delegates und Attribut-Typen. Diese Referenztypen ermöglichen eine größere Vielfalt an Programmierkonzepten und -strukturen in C-Sharp.'},
     {'question': 'Was sind Delegates in C-Sharp und wozu dienen sie?', 'answer': 'Delegates in C-Sharp sind Zeiger auf an ein Objekt gebundene einzelne Methoden. Sie ermöglichen es, Funktionen und Methoden als Parameter an andere Funktionen oder Methoden zu übergeben, was besonders nützlich für Problemstellungen wie Listener-Mechanismen ist. Delegates ersetzen die aus anderen Sprachen bekannten Funktionszeiger oder Funktionspointer.'},
     {'question': 'Was ist Runtime Type Information (RTTI) in C++?', 'answer': 'Runtime Type Information (RTTI) ist eine Funktion in C++, die es ermöglicht, für Objekte mit dynamisch gebundenen Methoden festzustellen, welcher Klasse sie angehören. RTTI ermöglicht die Ermittlung des Typs eines Objekts zur Laufzeit.'},
     {'question': 'Welche Aufgaben können Zugriffsmethoden in EIFFEL erfüllen?', 'answer': 'Neben dem Lesen und Setzen von Instanzvariablen können Zugriffsmethoden in EIFFEL auch andere Aufgaben erfüllen, wie das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen.'},
     {'question': 'Was sind Features in EIFFEL?', 'answer': 'In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als "Features" bezeichnet. Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL.'},
     {'question': 'Was ist das Besondere an der Definition einer Schnittstelle in EIFFEL?', 'answer': 'Die Definition einer Schnittstelle in EIFFEL ist recht unspezifisch. Alle Klienten einer Klasse haben standardmäßig das gleiche Bild von ihr. Statt den Zugriff an Pakete oder Freunde zu binden, bietet EIFFEL die Möglichkeit, einzelne Features gezielt zu veröffentlichen (exportieren).'},
     {'question': 'Wie würden Sie das Programmiermodell von EIFFEL beschreiben?', 'answer': 'Das Programmiermodell von EIFFEL ist rein objektorientiert, bei dem der gesamte Code in Klassen organisiert ist. Diese Klassen können separat übersetzt werden, und die Ausführung erfolgt direkt auf der Zielmaschine.'},
     {'question': 'Welche Methode verwendet EIFFEL zur Speicherfreigabe?', 'answer': 'EIFFEL verwendet Garbage Collection zur Speicherfreigabe.'},
     {'question': 'Welche Gemeinsamkeiten gibt es zwischen C-Sharp und Java ?', 'answer': 'C-Sharp und Java weisen in Bezug auf Objekte, Variablen und Ausdrücke, Anweisungen, Blöcke und Kontrollstrukturen viele Gemeinsamkeiten auf. Die grundlegende Syntax und Struktur der beiden Sprachen sind ähnlich. In beiden Sprachen werden Klassen verwendet, um Objekte zu erstellen, Variablen und Ausdrücke zu definieren, Anweisungen auszuführen und Kontrollstrukturen zu steuern.'},
     {'question': 'Welche Besonderheit gibt es in C-Sharp in Bezug auf die Überladung von Operatoren?', 'answer': 'In C-Sharp ist es möglich, Operatoren wie +, -, == usw. zu überladen. Dies wird durch das Schlüsselwort "operator" ermöglicht, das in einer Operatordefinition vorangestellt wird. Die Überladung von Operatoren erfolgt ähnlich wie die Definition von Methoden, aber anstelle von Methodennamen werden die Operatorzeichen verwendet.'},
     {'question': 'Was sind "Call by reference" und "Call by value" in C-Sharp umgesetzt?', 'answer': 'In C-Sharp ermöglicht "Call by reference" (auch als "ref" und "out" bekannt) das Übergeben von Argumenten an Methoden, bei denen die Änderungen an den Parametern innerhalb der Methode auf die ursprünglichen Argumente außerhalb der Methode angewendet werden. Im Gegensatz dazu verwendet "Call by value" Kopien der Argumente, und Änderungen innerhalb der Methode haben keine Auswirkungen auf die ursprünglichen Argumente.'},
     {'question': 'Was ist ein herausragendes Merkmal des Typsystems von EIFFEL?', 'answer': 'Ein herausragendes Merkmal des Typsystems von EIFFEL ist die Unterstützung von Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen (Löschen von Methoden), sowie kovariante Redefinitionen, die durch "verankerte Typen" ermöglicht werden.'},
     {'question': 'Welche Bedeutung haben "verankerte Typen" im Kontext von kovarianten Redefinitionen in EIFFEL?', 'answer': '"Verankerte Typen" (engl. "anchored types") spielen im Kontext von kovarianten Redefinitionen in EIFFEL eine wichtige Rolle. Sie ermöglichen es, die Kovarianz bei der Redefinition von Methoden zu unterstützen und sind eine besondere Eigenschaft von EIFFEL.'},
     {'question': 'Was sind einige der Eigenschaften des Typsystems von EIFFEL?', 'answer': 'Einige der prominenten Eigenschaften des Typsystems von EIFFEL sind Mehrfachvererbung, Generizität (beschränkter parametrischer Polymorphismus), das Unterdrücken von Instanzvariablen und Methoden in Subklassen sowie die Unterstützung kovarianter Redefinitionen durch "verankerte Typen".'},
     {'question': 'Welche Arten von Anweisungen gibt es in EIFFEL?', 'answer': 'In EIFFEL gibt es Anweisungen, die aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung bestehen.'},
     {'question': 'Welche Prinzipien der Programmierung werden von EIFFEL strikt eingehalten?', 'answer': 'EIFFEL hält sich strikt an die Prinzipien strukturierter Programmierung, was bedeutet, dass jede Kontrollstruktur genau einen Eingang und einen Ausgang hat.'},
     {'question': 'Welche Besonderheit bietet das Exception Handling in EIFFEL?', 'answer': 'EIFFEL bietet ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet, insbesondere erlaubt es ein "Retry", also das Wiederholen eines fehlgeschlagenen Versuchs, während dies in anderen Sprachen durch Codiermuster umgesetzt werden muss.'},
     {'question': 'Welche Rolle spielt der Zuweisungsversuch bei kovarianten Redefinitionen in EIFFEL?', 'answer': 'Der Zuweisungsversuch spielt eine Rolle bei kovarianten Redefinitionen in EIFFEL, da er verwendet wird, um dynamische Bindungen programmatisch zu emulieren. Da EIFFEL polymorphe CAT-Calls verbietet, werden Zuweisungsversuche genutzt, um das dynamische Binden zu ermöglichen.'},
     {'question': 'Welche Probleme ergeben sich aus der Verwendung von kovarianten Redefinitionen in EIFFEL?', 'answer': 'Die Verwendung von kovarianten Redefinitionen in EIFFEL kann zu Problemen führen, insbesondere wenn dynamische Bindungen auftreten. Dies kann dazu führen, dass Typen inkonsistent werden und unerwartetes Verhalten auftritt.'},
     {'question': 'Welche Rolle spielen verankerte Typdeklarationen in EIFFEL?', 'answer': 'Verankerte Typdeklarationen in EIFFEL ermöglichen es, den Typ von Variablen automatisch an den Typ eines bereits typisierten Programms zu binden. Dies erleichtert die Verwendung von kovarianten Redefinitionen.'},
     {'question': 'Wie würden Sie das Programmiermodell von C++ beschreiben?', 'answer': 'Das Programmiermodell von C++ ist ein klassisches Modell, bei dem Programme als eine Menge von Quellcode-Dateien geschrieben werden, die auf einer Zielmaschine direkt in ausführbaren Maschinencode übersetzt werden.'},
     {'question': 'Was ist das Ziel des Typsystems von C++?', 'answer': 'Das Ziel des Typsystems von C++ ist, objektorientierte Programmierung mit starker Typsicherheit zu ermöglichen, während gleichzeitig die volle Freiheit der Programmiererin erhalten bleibt und der Laufzeit-Overhead minimiert wird.'},
     {'question': 'Welche primitive Datentypen gibt es in C++?', 'answer': 'In C++ gibt es primitive Datentypen wie int, bool, etc. Diese Datentypen sind genau wie die durch Klassen definierten Typen, Typen mit Wertsemantik.'},
     {'question': 'Welche Eigenschaften sollte eine typsichere Sprache haben?', 'answer': 'Eine typsichere Sprache wie C-Sharp soll strikte Typprüfungen durchführen, um sicherzustellen, dass Variablen nur Werte akzeptieren, die ihrem deklarierten Typ entsprechen.'},
     {'question': 'Was sind explizite Interfaceimplementierungen in C-Sharp?', 'answer': 'Explizite Interfaceimplementierungen in C-Sharp ermöglichen es einer Klasse, dieselbe Methodendeklaration, die von verschiedenen Interfaces "geerbt" wurde, getrennt voneinander zu implementieren. Dies wird erreicht, indem die Methodendeklaration mit dem Namen des Interfaces und dem Doppelpunkt versehen wird.'},
     {'question': 'Was ist der Nutzen der expliziten Interfaceimplementierung in C-Sharp?', 'answer': 'Der Nutzen der expliziten Interfaceimplementierung liegt darin, dass die Methode gibTelefonnummer() je nach Aufruf unterschiedlich reagiert, abhängig davon, über welches Interface sie angesprochen wird. Der Typ der Variablen (oder des Ausdrucks), die als Empfänger fungiert, gibt gewissermaßen die Rolle vor, in der das Objekt angesprochen wird.'},
     {'question': 'Was ist die Funktion der ungarischen Notation in C-Sharp?', 'answer': 'Die ungarische Notation in C-Sharp wird verwendet, um die Typen von Variablen und Methoden zu identifizieren, indem man den Variablen- oder Methodennamen mit einem Präfix versehen, das den Typ angibt. In diesem Fall wird die ungarische Notation verwendet, um die implizite Interfaceimplementierung in C-Sharp aufzulösen, indem alle Interfacenamen mit einem "I" beginnen.'},
     {'question': 'Was ist die Position von Bertrand Meyer zum Überladen von Methoden?', 'answer': 'Bertrand Meyer ist ein entschiedener Gegner des Überladens.'},
     {'question': 'Ist es in Eiffel erlaubt, das zwei Methoden den gleichen Namen haben?', 'answer': 'In Eiffel ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben, solange diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen oder die Methoden gleiche oder kovariant redefinierte Parameter haben.'},
     {'question': 'Was ist die Reflection API in Java?', 'answer': 'Die Reflection API in Java ist eine Programmierschnittstelle, die es ermöglicht, auf die Elemente eines Programms zuzugreifen und diese zu untersuchen. Es enthält Klassen, die Instanzen entsprechender Programmelemente repräsentieren, wie zum Beispiel Methoden und Felder.'},
     {'question': 'Was sind Annotationen in Java?', 'answer': 'Annotationen in Java 5 sind eine spezielle Art von Interfaces, die nur Felder deklarieren und zur Zuordnung von Programmmetadaten zu Programmelementen im Quelltext dienen. Diese können während der Übersetzung und/oder Ausführung des Programms abgefragt und den jeweiligen Prozess beeinflussen oder sogar steuern.'},
     {'question': 'Was ist ein Modul in der Programmierung?', 'answer': 'Ein Modul ist eine Einheit von Programmelementen, die nur über die Schnittstelle des Moduls von außen zugänglich sind. Damit behält ein Modul einen Teil seiner Implementierung für sich und hütet ein Implementationsgeheimnis. Der Teil, den es nach außen trägt, gilt als öffentlich.'},
     {'question': 'Was ist die Funktion des "unsafe"-Modifikators in C-Sharp?', 'answer': 'Der "unsafe"-Modifikator in C-Sharp dient dazu, Bereiche im Programm zu markieren, in denen explizite Speicherverwaltung und das Hantieren mit Pointern erlaubt sind. Diese Bereiche werden als "unsicher" bezeichnet.'},
     {'question': 'Was sind die Funktionen von Klassen in Java?', 'answer': 'Klassen in Java haben drei Funktionen: Sie dienen als Vorlage für die Erzeugung von Objekten, sie liefern Typen für ein Programm und sie dienen der Modularisierung.'},
     {'question': 'Was sind Pakete in der Programmierung?', 'answer': 'Pakete sind in der Programmierung Sammlungen von Klassen und dienen gleichzeitig als Namensräume für sie. Sie haben eine hierarchische Organisation, aber diese hat keine Bedeutung. Pakete erlauben keinen privilegierten Zugriff auf Klassen ihrer Subpakete. Damit Klassen paketübergreifend aufeinander zugreifen können, bedarf es expliziter Import-Deklarationen unter Nennung der jeweiligen Paketnamen.'},
     {'question': 'Was ist Sichtbarkeit in Java?', 'answer': 'In Java bezieht sich Sichtbarkeit auf lexikalische Scopes und wird durch Hiding, Shadowing und Obscuring eingeschränkt. Sie kann bisweilen über Qualifizierer wiederhergestellt werden.'},
     {'question': 'Was sind Array-Initialisierer in Java?', 'answer': 'Array-Initialisierer in Java sind eine Möglichkeit, Arrays mit Werten zu initialisieren. Sie werden verwendet, um die Elemente eines Arrays bei der Erstellung des Arrays zu initialisieren. Die Elemente werden in geschweiften Klammern ({}) aufgelistet, getrennt durch Kommas. Zum Beispiel: int[] arr = {1, 2, 3}; erstellt ein Array von ganzen Zahlen mit den Werten 1, 2 und 3.'},
     {'question': 'Was ist ein Klassenliteral in Java?', 'answer': 'Ein Klassenliteral in Java ist eine Notation, die aus dem Namen der Klasse, gefolgt von ".class" besteht, und mit der man Klassen als Werte angeben kann.'},
     {'question': 'Was ist das Typsystem von Java?', 'answer': 'Das Typsystem von Java hat eine starke statische Komponente, bei der jedoch nicht alle Typprüfungen zur Übersetzungszeit durchgeführt werden können. Für manche Typumwandlungen sind dynamische Typprüfungen notwendig.'},
     {'question': 'Was ist der Zweck von Wildcards in Java?', 'answer': 'Der Zweck von Wildcards in Java ist es, die dynamischen Typprüfungen bei Arrays zu vermeiden.'},
     {'question': 'Was sind Wildcards in Java?', 'answer': 'Wildcards in Java sind eine Möglichkeit, dynamische Typprüfungen bei Arrays zu vermeiden. Sie ermöglichen es, Arrays mit unterschiedlichen Typen zu verwenden, ohne dass statische Typprüfungen zur Übersetzungszeit erforderlich sind.'},
     {'question': 'Was ist eine öffentliche Schnittstelle in Java?', 'answer': 'In Java ist eine öffentliche Schnittstelle eine eigenständige Deklaration, die von der Klasse unabhängig ist und einen Typ definiert. Sie wird mit Hilfe des Schlüsselwortes "interface" deklariert und enthält eine Menge von Instanzvariablen und -methoden, die public deklariert sind.'},
     {'question': 'Was sind Interfaces in Java?', 'answer': 'Interfaces in Java definieren Typen und können daher in Variablendeklarationen verwendet werden. Der Type checker garantiert, dass auf der Variablen mit Namen „Variablenname“ nur die Methoden aufgerufen werden können, die im Interface mit Namen „Interfacename“ deklariert sind, selbst wenn das Objekt, das die Variable benennt, mehr anbietet. So ist es möglich, dass Methoden und Felder einer Instanz vor anderen Instanzen anderer oder derselben Klasse verborgen werden können: Man deklariert einfach die Variablen, die auf die Instanz verweisen, mit dem Interface als Typ.'},
     {'question': 'Was ist Interfacevererbung in Java?', 'answer': 'Interfacevererbung in Java bedeutet, dass eine Klasse mehrere Interfaces gleichzeitig implementieren kann. Dabei wird nichts vererbt, sondern es handelt sich um eine Art Mehrfach-Subtyping.'},
     {'question': 'Was ist Typkonformität in Java?', 'answer': 'In Java ist die Typkonformität und damit die Zuweisungskompatibilität unter Referenztypen an Subtyping gebunden. Damit Ausdrücke von einem Typ Variablen eines anderen zugeordnet werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen den beiden bestehen. Java setzt auf nominale Typkonformität, das heißt, dass Subtypen ihre Supertypen namentlich kennen müssen.'},
     {'question': 'Was ist nominale Typkonformität in Java?', 'answer': 'In Java ist nominale Typkonformität eine Art von Typkonformität, bei der die Typen entweder identisch sein müssen oder eine Subtypbeziehung zwischen den beiden bestehen muss, die explizit deklariert werden muss. Das bedeutet, dass Subtypen ihre Supertypen namentlich kennen müssen.'},
     {'question': 'Was ist Kovarianz in Java?', 'answer': 'In Java ist Kovarianz eine Regel im Subtyping, die vorschreibt, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen. Dadurch wird eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt.'},
     {'question': 'Was ist ein strenges Typsystem in Java?', 'answer': 'Ein strenges Typsystem in Java bedeutet, dass alle Typfehler während der Übersetzung durch den Compiler oder während der Laufzeit erkannt werden, insbesondere bei einer Wertzuweisung, bei der eine Typinvariante verletzt wird.'},
     {'question': 'Was sind Konstruktoren in Java?', 'answer': 'Konstruktoren sind spezielle Methoden in Java, die verwendet werden, um Objekte zu erzeugen, die keine literale Repräsentation haben. Sie sind keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Konstruktoren verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können.'},
     {'question': 'Was ist der Zweck eines Konstruktors in Java?', 'answer': 'Der Zweck eines Konstruktors in Java ist es, eine neue Instanz der Klasse zu erzeugen und gegebenenfalls die Variablen der Klasse zu initialisieren. Wird kein Konstruktor definiert, wird standardmäßig ein impliziter parameterloser Konstruktor verwendet. Konstruktoren werden nicht vererbt, aber beim Erzeugen einer Instanz einer Subklasse wird automatisch der Standardkonstruktor der Superklasse aufgerufen.'},
     {'question': 'Was sind Factory-Methoden in Java?', 'answer': 'Factory-Methoden sind Klassenmethoden in Java, die zur Objekterzeugung verwendet werden können. Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben.'},
     {'question': 'Was ist Exception Handling in Java?', 'answer': 'Exception Handling in Java ist eine Möglichkeit, bei der Spezifikation des Kontrollflusses eines Programms zunächst mögliche Ausnahmesituationen und deren Behandlung unberücksichtigt zu lassen und so zu tun, als würde immer alles gutgehen. Es erlaubt sowohl der Autorin als auch dem Leser eines Programms, sich auf die Hauptfunktion zu konzentrieren, mit dem Motto "Zu den Ausnahmen kommen wir später!".'},
     {'question': 'Was ist eine Exception in Java?', 'answer': 'In Java sind Exceptions Instanzen von Klassen, die jeweils eine konkrete Ausnahmesituation während des Programmablaufs repräsentieren. Wenn eine Exception geworfen wird, wird der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist.'},
     {'question': 'Was ist der Zweck von Try-Catch-Blöcken in Java?', 'answer': 'Try-Catch-Blöcke in Java werden verwendet, um Ausnahmesituationen während des Programmablaufs abzufangen und zu behandeln. Der Codeabschnitt, in dem die Exception auftreten kann, wird in den Try-Block eingefasst, während der Catch-Block den Code enthält, der die Exception behandelt.'},
     {'question': 'Was ist der Zweck der Throws-Klausel in Java?', 'answer': 'Die Throws-Klausel in Java wird verwendet, um eine Methode zu deklarieren, dass sie eine bestimmte Exception wirft, ohne sie selbst abzufangen. Dies muss geschehen, wenn die Methode eine Exception wirft und kein passender Catch-Block vorhanden ist.'},
     {'question': 'Was ist ein Try-Catch-Block in der Programmierung?', 'answer': 'Ein Try-Catch-Block ist eine Programmstruktur, die eine Ausnahmebehandlung ermöglicht. Der Try-Block enthält den Code, der möglicherweise eine Ausnahme auslöst, während der Catch-Block den Code enthält, der die Ausnahme behandelt.'},
     {'question': 'Was sind Checked Exceptions?', 'answer': 'Checked Exceptions sind Exceptions, die eine Deklaration im Methodenkopf erfordern oder innerhalb der Methode behandelt werden müssen. Diese Praxis kann zwar zu erheblichem Schreibaufwand führen, stellt jedoch sicher, dass die Programmierer sich der möglichen Ausnahmesituationen bewusst sind, ohne die Kontrollflussspezifikation übermäßig zu belasten.'},
     {'question': 'Was sind Unchecked Exceptions?', 'answer': 'Unchecked Exceptions sind Exceptions, die in der Praxis überall auftreten können und nicht explizit deklariert werden müssen. Einige Beispiele für Unchecked Exceptions sind "Out of Memory Exception", "Null Pointer Exception" und "Array Index Out of Bounds Exception".'},
     {'question': 'Was sind Unchecked Exceptions in Java?', 'answer': 'Unchecked Exceptions in Java sind Exceptions, bei denen es nicht erforderlich ist, jede Anweisung, bei der eine solche Exception auftreten könnte, mit einem Try-Catch-Block abzusichern. Alle Exceptions, die von der Klasse RuntimeException abgeleitet sind, werden als Unchecked Exceptions betrachtet.'},
     {'question': 'Was ist der Zugriffsschutz in Java?', 'answer': 'In Java wird der Zugriffsschutz durch die Zugriffskontrollmodifikatoren private, protected und public realisiert. Diese Modifikatoren bestimmen, welche Klassen auf die Elemente einer anderen Klasse zugreifen können. Standardmäßig ist alles, was nicht explizit als privat, geschützt oder öffentlich deklariert ist, in Java package-private, d.h. nur innerhalb des Pakets sichtbar.'},
     {'question': 'Was ist der privilegierte Zugriff in Java?', 'answer': 'In Java wird der privilegierte Zugriff durch die Zugriffskontrollmodifikatoren private, protected und public realisiert. Diese Modifikatoren bestimmen, welche Klassen auf die Elemente einer anderen Klasse zugreifen können. Klassen, die sich im selben Paket befinden, können auf package-private Elemente zugreifen, und Klassen, die eine Klasse erweitern, können auf protected Elemente zugreifen. Somit gewähren sich die Klassen eines Programms untereinander privilegierten Zugriff.'},
     {'question': 'Was ist die private Schnittstelle eines Moduls?', 'answer': 'Die private Schnittstelle eines Moduls besteht aus allen Deklarationen, die nicht Teil der öffentlichen Schnittstelle sind.'},
     {'question': 'Was ist die öffentliche Schnittstelle eines Moduls?', 'answer': 'Die öffentliche Schnittstelle eines Moduls besteht aus allen Deklarationen, die mit einem Schlüsselwort als öffentlich gekennzeichnet sind.'},
     {'question': 'Was ist die Open Services Gateway Initiative (OSGi)?', 'answer': 'Die Open Services Gateway Initiative (OSGi) ist ein Standard, der die Zusammenfassung von Java-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation erlaubt. Dieser Standard ist unter anderem die Grundlage von Eclipse, das nicht nur eine Java-IDE, sondern im Kern ein Framework für die Entwicklung beliebig komplexer Java-Programme (sog. Rich Clients) ist.'},
     {'question': 'Was ist ein Modul in Java?', 'answer': 'Ein Modul in Java 9 ist eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Eine Moduldeklaration besteht aus einem (eindeutigen) Namen des Moduls, einer Deklaration der angebotenen Schnittstelle und einer Deklaration der benötigten Schnittstelle. Neben den allgemeinen Export tritt der sog. qualifizierte Export, der den Austausch zwischen bestimmten Modulen erlaubt.'},
     {'question': 'Was sind Streams in Java?', 'answer': 'Streams in Java sind ein Framework, das interne Iterationen à la SMALLTALK erlaubt. Mit Hilfe von Streams können Methoden wie forEach, filter, map und reduce definiert werden, die auf Collection-Klassen angewendet werden können.'},
     {'question': 'Was sind Streams in Java 8?', 'answer': 'Streams in Java 8 sind ein neues Konstrukt, das eine Datenverarbeitung in Pipelines ermöglicht. Sie sind interne Iteratoren, die eine potenziell unendliche Folge von Elementen halten. Streams können entweder abgeschlossenen Datenspeichern wie Collections und Files oder offenen Datenlieferanten wie der Tastatur oder Datengeneratoren als Quelle dienen. Ein Ergebnis liefert eine Stream-Pipeline immer durch einen Abschluss, also eine Methode, die ein anderes Ergebnis als einen Stream liefert.'},
     {'question': 'Welche beiden Interfaces in Java ermöglichen eine einheitliche Iteration über Collections mittels Iteratoren?', 'answer': 'In Java ermöglichen die beiden Interfaces Enumeration (total veraltet) und Iterator (etwas neuer) eine einheitliche Iteration über Collections mittels Iteratoren.'},
     {'question': 'Was ist das Überschreiben von Methoden in Java, und welche Bedingungen gelten dafür?', 'answer': 'Das Überschreiben von Methoden in Java bedeutet, dass eine bereits vorhandene Methode in einer Subklasse mit derselben Signatur (Methodenname und formale Parametertypen) neu definiert wird. Die Bedingungen dafür sind, dass die Methode denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode hat und dass die deklarierten Parametertypen der Methode Subtypen der deklarierten Parametertypen der Methode in der Superklasse sind.'},
     {'question': 'Was ist das Überladen von Methoden in Java, und wie unterscheidet es sich vom Überschreiben?', 'answer': 'Das Überladen von Methoden in Java bedeutet, dass Methoden denselben Namen haben, aber verschiedene Parametertypen in derselben Klasse oder einer Subklasse haben. Der Unterschied zum Überschreiben besteht darin, dass beim Überladen neue Methoden hinzugefügt werden, während beim Überschreiben bereits vorhandene Methoden neu definiert werden.'},
     {'question': 'Was ist dynamisches Binden in Java, und wie funktioniert der Bindungsalgorithmus?', 'answer': 'Das dynamische Binden in Java bezieht sich auf die Auswahl der Methode zur Laufzeit, basierend auf dem tatsächlichen Typ des Empfängerobjekts. Der Bindungsalgorithmus in Java wählt die Methode aus, die die folgenden Bedingungen erfüllt: Sie hat denselben Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode, ist in der Klasse des deklarierten Typs des Ausdrucks deklariert und deren deklarierte Parametertypen sind Subtypen der deklarierten Parametertypen der aufgerufenen Methode. Wenn mehrere Methoden die Bedingungen erfüllen, wird diejenige ausgewählt, deren Klasse am nächsten zur Klasse des Empfängerobjekts in der Superklassenkette ist.'},
     {'question': 'Was sind die Einschränkungen von Java-Arrays im Vergleich zu Collections?', 'answer': 'Java-Arrays haben im Vergleich zu Collections Einschränkungen in ihrer Funktionalität. Sie bieten keine eigenen Methoden zur Unterstützung des Zugriffs, kein dynamisches Wachstum und es gibt einige Probleme mit dem Subtyping von Arrays.'},
     {'question': 'Welche Rolle spielen Interfaces bei der Einschränkung des Zugriffs auf Methoden in Java?', 'answer': 'Interfaces können dazu verwendet werden, den Zugriff auf Methoden zu beschränken, da nur die im Interface definierten Methoden aufgerufen werden können. Dies ermöglicht es, verschiedene Sichten auf ein Objekt zu gewähren und den Zugriff auf bestimmte Methoden zu kontrollieren.'},
     {'question': 'Welche Rolle spielt die Java Virtual Machine (JVM) in Java-Programmen?', 'answer': 'Die Java Virtual Machine (JVM) interpretiert den Bytecode, der das Ergebnis der Übersetzung von Java-Programmen ist. Sie spielt eine entscheidende Rolle bei der Ausführung von Java-Programmen.'},
     {'question': 'Was ist die typische Methode, um ein Java-Programm auszuführen, und wie lautet ihre Signatur?', 'answer': 'Die typische Methode, um ein Java-Programm auszuführen, ist die "main"-Methode mit der Signatur "public static void main(String[] args)". Dies ist die Startmethode für Java-Anwendungen.'},
     {'question': 'Was ist ein wichtiges Merkmal des Programmiermodells von Java in Bezug auf die Namenskonvention von Klassen?', 'answer': 'Ein wichtiges Merkmal des Programmiermodells von Java ist, dass Klassennamen immer großgeschrieben werden sollen.'},
     {'question': 'Welches Problem ergibt sich bei der Erweiterung von Interfaces, wenn man keine abstrakten Klassen verwendet?', 'answer': 'Bei der Erweiterung von Interfaces, insbesondere wenn diese von Anwendungsklassen implementiert werden, entsteht das Problem, dass die Klassen, die diese Interfaces implementieren, aktualisiert werden müssen. Dies kann zu Schwierigkeiten führen, insbesondere wenn die Entwicklung dieser Klassen in den Händen Dritter liegt.'},
     {'question': 'Welchen Zusammenhang gibt es zwischen Klassen und Dateien in Java?', 'answer': 'In Java entspricht normalerweise jede Datei der Definition einer Klasse mit dem gleichen Namen wie der Dateiname (ohne Erweiterung). Es ist möglich, mehrere Klassen in einer Datei zu definieren, aber keine dieser Klassen darf als "public" deklariert werden. Dies liegt an Konventionen, die die meisten integrierten Entwicklungsumgebungen und Versionsverwaltungssysteme unterstützen. In der Regel sollte jede Datei eine öffentliche Klasse mit demselben Namen enthalten.'},
     {'question': 'Welche Konvention wird in Java verwendet, um den Typ bei Deklarationen anzugeben, und wie unterscheidet sich dies von STRONGTALK?', 'answer': 'In Java wird der Typ bei Deklarationen ohne spitze Klammern vorangestellt. Dies unterscheidet sich von STRONGTALK, bei dem die spitzen Klammern in Deklarationen verwendet werden. In Java folgt die Typangabe der Tradition von C und C++.'},
     {'question': 'Was ist das Reflection API in Java und wofür wird es verwendet?', 'answer': 'Das Reflection API in Java ermöglicht den Zugriff auf die Elemente eines Programms, obwohl nicht alles in Java ein Objekt ist. Es stellt Klassen zur Verfügung, die verschiedene Programmelemente repräsentieren, wie Methoden (Klasse Method) oder Felder (Klasse Field). Dies ermöglicht es, Programmierung auf einer höheren Ebene durchzuführen, indem man dynamisch auf Programmstrukturen zugreift. Eine ausführliche Untersuchung dieses APIs wird im Kurs 01853 ("Moderne Programmiertechniken und -methoden") behandelt.'},
     {'question': 'Was sind Annotationen in Java und welche Rolle spielen sie in der Metaprogrammierung?', 'answer': 'Annotationen in Java sind eine Form der Metaprogrammierung, bei der Programmmetadaten den Programmelementen im Quelltext zugeordnet werden. Diese Metadaten können während der Übersetzung und/oder während der Ausführung des Programms abgefragt werden und den jeweiligen Prozess beeinflussen oder steuern. In Java 5 wurden Annotationen als eine spezielle Art von Interfaces eingeführt, die jedoch keine Methoden, sondern nur Felder deklarieren. Annotationen werden häufig verwendet, um zusätzliche Informationen oder Konfigurationen zu einem Programm hinzuzufügen.'},
     {'question': 'Was ist ein Modul in der Programmierung und wie ist seine Schnittstelle definiert?', 'answer': 'Ein Modul ist eine Einheit von Programmelementen, deren Funktion von außen, z. B. von anderen Modulen, nur über die Schnittstelle des Moduls zugänglich ist. Die Schnittstelle definiert, welche Teile des Moduls öffentlich sichtbar sind.'},
     {'question': 'Welche Trennung gibt es in Java zwischen Operationen und Methoden?', 'answer': 'In Java gibt es eine Trennung zwischen Operationen, die auf primitiven Typen fest vorgegeben sind, und Methoden, die in Klassen definiert werden müssen.'},
     {'question': 'Welcher Operator steht speziell für Referenztypen in Java zur Verfügung?', 'answer': 'Ein Operator, der speziell für Referenztypen in Java zur Verfügung steht, ist der Typtest "instanceof". Er ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist.'},
     {'question': 'Welche Funktionen haben Klassen in Java?', 'answer': 'Klassen in Java dienen als Vorlagen für die Erzeugung von Objekten, liefern Typen für ein Programm und dienen der Modularisierung.'},
     {'question': 'Was sind Zugriffsmodifikatoren in Java?', 'answer': 'Zugriffsmodifikatoren (access modifiers) sind in Java Schlüsselwörter wie private, protected, public und "Package local," die die Zugriffsbeschränkungen für Klassen, Typen und deren Elemente festlegen. Sie regeln, welche Teile einer Klasse von anderen Klassen aus zugänglich sind.'},
     {'question': 'Welche Auswirkungen haben die Zugriffsbeschränkungen in Java?', 'answer': 'Die Zugriffsbeschränkungen in Java regeln, welche Teile einer Klasse oder eines Typs von anderen Klassen oder Typen aus zugänglich sind. Sie beeinflussen die Sichtbarkeit von Variablen, Methoden und anderen Elementen innerhalb einer Klasse und zwischen Klassen, insbesondere in verschiedenen Paketen.'},
     {'question': 'Was sind die konkreten Auswirkungen der Zugriffsbeschränkungen in Java?', 'answer': 'Die Zugriffsbeschränkungen in Java wirken sich auf die Sichtbarkeit von Elementen innerhalb von Klassen und zwischen Klassen aus. Sie regeln, welche Teile eines Moduls von anderen Modulen aus sichtbar sind und können durch Hiding, Shadowing und Obscuring weiter eingeschränkt werden. Die Verknüpfung von Typ und Zugriffsbeschränkung ist in Java etabliert und ermöglicht die Deklaration von Typen und Schnittstellen in einem.'},
     {'question': 'Welche Arten von Literale gibt es in Java?', 'answer': 'In Java gibt es Literale für Zahlen, Zeichen und Strings.'},
     {'question': 'Welche drei besonderen Werte im Fließkommabereich haben keine Literale, sondern nur Konstanten in Java?', 'answer': 'Die drei besonderen Werte im Fließkommabereich, die keine Literale, sondern nur Konstanten in Java haben, sind "NaN" (Not a Number), "POSITIVE_INFINITY" und "NEGATIVE_INFINITY".'},
     {'question': 'Welcher Typ hat ein Klassenliteral in Java?', 'answer': 'Der Typ eines Klassenliterals in Java ist "Class<T>", wobei T der Typ der Klasse ist. Zum Beispiel hat "Class<Object>" den Typ "Class<Object>".'},
     {'question': 'Welche Art von Typprüfungen kann Java zur Übersetzungszeit durchführen?', 'answer': 'Java kann zur Übersetzungszeit statische Typprüfungen durchführen.'},
     {'question': 'Welche gelegentlichen Typprüfungen erfordern dynamische Typprüfungen in Java?', 'answer': 'Gelegentliche Typprüfungen, die dynamische Typprüfungen in Java erfordern, sind insbesondere Typumwandlungen (Type casts).'},
     {'question': 'Welches Schlüsselwort verwendet Java, um die Bestehen einer Subklassenbeziehung zwischen zwei Klassen zu deklarieren?', 'answer': 'Java verwendet das Schlüsselwort "extends," um die Bestehen einer Subklassenbeziehung zwischen zwei Klassen zu deklarieren.'},
     {'question': 'Was ist ein Interface in Java und wie wird es deklariert?', 'answer': 'Ein Interface in Java ist eine eigenständige Schnittstellendeklaration, die von einer Klasse unabhängig ist, aber genauso wie eine Klasse einen Typ definiert. Interfaces werden mit dem Schlüsselwort "interface" deklariert.'},
     {'question': 'Welche Beziehung müssen die Typen in Java haben, damit Ausdrücke von einem Typ Variablen eines anderen Typs zugewiesen werden können?', 'answer': 'Damit Ausdrücke von einem Typ Variablen eines anderen Typs zugewiesen werden können, müssen die Typen entweder identisch sein oder es muss eine Subtypbeziehung zwischen ihnen bestehen.'},
     {'question': 'Welche Anforderung stellt Java an geerbte Variablen (Felder und Parametertypen von Methoden)?', 'answer': 'Java verlangt, dass die Typen geerbter Variablen nicht verändert werden dürfen. Dies wird als Kovarianz bezeichnet.'},
     {'question': 'Was sind Konstruktoren in Java, und wie verhalten sie sich im Vergleich zu SMALLTALK?', 'answer': 'Konstruktoren in Java sind spezielle Methoden, die zur Erzeugung von Objekten verwendet werden. Im Gegensatz zu SMALLTALK sind Konstruktoren in Java keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Sie verhalten sich wie Instanzmethoden und können auf alle Felder und Methoden der neu erzeugten Instanz zugreifen.'},
     {'question': 'Was sind Factory-Methoden in Java, und wie werden sie verwendet?', 'answer': 'Factory-Methoden sind Klassenmethoden in Java, die zur Erzeugung von Objekten verwendet werden können. Sie können auch Instanzen eines anderen Typs als den deklarierten zurückgeben. Factory-Methoden ermöglichen eine flexible Objekterzeugung und werden oft in Bibliotheken und Frameworks eingesetzt.'},
     {'question': 'Was ist Exception Handling in Java?', 'answer': 'Exception Handling ist eine Möglichkeit in Java, mögliche Ausnahmesituationen und deren Behandlung bei der Spezifikation des Kontrollflusses eines Programms vorübergehend zu vernachlässigen und so zu tun, als würde immer alles gutgehen. Ausnahmesituationen werden in Java in Form von Exception-Klassen dargestellt.'},
     {'question': 'Was sind Checked Exceptions in Java?', 'answer': 'Checked Exceptions sind Ausnahmesituationen, bei denen die Programmierer sich der möglichen Ausnahmesituationen bewusst sein müssen. Sie erfordern eine Deklaration im Methodenkopf oder müssen innerhalb der Methode behandelt werden. Diese Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind.'},
     {'question': 'Was sind Unchecked Exceptions in Java?', 'answer': 'Unchecked Exceptions sind Ausnahmesituationen, die in der Praxis überall auftreten können. Sie erfordern keine explizite Deklaration im Methodenkopf und können überall auftreten. Unchecked Exceptions werden von Exception-Klassen abgeleitet, die von RuntimeException abgeleitet sind.'},
     {'question': 'Welche Initiative wurde von der Java-Community aufgegriffen, um die Situation mit aufgeteilten Paketen zu verbessern?', 'answer': 'Die Java-Community griff die Open Services Gateway Initiative (OSGi) auf, um die Situation mit aufgeteilten Paketen zu verbessern. OSGi ermöglichte die Zusammenfassung von Java-Paketen zu Modulen mit einer eigenen Schnittstellenspezifikation.'},
     {'question': 'Was ist der qualifizierte Export in der Moduldefinition von Java?', 'answer': 'Der qualifizierte Export in der Moduldefinition von Java ist ähnlich wie in EIFFEL. Er nennt die Module, an die exportiert wird, namentlich und erlaubt einen "privaten" Austausch zwischen bestimmten Modulen, die somit ihre eigenen, privaten Schnittstellen haben.'},
     {'question': 'Was ist das Besondere an der Moduldefinition von Java in Bezug auf die Einhaltung der Schnittstellenspezifikationen?', 'answer': 'Die Moduldefinition von Java erzwingt die Einhaltung der Schnittstellenspezifikationen sowohl zur Übersetzungszeit als auch zur Laufzeit. Sie kontrolliert auch den reflektiven Zugriff auf Programmelemente, was zu einer erheblichen Verbesserung der Sicherheit von Java-Programmen führt.'},
     {'question': 'Welche Möglichkeit zur Iteration von Collection-Klassen kennen Sie aus SMALLTALK?', 'answer': 'In SMALLTALK gibt es die Möglichkeit, Iterationen als Methoden der Collection-Klassen zu definieren, was als interne Iteration bezeichnet wird.'},
     {'question': 'Welche neuen Funktionen wurden in Java 8 eingeführt, um interne Iterationen zu ermöglichen?', 'answer': 'In Java 8 wurden (anonyme) Funktionen, auch bekannt als Lambda-Ausdrücke, eingeführt, um interne Iterationen à la SMALLTALK zu ermöglichen.'},
     {'question': 'Welches Framework wurde für die Implementierung der Methoden forEach, filter, map und reduce in Java 8 geschaffen?', 'answer': 'Für die Implementierung der Methoden forEach, filter, map und reduce in Java 8 wurde das Stream-Framework geschaffen.'},
     {'question': 'Was ist die Hauptanwendung generischer Typen in Java?', 'answer': 'Eine Hauptanwendung generischer Typen in Java ist die Arbeit mit Collections, um den Typ der Elemente in der Collection anzugeben und so die Typsicherheit zu erhöhen.'},
     {'question': 'Welche Konvention wird häufig verwendet, um Typparameter von Klassen- und Variablennamen zu unterscheiden?', 'answer': 'Eine häufig verwendete Konvention ist es, einzelne Großbuchstaben für Typparameter zu wählen. Zum Beispiel steht "E" üblicherweise für den Elementtyp von Containern wie Collections.'},
     {'question': 'Was ist rekursiv beschränkter parametrischer Polymorphismus in Java?', 'answer': 'Rekursiv beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Möglichkeit, Beschränkungen für Typparameter auf eine Weise zu definieren, die auf sich selbst oder andere Typparameter verweist.'},
     {'question': 'Welcher Typkonstruktor wurde in Java 1.5 für Aufzählungstypen hinzugefügt?', 'answer': 'In Java 1.5 wurde der Typkonstruktor enum für Aufzählungstypen hinzugefügt.'},
     {'question': 'Welche Art von Typen sind Aufzählungstypen in Java?', 'answer': 'Aufzählungstypen in Java sind Klassentypen. Sie können neben den Aufzählungselementen auch Felder und Methoden enthalten.'},
     {'question': 'Was ist das Symbol für eine Typ-Wildcard in Java?', 'answer': 'Das Symbol für eine Typ-Wildcard in Java ist das Fragezeichen.'},
     {'question': 'Was ist die Verwendung von "extends" und "super" in Verbindung mit Typ-Wildcards?', 'answer': '"extends" wird verwendet, um eine obere Schranke für Typ-Wildcards anzugeben, während "super" verwendet wird, um eine untere Schranke anzugeben. Mit "extends" beschränkte Wildcard-Typen sind kovariant, und mit "super" beschränkte Wildcard-Typen sind kontravariant.'},
     {'question': 'Welche Einschränkung gibt es bei der Verwendung von "super" beschränkten Typ-Wildcards?', 'answer': 'Bei "super" beschränkten Typ-Wildcards ist der Zugriff auf Elemente in der Regel auf schreibende Zugriffe beschränkt, und lesende Zugriffe haben immer den Typ "Object".'},
     {'question': 'Welche Art von Subtyping wird bei "extends" beschränkten Wildcard-Typen verwendet?', 'answer': '"extends" beschränkte Wildcard-Typen verwenden kovariantes Subtyping.'},
     {'question': 'Welche Art von Subtyping wird bei "super" beschränkten Wildcard-Typen verwendet?', 'answer': '"super" beschränkte Wildcard-Typen verwenden kontravariantes Subtyping.'},
     {'question': 'Welche Merkmale von C++ und SMALLTALK wurden in Java übernommen?', 'answer': 'In Java wurden weite Teile der Syntax und der statischen Typüberprüfung von C++ übernommen. Außerdem wurde der eher klassisch prozedurale Charakter von C++ beibehalten, wobei Methodenaufrufe anstelle von Nachrichtenversand verwendet werden. Von SMALLTALK wurden die umfassende Objektorientierung (es gibt keinen Code außerhalb von Klassen), die Einfachvererbung sowie die Garbage Collection übernommen.'},
     {'question': 'Was sind Instanzvariablen in Java?', 'answer': 'Instanzvariablen in Java sind Felder, die zur Speicherung von Daten in einer Klasse verwendet werden. Jede Instanz der Klasse hat ihre eigenen Kopien dieser Variablen.'},
     {'question': 'Was sind Instanzmethoden in Java?', 'answer': 'Instanzmethoden in Java sind Methoden, die auf Instanzen (Objekten) einer Klasse angewendet werden können. Sie definieren das Verhalten der Klasse.'},
     {'question': 'Was sind "Member" in Bezug auf Klassendefinitionen in Java?', 'answer': '"Member" ist ein zusammenfassender Begriff für Felder und Methoden innerhalb einer Klassendefinition in Java.'},
     {'question': 'Welche weiteren Arten von Klassendefinitionen sind in Java möglich?', 'answer': 'In Java können Sie auch geschachtelte Klassendefinitionen und innere Klassendefinitionen erstellen, die ebenfalls als Members der umschließenden Klasse gelten.'},
     {'question': 'Welche Arten von Ausdrücken gibt es in Java?', 'answer': 'In Java gibt es verschiedene Arten von Ausdrücken, darunter Literale, Variablen, Methodenaufrufe, Operatoranwendungen, Feldzugriffe, Klasseninstanziierungen, Array-Instanziierungen, Konditionalausdrücke, Cast-Ausdrücke und Lambda-Ausdrücke.'},
     {'question': 'Welche Typisierungsanforderungen gelten für Ausdrücke in Java?', 'answer': 'In Java müssen alle Ausdrücke korrekt typisiert sein. Das bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks übereinstimmen muss, an der Stelle, an der er eingesetzt wird.'},
     {'question': 'Welche Rolle spielen Lambda-Ausdrücke in Java, und wie unterscheiden sie sich von anonymen inneren Klassen?', 'answer': 'Lambda-Ausdrücke in Java, die in Version 8 eingeführt wurden, ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Sie ermöglichen die Darstellung von Funktionen als Werte und werden häufig für die Implementierung von Schnittstellen mit nur einer Methode (Funktionale Interfaces) verwendet. Im Gegensatz dazu verwenden anonyme innere Klassen explizite Klassendefinitionen, um Schnittstellen zu implementieren.'},
     {'question': 'Welche Arten von Typumwandlungen gibt es in Java?', 'answer': 'In Java gibt es drei Arten von Typumwandlungen: Up casts, Down casts und Cross casts.'},
     {'question': 'Was ist ein Up cast?', 'answer': 'Ein Up cast tritt auf, wenn der Zieltyp ein Supertyp des Ausgangstyps ist.'},
     {'question': 'Was ist ein Down cast?', 'answer': 'Ein Down cast tritt auf, wenn der Zieltyp ein Subtyp des Ausgangstyps ist.'},
     {'question': 'Was ist ein Cross cast?', 'answer': 'Ein Cross cast tritt auf, wenn Zieltyp und Ausgangstyp keine Subtypenbeziehung zueinander haben und nebeneinander stehen.'},
     {'question': 'Welche Art von Typumwandlung ist immer sicher?', 'answer': 'Ein Up cast ist immer sicher, da jedes Objekt neben seinem Typ auch den Typ all seiner Supertypen hat.'},
     {'question': 'Welche Art von Typumwandlung kann zu Laufzeittypfehlern führen?', 'answer': 'Down und Cross casts können zu Laufzeittypfehlern führen, wenn das Objekt, zu dem der typumgewandelte Ausdruck ausgewertet wird, nicht den Zieltyp oder einen Subtyp davon hat. Dies kann zur Laufzeit zu ClassCastException-Fehlern führen.'},
     {'question': 'Welche Bedeutung haben Interfaces und Module in Java?', 'answer': 'Interfaces und Module sind in Java eng miteinander verknüpft und dienen dazu, die Schnittstellen und die Modularisierung von Klassen und Programmen zu definieren.'},
     {'question': 'Welche Rolle spielen Interfaces in der objektorientierten Programmierung?', 'answer': 'Interfaces spielen in der objektorientierten Programmierung eine wichtige Rolle, da sie dazu dienen, Schnittstellen zu definieren, über die Klassen miteinander kommunizieren können. Sie ermöglichen die Implementierung von Methoden in verschiedenen Klassen und erlauben die Implementierung von Polymorphismus.'},
     {'question': 'Was ist die Besonderheit von Javas Interfaces?', 'answer': 'Javas Interfaces sind eigenständige Konstrukte, die über die ursprüngliche Bedeutung hinausgehen und weitreichende Möglichkeiten zur Definition von Schnittstellen und zur Entwicklung objektorientierter Programmiersprachen bieten.'},
     {'question': 'Welche Formen von Abhängigkeiten gibt es in den Klassen als Modulen der Java-Programmierung?', 'answer': 'In den Klassen als Modulen der Java-Programmierung gibt es zwei Formen von Abhängigkeiten: Eine Klasse hängt von einer anderen ab, wenn auf Objekte der anderen Klasse zugegriffen wird. Dies zeigt sich durch die Deklaration von Variablen des entsprechenden Typs und gegebenenfalls durch das Importieren der Klasse oder des Pakets, in dem sich die andere Klasse befindet. Eine Klasse bietet einige ihrer Member zur Benutzung durch andere Klassen an und diese werden dadurch von ihr abhängig. Dies erkennt man an der Verwendung von Zugriffsmodifikatoren, die nicht privat sind, sowie an der Implementierung von Interfaces.'},
     {'question': 'Welche Arten von Abhängigkeiten können zwischen Klassen und Paketen in Java entstehen?', 'answer': 'In Java können Vererbungsabhängigkeiten zwischen Klassen auftreten, die nicht zirkulär sind. Bei der Ausdehnung der Abhängigkeiten auf Pakete können jedoch auch zirkuläre Abhängigkeiten zwischen Paketen entstehen.'},
     {'question': 'Welches Schlüsselwort wird in Java für Typtests verwendet?', 'answer': 'Das Schlüsselwort für Typtests in Java lautet "instanceof".'},
     {'question': 'Was ist die Sichtbarkeit von Typparametern in Methodendefinitionen?', 'answer': 'Die Sichtbarkeit von Typparametern in Methodendefinitionen ist auf die jeweilige Methode beschränkt.'},
     {'question': 'Was ist Typinferenz in Bezug auf generische Methoden?', 'answer': 'Typinferenz in Bezug auf generische Methoden bezieht sich auf die Fähigkeit des Java-Compilers, den tatsächlichen Typparameter wegzulassen, wenn er sich aus dem Kontext des Methodenaufrufs ableiten kann.'},
     {'question': 'Welche Arten von Anweisungen gibt es in Java?', 'answer': 'In Java gibt es verschiedene Arten von Anweisungen, darunter Variablendeklarationen, Wertzuweisungen, Methodenaufrufe, Klasseninstanziierungen und Kontrollstrukturen wie If-Anweisungen, Schleifen, Switch-Anweisungen, Try-Anweisungen und mehr.'},
     {'question': 'Was ist der Zweck der Assert-Anweisung in Java?', 'answer': 'Die Assert-Anweisung in Java dient dazu, bestimmte Bedingungen im Programm zu überprüfen. Wenn die Bedingung zu false ausgewertet wird, wird das Programm mit einer entsprechenden Fehlermeldung abgebrochen. Die Assert-Anweisung kann auch ein optionales Ergebnis liefern, das in der Fehlermeldung angezeigt wird. Sie eignet sich zur Überprüfung von Invarianten zur Laufzeit.'},
     {'question': 'Welche Semantik haben Variablen in Java, und wie wird dies bestimmt?', 'answer': 'Variablen in Java haben entweder Referenzsemantik oder Wertsemantik, je nach ihrem Typ. Primitive Typen wie byte, short, int, usw., haben Wertsemantik. Andere Typen haben Referenzsemantik.'},
     {'question': 'Welche Vorsichtsmaßnahmen müssen bei "Auto boxing" und "Auto unboxing" in Java getroffen werden?', 'answer': 'Bei "Auto boxing" und "Auto unboxing" in Java ist Vorsicht geboten, da unerwartete Ergebnisse auftreten können. Zwei Objekte, die den gleichen Wert repräsentieren, sind zwar immer gleich, müssen aber nicht identisch sein. Daher ist es wichtig, sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte, um Programmierfehler zu vermeiden.'},
     {'question': 'Was sind die Arten von Typen, die in Java unterschieden werden?', 'answer': 'In Java werden die folgenden sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen.'},
     {'question': 'Welche primitiven Typen sind in Java definiert?', 'answer': 'In Java sind die folgenden primitiven Typen definiert: byte, short, int, long, float, double, boolean und char.'},
     {'question': 'Kennen Sie vordefinierte Type in der Java-Sprachdefinition?', 'answer': 'In der Java-Sprachdefinition sind folgende vordefinierte Typen festgelegt: Object, String, Throwable, Error, Exception, RuntimeException und Thread.'},
     {'question': 'Was ist beschränkter parametrischer Polymorphismus in Java?', 'answer': 'Beschränkter parametrischer Polymorphismus in Java bezieht sich auf die Einschränkung der möglichen Typen, die für einen Typparameter einer generischen Klasse verwendet werden können. Dies geschieht durch das Festlegen von Beschränkungen oder Bedingungen für den Typparameter.'},
     {'question': 'Welche Einschränkungen gelten für generische Variablen mit Typ-Wildcards?', 'answer': 'Generische Variablen mit Typ-Wildcards unterliegen Einschränkungen, insbesondere in Bezug auf die Verwendung von Wildcards mit oberen und unteren Schranken.'},
     {'question': 'Was sind Threads in Java und wie unterscheiden sie sich von Prozessen?', 'answer': 'Threads in Java sind parallele Ausführungsstränge, während Prozesse in der Regel eigenständige Programme mit separater Ressourcenallokation sind. Threads sind leichtgewichtiger und teilen sich Ressourcen innerhalb eines Prozesses. Bei Threads müssen die Synchronisationsmechanismen selbst implementiert werden, während Prozesse in Betriebssystemen über die Inter-Prozess-Kommunikation reguliert werden.'},
     {'question': 'Was ist ein Monitor in Bezug auf Threads in Java?', 'answer': 'Ein Monitor in Bezug auf Threads in Java ist ein Mechanismus, der dazu dient, die Synchronisation von Threads zu ermöglichen. Jedes Objekt in Java ist mit einem Monitor verknüpft. Wenn ein Thread einen Monitor eines Objekts sperrt ("lockt"), kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.'},
     {'question': 'Welche Besonderheiten gibt es bei mehrdimensionalen Arrays in Java?', 'answer': 'In Java können mehrdimensionale Arrays geschachtelt werden, wobei die Größen der Dimensionen nicht für jedes Element der ersten Dimension gleich sein müssen.'},
     {'question': 'Was sind Annotationen in Java?', 'answer': 'Annotationen in Java sind eine Spracherweiterung, die es ermöglicht, zusätzliche Informationen zu Klassen, Methoden und Variablen hinzuzufügen. Sie wurden von C-Sharp inspiriert und ermöglichen es, Metadaten zu definieren, die von Compilern, Tools und Frameworks ausgewertet werden können.'},
     {'question': 'Was ist der Supertyp aller Referenztypen in Java?', 'answer': 'Object ist der Supertyp aller Referenztypen in Java.'},
     {'question': 'Was ist ein klassischer Anwendungsfall von generischen Typen?', 'answer': 'Die klassische Anwendung generischer Typen findet man bei Collections. Genauso, wie man in Java Arrays über einen bestimmten Elementtyp bilden kann, will man auch andere Arten von Collections über Elementtypen haben. Zu diesem Zweck verfügt Java über eine ganze Reihe von Collection-Klassen wie z. B. Sets (für Mengen) oder Maps (die Java-Variante von SMALLTALKs Dictionaries). Nun sind diese Collections (anders als Arrays) nicht Bestandteil der Sprachdefinition Javas, sondern Elemente einer Bibliothek, also in der Sprache selbst programmierte, für die allgemeine Verwendung gedachte Klassen.'},
     {'question': 'Was ist der Zweck der Verwendung von Generics in Java?', 'answer': 'Der Zweck der Verwendung von Generics in Java ist es, die Typsicherheit statisch, also zur Übersetzungszeit, zu erhöhen und die Notwendigkeit von Typumwandlungen (Downcast) zu verringern, die zu Laufzeitfehlern führen können.'},
     {'question': 'Was ist eine Besonderheit von EIFFEL in Bezug auf Zusicherungen?', 'answer': 'In EIFFEL sind Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen integriert. Das bedeutet, dass es für Zusicherungen vorgesehene Orte gibt und sie nicht ganz im Ermessen der Programmiererin liegen.'},
     {'question': 'Was ist die Funktion von "require" und "ensure" in EIFFEL?', 'answer': '"Require" und "ensure" sind Schlüsselwörter in EIFFEL, die Boolesche Ausdrücke folgen. "Require"-Klauseln sollten erfüllt sein, damit die Methode korrekt funktioniert, während "Ensure"-Klauseln garantieren, dass die Methode bestimmte Bedingungen erfüllt. Beide Klauseln dürfen nebenwirkungsfreie Abfragen der Klasse verwenden.'},
     {'question': 'Was sind Klasseninvarianten in EIFFEL?', 'answer': 'Klasseninvarianten sind in EIFFEL eine Möglichkeit, Zusicherungen zu formulieren, die zwischen zwei Methodenaufrufen gelten müssen. Sie werden mit dem Schlüsselwort "invariant" deklariert und können sich vorstellen, dass sie jeder Vor- und Nachbedingung per Konjunktion hinzugefügt werden.'},
     {'question': 'Was ist der Zusammenhang zwischen Zusicherungen und Methoden in EIFFEL?', 'answer': 'In EIFFEL werden Zusicherungen wie Vor- und Nachbedingungen von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen auch die Zusicherungen angepasst werden, allerdings gilt hierbei, dass die Vorbedingung nur abgeschwächt und die Nachbedingung nur verschärft werden darf. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.'},
     {'question': 'Was ist die Sprache EIFFEL?', 'answer': 'EIFFEL ist eine Sprache, die für objektorientierte Analyse und Design, kommerzielle Programmierung und akademische Lehre verwendet wird.'},
     {'question': 'Was ist die Sonderstellung von EIFFEL unter den hier behandelten Sprachen?', 'answer': 'EIFFEL ist eine Sprache für objektorientierte Analyse und Design, eine Sprache für kommerzielle Programmierung und eine akademische Lehrsprache.'},
     {'question': 'Was ist die Besonderheit von EIFFEL?', 'answer': 'Die Besonderheit von EIFFEL ist die Integration von Zusicherungen, die als Verträge zwischen dienstanbietenden und dienstnehmenden Klassen interpretiert werden können. Diese erlauben, das "Was" einer Software zumindest teilweise unabhängig vom "Wie" zu spezifizieren. EIFFEL erlaubt darüber hinaus, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können.'},
     {'question': 'Was ist eine Typhierarchie in C-Sharp?', 'answer': 'In C-Sharp ist eine Typhierarchie eine Vererbungshierarchie, die die Beziehungen zwischen den verschiedenen Datentypen definiert. Alle Typen, einschließlich primitiver Typen, gelten als von Object (genauer: System.Object) abgeleitet. Diese Hierarchie ermöglicht es, Objekte verschiedener Typen zu behandeln, als ob sie vom gleichen Typ wären, was Polymorphie ermöglicht.'},
     {'question': 'Was sind Attribute in C-Sharp?', 'answer': 'Attribute in C-Sharp sind eine Möglichkeit, zusätzliche Informationen zu einem Programmelement hinzuzufügen. Sie sind ähnlich wie Annotationen in Java und haben nichts unmittelbar mit objektorientierter Programmierung zu tun.'},
     {'question': 'Was ist eine Klassenhierarchie in C-Sharp?', 'answer': 'Eine Klassenhierarchie in C-Sharp ist eine Vererbungshierarchie, die die verschiedenen Arten von Typen in C-Sharp einteilt. Sie ist wesentlich komplexer und vereinheitlicht das Typsystem von C-Sharp, indem alle Typen von System.Object abgeleitet sind.'},
     {'question': 'Was ist eine Einteilung der verschiedenen Arten von Typen in C-Sharp?', 'answer': 'Die Einteilung der verschiedenen Arten von Typen in C-Sharp ist eine Einteilung, die die verschiedenen Arten von Typen in C-Sharp in ValueType, Delegate und class einteilt.'},
     {'question': 'Was ist ein Wertetyp in C-Sharp?', 'answer': 'Ein Wertetyp ist ein Typ, der von System.ValueType abgeleitet'},
     {'question': 'Was ist Auto-Boxing und Unboxing in C-Sharp?', 'answer': 'Auto-Boxing ist eine automatische Konvertierung eines Werttyps in einen Referenztyp, während Unboxing die umgekehrte Konvertierung ist. Diese Funktionen ermöglichen es, Werttypen als Subtypen eines Referenztyps (nämlich Object) zu deklarieren.'},
     {'question': 'Was sind Aufzählungstypen in Java?', 'answer': 'Aufzählungstypen in Java sind mit Java 1.5 hinzugekommen und stellen eine Unterart der Klassentypen dar. Sie werden mit dem Schlüsselwort enum definiert und können Elemente, Felder und Methoden enthalten. Die Elemente einer Aufzählung werden zu Konstanten, also zu lebenslang gültigen Namen für Objekte einer Klasse, die den Aufzählungstyp repräsentiert.'},
     {'question': 'Was ist die Lösung für das Problem der fehlenden Zuweisungskompatibilität zwischen "ArrayList<Integer>" und "ArrayList<Comparable>"?', 'answer': 'Die Lösung für das Problem der fehlenden Zuweisungskompatibilität zwischen "ArrayList<Integer>" und "ArrayList<Comparable>" ist die Verwendung von Generics. Generics ermöglichen es, den Typ der Elemente in einer ArrayList bei der Erstellung der ArrayList anzugeben. Dadurch wird sichergestellt, dass nur Elemente des angegebenen Typs in die ArrayList aufgenommen werden können. Wenn man also eine ArrayList<Integer> erstellt, kann man nicht versehentlich eine ArrayList<String> zuweisen, und umgekehrt.'},
     {'question': 'Was sind Typ-Wildcards in Java?', 'answer': 'Typ-Wildcards, auch als Typ-Joker oder Platzhalter bezeichnet, sind ein Konzept in Java, das eingeführt wurde, um das Problem der Instanziierung eines generischen Typs mit einem beliebigen Typ zu lösen. Sie können bei der Instanziierung eines generischen Typs den Platz des tatsächlichen Typparameters einnehmen und zunächst für einen beliebigen Typ stehen. Das Symbol für eine Typ-Wildcard ist das Fragezeichen: "List<?>" ist also ein Typ, mit dem Variablen (einschließlich formaler Parameter) deklariert werden können. Per Definition ist dieser Typ "List<?>" ein Supertyp aller Instanziierungen von "List<T>" - beispielsweise sind "List<Integer>" und "List<String>" mit "List<?>" zuweisungskompatibel.'},
     {'question': 'Was sind Wildcard-Typen in Java?', 'answer': 'Wildcard-Typen wie "List<?>" und "ArrayList<?>" sind abstrakt und haben keine direkten Instanzen. Das Fragezeichen selbst ist kein Typ oder eine Typvariable.'},
     {'question': 'Was sind per extends beschränkte Typ-Wildcards?', 'answer': 'Per extends beschränkte Typ-Wildcards erlauben eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt). Diese Situation unterscheidet sich von der bei Arrays lediglich dadurch, dass die Typprüfung statisch, also bereits zur Übersetzungszeit, durchgeführt wird.'},
     {'question': 'Was ist umgekehrtes Subtyping?', 'answer': 'Umgekehrtes Subtyping ist eine Art des Subtypings, bei der nur Supertypen der Schranke eingesetzt werden dürfen. Da Supertypen mit ihren Subtypen zuweisungskompatibel sind, weiß der Compiler, dass er Elemente jedes beliebigen Subtyps der Schranke zuweisen darf.'},
     {'question': 'Was sind Zugriffsmethoden in Eiffel?', 'answer': 'Zugriffsmethoden in Eiffel sind Methoden, die vom System automatisch bereitgestellt werden, um auf Instanzvariablen zuzugreifen. Sie nehmen syntaktisch die Form von Variablen an, ermöglichen aber dennoch die Datenkapselung.'},
     {'question': 'Was ist eine Setter-Funktion?', 'answer': 'Eine Setter-Funktion ist eine Funktion, die mit einem Parameter aufgerufen wird und üblicherweise einen Wert setzt.'},
     {'question': 'Was ist eine Getter-Funktion?', 'answer': 'Eine Getter-Funktion ist eine Funktion, die einen Wert zurückgibt und üblicherweise mit einer Zuweisung an eine Variable verwendet wird.'},
     {'question': 'Was sind Setter und Getter?', 'answer': 'Setter und Getter sind Funktionen, die den Zustand eines Objekts ändern oder abfragen. Ein Setter wird mit einem Parameter aufgerufen, um den Zustand des Objekts zu ändern, während ein Getter aufgerufen wird, um einen Wert zurückzugeben, der mit dem Zustand des Objekts kompatibel ist.'},
     {'question': 'Was sind Features in EIFFEL?', 'answer': 'In EIFFEL werden Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet. Sie sind die einzigen Elemente einer Klassendefinition in EIFFEL.'},
     {'question': 'Was sind die einzigen Elemente einer Klassendefinition in EIFFEL?', 'answer': 'In EIFFEL sind Attribute (Instanzvariablen) und Routinen (Methoden) zusammen als Features bezeichnet und die einzigen Elemente einer Klassendefinition.'},
     {'question': 'Was ist Mehrfachvererbung?', 'answer': 'Mehrfachvererbung ist eine Konstruktion in der objektorientierten Programmierung, bei der eine Klasse von mehreren anderen Klassen erben kann. Sie wird häufig von Programmiererinnen gewünscht, bringt aber praktische Probleme mit sich, wie zum Beispiel die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements erbt.'},
     {'question': 'Welche Probleme bringt Mehrfachvererbung mit sich?', 'answer': 'Mehrfachvererbung bringt einige praktische Probleme mit sich, wie zum Beispiel die Frage, was zu tun ist, wenn eine Klasse von mehreren anderen Klassen verschiedene Definitionen desselben Elements (Feld oder Methode) erbt. Darüber hinaus führt die Mehrfachvererbung noch zu zahlreichen weiteren Problemen, wie zum Beispiel das unerwartete Verhalten im Zusammenhang mit dynamischem Binden und offener Rekursion.'},
     {'question': 'Was ist Operatorüberladung in C-Sharp?', 'answer': 'In C-Sharp ist es möglich, Operatoren wie +, -, ==, new, ( ), ||, &&, = etc. zu überladen. Dies wird durch das Schlüsselwort "operator" in einer Operatordefinition erreicht, die der Definition einer Methode ähnelt.'},
     {'question': 'Wie verwendet C-Sharp Call by reference?', 'answer': 'Call by reference in C-Sharp ist eine Möglichkeit, Funktionen oder Methoden zu schreiben, bei der die Funktions- oder Methodenparameter als Referenzen übergeben werden, anstatt als Werte. Das bedeutet, dass die Funktion oder Methode direkt auf die Originalvariablen zugreifen und diese ändern kann, anstatt Kopien der Variablen zu verwenden. Diese Funktionalität ist ähnlich wie in Pascal, aber in C-Sharp wird es ohne explizite Pointer implementiert. Diese Funktionalität ist besonders nützlich für Methoden wie "swap", die die Werte von zwei Variablen vertauschen.'},
     {'question': 'Was sind generische Typen in Java?', 'answer': 'Generische Typen in Java sind eine Abstraktion von Typen, bei der die Referenzierung eines oder mehrerer Typen innerhalb einer Typdefinition durch Typvariablen ersetzt wird. Diese Typvariablen stehen in Java jedoch nicht in eckigen, sondern in spitzen Klammern.'},
     {'question': 'Was ist ein Indexer in C-Sharp?', 'answer': 'Ein Indexer in C-Sharp ist eine spezielle Art von Methode, die es ermöglicht, auf Instanzvariablen eines Objekts über einen Index zuzugreifen. Der Indexer kann überladen werden, um mehrere indizierte Instanzvariablen zu simulieren, wobei der Elementtyp (der Rückgabetyp beim Überladen) gleich bleiben muss. Der Zugriff auf den Indexer erfolgt aufgrund des fehlenden Namens einzig über den Typ des Indexes. Der Inhalt des Indexers muss nicht zwangsläufig auf eine interne Instanzvariable zugreifen, sondern kann auch berechnet werden.'},
     {'question': 'Was sind Instanzvariablen und Instanzmethoden in Java?', 'answer': 'Instanzvariablen und Instanzmethoden sind Bestandteile einer Klassendefinition in Java. Sie werden zusammenfassend auch als "Member" bezeichnet. Instanzvariablen, auch Felder genannt, sind Variablen, die zu einer Instanz einer Klasse gehören. Instanzmethoden sind Methoden, die auf eine Instanz einer Klasse angewendet werden können.'},
     {'question': 'Was ist der Begriff "Member" in Java?', 'answer': 'Der Begriff "Member" in Java bezieht sich auf die Klassendefinition und umfasst Instanzvariablen und Instanzmethoden.'},
     {'question': 'Was ist der Zweck von Konstruktoren in Java?', 'answer': 'Konstruktoren werden verwendet, um die Initialisierung von Objekten zu definieren, wenn sie erstellt werden. Sie werden nicht als Members einer Klasse betrachtet.'},
     {'question': 'Was sind innere Klassen in Java?', 'answer': 'Innere Klassen in Java sind Klassendefinitionen, die innerhalb einer anderen Klasse definiert werden. Sie sind vor allem sinnvoll, wenn die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Instanzen innerer Klassen liegen "innerhalb" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt "Outer this" auf diese zugreifen.'},
     {'question': 'Was sind die verschiedenen Arten von Ausdrücken in Java?', 'answer': 'In Java gibt es Literale, Variablen, Operatoranwendungen, Feldzugriffe, Methodenaufrufe, Array-Zugriffe, Klasseninstanziierungen, Array-Instanziierungen, Konditionalausdrücke, Cast-Ausdrücke, Lambda-Ausdrücke.'},
     {'question': 'Was ist ein Methodenausdruck in Java?', 'answer': 'Ein Methodenausdruck in Java beinhaltet einen Ausdruck für den Empfänger sowie möglicherweise weitere Ausdrücke für die Parameter des Methodenaufrufs.'},
     {'question': 'Was sind Lambda-Ausdrücke in Java?', 'answer': 'Lambda-Ausdrücke in Java sind eine Möglichkeit, Funktionen zu definieren, die mit Version 8 eingeführt wurden. Sie ersetzen die zuvor verwendete Praxis, Funktionen über anonyme innere Klassen zu implementieren. Lambda-Ausdrücke haben den Typ eines Interfaces, der jedoch nicht direkt angegeben wird, sondern inferiert wird. Die Funktionen, die Lambda-Ausdrücke darstellen, erhalten über das Interface einen Namen.'},
     {'question': 'Was ist das Typsystem in EIFFEL?', 'answer': 'Das Typsystem in EIFFEL ist ein einheitliches Typsystem, das keine separaten Referenz- und Werttypen kennt. Es unterscheidet auch nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden.'},
     {'question': 'Welche Unterscheidung gibt es im Typsystem von EIFFEL nicht?', 'answer': 'EIFFEL besitzt ein einheitliches Typsystem und unterscheidet nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden. Auch gibt es keine an bestimmte Typkonstruktoren gebundene Unterscheidung von Wert- und Referenztypen.'},
     {'question': 'Was sind die prominentesten Eigenschaften des Typsystems von EIFFEL?', 'answer': 'Die prominentesten Eigenschaften des Typsystems von EIFFEL sind Mehrfachvererbung, Generizität, das Unterdrücken von Instanzvariablen und Methoden in Subklassen, und kovariante Redefinition, unterstützt durch sog. "verankerte Typen".'},
     {'question': 'Was ist Mehrfachvererbung in EIFFEL?', 'answer': 'Mehrfachvererbung in EIFFEL ist eine Eigenschaft des Typsystems, die es ermöglicht, dass eine Klasse von mehreren übergeordneten Klassen erben kann. Das bedeutet, dass eine Klasse Merkmale und Eigenschaften von mehreren Elternklassen erben kann, was die Wiederverwendung von Code und die Flexibilität bei der Gestaltung von Klassenhierarchien erhöht.'},
     {'question': 'Was ist kovariante Redefinition in EIFFEL?', 'answer': 'In EIFFEL, kovariante Redefinition ist eine Eigenschaft, bei der die Menge der möglichen Parameterobjekte in einer Unterklasse eingeschränkt wird, so dass es keinen gültigen Aufruf gibt. Diese Eigenschaft ist ähnlich wie das Unterdrücken von Methoden eines Typs in seinen Subtypen.'},
     {'question': 'Was ist ein Up cast in Java?', 'answer': 'Ein Up cast in Java ist ein Typumwandlungsausdruck, der ein Objekt in einen seiner Supertypen umwandelt. Ein Up cast ist immer sicher und kann daher auch weggelassen werden.'},
     {'question': 'Was ist ein Down cast in Java?', 'answer': 'Ein Down cast in Java ist ein Typumwandlungsausdruck, der ein Objekt in einen seiner Subtypen umwandelt. Ein Down cast kann zu Laufzeittypfehlern führen, wenn das Objekt nicht den Zieltyp oder einen Subtyp davon hat.'},
     {'question': 'Was ist ein Cross cast in Java?', 'answer': 'Ein Cross cast in Java ist ein Typumwandlungsausdruck, der ein Objekt in einen beliebigen anderen Typ umwandelt. Ein Cross cast kann zu Laufzeittypfehlern führen, wenn das Objekt nicht den Zieltyp oder einen Subtyp davon hat.'},
     {'question': 'Was ist eine ClassCastException in Java?', 'answer': 'Eine ClassCastException in Java ist eine Laufzeittypfehlermeldung, die geworfen wird, wenn ein Down oder Cross cast zu einem Objekt durchgeführt wird, das nicht den Zieltyp oder einen Subtyp davon hat.'},
     {'question': 'Was sind die Anweisungen in EIFFEL?', 'answer': 'In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. Jede Kontrollstruktur hat genau einen Eingang und einen Ausgang. EIFFEL bietet ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet.'},
     {'question': 'Was sind die Bestandteile einer Anweisung in EIFFEL?', 'answer': 'In EIFFEL bestehen Anweisungen aus Zuweisungen, Methodenaufrufen, Konstruktoraufrufen und den üblichen Kontrollstrukturen zur Verzweigung und Wiederholung. Jede Kontrollstruktur hat genau einen Eingang und einen Ausgang. EIFFEL bietet ein Exception Handling, das sich angenehm von dem in Java/C-Sharp/C++ unterscheidet.'},
     {'question': 'Was sind Properties in C-Sharp?', 'answer': 'Properties in C-Sharp sind eine Möglichkeit, gewissermaßen die Umkehrung von Zugriffsmethoden zu erreichen. Statt auf ein Feld eines Objekts über Methoden zuzugreifen, ruft man Methoden über das auf, was syntaktisch wie ein Feldzugriff aussieht. Dies erlaubt es, Feldzugriffe mit Nebeneffekten zu versehen, wie zum Beispiel einer dynamischen Typprüfung bei schreibendem Zugriff. Properties können auch dazu verwendet werden, Felder mit Nur-Lese- oder Nur-Schreib-Zugriff zu simulieren.'},
     {'question': 'Was ist ein Zuweisungsversuch in EIFFEL?', 'answer': 'In EIFFEL wird ein Zuweisungsversuch verwendet, um einen Typtest durchzuführen. Wenn die Zuweisungskompatibilität nicht gegeben ist, wird einfach "void" zugewiesen.'},
     {'question': 'Was ist nominale Typkonformität in EIFFEL?', 'answer': 'In EIFFEL ist nominale Typkonformität die Zuweisungskompatibilität, die mit der Typerweiterung (Vererbung) einhergeht. Das bedeutet, dass eine Unterklasse mit einer Oberklasse kompatibel ist und eine Variable der Oberklasse mit einem Objekt der Unterklasse zugewiesen werden kann.'},
     {'question': 'Was ist das Problem der Kovarianz in EIFFEL?', 'answer': 'Das Problem der Kovarianz in EIFFEL tritt auf, wenn eine Konstruktion vom Type checker zur Übersetzungszeit zurückgewiesen wird, weil der Typ des Objekts nicht mit den Typkonformitätsregeln übereinstimmt.'},
     {'question': 'Was sind CAT-Calls in Eiffel?', 'answer': 'CAT-Calls (Change Availability or Type Calls) sind dynamisch gebundene Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen ändern können. Ein Beispiel für einen CAT-Call ist der Aufruf von share auf s1 wie oben, der verboten ist, weil share in BOY und GIRL kovariant redefiniert wird.'},
     {'question': 'Was sind zirkuläre Abhängigkeiten zwischen Paketen?', 'answer': 'Zirkuläre Abhängigkeiten zwischen Paketen sind Abhängigkeiten, bei denen zwei oder mehr Pakete aufeinander referenzieren, so dass ein Kreislauf entsteht. Diese Abhängigkeiten können die Modularisierung und Wartbarkeit des Codes erschweren.'},
     {'question': 'Was sind Typtests in Java?', 'answer': 'Typtests in Java sind eine Methode, um Laufzeitfehler zu vermeiden. Sie werden durchgeführt, bevor eine Typumwandlung durchgeführt wird. Das Schlüsselwort hierfür ist instanceof.'},
     {'question': 'Was ist Typinferenz in Java?', 'answer': 'Typinferenz in Java ist eine Funktion des Compilers, die es ermöglicht, den tatsächlichen Typparameter bei einem Aufruf einer parametrischen Methode wegzulassen, wenn er sich aus dem Aufruf erschließen lässt.'},
     {'question': 'Wann sollte man eine Typ-Wildcard verwenden?', 'answer': 'Ein Typparameter ist ein Parameter, der innerhalb einer Methode nicht mehr verwendet wird. Wenn eine Variable nur einmal vorkommt, kann man sie weglassen oder zumindest unbenannt lassen. In diesen Fällen ist es gute Praxis, anstelle des Typparameters eine Typ-Wildcard zu verwenden.'},
     {'question': 'Was sind Tupel in EIFFEL?', 'answer': 'Tupel in EIFFEL sind eine Möglichkeit, mehrere Objekte ohne großen Aufwand zu gruppieren, insbesondere ohne die Notwendigkeit, eine Klasse zu definieren. Tupel sind besonders interessant, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugeordnet wird. Dies ist besonders prominent bei Methoden, die mehrere Werte anstelle eines einzigen Wertes zurückgeben sollen.'},
     {'question': 'Was sind Blöcke in Java?', 'answer': 'In Java sind Blöcke lediglich (in geschweifte Klammern eingefasste) Abschnitte des Quelltextes, die an die Stelle einzelner Anweisungen treten können und die einen Sichtbarkeitsbereich für darin enthaltene Variablendeklarationen darstellen. Blöcke wie in SMALLTALK kennt Java erst seit Version 8, mit der Einführung der Lambda-Ausdrücke.'},
     {'question': 'Was sind die Kontrollstrukturen in der Programmierung?', 'answer': 'Die Kontrollstrukturen in der Programmierung sind if-Anweisungen, while-Anweisungen, repeat-Anweisungen, for-Anweisungen und case-Anweisungen. Sie dienen dazu, den Kontrollfluss eines Programms von der normalen, sequentiellen Ausführung abzuweichen.'},
     {'question': 'Was sind die Anweisungen die den Kontrollfluss eines Programms beeinflussen?', 'answer': 'Die Anweisungen die den Kontrollfluss eines Programms beeinflussen sind: if-Anweisungen, while-Anweisungen, repeat-Anweisungen, case-Anweisungen, for-Anweisungen, loop-Anweisungen, exit-Anweisungen und return-Anweisungen.'},
     {'question': 'Was ist die Switch-Anweisung in Java?', 'answer': 'Die Switch-Anweisung in Java ist eine Steuerungsanweisung, die einen Ausdruck mit einem oder mehreren Literalen vergleicht und eine entsprechende Anweisungsliste ausführt. Der Ausdruck und die Literale müssen vom Typ char, byte, short, int, String oder einem Aufzählungstyp sein. Die Anweisungslisten können mit einem break abgeschlossen werden, müssen aber nicht. Wenn keines der Literale mit dem Ausdruck übereinstimmt, wird die default-Anweisungsliste ausgeführt.'},
     {'question': 'Was sind die möglichen Seiteneffekte der Assert-Anweisung?', 'answer': 'Die Assert-Anweisung kann Seiteneffekte haben, wie das Ändern von Werten von Variablen aus umgebenden Blöcken oder von Instanzvariablen.'},
     {'question': 'Was sind Assert-Anweisungen in Java?', 'answer': 'Assert-Anweisungen in Java sind ein Verfahren, um Invarianten in einem Programm zu überprüfen. Dabei werden die Bedingungen, die die Invarianten formulieren, zur Laufzeit überprüft, indem die entsprechenden Statements ausgeführt werden. Fortschrittlichere Verfahren zur Zusicherung von Invarianten werden jedoch als Quellcodeannotationen formuliert und stellen sicher, dass alle Zugriffe auf Programmelemente den Zustand des Programms nicht verändern.'},
     {'question': 'Welche Semantik haben Variablen in Java?', 'answer': 'In Java haben Variablen entweder Referenz- oder Wertsemantik, je nachdem welchen Typ sie haben. Variablen mit primitiven Typen wie byte, short, int, long, float, double, boolean und char haben Wertsemantik, während Variablen mit anderen Typen Referenzsemantik haben.'},
     {'question': 'Was ist Auto boxing und Auto unboxing in Java?', 'answer': 'Seit Java 5 können Werte primitiver Typs direkt Variablen der entsprechenden Wrapper-Typen zugewiesen werden und umgekehrt. Dies nennt man "Auto boxing" bzw. "Auto unboxing". Dabei ist es wichtig, in Java sorgfältig zu überlegen, ob man die equals-Methode oder den Test auf Identität (==) verwenden sollte, um unerwartete Phänomene zu vermeiden.'},
     {'question': 'Was ist das Friends-Konzept in C++?', 'answer': 'Das Friends-Konzept in C++ ist ein Mechanismus, der eine enge Kooperation zwischen Klassen ermöglicht. Dabei kann eine Klasse auf Elemente einer anderen Klasse zugreifen, die anderen Klassen verborgen bleiben sollen. Die Schnittstelle solcher kooperierender Klassen kann somit relativ zu anderen Klassen definiert werden.'},
     {'question': 'Was sind Wrapper-Typen in Java?', 'answer': 'In Java werden für jeden primitiven Typ Referenztypen definiert, die Werte eines entsprechenden primitiven Typs aufnehmen können. Diese Typen, nämlich Byte, Short, Integer, Long, Float, Double, Boolean und Character, werden Wrapper-Typen genannt.'},
     {'question': 'Was sind Literale in Java?', 'answer': 'Literale sind in Java fest definierte Werte, die direkt in den Quellcode eingebettet werden können. Sie werden vom Compiler in Maschinencode übersetzt. In Java gibt es Literale für die folgenden Datentypen: Ganze Zahlen (Integer-Literale), Gleitkommazahlen (Floating-Point-Literale), Zeichen (Character-Literale), Zeichenketten (String-Literale), Boolean-Literale und Null-Literale. Ganze Zahlen'},
     {'question': 'Welche Typkonstruktoren bietet C-Sharp für Wert- und Referenztypen an?', 'answer': 'C-Sharp bietet für Wert-Typen die Typkonstruktoren struct und enum, für Referenz-Typen die Typkonstruktoren class und interface an.'},
     {'question': 'Welche Verbesserungen bietet C-Sharp in Verbindung mit dem Typsystem?', 'answer': 'C-Sharp bietet eine ganze Reihe von Verbesserungen in Verbindung mit dem Typsystem, auf die hier aber nicht näher eingegangen wird.'},
     {'question': 'Wofür wird C++ eingesetzt?', 'answer': 'C++ ist ein objektorientierter Nachfolger von C, der einen stufenlosen Übergang von der prozeduralen zur objektorientierten Programmierung ermöglicht. Es wird hauptsächlich für maschinennahe Programmierung wie bei Betriebs- oder eingebetteten Systemen eingesetzt, bei denen extreme Speicher- und Recheneffizienz oft oberste Kriterien sind.'},
     {'question': 'Was ist der Zweck von generischen Variablen in Java?', 'answer': 'Der Zweck von generischen Variablen in Java ist es, Variablen zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Dies ist möglich, da eine Variable keinen neuen Sichtbarkeitsbereich definiert, jedoch nur mit anonymen Typvariablen, also Wildcards. Der per "Wildcard" deklarierten Variable können also Listen beliebigen Elementtyps zugewiesen werden, weil "List<?>" Supertyp aller Instanziierungen von "List<T>" ist.'},
     {'question': 'Was ist die Rolle des Typsystems in C++?', 'answer': 'Das Typsystem von C++ ist ein wichtiger Bestandteil der Sprache und umfasst primitive Datentypen wie int, bool, etc., sowie die Typkonstruktoren struct und union. Diese Typen sind alle Typen mit Wertsemantik. Es ist auch möglich, Zeigertypen auf diese Typen zu definieren.'},
     {'question': 'Welche Datentypen gibt es in C++?', 'answer': 'In C++ gibt es primitive Datentypen wie int, bool, etc., und auch die Typkonstruktoren struct und union. Alle diese Typen sind Typen mit Wertsemantik. Es lassen sich jedoch auch Zeigertypen darauf definieren.'},
     {'question': 'Was ist Mehrfachvererbung in C++?', 'answer': 'Mehrfachvererbung in C++ bedeutet, dass eine Klasse von mehreren anderen Klassen abgeleitet werden kann. Die Syntax von C++ sieht vor, die Namen der Basisklassen, von denen abgeleitet wird, durch einen Doppelpunkt getrennt hinter dem Namen der zu definierenden Klasse aufzulisten.'},
     {'question': 'Was ist das Problem bei der Mehrfachvererbung in C++?', 'answer': 'Das Problem bei der Mehrfachvererbung in C++ ist, dass verschiedene Supertypen eines Typs dieselbe Eigenschaft anders spezifizieren können. Der Subtyp hat dann einen Konflikt, da er nicht den Spezifikationen beider Supertypen dienen kann.'},
     {'question': 'Was ist die Folge der Mehrfachvererbung für das Typsystem?', 'answer': 'Die Folge der Mehrfachvererbung für das Typsystem ist, dass ein von einer Klasse abgeleiteter Typ beliebig viele direkte Supertypen haben kann (nämlich einen pro direkte Superklasse).'},
     {'question': 'Was ist eine virtuelle Methode?', 'answer': 'Bei virtuellen Methoden wird zur Laufzeit geprüft, welchen Typs das Objekt ist, und dann zur entsprechenden Methodenimplementierung verzweigt. Dies geschieht über eine Virtual function table, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt als teuer und sollte daher nur verwendet werden, wenn unbedingt notwendig.'},
     {'question': 'Was ist ein Virtual function table?', 'answer': 'Ein Virtual function table ist eine Tabelle, die im Laufzeitsystem gehalten wird und in der die zum Objekt passende Implementierung einer virtuellen Methode nachgeschlagen werden kann. Sie wird verwendet, um zur Laufzeit zu prüfen, welchen Typs das Objekt ist und dann zur entsprechenden Methodenimplementierung zu verzweigen.'},
     {'question': 'Was ist das Typsystem von C++?', 'answer': 'Das Typsystem von C++ ist rein statisch, aber nicht strikt. Es erlaubt Typumwandlungen (Type casts), die nur zur Kompilierungszeit überprüft werden. Während der Laufzeit wird die Zulässigkeit der Typumwandlung nicht überprüft.'},
     {'question': 'Was ist das Verhältnis zwischen einem Thread und einem Thread-Objekt in Java?', 'answer': 'Ein Thread ist ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Jeder Thread hat jedoch ein Thread-Objekt, das ihn repräsentiert und spezifische Daten wie den Namen des Threads und seine Priorität speichert. Das Thread-Objekt kann mit Thread.currentThread() abgefragt werden.'},
     {'question': 'Was ist der Zweck von Monitoren in Java?', 'answer': 'Monitoren in Java werden verwendet, um den Zugriff auf ein Objekt durch mehrere Threads zu synchronisieren. Wenn ein Thread einen Monitor sperrt, kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.'},
     {'question': 'Was ist der Zweck der synchronized-Anweisung in Java?', 'answer': 'Die synchronized-Anweisung in Java wird verwendet, um die Synchronisation von Threads zu erzwingen. Sie stellt sicher, dass die Anweisungen innerhalb des synchronisierten Blocks nur dann ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden.'},
     {'question': 'Was ist die Aufgabe der Laufzeitkomponente des Typsystems in C-Sharp?', 'answer': 'Die Laufzeitkomponente des Typsystems in C-Sharp führt eine strikte Typprüfung durch, um sicherzustellen, dass die Variablen und Ausdrücke nur mit Werten verwendet werden, die zum jeweiligen Typ passen.'},
     {'question': 'Was ist der Zweck von Casts in C++?', 'answer': 'Der Zweck von Casts in C++ ist es, die statische Typisierung zu umgehen und den Compiler zu zwingen, den Ausdruck auf der linken Seite des Casts als Typ zu interpretieren, der auf der rechten Seite angegeben ist.'},
     {'question': 'Was sind Ragged oder Jagged arrays in Java?', 'answer': 'Ragged oder Jagged arrays in Java sind mehrdimensionalen Arrays, bei denen die Größen der zweiten und aller weiteren Dimensionen nicht für jedes Element der ersten Dimension gleich viele Elemente enthalten müssen.'},
     ],
    [{'question': 'Wie erzeugt man in C++ Objekte mit Identität?', 'answer': 'Um in C++ Objekte mit Identität zu erzeugen, muss man Variablen vom Typ eines Zeigers auf eine Klasse anlegen und dann eine Klasse mit dem New-Operator instanziieren.'},
     {'question': 'Wie verhält sich Java und SMALLTALK in Bezug auf die Übergabe von Parametern?', 'answer': 'In Java und SMALLTALK wird bei Methodenaufrufen immer der Zeiger auf das Objekt übergeben, und es wird nirgends explizit angegeben, dass es sich um eine Pointer-variable handelt.'},
     {'question': 'Wie werden Generics in C-Sharp und Java behandelt?', 'answer': 'In Java werden die Typparameter grundsätzlich immer wegkompiliert, um Abwärtskompatibilität zu erreichen. Im Gegensatz dazu instanziiert C-Sharp im Fall von Werttyp-Parametern jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen. Für Referenztypen wird der Code jedoch nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.'},
     {'question': 'Wie werden Typen in C-Sharp und Java behandelt?', 'answer': 'In Java werden die Typparameter grundsätzlich immer wegkompiliert, um Abwärtskompatibilität zu erreichen (Type erasure). Im Gegensatz dazu instanziiert C-Sharp im Fall von Werttyp-Parametern (wie int, float usw., aber auch die per struct definierten Typen) jede generische Klasse für jeden verwendeten Typ einmal, erzeugt also alternative Implementierungen (sog. Typexpansion). Für Referenztypen wird der Code jedoch (wie in Java) nur einmal erzeugt. Gleichwohl bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.'},
     {'question': 'Wie wird in C-Sharp Zuweisungskompatibilität bei Containern hergestellt?', 'answer': 'In C-Sharp wird Zuweisungskompatibilität bei Containern hergestellt, indem dem kovarianten bzw. kontravarianten Typparameter das Schlüsselwort out bzw. in vorangestellt wird. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen.'},
     {'question': 'Wie wird in C-Sharp das Varianzproblem bei der Zuweisung von Containern gelöst?', 'answer': 'In C-Sharp wird das Varianzproblem bei der Zuweisung von Containern durch eine Annotation der Definition des Typs gelöst. Dem kovarianten bzw. kontravarianten Typparameter wird dazu das Schlüsselwort out bzw. in vorangestellt. Die Beschränkungen (nur lesen bzw. nur schreiben) sind dann bei allen Verwendungen des Typs die gleichen.'},
     {'question': 'Wie erhält man einen Iterator für eine Collection in Java?', 'answer': 'In Java kann man einen Iterator für eine Collection erhalten, indem man die Methode iterator() auf der Collection aufruft. Diese Methode gibt ein Iterator-Objekt zurück, das für die Iteration über die Elemente der Collection verwendet werden kann.'},
     {'question': 'Wie funktioniert der Bindealgorithmus in Java?', 'answer': 'Der Bindealgorithmus in Java funktioniert, indem er zunächst die Methode in der Klasse sucht, in der sie aufgerufen wurde. Wenn sie nicht gefunden wird, wird die Superklasse überprüft, bis die Methode gefunden wird oder die Klassenhierarchie durchsucht ist. Wenn die Methode nicht in der Klassenhierarchie gefunden wurde, wird eine Methode mit dem gleichen Namen in einer Schnittstelle gesucht, die von der Klasse implementiert wird. Wenn die Methode immer noch nicht gefunden wurde, wird eine Fehlermeldung ausgegeben.'},
     {'question': 'Wie funktioniert das dynamische Binden in Java?', 'answer': 'Das dynamische Binden in Java funktioniert durch einen Bindealgorithmus, der im Klassenbereich der Klasse des Objekts beginnt und sich durch die Klassenhierarchie nach oben arbeitet, bis eine passende Methode gefunden wird oder die Suche bei Object endet.'},
     {'question': 'Wie wird ein dynamischer Methodenaufruf zur Übersetzungszeit gebunden?', 'answer': 'Ein dynamischer Methodenaufruf wird zur Übersetzungszeit lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die den Namen und die Anzahl der Parameter der aufgerufenen Methode teilt, in der Klasse deklariert ist, die dem deklarierten Typ des Empfängerobjekts entspricht, und deren deklarierte Parametertypen Subtypen der deklarierten Parametertypen des Aufrufs sind. Wenn es mehrere solche Methoden gibt, wird diejenige gewählt, deren deklarierte formale Parametertypen am nächsten oder gleich weit vom Typ des Aufrufs entfernt sind.'},
     {'question': 'Wann wird eine dynamische Methode an eine Methodendeklaration gebunden?', 'answer': 'Bereits zur Übersetzungszeit wird ein dynamischer Methodenaufruf lose an eine Methodendeklaration gebunden, und zwar an genau diejenige, die den Namen und die Anzahl der Parameter der aufgerufenen Methode teilt, in der Klasse deklariert ist, die dem deklarierten Typ des Empfängerobjekts entspricht oder von einer ihrer Superklassen geerbt wird, und deren deklarierte Parametertypen Subtypen der deklarierten Parametertypen der Methodendeklaration sind.'},
     {'question': 'Wie wird ein dynamischer Methodenaufruf in der objektorientierten Programmierung gebunden?', 'answer': 'Ein dynamischer Methodenaufruf wird in der objektorientierten Programmierung an eine Methodendeklaration gebunden, die den gleichen Namen und dieselbe Anzahl von Parametern wie die aufgerufene Methode hat, in der Klasse deklariert ist, die dem deklarierten Typ des Empfängerobjekts entspricht, und deren deklarierte Parametertypen Subtypen der deklarierten Parametertypen des Aufrufs sind. Wenn keine solche Methode gefunden wird, wird die Suche nach einer Methode mit den gleichen Eigenschaften in den Superklassen wiederholt.'},
     {'question': 'Wie wird die tatsächliche Methode bei der Laufzeit bestimmt?', 'answer': 'Zur Laufzeit wird der tatsächliche Typ des Empfängerobjekts bestimmt. Mit diesem tatsächlichen (auch dynamisch genannten) Typ wird dann aus der Gruppe der in Frage kommenden überschriebenen Methoden diejenige ausgewählt, die in der Klasse definiert wurde, die der Klasse des Empfängerobjekts in der Superklassenkette am nächsten ist.'},
     {'question': 'Wann tritt ein Methodenambiguitätsfehler nicht mehr auf?', 'answer': 'Ein Methodenambiguitätsfehler tritt nicht mehr auf, wenn der problematische Aufruf entfernt wird.'},
     {'question': 'Wie wird C++ oft beschrieben?', 'answer': 'C++ wird oft als eine "sofortige Legacy"-Sprache beschrieben, die eine Erweiterung von C ist und eine chaotische Syntax hat.'},
     {'question': 'Wie werden Zu-n-Beziehungen in Java umgesetzt?', 'answer': 'In Java werden Zu-n-Beziehungen mithilfe von Zwischenobjekten umgesetzt, wobei zwischen zwei Arten von Zwischenobjekten unterschieden wird: Arrays und Collections. Arrays sind in Java beschränkt, da sie keine eigenen Methoden zur Unterstützung des Zugriffs haben, kein dynamisches Wachstum ermöglichen und eine etwas verkorkste Situation beim Subtyping aufweisen.'},
     {'question': 'Wie können Klienten auf die Methoden zugreifen, ohne die tatsächliche Implementierung zu kennen?', 'answer': 'Klienten können auf die Methoden zugreifen, ohne die tatsächliche Implementierung zu kennen, indem sie die Interfaces verwenden, die die Schnittstelle zwischen Klienten und Diensten definieren. Die Interfaces definieren den Vertrag, welche Methoden eine Klasse implementieren muss, um ein bestimmtes Verhalten zu bieten, und die Klienten können auf die Methoden zugreifen, indem sie die Interfaces als Typen verwenden.'},
     {'question': 'Wie werden Java-Programme gespeichert und ausgeführt?', 'answer': 'Java-Programme werden als Quelltext in sogenannten Compilation Units gespeichert, die gewöhnlich Dateien sind und die immer als Ganzes übersetzt werden. Das Ergebnis der Übersetzung ist Bytecode, der von einer virtuellen Maschine, der Java Virtual Machine (JVM), interpretiert werden muss. Die JVM ermöglicht eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit.'},
     {'question': 'Wie wird ein Java-Programm ausgeführt?', 'answer': 'Um ein Java-Programm auszuführen, muss man eine Klasse angeben, die eine Startmethode mit der Signatur public static void main(String[] args) besitzt. Diese Startmethode ist eine statische Methode, die nicht zu einem Objekt gehört, sondern der Klasse selbst. Sie wird über den Klassennamen aufgerufen. Die main-Methode ist eine normale Instanzmethode, die zu einem beliebigen Objekt gehören kann, das die main-Methode implementiert.'},
     {'question': 'Wie startet man ein Java-Programm?', 'answer': 'Um ein Java-Programm auszuführen, muss man eine Klasse angeben, die eine main-Methode besitzt. Die Signatur der main-Methode hat die Form public static void main(String[] args). Die main-Methode ist eine normale Instanzmethode, die zu einem beliebigen Objekt gehören kann, das die main-Methode implementiert.'},
     {'question': 'Wie heißt die Startmethode in Java?', 'answer': 'Die Startmethode in Java heißt "public static void main(String[] args)".'},
     {'question': 'Wie werden Klassen in Java und SMALLTALK benannt?', 'answer': 'In Java werden Klassen wie in SMALLTALK per Konvention immer großgeschrieben.'},
     {'question': 'Wie werden Java-Anwendungen in der Regel verteilt?', 'answer': 'Java-Anwendungen werden heute praktisch nur noch per Java Archive (einer .jar-Datei) verteilt. Zur Ausführung ist jedoch eine Installation der JVM nötig.'},
     {'question': 'Wie ist der Zusammenhang zwischen Klassen und Dateien in Java?', 'answer': 'In Java besteht ein enger Zusammenhang zwischen Klassen und Dateien. Jede Datei enthält die Definition einer Klasse, die den Dateinamen (ohne Erweiterung) als Namen trägt. Eine Datei kann auch mehrere Klassen enthalten, die dann verschiedene Namen haben müssen. Es darf jedoch nur eine dieser Klassen als "public" deklariert werden.'},
     {'question': 'Wie hängen Klassen und Typen in Java zusammen?', 'answer': 'In Java definiert jede Klasse ihren eigenen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält.'},
     {'question': 'Wie wird in Java ein Typ definiert?', 'answer': 'In Java wird ein Typ durch eine Klassendefinition definiert, die Felddefinitionen und Methodendeklarationen enthält. Jede Klasse definiert somit ihren eigenen Typ, der denselben Namen wie die Klasse trägt.'},
     {'question': 'Wie werden Variablen in Java deklariert?', 'answer': 'In Java wird der Typ einer Variablen bei der Deklaration vorangestellt, z.B. int x; oder String s;'},
     {'question': 'Wie hat Microsoft das Problem der temporären Variablen gelöst?', 'answer': 'Microsoft hat das Problem der temporären Variablen zumindest teilweise auf die Ebene der Programmiersprache gehoben, indem es eine Möglichkeit geschaffen hat, diese Unterscheidung in der Programmiersprache zu behandeln.'},
     {'question': 'Wie werden Klassenfelder und -methoden in C++ deklariert?', 'answer': 'Klassenfelder und -methoden werden in C++ mit dem Schlüsselwort "static" in einer Klasse eingeführt, ähnlich wie in Java.'},
     {'question': 'Wie erfolgt die Erzeugung von Objekten in C++ im Vergleich zu Java?', 'answer': 'In C++ erfolgt die Erzeugung von Objekten oft ohne "new". Der benötigte Speicherplatz wird bei der Deklaration reserviert, und es entstehen Werte (Objekte) mit Wertsemantik, im Gegensatz zu Java, wo "new" verwendet wird.'},
     {'question': 'Wie erzeugt man in C++ Objekte mit Identität?', 'answer': 'Um in C++ Objekte mit Identität zu erzeugen, muss man Zeigervariablen (Pointer) verwenden und eine Klasse mit dem "new"-Operator instanziieren.'},
     {'question': 'Wie sieht die Dereferenzierung eines Zeigers auf ein Objekt in C++ aus?', 'answer': 'In C++ erfolgt die Dereferenzierung eines Zeigers auf ein Objekt mit "->", z.B., "a->x" oder "a->f(x)" für ein Feld oder eine Methode der Klasse.'},
     {'question': 'Wie kann in C++ "Call by reference" erreicht werden?', 'answer': 'In C++ kann "Call by reference" erreicht werden, indem man den Zeigeroperator "&" verwendet und die formalen Parameter so deklariert, dass sie Zeiger auf Zeiger aufnehmen können.'},
     {'question': 'Wie wird das Varianzproblem bei der Subtypisierung von Containern in C-Sharp gelöst?', 'answer': 'In C-Sharp wird das Varianzproblem bei der Subtypisierung von Containern durch das Hinzufügen des Schlüsselworts "out" für kovariante Typparameter und "in" für kontravariante Typparameter bei der Definition des Typs gelöst. Dies stellt sicher, dass Zuweisungskompatibilität auch dann gegeben ist, wenn die generischen Typen verschiedene Typparameter haben.'},
     {'question': 'Wie hat Microsoft versucht, das Problem der Kommunikation mit unbekannten Objekten auf der Ebene der Programmiersprache zu lösen?', 'answer': 'Microsoft hat versucht, das Problem der Kommunikation mit unbekannten Objekten teilweise von der Ebene der Programmierung auf die Ebene der Programmiersprache zu heben, indem sie das Konstrukt des Events (Ereignisses) eingeführt haben. Über Ereignisse können sogenannte Eventhandler aktiviert werden, die auf unerwartete Ereignisse reagieren können. Dies wurde mithilfe von Delegates realisiert.'},
     {'question': 'Wie wird in C-Sharp sichergestellt, dass explizite Interfaceimplementierungen von außen aufgerufen werden?', 'answer': 'In C-Sharp muss der tatsächliche deklarierende Typ des Objekts als Qualifikator für den Methodenaufruf angegeben werden, um sicherzustellen, dass die richtige explizite Interfaceimplementierung aufgerufen wird.'},
     {'question': 'Wie werden in EIFFEL überschriebene Methoden bezeichnet?', 'answer': 'In EIFFEL werden überschriebene Methoden als "Redefinition" bezeichnet.'},
     {'question': 'Wie können in EIFFEL Methoden mit demselben Namen in verschiedenen Klassen behandelt werden?', 'answer': 'In EIFFEL ist es erlaubt, dass verschiedene Klassen Methoden mit gleichem Namen haben, solange diese Klassen nicht in einer Vererbungsbeziehung zueinander stehen. Wenn die Methoden gleiche oder kovariant redefinierte Parameter haben, handelt es sich nicht um Überladung, sondern um Überschreibung.'},
     {'question': 'Wie kann in EIFFEL sichergestellt werden, dass geerbte Features mit demselben Namen unterschiedlich benannt werden?', 'answer': 'EIFFEL ermöglicht es, geerbte Features umzubenennen, indem eine "Rename"-Klausel verwendet wird. Diese Klausel erlaubt es, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen, ohne das dynamische Binden zu beeinflussen.'},
     {'question': 'Wie unterscheidet sich das Programmiermodell von C-Sharp von dem von Java?', 'answer': 'Das Programmiermodell von C-Sharp weist zunächst einige Ähnlichkeiten mit dem von Java auf, da es ebenfalls auf Klassen basiert und der Code in einzelnen Klassen organisiert ist. Die Klassen in C-Sharp können jedoch in lockererem Verhältnis zu Dateien stehen, und Klassen können anders benannt werden als ihre Dateien. Ein wesentlicher Unterschied besteht darin, dass der Bytecode von C-Sharp und die zugehörige virtuelle Maschine, Common Intermediate Language (CIL) genannt, für alle .NET-Sprachen entwickelt wurden und nicht exklusiv für C-Sharp. Die CIL gilt als menschenlesbar.'},
     {'question': 'Wie werden Vor- und Nachbedingungen in EIFFEL formuliert?', 'answer': 'Vor- und Nachbedingungen in EIFFEL werden als Boolesche Ausdrücke formuliert, die immer als "wahr" ausgewertet werden müssen. Die "require"-Klausel stellt Bedingungen dar, die vor dem Aufruf der Methode erfüllt sein müssen, während die "ensure"-Klausel Bedingungen darstellt, die nach dem Aufruf der Methode garantiert erfüllt sind.'},
     {'question': 'Wie werden Zusicherungen in EIFFEL vererbt, insbesondere wenn eine Methode redefiniert wird?', 'answer': 'Zusicherungen, einschließlich Vor- und Nachbedingungen, werden in EIFFEL von Klassen auf ihre Subklassen vererbt. Wenn eine Methode redefiniert wird, dürfen die Zusicherungen angepasst werden, jedoch mit bestimmten Einschränkungen. Die Vorbedingung darf nur abgeschwächt und die Nachbedingung nur verschärft werden, und die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingungen eingehalten werden.'},
     {'question': 'Wie können Runtime Type Information (RTTI) in C++ verwendet werden, um den Typ eines Objekts zu ermitteln?', 'answer': 'RTTI kann verwendet werden, indem die Funktion typeid auf eine Referenz aufgerufen wird. Diese Funktion ist auf Klassennamen überladen und gibt eine Struktur zurück, auf der == als Gleichheitstest definiert ist. Der Typ eines Objekts kann überprüft werden, indem typeid(x) == typeid(T) verwendet wird.'},
     {'question': 'Wie kann in C++ ohne Verwendung von typeid herausgefunden werden, welcher Klasse Instanzen aller Klassen angehören?', 'answer': 'Eine Möglichkeit, den Typ einer Klasse in C++ ohne Verwendung von typeid herauszufinden, ist die Verwendung von dynamic_cast. Man kann versuchen, das Objekt auf verschiedene Klassen zu überprüfen, und wenn das Casting erfolgreich ist, gehört das Objekt zu dieser Klasse.'},
     {'question': 'Wie werden Zugriffsmethoden in EIFFEL syntaktisch dargestellt?', 'answer': 'Zugriffsmethoden in EIFFEL sehen syntaktisch aus wie Variablen, können jedoch Funktionen (Setter) oder Funktionen (Getter) sein. Sie können verwendet werden, um Werte zu setzen oder zu lesen.'},
     {'question': 'Wie werden in EIFFEL Abfragen und Befehle logisch unterteilt?', 'answer': 'In EIFFEL werden Methoden einer Klasse als "Abfragen" (queries) und "Befehle" (commands) logisch unterteilt. Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern.'},
     {'question': 'Wie wird der Zugriff auf Features in EIFFEL kontrolliert?', 'answer': 'In EIFFEL wird der Zugriff auf Features durch die gezielte Veröffentlichung (Export) von Features gesteuert. Klassen, die auf diese Features zugreifen sollen, werden explizit genannt.'},
     {'question': 'Wie unterscheidet sich EIFFEL von C++ in Bezug auf die Ausführungsumgebung?', 'answer': 'Im Gegensatz zu C++ führt EIFFEL den Code nicht auf einer virtuellen Maschine aus, sondern direkt auf der Zielmaschine. Es gibt jedoch auch eine Version von EIFFEL für .NET, die in CIL übersetzt und dann in Maschinencode ausgeführt wird.'},
     {'question': 'Wie wird EIFFEL als Sprache häufig charakterisiert?', 'answer': 'EIFFEL wird als eine akademische Sprache charakterisiert, was bedeutet, dass sie in erster Linie in der akademischen Welt verwendet wird und möglicherweise weniger in kommerziellen Anwendungen anzutreffen ist.'},
     {'question': 'Wie wird in EIFFEL ein Typtest durchgeführt?', 'answer': 'In EIFFEL wird ein Typtest mithilfe eines "Zuweisungsversuchs" (engl. "assignment attempt") durchgeführt. Wenn es keine Zuweisungskompatibilität zwischen den Typen gibt, wird "void" (entsprechend "nil" in SMALLTALK oder "null" in Java) zugewiesen. Die Programmiererin muss dann den Typ von "a" nach der Zuweisung überprüfen.'},
     {'question': 'Wie definiert EIFFEL unparametrisierte und parametrisierte Klassen?', 'answer': 'In EIFFEL definiert jede unparametrisierte Klasse einen Typ, während jede parametrisierte Klasse eine (generische) Menge von Typen definiert.'},
     {'question': 'Wie wird in EIFFEL zwischen Wert- und Referenztypen unterschieden?', 'answer': 'In EIFFEL kann bei der Deklaration angegeben werden, ob Variablen eines Typs Wertsemantik oder Referenzsemantik haben sollen. Dies kann für alle Variablen eines Typs oder nur für bestimmte Variablen festgelegt werden.'},
     {'question': 'Wie könnte man die Kovarianzprobleme in EIFFEL verhindern?', 'answer': 'Es gibt verschiedene Ansätze, um die Kovarianzprobleme in EIFFEL zu verhindern, darunter die Beschränkung der Zuweisungskompatibilität, die Durchführung einer Typinferenz für das gesamte Programm und das Verbot dynamisch gebundener Aufrufe von Methoden, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen ändern. Jede dieser Methoden hat jedoch ihre eigenen Einschränkungen und Herausforderungen.'},
     {'question': 'Wie werden Tupeltypen in EIFFEL deklariert?', 'answer': 'Tupeltypen in EIFFEL werden deklariert, indem für jede Position im Tupel ein Typ angegeben wird. Konkrete Werte eines Tupels werden in eckigen Klammern notiert, wobei die Positionen optional auch Namen erhalten können.'},
     {'question': 'Wie wird in C++ festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen?', 'answer': 'In C++ wird festgelegt, welche Klassen auf die privaten Elemente einer anderen Klasse zugreifen dürfen, indem man die betreffenden Klassen mit dem Schlüsselwort "friend" in der Zielsklasse deklariert. Zum Beispiel: friend class B; und friend class C;'},
     {'question': 'Wie wird das Friends-Konzept in Java angenähert?', 'answer': 'Das Friends-Konzept wird in Java durch die Verwendung von Modulen und den dedizierten (qualifizierten) Export auf Ebene der Pakete angenähert. Dies ermöglicht eine kontrollierte Freigabe von Elementen an bestimmte Pakete.'},
     {'question': 'Wie ermöglicht C++ die getrennte Übersetzung von Programmteilen?', 'answer': 'C++ ermöglicht die getrennte Übersetzung von Programmteilen mithilfe von Header-Dateien, die die Schnittstellen der Teile enthalten.'},
     {'question': 'Wie erfolgt die Methodenbindung in C++ standardmäßig?', 'answer': 'Standardmäßig erfolgt die Methodenbindung (Methodenaufruf) in C++ statisch. Das bedeutet, dass die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable hat.'},
     {'question': 'Wann werden Methoden in C++ zur Laufzeit dynamisch gebunden?', 'answer': 'In C++ werden Methoden zur Laufzeit dynamisch gebunden, wenn sie mit dem Schlüsselwort virtual deklariert sind. Bei virtuellen Methoden wird zur Laufzeit überprüft, welchen Typs das Objekt ist, und zur entsprechenden Methodenimplementierung verzweigt.'},
     {'question': 'Wie wird Generizität in C++ implementiert?', 'answer': 'Generizität in C++ wird mit Hilfe von Templates erreicht. Ein Template ist ein Muster, anhand dessen neue, parameterlose Klassen erzeugt werden können. Tatsächlich werden aus Templates neue Typen erzeugt, und für jede Instanz eines generischen Typs wird ein neuer Typ erzeugt und kompiliert.'},
     {'question': 'Wie wird die Zulässigkeit von Typumwandlungen in C++ überprüft?', 'answer': 'Die Zulässigkeit von Typumwandlungen in C++ wird zur Laufzeit überprüft, und sie kann nicht zur Kompilierzeit überprüft werden. Typumwandlungen sollten vermieden werden, da sie die Typsicherheit untergraben können.'},
     {'question': 'Wie kann in C-Sharp eine Typumwandlung (Casting) durchgeführt werden?', 'answer': 'In C-Sharp kann eine Typumwandlung mithilfe von Casts durchgeführt werden. Die Syntax dafür ist (T)a;, wobei T der Zieltyp ist und a der Ausdruck, der umgewandelt werden soll.'},
     {'question': 'Wie wird in C-Sharp sichergestellt, dass ein Cast sicher ist?', 'answer': 'In C-Sharp wird ein Cast sicher gemacht, indem der is-Operator verwendet wird, um zu prüfen, ob die Zuweisung kompatibel ist. Zusätzlich kann der as-Operator verwendet werden, der bei fehlschlagender Zuweisung null zurückgibt.'},
     {'question': 'Wie werden Methoden in EIFFEL überschrieben?', 'answer': 'In EIFFEL wird das Überschreiben von Methoden als "Redefinition" bezeichnet.'},
     {'question': 'Wie werden abstrakte Klassen in EIFFEL deklariert?', 'answer': 'In EIFFEL werden abstrakte Klassen mit dem Schlüsselwort "deferred" deklariert.'},
     {'question': 'Wie ist die Reihenfolge der Klassendeklaration in EIFFEL?', 'answer': 'In EIFFEL muss zu Beginn einer Klassendefinition deklariert werden, welche Methoden in der Klasse überschrieben werden ("welche \'Features redefiniert\' werden").'},
     {'question': 'Wie wirkt sich das Umbenennen von geerbten Features auf das dynamische Binden in Eiffel aus?', 'answer': 'Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.'},
     {'question': 'Wie wirkt sich das Umbenennen von geerbten Features auf das dynamische Binden in Eiffel aus?', 'answer': 'Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.'},
     {'question': 'Wie ist das Verhältnis von Klasse zu Datei in C-Sharp?', 'answer': 'Das Verhältnis von Klasse zu Datei in C-Sharp ist lockerer als in Java. Klassen können anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden.'},
     {'question': 'Wie ist der Umgang mit primitiven Typen und Referenztypen in Java?', 'answer': 'In Java gibt es eine klare Trennung zwischen primitiven Typen und Referenztypen. Für primitiven Typen sind bestimmte Operationen fest vorgegeben, wie es die Sprachdefinition vorsieht. Alle anderen Operationen müssen als Methoden in Klassen definiert werden. Primitive Typen sind keine Klassen und es ist daher nicht gestattet, Operatoren in Klassendefinitionen zu definieren. Diese Trennung ist konsequent durchgezogen und hat den Charakter von Java als Programmiersprache geprägt.'},
     {'question': 'Wie wird der Zugriff auf Klassen, Typen und deren Elemente in Java eingeschränkt?', 'answer': 'In Java wird der Zugriff auf Klassen, Typen und deren Elemente durch sogenannte Zugriffsmodifikatoren eingeschränkt. Es gibt vier Zugriffsmodifikatoren: private, protected, public und "Package local". Die Zugriffsbeschränkung ist konzeptionell eine Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.'},
     {'question': 'Wie ist der Zugriff auf Instanzvariablen und Instanzmethoden geregelt?', 'answer': 'Eine Klasse kann nur auf Instanzvariablen und Instanzmethoden der Klasse selbst und ihrer Superklassen zugreifen. Eine Instanzvariable ist nur innerhalb der Klasse sichtbar, in der sie deklariert ist. Eine Instanzmethode kann nur auf Instanzvariablen und Instanzmethoden der Klasse, in der sie deklariert ist, und ihrer Superklassen zugreifen.'},
     {'question': 'Wie wirken sich Zugriffsbeschränkungen auf die Verwendung von Variablen und Methoden aus?', 'answer': 'Eine Klasse kann die Instanzvariablen und Instanzmethoden anderer Klassen nicht verwenden, wenn diese mit private deklariert sind. Eine Instanzmethode kann die Instanzvariablen und Instanzmethoden anderer Objekte nicht verwenden, wenn diese mit private deklariert sind. Eine Klasse kann die Klassenvariablen und Klassenmethoden anderer Klassen jedoch immer verwenden, unabhängig von der Deklaration. Eine Instanzmethode kann die Instanzvariablen und Instanzmethoden des Empfängers sowie die Klassenvariablen und Klassenmethoden anderer Klassen immer verwenden, unabhängig von der Deklaration.'},
     {'question': 'Wie werden Zahlenliterale in Java dargestellt?', 'answer': 'Zahlenliterale in Java können eine Vielzahl von Formen annehmen. Für drei besondere Werte im Fließkommabereich stehen jedoch keine Literale, sondern nur Konstanten zur Verfügung: Es handelt sich um "NaN" (für das englische "Not a Number") sowie "POSITIVE\\_INFINITY" und "NEGATIVE\\_INFINITY".'},
     {'question': 'Wie kann man in Java Klassen als Werte angeben?', 'answer': 'In Java können Klassen als Werte angegeben werden, indem man ein sogenanntes Klassenliteral verwendet, das aus dem Namen der Klasse, gefolgt von ".class" besteht, also beispielsweise "Klasse.class".'},
     {'question': 'Wie werden abstrakte Klassen in Java deklariert?', 'answer': 'In Java werden abstrakte Klassen mit dem Schlüsselwort "abstract" deklariert, um sie als abstrakt und damit als nicht instanziierbar zu kennzeichnen.'},
     {'question': 'Wie wird eine abstrakte Methode in SMALLTALK gekennzeichnet?', 'answer': 'In SMALLTALK wird eine abstrakte Methode durch einen Aufruf von "implementedBySubclass" o. ä. gekennzeichnet.'},
     {'question': 'Wie wird eine abstrakte Methode in Smalltalk deklariert?', 'answer': 'In Smalltalk wird eine abstrakte Methode hinter der Methodensignatur (also dem Namen und den Parametern) nicht mit einer Implementierung (in geschweiften Klammern) deklariert, sondern lediglich mit einem abschließenden Semikolon. Zusätzlich muss die Methode durch einen Aufruf von "implementedBySubclass" o. ä. gekennzeichnet werden.'},
     {'question': 'Wie ist das Typsystem in Java im Vergleich zu SMALLTALK und C++?', 'answer': 'Im Gegensatz zu SMALLTALK und C++ ist Java eine Sprache mit einem strengen Typsystem, bei der alle Typfehler entweder während der Übersetzung durch den Compiler oder während der Laufzeit erkannt werden.'},
     {'question': 'Wie werden Konstruktoren in Java definiert?', 'answer': 'In Java werden Konstruktoren definiert, indem man eine Methode mit demselben Namen wie die Klasse erstellt, die keine Rückgabewerte besitzt. Sie werden aufgerufen, indem man den Klassennamen verwendet, gefolgt von Klammern.'},
     {'question': 'Wie werden Konstruktoren in Java aufgerufen?', 'answer': 'In Java werden Konstruktoren nicht durch einen speziellen Methodennamen wie "new" aufgerufen, sondern durch den Klassennamen selbst.'},
     {'question': 'Wie können Ausnahmesituationen in einem Programm erkannt und gemeldet werden?', 'answer': 'Ausnahmesituationen können durch die Verwendung der Throw-Anweisung erkannt und gemeldet werden, um die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.'},
     {'question': 'Wie können Ausnahmesituationen in einem Programm behandelt werden?', 'answer': 'Ausnahmesituationen können vom Programm selbst erkannt und gemeldet werden, indem die Throw-Anweisung verwendet wird, um eine entsprechende Exception-Klasse zu instanziieren. Dies ermöglicht es, die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.'},
     {'question': 'Wie ist der Zugriff auf Klassen in Java geregelt?', 'answer': 'In Java gewähren Klassen sich untereinander privilegierten Zugriff, während nach außen nur öffentlich deklarierte Programmelemente sichtbar sind.'},
     {'question': 'Wie ist der Zugriff auf Programmelemente in Java geregelt?', 'answer': 'In Java ist der Zugriff auf Programmelemente so geregelt, dass Klassen eines Programms untereinander privilegierten Zugriff haben, während nach außen nur öffentlich deklarierte Programmelemente sichtbar sind.'},
     {'question': 'Wie wird der Zugriffsschutz in Java realisiert?', 'answer': 'Der Zugriffsschutz in Java wird durch die Zugriffskontrollmodifikatoren private, protected und public realisiert. Diese Modifikatoren bestimmen, welche Klassen auf die Elemente einer anderen Klasse zugreifen können. Standardmäßig ist alles, was nicht explizit als privat, geschützt oder öffentlich deklariert ist, in Java package-private, d.h. nur innerhalb des Pakets sichtbar.'},
     {'question': 'Wie wird der Zugriff auf die Elemente einer anderen Klasse in Java geregelt?', 'answer': 'Der Zugriff auf die Elemente einer anderen Klasse in Java wird durch die Zugriffskontrollmodifikatoren private, protected und public geregelt. Diese Modifikatoren bestimmen, welche Klassen auf die'},
     {'question': 'Wie wurde der Fehler bezüglich unnötig langer Bezeichner in Iterationen mit Java 5 korrigiert?', 'answer': 'Der Fehler bezüglich unnötig langer Bezeichner in Iterationen wurde mit Java 5 korrigiert, indem die "for"-Schleife um eine vereinfachte Schreibweise für die externe Iteration über Collections ergänzt wurde.'},
     {'question': 'Wie wird das dynamische Binden in Java durchgeführt, und warum ist es wichtig zu verstehen?', 'answer': 'Das dynamische Binden in Java erfolgt zur Laufzeit, wenn der tatsächliche Typ des Empfängerobjekts bestimmt wird, um die entsprechende Methode auszuwählen. Es ist wichtig zu verstehen, da es das Verhalten eines Programms beeinflusst und zur Vorhersage des Programmverhaltens beiträgt.'},
     {'question': 'Wie können Interfaces in Java dazu beitragen, die Austauschbarkeit von Klassen zu verbessern?', 'answer': 'Interfaces ermöglichen es, verschiedene Implementierungen eines Interfaces zu verwenden, ohne den zugrunde liegenden Klassentyp zu spezifizieren. Dies verbessert die Austauschbarkeit von Klassen, da verschiedene Klassen, die dasselbe Interface implementieren, in derselben Weise verwendet werden können.'},
     {'question': 'Wie erfolgt die Ausführung eines Java-Programms auf Betriebssystemebene?', 'answer': 'Die Ausführung eines Java-Programms auf Betriebssystemebene erfolgt, indem man der JVM den Namen der Klasse als Parameter übergibt. Zum Beispiel: "Java MeineKlasse".'},
     {'question': 'Wie erfolgt in Java das Deployment von Anwendungen?', 'answer': 'In Java erfolgt das Deployment von Anwendungen oft durch die Verteilung von sogenannten Java Archiven (.jar-Dateien). Zur Ausführung ist jedoch eine Installation der JVM erforderlich.'},
     {'question': 'Wie wurde das Problem der Erweiterung von Interfaces in Java 8 gelöst?', 'answer': 'In Java 8 wurde das Problem der Erweiterung von Interfaces gelöst, indem Interfaces die Implementierung von Methoden durch das Schlüsselwort "default" vorgeben konnten. Dadurch konnten zusätzliche Methoden in Interfaces hinzugefügt werden, ohne die implementierenden Klassen zu zwingen, sie zu implementieren.'},
     {'question': 'Wie wird ein Typ in Java aus einer Klassendefinition abgeleitet?', 'answer': 'In Java spezifiziert jede Klasse ihren eigenen Typ. Der Typ trägt denselben Namen wie die Klasse und enthält Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften.'},
     {'question': 'Wie wurden Module in Java bis zur Version 8 simuliert?', 'answer': 'In Java wurden Module bis zur Version 8 mehr oder weniger gut durch Klassen und Pakete simuliert.'},
     {'question': 'Wie kann auf Klassen und Typen in unterschiedlichen Paketen in Java zugegriffen werden?', 'answer': 'Um auf Klassen und Typen in verschiedenen Paketen zuzugreifen, müssen in Java explizite Import-Deklarationen verwendet werden, die die jeweiligen Paketnamen nennen. Pakete ermöglichen keinen privilegierten Zugriff auf Klassen ihrer Subpakete.'},
     {'question': 'Wie werden Zeichenliterale und String-Literale in Java dargestellt?', 'answer': 'Zeichenliterale werden in Java durch einfache Anführungsstriche eingeschlossen, während String-Literale durch doppelte Anführungsstriche eingeschlossen werden.'},
     {'question': 'Wie gibt man in Java den Typ einer Klasse als Wert an?', 'answer': 'In Java gibt man den Typ einer Klasse als Wert mittels eines sogenannten Klassenliterals an. Dieses besteht aus dem Namen der Klasse, gefolgt von ".class", z. B. "Klasse.class".'},
     {'question': 'Wie werden abstrakte Methoden in Java deklariert, und wie werden sie in Subklassen implementiert?', 'answer': 'Abstrakte Methoden in Java werden deklariert, indem man hinter der Methodensignatur ein abschließendes Semikolon setzt, anstatt eine Implementierung anzugeben. In Subklassen müssen abstrakte Methoden mit Implementierungen versehen werden, andernfalls gibt der Compiler eine Fehlermeldung aus.'},
     {'question': 'Wie kann in Java verhindert werden, dass von einer Klasse abgeleitet wird?', 'answer': 'In Java kann verhindert werden, dass von einer Klasse abgeleitet wird, indem man das Schlüsselwort "final" vor der Klassendefinition verwendet.'},
     {'question': 'Wie gibt eine Klasse an, dass sie ein Interface implementiert, und welche Verpflichtung ergibt sich daraus?', 'answer': 'Eine Klasse gibt an, dass sie ein Interface implementiert, indem sie das Schlüsselwort "implements" verwendet, gefolgt vom Namen des Interfaces. Die Klasse verpflichtet sich, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten.'},
     {'question': 'Wie können Interfaces in Variablendeklarationen verwendet werden?', 'answer': 'Interfaces können in Variablendeklarationen als Typen verwendet werden. Der Type Checker garantiert dann, dass auf der Variable nur die Methoden aufgerufen werden können, die im Interface deklariert sind, selbst wenn das Objekt, das die Variable referenziert, mehr Methoden anbietet.'},
     {'question': 'Wie werden Konstruktoren in Java aufgerufen?', 'answer': 'In Java werden Konstruktoren aufgerufen, indem der Klassenname gefolgt von den Konstruktorargumenten verwendet wird, z.B., "new MeineKlasse(argumente)".'},
     {'question': 'Wie unterscheiden sich Streams von Collections in Java?', 'answer': 'Streams unterscheiden sich von Collections in Java dadurch, dass sie keine Datenspeicher sind, sondern interne Iteratoren. Jeder Stream hält zu einem Zeitpunkt immer genau ein Element einer potenziell unendlichen Folge von Elementen.'},
     {'question': 'Wann liefert eine Stream-Pipeline in Java ein Ergebnis?', 'answer': 'Eine Stream-Pipeline in Java liefert ein Ergebnis immer erst durch einen sogenannten Abschluss, also eine Methode wie reduce oder collect, die ein anderes Ergebnis als einen Stream liefert, beispielsweise eine Collection im Falle von collect.'},
     {'question': 'Wie werden parametrische (generische) Typen in Java definiert?', 'answer': 'Parametrische (generische) Typen in Java werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Die formalen Typparameter in der Klassendefinition können durch verschiedene Typen ersetzt werden.'},
     {'question': 'Wie können Typ-Wildcards in Java zur Verbesserung der Typsicherheit verwendet werden?', 'answer': 'Typ-Wildcards können verwendet werden, um sicherzustellen, dass Zuweisungen und Zugriffe auf generische Typen zur Übersetzungszeit statisch typsicher sind, ohne dass es zu Laufzeitfehlern kommt. Dies erhöht die Typsicherheit von Java-Programmen.'},
     {'question': 'Wie können Typ-Wildcards in Java dazu verwendet werden, eine Liste von Zahlen oder Untertypen von "Number" zu verarbeiten?', 'answer': 'Typ-Wildcards können verwendet werden, um eine Methode wie "sum(List<? extends Number> list)" zu erstellen, die eine Liste von Zahlen oder Untertypen von "Number" akzeptiert und die Summe der Zahlen berechnet, unabhängig von ihrem konkreten Typ.'},
     {'question': 'Wie werden Typvariablen in Java generischen Typen dargestellt?', 'answer': 'In Java werden Typvariablen in generischen Typen in spitzen Klammern dargestellt.'},
     {'question': 'Wie sieht eine einfache Klassendefinition in Java aus?', 'answer': 'Eine einfache Klassendefinition in Java besteht aus dem Klassennamen, der Angabe von Instanzvariablen (Felder) und Instanzmethoden.'},
     {'question': 'Wann werden "final"-Variablen in Java verwendet?', 'answer': '"final"-Variablen werden in Java verwendet, um Konstanten zu deklarieren. Sie dürfen nur einmal einen Wert zugewiesen bekommen und sind dann nicht mehr änderbar.'},
     {'question': 'Wie werden Ausdrücke in Java aufgebaut, und welche rekursiven Elemente sind dabei beteiligt?', 'answer': 'Ausdrücke in Java können rekursiv aus anderen Ausdrücken aufgebaut werden. Zum Beispiel enthalten Methodenausdrücke Ausdrücke für den Empfänger und die Parameter des Methodenaufrufs. Array-Zugriffe und -Instanziierungen beinhalten Ausdrücke zur Bestimmung von Indexen oder Größen.'},
     {'question': 'Wann werden Type casts in Java verwendet?', 'answer': 'Type casts werden in Java verwendet, wenn man einem Programmelement, das einen bestimmten Typ hat, einen anderen Typ zuweisen möchte oder wenn man auf Methoden oder Felder zugreifen möchte, die nicht im deklarierten Typ verfügbar sind.'},
     {'question': 'Wie vermeidet man Laufzeitfehler bei Typumwandlungen in Java?', 'answer': 'Man vermeidet Laufzeitfehler bei Typumwandlungen in Java mithilfe von Typtests, die vor der Typumwandlung durchgeführt werden.'},
     {'question': 'Wie können Ausdrücke zu Anweisungen in Java gemacht werden?', 'answer': 'In Java können Ausdrücke zu Anweisungen gemacht werden, indem sie einfach durch ein Semikolon abgeschlossen werden. Dies gilt insbesondere für Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen.'},
     {'question': 'Wie werden Werte Variablen in Java zugewiesen?', 'answer': 'In Java werden Werte Variablen sowohl explizit per Zuweisungsoperator "=" als auch implizit per Methodenaufruf zugewiesen.'},
     {'question': 'Wie wird beschränkter parametrischer Polymorphismus in Java implementiert?', 'answer': 'In Java wird beschränkter parametrischer Polymorphismus durch das Hinzufügen von Beschränkungen für den Typparameter einer generischen Klasse oder Methode erreicht. Dies geschieht durch die Verwendung des "extends" oder "super" Schlüsselworts gefolgt von einem bestimmten Typ oder einer bestimmten Schnittstelle.'},
     {'question': 'Wie wird in Java zwischen Gleichheit und Identität von Objekten unterschieden?', 'answer': 'In Java wird zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) geprüft, während die Identität mittels == (bzw. !=) überprüft wird.'},
     {'question': 'Wie startet man einen neuen Thread in Java?', 'answer': 'Einen neuen Thread in Java startet man, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.'},
     {'question': 'Wie stellt man sicher, dass ein neuer Thread in Java sinnvolle Aufgaben ausführt?', 'answer': 'Es gibt zwei Möglichkeiten, sicherzustellen, dass ein neuer Thread in Java sinnvolle Aufgaben ausführt. Entweder man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen, oder man lässt eine Klasse das Interface Runnable implementieren und implementiert die Methode run() in dieser Klasse. Dann erzeugt man eine Instanz dieser Klasse und startet deren Methode run().'},
     {'question': 'Wie kann die Synchronisation von Threads in Java erzwungen werden?', 'answer': 'Die Synchronisation von Threads in Java kann auf zwei Arten erzwungen werden. Die erste Möglichkeit ist die Verwendung der synchronized-Anweisung, um einen synchronisierten Block zu erstellen. Die Anweisungen innerhalb dieses Blocks können nur von einem Thread gleichzeitig ausgeführt werden. Die zweite Möglichkeit besteht darin, eine gesamte Methode mit synchronized zu deklarieren, wodurch die Sperre auf das zugehörige Objekt angewendet wird. Es ist wichtig zu beachten, dass Felder nicht als synchronized deklariert werden können.'},
     {'question': 'Wie erfolgt die Deklaration von Arrays in Java?', 'answer': 'Die Deklaration von Arrays in Java erfolgt implizit in Variablendeklarationen, wobei die Größe des Arrays nicht in der Deklaration festgelegt wird.'},
     {'question': 'Wie können Arrays in Java initialisiert werden?', 'answer': 'Arrays können in Java bei ihrer Deklaration initialisiert werden. Dabei wird die Größe des Arrays automatisch festgelegt.'},
     {'question': 'Wie funktioniert die Zuweisung von Array-Variablen in Java?', 'answer': 'In Java haben Array-Variablen Referenzsemantik, und bei der Zuweisung wird lediglich ein Verweis auf das Array übergeben. Die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[] ist zulässig.'},
     {'question': 'Wie werden parametrische Typen definiert?', 'answer': 'Parametrische Typen werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Die Instanziierung einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter führt nur zu einem neuen Typ, aber nicht zu einer neuen Klasse.'},
     {'question': 'Wie werden Zusicherungen in EIFFEL behandelt?', 'answer': 'In EIFFEL werden Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen integriert. Das bedeutet, dass die Zusicherungen an bestimmten Stellen in der Sprache vorgesehen sind und nicht willkürlich platziert werden können.'},
     {'question': 'Wie ist die Typenhierarchie in C-Sharp aufgebaut?', 'answer': 'In C-Sharp sind alle Variablen typisiert. Anders als in Java wird zunächst nicht zwischen Wert- (primitiven) und Referenztypen unterschieden: Alle Typen, auch die primitiven, gelten als von Object (genauer: System.Object) abgeleitet.'},
     {'question': 'Wie ist die Typhierarchie von C-Sharp definiert?', 'answer': 'Die Typhierarchie von C-Sharp ist Teil des Common Type Systems (CTS) von .NET und ist für alle .NET-Sprachen dieselbe. Sie ermöglicht es, Typen, die in einer Sprache definiert wurden, in einer anderen Sprache zu verwenden, als wären sie in der anderen Sprache selbst definiert worden.'},
     {'question': 'Wie können Typen in C-Sharp eingeteilt werden?', 'answer': 'In C-Sharp gibt es eine grobe Einteilung der Typen in Werttypen und Referenztypen, wobei zu den Referenztypen Klassen, Interfaces, Arrays, Delegates und Attribut-Typen gehören.'},
     {'question': 'Wie sind alle Arten von Typen in C-Sharp integriert?', 'answer': 'Alle Arten von Typen sind in C-Sharp integriert, was daran zu erkennen ist, dass einige Arten von Typen durch spezielle Klassen (Array, Delegate, Attribute) vertreten sind. Klassen, außer System.Object, haben genau eine Superklasse und können beliebig viele Interfaces implementieren. Die Tatsache, dass Werttypen als Subtypen eines Referenztyps (nämlich Object) deklariert sind, verrät außerdem, dass C-Sharp über Auto-Boxing und Unboxing verfügt.'},
     {'question': 'Wann ist die Verwendung von Runtime Type Information (RTTI) in C++ sinnvoll?', 'answer': 'Die Verwendung von RTTI in C++ ist sinnvoll, wenn die Klasse eines Objekts zur Laufzeit bestimmt werden muss, um beispielsweise eine geeignete Methode für die Ausführung auszuwählen.'},
     {'question': 'Wie kann man die Zuweisungskompatibilität zwischen "ArrayList<Integer>" und "ArrayList<Comparable<Integer>>" herstellen?', 'answer': 'Die Zuweisungskompatibilität zwischen "ArrayList<Integer>" und "ArrayList<Comparable<Integer>>" kann durch die Verwendung des Upper-Bounded Wildcards hergestellt werden. Dazu wird der generische Typ mit einem Fragezeichen und dem Upper-Bound (in diesem Fall "Comparable<Integer>") angegeben, was bedeutet, dass der generische Typ jede Klasse sein kann, die ein Subtyp von "Comparable<Integer>" ist. Somit ist "Integer" ein Subtyp von "Comparable<Integer>" und die Zuweisungskompatibilität wird hergestellt.'},
     {'question': 'Wie hängen die Subtyp-Beziehungen von generischen Typen mit Typ-Wildcards zusammen?', 'answer': 'Für mit "extends" nach oben beschränkte Wildcard-Typen gilt, dass sie Subtypen sind, wenn die Schranken Subtypen sind. Wenn also "Integer" ein Subtyp von "Number" ist, dann ist auch "List<? extends Integer>" ein Subtyp von "List<? extends Number>". Umgekehrt gilt für mit "super" nach unten beschränkte Typen, dass "List<? super Integer>" ein Supertyp von "List<? super Number>" ist. Man sagt auch, das Subtyping mit "extends" beschränkter Wildcard-Typen sei kovariant und das mit "super" beschränkter Wildcard-Typen kontravariant.'},
     {'question': 'Wie werden auf Attribute in EIFFEL zugegriffen?', 'answer': 'In EIFFEL werden auf Attribute über Zugriffsmethoden zugegriffen, die syntaktisch wie Variablen aussehen. Um das Attribut a eines Objekts x zu ändern, wird ein Zuweisungsausdruck verwendet: x.a := b.'},
     {'question': 'Wie können in Eiffel auf Instanzvariablen zugegriffen werden?', 'answer': 'In Eiffel können auf Instanzvariablen, die als Attribute bezeichnet werden, nur über Zugriffsmethoden zugegriffen werden. Diese Zugriffsmethoden nehmen syntaktisch die Form von Variablen an, werden jedoch vom System automatisch bereitgestellt.'},
     {'question': 'Wie ist die Zugriffsmodellierung in EIFFEL?', 'answer': 'In EIFFEL gibt es keine Zugriffsmodifikatoren wie in Java/C-Sharp/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt. Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.'},
     {'question': 'Wie ist die Zugriffsebene von Features in EIFFEL festgelegt?', 'answer': 'In EIFFEL gibt es keine Zugriffsmodifikatoren wie in Java/C-Sharp/C++. Wenn nichts weiter vermerkt wird, sind alle Features öffentlich zugänglich. Da Attribute jedoch nur über Zugriffsmethoden zugänglich sind, ist der Zustand eines Objekts automatisch gekapselt. Zugriffsmethoden müssen in EIFFEL nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.'},
     {'question': 'Wie wird der Zustand eines Objekts in EIFFEL gekapselt?', 'answer': 'In EIFFEL wird der Zustand eines Objekts automatisch gekapselt, indem Attribute nur über Zugriffsmethoden zugänglich sind. Diese Zugriffsmethoden müssen nicht spezifiziert werden, es sei denn, die entsprechenden Abfragen und Befehle sind Teil der Schnittstelle und kein Geheimnis.'},
     {'question': 'Wie wird die Sichtbarkeit von Features in EIFFEL geregelt?', 'answer': 'In EIFFEL wird die Sichtbarkeit von Features durch den dedizierten Export geregelt, bei dem die Klassen genannt werden, die auf die Features zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was privat in anderen Sprachen entspricht.'},
     {'question': 'Wie werden Features in EIFFEL exportiert?', 'answer': 'In EIFFEL können Features gezielt exportiert werden, indem die Klassen genannt werden, die darauf zugreifen können sollen. Dies schließt auch die Möglichkeit ein, dass keine andere Klasse diese Features sehen kann, was private in anderen Sprachen entspricht. Diese Klassen müssen die angebotenen Features nicht explizit importieren.'},
     {'question': 'Wie wird eine Methode in C-Sharp überschrieben?', 'answer': 'In C-Sharp muss eine Methode, die überschrieben werden soll, mit dem Schlüsselwort "virtual" deklariert werden. Die überschreibende Methode muss mit dem Schlüsselwort "override" deklariert werden.'},
     {'question': 'Wie unterscheidet sich C-Sharp von Java in Bezug auf Schlüsselwörter und Kontrollflussanweisungen?', 'answer': 'In C-Sharp werden einige Sprachkonstrukte mit anderen Schlüsselwörtern als in Java verwendet, wie zum Beispiel "lock" anstatt "synchronized" und "foreach" anstatt "for" für die zweite Form von "For"-Schleifen. Zudem sind in C-Sharp auch "Strings" als Basis einer "Switch"-Anweisung zugelassen und jeder Zweig muss mit einer expliziten Kontrollflussanweisung abgeschlossen werden. Im Gegensatz zu Java verfügt C-Sharp über eine "Goto"-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. Diese Unterschiede haben jedoch nichts mit Objektorientierung zu tun.'},
     {'question': 'Wie werden Typvariablen in Java bezeichnet?', 'answer': 'In Java werden Typvariablen in generischen Typen in spitzen Klammern bezeichnet.'},
     {'question': 'Wie würden Sie die Programmiersprache Java beschreiben?', 'answer': 'Java ist eine Programmiersprache, die eine Mischung aus SMALLTALK und C++ ist. Es übernahm weite Teile der Syntax und der statischen Typüberprüfung von C++ sowie den eher klassisch prozeduralen Charakter. Andererseits übernahm es die umfassende Objektorientierung, die Einfachvererbung und die Garbage Collection von SMALLTALK.'},
     {'question': 'Wie können anonyme Funktionen oder Blöcke in Java erstellt werden?', 'answer': 'In Java können anonyme Funktionen oder Blöcke über vordefinierte Interfaces erstellt werden.'},
     {'question': 'Wie unterscheiden sich Java-Ausdrücke und SMALLTALK-Ausdrücke?', 'answer': 'Es gibt einige Unterschiede zwischen Java-Ausdrücken und SMALLTALK-Ausdrücken, darunter die Verwendung von direkten Feldzugriffen in Java (a.x) und das Fehlen von indizierten Instanzvariablen in SMALLTALK. Außerdem unterscheidet Java zwischen Operatoranwendungen (+, -, etc.), Methodenaufrufen, Konstruktoraufrufen und Arrayzugriffen, während in SMALLTALK nur Methodenaufrufe existieren.'},
     {'question': 'Wie wird das klassische Beispiel zur Motivation kovarianter Redefinition und verankerter Typen beschrieben?', 'answer': 'Das klassische Beispiel zur Motivation kovarianter Redefinition und verankerter Typen beinhaltet eine Klasse KUNSTWERK, die Informationen über ein Kunstwerk verwaltet. Es gibt zwei Unterklassen, BILD und SKULPTUR, die spezifische Informationen über Gemälde und Skulpturen verwalten. BILD hat eine Instanzvariable HÖHE, die die Höhe des Gemäldes in cm speichert, während SKULPTUR eine Instanzvariable GEWICHT hat, die das Gewicht der Skulptur in kg speichert.'},
     {'question': 'Wann können Down und Cross casts in Java zu Laufzeittypfehlern führen?', 'answer': 'Down und Cross casts können zu Laufzeittypfehlern führen, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, nicht den Zieltyp oder einen Subtyp davon hat.'},
     {'question': 'Wann ist ein Up cast in Java sicher?', 'answer': 'Ein Up cast in Java ist immer sicher, da jedes Objekt neben seinem Typ zugleich auch den Typ all seiner Supertypen hat. Der Up cast kann daher weggelassen werden.'},
     {'question': 'Wann sind Down und Cross casts in Java erfolgreich?', 'answer': 'Down und Cross casts sind in Java nur erfolgreich, wenn das Objekt, zu dem der typumgewandelte Ausdruck auswertet, tatsächlich den Zieltyp (oder einen Subtyp davon) hat. Dies kann jedoch zur Übersetzungszeit nicht garantiert werden und kann daher zu Laufzeittypfehlern (der in Java sogenannten ClassCastException) führen.'},
     {'question': 'Wie wird das Semikolon in EIFFEL verwendet?', 'answer': 'Im Gegensatz zu anderen Programmiersprachen dient das Semikolon in EIFFEL nicht als Ende einer Anweisung, sondern als Trennzeichen zwischen Anweisungen. Es kann am Ende einer Zeile weggelassen werden.'},
     {'question': 'Wie werden Properties in C-Sharp verwendet?', 'answer': 'Properties werden verwendet, um (lesend und schreibend) Feldzugriffe zu ermöglichen, die wie Feldzugriffe aussehen, aber mit zusätzlichen Funktionalitäten. Sie können auch verwendet werden, um Felder mit Nur-Lese- oder Nur-Schreib-Zugriff zu simulieren.'},
     {'question': 'Wie ist die Zuweisungskompatibilität in EIFFEL gebunden?', 'answer': 'Die Zuweisungskompatibilität ist in EIFFEL an nominale Typkonformität gebunden, die wiederum mit der Typerweiterung (in EIFFEL einfach Vererbung genannt) einhergeht, ganz wie in Java.'},
     {'question': 'Wie werden Methoden in EIFFEL aufgerufen?', 'answer': 'In EIFFEL werden Methoden mit eckigen Klammern und einem Pfeil (->) aufgerufen.'},
     {'question': 'Wie werden in EIFFEL Vererbungsbeziehungen ausgedrückt?', 'answer': 'In EIFFEL werden Vererbungsbeziehungen durch eckige Klammern und einem Pfeil (->) anstelle von spitzen Klammern und extends in Java ausgedrückt.'},
     {'question': 'Wie wird in EIFFEL die Unterscheidung zwischen Wert- und Referenztypen einer Klasse umgesetzt?', 'answer': 'In EIFFEL wird die Unterscheidung zwischen Wert- und Referenztypen einer Klasse durch den Typkonstruktor expanded umgesetzt. Dieser gibt einer einzelnen Variable Wertsemantik und in Klassendefinitionen allen Variablen des entsprechenden Typs automatisch Wertsemantik. Diese Unterscheidung hat in EIFFEL einen starken konzeptuellen Hintergrund, da sie die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen.'},
     {'question': 'Wie kann das Problem der Kovarianz in EIFFEL gelöst werden?', 'answer': 'Eine Lösung für das Problem der Kovarianz kann sein, die Typkonformitätsregeln von EIFFEL zu ändern, um die Kovarianz zu ermöglichen.'},
     {'question': 'Wie wirkt sich das Typsystem von EIFFEL in der Praxis aus?', 'answer': 'Der Autor des Textes ist nicht sicher, wie sich das Typsystem von EIFFEL in der Praxis auswirkt, da er keine praktischen Erfahrungen damit hat. Er weist jedoch darauf hin, dass der Schöpfer von EIFFEL, Bertrand Meyer, behauptet, dass die damit verbundenen Probleme praktisch keine Rolle spielen. Der Autor fügt hinzu, dass falls doch, die durchschnittliche Programmiererin kaum verstehen wird, was das Problem ist und was sie tun kann, um es zu umgehen.'},
     {'question': 'Wie äußert sich die Abhängigkeit zwischen Klassen in Java?', 'answer': 'Die Abhängigkeit zwischen Klassen in Java manifestiert sich in zwei verschiedenen Formen: Zum einen, wenn eine Klasse auf Objekte einer anderen Klasse zugreift, was sich durch die Deklaration von Variablen des entsprechenden Typs und gegebenenfalls durch das Importieren der Klasse oder des Pakets zeigt. Zum anderen, wenn eine Klasse einige ihrer Member anderen zur Benutzung anbietet, was sich durch die Verwendung von Zugriffsmodifikatoren, die nicht private sind, sowie an der Implementierung von Interfaces zeigt.'},
     {'question': 'Wie vermeidet man in Java Laufzeitfehler durch Typumwandlung?', 'answer': 'In Java vermeidet man Laufzeitfehler durch Typumwandlung mithilfe von Typtests, die man mit dem Schlüsselwort instanceof durchführt.'},
     {'question': 'Wie werden Ausdrücke in Java zu Anweisungen?', 'answer': 'In Java können bestimmte Ausdrücke zu Anweisungen gemacht werden, indem sie durch ein Semikolon abgeschlossen werden. Dazu gehören Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen.'},
     {'question': 'Wie werden Variablen in Java Werte zugewiesen?', 'answer': 'In Java werden Variablen Werte explizit per Zuweisungsoperator "=" und implizit per Methodenaufruf zugewiesen. Der Inhalt von Variablen primitiver Typen ist ein entsprechender Wert, während Variablen anderer Typen immer eine Referenz auf ein Objekt halten.'},
     {'question': 'Wie funktioniert die Parameterübergabe in Java?', 'answer': 'In Java gibt es nur "Call by value", d.h. bei Methodenaufrufen werden immer Kopien der Werte an die formalen Parameter übergeben. Selbst wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben, werden bei Methodenaufrufen immer Kopien der Zeiger übergeben.'},
     {'question': 'Wie werden Parameter in Java übergeben?', 'answer': 'In Java werden Parameter immer durch Wertübertragung übergeben, auch wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben. Bei den impliziten Zuweisungen eines Methodenaufrufs wird immer eine Kopie des Zeigers an die formalen Parameter übergeben.'},
     {'question': 'Wie viele Arten von Typen werden in Java unterschieden?', 'answer': 'In Java werden sechs Arten von Typen unterschieden: primitive Typen, Klassentypen, Interfacetypen, Array-Typen, Aufzählungstypen und Annotationstypen.'},
     {'question': 'Wie unterscheidet sich das Typsystem von C-Sharp von dem von Java?', 'answer': 'Das Typsystem von C-Sharp unterscheidet sich von dem von Java in der Art der Unterscheidung von Wert- und Referenztypen, den angebotenen Typkonstruktoren für Wert- und Referenztypen und dem Umgang mit Interfaces als Typen.'},
     {'question': 'Wann wird in C-Sharp die Unterscheidung von Wert- und Referenztypen getroffen?', 'answer': 'In C-Sharp wird die Unterscheidung von Wert- und Referenztypen dynamisch zur Laufzeit getroffen.'},
     {'question': 'Wie werden Interfaces in C-Sharp verwendet?', 'answer': 'In C-Sharp können Interfaces als Typen verwendet werden, das heißt, dass eine Variable einen Interface-Typ haben kann.'},
     {'question': 'Wie wird die Gleichheit von Objekten in Java geprüft?', 'answer': 'Die Gleichheit von Objekten wird in Java mittels der Methode equals(.) geprüft.'},
     {'question': 'Wie unterscheidet man in Java zwischen Gleichheit und Identität von Objekten?', 'answer': 'In Java wird zwischen Gleichheit und Identität von Objekten unterschieden. Die Gleichheit von Objekten wird mittels der Methode equals(.) geprüft, die Identität mittels == (bzw. != für das Negativ). equals(.) wird von der Klasse Object geerbt und sollte in den Subklassen entsprechend der jeweiligen Bedeutung von Gleichheit überschrieben werden. Das Gleichheitszeichen = steht in Java für die Wertzuweisung.'},
     {'question': 'Wie wird Mehrfachvererbung in C++ emuliert?', 'answer': 'In C++ wird Mehrfachvererbung durch rein abstrakte Klassen emuliert, da C++ keine Interfaces wie Java oder C-Sharp kennt.'},
     {'question': 'Wie werden Methoden in C++ gebunden?', 'answer': 'In C++ werden Methoden standardmäßig statisch gebunden, das bedeutet, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ eines Objekts wird also ignoriert, es sei denn, die betreffende Methode wurde mit virtual deklariert.'},
     {'question': 'Wie wird bei einer virtuellen Methode die richtige Implementierung ermittelt?', 'answer': 'Zur Ermittlung der richtigen Implementierung wird eine sog. Virtual function table verwendet, in der die zum Objekt passende Implementierung nachgeschlagen werden kann. Diese Indirektion gilt jedoch als teuer und sollte daher nur verwendet werden, wenn unbedingt notwendig.'},
     {'question': 'Wie wird Generizität in C++ erreicht?', 'answer': 'In C++ wird Generizität mithilfe von Templates erreicht. Templates sind Muster, anhand derer neue, parameterlose Klassen erzeugt werden können. Im Gegensatz zu Java werden aus Templates tatsächlich neue Klassen erzeugt, die kompiliert werden. Man kann sich den Mechanismus wie eine Textverarbeitung vorstellen, die das Template kopiert, alle Vorkommen der Typparameter darin durch tatsächliche Typen ersetzt, das ganze dann mit einem neuen Namen versieht und kompiliert. Tatsächlich wird die Generizität in C++ als ein Makro-Mechanismus angesehen, der vom Präprozessor umgesetzt wird.'},
     {'question': 'Wie werden parallele Ausführungsstränge in Java bezeichnet?', 'answer': 'In Java werden parallele Ausführungsstränge als Threads bezeichnet.'},
     {'question': 'Wie wird in Java ein neuer Thread gestartet?', 'answer': 'In Java wird ein neuer Thread gestartet, indem man eine neue Instanz der Klasse Thread erzeugt und auf dieser Instanz die Methode start() aufruft.'},
     {'question': 'Wie kann man sicherstellen, dass ein neuer Thread sinnvolle Aufgaben ausführt?', 'answer': 'Es gibt zwei Möglichkeiten: Man definiert eine neue Subklasse von Thread und überschreibt darin die Methode run(), um die gewünschten Aufgaben auszuführen oder zumindest anzustoßen. Man lässt eine Klasse das Interface Runnable implementieren, implementiert dann in der Klasse die vom Interface geforderte Methode run(), erzeugt eine Instanz dieser Klasse und startet deren Methode run() mit (new Thread(i)).start(), wobei i die Instanz darstellt.'},
     {'question': 'Wie wird die Synchronisation von Threads in Java erreicht?', 'answer': 'Die Synchronisation von Threads in Java erfolgt mit Monitoren, die mit Objekten verknüpft sind. Wenn ein Thread einen Monitor eines Objekts sperrt, kann kein anderer Thread denselben Monitor sperren, bis die Sperre durch den ersten Thread aufgehoben wird.'},
     {'question': 'Wie kann die Synchronisation von Threads erzwungen werden?', 'answer': 'Die Synchronisation von Threads kann durch die Verwendung der synchronized-Anweisung erzwungen werden. Die Anweisungen innerhalb eines synchronisierten Blocks können nur ausgeführt werden, wenn sie nicht gleichzeitig von einem anderen Thread ausgeführt werden. Das mit dem Block assoziierte Objekt, auf dessen Monitor die Sperre angewendet wird, muss in der synchronized-Anweisung angegeben werden.'},
     {'question': 'Wie kann eine Methode in Java synchronisiert werden?', 'answer': 'Eine Methode kann in Java synchronisiert werden, indem sie mit dem Schlüsselwort "synchronized" deklariert wird. Es gibt zwei Möglichkeiten, eine Methode zu synchronisieren: entweder durch die Synchronisierung der gesamten Methode oder durch die Synchronisierung eines bestimmten Blocks innerhalb der Methode. Wenn es sich um eine Instanzmethode handelt, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird. Wenn es sich um eine Klassenmethode handelt, wird die Sperre auf das Objekt angewendet, das die Klasse repräsentiert. Felder können jedoch nicht als synchronized deklariert werden.'},
     {'question': 'Wie kann man in C-Sharp einen Ausdruck einer Typumwandlung unterziehen?', 'answer': 'In C-Sharp kann man einen Ausdruck einer Typumwandlung unterziehen, indem man Casts verwendet, genau wie in Java und C++. Die Syntax unterscheidet sich nicht.'},
     {'question': 'Wie kann man in C++ die statische Typisierung umgehen?', 'answer': 'In C++ kann man die statische Typisierung mit'},
     {'question': 'Wie wird die Größe eines Arrays in Java festgelegt?', 'answer': 'Die Größe eines Arrays in Java wird nicht in der Deklaration festgelegt, sondern erst bei der Initialisierung.'},
     {'question': 'Wie können Arrays in Java initialisiert werden?', 'answer': 'In Java können Arrays bei ihrer Deklaration initialisiert werden, indem man ihnen Werte zuweist. Die Größe des Arrays wird dabei automatisch festgelegt. Die Elemente des Arrays müssen nicht selbst Literale sein, sondern dürfen auch andere Ausdrücke sein.'},
     {'question': 'Wie ist die Initialisierung von Elementen in Java-Arrays?', 'answer': 'Alle Elemente des Arrays enthalten nach der Initialisierung den Wert null (Javas Äquivalent von SMALLTALKs nil).'},
     {'question': 'Wie ist die Nummerierung der Indizes in Java-Arrays?', 'answer': 'Java-Arrays sind 0-basiert, was soviel heißt wie dass das erste Element den Index 0 hat. (Zur Erinnerung: In SMALLTALK hat es den Index 1.)'},
     {'question': 'Wie können Array-Initialisierer in Java sein?', 'answer': 'Array-Initialisierer können in Java auch geschachtelt werden und somit mehrere Dimensionen umfassen.'},
     {'question': 'Wie werden mehrdimensionale Arrays in Java deklariert?', 'answer': 'Mehrdimensionale Arrays in Java werden als Arrays von Arrays deklariert.'},
     {'question': 'Wie verhält sich die Zuweisungskompatibilität von Array-Variablen in Java?', 'answer': 'In Java haben Array-Variablen immer Referenzsemantik. Eine Zuweisung von f an eine Variable vom Typ Object ist zulässig, während eine Zuweisung von f an eine Variable vom Typ Object[] nicht zulässig ist. Dies liegt daran, dass float[] kein Subtyp von Object[] ist.'}],
    [{'question': 'Gibt es in C++ Metaklassen?', 'answer': 'Nein, in C++ gibt es keine Metaklassen.'},
     {'question': 'Wie unterscheiden sich Properties in C-Sharp von Zugriffsmethoden (Settern und Gettern)?', 'answer': 'Properties in C-Sharp sind eine Möglichkeit, auf die Felder eines Objekts zuzugreifen, indem Methoden aufgerufen werden, die wie Feldzugriffe aussehen. Sie sind die Umkehrung von Zugriffsmethoden (Settern und Gettern) und ermöglichen es, Feldzugriffe mit Nebeneffekten zu versehen. In C-Sharp werden die Schlüsselwörter "get" und "set" verwendet, wobei "get" für den Lesezugriff und "set" für den Schreibzugriff verwendet wird. Die Variable "value" wird verwendet, um den Eingabewert eines Setters zu halten.'},
     {'question': 'Unterstützt C++ Objektorientierung?', 'answer': 'Ja, C++ unterstützt Objektorientierung, indem es neben den aus C übernommenen Strukturen (structs) auch Klassen anbietet. Diese beinhalten, genau wie in SMALLTALK und Java, neben Feldern (Instanzvariablen) auch Methoden. Klassenfelder und -methoden werden mit dem Schlüsselwort static in einer Klasse eingeführt. Metaklassen gibt es in C++ nicht; gleichwohl kann der Name einer Klasse als Wert verwendet werden.'},
     {'question': 'Was ist der Unterschied zwischen Objekten in SMALLTALK und Objekten in C++?', 'answer': 'In SMALLTALK haben Objekte Identität, während in C++ Objekte Werte sind, die keine Identität haben. Bei Zuweisungen an andere Variablen werden in SMALLTALK Referenzen angefertigt, während in C++ Kopien erstellt werden.'},
     {'question': 'Was ist der Unterschied zwischen Referenz- und Wertsemantik?', 'answer': 'Bei der Referenzsemantik wird auf ein Objekt verwiesen, während bei der Wertsemantik eine Kopie des Objekts erstellt wird. In C++ und Java haben Variablen mit einer Klasse als Typ Wertsemantik, während in SMALLTALK Variablen mit Referenzsemantik arbeiten.'},
     {'question': 'Was ist der Unterschied zwischen Objekten mit Wertsemantik und Objekten mit Referenzsemantik?', 'answer': 'Objekte mit Wertsemantik werden bei Zuweisungen an andere Variablen kopiert, während Objekte mit Referenzsemantik nur einen Verweis auf das Objekt kopieren. Objekte mit Wertsemantik haben keine Identität, während Objekte mit Referenzsemantik eine Identität haben.'},
     {'question': 'Was ist der Unterschied zwischen "Call by value" und der Übertragung von Pointer-Variablen in C++?', 'answer': 'Im "Call by value" in C++ wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen. Bei Pointer-Variablen wie dem obigen a wird jedoch nur der Zeiger auf das Objekt übergeben, was dem Verhalten von Java und SMALLTALK entspricht. In Java und SMALLTALK wird jedoch nirgends explizit angegeben, dass es sich um eine Pointer-variable handelt.'},
     {'question': 'Was passiert bei Methodenaufrufen mit Pointer-Variablen in C++?', 'answer': 'Bei Methodenaufrufen mit Pointer-Variablen in C++ wird nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben. Dies entspricht dem Verhalten von Java und SMALLTALK, wobei bei beiden nirgends explizit angegeben wird, dass es sich um eine Pointer-Variable handelt.'},
     {'question': 'Was bedeutet "Call by value" in C++?', 'answer': 'Bei "Call by value" in C++ wird eine Kopie des Inhalts des tatsächlichen Parameters dem formalen Parameter zugewiesen.'},
     {'question': 'Was passiert bei "Call by value" in C++, wenn Pointer-Variablen übergeben werden?', 'answer': 'Wenn Pointer-Variablen wie dem obigen a übergeben werden, wird nicht das Objekt, sondern nur der Zeiger auf das Objekt übergeben.'},
     {'question': 'Was ist der Unterschied zwischen "Call by value" und "Call by reference"?', 'answer': '"Call by value" bedeutet, dass eine Kopie des Inhalts der Variablen an die Funktion übergeben wird, während "Call by reference" bedeutet, dass an die Funktion ein Zeiger auf die Speicherstelle der Variablen übergeben wird. In C++ kann man "Call by reference" auch mit Zeigern auf Zeiger implementieren, oder aber wie in PASCAL, indem man die formalen Parameter so deklariert, dass sie Zeiger aufnehmen können und an der Aufrufstelle kein Zeigeroperator & verwendet wird.'},
     {'question': 'Was ist der Unterschied zwischen "Call by reference" und der Übergabe von Zeigern in C++?', 'answer': '"Call by reference" ist eine Technik, bei der anstelle einer Kopie des Inhalts der Variablen ein Zeiger auf die Speicherstelle der Variablen übergeben wird. In C++ kann dies durch die Verwendung des Zeigeroperators & an der Aufrufstelle erreicht werden, wobei die formalen Parameter so deklariert werden müssen, dass sie Zeiger auf Zeiger aufnehmen können. Alternativ kann in C++ wie in PASCAL verfahren werden, wobei die Aufrufstelle unverändert bleibt (also ohne & auskommt). Der Unterschied besteht darin, dass bei "Call by reference" die Aufrufstelle geändert werden muss, während bei der Übergabe von Zeigern in C++ die Aufrufstelle unverändert bleibt.'},
     {'question': 'Was ist der Unterschied zwischen "Call by reference" und der Möglichkeit in C++ wie in PASCAL zu verfahren?', 'answer': '"Call by reference" in C++ erfordert die Verwendung des Zeigeroperators & an der Aufrufstelle, um einen Zeiger auf die Speicherstelle der Variablen zu erzeugen und zu übergeben. Dagegen erfordert die Möglichkeit in C++ wie in PASCAL zu verfahren, dass keine Änderungen an der Aufrufstelle vorgenommen werden müssen, da die formalen Parameter so deklariert werden, dass sie Zeiger auf Zeiger aufnehmen können.'},
     {'question': 'Unterstützt C-Sharp generische Programmierung?', 'answer': 'Ja, C-Sharp unterstützt ab Version 2.0 generische Programmierung sowohl bei Klassen als auch bei Methoden. Es erlaubt sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus. C-Sharp erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).'},
     {'question': 'Unterstützt C-Sharp generischen Polymorphismus?', 'answer': 'Ja, C-Sharp unterstützt sowohl beschränkten als auch unbeschränkten parametrischen Polymorphismus, sowohl von Klassen als auch von Methoden. Die Syntax für beschränkte Typparameter sieht anders aus als die von Java, während die Syntax für unbeschränkte sich nicht unterscheidet. Parametrisch definierte Klassen und Interfaces spezifizieren jeweils eine (potenziell unendliche) Menge von Typen, die durch Einsetzen konkreter Typparameter in die Typvariablen entstehen. C-Sharp erlaubt zudem, den tatsächlichen Typparameter bei parametrischen Methodenaufrufen wegzulassen, wenn ihn der Compiler aus den Typen der Argumente erschließen kann (Typinferenz).'},
     {'question': 'Was ist der Unterschied zwischen beschränktem und unbeschränktem parametrischen Polymorphismus in C-Sharp?', 'answer': 'Beschränkter parametrischer Polymorphismus in C-Sharp erlaubt die Einschränkung der zulässigen Typen für die Typvariablen, während unbeschränkter parametrischer Polymorphismus keine Einschränkungen vorsieht. Die Syntax für beschränkte Typparameter in C-Sharp sieht anders aus als die für unbeschränkte, die Syntax für unbeschränkte Typparameter ist in C-Sharp identisch mit der von Java.'},
     {'question': 'Was ist der Unterschied zwischen Generics in C-Sharp und Java?', 'answer': 'Der Hauptunterschied besteht darin, dass Java die Typparameter grundsätzlich immer wegkompiliert, während C-Sharp im Fall von Werttyp-Parametern jede generische Klasse für jeden verwendeten Typ einmal instanziiert und alternative Implementierungen erzeugt, was zu optimierten Implementierungen führt. Für Referenztypen verhält sich C-Sharp jedoch wie Java. Zudem bleibt die generische Typinformation in C-Sharp zur Laufzeit erhalten und kann per Reflection abgefragt werden.'},
     {'question': 'Was ist der Unterschied zwischen der Annotation der Benutzung eines Typs in Java und der Annotation der Definition des Typs in C-Sharp?', 'answer': 'In Java wird ein Typparameter durch eine Annotation der Benutzung eines Typs als kovariant, kontravariant oder invariant markiert, während in C-Sharp die Annotation der Definition des Typs erfolgt. Das bedeutet, dass in Java die Varianz eines Typs bei seiner Verwendung festgelegt wird, während in C-Sharp die Varianz eines Typs bei seiner Definition festgelegt wird. In C-Sharp wird dem kovarianten oder kontravarianten Typparameter das Schlüsselwort out oder in vorangestellt, um die Beschränkungen (nur lesen oder nur schreiben) bei allen Verwendungen des Typs festzulegen.'},
     {'question': 'Wozu dienen Iteratoren in Java?', 'answer': 'Iteratoren in Java dienen dazu, eine einheitliche Iteration über verschiedene Arten von Collections zu ermöglichen, unabhängig davon, ob sie indiziert sind oder nicht. Sie bieten eine standardisierte Möglichkeit, durch die Elemente einer Collection zu iterieren, ohne sich um die interne Implementierung der Collection kümmern zu müssen.'},
     {'question': 'Was tut die Methode next() in einem Iterator-Objekt?', 'answer': 'Die Methode next() in einem Iterator-Objekt gibt das erste und anschließend alle weiteren Objekte der Collection zurück.'},
     {'question': 'Was macht die Methode hasNext() in einem Iterator-Objekt?', 'answer': 'Die Methode hasNext() in einem Iterator-Objekt fragt ab, ob die Collection noch weitere Objekte enthält.'},
     {'question': 'Was bedeutet es, eine Methode in Java zu redefinieren?', 'answer': 'In Java kann eine Subklasse eine Methode mit derselben Signatur (bestehend aus Methodennamen und formalen Parametertypen) wie eine Methode der Superklasse neu definieren, jedoch mit einer geänderten Implementierung. Die Methode kann auch den Rückgabetyp kovariant ändern, d.h., in Richtung Subtyp. Die Einhaltung der Typinvarianten, die mit ihren (geerbten) Parametern verbunden sind, über die hinaus die überschreibende Methode nichts tut, was mit der überschriebenen Methode inkompatibel ist, kann durch die Sprachdefinition von Java nicht erzwungen werden. In diesem Punkt liegt die Verantwortung beim Programmierer.'},
     {'question': 'Was bedeutet es, wenn eine Methode in Java kovariant geändert wird?', 'answer': 'Wenn eine Methode in Java kovariant geändert wird, bedeutet das, dass sie den Rückgabetyp in Richtung Subtyp ändern kann. Das heißt, der Rückgabetyp der überschriebenen Methode kann eine Unterklasse des Rückgabetyp der ursprünglichen Methode sein.'},
     {'question': 'Was ist der Unterschied zwischen Überladen und Überschreiben in Java?', 'answer': 'Beim Überladen wird eine neue Methode mit demselben Namen, aber verschiedenen Parametertypen eingeführt, während beim Überschreiben eine bereits existierende Methode neu definiert wird. Diese Unterscheidung ist wichtig für das dynamische Binden.'},
     {'question': 'Was ist der Unterschied zwischen dem deklarierten Typ und dem tatsächlichen Typ eines Objekts?', 'answer': 'Der deklarierte Typ eines Objekts ist der Typ, der bei der Deklaration des Objekts angegeben wird, während der tatsächliche Typ (auch dynamischer Typ genannt) erst zur Laufzeit bestimmt wird. Der tatsächliche Typ muss ein Subtyp des deklarierten Typs sein.'},
     {'question': 'Was ist der Unterschied zwischen dem deklarierten Typ und dem tatsächlichen Typ eines Objekts?', 'answer': 'Der deklarierte Typ eines Objekts ist der Typ, der bei der Deklaration des Objekts angegeben wird, während der tatsächliche Typ (auch dynamischer Typ genannt) erst zur Laufzeit bestimmt wird. Der tatsächliche Typ muss ein Subtyp des deklarierten Typs sein.'},
     {'question': 'Was verursacht einen Methodenambiguitätsfehler?', 'answer': 'Ein Methodenambiguitätsfehler wird verursacht, wenn bei der Suche nach einer Methode zur Übersetzungszeit nach dem oben beschriebenen Algorithmus (Schritt 4) eine oder mehrere andere Methodendefinitionen gleich weit von der aufgerufenen Methode entfernt sind und der Compiler dadurch nicht eindeutig bestimmen kann, welche Methode aufgerufen werden soll.'},
     {'question': 'Wer meldet einen Methodenambiguitätsfehler?', 'answer': 'Der Compiler meldet einen Methodenambiguitätsfehler.'},
     {'question': 'Was bedeutet ein Methodenambiguitätsfehler?', 'answer': 'Ein Methodenambiguitätsfehler bedeutet, dass die aufgerufene Methode durch den Aufruf nicht eindeutig bestimmt ist.'},
     {'question': 'Warum ist es besser, dass C++-Code wiederverwendbar ist?', 'answer': 'Es ist besser, dass C++-Code wiederverwendbar ist, weil niemand jemals daran denken wird, ihn rückzuentwickeln, aufgrund der chaotischen Syntax.'},
     {'question': 'Warum wird C++ als "sofortige Legacy"-Sprache bezeichnet?', 'answer': 'C++ wird als "sofortige Legacy"-Sprache bezeichnet, weil es zahlreiche große Projekte gibt, die bereits in veralteten Dialekten geschrieben wurden und weil die chaotische Syntax von C++ dazu führt, dass sogar Compiler raten müssen, was der Programmierer beabsichtigt hat. Diese Faktoren machen es unwahrscheinlich, dass C++-Code rückentwickelt wird, und somit ist die Wiederverwendbarkeit von C++-Code wichtiger als seine Rückentwicklung.'},
     {'question': 'Warum wird oft vergessen, dass C++ vollständig rückwärtskompatibel zu C sein muss?', 'answer': 'Bei der Entwicklung von C++ war eine der harten Anforderungen die vollständige Rückwärtskompatibilität zu C. Diese Anforderung wird oft vergessen, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss.'},
     {'question': 'Kann man in C++ völlig unlesbaren Code schreiben?', 'answer': 'Ja, man kann in C++ völlig unlesbaren Code schreiben, aber das gilt auch für C, weil man in C völlig unlesbaren Code schreiben kann.'},
     {'question': 'Kann man auch C++ mit einer neuen Syntax versehen und dann völlig lesbaren Code schreiben?', 'answer': 'Ja, man kann C++ mit einer neuen Syntax versehen, indem man den Präprozessor verwendet, der die Ausdrucksstärke einer vollwertigen Programmiersprache besitzt, und dann völlig lesbaren Code schreiben.'},
     {'question': 'Warum ist die Kritik an C++ als unfair anzusehen?', 'answer': 'Die Kritik an C++ ist als unfair anzusehen, weil bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C gefordert wurde, was ein so schwerwiegender Nachteil ist, dass fast jede Kritik an C++ als unfair angesehen werden muss.'},
     {'question': 'Was ist der Unterschied zwischen Arrays und Collections in Java?', 'answer': 'In Java werden Arrays und Collections als Zwischenobjekte verwendet, um Zu-n-Beziehungen umzusetzen. Der Hauptunterschied besteht darin, dass Arrays beschränkt sind und keine eigenen Methoden zur Unterstützung des Zugriffs haben, kein dynamisches Wachstum ermöglichen und eine etwas verkorkste Situation beim Subtyping aufweisen. Collections hingegen sind dynamisch und verfügen über eine Vielzahl von Methoden, die das Manipulieren von Objekten erleichtern.'},
     {'question': 'Was bedeutet es, dass jeder Typ in Java ein Subtyp von Object ist?', 'answer': 'Das bedeutet, dass jeder Typ in Java eine Unterklasse von Object ist und somit die Methoden von Object erbt.'},
     {'question': 'Was ist in Java der Unterschied zwischen Klassen und Interfaces?', 'answer': 'In Java sind Klassen die Blaupausen für Objekte, die definieren, welche Attribute und Methoden ein Objekt besitzt. Interfaces hingegen definieren nur eine Schnittstelle, die von Klassen implementiert werden kann. Sie spezifizieren eine Menge von Methodensignaturen, die eine Klasse implementieren muss, wenn sie das Interface implementiert. Im Gegensatz zu Klassen können Interfaces keine Attribute haben und die Methoden in Interfaces sind immer abstrakt.'},
     {'question': 'Warum können Interfaces in Java nicht von Klassen abgeleitet werden?', 'answer': 'Interfaces in Java können nicht von Klassen abgeleitet werden, weil sie nur eine Schnittstelle definieren und keine Implementierung enthalten. Sie spezifizieren lediglich eine Menge von Methodensignaturen, die eine Klasse implementieren muss, wenn sie das Interface implementiert. Daher können Interfaces nicht von Klassen abgeleitet werden, sondern nur von anderen Interfaces.'},
     {'question': 'Wozu können verschiedene Interfaces einer Klasse dienen?', 'answer': 'Unterschiedliche Interfaces einer Klasse können unterschiedliche Methodenmengen zur Verfügung stellen. Dadurch können mithilfe von verschiedenen Interfaces verschiedene Sichten auf ein Objekt gewährt werden. Zum Beispiel kann eine Klasse zwei Interfaces implementieren, von denen das eine nur die zum Lesen benötigten Methoden enthält und das andere nur die zum Schreiben.'},
     {'question': 'Was sind die Vorteile von Interfaces?', 'answer': 'Interfaces ermöglichen es, unterschiedliche Sichten auf ein Objekt zu gewähren, indem sie unterschiedliche Methodenmengen zur Verfügung stellen. Dadurch können beispielsweise auf eine Variable, die mit einem Interfacetyp deklariert wurde, nur die Methoden aufgerufen werden, die der Interfacetyp veröffentlicht. Dies führt zu einer besseren Kapselung und erhöht die Sicherheit, da Laufzeitfehler vermieden werden können.'},
     {'question': 'Was ist der Vorteil von Interfaces in Java?', 'answer': 'Der Vorteil von Interfaces in Java ist, dass sie die Abhängigkeit von der Implementierung verringern, da Klienten auf die Methoden zugreifen können, ohne die tatsächliche Implementierung zu kennen. Dies ermöglicht es, die Klassen zu ändern, ohne die Klienten zu beeinflussen, und erleichtert die Wartung und Erweiterung des Codes.'},
     {'question': 'Was ist der Unterschied zwischen der Verwendung von Interfaces und Klassen als Variablentypen in Java?', 'answer': 'Wenn die Klasse, von der das verwendete Objekt eine Instanz ist, als Typ zur Verfügung steht, kann man in Java in Variablendeklarationen genauso gut die Klasse als Typ verwenden. Dann hat man jedoch keine syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variable mehr. Seit Java 8 können in Interfaces auch statische Methoden definiert werden, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen. Man braucht dann keinerlei Zugriff mehr auf die Klassen, die somit vollständig hinter dem Interface als Schnittstelle verborgen werden können.'},
     {'question': 'Was ist der Unterschied zwischen der Verwendung von Interfaces und Klassen als Typ in Java?', 'answer': 'In Java können Variablendeklarationen entweder mit der Klasse oder mit dem Interface als Typ erfolgen. Wenn man die Klasse als Typ verwendet, hat man syntaktische Unterstützung bei der Benutzung der Variable, aber keine Zugriffsbeschränkung. Wenn man das Interface als Typ verwendet, hat man eine Zugriffsbeschränkung, aber keine syntaktische Unterstützung. Seit Java 8 können in Interfaces auch statische Methoden definiert werden, die neue Instanzen von Klassen, die das Interface implementieren, zurückliefern. Dadurch können die Konstruktoren der Klassen ersetzt und die Klassen hinter dem Interface als Schnittstelle verborgen werden.'},
     {'question': 'Was ermöglichen Interfaces in Java und C-Sharp?', 'answer': 'Interfaces in Java ermöglichen es, die Variablen mit dem Typ der Klasse zu deklarieren, die die Instanz des Objekts bereitstellt, und somit die syntaktische Unterstützung (Einschränkung des Funktionsumfangs) bei der Benutzung der Variablen zu behalten. C-Sharp geht noch weiter und ermöglicht es, Klassendefinitionen ihre Methoden ausschließlich über Interfacetypen zugänglich zu machen und somit die Konstruktoren der Klassen zu ersetzen. Seit Java 8 können in Interfaces auch statische Methoden definiert werden, die neue Instanzen von Klassen, die die Interfaces implementieren, zurückliefern und somit die Konstruktoren dieser Klassen ersetzen.'},
     {'question': 'Wozu dienen Interfaces in Java?', 'answer': 'Interfaces in Java dienen der Beschränkung des Zugriffs und der besseren Austauschbarkeit von Klassen. Durch die Verwendung von Interfaces als Typen von Variablen können Objekte verschiedener Klassen zugewiesen werden, solange sie dasselbe Interface implementieren.'},
     {'question': 'Was sind die Vorteile von Java gegenüber anderen Programmiersprachen?', 'answer': 'Die Vorteile von Java gegenüber anderen Programmiersprachen sind eine größere Flexibilität bei der Entwicklung und Verteilung von Anwendungen sowie eine weitgehende Plattformunabhängigkeit. Java-Programme können auf jedem Rechner und Betriebssystem laufen, für die es eine JVM gibt, sofern sie nicht von bestimmten Eigenheiten der Betriebssysteme abhängen.'},
     {'question': 'Warum ist es schwierig, die Sprache Java zu revolutionieren?', 'answer': 'Es ist schwierig, die Sprache Java zu revolutionieren, weil aufgrund der riesigen Menge an Software, die in Java geschrieben ist, stets auf Rückwärtskompatibilität geachtet werden muss. Zudem ist das Programmiermodell von Java seit Beginn an dasselbe geblieben und wird wohl auch immer gleich bleiben.'},
     {'question': 'Was bedeutet es, dass Java klassenbasiert und nicht prototypenbasiert ist?', 'answer': 'In Java werden Programme durch Angabe von Klassendefinitionen erstellt, im Gegensatz zu prototypenbasierten Sprachen, bei denen Objekte direkt erstellt und angepasst werden können.'},
     {'question': 'Was ist der Unterschied zwischen klassenbasierten und prototypenbasierten Programmiersprachen?', 'answer': 'Klassenbasierte Programmiersprachen wie Java, SMALLTALK und andere Sprachen, die in der nächsten Kurseinheit behandelt werden, verwenden Klassendefinitionen, um das Programmieren zu ermöglichen. Prototypenbasierte Sprachen hingegen verwenden Prototypen, um Objekte zu erstellen und zu definieren. In prototypenbasierten Sprachen gibt es keine Klassendefinitionen, sondern Objekte werden direkt erstellt und können dann als Vorlage für andere Objekte dienen.'},
     {'question': 'Was definiert eine Klasse in Java?', 'answer': 'In Java definiert jede Klasse ihren eigenen Typ, der denselben Namen wie die Klasse trägt und Felddefinitionen sowie Methodendeklarationen der Klasse als Eigenschaften enthält.'},
     {'question': 'Was ist der Unterschied zwischen STRONGTALK und Java in Bezug auf Deklarationen?', 'answer': 'In STRONGTALK werden die Typen bei Deklarationen ohne spitze Klammern nachgestellt, während in Java der Typ bei Deklarationen ohne spitze Klammern vorangestellt wird, in Anlehnung an die Tradition von C und C++. Die spitzen Klammern in Zeile 985 kennzeichnen in diesem Zusammenhang lediglich metasyntaktische Variablen.'},
     {'question': 'Warum hat Microsoft sich entschieden, das Problem der Unterscheidung zwischen Verweis- und Wertsemantik auf die Ebene der Programmiersprache zu heben?', 'answer': 'Das Problem der Unterscheidung zwischen Verweis- und Wertsemantik tritt sehr häufig auf. Microsoft hat sich dafür entschieden, es zumindest teilweise auf die Ebene der Programmiersprache zu heben, um es mittels einer Implementierung der benötigten Mechanismen in der Sprache zu lösen. In Smalltalk, wo diese Unterscheidung nicht so ausgeprägt ist, war das Problem mittels einer Implementierung in der Klasse Object gelöst worden, von der alle anderen Klassen erben.'},
     {'question': 'Welche Vorteile bietet die Typexpansion in C-Sharp für Werttypen?', 'answer': 'Die Typexpansion in C-Sharp ermöglicht es, generische Klassen für Werttypen ohne Boxing/Unboxing zu optimieren. Dies führt zu besserer Leistung und geringerem Overhead, da der JIT-Compiler den Code für verschiedene Typen optimieren kann.'},
     {'question': 'Welche Unterschiede gibt es in Bezug auf die Garbage Collection zwischen C-Sharp und Java?', 'answer': 'In C-Sharp haben Entwickler die Möglichkeit, den Speicherplatz für Objekte, die mit "new" erstellt wurden, manuell freizugeben. Dies kann jedoch zu Speicherlecks führen, wenn Entwickler vergessen, den Speicher freizugeben, oder zu Problemen, wenn auf freigegebene Objekte weiterhin Referenzen vorhanden sind. Im Gegensatz dazu verwendet Java normalerweise eine automatische Garbage Collection, bei der nicht mehr benötigte Objekte automatisch erkannt und freigegeben werden.'},
     {'question': 'Was ist ein Nachteil der Mehrfachvererbung in C++?', 'answer': 'Ein Nachteil der Mehrfachvererbung in C++ ist, dass das Erben nicht selektiv erfolgt, und das Löschen von geerbten Membern nicht möglich ist. Dies führt oft dazu, dass Klassen in viele kleine Teile aufgespalten werden, um unnötigen Ballast zu vermeiden.'},
     {'question': 'Was sind die Unterschiede zwischen "ref" und "out" in Bezug auf Methodenparameter in C-Sharp?', 'answer': 'In C-Sharp werden "ref" und "out" verwendet, um formale Parameter zu kennzeichnen, die durch den Methodenaufruf modifiziert werden können. Der Hauptunterschied besteht darin, dass bei "ref" die übergebene Variable vor dem Aufruf initialisiert sein muss, während bei "out" dies nicht erforderlich ist. Bei "out" muss jedoch die formale Parameter in der Methode selbst einen Wert zugewiesen bekommen. Beide ermöglichen mehrere Rückgabewerte für Methoden.'},
     {'question': 'Welche Unterschiede gibt es zwischen der Überschreibung von Methoden in C-Sharp im Vergleich zu Java?', 'answer': 'In C-Sharp müssen dynamisch zu bindende Methoden als "virtual" deklariert werden, und überschreibende Methoden müssen mit "override" gekennzeichnet sein. Wenn eine Methode in einer Subklasse neu eingeführt werden soll, wird "new" verwendet. Dies unterscheidet sich von Java, wo Methoden standardmäßig überschrieben werden können, es sei denn, sie sind als "final" deklariert. Diese Unterschiede sollen das sogenannte "Fragile-base-class-Problem" verhindern und die Programmiererin darüber informieren, welche Methoden dynamisch gebunden werden und welche nicht.'},
     {'question': 'Welche anderen Unterschiede und Konventionen gibt es zwischen C-Sharp und Java in Bezug auf Sprachkonstrukte?', 'answer': 'Einige Unterschiede und Konventionen zwischen C-Sharp und Java umfassen die Verwendung von "lock" anstelle von "synchronized" für die Synchronisation, die Verwendung von "foreach" anstelle von "for" für bestimmte Schleifen, die Möglichkeit, "Strings" als Basis einer "Switch"-Anweisung zu verwenden, und die Anforderung, dass jeder Zweig (case) einer "Switch"-Anweisung mit einer expliziten Kontrollflussanweisung ("break", "goto", "return" oder "throw") abgeschlossen sein muss. C-Sharp verfügt auch über eine "Goto"-Anweisung, die jedoch nicht in Blöcke springen kann.'},
     {'question': 'Welche Unterschiede gibt es im Typsystem von EIFFEL im Vergleich zu anderen Sprachen wie Java?', 'answer': 'Im Gegensatz zu Java besitzt EIFFEL ein einheitliches Typsystem, bei dem keine separaten Referenz- und Werttypen unterschieden werden. EIFFEL unterscheidet auch nicht zwischen eingebauten Operatoren und von Programmiererinnen definierten Methoden. Alle Operationen, einschließlich derer auf eingebauten Typen wie Integern, werden als Methoden behandelt.'},
     {'question': 'Welche Vorteile bieten Properties in C-Sharp im Vergleich zu direktem Feldzugriff?', 'answer': 'Properties in C-Sharp bieten den Vorteil, dass sie Feldzugriffe mit zusätzlicher Logik und Validierung versehen können. Sie machen den Code auf der Aufruferinnenseite knapper und besser lesbar, da sie wie Feldzugriffe aussehen und die Details der Implementierung verbergen. Außerdem ermöglichen sie die Simulation von Feldern mit Nur-Lese- oder Nur-Schreib-Zugriff, indem entweder der Getter oder der Setter weggelassen wird.'},
     {'question': 'Welche Unterschiede gibt es zwischen Zuweisungsversuchen in EIFFEL und Downcasts in Java?', 'answer': 'Ein Unterschied besteht darin, dass Zuweisungsversuche in EIFFEL keinen Laufzeitfehler verursachen können, im Gegensatz zu Downcasts in Java. Allerdings kann "void" in einer Variable in EIFFEL zur Laufzeit eine Nullzeiger-Ausnahme auslösen.'},
     {'question': 'Welchen Nachteil hat die Verwendung von Paketen in Java für die Zusammenarbeit von Klassen?', 'answer': 'In Java hatte man bis zur Version 8 die Möglichkeit, Klassen in ein Paket zu verfrachten, um die Zusammenarbeit von Klassen zu ermöglichen. Der Nachteil dabei ist, dass alle Klassen desselben Pakets dieselbe Schnittstelle jeder einzelnen enthaltenen Klasse haben, was die Aufteilung der Klassen auf Pakete einschränken kann.'},
     {'question': 'Was sind einige der Unterschiede im Typsystem von C-Sharp, die im Text erwähnt werden?', 'answer': 'Im Text werden die folgenden Unterschiede im Typsystem von C-Sharp im Vergleich zu Java erwähnt: Die Unterscheidung von Wert- und Referenztypen. Die verschiedenen Typkonstruktoren für Wert- und Referenztypen. Der Umgang mit Interfaces als Typen.'},
     {'question': 'Was enthält eine C++ Klasse neben Feldern (Instanzvariablen)?', 'answer': 'Eine C++ Klasse enthält neben Feldern (Instanzvariablen) auch Methoden.'},
     {'question': 'Gibt es in C++ die Möglichkeit, "Call by reference" ohne Verwendung des Zeigeroperators "&" zu erreichen?', 'answer': 'Ja, in C++ gibt es die Möglichkeit, "Call by reference" ohne Verwendung des Zeigeroperators "&" zu erreichen, ähnlich wie in Pascal. Hierbei bleiben die Aufrufstellen unverändert.'},
     {'question': 'Was unterscheidet Generics in C-Sharp und Generics in Java?', 'answer': 'Obwohl die Oberfläche von C-Sharp Generics der von Java ähnelt, unterscheidet sich der Mechanismus dahinter. C-Sharp instanziiert generische Klassen für Werttypen (wie int oder selbst definierte structs) für jeden verwendeten Typ, während Java Typparameter grundsätzlich immer entfernt (Type Erasure) und nur eine Implementierung erzeugt.'},
     {'question': 'Bleibt die generische Typinformation in C-Sharp auch zur Laufzeit erhalten?', 'answer': 'Ja, in C-Sharp bleibt die generische Typinformation auch zur Laufzeit erhalten und kann per Reflection abgefragt werden.'},
     {'question': 'Gibt es in C-Sharp eine Möglichkeit zur Typparameter-Inferenz bei generischen Methodenaufrufen?', 'answer': 'Ja, C-Sharp unterstützt Typparameter-Inferenz, was bedeutet, dass der Compiler den tatsächlichen Typparameter bei generischen Methodenaufrufen automatisch aus den Argumenten ableiten kann. Dies führt zu weniger Code und erhöht die Lesbarkeit.'},
     {'question': 'Warum wird C++ als "sofortige Legacy"-Sprache bezeichnet?', 'answer': 'C++ wird als "sofortige Legacy"-Sprache bezeichnet, weil sie eine Erweiterung von C ist und eine chaotische Syntax hat, die es schwer macht, den Code zu verstehen oder zurückzuentwickeln. Außerdem gibt es viele große Projekte, die bereits in veralteten C++-Dialekten geschrieben wurden.'},
     {'question': 'Warum wird darauf hingewiesen, dass C++ eine Erweiterung von C ist?', 'answer': 'Es wird darauf hingewiesen, dass C++ eine Erweiterung von C ist, um zu betonen, dass eine der harten Anforderungen bei der Entwicklung von C++ die vollständige Rückwärtskompatibilität zu C ist. Dies bedeutet, dass C++-Code mit C-Code kombiniert werden kann und C++-Programmierer auf bestehende C-Bibliotheken zugreifen können.'},
     {'question': 'Warum wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann?', 'answer': 'Es wird darauf hingewiesen, dass man in C++ völlig unlesbaren Code schreiben kann, um zu betonen, dass die Lesbarkeit des Codes in C++ stark von der Programmierpraxis abhängt. C++ bietet die Flexibilität, Code auf unterschiedliche Weisen zu schreiben, von sehr lesbar bis hin zu sehr unlesbar, je nach den Entscheidungen der Entwickler.'},
     {'question': 'Warum benötigen viele Applikationen, insbesondere solche mit GUI, eine Kommunikation mit unbekannten Objekten?', 'answer': 'Viele Applikationen benötigen eine Kommunikation mit unbekannten Objekten, da sie neben der direkten Kommunikation zwischen Objekten, die sich kennen, auch mit anderen Objekten kommunizieren müssen, die nicht im Voraus bekannt sind. Dies tritt insbesondere in Anwendungen mit grafischer Benutzeroberfläche (GUI) auf, wo verschiedene Elemente miteinander interagieren müssen, ohne im Voraus genau zu wissen, welche Objekte diese Interaktion benötigen.'},
     {'question': 'Was passiert, wenn man versucht, eine explizite Interfaceimplementierung mit einem anderen Zugriffsmodifikator als "public" zu deklarieren?', 'answer': 'In C-Sharp ist es möglich, Methoden von expliziten Interfaceimplementierungen mit Zugriffsmodifikatoren, die nicht "public" sind, von außen aufzurufen. Dies ist jedoch an die explizite Implementierung gebunden und erfordert die Verwendung des richtigen Interfacequalifikators.'},
     {'question': 'Können explizite Interfaceimplementierungen in C-Sharp überschrieben werden?', 'answer': 'Nein, explizite Interfaceimplementierungen können nicht überschrieben werden. Eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt diese ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut.'},
     {'question': 'Gibt es eine Namenskonvention für Interfaces in C-Sharp?', 'answer': 'Ja, im Common Type System von .NET sollten alle Interfacenamen mit einem "I" beginnen. Dies dient zur Unterscheidung von Interface- und Klassennamen und folgt der Tradition der ungarischen Notation bei Microsoft.'},
     {'question': 'Warum wurde in C-Sharp das Hantieren mit Pointern wieder eingeführt, und wie werden unsichere Bereiche behandelt?', 'answer': 'In C-Sharp wurde das Hantieren mit Pointern in unsichere Bereiche verbannt, weil es in systemnahen Programmierungen und beim Zugriff auf das Betriebssystem notwendig ist. Der Modifikator "unsafe" kennzeichnet solche unsicheren Bereiche und wird verwendet, um den Einsatz von Pointern zu ermöglichen. In unsicheren Bereichen können Zeiger auf Typen deklariert werden, und die Dereferenzierung eines Zeigers erfolgt mit einem Stern (*). Dies ermöglicht das Hantieren mit Pointern in einem begrenzten und kontrollierten Umfeld.'},
     {'question': 'Warum wird C++ als eine sehr komplexe Sprache beschrieben?', 'answer': 'C++ wird als eine sehr komplexe Sprache beschrieben, weil ihre Beherrschung Jahre dauern kann, selbst bei täglichem Umgang mit ihr. Die eigentliche Komplexität ergibt sich aus der kombinierten Verwendung ihrer zahlreichen Konstrukte, und die Möglichkeiten sind vielfältig.'},
     {'question': 'Warum ist es schwer, C++ zu lehren?', 'answer': 'Es ist schwer, C++ zu lehren, weil die Sprache sehr komplex ist und die Kombinatorik ihrer Konstrukte zu einer hohen Zahl von Möglichkeiten führt. Die Vielzahl von Idiomen (Wendungen) in C++ trägt ebenfalls zur Komplexität bei.'},
     {'question': 'Warum ist es schwierig, die Komplexität von C++ von der Objektorientierung zu trennen?', 'answer': 'Es ist schwierig, die Komplexität von C++ von der Objektorientierung zu trennen, weil viele Beiträge zur Komplexität von C++ in Zusammenhang mit der Objektorientierung stehen. Die Kombination von objektorientierten Konzepten und anderen Sprachmerkmalen macht C++ zu einer komplexen Sprache.'},
     {'question': 'Was wird als mögliche Gefahr hinsichtlich der Entwicklung von C-Sharp und Java erwähnt?', 'answer': 'Als mögliche Gefahr wird erwähnt, dass die beiden Sprachen sich gegenseitig übertrumpfen könnten. Es besteht die Möglichkeit, dass jemand auf die Idee kommt, die besten Eigenschaften beider Sprachen zu kombinieren und eine neue Sprache zu entwickeln. Dies könnte auch eine Gelegenheit sein, sich von den Syntax-Erben aus der C-Welt zu verabschieden.'},
     {'question': 'Warum könnte EIFFEL trotz seiner Funktionen kein größerer Erfolg geworden sein?', 'answer': 'Es gibt mehrere mögliche Gründe für den begrenzten Erfolg von EIFFEL. Dies könnte auf unzureichende Implementierungen der Werkzeuge, die Kompromisslosigkeit des Schöpfers BERTRAND MEYER und den Spagat zwischen kommerzieller Anwendbarkeit und akademischer Eignung zurückzuführen sein. Auch das Typsystem von EIFFEL und akademische Vorbehalte gegenüber bestimmten Programmierweisen könnten eine Rolle spielen. Trotzdem hat EIFFEL Einfluss auf die Art und Weise, wie über das Programmieren nachgedacht wird.'},
     {'question': 'Gibt es in C-Sharp einen Unterschied zwischen Wert- (primitiven) und Referenztypen wie in Java?', 'answer': 'In C-Sharp wird zunächst nicht zwischen Wert- (primitiven) und Referenztypen wie in Java unterschieden. Alle Typen, einschließlich der primitiven Typen, gelten als von Object (genauer: System.Object) abgeleitet.'},
     {'question': 'Bietet C++ eine dynamische Typprüfung wie andere Sprachen?', 'answer': 'Nein, C++ bietet keine eingebaute dynamische Typprüfung.'},
     {'question': 'Warum wissen einige Objekte in C++, von welcher Klasse sie eine Instanz sind?', 'answer': 'Einige Objekte in C++ wissen zumindest im Prinzip, von welcher Klasse sie eine Instanz sind, weil sie einen Zeiger auf die Sprungtabelle ihrer virtuellen Methoden besitzen. Diese virtuelle Funktionstabelle dient als eine Art Repräsentation der Klasse.'},
     {'question': 'Gibt es in EIFFEL Zugriffsmodifikatoren wie in Java oder C++?', 'answer': 'Nein, es gibt in EIFFEL keine Zugriffsmodifikatoren wie in Java oder C++. Alle Features sind standardmäßig öffentlich zugänglich.'},
     {'question': 'Bietet EIFFEL spezielle Konstrukte zur Leistungsoptimierung?', 'answer': 'Nein, EIFFEL sieht keine speziellen Konstrukte vor, mit denen Programmierer zwischen leistungsstarken und weniger leistungsstarken Implementierungen wählen können. Die Performance-Verbesserungen werden vollständig einem optimierenden Compiler überlassen.'},
     {'question': 'Warum kann Mehrfachvererbung in C++ sinnvoll sein?', 'answer': 'Mehrfachvererbung kann aus verschiedenen Gründen sinnvoll sein: Eine Klasse kann von mehreren vollständig abstrakten Klassen erben und damit mehrere Interfaces implementieren. In Aufgabenstellungen, in denen eine Klasse Eigenschaften von mehreren anderen Klassen benötigt, erlaubt Mehrfachvererbung, alle benötigten Eigenschaften zu erben, anstatt sich für eine einzige Superklasse entscheiden zu müssen.'},
     {'question': 'Warum gibt es in C-Sharp keine "Throws"-Klauseln in Methodendeklarationen, wie sie in Java existieren?', 'answer': 'C-Sharp verzichtet auf "Throws"-Klauseln in Methodendeklarationen, die in Java zur Unterscheidung von Checked Exceptions und Unchecked Exceptions verwendet werden. Stattdessen gibt es in C-Sharp nur Unchecked Exceptions. Diese Entscheidung wurde getroffen, um die Programmierer nicht dazu zu zwingen, im Voraus zu wissen, was in jeder Methode schief gehen kann. Es gibt jedoch Möglichkeiten, Exception-Handling in C-Sharp durch "Exception chaining" und "Exception tunneling" zu implementieren.'},
     {'question': 'Können Indexer in C-Sharp überladen werden und mehrere indizierte Instanzvariablen simulieren?', 'answer': 'Ja, Indexer in C-Sharp können überladen werden, um mehrere indizierte Instanzvariablen zu simulieren. Dies ermöglicht einem Objekt, mehrere indizierte Variablen mit unterschiedlichen Indexen zu haben. Die Einschränkung dabei ist, dass der Rückgabetyp (Elementtyp) beim Überladen gleich bleiben muss. Indexer können auch berechnete Werte zurückgeben, ohne auf interne Instanzvariablen zuzugreifen, ähnlich wie Properties.'},
     {'question': 'Warum wird in EIFFEL eine kovariante Redefinition benötigt?', 'answer': 'In EIFFEL wird eine kovariante Redefinition benötigt, um die Unterkunft der jungen Skifahrerinnen nach Geschlechtern getrennt zu organisieren. Dies ermöglicht es, Mädchen und Jungen unterschiedliche Typen für "roommate" zuzuweisen.'},
     {'question': 'Warum führt die implizite Allquantifizierung einer Deklaration zu einem Fehler?', 'answer': 'Die implizite Allquantifizierung einer Deklaration wie "SKIER.share(SKIER)" bedeutet nicht, dass alle Skifahrerinnen (beider Geschlechter) ihr Zimmer mit allen Skifahrerinnen teilen können. Dies ist aufgrund von Faktoren wie Krankheit nicht immer möglich. Die statische Typisierung kann solche situativen Unterschiede nicht abbilden.'},
     {'question': 'Warum sind Typtests in EIFFEL manchmal notwendig?', 'answer': 'Typtests in EIFFEL sind manchmal notwendig, um festzustellen, welchen genauen Typ ein Element hat, das in einen Container (eine Variable oder eine Collection) ungleichen Typs gelegt wurde. Dadurch kann das Element entsprechend seines Typs verwendet werden.'},
     {'question': 'Gibt es in EIFFEL explizite Typumwandlungen wie in anderen Sprachen?', 'answer': 'In EIFFEL gibt es keine expliziten Typumwandlungen wie in einigen anderen Sprachen. Die Typumwandlung erfolgt immer in Verbindung mit einer Zuweisung.'},
     {'question': 'Was unterscheidet Werttypen und Referenztypen in EIFFEL?', 'answer': 'Anders als in C-Sharp unterscheidet EIFFEL nicht zwischen Wert- und Referenztypen auf der Ebene von Typkonstruktoren. Stattdessen kann es für jeden Typ sowohl Wertsemantik als auch Referenzsemantik geben.'},
     {'question': 'Warum ist das Friends-Konzept in C++ nützlich?', 'answer': 'Das Friends-Konzept ist nützlich, wenn ein Teilproblem in der Programmierung nicht von einer einzelnen Klasse gelöst werden kann, sondern die Zusammenarbeit mehrerer Klassen erfordert. Es ermöglicht, dass diese Klassen eng zusammenarbeiten können, ohne dass alle Klassen dieselbe Schnittstelle haben müssen.'},
     {'question': 'Gibt es in C++ die Möglichkeit, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren?', 'answer': 'Nein, in C++ ist es nicht möglich, einzelne Member einer Klasse spezifisch an bestimmte Klassen zu exportieren. Stattdessen erlaubt das Friends-Konzept, dass bestimmte Klassen auf alle privaten Elemente einer anderen Klasse zugreifen können.'},
     {'question': 'Warum wurde C-Sharp entwickelt?', 'answer': 'Die Entwicklung von C-Sharp wurde weniger als Versuch betrachtet, mit Microsofts Marktmacht einen proprietären Standard durchzusetzen, sondern war vielmehr dem Umstand geschuldet, dass Java keine volle Kontrolle über Hardware und Betriebssystem bietet und somit nicht für jede kommerzielle Softwareentwicklung geeignet ist.'},
     {'question': 'In welchen wesentlichen Punkten unterscheidet sich das Typsystem von C-Sharp von dem von Java?', 'answer': 'Das Typsystem von C-Sharp unterscheidet sich von Java in mehreren wesentlichen Punkten, darunter die Art der Unterscheidung von Wert- und Referenztypen, die angebotenen Typkonstruktoren für Wert- und Referenztypen und den Umgang mit Interfaces als Typen.'},
     {'question': 'Warum ist es wichtig, verschiedene objektorientierte Programmiersprachen zu kennen?', 'answer': 'Es ist wichtig, verschiedene objektorientierte Programmiersprachen zu kennen, da Praktikerinnen und solche, die es werden wollen, die Programmiersprachen kennen müssen, die auf dem Markt gefragt sind. Dies ermöglicht es ihnen, in verschiedenen beruflichen Situationen flexibel zu sein und die am besten geeignete Sprache für bestimmte Aufgaben auszuwählen.'},
     {'question': 'Was ermöglicht Mehrfachvererbung in C++?', 'answer': 'Mehrfachvererbung in C++ ermöglicht es, eine Klasse von mehreren anderen abzuleiten. Dadurch kann eine Klasse mehrere direkte Supertypen haben, einen pro direkte Superklasse.'},
     {'question': 'Was passiert, wenn eine Typumwandlung in C-Sharp nicht möglich ist?', 'answer': 'Wenn eine Typumwandlung in C-Sharp nicht möglich ist, weil der tatsächliche Typ des Ausdrucks a kein Subtyp von T ist oder keine entsprechende Typumwandlung definiert ist, führt dies zu einem Laufzeitfehler.'},
     {'question': 'Was bedeutet es, wenn eine Klasse explizite Interfaceimplementierungen erbt?', 'answer': 'Wenn eine Klasse von einer Klasse mit expliziten Interfaceimplementierungen erbt, erbt sie diese Implementierungen ohne die Möglichkeit, sie zu überschreiben, es sei denn, sie implementiert das Interface erneut. Es ist jedoch wichtig zu beachten, dass diese erneute explizite Implementierung keine Überschreibung darstellt und bei Aufruf der explizit implementierten Methode kein dynamisches Binden stattfindet.'},
     {'question': 'Was passiert, wenn eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, diese Methode erneut implementiert?', 'answer': 'Wenn eine Klasse, die von einer Klasse mit expliziten Interfaceimplementierungen erbt, diese Methode erneut implementiert, dann stellt dies keine Überschreibung dar und findet bei Aufruf der explizit implementierten Methode kein dynamisches Binden statt.'},
     {'question': 'Unterstützt EIFFEL Mehrfachvererbung?', 'answer': 'Ja, EIFFEL erlaubt Mehrfachvererbung.'},
     {'question': 'Kann man in EIFFEL Methoden löschen?', 'answer': 'Ja, EIFFEL gestattet das Löschen von Methoden.'},
     {'question': 'Unterstützt EIFFEL Mehrfachvererbung?', 'answer': 'Ja, EIFFEL erlaubt Mehrfachvererbung.'},
     {'question': 'Was bedeutet "Redefinition" in EIFFEL?', 'answer': 'In EIFFEL wird das Überschreiben von Methoden als "Redefinition" bezeichnet.'},
     {'question': 'Was bedeutet "deferred" in EIFFEL?', 'answer': 'In EIFFEL bezeichnet das Schlüsselwort "deferred" abstrakte Klassen.'},
     {'question': 'Was bedeutet "Redefine" in Eiffel?', 'answer': '"Redefine" ist eine Deklaration in Eiffel, die angibt, dass eine Methode eine andere Methode mit demselben Namen und denselben oder kovariant redefinierten Parametern überschreibt.'},
     {'question': 'Was ermöglicht Eiffel, wenn zwei Klassen, von denen Sie erben möchten, Methoden mit demselben Namen verwenden?', 'answer': 'Eiffel ermöglicht es, geerbte Features umzubenennen, indem es eine "Rename"-Klausel gibt, die es erlaubt, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen.'},
     {'question': 'Was passiert mit dem ursprünglichen Namen einer umbenannten Methode in Eiffel?', 'answer': 'Wenn auf das Feature über den Typ der Klasse zugegriffen wird, von der das umbenannte Feature geerbt wurde, behält das Feature weiterhin seinen ursprünglichen Namen bei.'},
     {'question': 'Was ermöglicht die "Rename"-Klausel in Eiffel?', 'answer': 'Die "Rename"-Klausel in Eiffel ermöglicht es, zwei geerbte Features mit demselben Namen unterschiedlich zu benennen.'},
     {'question': 'Warum ist es wichtig, zwischen öffentlichen und privaten Teilen eines Moduls zu unterscheiden?', 'answer': 'Die Unterscheidung zwischen öffentlichen und privaten Teilen eines Moduls ermöglicht es den Programmierern, die Hoheit über die Implementierung des Moduls zu behalten. Durch die Verwendung einer Schnittstelle und das Verbergen der internen Details können sie jederzeit die internen Teile ändern, ohne dass dies Auswirkungen auf andere Teile des Programms hat, solange die Schnittstelle unverändert bleibt.'},
     {'question': 'Was simulierten Klassen und Pakete in Java bis Version 8?', 'answer': 'In Java wurden bis Version 8 Module durch Klassen und Pakete simuliert.'},
     {'question': 'Was ist der Unterschied zwischen der Verwendung von Klassen in C-Sharp und Java?', 'answer': 'Der Unterschied liegt darin, dass in C-Sharp das Verhältnis von Klasse zu Datei lockerer ist als in Java. In C-Sharp können Klassen anders heißen als ihre Dateien und sogar auf mehrere Dateien aufgeteilt werden. Im Gegensatz dazu ist in Java das Verhältnis von Klasse zu Datei strenger, da die Klasse denselben Namen wie ihre Datei haben muss.'},
     {'question': 'Was bedeutet der Stern hinter einem Typ in Objective-C?', 'answer': 'Der Stern hinter einem Typ in Objective-C bedeutet, dass es sich um einen Zeiger-auf-Typ handelt.'},
     {'question': 'Was bedeutet der Stern vor einer Variable in der Programmierung?', 'answer': 'Vor einer Variable bedeutet der Stern, dass die Variable dereferenziert wird, also nicht auf den Pointer, sondern auf die Speicherstelle, auf die der Pointer zeigt, zugegriffen wird.'},
     {'question': 'Was bedeutet der Stern neben Methoden, Klassen, Blöcken und Variablen in der Programmierung?', 'answer': 'Neben Methoden, Klassen, Blöcken und Variablen bedeutet der Stern, dass sie unsicher sind. Das heißt, sie können Null-Werte haben und müssen vor der Verwendung auf Null überprüft werden.'},
     {'question': 'Warum ist C++ eine sehr komplexe Programmiersprache?', 'answer': 'C++ ist eine sehr komplexe Programmiersprache, weil sie eine große Anzahl an Konstrukten hat und die eigentliche Komplexität aus deren kombinierter Verwendung entsteht. Die Zahl der Möglichkeiten ist hoch und es gibt entsprechend viele Idiome (Wendungen) für C++.'},
     {'question': 'Was ist der Unterschied zwischen primitiven und Referenztypen in Java?', 'answer': 'In Java gibt es eine Trennung zwischen primitiven und Referenztypen. Primitiven Typen sind vordefinierte Datentypen, wie zum Beispiel int, float oder boolean. Referenztypen hingegen sind Objekte, die in der Sprache definiert werden. Die Operationen auf primitiven Typen sind fest vorgegeben, während alle anderen Operationen als Methoden in Klassen definiert werden müssen. Primitiven Typen besitzen weder Identität noch Zustand, im Gegensatz zu Referenztypen.'},
     {'question': 'Warum gibt es in Java eine klare Trennung zwischen primitiven und Referenztypen?', 'answer': 'Die klare Trennung zwischen primitiven und Referenztypen ist konsequent durchgezogen, was den Charakter von Java als Programmiersprache geprägt hat. Sie ist sinnvoll, weil Werte, im Gegensatz zu Objekten, weder Identität noch Zustand besitzen und somit unterschieden werden müssen.'},
     {'question': 'Was ist der Unterschied zwischen Prozeduren und Funktionen in Java?', 'answer': 'Der Unterschied zwischen Prozeduren und Funktionen in Java besteht darin, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp "void" deklarieren, während Funktionen einen Rückgabewert haben.'},
     {'question': 'Was macht der Operator "instanceof" in Java?', 'answer': 'Der Operator "instanceof" in Java ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist. Dabei wird nicht zwischen direkten und indirekten Instanzen unterschieden.'},
     {'question': 'Was kann der Typtest "instanceof" in Java?', 'answer': 'Der Typtest "instanceof" in Java ermöglicht es zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist, unabhängig davon, ob es sich um eine direkte oder indirekte Instanz handelt. Zum Beispiel ergibt "x instanceof Object" immer "true", unabhängig davon, für welches Objekt "x" steht.'},
     {'question': 'Was regeln die Zugriffsmodifikatoren in Java?', 'answer': 'Die Zugriffsmodifikatoren in Java regeln die Zugreifbarkeit von Klassen, Typen und den Elementen ihrer Definition (den Membern) in Abhängigkeit von der Position, an der sie verwendet werden. Es gibt vier Zugriffsmodifikatoren: private, protected, public und "Package local". Die Zugriffsbeschränkung, die gemeinsam mit einem Typ deklariert wird, ist konzeptionell jedoch nicht mit dem Typ selbst verbunden, sondern vielmehr die Schnittstellenspezifikation eines Moduls, wobei das Modul die Klasse ist.'},
     {'question': 'Was verhindern Zugriffsbeschränkungen auf Instanzvariablen und Klassenvariablen?', 'answer': 'Zugriffsbeschränkungen auf Instanzvariablen und Klassenvariablen verhindern, dass diese von außen verändert werden.'},
     {'question': 'Was verhindern Zugriffsbeschränkungen auf Methoden?', 'answer': 'Zugriffsbeschränkungen auf Methoden verhindern, dass diese von außen aufgerufen werden.'},
     {'question': 'Was ist der Vorteil der Verknüpfung von Typ und Zugriffsbeschränkung in Java?', 'answer': 'Der Vorteil der Verknüpfung von Typ und Zugriffsbeschränkung in Java ist die sprachliche Knappheit, da Typ- und Schnittstellendeklaration in einem angegeben werden können.'},
     {'question': 'Was sind die Unterschiede zwischen Zeichenliteralen und String-Literalen in Java?', 'answer': 'Zeichenliterale in Java werden durch einfache Anführungsstriche eingeschlossen und repräsentieren ein einzelnes Zeichen, während String-Literale durch doppelte Anführungsstriche eingeschlossen sind und eine Folge von Zeichen repräsentieren. Beide können Escape-Sequenzen zur Darstellung von Sonderzeichen enthalten.'},
     {'question': 'Was ist der Unterschied zwischen Klassennamen und Klassenliteralen in Java?', 'answer': 'In Java sind Klassennamen und Klassenliteralen zwei verschiedene Dinge. Klassennamen werden direkt verwendet, zum Beispiel als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie "instanceof". Klassenliteralen hingegen sind Objekte, die die Metaklasse einer Klasse repräsentieren. Sie werden mit dem Schlüsselwort "Class" und dem Klassennamen in spitzen Klammern erzeugt. Die Unterscheidung von Klassennamen und Klassenliteralen in Java ist nicht sehr intuitiv und wird eher selten verwendet.'},
     {'question': 'Was bedeutet es, wenn eine Java-Klasse von einer anderen Klasse ableitet?', 'answer': 'Wenn eine Java-Klasse von einer anderen Klasse ableitet, wird eine Subklassenbeziehung zwischen den beiden Klassen deklariert. Die abgeleitete Klasse erbt alle Eigenschaften und Methoden der Basisklasse und kann diese erweitern oder überschreiben. Diese Beziehung ermöglicht auch Zuweisungskompatibilität, was bedeutet, dass eine Instanz der abgeleiteten Klasse auch als Instanz der Basisklasse behandelt werden kann.'},
     {'question': 'Was bedeutet die "extends"-Klausel in einer Klassendeklaration in Java?', 'answer': 'Durch die Angabe einer "extends"-Klausel gibt eine Klasse in Java an, von welcher anderen Klasse sie die nicht als "static" deklarierten Member erbt. Die erbende Klasse ist automatisch ein Subtyp des Typs der Klasse, von der sie erbt.'},
     {'question': 'Was ist der Unterschied zwischen einer Klasse und einem Objekt?', 'answer': 'Eine Klasse ist eine Art Blaupause oder Vorlage für die Erstellung von Objekten, während ein Objekt eine konkrete Instanz einer Klasse ist. Ein Objekt besitzt einen Zustand und ein Verhalten, das durch die Methoden der Klasse definiert wird, von der es abgeleitet ist.'},
     {'question': 'Was ist der Unterschied zwischen einem Typ und einer Klasse?', 'answer': 'Ein Typ ist eine Menge von Objekten, die eine bestimmte Schnittstelle implementieren, während eine Klasse eine Blaupause oder Vorlage für die Erstellung von Objekten ist. Eine Klasse definiert den Zustand und das Verhalten ihrer Objekte, und ein Typ definiert die Schnittstelle, die von den Objekten implementiert werden muss.'},
     {'question': 'Was bedeutet es, wenn der Typ einer Variablen eine Subklasse ist?', 'answer': 'Wenn der Typ einer Variablen eine Subklasse ist, kann die Variable auf Objekte der Subklasse und der Oberklasse verweisen. Das bedeutet, dass die Variable auf Objekte verweisen kann, die die Methoden und Attribute der Oberklasse und der Subklasse besitzen.'},
     {'question': 'Was bedeutet es, wenn eine Klasse in Java als abstrakt deklariert wird?', 'answer': 'Wenn eine Klasse in Java als abstrakt deklariert wird, bedeutet das, dass sie nicht instanziiert werden kann, d.h. es können keine Objekte dieser Klasse erzeugt werden. Diese Klasse dient lediglich als Basisklasse für andere Klassen und enthält in der Regel eine oder mehrere abstrakte Methoden, die von den Unterklassen implementiert werden müssen.'},
     {'question': 'Was bedeutet es, wenn eine Klasse als abstrakt markiert wird?', 'answer': 'Wenn eine Klasse als abstrakt markiert wird, dürfen keine Instanzen mehr von dieser Klasse gebildet werden. Dieses Verbot gilt unabhängig davon, ob von der Klasse Instanzen erstellt werden könnten. Selbst wenn alles, was für das Funktionieren der Instanzen benötigt wird, in der Klasse vorhanden ist, darf sie nicht instanziiert werden.'},
     {'question': 'Was passiert, wenn man in Java eine abstrakte Klasse ableitet und die abstrakten Methoden nicht implementiert?', 'answer': 'Wenn man in Java eine abstrakte Klasse ableitet und die abstrakten Methoden nicht implementiert, erhält man vom Compiler eine entsprechende Aufforderung.'},
     {'question': 'Was bedeutet es, wenn eine Klasse in Java als "final" deklariert wird?', 'answer': 'Wenn eine Klasse in Java als "final" deklariert wird, verhindert es, dass von dieser Klasse abgeleitet wird.'},
     {'question': 'Was bewirkt die "final"-Deklaration einer Methode in Java?', 'answer': 'Durch die "final"-Deklaration einer Methode in Java wird das Überschreiben der Methode in einer Subklasse verhindert.'},
     {'question': 'Was besagt die goldene Regel der objektorientierten Programmierung bezüglich der Deklaration von Klassen als abstrakt oder final?', 'answer': 'Die goldene Regel der objektorientierten Programmierung besagt, dass man alle Klassen entweder als abstrakt oder als final deklarieren sollte. Dies fördert das Prinzip der abstrakten Generalisierung und vermeidet die Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien.'},
     {'question': 'Was ist der Unterschied zwischen einer Klasse und einem Interface in Java?', 'answer': 'Ein Interface in Java ist ein eigenständiges Konstrukt, das eine öffentliche Schnittstelle definiert, während eine Klasse sowohl eine öffentliche Schnittstelle als auch eine Implementierung der Methoden bereitstellt. Ein Interface kann nur Methoden deklarieren, aber keine Implementierungen bereitstellen. Eine Klasse hingegen kann eine Implementierung für die Methoden bereitstellen, die in einem Interface deklariert sind. Ein Interface kann von mehreren Klassen implementiert werden, während eine Klasse nur von einer Superklasse erben kann.'},
     {'question': 'Was ist der Unterschied zwischen einer Klassendeklaration und einer Interfacedeklaration?', 'answer': 'Eine Klassendeklaration enthält Felddeklarationen und eine Implementierung der Methoden, während eine Interfacedeklaration nur die Methodensignatur ohne Implementierung enthält und keine Felddeklarationen. Zudem wird für eine Interfacedeklaration das Schlüsselwort "interface" anstelle von "class" verwendet.'},
     {'question': 'Warum können Interfaces keine Implementierungen oder Objekte liefern?', 'answer': 'Interfaces können keine Implementierungen oder Objekte liefern, weil sie lediglich eine Schnittstelle definieren, die von Klassen implementiert werden kann. Sie legen lediglich fest, welche Methoden eine Klasse implementieren muss, um ein bestimmtes Interface zu implementieren.'},
     {'question': 'Warum gibt es in Interfaces keine Felder?', 'answer': 'In Interfaces gibt es keine Felder, weil bei Feldern nicht zwischen Deklaration und Implementierung unterschieden werden kann. Da Interfaces lediglich Schnittstellen definieren, die von Klassen implementiert werden können, wurden Felder aus den Interfaces verbannt. Stattdessen können Feldzugriffe in Interfaces durch Zugriffsmethoden (Accessoren) ersetzt werden.'},
     {'question': 'Was bedeutet es, wenn eine Klasse ein Interface implementiert?', 'answer': 'Wenn eine Klasse ein Interface implementiert, verpflichtet sie sich, alle im Interface angekündigten Methoden zu implementieren und öffentlich anzubieten. Zudem ist die Angabe der implementierten Interfaces eine nominale Typkonformitätsdeklaration, d.h. Instanzen der Klasse sind mit allen Variablen jedes der genannten Interfaces zuweisungskompatibel.'},
     {'question': 'Was ist der Unterschied zwischen Mehrfachvererbung und Mehrfach-Subtyping in Java?', 'answer': 'Mehrfachvererbung bezieht sich auf die Fähigkeit einer Klasse, Eigenschaften und Methoden von mehr als einer Superklasse zu erben, während Mehrfach-Subtyping darauf beruht, dass eine Klasse mehr als einem Interface gleichzeitig implementieren kann. Im Gegensatz zur Mehrfachvererbung wird bei der Implementierung eines Interface nichts vererbt, sondern es wird eine Art Mehrfach-Subtyping erreicht, das auch nützlich sein kann.'},
     {'question': 'Was verlangt das Subtyping in Java?', 'answer': 'Das Subtyping in Java verlangt, dass die Typen geerbter Variablen (Felder und Parametertypen von Methoden) nicht verändert werden dürfen, was Kovarianz bedeutet. Dadurch wird eine statisch-semantische Substituierbarkeit von Objekten der Subtypen gegenüber ihren Supertypen sichergestellt. Allerdings kann der Rückgabetyp von Methoden kovariant redefiniert werden.'},
     {'question': 'Was unterscheidet Konstruktoren in Java im Vergleich zu SMALLTALK?', 'answer': 'Im Gegensatz zu SMALLTALK sind Konstruktoren in Java keine Klassenmethoden, sondern stehen zwischen Klassen- und Instanzmethoden. Sie verhalten sich wie Instanzmethoden, da sie im Inneren auf alle Felder und Methoden der neu erzeugten Instanz zugreifen können. In diesem Sinne können Konstruktoren als Instanzmethoden betrachtet werden, die auf der neu erzeugten Instanz aufgerufen werden.'},
     {'question': 'Was ist der Unterschied zwischen Konstruktoren und Klassenmethoden in Java?', 'answer': 'Der Unterschied zwischen Konstruktoren und Klassenmethoden in Java ist, dass Konstruktoren auf der Klasse aufgerufen werden und dazu dienen, ein neues Objekt zu initialisieren, während Klassenmethoden ebenfalls auf der Klasse aufgerufen werden, aber kein neues Objekt erstellen.'},
     {'question': 'Warum wird im Kontext kein Rückgabetyp für den Konstruktor angegeben?', 'answer': 'Im Vergleich zu anderen Methoden erlauben Konstruktordefinitionen in Java keine Angabe eines Rückgabetyps. Da die erzeugte Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist, ist der Typ festgelegt.'},
     {'question': 'Warum ist die Angabe des Rückgabetyps in Konstruktordefinitionen in Java nicht erforderlich?', 'answer': 'In Konstruktordefinitionen in Java ist die Angabe des Rückgabetyps nicht erforderlich, weil der Typ der erzeugten Instanz immer ein Exemplar der Klasse ist, in der der Konstruktor definiert ist. Somit ist der Typ der Instanz bereits festgelegt und muss nicht explizit angegeben werden.'},
     {'question': 'Was passiert, wenn kein Konstruktor in Java definiert wird?', 'answer': 'Wenn kein Konstruktor in Java definiert wird, verwendet Java standardmäßig den impliziten Standardkonstruktor. Dieser ist parameterlos und erzeugt eine neue Instanz der Klasse.'},
     {'question': 'Was bewirkt der Aufruf von "super" in einem Konstruktor?', 'answer': 'Durch den Aufruf von "super" in einem Konstruktor werden die in "super" aufgerufenen Methoden dynamisch gebunden, was dazu führen kann, dass auf noch nicht initialisierte Variablen zugegriffen wird.'},
     {'question': 'Wird der Standardkonstruktor einer Klasse beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen?', 'answer': 'Ja, der Standardkonstruktor einer Klasse wird beim Erzeugen einer Instanz einer ihrer Subklassen automatisch aufgerufen.'},
     {'question': 'Was ist der Unterschied zwischen Klassenmethoden und Konstruktoren?', 'answer': 'Klassenmethoden sind Methoden, die auf die Klasse als Ganzes angewendet werden, während Konstruktoren beim Erzeugen eines Objekts aufgerufen werden und der Initialisierung der Instanzvariablen dienen.'},
     {'question': 'Was passiert, wenn eine Exception geworfen wird?', 'answer': 'Wenn eine Exception geworfen wird, wird der Programmablauf an der aktuellen Stelle unterbrochen und an der nächsten Stelle fortgesetzt, an der ein passender Exception Handler für den Typ der geworfenen Exception vorhanden ist. Der Codeabschnitt, in dem die Exception auftreten kann, muss in einen Try-Catch-Block eingefasst sein.'},
     {'question': 'Was passiert, wenn der Typ der geworfenen Exception nicht in einer der Catch-Klauseln aufgeführt ist?', 'answer': 'Wenn der Typ der geworfenen Exception nicht in einer der Catch-Klauseln aufgeführt ist, wird die Exception als unbehandelt betrachtet, und die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung ("Exception in thread ...").'},
     {'question': 'Was ermöglicht die Throw-Anweisung in Java?', 'answer': 'Die Throw-Anweisung in Java ermöglicht es, Ausnahmesituationen vom Programm selbst zu erkennen und eine entsprechende Exception-Klasse zu instanziieren, um die Verantwortung für die Behandlung von Ausnahmen von der virtuellen Maschine auf das Programm selbst zu verlagern.'},
     {'question': 'Was muss eine Methode tun, wenn sie eine Exception aufruft, die von einer anderen Methode geworfen wird?', 'answer': 'Eine Methode, die eine Exception aufruft, die von einer anderen Methode geworfen wird, muss den Aufruf entweder in einen Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält, oder selbst deklarieren, dass sie die Exception behandelt oder weiterwirft.'},
     {'question': 'Was muss eine Methode tun, wenn sie eine Exception aufruft, die sie nicht behandeln kann?', 'answer': 'Wenn eine Methode eine Exception aufruft, die sie nicht behandeln kann, muss sie diese Exception weiterwerfen oder sie in einem Try-Catch-Block einschließen, der die erforderliche Catch-Klausel enthält.'},
     {'question': 'Was ist der Unterschied zwischen Exceptions und Errors in Java?', 'answer': 'Exceptions und Errors sind beides Unterklassen von Throwable, aber Errors sollten nicht abgefangen werden und führen zu einem sofortigen Programmabbruch. Exceptions sind checked und müssen abgefangen werden, während Errors unchecked sind und nicht abgefangen werden sollten. Auslassungszeichen in Java werden zur Formulierung einer Invariante verwendet und wurden früher zur Emulation der mittlerweile vorhandenen Assert-Anweisung verwendet. Auch heute sollte man Errors eigentlich nur während der Testphase eines Programms einsetzen.'},
     {'question': 'Was passiert, wenn Programme auf mehrere Pakete aufgeteilt werden?', 'answer': 'Wenn Programme auf mehrere Pakete aufgeteilt werden und zwischen den Paketen Abhängigkeiten bestehen, sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente jedoch für alle gleichermaßen sichtbar machen. Ein Programm kann also keine andere (eingeschränktere) öffentliche Schnittstelle haben als die Summe seiner Pakete.'},
     {'question': 'Warum führen Abhängigkeiten zwischen Paketen zu öffentlichen Deklarationen?', 'answer': 'Wenn zwischen Paketen Abhängigkeiten bestehen, sind hierfür öffentliche Deklarationen erforderlich, die die so deklarierten Programmelemente für alle gleichermaßen sichtbar machen.'},
     {'question': 'Was ist der Unterschied zwischen Paketen und Modulen?', 'answer': 'Der Unterschied zwischen Paketen und Modulen besteht darin, dass Module neben einer öffentlichen Schnittstelle auch eine private Schnittstelle haben, die für andere Module nicht sichtbar ist, wodurch die Kapselung von Details gewährleistet wird.'},
     {'question': 'Was wird durch die Moduldefinition in Java erzwungen?', 'answer': 'Die Einhaltung der Schnittstellenspezifikationen wird sowohl zur Übersetzungszeit als auch zur Laufzeit erzwungen. Zudem wird der reflektive Zugriff auf Programmelemente kontrolliert, was die Sicherheit von Java-Programmen erhöht.'},
     {'question': 'Was ermöglicht das Stream-Framework von Java?', 'answer': 'Das Stream-Framework von Java ermöglicht eine besonders effiziente Ausführung für viele Pipelines, indem jedes Element einer Datenquelle nur einmal angefragt wird und die interne Speicherung von Zwischenergebnissen automatisch gering gehalten wird. Es kann auch bestimmt werden, ob die Verarbeitung der Pipeline parallel oder sequenziell erfolgt.'},
     {'question': 'Welche Vorteile bietet die Verwendung von Interfaces in Java?', 'answer': 'Die Verwendung von Interfaces in Java ermöglicht die Bereitstellung verschiedener Sichten auf Objekte, die von Klassen implementiert werden. Dies kann dazu beitragen, den Zugriff auf die Methoden eines Objekts zu beschränken oder die Austauschbarkeit von Klassen zu verbessern.'},
     {'question': 'Welche Unterschiede gibt es zwischen der Deklaration eines Interfaces und einer Klasse?', 'answer': 'Die Unterschiede zwischen der Deklaration eines Interfaces und einer Klasse sind: Verwendung des Schlüsselworts "interface" anstelle von "class". Fehlen von Felddeklarationen in Interfaces. In Interfaces folgt auf die Methodendeklaration lediglich ein abschließendes Semikolon, ohne Implementierung.'},
     {'question': 'Welchen Vorteil bietet die Verwendung von Interfaces bei der Verwendung von Variablen?', 'answer': 'Die Verwendung von Interfaces ermöglicht es, Methoden und Felder einer Instanz vor anderen Instanzen zu verbergen. Durch die Deklaration von Variablen mit dem Interface als Typ kann der Zugriff auf bestimmte Methoden und Felder beschränkt werden.'},
     {'question': 'Was ist nominale Typkonformität, und welche Vor- und Nachteile hat sie?', 'answer': 'Nominale Typkonformität bedeutet, dass die Subtypbeziehung explizit deklariert werden muss. Dies hat den Vorteil der Filterfunktion, aber den Nachteil, dass Subtypen ihre Supertypen namentlich kennen müssen, was bei verteilten Anwendungen problematisch sein kann.'},
     {'question': 'Welche Vorteile bietet das Stream-Framework von Java im Vergleich zu naiven Implementierungen von Pipelines?', 'answer': 'Das Stream-Framework von Java ermöglicht für viele Pipelines eine besonders effiziente Ausführung. Es minimiert die Anzahl der Iterationen, reduziert die interne Speicherung von Zwischenergebnissen und erlaubt die Auswahl zwischen paralleler und sequenzieller Verarbeitung der Pipeline. Dennoch ist die Performanz von Java-Pipelines nicht leicht vorherzusagen und erfordert Erfahrung und Kenntnisse der Implementierung.'},
     {'question': 'Welche Vorteile bieten Typtests in Kombination mit bedingten Umwandlungen?', 'answer': 'Typtests in Kombination mit bedingten Umwandlungen bilden die typsichere Variante der Typumwandlung und helfen, Laufzeitfehler zu vermeiden.'},
     {'question': 'Welche Vorteile bietet die Verwendung von Typinferenz bei generischen Methoden?', 'answer': 'Die Verwendung von Typinferenz bei generischen Methoden erleichtert die Verwendung, da der tatsächliche Typparameter nicht immer explizit angegeben werden muss, was den Code lesbarer macht.'},
     {'question': 'Warum ist die oben gezeigte Form der Iteration in Java nicht anwendbar, wenn Collections verwendet werden, die nicht indiziert sind?', 'answer': 'Die oben gezeigte Form der Iteration mittels Indizes ist nicht anwendbar, wenn Collections verwendet werden, die nicht indiziert sind, da diese Collections keine numerischen Indizes für den Zugriff auf ihre Elemente bereitstellen.'},
     {'question': 'Was tut die Methode next() eines Iterator-Objekts?', 'answer': 'Die Methode next() eines Iterator-Objekts gibt das nächste Element der Collection zurück, über die iteriert wird.'},
     {'question': 'Wofür wird die Methode hasNext() bei der Verwendung von Iteratoren in Java eingesetzt?', 'answer': 'Die Methode hasNext() wird bei der Verwendung von Iteratoren in Java eingesetzt, um abzufragen, ob die Collection noch weitere Elemente enthält, die iteriert werden können.'},
     {'question': 'Was passiert, wenn der Bindungsalgorithmus in Java zu mehreren Methoden führt, die die Bedingungen erfüllen?', 'answer': 'Wenn der Bindungsalgorithmus zu mehreren Methoden führt, die die Bedingungen erfüllen, meldet der Compiler einen Methodenambiguitätsfehler, da die aufgerufene Methode nicht eindeutig bestimmt werden kann. Dieser Fehler wird durch Methodenaufrufe, nicht durch Methodendeklarationen, verursacht.'},
     {'question': 'In der Java-Programmierung gibt es zwei Arten von Zwischenobjekten für die Umsetzung von Zu-n-Beziehungen. Welche sind das?', 'answer': 'In der Java-Programmierung gibt es zwei Arten von Zwischenobjekten für die Umsetzung von Zu-n-Beziehungen: Arrays und Collections.'},
     {'question': 'Was bedeutet es, dass in Java jeder Typ ein Subtyp von Object ist?', 'answer': 'In Java ist jeder Typ, einschließlich Klassen und Interfaces, ein Subtyp von Object. Das bedeutet, dass alle Typen in Java die Methoden und Eigenschaften erben, die in der Object-Klasse definiert sind. Dies ermöglicht eine gewisse Einheitlichkeit und Polymorphie in der Java-Programmierung. Beachten Sie jedoch, dass Interfaces in anderen Aspekten nicht von Klassen abgeleitet werden können, obwohl sie Object erweitern.'},
     {'question': 'Warum werden Marker-Interfaces in Java manchmal durch Metadaten (Annotationen) ersetzt?', 'answer': 'Marker-Interfaces werden in Java manchmal durch Metadaten (Annotationen) ersetzt, da Metadaten eine flexiblere Möglichkeit bieten, Informationen über Klassen oder Methoden zu kennzeichnen, ohne zusätzliche Schnittstellen zu definieren. Annotations können zur Laufzeit oder zur Übersetzungszeit gelesen und interpretiert werden, während Marker-Interfaces nur zur Übersetzungszeit überprüft werden können. Dies bietet mehr Flexibilität und ermöglicht es, zusätzliche Informationen zu annotieren, ohne die Klassenhierarchie zu ändern.'},
     {'question': 'Warum sind Java-Programme weitgehend plattformunabhängig?', 'answer': 'Java-Programme sind weitgehend plattformunabhängig, da sie in Form von Bytecode vorliegen und von der JVM interpretiert werden. Solange eine JVM für ein bestimmtes Betriebssystem verfügbar ist, können Java-Programme auf jedem Rechner und Betriebssystem ausgeführt werden, für das es eine JVM gibt.'},
     {'question': 'Warum wird darauf hingewiesen, dass Java-Programmierung oft in integrierten Entwicklungsumgebungen (IDEs) stattfindet?', 'answer': 'Es wird darauf hingewiesen, dass Java-Programmierung oft in integrierten Entwicklungsumgebungen (IDEs) stattfindet, da diese Werkzeuge die Entwicklung erleichtern. Allerdings können IDEs aufgrund ihrer Komplexität Anfänger überwältigen.'},
     {'question': 'Warum haben Interfaces in Java seit Version 8 einen Bedeutungswandel erfahren?', 'answer': 'Interfaces in Java haben einen Bedeutungswandel erfahren, weil sie im Laufe der Zeit um zusätzliche Methoden erweitert wurden, was dazu führte, dass Klassen, die diese Interfaces implementieren, aktualisiert werden mussten. Insbesondere bei Black-Box-Frameworks, bei denen die Entwicklung von Anwendungsklassen in den Händen Dritter liegt, führte dies zu erheblichen Problemen.'},
     {'question': 'Was erlaubte Java 9 in Bezug auf Interfaces?', 'answer': 'In Java 9 wurde es erlaubt, in Interfaces auch private Methoden zu definieren. Diese privaten Methoden sind nur innerhalb des Interfaces selbst zugreifbar und dienen dazu, die Lesbarkeit von Default-Methoden zu verbessern, indem gemeinsame Teile in private Methoden ausgelagert werden können.'},
     {'question': 'Was bedeutet es, dass Java eine klassenbasierte Programmiersprache ist, und wie unterscheidet sich dies von prototypenbasierten Sprachen?', 'answer': 'Java ist klassenbasiert, was bedeutet, dass Programmierung durch die Definition von Klassen erfolgt. Im Gegensatz dazu sind prototypenbasierte Sprachen wie SMALLTALK auf Prototypenobjekten aufgebaut, und es gibt keine strikten Klassendefinitionen.'},
     {'question': 'Warum ist es wichtig, zwischen öffentlichen und nicht öffentlichen (privaten) Teilen eines Moduls zu unterscheiden?', 'answer': 'Es ist wichtig, zwischen öffentlichen und privaten Teilen eines Moduls zu unterscheiden, damit die Programmierer die Kontrolle über die Implementierung des Moduls behalten können. Indem sie sich auf eine Schnittstelle festlegen und private Teile hinter der Schnittstelle verbergen, können sie Änderungen an den verborgenen Teilen vornehmen, ohne andere Benutzer des Moduls zu beeinträchtigen.'},
     {'question': 'Ab welcher Version von Java wurde ein Modulbegriff eingeführt, der diesen Namen verdient?', 'answer': 'Ein Modulbegriff, der den Namen verdient, wurde mit Java 9 eingeführt, nach langer Vorbereitungszeit.'},
     {'question': 'Warum gibt es für mathematische Funktionen in Java die spezielle Klasse Math?', 'answer': 'Die primitiven Typen in Java sind keine Klassen, daher werden mathematische Funktionen wie sin(.) in der speziellen Klasse Math als Klassenmethoden definiert.'},
     {'question': 'Können Klassendefinitionen in Java Operatoren definieren?', 'answer': 'Nein, in Java ist es Klassendefinitionen nicht gestattet, Operatoren zu definieren wie es bei den binären Methoden in SMALLTALK der Fall ist.'},
     {'question': 'Was unterscheidet Prozeduren und Funktionen in Java?', 'answer': 'In Java können Methoden in Prozeduren und Funktionen unterteilt werden. Der einzige Unterschied besteht darin, dass Prozeduren keine Rückgabewerte haben und daher den Rückgabetyp "void" deklarieren.'},
     {'question': 'Wozu dienen Pakete in Java?', 'answer': 'Pakete in Java dienen der Sammlung von Klassen und dienen gleichzeitig als Namensräume für diese. Sie ermöglichen die Organisation von Klassen und bieten zugleich laxere Zugriffsbeschränkungen für Klassen innerhalb desselben Pakets.'},
     {'question': 'Warum sind Klassenliterale in Java eher selten anzutreffen?', 'answer': 'Klassenliterale sind in Java eher selten anzutreffen, da Klassennamen auch direkt in Java-Programmen verwendet werden können, beispielsweise als Empfänger beim Aufruf von Klassenmethoden oder in Typtests wie "instanceof".'},
     {'question': 'Warum können nicht alle Typprüfungen in Java zur Übersetzungszeit durchgeführt werden?', 'answer': 'Nicht alle Typprüfungen können in Java zur Übersetzungszeit durchgeführt werden, da einige Typprüfungen erst zur Laufzeit notwendig sind und nicht im Voraus bekannt sind.'},
     {'question': 'Was bedeutet es, wenn eine Klasse in Java als abstrakt deklariert wird?', 'answer': 'Wenn eine Klasse in Java als abstrakt deklariert wird, bedeutet dies, dass sie nicht instanziierbar ist. Es können keine Objekte dieser Klasse erstellt werden.'},
     {'question': 'Warum ist es eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren?', 'answer': 'Es ist eine gute Praxis, entweder alle Klassen als abstrakt oder als final zu deklarieren, um das Prinzip der abstrakten Generalisierung zu fördern und Probleme von ausschließlich vererbungsgetriebenen Klassenhierarchien zu vermeiden.'},
     {'question': 'Warum wird das Schlüsselwort "abstract" in Interfaces automatisch angenommen?', 'answer': 'Das Schlüsselwort "abstract" wird in Interfaces automatisch angenommen, da Interfaces zunächst weder Implementierungen noch Objekte liefern. Sie dienen der Definition von Schnittstellen und Typen.'},
     {'question': 'Kann eine Klasse mehrere Interfaces gleichzeitig implementieren?', 'answer': 'Ja, eine Klasse kann mehrere Interfaces gleichzeitig implementieren, indem die entsprechenden Interface-Namen durch Kommata getrennt angegeben werden. In diesem Fall müssen die Methoden in der Klasse zumindest als abstrakt deklariert werden.'},
     {'question': 'An welches Konzept in Java ist die Typkonformität und die Zuweisungskompatibilität unter Referenztypen gebunden?', 'answer': 'Die Typkonformität und die Zuweisungskompatibilität unter Referenztypen in Java sind an das Konzept des Subtypings gebunden.'},
     {'question': 'Ist Java eine Sprache mit einem strengen Typsystem, und was bedeutet das?', 'answer': 'Ja, Java ist eine Sprache mit einem strengen Typsystem, was bedeutet, dass alle Typfehler entweder während der Übersetzung durch den Compiler oder während der Laufzeit erkannt werden, jedoch immer zum frühest möglichen Zeitpunkt, nämlich bei einer Wertzuweisung, bei der eine Typinvariante verletzt wird.'},
     {'question': 'Was passiert, wenn kein Konstruktor in Java definiert wird?', 'answer': 'Wenn kein Konstruktor in Java definiert wird, verwendet Java standardmäßig den impliziten Standardkonstruktor, der parameterlos ist und eine neue Instanz der Klasse erzeugt.'},
     {'question': 'Werden Konstruktoren in Java vererbt?', 'answer': 'Nein, Konstruktoren werden in Java nicht vererbt. Stattdessen wird der Standardkonstruktor einer Klasse automatisch aufgerufen, wenn eine Instanz einer ihrer Subklassen erzeugt wird.'},
     {'question': 'Was passiert, wenn der Typ der geworfenen Exception nicht in einer Catch-Klausel aufgeführt ist?', 'answer': 'Wenn der Typ der geworfenen Exception nicht in einer Catch-Klausel aufgeführt ist, wird die Exception als unbehandelt betrachtet. Die nächst umgebende Klammer wird nach einer passenden Behandlung durchsucht. Wenn keine geeignete Behandlung gefunden wird, führt dies zu einem Programmabbruch mit einer entsprechenden Fehlermeldung ("Exception in thread ...").'},
     {'question': 'Was unterscheidet Checked Exceptions und Unchecked Exceptions in Java?', 'answer': 'Der Hauptunterschied besteht darin, dass Checked Exceptions eine explizite Deklaration im Methodenkopf oder eine Behandlung innerhalb der Methode erfordern, während Unchecked Exceptions dies nicht tun. Checked Exceptions werden von Exception-Klassen abgeleitet, die nicht von RuntimeException abgeleitet sind, während Unchecked Exceptions von Exception-Klassen abgeleitet werden, die von RuntimeException abgeleitet sind. Checked Exceptions sollen den Programmierer auf mögliche Ausnahmesituationen hinweisen, während Unchecked Exceptions oft schwer vorhersehbar sind und überall auftreten können.'},
     {'question': 'Warum funktioniert der ursprüngliche Ansatz von Java, bei dem alle Klassen eines Programms zu einem Paket zusammengefasst werden können, nicht mehr, wenn Programme in mehrere Pakete aufgeteilt werden?', 'answer': 'Der ursprüngliche Ansatz von Java, bei dem alle Klassen eines Programms zu einem Paket zusammengefasst werden können, funktioniert nicht mehr, wenn Programme in mehrere Pakete aufgeteilt werden, weil Abhängigkeiten zwischen den Paketen öffentliche Deklarationen erfordern, die dann jedoch alle Programmelemente für jeden sichtbar machen, was die Modularität einschränkt.'},
     {'question': 'Was wurde mit Java 9 eingeführt, um das Problem der Modularität in Java zu lösen?', 'answer': 'Mit Java 9 wurde ein eigenes Modulkonzept eingeführt, das über Klassen und Paketen steht. Ein Modul in Java 9 ist eine Menge von Paketen, die über eine Moduldeklaration eine gemeinsame Schnittstelle spezifiziert. Die Moduldeklaration umfasst den Namen des Moduls, die angebotene Schnittstelle und die benötigte Schnittstelle.'},
     {'question': 'Warum führt die Zuweisung von List<Integer> zu List<Object> zu einem statischen Typfehler in Java?', 'answer': 'Die Zuweisung von List<Integer> zu List<Object> führt zu einem statischen Typfehler in Java, weil bei generischen Typen nicht automatisch eine Zuweisungskompatibilität zwischen unterschiedlichen generischen Typen besteht, selbst wenn die Typen, die sie parametrisieren, zueinander in Beziehung stehen. Dies erhöht die Typsicherheit zur Übersetzungszeit.'},
     {'question': 'Warum könnte eine Parametrisierung von "Comparable" vorteilhaft sein?', 'answer': 'Eine Parametrisierung von "Comparable" könnte vorteilhaft sein, um die Flexibilität bei der Verwendung von Vergleichen zu erhöhen. Es ermöglicht, dass Objekte mit verschiedenen, aber kompatiblen Typen miteinander verglichen werden können.'},
     {'question': 'Was würde die Deklaration "interface Comparable<T extends T>" bedeuten?', 'answer': 'Die Deklaration "interface Comparable<T extends T>" würde bedeuten, dass der Typparameter "T" vom gleichen Typ sein muss wie der Typparameter "T" selbst, was in der Praxis keine sinnvolle Einschränkung ist.'},
     {'question': 'Warum ist die Bedingung, dass zu vergleichende Elemente vom gleichen Typ sein müssen, zu restriktiv?', 'answer': 'Die Bedingung, dass zu vergleichende Elemente vom gleichen Typ sein müssen, ist zu restriktiv, weil es Fälle gibt, in denen Objekte unterschiedlicher, aber verwandter Typen miteinander verglichen werden sollen. Eine flexiblere Einschränkung ist erforderlich.'},
     {'question': 'Was bedeutet "Comparable<? super E>"?', 'answer': '"Comparable<? super E>" bedeutet, dass der Parametertyp von "Comparable" mindestens "E" umfassen muss, kann jedoch auch allgemeiner sein, z. B. "Object". Das "?" in der Typ-Wildcard steht für einen beliebigen Typen, der die Bedingung erfüllt, in diesem Fall ein Supertyp von "E".'},
     {'question': 'Warum ist "Comparable<? super E>" flexibler als "Comparable<T extends T>"?', 'answer': '"Comparable<? super E>" ist flexibler, weil es eine größere Bandbreite von Typen zulässt, die miteinander verglichen werden können. Es erlaubt, dass Objekte vom Typ "E" mit Objekten anderer, aber verwandter Typen verglichen werden, was die Verwendung von "Comparable" vielseitiger macht.'},
     {'question': 'Warum wurden Typ-Wildcards (Wildcard-Typen) in Java eingeführt?', 'answer': 'Typ-Wildcards wurden eingeführt, um eine flexiblere Form der Zuweisungskompatibilität für generische Typen zu ermöglichen, insbesondere bei der Verwendung von Collections mit unterschiedlichen Typparametern.'},
     {'question': 'Was bedeutet es, wenn ein Typ mit einer Typ-Wildcard (z. B. List<?>) deklariert wird?', 'answer': 'Wenn ein Typ mit einer Typ-Wildcard deklariert wird, bedeutet dies, dass die Variable dieses Typs Objekte beliebigen, aber unbekannten Typparameters akzeptieren kann. Es ist eine abstrakte Deklaration.'},
     {'question': 'Warum sind "ArrayList<Integer>" und "ArrayList<String>" trotz "Integer" und "String" als Subtypen von "Comparable" nicht zuweisungskompatibel mit "ArrayList<Comparable>"?', 'answer': '"ArrayList<Integer>" und "ArrayList<String>" sind nicht zuweisungskompatibel mit "ArrayList<Comparable>", weil generische Typen in Java keine kovariante Zuweisung von Subtypen erlauben. Dies wurde durch die Einführung von Typ-Wildcards gelöst.'},
     {'question': 'Warum sollten Klassenbibliotheken unabhängig von der Sprachdefinition sein und austauschbar sein?', 'answer': 'Klassenbibliotheken sollten unabhängig von der Sprachdefinition sein und austauschbar sein, um die Flexibilität und Portabilität von Software zu gewährleisten. Wenn Klassenbibliotheken eng an die Sprachdefinition gebunden sind, könnte dies dazu führen, dass eine Software nur auf einer bestimmten Plattform oder mit einer bestimmten Sprachversion funktioniert. Durch die Unabhängigkeit von der Sprachdefinition können Klassenbibliotheken in verschiedenen Umgebungen verwendet werden und die Softwareentwicklung erleichtern.'},
     {'question': 'Warum sind einige Klassen in Java von der Sprache fest vorgegeben und können nicht beliebig ersetzt werden?', 'answer': 'In Java sind einige Klassen von der Sprache fest vorgegeben, um die grundlegende Funktionalität der Sprache sicherzustellen und um sicherzustellen, dass bestimmte wichtige Aufgaben immer erfüllt werden können. Zum Beispiel sind Klassen wie Object und String integraler Bestandteil der Java-Sprache und können nicht ersetzt werden, da sie grundlegende Funktionen wie die Objekterstellung und Zeichenkettenmanipulation ermöglichen. Diese Klassen stellen die Grundlage für die Entwicklung von Java-Programmen dar und sind daher unverzichtbar.'},
     {'question': 'Was bedeutet es, wenn ein Member in Java als "static" deklariert wird?', 'answer': 'Wenn ein Member als "static" deklariert wird, bedeutet dies, dass er sich nicht auf Instanzen der Klasse bezieht, sondern auf die Klasse selbst. Es handelt sich um Klassenvariablen und -methoden.'},
     {'question': 'Warum sind "static"-Felder in Java keine Konstanten?', 'answer': '"static"-Felder in Java sind nicht automatisch Konstanten, da sie mehrfach geändert werden können. Konstanten werden in Java stattdessen durch das Schlüsselwort "final" gekennzeichnet.'},
     {'question': 'Was unterscheidet Call by Value und Call by Reference, und wie wird dies in Java gehandhabt?', 'answer': 'In Java wird Call by Value verwendet, was bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können. Dies ist eine Einschränkung im Vergleich zu Call by Reference, bei dem eine Methode auf den ursprünglichen Wert einer Variablen zugreifen und ihn ändern kann.'},
     {'question': 'Was versteht man unter einem Type cast (Typumwandlung)?', 'answer': 'Ein Type cast ist der Vorgang, bei dem einem Programmelement ein anderer Typ aufgezwungen wird als der, mit dem es deklariert wurde.'},
     {'question': 'Warum werden Interfaces in Java als einer der wichtigsten Beiträge zur objektorientierten Programmierung angesehen?', 'answer': 'Interfaces in Java sind einer der wichtigsten Beiträge zur objektorientierten Programmierung, da sie die Möglichkeit bieten, Schnittstellen und Polymorphismus zu implementieren, was die Flexibilität und Erweiterbarkeit von Programmen erheblich verbessert.'},
     {'question': 'Warum ist die Aufteilung eines Programms in Module wichtig?', 'answer': 'Die Aufteilung eines Programms in Module ist wichtig, um die unabhängige Entwicklung von Programmteilen zu ermöglichen. Dadurch sollen Abhängigkeiten zwischen den Modulen minimiert werden, insbesondere in Bezug auf Änderungen.'},
     {'question': 'Was bedeutet Abhängigkeit zwischen Modulen in der Programmierung?', 'answer': 'In der Programmierung bedeutet Abhängigkeit zwischen Modulen in der Regel Änderungsabhängigkeit. Wenn sich in einem Modul etwas ändert, kann dies Auswirkungen auf andere davon abhängige Module haben. Abhängigkeiten ergeben sich oft aus Benutzungsbeziehungen und können in der objektorientierten Programmierung auch Vererbungsabhängigkeiten einschließen.'},
     {'question': 'Sind zirkuläre Abhängigkeiten zwischen Klassen in Java erlaubt?', 'answer': 'Ja, zirkuläre Abhängigkeiten zwischen Klassen sind in Java zunächst erlaubt. Dies bedeutet, dass sich zwei Klassen wechselseitig importieren können. Jedoch wird dies in der Softwareentwicklung vermieden, da wechselseitige Abhängigkeiten eine enge Kopplung zwischen Modulen anzeigen, die vermieden werden sollte. Für Java-Module sind zirkuläre Abhängigkeiten jedoch verboten.'},
     {'question': 'Warum sind zirkuläre Abhängigkeiten in Java-Modulen verpönt?', 'answer': 'Zirkuläre Abhängigkeiten in Java-Modulen sind verpönt, da sie eine enge Kopplung zwischen Modulen dokumentieren und dies vermieden werden sollte. Das Verbot zirkulärer Abhängigkeiten erfordert eine sorgfältige Planung der Modularisierung, was generell von großem Wert ist.'},
     {'question': 'Wem obliegt es, zu definieren, was passieren soll, wenn der Typtest fehlschlägt?', 'answer': 'Es obliegt der Programmiererin, zu definieren, was passieren soll, wenn der Typtest fehlschlägt, d.h., wenn das Objekt nicht den geforderten Typ hat.'},
     {'question': 'Wo können Typvariablen (formale Typparameter) in Java verwendet werden?', 'answer': 'Typvariablen können sowohl in Typdefinitionen als auch in Methodendefinitionen in Java verwendet werden.'},
     {'question': 'Warum könnte es sinnvoll sein, den Typparameter einer generischen Methode mit "extends" zu beschränken?', 'answer': 'Das Beschränken des Typparameters einer generischen Methode mit "extends" kann sinnvoll sein, um die Verwendbarkeit oder die Typsicherheit der mit dem Parameter übergebenen Objekte zu erhöhen, da deren Typ innerhalb der Methode bekannter ist.'},
     {'question': 'Warum könnte es in einigen Fällen sinnvoll sein, ein Typ-Wildcard anstelle eines Typparameters in einer generischen Methode zu verwenden?', 'answer': 'In einigen Fällen, in denen der Typparameter innerhalb der Methode nicht verwendet wird, kann es sinnvoll sein, anstelle des Typparameters ein (entsprechend beschränktes) Typ-Wildcard in der generischen Methode zu verwenden, um den Code einfacher und lesbarer zu gestalten.'},
     {'question': 'Was bewirkt die Break-Anweisung in Java?', 'answer': 'Die Break-Anweisung in Java bewirkt, dass eine Schleife oder ein Switch-Statement sofort verlassen wird. Sie kann optional mit einem Label versehen werden, um eine äußere Schleife oder ein äußeres Switch-Statement zu verlassen.'},
     {'question': 'Was bedeutet es, dass Java eine stark typisierte Sprache ist?', 'answer': 'Java ist eine stark typisierte Sprache, was bedeutet, dass alle Ausdrücke einen Typ haben und Variablen bei ihrer Deklaration einen Typ angeben müssen.'},
     {'question': 'Was unterscheidet eine Wertzuweisung und eine Zuweisung von Referenzen in Java?', 'answer': 'Bei der Wertzuweisung wird der tatsächliche Wert einer Variable kopiert, während bei der Zuweisung von Referenzen nur die Referenz auf das Objekt kopiert wird.'},
     {'question': 'Gibt es in Java "Call by reference"?', 'answer': 'Nein, in Java gibt es kein "Call by reference", sondern nur "Call by value". Auch wenn Variablen Referenztypen haben, wird bei Methodenaufrufen immer eine Kopie des Zeigers an die formalen Parameter übergeben.'},
     {'question': 'Warum ist beschränkter parametrischer Polymorphismus wichtig?', 'answer': 'Beschränkter parametrischer Polymorphismus ist wichtig, um sicherzustellen, dass die Objekte, die von einem generischen Typ erzeugt werden, bestimmte Eigenschaften oder Methoden haben. Dadurch wird die Typsicherheit erhöht und es können bestimmte Annahmen über die Objekte gemacht werden.'},
     {'question': 'Was bedeutet die Einschränkung "<E extends Comparable<E>>" in der Klasse "SortedList"?', 'answer': 'Die Einschränkung "<E extends Comparable<E>>" bedeutet, dass der Typparameter "E" auf Typen beschränkt ist, die das Interface "Comparable" implementieren oder davon erben. Dies stellt sicher, dass Objekte vom Typ "E" die Methode "compareTo(.)" implementieren können, die vom Interface "Comparable" vorgeschrieben wird.'},
     {'question': 'Warum wird "SortedList<String>" als gültige Deklaration betrachtet, aber "SortedList<Integer>" nicht?', 'answer': '"SortedList<String>" wird als gültige Deklaration betrachtet, weil "String" ein Subtyp von "Comparable" ist und daher die Bedingung "<E extends Comparable<E>>" erfüllt. "SortedList<Integer>" wird hingegen nicht als gültige Deklaration betrachtet, da "Integer" nicht "Comparable<Integer>" implementiert, was nicht der Einschränkung entspricht.'},
     {'question': 'Ist "SortedList<String>" ein Subtyp von "SortedList<Comparable>"?', 'answer': 'Nein, "SortedList<String>" ist kein Subtyp von "SortedList<Comparable>". Die Einschränkung "<E extends Comparable<E>>" in "SortedList" sorgt dafür, dass der Typparameter "E" ein Subtyp von "Comparable<E>" sein muss, aber sie schafft keine Subtypenbeziehung zwischen den "SortedList"-Instanzen selbst.'},
     {'question': 'Ist es in Java möglich, generische Variablen zu deklarieren?', 'answer': 'Ja, es ist in Java möglich, generische Variablen zu deklarieren.'},
     {'question': 'Was passiert, wenn eine Variable mit einem Typ-Wildcard deklariert wird?', 'answer': 'Wenn eine Variable mit einem Typ-Wildcard deklariert wird, kann ihr eine Instanz eines beliebigen konkreten Typs zugewiesen werden, der den Anforderungen der Wildcard entspricht.'},
     {'question': 'Führen generische Variablendeklarationen einen neuen Typ ein?', 'answer': 'Nein, generische Variablendeklarationen führen keinen neuen Typ ein. Der durch ein Typ-Wildcard als tatsächlichen Parameter eingesetzte Typ ist ein konkreter Typ.'},
     {'question': 'Warum ist die Verwechslung von equals(.) und == ein häufiger Programmierfehler in Java?', 'answer': 'Die Verwechslung von equals(.) und == ist auch in Java ein häufiger Programmierfehler, da sie unterschiedliche Bedeutungen haben. equals(.) prüft die Gleichheit von Objekten, während == die Identität überprüft.'},
     {'question': 'Wofür steht das Gleichheitszeichen = in Java?', 'answer': 'Das Gleichheitszeichen = in Java steht für die Wertzuweisung, nicht für die Überprüfung der Gleichheit von Objekten.'},
     {'question': 'Was passiert standardmäßig, wenn man einen neuen Thread in Java startet?', 'answer': 'Standardmäßig führt ein Thread in Java keine spezifischen Aufgaben aus und endet sofort. Dies geschieht, weil die Methode run() in der Klasse Thread standardmäßig leer ist.'},
     {'question': 'Was ermöglicht Java in Bezug auf Arrays in Bezug auf Wert- und Referenztypen?', 'answer': 'In Java ist es möglich, sowohl Arrays von primitiven (Wert-)Typen als auch von Referenztypen zu erstellen.'},
     {'question': 'Warum gestattet Java die Zuweisung von einem Array vom Typ A[] an eine Variable vom Typ Object[]?', 'answer': 'Diese Zuweisungskompatibilität ermöglicht eine flexiblere Programmierung, insbesondere in Situationen, in denen der statische Typ der Array-Elemente nicht genau festgelegt ist, aber nach oben beschränkt werden soll, wie im Beispiel mit dem Interface Comparable und der Methode sort. Dieser Kompromiss zwischen statischer und dynamischer Typprüfung bietet Flexibilität beim Programmieren.'},
     {'question': 'Was ist der Unterschied zwischen C-Sharp und Java?', 'answer': 'C-Sharp und Java sind beides objektorientierte Programmiersprachen, aber C-Sharp war ein Pionier für Spracherweiterungen, die es inzwischen auch in Java gibt, wie zum Beispiel Attribute und Lambda-Ausdrücke. Die Gefahr besteht jedoch darin, dass sich die beiden Sprachen gegenseitig übertrumpfen könnten und irgendwann jemand auf die Idee kommt, eine neue Sprache zu destillieren, die die besten Eigenschaften beider Sprachen vereint. Vielleicht wird bei der Gelegenheit auch endlich mit dem C-Erbe aufgeräumt und die fürchterliche Syntax von C-Sharp entsorgt.'},
     {'question': 'Was ist der Unterschied zwischen parametrischen und unparametrischen Typen in Java?', 'answer': 'Unparametrisierte Typen in Java werden nicht aus eigenständigen Typdefinitionen hervorgehen, sondern mit der Definition einer Klasse oder eines Interfaces einhergehen. Parametrische Typen hingegen werden nicht separat definiert, sondern sind das Produkt parametrischer Klassen- bzw. Interfacedefinitionen. Jede Klasse, deren Definition einen Typparameter enthält, steht tatsächlich für eine ganze Menge von Typen, nämlich einen pro möglicher Belegung des Typparameters. Insbesondere führt die „Instanziierung“ einer parametrisch definierten Klasse mit einem tatsächlichen Typparameter nur zu einem neuen Typ, aber nicht zu einer neuen Klasse. Deswegen sind auch die Klassenvariablen und -methoden einer parametrischen Klasse für alle Instanzen ihrer generierten Typen gleich; Instanzvariablen und -methoden können dagegen den Typparameter als Typ verwenden und sich insofern unterscheiden.'},
     {'question': 'Warum können in Java Arrays über einen bestimmten Elementtyp gebildet werden?', 'answer': 'In Java können Arrays über einen bestimmten Elementtyp gebildet werden, weil es in Java eine Sprachdefinition für Arrays gibt, die eine solche Möglichkeit vorsieht. Dies ermöglicht eine bessere Typsicherheit und Effizienz, da die Elemente eines Arrays alle vom gleichen Typ sind und somit keine Typumwandlung bei der Zuweisung oder beim Zugriff notwendig ist.'},
     {'question': 'Was ist der Vorteil von generischen Typen?', 'answer': 'Der Vorteil von generischen Typen ist, dass sie es ermöglichen, bei der Deklaration einer Variablen den Elementtyp mit anzugeben, was die Typsicherheit erhöht und die Notwendigkeit von expliziten Typumwandlungen verringert.'},
     {'question': 'Was bedeuten spitze Klammern in Java?', 'answer': 'Spitze Klammern < > werden in Java verwendet, um Typparameter in generischen Klassen oder Methoden zu definieren. Sie werden auch als Diamant-Operator bezeichnet.'},
     {'question': 'Was bedeutet nominales Subtyping?', 'answer': 'Nominales Subtyping bedeutet, dass eine Variable eines bestimmten Typs auch einem Untertyp dieses Typs zugewiesen werden kann. In Java-Syntax wird dies durch die Deklaration List<Integer> liste; sichergestellt, wodurch die Variable liste auch mit einem ArrayList<Integer>-Objekt initialisiert werden kann.'},
     {'question': 'Warum sollte List<Integer> nicht unbedingt ein Subtyp von List<Object> sein?', 'answer': 'Der Kompromiss, dass List<Integer> ein Subtyp von List<Object> sein sollte, wurde offenbar nicht weiter fortgeführt, weil Integer ein Subtyp von Object ist. Das liegt daran, dass dies zu inkonsistenten Typzuweisungen führen könnte, was die Typsicherheit des Programms beeinträchtigen würde.'},
     {'question': 'Was bedeutet es, wenn der Parametertyp von "Comparable" mindestens "E" umfassen muss?', 'answer': 'Das bedeutet, dass die Objekte der sortierten Liste mit Objekten vom Typ "E" oder mit Objekten eines Supertyps von "E" vergleichbar sein müssen.'},
     {'question': 'Was ist der Unterschied zwischen der Verwendung von Zusicherungen in EIFFEL und Java?', 'answer': 'In EIFFEL sind Zusicherungen in Form von Vor- und Nachbedingungen bei Methodenaufrufen integriert, während in Java die Assert-Anweisung verwendet wird, die es erlaubt, Zusicherungen zur Laufzeit auszuwerten, aber keine von der Sprachdefinition vorgesehenen Orte für ihre Platzierung gibt.'},
     {'question': 'Was passiert mit Zusicherungen (Vor- und Nachbedingungen) bei der Redefinition einer Methode in EIFFEL?', 'answer': 'Bei der Redefinition einer Methode in EIFFEL dürfen die Vorbedingungen nur abgeschwächt und die Nachbedingungen nur verschärft werden. Die Sprachdefinition von EIFFEL stellt sicher, dass diese Bedingung eingehalten wird, indem die Vorbedingung einer redefinierten Methode implizit disjunktiv mit der geerbten Vorbedingung und die redefinierte Nachbedingung implizit konjunktiv mit der geerbten verknüpft wird.'},
     {'question': 'Was ist der Unterschied zwischen Vor- und Nachbedingungen in EIFFEL?', 'answer': 'In EIFFEL sind Vorbedingungen (preconditions) Bedingungen, die vor der Ausführung einer Methode erfüllt sein müssen, während Nachbedingungen (postconditions) Bedingungen sind, die nach der Ausführung einer Methode erfüllt sein müssen. Vorbedingungen werden verwendet, um sicherzustellen, dass die Methode nur dann aufgerufen wird, wenn die Voraussetzungen erfüllt sind, während Nachbedingungen sicherstellen, dass die Methode das gewünschte Ergebnis liefert.'},
     {'question': 'Was ermöglicht EIFFEL im Vergleich zu anderen Typsystemen?', 'answer': 'EIFFEL ermöglicht es, nahezu beliebige Bedingungen für Variablen- und Rückgabewerte von Methoden auszudrücken, die sowohl auf andere Werte als auch auf den zeitlichen Verlauf (vorher/nachher) Bezug nehmen können. Im Gegensatz zu anderen Typsystemen, die sich jeweils auf die möglichen Werte einer Variablen beziehen und dabei voneinander und von der Zeit unabhängig bleiben.'},
     {'question': 'Wer ist der Erfinder der Programmiersprache EIFFEL?', 'answer': 'Der Erfinder der Programmiersprache EIFFEL ist Bertrand Meyer.'},
     {'question': 'Warum ist EIFFEL kein größerer Erfolg beschieden?', 'answer': 'Es gibt mehrere Gründe, warum EIFFEL kein größerer Erfolg beschieden ist. Dazu gehören die anfänglich unzureichende Implementierung der Werkzeuge, insbesondere des Compilers, die Natur von Bertrand Meyer, der sich mit seiner Kompromisslosigkeit nicht nur Freunde gemacht hat, und der Spagat zwischen kommerzieller Einsetzbarkeit und akademischer Eignung. Zudem ist das Typsystem von EIFFEL nicht unbedingt zur Akzeptanz beigetragen. Trotzdem hat EIFFEL neben Smalltalk am ehesten das Format und die Art, wie man über das Programmieren denkt, beeinflusst.'},
     {'question': 'Was ist der Unterschied zwischen Wert- und Referenztypen in C-Sharp?', 'answer': 'In C-Sharp werden primitiven Typen als Werttypen implementiert, die auf dem Stack abgelegt und bei der Übergabe an eine Methode kopiert werden. Referenztypen werden dagegen auf dem Heap abgelegt und bei der Übergabe an eine Methode nur der Verweis kopiert.'},
     {'question': 'Was ist der Unterschied zwischen Werttypen und Referenztypen in C-Sharp?', 'answer': 'Werttypen werden direkt auf dem Stack gespeichert und enthalten einen Wert, während Referenztypen auf dem Heap gespeichert werden und eine Referenz auf ein Objekt enthalten. Werttypen werden beim Zuweisen oder Übergeben an eine Methode kopiert, während Referenztypen nur eine Kopie der Referenz erstellen.'},
     {'question': 'Was ist der Unterschied zwischen einer Klassenhierarchie und der Einteilung der verschiedenen Arten von Typen in C-Sharp?', 'answer': 'Die Klassenhierarchie ist eine Vererbungshierarchie, die alle Typen von System.Object ableitet und das Typsystem von C-Sharp vereinheitlicht. Die Einteilung der verschiedenen Arten von Typen in C-Sharp ist eine Einteilung, die die verschiedenen Arten von Typen in C-Sharp in ValueType, Delegate und class einteilt.'},
     {'question': 'Was ist der Unterschied zwischen ValueType, Delegate und class in C-Sharp?', 'answer': 'ValueType ist ein Wertetyp, der von System.ValueType abgeleitet ist und auf dem Stack gespeichert wird. Delegate ist ein Verweistyp, der von System.Delegate abgeleitet ist und Delegate-Objekte repräsentiert. class ist ein Verweistyp, der von System.Object abgeleitet ist und Klassenobjekte repräsentiert.'},
     {'question': 'Was passiert, wenn ein Objekt eine Nachricht erhält, die es nicht versteht?', 'answer': 'Wenn ein Objekt eine Nachricht erhält, die es nicht versteht, wird eine Methode Not a Understand aufgerufen, die eine Fehlermeldung ausgeben kann.'},
     {'question': 'Wozu dient die liberale Zuweisungskompatibilität bei generischen Typen?', 'answer': 'Die liberale Zuweisungskompatibilität bei generischen Typen ermöglicht es, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel kann so eine Methode "sort" mit Objekten verschiedener Instanzen von "ArrayList<E>" aufgerufen werden, also beispielsweise mit Objekten vom Typ "ArrayList<Integer>" und "ArrayList<String>".'},
     {'question': 'Warum ist es sinnvoll, für generische Typen eine liberalere Form der Zuweisungskompatibilität zuzulassen?', 'answer': 'Es ist sinnvoll, weil es so möglich ist, Objekte verschiedener Instanzen eines parametrisierten Typs bei einem Methodenaufruf demselben formalen Parameter zuzuweisen. Zum Beispiel kann so eine Methode "sort" mit Objekten verschiedener Instanzen von "ArrayList<E>" aufgerufen werden, also beispielsweise mit Objekten vom Typ "ArrayList<Integer>" und "ArrayList<String>".'},
     {'question': 'Was ist der Unterschied zwischen Use-site-Variance und Declaration-site-Variance?', 'answer': 'Use-site-Variance bedeutet, dass Wildcards bei der Verwendung an der Stelle definiert werden, an der sie benötigt werden, während Declaration-site-Variance bedeutet, dass Wildcards an der Stelle definiert werden, an der sie erklärt werden, wie beispielsweise in C-Sharp.'},
     {'question': 'Was erlauben per extends beschränkte Typ-Wildcards?', 'answer': 'Per extends beschränkte Typ-Wildcards erlauben eine spezielle Art des Subtypings, bei der Zuweisungen von Objekten eines Subtyps an Variablen eines Supertyps erlaubt sind, aber in der Folge schreibende Zugriffe auf Variablen, die mit dem Typparameter als Typ deklariert sind, verboten sind (lesende Zugriffe sind hingegen erlaubt).'},
     {'question': 'Was bedeutet es, wenn man sagt, dass das Subtyping mit "extends" beschränkter Wildcard-Typen kovariant ist?', 'answer': 'Das Subtyping mit "extends" beschränkter Wildcard-Typen ist kovariant, das heißt, wenn "Integer" ein Subtyp von "Number" ist, dann ist auch "List<? extends Integer>" ein Subtyp von "List<? extends Number>".'},
     {'question': 'Was bedeutet es, wenn man sagt, dass das Subtyping mit "super" beschränkter Wildcard-Typen kontravariant ist?', 'answer': 'Das Subtyping mit "super" beschränkter Wildcard-Typen ist kontravariant, das heißt, "List<? super Integer>" ist ein Supertyp von "List<? super Number>", wenn "Integer" ein Subtyp von "Number" ist.'},
     {'question': 'Was bedeutet kovarianter Subtyping von Wildcard-Typen?', 'answer': 'Kovarianter Subtyping von Wildcard-Typen bedeutet, dass wenn ein Typ S ein Subtyp von T ist, dann ist auch der mit "extends" nach oben beschränkte Wildcard-Typ "List<? extends S>" ein Subtyp von "List<? extends T>"'},
     {'question': 'Wozu dienen Zugriffsmethoden in EIFFEL?', 'answer': 'Zugriffsmethoden in EIFFEL dienen dazu, auf die privaten Instanzvariablen oder Felder einer Klasse von außen zugreifen zu können. Sie nehmen syntaktisch die Form von Variablen an, sodass der Code, der auf die Instanzvariablen zugreift, lesbarer und einfacher zu verstehen ist. Diese Zugriffsmethoden werden vom System automatisch bereitgestellt.'},
     {'question': 'Warum werden in Eiffel Zugriffsmethoden verwendet?', 'answer': 'In Eiffel werden Zugriffsmethoden verwendet, um den Zugriff auf Instanzvariablen zu ermöglichen und gleichzeitig die Datenkapselung zu gewährleisten.'},
     {'question': 'Was ermöglichen Zugriffsmethoden?', 'answer': 'Zugriffsmethoden ermöglichen das Setzen oder Lesen von Instanzvariablen, das Festlegen von Vor- und Nachbedingungen für den Zugriff auf Instanzvariablen, die Repräsentationsunabhängigkeit und das Anbieten von etwas, das wie eine Instanzvariable aussieht, ohne sich auf eine tatsächliche Instanzvariable festzulegen. Zudem gibt es in EIFFEL auch Indexer.'},
     {'question': 'Was ist der Unterschied zwischen Abfragen und Befehlen in EIFFEL?', 'answer': 'In EIFFEL werden Methoden als Routinen bezeichnet und logisch in zwei Gruppen unterteilt: Abfragen (queries) und Befehle (commands). Abfragen liefern Informationen über den Zustand von Objekten, während Befehle diesen Zustand ändern. Es ist schlechter Stil in EIFFEL (obwohl es durch die Sprachdefinition nicht verhindert wird), dass eine Abfrage Seiteneffekte hat, die den Zustand des abgefragten Objekts (des Empfängers) oder eines anderen Objekts verändern.'},
     {'question': 'Gibt es in EIFFEL die Möglichkeit Klassendefinitionen zu schachteln?', 'answer': 'Nein, in EIFFEL gibt es keine Möglichkeit, Klassendefinitionen zu schachteln (es gibt keine inneren Klassen).'},
     {'question': 'Warum sollte eine Klassenbibliothek mit den Mitteln der Sprache programmiert werden, aber von der Sprachdefinition unabhängig sein?', 'answer': 'Das hat den Vorteil, dass die Klassenbibliothek austauschbar ist und somit die Sprache flexibler einsetzbar wird.'},
     {'question': 'Warum wird in objektorientierten Sprachen oft nicht daran gehalten, Klassenbibliotheken von der Sprachdefinition unabhängig zu programmieren?', 'answer': 'Das liegt daran, dass die Sprache selbst oft bestimmte Klassen vorgibt, die nicht beliebig ersetzt werden können.'},
     {'question': 'Ist EIFFEL eine objektorientierte Programmiersprache?', 'answer': 'Ja, EIFFEL ist eine rein objektorientierte Programmiersprache, bei der der gesamte Code innerhalb von Klassen organisiert ist.'},
     {'question': 'Was ist der Unterschied zwischen Mehrfachvererbung und Einfachvererbung?', 'answer': 'Im Gegensatz zur Einfachvererbung, bei der eine Klasse nur eine Superklasse haben kann, erlaubt Mehrfachvererbung, dass eine Klasse von mehreren Superklassen erbt.'},
     {'question': 'Was kann in C-Sharp zu überladen werden?', 'answer': 'In C-Sharp ist es möglich, Operatoren wie +, -, ==, new, ( ), ||, &&, = etc. zu überladen.'},
     {'question': 'Was ist der Unterschied zwischen "ref" und "out" in C-Sharp?', 'answer': 'Bei "ref" muss die Variable, die den tatsächlichen Parameter liefert, vor dem Aufruf initialisiert worden sein, während dies bei "out" nicht der Fall ist. Dafür muss bei "out" der formale Parameter in der Methode einen Wert zugewiesen bekommen. Der Unterschied liegt also in der Richtung der Zuweisung.'},
     {'question': 'Wofür werden "ref" und "out" verwendet?', 'answer': 'Sowohl "ref" als auch "out" ermöglichen, dass eine Methode mehr als einen Rückgabewert hat. Sie werden verwendet, um mehrere Rückgabewerte in einem Objekt zu verpacken.'},
     {'question': 'Was ist der Unterschied zwischen dem Überschreiben von Methoden in Java und C-Sharp?', 'answer': 'In Java können alle Methoden überschrieben werden, während in C-Sharp dynamisch zu bindende Methoden unbedingt als solche zu deklarieren sind und eine überschreibende Methode mit dem Schlüsselwort "override" deklariert werden muss. Wenn eine Methode gleicher Signatur in einer Subklasse neu eingeführt werden soll, muss dies durch Verwendung des Schlüsselworts "new" bekanntgegeben werden. Diese Deklaration vermindert die Zahl der dynamischen Bindungen in einem Programm und markiert alle Stellen im Programm, an denen das sog. "Fragile-base-class-Problem" auftreten kann.'},
     {'question': 'Was sind die Unterschiede zwischen C-Sharp und Java in Bezug auf Sprachkonstrukte?', 'answer': 'Einige Sprachkonstrukte verwenden in C-Sharp andere Schlüsselwörter als Java, wie zum Beispiel "lock" anstatt "synchronized" und "foreach" anstatt "for" für die zweite Form von "For"-Schleifen. Andere weichen in ihrer Bedeutung leicht von denen Javas ab, wie zum Beispiel die Zulassung von "Strings" als Basis einer "Switch"-Anweisung in C-Sharp und die Notwendigkeit einer expliziten Kontrollflussanweisung am Ende jedes Zweigs. Zudem hat C-Sharp eine "Goto"-Anweisung, mit der man jedoch nicht in Blöcke hinein springen kann. Diese Unterschiede haben jedoch nichts mit Objektorientierung zu tun.'},
     {'question': 'Was bedeutet der Einsatz des Schlüsselworts "this" in Bezug auf Indexer?', 'answer': 'Im Kontext von Indexer wird das Schlüsselwort "this" missbraucht, um anzudeuten, dass bei Zugriffen auf die indizierte Instanzvariable kein Name einer Instanzvariable (eines Feldes) steht, sondern lediglich der Name des Objekts, zu dem sie gehört.'},
     {'question': 'Was bedeutet es, wenn der Indexer in C-Sharp überladen wird?', 'answer': 'Wenn der Indexer in C-Sharp überladen wird, kann ein Objekt mehrere indizierte Instanzvariablen haben. Der Zugriff erfolgt aufgrund des fehlenden Namens einzig über den Typ des Indexes. Durch das Überladen ist es wiederum möglich, nicht eine, sondern mehrere indizierte Instanzvariablen zu simulieren, wobei jedoch die Einschränkung besteht, dass der Elementtyp (der Rückgabetyp beim Überladen) gleich bleiben muss.'},
     {'question': 'Sind Konstruktoren Members in Java?', 'answer': 'Nein, Konstruktoren zählen nicht zu den Members in Java.'},
     {'question': 'Was ist der Unterschied zwischen Members und Konstruktoren in Java?', 'answer': 'Members einer Klasse sind Instanzvariablen und Instanzmethoden, während Konstruktoren keine Members sind.'},
     {'question': 'Wozu werden innere Klassen in Java verwendet?', 'answer': 'Innere Klassen in Java werden verwendet, um die enge Beziehung zwischen zwei Klassen auszudrücken. Sie werden vor allem dann sinnvoll, wenn die Existenz der inneren Klasse ohne die der äußeren sinnlos wäre. Zum Beispiel, wenn verknüpfte Listen implementiert werden, wird die Klasse der Listenelemente innerhalb der Klasse der Liste definiert. Instanzen innerer Klassen liegen immer "innerhalb" von Instanzen ihrer äußeren Klasse(n) und können über das Konstrukt "Outer this" auf diese zugreifen.'},
     {'question': 'Was bedeutet es, wenn Members in Java als "static" deklariert werden?', 'answer': 'Wenn Members in Java als "static" deklariert werden, beziehen sie sich nicht auf Objekte, sondern auf die Klasse selbst. Es handelt sich also um Klassenvariablen und -methoden, die nicht dynamisch gebunden werden.'},
     {'question': 'Was bedeutet es, wenn Members als "static" deklariert werden?', 'answer': 'Wenn Members als "static" deklariert werden, beziehen sie sich nicht auf Objekte, sondern auf die Klasse selbst. Es handelt sich also um Klassenvariablen und -methoden. Diese werden nicht dynamisch gebunden, sondern sind während der Programmausführung dauerhaft existierende, unveränderliche Gebilde, die nicht in Variablen gespeichert werden können.'},
     {'question': 'Was ist der Unterschied zwischen "static" und "final" in Java?', 'answer': '"static" deklarierte Felder sind nicht konstant, während "final" dazu verwendet wird, Variablen als Konstanten zu deklarieren. "final" bedeutet, dass einer Variablen genau einmal ein Wert zugewiesen werden darf. Im Gegensatz dazu benötigte man in Smalltalk konstante Methoden für Konstanten. "final" in Java verhindert auch, dass eine Methode in Subklassen überschrieben wird.'},
     {'question': 'Was bedeutet das Schlüsselwort "final" in Java?', 'answer': 'In Java dient das Schlüsselwort "final" dazu, Variablen als Konstanten zu deklarieren, was bedeutet, dass einer Variablen genau einmal ein Wert zugewiesen werden darf. Auf Methoden angewandt bedeutet "final", dass diese in Subklassen nicht überschrieben werden dürfen.'},
     {'question': 'Was bedeutet es, dass alle Ausdrücke korrekt typisiert sein müssen in Java?', 'answer': 'Das bedeutet, dass der Typ jedes Ergebnisses eines inneren Ausdrucks mit dem Typ des äußeren Ausdrucks, an der Stelle, an der er eingesetzt wird, zuweisungskompatibel sein muss.'},
     {'question': 'Gibt es in Java Call by Reference?', 'answer': 'Nein, in Java gibt es nur Call by Value und keine Call by Reference.'},
     {'question': 'Was ist der Unterschied zwischen Call by Value und Call by Reference in Programmiersprachen?', 'answer': 'Call by Value bedeutet, dass der Wert eines Parameters an eine Methode übergeben wird, während Call by Reference bedeutet, dass eine Referenz auf den Speicherort des Parameters übergeben wird. In Java und SMALLTALK gibt es nur Call by Value, was bedeutet, dass Methoden keinen anderen Wert für einen tatsächlichen Parameter zuweisen können.'},
     {'question': 'Was unterscheidet EIFFEL von SMALLTALK und C-Sharp in Bezug auf das Typsystem?', 'answer': 'EIFFEL hat ein einheitliches Typsystem, das keine separate Unterscheidung zwischen Referenz- und Werttypen macht, im Gegensatz zu C-Sharp. Im Gegensatz zu SMALLTALK, das sich auf Referenztypen festgelegt hat, unterstützt EIFFEL auch Werttypen.'},
     {'question': 'Was ist der Unterschied zwischen Up casts, Down casts und Cross casts?', 'answer': 'Up casts sind Typumwandlungen, bei denen der Zieltyp ein Supertyp des Ausgangstyps ist, Down casts sind Typumwandlungen, bei denen der Zieltyp ein Subtyp des Ausgangstyps ist und Cross casts sind Typumwandlungen, bei denen Zieltyp und Ausgangstyp in keiner Subtypenbeziehung zueinander stehen.'},
     {'question': 'Was ist der Unterschied zwischen Up cast, Down cast und Cross cast?', 'answer': 'Ein Up cast ist eine Typumwandlung, die ein Objekt in einen seiner Supertypen umwandelt, während ein Down cast ein Objekt in einen seiner Subtypen umwandelt. Ein Cross cast ist eine Typumwandlung, die ein Objekt in einen Typ umwandelt, der nicht direkt mit seinem Typ verwandt ist. Ein Up cast ist immer sicher, während Down und Cross casts nur erfolgreich sind, wenn das Objekt den Zieltyp (oder einen Subtyp davon) hat, und können zu Laufzeittypfehlern führen.'},
     {'question': 'Wozu können Typprüfungen in EIFFEL notwendig sein?', 'answer': 'Typprüfungen können in EIFFEL notwendig sein, wenn man in einen Container Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt.'},
     {'question': 'Warum ist es manchmal notwendig, den Typ explizit zu prüfen und innerhalb einer Methode zu verzweigen?', 'answer': 'Es ist manchmal notwendig, den Typ explizit zu prüfen und innerhalb einer Methode zu verzweigen, wenn man in einen Container (eine Variable oder eine Collection) Elemente ungleichen Typs hineinpackt und hinterher wissen will, welchen genauen Typs ein Element ist, um es seinem Typ entsprechend verwenden zu können. Nicht immer wird man die dazu notwendige Fallunterscheidung dem dynamischen Binden überlassen wollen; manchmal ist es einfach einfacher (und besser nachvollziehbar), wenn man den Typ explizit prüft und innerhalb einer Methode entsprechend verzweigt.'},
     {'question': 'Was passiert, wenn man einem Objekt eine Nachricht schickt, die nicht zu seinem Typ passt?', 'answer': 'Wenn man einem Objekt eine Nachricht schickt, die nicht zu seinem Typ passt, führt dies nicht zu einem Typfehler, sondern höchstens dazu, dass das Objekt "void" zugewiesen wird. Die Programmiererin muss dann selbst sicherstellen, dass das Objekt nach der Zuweisung korrekt verwendet wird. Dies entspricht dem "as" aus C-Sharp, dem "dynamic\\_cast<T>(x)" aus C++ sowie dem Java-Konstrukt.'},
     {'question': 'Was passiert, wenn man ein Objekt einer anderen Klasse zuweist?', 'answer': 'Wenn man ein Objekt einer anderen Klasse zuweist, wird höchstens dazu führen, dass das Objekt "void" zugewiesen wird, und es liegt dann in der Verantwortung der Programmiererin, das Objekt nach der Zuweisung zu überprüfen. Dies entspricht dem "as" aus C-Sharp, dem "dynamic\\_cast<T>(x)" aus C++ und dem Java-Konstrukt.'},
     {'question': 'Was ist der Unterschied zwischen dem Zuweisungsversuch in EIFFEL und dem Downcast in Java?', 'answer': 'Im Gegensatz zum Zuweisungsversuch in EIFFEL kann der Downcast in Java einen Laufzeitfehler verursachen.'},
     {'question': 'Was ist der Unterschied zwischen expliziten Typumwandlungen in EIFFEL und Java?', 'answer': 'In EIFFEL gibt es keine expliziten Typumwandlungen, während es in Java welche gibt. In EIFFEL kann der Zuweisungsversuch die Funktion einer Typumwandlung erfüllen, während er in Java einen Laufzeitfehler verursachen kann. Allerdings kann der Zuweisungsversuch in EIFFEL auch einen Typumwandlungsfehler verursachen, der jedoch als Nullzeiger-Ausnahme behandelt wird.'},
     {'question': 'Was ist der Unterschied zwischen Zuweisungskompatibilität und Gleichheit in EIFFEL?', 'answer': 'In EIFFEL sind zwei Typen zuweisungskompatibel, wenn der Zieltyp ein Subtyp des Quelltyps ist, einschließlich der Gleichheit. Das bedeutet, dass der Quelltyp entweder genau dem Zieltyp entspricht oder ein Subtyp des Zieltyps ist. Gleichheit hingegen bedeutet, dass die beiden Typen identisch sind, d.h. der Quelltyp und der Zieltyp sind exakt der gleiche Typ.'},
     {'question': 'Wofür wird die Typumwandlung in EIFFEL verwendet?', 'answer': 'In EIFFEL wird die Typumwandlung für das Binden von Aufrufen kovariant redefinierter Methoden verwendet. Da EIFFEL polymorphe CAT-Calls verbieten muss, diese aber gleichwohl notwendig sein können, hat man nur die Möglichkeit, die dynamische Bindung programmatisch zu emulieren. Und dafür braucht man Zuweisungsversuche.'},
     {'question': 'Auf welcher Basis beruht das Typsystem von EIFFEL?', 'answer': 'Das Typsystem von EIFFEL basiert auf dem Begriff der Typkonformität.'},
     {'question': 'Was bedeutet es, wenn ein Typ U in EIFFEL typkonform zu einem Typ T ist?', 'answer': 'U ist typkonform zu T, wenn U und T gleich sind, wenn U eine direkte Erweiterung von T ist und wenn zusätzlich, im Falle von parametrischer Erzeugung von U und T, jeder tatsächliche Typparameter von U konform ist zum entsprechenden tatsächlichen Typparameter von T oder wenn es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist.'},
     {'question': 'Was ist der Unterschied zwischen direkter und indirekter Erweiterung in EIFFEL?', 'answer': 'Eine direkte Erweiterung bedeutet, dass U direkt von T erbt, während eine indirekte Erweiterung bedeutet, dass es einen Typ V gibt, so dass U typkonform mit V und V typkonform mit T ist.'},
     {'question': 'Was ist der Unterschied zwischen EIFFEL und Java in Bezug auf die Syntax für Vererbung?', 'answer': 'In EIFFEL wird Vererbung durch eckige Klammern und Pfeil (->) dargestellt, während in Java spitze Klammern und extends verwendet werden.'},
     {'question': 'Was ist der Unterschied zwischen Wert- und Referenztypen in EIFFEL?', 'answer': 'In EIFFEL gibt es die Möglichkeit, bei einer Deklaration anzugeben, dass Variablen eines Typs Wertsemantik haben sollen, was bedeutet, dass sie ein Objekt anstelle einer Referenz auf ein Objekt zum Inhalt haben. Dies ist manchmal für alle Variablen eines Typs sinnvoll, z.B. bei Zahlen und Wahrheitswerten, manchmal aber auch nur für manche. Der Unterschied von Wert- und Referenztypen hat in EIFFEL einen starken konzeptuellen Hintergrund, da er die Komposition und ihre Abgrenzung als eine besondere Beziehung zwischen Objekten unterstützt, nämlich das Enthalten-Sein von Objekten in anderen.'},
     {'question': 'Was ist der Unterschied zwischen expanded Variablen und normalen Variablen in EIFFEL?', 'answer': 'In EIFFEL können Instanzen einer Klasse fallweise Komponentenobjekte (über expanded Variablen) und freie Objekte (über normale Variablen) haben. Expanded Variablen sind Komponentenobjekte, während normale Variablen freie Objekte sind. Dieses Feature ist in C-Sharp (zumindest nicht im Safe mode) nicht verfügbar, denn dort definieren Structs ausschließlich Werttypen und Klassen ausschließlich Referenztypen.'},
     {'question': 'Was ist der Unterschied zwischen Komponentenobjekten und freien Objekten in EIFFEL?', 'answer': 'In EIFFEL können Instanzen einer Klasse fallweise Komponentenobjekte und freie Objekte haben. Komponentenobjekte werden über expanded Variablen definiert und sind in anderen Objekten enthalten, während freie Objekte über normale Variablen definiert werden und nirgends enthalten sind.'},
     {'question': 'Was passiert bei der Zuweisung zwischen zwei Variablen mit unterschiedlicher Semantik?', 'answer': 'Wenn eine Variable mit Referenzsemantik an eine Variable mit Wertsemantik zugewiesen wird, wird das Objekt, auf das der Zeiger verweist, kopiert. Wenn eine Variable mit Wertsemantik an eine Variable mit Referenzsemantik zugewiesen wird, wird ein Klon des Objekts erzeugt und eine Referenz auf diesen Klon wird übergeben.'},
     {'question': 'Was passiert bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik?', 'answer': 'Bei der Zuweisung einer Variable mit Referenzsemantik an eine Variable mit Wertsemantik wird das Objekt, auf das der Zeiger verweist, kopiert. Genauer: die Attribute des Objekts in den für die Attribute des Werts reservierten Speicher der Variable kopiert.'},
     {'question': 'Was bedeutet kovarianter Rückgabetyp und kovarianter Parametertyp?', 'answer': 'Wenn eine Unterklasse eine Instanzvariable oder eine Methode redefiniert, dann muss der Typ der Instanzvariable oder der Rückgabetyp der Methode in der Unterklasse ein Subtyp des Typs in der Oberklasse sein. Dies wird als kovarianter Typ bezeichnet. Wenn der Parametertyp einer Methode in der Unterklasse ein Subtyp des Parametertyps in der Oberklasse ist, dann wird dies als kovarianter Parametertyp bezeichnet.'},
     {'question': 'Was wäre eine Möglichkeit, Zuweisungskompatibilität für Variablen mit verankerten Typen einzuschränken?', 'answer': 'Eine Möglichkeit wäre, Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs nur noch mit solchen zu erlauben, die ihn als Anker benutzen. Dadurch würden geschlossene Zirkel entstehen, aus denen kein Objekt hinaus und in die keines hinein käme. Diese Methode hätte jedoch den Nachteil, dass es für die Programmiererin schwer wäre, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll.'},
     {'question': 'Was würde passieren, wenn man die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einschränken würde?', 'answer': 'Wenn man die Zuweisungskompatibilität für Variablen mit verankerten Typen und Typankern einschränken würde, wären nur noch Zuweisungen zwischen Variablen eines als Typanker verwendeten Typs mit solchen, die ihn als Anker benutzen, erlaubt. Das hätte zur Konsequenz, dass bei verankert genutzten Typen geschlossene Zirkel entstünden, aus denen kein Objekt hinaus und in die keines hinein käme (außer bei seiner Erzeugung). Außerdem wäre es für die Programmiererin schwer, vorab zu entscheiden, ob ein Typ entweder als Anker zur kovarianten Redefinition verwendet oder ob er polymorph, also für Variablen, die Objekte unterschiedlichen Typs haben dürfen, genutzt werden soll.'},
     {'question': 'Warum ist eine Typinferenz für das gesamte Programm in den meisten Fällen unrealistisch?', 'answer': 'Eine Typinferenz für das gesamte Programm ist unrealistisch, da sie alle Methodenaufrufe im System berücksichtigen muss, die je nach Konfiguration sehr unterschiedlich ausfallen können. Zudem ist sie sehr aufwendig und erfordert eine komplexe Algorithmik.'},
     {'question': 'Was für Möglichkeiten gibt es in EIFFEL, dynamisch gebundene Aufrufe von Methoden zu behandeln?', 'answer': 'Die drei Möglichkeiten sind: 1) Alle dynamisch gebundenen Aufrufe von Methoden zuzulassen, 2) Alle dynamisch gebundenen Aufrufe von Methoden zu verbieten, die in überschriebenen Versionen („Redefinitionen“) verfügbar oder deren Parametertypen sich ändern und 3) Alle dynamisch gebundenen Aufrufe von Methoden zu verbieten, deren Verfügbarkeit oder Parametertypen sich in überschriebenen Versionen („Redefinitionen“) ändern (die von MEYER so genannten CAT-Calls). Die erste Möglichkeit erlaubt alle dynamisch gebundenen Aufrufe von Methoden, die zweite verbietet alle und die dritte verbietet nur die, die in überschriebenen Versionen („Redefinitionen“) verfügbar oder deren Parametertypen sich ändern.'},
     {'question': 'Was kann man über das Typsystem von EIFFEL sagen?', 'answer': 'Das Typsystem von EIFFEL ist ziemlich restriktiv und wird von einigen als eigenartig empfunden. Obwohl die Probleme in der Praxis laut MEYER kaum eine Rolle spielen, ist es möglich, dass sie auftreten. Wenn dies der Fall ist, versteht die durchschnittliche Programmiererin wahrscheinlich nicht, was das Problem ist und was sie tun kann, um es zu umgehen.'},
     {'question': 'Was ist der Unterschied zwischen Modul und Interface?', 'answer': 'Modul und Interface sind eigentlich ein Begriffspaar, das sich nur mithilfe des anderen definieren lässt. Interfaces in Java sind jedoch eigenständige Konstrukte, die über die eigentliche Bedeutung des Begriffs hinausgehen.'},
     {'question': 'Warum sind Interfaces in Java wichtig?', 'answer': 'Interfaces in Java sind wichtig, weil sie über die eigentliche Bedeutung des Begriffs, nämlich eine Schnittstelle zu definieren, hinausgehen und ein wichtiger Beitrag von Java zur Entwicklung objektorientierter Programmiersprachen sind.'},
     {'question': 'Wozu dient die Aufteilung eines Programms in Module?', 'answer': 'Die Aufteilung eines Programms in Module dient vor allem dem Zweck der unabhängigen Entwicklung der Programmteile. Dabei muss die Abhängigkeit der Module möglichst gering ausfallen.'},
     {'question': 'Sind zirkuläre Abhängigkeiten in Java erlaubt?', 'answer': 'Nein, zirkuläre Abhängigkeiten sind in Java nicht erlaubt, außer bei Klassen (genauer: Kompilierungseinheiten). Für Java-Module sind sie jedoch verboten.'},
     {'question': 'Warum sind zirkuläre Abhängigkeiten in Java-Modulen verboten?', 'answer': 'Zirkuläre Abhängigkeiten sind in Java-Modulen verboten, um eine enge Kopplung zwischen Modulen zu vermeiden und eine sorgfältige Planung der Modularisierung zu erzwingen.'},
     {'question': 'Wozu können Typparameter in Methodendefinitionen eingesetzt werden?', 'answer': 'Typparameter in Methodendefinitionen können dazu genutzt werden, variable Über- und Rückgabeparametertypen für eine Methode zu deklarieren. Die Belegung der Typparameter mit konkreten Typen als Werten erfolgt dann bei der Bindung eines Methodenaufrufs zur Übersetzungszeit.'},
     {'question': 'Was bedeutet es, einen Typparameter mit extends zu beschränken?', 'answer': 'Wenn ein Typparameter mit extends beschränkt wird, kann er nur an einen Typ gebunden werden, der eine Unterklasse des angegebenen Typs ist. Dadurch wird die Verwendbarkeit oder Typsicherheit der mit dem Parameter übergebenen Objekte innerhalb der Methode eingeschränkt.'},
     {'question': 'Was bedeutet es, den Typparameter einer generischen Methode mit extends zu beschränken?', 'answer': 'Wenn man den Typparameter einer generischen Methode mit extends beschränkt, kann er nur an Typen gebunden werden, die eine Unterklasse der angegebenen Klasse sind. Das erhöht die Typsicherheit der mit dem Parameter übergebenen Objekte, da deren Typ innerhalb der Methode bekannt ist.'},
     {'question': 'Wofür werden Tupel in EIFFEL verwendet?', 'answer': 'Tupel werden in EIFFEL als eine Möglichkeit verwendet, mehrere Objekte ohne großen Aufwand zu gruppieren, insbesondere ohne die Notwendigkeit, eine Klasse zu definieren. Sie sind besonders interessant, wenn strukturierte Daten benötigt werden, ohne dass diesen eine eigenständige Bedeutung zugeordnet wird. Dies ist beispielsweise bei Methoden der Fall, die mehrere Werte anstelle eines einzigen Wertes zurückgeben sollen.'},
     {'question': 'Was ist der Unterschied zwischen einem Ausdruck und einer Anweisung in Java?', 'answer': 'In Java werden Ausdrücke im Rahmen der Ausführung von Anweisungen ausgewertet. Ein Ausdruck wird zu einer Anweisung, indem er mit einem Semikolon abgeschlossen wird. Im Gegensatz zum Semikolon in PASCAL oder dem Punkt in SMALLTALK ist das Semikolon in Java kein Trennzeichen, sondern Teil der Anweisung. Variablendeklarationen, Wertzuweisungen, Methodenaufrufe und Klasseninstanziierungen sind in Java direkt als Anweisungen möglich.'},
     {'question': 'Was bewirkt eine If-Anweisung in der Programmierung?', 'answer': "Eine If-Anweisung in der Programmierung führt genau dann das angegebene Statement aus, wenn der boole'sche Ausdruck zu true auswertet."},
     {'question': 'Was bedeutet die If-else-Anweisung in der Programmierung?', 'answer': 'Die If-else-Anweisung ist eine Steuerungsstruktur, die es ermöglicht, eine bestimmte Anweisung auszuführen, wenn ein boolescher Ausdruck wahr ist, und eine andere Anweisung auszuführen, wenn der boolesche Ausdruck falsch ist. Die Anweisung, die ausgeführt wird, wenn der boolesche Ausdruck wahr ist, wird als <Statement 1> bezeichnet, und die Anweisung, die ausgeführt wird, wenn der boolesche Ausdruck falsch ist, wird als <Statement 2> bezeichnet.'},
     {'question': 'Was macht eine While-Anweisung?', 'answer': 'Die While-Anweisung wiederholt eine Anweisung, solange eine boolesche Bedingung wahr ist.'},
     {'question': 'Was ist der Unterschied zwischen der Do-Anweisung und dem While-Statement?', 'answer': 'Der Unterschied liegt darin, dass bei der Do-Anweisung der boolesche Ausdruck erst nach Ausführung des Statements ausgewertet wird, während beim While-Statement der boolesche Ausdruck vor der Ausführung des Statements ausgewertet wird.'},
     {'question': 'Was bewirkt die Break-Anweisung in Programmiersprachen?', 'answer': 'Die Break-Anweisung führt dazu, dass eine Schleife oder ein Switch-Statement sofort verlassen wird. Sie kann mit einem Label versehen werden, auf das sie sich bezieht, um eine äußere Schleife oder ein äußeres Switch-Statement zu verlassen.'},
     {'question': 'Was bewirkt die Continue-Anweisung in Schleifen?', 'answer': 'Die Continue-Anweisung führt dazu, dass der Rest des innersten bzw. des durch <Label> bezeichneten Schleifenrumpfs für den aktuellen Durchlauf nicht mehr ausgeführt wird, sondern sofort mit dem nächsten Durchlauf, falls vorhanden, fortgesetzt wird.'},
     {'question': 'Was bewirkt die Return-Anweisung in einer Methode?', 'answer': 'Die Return-Anweisung bewirkt, dass die umschließende Methode sofort beendet wird und ggf. der Wert der Auswertung von <Ausdruck> zurückgegeben wird.'},
     {'question': 'Was bewirkt die Synchronized-Anweisung in Java?', 'answer': 'Die Synchronized-Anweisung in Java sorgt dafür, dass der durch den Block bezeichnete Anweisungsblock nur ausgeführt wird, wenn das mit dem Objekt, zu dem der Ausdruck ausgewertet wird, verbundene Lock dies zulässt.'},
     {'question': 'Was bewirkt die Throw-Anweisung in einem Programm?', 'answer': 'Die Throw-Anweisung lässt das Programm eine Exception werfen, was zu einer Ausnahmesituation führt.'},
     {'question': 'Was bewirkt die Assert-Anweisung?', 'answer': 'Die Assert-Anweisung bewirkt, dass das Programm mit einer entsprechenden Fehlermeldung abgebrochen wird, wenn der angegebene Boolesche Ausdruck falsch ist. Sie kann auch verwendet werden, um zusätzliche Informationen auszugeben, wenn der Ausdruck wahr ist.'},
     {'question': 'Wozu werden Assert-Anweisungen in Java verwendet?', 'answer': 'Assert-Anweisungen in Java werden verwendet, um sicherzustellen, dass bestimmte Bedingungen während der Laufzeit erfüllt sind. Dabei werden die Bedingungen in Form von Statements formuliert, die zur Laufzeit ausgeführt werden. Assert-Anweisungen beziehen sich häufig auf Methoden des Programms, für die die Invarianten angegeben werden sollen. Allerdings können diese Methoden den Zustand des Programms ändern, weshalb man einer Zusicherung mit assert nicht ansehen kann, ob sie seiteneffektfrei ist.'},
     {'question': 'Was ist der Unterschied zwischen Referenz- und Wertsemantik in Java?', 'answer': 'In Java haben Variablen mit Referenzsemantik einen Wert, der auf ein Objekt verweist, während Variablen mit Wertsemantik den Wert direkt enthalten. Der Unterschied liegt darin, dass Variablen mit Referenzsemantik den Wert des Objekts nicht direkt enthalten, sondern nur eine Referenz auf das Objekt halten.'},
     {'question': 'Was ist der Unterschied zwischen Variablen mit Wert- und Referenzsemantik in Java?', 'answer': 'In Java haben Variablen mit Wertsemantik einen konkreten Wert, während Variablen mit Referenzsemantik einen Verweis auf ein Objekt speichern. Wenn man eine Variable mit Referenzsemantik ändert, wird nur der Verweis geändert, nicht das Objekt selbst. Bei Variablen mit Wertsemantik hingegen wird der Wert direkt geändert.'},
     {'question': 'Was ist der Unterschied zwischen Zuweisungen an Variablen primitiver Typen und solchen anderer Typen in Java?', 'answer': 'Bei Zuweisungen an Variablen primitiver Typen wird der Wert selbst kopiert, während bei Zuweisungen an Variablen anderer Typen eine Referenz auf das Objekt kopiert wird.'},
     {'question': 'Gibt es in Java "Call by reference"?', 'answer': 'Nein, in Java gibt es kein "Call by reference", sondern nur "Call by value". Bei Methodenaufrufen mit impliziten Zuweisungen wird immer eine Kopie des Zeigers an die formalen Parameter übergeben, auch wenn Variablen, die mit Referenztypen deklariert sind, Referenzsemantik haben.'},
     {'question': 'Was ist der Unterschied zwischen der equals-Methode und dem Test auf Identität (==) in Java?', 'answer': 'Die equals-Methode testet, ob zwei Objekte den gleichen Wert repräsentieren, während der Test auf Identität (==) prüft, ob zwei Objekte identisch sind.'},
     {'question': 'Wofür wird das Friends-Konzept in C++ verwendet?', 'answer': 'Das Friends-Konzept wird verwendet, um die Schnittstelle von kooperierenden Klassen relativ zu anderen Klassen definieren zu können, indem es den Zugriff auf private und protected Elemente erlaubt, die anderen Klassen verborgen bleiben sollen.'},
     {'question': 'Was bietet das Friends-Konzept in C++?', 'answer': 'Das Friends-Konzept in C++ ermöglicht es, dass bestimmte Klassen auf alle privat deklarierten Elemente einer anderen Klasse zugreifen können. Das heißt, dass die Definition friend class B; friend class C; bewirkt, dass (Instanzen von) B und (von) C auf alle privat deklarierten Elemente von (Instanzen von) A zugreifen können. Jedoch können weder A auf B und C noch B und C gegenseitig darauf zugreifen.'},
     {'question': 'Was ist der Unterschied zwischen Java und SMALLTALK in Bezug auf die Objektorientierung?', 'answer': 'In Java sind neben Objekten auch Werte wie Zahlen, Zeichen und Wahrheitswerte vorhanden, die keine Objekte sind. Im Gegensatz dazu sind in SMALLTALK alle Werte Objekte.'},
     {'question': 'Was ist der Unterschied zwischen Objekten und Werten in Java?', 'answer': 'In Java sind Objekte Instanzen von Klassen und haben einen Verweis auf einen Speicherbereich, in dem ihre Attribute gespeichert sind. Währenddessen sind Werte wie Zahlen, Zeichen und Wahrheitswerte nicht instanziiert und haben keinen Verweis auf einen Speicherbereich. Sie sind direkt in den Variablen gespeichert.'},
     {'question': 'Was ist der Unterschied zwischen lokalen Variablen und Instanzvariablen in Java?', 'answer': 'Lokale Variablen sind Variablen, die innerhalb einer Methode deklariert werden und nur innerhalb dieser Methode sichtbar sind. Instanzvariablen sind Variablen, die in einer Klasse deklariert werden und für alle Instanzen dieser Klasse gültig sind. Instanzvariablen werden initialisiert, wenn ein Objekt erzeugt wird und behalten ihren Wert zwischen verschiedenen Methodenaufrufen bei.'},
     {'question': 'Was ist der Unterschied zwischen einem Objekt und einem Literal in Java?', 'answer': 'Der Unterschied zwischen einem Objekt und einem Literal in Java ist, dass ein Objekt eine Instanz einer Klasse ist, die zur Laufzeit erzeugt wird, während ein Literal ein Wert ist, der direkt in den Quellcode eingebettet ist und zur Laufzeit als konkreter Wert zur Verfügung gestellt wird. Objekte haben einen Klassentyp, während Literale einen primitiven Typ haben.'},
     {'question': 'Was ist der Unterschied zwischen parametrischen Polymorphismus und beschränktem parametrischen Polymorphismus in Java?', 'answer': 'Parametrischer Polymorphismus in Java erlaubt es, eine Klasse oder Methode mit einem Typparameter zu definieren, der bei der Instanziierung mit einem konkreten Typ ersetzt wird. Beschränkter parametrischer Polymorphismus hingegen erlaubt es, zusätzlich zu dem Typparameter, bestimmte Eigenschaften des konkreten Typs vorauszusetzen, der für den Typparameter eingesetzt wird. Dadurch kann man in der Implementierung der Klasse oder Methode, die den Typparameter definiert, davon ausgehen, dass diese Eigenschaften beim konkreten Typ vorhanden sind, und diese nutzen.'},
     {'question': 'Was bedeutet es, wenn eine Typvariable auf einen generischen Typ eingeschränkt wird?', 'answer': 'Wenn eine Typvariable auf einen generischen Typ eingeschränkt wird, werden die möglichen Werte der Typvariable auf Typen eingeschränkt, die den eingeschränkten Typ direkt oder indirekt erweitern. Dadurch werden die Möglichkeiten konkreter Typen (z.B. in Variablendeklarationen) zu bilden eingeschränkt. Es wird jedoch keine neue Subtypenrelation zwischen irgendwelchen Typen hergestellt.'},
     {'question': 'Warum werden in der akademischen Sicht Programmiersprachen wie Java, C++ oder Python weniger durch revolutionäre Konzepte oder neuartige Sichtweisen ausgezeichnet?', 'answer': 'In der akademischen Sicht werden Programmiersprachen wie Java, C++ oder Python weniger durch revolutionäre Konzepte oder neuartige Sichtweisen ausgezeichnet, sondern vielmehr durch ihre weite Verbreitung in der Praxis.'},
     {'question': 'Warum werden in der akademischen Sichtweise bestimmte Programmiersprachen bevorzugt?', 'answer': 'In der akademischen Sichtweise werden Programmiersprachen bevorzugt, die durch revolutionäre Konzepte oder neuartige Sichtweisen auffallen, anstatt durch ihre Verbreitung in der Praxis. Diese Sprachen können Leserinnen dazu ermutigen, ihre bisherigen Denkweisen zu überprüfen.'},
     {'question': 'Warum ist es wichtig für Praktikerinnen, die Programmiersprachen zu kennen, die auf dem Markt gefragt sind?', 'answer': 'Für Praktikerinnen ist es wichtig, die Programmiersprachen zu kennen, die auf dem Markt gefragt sind, weil sie so in der Lage sind, die Sprachen zu verwenden, die in der Industrie und im Geschäftsleben am häufigsten eingesetzt werden. Dies erhöht ihre Beschäftigungsfähigkeit und ermöglicht es ihnen, an einer Vielzahl von Projekten zu arbeiten.'},
     {'question': 'Was bedeutet es, Variablen generisch zu deklarieren?', 'answer': 'In Java ist es möglich, Variablen generisch zu deklarieren, ohne dass die in der Variablendeklaration verwendete Typvariable bereits von einer umschließenden Methode oder Klasse eingeführt worden wäre. Dies ist jedoch nur mit anonymen Typvariablen, also Wildcards, möglich. Eine solche Variablendeklaration führt keinen neuen Typ ein, sondern die per "Wildcard" deklarierte Variable kann Listen beliebigen Elementtyps zugewiesen werden, weil "List<>" Supertyp aller Instanziierungen von "List<T>" ist.'},
     {'question': 'Was ist der Unterschied zwischen Typen mit Wertsemantik und Typen mit Referenzsemantik in C++?', 'answer': 'In C++ haben Typen mit Wertsemantik eine eigene Kopie im Speicher, während Typen mit Referenzsemantik (Zeiger) nur einen Speicherort im Speicher referenzieren. Das bedeutet, dass bei der Zuweisung von Werten mit Wertsemantik eine Kopie erstellt wird, während bei der Zuweisung von Werten mit Referenzsemantik nur der Speicherort kopiert wird.'},
     {'question': 'Was erlaubt C++ und unterscheidet sich dadurch von vielen anderen objektorientierten Programmiersprachen?', 'answer': 'C++ erlaubt Mehrfachvererbung, das heißt, eine Klasse kann von mehreren anderen Klassen abgeleitet werden. Diese Funktionalität unterscheidet C++ von den zuvor diskutierten Sprachen, die nur die Einfachvererbung unterstützen.'},
     {'question': 'Was bedeutet statische Bindung in C++?', 'answer': 'In C++ werden Methoden standardmäßig statisch gebunden, das heißt, dass auf einem Objekt immer die Methode aufgerufen wird, die in der Klasse definiert ist, deren Typ die Variable (und nicht das Objekt, auf das sie verweist) hat. Der tatsächliche Typ des Objekts wird also ignoriert.'},
     {'question': 'Was ist der Unterschied zwischen statischen und strikten Typsystemen?', 'answer': 'Ein statisches Typsystem ist ein Typsystem, in dem die Typen der Ausdrücke bereits zur Übersetzungszeit bestimmt werden. Ein striktes Typsystem ist ein Typsystem, in dem die Typen der Ausdrücke nicht nur zur Übersetzungszeit, sondern auch zur Laufzeit überprüft werden und die Zulässigkeit von Typumwandlungen sichergestellt wird.'},
     {'question': 'Was wird durch explizite Typumwandlung vermieden?', 'answer': 'Explicit type conversion ist am besten zu vermeiden. Durch die Verwendung eines Casts wird die vom Compiler bereitgestellte Typüberprüfung unterdrückt und wird daher zu Überraschungen führen, es sei denn, die Programmiererin hat recht.'},
     {'question': 'Was ist der Unterschied zwischen Threads und Prozessen in Java?', 'answer': 'In Java werden parallele Ausführungsstränge als Threads bezeichnet, im Gegensatz zu Prozessen in anderen Programmiersprachen. Threads sind leichtgewichtiger als Prozesse, da sie keine separate Allokation von Ressourcen wie Hauptspeicher erfordern und alle auf denselben Ressourcen arbeiten. Der Preis dafür ist, dass die Mechanismen zur Synchronisation bei Threads selbst implementiert werden müssen, während sie bei Prozessen über die Inter-Prozess-Kommunikation des Betriebssystems geregelt sind.'},
     {'question': 'Was repräsentiert eine Instanz der Klasse Thread in Java?', 'answer': 'Eine Instanz der Klasse Thread in Java repräsentiert nicht den Thread selbst, sondern simuliert einen aktiven Objekt, der seinen eigenen Ausführungsstrang hat und behält. Der Thread ist ein paralleler Ausführungsstrang der JVM, der nicht an ein spezifisches Objekt gebunden ist, sondern zwischen den Empfängerobjekten wechselt. Das Thread-Objekt speichert spezifische Daten wie den Namen des Threads und seine Priorität.'},
     {'question': 'Was passiert, wenn eine Instanzmethode mit synchronized deklariert wird?', 'answer': 'Wenn eine Instanzmethode mit synchronized deklariert wird, wird die Sperre auf das Objekt angewendet, auf dem die Methode aufgerufen wird.'},
     {'question': 'Ist C-Sharp eine typsichere Sprache?', 'answer': 'Ja, C-Sharp ist eine typsichere Sprache, die eine strikte Typprüfung durchführt. Allerdings hat das Typsystem von C-Sharp auch eine Laufzeitkomponente, da nicht alles zur Übersetzungszeit geschehen kann.'},
     {'question': 'Was ist der Unterschied zwischen C-Sharp und C++ in Bezug auf Typsicherheit?', 'answer': 'Im Gegensatz zu C++ ist C-Sharp eine typsichere Sprache, die eine strikte Typprüfung durchführt. Diese Typprüfung erfolgt sowohl zur Übersetzungszeit als auch zur Laufzeit. In C++ hingegen wird keine Laufzeitprüfung durchgeführt, was zu potenziellen Sicherheitsrisiken führen kann.'},
     {'question': 'Was passiert, wenn ein Cast nicht möglich ist?', 'answer': 'Wenn ein Cast nicht möglich ist, weil der tatsächliche Typ des Objekts, auf das a verweist, kein Subtyp von T ist oder weil keine entsprechende Typumwandlung definiert ist (einschließlich Boxing/Unboxing), wird dies mit einem Laufzeitfehler quittiert.'},
     {'question': 'Was macht der Operator is in C-Sharp?', 'answer': 'Der Operator is in C-Sharp prüft, ob das Ergebnis der Auswertung eines beliebigen Ausdrucks a mit einer Variablen vom Typ T zuweisungskompatibel ist. Dabei wird sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.'},
     {'question': 'Was gibt der Operator is in C-Sharp zurück?', 'answer': 'Der Operator is in C-Sharp gibt zurück, ob das Ergebnis der Auswertung eines beliebigen Ausdrucks a mit einer Variablen vom Typ T zuweisungskompatibel ist, wobei er sowohl das Subtyping als auch das implizite (Auto-)Boxing berücksichtigt.'},
     {'question': 'Was passiert bei der Verwendung von Casts in C++?', 'answer': 'Bei der Verwendung von Casts in C++ wird der Compiler gezwungen, den Ausdruck auf der linken Seite des Casts als Typ zu interpretieren, der auf der rechten Seite angegeben ist, wodurch die statische Typisierung umgangen wird.'},
     {'question': 'Kann man in Java Arrays von primitiven Typen bilden?', 'answer': 'Ja, in Java ist es möglich, sowohl von primitiven (Wert-)Typen als auch von Referenztypen Arrays zu bilden.'},
     {'question': 'Kann man in Java neue Typen über den Array-Typkonstruktor benennen?', 'answer': 'Nein, in Java können über den Array-Typkonstruktor keine neuen Typen benannt werden. Die Typkonstruktion erfolgt immer implizit in einer Variablendeklaration.'},
     {'question': 'Was ist der Unterschied zwischen primitiven (Wert-)Typen und Referenztypen in Java?', 'answer': 'Primitiven (Wert-)Typen werden direkt im Speicher abgelegt, während Referenztypen auf einen Speicherbereich verweisen, der die Daten enthält. Der Hauptunterschied liegt darin, wie sie in Arrays abgelegt werden. Für primitiven Typen wird ein neuer Typ benannt, während für Referenztypen die Typkonstruktion immer implizit in einer Variablendeklaration erfolgt.'},
     {'question': 'Was passiert mit den Elementen eines Arrays nach der Initialisierung in Java?', 'answer': 'Nach der Initialisierung eines Arrays in Java enthalten alle Elemente den Wert null.'},
     {'question': 'Was bedeutet es, wenn ein Array in Java 0-basiert ist?', 'answer': 'Wenn ein Array in Java 0-basiert ist, hat das erste Element den Index 0.'},
     {'question': 'Was kann ein Array-Initialisierer in Java umfassen?', 'answer': 'Ein Array-Initialisierer in Java kann mehrere Dimensionen umfassen.'},
     {'question': 'Gibt es eine Einschränkung bei der Größe der Dimensionen in Java?', 'answer': 'Nein, in Java gibt es keine Einschränkung bei der Größe der Dimensionen.'},
     {'question': 'Warum haben Array-Variablen in Java immer Referenzsemantik?', 'answer': 'Array-Variablen haben in Java immer Referenzsemantik, weil Array-Kopieroperationen sehr teuer sind und zudem selten benötigt werden. Dies hat den Hintergrund, dass bei der Zuweisung an die Variable f lediglich ein Pointer darauf übergeben wird, anstatt ein ganzes Array als Kopie.'},
     {'question': 'Ist die Zuweisung einer Variablen vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] in Java zulässig?', 'answer': 'Ja, die Zuweisung ist in Java zulässig.'},
     {'question': 'Warum ist die Zuweisung einer Variable vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] zulässig in Java?', 'answer': 'In Java ist die Zuweisung einer Variablen vom Typ A[], wobei A ein Referenztyp sei und damit automatisch ein Subtyp von Object, an eine Variable vom Typ Object[] zulässig, weil Java eine polymorphe Zuweisung von Arrays erlaubt. Dies bedeutet, dass ein Array-Referenzvariablen jeder Kompatibilitätsebene einen Wert zugewiesen werden kann, der eine Array-Instanz eines beliebigen Subtyps der angegebenen Kompatibilitätsebene ist.'},
     {'question': 'Warum wird auf statische Typprüfung verzichtet und stattdessen eine dynamische Typprüfung mit möglicher Meldung eines Laufzeitfehlers durchgeführt?', 'answer': 'Dies geschieht, um die Möglichkeit der statischen Typprüfung zu vermeiden, die auf Basis mangelnder Typkonformität einen Typfehler bei der Zuweisung melden würde. Stattdessen wird eine dynamische Typprüfung durchgeführt, um die Flexibilität beim Programmieren zu erhöhen, auch wenn dies zu einem Laufzeitfehler führen kann.'},
     {'question': 'Warum wird auf die statische Typprüfung zugunsten einer dynamischen Typprüfung verzichtet?', 'answer': 'Der Verzicht auf die statische Typprüfung zugunsten einer dynamischen Typprüfung wird vorgenommen, um die Möglichkeit der statischen Typprüfung zu verhindern, die (auf Basis mangelnder Typkonformität) einen Typfehler bei der Zuweisung melden würde. Dies geschieht, wenn die statische Typprüfung Programme verhindert, die man gern schreiben möchte und die auch korrekt sein können, ohne dass dies vom Compiler garantiert werden könnte.'},
     {'question': 'Warum wird in diesem Fall auf die statische Typprüfung verzichtet und stattdessen eine dynamische Typprüfung durchgeführt?', 'answer': 'Der Verzicht auf die statische Typprüfung zugunsten einer dynamischen Typprüfung wird vorgenommen, um die Möglichkeit zu haben, Programme zu schreiben, die zwar korrekt sein können, aber von dem Compiler nicht garantiert werden können. Dies geschieht, um die Flexibilität beim Programmieren zu erhöhen. Ein Laufzeittest wird durchgeführt, um sicherzustellen, dass der Typ beim Zugriff auf das Array korrekt ist.'},
     {'question': 'Wozu dient Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs?', 'answer': 'Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs ist nützlich, wenn es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern nur nach oben beschränken wollen. Zum Beispiel kann der Interfacetyp Comparable<T> als statischer Typ für Array-Elemente verwendet werden, um zu signalisieren, dass die Array-Elemente eine Methode compareTo(T o) implementieren müssen. Die tatsächliche Klasse der Array-Elemente muss diese Methode nicht unbedingt von Comparable<T> erben, sie kann auch eine eigene Klasse sein, die compareTo(T o) implementiert.'},
     {'question': 'Warum ist Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs wünschenswert?', 'answer': 'Zuweisungskompatibilität zwischen Arrays nicht gleichen Typs ist wünschenswert, weil es Prozeduren gibt, die den (statischen) Typ der Array-Elemente nicht genau festlegen, sondern lediglich nach oben beschränken wollen. So kann eine Prozedur mit einem Array von Objekten aufgerufen werden, die den Typ Comparable<T> implementieren, unabhängig davon, welcher Typ T das ist.'},
     {'question': 'Was macht die Methode compareTo?', 'answer': 'Die Methode compareTo vergleicht das Empfänger-Objekt mit dem Parameterobjekt und gibt einen Wert zurück, der angibt, wie der Vergleich ausgegangen ist.'},
     {'question': 'Was ist der Vorteil der dynamischen Typprüfung in Bezug auf die Methode sort?', 'answer': 'Der Vorteil der dynamischen Typprüfung ist, dass sie die Verwendung der Methode sort erlaubt, obwohl das statische Typsystem dies nicht zugelassen hätte. Dadurch wird eine sichere Verwendung ermöglicht.'},
     {'question': 'Warum ist die Methode sort faktisch sicher?', 'answer': 'Die Methode sort ist faktisch sicher, weil beim Sortieren die Elemente eines Arrays nicht ersetzt, sondern nur umgeordnet werden, und daher kein Typfehler von der Art der Zeile 1046 auftreten kann.'},
     {'question': 'Warum ist der Kompromiss zwischen statischer und dynamischen Typprüfung vertretbar?', 'answer': 'Der Kompromiss zwischen statischer und dynamischen Typprüfung ist vertretbar, weil er die Verwendung der Methode sort erlaubt, die Arrays beliebiger Elementtypen zum Sortieren annehmen kann, solange diese nur Comparable implementieren und damit Auskunft über ihre relative Ordnung zu geben in der Lage sind.'}],
]
KE6_questions = [
    [{'question': 'Was ist das Ziel von "guter Programmierung"?', 'answer': 'Das Ziel von "guter Programmierung" ist es, die Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf zu minimieren. Eine gute Programmiererin schreibt ihre Programme so, dass die statische Struktur des Programms möglichst viele Rückschlüsse auf seinen dynamischen Ablauf zulässt.'},
     {'question': 'Was ist das Lokalitätsprinzip von Programmen?', 'answer': 'Das Lokalitätsprinzip von Programmen besagt, dass Dinge, die zusammengehören, auch im Programmtext beieinander stehen sollten. Dadurch wird die Lesbarkeit und Nachvollziehbarkeit des Programms verbessert.'},
     {'question': 'Was ist die Auswirkung von Goto-Anweisungen auf den Programmfluss?', 'answer': 'Goto-Anweisungen können den Programmfluss beeinflussen, indem sie den Kontext verlassen und zu einer anderen Stelle im Programm springen. Das Ziel des Sprungs ist nicht immer eindeutig aus dem Kontext erkennbar, und es kann unklar sein, welche Anweisungen vorher ausgeführt wurden.'},
     {'question': 'Was ist strukturierte Programmierung?', 'answer': 'Die strukturierte Programmierung ist eine Programmiermethode, die neben der Sequenz von Anweisungen, die Verzweigung, die Wiederholung und den Unterprogrammaufruf vorsieht. Sie behält das Lokalitätsprinzip bei, solange man den Kontext auf den Umfang der Fallunterscheidung bzw. Schleife ausdehnt.'},
     {'question': 'Was ist das Lokalitätsprinzip in der Programmierung?', 'answer': 'Das Lokalitätsprinzip in der Programmierung besagt, dass die Bedeutung eines Elements in einem Programm durch seinen unmittelbaren Kontext bestimmt wird. Dieses Prinzip wird bei der strukturierten Programmierung durch die Sequenz von Anweisungen, Verzweigungen und Wiederholungen eingehalten, aber durchbrochen, wenn ein Unterprogramm aufgerufen wird, da es von mehreren Stellen eines Programms aus aufgerufen werden kann und diese Stellen nicht automatisch denselben Kontext haben.'},
     {'question': 'Was sind die Kriterien für die Aufteilung in Unterprogramme bei der objektorientierten Programmierung?', 'answer': 'Bei der objektorientierten Programmierung sind die Kriterien für die Aufteilung in Unterprogramme das Vermeiden von doppeltem Code, die stufenweise Verfeinerung, das Zuordnen jeder Teilfunktion der Klasse, deren Daten sie manipuliert, und die Disziplin, die Implementierung größerer Funktionen zu verteilen.'},
     {'question': 'Was ist das Problem mit dynamisch gebundenen Unterprogrammaufrufen in der objektorientierten Programmierung?', 'answer': 'Das Problem mit dynamisch gebundenen Unterprogrammaufrufen in der objektorientierten Programmierung ist, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht. Das dynamische Binden verbindet den Unterprogrammaufruf mit der Verzweigung.'},
     {'question': 'Was ist dynamisches Binden und wie verbindet es Unterprogrammaufruf mit Verzweigung?', 'answer': 'Dynamisches Binden ist eine Technik in der objektorientierten Programmierung, bei der der Unterprogrammaufruf mit der Verzweigung verbunden wird, indem die Entscheidung darüber, welches Unterprogramm aufgerufen werden soll, zur Laufzeit getroffen wird, anstatt zur Übersetzungszeit. Das bedeutet, dass der Compiler nicht im Voraus entscheiden kann, welches Unterprogramm aufgerufen wird, sondern dass diese Entscheidung zur Laufzeit getroffen wird, wenn der Unterprogrammaufruf tatsächlich ausgeführt wird. Dies ermöglicht es, dass der Zielcode des Unterprogrammaufrufs zur Laufzeit bestimmt wird, was eine flexiblere und dynamischere Programmstruktur ermöglicht.'},
     {'question': 'Was ist das Lokalitätsprinzip und wie wird es durch dynamisches Binden aufgeweicht?', 'answer': 'Das Lokalitätsprinzip besagt, dass die Bedeutung eines Namens durch die unmittelbare Umgebung bestimmt wird, in der er deklariert ist. Durch dynamisches Binden wird das Lokalitätsprinzip aufgeweicht, da die Bedeutung eines Namens, der auf eine Methode verweist, nicht nur durch die unmittelbare Umgebung bestimmt wird, sondern auch durch die Klasse des Empfängerobjekts, auf dem die Methode aufgerufen wurde. Diese Information ist in der Regel nicht lokal bestimmbar und erfordert eine vollständige Programmanalyse.'},
     {'question': 'Was ist das Problem, wenn man sich den aufgerufenen Code anschauen will?', 'answer': 'Das Problem ist, dass man gar nicht weiß, an welcher Stelle man schauen muss.'},
     {'question': 'Was ist ein Entwurfsprinzip in der Programmierung?', 'answer': 'Ein Entwurfsprinzip in der Programmierung ist ein Grundsatz, der bei der Gestaltung von Software berücksichtigt wird. Im Gegensatz zu einem Programmierstil ist ein Entwurfsprinzip eher allgemein und weniger willkürlich. Es kann die Gestaltung von Software in Hinsicht auf Funktionalität, Wartbarkeit, Lesbarkeit und Effizienz beeinflussen.'},
     {'question': 'Was ist ein Entwurfsprinzip und wie unterscheidet es sich von einem Programmierstil?', 'answer': 'Ein Entwurfsprinzip ist ein allgemeiner Grundsatz oder Richtlinie, die bei der Gestaltung von Softwarearchitektur und Design befolgt wird. Im Gegensatz dazu ist ein Programmierstil eine bestimmte Art und Weise, wie Code geschrieben wird, die von der persönlichen Vorliebe des Programmierers abhängt. Ein Entwurfsprinzip ist also ein allgemeinerer Begriff als Programmierstil und bezieht sich auf die Architektur und das Design von Software, während Programmierstil sich auf die Art und Weise bezieht, wie Code geschrieben wird.'},
     {'question': 'Was ist die wichtigste Programmierrichtlinie zur Vererbung?', 'answer': 'Die wichtigste Programmierrichtlinie zur Vererbung ist: Mache alle Superklassen abstrakt.'},
     {'question': 'Was ist das Fragile-base-class-Problem?', 'answer': 'Das Fragile-base-class-Problem ist ein Problem, bei dem eine Änderung an der Basisklasse sich auf andere Klassen ausbreiten und den Vertrag dieser Klassen mit ihren Klienten brechen kann. Das Problem tritt auf, wenn die Klasse, deren Verhalten man ändern möchte, Subklassen hat oder wenn die Designerin von Klassenbibliotheken beschließt, das Verhalten einer Klasse zu ändern.'},
     {'question': 'Was sind Formatierungskonventionen?', 'answer': 'Formatierungskonventionen sind Vereinbarungen über die Formatierung von Quellcode, die neben Namenskonventionen dazu dienen, den Code lesbarer zu gestalten. Sie regeln Dinge wie Einrückungen und an welchen Stellen Zeilenumbrüche, Leerzeilen und Leerzeichen einzufügen sind.'},
     {'question': 'Was sind Coding Conventions?', 'answer': 'Coding Conventions sind Vereinbarungen über die Formatierung von Quellcode, die neben Namenskonventionen und anderen Richtlinien dazu dienen, den Code lesbarer zu gestalten. Sie regeln Dinge wie Einrückungen, Zeilenumbrüche, Leerzeilen und Leerzeichen.'},
     {'question': 'Was sind automatische Codeformatierer?', 'answer': 'Automatische Codeformatierer sind Werkzeuge, die auf Knopfdruck bestimmte Codierungs-konventionen umsetzen. Sie sind ein wirksames Gegenmittel gegen Energieverschwendung und sollten, wo immer verfügbar, eingesetzt werden.'},
     {'question': 'Was ist Substituierbarkeit in der Programmierung?', 'answer': 'Substituierbarkeit in der Programmierung ist ein Begriff, der unabhängig von der Typkonformität betrachtet wird. Er bezieht sich darauf, ob eine Zuweisung automatisch und ohne Probleme durch den Compiler beantwortet werden kann.'},
     {'question': 'Was ist Substituierbarkeit in der objektorientierten Programmierung?', 'answer': 'Substituierbarkeit in der objektorientierten Programmierung bedeutet, dass ein Objekt ein anderes Objekt ersetzen kann, ohne dass sich der Programmablauf ändert. In der strengsten Auslegung müsste das ersetzende Objekt nicht nur gleich implementiert sein wie das ersetzte, sondern sich auch noch im selben Zustand befinden.'},
     {'question': 'Was ist die strengste Auslegung des Begriffs der Substituierbarkeit?', 'answer': 'In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dazu müsste das ersetzende Objekt nicht nur gleich implementiert sein wie das ersetzte (also Instanz derselben Klasse), sondern sich auch noch (zum Zeitpunkt der Substituierung) im selben Zustand wie das substituierte befinden.'},
     {'question': 'Was ist der Substituierbarkeitsbegriff und wie hängt er mit der Übersetzungszeit zusammen?', 'answer': 'Der Substituierbarkeitsbegriff ist ein Begriff, der unabhängig vom konkreten Zustand der Objekte sein muss. Wenn man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungszeit verlagert, ist das Verhalten aller Objekte einer Klasse gleich spezifiziert, so dass eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.'},
     {'question': 'Was ist der Substituierbarkeitsbegriff und wovon sollte er unabhängig sein?', 'answer': 'Der Substituierbarkeitsbegriff bezieht sich darauf, ob ein Objekt eines Typs durch ein Objekt eines anderen Typs ersetzt werden kann, ohne dass sich das Verhalten des Systems ändert. Er sollte unabhängig vom konkreten Zustand der Objekte sein.'},
     {'question': 'Was ist die Frage der Substituierbarkeit?', 'answer': 'Die Frage der Substituierbarkeit bezieht sich darauf, ob ein Objekt durch ein anderes Objekt ersetzt werden kann, ohne dass sich das Verhalten des Gesamtsystems ändert. Diese Frage wird interessant, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt. Diese Abweichungen können sowohl funktional als auch nichtfunktional sein.'},
     {'question': 'Was ist Substituierbarkeit und wann wird sie interessant?', 'answer': 'Substituierbarkeit bedeutet, dass ein Objekt durch ein anderes Objekt ersetzt werden kann, ohne dass sich das Verhalten des Systems ändert. Sie wird interessant, wenn die Objekte nicht derselben Klasse angehören und wenn man eine gewisse Abweichung im Verhalten von zu substituierenden Objekten zulässt, wie beispielsweise in nichtfunktionalen Eigenschaften wie Geschwindigkeit oder Speicheranforderungen. Es ist jedoch zu beachten, dass funktionale und nichtfunktionale Anforderungen nicht immer hundertprozentig voneinander zu trennen sind und dass ein Programm, das von einem funktionalen nur in nicht-funktionalen Eigenschaften abweicht, möglicherweise nicht funktioniert.'},
     {'question': 'Was ist funktionale Äquivalenz?', 'answer': 'Funktionale Äquivalenz bedeutet, dass zwei Objekte, die zu verschiedenen Typen gehören, aber innerhalb derselben Gruppe sind, die gleichen Funktionen erfüllen und die gleichen Methoden aufrufen können. Sie können sich jedoch im Aussehen und Verhalten unterscheiden.'},
     {'question': 'Was ist ein Beispiel für funktional äquivalente, aber verschiedene Typen?', 'answer': 'Ein klassisches Beispiel für die gegenseitige Austauschbarkeit funktional äquivalenter, aber verschiedener Typen ist die plattformunabhängige GUI-Programmierung. So können beispielsweise die Objekte für die Elemente eines GUI, wie Fenster, Buttons etc. für jedes Betriebssystem eine eigene Implementierung haben. Diese Objekte sind innerhalb derselben Gruppe (also als Objekte von Subtypen desselben Typs) funktional äquivalent, können sich aber im Aussehen und ggf. auch im Detailverhalten (gegenüber dem Benutzer) unterscheiden. Diese Unterschiede sind jedoch gewollt, und die Substituierbarkeit bleibt davon unberührt.'},
     {'question': 'Was ist funktionale Äquivalenz?', 'answer': 'Funktionale Äquivalenz bedeutet, dass zwei Objekte, die zu verschiedenen Typen gehören, aber innerhalb derselben Gruppe sind, die gleichen Funktionen erfüllen und die gleichen Methoden aufrufen können. Sie können sich jedoch im Aussehen und Verhalten unterscheiden.'},
     {'question': 'Was ist der Zweck von Objekten, die eine "Rückgängigmachen"-Funktion haben?', 'answer': 'Der Zweck von Objekten, die eine "Rückgängigmachen"-Funktion haben, ist es, Aktionen als Objekte zu repräsentieren, die neben einer Funktion "ausführen" auch noch eine "Rückgängigmachen"-Funktion haben, die für jeden Typ von Aktion unterschiedlich ist. Diese Objekte sind dann gegeneinander austauschbar, und die Aktionstypen sind alle Subtypen eines allgemeinen (abstrakten) Typs Aktion. Die Anforderungen an die Substituierbarkeit sind in diesem Fall also eher gering.'},
     {'question': 'Was ist der Zweck von abstrakten Typen?', 'answer': 'Abstrakte Typen werden verwendet, um Objekte verschiedener konkreter Typen zu repräsentieren, die eine gemeinsame Schnittstelle haben, aber ein unterschiedliches Verhalten aufweisen. Die Objekte sind austauschbar, da sie die gleichen Methoden besitzen, aber das konkrete Verhalten dieser Methoden kann unterschiedlich sein. Abstrakte Typen werden verwendet, um eine allgemeine Klasse von Objekten zu definieren, ohne sich auf eine bestimmte Implementierung festzulegen.'},
     {'question': 'Was ist die Idee hinter dem Begriff der Substituierbarkeit?', 'answer': 'Die Idee hinter dem Begriff der Substituierbarkeit ist, dass Objekte unterschiedlicher Typen austauschbar sind, wenn sie die gleichen Methoden besitzen und diese auf die gleiche Weise implementieren. Dies ermöglicht es, Objekte verschiedener Typen in einem Programm zu verwenden, ohne dass das Programmverhalten davon beeinflusst wird. Die Substituierbarkeit ist ein wichtiges Prinzip in der objektorientierten Programmierung, da es die Wiederverwendung von Code und die Entwicklung von abstrakten Klassen und Schnittstellen ermöglicht.'},
     {'question': 'Was ist die Bedeutung von einheitlichen Stilrichtlinien in der Softwareentwicklung?', 'answer': 'Einheitliche Stilrichtlinien in der Softwareentwicklung fördern die Kreativität, indem sie die Kreativität auf das Wesentliche konzentrieren. Ein großer Teil der Softwareentwicklung besteht darin, bestehenden Code zu lesen und sicherzustellen, dass der geschriebene Code für andere leicht lesbar ist. Individuelle Eigenheiten sind niemandem von Nutzen, während gemeinsame Konventionen allen helfen.'},
     {'question': 'Was ist das Problem der schlechten Tracebarkeit?', 'answer': 'Das Problem der schlechten Tracebarkeit entsteht durch den dynamischen Programmablauf. Die Goto-Anweisung erlaubt Sprünge von beliebigen Stellen eines Programms zu anderen Stellen und bricht dabei das Lokalitätsprinzip von Programmen, bei dem zusammengehörende Anweisungen im Programmtext nahe beieinander stehen. Dies führte zu einer Unübersichtlichkeit im Programmtext und erschwerte das Verstehen und Debuggen von Programmen.'},
     {'question': 'Welche Probleme ergeben sich bei der Verwendung dynamisch gebundener Unterprogrammaufrufe in der objektorientierten Programmierung?', 'answer': 'Bei der Verwendung dynamisch gebundener Unterprogrammaufrufe in der objektorientierten Programmierung ergibt sich das Problem, dass aus dem Programmtext nicht unmittelbar ersichtlich ist, wohin der Sprung geht. Dies führt zu einer Unsicherheit darüber, welcher Code tatsächlich ausgeführt wird, insbesondere beim Tracen oder Debuggen von Programmen.'},
     {'question': 'Welche Idee aus der formalen Programmverifikation wird verwendet, um das Verhalten von Objekten in der Subtypenbeziehung zu berücksichtigen?', 'answer': 'Die Idee aus der formalen Programmverifikation besteht darin, Vorbedingungen in Nachbedingungen zu überführen, um das Verhalten von Objekten eines Typs zu berücksichtigen. Dies wird verwendet, um sicherzustellen, dass die Implementierung eines Typs korrekt ist und dass aus Vorbedingungen die entsprechenden Nachbedingungen folgen.'},
     {'question': 'Welches Konzept bieten Programmiersprachen wie Java und C-Sharp, um die doppelte Sichtweise auf Typen zu unterstützen?', 'answer': 'Programmiersprachen wie Java und C-Sharp bieten das Konzept von "Interfaces als Typen" an, mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. Dies ermöglicht es den Nutzerinnen, ihre eigenen Anforderungen als Typen zu definieren. Allerdings wird diese Möglichkeit in der Praxis oft nicht genutzt, um Anwenderinnen ihre eigenen Typen definieren zu lassen. Es wird jedoch darauf hingewiesen, dass dies in Zukunft anders gehandhabt werden könnte.'},
     {'question': 'Was ist das Fragile-Base-Class-Problem?', 'answer': 'Das Fragile-Base-Class-Problem bezieht sich auf eine Gruppe von Problemen in der Vererbung von Klassen. Wenn zwischen einer Klasse und ihren Subklassen aufgrund der Vererbung von Eigenschaften starke Abhängigkeiten bestehen, können Änderungen an der Basisklasse zu unerwarteten und unerwünschten Auswirkungen in der abgeleiteten Klasse führen.'},
     {'question': 'Welche Herausforderungen ergeben sich aus dem Fragile-Base-Class-Problem in verteilten Objektsystemen?', 'answer': 'In verteilten Objektsystemen wird das Problem komplexer, da Änderungen an einer Komponente unerwartete Auswirkungen auf verwandte Komponenten haben können. Die Schnittstellen und Beziehungen zwischen Komponenten müssen klar und stabil sein, um unerwartetes Verhalten zu verhindern. Das Problem wird noch schwerwiegender, wenn verschiedene Anbieter Komponenten entwickeln, da Änderungen an einer Komponente die Funktionalität anderer Komponenten beeinträchtigen könnten.'},
     {'question': 'Welche Ansätze werden zur Bewältigung des Fragile-Base-Class-Problems vorgeschlagen?', 'answer': 'Ein Ansatz besteht darin, explizite Vererbungsinterfaces einzuführen, um die Beziehungen zwischen Klassen in einer Vererbungshierarchie klarer zu definieren. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie "protected," "virtual" und "override," um die Überschreibbarkeit von Methoden zu steuern und das Verhalten in Subklassen zu dokumentieren. Jedoch gibt es keine universelle Lösung für das Problem.'},
     {'question': 'Welche Faktoren beeinflussen den Programmierstil in der Softwareentwicklung?', 'answer': 'Programmiersprachen ermöglichen es einer Autorin, sich auf eine persönliche Art und Weise auszudrücken. Die Qualität eines Programms wird nicht durch die Ausdrucksweise bestimmt, sondern durch Faktoren wie Effizienz und Verständlichkeit. Der Programmierstil, der sich ausdrückt, spielt eine entscheidende Rolle für die Verständlichkeit und Qualität eines Programms. Weitere Faktoren wie Mode und Ästhetik (Eleganz) können ebenfalls den Programmierstil beeinflussen.'},
     {'question': 'Welche strukturbildende Einheit wird in der objektorientierten Programmierung auf Programmebene hauptsächlich verwendet?', 'answer': 'Auf Programmebene besteht die strukturbildende Einheit in der objektorientierten Programmierung hauptsächlich aus Klassen.'},
     {'question': 'Welche Herausforderung besteht hinsichtlich der Strukturierung von Klassen in der objektorientierten Programmierung?', 'answer': 'Eine Herausforderung besteht darin, dass die hierarchische Struktur objektorientierter Systeme auf Klassenebene nicht immer vorschreibbar ist. Objekte einer Klasse sind nicht immer Teile von Objekten anderer Klassen, sondern können auch einzelne Exemplare (Instanzen) sein und selbst Teile haben können. Es fehlen Konstrukte zur Definition von Komponenten als separate strukturbildende Einheiten neben Klassen und Objekten.'},
     {'question': 'Welches Beispiel wird gegeben, um das Problem der Substituierbarkeit zwischen den Typen Set (Menge) und Bag (Multimenge) zu erklären?', 'answer': 'Das Beispiel betrifft die Substituierbarkeit zwischen den Typen Set (Menge) und Bag (Multimenge). Wenn Set als Subtyp von Bag angesehen wird, gibt es Probleme, da Sets einige charakteristische Eigenschaften von Multimengen verletzen, wie die Größenänderung nach dem Hinzufügen eines Elements. Wenn Bag als Subtyp von Set angesehen wird, wird die charakteristische Eigenschaft verletzt, dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist.'},
     {'question': 'Was ist das Problem, das im Zusammenhang mit Subtyping und dynamischem Methodenaufruf auftritt?', 'answer': 'Das Problem besteht darin, dass aufgrund des dynamischen Bindens von Methodenaufrufen nicht vorhergesagt werden kann, welchen Effekt ein Aufruf der Methode in einem bestimmten Programmfragment haben wird, selbst wenn der Typ des Empfängerobjekts bekannt ist. Es ist schwer zu bestimmen, welcher Subtyp des Typs des Empfängerobjekts tatsächlich betroffen ist.'},
     {'question': 'Welche Variante der objektorientierten Programmierung scheint besser für die GUI-Programmierung geeignet zu sein?', 'answer': 'Die prototypenbasierte Variante der objektorientierten Programmierung, wie sie in JavaSCRIPT verwendet wird, scheint besser für die GUI-Programmierung geeignet zu sein.'},
     {'question': 'Was ist das Liskov-Substitutionsprinzip (Liskov substitution principle, LSP) und warum ist es wichtig?', 'answer': 'Das Liskov-Substitutionsprinzip (LSP) ist ein Prinzip im Zusammenhang mit Subtyping, das von Barbara Liskov und Jeannette Wing entwickelt wurde. Es besagt, dass ein Subtyp (z. B. eine abgeleitete Klasse) eines Typs (z. B. eine Basisklasse) sich so verhalten sollte, dass er anstelle des Supertyps (der Basisklasse) in jedem Programm oder Kontext verwendet werden kann, ohne die Korrektheit des Programms zu gefährden. Das LSP ist wichtig, um sicherzustellen, dass Subtypen die Spezifikationen und das Verhalten des Supertyps beibehalten und korrekt verwenden.'},
     {'question': 'Welche beiden Lösungen werden vorgeschlagen, um das Problem der Aliasbildung und zusätzlicher Methodenaufrufe zu lösen?', 'answer': 'Es werden zwei Lösungen vorgeschlagen, um das Problem der Aliasbildung und zusätzlicher Methodenaufrufe zu lösen: Die erste Lösung besagt, dass das Verhalten eines Subtyps immer dann mit dem des Supertyps kompatibel ist, wenn sämtliches zusätzliche Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Dies bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existieren muss, die denselben Effekt wie die zusätzliche Methode hat. Die zweite Lösung erfordert von jedem Typ zusätzlich zur Verhaltensspezifikation der Methoden die Einhaltung von Verlaufseigenschaften, die die möglichen Zustandsänderungen der Objekte des Typs betreffen. Diese werden als Zustandswechselinvarianten bezeichnet und erfordern eine Art Spezifikation endlicher Automaten, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt.'},
     {'question': 'Was ist das Problem der eindimensionalen Strukturierung?', 'answer': 'Bei größeren Programmen kann das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren, da verschiedene Vererbungshierarchien oder andere Strukturierungskriterien gleichzeitig relevant sein können. Die Trennung der Belange, auch als Separation of Concerns bekannt, wird in der objektorientierten Programmierung als unzureichend unterstützt angesehen, da es schwer ist, verschiedene Aspekte eines Systems sauber voneinander zu trennen.'},
     {'question': 'Welche Rolle spielen Klassen in der objektorientierten Programmierung, und wie werden Programme weiter strukturiert?', 'answer': 'Klassen sind die Module der objektorientierten Programmierung. Programme werden durch die Vererbungshierarchie weiter strukturiert, was bedeutet, dass Klassen in einer hierarchischen Beziehung zueinander stehen.'},
     {'question': 'Welche Art von Struktur gibt es parallel zur Vererbungshierarchie, die jedoch nicht hierarchisch ist und sich nicht zur systematischen Programmorganisation eignet?', 'answer': 'Parallel zur Vererbungshierarchie gibt es eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen bzw. Objekten geprägt ist. Diese Struktur ist nicht hierarchisch und eher unorganisiert, weshalb sie sich nicht zur systematischen Programmorganisation eignet.'},
     {'question': 'Was ist das Problem der mangelnden Kapselung?', 'answer': 'Die Vererbung in der objektorientierten Programmierung beeinträchtigt die Kapselung von Klassen auf unangenehme Weise. Vererbung führte zu starken Abhängigkeiten zwischen Klassen und ihren Subklassen, einschließlich der Implementierungsdetails. Diese Abhängigkeiten führten dazu, dass Teile der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufgegeben werden mussten. Das Aliasing-Problem tritt auf, wenn ein Objekt, das von einem anderen Objekt gekapselt wird, auch einen Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dies bedeutet, dass von außen auf das gekapselte Objekt zugegriffen werden kann, indem man den Alias verwendet. Dies stellt eine Herausforderung für die Kapselung dar, da es die Geheimhaltung der Implementierung durchbrechen kann.'},
     {'question': 'Welche Enttäuschung trat auf, die die Kapselung von Klassen beeinflusste?', 'answer': 'Die Enttäuschung trat auf, als man feststellte, dass die Vererbung in der objektorientierten Programmierung die Kapselung von Klassen auf unangenehme Weise beeinträchtigte. Vererbung führte zu starken Abhängigkeiten zwischen Klassen und ihren Subklassen, einschließlich der Implementierungsdetails. Diese Abhängigkeiten konnten dokumentiert, aber nicht beseitigt werden, und sie führten dazu, dass Teile der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufgegeben werden mussten.'},
     {'question': 'Was ist das Aliasing-Problem, und warum stellt es eine Herausforderung für die Kapselung dar?', 'answer': 'Das Aliasing-Problem tritt auf, wenn ein Objekt, das von einem anderen Objekt gekapselt wird, auch einen Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dies bedeutet, dass von außen auf das gekapselte Objekt zugegriffen werden kann, indem man den Alias verwendet. Dies stellt eine Herausforderung für die Kapselung dar, da es die Geheimhaltung der Implementierung durchbrechen kann.'},
     {'question': 'Welche Möglichkeiten zur Kontrolle von Aliasing werden in objektorientierten Programmiersprachen diskutiert?', 'answer': 'Es gibt verschiedene Ansätze zur Kontrolle von Aliasing in objektorientierten Programmiersprachen. Ein Ansatz besteht darin, die Teil-Ganzes-Beziehung zwischen Repräsentationsobjekten und dem Objekt zu definieren, sodass die Teile dem Ganzen gehören und nicht gleichzeitig Teile anderer Objekte sein können. Ein anderer Ansatz ist die Verwendung von Wertobjekten, die keine Referenzen auf andere Objekte zulassen. Ein dritter Ansatz besteht darin, Mechanismen zur Aliaskontrolle in die Programmiersprache zu integrieren, wobei viele dieser Mechanismen noch in der Entwicklung sind.'},
     {'question': 'Was sind Interfaces in der objektorientierten Programmierung?', 'answer': 'Interfaces sind in der objektorientierten Programmierung Typen, die eher Rollen bezeichnen, die Objekte spielen können, als Allgemeinbegriffe. Sie werden häufig durch Substantive oder Adjektive bezeichnet.'},
     {'question': 'Was ist eine Möglichkeit für Programmiererinnen, deren Muttersprache nicht Englisch ist?', 'answer': 'Eine Möglichkeit für Programmiererinnen, deren Muttersprache nicht Englisch ist, ist die Wahl der Bezeichner zwischen zwei Sprachen zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Zum Beispiel können sie für Begrifflichkeiten aus der Anwendungsdomäne deutsche Bezeichner und für solche aus der technischen Umsetzung englische Bezeichner verwenden. Alternativ können sie auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden.'},
     {'question': 'Was ist die Idee hinter der Überführung von Vorbedingungen in Nachbedingungen?', 'answer': 'Die Idee hinter der Überführung von Vorbedingungen in Nachbedingungen stammt aus der formalen Programmverifikation und wird genutzt, um auch das Verhalten der Objekte eines Typs zu berücksichtigen. Dabei werden Vorbedingungen in Nachbedingungen überführt, um die Zuweisungskompatibilität zu regeln.'},
     {'question': 'Was ist eine Vorbedingung und Nachbedingung in der Objektorientierung?', 'answer': 'In der Objektorientierung ist eine Vorbedingung eine Bedingung, die vor der Ausführung einer Methode erfüllt sein muss. Die Nachbedingung ist eine Bedingung, die nach der Ausführung einer Methode erfüllt sein muss. Ein Typ gilt als korrekt implementiert, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung die Nachbedingung folgt.'},
     {'question': 'Was sind Invarianten?', 'answer': 'Invarianten sind Bedingungen, die für alle Zustände eines Objekts gelten müssen.'},
     {'question': 'Was ist der Zweck der Prüfung, ob eine (korrekte) Implementierung durch eine andere (ebenfalls korrekte, aber unterschiedliche) ersetzt werden kann, abhängig vom Verwendungskontext?', 'answer': 'Der Zweck der Prüfung ist es, festzustellen, ob ein Objekt durch ein anderes ersetzt werden kann, selbst wenn die entsprechenden Typen nicht konform sind. Dies ist beispielsweise relevant, wenn mit einem Objekt gar nichts gemacht wird.'},
     {'question': 'Was ist der Zweck der Nachbedingung in der objektorientierten Programmierung?', 'answer': 'Der Zweck der Nachbedingung in der objektorientierten Programmierung ist es, die Korrektheit der Implementierung zu gewährleisten. Die Nachbedingung wird aus der Vorbedingung abgeleitet und gilt für die Implementierung einer Methode in der zugehörigen Klasse. Der Beweis für die Nachbedingung muss nicht geführt werden, da es hier um die Austauschbarkeit von Implementierungen abhängig vom Verwendungskontext geht.'},
     {'question': 'Was ist eine verhaltensbasierte Subtypenrelation?', 'answer': 'Eine verhaltensbasierte Subtypenrelation ist eine Beziehung zwischen potenziellen Subtypen und Supertypen, bei der die Bedingungen betrachtet werden, die erfüllt sein müssen, damit die potenziellen Subtypen die Spezifikation des Supertyps erfüllen und als verhaltenskonform betrachtet werden können. Diese Beziehung wird in Kapitel 26 beschrieben.'},
     {'question': 'Was ist verhaltensbasiertes Subtyping?', 'answer': 'Verhaltensbasiertes Subtyping, auch bekannt als Behavior Subtyping, ist ein Prinzip in der objektorientierten Programmierung, bei dem ein Untertyp die gleichen Methoden wie sein Obertyp haben muss, aber nicht unbedingt die gleichen Attribute. Das bedeutet, dass ein Objekt eines Untertyps die gleichen Methoden wie ein Objekt des Obertyps aufrufen kann, aber nicht umgekehrt.'},
     {'question': 'Was ist Behavior Subtyping?', 'answer': 'Behavior Subtyping, auch verhaltensbasiertes Subtyping genannt, ist eine Art von Subtyping, bei der ein Untertyp die gleichen Methoden wie sein Obertyp haben muss, aber nicht unbedingt die gleichen Attribute.'},
     {'question': 'Was ist das Problem mit der methodenweisen Betrachtung von Bedingungen für die Substituierbarkeit?', 'answer': 'Die methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht nicht aus, weil sie nicht berücksichtigt, dass ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden kann. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel.'},
     {'question': 'Was ist das Problem mit der Substituierbarkeit von Objekten in der objektorientierten Programmierung?', 'answer': 'Das Problem ist, dass ein Objekt vom Typ S, das von einem Klienten als Typ T betrachtet wird, von einem anderen Klienten als Typ S (oder als ein anderer Supertyp als T) betrachtet werden kann. Dadurch können Methoden auf dem Objekt aufgerufen werden, die Zustandsänderungen verursachen, die nicht durch die mit T verbundenen Methodenspezifikationen (Vor- und Nachbedingungen) abgedeckt sind. Dieses Verhalten ist nicht mit dem von T kompatibel und für Benutzer, die das Objekt als T betrachten, nicht akzeptabel.'},
     {'question': 'Was ist Aliasing in der objektorientierten Programmierung?', 'answer': 'Aliasing in der objektorientierten Programmierung bedeutet, dass mehrere Variablen auf dasselbe Objekt verweisen. Das kann dazu führen, dass Zustandsänderungen an dem Objekt von einem Klienten unerwartet für einen anderen Klienten sichtbar werden, da beide Klienten das Objekt über eine eigene Variable referenzieren.'},
     {'question': 'Was ist ein Indikator dafür, dass eine Klasse in mehrere Subklassen aufgeteilt werden sollte?', 'answer': 'Ein guter Indikator dafür ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen.'},
     {'question': 'Was ist ein Indikator dafür, dass eine Klasse nicht nur für eine Abstraktion der Anwendungsdomäne steht, sondern für mehrere?', 'answer': 'Ein guter Indikator dafür ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen.'},
     {'question': 'Was ist ein Indikator dafür, dass eine Klasse in mehrere Spezialisierungen aufgeteilt werden sollte?', 'answer': 'Ein guter Indikator dafür ist das wiederholte Vorkommen gleicher Fallunterscheidungen, insbesondere dann, wenn diese Fallunterscheidungen die Art der Objekte betreffen.'},
     {'question': 'Was ist die ungarische Notation?', 'answer': 'Die ungarische Notation ist eine Namenskonvention, bei der Bezeichner, die für ein Objekt oder einen Wert stehen, den Typ dieses Objekts oder Werts widerspiegeln. Es gibt verschiedene Auslegungen der ungarischen Notation, eine davon verlangt, dass alle Variablen, die Strings bezeichnen, mit "str" beginnen. Eine sinnvollere Auslegung ist, Variablen um die Verwendung ihres so bezeichneten Inhalts zu ergänzen, was in der objektorientierten Programmierung auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt werden kann.'},
     {'question': 'Was ist Substituierbarkeit und wie hängt sie von der Verwendung der Typen ab?', 'answer': 'Substituierbarkeit bezieht sich auf die Möglichkeit, einen Typ durch einen anderen Typ ersetzen zu können. Im Beispiel von "Set" und "Bag" kann die Substituierbarkeit nicht grundsätzlich ausgeschlossen werden, da es Anwendungsfälle geben kann, in denen der eine Typ den anderen ersetzen kann. Die tatsächliche Substituierbarkeit hängt jedoch nicht nur von den beteiligten Typen ab, sondern auch von ihrer Verwendung. Es gibt also keine absolute Substituierbarkeit, die von jeder möglichen Verwendung losgelöst ist.'},
     {'question': 'Was ist die Voraussetzung dafür, dass Objekte ihre Rolle spielen können?', 'answer': 'Die einzige Voraussetzung dafür ist, dass sie typkonform sind.'},
     {'question': 'Was ist die Voraussetzung dafür, dass Objekte typkonform sind?', 'answer': 'Die Voraussetzung dafür, dass Objekte typkonform sind, ist, dass sie die Eigenschaften und Verhaltensweisen besitzen, die von einem Objekt seines Typs erwartet werden.'},
     {'question': 'Was sind Interfaces als Typen?', 'answer': 'Interfaces als Typen sind ein Konzept in Programmiersprachen wie Java und C-Sharp, mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. Diese Möglichkeit wird jedoch selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen.'},
     {'question': 'Was ist das Fragile-Base-Class-Problem?', 'answer': 'Das Fragile-Base-Class-Problem bezieht sich auf eine Familie von Problemen, die eng mit der Vererbung zusammenhängen. Es tritt auf, wenn eine Unterklasse eine Methode der Superklasse überschreibt und diese Änderung unbeabsichtigte Auswirkungen auf andere Unterklassen hat, die ebenfalls diese Methode überschreiben.'},
     {'question': 'Was ist die Bedeutung von Differentia in der Objektorientierung?', 'answer': 'In der Objektorientierung ist Differentia der Teil, der spezifiziert werden muss, während der Rest einfach geerbt wird. Es ist der Unterschied, der eine Klasse von anderen Klassen unterscheidet.'},
     {'question': 'Was ist ein Refactoring?', 'answer': 'Refactoring ist eine semantikerhaltende Umstrukturierung von Code, bei der der Verhaltensumfang der Methode nicht verändert wird, sondern nur die innere Struktur der Methode.'},
     {'question': 'Was ist das Fragile-Base-Class-Problem?', 'answer': 'Das Fragile-Base-Class-Problem bezieht sich auf eine Familie von Problemen, die eng mit der Vererbung zusammenhängen. Es tritt auf, wenn eine Unterklasse eine Methode der Superklasse überschreibt und diese Änderung unbeabsichtigte Auswirkungen auf andere Unterklassen hat, die ebenfalls diese Methode überschreiben.'},
     {'question': 'Was ist die Vererbung von Implementierung?', 'answer': 'Die Vererbung von Implementierung ist eine Technologie zum Erstellen von Anwendungen, bei der eine Komponente von einer anderen Komponente abgeleitet wird oder Teile ihrer Funktionalität erbt.'},
     {'question': 'Was ist Vererbung von Implementierung und welche Probleme kann sie verursachen?', 'answer': 'Vererbung von Implementierung ist eine Technologie, die es ermöglicht, eine Komponente von einer anderen Komponente abzuleiten oder Teile ihrer Funktionalität zu erben. Diese Technologie kann jedoch viele Probleme in einem verteilten, sich weiterentwickelnden Objektsystem verursachen, da sie die Kopplung zwischen Komponenten erhöht und die Änderungen in der Basiskomponente Auswirkungen auf die abgeleiteten Komponenten haben können.'},
     {'question': 'Was ist ein explizites Vererbungsinterface?', 'answer': 'Ein explizites Vererbungsinterface ist eine Schnittstelle zwischen einer Klasse und ihren Subklassen, die die Eigenschaften definiert, auf die man über die Variablen self oder super zugreifen kann. Im Gegensatz zu anderen Schnittstellen handelt es sich hierbei nicht um eine Abhängigkeit zu anderen Objekten, sondern um eine Schnittstelle, die das Verhalten zwischen einer Klasse und ihren Subklassen regelt.'},
     {'question': 'Was ist das Fragile-Base-Class-Problem in Java?', 'answer': 'Das Fragile-Base-Class-Problem in Java ist ein Problem, bei dem Änderungen an der Superklasse (Basisklasse) eine Unterklasse brechen können, wenn der Zugriffsmodifikator protected, virtual und override nicht berücksichtigt werden.'},
     {'question': 'Was ist ein deklarativer Programmierstil in der objektorientierten Programmierung?', 'answer': 'Ein deklarativer Programmierstil in der objektorientierten Programmierung bemüht sich mehr um das "Was" als um das "Wie". Er ist typisch für die objektorientierte Programmierung und geht einher mit kurzen Methoden und aussagekräftigen Bezeichnern. Der Effizienzgedanke ist dabei sekundär – mögliche Optimierungen werden dem Compiler überlassen und ansonsten für später aufgehoben, wenn sich herausstellen sollte, dass die Abarbeitung einer deklarativ formulierten Lösung zu ineffizient ist.'},
     {'question': 'Was ist eine Shortcut-Variante in der Programmierung?', 'answer': 'Eine Shortcut-Variante ist eine abgekürzte oder optimierte Variante einer Methode, die eine Iteration ggf. vorzeitig abbricht, wenn eine bestimmte Bedingung erfüllt ist. Sie wird auch als "Schnellausgang" oder "Frühausgang" bezeichnet.'},
     {'question': 'Was sind Zusicherungen in einem deklarativen Programmierstil?', 'answer': 'Zusicherungen sind Vor- und Nachbedingungen sowie Invarianten, die anstelle von Kommentaren in einem deklarativen Programmierstil verwendet werden.'},
     {'question': 'Was ist die Bedeutung von Zusicherungen (Assertions) in der Programmierung?', 'answer': 'Zusicherungen (Assertions) sind in der Programmierung eine Möglichkeit, die Richtigkeit von Bedingungen zu einem bestimmten Zeitpunkt während der Ausführung eines Programms zu überprüfen. Wenn die Sprache dies zulässt, können sie auch dazu verwendet werden, dem Aufrufer der Methode zu zeigen, wie er selbst prüfen kann, ob die Vorbedingung eingehalten ist.'},
     {'question': 'Was ist das grundlegende Problem bei der Verwendung von Variablennamen wie "i" in Programmen?', 'answer': 'Das grundlegende Problem ist, dass man sich vertieft in das Programm und den dazugehörigen Text einarbeiten muss, um zu verstehen, wofür die Variablen stehen.'},
     {'question': 'Was ist die strukturbildende Einheit der objektorientierten Programmierung auf Programmebene?', 'answer': 'Die strukturbildende Einheit der objektorientierten Programmierung auf Programmebene ist die Klasse.'},
     {'question': 'Was sind Komponenten in objektorientierter Programmierung?', 'answer': 'In objektorientierter Programmierung werden Komponenten als wiederverwendbare, selbstbeschreibende und austauschbare Einheiten angesehen, die eine bestimmte Funktionalität bereitstellen. Sie werden in der Regel zur Laufzeit, per Aggregation von Objekten, zusammengebaut. Leider ist es mit der Einführung von Komponenten in objektorientierten Programmiersprachen noch nicht besonders weit, da keine weit verbreitete objektorientierte Programmiersprache das Schlüsselwort "component" verwendet oder reserviert. Stattdessen werden Programmierer dazu veranlasst, alles in Form von Klassen zu definieren. Konzepte wie Pakete (Java) oder Assemblies (C-Sharp) können einen Komponentenbegriff nicht ersetzen, da sie lediglich Klassen gruppieren und dabei ignorieren, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann. Es wird vermutet, dass in den nächsten Jahren in diesem Bereich noch der größte Fortschritt erzielt werden kann.'},
     {'question': 'Welches Mittel wird empfohlen, um unnötigen Aufwand und Konflikte in Bezug auf Formatierung zu vermeiden?', 'answer': 'Es wird empfohlen, automatische Codeformatierer zu verwenden, die auf Knopfdruck bestimmte Formatierungskonventionen anwenden. Selbst wenn man alleine arbeitet, sollte man solche Tools nutzen, um sich an allgemein übliche Formatierungsstandards zu halten und die Entwicklung eines persönlichen Programmierstils nicht zu weit von der Norm entfernen zu lassen. Individualität in der Programmierung ist nicht geeignet, um effizienten und wartbaren Code zu produzieren.'},
     {'question': 'Welche Wortarten einer natürlichen Sprache sollten für verschiedene Arten von Programmelementen verwendet werden?', 'answer': 'Es ist angemessen, die verschiedenen Wortarten einer natürlichen Sprache für verschiedene Arten von Programmelementen zu verwenden. Zum Beispiel werden in der objektorientierten Programmierung Substantive oft für Klassennamen verwendet.'},
     {'question': 'Welche Art von Methoden wird oft mit Verben benannt, und welche Formen von Verben können verwendet werden?', 'answer': 'Methoden, die eine Aktion implementieren (Befehle), werden oft mit Verben benannt. Bei der Wahl der Verben ist es eine Stilfrage, ob man die Infinitiv- oder die Imperativform bevorzugt. Beispielsweise kann man "hinzufügen" (Infinitivform) oder "entfernen" (Imperativform) verwenden.'},
     {'question': 'Welche Namenskonvention wird für Methoden, die Abfragen darstellen (Queries), vorgeschlagen?', 'answer': 'Für Methoden, die Abfragen darstellen (Queries), werden oft Adjektive oder Kopula plus Prädikatsnomen verwendet. Beispiele hierfür sind "istLeer" oder "hatInhalt."'},
     {'question': 'Welche Wortarten werden für Instanzvariablen verwendet, abhängig davon, ob sie Attribute oder Beziehungen repräsentieren?', 'answer': 'Für Instanzvariablen, die Attribute repräsentieren, wie Größe oder Farbe, verwendet man oft den Namen der Qualität als Substantiv. Wenn es sich um zweiwertige (Boolesche) Attribute handelt, nimmt man das entsprechende Adjektiv oder ein Gerundivum. Für Instanzvariablen, die Beziehungen repräsentieren, verwendet man oft den Namen der Gegenrolle, wie "mutter" in einer Kind-Mutter-Beziehung.'},
     {'question': 'Was ist eine interessante Option für Programmiererinnen, deren Muttersprache nicht Englisch ist, in Bezug auf die Wahl der Bezeichner?', 'answer': 'Programmiererinnen, deren Muttersprache nicht Englisch ist, haben die Möglichkeit, zwischen zwei Sprachen bei der Wahl der Bezeichner zu wählen und damit eine zusätzliche Form der Differenzierung einzusetzen. Man kann deutsche Bezeichner für Begrifflichkeiten aus der Anwendungsdomäne und englische Bezeichner für technische Umsetzungselemente verwenden, oder alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von denen aus Bibliotheken und Frameworks zu unterscheiden.'},
     {'question': 'Welche Faustregel wird genannt, um einen guten Namen für ein Programmelement auszuwählen?', 'answer': 'Als Faustregel wird genannt, dass ein Name dann gut gewählt ist, wenn man alle Ausdrücke, in denen er vorkommt, schnell und klar verstehen kann. Ein gut gewählter Name sollte keine falschen Assoziationen oder Vermutungen hervorrufen und sollte somit leicht verständlich sein. Es ist ratsam, sich Zeit für die Auswahl eines passenden Namens zu nehmen, da dies eine sorgfältige Überlegung erfordert und die Lesbarkeit des Codes erheblich verbessern kann.'},
     {'question': 'Welches Refactoring-Verfahren wird häufig angewendet, um Teile einer Methode in separate Methoden auszulagern?', 'answer': 'Das "Extract-method"-Refactoring-Verfahren wird häufig angewendet, um Teile einer Methode in separate Methoden auszulagern. Dieses Verfahren ermöglicht es, Teile des Codes in neue Methoden auszulagern, selbst wenn diese Teile vorerst nur von ihrer ursprünglichen Position aus aufgerufen werden, um die Lesbarkeit zu verbessern. Es handelt sich um eine gängige Praxis in der objektorientierten Programmierung.'},
     {'question': 'Was ist ein wichtiges Merkmal der objektorientierten Programmierung in Bezug auf die Größe von Klassen?', 'answer': 'Ein wichtiges Merkmal der objektorientierten Programmierung ist, dass Klassen nicht ins Uferlose wachsen sollten. Wenn der Methodenumfang einer Klasse zu groß wird, deutet dies darauf hin, dass die Klasse möglicherweise mehrere Abstraktionen repräsentiert oder auf einem höheren Abstraktionsniveau steht als die aktuelle Implementierung.'},
     {'question': 'Welche Gründe können dazu führen, dass eine Klasse in der objektorientierten Programmierung zu groß wird?', 'answer': 'Es gibt zwei mögliche Gründe, warum eine Klasse in der objektorientierten Programmierung zu groß werden kann: Die Klasse repräsentiert nicht nur eine Abstraktion der Anwendungsdomäne, sondern mehrere. In diesem Fall sollte die Klasse in mehrere Teilklassen aufgeteilt werden, wobei jede Teilklassen eine Abstraktion darstellt, und die Daten und Methoden entsprechend zugeordnet werden. Die Klasse repräsentiert eine Abstraktion der Anwendungsdomäne auf einem höheren Abstraktionsniveau als die aktuelle Implementierung. Dies kann entweder bedeuten, dass die Klasse eine Generalisierung darstellt und alle Spezialisierungen in einer Klasse zusammengefasst sind oder dass die Klasse eine Aggregation oder Komposition darstellt und Teile als logische Einheiten identifiziert werden müssen.'},
     {'question': 'Welche Schritte sollten unternommen werden, wenn eine Klasse zu groß wird?', 'answer': 'Wenn eine Klasse zu groß wird, sollten die folgenden Schritte unternommen werden, abhängig von der Ursache der Größe: Wenn die Klasse mehrere Abstraktionen repräsentiert, sollte die Klasse in mehrere Teilklassen aufgeteilt werden, wobei jede Teilklassen eine Abstraktion darstellt, und die Daten und Methoden entsprechend zugeordnet werden. Wenn die Klasse eine Generalisierung darstellt, sollten die unterschiedlichen Spezialisierungen identifiziert und die jeweils darauf bezogenen Daten und Funktionen in neu zu schaffende Subklassen verlagert werden. Das gemeinsame Protokoll sollte idealerweise in der neuen Superklasse verbleiben. Wenn die Klasse eine Aggregation oder Komposition darstellt, sollten die Teile als logische Einheiten identifiziert und neue Klassen formuliert werden. Falls diese neuen Klassen außerhalb der Abstraktion keine Bedeutung haben, kann in Erwägung gezogen werden, sie als innere Klassen zu deklarieren, um den Namensraum nicht unnötig zu überfrachten und die Anzahl der wahrgenommenen Klassen nicht unnötig zu erhöhen.'},
     {'question': 'Was ist eine gängige Namenskonvention in Bezug auf Interfacetypen?', 'answer': 'Eine gängige Namenskonvention ist, Namen von Interfacetypen mit einem großen "I" beginnen zu lassen. Zum Beispiel könnte ein Interface "Auto" als "IAuto" benannt werden.'},
     {'question': 'Was ist die ungarische Notation in Bezug auf Namenskonventionen?', 'answer': 'Die ungarische Notation ist eine Namenskonvention, bei der Bezeichner, die für ein Objekt oder einen Wert stehen (wie Variablen und Funktionsnamen), den Typ dieses Objekts oder Werts widerspiegeln. Es gibt verschiedene Auslegungen der ungarischen Notation.'},
     {'question': 'Was sind die möglichen Auslegungen der ungarischen Notation?', 'answer': 'Eine mögliche Auslegung der ungarischen Notation verlangt, dass Variablen, die Strings bezeichnen, mit "str" beginnen. Diese Auslegung kann jedoch als weniger sinnvoll angesehen werden, da Compiler und IDE bereits Informationen über den Typ der Variablen bereitstellen und diese Information den Namen der Variablen nicht zusätzlich belasten sollte. Eine sinnvollere Auslegung der ungarischen Notation schlägt vor, Variablen um die Verwendung ihres Inhalts zu ergänzen. Das bedeutet, die Funktion des durch die Variable bezeichneten Objekts oder Werts innerhalb des Kontextes anzugeben, in dem die Variable gültig ist. Dies ermöglicht es, die Funktion kontextbezogen auszudrücken, ohne den Namen der Variable mit redundanten Informationen zu belasten. In der objektorientierten Programmierung kann diese kontextbezogene Funktion oft auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt werden, was vom Compiler überprüft werden kann.'},
     {'question': 'Welche Rolle spielen Bibliotheken in der objektorientierten Programmierung?', 'answer': 'Bibliotheken spielen eine entscheidende Rolle in der objektorientierten Programmierung. Sie sind ein wesentlicher Bestandteil des objektorientierten Programmierstils und tragen maßgeblich zum Erfolg dieses Ansatzes bei.'},
     {'question': 'Welche Techniken und Praktiken kennzeichnen den deklarativen Programmierstil in der objektorientierten Programmierung?', 'answer': 'Der deklarative Programmierstil in der objektorientierten Programmierung zeichnet sich durch folgende Techniken und Praktiken aus: Verwendung von aussagekräftigen Bezeichnern, die beschreiben, was eine Methode tut. Aufteilung von komplexen Funktionen in separate Methoden mit klaren Namen. Betonung des "Was" anstelle des "Wie" bei der Formulierung des Codes. Verwendung von Zusicherungen (Vor- und Nachbedingungen, Invarianten) anstelle von Kommentaren, um die Absichten und Bedingungen des Codes deutlicher zu machen. Zurückhaltung bei der Verwendung von Optimierungen, die die funktionale Äquivalenz gefährden könnten, bis ihre Auswirkungen vollständig verstanden sind.'},
     {'question': 'Was ist der Sinn und Zweck des Gesetzes Demeters in der objektorientierten Programmierung?', 'answer': 'Der Sinn und Zweck des Gesetzes Demeters ist es, die Kopplung und die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wenn das Gesetz Demeters verletzt wird, kann eine Änderung des Protokolls einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zur Klasse stehen, was vermieden werden sollte.'},
     {'question': 'Welche Art von Zugriffsregel führt Demeters Gesetz faktisch ein?', 'answer': 'Demeters Gesetz führt faktisch eine neue, kontextabhängige Zugriffsregel ein: Eigenschaften von Objekten, die ein Objekt nicht selbst kennt, sind für das Objekt gleichgestellt mit denen von Objekten, die es zwar selbst kennt, auf die es aber nicht zugreifen darf. Dies führt zu einer klaren Trennung zwischen direkten und indirekten Beziehungen zwischen Objekten.'},
     {'question': 'Was ist Substituierbarkeit in Bezug auf Typerweiterung und Typeinschränkung?', 'answer': 'Substituierbarkeit bedeutet, dass ein Objekt eines Typs durch ein Objekt eines anderen Typs ersetzt werden kann, ohne dass die Korrektheit des Programms beeinträchtigt wird. Wenn eine Typerweiterung vorliegt, ist die Substituierbarkeit in der Regel unproblematisch. Wenn jedoch eine Typeinschränkung vorliegt, kann die Substituierbarkeit fraglich sein, da das ersetzende Objekt möglicherweise nicht die gleichen Eigenschaften und Methoden aufweist wie das ursprüngliche Objekt.'},
     {'question': 'Was ist fraglich bei der Substituierbarkeit, wenn es sich um eine Typeinschränkung handelt?', 'answer': 'Wenn es sich um eine Typeinschränkung handelt, ist die Substituierbarkeit fraglich.'},
     {'question': 'Was ist eine mögliche Folge davon, wenn eine Funktion in einem Subtyp so abgeändert wird, dass sie dem erwarteten Verhalten des Supertyps widerspricht?', 'answer': 'Eine mögliche Folge davon ist, dass das Verhalten des Programms schwer vorherzusagen und zu verstehen ist, was zu Fehlern und unerwarteten Ergebnissen führen kann.'},
     {'question': 'Was sind die Eigenschaften von Sets?', 'answer': 'Sets sind eine Datenstruktur, die die Eigenschaften besitzt, dass jedes Hinzufügen eines Elements die Größe nicht unbedingt um 1 erhöht und dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden. Doppelte Einfügungen werden von Sets einfach ignoriert.'},
     {'question': 'Was sind die charakteristischen Eigenschaften von Multimengen (Bags)?', 'answer': 'Die charakteristischen Eigenschaften von Multimengen (Bags) sind, dass jedes Hinzufügen eines Elements die Größe um 1 erhöht und dass genauso viele Elemente entnommen werden können, wie hinzugefügt wurden.'},
     {'question': 'Was ist ein mögliches Problem, wenn man Bag als Subtyp von Set annimmt?', 'answer': 'Wenn man Bag als Subtyp von Set annimmt, kann dies dazu führen, dass die für Set charakteristische Eigenschaft verletzt wird, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt. Je nach Standpunkt kann dies als Typfehler angesehen werden.'},
     {'question': 'Was ist der Grund für den Typfehler, wenn man Bag als Subtyp von Set annimmt?', 'answer': 'Der Grund für den Typfehler ist, dass die für Set charakteristische Eigenschaft verletzt wird, nämlich dass nach dem Entfernen eines Elements dieses nicht mehr in der Menge enthalten ist. Programme, die darauf basieren, dass diese Eigenschaft garantiert wird und die stattdessen eine Multimenge erhalten, funktionieren nicht mehr korrekt.'},
     {'question': 'Was ist das Problem bei der Definition von Subtypen für Bag und Set?', 'answer': 'Die charakteristischen Eigenschaften von Bag und Set stehen im Widerspruch zueinander, so dass sich keine korrekten Aussagen bilden lassen, die für alle Objekte vom Typ X gelten sollen, die auch die vom jeweils anderen Typen Y einschließen. Dies steht im Widerspruch zur Definition des Subtypings, daher ist es eine Frage der Interpretation, ob die syntaktischen Bedingungen für das Subtyping ausreichen oder ob strengere Substituierbarkeitsbedingungen erfüllt sein müssen.'},
     {'question': 'Was ist das Problem bei der Definition von Subtypen?', 'answer': 'Das Problem bei der Definition von Subtypen ist, dass die charakteristischen Eigenschaften eines Typs nicht die des anderen implizieren und sich tatsächlich im Widerspruch zueinander befinden. Daher lassen sich keine korrekten Aussagen bilden, die Objekte vom Typ X einschließen sollen, die auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird.'},
     {'question': 'Was ist das Ziel des Gesetzes Demeters?', 'answer': 'Das Ziel des Gesetzes Demeters ist es, die Kopplung und damit die Entwurfsabhängigkeiten zwischen Klassen zu verringern. Wenn das Gesetz Demeters verletzt wird, kann die Änderung (des Protokolls) einer Klasse dazu führen, dass auch Klassen angepasst werden müssen, die selbst in keiner unmittelbaren Beziehung zu der Klasse stehen.'},
     {'question': 'Was ist Subtyping in der objektorientierten Programmierung?', 'answer': 'Subtyping ist ein Konzept in der objektorientierten Programmierung, das die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen soll. Es erlaubt, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Dadurch wird die Erweiterung um Subklassen oder Subtypen ermöglicht.'},
     {'question': 'Was ist Subtyping und welches Problem ergibt sich daraus?', 'answer': 'Subtyping ist ein Begriff in der objektorientierten Programmierung, der die Zuweisungskompatibilität zwischen verschiedenen Typen ermöglichen soll. Das bedeutet, dass Objekte eines Typs Variablen eines anderen Typs, nämlich eines Supertyps, zugewiesen werden können. Das Problem, das sich daraus ergibt, ist, dass aufgrund des dynamischen Bindens von Methodenaufrufen bei Vorliegen des Programmfragments selbst bei Kenntnis des Typs T nicht vorhergesagt werden kann, welchen Effekt der Aufruf der Methode m in Zeile 1509 hat. In einer statischen, lokalen Betrachtung befinden wir uns in einem Zustand völliger Unsicherheit.'},
     {'question': 'Was ist das Problem der formalen Programmverifikation?', 'answer': 'Das Problem der formalen Programmverifikation ist die Beziehung P {e m} Q, bei der vor der Ausführung des Methodenaufrufs e m die Bedingung P gilt und nach seiner Ausführung die Bedingung Q erfüllt sein muss. Ein solcher Beweis erfordert genaue Kenntnisse über die Implementierung der Methode.'},
     {'question': 'Was ist der Begriff der Substituierbarkeit?', 'answer': 'Der Begriff der Substituierbarkeit ermöglicht eine lokale, "modulare" Betrachtung bei der Analyse von Methodenaufrufen, indem er die Gewissheit bietet, dass man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte.'},
     {'question': 'Was ist der Zweck der Substituierbarkeit?', 'answer': 'Der Zweck der Substituierbarkeit in der objektorientierten Programmierung ist es, die Gewissheit zu haben, dass eine lokale, "modulare" Betrachtung ausreicht und man nicht jedes Mal eine Analyse des gesamten Programms durchführen muss, um zu entschlüsseln, was ein Methodenaufruf bewirken könnte.'},
     {'question': 'Was ist das Hammerprinzip in der objektorientierten Programmierung?', 'answer': 'Das Hammerprinzip in der objektorientierten Programmierung bedeutet, dass Programmiererinnen dazu neigen, alle Probleme mit objektorientierter Programmierung zu lösen, auch wenn andere Programmierparadigmen besser geeignet wären.'},
     {'question': 'Was ist weniger geeignet für die objektorientierte Programmierung?', 'answer': 'Probleme, die einen hohen algorithmischen Anteil und vergleichsweise einfache Datenstrukturen verlangen, sind weniger geeignet für die objektorientierte Programmierung.'},
     {'question': 'Was ist das Ziel der Objektorientierung?', 'answer': 'Das Ziel der Objektorientierung ist es, die Komplexität von Software zu reduzieren, indem sie die Software in kleinere, leichter zu verstehende Einheiten aufteilt, die Objekte genannt werden und Instanzen von Klassen sind.'},
     {'question': 'Was ist ein Impedanzmismatch zwischen relationalen Datenbanken und objektorientierten Programmen?', 'answer': 'Ein Impedanzmismatch zwischen relationalen Datenbanken und objektorientierten Programmen ist das Problem, dass sich beide Welten in ihrer Art und Weise unterscheiden, wie sie Daten und Beziehungen darstellen. Relationale Datenbanken sind wertbasiert und stellen Beziehungen über die Verwendung gleicher Werte in Schlüsseln und Fremdschlüsseln sowie über Join-Operationen her, während objektorientierte Programme zeigerbasiert sind und Beziehungen über Referenzen und deren Dereferenzierung (Navigation) herstellen. Vererbung bzw. Subtyping, für die objektorientierte Programmierung charakteristisch ist, gibt es in relationalen Datenbanken gar nicht. Daher muss man sich, wenn relationale Daten durch objektorientierte Programme verarbeitet werden sollen, an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben.'},
     {'question': 'Was ist ein Impedanzmismatch?', 'answer': 'Ein Impedanzmismatch ist ein Problem, das auftritt, wenn relationale Daten durch objektorientierte Programme verarbeitet werden sollen. Dies liegt daran, dass relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Um dieses Problem zu lösen, muss man sich an die Prinzipien der relationalen Welt anpassen und damit einen Großteil dessen, was Objektorientierung ausmacht, aufgeben.'},
     {'question': 'Was ist Liskov-Substitutionsprinzip (LSP)?', 'answer': 'Das Liskov-Substitutionsprinzip (LSP) ist ein Prinzip im Zusammenhang mit verhaltensbasiertem Subtyping. Es besagt, dass ein Objekt der Unterklasse eines anderen Objekts der Oberklasse ohne Einschränkung der Korrektheit des Programms ersetzt werden kann. Es ist eines der am häufigsten diskutierten Themen im Zusammenhang mit Subtyping.'},
     {'question': 'Was ist das Liskov-Substitutionsprinzip?', 'answer': 'Das Liskov-Substitutionsprinzip ist eine ausreichende Bedingung für die Subtypenbeziehung zwischen zwei Typen. Es besagt, dass ein Typ B, der als Subtyp eines Typs A deklariert ist, in einem Programm an allen Stellen, an denen ein Objekt vom Typ A erwartet wird, durch ein Objekt vom Typ B ersetzt werden kann, ohne dass das Programm dadurch in seiner Funktionalität beeinträchtigt wird.'},
     {'question': 'Was ist verhaltensbezogenes Subtyping?', 'answer': 'Verhaltensbezogenes Subtyping geht über die syntaktische Subtypenbeziehung hinaus und fordert, dass sich Objekte eines Subtyps und seines Supertyps gleich verhalten sollten. Diese Forderung wird als "Subtype Requirement" bezeichnet und besagt, dass eine Eigenschaft, die für Objekte eines Typs gilt, auch für Objekte eines Subtyps gelten sollte.'},
     {'question': 'Was ist die Subtypenbeziehung?', 'answer': 'Die Subtypenbeziehung ist eine Beziehung zwischen zwei Typen, bei der der Untertyp alle Eigenschaften des Obertyps erfüllt. Das bedeutet, dass ein Objekt des Untertyps auch als Objekt des Obertyps behandelt werden kann. Diese Beziehung wird oft durch eine Hierarchie von Klassen dargestellt, bei der eine Unterklasse eine spezifischere Version einer Oberklasse ist.'},
     {'question': 'Was sind Vor- und Nachbedingungen in typlosen Sprachen?', 'answer': 'In typlosen Sprachen wie Smalltalk werden die Anforderungen an die Parameterobjekte mithilfe von Vor- und Nachbedingungen formuliert. Vorbedingungen beschreiben die Bedingungen, die vor der Ausführung einer Methode erfüllt sein müssen, während Nachbedingungen die Bedingungen beschreiben, die nach der Ausführung der Methode erfüllt sein müssen. Die Menge der ausgelösten Ausnahmen ist Teil der Nachbedingungen.'},
     {'question': 'Was sind Zustandswechselinvarianten?', 'answer': 'Zustandswechselinvarianten sind Verlaufseigenschaften, die die möglichen Zustandsänderungen von Objekten betreffen. Sie werden benötigt, um eine weniger restriktive Lösung für die Spezifikation von Methoden zu ermöglichen, die neben Vor- und Nachbedingungen auch die Zustandsänderungen von Objekten berücksichtigt. Dazu ist eine Art Spezifikation endlicher Automaten erforderlich, die die Menge der möglichen Zustände und Zustandsübergänge beschreibt. Um den Zustandsraum kombinatorisch zu vermeiden, werden bei den historischen Zustandswechseln lediglich zwei beliebige, zeitlich nicht notwendigerweise aufeinanderfolgende Zustände betrachtet, für die eine Bedingung formuliert wird, die eingehalten werden muss.'},
     {'question': 'Was sind historische Invarianten und Zustandswechselinvarianten?', 'answer': 'Historische Invarianten sind Bedingungen, die für den Zustand eines Objekts während seiner gesamten Lebensdauer gelten. Zustandswechselinvarianten sind Bedingungen, die für den Zustand eines Objekts während eines Zustandsübergangs gelten. Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.'},
     {'question': 'Was ist die Trennung der Belange (Separation of Concerns) in der objektorientierten Programmierung?', 'answer': 'Die Trennung der Belange, auch Separation of Concerns genannt, ist ein Prinzip in der objektorientierten Programmierung, das die Aufgaben und Verantwortlichkeiten von Objekten und Komponenten klar trennen soll. Es ist jedoch unzureichend unterstützt und kann die Komplexität nur in das Zusammenführen der Sichten verschieben.'},
     {'question': 'Was ist die Bedeutung der Kapselung in der objektorientierten Programmierung?', 'answer': 'Die Kapselung ist ein Konzept in der objektorientierten Programmierung, bei dem Daten und Implementierungsdetails hinter der Klassenschnittstelle verbergen werden können. Das Konzept der Kapselung ermöglicht es, Klassen auf natürliche Weise aus der Anwendungsdomäne abzuleiten und trägt zur besseren Organisation und Strukturierung des Codes bei.'},
     {'question': 'Was ist Kapselung in der objektorientierten Programmierung?', 'answer': 'Kapselung in der objektorientierten Programmierung ist ein Konzept, bei dem Daten und Implementierungsdetails in einer Klasse verborgen werden und nur über eine Schnittstelle (das Protokoll der Objekte) zugänglich sind. Dies ermöglicht es, die Komplexität von Systemen zu reduzieren und die Wartbarkeit und Erweiterbarkeit von Code zu verbessern.'},
     {'question': 'Was ist das Aliasing-Problem in der Objektorientierung?', 'answer': 'Das Aliasing-Problem ist ein Problem in der Objektorientierung, bei dem ein Objekt, das durch ein anderes Objekt gekapselt wird, einen weiteren Alias besitzt, der nicht selbst dem kapselnden Objekt gehört. Dadurch kann man auf das gekapselte Objekt zugegriffen werden, auch wenn die Instanzvariable von außen unzugreifbar ist.'},
     {'question': 'Was ist ein Beispiel für fehlerhafte Verwendung von Aliase?', 'answer': 'Ein Beispiel für fehlerhafte Verwendung von Aliase ist das folgende: Angenommen, Sie wollten eine Ampelsimulation an einem Fußgängerüberweg programmieren. Die Ampel soll verschiedene Leuchten haben, von denen jede unabhängig voneinander ein- und ausschaltbar sein soll. Wenn man Aliase fehlerhaft einsetzt, kann es passieren, dass eine Änderung an einer Leuchte sich auf andere Leuchten auswirkt, obwohl dies nicht beabsichtigt war.'},
     {'question': 'Was sind Repräsentationsobjekte?', 'answer': 'Repräsentationsobjekte sind Objekte, die die Implementierung eines anderen Objekts ausmachen und die hinter der Schnittstelle des Objekts verborgen werden sollen. Sie kommen lediglich als „Innereien“ der Objekte vor, deren Repräsentation sie ausmachen.'},
     {'question': 'Was ist Aliasing und wie kann es bei der Spezifikation von sicherheitskritischen Anwendungen problematisch sein?', 'answer': 'Aliasing bedeutet, dass mehrere Variablen auf das gleiche Objekt verweisen. Bei der Spezifikation von sicherheitskritischen Anwendungen kann Aliasing problematisch sein, da es mit der Spezifikation nicht vereinbar wäre, wenn es von außen auf geheime Daten- oder Funktionsträger gibt. Am Programmverhalten ist dies jedoch nicht zu erkennen.'},
     {'question': 'Was ist Aliasing und wie kann es zu Problemen führen?', 'answer': 'Aliasing bedeutet, dass mehrere Variablen auf das gleiche Objekt verweisen. Dies kann zu Problemen führen, wenn die Kapselung von Objekten (das Geheimnisprinzip) Gegenstand der Spezifikation eines Programms ist, da Aliase von außen auf diese Objekte als geheime Daten- oder Funktionsträger zugreifen können. Dies ist bei sicherheitskritischen Anwendungen der Fall, bei denen Daten geschützt werden müssen oder Funktionen nur durch autorisierte Benutzer ausgeführt werden dürfen. Am Programmverhalten ist dies jedoch nicht zu erkennen.'},
     {'question': 'Was ist Aliasing und wie kann es kontrolliert werden?', 'answer': 'Aliasing bedeutet, dass mehrere Variablen auf ein und dasselbe Objekt verweisen. Um Aliasing zu kontrollieren, muss man sicherstellen, dass dies nicht geschieht oder dass es bei der Ausführung des Programms keine negativen Auswirkungen hat. Dies kann durch verschiedene Methoden erreicht werden, wie zum Beispiel durch die Verwendung von lokalen Variablen oder durch Kopien von Objekten anstelle von Referenzen.'}],
    [{'question': 'Wie kann man sich den Variableninhalt ansehen, wenn man nicht weiß, an welcher Stelle man schauen muss?', 'answer': 'In der Praxis bleibt nur, das Programm erneut auszuführen, vor dem dynamisch gebundenen Aufruf zu stoppen und sich den Variableninhalt anzusehen.'},
     {'question': 'Wie kann man die Beschränkung umgehen, wenn die Bibliotheksdesignerin alle relevanten Klassen final deklariert hat?', 'answer': 'Eine Möglichkeit, diese Beschränkung zu umgehen, ist die Konvention, die Klasse, von der geerbt werden soll, als abstrakt zu deklarieren und eine Subklasse davon abzuleiten, die zunächst keine Änderungen hinzufügt, dafür aber konkret und final ist. Sollte die Bibliotheksdesignerin Änderungen durchführen wollen, kann sie das zunächst an ihrer finalen Klasse tun und nur, wenn sie sich vollkommen sicher ist, dass sie alle Klienten ihrer Bibliothek mit den Änderungen beglücken möchte, die Änderungen in der abstrakten Superklasse durchführen.'},
     {'question': 'Wie versuchte man das Problem der schlechten Tracebarkeit durch Goto-Anweisungen zu lösen?', 'answer': 'Man versuchte, das Problem der schlechten Tracebarkeit durch das Vermeiden von Goto-Anweisungen zu lösen. Stattdessen setzte man auf strukturierte Programmierung, die Verzweigung, Wiederholung und Unterprogrammaufrufe verwendete, um den Programmfluss zu steuern.'},
     {'question': 'Wie wird der Begriff der Substituierbarkeit in der Programmierung betrachtet?', 'answer': 'Der Begriff der Substituierbarkeit bezieht sich darauf, ob eine Zuweisung zwischen verschiedenen Typen gutgeht, ohne Fehler zu verursachen. Dieser Begriff wird unabhängig von der Zuweisungskompatibilität betrachtet und kann als eigenständiger Begriff betrachtet werden.'},
     {'question': 'Wann wird die Frage der Substituierbarkeit interessant?', 'answer': 'Die Frage der Substituierbarkeit wird interessant, wenn Objekte nicht derselben Klasse angehören und eine gewisse Abweichung im Verhalten der zu substituierenden Objekte erlaubt ist.'},
     {'question': 'Wann werden Objekte als nicht gegeneinander austauschbar angesehen?', 'answer': 'Objekte werden als nicht gegeneinander austauschbar angesehen, wenn eine Funktion, die in einem Typ definiert ist, in einem anderen Typ schlicht fehlt. Dies ist der Fall, wenn das Verhalten eines Typs nicht das erwartete Verhalten eines anderen Typs bietet, was zu Inkompatibilitäten führt.'},
     {'question': 'Wie kann man dem Umstand der relativen Substituierbarkeit begegnen?', 'answer': 'Man kann dem Umstand der relativen Substituierbarkeit begegnen, indem man nicht nur die Sichtweise der Person berücksichtigt, die die Typen erstellt (die Anbieterin), sondern auch die Sichtweise der Person, die die Typen für einen bestimmten Zweck verwendet (die Nutzerin). Die Nutzerin kann ihre Erwartungen an einen Typen definieren, indem sie einen eigenen Typen erstellt, der nur die benötigten Eigenschaften umfasst. Dieser Typ spezifiziert die Rolle, die die Objekte im Kontext der Verwendung spielen sollen. Die Auswahl der Typen, deren Objekte für spezielle Zwecke in Frage kommen, erweitert sich dadurch, ohne die Substituierbarkeit zu beeinträchtigen.'},
     {'question': 'Wie kann die Programmiererin ihre Erwartungen an Typen ausdrücken?', 'answer': 'Die Programmiererin kann ihre Erwartungen an Typen ausdrücken, indem sie einen eigenen Typen definiert, der nur die benötigten Eigenschaften umfasst. Dieser Typ stellt gewissermaßen die Rolle dar, die die Objekte im Kontext der Verwendung spielen sollen. Durch die Definition solcher Typen kann die Programmiererin ihre Anforderungen klar ausdrücken und sicherstellen, dass die Typen ihren speziellen Zwecken entsprechen.'},
     {'question': 'Wie kann man das Fragile-Base-Class-Problem verhindern?', 'answer': 'Eine Möglichkeit zur Vermeidung des Problems besteht darin, explizite Schnittstellen oder Vererbungsinterfaces einzuführen, die genau definieren, welche Eigenschaften und Methoden von Subklassen erwartet werden. Ein weiterer Ansatz ist die Verwendung von Zugriffsmodifikatoren und Schlüsselwörtern wie "virtual" und "override," um die Überschreibbarkeit und das Verhalten von Methoden in der Vererbungshierarchie zu steuern.'},
     {'question': 'Wie hat sich der Programmierstil im Laufe der Zeit entwickelt?', 'answer': 'In den letzten Jahrzehnten gab es einen Wandel im Programmierstil weg von einem mathematisch prägnanten Stil hin zu einem prosaisch-verbosen Stil. Früher wurden oft kurze und kryptische Bezeichner für Variablen verwendet, während heute der Trend zu aussagekräftigen und selbstdokumentierenden Bezeichnern geht. Ein Beispiel zeigt den Unterschied zwischen den beiden Stilen: Früher wurden Variablen oft als "i" bezeichnet, während heute aussagekräftigere Namen verwendet werden, die im Kontext ihre Bedeutung klar machen.'},
     {'question': 'Wie wird die Prüfung der Substituierbarkeit in der Praxis durchgeführt?', 'answer': 'In der Praxis wird die Prüfung der Substituierbarkeit durch Typüberprüfungsverfahren, insbesondere die Prüfung der Typkonformität, angenähert. Dabei wird jedoch betont, dass nicht einmal eine Substituierbarkeit ausgeschlossen werden kann, wenn mangelnde Typkonformität vorliegt. Substituierbarkeit erfordert auch eine Betrachtung des Verhaltens der Objekte.'},
     {'question': 'Wie kann das Problem des dynamischen Bindens und der Unsicherheit bei Methodenaufrufen in Bezug auf Subtyping ausgedrückt werden?', 'answer': 'Das Problem kann als ein Problem der formalen Programmverifikation ausgedrückt werden. Es geht darum, wie bewiesen werden kann, dass Methodenaufrufe unter Berücksichtigung des Empfängerobjekts korrekt gebunden werden können. Dies erfordert genaue Kenntnisse darüber, welchen Effekt der Methodenaufruf hat, was die Kenntnis der Implementierung der Methode erfordert.'},
     {'question': 'Wie kann das Problem der Substituierbarkeit dazu beitragen, das Problem des dynamischen Bindens und der Unsicherheit bei Methodenaufrufen zu lösen?', 'answer': 'Das Konzept der Substituierbarkeit zielt darauf ab, sicherzustellen, dass eine lokale, "modulare" Betrachtung ausreicht, um zu verstehen, welchen Effekt ein Methodenaufruf haben wird, ohne eine umfassende Analyse des gesamten Programms durchführen zu müssen. Substituierbarkeit soll sicherstellen, dass die Bedingungen, unter denen die Methodenaufrufe korrekt sind, bekannt sind, und dass die Implementierungen von Methoden für Subtypen eines bestimmten Typs korrekt verwendet werden können.'},
     {'question': 'Wie können Substantive in der Programmierung verwendet werden?', 'answer': 'In der Programmierung können Substantive für Klassennamen verwendet werden. Diese Technik wird oft in der Analysephase eines Projekts angewendet, um die Menge der Klassen eines Systems zu identifizieren.'},
     {'question': 'Wie sollten Methoden, die eine Aktion implementieren, benannt werden?', 'answer': 'Methoden, die eine Aktion implementieren, sollten mit Verben benannt werden, wobei es eine Stilfrage ist, ob man die Infinitiv- oder die Imperativform bevorzugt. Die Namen sollten so gewählt werden, dass sie möglichst lesbar sind.'},
     {'question': 'Wie werden Methoden bezeichnet, die eine Abfrage darstellen?', 'answer': 'Methoden, die eine Abfrage darstellen, werden als Queries bezeichnet und werden mit Adjektiven oder Kopula plus Prädikatsnomen benannt.'},
     {'question': 'Wie werden Instanzvariablen benannt, die ein Attribut repräsentieren?', 'answer': 'Für Instanzvariablen, die ein Attribut repräsentieren, wird der Name der Qualität verwendet, die das Attribut ausdrückt. Dabei wird ein Substantiv (ggf. in Kleinschreibung) verwendet.'},
     {'question': 'Wie werden Instanzvariablen benannt, die eine Beziehung repräsentieren?', 'answer': 'Für Instanzvariablen, die Beziehungen ausdrücken, nimmt man gerne den Namen der Gegenrolle, also beispielsweise "mutter" in einer Kind-Mutter-Beziehung. Bei n-Beziehungen nehme ich persönlich gerne den Plural, also z. B. "kinder" (statt "kind") für die umgekehrte Richtung.'},
     {'question': 'Wie kann man mit der Substituierbarkeit von Typen umgehen?', 'answer': 'Man kann der Substituierbarkeit von Typen begegnen, indem man die Sichtweise der Programmiererin berücksichtigt, die die Typen für einen bestimmten Zweck verwenden möchte. Diese Programmiererin weiß genau, welche Erwartungen sie an einen Typen hat und kann beurteilen, welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind.'},
     {'question': 'Wie kann man die Substituierbarkeit von Typen und die darauf basierende Subtypenbeziehung berücksichtigen?', 'answer': 'Man kann dies tun, indem man die Sichtweise der Programmiererin berücksichtigt, die die Typen erstellt und sich um deren Substituierbarkeit kümmert, sowie die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte. Nur diese Programmiererin weiß genau, welche Erwartungen sie an einen Typen hat, und nur sie kann beurteilen, welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind.'},
     {'question': 'Wie können Programmierer ihre Erwartungen an Objekte ausdrücken?', 'answer': 'Programmierer können ihre Erwartungen an Objekte ausdrücken, indem sie selbst einen Typen definieren, der nur die Eigenschaften umfasst, die sie benötigen. Ein solcher Typ spezifiziert gewissermaßen die Rolle, die die Objekte im Kontext der Verwendung spielen sollen.'},
     {'question': 'Wie kann das Fragile Base-Class-Problem verhindert werden, wenn die Schuld nicht feststeht?', 'answer': 'Das Fragile Base-Class-Problem kann verhindert werden, indem man eine klare Schnittstelle definiert und sicherstellt, dass alle Klassen diese Schnittstelle einhalten. Zudem sollten Subklassen die Möglichkeit haben, die Verhaltensweise der übergeordneten Klassen zu überschreiben, ohne dass dies zu unerwarteten Nebenwirkungen führt. Das Problem kann außerdem verhindert werden, indem man eine klare Dokumentation und Kommunikation zwischen den Subklassen und Superklassen pflegt, um sicherzustellen, dass die geerbten Methoden die eigenen Methoden aufrufen. Zudem kann man eine Schnittstelle definieren, die von der Superklasse und allen Subklassen eingehalten wird, um sicherzustellen, dass die Methodenaufrufe konsistent sind.'},
     {'question': 'Wie ist die objektorientierte Programmierung im Hinblick auf imperative und deklarative Programmierung?', 'answer': 'Objektorientierte Programmierung ist eher imperativ als deklarativ, aber es ist möglich, einen deklarativen Stil zu verwenden, indem man einzelne Schleifen in eigene Methoden verschiebt und durch Methodenaufrufe ersetzt.'},
     {'question': 'Wie werden Typen und Variablen in Java bezeichnet?', 'answer': 'In Java werden Typen und Variablen häufig gleich benannt, sich nur in der Groß- bzw. Kleinschreibung ihres Anfangsbuchstabens unterscheidend. Ein typisches Beispiel dafür ist das folgende:'},
     {'question': 'Wann sollte man einen langen Namen für eine Variable bevorzugen?', 'answer': 'Einen langen Namen für eine Variable sollte man bevorzugen, wenn der Typ der Variablen nicht mehr angegeben wird (Typinferenz), wenn die Sichtbarkeit der Variablen nicht auf die unmittelbare Umgebung der Deklaration beschränkt ist oder wenn der Typ der Variable aus dem Kontext nicht abgeleitet werden kann.'},
     {'question': 'Wie beeinflusst die Ausdrucksweise einer Programmiersprache die Qualität eines Programms?', 'answer': 'Die Ausdrucksweise einer Programmiersprache beeinflusst die Qualität eines Programms, indem sie die Effizienz der Problemlösung und die Verständlichkeit der Formulierung beeinflusst. Dies hängt von Faktoren wie Schreibstil, Mode und Ästhetik ab.'},
     {'question': 'Wie beeinflusst die Ausdrucksweise die Qualität eines Programms?', 'answer': 'Die Ausdrucksweise in Programmiersprachen beeinflusst die Qualität eines Programms, indem sie die Effizienz der Problemlösung und die Verständlichkeit der Formulierung beeinflusst. Dies hängt von Faktoren wie Schreibstil, Mode und Ästhetik ab.'},
     {'question': 'Wann werden temporäre Variablen vom System entfernt?', 'answer': 'Temporäre Variablen werden vom System nach Beendigung der Methode entfernt.'},
     {'question': 'Wann müssen temporäre Variablen in einer Methode deklariert werden?', 'answer': 'Temporäre Variablen müssen in einer Methode zu Beginn der Methode (nach der Methodensignatur und vor der ersten Anweisung) deklariert werden.'},
     {'question': 'Wie kann man Demeters Gesetz folgen und gleichzeitig die Funktion von Ausdrücken haben?', 'answer': 'Man erweitert das Protokoll der Klasse des ersten Nachrichtenempfängers um die Methode(n), die man nicht verkettet aufrufen darf, und lässt das Ergebnis von "doX" die Methode "doY" aufrufen und das Ergebnis zurückgeben.'},
     {'question': 'Wie können Objekte in objektorientierten Systemen strukturiert werden?', 'answer': 'Objekte können in objektorientierten Systemen mithilfe der Teil-Ganzes-Beziehung rekursiv aufgebaut werden, wobei Teile hinter Ganzen verbergen können. Für Klassen gilt das nicht, da Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind. Stattdessen können Objekte einzelne Exemplare (Instanzen) sein, die Teile haben können. Komponenten als zusätzliches Programmiersprachenkonstrukt können hierbei helfen, die Struktur von objektorientierten Systemen zu beschreiben.'},
     {'question': 'Wie werden Komponenten in objektorientierten Programmiersprachen bisher behandelt?', 'answer': 'Bislang ist es mit der Einführung von Komponenten in objektorientierten Programmiersprachen noch nicht besonders weit. Es gibt kein weit verbreitetes Schlüsselwort "component" und Komponenten werden immer zur Laufzeit, per Aggregation von Objekten, zusammengebaut. Pakete oder Assemblies können keinen Komponentenbegriff ersetzen, da sie lediglich Klassen gruppieren.'},
     {'question': 'Wie kann die Einhaltung von Namenskonventionen die Kreativität der Entwicklerinnen fördern?', 'answer': 'Die Einhaltung von Namenskonventionen kann die Kreativität der Entwicklerinnen fördern, indem sie die schöpferische Energie auf die relevanten Aspekte lenkt. Durch die Festlegung bestimmter Regeln wird die Entwicklerin in ihrer kreativen Gestaltung eingeschränkt, was jedoch dazu führen kann, dass die Kreativität gezielter eingesetzt wird und besser zur Geltung kommt.'},
     {'question': 'Wie kann die Analysephase eines Projekts zur Identifizierung der Klassen eines Systems beitragen?', 'answer': 'In der Analysephase eines Projekts können alle Substantive aus der Spezifikation extrahiert werden, um auf der Basis dieser Liste die Menge der Klassen eines Systems zu identifizieren. Dies ist eine vielzitierte objektorientierte Technik.'},
     {'question': 'Wann sollte der lange Name einer Variable bevorzugt werden?', 'answer': 'Der lange Name einer Variable sollte bevorzugt werden, sobald dies nicht mehr der Fall ist, wenn die Sichtbarkeit der Variable über die unmittelbare Umgebung der Deklaration hinausgeht, wie es typischerweise bei der Deklaration von Instanzvariablen der Fall ist. Dies gilt auch, wenn der Typ der Variable aus dem Kontext abgeleitet werden kann (Typinferenz).'},
     {'question': 'Wie kann man die Einhaltung des Gesetzes Demeters sicherstellen und dennoch die Funktionalität von Ausdrücken beibehalten?', 'answer': 'Um sowohl die Funktionalität von Ausdrücken beizubehalten als auch das Gesetz Demeters einzuhalten, kann man das Protokoll der Klasse des ersten Nachrichtenempfängers erweitern. Dies bedeutet, dass die Klasse des von "a" benannten Objekts um die Methode "doY" erweitert wird, wenn "a" das Ergebnis von "doX" ist. Dadurch wird sicherer gestellt, dass "a" auch die Methode "doY" aufruft und das Ergebnis zurückgibt.'},
     {'question': 'Wann wird das Gesetz Demeters typischerweise verletzt, und wie äußert sich diese Verletzung?', 'answer': 'Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks vorliegen. Dies tritt oft bei Kettenaufrufen auf oder kann durch eine zwischenzeitliche Zuweisung zu einer temporären Variable erfolgen. Eine Verletzung des Gesetzes Demeters äußert sich darin, dass Nachrichten an Objekte gesendet werden, die nicht vom Sender direkt gekannt oder erzeugt wurden.'},
     {'question': 'Wie wird das Gesetz Demeters oft in einer kurzen Phrase zusammengefasst?', 'answer': 'Das Gesetz Demeters wird oft in folgender Phrase zusammengefasst: "Sprich nicht mit Fremden." In Bezug auf SMALLTALK bedeutet dies, dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen.'},
     {'question': 'Wann ist die Substituierbarkeit fraglich?', 'answer': 'Die Substituierbarkeit ist fraglich, wenn die neue Klasse eine Eigenschaft besitzt, die die alte Klasse nicht besitzt.'},
     {'question': 'Wann wird das Gesetz Demeters typischerweise verletzt?', 'answer': 'Das Gesetz Demeters wird typischerweise verletzt, wenn Nachrichten an Objekte gesendet werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks vorliegen, wie zum Beispiel bei Kettenaufrufen oder über eine zwischenzeitliche Zuweisung zu einer temporären Variablen.'},
     {'question': 'Wie kann das Problem der Aliasbildung bei der Übergabe von Objekten als Argumente gelöst werden?', 'answer': 'Das Problem der Aliasbildung kann durch zwei Lösungen gelöst werden: Die Aliasbildung wird vermieden, indem die Objekte, die als Argumente übergeben werden, kopiert werden. Dadurch wird sichergestellt, dass die Methode nur auf eine Kopie des Objekts zugreift und nicht auf das Original. Oder die Aliasbildung wird zugelassen, aber die Methodenaufrufe werden begrenzt, was bedeutet, dass die Methode nur auf die Objekte zugreifen kann, die ihr als Argumente übergeben werden, und nicht auf die Objekte, auf die diese Objekte verweisen.'},
     {'question': 'Wie kann das Problem der Aliasbildung gelöst werden?', 'answer': 'Das Problem der Aliasbildung kann durch die Verwendung von lokalen Variablen gelöst werden, die eine Kopie des Objekts enthalten, oder durch die Verwendung von lokalen Prozeduren, die das Objekt manipulieren, ohne dass es zu einer Aliasbildung kommt.'},
     {'question': 'Wie hängen historische Invarianten und Zustandswechselinvarianten zusammen?', 'answer': 'Wenn alle Methoden des Supertyps die historischen Invarianten einhalten und eine Methode des Subtyps sich als Kombination von Methoden des Supertyps darstellen lässt, die ebenfalls die historischen Invarianten einhalten, dann sind die Zustandswechselinvarianten ebenfalls erfüllt.'},
     {'question': 'Wie werden Klassen in der objektorientierten Programmierung strukturiert?', 'answer': 'Die Menge der Module und damit das Programm werden durch die Vererbungshierarchie weiter strukturiert. Parallel dazu gibt es noch eine Struktur, die durch das Bestehen von Beziehungen zwischen Klassen geprägt ist. Diese ist jedoch nicht hierarchisch und insgesamt eher unorganisiert. Die Klassenhierarchie stellt also insbesondere keine Form der hierarchischen Modularisierung dar.'},
     {'question': 'Wie wirkt sich Vererbung auf die Kapselung von Klassen aus?', 'answer': 'Vererbung kann die Kapselung von Klassen auf unangenehme Weise aufbrechen, indem sie starke Abhängigkeiten zwischen Klassen und ihren Subklassen erzeugt. Diese Abhängigkeiten explizit zu machen, kann zwar vor Programmierfehlern schützen, aber die Abhängigkeiten nicht beseitigen. Die Abhängigkeiten zu beschränken, bedeutet, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben.'},
     {'question': 'Wie kann man sicherstellen, dass eine Methode in einer Klasse keine Aliase anlegt und verwendet?', 'answer': 'Um sicherzustellen, dass eine Methode in einer Klasse keine Aliase anlegt und verwendet, kann man die Implementierung der Klasse überprüfen und sicherstellen, dass sie keine Aliase erstellt oder verwendet. Zusätzlich kann man die Sprache und die Laufzeitumgebung überprüfen, um sicherzustellen, dass sie keine Aliase automatisch erzeugen.'},
     {'question': 'Wie kann das Geheimnisprinzip umgangen werden?', 'answer': 'Das Geheimnisprinzip kann umgangen werden, indem Repräsentationsobjekte, deren Namen verborgen werden sollen, noch andere Namen besitzen, zum Beispiel wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt oder wenn das Objekt selbst eine Referenz auf ein Repräsentationsobjekt herausgibt, beispielsweise durch einen Getter.'},
     {'question': 'Wie kann man die Teil-Ganzes-Beziehung zwischen Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, in Programmierung verstehen?', 'answer': 'Man kann das Bestreben nach Kapselung als Ausdruck des Bestehens einer Teil-Ganzes-Beziehung zwischen den Repräsentationsobjekten und dem Objekt, dessen Repräsentation sie ausmachen, verstehen. Die Teile sollen dabei dem Ganzen gehören in dem Sinne, dass sie nicht zugleich auch Teile anderer Objekte sein können, und darüber hinaus auch nicht von anderen Objekten referenziert werden können.'},
     {'question': 'Wie kann man verhindern, dass Objekte von anderen Objekten referenziert werden können?', 'answer': 'Eine Möglichkeit, dies zu verhindern, ist, aus den Objekten Wertobjekte zu machen und die verwendete Programmiersprache keine Zeiger auf Wertobjekte erlaubt. Dies ist jedoch nur in einigen Programmiersprachen möglich, wie zum Beispiel in C-Sharp im Safe mode, wenn die „Klasse“ der Teil-Objekte per "struct" definiert wurde. Diese Vorgehensweise ist jedoch nur selten ohne unerwünschte Nebenwirkungen, da alle Objekte dieser „Klasse“ nur Wertobjekte sein und keine Referenzen haben dürfen, was die Anwendungsdomäne in der Regel nicht korrekt abbildet.'},
     {'question': 'Wie geht EIFFEL mit Referenz- und Wertvariablen um?', 'answer': 'EIFFEL erlaubt, auf Wertobjekte Referenzen zu haben, aber bei der Zuweisung einer Referenzvariable an eine Wertvariable wird immer eine (aliasfreie) Kopie des referenzierten Objekts erzeugt und zugewiesen, sodass kein Alias in die Repräsentation hinein entstehen kann. Umgekehrt wird bei der Zuweisung eines Wertobjekts an eine Referenzvariable immer eine Kopie des Wertobjekts erzeugt und die Referenz darauf angelegt. Somit sind Wertobjekte in EIFFEL aliasfrei.'}],
    [{'question': 'Was bedeutet "gute Programmierung"?', 'answer': 'Laut dem Kurstext bedeutet "gute Programmierung", dass der Programmtext und der Programmablauf einander möglichst ähnlich sind, genauer gesagt, dass die (statische) Struktur des Programms möglichst viele Rückschlüsse auf seinen (dynamischen) Ablauf zulässt.'},
     {'question': 'Was war das Hauptproblem schlechter Programmierung?', 'answer': 'Das Hauptproblem schlechter Programmierung war die große Diskrepanz zwischen statischem, linearem Programmtext und dynamischem, stark verzweigendem und sich wiederholendem Programmablauf.'},
     {'question': 'Warum wird die Verwendung von Goto-Anweisungen im Programmieren nicht empfohlen?', 'answer': 'Die Verwendung von Goto-Anweisungen verursacht ein hohes Maß an Nichtwissen bei der Interpretation von Quelltext, insbesondere beim Debugging von Programmen ist der Blick in den Quelltext des Programms nur bedingt von Nutzen.'},
     {'question': 'Was ist der Unterschied zwischen dem dynamischen Vorgänger einer Anweisung und dem Unterprogrammaufruf?', 'answer': 'Der dynamische Vorgänger einer Anweisung ist die Anweisung, die unmittelbar davor ausgeführt wurde. Beim Unterprogrammaufruf hingegen wird der Kontrollfluss an eine andere Stelle im Programm übergeben, was zu einer gewissen Unwissenheit führt. Allerdings ist diese Unwissenheit im Vergleich zum Goto geringer und bietet den Vorteil, dass Code dupliziert werden kann und die Programmierung in Abschnitte unterteilt werden kann, die getrennt untersucht und verstanden werden können.'},
     {'question': 'Was ist der Unterschied zwischen dem dynamischen Vorgänger einer Anweisung und dem Goto?', 'answer': 'Der dynamische Vorgänger einer Anweisung ist die Anweisung, die unmittelbar davor im Programmablauf ausgeführt wurde. Beim Goto wird die Programmlogik durch Sprunganweisungen unterbrochen, was zu einer unübersichtlichen Programmstruktur führen kann. Im Gegensatz dazu bietet der dynamische Vorgänger eine klare und strukturierte Abfolge der Anweisungen.'},
     {'question': 'Was ist der Unterschied zwischen der Unwissenheit, die durch einen Unterprogrammaufruf und durch eine Goto-Anweisung verursacht wird?', 'answer': 'Die Unwissenheit, die durch einen Unterprogrammaufruf verursacht wird, ist im Vergleich zu der beim Goto gering.'},
     {'question': 'Welche Vorteile bietet ein Unterprogrammaufruf gegenüber der Duplizierung von Code?', 'answer': 'Durch den Unterprogrammaufruf wird die Duplizierung von Code vermieden, was die Notwendigkeit beseitigt, die Anweisungen des Unterprogramms im Aufrufkontext zu halten, wenn es mehrere solche Aufrufkontexte gibt. Dies erleichtert die Unterteilung von Programmen in Abschnitte, die getrennt untersucht und verstanden werden können.'},
     {'question': 'Was ist der Vorteil von lokalen Variablen in Unterprogrammen?', 'answer': 'Der Vorteil von lokalen Variablen in Unterprogrammen ist, dass die Programmiererin das Unterprogramm korrekt benutzen kann, ohne in das Unterprogramm hineinschauen zu müssen. Sie muss also nicht die Anweisungen des Unterprogramms inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt.'},
     {'question': 'Was ist der Vorteil von Unterprogrammen?', 'answer': 'Der Vorteil von Unterprogrammen ist, dass die Programmiererin nicht in das Unterprogramm hineinschauen muss, um es korrekt benutzen zu können. Sie muss also nicht die Anweisungen des Unterprogramms inspizieren, wenn ihr eigentliches Interesse dem Kontext der Aufrufstelle gilt. Umgekehrt muss sie, wenn sie das Unterprogramm interessiert, nicht wissen, von wo es überall aufgerufen wird.'},
     {'question': 'Warum ist es wichtig, dass die Programmiererin nicht in das Unterprogramm hineinschauen muss, um es korrekt benutzen zu können?', 'answer': 'Es ist wichtig, dass die Programmiererin nicht in das Unterprogramm hineinschauen muss, um es korrekt benutzen zu können, weil sie sich so auf den Kontext der Aufrufstelle konzentrieren kann und nicht abgelenkt wird durch die Implementierungsdetails des Unterprogramms. Dies erleichtert die Lesbarkeit und Wartbarkeit des Codes.'},
     {'question': 'Warum ist es wichtig, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert?', 'answer': 'Es ist wichtig, jede Teilfunktion der Klasse zuzuordnen, deren Daten sie manipuliert, um das Vermeiden von doppeltem Code sowie die stufenweise Verfeinerung zu gewährleisten und die Implementierung größerer Funktionen in kleinere Unterprogramme aufzuteilen. Diese Disziplin hilft, den Überblick über das Programm zu behalten, auch wenn die Unterprogrammaufrufe in so kurzer Folge erfolgen, dass man schnell den Kontextwechsel verlieren kann.'},
     {'question': 'Was passiert, wenn man die Klasse des Empfängerobjekts nicht kennt?', 'answer': 'Wenn man die Klasse des Empfängerobjekts nicht kennt, ist es nicht möglich, an der Stelle der betrachteten Anweisung zu bestimmen, von woher der in der Anweisung zuvor angestoßene Unterprogrammaufruf zurückkehrt. Das Lokalitätsprinzip wird also durch das dynamische Binden weiter aufgeweicht als durch den Unterprogrammaufruf allein.'},
     {'question': 'Warum wird dynamisches Binden in der objektorientierten Programmierung kritisiert?', 'answer': 'Kritikerinnen der objektorientierten Programmierung haben das dynamische Binden als eine Art Goto der 90er Jahre betrachtet. Dieser Vergleich ist jedoch nicht ganz fair, weil die Aufruferin nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen. Es reicht zu wissen, welchen Vertrag die aufgerufene Methode erfüllt.'},
     {'question': 'Warum ist der Vergleich des dynamischen Bindens mit Goto der 90er Jahre nicht ganz fair?', 'answer': 'Der Vergleich ist nicht ganz fair, weil im Gegensatz zum Goto die Aufruferin nicht wissen muss, welche genauen Anweisungen als Antwort darauf ausgeführt werden müssen, sondern es reicht zu wissen, welchen Vertrag die aufgerufene Methode erfüllt. Diese Unabhängigkeit vom vertragserfüllenden Objekt ist ein wichtiger Unterschied zum Goto.'},
     {'question': 'Warum kann es bei der Betrachtung der Aufrufstelle interessant sein, was in der aufgerufenen Methode passiert ist?', 'answer': 'Es kann interessant sein, weil man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann und mehr Informationen über die Abläufe in der aufgerufenen Methode benötigt.'},
     {'question': 'Warum ist es in der Praxis nicht immer möglich, den aufgerufenen Code anzuschauen?', 'answer': 'In der Praxis ist es nicht immer möglich, den aufgerufenen Code anzuschauen, weil man nicht weiß, an welcher Stelle man schauen muss. Man muss das Programm erneut ausführen, vor dem dynamisch gebundenen Aufruf stoppen und sich den Variableninhalt ansehen oder den Programmablauf Schritt für Schritt verfolgen.'},
     {'question': 'Warum ist es wichtig, den aufgerufenen Code anzuschauen, wenn man sich eine bestimmte, resultierende Variablenbelegung nicht erklären kann?', 'answer': 'Es ist wichtig, den aufgerufenen Code anzuschauen, um zu verstehen, was in der aufgerufenen Methode passiert ist und wie sich dies auf die Variablenbelegung ausgewirkt hat. Dies kann hilfreich sein, um Fehler zu debuggen und das Verhalten des Programms zu verstehen.'},
     {'question': 'Sind objektorientierte Programme schwerer zu tracen und zu debuggen als prozedurale?', 'answer': 'Es ist wohl unbestritten, dass objektorientierte Programme schwerer zu tracen und zu debuggen sind als prozedurale. Jedoch scheint die Antwort für viele Programmiererinnen positiv zu sein, dass der Gewinn durch das dynamische Binden den Preis aufwiegt.'},
     {'question': 'Warum werden objektorientierte Programme als schwerer zu tracen und zu debuggen angesehen als prozedurale?', 'answer': 'Objektorientierte Programme werden als schwerer zu tracen und zu debuggen angesehen als prozedurale, weil sie dynamisch gebundene Unterprogrammaufrufe verwenden, was die Nachverfolgung von Programmabläufen erschweren kann.'},
     {'question': 'Warum sollten nur die Blätter der Klassenhierarchie instanziierbar sein?', 'answer': 'Die Blätter der Klassenhierarchie sollten instanziierbar sein, weil man die Implementierung einer Klasse ändern will, ohne die Implementierung der Superklasse ändern zu müssen. Wenn man mit der Funktionalität einer Klasse nicht zufrieden ist, will man die Implementierung der Klasse ändern, ohne die Implementierung der Superklasse ändern zu müssen.'},
     {'question': 'Warum kann eine Änderung am Verhalten einer Klasse Auswirkungen auf andere Klassen haben?', 'answer': 'Eine Änderung am Verhalten einer Klasse kann Auswirkungen auf andere Klassen haben, weil wenn die Klasse, deren Verhalten man ändern möchte, selbst Subklassen hat, jede Änderung sich auf diese Subklassen ausbreiten und den Vertrag dieser Klassen mit ihren Klienten brechen kann. Auch wenn die Designerin sicher ist, dass die Änderung innerhalb der Bibliothek keine anderen als die gewünschten Auswirkungen hat, kann sie nicht sicher sein, dass irgendeine Verwenderin ihrer Bibliothek von der Klasse, die sie gerade geändert hat, erbt und somit eine Verhaltensänderung erfährt, mit der sie nicht leben kann.'},
     {'question': 'Warum sind Formatierungskonventionen wichtig in der Teamarbeit?', 'answer': 'Formatierungskonventionen sind wichtig in der Teamarbeit, um eine einheitliche Formatierung des Codes zu gewährleisten und somit die Lesbarkeit und Verständlichkeit zu erhöhen. Sie vermeiden den Effekt, dass jede Programmiererin im Team ihre eigenen Vorlieben pflegt, was zu unnötigen Änderungen und Konflikten führen kann.'},
     {'question': 'Warum sollte man sich zur Angewohnheit machen, automatische Codeformatierer einzusetzen?', 'answer': 'Man sollte sich zur Angewohnheit machen, automatische Codeformatierer einzusetzen, um Energieverschwendung zu vermeiden, Codierungs-konventionen umzusetzen, sich nicht zu weit von dem, was allgemein üblich ist, zu entfernen und sich auf die Entwicklung des persönlichen Programmierstils zu konzentrieren.'},
     {'question': 'Was bedeutet Zuweisungskompatibilität?', 'answer': 'Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs dort auftreten dürfen, wo Objekte eines anderen Typs erwartet werden. Wenn dies gutgeht, also wenn durch eine entsprechende Zuweisungskompatibilität keine Fehler entstehen, spricht man von der Substituierbarkeit der Objekte des Typs auf der linken Seite der Zuweisung durch die des Typs auf der rechten.'},
     {'question': 'Was ist der Vorteil, wenn man die Betrachtung von Substituierbarkeit von der Laufzeit auf die Übersetzungs- (oder Entwurfs-)Zeit verlagern kann?', 'answer': 'Der Vorteil ist, dass auf dieser Ebene das Verhalten aller Objekte einer Klasse gleich ist und somit eine gegenseitige Substituierbarkeit von Objekten derselben Klasse automatisch gegeben ist.'},
     {'question': 'Was ist der Unterschied zwischen einer Aktion, die in dem auszutauschenden Typen definiert ist, und einer Aktion, die in dem austauschenden Typ schlicht fehlt?', 'answer': 'Wenn eine Aktion in dem auszutauschenden Typen definiert ist, aber in dem austauschenden Typ fehlt, dann ist diese Aktion nicht austauschbar. Ein Beispiel wäre eine Aktion, für die "rückgängig machen" nicht definiert ist, wie zum Beispiel das Speichern. Ob es ausreicht, die Funktion "rückgängig machen" in Speichern leer zu implementieren, ist diskutierbar. Die formale Spezifikation, nämlich die Aktion rückgängig zu machen, würde nicht erfüllt, und Objekte vom Typ Speichern sind damit nicht gegen andere Objekte vom Typ Aktion austauschbar.'},
     {'question': 'Was ist der Unterschied zwischen Subtypen und austauschbaren Typen?', 'answer': 'Subtypen sind im Allgemeinen nicht gegeneinander austauschbar, während austauschbare Typen es sind. Ein Beispiel für einen Subtyp, der nicht gegen einen anderen Subtyp austauschbar ist, ist eine Aktion, für die "rückgängig machen" nicht definiert ist, während eine Aktion, für die "rückgängig machen" definiert ist, gegen eine Aktion austauschbar ist, für die "rückgängig machen" leer implementiert ist.'},
     {'question': 'Was ist der Unterschied zwischen austauschbaren und nicht austauschbaren Typen?', 'answer': 'Austauschbare Typen sind solche, bei denen eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ vorhanden ist und die gleiche Funktionalität aufweist. Nicht austauschbare Typen hingegen sind solche, bei denen eine Funktion, die in dem auszutauschenden Typen definiert ist, in dem austauschenden Typ fehlt oder eine andere Funktionalität aufweist. Ein Beispiel für nicht austauschbare Typen ist eine Aktion, für die "rückgängig machen" nicht definiert ist, wie beispielsweise Speichern. Es ist diskutierbar, ob es ausreicht, die Funktion "rückgängig machen" in Speichern leer zu implementieren, die Benutzerin ist vermutlich zerknittert, aber das Programm würde immerhin weiterlaufen. Die formale Spezifikation, nämlich die Aktion (das Speichern) rückgängig zu machen, würde freilich nicht erfüllt; Objekte vom Typ Speichern sind damit strenggenommen nicht gegen andere Objekte vom Typ Aktion austauschbar.'},
     {'question': 'Wozu dienen Namenskonventionen?', 'answer': 'Namenskonventionen erleichtern die Bezeichnerwahl, indem sie die schöpferische Freiheit der Programmiererin einschränken und das Lesen von Code, indem sie die Bedeutung des Bezeichners bzw. des dahinterstehenden Programmelements leichter entschlüsseln.'},
     {'question': 'Warum sind gemeinsame Konventionen in der Softwareentwicklung wichtig?', 'answer': 'Gemeinsame Konventionen in der Softwareentwicklung sind wichtig, weil ein großer Teil des Aufwands bei der Softwareentwicklung darin besteht, bestehende Software zu lesen und sicherzustellen, dass andere das Geschriebene leicht verstehen können. Individuelle Eigenheiten sind nicht hilfreich, während gemeinsame Konventionen allen Entwicklern helfen.'},
     {'question': 'Warum wurde die Frage nach "guter Programmierung" besonders mit der Einführung von Hochsprachen und großen Programmen relevant?', 'answer': 'Die Frage nach "guter Programmierung" wurde relevant, weil mit der Verfügbarkeit von Hochsprachen und immer größer werdenden Programmen die Diskrepanz zwischen dem statischen, linearen Programmtext und dem dynamischen, stark verzweigten Programmablauf immer offensichtlicher wurde.'},
     {'question': 'Warum wurde die Goto-Anweisung als Hauptverursacher für schlechte Programmierung identifiziert?', 'answer': 'Die Goto-Anweisung erlaubt Sprünge von beliebigen Stellen eines Programms zu anderen Stellen und bricht dabei das Lokalitätsprinzip von Programmen, bei dem zusammengehörende Anweisungen im Programmtext nahe beieinander stehen. Dies führte zu einer Unübersichtlichkeit im Programmtext und erschwerte das Verstehen und Debuggen von Programmen.'},
     {'question': 'Warum wird das dynamische Binden von Skeptikern und Gegnern der objektorientierten Programmierung manchmal als eine Art Goto der 90er Jahre betrachtet?', 'answer': 'Das dynamische Binden wird manchmal als eine Art Goto der 90er Jahre betrachtet, weil es ähnliche Probleme in Bezug auf Tracebarkeit und Verständlichkeit von Programmen verursachen kann. Es erfordert, den Programmablauf im Kontext des dynamisch aufgerufenen Codes zu verstehen, was die Nachverfolgung und das Debuggen erschwert.'},
     {'question': 'Was bedeutet Zuweisungskompatibilität zwischen verschiedenen Typen?', 'answer': 'Zuweisungskompatibilität zwischen verschiedenen Typen bedeutet, dass Objekte eines Typs an Stellen verwendet werden können, an denen Objekte eines anderen Typs erwartet werden. Es bedeutet, dass die Objekte auf der linken Seite der Zuweisung durch die Objekte auf der rechten Seite substituiert werden können.'},
     {'question': 'Was bedeutet die strengste Auslegung des Begriffs der Substituierbarkeit?', 'answer': 'In der strengsten Auslegung des Begriffs der Substituierbarkeit kann ein Objekt ein anderes nur dann substituieren, wenn sich das auf den Programmablauf in keiner Weise auswirkt. Dies bedeutet, dass die Objekte nicht nur gleich implementiert sein müssen, sondern sich auch im selben Zustand befinden müssen.'},
     {'question': 'Warum ist die Unabhängigkeit vom konkreten Zustand der Objekte wichtig im Zusammenhang mit der Substituierbarkeit?', 'answer': 'Die Unabhängigkeit vom konkreten Zustand der Objekte ermöglicht es, die Substituierbarkeit von der Laufzeit auf die Übersetzungs- oder Entwurfszeit zu verlagern. Auf dieser Ebene ist das Verhalten aller Objekte einer Klasse gleich, da sie durch dieselbe Klassendefinition spezifiziert sind.'},
     {'question': 'Warum könnten funktional äquivalente, aber verschiedene Typen ausgetauscht werden?', 'answer': 'Funktional äquivalente, aber verschiedene Typen können ausgetauscht werden, wenn Unterschiede im Verhalten toleriert oder sogar gewünscht werden. Ein Beispiel dafür ist die plattformunabhängige GUI-Programmierung, bei der GUI-Elemente funktional äquivalent sein können, sich jedoch im Aussehen und Detailverhalten unterscheiden.'},
     {'question': 'Was bedeutet "verhaltensbasiertes Subtyping" oder "Behavior Subtyping"?', 'answer': '"Verhaltensbasiertes Subtyping" oder "Behavior Subtyping" bezieht sich auf eine Subtypenbeziehung, bei der die Bedingungen erfüllt sein müssen, damit die Spezifikation des Subtyps die des Supertyps erfüllt und als verhaltenskonform betrachtet werden kann. Dies bedeutet, dass das Verhalten der Objekte des Subtyps mit dem Verhalten des Supertyps übereinstimmen muss.'},
     {'question': 'Warum reicht eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit nicht aus?', 'answer': 'Eine methodenweise Betrachtung von Bedingungen für die Substituierbarkeit reicht nicht aus, da Aliasings in der objektorientierten Programmierung dazu führen kann, dass ein Objekt vom Typ S von verschiedenen Klienten unterschiedliche Typen hat und Methodenaufrufe auf dem Objekt Zustandsänderungen verursachen können, die nicht durch die mit T verbundenen Methodenspezifikationen abgedeckt sind. Daher muss eine umfassendere Betrachtung erfolgen, die die Auswirkungen des Verhaltens auf den Zustand und die Spezifikation des Typs berücksichtigt.'},
     {'question': 'Warum hängt die Substituierbarkeit von Typen von ihrer jeweiligen Verwendung ab?', 'answer': 'Die Substituierbarkeit von Typen hängt von ihrer jeweiligen Verwendung ab, da verschiedene Anwendungsfälle unterschiedliche Anforderungen an Typen und deren Objekte haben können. Ein Typ kann in einem bestimmten Kontext problemlos durch einen anderen Typen ersetzt werden, während dies in einem anderen Kontext nicht der Fall sein kann. Die Substituierbarkeit ist daher relativ zur Verwendung der Typen.'},
     {'question': 'Warum ist der Name Fragile-Base-Class-Problem etwas irreführend?', 'answer': 'Der Name ist etwas irreführend, da nicht unbedingt die Basisklassen, sondern eher die abgeleiteten Klassen als "anfällig" oder "zerbrechlich" gelten.'},
     {'question': 'Können Sie ein einfaches Beispiel für das Fragile-Base-Class-Problem geben?', 'answer': 'Ja, nehmen wir an, es gibt eine Klasse namens "TapeArchive", die Videobänder archiviert. Später wird eine Subklasse namens "NotifyingTapeArchive" erstellt, die Nachrichten sendet, wenn Bänder archiviert werden. Das Problem besteht darin, dass Änderungen in der Basisklasse "TapeArchive" sich unerwartet auf die Subklasse "NotifyingTapeArchive" auswirken können.'},
     {'question': 'Warum ist es schwierig, das Fragile-Base-Class-Problem zu erkennen?', 'answer': 'Es ist schwer zu erkennen, da die Basisklasse auf den ersten Blick korrekt erscheint. Das Problem besteht darin, dass die Subklasse von bestimmtem Verhalten der Basisklasse abhängt, ohne dass dies in der Basisklasse explizit dokumentiert ist.'},
     {'question': 'Warum ist es wichtig, aussagekräftige Bezeichner in Programmen zu verwenden?', 'answer': 'Die Verwendung von aussagekräftigen Bezeichnern in Programmen trägt zur Verständlichkeit des Codes bei. Gut gewählte Bezeichner drücken im Kontext ihre Bedeutung aus, sodass Kommentare zur Erklärung der Programmelemente oft unnötig werden. Dies erleichtert anderen Entwicklerinnen das Verständnis des Codes und erhöht die Lesbarkeit und Wartbarkeit des Programms.'},
     {'question': 'Warum könnte es in einigen Fällen sinnvoll sein, eine geistreichere Lösung mit einem erklärenden Kommentar zu versehen?', 'answer': 'In einigen Fällen könnte eine Lösung, auch wenn sie in ihrer verständlichsten Form vorliegt, weniger elegant sein als eine raffinierte Variante, die nicht jedem sofort ersichtlich ist. In solchen Situationen kann die Versuchung groß sein, die geistreichere Lösung zu wählen und sie mit einem erklärenden Kommentar zu versehen, um sicherzustellen, dass auch weniger erfahrene Entwicklerinnen den Code nachvollziehen können. Dies ermöglicht es, komplexe Algorithmen oder unkonventionelle Ansätze zu dokumentieren und zu erläutern.'},
     {'question': 'Warum werden große Klassen (mit vielen Attributen und Methoden) in der objektorientierten Programmierung in der Regel vermieden?', 'answer': 'Große Klassen gelten in der Regel als schlechter Stil, da sie die Anwendungsdomäne nicht angemessen widerspiegeln. In der Anwendungsdomäne sind komplexe Dinge normalerweise aus einfacheren Teilen zusammengesetzt, die selbst wieder aus kleineren Teilen bestehen.'},
     {'question': 'Warum sind innere Klassen (in Java) allein keine ausreichende Lösung für die Strukturierung von Klassen?', 'answer': 'Innere Klassen in Java können Klassen strukturieren, aber sie werden relativ wenig verwendet, da sie sich nicht als besonders nützlich erweisen. Objekte einer Klasse sind nicht immer Teile von Objekten anderer Klassen, daher ist die hierarchische Struktur auf Klassenebene nicht immer passend.'},
     {'question': 'Warum können Konzepte wie Pakete (Java) oder Assemblies (C-Sharp) den Begriff der Komponente nicht ersetzen?', 'answer': 'Pakete (Java) oder Assemblies (C-Sharp) gruppieren lediglich Klassen und berücksichtigen nicht, dass dieselbe Klasse Instanzen für Komponenten verschiedener Typen liefern kann. Sie können den Begriff der Komponente daher nicht vollständig ersetzen.'},
     {'question': 'Warum ist die Substituierbarkeit fraglich, wenn keine Typerweiterung vorliegt?', 'answer': 'Die Substituierbarkeit ist fraglich, wenn keine Typerweiterung vorliegt, insbesondere wenn es sich um eine Typeinschränkung handelt. Dies führt zu Problemen, wenn Objekte eines Subtyps an Stellen verwendet werden, an denen Objekte des Supertyps erwartet werden.'},
     {'question': 'Warum kann die Unterdrückung von Eigenschaften bei abgeleiteten Typen in Java problematisch sein?', 'answer': 'In Java ist die Unterdrückung von Eigenschaften bei abgeleiteten Typen problematisch, da sie dazu führen kann, dass an Stellen im Programm, an denen ein Objekt des Supertyps erwartet wird, ein Objekt des Subtyps auftaucht. Dies kann zu schwerwiegenden Programmierfehlern führen, da die erwarteten Funktionen des Supertyps möglicherweise nicht verfügbar sind.'},
     {'question': 'Warum können keine korrekten Aussagen wie "Für alle Objekte vom Typ X gilt..." gebildet werden, wenn X (Bag oder Set) als Subtyp von Y (dem jeweils anderen Typ) betrachtet wird?', 'answer': 'Es können keine korrekten Aussagen wie "Für alle Objekte vom Typ X gilt..." gebildet werden, wenn X (Bag oder Set) als Subtyp von Y (dem jeweils anderen Typ) betrachtet wird, da die charakteristischen Eigenschaften der beiden Typen im Widerspruch zueinander stehen. Dies entspricht nicht der Definition des Subtypings, da die Bedingungen der Ko- und Kontravarianz nicht erfüllt sind.'},
     {'question': 'Warum reicht die Typkonformität allein nicht aus, um Substituierbarkeit sicherzustellen?', 'answer': 'Die Typkonformität allein reicht nicht aus, um Substituierbarkeit sicherzustellen, da auch das Verhalten der Objekte betrachtet werden muss. Typkonformität bedeutet nicht automatisch Substituierbarkeit. Substituierbarkeit erfordert eine Betrachtung des Verhaltens der Objekte.'},
     {'question': 'Warum ist es wichtig zu wissen, wie Methoden einer neu eingeführten Klasse in ein bestehendes Programm integriert werden können?', 'answer': 'Es ist wichtig zu wissen, wie Methoden einer neu eingeführten Klasse in ein bestehendes Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert und keine unerwarteten Verhaltensänderungen auftreten. Dies ist notwendig, um sicherzustellen, dass die neuen Implementierungen sich nahtlos in das bestehende Programm einfügen und die Programmfunktionalität nicht gefährden.'},
     {'question': 'Warum sind nicht alle Aufgaben gleichermaßen zur Lösung per objektorientierter Programmierung geeignet?', 'answer': 'Nicht alle Aufgaben sind gleichermaßen zur Lösung per objektorientierter Programmierung geeignet, da einige Aufgaben besser mit anderen Programmierparadigmen wie funktionale oder logische Programmiersprachen gelöst werden können. Auch Batch- und Scripting-Probleme, die einen imperativ-prozeduralen Charakter haben, eignen sich möglicherweise nicht optimal für die objektorientierte Programmierung.'},
     {'question': 'Warum ist die gute objektorientierte Programmierung bei Problemen mit einem hohen algorithmischen Anteil und einfachen Datenstrukturen möglicherweise weniger geeignet?', 'answer': 'Die gute objektorientierte Programmierung erfordert, den Code auf die Klassen aufzuteilen, die die Daten definieren, auf denen der Code arbeitet. Bei Problemen mit einfachen Datenstrukturen und einem hohen algorithmischen Anteil müssen größere Probleme jedoch in der Regel auf durch verschiedene Klassen definierte Daten zugreifen. Dies kann dazu führen, dass der Code durch seine Datenbindung regelrecht zerfleddert wird.'},
     {'question': 'Warum ist die objektorientierte Programmierung möglicherweise nicht ideal für Programme, in denen es hauptsächlich um Abläufe geht?', 'answer': 'In Programmen, in denen es hauptsächlich um Abläufe geht, möchte man oft, dass die Reihenfolge der Schritte, die auszuführen sind, in einem Stück festgehalten wird. In solchen Fällen steht das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten, was die objektorientierte Programmierung weniger ideal macht.'},
     {'question': 'Warum ist die Wahl einer geeigneten Programmiersprache in der Praxis oft ein Abwägungsproblem?', 'answer': 'Die Wahl einer geeigneten Programmiersprache ist oft ein Abwägungsproblem, da verschiedene Programmiersprachen unterschiedliche Vor- und Nachteile haben. Bei der objektorientierten Programmierung kann die Organisation der Funktionen auf der Strecke bleiben, während bei der prozeduralen Programmierung die Daten häufig in unüberschaubarer Weise hin- und hergeschickt werden oder global sind.'},
     {'question': 'Warum eignen sich Programmiersprachen, die eine Mischung mehrerer Paradigmen erlauben, weniger für Anfängerinnen?', 'answer': 'Programmiersprachen, die eine Mischung mehrerer Paradigmen erlauben, können Anfängerinnen aufgrund ihrer großen Auswahl an Konstrukten und der unüberschaubaren Anzahl von Alternativen überfordern, wie man ein einzelnes Problem lösen kann.'},
     {'question': 'Warum wird bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung oft von einem Impedanzmismatch gesprochen?', 'answer': 'Bei der Verwendung von relationalen Datenbanken in Verbindung mit objektorientierter Programmierung besteht häufig ein Impedanzmismatch, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Die beiden Ansätze verwenden unterschiedliche Mittel zur Darstellung von Beziehungen und Datenstrukturen.'},
     {'question': 'Warum muss man bei der Verarbeitung von relationalen Daten durch objektorientierte Programme oft Prinzipien der relationalen Welt anpassen?', 'answer': 'Bei der Verarbeitung von relationalen Daten durch objektorientierte Programme muss man sich an die Prinzipien der relationalen Welt anpassen, da relationale Datenbanken wertbasiert sind, während objektorientierte Programme zeigerbasiert sind. Dies erfordert häufig, einen Teil dessen, was Objektorientierung ausmacht, aufzugeben.'},
     {'question': 'Warum ist die GUI-Programmierung nicht unbedingt ein Heimspiel für die objektorientierte Programmierung?', 'answer': 'Die GUI-Programmierung ist nicht unbedingt ein Heimspiel für die objektorientierte Programmierung, da die Instanzen einer Klasse alle Methoden teilen und es nicht möglich ist, für verschiedene GUI-Elemente derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Dies kann zu Problemen führen, insbesondere wenn es um das gemeinsame Verhalten von GUI-Elementen geht.'},
     {'question': 'Warum wird darauf hingewiesen, dass das Liskov-Substitutionsprinzip nicht ausschließlich auf die Arbeiten von Barbara Liskov und Jeannette Wing beschränkt ist?', 'answer': 'Es wird darauf hingewiesen, dass das Liskov-Substitutionsprinzip nicht ausschließlich auf die Arbeiten von Barbara Liskov und Jeannette Wing beschränkt ist, um anzuerkennen, dass es frühere Arbeiten gab, die ebenfalls zur Entwicklung dieses Prinzips beigetragen haben. Das Prinzip selbst ist eine wichtige Konzeption in Bezug auf Subtyping und geht über die Beiträge einzelner Personen hinaus.'},
     {'question': 'Warum ist das Liskov-Substitutionsprinzip möglicherweise zu streng formuliert?', 'answer': 'Das Liskov-Substitutionsprinzip (LSP) könnte zu streng formuliert sein, da es einige problematische Aspekte aufweist. Zum Beispiel geht es davon aus, dass Objekte genau die Typen T oder S haben, was nicht auf abstrakte Typen und Interfaces anwendbar ist. Außerdem verlangt es, dass alle Eigenschaften von T auch für S gelten, was im Widerspruch zur eigentlichen Absicht des Subtypings steht, da ein Objekt, das sich in keiner Weise von dem unterscheidet, das es ersetzen soll, keinen Mehrwert bietet. Daher könnte eine weniger strenge Formulierung des Prinzips notwendig sein.'},
     {'question': 'Warum könnte das Liskov-Substitutionsprinzip in der Praxis als zu restriktiv angesehen werden?', 'answer': 'Das Liskov-Substitutionsprinzip (LSP) könnte in der Praxis als zu restriktiv angesehen werden, da es strengere Anforderungen an die Subtypen stellt und einige gültige Programme ablehnt. Zum Beispiel kann es vorkommen, dass ein Subtyp spezifische Methodenaufrufe erlaubt, die nicht im Supertyp vorhanden sind, aber dennoch in bestimmten Kontexten korrekt und sicher sind. Das LSP kann diese Fälle nicht berücksichtigen, was zu einer unnötigen Ablehnung von gültigen Programmen führen kann.'},
     {'question': 'Warum stellt die Klassenhierarchie keine Form der hierarchischen Modularisierung dar?', 'answer': 'Die Klassenhierarchie stellt keine Form der hierarchischen Modularisierung dar, da das Herauslösen eines Teilbaums der Vererbungshierarchie praktisch immer Beziehungen zwischen Mitgliedern des Teilbaums und anderen trennt. Somit werden Beziehungen zwischen Klassenmitgliedern gestört.'},
     {'question': 'Warum kann bei größeren Programmen das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren?', 'answer': 'Bei größeren Programmen kann das Bedürfnis entstehen, ein Programm nach mehreren Kriterien gleichzeitig zu strukturieren, da verschiedene Vererbungshierarchien oder andere Strukturierungskriterien gleichzeitig relevant sein können, ähnlich wie in der Biologie, wo Arten nach verschiedenen Gesichtspunkten klassifiziert werden. Dies erfordert jedoch, dass die verschiedenen Darstellungen getrennt gepflegt werden und keine Inkonsistenzen oder ungewollten Interferenzen entstehen.'},
     {'question': 'Warum wird die Trennung der Belange in der objektorientierten Programmierung als unzureichend unterstützt angesehen?', 'answer': 'Die Trennung der Belange, auch als Separation of Concerns bekannt, wird in der objektorientierten Programmierung als unzureichend unterstützt angesehen, da es schwer ist, verschiedene Aspekte eines Systems sauber voneinander zu trennen. Ansätze wie das Subject- oder Aspect-oriented Programming wurden zwar diskutiert, haben jedoch keine breite Akzeptanz gefunden. Die Gründe dafür können vielfältig sein, aber letztendlich ist es schwierig, die essentielle Komplexität eines Problems durch programmiersprachliche Mittel vollständig zu beseitigen.'},
     {'question': 'Warum werden Softwaresysteme als die kompliziertesten technischen Artefakte bezeichnet, die die Menschheit jemals hervorgebracht hat?', 'answer': 'Softwaresysteme werden als die kompliziertesten technischen Artefakte bezeichnet, die die Menschheit jemals hervorgebracht hat, weil sie eine immense Komplexität aufweisen. Die Trennung der Belange und die Bewältigung dieser Komplexität sind nach wie vor große Herausforderungen in der Softwareentwicklung. Daher wird darauf hingewiesen, dass Einfachheit in diesem Kontext schwer zu erreichen ist.'},
     {'question': 'Was war die anfängliche Erwartung in Bezug auf Kapselung in der objektorientierten Programmierung, und warum?', 'answer': 'Anfangs glaubte man, dass die objektorientierte Programmierung durch das Konzept der Klassen eine natürliche Form der Kapselung gefunden hatte. Dies wurde auch mit der Theorie der abstrakten Datentypen in Einklang gebracht. Klassen sollten natürliche Repräsentanten von Allgemeinbegriffen sein, und Daten sowie Implementierungsdetails sollten hinter der Klassenschnittstelle verborgen werden.'},
     {'question': 'Warum können private Instanzvariablen allein das Aliasing-Problem nicht lösen?', 'answer': 'Private Instanzvariablen können allein das Aliasing-Problem nicht lösen, da sie lediglich Namen verbergen und nicht verhindern können, dass Repräsentationsobjekte (Implementierungsdetails) Aliasen ausgesetzt sind.'},
     {'question': 'Warum kann das Verbot von Aliasing in einigen Programmiersprachen nicht immer eine geeignete Lösung sein?', 'answer': 'Das Verbot von Aliasing in einigen Programmiersprachen kann nicht immer eine geeignete Lösung sein, da es zahlreiche Anwendungsfälle gibt, in denen die Verwendung von Aliasing notwendig oder sinnvoll ist. Zum Beispiel können bestimmte Datenstrukturen oder Container von Natur aus Aliase erfordern, um effizient zu arbeiten.'},
     {'question': 'Warum werden Substantive für Klassennamen verwendet?', 'answer': 'Substantive werden für Klassennamen verwendet, weil sie die Namen von Dingen oder Konzepten bezeichnen, die in der Objektorientierung als Klassen repräsentiert werden. Diese Technik erleichtert die Identifizierung der Klassen eines Systems in der Analysephase.'},
     {'question': 'Warum kann es sinnvoll sein, bei der Wahl der Bezeichner zwischen zwei Sprachen zu wählen?', 'answer': 'Das kann sinnvoll sein, um eine zusätzliche Form der Differenzierung einzusetzen. Zum Beispiel kann man für Begrifflichkeiten aus der Anwendungsdomäne deutsche Bezeichner verwenden und für solche aus der technischen Umsetzung englische. Alternativ kann man auch alle selbst beigesteuerten Programmelemente auf Deutsch benennen, um sie von den aus Bibliotheken und Frameworks zusammengeklaubten zu unterscheiden.'},
     {'question': 'Warum sollte man lange, sprechende Bezeichner verwenden?', 'answer': 'Gegen die Verwendung langer, sprechender Bezeichner kann man einwenden, dass der Programmtext dadurch übermäßig lang wird. Allerdings erhöht dies die Lesbarkeit und verringert das Risiko von Tippfehlern, da die meisten Entwicklungsumgebungen über eine automatische Vervollständigungsfunktion verfügen, die einem das Tippen abnimmt.'},
     {'question': 'Warum ist die Wahl eines guten Namens für ein Programmelement wichtig?', 'answer': 'Eine sorgfältige Programmiererin wird sich häufiger dabei beobachten, wie sie über einen passenden Namen für ein Programmelement länger nachsinnt. Diese Zeit ist jedoch gut investiert, da prägnante Namen vorzuziehen sind und lange Namen, die sich nur geringfügig unterscheiden, zu vermeiden sind. Ein Name ist dann gut gewählt, wenn man alle Ausdrücke, in denen er vorkommt, schnell verstehen kann.'},
     {'question': 'Was bedeutet es, wenn ein Typ als korrekt implementiert gilt?', 'answer': 'Ein Typ wird als korrekt implementiert betrachtet, wenn für jede Methode gezeigt werden kann, dass aus der Vorbedingung der Methode die Nachbedingung folgt und dass die Invarianten des Typs höchstens temporär während der Methodenausführung verletzt werden.'},
     {'question': 'Was beschreibt die Nachbedingung einer Methode?', 'answer': 'Die Nachbedingung einer Methode beschreibt den Zustand, in dem sich das Objekt nach der Ausführung der Methode befindet.'},
     {'question': 'Was beschreibt die Vorbedingung einer Methode?', 'answer': 'Die Vorbedingung einer Methode beschreibt den Zustand, in dem sich ein Objekt befinden muss, damit die Methode aufgerufen werden kann.'},
     {'question': 'Warum sind Methoden in objektorientierter Programmierung im Durchschnitt kurz?', 'answer': 'Die Methoden sind im Durchschnitt kurz, weil die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Sobald eine Funktion verschiedene Arten von Daten manipuliert, ist es wahrscheinlich, dass diese Funktion nicht vollständig in einer Methode implementiert wird.'},
     {'question': 'Warum sind Methoden in objektorientierter Programmierung im Durchschnitt kurz?', 'answer': 'Die Methoden sind im Durchschnitt kurz, weil die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Sobald eine Funktion verschiedene Arten von Daten manipuliert, ist es wahrscheinlich, dass diese Funktion nicht vollständig in einer Methode implementiert wird.'},
     {'question': 'Warum bevorzugen objektorientierte Programmierer kurze Methoden?', 'answer': 'Objektorientierte Programmierer bevorzugen kurze Methoden, weil sie als objektorientierter Stil gelten. Diese Methoden können nur aus einer Zeile bestehen und die Funktionalität wird stark zerlegt. Dies führt zu einer hohen Dichte an Bezeichnern in objektorientierten Programmen, da jede Teilfunktion, die in eine Methode ausgelagert wird, einen eigenen, eindeutigen Namen haben muss.'},
     {'question': 'Warum ist es üblich, Teile einer Methode in eine neue auszulagern?', 'answer': 'Es ist üblich, Teile einer Methode in eine neue auszulagern, um die Lesbarkeit zu verbessern und die Funktionalität besser zu zerlegen. Dies wird auch als "Extract-method"-Refactoring bezeichnet. Jede Teilfunktion, die in eine Methode ausgelagert wird, muss einen eigenen, eindeutigen Namen haben, was die Programmiererin dazu zwingt, sich ständig (in Form der Namenswahl für Bezeichner) dazu zu äußern, was sie gerade tut.'},
     {'question': 'Wozu dienen Namenskonventionen?', 'answer': 'Namenskonventionen werden verwendet, um die Bedeutung von Bezeichnern zu verdeutlichen und die Lesbarkeit des Codes zu erhöhen. Eine gängige Namenskonvention ist beispielsweise, Namen von Interfacetypen mit einem großen "I" beginnen zu lassen. Nach einer sinnvolleren Auslegung der ungarischen Notation sollten Variablen um die Verwendung ihres so bezeichneten Inhalts ergänzt werden. Das bedeutet, die Funktion des durch sie bezeichneten Objekts oder Werts innerhalb des Kontextes, in dem die Variable gültig ist, anzugeben. Diese kontextbezogene Funktion kann in der objektorientierten Programmierung jedoch auch durch die Verwendung eines Interfaces anstelle einer Klasse als Typ bei der Deklaration der Variable ausgedrückt und somit auch vom Compiler überprüft werden.'},
     {'question': 'Warum sind Bibliotheken wichtig für die objektorientierte Programmierung?', 'answer': 'Bibliotheken sind wichtig für die objektorientierte Programmierung, da sie einen Großteil des Erfolgs ausmachen. Sie enthalten wiederverwendbare Klassen und Methoden, die die Entwicklung von Programmen erleichtern und beschleunigen. In SMALLTALK sind Sprache und Bibliothek praktisch nicht zu trennen, während in Java ein Teil der Sprachdefinition in bestimmte Klassen verlagert ist. Auch wird praktisch kein Java-Programm ohne die Verwendung bestimmter Bibliotheksklassen auskommen.'},
     {'question': 'Warum hängt der Erfolg der objektorientierten Programmierung von der Verfügbarkeit und systematischen Verwendung von Bibliotheken ab?', 'answer': 'Der Erfolg der objektorientierten Programmierung hängt von der Verfügbarkeit und systematischen Verwendung von Bibliotheken ab, weil sie wiederverwendbaren Code bereitstellen, der die Entwicklungszeit verkürzt und die Fehleranfälligkeit reduziert. Sie ermöglichen es den Programmierern, auf bereits getesteten und bewährten Funktionen zurückzugreifen, anstatt das Rad immer wieder neu zu erfinden. In Smalltalk ist dies besonders ausgeprägt, da Sprache und Bibliothek praktisch nicht zu trennen sind. Auch in Java ist ein Teil der Sprachdefinition in bestimmte, spezielle Klassen verlagert und ein Großteil der Programme verwenden bestimmte Bibliotheksklassen, wie das Collection-Framework.'},
     {'question': 'Warum ist es vorteilhaft, existierende Bibliotheken in der objektorientierten Programmierung zu verwenden?', 'answer': 'Es ist vorteilhaft, existierende Bibliotheken in der objektorientierten Programmierung zu verwenden, da die Implementierungen in der Regel korrekt sind, die Wartung und Anpassung übernommen wird, die Funktionalität bekannt ist und die eigene Arbeit klein und überschaubar bleibt.'},
     {'question': 'Was bestimmt die Substituierbarkeit von Typen?', 'answer': 'Die Substituierbarkeit von Typen hängt nicht nur von den beteiligten Typen ab, sondern auch von ihrer Verwendung. Es gibt also keine absolute Substituierbarkeit, die von jeder möglichen Verwendung losgelöst ist.'},
     {'question': 'Warum ist die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte, wichtig?', 'answer': 'Die Sichtweise der Programmiererin, die die Typen für einen bestimmten Zweck verwenden möchte, ist wichtig, weil sie genau weiß, welche Erwartungen sie an einen Typen hat und welche Typen in ihrem speziellen Anwendungsfall gegeneinander austauschbar sind.'},
     {'question': 'Was bedeutet es, wenn ein Objekt typkonform ist?', 'answer': 'Wenn ein Objekt typkonform ist, bedeutet das, dass es die Eigenschaften und Verhaltensweisen besitzt, die von einem Objekt seines Typs erwartet werden. Es erfüllt also die Anforderungen, die an Objekte dieses Typs gestellt werden.'},
     {'question': 'Warum ist es wichtig, dass Objekte typkonform sind?', 'answer': 'Es ist wichtig, dass Objekte typkonform sind, weil sie nur dann die ihnen zugewiesene Rolle spielen können. Wenn Objekte nicht typkonform sind, können sie nicht die gewünschten Funktionen erfüllen und können zu Fehlern im Programm führen.'},
     {'question': 'Was passiert, wenn ein Objekt nicht typkonform ist?', 'answer': 'Wenn ein Objekt nicht typkonform ist, kann es nicht die gewünschten Funktionen erfüllen und kann zu Fehlern im Programm führen.'},
     {'question': 'Was ist der Unterschied zwischen der Sicht der Nutzerin und der Sicht der Anbieterin auf Typen?', 'answer': 'Die Sicht der Nutzerin auf Typen ist, wie sie in einem Programm verwendet werden, während die Sicht der Anbieterin sich auf die Implementierung des Typs bezieht. Die Programmiersprachen Java und C-Sharp bieten das Konzept von "Interfaces als Typen" an, mit dem es möglich ist, partielle Ansichten auf Typen in einem Programm zu definieren. In der Praxis wird diese Möglichkeit jedoch selten genutzt, um Anwenderinnen ihre eigenen Anforderungen als Typen definieren zu lassen.'},
     {'question': 'Warum ist die Implementierungsvererbung nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert?', 'answer': 'Die Implementierungsvererbung ist nicht für ein Systemobjektmodell geeignet, das eine Architektur für Komponentensoftware definiert, weil sie implizit und mehrdeutig ist. Wenn die Eltern- oder Kindkomponente unerwartet ihr Verhalten ändert, kann dies zu undefiniertem Verhalten verwandter Komponenten führen. Diese Unsicherheit ist nicht akzeptabel in einem System, das von vielen verschiedenen Programmierern entwickelt wird, die nicht alle gleichzeitig Updates an allen Komponenten vornehmen können.'},
     {'question': 'Warum ist es wichtig, dass die Schnittstelle einer Komponente für den Anbieter und den Client klar definiert ist?', 'answer': 'Damit der Komponentenanbieter sein Produkt revidieren, aktualisieren und verteilen (oder neu verteilen) kann, ohne den bestehenden Code auf dem Feld zu beeinträchtigen, der die vorherige Revision oder Revisionen seiner Komponente verwendet.'},
     {'question': 'Warum ist es wichtig, dass die Schnittstelle einer Komponente für beide Parteien kristallklar ist?', 'answer': 'Damit der Komponentenanbieter sicherstellen kann, dass er die Schnittstelle beibehält und somit die bestehenden Clients nicht stört.'},
     {'question': 'Warum wurde die Vererbung von Implementierung in Microsofts Component Object Model (COM) verbannt?', 'answer': 'Die Vererbung von Implementierung wurde in COM verbannt, weil der Vertrag zwischen den Klassen in einer Vererbungshierarchie nicht klar definiert ist. Wenn Super- oder Subklassen ihr Verhalten unerwartet ändern, kann dies zu undefiniertem Verhalten in verwandten Klassen führen.'},
     {'question': 'Was ist der Vorteil von Interfaces gegenüber der Vererbung von Implementierung?', 'answer': 'Der Vorteil von Interfaces gegenüber der Vererbung von Implementierung ist, dass sie den Vertrag zwischen Klassen klar definiert und das dynamische Binden ermöglicht, ohne sich um die Implementierungsdetails kümmern zu müssen.'},
     {'question': 'Was ist der Nachteil von Interfaces gegenüber der Vererbung von Implementierung?', 'answer': 'Der Nachteil von Interfaces gegenüber der Vererbung von Implementierung ist, dass sie keine gemeinsam genutzten Implementierungen ermöglicht und die Code-Duplizierung erhöhen kann.'},
     {'question': 'Was ist der Unterschied zwischen der Schnittstelle, die einem Client einer Klasse angeboten wird und der Schnittstelle zwischen einer Klasse und ihren Subklassen?', 'answer': 'Die Schnittstelle, die einem Client einer Klasse angeboten wird, ist die Schnittstelle, die der Client nutzt, indem er Variablen mit dem zur Klasse gehörenden Typ deklariert und somit auf Instanzen der Klasse zugreifen kann. Die Schnittstelle zwischen einer Klasse und ihren Subklassen hingegen ist eine etwas anders geartete Schnittstelle, die lediglich zwei Variablen, self (oder this) und super, umfasst und nicht explizit typisiert ist. Die Schnittstelle zwischen einer Klasse und ihren Subklassen muss man selbst zusammensuchen und ist nicht mit Information Hiding und dem Verbergen von Implementationsdetails zu tun.'},
     {'question': 'Was ist der Unterschied zwischen statischer und dynamischer Bindung?', 'answer': 'Statische Bindung findet zur Übersetzungszeit statt und ist damit schneller, während dynamische Bindung zur Laufzeit erfolgt und damit etwas langsamer ist. Statische Bindung wird verwendet, wenn der Compiler die Methodenaufrufe bereits zur Übersetzungszeit auflösen kann, während dynamische Bindung verwendet wird, wenn der Compiler die Methodenaufrufe nicht auflösen kann und sie daher zur Laufzeit auflösen muss.'},
     {'question': 'Was ist der Unterschied zwischen einem deklarativen und einem imperativen Programmierstil?', 'answer': 'Ein deklarativer Programmierstil beschäftigt sich mehr mit dem "Was" als mit dem "Wie" und beschreibt, was das Programm tun soll, während ein imperativer Programmierstil sich mehr auf die Anweisungen und die Reihenfolge der Befehle konzentriert, die das Programm ausführen soll, um ein bestimmtes Ergebnis zu erzielen.'},
     {'question': 'Was ist der Unterschied zwischen imperativer und deklarativer Programmierung?', 'answer': 'Imperative Programmierung ist eine Programmierparadigme, bei der der Programmierer explizit die Schritte angibt, die der Computer ausführen soll, um ein Problem zu lösen. Deklarative Programmierung hingegen ist eine Programmierparadigme, bei der der Programmierer lediglich die gewünschte Lösung angibt, ohne die Schritte zur Lösung des Problems zu spezifizieren. In der objektorientierten Programmierung ist es durchaus üblich, einzelne Schleifen aus einem Methodenrumpf in eine eigene Methode zu verschieben und durch einen entsprechenden Methodenaufruf zu ersetzen, um das Programm deklarativer zu gestalten, aber es ist immer noch imperativ.'},
     {'question': 'Warum sollte man bei Optimierungen vorsichtig sein?', 'answer': 'Man sollte bei Optimierungen vorsichtig sein, weil nicht sichergestellt ist, dass die optimierte Version funktional äquivalent ist und dasselbe Ergebnis liefert. Zum Beispiel könnte "auswerten" für "Literale" einen Seiteneffekt haben, was die optimierten Versionen ungleich machen würde.'},
     {'question': 'Was sollte man bei vermeintlichen Abkürzungen beachten?', 'answer': 'Man sollte sicherstellen, dass die Abkürzung funktional äquivalent ist, d.h. dasselbe Ergebnis liefert, bevor man solche Optimierungen vornimmt. Wenn beispielsweise "auswerten" für "Literale" einen Seiteneffekt hat, wären die optimierten Versionen nicht mehr äquivalent.'},
     {'question': 'Was bedeutet funktional äquivalent?', 'answer': 'Funktional äquivalent bedeutet, dass zwei Ausdrücke das gleiche Ergebnis liefern, wenn sie mit den gleichen Eingabewerten ausgeführt werden.'},
     {'question': 'Wozu können Zusicherungen in der objektorientierten Programmierung eingesetzt werden?', 'answer': 'Zusicherungen können in der objektorientierten Programmierung eingesetzt werden, um die Laufzeitverifikation zu ermöglichen und dem Aufrufer der Methode zu zeigen, wie er prüfen kann, ob die Vorbedingung eingehalten ist.'},
     {'question': 'Sind Abkürzungen in der Programmierung zu vermeiden?', 'answer': 'Abkürzungen sind nicht grundsätzlich zu vermeiden. Wenn sie etabliert sind und man davon ausgehen darf, dass eine Leserin des Programms sie kennt, ist ihre Verwendung sogar angezeigt. Man sollte jedoch auf hausgemachte Abkürzungen verzichten, deren Bedeutung nur von einem selbst bekannt ist.'},
     {'question': 'Warum sollte man den langen Namen einer Variablen bevorzugen, wenn sie nicht nur in ihrer unmittelbaren Umgebung sichtbar ist?', 'answer': 'Der lange Name einer Variablen sollte bevorzugt werden, wenn sie nicht nur in ihrer unmittelbaren Umgebung sichtbar ist, um die Lesbarkeit und Verständlichkeit des Codes zu erhöhen. Ein aussagekräftiger und beschreibender Name hilft anderen Programmierern und auch dem zukünftigen Selbst, den Zweck und die Funktion der Variablen besser zu verstehen.'},
     {'question': 'Warum spielt die Ausdrucksweise in Programmiersprachen eine Rolle?', 'answer': 'Die Ausdrucksweise in Programmiersprachen bestimmt nicht den Inhalt des Programms, sondern seine Qualität. Sie beeinflusst, wie effizient ein gegebenes Problem gelöst wird oder wie verständlich die Formulierung der Lösung für die Betrachterin ist. Besonders die Verständlichkeit hat viel mit Schreibstil zu tun, aber auch andere Faktoren wie Mode und Ästhetik (Eleganz) spielen eine Rolle.'},
     {'question': 'Was ist der Unterschied zwischen einem mathematisch prägnanten Stil und einem prosaisch-verbosen Stil in der Programmierung?', 'answer': 'Ein mathematisch prägnanter Stil in der Programmierung zeichnet sich durch eine kompakte und präzise Schreibweise aus, während ein prosaisch-verboser Stil durch eine ausführliche und detaillierte Schreibweise gekennzeichnet ist.'},
     {'question': 'Was versteht man unter einem mathematisch prägnanten Stil in der Programmierung?', 'answer': 'Ein mathematisch prägnanter Stil in der Programmierung zeichnet sich durch eine kompakte, präzise und logische Schreibweise aus, die an die mathematische Notation erinnert. Er vermeidet unnötige Wiederholungen und nutzt stattdessen abstrakte Konzepte und Funktionen, um die Absicht des Programmcodes klar und eindeutig auszudrücken. Diese Art der Programmierung wird oft als "sauber" und "elegant" angesehen, da sie die Komplexität reduziert und die Wartbarkeit des Codes verbessert.'},
     {'question': 'Warum ist die Verwendung aussagekräftiger Variablennamen wichtig?', 'answer': 'Die Verwendung aussagekräftiger Variablennamen ist wichtig, um das Verständnis des Programms zu erleichtern. Wenn Variablennamen wie "i" verwendet werden, ist es schwieriger zu verstehen, wofür die Variablen stehen. Durch die Verwendung aussagekräftiger Variablennamen wie "r", "m" oder "w" in diesem Beispiel wird das Programm jedoch leichter verständlich.'},
     {'question': 'Wozu können temporäre Variablen in Programmen dienen?', 'answer': 'Temporäre Variablen können in Programmen zur besseren Lesbarkeit dienen, indem sie Zwischenergebnissen Namen geben.'},
     {'question': 'Sind die Werte temporärer Variablen außerhalb der Methode sichtbar?', 'answer': 'Nein, die Werte temporärer Variablen sind außerhalb der Methode nicht sichtbar.'},
     {'question': 'Warum sind Kommentare in einem Programm nicht immer notwendig?', 'answer': 'Heutzutage ist es üblich, Bezeichner in einem Programm so zu wählen, dass Kommentare zur Bedeutung der jeweiligen Programmelemente unnötig sind, da die Bezeichner ihre Bedeutung bereits im Kontext ausdrücken. Ein gut geschriebenes objektorientiertes Programm benötigt daher eigentlich keine Kommentare.'},
     {'question': 'Warum werden Kommentare in einem gut geschriebenen objektorientierten Programm nicht benötigt?', 'answer': 'In einem gut geschriebenen objektorientierten Programm werden Bezeichner (Namen für Module, Typen, Variablen, Prozeduren und Funktionen) so gewählt, dass sie ihre Bedeutung bereits im Kontext ausdrücken, wodurch Kommentare unnötig werden.'},
     {'question': 'Kann die Einhaltung des Law of Demeter automatisch überprüft werden?', 'answer': 'Die Einhaltung des Law of Demeter kann nicht automatisch überprüft werden, da das Gesetz in Termini von Objekten und nicht von Variablen oder Typen formuliert ist. Automatische Checker prüfen zumeist nur die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters haben. In SMALLTALK ist eine solche Prüfung nicht möglich, da Ausdrücke nicht typisiert sind.'},
     {'question': 'Warum ist es in SMALLTALK nicht möglich, das Law of Demeter automatisch zu überprüfen?', 'answer': 'Das Law of Demeter kann in SMALLTALK nicht automatisch überprüft werden, da Ausdrücke nicht typisiert sind und die Prüfung daher nicht auf Variablendeklarationen und Methodenaufrufe beschränkt werden kann. Stattdessen würde eine Überprüfung die Auswertung von konkreten Zuweisungen und damit des dynamischen Programmflusses erfordern, was mechanisch extrem aufwendig bis gar nicht durchführbar ist.'},
     {'question': 'Was passiert, wenn die Verkettung von Nachrichtenausdrücken länger wird?', 'answer': 'Wenn die Verkettung von Nachrichtenausdrücken länger wird, wird das Protokoll der Klasse von "a" komplexer und muss mit entsprechenden Implementierungen versehen werden.'},
     {'question': 'Wozu dienen feingranulare Klassen in der objektorientierten Programmierung?', 'answer': 'Feingranulare Klassen in der objektorientierten Programmierung sind nützlich, um die Anwendungsdomäne angemessen abzubilden und die Komplexität der Klassen zu reduzieren. Sie ermöglichen eine bessere Strukturierung der Klassen und erleichtern die Wartung und Weiterentwicklung des Codes.'},
     {'question': 'Warum sollten Klassen nicht zu groß sein?', 'answer': 'Klassen sollten nicht zu groß sein, da dies als schlechter Stil gilt und die Anwendungsdomäne nicht angemessen widerspiegelt. Stattdessen sollten große Dinge in einfachere zusammengesetzt werden, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind. Diese Art der Strukturierung findet man auch in anderen Ingenieursdisziplinen wie dem Bauwesen.'},
     {'question': 'Warum sind Klassen in objektorientierter Programmierung relativ feingranular?', 'answer': 'Klassen sind in objektorientierter Programmierung relativ feingranular, weil große Klassen mit Hunderten von Attributen und Methoden als schlechter Stil gelten und die Anwendungsdomäne nicht angemessen widerspiegeln. Stattdessen sind alle großen (komplexen) Dinge aus einfacheren zusammengesetzt, die, wenn sie selbst eine gewisse Komplexität haben, selbst wieder aus kleineren zusammengesetzt sind usw. Diese Art der Strukturierung findet man auch in anderen Ingenieursdisziplinen wie dem Bauwesen, wo Baupläne in Komponenten und Unterkomponenten bzw. Systeme und Untersysteme strukturiert sind.'},
     {'question': 'Was ist der Unterschied zwischen Objekten und Klassen in Bezug auf die Teil-Ganzes-Beziehung?', 'answer': 'Objekte können mithilfe der Teil-Ganzes-Beziehung rekursiv aufgebaut werden, während Klassen nicht hierarchisch strukturiert werden können. Objekte sind einzelne Exemplare (Instanzen) und können Teile haben, während Klassen Typen von Objekten sind und nicht immer Teile von anderen Klassen sind.'},
     {'question': 'Warum sind innere Klassen in Java nicht ein besonders nützlicher Mechanismus?', 'answer': 'Obwohl in Java innere Klassen genutzt werden können, um Klassen zu strukturieren, wird davon relativ wenig Gebrauch gemacht. Dies liegt daran, dass Objekte einer Klasse nicht immer Teile von Objekten anderer Klassen sind und vielmehr einzelne Exemplare (Instanzen) sein und vielleicht sogar selbst Teile haben können. Einzelne Instanzen können nicht durch innere Klassen beschrieben werden, weshalb sie als ein nicht besonders nützlicher Mechanismus angesehen werden.'},
     {'question': 'Was ist der Unterschied zwischen Komponenten und Klassen in objektorientierten Programmiersprachen?', 'answer': 'Im Gegensatz zu Klassen, die in objektorientierten Programmiersprachen verwendet werden, um Objekte zu definieren, werden Komponenten verwendet, um Objekte zur Laufzeit zusammenzubauen. Leider ist der Begriff "Komponente" in objektorientierten Programmiersprachen noch nicht weit verbreitet und wird oft durch andere Konzepte wie Pakete oder Assemblies ersetzt, die lediglich Klassen gruppieren.'},
     {'question': 'Welche Vorteile haben Namenskonventionen in der Programmierung?', 'answer': 'Namenskonventionen in der Programmierung haben mehrere Vorteile. Sie erleichtern die Bezeichnerwahl, begrenzen die schöpferische Freiheit der Programmiererin, was als Entlastung empfunden werden kann, und machen das Lesen von Code einfacher, da Entwicklerinnen, die die Konventionen kennen, die Bedeutung der Bezeichner schneller entschlüsseln können und sich somit schneller zurechtfinden.'},
     {'question': 'Welche Vorteile ergeben sich aus kurzen Methoden in der objektorientierten Programmierung?', 'answer': 'Kurze Methoden in der objektorientierten Programmierung fördern die Lesbarkeit und den objektorientierten Stil. Sie erlauben es, Teile einer Methode in separate, klar benannte Methoden auszulagern, was die Lesbarkeit und Wartbarkeit des Codes verbessert. Dieser Stil fördert auch die Verwendung von aussagekräftigen Bezeichnern und trägt zur besseren Dokumentation des Codes bei.'},
     {'question': 'Warum ist die Vererbung ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung?', 'answer': 'Die Vererbung ist ein Aushängeschild und gleichzeitig ein Problem in der objektorientierten Programmierung, weil sie einerseits ein mächtiges Konzept zur Wiederverwendung von Code und zur Erstellung von Klassenhierarchien darstellt, andererseits aber auch dazu führen kann, dass Änderungen an einer Klasse sich auf alle davon abgeleiteten Klassen auswirken. Dies kann die Wartbarkeit und Erweiterbarkeit des Codes beeinträchtigen und zu unerwartetem Verhalten führen.'},
     {'question': 'Was besagt die gewichtigste Regel im Zusammenhang mit Vererbung?', 'answer': 'Die gewichtigste Regel im Zusammenhang mit Vererbung besagt: "Deklariere jede Klasse entweder als abstrakt oder als final." Das bedeutet, dass Klassen entweder als abstrakt (nicht instanziierbar) oder als final (nicht ableitbar) deklariert werden sollten.'},
     {'question': 'Warum sollten nur die Blätter der Klassenhierarchie instanziierbar sein?', 'answer': 'Die Blätter der Klassenhierarchie sollten instanziierbar sein, weil dies sicherstellt, dass Änderungen an einer Klasse nur Auswirkungen auf diese Klasse selbst haben und nicht auf alle davon abgeleiteten Klassen. Wenn eine Klasse in der Hierarchie geändert werden muss, können diese Änderungen in der Klasse selbst oder in ihren Subklassen vorgenommen werden, ohne die anderen Klassen in der Hierarchie zu beeinflussen.'},
     {'question': 'Warum ist es wichtig, Klassen als abstrakt oder final zu deklarieren, um Änderungen an der Funktionalität der Klasse zu ermöglichen?', 'answer': 'Das Deklarieren von Klassen als abstrakt oder final ermöglicht es, Änderungen an der Funktionalität der Klasse auf sichere Weise durchzuführen. Wenn eine Klasse als abstrakt deklariert ist, können Änderungen in den abgeleiteten Subklassen vorgenommen werden, ohne die anderen Klassen in der Hierarchie zu beeinflussen. Wenn eine Klasse als final deklariert ist, kann sie nicht abgeleitet werden, was bedeutet, dass ihre Funktionalität nicht geändert werden kann. Dies ermöglicht es, den Vertrag zwischen der Klasse und ihren Klienten zu schützen und unerwartete Verhaltensänderungen zu verhindern.'},
     {'question': 'Warum ist die Verwendung von abstrakten Klassen in Bibliotheken eine Möglichkeit, die Beschränkungen von finalen Klassen zu umgehen?', 'answer': 'Die Verwendung von abstrakten Klassen in Bibliotheken ermöglicht es, die Beschränkungen von finalen Klassen zu umgehen, indem sie eine Schicht der Abstraktion hinzufügen. Anstatt eine Klasse als final zu deklarieren, wird sie als abstrakt deklariert und per Vererbung eine Subklasse davon abgeleitet, die konkret (instanziierbar) und final ist. Auf diese Weise können Klienten der Bibliothek von der abgeleiteten, finalen Klasse erben und diese verwenden, ohne die ursprüngliche Klasse ändern zu müssen. Wenn Änderungen erforderlich sind, können sie in der finalen Klasse vorgenommen werden, und nur wenn sie für alle Klienten geeignet sind, werden sie in der abstrakten Superklasse durchgeführt. Dies ermöglicht eine gewisse Flexibilität bei der Aktualisierung von Bibliotheken, ohne den Vertrag mit den Klienten zu brechen.'},
     {'question': 'Warum sind Formatierungskonventionen in der Programmierung wichtig?', 'answer': 'Formatierungskonventionen in der Programmierung sind wichtig, da sie die Lesbarkeit des Codes verbessern. Sie regeln Dinge wie Einrückungen, Zeilenumbrüche, Leerzeichen und Leerzeilen, um den Code übersichtlicher zu gestalten.'},
     {'question': 'Warum sind Formatierungskonventionen besonders in Teamprojekten wichtig?', 'answer': 'In Teamprojekten sind Formatierungskonventionen besonders wichtig, um zu verhindern, dass jede Entwicklerin im Team ihre eigenen Formatierungsvorlieben pflegt. Ohne einheitliche Konventionen kann es passieren, dass Entwicklerinnen den Code anderer Teammitglieder nach ihren eigenen Vorlieben formatieren, was zu Konflikten und ineffizienter Arbeit führen kann.'},
     {'question': 'Warum ist es wichtig, dass Namenskonventionen genau festgeschrieben sind und von allen akzeptiert werden?', 'answer': 'Es ist wichtig, dass Namenskonventionen genau festgeschrieben sind und von allen akzeptiert werden, da andernfalls individuelle Auslegungen der Regeln Verwirrung stiften können. Wenn jede Person ihre eigene Auslegung hat, verliert die Namenskonvention ihren Nutzen und kann sogar zu mehr Verwirrung führen.'},
     {'question': 'Warum werden Interfaces oft mit Substantiven oder Adjektiven bezeichnet?', 'answer': 'Interfaces sind wie Klassen Typen, aber sie bezeichnen keine Allgemeinbegriffe, sondern eher Rollen, die die Objekte spielen können. Diese Rollen werden häufig durch Substantive oder Adjektive bezeichnet. Zum Beispiel enden viele Interfacenamen im Englischen auf „able“ oder „ible“, wie "Serializable."'},
     {'question': 'Warum könnte die Verwendung langer, sprechender Bezeichner in der Programmierung problematisch sein?', 'answer': 'Die Verwendung langer, sprechender Bezeichner kann in der Programmierung problematisch sein, da der Programmtext dadurch übermäßig lang wird. Anweisungen, die normalerweise in eine Zeile passen würden, müssen möglicherweise mehrfach umgebrochen werden, was die Lesbarkeit beeinträchtigen kann. Außerdem hört man gelegentlich das Argument, dass lange Namen zusätzliche Schreibarbeit für die Entwicklerin bedeuten. Dieses Argument wird jedoch in der Regel nicht akzeptiert, da die meisten Entwicklungsumgebungen über automatische Vervollständigungsfunktionen verfügen, die das Tippen erleichtern.'},
     {'question': 'Warum sind die Methoden in objektorientierten Programmen im Durchschnitt ziemlich kurz?', 'answer': 'Die Methoden in objektorientierten Programmen sind im Durchschnitt ziemlich kurz, weil in der objektorientierten Programmierung die Funktionalität auf Basis der Daten, von denen sie abhängt, aufgebrochen und aufgeteilt wird. Wenn eine Funktion verschiedene Arten von Daten manipuliert, wird die Funktionalität wahrscheinlich nicht vollständig in einer Methode implementiert.'},
     {'question': 'Warum ist die Verwendung von Bibliotheken in der objektorientierten Programmierung wichtig?', 'answer': 'Die Verwendung von Bibliotheken in der objektorientierten Programmierung bietet mehrere Vorteile: Sie ermöglicht es, Lösungen für Probleme aus vorhandenen, bewährten und weit verbreiteten Bibliotheken zusammenzustellen, was Zeit und Aufwand spart. Bibliotheken enthalten in der Regel korrekte Implementierungen von Funktionen und berücksichtigen Probleme sowie Sonderfälle, die ein einzelner Entwickler möglicherweise übersehen würde. Die Wartung und Anpassung von Bibliotheken wird oft von anderen Entwicklern übernommen, was die Entwickler entlastet. Die Verwendung weit verbreiteter Bibliotheken erleichtert die Kommunikation und Zusammenarbeit mit anderen Entwicklern, da diese bereits mit den Bibliotheken vertraut sind.'},
     {'question': 'Warum sollten Entwickler in der objektorientierten Programmierung Bibliotheken nutzen?', 'answer': 'Entwickler sollten Bibliotheken in der objektorientierten Programmierung nutzen, um Zeit zu sparen, Fehler zu vermeiden, auf bewährte Lösungen zuzugreifen und den Entwicklungsprozess effizienter zu gestalten. Die Verwendung von Bibliotheken ermöglicht es Entwicklern, sich auf die spezifischen Anforderungen ihres Projekts zu konzentrieren, anstatt grundlegende Funktionen und Implementierungen selbst zu schreiben. Dies trägt zur Produktivität und Qualität der Software bei.'},
     {'question': 'Was kennzeichnet den deklarativen Programmierstil in der objektorientierten Programmierung?', 'answer': 'Der deklarative Programmierstil in der objektorientierten Programmierung legt mehr Wert auf das "Was" als auf das "Wie". Er betont die Ausdrucksform und verschiebt mögliche Optimierungen auf den Compiler oder später in der Entwicklung. Das bedeutet, dass die Programmiererin sich auf das Beschreiben dessen konzentriert, was erreicht werden soll, anstatt detaillierte Anweisungen zur Durchführung zu geben.'},
     {'question': 'Warum ist der deklarative Programmierstil in der objektorientierten Programmierung trotz ihres eher imperativen Charakters relevant?', 'answer': 'Der deklarative Programmierstil ist in der objektorientierten Programmierung relevant, da er die Lesbarkeit und Wartbarkeit des Codes verbessert. Obwohl die objektorientierte Programmierung tendenziell eher imperativ ist, kann der deklarative Stil durch den Einsatz von aussagekräftigen Bezeichnern und die Aufteilung von Funktionalität in separate Methoden erreicht werden. Dies führt dazu, dass der Code leichter zu verstehen ist und die Absicht der Programmiererin klarer hervortritt.'},
     {'question': 'Warum sind Abkürzungen in der Programmierung nicht grundsätzlich zu vermeiden?', 'answer': 'Abkürzungen in der Programmierung sind nicht grundsätzlich zu vermeiden, besonders wenn sie etabliert sind und die Leserin des Programms wahrscheinlich weiß, was sie bedeuten. Dies kann dazu beitragen, zu lange Namen zu vermeiden und den Code lesbarer zu machen.'},
     {'question': 'Warum sollte man auf selbst erstellte Abkürzungen verzichten?', 'answer': 'Auf selbst erstellte Abkürzungen sollte man verzichten, da ihre Bedeutung oft nur von der Person bekannt ist, die sie erstellt hat. Dies kann die Lesbarkeit des Codes für andere Programmiererinnen beeinträchtigen und zu Missverständnissen führen.'},
     {'question': 'In welchen Fällen ist die Verwendung von Abkürzungen in Java und ähnlichen objektorientierten Programmiersprachen legitim?', 'answer': 'In Java und ähnlichen objektorientierten Programmiersprachen ist die Verwendung von Abkürzungen legitim, wenn Typen und Variablen denselben Namen haben und sich nur in der Groß- bzw. Kleinschreibung ihres Anfangsbuchstabens unterscheiden. Dies kann in Fällen auftreten, in denen es keinen besseren Namen für die Variable gibt und die Sichtbarkeit der Variable auf die unmittelbare Umgebung der Deklaration beschränkt ist.'},
     {'question': 'Ist es möglich, die Einhaltung des Gesetzes Demeters automatisch zu überprüfen? Warum oder warum nicht?', 'answer': 'Die automatische Überprüfung des Gesetzes Demeters gestaltet sich schwierig, da das Gesetz in Bezug auf Objekte formuliert ist und die Auswertung von konkreten Zuweisungen und dynamischen Programmfluss erfordern würde, was mechanisch extrem aufwendig oder sogar unmöglich ist. Stattdessen überprüfen automatische Checker des Gesetzes Demeters in der Regel die Variablendeklarationen und ob alle Methodenaufrufe einer Klasse nur auf Ausdrücken erfolgen, die den Typ einer Instanzvariable oder eines formalen Parameters haben.'},
     {'question': 'Warum ist die automatische Überprüfung des Gesetzes Demeters in SMALLTALK nicht möglich?', 'answer': 'In SMALLTALK ist die automatische Überprüfung des Gesetzes Demeters nicht möglich, da Ausdrücke in SMALLTALK nicht typisiert sind. Daher können Checker nicht feststellen, ob die Art und Weise, wie auf Objekte zugegriffen wird, dem Gesetz Demeters entspricht.'},
     {'question': 'Was besagt das Gesetz Demeters in Bezug auf die Nachrichtenübermittlung in der objektorientierten Programmierung?', 'answer': 'Das Gesetz Demeters besagt, dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, indem es auf eine Variable direkt zugreift, die das andere Objekt benennt. Die Dauer des Kennens kann variieren, wobei Instanzvariablen eine dauerhafte Bindung darstellen, während formale Parameter einer Methode temporär bekannt sind.'},
     {'question': 'Warum muss man bei der Verwendung von Collections als Zwischenobjekte immer eine Ausnahme von Demeters Gesetz machen?', 'answer': 'Bei der Verwendung von Collections als Zwischenobjekte muss man eine Ausnahme von Demeters Gesetz machen, weil die Verwendung von Iteratoren und Methoden wie "detect:" eine Verkettung von Nachrichten erzeugt, die in direktem Widerspruch zum Gesetz Demeters steht. Dies liegt daran, dass die Klausel "detect:" auf einer Kollektion nicht dem Prinzip des Gesetzes Demeters entspricht, bei dem Nachrichten nur an Objekte gesendet werden dürfen, die der Sender selbst kennt oder erzeugt.'},
     {'question': 'Warum ist das Gesetz Demeters umstritten und nicht allgemein anerkannt?', 'answer': 'Das Gesetz Demeters ist umstritten und nicht allgemein anerkannt, weil es in einigen Fällen schwer umsetzbar sein kann und zu unpraktischem Code führen kann. Es erfordert, dass Verkettungen von Nachrichten vermieden werden, was in einigen Fällen zu einer unnötigen Fragmentierung des Codes führen kann. Einige Entwickler sehen das Gesetz Demeters als zu restriktiv an und argumentieren, dass es in bestimmten Situationen vernünftiger ist, Verkettungen von Nachrichten zu verwenden, um den Code lesbarer und effizienter zu gestalten. Dennoch ist es wichtig, das Gesetz Demeters zu verstehen und in Betracht zu ziehen, da es in vielen Fällen dazu beitragen kann, die Kopplung zwischen Klassen zu verringern und den Code wartbarer zu machen.'},
     {'question': 'Warum können in Java abgeleitete Typen keine Eigenschaften unterdrücken?', 'answer': 'In Java können abgeleitete Typen keine Eigenschaften unterdrücken, weil es in Java nicht möglich ist, die öffentlich zugängliche Schnittstelle eines abgeleiteten Typs von der des Basistyps zu unterscheiden. Wenn ein Objekt vom Typ Stack in einem Programmabschnitt erwartet wird, in dem ein Objekt vom Typ Vector auftauchen kann, kann das Programm nicht fortgesetzt werden, wenn es auf ein Element zugreifen will, wenn stattdessen ein Stack vorliegt. Eine solche Prüfung muss zur Laufzeit erfolgen, und wenn sie vergessen wird, kann dies zu einem schwerwiegenden Programmierfehler führen. Solche Fehler lassen sich einfach vermeiden, indem man abgeleiteten Typen verbietet, Eigenschaften zu unterdrücken.'},
     {'question': 'Was ist der Unterschied zwischen Set und Bag?', 'answer': 'Set und Bag sind zwei verschiedene Datentypen. Set ist eine Menge, die nur einmal jedes Element enthalten kann, während Bag eine Multimenge ist, die mehrere Vorkommen desselben Elements enthalten kann.'},
     {'question': 'Was passiert, wenn man Set als Subtyp von Bag annimmt?', 'answer': 'Wenn man Set als Subtyp von Bag annimmt, könnte man dies als eine Art Typeinschränkung verstehen, bei der die Anzahl der Vorkommen jedes einzelnen Elements auf die Werte 0 und 1 (den Wertebereich {0, 1}) beschränkt ist.'},
     {'question': 'Warum können keine korrekten Aussagen wie "Für alle Objekte vom Typ X gilt..." gebildet werden, wobei die Objekte vom Typ X immer auch die vom jeweils anderen Typen Y einschließen sollen, der als Subtyp von X betrachtet wird?', 'answer': 'Die charakteristischen Eigenschaften der beiden Typen Bag und Set stehen im Widerspruch zueinander, daher lassen sich keine korrekten Aussagen bilden, die die Eigenschaften beider Typen implizieren.'},
     {'question': 'Was ist der Unterschied zwischen Typkonformität und Substituierbarkeit?', 'answer': 'Typkonformität bedeutet, dass ein Objekt dem erwarteten Typ entspricht, während Substituierbarkeit bedeutet, dass ein Objekt anstelle eines anderen Objekts verwendet werden kann, ohne dass sich das Verhalten des Programms ändert. Typkonformität ist eine notwendige, aber nicht hinreichende Bedingung für Substituierbarkeit.'},
     {'question': 'Was bedeutet Typkonformität nicht automatisch auch Substituierbarkeit?', 'answer': 'Typkonformität bedeutet nicht automatisch auch Substituierbarkeit, weil auch bei Typkonformität das Verhalten der Objekte verglichen werden muss, um sicherzustellen, dass die Substituierbarkeit gegeben ist.'},
     {'question': 'Was besagt das Gesetz Demeters?', 'answer': 'Das Gesetz Demeters besagt, dass Nachrichten nur an Objekte versendet werden dürfen, die der Sender selbst kennt oder erzeugt. Dabei ist "kennen" im Sinne von Kurseinheit 1 zu verstehen: Ein Objekt kennt ein anderes, wenn es in direkter Beziehung dazu steht, wenn es also auf eine Variable direkt (also ohne den Umweg über ein anderes Objekt) zugreift, die das andere Objekt benennt.'},
     {'question': 'Was verstößt gegen das Gesetz Demeters?', 'answer': 'Das Gesetz Demeters wird verletzt, wenn Nachrichten an Objekte gesendet werden, die selbst nur als Ergebnis eines Nachrichtenausdrucks vorliegen, wie zum Beispiel bei Kettenaufrufen oder über eine zwischenzeitliche Zuweisung zu einer temporären Variablen.'},
     {'question': 'Was bedeutet das Gesetz Demeters in Bezug SMALLTALK?', 'answer': 'Das Gesetz Demeters ist ein Prinzip der objektorientierten Programmierung, das besagt, dass ein Objekt nur mit seinen direkten Nachbarn kommunizieren sollte, anstatt sich in die inneren Angelegenheiten anderer Objekte einzumischen. In SMALLTALK bedeutet "Sprich nicht mit Fremden", dass Methodenaufrufe zwar geschachtelt, aber nicht verkettet erfolgen dürfen. Das heißt, ein Objekt darf eine Methode auf einem anderen Objekt aufrufen, aber es sollte nicht erwarten, dass dieses Objekt eine Methode auf einem dritten Objekt aufruft.'},
     {'question': 'Was führt das Demeters Gesetz ein?', 'answer': 'Demeters Gesetz ist führt eine neue, kontextabhängige Zugriffbarkeitsregel ein, die besagt, dass ein Objekt nicht direkt auf Eigenschaften von Objekten zugreifen soll, die es nicht selbst kennt. Stattdessen soll es Nachrichten an andere Objekte senden, um die gewünschten Informationen zu erhalten.'},
     {'question': 'Warum ist es wichtig, die Bedingungen zu kennen, unter denen Methoden in ein bestehendes Programm integriert werden können?', 'answer': 'Es ist wichtig, die Bedingungen zu kennen, unter denen Methoden in ein bestehendes Programm integriert werden können, um sicherzustellen, dass das Programm ordnungsgemäß funktioniert und kein unerwartetes Verhalten hervorruft. Nur wenn diese Zusicherungen in Form von (54.1) für alle Aufrufe erfüllt sind, ist das Funktionieren des Programms nicht gefährdet.'},
     {'question': 'Warum sind Probleme mit hohem algorithmischen Anteil und einfachen Datenstrukturen weniger geeignet für die objektorientierte Programmierung?', 'answer': 'Probleme mit hohem algorithmischen Anteil und einfachen Datenstrukturen sind weniger geeignet für die objektorientierte Programmierung, da sie eine Zerfledderung des Codes durch die Datenbindung verursachen. Die Funktionalität wird in der objektorientierten Programmierung auf die Klassen aufgeteilt, die die Daten definieren, auf denen der Code arbeitet.'},
     {'question': 'Warum ist die objektorientierte Programmierung nicht ideal, wenn das Interesse an der Struktur der Funktionen über dem an der Struktur der Daten liegt?', 'answer': 'In der objektorientierten Programmierung liegt der Fokus auf der Struktur der Daten, indem Objekte mit ihren Daten und Methoden im Vordergrund stehen. Wenn das Interesse jedoch hauptsächlich an der Struktur der Funktionen liegt, kann die objektorientierte Programmierung ineffizient sein, da die Funktionen auf zahlreiche Klassen aufgeteilt werden müssen. In solchen Fällen ist es besser, die Abläufe in einem Stück festzuhalten, um die Lesbarkeit und Wartbarkeit des Codes zu verbessern.'},
     {'question': 'Warum eignen sich Sprachen, die mehrere Programmierparadigmen erlauben, weniger für die Didaktik?', 'answer': 'Sprachen, die mehrere Programmierparadigmen erlauben, sind für Anfängerinnen oft überfordernd, da sie eine große Auswahl an Konstrukten und eine unüberschaubare Anzahl von Alternativen bieten, um ein einzelnes Problem zu lösen.'},
     {'question': 'Was sind die Nachteile der objektorientierten Programmierung?', 'answer': 'Die Nachteile der objektorientierten Programmierung sind, dass die Organisation der Funktionen auf der Strecke bleibt und dass die Daten hin- und hergeschickt werden müssen.'},
     {'question': 'Was sind die Nachteile der prozeduralen Programmierung?', 'answer': 'Die Nachteile der prozeduralen Programmierung sind, dass die Daten auf kaum nachvollziehbare Weise hin- und hergeschickt werden oder global sind.'},
     {'question': 'Was sind die Vorteile von Sprachen, die eine Mischung mehrerer Programmierparadigmen erlauben?', 'answer': 'Die Vorteile von Sprachen, die eine Mischung mehrerer Programmierparadigmen erlauben, sind, dass sie eine größere Auswahl an Konstrukten bieten und eine unüberschaubare Anzahl von Alternativen, wie man ein einzelnes Problem lösen kann.'},
     {'question': 'Warum kann es sinnvoll sein, eine relationale Datenbank für die Simulation einer Objektorientiertierung zu verwenden?', 'answer': 'Es kann sinnvoll sein, eine relationale Datenbank für die Simulation einer objektorientierten zu verwenden, wenn bereits relationale Datenbanken im betrieblichen Umfeld erfolgreich eingesetzt werden und die Umstellung auf Objektorientierung in der Datenhaltung mit Risiken verbunden scheint. Die Daten sind häufig der eigentliche Wert eines Softwaresystems. Die Abbildung der objektorientierten Klassenstruktur auf das relationale Schema wird durch ein Persistenzlayer erreicht, das Programm muss sich um die Datenhaltung nur auf sehr abstrakter Ebene kümmern.'},
     {'question': 'Warum ist die objektorientierte Programmierung nicht gut für GUI-Programmierung geeignet?', 'answer': 'Objektorientierte Programmierung ist nicht gut für GUI-Programmierung geeignet, weil sich die Instanzen einer Klasse alle Methoden teilen, was es nicht möglich macht, für verschiedene Objekte derselben Klasse verschiedene Implementierungen einer Methode anzugeben. Um dies zu erreichen, muss eine Indirektion eingebaut werden, wie zum Beispiel in Smalltalk über einen Block, in Java über anonyme innere Klassen, in C++ und C-Sharp über Funktionszeiger (Delegates in C-Sharp). Die prototypenbasierte Variante der objektorientierten Programmierung, wie sie in JavaScript verwendet wird, scheint hier besser geeignet zu sein.'},
     {'question': 'Warum ist es nicht möglich, für verschiedene Instanzen einer Klasse verschiedene Implementierungen einer Methode anzugeben?', 'answer': 'Da sich die Instanzen einer Klasse alle Methoden teilen, ist es nicht möglich, für verschiedene Instanzen derselben Klasse verschiedene Implementierungen einer Methode anzugeben.'},
     {'question': 'Warum können in objektorientierter Programmierung nicht für verschiedene Instanzen einer Klasse verschiedene Implementierungen einer Methode angegeben werden?', 'answer': 'In objektorientierter Programmierung können für verschiedene Instanzen einer Klasse nicht verschiedene Implementierungen einer Methode angegeben werden, weil alle Instanzen einer Klasse dieselben Methoden teilen. Um dieses Problem zu lösen, können Indirektionen eingebaut werden, wie zum Beispiel in Smalltalk über einen Block, in Java über anonyme innere Klassen, in C++ und C-Sharp über Funktionszeiger (Delegates in C-Sharp). Eine bessere Eignung scheint hier die prototypenbasierte Variante der objektorientierten Programmierung zu haben, wie sie in JavaScript seit Jahren erfolgreich eingesetzt wird.'},
     {'question': 'Was ist der Unterschied zwischen Verhalten des Programms und seiner Spezifikation?', 'answer': 'Die Spezifikation eines Programms beschreibt, was das Programm tun soll, während das Verhalten des Programms beschreibt, was das Programm tatsächlich tut. Die Spezifikation ist eine Art Blaupause oder Anleitung für das Programm, während das Verhalten das Ergebnis der Ausführung des Programms ist.'},
     {'question': 'Was definiert die Subtypenbeziehung zwischen S und T?', 'answer': 'Die Subtypenbeziehung zwischen S und T wird durch das Subtype Requirement definiert, das durch die folgenden Regeln beschrieben wird: a. Kontravarianz der Argumenttypen der überschreibenden Methode. b. Kovarianz des Ergebnistyps der überschreibenden Methode. c. Kovarianz der ausgelösten Ausnahmen der überschreibenden Methode. d. Vorbedingungen der überschriebenen Methode implizieren Vorbedingungen der überschreibenden Methode. e. Nachbedingungen der überschriebenen Methode werden von Nachbedingungen der überschreibenden Methode impliziert. Die Invarianten von S implizieren die Invarianten von T.'},
     {'question': 'Was besagt die Kontravarianz der Argumenttypen der überschreibenden Methode?', 'answer': 'Die Kontravarianz der Argumenttypen der überschreibenden Methode besagt, dass der Typ des Arguments der überschreibenden Methode ein Subtyp des Arguments der überschriebenen Methode sein muss.'},
     {'question': 'Was bedeutet Substituierbarkeit in diesem Kontext?', 'answer': 'In diesem Kontext bedeutet Substituierbarkeit, dass ein Objekt eines Untertyps an jeder Stelle, an der ein Objekt des Obertyps erwartet wird, verwendet werden kann, ohne dass die Korrektheit des Programms beeinträchtigt wird.'},
     {'question': 'Was bedeutet die Wirksamkeit der Bedingungen in diesem Kontext?', 'answer': 'Die Wirksamkeit der Bedingungen bedeutet, dass die Subtypenregeln und die Korrektheit der überschreibenden Methode in S die gewünschte Substituierbarkeit gewährleisten.'},
     {'question': 'Was bedeuten die Subtypenregeln und die Korrektheit der überschreibenden Methode in S für die Substituierbarkeit?', 'answer': 'Die Subtypenregeln und die Korrektheit der überschreibenden Methode in S bedeuten, dass die Unterklasse S die Bedingungen erfüllt, um eine Substitutionsinstanz der Oberklasse zu sein. Das heißt, dass ein Objekt der Unterklasse S an jeder Stelle, an der ein Objekt der Oberklasse erwartet wird, verwendet werden kann, ohne dass die Korrektheit des Programms beeinträchtigt wird.'},
     {'question': 'Was bedeutet es, wenn das Verhalten eines Subtyps mit dem des Supertyps kompatibel ist?', 'answer': 'Das Verhalten eines Subtyps ist mit dem des Supertyps kompatibel, wenn sämtliches zusätzliches Verhalten des Subtyps durch das Verhalten des Supertyps simuliert werden kann. Das bedeutet, dass für jede zusätzliche Methode des Subtyps eine Kombination von Methodenaufrufen des Supertyps existiert, die denselben Effekt wie die zusätzliche Methode hat und vom Klienten des Objekts selbst oder von einem anderen Klienten, der jedoch das Objekt als denselben Typ sieht, durchgeführt werden kann.'},
     {'question': 'Was ist der Nachteil des Liskov-Substitutionsprinzips?', 'answer': 'Der Nachteil des Liskov-Substitutionsprinzips ist, dass es in der Praxis als zu restriktiv erweist und eine Typüberprüfung darstellt, die gültige Programme ablehnt. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.'},
     {'question': 'Warum erweist sich das Liskov-Substitutionsprinzip in der Praxis als zu restriktiv?', 'answer': 'Das Liskov-Substitutionsprinzip erweist sich in der Praxis als zu restriktiv, weil es eine Typüberprüfung darstellt, die gültige Programme ablehnt. Zum Beispiel, wenn eine Methode in einem Subtyp kontravariant im Eingabeparameter und nicht kovariant im Ausgabeparameter ist, erfüllt sie nicht die Bedingungen des LSP, aber sie kann trotzdem an jeder Stelle, an der die Methode im Basistyp erwartet wird, ohne Probleme verwendet werden. Die Tatsache, dass die Einhaltung des LSP im Allgemeinen nicht automatisch überprüft werden kann, ist ein recht hoher Preis für die strenge Anforderung.'},
     {'question': 'Warum ist es wichtig, verschiedene Vererbungshierarchien in einem Programm getrennt voneinander zu pflegen?', 'answer': 'Es ist wichtig, verschiedene Vererbungshierarchien in einem Programm getrennt voneinander zu pflegen, um Inkonsistenzen im Code und ungewollte Interferenzen zu vermeiden.'},
     {'question': 'Warum ist es wichtig, verschiedene Darstellungen eines Programms getrennt voneinander zu pflegen?', 'answer': 'Es ist wichtig, verschiedene Darstellungen eines Programms getrennt voneinander zu pflegen, um Inkonsistenzen im Code und ungewollte Interferenzen zu vermeiden.'},
     {'question': 'Warum wird die Trennung der Belange in der objektorientierten Programmierung nur unzureichend unterstützt?', 'answer': 'Die Trennung der Belange wird in der objektorientierten Programmierung nur unzureichend unterstützt, weil die Ansätze wie das Subject- oder Aspect-oriented Programming zwar hoch gehandelt wurden, aber noch nicht im Mainstream angekommen sind. Die Gründe dafür sind vielfältig, aber letztlich ist es illusorisch, die essentielle Komplexität, die einem Problem innewohnt, durch programmiersprachliche Mittel beseitigen zu wollen. Die getrennte Spezifikation eines Systems aus verschiedenen Sichten verlagert die Komplexität nur in das Zusammenführen der Sichten. Unsere heutigen Softwaresysteme sind die kompliziertesten technischen Artefakte, die die Menschheit jemals hervorgebracht hat, und wer hier Einfachheit verspricht, sollte sich schämen.'},
     {'question': 'Was sind die Nachteile der Vererbung in objektorientierter Programmierung?', 'answer': 'Die Vererbung in objektorientierter Programmierung kann die Kapselung von Klassen auf unangenehme Weise aufbrechen und starke Abhängigkeiten zwischen Klassen und ihren Subklassen erzeugen. Diese Abhängigkeiten explizit zu machen, kann zwar vor Programmierfehlern schützen, aber sie nicht beseitigen. Die Abhängigkeiten zu beschränken, bedeutet, einen Teil der Ausdrucksstärke und Flexibilität der objektorientierten Programmierung aufzugeben.'},
     {'question': 'Was ist der Unterschied zwischen Verweisvariablen und Wertvariablen?', 'answer': 'Verweisvariablen enthalten einen Verweis auf ein Objekt, während Wertvariablen den Wert des Objekts enthalten.'},
     {'question': 'Was ist der Unterschied zwischen einem Alias und einem Wert?', 'answer': 'Ein Alias ist eine Referenz auf ein Objekt, während ein Wert eine eigene Kopie des Objekts ist. Wenn man einen Alias ändert, dann ändert man das Originalobjekt, während man bei einem Wert nur die Kopie ändert. Im Beispiel von "jetzt" und "Time now" sind beide Alias auf das gleiche Zeitobjekt, und wenn man das Zeitobjekt ändert, dann ändert sich auch die Erzeugungszeit von "a".'},
     {'question': 'Was sind die Nachteile, wenn Aliase in Programmiersprachen verboten werden?', 'answer': 'Wenn Aliase in Programmiersprachen verboten werden, schränkt man sich selbst nur wieder zahlreicher Möglichkeiten ein. Ein Beispiel dafür ist die Verwendung von Klassen als Werttypen in Programmiersprachen wie C-Sharp, C++ und EIFFEL, bei der bei Zuweisungen nicht automatisch Aliase entstehen.'},
     {'question': 'Warum können Aliase ein Problem sein?', 'answer': 'Aliase sind Variablen, die auf das gleiche Objekt verweisen. Sie können schlecht sein, weil sie zu unerwarteten Nebenwirkungen führen können, wenn man nicht vorsichtig ist. Wenn man beispielsweise den Zustand eines Objekts über eine Variable ändert, kann dies auch den Zustand über eine andere Variable beeinflussen, die auf dasselbe Objekt verweist. Dies kann zu Verwirrung und Fehlern führen. Einige Programmiersprachen bieten die Möglichkeit, Klassen als Werttypen zu definieren, um das Entstehen von Aliase zu vermeiden.'},
     {'question': 'Was ist der Unterschied zwischen einer Kopie und einem Zeiger in Bezug auf Objekte?', 'answer': 'In Bezug auf Objekte ist eine Kopie eine unabhängige Instanz des Objekts, während ein Zeiger auf das originale Objekt verweist. In Sprachen ohne Referenzsemantik ist es nicht möglich, Zeiger zu verwenden, während Sprachen mit Referenzsemantik dies ermöglichen.'},
     {'question': 'Warum können Aliase ein Problem bei sicherheitskritischen Anwendungen darstellen?', 'answer': 'Aliase können ein Problem bei sicherheitskritischen Anwendungen darstellen, da sie mit der Spezifikation nicht vereinbar wären. Wenn es Aliase von außen auf geheime Daten- oder Funktionsträger gibt, ist die Spezifikation nicht erfüllt.'},
     {'question': 'Was ist der Unterschied zwischen Namensschutz und Geheimnisprinzip?', 'answer': 'Namensschutz (name protection) verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, indem es ihre Namen verbirgt. Das Geheimnisprinzip (information hiding) hingegen verhindert, dass andere Klassen von der Implementierung eines Objekts abhängen, indem es die Möglichkeit schafft, die Implementierung ohne Auswirkungen auf andere Klassen zu ändern.'},
     {'question': 'Was wird durch den Namensschutz verhindert?', 'answer': 'Der Namensschutz verhindert, dass andere Klassen von der Existenz bestimmter Instanzvariablen abhängen, sodass diese problemlos geändert werden können.'},
     {'question': 'Was besagt das Geheimnisprinzip?', 'answer': 'Das Geheimnisprinzip besagt, dass die Repräsentationsobjekte, deren Namen verborgen werden, noch andere Namen besitzen können, z.B. wenn ein Objekt seine Repräsentationsobjekte bei seiner Erzeugung von außen geliefert bekommt. Eine weitere Möglichkeit, die Kapselung zu durchbrechen, ist, selbst eine Referenz auf ein Repräsentationsobjekt herauszugeben, beispielsweise durch einen Getter.'},
     {'question': 'Warum verhindert die Verwendung von Wertobjekten in C-Sharp, dass die Objekte referenziert werden können?', 'answer': 'In C-Sharp können, wenn die „Klasse“ der Teil-Objekte per "struct" definiert wurde, keine Zeiger auf Wertobjekte erstellt werden, was bedeutet, dass die Objekte nicht von anderen Objekten referenziert werden können.'}],
]
